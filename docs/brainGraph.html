<!DOCTYPE html><html lang="en"><head><title>Help for package brainGraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {brainGraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brainGraph'><p>Default options for brainGraph</p></a></li>
<li><a href='#apply_thresholds'><p>Threshold additional set of matrices</p></a></li>
<li><a href='#Atlas+20Helpers'><p>Atlas helper functions</p></a></li>
<li><a href='#Attributes'><p>Set graph, vertex, and edge attributes common in MRI analyses</p></a></li>
<li><a href='#auc_diff'><p>Difference in the area-under-the-curve of two vectors</p></a></li>
<li><a href='#Bootstrapping'><p>Bootstrapping for global graph measures</p></a></li>
<li><a href='#Brain+20Atlases'><p>Coordinates for data from brain atlases</p></a></li>
<li><a href='#brainGraph_permute'><p>Permutation test for group difference of graph measures</p></a></li>
<li><a href='#brainGraph-methods'><p>brainGraph generic methods</p></a></li>
<li><a href='#brainGraphList'><p>Create a list of brainGraph graphs</p></a></li>
<li><a href='#centr_betw_comm'><p>Calculate communicability betweenness centrality</p></a></li>
<li><a href='#centr_lev'><p>Calculate a vertex's leverage centrality</p></a></li>
<li><a href='#check_sID'><p>Test if an object is a character vector of numbers</p></a></li>
<li><a href='#check_weights'><p>Check for vertex or edge attributes</p></a></li>
<li><a href='#choose.edges'><p>Select edges for re-wiring</p></a></li>
<li><a href='#coeff_var'><p>Calculate coefficient of variation</p></a></li>
<li><a href='#communicability'><p>Calculate communicability</p></a></li>
<li><a href='#contract_brainGraph'><p>Contract graph vertices based on brain lobe and hemisphere</p></a></li>
<li><a href='#cor.diff.test'><p>Calculate the p-value for differences in correlation coefficients</p></a></li>
<li><a href='#corr.matrix'><p>Calculate correlation matrix and threshold</p></a></li>
<li><a href='#Count+20Edges'><p>Count number of edges of a brain graph</p></a></li>
<li><a href='#create_mats'><p>Create connection matrices for tractography or fMRI data</p></a></li>
<li><a href='#Creating_Graphs'><p>Create a brainGraph object</p></a></li>
<li><a href='#Creating_Graphs_GLM'><p>Create a graph list with GLM-specific attributes</p></a></li>
<li><a href='#delete_all_attr'><p>Delete all attributes of a graph</p></a></li>
<li><a href='#dir2files'><p>Return a vector of filenames based on a directory name or options list</p></a></li>
<li><a href='#edge_asymmetry'><p>Calculate an asymmetry index based on edge counts</p></a></li>
<li><a href='#efficiency'><p>Calculate graph global, local, or nodal efficiency</p></a></li>
<li><a href='#get_rand_attrs'><p>Convenience function to get attributes for lists of random graphs</p></a></li>
<li><a href='#GLM'><p>Fit General Linear Models at each vertex of a graph</p></a></li>
<li><a href='#GLM+20basic+20info'><p>Extract basic information from a bg_GLM object</p></a></li>
<li><a href='#GLM+20design'><p>Create a design matrix for linear model analysis</p></a></li>
<li><a href='#GLM+20fits'><p>Fit design matrices to one or multiple outcomes</p></a></li>
<li><a href='#GLM+20helpers'><p>Helper functions to set-up for GLM analyses</p></a></li>
<li><a href='#GLM+20influence+20measures'><p>Influence measures for a bg_GLM object</p></a></li>
<li><a href='#GLM+20model+20selection'><p>Model selection for bg_GLM objects</p></a></li>
<li><a href='#GLM+20statistics'><p>Extract model fit statistics from a bg_GLM object</p></a></li>
<li><a href='#Graph+20Data+20Tables'><p>Create a data table with graph global and vertex measures</p></a></li>
<li><a href='#Graph+20Distances'><p>Calculate Euclidean distance of edges and vertices</p></a></li>
<li><a href='#hubness'><p>Calculate vertex hubness</p></a></li>
<li><a href='#import_scn'><p>Import data for structural connectivity analysis</p></a></li>
<li><a href='#IndividualContributions'><p>Approaches to estimate individual network contribution</p></a></li>
<li><a href='#Inverse'><p>Calculate the inverse of the cross product of a design matrix</p></a></li>
<li><a href='#make_auc_brainGraph'><p>Calculate the AUC across densities of given attributes</p></a></li>
<li><a href='#make_ego_brainGraph'><p>Create a graph of the union of multiple vertex neighborhoods</p></a></li>
<li><a href='#make_intersection_brainGraph'><p>Create the intersection of graphs based on a logical condition</p></a></li>
<li><a href='#Matrix+20utilities'><p>Matrix/array utility functions</p></a></li>
<li><a href='#mean_distance_wt'><p>Calculate weighted shortest path lengths</p></a></li>
<li><a href='#Mediation'><p>Mediation analysis with brain graph measures as mediator variables</p></a></li>
<li><a href='#mtpc'><p>Multi-threshold permutation correction</p></a></li>
<li><a href='#NBS'><p>Network-based statistic for brain MRI data</p></a></li>
<li><a href='#plot_brainGraph_multi'><p>Save PNG of one or three views for all graphs in a brainGraphList</p></a></li>
<li><a href='#plot_global'><p>Plot global graph measures across densities</p></a></li>
<li><a href='#plot_rich_norm'><p>Plot normalized rich club coefficients against degree threshold</p></a></li>
<li><a href='#plot_vertex_measures'><p>Plot vertex-level graph measures at a single density or threshold</p></a></li>
<li><a href='#plot_volumetric'><p>Plot group distributions of volumetric measures for a given brain region</p></a></li>
<li><a href='#plot.brainGraph'><p>Plot a brain graph with a specific spatial layout</p></a></li>
<li><a href='#plot.brainGraphList'><p>Plot a brainGraphList and write to PDF</p></a></li>
<li><a href='#Plotting+20GLM+20graphs'><p>Plot a graph with results from GLM-based analyses</p></a></li>
<li><a href='#Random+20Graphs'><p>Perform an analysis with random graphs for brain MRI data</p></a></li>
<li><a href='#randomise'><p>GLM non-parametric permutation testing</p></a></li>
<li><a href='#rename_levels'><p>Rename the levels of global metrics in a data.table</p></a></li>
<li><a href='#Residuals'><p>Linear model residuals in structural covariance networks</p></a></li>
<li><a href='#Rich+20Club'><p>Rich club calculations</p></a></li>
<li><a href='#rich_club_attrs'><p>Assign graph attributes based on rich-club analysis</p></a></li>
<li><a href='#robustness'><p>Analysis of network robustness</p></a></li>
<li><a href='#s_core'><p>Calculate the s-core of a network</p></a></li>
<li><a href='#set_graph_colors'><p>Color graph vertices and edges</p></a></li>
<li><a href='#small.world'><p>Calculate graph small-worldness</p></a></li>
<li><a href='#subset_graph'><p>Subset graphs based on a given logical condition</p></a></li>
<li><a href='#update_fs_names'><p>Update column names in a Freesurfer table</p></a></li>
<li><a href='#Utility+20functions'><p>Utility functions</p></a></li>
<li><a href='#Vertex+20Roles'><p>Gateway coefficient, participation coefficient, and within-mod degree z-score</p></a></li>
<li><a href='#vif.bg_GLM'><p>Variance inflation factors for <code>bg_GLM</code> objects</p></a></li>
<li><a href='#vulnerability'><p>Calculate graph vulnerability</p></a></li>
<li><a href='#write_brainnet'><p>Write files to be used for visualization with BrainNet Viewer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Graph Theory Analysis of Brain MRI Data</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for performing graph theory analysis of brain MRI
    data. It works with data from a Freesurfer analysis (cortical thickness,
    volumes, local gyrification index, surface area), diffusion tensor
    tractography data (e.g., from FSL) and resting-state fMRI data (e.g., from
    DPABI). It contains a graphical user interface for graph visualization and
    data exploration, along with several functions for generating useful
    figures.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cwatson/brainGraph">https://github.com/cwatson/brainGraph</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://groups.google.com/forum/?hl=en#!forum/brainGraph-help">https://groups.google.com/forum/?hl=en#!forum/brainGraph-help</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), igraph (&ge; 1.2.4),</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, data.table (&ge; 1.12.4), doParallel, foreach, grid,
lattice, MASS, Matrix, methods, permute, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Hmisc, ade4, boot, car, expm, ggplot2, ggrepel, gridExtra,
mediation, oro.nifti, scales</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'glm_stats.R' 'brainGraph_GLM.R' 'glm_methods.R' 'NBS.R'
'analysis_random_graphs.R' 'atlas.R' 'auc.R' 'boot_global.R'
'brainGraph_mediate.R' 'centr_lev.R' 'communicability.R'
'contract_brainGraph.R' 'corr_matrix.R' 'count_edges.R'
'create_graphs.R' 'create_mats.R' 'data.R' 'data_tables.R'
'distances.R' 'edge_asymmetry.R' 'get_resid.R' 'glm_design.R'
'glm_fit.R' 'glm_randomise.R' 'graph_efficiency.R' 'hubs.R'
'import.R' 'individ_contrib.R' 'list.R' 'method_helpers.R'
'mtpc.R' 'methods.R' 'permute_group.R' 'plot_brainGraph.R'
'plot_brainGraph_multi.R' 'plot_global.R' 'plot_group_means.R'
'plot_rich_norm.R' 'plot_vertex_measures.R' 'random_graphs.R'
'rich_club.R' 'robustness.R' 's_core.R'
'set_brainGraph_attributes.R' 'small_world.R' 'spatial_dist.R'
'utils.R' 'utils_matrix.R' 'vertex_roles.R' 'vulnerability.R'
'write_brainnet.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 03:25:22 UTC; cwatson</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher G. Watson
    <a href="https://orcid.org/0000-0002-7082-7631"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher G. Watson &lt;cgwatson@bu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-04 05:03:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='brainGraph'>Default options for brainGraph</h2><span id='topic+brainGraph'></span><span id='topic+brainGraph-options'></span><span id='topic+brainGraph-package'></span>

<h3>Description</h3>

<p>brainGraph is a package for performing <em>graph theory analysis</em> of brain
MRI data.
</p>


<h3>Package options</h3>

<p>brainGraph uses the following <code><a href="base.html#topic+options">options</a></code> to configure behavior:
</p>

<ul>
<li> <p><code>bg.subject_id</code>: character string specifying the name your
project/study uses as a subject identifier. All imported data (e.g.,
covariates tables) <em>MUST</em> have a column matching this. One possible
alternative is <code>'participant_id'</code>, recommended by BIDS. Default:
<code>'Study.ID'</code>
</p>
</li>
<li> <p><code>bg.group</code>: character string specifying the name your
project/study uses as a group identifier. All imported data (e.g.,
covariates tables) <em>MUST</em> have a column matching this. One possible
alternative is <code>'group'</code>, recommended by BIDS. Default:
<code>'Group'</code>
</p>
</li>
<li> <p><code>bg.session</code>: character string specifying the name your
project/study uses as a &ldquo;time&rdquo; or session identifier, in the case
of longitudinal studies. All imported data (e.g., covariates tables)
<em>MUST</em> have a column matching this. One possible alternative is
<code>'session_id'</code>, recommended by BIDS. Default: <code>'Time'</code>
</p>
</li>
<li> <p><code>bg.progress</code>: logical indicating whether to show progress bars
for functions that provide the option. Default: <code>TRUE</code>
</p>
</li>
<li> <p><code>bg.ncpus</code>: integer indicating the number of cores to use for
parallel operations. Only used if you have not already registered a
parallel backend (see Chapter 5 of the User Guide or
<a href="https://github.com/cwatson/brainGraph/blob/master/README.md">https://github.com/cwatson/brainGraph/blob/master/README.md</a> for
examples). Default: <code>2L</code>
</p>
</li></ul>


<hr>
<h2 id='apply_thresholds'>Threshold additional set of matrices</h2><span id='topic+apply_thresholds'></span>

<h3>Description</h3>

<p><code>apply_thresholds</code> thresholds an additional set of matrices (e.g.,
FA-weighted matrices for DTI tractography) based on the matrices that have
been returned from <code><a href="#topic+create_mats">create_mats</a></code>. This ensures that the same
connections are present in both sets of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_thresholds(sub.mats, group.mats, W.files, inds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_thresholds_+3A_sub.mats">sub.mats</code></td>
<td>
<p>List (length equal to number of thresholds) of numeric arrays
(3-dim) for all subjects</p>
</td></tr>
<tr><td><code id="apply_thresholds_+3A_group.mats">group.mats</code></td>
<td>
<p>List (length equal to number of thresholds) of numeric
arrays (3-dim) for group-level data</p>
</td></tr>
<tr><td><code id="apply_thresholds_+3A_w.files">W.files</code></td>
<td>
<p>Character vector of the filenames of the files with
connectivity matrices</p>
</td></tr>
<tr><td><code id="apply_thresholds_+3A_inds">inds</code></td>
<td>
<p>List (length equal to number of groups) of integers; each list
element should be a vector of length equal to the group sizes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>W.files</code> accepts the same formats as <code>A.files</code>; see
<code><a href="#topic+create_mats">create_mats</a></code> for details.
</p>


<h3>Value</h3>

<p>List containing:
</p>
<table role = "presentation">
<tr><td><code>W</code></td>
<td>
<p>A 3-d array of the raw connection matrices</p>
</td></tr>
<tr><td><code>W.norm.sub</code></td>
<td>
<p>List of 3-d arrays of the normalized connection matrices
for all given thresholds</p>
</td></tr>
<tr><td><code>W.norm.mean</code></td>
<td>
<p>List of 3-d arrays of the normalized connection matrices
averaged for each group</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  W.mats &lt;- apply_thresholds(A.norm.sub, A.norm.mean, f.W, inds)

## End(Not run)
</code></pre>

<hr>
<h2 id='Atlas+20Helpers'>Atlas helper functions</h2><span id='topic+Atlas+20Helpers'></span><span id='topic+guess_atlas'></span><span id='topic+as_atlas'></span><span id='topic+create_atlas'></span>

<h3>Description</h3>

<p><code>guess_atlas</code> tries to determine which atlas is being used based on the
data; i.e., the number of vertices/regions.
</p>
<p><code>as_atlas</code> and <code>create_atlas</code> converts/coerces an object to a
a <code>data.table</code>, or creates one, that is compatible with
<code>brainGraph</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_atlas(x)

as_atlas(object)

create_atlas(regions, coords, lobes, hemis, other = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Atlas+2B20Helpers_+3A_x">x</code>, <code id="Atlas+2B20Helpers_+3A_object">object</code></td>
<td>
<p>An object to test or convert to an atlas data.table</p>
</td></tr>
<tr><td><code id="Atlas+2B20Helpers_+3A_regions">regions</code></td>
<td>
<p>Character vector of region names</p>
</td></tr>
<tr><td><code id="Atlas+2B20Helpers_+3A_coords">coords</code></td>
<td>
<p>Numeric matrix of spatial coordinates; must have 3 columns</p>
</td></tr>
<tr><td><code id="Atlas+2B20Helpers_+3A_lobes">lobes</code></td>
<td>
<p>Character or factor vector of lobe membership</p>
</td></tr>
<tr><td><code id="Atlas+2B20Helpers_+3A_hemis">hemis</code></td>
<td>
<p>Character or factor vector of hemisphere membership. There
should probably not be more than 3 unique elements (for left, right, and
bi-hemispheric regions)</p>
</td></tr>
<tr><td><code id="Atlas+2B20Helpers_+3A_other">other</code></td>
<td>
<p>A <em>named list</em> of vectors with other data. The names of the
list will become column names in the return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>guess_atlas</code> - Character string; either the matched atlas or
<code>NA</code>
</p>
<p><code>as_atlas</code> and <code>create_atlas</code> return a <code>data.table</code>
that conforms to other atlases in the package, or exits with an error.
</p>


<h3>Guessing the atlas from an object</h3>

<p>There are several valid inputs to <code>guess_atlas</code>:
</p>

<dl>
<dt>data.table</dt><dd><p>The atlas will be guessed based on the number of columns
(subtracting by 1 if a &ldquo;Study ID&rdquo; column is present). This is the
same behavior as for <code>data.frame</code> objects, as well.</p>
</dd>
<dt>igraph</dt><dd><p>The vertex count</p>
</dd>
<dt>brainGraph</dt><dd><p>If there is a <code>atlas</code> graph-level attribute, it will
return that. Otherwise, the vertex count.</p>
</dd>
<dt>matrix,array</dt><dd><p>The number of rows, which should equal the number of
columns if the input is a connectivity matrix.</p>
</dd>
</dl>

<p>Note that this will only work properly for atlases that are currently in the
package. If you are using a custom atlas and you receive errors, please open
an issue on <em>GitHub</em>.
</p>


<h3>Coercing to an atlas</h3>

<p>There are several things <code>as_atlas</code> tries to do to make it work without
error:
</p>

<ul>
<li><p> Coerce the object to <code>data.table</code>
</p>
</li>
<li><p> Add a column of integers named <code>index</code>
</p>
</li>
<li><p> Change columns named <code>'x'</code>, <code>'y'</code>, or <code>'z'</code> to have
<code>.mni</code> at the end
</p>
</li>
<li><p> Convert the <code>lobe</code> and <code>hemi</code> columns to be <em>factors</em>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>my_atlas &lt;- data.frame(name=paste('Region', 1:10), x.mni=rnorm(10),
  y.mni=rnorm(10), z.mni=rnorm(10),
  lobe=rep(c('Frontal', 'Parietal', 'Temporal', 'Occipital', 'Limbic'), 2),
  hemi=c(rep('L', 5), rep('R', 5)))
my_atlas2 &lt;- as_atlas(my_atlas)
str(my_atlas)
str(my_atlas2)
regions &lt;- paste('Region', 1:10)
xyz &lt;- matrix(rnorm(30), nrow=10, ncol=3)
lobe &lt;- rep(c('Frontal', 'Parietal', 'Temporal', 'Occipital', 'Limbic'), 2)
hemi &lt;- c(rep('L', 5), rep('R', 5))
other &lt;- list(network=rep(c('Default mode', 'Task positive'), 5))
my_atlas &lt;- create_atlas(regions, xyz, lobe, hemi, other)
str(my_atlas)
</code></pre>

<hr>
<h2 id='Attributes'>Set graph, vertex, and edge attributes common in MRI analyses</h2><span id='topic+Attributes'></span><span id='topic+set_brainGraph_attr'></span><span id='topic+xfm.weights'></span>

<h3>Description</h3>

<p><code>set_brainGraph_attr</code> is a convenience function that sets a number of
graph, vertex, and edge attributes for a given graph object. Specifically, it
calculates measures that are common in MRI analyses of brain networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_brainGraph_attr(g, type = c("observed", "random"),
  use.parallel = TRUE, A = NULL, xfm.type = c("1/w", "-log(w)",
  "1-w", "-log10(w/max(w))", "-log10(w/max(w)+1)"),
  clust.method = "louvain")

xfm.weights(g, xfm.type = c("1/w", "-log(w)", "1-w", "-log10(w/max(w))",
  "-log10(w/max(w)+1)"), invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Attributes_+3A_g">g</code></td>
<td>
<p>A graph object</p>
</td></tr>
<tr><td><code id="Attributes_+3A_type">type</code></td>
<td>
<p>Character string indicating the type of graphs. Default:
<code>observed</code></p>
</td></tr>
<tr><td><code id="Attributes_+3A_use.parallel">use.parallel</code></td>
<td>
<p>Logical indicating whether to use <em>foreach</em>.
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="Attributes_+3A_a">A</code></td>
<td>
<p>Numeric matrix; the (weighted) adjacency matrix, which can be used
for faster calculation of local efficiency. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Attributes_+3A_xfm.type">xfm.type</code></td>
<td>
<p>Character string specifying how to transform the weights.
Default: <code>1/w</code></p>
</td></tr>
<tr><td><code id="Attributes_+3A_clust.method">clust.method</code></td>
<td>
<p>Character string indicating which method to use for
community detection. Default: <code>'louvain'</code></p>
</td></tr>
<tr><td><code id="Attributes_+3A_invert">invert</code></td>
<td>
<p>Logical indicating whether or not to invert the transformation.
Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Including <code>type='random'</code> in the function call will reduce the number of
attributes calculated. It will only add graph-level attributes for:
clustering coefficient, characteristic path length, rich club coefficient,
global efficiency, and modularity.
</p>


<h3>Value</h3>

<p>A graph object with the following attributes:
</p>
<table role = "presentation">
<tr><td><code>Graph-level</code></td>
<td>
<p>Density, connected component sizes, diameter, # of
triangles, transitivity, average path length, assortativity, global &amp;
local efficiency, modularity, vulnerability, hub score, rich-club
coefficient, # of hubs, edge asymmetry</p>
</td></tr>
<tr><td><code>Vertex-level</code></td>
<td>
<p>Degree, strength; betweenness, eigenvector, and
leverage centralities; hubs; transitivity (local); k-core, s-core; local
&amp; nodal efficiency; color (community, lobe, component); membership
(community, lobe, component); gateway and participation coefficients,
within-module degree z-score; vulnerability; and coordinates (x, y, and
z)</p>
</td></tr>
<tr><td><code>Edge-level</code></td>
<td>
<p>Color (community, lobe, component), edge betweenness,
Euclidean distance (in mm), weight (if weighted)</p>
</td></tr>
</table>
<p><code>xfm.weights</code> returns the same graph object, with transformed
edge weights plus a graph attribute (<code>xfm.type</code>) recording the method
of transformation
</p>


<h3>Negative edge weights</h3>

<p>If there are any negative edge weights in the graph, several of the
distance-based metrics will <em>not</em> be calculated, because they can throw
errors which is undesirable when processing a large dataset. The metrics are:
local and nodal efficiency, diameter, characteristic path length, and
hubness.
</p>


<h3>Transforming edge weights</h3>

<p>For distance-based measures, it is important to transform the edge weights so
that the <em>strongest</em> connections are re-mapped to having the
<em>lowest</em> weights. Then you may calculate e.g., the <em>shortest path
length</em> which will include the strongest connections.
</p>
<p><code>xfm.type</code> allows you to choose from 5 options for transforming edge
weights when calculating distance-based metrics (e.g., shortest paths). There
is no &ldquo;best-practice&rdquo; for choosing one over the other, but the reciprocal is
probably most common.
</p>

<dl>
<dt><code>1/w</code></dt><dd><p>reciprocal (default)</p>
</dd>
<dt><code>-log(w)</code></dt><dd><p>the negative (natural) logarithm</p>
</dd>
<dt><code>1-w</code></dt><dd><p>subtract weights from 1</p>
</dd>
<dt><code>-log10(w/max(w))</code></dt><dd><p>negative (base-10) log of normalized
weights</p>
</dd>
<dt><code>-log10(w/max(w)+1)</code></dt><dd><p>same as above, but add 1 before taking
the log</p>
</dd>
</dl>

<p>To transform the weights back to original values, specify <code>invert=TRUE</code>.
</p>


<h3>Community detection</h3>

<p><code>clust.method</code> allows you to choose from any of the clustering
(community detection) functions available in <code>igraph</code>. These functions
begin with <code>cluster_</code>; the function argument should not include this
leading character string. There are a few possibilities, depending on the
value and the type of input graph:
</p>

<ol>
<li><p> By default, <code>louvain</code> is used, calling
<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>
</p>
</li>
<li><p> Uses <code>spinglass</code> if there are any negative edges and/or the
selected method is <code>spinglass</code>
</p>
</li>
<li><p> Uses <code>walktrap</code> if there are any negative edge weights and any
other method (besides <code>spinglass</code>) is selected
</p>
</li>
<li><p> Automatically transforms the edge weights if <code>edge_betweenness</code>
is selected and the graph is weighted, because the algorithm considers
edges as <em>distances</em>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+components">components</a></code>, <code><a href="igraph.html#topic+diameter">diameter</a></code>,
<code><a href="igraph.html#topic+centr_betw">centr_betw</a></code>, <code><a href="igraph.html#topic+betweenness">betweenness</a></code>,
<code><a href="igraph.html#topic+centr_eigen">centr_eigen</a></code>, <code><a href="igraph.html#topic+transitivity">transitivity</a></code>,
<code><a href="igraph.html#topic+distances">distances</a></code>, <code><a href="igraph.html#topic+assortativity">assortativity</a></code>,
<code><a href="igraph.html#topic+coreness">coreness</a></code>, <code><a href="igraph.html#topic+communities">communities</a></code>,
<code><a href="igraph.html#topic+knn">knn</a></code>
</p>

<hr>
<h2 id='auc_diff'>Difference in the area-under-the-curve of two vectors</h2><span id='topic+auc_diff'></span>

<h3>Description</h3>

<p>This function takes two vectors, calculates the area-under-the-curve (AUC),
and calculates the difference between the two (if applicable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc_diff(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auc_diff_+3A_x">x</code></td>
<td>
<p>Numeric vector of the x-values</p>
</td></tr>
<tr><td><code id="auc_diff_+3A_y">y</code></td>
<td>
<p>A numeric vector or matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 4 different behaviors for this function:
</p>

<ol>
<li><p> If <code>x</code> is a single numeric value, then <code>y</code> should be a
vector of 2 values and the difference is returned. This generally should
not occur and may be removed in the future.
</p>
</li>
<li><p> If <code>y</code> has 1 column (or is a vector), then the AUC of <code>y</code>
is returned.
</p>
</li>
<li><p> If <code>y</code> has exactly 2 columns, then each column should contain
the values of interest for each subject group, and the difference in
AUC's for each group is returned.
</p>
</li>
<li><p> If <code>y</code> has multiple columns (e.g., equal to the number of
vertices of a graph), it will calculate the AUC for each column.
</p>
</li></ol>



<h3>Value</h3>

<p>A numeric value of the difference between two groups, or a numeric
vector of the AUC across vertices
</p>

<hr>
<h2 id='Bootstrapping'>Bootstrapping for global graph measures</h2><span id='topic+Bootstrapping'></span><span id='topic+brainGraph_boot'></span><span id='topic+summary.brainGraph_boot'></span><span id='topic+plot.brainGraph_boot'></span>

<h3>Description</h3>

<p>Perform bootstrapping to obtain groupwise standard error estimates of a
global graph measure.
</p>
<p>The <code>plot</code> method returns two <code>ggplot</code> objects: one with shaded
regions based on the standard error, and the other based on confidence
intervals (calculated using the normal approximation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainGraph_boot(densities, resids, R = 1000, measure = c("mod",
  "E.global", "Cp", "Lp", "assortativity", "strength", "mod.wt",
  "E.global.wt"), conf = 0.95, .progress = getOption("bg.progress"),
  xfm.type = c("1/w", "-log(w)", "1-w", "-log10(w/max(w))",
  "-log10(w/max(w)+1)"))

## S3 method for class 'brainGraph_boot'
summary(object, ...)

## S3 method for class 'brainGraph_boot'
plot(x, ..., alpha = 0.4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bootstrapping_+3A_densities">densities</code></td>
<td>
<p>Numeric vector of graph densities to loop through</p>
</td></tr>
<tr><td><code id="Bootstrapping_+3A_resids">resids</code></td>
<td>
<p>An object of class <code>brainGraph_resids</code> (the output from
<code><a href="#topic+get.resid">get.resid</a></code>)</p>
</td></tr>
<tr><td><code id="Bootstrapping_+3A_r">R</code></td>
<td>
<p>Integer; the number of bootstrap replicates. Default: <code>1e3</code></p>
</td></tr>
<tr><td><code id="Bootstrapping_+3A_measure">measure</code></td>
<td>
<p>Character string of the measure to test. Default: <code>mod</code></p>
</td></tr>
<tr><td><code id="Bootstrapping_+3A_conf">conf</code></td>
<td>
<p>Numeric; the level for calculating confidence intervals. Default:
<code>0.95</code></p>
</td></tr>
<tr><td><code id="Bootstrapping_+3A_.progress">.progress</code></td>
<td>
<p>Logical indicating whether or not to show a progress bar.
Default: <code>getOption('bg.progress')</code></p>
</td></tr>
<tr><td><code id="Bootstrapping_+3A_xfm.type">xfm.type</code></td>
<td>
<p>Character string specifying how to transform the weights.
Default: <code>1/w</code></p>
</td></tr>
<tr><td><code id="Bootstrapping_+3A_object">object</code>, <code id="Bootstrapping_+3A_x">x</code></td>
<td>
<p>A <code>brainGraph_boot</code> object</p>
</td></tr>
<tr><td><code id="Bootstrapping_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="Bootstrapping_+3A_alpha">alpha</code></td>
<td>
<p>A numeric indicating the opacity for the confidence bands</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence intervals are calculated using the <em>normal approximation</em>
at the <code class="reqn">100 \times conf</code>% level (by default, 95%).
</p>
<p>For getting estimates of <em>weighted global efficiency</em>, a method for
transforming edge weights must be provided. The default is to invert them.
See <code><a href="#topic+xfm.weights">xfm.weights</a></code>.
</p>


<h3>Value</h3>

<p><code>brainGraph_boot</code> &ndash; an object of class <code>brainGraph_boot</code>
containing some input variables, in addition to a list of
<code><a href="boot.html#topic+boot">boot</a></code> objects (one for each group).
</p>
<p><code>plot</code> &ndash; <em>list</em> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>se</code></td>
<td>
<p>A ggplot object with ribbon representing standard error</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>A ggplot object with ribbon representing confidence intervals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code>, <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>
</p>
<p>Other Group analysis functions: <code><a href="#topic+GLM">GLM</a></code>,
<code><a href="#topic+Mediation">Mediation</a></code>, <code><a href="#topic+NBS">NBS</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>, <code><a href="#topic+mtpc">mtpc</a></code>
</p>
<p>Other Structural covariance network functions: <code><a href="#topic+IndividualContributions">IndividualContributions</a></code>,
<code><a href="#topic+Residuals">Residuals</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>,
<code><a href="#topic+corr.matrix">corr.matrix</a></code>, <code><a href="#topic+import_scn">import_scn</a></code>,
<code><a href="#topic+plot_volumetric">plot_volumetric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
boot.E.global &lt;- brainGraph_boot(densities, resids.all, 1e3, 'E.global')

## End(Not run)
</code></pre>

<hr>
<h2 id='Brain+20Atlases'>Coordinates for data from brain atlases</h2><span id='topic+Brain+20Atlases'></span><span id='topic+aal116'></span><span id='topic+aal90'></span><span id='topic+aal2.120'></span><span id='topic+aal2.94'></span><span id='topic+destrieux'></span><span id='topic+destrieux.scgm'></span><span id='topic+dk'></span><span id='topic+dk.scgm'></span><span id='topic+dkt'></span><span id='topic+dkt.scgm'></span><span id='topic+brainsuite'></span><span id='topic+craddock200'></span><span id='topic+dosenbach160'></span><span id='topic+hoa112'></span><span id='topic+lpba40'></span><span id='topic+hcp_mmp1.0'></span><span id='topic+power264'></span><span id='topic+brainnetome'></span><span id='topic+gordon333'></span>

<h3>Description</h3>

<p>Datasets containing spatial coordinates for: the original AAL atlases, the
newer AAL2 atlases, Freesurfer atlases, Brainsuite, Craddock200,
Dosenbach160, Harvard-Oxford, and LONI probabilistic brain atlas. In addition
to coordinates, there are indices for the major lobes and hemispheres of the
brain, the <em>class</em> variable (for Destrieux atlases), functional networks
(for Dosenbach, Power, and Gordon atlases; plus the Yeo network labels for
the Brainnetome atlas).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aal116

aal90

aal2.120

aal2.94

destrieux

destrieux.scgm

dk

dk.scgm

dkt

dkt.scgm

brainsuite

craddock200

dosenbach160

hoa112

lpba40

hcp_mmp1.0

power264

brainnetome

gordon333
</code></pre>


<h3>Format</h3>

<p>A data frame with 90 or 116 (for the original AAL atlases), 94 or 120
(for the newer AAL2 atlases), 148 or 162 (for Destrieux), 68 or 82 (for DK),
62 or 76 (for DKT), 74 (Brainsuite), 200 (Craddock), 160 (Dosenbach), 112
(Harvard-Oxford), 40 (LONI), 246 (Brainnetome), 360 (HCP), 264 (Power), or
333 (Gordon) observations on (some of) the following 19 variables:
</p>

<dl>
<dt><code>name</code></dt><dd><p>a character vector of region names</p>
</dd>
<dt><code>x.mni</code></dt><dd><p>a numeric vector of x-coordinates (in MNI space)</p>
</dd>
<dt><code>y.mni</code></dt><dd><p>a numeric vector of y-coordinates (in MNI space)</p>
</dd>
<dt><code>z.mni</code></dt><dd><p>a numeric vector of z-coordinates (in MNI space)</p>
</dd>
<dt><code>lobe</code></dt><dd><p>a factor with some of levels <code>Frontal</code>
<code>Parietal</code> <code>Temporal</code> <code>Occipital</code> <code>Insula</code>
<code>Limbic</code> <code>Cingulate</code> <code>SCGM</code> <code>Cerebellum</code> (for
<code>aal116</code> and <code>aal2.120</code>) and <code>Brainstem</code> (for
<code>craddock200</code>)</p>
</dd>
<dt><code>hemi</code></dt><dd><p>a factor with levels <code>L</code> <code>R</code> and <code>B</code> (for
<code>dosenbach160</code>)</p>
</dd>
<dt><code>index</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>name.full</code></dt><dd><p>a character vector of full region names, for the DK
and DKT atlases</p>
</dd>
<dt><code>class</code></dt><dd><p>a factor with levels <code>G</code> <code>G_and_S</code> <code>S</code>,
for the Destrieux atlases</p>
</dd>
<dt><code>network</code></dt><dd><p>(dosenbach160) a factor with levels <code>default</code>
<code>fronto-parietal</code> <code>cingulo-opercular</code> <code>sensorimotor</code>
<code>cerebellum</code> <code>occipital</code></p>
</dd>
<dt><code>gyrus</code></dt><dd><p>(brainnetome) Abbreviated names of gyri/regions
(including subcortical), with 24 unique values</p>
</dd>
<dt><code>gyrus.full</code></dt><dd><p>(brainnetome) Full names of <code>gyrus</code></p>
</dd>
<dt><code>subregion</code></dt><dd><p>(brainnetome) Abbreviated names of subregions
(including subdivisions of subcortical gray matter)</p>
</dd>
<dt><code>subregion.full</code></dt><dd><p>(brainnetome) Full names of <code>subregion</code></p>
</dd>
<dt><code>Yeo_7network</code></dt><dd><p>(brainnetome) Factor with 8 levels consisting of
SCGM plus the 7 networks from Yeo et al.</p>
</dd>
<dt><code>Yeo_17network</code></dt><dd><p>(brainnetome) Factor with 18 levels consisting
of SCGM plus the 17 networks from Yeo et al.</p>
</dd>
<dt><code>area</code></dt><dd><p>(HCP) a factor with 23 cortical areas</p>
</dd>
<dt><code>Anatomy</code></dt><dd><p>(power264) Full region/gyrus names for the Power
atlas; contains 53 unique regions</p>
</dd>
<dt><code>Brodmann</code></dt><dd><p>(power264) Integer values for Brodmann areas</p>
</dd>
</dl>


<h3>Note</h3>

<p>Use of the HCP parcellation is subject to the terms at
<a href="https://balsa.wustl.edu/WN56">https://balsa.wustl.edu/WN56</a>. In particular: &quot;I will acknowledge the
use of WU-Minn HCP data and data derived from WU-Minn HCP data when
publicly presenting any results or algorithms that benefitted from their
use.&quot;
</p>
<p>Region names in the <code>gordon333</code> atlas were chosen to match those
of the <code>hcp_mmp1.0</code> atlas. Many were determined from the coordinates
(using FSL's <code>atlasquery</code>), while the rest were entered manually by
me. The <code>lobe</code> values were matched to the HCP atlas, as well.
</p>


<h3>Source</h3>

<p><a href="https://neuroimaging-core-docs.readthedocs.io/en/latest/pages/atlases.html">https://neuroimaging-core-docs.readthedocs.io/en/latest/pages/atlases.html</a>
</p>


<h3>References</h3>

<p>Tzourio-Mazoyer, N. and Landeau, B. and Papathanassiou, D. and
Crivello, F. and Etard, O. and Delcroix, N. and Mazoyer, B. and Joliot, M.
(2002) Automated anatomical labeling of activations in SPM using a
macroscopic anatomical parcellation of the MNI MRI single-subject brain.
<em>NeuroImage</em>, <b>15(1)</b>, 273&ndash;289.
doi: <a href="https://doi.org/10.1006/nimg.2001.0978">10.1006/nimg.2001.0978</a>
</p>
<p>Rolls, E.T. and Joliot, M. and Tzourio-Mazoyer, N. (2015)
Implementation of a new parcellation of the orbitofrontal cortex in the
automated anatomical labelling atlas. <em>NeuroImage</em>, <b>122</b>, 1&ndash;5.
doi: <a href="https://doi.org/10.1016/j.neuroimage.2015.07.075">10.1016/j.neuroimage.2015.07.075</a>
</p>
<p>Destrieux, C. and Fischl, B. and Dale, A. and Halgren E. (2010)
Automatic parcellation of human cortical gyri and sulci using standard
anatomic nomenclature. <em>NeuroImage</em>, <b>53(1)</b>, 1&ndash;15.
doi: <a href="https://doi.org/10.1016/j.neuroimage.2010.06.010">10.1016/j.neuroimage.2010.06.010</a>
</p>
<p>Desikan, R.S. and Segonne, F. and Fischl, B. et al. (2006) An
automated labeling system for subdividing the human cerebral cortex on MRI
scans into gyral based regions of interest. <em>NeuroImage</em>, <b>31</b>,
968&ndash;980. doi: <a href="https://doi.org/10.1016/j.neuroimage.2006.01.021">10.1016/j.neuroimage.2006.01.021</a>
</p>
<p>Klein, A. and Tourville, J. (2012) 101 labeled brain images
and a consistent human cortical labeling protocol. <em>Front Neurosci</em>,
6. doi: <a href="https://doi.org/10.3389/fnins.2012.00171">10.3389/fnins.2012.00171</a>
</p>
<p>Shattuck, D.W. and Leahy, R.M. (2002) BrainSuite: an automated
cortical surface identification tool. <em>Medical Image Analysis</em>,
<b>8(2)</b>, 129&ndash;142.
</p>
<p>Pantazis, D. and Joshi, A.A. and Jintao, J. and Shattuck, D.W.
and Bernstein, L.E. and Damasio, H. and Leahy, R.M. (2009) Comparison of
landmark-based and automatic methods for cortical surface registration.
<em>NeuroImage</em>, <b>49(3)</b>, 2479&ndash;2493.
</p>
<p>Craddock, R.C. and James, G.A. and Holtzheimer, P.E. and Hu, X.P.
and Mayberg, H.S. (2012) A whole brain fMRI atlas generated via spatially
constrained spectral clustering. <em>Human Brain Mapping</em>, <b>33</b>,
1914&ndash;1928. doi: <a href="https://doi.org/10.1002/hbm.21333">10.1002/hbm.21333</a>
</p>
<p>Dosenbach, N.U. and Nardos, B. and Cohen, A.L. and Fair, D.A. and
Power, J.D. and Church, J.A. and Nelson, S.M. and Wig, G.S. and Vogel, A.C.
and Lessov-Schlaggar, C.N. and Barnes, K.A. (2010) Prediction of individual
brain maturity using fMRI. <em>Science</em>, <b>329(5997)</b>, 1358&ndash;1361.
</p>
<p>Makris, N. and Goldstein, J.M. and Kennedy, D. et al. (2006)
Decreased volume of left and total anterior insular lobule in
schizophrenia. <em>Schizophr Res</em>, <b>83(2-3)</b>, 155&ndash;171.
</p>
<p>Shattuck, D.W. and Mirza, M. and Adisetiyo, V. and Hojatkashani,
C. and Salamon, G. and Narr, K.L. and Poldrack, R.A. and Bilder, R.M. and
Toga, A.W. (2008) Construction of a 3D probabilistic atlas of human
cortical structures. <em>NeuroImage</em>, <b>39(3)</b>, 1064&ndash;1080.
doi: <a href="https://doi.org/10.1016/j.neuroimage.2007.09.031">10.1016/j.neuroimage.2007.09.031</a>
</p>
<p>Glasser, M.F. and Coalson, T.S. and Robinson, E.C. and Hacker,
C.D. and Harwell, J. and Yacoub, E. and Ugurbil, K. and Andersson, J. and
Beckmann, C.F. and Jenkinson, M. and Smith, S.M. and van Essen, D.C.
(2016) A multi-modal parcellation of human cerebral cortex. <em>Nature</em>,
<b>536</b>, 171&ndash;178. doi: <a href="https://doi.org/10.1038/nature18933">10.1038/nature18933</a>. PMID:
27437579.
</p>
<p>Power, J.D. and Cohen, A.L. and Nelson, S.M. and Wig, G.S. and
Barnes, K.A. and Church, J.A. and Vogel, A.C. and Laumann, T.O. and Miezin,
F.M. and Schlaggar, B.L. and Petersen, S.E. (2011) Functional network
organization of the human brain. <em>Neuron</em>, <b>72(4)</b>, 665&ndash;678.
doi: <a href="https://doi.org/10.1016/j.neuron.2011.09.006">10.1016/j.neuron.2011.09.006</a>
</p>
<p>Fan, L. and Li, H. and Zhuo, J. and Zhang, Y. and Wang, J. and
Chen, L. and Yang, Z. and Chu, C. and Xie, S. and Laird, A.R. and Fox,
P.T. and Eickhoff, S.B. and Yu, C. and Jiang, T (2016) The Human
Brainnetome Atlas: A New Brain Atlas Based on Connectional Architecture.
<em>Cerebral Cortex</em>, <b>26(8)</b>, 3508&ndash;3526.
doi: <a href="https://doi.org/10.1093/cercor/bhw157">10.1093/cercor/bhw157</a>
</p>
<p>Gordon, E.M. and Laumann, T.O. and Adeyemo, B. and Huckins, J.F.
and Kelley, W.M. and Petersen, S.E. (2014) Generation and Evaluation of a
Cortical Area Parcellation from Resting-State Correlations. <em>Cerebral
Cortex</em>, <b>26(1)</b>, 288&ndash;303.
doi: <a href="https://doi.org/10.1093/cercor/bhu239">10.1093/cercor/bhu239</a>
</p>

<hr>
<h2 id='brainGraph_permute'>Permutation test for group difference of graph measures</h2><span id='topic+brainGraph_permute'></span><span id='topic+summary.brainGraph_permute'></span><span id='topic+plot.brainGraph_permute'></span>

<h3>Description</h3>

<p><code>brainGraph_permute</code> draws permutations from linear model residuals to
determine the significance of between-group differences of a global or
vertex-wise graph measure. It is intended for structural covariance networks
(in which there is only one graph per group), but can be extended to other
types of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainGraph_permute(densities, resids, N = 5000, perms = NULL,
  auc = FALSE, level = c("graph", "vertex", "other"),
  measure = c("btwn.cent", "coreness", "degree", "eccentricity",
  "clo.cent", "communicability", "ev.cent", "lev.cent", "pagerank",
  "subg.cent", "E.local", "E.nodal", "knn", "Lp", "transitivity",
  "vulnerability"), .function = NULL)

## S3 method for class 'brainGraph_permute'
summary(object, measure = object$measure,
  alternative = c("two.sided", "less", "greater"), alpha = 0.05,
  p.sig = c("p", "p.fdr"), ...)

## S3 method for class 'brainGraph_permute'
plot(x, measure = x$measure,
  alternative = c("two.sided", "less", "greater"), alpha = 0.05,
  p.sig = c("p", "p.fdr"), ptitle = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainGraph_permute_+3A_densities">densities</code></td>
<td>
<p>Numeric vector of graph densities</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_resids">resids</code></td>
<td>
<p>An object of class <code>brainGraph_resids</code> (the output from
<code><a href="#topic+get.resid">get.resid</a></code>)</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_n">N</code></td>
<td>
<p>Integer; the number of permutations (default: 5e3)</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_perms">perms</code></td>
<td>
<p>Numeric matrix of permutations, if you would like to provide
your own (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_auc">auc</code></td>
<td>
<p>Logical indicating whether or not to calculate differences in the
area-under-the-curve of metrics (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_level">level</code></td>
<td>
<p>A character string for the attribute &ldquo;level&rdquo; to calculate
differences (default: <code>graph</code>)</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_measure">measure</code></td>
<td>
<p>A character string specifying the vertex-level metric to
calculate, only used if <code>level='vertex'</code> (default: <code>btwn.cent</code>).
For the <code>summary</code> method, this is to focus on a single
<em>graph-level</em> measure (since multiple are calculated at once).</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_.function">.function</code></td>
<td>
<p>A custom function you can pass if <code>level='other'</code></p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_object">object</code>, <code id="brainGraph_permute_+3A_x">x</code></td>
<td>
<p>A <code>brainGraph_permute</code> object (output by
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>).</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_alternative">alternative</code></td>
<td>
<p>Character string, whether to do a two- or one-sided test.
Default: <code>'two.sided'</code></p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; the significance level. Default: 0.05</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_p.sig">p.sig</code></td>
<td>
<p>Character string specifying which p-value to use for displaying
significant results (default: <code>p</code>)</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="brainGraph_permute_+3A_ptitle">ptitle</code></td>
<td>
<p>Character string specifying a title for the plot (default:
<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you would like to calculate differences in the area-under-the-curve (AUC)
across densities, then specify <code>auc=TRUE</code>.
</p>
<p>There are three possible &ldquo;levels&rdquo;:
</p>

<ol>
<li> <p><em>graph</em> Calculate modularity (Louvain algorithm), clustering
coefficient, characteristic path length, degree assortativity, and global
efficiency.
</p>
</li>
<li> <p><em>vertex</em> Choose one of: centrality metrics (betweenness,
closeness, communicability, eigenvector, leverage, pagerank, subgraph);
k-core; degree; eccentricity; nodal or local efficiency; k-nearest neighbor
degree; shortest path length; transitivity; or vulnerability.
</p>
</li>
<li> <p><em>other</em> Supply your own function. This is useful if you want to
calculate something that I haven't hard-coded. It must take as its own
arguments: <code>g</code> (a list of lists of <code>igraph</code> graph objects); and
<code>densities</code> (numeric vector).
</p>
</li></ol>



<h3>Value</h3>

<p>An object of class <code>brainGraph_permute</code> with input arguments in
addition to:
</p>
<table role = "presentation">
<tr><td><code>DT</code></td>
<td>
<p>A data table with permutation statistics</p>
</td></tr>
<tr><td><code>obs.diff</code></td>
<td>
<p>A data table of the observed group differences</p>
</td></tr>
<tr><td><code>Group</code></td>
<td>
<p>Group names</p>
</td></tr>
</table>
<p>The <code>plot</code> method returns a <em>list</em> of <code>ggplot</code> objects
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other Group analysis functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+GLM">GLM</a></code>, <code><a href="#topic+Mediation">Mediation</a></code>,
<code><a href="#topic+NBS">NBS</a></code>, <code><a href="#topic+mtpc">mtpc</a></code>
</p>
<p>Other Structural covariance network functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+IndividualContributions">IndividualContributions</a></code>,
<code><a href="#topic+Residuals">Residuals</a></code>, <code><a href="#topic+corr.matrix">corr.matrix</a></code>,
<code><a href="#topic+import_scn">import_scn</a></code>, <code><a href="#topic+plot_volumetric">plot_volumetric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myResids &lt;- get.resid(lhrh, covars)
myPerms &lt;- shuffleSet(n=nrow(myResids$resids.all), nset=1e3)
out &lt;- brainGraph_permute(densities, m, perms=myPerms)
out &lt;- brainGraph_permute(densities, m, perms=myPerms, level='vertex')
out &lt;- brainGraph_permute(densities, m, perms=myPerms,
  level='other', .function=myFun)

## End(Not run)
</code></pre>

<hr>
<h2 id='brainGraph-methods'>brainGraph generic methods</h2><span id='topic+brainGraph-methods'></span><span id='topic+groups.brainGraphList'></span><span id='topic+groups.corr_mats'></span><span id='topic+region.names'></span><span id='topic+region.names.data.table'></span><span id='topic+nregions'></span>

<h3>Description</h3>

<p>These functions are S3 <em>generics</em> for various <code>brainGraph</code>-defined
objects.
</p>
<p><code>groups</code> returns the &ldquo;Group&rdquo; graph attribute for each graph or
observation in the object.
</p>
<p><code>region.names</code> is a generic method for extracting region names from
various <code>brainGraph</code> objects. These are generally convenience functions.
</p>
<p><code>nregions</code> is a generic method for extracting the number of regions from
various <code>brainGraph</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brainGraphList'
groups(x)

## S3 method for class 'corr_mats'
groups(x)

region.names(object)

## S3 method for class 'data.table'
region.names(object)

nregions(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainGraph-methods_+3A_x">x</code>, <code id="brainGraph-methods_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a <code>data.table</code>, <code>region.names</code> assumes that it contains a
<em>factor</em> column named <code>region</code>.
</p>

<hr>
<h2 id='brainGraphList'>Create a list of brainGraph graphs</h2><span id='topic+brainGraphList'></span><span id='topic+make_brainGraphList'></span><span id='topic+make_brainGraphList.array'></span><span id='topic+make_brainGraphList.corr_mats'></span><span id='topic+Extract.brainGraphList'></span><span id='topic++5B.brainGraphList'></span><span id='topic+print.brainGraphList'></span><span id='topic+is.brainGraphList'></span><span id='topic+nobs.brainGraphList'></span><span id='topic+as_brainGraphList'></span>

<h3>Description</h3>

<p><code>make_brainGraphList</code> creates a <code>brainGraphList</code> object, a list
containing a set of graphs for all subjects (or group-average graphs) in a
study at a specific threshold (or density), in addition to some graph-level
attributes common to those graphs.
</p>
<p>The <code>[</code> method will let you subset/slice the graphs for individual
subjects and/or <em>groups</em>.
</p>
<p><code>as_brainGraphList</code> coerces a list of graphs to a <code>brainGraphList</code>
object. It is assumed that certain metadata attributes &ndash; threshold, package
version, atlas, imaging modality, edge weighting, and whether they are
random graphs &ndash; are identical for all graphs in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_brainGraphList(x, atlas, type = c("observed", "random"),
  level = c("subject", "group", "contrast"), set.attrs = TRUE,
  modality = NULL, weighting = NULL, threshold = NULL,
  gnames = NULL, ...)

## S3 method for class 'array'
make_brainGraphList(x, atlas, type = c("observed",
  "random"), level = c("subject", "group", "contrast"),
  set.attrs = TRUE, modality = NULL, weighting = NULL,
  threshold = NULL, gnames = NULL, grpNames = NULL, subnet = NULL,
  mode = "undirected", weighted = NULL, diag = FALSE,
  .progress = getOption("bg.progress"), ...)

## S3 method for class 'corr_mats'
make_brainGraphList(x, atlas = x$atlas,
  type = "observed", level = "group", set.attrs = TRUE,
  modality = NULL, weighting = NULL, threshold = x$densities,
  gnames = names(x$r.thresh), grpNames = gnames, mode = "undirected",
  weighted = NULL, diag = FALSE,
  .progress = getOption("bg.progress"), ...)

## S3 method for class 'brainGraphList'
x[i, g = NULL, drop = TRUE]

## S3 method for class 'brainGraphList'
print(x, ...)

is.brainGraphList(x)

## S3 method for class 'brainGraphList'
nobs(object, ...)

as_brainGraphList(g.list, type = c("observed", "random"),
  level = c("subject", "group", "contrast"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainGraphList_+3A_x">x</code></td>
<td>
<p>3-D numeric array of all subjects' connectivity matrices (for a
single threshold) or a <code>corr_mats</code> object</p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_atlas">atlas</code></td>
<td>
<p>Character string specifying the brain atlas</p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_type">type</code></td>
<td>
<p>Character string indicating the type of graphs. Default:
<code>observed</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_level">level</code></td>
<td>
<p>Character string indicating whether the graphs are subject-,
group-, or contrast-specific. Default: <code>'subject'</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_set.attrs">set.attrs</code></td>
<td>
<p>Logical indicating whether to assign all graph-, vertex-,
and edge-level attributes (via <code><a href="#topic+set_brainGraph_attr">set_brainGraph_attr</a></code>). Default:
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_modality">modality</code></td>
<td>
<p>Character string indicating imaging modality (e.g. 'dti').
Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_weighting">weighting</code></td>
<td>
<p>Character string indicating how the edges are weighted
(e.g., 'fa', 'pearson', etc.). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_threshold">threshold</code></td>
<td>
<p>Integer or number indicating the threshold used when
&ldquo;sparsifying&rdquo; the connectivity matrix (if any). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_gnames">gnames</code></td>
<td>
<p>Character vector of graph names (e.g., study IDs if
<code>level='subject'</code>). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+set_brainGraph_attr">set_brainGraph_attr</a></code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_grpnames">grpNames</code></td>
<td>
<p>Character (or factor) vector of group names. If <code>level ==
'group'</code>, then you do not need to include this argument (the group names
will be the same as <code>gnames</code>). Default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_subnet">subnet</code></td>
<td>
<p>Integer or character vector indicating the vertices to keep, if
you are interested in working with a subset of an atlas. By default, all
vertices are used.</p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_mode">mode</code></td>
<td>
<p>Character string defining how the matrix should be interpreted.
Default: <code>'undirected'</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_weighted">weighted</code></td>
<td>
<p>Logical specifying whether to create a weighted network</p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_diag">diag</code></td>
<td>
<p>Logical indicating whether to include the diagonal of the
connectivity matrix. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_.progress">.progress</code></td>
<td>
<p>Logical indicating whether to print a progress bar. Default:
<code>getOption('bg.progress')</code></p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_i">i</code></td>
<td>
<p>Integer, character, or logical vector for subsetting by subject, or
by group (if <code>x$level='group'</code>)</p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_g">g</code></td>
<td>
<p>Integer, character, or logical vector for subsetting by group (if
<code>x$level='subject'</code>)</p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> (the default), then return only the list of
graphs; otherwise, subset the graphs and return the entire object</p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_object">object</code></td>
<td>
<p>A <code>brainGraphList</code> object</p>
</td></tr>
<tr><td><code id="brainGraphList_+3A_g.list">g.list</code></td>
<td>
<p>List of graph objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to creating the initial <code>igraph</code> graphs from the
connectivity matrices, then attributes will be calculated and assigned for
each graph via <code><a href="#topic+set_brainGraph_attr">set_brainGraph_attr</a></code> if <code>set.attrs=TRUE</code>.
Other arguments can be passed to that function. You may display a progress
bar by setting <code>.progress=TRUE</code>.
</p>
<p>This object can be considered comparable to a 4-D <em>NIfTI</em> file,
particularly that returned by FSL's <em>TBSS</em> &ldquo;prestats&rdquo; step since
that file contains the FA volumes for all study subjects.
</p>
<p>To convert an object with 3 &ldquo;levels&rdquo; (i.e., subject-level lists from
an older <code>brainGraph</code> version), see the code in the Examples below.
</p>


<h3>Value</h3>

<p><code>make_brainGraphList</code> returns an object of class
<code>brainGraphList</code> with elements:
</p>
<table role = "presentation">
<tr><td><code>threshold</code></td>
<td>
<p>The specified threshold/density</p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>The versions of <code>R</code>, <code>igraph</code>, and
<code>brainGraph</code> used when creating the graphs</p>
</td></tr>
<tr><td><code>atlas</code></td>
<td>
<p>The atlas common to all the graphs</p>
</td></tr>
<tr><td><code>modality</code></td>
<td>
<p>The imaging modality (if supplied)</p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p>A string indicating what edge weights represent (if
applicable)</p>
</td></tr>
<tr><td><code>graphs</code></td>
<td>
<p>A <em>named list</em> of <code>brainGraph</code> graphs; the names
correspond to the individual graphs' Study IDs</p>
</td></tr>
</table>
<p><code>[</code> &ndash; A <code>brainGraphList</code> object (if <code>drop=FALSE</code>) or
a list of graphs
</p>


<h3>Subsetting/extracting</h3>

<p>The first index is for subsetting the individual graphs. The second index is
for subsetting by group membership and requires that the graphs have a
<code>Group</code> graph attribute. When both are included, the first index cannot
have length or numeric value greater than the number of <em>remaining</em>
subjects <em>after</em> subsetting by group.
</p>
<p>If the indexing vector(s) is (are) <code>character</code>, the vector(s) must
contain one (or more) of the subject or group names. If <code>logical</code>, its
length must equal the number of subjects or groups.
</p>


<h3>Note</h3>

<p>If the input is a <code>corr_mats</code> object, and the extent of the 3-D
array is greater than 1, then only the first will be converted to a graph.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other Graph creation functions: <code><a href="#topic+Creating_Graphs_GLM">Creating_Graphs_GLM</a></code>,
<code><a href="#topic+Creating_Graphs">Creating_Graphs</a></code>,
<code><a href="#topic+make_ego_brainGraph">make_ego_brainGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a list, one for each threshold
g &lt;- vector('list', length(thresholds))
for (i in seq_along(thresholds)) {
  g[[i]] &lt;- make_brainGraphList(A.norm.sub[[i]], thresholds[i], atlas,
      covars.dti$Study.ID, covars.dti$Group, modality='dti', weighting='fa')
}

## End(Not run)
## Not run: 
# Subset the first 10 subjects, irrespective of group
my.bgl[1:10]

# Return object for only 'Control' subjects
my.bgl[, 'Control']

# Return object with graphs from groups 1 and 3
my.bgl[g=c(1, 3), drop=FALSE]

# Subset the first 10 subjects of group 2
my.bgl[1:10, 2]

## End(Not run)
## Not run: 
## Convert old version single-subject graph lists
## g[[1]] is group 1, g[[1]][[1]] is threshold 1, g[[1]][[1]][[1]] is subj. 1
kNumThresholds &lt;- length(g[[1]])
g.l &lt;- vector('list', kNumThresholds)
for (i in seq_len(kNumThresholds)) {
  g.l[[i]] &lt;- as_brainGraphList(do.call(Map, c(c, g))[[i]])
}

## End(Not run)
</code></pre>

<hr>
<h2 id='centr_betw_comm'>Calculate communicability betweenness centrality</h2><span id='topic+centr_betw_comm'></span>

<h3>Description</h3>

<p><code>centr_betw_comm</code> calculates the <em>communicability betweenness</em> of
the vertices of a graph. The centrality for vertex <code>r</code> is
</p>
<p style="text-align: center;"><code class="reqn">\omega_r = \frac{1}{C} \sum_p \sum_q \frac{(e^{\mathbf{A}})_{pq} -
(e^{\mathbf{A} + \mathbf{E}(r)})_{pq}}{(e^{\mathbf{A}})_{pq}}</code>
</p>

<p>where <code class="reqn">C = (n - 1)^2 - (n - 1)</code> is a normalization factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_betw_comm(g, A = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centr_betw_comm_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="centr_betw_comm_+3A_a">A</code></td>
<td>
<p>Numeric matrix; the adjacency matrix of the input graph. Default:
<code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the centrality for each vertex
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Estrada, E. and Higham, D.J. and Hatano N. (2009) Communicability
betweenness in complex networks. <em>Physica A</em>, <b>388</b>, 764&ndash;774.
doi: <a href="https://doi.org/10.1016/j.physa.2008.11.011">10.1016/j.physa.2008.11.011</a>
</p>


<h3>See Also</h3>

<p>Other Centrality functions: <code><a href="#topic+centr_lev">centr_lev</a></code>
</p>

<hr>
<h2 id='centr_lev'>Calculate a vertex's leverage centrality</h2><span id='topic+centr_lev'></span>

<h3>Description</h3>

<p>Calculates the leverage centrality of each vertex in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_lev(g, A = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centr_lev_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="centr_lev_+3A_a">A</code></td>
<td>
<p>Numeric matrix; the adjacency matrix of the input graph. Default:
<code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The leverage centrality relates a vertex's degree with the degree of its
neighbors. The equation is:
</p>
<p style="text-align: center;"><code class="reqn">l_i = \frac{1}{k_i} \sum_{j \in N_i} \frac{k_i - k_j}{k_i + k_j}</code>
</p>

<p>where <code class="reqn">k_i</code> is the degree of the <code class="reqn">i^{th}</code> vertex and <code class="reqn">N_i</code> is the
set of neighbors of <em>i</em>. This function replaces <em>NaN</em> with
<em>NA</em> (for functions that have the argument <em>na.rm</em>).
</p>


<h3>Value</h3>

<p>A vector of the leverage centrality for all vertices.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Joyce, K.E. and Laurienti P.J. and Burdette J.H. and Hayasaka S.
(2010) A new measure of centrality for brain networks. <em>PLoS One</em>,
<b>5(8)</b>, e12200. doi: <a href="https://doi.org/10.1371/journal.pone.0012200">10.1371/journal.pone.0012200</a>
</p>


<h3>See Also</h3>

<p>Other Centrality functions: <code><a href="#topic+centr_betw_comm">centr_betw_comm</a></code>
</p>

<hr>
<h2 id='check_sID'>Test if an object is a character vector of numbers</h2><span id='topic+check_sID'></span><span id='topic+pad_zeros'></span>

<h3>Description</h3>

<p><code>check_sID</code> is a convenience function to test if a vector (typically the
<em>subject ID</em> column in a <code>data.table</code>) is a character vector of
numbers, a factor vector of numbers, or a numeric vector. If so, it will
zero-pad the variable to have equal width.
</p>
<p><code>pad_zeros</code> pads a vector with zeros to avoid issues with ordering a
column of integers or integers converted to <code>character</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sID(x)

pad_zeros(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_sID_+3A_x">x</code></td>
<td>
<p><code>pad_zeros</code> accepts either a vector (numeric or character) or a
single integer. <code>check_sID</code> accepts a character, numeric, or factor
vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to avoid issues that arise when sorting a vector of
numbers that have been converted to <code>character</code>. For example,
<code><a href="#topic+import_scn">import_scn</a></code> automatically reads in the first column (with
<em>FreeSurfer</em> outputs this is the column of subject IDs) as a
<code>character</code> variable. If the subject IDs had been all numbers/integers,
then sorting (i.e., setting the <code>key</code> in a <code>data.table</code>) would be
incorrect: e.g., it might be <code>'1', '10', '2', ...</code>.
</p>
<p>If &ldquo;x&rdquo; is a numeric vector, then the resultant string width will be
determined by <code>max(x)</code> or <code>x</code> itself if the input is a single
integer. For example, if <code>x=10</code>, it will return <code>'01', '02', ...,
'10'</code>. If &ldquo;x&rdquo; is a character vector, then the output's string width
will be <code>max(nchar(x))</code>. For example, if <code>x</code> includes both
<code>'1'</code> and <code>'1000'</code>, it will return <code>'0001'</code>, etc.
</p>


<h3>Value</h3>

<p><code>check_sID</code> returns either the input vector or a character
vector padded with <code>0</code>
</p>
<p>A character vector with zero-padded values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pad_zeros(10)  # '01' '02' ... '10'
x &lt;- c(1, 10, 100)
pad_zeros(x)   # '001' '010' '100'
x &lt;- as.character(x)
pad_zeros(x)   # '001' '010' '100'
</code></pre>

<hr>
<h2 id='check_weights'>Check for vertex or edge attributes</h2><span id='topic+check_weights'></span><span id='topic+check_degree'></span><span id='topic+check_strength'></span>

<h3>Description</h3>

<p><code>check_weights</code> is a helper function for dealing with edge weights that
get passed to different <code>igraph</code> functions.
</p>
<p><code>check_degree</code> is a helper function to check if <code>degree</code> is a
vertex attribute of the input graph. Returns a numeric vector of the degree
values.
</p>
<p><code>check_strength</code> is a helper function to check if <code>strength</code> is a
vertex attribute of the input graph. Returns a numeric vector of the strength
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_weights(g, weights)

check_degree(g)

check_strength(g)
</code></pre>


<h3>Value</h3>

<p><code>check_weights</code> - If <code>weights=NULL</code> and the graph has a
<code>'weight'</code> attribute, then <code>NULL</code> will be returned. If
<code>weights=NA</code>, then <code>NA</code> is returned.
</p>

<hr>
<h2 id='choose.edges'>Select edges for re-wiring</h2><span id='topic+choose.edges'></span>

<h3>Description</h3>

<p><code>choose.edges</code> selects edges to be re-wired when simulating random
graphs while controlling for <em>clustering</em>. It is based on the algorithm
by Bansal et al. (2009), BMC Bioinformatics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose.edges(A, degs.large)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choose.edges_+3A_a">A</code></td>
<td>
<p>Numeric (adjacency) matrix</p>
</td></tr>
<tr><td><code id="choose.edges_+3A_degs.large">degs.large</code></td>
<td>
<p>Integer vector of vertex numbers with degree greater than
one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with four elements; two edges <code>(y1, z1)</code> and
<code>(y2, z2)</code> will be removed, and two edges <code>(y1, y2)</code> and
<code>(z1, z2)</code> will be added between the four vertices.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>

<hr>
<h2 id='coeff_var'>Calculate coefficient of variation</h2><span id='topic+coeff_var'></span><span id='topic+coeff_var.default'></span>

<h3>Description</h3>

<p><code>coeff_var</code> is a S3 generic that calculates the <em>coefficient of
variation</em>, defined as
</p>
<p style="text-align: center;"><code class="reqn">CV(x) = \frac{sd(x)}{mean(x)}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>coeff_var(x, na.rm = FALSE, ...)

## Default S3 method:
coeff_var(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coeff_var_+3A_x">x</code></td>
<td>
<p>Numeric vector, matrix, or array</p>
</td></tr>
<tr><td><code id="coeff_var_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating whether <code>NA</code> values should be stripped
when calculating sums. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="coeff_var_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a matrix, it will calculate the CV for each <em>column</em>. If
<code>x</code> is a 3D array, it will calculate the coefficient of variation for
each <em>row-column</em> combination. If the input dimensions are <code class="reqn">n \times
n \times r</code>, a matrix with size <code class="reqn">n \times n</code> will be returned.
</p>


<h3>Value</h3>

<p>A numeric vector or matrix
</p>

<hr>
<h2 id='communicability'>Calculate communicability</h2><span id='topic+communicability'></span>

<h3>Description</h3>

<p><code>communicability</code> calculates the communicability of a network, a measure
which takes into account all possible paths (including non-shortest paths)
between vertex pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communicability(g, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="communicability_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="communicability_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of edge weights; if <code>NULL</code> (the default),
and if the graph has edge attribute <code>weight</code>, then that will be used.
To avoid using weights, this should be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The communicability <code class="reqn">G_{pq}</code> is a weighted sum of the number of walks
from vertex <em>p</em> to <em>q</em> and is calculated by taking the exponential
of the adjacency matrix <em>A</em>:
</p>
<p style="text-align: center;"><code class="reqn">G_{pq} = \sum_{k=0}^{\infty} \frac{(\mathbf{A}^k)_{pq}}{k!} =
(e^{\mathbf{A}})_{pq}</code>
</p>

<p>where <code class="reqn">k</code> is <em>walk</em> length.
</p>
<p>For weighted graphs with <code class="reqn">D = diag(d_i)</code> a diagonal matrix of vertex
strength,
</p>
<p style="text-align: center;"><code class="reqn">G_{pq} = (e^{\mathbf{D}^{-1/2} \mathbf{A} \mathbf{D}^{-1/2}})_{pq}</code>
</p>



<h3>Value</h3>

<p>A numeric matrix of the communicability
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Estrada, E. and Hatano, N. (2008) Communicability in complex
networks. <em>Physical Review E</em>. <b>77</b>, 036111.
doi: <a href="https://doi.org/10.1103/PhysRevE.77.036111">10.1103/PhysRevE.77.036111</a>
</p>
<p>Crofts, J.J. and Higham, D.J. (2009) A weighted communicability
measure applied to complex brain networks. <em>J. R. Soc. Interface</em>.
<b>6</b>, 411&ndash;414. doi: <a href="https://doi.org/10.1098/rsif.2008.0484">10.1098/rsif.2008.0484</a>
</p>

<hr>
<h2 id='contract_brainGraph'>Contract graph vertices based on brain lobe and hemisphere</h2><span id='topic+contract_brainGraph'></span>

<h3>Description</h3>

<p>Create a new graph after merging vertices within specified groups.
By default, groups are brain <em>lobe</em> and <em>hemisphere</em> membership.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract_brainGraph(g, vgroup = "lobe.hemi")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contract_brainGraph_+3A_g">g</code></td>
<td>
<p>A <code>brainGraph</code> graph object</p>
</td></tr>
<tr><td><code id="contract_brainGraph_+3A_vgroup">vgroup</code></td>
<td>
<p>Character string; the name of the vertex attribute to use when
contracting the graph. Default: <code>'lobe.hemi'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>size</code> vertex-level attribute of the resultant graph is equal to the
number of vertices in each group. The x-, y-, and z-coordinates of the new
graph are equal to the mean coordinates of the vertices per group.
The new edge weights are equal to the number of inter-group connections of
the original graph.
</p>


<h3>Value</h3>

<p>A new <code>brainGraph</code> graph object with vertex-level attributes
representing the mean spatial coordinates, and vertex- and edge-level
attributes of color names
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+contract">contract</a></code>
</p>

<hr>
<h2 id='cor.diff.test'>Calculate the p-value for differences in correlation coefficients</h2><span id='topic+cor.diff.test'></span>

<h3>Description</h3>

<p>Given two sets of correlation coefficients and sample sizes, this function
calculates and returns the <em>z-scores</em> and <em>p-values</em> associated
with the difference between correlation coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.diff.test(r1, r2, n, alternative = c("two.sided", "less", "greater"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor.diff.test_+3A_r1">r1</code>, <code id="cor.diff.test_+3A_r2">r2</code></td>
<td>
<p>Numeric (vector or matrix) of correlation coefficients for both
groups</p>
</td></tr>
<tr><td><code id="cor.diff.test_+3A_n">n</code></td>
<td>
<p>Integer vector; number of observations for both groups</p>
</td></tr>
<tr><td><code id="cor.diff.test_+3A_alternative">alternative</code></td>
<td>
<p>Character string, whether to do a two- or one-sided test.
Default: <code>'two.sided'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>p</code> and <code>z</code>, the p-values
and z-scores for the difference in correlations.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
kNumSubjs &lt;- summary(covars$Group)
corr.diffs &lt;- cor.diff.test(corrs$R[, , 1], corrs$R[, , 2], kNumSubjs)
edge.diffs &lt;- t(sapply(which(corr.diffs$p &lt; .05), function(x)
                       mapply('[[',
                              dimnames(corr.diffs$p),
                              arrayInd(x, dim(corr.diffs$p)))
                              ))

## End(Not run)
</code></pre>

<hr>
<h2 id='corr.matrix'>Calculate correlation matrix and threshold</h2><span id='topic+corr.matrix'></span><span id='topic+Extract.corr_mats'></span><span id='topic++5B.corr_mats'></span><span id='topic+plot.corr_mats'></span><span id='topic+region.names.corr_mats'></span><span id='topic+nregions.corr_mats'></span>

<h3>Description</h3>

<p><code>corr.matrix</code> calculates the correlation between all column pairs of a
given data frame, and thresholds the resultant correlation matrix based on a
given density (e.g., <code>0.1</code> if you want to keep only the 10% strongest
correlations). If you want to threshold by a specific correlation coefficient
(via the <code>thresholds</code> argument), then the <code>densities</code> argument is
ignored.
</p>
<p>The <code>plot</code> method will plot &ldquo;heat maps&rdquo; of the correlation
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr.matrix(resids, densities, thresholds = NULL, what = c("resids",
  "raw"), exclude.reg = NULL, type = c("pearson", "spearman"),
  rand = FALSE)

## S3 method for class 'corr_mats'
x[i, g = NULL]

## S3 method for class 'corr_mats'
plot(x, mat.type = c("thresholded", "raw"),
  thresh.num = 1L, ordered = TRUE, order.by = "lobe",
  graphs = NULL, grp.names = NULL, legend.title = NULL, ...)

## S3 method for class 'corr_mats'
region.names(object)

## S3 method for class 'corr_mats'
nregions(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corr.matrix_+3A_resids">resids</code></td>
<td>
<p>An object of class <code>brainGraph_resids</code> (the output from
<code><a href="#topic+get.resid">get.resid</a></code>)</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_densities">densities</code></td>
<td>
<p>Numeric vector indicating the resultant network
densities; keeps the top <em>X</em>% of correlations</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_thresholds">thresholds</code></td>
<td>
<p>Numeric; absolute correlation value to threshold by
(default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_what">what</code></td>
<td>
<p>Character string indicating whether to correlate the residuals or
the raw structural MRI values (default: <code>'resids'</code>)</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_exclude.reg">exclude.reg</code></td>
<td>
<p>Character vector of regions to exclude (default:
<code>NULL</code>)</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_type">type</code></td>
<td>
<p>Character string indicating which type of correlation coefficient
to calculate (default: <code>'pearson'</code>)</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_rand">rand</code></td>
<td>
<p>Logical indicating whether the function is being called for
permutation testing; not intended for general use (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_x">x</code>, <code id="corr.matrix_+3A_object">object</code></td>
<td>
<p>A <code>corr_mats</code> object</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_i">i</code></td>
<td>
<p>Integer for subsetting by density/threshold</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_g">g</code></td>
<td>
<p>Integer, character, or logical for subsetting by group</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_mat.type">mat.type</code></td>
<td>
<p>Character string indicating whether to plot raw or thresholded
(binarized) matrices. Default: <code>'raw'</code></p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_thresh.num">thresh.num</code></td>
<td>
<p>Integer specifying which threshold to plot (if
<code>mat.type='thresholded'</code>). Default: <code>1L</code></p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_ordered">ordered</code></td>
<td>
<p>Logical indicating whether to order the vertices by some
grouping. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_order.by">order.by</code></td>
<td>
<p>Character string indicating how to group vertices. Default:
<code>'lobe'</code></p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_graphs">graphs</code></td>
<td>
<p>A <code>brainGraphList</code> object containing graphs with the
vertex-level attribute of interest. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_grp.names">grp.names</code></td>
<td>
<p>Character vector specifying the names of each group of
vertices. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_legend.title">legend.title</code></td>
<td>
<p>Character string for the legend title. Default is to
leave blank</p>
</td></tr>
<tr><td><code id="corr.matrix_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you wish to exclude regions from your analysis, you can give the indices
of their columns with the <code>exclude.reg</code> argument.
</p>
<p>By default, the Pearson correlation coefficients are calculated, but you can
return Spearman by changing the <code>type</code> argument.
</p>


<h3>Value</h3>

<p>A <code>corr_mats</code> object containing the following components:
</p>
<table role = "presentation">
<tr><td><code>R</code>, <code>P</code></td>
<td>
<p>Numeric arrays of correlation coefficients and P-values. The
length of the 3rd dimension equals the number of groups</p>
</td></tr>
<tr><td><code>r.thresh</code></td>
<td>
<p>A list of 3-d binary arrays indicating correlations that
are above a certain threshold. The length of the list equals the number
of groups, and the length of the 3rd dimension equals the number of
thresholds/densities.</p>
</td></tr>
<tr><td><code>thresholds</code></td>
<td>
<p>Numeric matrix of the thresholds supplied. The number of
columns equals the number of groups.</p>
</td></tr>
<tr><td><code>what</code></td>
<td>
<p>Residuals or raw values</p>
</td></tr>
<tr><td><code>exclude.reg</code></td>
<td>
<p>Excluded regions (if any)</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Pearson or Spearman</p>
</td></tr>
<tr><td><code>atlas</code></td>
<td>
<p>The brain atlas used</p>
</td></tr>
<tr><td><code>densities</code></td>
<td>
<p>Numeric vector; the densities of the resulting graphs, if
you chose to threshold each group to have equal densities.</p>
</td></tr>
</table>


<h3>Plotting correlation matrices</h3>

<p>There are several ways to control the plot appearance. First, you may plot
the &ldquo;raw&rdquo; correlations, or only those of the thresholded (binarized)
matrices. Second, you may order the vertices by a given vertex attribute; by
default, they will be ordered by <em>lobe</em>, but you may also choose to
order by, e.g., <em>network</em> (for the <code>dosenbach160</code> atlas) or by
<em>community membership</em>. In the latter case, you need to pass a
<code>brainGraphList</code> object to the <code>graphs</code> argument; each graph in the
object must have a vertex attribute specified in <code>order.by</code>. Finally,
you can control the legend text with <code>grp.names</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="Hmisc.html#topic+rcorr">rcorr</a></code>
</p>
<p>Other Structural covariance network functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+IndividualContributions">IndividualContributions</a></code>,
<code><a href="#topic+Residuals">Residuals</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>,
<code><a href="#topic+import_scn">import_scn</a></code>, <code><a href="#topic+plot_volumetric">plot_volumetric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myResids &lt;- get.resid(lhrh, covars)
corrs &lt;- corr.matrix(myResids, densities=densities)))

## End(Not run)
## Not run: 
corrs &lt;- corr.matrix(myResids, densities)
plot(corrs, order.by='comm', graphs=g.list, grp.names='Community')

## End(Not run)
</code></pre>

<hr>
<h2 id='Count+20Edges'>Count number of edges of a brain graph</h2><span id='topic+Count+20Edges'></span><span id='topic+count_homologous'></span><span id='topic+count_inter'></span>

<h3>Description</h3>

<p><code>count_homologous</code> counts the number of edges between homologous regions
in a brain graph (e.g. between L and R superior frontal).
</p>
<p><code>count_inter</code> counts the number of edges between and within all vertices
in one group (e.g. <em>lobe</em>, <em>hemi</em>, <em>network</em>, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_homologous(g)

count_inter(g, group = c("lobe", "hemi", "network", "class", "gyrus",
  "Yeo_7network", "Yeo_17network", "area", "Brodmann"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Count+2B20Edges_+3A_g">g</code></td>
<td>
<p>A <code>brainGraph</code> graph object</p>
</td></tr>
<tr><td><code id="Count+2B20Edges_+3A_group">group</code></td>
<td>
<p>Character string specifying which grouping to calculate edge
counts for. Default: <code>'lobe'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>count_homologous</code> - a named vector of the edge ID's connecting
homologous regions
</p>
<p><code>count_inter</code> - a <code>data.table</code> of total, intra-, and
inter-group edge counts
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g1.lobecounts &lt;- count_inter(g[[1]][[N]], 'lobe')

## End(Not run)
</code></pre>

<hr>
<h2 id='create_mats'>Create connection matrices for tractography or fMRI data</h2><span id='topic+create_mats'></span>

<h3>Description</h3>

<p><code>create_mats</code> creates arrays from connection matrices (e.g.,
<em>fdt_network_matrix</em> from FSL or <em>ROICorrelation.txt</em> from DPABI).
You may choose to normalize these matrices by the <em>waytotal</em> or
<em>region size</em> (tractography), or not at all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_mats(A.files, modality = c("dti", "fmri"), divisor = c("none",
  "waytotal", "size", "rowSums"), div.files = NULL,
  threshold.by = c("consensus", "density", "mean", "consistency", "raw"),
  mat.thresh = 0, sub.thresh = 0.5, inds = list(seq_along(A.files)),
  algo = c("probabilistic", "deterministic"), P = 5000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_mats_+3A_a.files">A.files</code></td>
<td>
<p>Character vector of the filenames with connection matrices</p>
</td></tr>
<tr><td><code id="create_mats_+3A_modality">modality</code></td>
<td>
<p>Character string indicating data modality (default:
<code>dti</code>)</p>
</td></tr>
<tr><td><code id="create_mats_+3A_divisor">divisor</code></td>
<td>
<p>Character string indicating how to normalize the connection
matrices; either 'none' (default), 'waytotal', 'size', or 'rowSums'
(ignored if <code>modality</code> equals <code>fmri</code>)</p>
</td></tr>
<tr><td><code id="create_mats_+3A_div.files">div.files</code></td>
<td>
<p>Character vector of the filenames with the data to
normalize by (e.g. a list of <em>waytotal</em> files) (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="create_mats_+3A_threshold.by">threshold.by</code></td>
<td>
<p>Character string indicating how to threshold the data;
choose <code>density</code>, <code>mean</code>, or <code>consistency</code> if you want all
resulting matrices to have the same densities (default: <code>consensus</code>)</p>
</td></tr>
<tr><td><code id="create_mats_+3A_mat.thresh">mat.thresh</code></td>
<td>
<p>Numeric (vector) for thresholding connection matrices
(default: 0)</p>
</td></tr>
<tr><td><code id="create_mats_+3A_sub.thresh">sub.thresh</code></td>
<td>
<p>Numeric (between 0 and 1) for thresholding by subject
numbers (default: 0.5)</p>
</td></tr>
<tr><td><code id="create_mats_+3A_inds">inds</code></td>
<td>
<p>List (length equal to number of groups) of integers; each list
element should be a vector of length equal to the group sizes</p>
</td></tr>
<tr><td><code id="create_mats_+3A_algo">algo</code></td>
<td>
<p>Character string of the tractography algorithm used (default:
<code>'probabilistic'</code>). Ignored if <em>modality</em> is <code>fmri</code>.</p>
</td></tr>
<tr><td><code id="create_mats_+3A_p">P</code></td>
<td>
<p>Integer; number of samples per seed voxel (default: 5000)</p>
</td></tr>
<tr><td><code id="create_mats_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+symmetrize">symmetrize</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>A 3-d array of the raw connection matrices</p>
</td></tr>
<tr><td><code>A.norm</code></td>
<td>
<p>A 3-d array of the normalized connection matrices</p>
</td></tr>
<tr><td><code>A.bin</code></td>
<td>
<p>A list of 3-d arrays of binarized connection matrices, one array
for each threshold</p>
</td></tr>
<tr><td><code>A.bin.sums</code></td>
<td>
<p>A list of 3-d arrays of connection matrices, with each
entry signifying the number of subjects with a connection present; the
number of list elements equals the length of <code>mat.thresh</code>, and the
extent of the arrays equals the number of groups</p>
</td></tr>
<tr><td><code>A.inds</code></td>
<td>
<p>A list of arrays of binarized connection matrices, containing 1
if that entry is to be included</p>
</td></tr>
<tr><td><code>A.norm.sub</code></td>
<td>
<p>List of 3-d arrays of the normalized connection matrices
for all given thresholds</p>
</td></tr>
<tr><td><code>A.norm.mean</code></td>
<td>
<p>List of 3-d arrays of connection matrices averaged for
each group</p>
</td></tr>
</table>


<h3>Connection matrix files</h3>

<p>The <code>A.files</code> argument is mandatory and may be specified in a few ways:
</p>

<ol>
<li><p> A character vector of the filenames (preferably with full path).
</p>
</li>
<li><p> A single character string specifying the <em>directory</em> in which
all connectivity matrices are located. This will load <em>all</em> files in
the directory.
</p>
</li>
<li><p> A <em>named list</em> in which the names match the arguments to
<code><a href="base.html#topic+list.files">list.files</a></code>. This will load <em>all</em> files in <code>path</code>
that match the <code>pattern</code> argument, if present, and will load
<em>all</em> files in child directories if <code>recursive=TRUE</code>. See
examples below.
</p>
</li></ol>

<p>The same options apply to <code>div.files</code> as well.
</p>


<h3>Thresholding methods</h3>

<p>The argument <code>threshold.by</code> has 5 options:
</p>

<ol>
<li> <p><code>consensus</code> Threshold based on the raw (normalized, if selected)
values in the matrices. If this is selected, it uses the
<code>sub.thresh</code> value to perform &ldquo;consensus&rdquo; thresholding.
</p>
</li>
<li> <p><code>density</code> Threshold the matrices to yield a specific graph
density (given by the <code>mat.thresh</code> argument).
</p>
</li>
<li> <p><code>mean</code> Keep only connections for which the cross-subject mean is
at least 2 standard deviations higher than the threshold (specified by
<code>mat.thresh</code>)
</p>
</li>
<li> <p><code>consistency</code> Threshold based on the coefficient of variation to
yield a graph with a specific density (given by <code>mat.thresh</code>). The
edge weights will still represent those of the input matrices. See
Roberts et al. (2017) for more on &ldquo;consistency-based&rdquo;
thresholding.
</p>
</li>
<li> <p><code>raw</code> Threshold each subject's matrix <em>individually</em>,
irrespective of group membership. Ignores <code>sub.thresh</code>.
</p>
</li></ol>

<p>The argument <code>mat.thresh</code> allows you to choose a numeric threshold,
below which the connections will be replaced with 0; this argument will also
accept a numeric vector. The argument <code>sub.thresh</code> will keep only those
connections for which at least <em>X</em>% of subjects have a positive entry
(the default is 0.5, or 50%).
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Roberts, JA and Perry, A and Roberts, G and Mitchell, PB and
Breakspear, M (2017) Consistency-based thresholding of the human
connectome. <em>NeuroImage</em>. <b>145</b>, 118&ndash;129.
doi: <a href="https://doi.org/10.1016/j.neuroimage.2016.09.053">10.1016/j.neuroimage.2016.09.053</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
thresholds &lt;- seq(from=0.001, to=0.01, by=0.001)
fmri.mats &lt;- create_mats(f.A, modality='fmri', threshold.by='consensus',
  mat.thresh=thresholds, sub.thresh=0.5, inds=inds)
dti.mats &lt;- create_mats(f.A, divisor='waytotal', div.files=f.way,
  mat.thresh=thresholds, sub.thresh=0.5, inds=inds)

# Specify a directory and filename pattern
conn_files &lt;- list(path='~/data', pattern='.*fdt_network_matrix')
dti.mats &lt;- create_mats(conn_files, ...)

## End(Not run)
</code></pre>

<hr>
<h2 id='Creating_Graphs'>Create a brainGraph object</h2><span id='topic+Creating_Graphs'></span><span id='topic+make_brainGraph'></span><span id='topic+make_brainGraph.igraph'></span><span id='topic+make_brainGraph.matrix'></span><span id='topic+make_brainGraph.bg_mediate'></span><span id='topic+is.brainGraph'></span><span id='topic+summary.brainGraph'></span><span id='topic+make_empty_brainGraph'></span>

<h3>Description</h3>

<p><code>make_brainGraph</code> is the main creation function for creating a
<code>brainGraph</code> graph object. This is simply an <code>igraph</code> graph
object with additional attributes (at all levels). Several of the graph-level
attributes serve the purpose of providing metadata on how the connectivity
matrices/networks were created.
</p>
<p><code>make_brainGraph.bg_mediate</code> creates a graph only for
<em>vertex</em>-level analyses.
</p>
<p><code>make_empty_brainGraph</code> creates an empty undirected <code>brainGraph</code>
object with vertex count equal to the atlas specified; i.e., it creates a
graph with 0 edges. Typically used to present results from an analysis in
which edges don't make sense (e.g., GLM comparing differences in a
vertex-level attribute).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_brainGraph(x, atlas, type = c("observed", "random"),
  level = c("subject", "group", "contrast"), set.attrs = TRUE,
  modality = NULL, weighting = NULL, threshold = NULL, ...)

## S3 method for class 'igraph'
make_brainGraph(x, atlas, type = c("observed",
  "random"), level = c("subject", "group", "contrast"),
  set.attrs = TRUE, modality = NULL, weighting = NULL,
  threshold = NULL, name = NULL, Group = NULL, subnet = NULL, ...)

## S3 method for class 'matrix'
make_brainGraph(x, atlas, type = c("observed",
  "random"), level = c("subject", "group", "contrast"),
  set.attrs = TRUE, modality = NULL, weighting = NULL,
  threshold = NULL, name = NULL, Group = NULL, subnet = NULL,
  mode = "undirected", weighted = NULL, diag = FALSE, ...)

## S3 method for class 'bg_mediate'
make_brainGraph(x, atlas = x$atlas,
  type = "observed", level = "contrast", set.attrs = FALSE,
  modality = NULL, weighting = NULL, threshold = NULL, ...)

is.brainGraph(x)

## S3 method for class 'brainGraph'
summary(object, print.attrs = c("all", "graph",
  "vertex", "edge", "none"), ...)

make_empty_brainGraph(atlas, type = c("observed", "random"),
  level = c("subject", "group", "contrast"), modality = NULL,
  weighting = NULL, threshold = NULL, name = NULL, Group = NULL,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Creating_Graphs_+3A_x">x</code></td>
<td>
<p>An <code>igraph</code> graph object, numeric matrix, or <code>bg_mediate</code>
object</p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_atlas">atlas</code></td>
<td>
<p>Character string specifying the brain atlas</p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_type">type</code></td>
<td>
<p>Character string indicating the type of graphs. Default:
<code>observed</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_level">level</code></td>
<td>
<p>Character string indicating whether the graphs are subject-,
group-, or contrast-specific. Default: <code>'subject'</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_set.attrs">set.attrs</code></td>
<td>
<p>Logical indicating whether to assign all graph-, vertex-,
and edge-level attributes (via <code><a href="#topic+set_brainGraph_attr">set_brainGraph_attr</a></code>). Default:
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_modality">modality</code></td>
<td>
<p>Character string indicating imaging modality (e.g. 'dti').
Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_weighting">weighting</code></td>
<td>
<p>Character string indicating how the edges are weighted
(e.g., 'fa', 'pearson', etc.). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_threshold">threshold</code></td>
<td>
<p>Integer or number indicating the threshold used when
&ldquo;sparsifying&rdquo; the connectivity matrix (if any). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+set_brainGraph_attr">set_brainGraph_attr</a></code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_name">name</code></td>
<td>
<p>Character string indicating subject ID or group/contrast name,
depending on the <code>level</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_group">Group</code></td>
<td>
<p>Character string indicating group membership. Default:
<code>NULL</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_subnet">subnet</code></td>
<td>
<p>Integer or character vector indicating the vertices to keep, if
you are interested in working with a subset of an atlas. By default, all
vertices are used.</p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_mode">mode</code></td>
<td>
<p>Character string defining how the matrix should be interpreted.
Default: <code>'undirected'</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_weighted">weighted</code></td>
<td>
<p>Logical specifying whether to create a weighted network</p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_diag">diag</code></td>
<td>
<p>Logical indicating whether to include the diagonal of the
connectivity matrix. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_object">object</code></td>
<td>
<p>A <code>brainGraph</code> object</p>
</td></tr>
<tr><td><code id="Creating_Graphs_+3A_print.attrs">print.attrs</code></td>
<td>
<p>Character string indicating whether or not to list the
object's attributes (default: <code>all</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>brainGraph</code> graph object with additional graph-, vertex-, and
edge-level attributes (see below).
</p>
<p>The method for <code>bg_mediate</code> returns a <code>brainGraph_mediate</code>
object, which has extra attributes:
</p>
<table role = "presentation">
<tr><td><code>Graph</code></td>
<td>
<p><em>mediator</em>, <em>treat</em>, <em>outcome</em>, <em>nobs</em></p>
</td></tr>
<tr><td><code>Vertex</code></td>
<td>
<p><em>b?.acme, p?.acme</em>, <em>b?.ade, p?.ade</em>,
<em>b?.prop, p?.prop</em>, <em>b.tot, p.tot</em></p>
</td></tr>
</table>
<p><code>make_empty_brainGraph</code> &ndash; An empty <code>brainGraph</code> graph
object
</p>


<h3>Graph-level attributes</h3>

<p>Graph-level attributes added are:
</p>

<dl>
<dt>version</dt><dd><p>The R, <code>brainGraph</code>, and <code>igraph</code> package versions
used to create the graph</p>
</dd>
<dt>date</dt><dd><p>The creation date, from <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code></p>
</dd>
<dt>atlas</dt><dd><p>Character string denoting the brain atlas used</p>
</dd>
<dt>type</dt><dd><p>Character string specifying whether this is an <em>observed</em>
or <em>random</em> graph</p>
</dd>
<dt>modality</dt><dd><p>The imaging modality; you can choose anything you like,
but the <code>summary.brainGraph</code> knows about <code>dti</code>, <code>fmri</code>,
<code>thickness</code>, <code>area</code>, and <code>volume</code></p>
</dd>
<dt>weighting</dt><dd><p>What edge weights represent; you can choose anything you
like, but <code>summary.brainGraph</code> knows about <code>fa</code>, <code>sld</code>
(streamline density, tractography), <code>pearson</code>, <code>spearman</code>,
<code>kendall</code>, and <code>partial</code> (partial correlation coefficient)</p>
</dd>
<dt>threshold</dt><dd><p>Numeric indicating the threshold used to create the final
connectivity matrix (if any)</p>
</dd>
<dt>name</dt><dd><p>Character string specifying the study ID or group/contrast
name, depending on the <code>level</code> argument</p>
</dd>
<dt>Group</dt><dd><p>Character string specifying the experimental group that the
given subject belongs to, or if it is a group-level graph</p>
</dd>
<dt>subnet</dt><dd><p>Integer vector, if <code>subnet</code> was specified in the call</p>
</dd>
</dl>



<h3>Vertex attributes</h3>

<p>Vertex-level attributes added are:
</p>

<dl>
<dt>name</dt><dd><p>The names of the brain regions in the network</p>
</dd>
<dt>lobe</dt><dd><p>The names of the major brain lobes for each vertex</p>
</dd>
<dt>hemi</dt><dd><p>The names of the hemisphere for each vertex (either <code>'L'</code>,
<code>'R'</code>, or <code>'B'</code>)</p>
</dd>
<dt>lobe.hemi</dt><dd><p>The lobe-hemisphere combination (represented as an
<em>integer</em> vector)</p>
</dd>
<dt>class</dt><dd><p>The tissue class (if applicable)</p>
</dd>
<dt>network</dt><dd><p>The network (if the atlas is <code>dosenbach160</code>)</p>
</dd>
<dt>x,y,z</dt><dd><p>The spatial coordinates of the (centers-of-mass) brain regions
in MNI space</p>
</dd>
<dt>x.mni,y.mni,z.mni</dt><dd><p>Same as above</p>
</dd>
<dt>color.lobe,color.class,color.network</dt><dd><p>Colors for vertices of their
respective membership</p>
</dd>
<dt>circle.layout</dt><dd><p>Integer vector indicating the order (going
counter-clockwise from the top) for circular layouts</p>
</dd>
</dl>



<h3>Edge attributes</h3>

<p>Edge-level attributes added are:
</p>

<dl>
<dt>color.lobe,color.class,color.network</dt><dd><p>Correspond to the vertex
attribute of the same name. Inter-group edges will be colored
<em>gray</em></p>
</dd>
</dl>



<h3>Specifying a subnetwork</h3>

<p>You can create a graph for a subset of an atlas's regions with the
<code>subnet</code> argument. This can either be a numeric or character vector. If
the input object (either a matrix or an <code>igraph</code> graph) has fewer
rows/columns or vertices, respectively, than the atlas then the <code>subnet</code>
graph attribute will also be added to the return object. This may occur if,
for example, you use <code><a href="#topic+make_auc_brainGraph">make_auc_brainGraph</a></code> on graphs that were
initially created from subnetworks.
</p>


<h3>See Also</h3>

<p>Other Graph creation functions: <code><a href="#topic+Creating_Graphs_GLM">Creating_Graphs_GLM</a></code>,
<code><a href="#topic+brainGraphList">brainGraphList</a></code>,
<code><a href="#topic+make_ego_brainGraph">make_ego_brainGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bg &lt;- make_brainGraph(A, 'dkt', modality='dti', weighting='fa',
  mode='undirected', diag=FALSE, weighted=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Creating_Graphs_GLM'>Create a graph list with GLM-specific attributes</h2><span id='topic+Creating_Graphs_GLM'></span><span id='topic+make_brainGraphList.bg_GLM'></span><span id='topic+make_brainGraphList.mtpc'></span><span id='topic+make_brainGraphList.NBS'></span>

<h3>Description</h3>

<p>These methods create a <code>brainGraphList</code> with attributes specific to the
results of <code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a></code>, <code><a href="#topic+mtpc">mtpc</a></code>, or
<code><a href="#topic+NBS">NBS</a></code>. The <code>graphs</code> element of the returned object will
contain one graph for each contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bg_GLM'
make_brainGraphList(x, atlas = x$atlas,
  type = "observed", level = "contrast", set.attrs = FALSE,
  modality = NULL, weighting = NULL, threshold = NULL,
  gnames = x$con.name, ...)

## S3 method for class 'mtpc'
make_brainGraphList(x, atlas = x$atlas,
  type = "observed", level = "contrast", set.attrs = FALSE,
  modality = NULL, weighting = NULL, threshold = NULL,
  gnames = x$con.name, ...)

## S3 method for class 'NBS'
make_brainGraphList(x, atlas, type = "observed",
  level = "contrast", set.attrs = TRUE, modality = NULL,
  weighting = NULL, threshold = NULL, gnames = x$con.name,
  mode = "undirected", weighted = TRUE, diag = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Creating_Graphs_GLM_+3A_x">x</code></td>
<td>
<p>A <code>bg_GLM</code>, <code>mtpc</code>, or <code>NBS</code> object</p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_atlas">atlas</code></td>
<td>
<p>Character string specifying the brain atlas to use</p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_type">type</code></td>
<td>
<p>Character string indicating the type of graphs. Default:
<code>observed</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_level">level</code></td>
<td>
<p>Character string indicating whether the graphs are subject-,
group-, or contrast-specific. Default: <code>'subject'</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_set.attrs">set.attrs</code></td>
<td>
<p>Logical indicating whether to assign all graph-, vertex-,
and edge-level attributes (via <code><a href="#topic+set_brainGraph_attr">set_brainGraph_attr</a></code>). Default:
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_modality">modality</code></td>
<td>
<p>Character string indicating imaging modality (e.g. 'dti').
Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_weighting">weighting</code></td>
<td>
<p>Character string indicating how the edges are weighted
(e.g., 'fa', 'pearson', etc.). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_threshold">threshold</code></td>
<td>
<p>Integer or number indicating the threshold used when
&ldquo;sparsifying&rdquo; the connectivity matrix (if any). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_gnames">gnames</code></td>
<td>
<p>Character vector of graph names (e.g., study IDs if
<code>level='subject'</code>). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+set_brainGraph_attr">set_brainGraph_attr</a></code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_mode">mode</code></td>
<td>
<p>Character string defining how the matrix should be interpreted.
Default: <code>'undirected'</code></p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_weighted">weighted</code></td>
<td>
<p>Logical specifying whether to create a weighted network</p>
</td></tr>
<tr><td><code id="Creating_Graphs_GLM_+3A_diag">diag</code></td>
<td>
<p>Logical indicating whether to include the diagonal of the
connectivity matrix. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>brainGraphList</code> object, with a graph object for each contrast
with additional attributes:
</p>
<table role = "presentation">
<tr><td><code>Graph</code></td>
<td>
<p><em>name</em> (contrast name), <em>outcome</em> (the outcome
variable), <em>alpha</em> (the significance level); for MTPC:
<em>tau.mtpc</em>, <em>S.mtpc</em>, <em>S.crit</em>, <em>A.crit</em></p>
</td></tr>
<tr><td><code>Vertex</code></td>
<td>
<p><em>size2</em> (t-statistic); <em>size</em> (the t-stat
transformed for visualization purposes); <em>p</em> (equal to <code class="reqn">1-p</code>);
<em>p.fdr</em> (equal to <code class="reqn">1-p_{FDR}</code>, the FDR-adjusted p-value);
<em>effect.size</em> (the contrast of parameter estimates for t-contrasts;
the extra sum of squares for F-contrasts); <em>se</em> (the
standard error of <em>gamma</em>); <em>A.mtpc</em>, <em>sig</em> (binary
indicating whether <code>A.mtpc &gt; A.crit</code>) (for MTPC)</p>
</td></tr>
</table>
<p><code>make_brainGraphList.NBS</code> returns graphs with additional
attributes:
</p>
<table role = "presentation">
<tr><td><code>Vertex</code></td>
<td>
<p><em>comp</em> (integer vector indicating connected component
membership), <em>p.nbs</em> (P-value for each component)</p>
</td></tr>
<tr><td><code>Edge</code></td>
<td>
<p><em>stat</em> (the test statistic for each connection), <em>p</em>
(the P-value)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Only valid for <em>vertex</em>-level and <em>NBS</em> analyses.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a>, <a href="#topic+mtpc">mtpc</a>, <a href="#topic+NBS">NBS</a></code>
</p>
<p>Other Graph creation functions: <code><a href="#topic+Creating_Graphs">Creating_Graphs</a></code>,
<code><a href="#topic+brainGraphList">brainGraphList</a></code>,
<code><a href="#topic+make_ego_brainGraph">make_ego_brainGraph</a></code>
</p>

<hr>
<h2 id='delete_all_attr'>Delete all attributes of a graph</h2><span id='topic+delete_all_attr'></span>

<h3>Description</h3>

<p>Deletes all graph-, vertex-, and edge-level attributes of an <code>igraph</code>
graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_all_attr(g, keep.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete_all_attr_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="delete_all_attr_+3A_keep.names">keep.names</code></td>
<td>
<p>Logical indicating whether to keep the <code>name</code> vertex
attribute (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>igraph</code> graph object
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+delete_graph_attr">delete_graph_attr</a>,
  <a href="igraph.html#topic+delete_vertex_attr">delete_vertex_attr</a>, <a href="igraph.html#topic+delete_edge_attr">delete_edge_attr</a></code>
</p>

<hr>
<h2 id='dir2files'>Return a vector of filenames based on a directory name or options list</h2><span id='topic+dir2files'></span>

<h3>Description</h3>

<p>Return a vector of filenames based on a directory name or options list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir2files(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dir2files_+3A_x">x</code></td>
<td>
<p>Either a character string specifying a directory or a list of
arguments to be passed to <code><a href="base.html#topic+list.files">list.files</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='edge_asymmetry'>Calculate an asymmetry index based on edge counts</h2><span id='topic+edge_asymmetry'></span>

<h3>Description</h3>

<p>Calculate an <em>asymmetry index</em>, a ratio of intra-hemispheric edges in
the left to right hemisphere of a graph for brain MRI data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_asymmetry(g, level = c("hemi", "vertex"), A = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge_asymmetry_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="edge_asymmetry_+3A_level">level</code></td>
<td>
<p>Character string indicating whether to calculate asymmetry for
each region, or the hemisphere as a whole (default: <code>'hemi'</code>)</p>
</td></tr>
<tr><td><code id="edge_asymmetry_+3A_a">A</code></td>
<td>
<p>Numeric matrix; the adjacency matrix of the input graph. Default:
<code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation is:
</p>
<p style="text-align: center;"><code class="reqn">A = \frac{E_{lh} - E_{rh}}{0.5 \times (E_{lh} + E_{rh})}</code>
</p>

<p>where <em>lh</em> and <em>rh</em> are left and right hemispheres, respectively.
The range of this measure is <code class="reqn">[-2, 2]</code> (although the limits will only be
reached if all edges are in one hemisphere), with negative numbers
indicating more edges in the right hemisphere, and a value of 0 indicating
equal number of edges in each hemisphere.
</p>
<p>The <code>level</code> argument specifies whether to calculate asymmetry for each
vertex, or for the whole hemisphere.
</p>


<h3>Value</h3>

<p>A data table with edge counts for both hemispheres and the asymmetry
index; if <code>level</code> is <em>vertex</em>, the data table will have
<code>vcount(g)</code> rows.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>

<hr>
<h2 id='efficiency'>Calculate graph global, local, or nodal efficiency</h2><span id='topic+efficiency'></span>

<h3>Description</h3>

<p>This function calculates the global efficiency of a graph or the local or
nodal efficiency of each vertex of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiency(g, type = c("local", "nodal", "global"), weights = NULL,
  xfm = FALSE, xfm.type = NULL, use.parallel = TRUE, A = NULL,
  D = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="efficiency_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="efficiency_+3A_type">type</code></td>
<td>
<p>Character string; either <code>local</code>, <code>nodal</code>, or
<code>global</code>. Default: <code>local</code></p>
</td></tr>
<tr><td><code id="efficiency_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of edge weights; if <code>NULL</code> (the default),
and if the graph has edge attribute <code>weight</code>, then that will be used.
To avoid using weights, this should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_xfm">xfm</code></td>
<td>
<p>Logical indicating whether to transform the edge weights. Default:
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="efficiency_+3A_xfm.type">xfm.type</code></td>
<td>
<p>Character string specifying how to transform the weights.
Default: <code>1/w</code></p>
</td></tr>
<tr><td><code id="efficiency_+3A_use.parallel">use.parallel</code></td>
<td>
<p>Logical indicating whether or not to use <code>foreach</code>.
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="efficiency_+3A_a">A</code></td>
<td>
<p>Numeric matrix; the adjacency matrix of the input graph. Default:
<code>NULL</code></p>
</td></tr>
<tr><td><code id="efficiency_+3A_d">D</code></td>
<td>
<p>Numeric matrix; the graph's &ldquo;distance matrix&rdquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local efficiency for vertex <em>i</em> is:
</p>
<p style="text-align: center;"><code class="reqn">E_{local}(i) = \frac{1}{N} \sum_{i \in G} E_{global}(G_i)</code>
</p>

<p>where <code class="reqn">G_i</code> is the subgraph of neighbors of <em>i</em>, and <em>N</em> is the
number of vertices in that subgraph.
</p>
<p>Nodal efficiency for vertex <em>i</em> is:
</p>
<p style="text-align: center;"><code class="reqn">E_{nodal}(i) = \frac{1}{N-1} \sum_{j \in G} \frac{1}{d_{ij}}</code>
</p>

<p>Global efficiency for graph <em>G</em> with <em>N</em> vertices is:
</p>
<p style="text-align: center;"><code class="reqn">E_{global}(G) = \frac{1}{N(N-1)} \sum_{i \ne j \in G} \frac{1}{d_{ij}}</code>
</p>

<p>where <code class="reqn">d_{ij}</code> is the shortest path length between vertices <em>i</em> and
<em>j</em>. Alternatively, global efficiency is equal to the mean of all nodal
efficiencies.
</p>


<h3>Value</h3>

<p>A numeric vector of the efficiencies for each vertex of the graph
(if <em>type</em> is <code>local|nodal</code>) or a single number (if <em>type</em>
is <code>global</code>).
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Latora, V. and Marchiori, M. (2001) Efficient behavior of
small-world networks. <em>Phys Rev Lett</em>, <b>87.19</b>, 198701.
doi: <a href="https://doi.org/10.1103/PhysRevLett.87.198701">10.1103/PhysRevLett.87.198701</a>
</p>
<p>Latora, V. and Marchiori, M. (2003) Economic small-world
behavior in weighted networks. <em>Eur Phys J B</em>, <b>32</b>, 249&ndash;263.
doi: <a href="https://doi.org/10.1140/epjb/e2003-00095-5">10.1140/epjb/e2003-00095-5</a>
</p>

<hr>
<h2 id='get_rand_attrs'>Convenience function to get attributes for lists of random graphs</h2><span id='topic+get_rand_attrs'></span>

<h3>Description</h3>

<p>Convenience function to get attributes for lists of random graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rand_attrs(bg.list, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_rand_attrs_+3A_bg.list">bg.list</code></td>
<td>
<p>A <code>brainGraphList</code> object, created in
<code><a href="#topic+analysis_random_graphs">analysis_random_graphs</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code>
</p>

<hr>
<h2 id='GLM'>Fit General Linear Models at each vertex of a graph</h2><span id='topic+GLM'></span><span id='topic+brainGraph_GLM'></span><span id='topic+print.bg_GLM'></span><span id='topic+summary.bg_GLM'></span><span id='topic+plot.bg_GLM'></span><span id='topic++5B.bg_GLM'></span>

<h3>Description</h3>

<p><code>brainGraph_GLM</code> specifies and fits a General Linear Model (GLM) at each
vertex for a given vertex measure (e.g. <em>degree</em>) or at the graph-level
(e.g., <em>global efficiency</em>). Given a contrast matrix or list of
contrast(s), and contrast type (for t- or F-contrast(s), respectively) it
will calculate the associated statistic(s) for the given contrast(s).
</p>
<p>The <code>summary</code> method prints the results, only for which
<code class="reqn">p &lt; \alpha</code>, where <code>alpha</code> comes from the <code>bg_GLM</code> object.
&ldquo;Simple&rdquo; P-values are used by default, but you may change this to the
FDR-adjusted or permutation P-values via the function argument <code>p.sig</code>.
You may also choose to subset by <em>contrast</em>.
</p>
<p>The <code>plot</code> method plots the GLM diagnostics (similar to that of
<code><a href="stats.html#topic+plot.lm">plot.lm</a></code>). There are a total of 6 possible plots,
specified by the <code>which</code> argument; the behavior is the same as in
<code><a href="stats.html#topic+plot.lm">plot.lm</a></code>. Please see the help for that function.
</p>
<p>The <code>[</code> method allows you to select observations (i.e., rows of <code>X</code>
and <code>y</code>) and independent variables (i.e., columns of <code>X</code>) from a
<code>bg_GLM</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainGraph_GLM(g.list, covars, measure, contrasts, con.type = c("t",
  "f"), outcome = NULL, X = NULL, con.name = NULL,
  alternative = c("two.sided", "less", "greater"), alpha = 0.05,
  level = c("vertex", "graph"), permute = FALSE,
  perm.method = c("freedmanLane", "terBraak", "smith", "draperStoneman",
  "manly", "stillWhite"), part.method = c("beckmann", "guttman",
  "ridgway"), N = 5000, perms = NULL, long = FALSE, ...)

## S3 method for class 'bg_GLM'
print(x, ...)

## S3 method for class 'bg_GLM'
summary(object, p.sig = c("p", "p.fdr", "p.perm"),
  contrast = NULL, alpha = object$alpha, digits = max(3L,
  getOption("digits") - 2L), print.head = TRUE, ...)

## S3 method for class 'bg_GLM'
plot(x, region = NULL, which = c(1L:3L, 5L),
  ids = TRUE, ...)

## S3 method for class 'bg_GLM'
x[i, j]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM_+3A_g.list">g.list</code></td>
<td>
<p>A <code>brainGraphList</code> object</p>
</td></tr>
<tr><td><code id="GLM_+3A_covars">covars</code></td>
<td>
<p>A <code>data.table</code> of covariates</p>
</td></tr>
<tr><td><code id="GLM_+3A_measure">measure</code></td>
<td>
<p>Character string of the graph measure of interest</p>
</td></tr>
<tr><td><code id="GLM_+3A_contrasts">contrasts</code></td>
<td>
<p>Numeric matrix (for T statistics) or list of matrices (for F
statistics) specifying the contrast(s) of interest; if only one contrast is
desired, you can supply a vector (for T statistics)</p>
</td></tr>
<tr><td><code id="GLM_+3A_con.type">con.type</code></td>
<td>
<p>Character string; either <code>'t'</code> or <code>'f'</code> (for t or
F-statistics). Default: <code>'t'</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_outcome">outcome</code></td>
<td>
<p>Character string specifying the name of the outcome variable,
if it differs from the graph metric (<code>measure</code>)</p>
</td></tr>
<tr><td><code id="GLM_+3A_x">X</code></td>
<td>
<p>Numeric matrix, if you wish to supply your own design matrix.
Ignored if <code>outcome != measure</code>.</p>
</td></tr>
<tr><td><code id="GLM_+3A_con.name">con.name</code></td>
<td>
<p>Character vector of the contrast name(s); if <code>contrasts</code>
has row/list names, those will be used for reporting results</p>
</td></tr>
<tr><td><code id="GLM_+3A_alternative">alternative</code></td>
<td>
<p>Character string, whether to do a two- or one-sided test.
Default: <code>'two.sided'</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; the significance level. Default: 0.05</p>
</td></tr>
<tr><td><code id="GLM_+3A_level">level</code></td>
<td>
<p>Character string; either <code>vertex</code> (default) or
<code>graph</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_permute">permute</code></td>
<td>
<p>Logical indicating whether or not to permute group labels.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_perm.method">perm.method</code></td>
<td>
<p>Character string indicating the permutation method.
Default: <code>'freedmanLane'</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_part.method">part.method</code></td>
<td>
<p>Character string; the method of partitioning the design
matrix into covariates of interest and nuisance. Default: <code>'beckmann'</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_n">N</code></td>
<td>
<p>Integer; number of permutations to create. Default: <code>5e3</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_perms">perms</code></td>
<td>
<p>Matrix of permutations, if you would like to provide your own.
Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_long">long</code></td>
<td>
<p>Logical indicating whether or not to return all permutation
results. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+brainGraph_GLM_design">brainGraph_GLM_design</a></code></p>
</td></tr>
<tr><td><code id="GLM_+3A_object">object</code>, <code id="GLM_+3A_x">x</code></td>
<td>
<p>A <code>bg_GLM</code> object</p>
</td></tr>
<tr><td><code id="GLM_+3A_p.sig">p.sig</code></td>
<td>
<p>Character string specifying which P-value to use for displaying
significant results (default: <code>p</code>)</p>
</td></tr>
<tr><td><code id="GLM_+3A_contrast">contrast</code></td>
<td>
<p>Integer specifying the contrast to plot/summarize; defaults
to showing results for all contrasts</p>
</td></tr>
<tr><td><code id="GLM_+3A_digits">digits</code></td>
<td>
<p>Integer specifying the number of digits to display for P-values</p>
</td></tr>
<tr><td><code id="GLM_+3A_print.head">print.head</code></td>
<td>
<p>Logical indicating whether or not to print only the first
and last 5 rows of the statistics tables (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="GLM_+3A_region">region</code></td>
<td>
<p>Character string specifying which region's results to
plot; only relevant if <code>level='vertex'</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_which">which</code></td>
<td>
<p>Integer vector indicating which of the 6 plots to print to the
plot device. Default: <code>c(1:3, 5)</code></p>
</td></tr>
<tr><td><code id="GLM_+3A_ids">ids</code></td>
<td>
<p>Logical indicating whether to plot subject ID's for outliers.
Otherwise plots the integer index</p>
</td></tr>
<tr><td><code id="GLM_+3A_i">i</code></td>
<td>
<p>Integer/character vector; the observation number(s) or row names to
select or remove</p>
</td></tr>
<tr><td><code id="GLM_+3A_j">j</code></td>
<td>
<p>Integer/character vector; the design matrix column number(s) or
names to select or remove</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>measure</code> argument will be the graph- or vertex-level measure of
interest. Often, this will serve as the model's <em>outcome</em> (or dependent,
or response) variable; i.e., the variable typically denoted by <em>y</em> in
GLMs. In other cases, you may wish to choose some other variable as the
outcome; e.g., IQ, age, etc. Then you could test for a direct association
between the network measure and outcome of interest, or test for another
association while adjusting for the network metric. For these applications,
you must provide the variable name via the <code>outcome</code> argument. This is
analogous to <code>-evperdat</code> in FSL's PALM and to <code>--pvr</code> in
FreeSurfer.
</p>


<h3>Value</h3>

<p>An object of class <code>bg_GLM</code> containing some input-specific
variables (<code>level</code>, <code>outcome</code>, <code>measure</code>, <code>con.type</code>,
<code>contrasts</code>, <code>con.name</code>, <code>alt</code>, <code>alpha</code>,
<code>permute</code>, <code>perm.method</code>, <code>part.method</code>, <code>N</code>) in
addition to:
</p>
<table role = "presentation">
<tr><td><code>DT.Xy</code></td>
<td>
<p>A data table from which the design matrices are created and
the outcome variable, for all regions.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>A named numeric matrix or a 3D array of the design matrix.
Rownames are subject IDs, column names are predictor variables, and
dimnames along the 3rd dimension are region names (if applicable). This
is a 3D array only if <code>outcome != measure</code> and <code>level ==
    'vertex'</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A named numeric matrix of the outcome variable. Rownames are Study
IDs and column names are regions. There will be multiple columns only if
<code>outcome == measure</code> and <code>level == 'vertex'</code>.</p>
</td></tr>
<tr><td><code>DT</code></td>
<td>
<p>A data table with an entry for each vertex (region) containing
statistics of interest</p>
</td></tr>
<tr><td><code>removed.subs</code></td>
<td>
<p>A named integer vector in which the names are subject
ID's of those removed due to incomplete data (if any). The integers
correspond to the row number in the input <code>covars</code> table.</p>
</td></tr>
<tr><td><code>runX</code></td>
<td>
<p>If <code>outcome != measure</code> and <code>level == 'vertex'</code>, this
will be a character vector of the regions for which the design matrix is
invertible. Otherwise, it is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>runY</code></td>
<td>
<p>Character vector of the regions for which the outcome variable
has 0 variability. For example, if <code>level='vertex'</code> and
<code>measure='degree'</code>, some regions may be disconnected or have the
same degree for all subjects.</p>
</td></tr>
<tr><td><code>atlas</code></td>
<td>
<p>Character string of the atlas used (guessed based on the
vertex count).</p>
</td></tr>
<tr><td><code>perm</code></td>
<td>
<p>A list containing: <em>null.dist</em> (the null distribution of
maximum statistics), <em>thresh</em> (the statistic value corresponding
to the <code class="reqn">100 \times (1 - \alpha)</code>th% percentile of the null
distribution)</p>
</td></tr>
</table>
<p>The <code>plot</code> method returns a <em>list</em> of <code>ggplot</code> objects
(if installed) or writes the plots to a PDF in the current directory named
<code>bg_GLM_diagnostics.pdf</code>
</p>
<p>A <code>bg_GLM</code> object with the specified row(s) selected or removed
from both <code>X</code> and <code>y</code>, and column(s) selected/removed from
<code>X</code>
</p>


<h3>Design matrix</h3>

<p>The GLM's <em>design matrix</em> will often be identical to the <em>model
matrix</em> associated with <code>lm</code> objects (if &ldquo;dummy&rdquo; coding, the
default, is used) and is created from the input <code>data.table</code> and
arguments passed to <code><a href="#topic+brainGraph_GLM_design">brainGraph_GLM_design</a></code>. The first column
should have the name of <code>getOption('bg.subject_id')</code> and its values
must match the <em>name</em> graph-level attribute of the input graphs. The
covariates table must be supplied even if you provide your own design matrix
<code>X</code>.  If <code>level='vertex'</code> and <code>outcome == measure</code>, there will
be a single design for all regions but a separate model for each region
(since the graph measure varies by region). If <code>level='vertex'</code> and
<code>outcome != measure</code>, there will be a separate design (and, therefore, a
separate model) for each region even though the outcome is the same in all
models.
</p>


<h3>Contrasts and statistics</h3>

<p>Either t- or F-contrasts can be calculated (specified by <code>con.type</code>).
Multiple t-contrasts can be specified by passing a multi-row <em>matrix</em> to
<code>contrasts</code>. Multiple F-contrasts can be specified by passing a
<em>list</em> of matrices; all matrices must have the same number of columns.
All F-contrasts are necessarily <em>two-sided</em>; t-contrasts can be any
direction, but only one can be chosen per function call.
If you choose <code>con.type="f"</code>, the calculated effect size is represented
by the <code>ESS</code> (&ldquo;extra sum of squares&rdquo;), the additional variance
explained for by the model parameters of interest (as determined by the
contrast matrix). The standard error for F-contrasts is the sum of squared
errors of the <em>full model</em>.
</p>


<h3>Non-parametric permutation tests</h3>

<p>You can calculate permutations of the data to build a null distribution of
the maximum statistic which corrects for multiple testing. To account for
complex designs, the design matrix must be <em>partitioned</em> into covariates
of interest and nuisance; the default method is the <em>Beckmann</em> method.
The default permutation strategy is that of Freedman &amp; Lane (1983), and is
the same as that in FSL's <em>randomise</em>. See <code><a href="#topic+randomise">randomise</a></code>.
</p>


<h3>Note</h3>

<p>The <code>[</code> method is used when calculating <em>studentized
residuals</em> and other &ldquo;leave-one-out&rdquo; diagnostics, and typically should
not be called directly by the user.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.lm">plot.lm</a></code>
</p>
<p>Other GLM functions: <code><a href="#topic+GLM+20design">GLM design</a></code>,
<code><a href="#topic+GLM+20fits">GLM fits</a></code>, <code><a href="#topic+mtpc">mtpc</a></code>
</p>
<p>Other Group analysis functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+Mediation">Mediation</a></code>, <code><a href="#topic+NBS">NBS</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>, <code><a href="#topic+mtpc">mtpc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
conmat &lt;- matrix(c(0, 0, 0, 1), nrow=1)
rownames(conmat) &lt;- 'Control &gt; Patient'

res.lm &lt;- brainGraph_GLM(g[[6]], covars=covars.all[tract == 1],
  measure='strength', contrasts=conmat, alt='greater', permute=TRUE, long=TRUE)

## End(Not run)
## Not run: 
## Save objects and then to multipage PDF
lmPlots &lt;- plot(x)
ggsave('lmPlots.pdf', lmPlots)

## Save all the GLM sub-objects from MTPC analysis
res.mtpc &lt;- mtpc(...)
glmPlots &lt;- lapply(res.mtpc$res.glm, plot, which=1:6)
ml &lt;- marrangeGrob(glmPlots, nrow=1, ncol=1)
ggsave('glmPlots.pdf', ml, width=8.5, height=11)

## End(Not run)
</code></pre>

<hr>
<h2 id='GLM+20basic+20info'>Extract basic information from a bg_GLM object</h2><span id='topic+GLM+20basic+20info'></span><span id='topic+nobs.bg_GLM'></span><span id='topic+terms.bg_GLM'></span><span id='topic+formula.bg_GLM'></span><span id='topic+labels.bg_GLM'></span><span id='topic+case.names.bg_GLM'></span><span id='topic+variable.names.bg_GLM'></span><span id='topic+region.names.bg_GLM'></span><span id='topic+nregions.bg_GLM'></span>

<h3>Description</h3>

<p>These functions return the <code>terms</code>, <em>term labels</em>, <em>model
formula</em>, &ldquo;case names&rdquo;, &ldquo;variable names&rdquo;, <em>region names</em>,
and number of observations for a <code>bg_GLM</code> object. The term labels are
used for ANOVA tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bg_GLM'
nobs(object, ...)

## S3 method for class 'bg_GLM'
terms(x, ...)

## S3 method for class 'bg_GLM'
formula(x, ...)

## S3 method for class 'bg_GLM'
labels(object, ...)

## S3 method for class 'bg_GLM'
case.names(object, ...)

## S3 method for class 'bg_GLM'
variable.names(object, ...)

## S3 method for class 'bg_GLM'
region.names(object)

## S3 method for class 'bg_GLM'
nregions(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM+2B20basic+2B20info_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="GLM+2B20basic+2B20info_+3A_x">x</code>, <code id="GLM+2B20basic+2B20info_+3A_object">object</code></td>
<td>
<p>A <code>bg_GLM</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>terms</code> returns a named integer list in which the names are the
term labels and the list elements are the column(s) of the design matrix
for each term. <code>nobs</code> returns an integer. The other functions return
character vectors.
</p>


<h3>Note</h3>

<p><code>formula</code> returns a character string, not a <code>formula</code>
object.
</p>

<hr>
<h2 id='GLM+20design'>Create a design matrix for linear model analysis</h2><span id='topic+GLM+20design'></span><span id='topic+brainGraph_GLM_design'></span>

<h3>Description</h3>

<p><code>brainGraph_GLM_design</code> takes a <code>data.table</code> of covariates and
returns a <em>design matrix</em> to be used in linear model analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainGraph_GLM_design(covars, coding = c("dummy", "effects",
  "cell.means"), factorize = TRUE, binarize = NULL, int = NULL,
  mean.center = FALSE, center.how = c("all", "within-groups"),
  center.by = getOption("bg.group"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM+2B20design_+3A_covars">covars</code></td>
<td>
<p>A <code>data.table</code> of covariates</p>
</td></tr>
<tr><td><code id="GLM+2B20design_+3A_coding">coding</code></td>
<td>
<p>Character string indicating how factor variables will be coded.
Default: <code>'dummy'</code></p>
</td></tr>
<tr><td><code id="GLM+2B20design_+3A_factorize">factorize</code></td>
<td>
<p>Logical indicating whether to convert <em>character</em>
columns into <em>factor</em>. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="GLM+2B20design_+3A_binarize">binarize</code></td>
<td>
<p>Character vector specifying the column name(s) of the
covariate(s) to be converted from type <code>factor</code> to <code>numeric</code>.
Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="GLM+2B20design_+3A_int">int</code></td>
<td>
<p>Character vector specifying the column name(s) of the
covariate(s) to test for an interaction. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="GLM+2B20design_+3A_mean.center">mean.center</code></td>
<td>
<p>Logical indicating whether to mean center non-factor
variables. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="GLM+2B20design_+3A_center.how">center.how</code></td>
<td>
<p>Character string indicating whether to use the grand mean
or groupwise means. Default: <code>'all'</code></p>
</td></tr>
<tr><td><code id="GLM+2B20design_+3A_center.by">center.by</code></td>
<td>
<p>Character string indicating which grouping variable to use
for calculating means (if applicable). Default: <code>'Group'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three different ways to code factors: <em>dummy</em>, <em>effects</em>,
or <em>cell-means</em> (chosen by the argument <code>coding</code>). <em>Effects</em>
coding is sometimes referred to as <em>deviation</em> coding. <em>Dummy</em>
coding is the default when calling <code>lm</code>. To understand the difference
between these, see Chapter 8 of the User Guide.
</p>


<h3>Value</h3>

<p>A numeric matrix. Rownames are subject ID's and column names are the
variable names. There will be additional attributes recording the
<code>coding</code>, <code>factorize</code>, and <code>mean.center</code> function arguments.
There will also be attributes for <code>binarize</code> and <code>int</code> if they
are not <code>NULL</code>, and <code>center.how</code> and <code>center.by</code> if
<code>mean.center=TRUE</code>.
</p>


<h3>Character variables</h3>

<p>The default behavior is to convert all character columns (excluding the Study
ID column and any that you list in the <code>binarize</code> argument) to factor
variables. To change this, set <code>factorize=FALSE</code>. So, if your covariates
include multiple character columns, but you want to convert <em>Scanner</em> to
binary instead of a factor, you may still specify <code>binarize='Scanner'</code>
and get the expected result. <code>binarize</code> will convert the given factor
variable(s) into numeric variable(s), which is performed <em>before</em>
centering (if applicable).
</p>


<h3>Centering</h3>

<p>The argument <code>mean.center</code> will mean-center (i.e., subtract the mean of
from each variable) any non-factor variables (including any dummy/indicator
covariates). This is done <em>after</em> &ldquo;factorizing&rdquo; and
&ldquo;binarizing&rdquo;. If <code>center.how='all'</code>, then the &ldquo;grand mean&rdquo;
will be used; otherwise, the groupwise means will be used. The grouping
variable is determined by <code>center.by</code> and is by default <code>'Group'</code>.
</p>


<h3>Interactions</h3>

<p><code>int</code> specifies which variables should interact with one another. This
argument accepts both numeric/continuous (e.g., <em>Age</em>) and factor
variables (e.g., <em>Sex</em>). All interaction combinations will be generated:
if you supply 3 variables, all two-way and the single three-way interaction
will be generated. This variable <em>must</em> have at least two elements; it
is otherwise ignored. It is generally recommended that centering be performed
when including interaction terms.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other GLM functions: <code><a href="#topic+GLM+20fits">GLM fits</a></code>,
<code><a href="#topic+GLM">GLM</a></code>, <code><a href="#topic+mtpc">mtpc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Recreate design matrix when "outcome == measure"
DT &lt;- res.glm$DT.Xy[region == levels(region)[1L],
                    !c('region', res.glm$outcome),
                    with=FALSE]
X &lt;- do.call(brainGraph_GLM_design, c(list(covars=DT),
                                      attributes(res.glm$X)[-c(1L, 2L)]))
all.equal(X, res.glm$X)

## End(Not run)
</code></pre>

<hr>
<h2 id='GLM+20fits'>Fit design matrices to one or multiple outcomes</h2><span id='topic+GLM+20fits'></span><span id='topic+fastLmBG'></span><span id='topic+fastLmBG_3d'></span><span id='topic+fastLmBG_3dY'></span><span id='topic+fastLmBG_3dY_1p'></span><span id='topic+fastLmBG_t'></span><span id='topic+fastLmBG_f'></span>

<h3>Description</h3>

<p>These are the &ldquo;base&rdquo; model-fitting functions that solve the
<em>least squares problem</em> to estimate model coefficients, residuals, etc.
for brain network data.
</p>
<p><code>fastLmBG_t</code> and <code>fastLmBG_f</code> calculate contrast-based statistics
for T or F contrasts, respectively. It accepts any number of <em>contrasts</em>
(i.e., a multi-row contrast matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastLmBG(X, Y, QR = qr.default(X), Q = qr_Q2(QR, n = n, p = p),
  R = qr_R2(QR, p), n = dim(X)[1L], p = QR$rank, ny = dim(Y)[2L],
  dfR = n - p, XtXinv = inv(QR))

fastLmBG_3d(X, Y, runX, QR = qr(X[, , runX, drop = FALSE]),
  Q = lapply(QR, qr_Q2, n = n, p = p), R = lapply(QR, qr_R2, p),
  n = dim(X)[1L], p = QR[[1L]]$rank, ny = length(runX), dfR = n -
  p, XtXinv = inv(QR))

fastLmBG_3dY(X, Y, runX, QR = qr(X[, , runX, drop = FALSE]),
  Q = lapply(QR, qr_Q2, n = n, p = p), R = lapply(QR, qr_R2, p),
  n = dim(X)[1L], p = QR[[1L]]$rank, ny = length(runX), dfR = n -
  p, XtXinv = inv(QR))

fastLmBG_3dY_1p(X, Y, runX, QR = qr(X[, , runX, drop = FALSE]),
  Q = lapply(QR, qr_Q2, diag(1L, n, 1L), n, 1L), R = lapply(QR,
  function(r) r$qr[1L]), n = dim(X)[1L], p = 1L, ny = length(runX),
  dfR = n - 1L, XtXinv = inv(QR))

fastLmBG_t(fits, contrasts, alternative = c("two.sided", "less",
  "greater"), alpha = NULL)

fastLmBG_f(fits, contrasts, rkC = NULL, nC = length(contrasts))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM+2B20fits_+3A_x">X</code></td>
<td>
<p>Design matrix or 3D array of design matrices</p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_y">Y</code></td>
<td>
<p>Numeric matrix; there should be 1 column for each outcome variable
(so that in a graph-level analysis, this is a column matrix)</p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_qr">QR</code>, <code id="GLM+2B20fits_+3A_q">Q</code>, <code id="GLM+2B20fits_+3A_r">R</code></td>
<td>
<p>The QR decomposition(s) and Q and R matrix(es) of the design
matrix(es). If <code>X</code> is a 3D array, these should be <em>lists</em></p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_n">n</code>, <code id="GLM+2B20fits_+3A_p">p</code>, <code id="GLM+2B20fits_+3A_ny">ny</code>, <code id="GLM+2B20fits_+3A_dfr">dfR</code></td>
<td>
<p>Integers; the number of observations, model <em>rank</em>,
number of regions/outcome variables, and residual degrees of freedom</p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_xtxinv">XtXinv</code></td>
<td>
<p>Numeric matrix or array; the inverse of the cross-product of
the design matrix(es)</p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_runx">runX</code></td>
<td>
<p>Character vector of the regions for which the design matrix is
not singular</p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_fits">fits</code></td>
<td>
<p>List object output by one of the model fitting functions (e.g.,
<code>fastLmBG</code>)</p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_contrasts">contrasts</code></td>
<td>
<p>Numeric matrix (for T statistics) or list of matrices (for F
statistics) specifying the contrast(s) of interest; if only one contrast is
desired, you can supply a vector (for T statistics)</p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_alternative">alternative</code></td>
<td>
<p>Character string, whether to do a two- or one-sided test.
Default: <code>'two.sided'</code></p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; the significance level. Default: 0.05</p>
</td></tr>
<tr><td><code id="GLM+2B20fits_+3A_rkc">rkC</code>, <code id="GLM+2B20fits_+3A_nc">nC</code></td>
<td>
<p>Integers; the rank of the contrast matrix and number of
contrasts, respectively (for F contrasts)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>Parameter estimates</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Model rank</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Model residuals</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The residual standard deviation, or <em>root mean square
error (RMSE)</em></p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Model fitted values</p>
</td></tr>
<tr><td><code>qr</code></td>
<td>
<p>The design matrix QR decomposition(s)</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>The &ldquo;unscaled covariance matrix&rdquo;</p>
</td></tr>
</table>
<p><code>fastLmBG_t</code> &ndash; A multidimensional array with the third
dimension equaling the number of contrasts; each matrix contains the
contrast of parameter estimates, standard error of the contrast,
T-statistics, P-values, FDR-adjusted P-values, and confidence intervals (if
<code>alpha</code> is given)
</p>
<p><code>fastLmBG_f</code> &ndash; A numeric matrix with columns for the effect
size, standard error, F statistic, P-values, and FDR-adjusted P-values
</p>


<h3>Parameter estimation</h3>

<p>These functions use the <em>QR</em> decomposition to calculate the least
squares solution which is the same as the base <code><a href="stats.html#topic+lm">lm</a></code>
function. If we substitute <code class="reqn">X = QR</code> in the standard normal equations, the
equation to be solved reduces to
</p>
<p style="text-align: center;"><code class="reqn">X^T X \hat{\beta} = X^T y \Rightarrow R \hat{\beta} = Q^T y</code>
</p>

<p>Since <code>R</code> is an <em>upper-triangular</em> matrix, we can use the
<code><a href="base.html#topic+backsolve">backsolve</a></code> function which is a bit faster than
<code><a href="base.html#topic+solve">solve</a></code>. In some cases, the <code>fastLmBG*</code> functions are about
as fast or faster (particularly when <code>X</code> is not permuted) as one in
which the normal equations are solved directly; additionally, using the
<em>QR</em> method affords greater numerical stability.
</p>


<h3>Different scenarios</h3>

<p>There are a few different scenarios for fitting models of the data, with a
separate function for each:
</p>

<dl>
<dt>fastLmBG</dt><dd><p>The main function for when there is a single design matrix
<code class="reqn">X</code> and any number of outcome variables <code class="reqn">Y</code>.</p>
</dd>
<dt>fastLmBG_3d</dt><dd><p>Fits models when there is a different design matrix
<code class="reqn">X</code> for each region and a single outcome variable <code class="reqn">Y</code>, which in
this case will be a column matrix.</p>
</dd>
<dt>fastLmBG_3dY</dt><dd><p>Fits models when there is both a different design
matrix <code class="reqn">X</code> and outcome variable <code class="reqn">Y</code> for each region. Occurs under
permutation for the Freedman-Lane, ter Braak, and Still-White methods.</p>
</dd>
<dt>fastLmBG_3dY_1p</dt><dd><p>Fits models when there is both a different design
and outcome variable for each region, and also when <code class="reqn">X</code> is a rank-1
matrix (i.e., it has 1 column). Only occurs under permutation with the
Still-White method if there is a single regressor of interest.</p>
</dd>
</dl>

<p>In the last case above, model coefficients are calculated by simple (i.e.,
non-matrix) algebra.
</p>


<h3>Improving speed/efficiency</h3>

<p>Speed/efficiency gains will be vast for analyses in which there is a single
design matrix <code class="reqn">X</code> for all regions, there are multiple outcome variables
(i.e., vertex-level analysis), and the permutation method chosen does
not permute <code class="reqn">X</code>. Specifically, these are <em>Freedman-Lane</em>, <em>ter
Braak</em>, and <em>Manly</em> methods. Therefore, the QR decomposition, the
<code class="reqn">Q</code> and <code class="reqn">R</code> matrices, and the &ldquo;unscaled covariance matrix&rdquo;
(which is <code class="reqn">(X^T X)^{-1}</code>) only need to be calculated once for the entire
analysis. Other functions (e.g., <code>lm.fit</code>) would recalculate these for
each permutation.
</p>
<p>Furthermore, this (and the other model fitting functions in the package) will
likely only work in models with full rank. I sacrifice proper error checking
in favor of speed, but hopefully any issues with the model will be identified
prior to the permutation step. Finally, the number of observations, model
rank, number of outcome variables, and degrees of freedom will not change and
therefore do not need to be recalculated (although these probably amount to a
negligible speed boost).
</p>
<p>In case there are multiple design matrices, or the permutation method
permutes the design, then the QR decomposition will need to be calculated
each time anyway. For these cases, I use more simplified functions
<code>qr_Q2</code> and <code>qr_R2</code> to calculate the <code class="reqn">Q</code> and <code class="reqn">R</code> matrices,
and then the fitted values, residuals, and residual standard deviation are
calculated at the same time (whereas <code>lm.fit</code> and others would calculate
these each time).
</p>


<h3>Contrast-based statistics</h3>

<p>The <em>contrast of parameter estimates</em>, <code class="reqn">\gamma</code>, for T contrasts is
</p>
<p style="text-align: center;"><code class="reqn">\gamma = C \hat{\beta}</code>
</p>

<p>where <code class="reqn">C</code> is the contrast matrix with size <code class="reqn">k \times p</code> (where
<code class="reqn">k</code> is the number of contrasts) and <code class="reqn">\hat{\beta}</code> is the matrix of
parameter estimates with size <code class="reqn">p \times r</code> (where <code class="reqn">r</code> is the number
of regions). For F contrasts, the effect size is the <em>extra sum of
squares</em> and is calculated as
</p>
<p style="text-align: center;"><code class="reqn">\gamma (C (X^T X)^{-1} C^T)^{-1} \gamma^T</code>
</p>

<p>The <em>standard error</em> of a T contrast is
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\hat{\sigma} (X^T X)^{-1}}</code>
</p>

<p>where <code class="reqn">\hat{\sigma}</code> is the <em>residual standard deviation</em> of the
model and the second term is the unscaled covariance matrix. The standard
error for F contrasts is simply the <em>residual sum of squares</em>. P-values
and FDR-adjusted P-values (across regions) are also calculated. Finally, if
<code class="reqn">\alpha</code> is provided for T contrasts, confidence limits are calculated.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>randomise
</p>
<p>Other GLM functions: <code><a href="#topic+GLM+20design">GLM design</a></code>,
<code><a href="#topic+GLM">GLM</a></code>, <code><a href="#topic+mtpc">mtpc</a></code>
</p>

<hr>
<h2 id='GLM+20helpers'>Helper functions to set-up for GLM analyses</h2><span id='topic+GLM+20helpers'></span><span id='topic+setup_glm'></span><span id='topic+contrast_names'></span><span id='topic+check_if_singular'></span><span id='topic+add_nans'></span><span id='topic+cxtxfun_3d'></span><span id='topic+glm_data_table'></span><span id='topic+matrix2list'></span><span id='topic+maxfun'></span><span id='topic+sortfun'></span>

<h3>Description</h3>

<p><code>setup_glm</code> is used to setup the data/objects for any function that uses
the main GLM functionality in <code>brainGraph</code>.
</p>
<p><code>contrast_names</code> checks the dimensions of contrasts, generates contrast
names, and sets column names for GLM functions. For F-contrasts, if a
<code>matrix</code> is given, it converts it to a <code>list</code> to simplify processing
later.
</p>
<p><code>add_nans</code> adds rows/columns (or higher dimensions) to model fit data
for regions which were skipped (due to having a singular design matrix,
usually).
</p>
<p><code>cxtxfun_3d</code> returns a function that calculates the &ldquo;CXtX&rdquo;
matrix/array, used to calculate the standard error of a contrast. The
function signature will be <code>f(contrast, xtx, rkC, ny)</code>.
</p>
<p><code>glm_data_table</code> is used in <code>brainGraph_GLM</code> and
<code>brainGraph_mediate</code> to create a <code>data.table</code> with the
<em>subject IDs</em> and column(s) for the graph- or vertex-level metric of
interest.
</p>
<p><code>matrix2list</code> makes working with different contrast types (i.e., t or F)
a little simpler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_glm(g.list, level, covars, X, contrasts, con.type, con.name, measure,
  outcome, ...)

contrast_names(contrasts, con.type, con.name, X)

check_if_singular(QR)

add_nans(fits, dimX, namesX, runX = names(fits$qr))

cxtxfun_3d(con.type, transpose = TRUE)

glm_data_table(g.list, level, measure)

matrix2list(mat)

maxfun(alternative)

sortfun(alternative)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM+2B20helpers_+3A_g.list">g.list</code></td>
<td>
<p>A <code>brainGraphList</code> object</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_level">level</code></td>
<td>
<p>Character string; either <code>vertex</code> (default) or
<code>graph</code></p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_covars">covars</code></td>
<td>
<p>A <code>data.table</code> of covariates</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_x">X</code></td>
<td>
<p>Numeric matrix, if you wish to supply your own design matrix.
Ignored if <code>outcome != measure</code>.</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_contrasts">contrasts</code></td>
<td>
<p>Numeric matrix (for T statistics) or list of matrices (for F
statistics) specifying the contrast(s) of interest; if only one contrast is
desired, you can supply a vector (for T statistics)</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_con.type">con.type</code></td>
<td>
<p>Either <code>'t'</code> or <code>'f'</code></p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_con.name">con.name</code></td>
<td>
<p>Character vector of the contrast name(s); if <code>contrasts</code>
has row/list names, those will be used for reporting results</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_measure">measure</code></td>
<td>
<p>Character string of the graph measure of interest</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_outcome">outcome</code></td>
<td>
<p>Character string specifying the name of the outcome variable,
if it differs from the graph metric (<code>measure</code>)</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+brainGraph_GLM_design">brainGraph_GLM_design</a></code></p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_qr">QR</code></td>
<td>
<p>List of QR decompositions for each design matrix</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_fits">fits</code></td>
<td>
<p>List object output by one of the model fitting functions (e.g.,
<code><a href="#topic+fastLmBG">fastLmBG</a></code>)</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_dimx">dimX</code></td>
<td>
<p>Integer vector containing the dimensions of the original design
matrix/array (including singular designs)</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_namesx">namesX</code></td>
<td>
<p>List of character vectors containing the dimension names from
the original design matrix/array</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_runx">runX</code></td>
<td>
<p>Character vector of regions for which models were fit</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_transpose">transpose</code></td>
<td>
<p>Logical indicating whether to transpose the output of the
selected function. Ignored for F-contrasts. Should be <code>FALSE</code> for
T-contrasts when the &ldquo;Guttman&rdquo; partition method is used. Default:
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_mat">mat</code></td>
<td>
<p>Numeric matrix in which each row is a single contrast vector</p>
</td></tr>
<tr><td><code id="GLM+2B20helpers_+3A_alternative">alternative</code></td>
<td>
<p>Character string, whether to do a two- or one-sided test.
Default: <code>'two.sided'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function: removes unused levels from <code>covars</code> and <code>DT.y.m</code>,
removes subjects with incomplete data, creates a design matrix (if not
supplied), and supplies names to the contrast matrix.
</p>
<p>The &ldquo;CXtX&rdquo; matrix/array for T-contrasts is the diagonal of
</p>
<p style="text-align: center;"><code class="reqn">C (X^T X)^{-1} C^T</code>
</p>

<p>For F-contrasts, it is the <em>inverse</em> of the matrix:
</p>
<p style="text-align: center;"><code class="reqn">(C (X^T X)^{-1} C^T)^{-1}</code>
</p>

<p>where in both cases, <code class="reqn">C</code> is the contrast matrix and <code class="reqn">X</code> is the design
matrix/array.
</p>
<p>For T-contrasts, the function will return a numeric vector/matrix with
dimensions <code class="reqn">k \times r</code> where <code class="reqn">k</code> is the <em>number</em> of contrasts
(i.e., the number of rows in the contrast matrix) and <code class="reqn">r</code> is the number
of regions. For F-contrasts, the function would return a numeric array with
dimensions <code class="reqn">k \times k \times r</code>, where <code class="reqn">k</code> is the rank of the
contrast matrix and <code class="reqn">r</code> is the number of regions. If there is a single
design for all regions, it will be a <code class="reqn">k \times k</code> matrix.
</p>


<h3>Value</h3>

<p><code>contrast_names</code> &ndash; list containing the contrasts (matrix or
list), contrast names, and number of contrasts
</p>
<p><code>add_nans</code> &ndash; the original <code>fits</code> object with <code>NaN</code> or
<code>NA</code> inserted
</p>
<p><code>cxtxfun_3d</code> &ndash; A function with arguments for the contrast
(numeric matrix), the &ldquo;unscaled covariance&rdquo; array, the (row) rank of
the contrast, and the number of regions in the analysis (only used for
F-contrasts)
</p>
<p><code>glm_data_table</code> - A <code>data.table</code> with one column
containing the subject ID's and 1 or more columns with the graph- or
vertex-level measure of interest.
</p>
<p><code>matrix2list</code> &ndash; A list with length equal to the number of rows
of <code>C</code>
</p>

<hr>
<h2 id='GLM+20influence+20measures'>Influence measures for a bg_GLM object</h2><span id='topic+GLM+20influence+20measures'></span><span id='topic+rstandard.bg_GLM'></span><span id='topic+rstudent.bg_GLM'></span><span id='topic+hatvalues.bg_GLM'></span><span id='topic+cooks.distance.bg_GLM'></span><span id='topic+dffits.bg_GLM'></span><span id='topic+dfbeta.bg_GLM'></span><span id='topic+dfbetas.bg_GLM'></span><span id='topic+covratio.bg_GLM'></span><span id='topic+influence.bg_GLM'></span>

<h3>Description</h3>

<p>These functions compute common (leave-one-out) diagnostics for the models in
a <code>bg_GLM</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bg_GLM'
rstandard(model, type = c("sd.1", "predictive"), ...)

## S3 method for class 'bg_GLM'
rstudent(model, ...)

## S3 method for class 'bg_GLM'
hatvalues(model, ...)

## S3 method for class 'bg_GLM'
cooks.distance(model, ...)

dffits.bg_GLM(model)

## S3 method for class 'bg_GLM'
dfbeta(model, ...)

## S3 method for class 'bg_GLM'
dfbetas(model, ...)

covratio.bg_GLM(model)

## S3 method for class 'bg_GLM'
influence(model, do.coef = TRUE, region = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM+2B20influence+2B20measures_+3A_model">model</code></td>
<td>
<p>A <code>bg_GLM</code> object</p>
</td></tr>
<tr><td><code id="GLM+2B20influence+2B20measures_+3A_type">type</code></td>
<td>
<p>The type of standardized residuals. Default: <code>'sd.1'</code></p>
</td></tr>
<tr><td><code id="GLM+2B20influence+2B20measures_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="GLM+2B20influence+2B20measures_+3A_do.coef">do.coef</code></td>
<td>
<p>Logical indicating whether to calculate <code>dfbeta</code></p>
</td></tr>
<tr><td><code id="GLM+2B20influence+2B20measures_+3A_region">region</code></td>
<td>
<p>Character string of the region(s) to return results for.
Default is to calculate for all regions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>influence</code> method calculates all diagnostics present in
<code><a href="stats.html#topic+lm.influence">lm.influence</a></code> and
<code><a href="stats.html#topic+influence.measures">influence.measures</a></code>, consisting of the following
functions:
</p>

<dl>
<dt>rstandard</dt><dd><p>Standardized residuals. Choosing <code>type='predictive'</code>
returns leave-one-out cross validation residuals. The &ldquo;PRESS&rdquo;
statistic can be calculated as <code>colSums(resids.p^2)</code></p>
</dd>
<dt>rstudent</dt><dd><p>Studentized residuals</p>
</dd>
<dt>hatvalues</dt><dd><p>The <em>leverage</em>, or the diagonal of the
<em>hat/projection matrix</em></p>
</dd>
<dt>cooks.distance</dt><dd><p>Cook's distance</p>
</dd>
<dt>dffits.bg_GLM</dt><dd><p>The change in fitted values when deleting
observations</p>
</dd>
<dt>dfbeta</dt><dd><p>The change in parameter estimates (coefficients) when
deleting observations</p>
</dd>
<dt>dfbetas</dt><dd><p>The <em>scaled</em> change in parameter estimates</p>
</dd>
<dt>covratio.bg_GLM</dt><dd><p>The covariance ratios, or the change in the
determinant of the covariance matrix of parameter estimates when deleting
observations</p>
</dd>
</dl>



<h3>Value</h3>

<p>Most influence functions return a numeric matrix in which rownames
are Study ID's and column names are regions. <code>dfbeta</code> and
<code>dfbetas</code> return a numeric array in which each column is a parameter
estimate and the 3rd dimension is for each region. <code>influence</code> returns
a list with class <code>infl.bg_GLM</code> and elements:
</p>
<table role = "presentation">
<tr><td><code>infmat</code></td>
<td>
<p>Numeric array (like <code>dfbeta</code>) with DFBETAs, DFFITs,
covratios, Cook's distance, and hat values</p>
</td></tr>
<tr><td><code>is.inf</code></td>
<td>
<p>Logical array of the same data as <code>infmat</code>; values of
<code>TRUE</code> indicate the subject-variable-region combination is an
outlier value</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>The model <em>formula</em></p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The leave-one-out residual standard deviation</p>
</td></tr>
<tr><td><code>wt.res</code></td>
<td>
<p>Model residuals</p>
</td></tr>
</table>


<h3>Outlier values</h3>

<p>Each variable has a different criterion for determining outliers. In the
following: <code>x</code> is the influence variable (for <code>DFBETA</code>, the
criterion applies to all DFBETAs); <code>k</code> is the number of columns of the
design matrix; <code>dfR</code> is the residual degrees of freedom; and <code>n</code> is
the number of observations.
</p>

<dl>
<dt>DFBETAs</dt><dd><p>If <code class="reqn">|x| &gt; 1</code></p>
</dd>
<dt>DFFITs</dt><dd><p>If <code class="reqn">|x| &gt; 3 \sqrt{k / dfR}</code></p>
</dd>
<dt>covratio</dt><dd><p>If <code class="reqn">|1 - x| &gt; (3k / dfR)</code></p>
</dd>
<dt>cook</dt><dd><p>If <code class="reqn">F_{k, dfR}(x) &gt; 0.5</code></p>
</dd>
<dt>hat</dt><dd><p>If <code class="reqn">x &gt; 3k / n</code></p>
</dd>
</dl>

<p>The return object of <code>influence</code> has a <code>print</code> method which will
list the subjects/variables/regions for which an outlier was detected.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLM">GLM</a></code>
</p>

<hr>
<h2 id='GLM+20model+20selection'>Model selection for bg_GLM objects</h2><span id='topic+GLM+20model+20selection'></span><span id='topic+logLik.bg_GLM'></span><span id='topic+extractAIC.bg_GLM'></span>

<h3>Description</h3>

<p>These functions compute the log-likelihood and Akaike's <em>An Information
Criterion (AIC)</em> of a <code>bg_GLM</code> object. See
<code><a href="stats.html#topic+logLik.lm">logLik.lm</a></code> and <code><a href="stats.html#topic+extractAIC">extractAIC</a></code> for
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bg_GLM'
logLik(object, REML = FALSE, ...)

## S3 method for class 'bg_GLM'
extractAIC(fit, scale = 0, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM+2B20model+2B20selection_+3A_object">object</code>, <code id="GLM+2B20model+2B20selection_+3A_fit">fit</code></td>
<td>
<p>A <code>bg_GLM</code> object</p>
</td></tr>
<tr><td><code id="GLM+2B20model+2B20selection_+3A_reml">REML</code></td>
<td>
<p>Logical indicating whether to return the <em>restricted</em>
log-likelihood. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="GLM+2B20model+2B20selection_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="GLM+2B20model+2B20selection_+3A_scale">scale</code></td>
<td>
<p>Should be left at its default</p>
</td></tr>
<tr><td><code id="GLM+2B20model+2B20selection_+3A_k">k</code></td>
<td>
<p>Numeric; the weight of the equivalent degrees of freedom</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code> will also
work for <code>bg_GLM</code> objects because they each call <code>logLik</code>.
</p>


<h3>Value</h3>

<p><code>logLik</code> returns an object of class <code>logLik</code> with several
attributes. <code>extractAIC</code> returns a numeric vector in which the first
element is the <em>equivalent degrees of freedom</em> and the remaining are
the AIC's for each region
</p>

<hr>
<h2 id='GLM+20statistics'>Extract model fit statistics from a bg_GLM object</h2><span id='topic+GLM+20statistics'></span><span id='topic+coef.bg_GLM'></span><span id='topic+confint.bg_GLM'></span><span id='topic+fitted.bg_GLM'></span><span id='topic+residuals.bg_GLM'></span><span id='topic+deviance.bg_GLM'></span><span id='topic+coeff_determ'></span><span id='topic+df.residual.bg_GLM'></span><span id='topic+sigma.bg_GLM'></span><span id='topic+vcov.bg_GLM'></span><span id='topic+coeff_table'></span><span id='topic+anova.bg_GLM'></span>

<h3>Description</h3>

<p>These functions extract or calculate model fit statistics of a
<code>bg_GLM</code> object. These can be found in the output from
<code><a href="stats.html#topic+summary.lm">summary.lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bg_GLM'
coef(object, ...)

## S3 method for class 'bg_GLM'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'bg_GLM'
fitted(object, ...)

## S3 method for class 'bg_GLM'
residuals(object, type = c("response", "partial"), ...)

## S3 method for class 'bg_GLM'
deviance(object, ...)

coeff_determ(object, adjusted = FALSE)

## S3 method for class 'bg_GLM'
df.residual(object, ...)

## S3 method for class 'bg_GLM'
sigma(object, ...)

## S3 method for class 'bg_GLM'
vcov(object, ...)

coeff_table(object, CI = FALSE, level = 0.95)

## S3 method for class 'bg_GLM'
anova(object, region = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM+2B20statistics_+3A_object">object</code></td>
<td>
<p>A <code>bg_GLM</code> object</p>
</td></tr>
<tr><td><code id="GLM+2B20statistics_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="GLM+2B20statistics_+3A_parm">parm</code></td>
<td>
<p>Vector of parameters to calculate confidence intervals for.
Default is to use all parameters</p>
</td></tr>
<tr><td><code id="GLM+2B20statistics_+3A_level">level</code></td>
<td>
<p>The confidence level. Default: <code>0.95</code></p>
</td></tr>
<tr><td><code id="GLM+2B20statistics_+3A_type">type</code></td>
<td>
<p>Character string specifying the type of residuals to return.
Default: <code>'response'</code></p>
</td></tr>
<tr><td><code id="GLM+2B20statistics_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical indicating whether to calculate the adjusted
R-squared. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="GLM+2B20statistics_+3A_ci">CI</code></td>
<td>
<p>Logical indicating whether to include confidence intervals of
parameter estimates in the coefficient summary table. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="GLM+2B20statistics_+3A_region">region</code></td>
<td>
<p>Character vector indicating the region(s) to calculate ANOVA
statistics for. Default: <code>NULL</code> (use all regions)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These mimic the same functions that operate on <code><a href="stats.html#topic+lm">lm</a></code> objects, and
include:
</p>

<dl>
<dt>coef</dt><dd><p>Regression coefficients (parameter estimates)</p>
</dd>
<dt>confint</dt><dd><p>Confidence intervals (by default, 95%) for parameter
estimates</p>
</dd>
<dt>fitted</dt><dd><p>Fitted (mean) values; i.e., the design matrix multiplied by
the parameter estimates, <code class="reqn">X \hat{\beta}</code></p>
</dd>
<dt>residuals</dt><dd><p>Model residuals; i.e., the response/outcome variable minus
the <em>fitted</em> values. Partial residuals can also be calculated</p>
</dd>
<dt>deviance</dt><dd><p>Model deviance, or the <em>residual sum of squares</em></p>
</dd>
<dt>coeff_determ</dt><dd><p>Calculate the <em>coefficient of determination</em> (or
<code class="reqn">R^2</code>), adjusted or unadjusted</p>
</dd>
<dt>df.residual</dt><dd><p>Residual degrees of freedom</p>
</dd>
<dt>sigma</dt><dd><p>Residual standard deviation, sometimes called the <em>root
mean squared error (RMSE)</em></p>
</dd>
<dt>vcov</dt><dd><p>Variance-covariance matrix of the model parameters</p>
</dd>
</dl>

<p><code>coeff_table</code> returns model coefficients, standard errors, T-statistics,
and P-values for all model terms and regions in a <code>bg_GLM</code> object. This
is the same as running <code>summary(x)$coefficients</code> for a <code>lm</code> object.
</p>


<h3>Value</h3>

<p>A named numeric vector, matrix, or array, depending on the function:
</p>
<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>Matrix in which rownames are parameter names and column names
are regions</p>
</td></tr>
<tr><td><code>fitted</code>, <code>residuals</code></td>
<td>
<p>Matrix in which rownames are Study ID's and column
names are regions. If <code>type='partial'</code>, an array is returned in
which columns are <em>terms</em> and the 3rd dimension are regions</p>
</td></tr>
<tr><td><code>deviance</code>, <code>coeff_determ</code>, <code>sigma</code></td>
<td>
<p>Numeric vector with elements for each
region</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Single integer; the degrees of freedom</p>
</td></tr>
<tr><td><code>confint</code>, <code>vcov</code>, <code>coeff_table</code></td>
<td>
<p>Numeric array; the extent of the third
dimension equals the number of regions</p>
</td></tr>
</table>
<p><code>anova</code> returns a <em>list</em> of tables of class <code>anova</code>
</p>


<h3>ANOVA tables</h3>

<p>The <code>anova</code> method calculates the so-called <em>Type III</em> test
statistics for a <code>bg_GLM</code> object. These standard ANOVA statistics
include: sum of squares, mean squares, degrees of freedom, F statistics, and
P-values. Additional statistics calculated are: <code class="reqn">\eta^2</code>, partial
<code class="reqn">\eta^2</code>, <code class="reqn">\omega^2</code>, and partial <code class="reqn">\omega^2</code> as measures of
<em>effect size</em>.
</p>


<h3>Note</h3>

<p><code>sigma</code> &ndash; The denominator is <em>not</em> the number of
observations, but rather the model's <em>residual degrees of freedom</em>.
</p>
<p>When calculating <em>partial residuals</em>, the parameter estimates are
<em>not</em> re-calculated after removing one of the model terms.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLM">GLM</a></code>, <code><a href="car.html#topic+Anova">Anova</a></code>
</p>

<hr>
<h2 id='Graph+20Data+20Tables'>Create a data table with graph global and vertex measures</h2><span id='topic+Graph+20Data+20Tables'></span><span id='topic+graph_attr_dt'></span><span id='topic+vertex_attr_dt'></span>

<h3>Description</h3>

<p><code>graph_attr_dt</code> is a helper function that takes a <code>brainGraphList</code>
or a list of graphs and creates a <code>data.table</code> of global measures for
each graph. Each row will be for a different graph.
</p>
<p><code>vertex_attr_dt</code> is a helper function that creates a <code>data.table</code>
in which each row is a vertex and each column is a different network measure
(degree, centrality, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_attr_dt(bg.list)

vertex_attr_dt(bg.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Graph+2B20Data+2B20Tables_+3A_bg.list">bg.list</code></td>
<td>
<p>A <code>brainGraphList</code> object, or a list of graph objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code>
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+graph_attr">graph_attr</a>, <a href="igraph.html#topic+graph_attr_names">graph_attr_names</a></code>
</p>
<p><code><a href="igraph.html#topic+vertex_attr">vertex_attr</a>, <a href="igraph.html#topic+vertex_attr_names">vertex_attr_names</a>,
<a href="igraph.html#topic+graph_from_data_frame">graph_from_data_frame</a></code>
</p>

<hr>
<h2 id='Graph+20Distances'>Calculate Euclidean distance of edges and vertices</h2><span id='topic+Graph+20Distances'></span><span id='topic+edge_spatial_dist'></span><span id='topic+vertex_spatial_dist'></span>

<h3>Description</h3>

<p><code>edge_spatial_dist</code> calculates the Euclidean distance of an
<code>igraph</code> graph object's edges. The distances are in <em>mm</em> and based
on MNI space. These distances are <em>NOT</em> along the cortical surface, so
can only be considered approximations, particularly concerning
inter-hemispheric connections. The input graph must have <em>atlas</em> as a
graph-level attribute.
</p>
<p><code>vertex_spatial_dist</code> calculates, for each vertex of a graph, the
average Euclidean distance across all of that vertex's connections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_spatial_dist(g)

vertex_spatial_dist(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Graph+2B20Distances_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>edge_spatial_dist</code> - a numeric vector with length equal to the
edge count of the input graph, consisting of the Euclidean distance (in
<em>mm</em>) of each edge
</p>
<p><code>vertex_spatial_dist</code> - a named numeric vector with length equal
to the number of vertices, consisting of the average distance (in
<em>mm</em>) for each vertex
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Alexander-Bloch, A.F. and Vertes, P.E. and Stidd, R. et al.
(2013) The anatomical distance of functional connections predicts brain
network topology in health and schizophrenia. <em>Cerebral Cortex</em>,
<b>23</b>, 127&ndash;138. doi: <a href="https://doi.org/10.1093/cercor/bhr388">10.1093/cercor/bhr388</a>
</p>

<hr>
<h2 id='hubness'>Calculate vertex hubness</h2><span id='topic+hubness'></span>

<h3>Description</h3>

<p><code>hubness</code> calculates the &ldquo;hubness&rdquo; (see reference) of the
vertices in a graph. These are vertices which meet at least two of the
following four criteria:
</p>

<ol>
<li><p> Have high degree/strength
</p>
</li>
<li><p> Have high betweenness centrality
</p>
</li>
<li><p> Have low clustering coefficient
</p>
</li>
<li><p> Have low average path length
</p>
</li></ol>

<p>For each criterion, &ldquo;high&rdquo; or &ldquo;low&rdquo; means &ldquo;in the top
20%&rdquo; across all vertices. Vertices meeting any of the criteria get a value
of 1 for that metric; these are summed to yield the hubness score which
ranges from 0-4. As in the reference article, vertices with a score of 2 or
higher are to be considered hubs, although that determination isn't made in
this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hubness(g, xfm.type = g$xfm.type, weights = NULL, prop.keep = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hubness_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="hubness_+3A_xfm.type">xfm.type</code></td>
<td>
<p>Character string specifying how to transform the weights.
Default: <code>1/w</code></p>
</td></tr>
<tr><td><code id="hubness_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of edge weights; if <code>NULL</code> (the default),
and if the graph has edge attribute <code>weight</code>, then that will be used.
To avoid using weights, this should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="hubness_+3A_prop.keep">prop.keep</code></td>
<td>
<p>Numeric (between 0 and 1) indicating the proportion of
vertices to consider as having a high score. Default: 0.2 (20%)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the vertices' hubness score
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>van den Heuvel, M.P. and Mandl, R.C.W. and Stam, C.J. and Kahn,
R.S. and Pol, H.E.H. (2010) Aberrant frontal and temporal complex network
structure in schizophrenia: a graph theoretical analysis. <em>The Journal
of Neuroscience</em>, <b>30(47)</b>, 15915&ndash;15926.
doi: <a href="https://doi.org/10.1523/JNEUROSCI.2874-10.2010">10.1523/JNEUROSCI.2874-10.2010</a>
</p>

<hr>
<h2 id='import_scn'>Import data for structural connectivity analysis</h2><span id='topic+import_scn'></span>

<h3>Description</h3>

<p>Given a directory, atlas name, and imaging modality/structural metric, this
function imports data for structural connectivity analysis. It expects files
containing a table of region-wise structural MRI measures (e.g., mean
cortical thickness), with one file for each hemisphere. The first column of
all files should contain the <em>subject ID</em>; the column name will be
changed to the value of <code>getOption('bg.subject_id')</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_scn(datadir, atlas, modality = "thickness", exclude.subs = NULL,
  custom.atlas = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_scn_+3A_datadir">datadir</code></td>
<td>
<p>The path name of the directory containing the data files</p>
</td></tr>
<tr><td><code id="import_scn_+3A_atlas">atlas</code></td>
<td>
<p>Character string specifying the atlas in use. For a custom
atlas, please specify <code>'custom'</code>, and provide the name to the
<code>custom.atlas</code> argument</p>
</td></tr>
<tr><td><code id="import_scn_+3A_modality">modality</code></td>
<td>
<p>The structural imaging measure (default: <code>'thickness'</code>)</p>
</td></tr>
<tr><td><code id="import_scn_+3A_exclude.subs">exclude.subs</code></td>
<td>
<p>Vector indicating the subjects to exclude, if any
(default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="import_scn_+3A_custom.atlas">custom.atlas</code></td>
<td>
<p>Character string specifying the name of the R object for
the atlas in use, if <code>atlas='custom'</code> was also supplied (default:
<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The files should have specific names; the second in the following list is
only required for atlases/parcellations that include <em>subcortical gray
matter</em> (e.g., <code>dk.scgm</code>).
</p>

<ul>
<li> <p><code>${parcellation}_${hemi}_${modality}.csv</code> for cortical volume,
thickness, surface area, or local gyrification index (LGI). Here,
<code>${parcellation}</code> can be <code>aparc</code>, <code>aparc.DKTatlas40</code>,
or <code>aparc.a2009s</code>. For example, for cortical thickness with the
<em>Desikan-Killiany</em> atlas, the filename should be
<code>aparc_lh_thickness.csv</code>. If you are using a custom atlas, see the
<em>Note</em> below. The <code>${hemi}</code> variable is either <code>lh</code> or
<code>rh</code>. Finally, <code>${modality}</code> should be either <code>volume</code>,
<code>thickness</code>, <code>area</code>, or <code>lgi</code>.
</p>
</li>
<li> <p><code>asegstats.csv</code> for SCGM volume
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>atlas</code></td>
<td>
<p>Character string</p>
</td></tr>
<tr><td><code>modality</code></td>
<td>
<p>Character string</p>
</td></tr>
<tr><td><code>lhrh</code></td>
<td>
<p>A <code>data.table</code> of structural MRI measures for both
hemispheres</p>
</td></tr>
<tr><td><code>aseg</code></td>
<td>
<p>A <code>data.table</code> of structural MRI measures for subcortical
gray matter, if applicable</p>
</td></tr>
<tr><td><code>subs.excluded</code></td>
<td>
<p>Vector of subject ID's that were excluded</p>
</td></tr>
<tr><td><code>subs.missing</code></td>
<td>
<p>Vector of subject ID's that are not present in <em>both</em>
the cortical and subcortical tables (if applicable)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When using a custom atlas, the name of the atlas's data.table should
match the <code>${parcellation}</code> portion of the filename (specification
shown above). Furthermore, it must conform to the output of Freesurfer's
<code>aparcstats2table</code> (and <code>asegstats2table</code>, if applicable).
Otherwise, please contact me for inclusion of a different data type.
</p>
<p>The subject ID column will be zero-padded (to the left) to avoid issues
when the variable is numeric; this ensures that all ID's will have the same
number of characters and sorting will be done properly.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other Structural covariance network functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+IndividualContributions">IndividualContributions</a></code>,
<code><a href="#topic+Residuals">Residuals</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>,
<code><a href="#topic+corr.matrix">corr.matrix</a></code>, <code><a href="#topic+plot_volumetric">plot_volumetric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  raw_data &lt;- import_scn('/home/cwatson/data', atlas='dkt',
                         exclude.subs=c('con07', 'con23', 'pat15'))

## End(Not run)
</code></pre>

<hr>
<h2 id='IndividualContributions'>Approaches to estimate individual network contribution</h2><span id='topic+IndividualContributions'></span><span id='topic+loo'></span><span id='topic+aop'></span><span id='topic+summary.IC'></span><span id='topic+plot.IC'></span>

<h3>Description</h3>

<p><code>loo</code> calculates the individual contribution to group network data for
each subject in each group using a &ldquo;leave-one-out&rdquo; approach. The
residuals of a single subject are excluded, and a correlation matrix is
created. This is compared to the original correlation matrix using the Mantel
test.
</p>
<p><code>aop</code> calculates the individual contribution using an
&ldquo;add-one-patient&rdquo; approach. The residuals of a single patient are
added to those of a control group, and a correlation matrix is created. This
is repeated for all individual patients and each patient group.
</p>
<p>The <code>summary</code> method prints the group/region-wise means and standard
deviations.
</p>
<p>The <code>plot</code> method is only valid for <em>regional</em> contribution
estimates, and plots the average regional contribution for each
vertex/region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo(resids, corrs, level = c("global", "regional"))

aop(resids, corrs, level = c("global", "regional"), control.value = 1L)

## S3 method for class 'IC'
summary(object, region = NULL, digits = max(3L,
  getOption("digits") - 2L), ...)

## S3 method for class 'IC'
plot(x, plot.type = c("mean", "smooth", "boxplot"),
  region = NULL, ids = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IndividualContributions_+3A_resids">resids</code></td>
<td>
<p>An object of class <code>brainGraph_resids</code> (the output from
<code><a href="#topic+get.resid">get.resid</a></code>)</p>
</td></tr>
<tr><td><code id="IndividualContributions_+3A_corrs">corrs</code></td>
<td>
<p>List of lists of correlation matrices (as output by
<code><a href="#topic+corr.matrix">corr.matrix</a></code>).</p>
</td></tr>
<tr><td><code id="IndividualContributions_+3A_level">level</code></td>
<td>
<p>Character string; the level at which you want to calculate
contributions (either <code>global</code> or <code>regional</code>)</p>
</td></tr>
<tr><td><code id="IndividualContributions_+3A_control.value">control.value</code></td>
<td>
<p>Integer or character string specifying the control group
(default: 1L)</p>
</td></tr>
<tr><td><code id="IndividualContributions_+3A_object">object</code>, <code id="IndividualContributions_+3A_x">x</code></td>
<td>
<p>A <code>IC</code> object</p>
</td></tr>
<tr><td><code id="IndividualContributions_+3A_region">region</code></td>
<td>
<p>Character vector specifying which regions' IC's to print. Only
relevant if <code>method='Leave one out'</code></p>
</td></tr>
<tr><td><code id="IndividualContributions_+3A_digits">digits</code></td>
<td>
<p>Integer specifying the number of digits to display for P-values</p>
</td></tr>
<tr><td><code id="IndividualContributions_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="IndividualContributions_+3A_plot.type">plot.type</code></td>
<td>
<p>Character string indicating the type of plot; the default is
to plot the mean (along with standard errors)</p>
</td></tr>
<tr><td><code id="IndividualContributions_+3A_ids">ids</code></td>
<td>
<p>Logical indicating whether to plot Study ID's for outliers.
Otherwise plots the integer index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with columns for
</p>
<table role = "presentation">
<tr><td><code>Study.ID</code></td>
<td>
<p>Subject identifier</p>
</td></tr>
<tr><td><code>Group</code></td>
<td>
<p>Group membership</p>
</td></tr>
<tr><td><code>region</code></td>
<td>
<p>If <code>level='regional'</code></p>
</td></tr>
<tr><td><code>IC</code>, <code>RC</code></td>
<td>
<p>The value of the individual/regional contributions</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For <code>aop</code>, it is assumed by default that the control group is the
first group.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Saggar, M. and Hosseini, S.M.H. and Buno, J.L. and Quintin, E.
and Raman, M.M. and Kesler, S.R. and Reiss, A.L. (2015) Estimating
individual contributions from group-based structural correlations networks.
<em>NeuroImage</em>, <b>120</b>, 274&ndash;284.
doi: <a href="https://doi.org/10.1016/j.neuroimage.2015.07.006">10.1016/j.neuroimage.2015.07.006</a>
</p>


<h3>See Also</h3>

<p>Other Structural covariance network functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+Residuals">Residuals</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>,
<code><a href="#topic+corr.matrix">corr.matrix</a></code>, <code><a href="#topic+import_scn">import_scn</a></code>,
<code><a href="#topic+plot_volumetric">plot_volumetric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
IC &lt;- loo(resids.all, corrs)
RC &lt;- loo(resids.all, corrs, level='regional')

## End(Not run)
## Not run: 
IC &lt;- aop(resids.all, corrs)
RC &lt;- aop(resids.all, corrs, level='regional')

## End(Not run)
</code></pre>

<hr>
<h2 id='Inverse'>Calculate the inverse of the cross product of a design matrix</h2><span id='topic+Inverse'></span><span id='topic+inv'></span><span id='topic+inv.matrix'></span><span id='topic+inv.array'></span><span id='topic+inv.qr'></span><span id='topic+inv.list'></span><span id='topic+pinv'></span>

<h3>Description</h3>

<p><code>inv</code> is a <code>S3</code> generic that calculates the inverse of the cross
product of a design matrix, also referred to as the &ldquo;unscaled
covariance matrix&rdquo;.
</p>
<p><code>pinv</code> calculates <code class="reqn">M^{+} = (M^T M)^{-1} M^T</code> for full (column) rank
matrices. However, it does not verify the matrix's rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv(x, ...)

## S3 method for class 'matrix'
inv(x, y = NULL, transpose = FALSE, ...)

## S3 method for class 'array'
inv(x, y = NULL, transpose = FALSE, ...)

## S3 method for class 'qr'
inv(x, p = x$rank, ...)

## S3 method for class 'list'
inv(x, p = x[[1L]]$rank, r = length(x),
  vnames = dimnames(x[[1L]]$qr)[[2L]], nms = names(x), ...)

pinv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Inverse_+3A_x">x</code></td>
<td>
<p>A numeric matrix or array, a <code>qr</code> object, or a list of
<code>qr</code> objects</p>
</td></tr>
<tr><td><code id="Inverse_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="Inverse_+3A_y">y</code></td>
<td>
<p>A numeric matrix or vector (for the <code>matrix</code> and <code>array</code>
methods). If supplied, this will be multiplied by <code>x</code> before the
inverse is calculated. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Inverse_+3A_transpose">transpose</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), take the cross
product of the arguments. If <code>TRUE</code>, use <code><a href="base.html#topic+tcrossprod">tcrossprod</a></code></p>
</td></tr>
<tr><td><code id="Inverse_+3A_p">p</code></td>
<td>
<p>The rank of the original matrix</p>
</td></tr>
<tr><td><code id="Inverse_+3A_r">r</code></td>
<td>
<p>The number of design matrices; i.e., the length of the input list</p>
</td></tr>
<tr><td><code id="Inverse_+3A_vnames">vnames</code></td>
<td>
<p>Character vector of the design matrix's variable names</p>
</td></tr>
<tr><td><code id="Inverse_+3A_nms">nms</code></td>
<td>
<p>The region names; i.e., the names of the input list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a matrix, the Cholesky decomposition of the cross product is
calculated (or using <code><a href="base.html#topic+tcrossprod">tcrossprod</a></code> if <code>transpose=TRUE</code>), and
the inverse is calculated from that result. That is,
</p>
<p style="text-align: center;"><code class="reqn">inv(X) = (X^T X)^{-1}</code>
</p>

<p style="text-align: center;"><code class="reqn">inv(X, transpose=TRUE) = (X X^T)^{-1}</code>
</p>

<p style="text-align: center;"><code class="reqn">inv(X, y) = (X^T y)^{-1}</code>
</p>

<p>If <code>x</code> is a 3-dimensional array, then the inverse will be calculated for
each matrix along the 3rd dimension, with the same input arguments for each.
</p>
<p>Finally, there is a method for objects with class <code>qr</code>, and lists of QR
decomposition objects.
</p>


<h3>Value</h3>

<p>A numeric matrix or array
</p>
<p><code>pinv</code> returns the input matrix's pseudoinverse
</p>


<h3>Note</h3>

<p>These methods should only be used on <em>full-rank</em> matrices, as
there is no error checking being performed.
</p>

<hr>
<h2 id='make_auc_brainGraph'>Calculate the AUC across densities of given attributes</h2><span id='topic+make_auc_brainGraph'></span>

<h3>Description</h3>

<p>Given a list of <code>brainGraphList</code> objects, this function will calculate
the area under the curve (AUC) across all thresholds/densities for each
subject or group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_auc_brainGraph(g.list, g.attr = NULL, v.attr = NULL,
  norm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_auc_brainGraph_+3A_g.list">g.list</code></td>
<td>
<p>A list of <code>brainGraphList</code> objects</p>
</td></tr>
<tr><td><code id="make_auc_brainGraph_+3A_g.attr">g.attr</code></td>
<td>
<p>A character vector of graph attribute name(s). Default:
<code>NULL</code></p>
</td></tr>
<tr><td><code id="make_auc_brainGraph_+3A_v.attr">v.attr</code></td>
<td>
<p>A character vector of vertex attribute name(s). Default:
<code>NULL</code></p>
</td></tr>
<tr><td><code id="make_auc_brainGraph_+3A_norm">norm</code></td>
<td>
<p>Logical indicating whether to normalize threshold values to be
between 0 and 1 (inclusive). Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the elements of the input list do not have a <code>threshold</code> element (or
if it is <code>NULL</code>) then the AUC will be calculated on the interval
<code class="reqn">[0, 1]</code> (inclusive). This has the same effect as specifying
<code>norm=TRUE</code> in the function call.
</p>


<h3>Value</h3>

<p>A <code>brainGraphList</code> object with one graph for each subject
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g.auc &lt;- make_auc_brainGraph(g.fa, g.attr='E.global.wt')

## End(Not run)
</code></pre>

<hr>
<h2 id='make_ego_brainGraph'>Create a graph of the union of multiple vertex neighborhoods</h2><span id='topic+make_ego_brainGraph'></span>

<h3>Description</h3>

<p>This function accepts multiple vertices, creates graphs of their
neighborhoods (of order 1), and returns the union of those graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ego_brainGraph(g, vs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_ego_brainGraph_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="make_ego_brainGraph_+3A_vs">vs</code></td>
<td>
<p>Either a character or integer vector (vertex names or indices,
respectively) for the vertices of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>igraph</code> graph object containing the union of all edges and
vertices in the neighborhoods of the input vertices; only the vertex
attribute <em>name</em> will be present
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+ego">ego</a></code>
</p>
<p>Other Graph creation functions: <code><a href="#topic+Creating_Graphs_GLM">Creating_Graphs_GLM</a></code>,
<code><a href="#topic+Creating_Graphs">Creating_Graphs</a></code>,
<code><a href="#topic+brainGraphList">brainGraphList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
subg &lt;- make_ego_brainGraph(g1[[N]], c(24, 58))
subg &lt;- make_ego_brainGraph(g1[[N]], c('lPCUN', 'rPCUN'))

## End(Not run)
</code></pre>

<hr>
<h2 id='make_intersection_brainGraph'>Create the intersection of graphs based on a logical condition</h2><span id='topic+make_intersection_brainGraph'></span>

<h3>Description</h3>

<p>Returns a graph object with vertices that meet certain criteria. By default,
only vertices that meet these criteria for <em>all</em> input graphs will be
retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_intersection_brainGraph(..., subgraph, keep.all.vertices = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_intersection_brainGraph_+3A_...">...</code></td>
<td>
<p>Graph objects or lists of graph objects</p>
</td></tr>
<tr><td><code id="make_intersection_brainGraph_+3A_subgraph">subgraph</code></td>
<td>
<p>Character string specifying an equation (logical condition)
for the vertices to subset</p>
</td></tr>
<tr><td><code id="make_intersection_brainGraph_+3A_keep.all.vertices">keep.all.vertices</code></td>
<td>
<p>Logical indicating whether to keep all vertices that
meet the criteria in at least 1 input graph. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no vertices meet criteria for all input graphs, then an <code>igraph</code>
graph object with 0 vertices is returned. If <code>keep.all.vertices=TRUE</code>,
this is essentially performing a <em>union</em> of vertex sets that meet the
criteria. In any case, the return graph will have 0 edges.
</p>


<h3>Value</h3>

<p>An <code>igraph</code> graph object
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res.mtpc &lt;- mtpc(g, covars, ...)
g.mtpc &lt;- make_glm_brainGraph(res.mtpc, atlas)

## All vertices with a significant MTPC result for all contrasts:
g.mtpc.int &lt;- make_intersection_brainGraph(g.mtpc, subgraph='sig == 1')

## Return graphs with vertices with degree &gt; 0 for each group separately
tapply(g.list, groups(g.list), make_intersection_brainGraph,
       subgraph='degree &gt; 0')

## End(Not run)
</code></pre>

<hr>
<h2 id='Matrix+20utilities'>Matrix/array utility functions</h2><span id='topic+Matrix+20utilities'></span><span id='topic+colMax'></span><span id='topic+colMaxAbs'></span><span id='topic+colMin'></span><span id='topic+diag_sq'></span><span id='topic+get_thresholds'></span><span id='topic+is_binary'></span><span id='topic+qr.array'></span><span id='topic+qr_Q2'></span><span id='topic+qr_R2'></span><span id='topic+symm_mean'></span><span id='topic+symmetrize'></span><span id='topic+symmetrize.matrix'></span><span id='topic+symmetrize.array'></span>

<h3>Description</h3>

<p>These functions are utility/helper functions when working with matrices or
arrays.
</p>
<p><code>diag_sq</code> is a pared-down version of <code><a href="base.html#topic+diag">diag</a></code> for square
matrices. It does not return any dimnames, does not check if <code>x</code> is a
square matrix, and it cannot be used to <em>create</em> a matrix with a given
value along the diagonal. Meant to be used in code that is called repeatedly
(thousands of times).
</p>
<p><code>get_thresholds</code> calculates the threshold values that would result in a
specific graph density. These depend, necessarily on the values in the matrix
themselves.
</p>
<p><code>qr.array</code> will calculate the QR decomposition for each matrix in a 3D
array.
</p>
<p><code>qr_Q2</code> and <code>qr_R2</code> are simplified versions of <code><a href="base.html#topic+qr.Q">qr.Q</a></code>
and <code><a href="base.html#topic+qr.R">qr.R</a></code>.
</p>
<p><code>symm_mean</code> returns a symmetric matrix in which the off-diagonal
elements <code class="reqn">A[i, j]</code> and <code class="reqn">A[j, i]</code> are set to the mean of the values
in the input matrix.
</p>
<p><code>symmetrize</code> will symmetrize a numeric matrix (or each matrix in an
array) by assigning to the off-diagonal elements either the <code>max</code>
(default), <code>min</code>, or <code>average</code> of <code class="reqn">\{A(i, j), A(j, i)\}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colMax(x, n = dim(x)[1L])

colMaxAbs(x, n = dim(x)[1L])

colMin(x, n = dim(x)[1L])

diag_sq(x, n = dim(x)[1L], inds = 1L + 0L:(n - 1L) * (n + 1L))

get_thresholds(x, densities, emax = dim(x)[1L] * (dim(x)[1L] - 1L)/2,
  ...)

is_binary(x)

## S3 method for class 'array'
qr(x, ...)

qr_Q2(QR, y = diag(1, n, p), n = dim(QR$qr)[1L], p = QR$rank)

qr_R2(QR, p = QR$rank)

symm_mean(x)

symmetrize(x, ...)

## S3 method for class 'matrix'
symmetrize(x, symm.by = c("max", "min", "avg"), ...)

## S3 method for class 'array'
symmetrize(x, symm.by = c("max", "min", "avg"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Matrix+2B20utilities_+3A_x">x</code></td>
<td>
<p>Numeric matrix or array (the latter, for <code>qr.array</code> and
<code>symmetrize.array</code>)</p>
</td></tr>
<tr><td><code id="Matrix+2B20utilities_+3A_n">n</code>, <code id="Matrix+2B20utilities_+3A_p">p</code></td>
<td>
<p>Integer; the number of rows or rank (respectively) of
the input matrix or QR decomposition</p>
</td></tr>
<tr><td><code id="Matrix+2B20utilities_+3A_inds">inds</code></td>
<td>
<p>Vector-based indices of the diagonal</p>
</td></tr>
<tr><td><code id="Matrix+2B20utilities_+3A_densities">densities</code></td>
<td>
<p>Numeric vector of densities</p>
</td></tr>
<tr><td><code id="Matrix+2B20utilities_+3A_emax">emax</code></td>
<td>
<p>Integer; the maximum number of edges</p>
</td></tr>
<tr><td><code id="Matrix+2B20utilities_+3A_...">...</code></td>
<td>
<p>Arguments passed to either <code><a href="base.html#topic+sort">sort</a></code> (for
<code>get_thresholds</code>) or <code><a href="base.html#topic+qr.default">qr.default</a></code> (for <code>qr.array</code>).
For the former, this will typically only be <code>decreasing=TRUE</code>, if that
is the desired behavior</p>
</td></tr>
<tr><td><code id="Matrix+2B20utilities_+3A_qr">QR</code></td>
<td>
<p>A <code>qr</code> object</p>
</td></tr>
<tr><td><code id="Matrix+2B20utilities_+3A_y">y</code></td>
<td>
<p>A numeric matrix with <code>1</code> along the diagonal, of the same size
as the input matrix (i.e., <code>QR$qr</code>)</p>
</td></tr>
<tr><td><code id="Matrix+2B20utilities_+3A_symm.by">symm.by</code></td>
<td>
<p>Character string; how to create symmetric off-diagonal
elements. Default: <code>max</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of densities, <code>get_thresholds</code> returns the numeric values
that will result in graphs of the given densities after thresholding by those
values. In the <em>Examples</em> section, the thresholds should result in
graphs with densities of <code class="reqn">5, 15, \dots, 55</code> percent.
</p>


<h3>Value</h3>

<p><code>diag_sq</code> returns an unnamed numeric vector with the values
along the diagonal of the input matrix
</p>
<p><code>get_thresholds</code> returns a numeric vector of the thresholds
</p>
<p><code>is_binary</code> returns a logical of length 1
</p>
<p><code>qr.array</code> returns a <em>list</em> in which each element is the QR
decomposition of each matrix along <code>x</code>'s 3rd dimension
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(25 * 25), 25, 25)
x &lt;- symmetrize(x)
diag(x) &lt;- 0
densities &lt;- seq(0.05, 0.55, by=0.1)
threshes &lt;- get_thresholds(x, densities)
## Verify that the densities are correct
graphs &lt;- lapply(threshes, function(th) {
  graph_from_adjacency_matrix(x * (x &gt; th), mode='undirected',
                              diag=FALSE, weighted=TRUE)
  })
sapply(graphs, graph.density)
</code></pre>

<hr>
<h2 id='mean_distance_wt'>Calculate weighted shortest path lengths</h2><span id='topic+mean_distance_wt'></span>

<h3>Description</h3>

<p>Calculate graph or vertex average shortest path lengths. For vertices, this
is just the row means of the distance matrix. For the graph-level, it is the
overall mean of the distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_distance_wt(g, level = c("graph", "vertex"), weights = NULL,
  xfm = FALSE, xfm.type = NULL, D = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_distance_wt_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="mean_distance_wt_+3A_level">level</code></td>
<td>
<p>Character string indicating whether to calculate vertex- or
graph-level shortest path length. Default: <code>'graph'</code></p>
</td></tr>
<tr><td><code id="mean_distance_wt_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of edge weights; if <code>NULL</code> (the default),
and if the graph has edge attribute <code>weight</code>, then that will be used.
To avoid using weights, this should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="mean_distance_wt_+3A_xfm">xfm</code></td>
<td>
<p>Logical indicating whether to transform the edge weights. Default:
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="mean_distance_wt_+3A_xfm.type">xfm.type</code></td>
<td>
<p>Character string specifying how to transform the weights.
Default: <code>1/w</code></p>
</td></tr>
<tr><td><code id="mean_distance_wt_+3A_d">D</code></td>
<td>
<p>Numeric matrix; the graph's &ldquo;distance matrix&rdquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, edge weights are not transformed (e.g., inverted). However, if
set to <code>TRUE</code>, then the input graph must have a graph-level attribute
called <code>'xfm.type'</code> or you must supply a value in the function call. If
you supply a distance matrix (the <code>D</code> argument), it is not necessary to
transform edge weights, as it is assumed the the distance matrix was
calculated from a graph with transformed edge weights already.
</p>


<h3>Value</h3>

<p>Numeric vector (if <code>level='vertex'</code>) of each vertex's shortest
path length, or a single number for the graph-level average
</p>

<hr>
<h2 id='Mediation'>Mediation analysis with brain graph measures as mediator variables</h2><span id='topic+Mediation'></span><span id='topic+brainGraph_mediate'></span><span id='topic+summary.bg_mediate'></span><span id='topic+bg_to_mediate'></span>

<h3>Description</h3>

<p><code>brainGraph_mediate</code> performs simple mediation analyses in which a given
graph- or vertex-level measure (e.g., <em>weighted global efficiency</em>) is
the mediator <em>M</em>. The outcome (or dependent/response) variable <em>Y</em>
can be a neuropsychological measure (e.g., <em>IQ</em>) or can be a
disease-specific metric (e.g., recovery time).
</p>
<p><code><a href="#topic+bg_to_mediate">bg_to_mediate</a></code> converts the results into an object of class
<code><a href="mediation.html#topic+mediate">mediate</a></code>. In <code>brainGraph</code>, it is only used for
the <code><a href="mediation.html#topic+summary.mediate">summary.mediate</a></code> method, but you can similarly
use its output for the <code><a href="mediation.html#topic+plot.mediate">plot.mediate</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainGraph_mediate(g.list, covars, mediator, treat, outcome, covar.names,
  level = c("graph", "vertex"), control.value = 0, treat.value = 1,
  int = FALSE, boot = TRUE, boot.ci.type = c("perc", "bca"),
  N = 1000, conf.level = 0.95, long = FALSE, ...)

## S3 method for class 'bg_mediate'
summary(object, mediate = FALSE, region = NULL,
  digits = max(3L, getOption("digits") - 2L), ...)

bg_to_mediate(x, region = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mediation_+3A_g.list">g.list</code></td>
<td>
<p>A <code>brainGraphList</code> object</p>
</td></tr>
<tr><td><code id="Mediation_+3A_covars">covars</code></td>
<td>
<p>A data table containing covariates of interest. It must include
columns for <code>getOption('bg.subject_id')</code>, <code>treat</code>,
<code>outcome</code>, and <code>covar.names</code>.</p>
</td></tr>
<tr><td><code id="Mediation_+3A_mediator">mediator</code></td>
<td>
<p>Character string; the name of the graph measure acting as
the <em>mediating</em> variable</p>
</td></tr>
<tr><td><code id="Mediation_+3A_treat">treat</code></td>
<td>
<p>Character string; the <em>treatment</em> variable (e.g.,
<em>Group</em>)</p>
</td></tr>
<tr><td><code id="Mediation_+3A_outcome">outcome</code></td>
<td>
<p>Character string; the name of the outcome variable of interest</p>
</td></tr>
<tr><td><code id="Mediation_+3A_covar.names">covar.names</code></td>
<td>
<p>Character vector of the column name(s) in <code>covars</code> to
include in the models as pre-treatment covariate(s).</p>
</td></tr>
<tr><td><code id="Mediation_+3A_level">level</code></td>
<td>
<p>Character string; either <code>vertex</code> (default) or
<code>graph</code></p>
</td></tr>
<tr><td><code id="Mediation_+3A_control.value">control.value</code></td>
<td>
<p>Value of <code>treat</code> to be used as the control
condition. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="Mediation_+3A_treat.value">treat.value</code></td>
<td>
<p>Value of <code>treat</code> to be used as the treatment
condition. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="Mediation_+3A_int">int</code></td>
<td>
<p>Logical indicating whether or not to include an interaction of the
mediator and treatment. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="Mediation_+3A_boot">boot</code></td>
<td>
<p>Logical indicating whether or not to perform bootstrapping. This
should always be done. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="Mediation_+3A_boot.ci.type">boot.ci.type</code></td>
<td>
<p>Character string; which type of CI's to calculate.
Default: <code>perc</code></p>
</td></tr>
<tr><td><code id="Mediation_+3A_n">N</code></td>
<td>
<p>Integer; the number of bootstrap samples to run. Default:
<code>1e3</code></p>
</td></tr>
<tr><td><code id="Mediation_+3A_conf.level">conf.level</code></td>
<td>
<p>Numeric between 0 and 1; the level of the CI's to
calculate. Default: <code>0.95</code> for the 2.5 and 97.5 percentiles)</p>
</td></tr>
<tr><td><code id="Mediation_+3A_long">long</code></td>
<td>
<p>Logical indicating whether or not to return all bootstrap
samples. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="Mediation_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+brainGraph_GLM_design">brainGraph_GLM_design</a></code>
(e.g., <code>binarize</code>) (unused in the <code>summary</code> method)</p>
</td></tr>
<tr><td><code id="Mediation_+3A_object">object</code></td>
<td>
<p>A <code>bg_mediate</code> object</p>
</td></tr>
<tr><td><code id="Mediation_+3A_mediate">mediate</code></td>
<td>
<p>Logical indicating whether or not to use the <code>summary</code>
method from <code><a href="mediation.html#topic+mediate">mediate</a></code> (default: <code>FALSE</code>). If
<code>TRUE</code>, only a single region can be printed.</p>
</td></tr>
<tr><td><code id="Mediation_+3A_region">region</code></td>
<td>
<p>Character string specifying which region's results to
summarize; only relevant if <code>level='vertex'</code> (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="Mediation_+3A_digits">digits</code></td>
<td>
<p>Integer specifying the number of digits to display for P-values</p>
</td></tr>
<tr><td><code id="Mediation_+3A_x">x</code></td>
<td>
<p>Object output from <code><a href="#topic+brainGraph_mediate">brainGraph_mediate</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code was adapted closely from <code><a href="mediation.html#topic+mediate">mediate</a></code> in the
<code>mediation</code> package, and the procedure is exactly the same as theirs
(see the references listed below). If you use this function, please cite
their work.
</p>


<h3>Value</h3>

<p>An object of class <code>bg_mediate</code> with elements:
</p>
<table role = "presentation">
<tr><td><code>level</code></td>
<td>
<p>Either <code>graph</code> or <code>vertex</code>.</p>
</td></tr>
<tr><td><code>removed.subs</code></td>
<td>
<p>A character vector of Study.ID's removed due to
incomplete data</p>
</td></tr>
<tr><td><code>X.m</code>, <code>X.y</code></td>
<td>
<p>Design matrix and numeric array for the model with the
mediator as the outcome variable (<code>X.m</code>) and for the model with the
mediator as an additional predictor (<code>X.y</code>), respectively</p>
</td></tr>
<tr><td><code>y.m</code>, <code>y.y</code></td>
<td>
<p>Outcome variables for the associated design matrices above.
<code>y.m</code> will be a matrix of size <em># subj. X # regions</em></p>
</td></tr>
<tr><td><code>res.obs</code></td>
<td>
<p>A <code>data.table</code> of the observed values of the point
estimates.</p>
</td></tr>
<tr><td><code>res.ci</code></td>
<td>
<p>A <code>data.table</code> of the confidence intervals for the
effect estimates.</p>
</td></tr>
<tr><td><code>res.p</code></td>
<td>
<p>A <code>data.table</code> of the two-sided p-values for the effect
estimates</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>Logical, the <code>boot</code> argument.</p>
</td></tr>
<tr><td><code>boot.ci.type</code></td>
<td>
<p>Character string indicating which type of bootstrap
confidence intervals were calculated.</p>
</td></tr>
<tr><td><code>res.boot</code></td>
<td>
<p>A <code>data.table</code> with <code>N</code> rows of the bootstrap
results for all effects.</p>
</td></tr>
<tr><td><code>treat</code></td>
<td>
<p>Character string of the treatment variable.</p>
</td></tr>
<tr><td><code>mediator</code></td>
<td>
<p>Character string of the mediator variable.</p>
</td></tr>
<tr><td><code>outcome</code></td>
<td>
<p>Character string of the outcome variable.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>Returns <code>NULL</code>; not used in this package.</p>
</td></tr>
<tr><td><code>INT</code></td>
<td>
<p>Logical indicating whether the models included an interaction
between treatment and mediator.</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>The confidence level.</p>
</td></tr>
<tr><td><code>control.value</code></td>
<td>
<p>The value of the treatment variable used as the
control condition.</p>
</td></tr>
<tr><td><code>treat.value</code></td>
<td>
<p>The value of the treatment variable used as the
treatment condition.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Integer; the number of observations in the models.</p>
</td></tr>
<tr><td><code>sims</code></td>
<td>
<p>Integer; the number of bootstrap replications.</p>
</td></tr>
<tr><td><code>covar.names</code></td>
<td>
<p>The pre-treatment covariate names.</p>
</td></tr>
</table>
<p><code>bg_to_mediate</code> returns an object of class <code>mediate</code>
</p>


<h3>Note</h3>

<p>As of <code>brainGraph v2.0.0</code>, this function has been tested only for
a treatment (independent) variable <em>X</em> being a <em>factor</em> (e.g.,
disease group, old vs. young, etc.). If your treatment variable has more
than 2 levels, then you must explicitly specify the levels you would like to
compare; otherwise, the baseline and first levels are taken to be the
control and treatment values, respectively. Be aware that these are <em>0</em>
indexed; that is, if you have 3 groups and you would like the treatment
group to be the 3rd, you should specify as either the group's character
string or as <code>treat.value=2</code>.
</p>
<p>Allowing for treatment-mediator interaction (setting <code>int=TRUE</code>)
currently will only work properly if the mediator is a continuous variable;
since the mediator is always a graph metric, this should always be the case.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Tingley, D. and Yamamoto, T. and Hirose, K. and Keele, L. and
Imai, K. (2014) mediation: R package for causal mediation analysis.
<em>Journal of Statistical Software</em>, <b>59(5)</b>, 1&ndash;38.
doi: <a href="https://doi.org/10.18637/jss.v059.i05">10.18637/jss.v059.i05</a>
</p>
<p>Imai, K. and Keele, L. and Yamamoto, T. (2010) Identification
inference, and sensitivity analysis for causal mediation effects.
<em>Statistical Science</em>, <b>25(1)</b>, 51&ndash;71.
doi: <a href="https://doi.org/10.1214/10-STS321">10.1214/10-STS321</a>
</p>
<p>Imai, K. and Keele, L. and Tingley, D. (2010) A general approach
to causal mediation analysis. <em>Psychological Methods</em>, <b>15(4)</b>,
309&ndash;334. doi: <a href="https://doi.org/10.1037/a0020761">10.1037/a0020761</a>
</p>
<p>Imai, K. and Keele, L. and Tingley, D. and Yamamoto, T. (2011)
Unpacking the black box of causality: learning about causal mechanisms from
experimental and observational studies. <em>American Political Science
Review</em>, <b>105(4)</b>, 765&ndash;789.
doi: <a href="https://doi.org/10.1017/S0003055411000414">10.1017/S0003055411000414</a>
</p>
<p>Imai, K. and Yamamoto, T. (2013) Identification and sensitivity
analysis for multiple causal mechanisms: revisiting evidence from framing
experiments. <em>Political Analysis</em>, <b>21(2)</b>, 141&ndash;171.
doi: <a href="https://doi.org/10.1093/pan/mps040">10.1093/pan/mps040</a>
</p>


<h3>See Also</h3>

<p><code><a href="mediation.html#topic+mediate">mediate</a></code>
</p>
<p>Other Group analysis functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+GLM">GLM</a></code>, <code><a href="#topic+NBS">NBS</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>, <code><a href="#topic+mtpc">mtpc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
med.EglobWt.FSIQ &lt;- brainGraph_mediate(g[[5]], covars.med, 'E.global.wt',
  'Group', 'FSIQ', covar.names=c('age', 'gender'), N=1e4)
med.strength.FSIQ &lt;- brainGraph_mediate(g[[5]], covars.med, 'strength',
  'Group', 'FSIQ', covar.names=c('age', 'gender'), level='vertex')

## End(Not run)
</code></pre>

<hr>
<h2 id='mtpc'>Multi-threshold permutation correction</h2><span id='topic+mtpc'></span><span id='topic+summary.mtpc'></span><span id='topic+plot.mtpc'></span><span id='topic+nobs.mtpc'></span><span id='topic+terms.mtpc'></span><span id='topic+formula.mtpc'></span><span id='topic+labels.mtpc'></span><span id='topic+case.names.mtpc'></span><span id='topic+variable.names.mtpc'></span><span id='topic+df.residual.mtpc'></span><span id='topic+region.names.mtpc'></span><span id='topic+nregions.mtpc'></span>

<h3>Description</h3>

<p>Applies the <em>multi-threshold permutation correction (MTPC)</em> method to
perform inference in graph theory analyses of brain MRI data.
</p>
<p>Plot the statistics from an MTPC analysis, along with the maximum permuted
statistics. The output is similar to Figure 11 in Drakesmith et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtpc(g.list, thresholds, covars, measure, contrasts, con.type = c("t",
  "f"), outcome = NULL, con.name = NULL, level = c("vertex",
  "graph"), clust.size = 3L, perm.method = c("freedmanLane",
  "terBraak", "smith", "draperStoneman", "manly", "stillWhite"),
  part.method = c("beckmann", "guttman", "ridgway"), N = 500L,
  perms = NULL, alpha = 0.05, res.glm = NULL, long = TRUE, ...)

## S3 method for class 'mtpc'
summary(object, contrast = NULL, digits = max(3L,
  getOption("digits") - 2L), print.head = TRUE, ...)

## S3 method for class 'mtpc'
plot(x, contrast = 1L, region = NULL,
  only.sig.regions = TRUE, show.null = TRUE, caption.stats = FALSE,
  ...)

## S3 method for class 'mtpc'
nobs(object, ...)

## S3 method for class 'mtpc'
terms(x, ...)

## S3 method for class 'mtpc'
formula(x, ...)

## S3 method for class 'mtpc'
labels(object, ...)

## S3 method for class 'mtpc'
case.names(object, ...)

## S3 method for class 'mtpc'
variable.names(object, ...)

## S3 method for class 'mtpc'
df.residual(object, ...)

## S3 method for class 'mtpc'
region.names(object)

## S3 method for class 'mtpc'
nregions(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mtpc_+3A_g.list">g.list</code></td>
<td>
<p>A list of <code>brainGraphList</code> objects for all thresholds</p>
</td></tr>
<tr><td><code id="mtpc_+3A_thresholds">thresholds</code></td>
<td>
<p>Numeric vector of the thresholds applied to the raw
connectivity matrices.</p>
</td></tr>
<tr><td><code id="mtpc_+3A_covars">covars</code></td>
<td>
<p>A <code>data.table</code> of covariates</p>
</td></tr>
<tr><td><code id="mtpc_+3A_measure">measure</code></td>
<td>
<p>Character string of the graph measure of interest</p>
</td></tr>
<tr><td><code id="mtpc_+3A_contrasts">contrasts</code></td>
<td>
<p>Numeric matrix (for T statistics) or list of matrices (for F
statistics) specifying the contrast(s) of interest; if only one contrast is
desired, you can supply a vector (for T statistics)</p>
</td></tr>
<tr><td><code id="mtpc_+3A_con.type">con.type</code></td>
<td>
<p>Character string; either <code>'t'</code> or <code>'f'</code> (for t or
F-statistics). Default: <code>'t'</code></p>
</td></tr>
<tr><td><code id="mtpc_+3A_outcome">outcome</code></td>
<td>
<p>Character string specifying the name of the outcome variable,
if it differs from the graph metric (<code>measure</code>)</p>
</td></tr>
<tr><td><code id="mtpc_+3A_con.name">con.name</code></td>
<td>
<p>Character vector of the contrast name(s); if <code>contrasts</code>
has row/list names, those will be used for reporting results</p>
</td></tr>
<tr><td><code id="mtpc_+3A_level">level</code></td>
<td>
<p>Character string; either <code>vertex</code> (default) or
<code>graph</code></p>
</td></tr>
<tr><td><code id="mtpc_+3A_clust.size">clust.size</code></td>
<td>
<p>Integer indicating the size of &ldquo;clusters&rdquo; (i.e.,
consecutive thresholds for which the observed statistic exceeds the null)
(default: <code>3L</code>)</p>
</td></tr>
<tr><td><code id="mtpc_+3A_perm.method">perm.method</code></td>
<td>
<p>Character string indicating the permutation method.
Default: <code>'freedmanLane'</code></p>
</td></tr>
<tr><td><code id="mtpc_+3A_part.method">part.method</code></td>
<td>
<p>Character string; the method of partitioning the design
matrix into covariates of interest and nuisance. Default: <code>'beckmann'</code></p>
</td></tr>
<tr><td><code id="mtpc_+3A_n">N</code></td>
<td>
<p>Integer; number of permutations to create. Default: <code>5e3</code></p>
</td></tr>
<tr><td><code id="mtpc_+3A_perms">perms</code></td>
<td>
<p>Matrix of permutations, if you would like to provide your own.
Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="mtpc_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; the significance level. Default: 0.05</p>
</td></tr>
<tr><td><code id="mtpc_+3A_res.glm">res.glm</code></td>
<td>
<p>A list of <code>bg_GLM</code> objects, as output by a previous run
of <code>mtpc</code>. Useful if you want to change the cluster size without
re-running all of the GLM's and permutations (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="mtpc_+3A_long">long</code></td>
<td>
<p>Logical indicating whether or not to return all permutation
results. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="mtpc_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a></code> and/or
<code><a href="#topic+brainGraph_GLM_design">brainGraph_GLM_design</a></code></p>
</td></tr>
<tr><td><code id="mtpc_+3A_object">object</code>, <code id="mtpc_+3A_x">x</code></td>
<td>
<p>A <code>mtpc</code> object</p>
</td></tr>
<tr><td><code id="mtpc_+3A_contrast">contrast</code></td>
<td>
<p>Integer specifying the contrast to plot/summarize; defaults
to showing results for all contrasts</p>
</td></tr>
<tr><td><code id="mtpc_+3A_digits">digits</code></td>
<td>
<p>Integer specifying the number of digits to display for P-values</p>
</td></tr>
<tr><td><code id="mtpc_+3A_print.head">print.head</code></td>
<td>
<p>Logical indicating whether or not to print only the first
and last 5 rows of the statistics tables (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="mtpc_+3A_region">region</code></td>
<td>
<p>Character string specifying which region's results to
plot; only relevant if <code>level='vertex'</code>. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="mtpc_+3A_only.sig.regions">only.sig.regions</code></td>
<td>
<p>Logical indicating whether to plot only significant
regions (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="mtpc_+3A_show.null">show.null</code></td>
<td>
<p>Logical indicating whether to plot points of the maximum
null statistics (per permutation)</p>
</td></tr>
<tr><td><code id="mtpc_+3A_caption.stats">caption.stats</code></td>
<td>
<p>Logical indicating whether to print the MTPC statistics
in the caption of the plot. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a multi-step procedure: (steps 3-4 are the time-consuming steps)
</p>

<ol>
<li><p> Apply thresholds <code class="reqn">\tau</code> to the networks, and compute network
metrics for all networks and thresholds. (already done beforehand)
</p>
</li>
<li><p> Compute test statistics <code class="reqn">S_{obs}</code> for each threshold. (done by
<code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a></code>)
</p>
</li>
<li><p> Permute group assignments and compute test statistics for each
permutation and threshold. (done by <code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a></code>)
</p>
</li>
<li><p> Build a null distribution of the maximum statistic across thresholds
(and across brain regions) for each permutation. (done by
<code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a></code>)
</p>
</li>
<li><p> Determine the critical value, <code class="reqn">S_{crit}</code> from the null
distribution of maximum statistics.
</p>
</li>
<li><p> Identify clusters where <code class="reqn">S_{obs} &gt; S_{crit}</code> and compute the AUC
for these clusters (denoted <code class="reqn">A_{MTPC}</code>).
</p>
</li>
<li><p> Compute a critical AUC (<code class="reqn">A_{crit}</code>) from the mean of the
supra-critical AUC's for the permuted tests.
</p>
</li>
<li><p> Reject <code class="reqn">H_0</code> if <code class="reqn">A_{MTPC} &gt; A_{crit}</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>An object of class <code>mtpc</code> with some input arguments plus the
following elements:
</p>
<table role = "presentation">
<tr><td><code>X</code>, <code>qr</code>, <code>cov.unscaled</code></td>
<td>
<p>Design matrix, QR decomposition, and unscaled
covariance matrix, if the design is the same across thresholds</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>The contrast matrix or list of matrices</p>
</td></tr>
<tr><td><code>con.name</code></td>
<td>
<p>Contrast names</p>
</td></tr>
<tr><td><code>removed.subs</code></td>
<td>
<p>Named integer vector of subjects with incomplete data</p>
</td></tr>
<tr><td><code>atlas</code></td>
<td>
<p>The atlas of the input graphs</p>
</td></tr>
<tr><td><code>rank</code>, <code>df.residual</code></td>
<td>
<p>The model rank and residual degrees of freedom</p>
</td></tr>
<tr><td><code>res.glm</code></td>
<td>
<p>List with length equal to the number of thresholds; each
list element is the output from <code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a></code></p>
</td></tr>
<tr><td><code>DT</code></td>
<td>
<p>A <code>data.table</code> for all thresholds, combined from the outputs
of <code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a></code></p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A data.table containing <code>S.mtpc</code> (the max. observed
statistic), <code>tau.mtpc</code> (the threshold of the max. observed
statistic), <code>S.crit</code> (the critical statistic value), and
<code>A.crit</code> (the critical AUC)</p>
</td></tr>
<tr><td><code>null.dist</code></td>
<td>
<p>Numeric array with <code>N</code> columns and number of rows
equal to the number of thresholds. The 3rd dimension is for each
contrast. Each element of the array is the maximum statistic
for that permutation, threshold, and contrast combination.</p>
</td></tr>
<tr><td><code>perm.order</code></td>
<td>
<p>Numeric matrix; the permutation set applied for all
thresholds (each row is a separate permutation)</p>
</td></tr>
</table>
<p>The <code>plot</code> method returns a <code>trellis</code> object or a list of
<code>ggplot</code> objects
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Drakesmith, M. and Caeyenberghs, K. and Dutt, A. and Lewis, G. and
David, A.S. and Jones, D.K. (2015) Overcoming the effects of false
positives and threshold bias in graph theoretical analyses of neuroimaging
data. <em>NeuroImage</em>, <b>118</b>, 313&ndash;333.
doi: <a href="https://doi.org/10.1016/j.neuroimage.2015.05.011">10.1016/j.neuroimage.2015.05.011</a>
</p>


<h3>See Also</h3>

<p>Other Group analysis functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+GLM">GLM</a></code>, <code><a href="#topic+Mediation">Mediation</a></code>,
<code><a href="#topic+NBS">NBS</a></code>, <code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>
</p>
<p>Other GLM functions: <code><a href="#topic+GLM+20design">GLM design</a></code>,
<code><a href="#topic+GLM+20fits">GLM fits</a></code>, <code><a href="#topic+GLM">GLM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
diffs.mtpc &lt;- mtpc(g.list=g.norm, thresholds=thresholds, N=N,
     covars=covars.dti, measure='E.nodal.wt', coding='effects',
     contrasts=c(0, 0, 0, 0, -2), alt='greater',
     binarize=c('Sex', 'Scanner'), con.name='Group 1 &gt; Group 2')
sig.regions &lt;- diffs.mtpc$DT[A.mtpc &gt; A.crit]

## End(Not run)
## Not run: 
mtpcPlots &lt;- plot(mtpc.diffs)

## Arrange plots into 3x3 grids
ml &lt;- marrangeGrob(mtpcPlots, nrow=3, ncol=3)
ggsave('mtpc.pdf', ml)

## End(Not run)
</code></pre>

<hr>
<h2 id='NBS'>Network-based statistic for brain MRI data</h2><span id='topic+NBS'></span><span id='topic+summary.NBS'></span><span id='topic+nobs.NBS'></span><span id='topic+terms.NBS'></span><span id='topic+formula.NBS'></span><span id='topic+labels.NBS'></span><span id='topic+case.names.NBS'></span><span id='topic+variable.names.NBS'></span><span id='topic+df.residual.NBS'></span><span id='topic+nregions.NBS'></span>

<h3>Description</h3>

<p>Calculates the <em>network-based statistic (NBS)</em>, which allows for
family-wise error (FWE) control over network data, introduced for brain MRI
data by Zalesky et al. Requires a three-dimensional array of all subjects'
connectivity matrices and a <code>data.table</code> of covariates, in addition to a
contrast matrix or list. A null distribution of the largest connected
component size is created by fitting a GLM to permuted data. For details, see
<code><a href="#topic+GLM">GLM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NBS(A, covars, contrasts, con.type = c("t", "f"), X = NULL,
  con.name = NULL, p.init = 0.001, perm.method = c("freedmanLane",
  "terBraak", "smith", "draperStoneman", "manly", "stillWhite"),
  part.method = c("beckmann", "guttman", "ridgway"), N = 1000,
  perms = NULL, symm.by = c("max", "min", "avg"),
  alternative = c("two.sided", "less", "greater"), long = FALSE, ...)

## S3 method for class 'NBS'
summary(object, contrast = NULL, digits = max(3L,
  getOption("digits") - 2L), ...)

## S3 method for class 'NBS'
nobs(object, ...)

## S3 method for class 'NBS'
terms(x, ...)

## S3 method for class 'NBS'
formula(x, ...)

## S3 method for class 'NBS'
labels(object, ...)

## S3 method for class 'NBS'
case.names(object, ...)

## S3 method for class 'NBS'
variable.names(object, ...)

## S3 method for class 'NBS'
df.residual(object, ...)

## S3 method for class 'NBS'
nregions(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NBS_+3A_a">A</code></td>
<td>
<p>Three-dimensional array of all subjects' connectivity matrices</p>
</td></tr>
<tr><td><code id="NBS_+3A_covars">covars</code></td>
<td>
<p>A <code>data.table</code> of covariates</p>
</td></tr>
<tr><td><code id="NBS_+3A_contrasts">contrasts</code></td>
<td>
<p>Numeric matrix (for T statistics) or list of matrices (for F
statistics) specifying the contrast(s) of interest; if only one contrast is
desired, you can supply a vector (for T statistics)</p>
</td></tr>
<tr><td><code id="NBS_+3A_con.type">con.type</code></td>
<td>
<p>Character string; either <code>'t'</code> or <code>'f'</code> (for t or
F-statistics). Default: <code>'t'</code></p>
</td></tr>
<tr><td><code id="NBS_+3A_x">X</code></td>
<td>
<p>Numeric matrix, if you wish to supply your own design matrix.
Ignored if <code>outcome != measure</code>.</p>
</td></tr>
<tr><td><code id="NBS_+3A_con.name">con.name</code></td>
<td>
<p>Character vector of the contrast name(s); if <code>contrasts</code>
has row/list names, those will be used for reporting results</p>
</td></tr>
<tr><td><code id="NBS_+3A_p.init">p.init</code></td>
<td>
<p>Numeric; the initial p-value threshold (default: <code>0.001</code>)</p>
</td></tr>
<tr><td><code id="NBS_+3A_perm.method">perm.method</code></td>
<td>
<p>Character string indicating the permutation method.
Default: <code>'freedmanLane'</code></p>
</td></tr>
<tr><td><code id="NBS_+3A_part.method">part.method</code></td>
<td>
<p>Character string; the method of partitioning the design
matrix into covariates of interest and nuisance. Default: <code>'beckmann'</code></p>
</td></tr>
<tr><td><code id="NBS_+3A_n">N</code></td>
<td>
<p>Integer; number of permutations to create. Default: <code>5e3</code></p>
</td></tr>
<tr><td><code id="NBS_+3A_perms">perms</code></td>
<td>
<p>Matrix of permutations, if you would like to provide your own.
Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="NBS_+3A_symm.by">symm.by</code></td>
<td>
<p>Character string; how to create symmetric off-diagonal
elements. Default: <code>max</code></p>
</td></tr>
<tr><td><code id="NBS_+3A_alternative">alternative</code></td>
<td>
<p>Character string, whether to do a two- or one-sided test.
Default: <code>'two.sided'</code></p>
</td></tr>
<tr><td><code id="NBS_+3A_long">long</code></td>
<td>
<p>Logical indicating whether or not to return all permutation
results. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="NBS_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+brainGraph_GLM_design">brainGraph_GLM_design</a></code></p>
</td></tr>
<tr><td><code id="NBS_+3A_object">object</code>, <code id="NBS_+3A_x">x</code></td>
<td>
<p>A <code>NBS</code> object</p>
</td></tr>
<tr><td><code id="NBS_+3A_contrast">contrast</code></td>
<td>
<p>Integer specifying the contrast to plot/summarize; defaults
to showing results for all contrasts</p>
</td></tr>
<tr><td><code id="NBS_+3A_digits">digits</code></td>
<td>
<p>Integer specifying the number of digits to display for P-values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When printing a <code>summary</code>, you can include arguments to
<code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>NBS</code> with some input arguments in addition
to:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>The design matrix</p>
</td></tr>
<tr><td><code>removed.subs</code></td>
<td>
<p>Character vector of subject ID's removed due to
incomplete data (if any)</p>
</td></tr>
<tr><td><code>T.mat</code></td>
<td>
<p>3-d array of (symmetric) numeric matrices containing the
statistics for each edge</p>
</td></tr>
<tr><td><code>p.mat</code></td>
<td>
<p>3-d array of (symmetric) numeric matrices containing the
P-values</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>List containing data tables of the observed and permuted
connected component sizes and P-values</p>
</td></tr>
<tr><td><code>rank</code>, <code>df.residual</code>, <code>qr</code>, <code>cov.unscaled</code></td>
<td>
<p>The rank, residual degrees of
freedom, QR decomposition, and unscaled covariance matrix of the design
matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is assumed that the order of the subjects in <code>covars</code> matches
that of the input array <code>A</code>. You will need to ensure that this is the
case. Prior to <code>v3.0.0</code>, the <code>covars</code> table was sorted by
<code>Study.ID</code> before creating the design matrix.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Zalesky, A. and Fornito,  A. and Bullmore, E.T. (2010)
Network-based statistic: identifying differences in brain networks.
<em>NeuroImage</em>, <b>53(4)</b>, 1197&ndash;1207.
doi: <a href="https://doi.org/10.1016/j.neuroimage.2010.06.041">10.1016/j.neuroimage.2010.06.041</a>
</p>


<h3>See Also</h3>

<p>Other Group analysis functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+GLM">GLM</a></code>, <code><a href="#topic+Mediation">Mediation</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>, <code><a href="#topic+mtpc">mtpc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
max.comp.nbs &lt;- NBS(A.norm.sub[[1]], covars.dti, N=5e3)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_brainGraph_multi'>Save PNG of one or three views for all graphs in a brainGraphList</h2><span id='topic+plot_brainGraph_multi'></span><span id='topic+slicer'></span>

<h3>Description</h3>

<p><code>plot_brainGraph_multi</code> writes a PNG file to disk containing three views
(columns) of 1 or more <code>brainGraph</code> objects (from left-to-right): left
sagittal, axial, and right sagittal. The number of rows in the figure will
equal the number of graphs to plot.
</p>
<p><code>slicer</code> writes a PNG file to disk containing a single view (i.e.,
either sagittal, axial, or circular) of all <code>brainGraph</code> objects in the
input list/<code>brainGraphList</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_brainGraph_multi(g.list, filename = "orthoview.png",
  subgraph = NULL, main = NULL, label = NULL, cex.main = 1, ...)

slicer(g.list, nrows, ncols, plane = "axial", hemi = "both",
  filename = "all.png", main = NULL, cex.main = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_brainGraph_multi_+3A_g.list">g.list</code></td>
<td>
<p>A <code>brainGraphList</code> or a list of <code>brainGraph</code> objects</p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_filename">filename</code></td>
<td>
<p>Character string of the filename of the PNG to be written.</p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_subgraph">subgraph</code></td>
<td>
<p>A vector or list of character strings to (optionally) subset
the graph(s), possibly by multiple conditions</p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_main">main</code></td>
<td>
<p>A vector or list of character strings to be placed in the main
title of the center (axial) plot for each graph</p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_label">label</code></td>
<td>
<p>A vector or list of character strings to be placed in one of the
corners of the left plot (sagittal) in each row</p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_cex.main">cex.main</code></td>
<td>
<p>Numeric specifying the level of character expansion for the
plot titles. Default: <code>1</code> (no expansion)</p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+plot.brainGraph">plot.brainGraph</a></code></p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_nrows">nrows</code></td>
<td>
<p>Integer; the number of rows in the figure</p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_ncols">ncols</code></td>
<td>
<p>Integer; the number of columns in the figure</p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_plane">plane</code></td>
<td>
<p>Character string indicating which orientation to plot.
Default: <code>'axial'</code></p>
</td></tr>
<tr><td><code id="plot_brainGraph_multi_+3A_hemi">hemi</code></td>
<td>
<p>Character string indicating which hemisphere to plot. Default:
<code>'both'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whether the first input is a <code>brainGraphList</code> object or a <code>list</code> of
<code>brainGraph</code> objects, <em>all</em> graphs in the object will be displayed
in the figure. For <code>plot_brainGraph_multi</code>, this may be undesirable if
you have more than 4 or 5 graphs in one object. You can choose fewer by using
simple subsetting operations (see Examples below).
</p>


<h3>Using subgraphs, titles, and labels</h3>

<p>There are three arguments that can differ for each graph to be displayed.
Each follows the same &ldquo;rules&rdquo;. If you would like the same value
applied to all graphs, you can specify a <code>character</code> string. If you
would like a different value for each group, you must supply a <code>vector</code>
or <code>list</code> with length equal to the number of graphs. If its length is
less than the number of graphs, values will be recycled. To &ldquo;skip&rdquo;
applying a value to one (or more) graph(s), you can use the <code>NULL</code> value
only within a list (see the Examples below).
</p>

<dl>
<dt>subgraph</dt><dd><p>Can be used to apply one or more conditions for subsetting
the graph(s).</p>
</dd>
<dt>main</dt><dd><p>Controls the main plot title, which appears in the <em>axial</em>
view along with each graph's <code>name</code> attribute. Depending on the
<code>level</code> of the <code>brainGraphList</code>, this will either be a Study
ID, Group name, or contrast name.</p>
</dd>
<dt>label</dt><dd><p>Can be used to print a text label in a corner for each
group/graph. For example, you can print a letter if you will refer to,
e.g., &ldquo;Figure 1A&rdquo;, &ldquo;Figure 1B&rdquo;, etc.</p>
</dd>
</dl>



<h3>Note</h3>

<p>All other arguments (passed to <code><a href="#topic+plot.brainGraph">plot.brainGraph</a></code>) will be
applied to <em>all</em> graphs. For example, if you include
<code>vertex.label=NA</code> in the function call, vertex labels will be omitted
for all graphs.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other Plotting functions: <code><a href="#topic+Plotting+20GLM+20graphs">Plotting GLM graphs</a></code>,
<code><a href="#topic+plot.brainGraphList">plot.brainGraphList</a></code>,
<code><a href="#topic+plot.brainGraph">plot.brainGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## "g.hubs" contains 2 groups; apply same subset to both
plot_brainGraph_multi(g.hubs, filename='Figure01_hubs.png',
  subgraph='N &gt; 0', vertex.color='color.lobe', vertex.size=15,
  show.legend=TRUE, vertex.label.cex=1.5)

## Single group, different subgraphs for both plots
## "g" is a "brainGraphList" object
gg &lt;- g[rep(1, 3), drop=FALSE]
plot_brainGraph_multi(gg, filename='group1_5-6-7core.png',
  vertex.color='color.lobe', edge.color='color.lobe', vertex.label=NA,
  subgraph=as.list(paste('coreness &gt;', 5:7)),
  main=as.list(paste('k-core', 5:7)))

## Apply different subset for groups 1 &amp; 3; no subset for group 2
plot_brainGraph_multi(g, groups=1:3, vertex.label=NA,
  subgraph=list('degree &gt; 5', NULL, 'degree &gt; 4'))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_global'>Plot global graph measures across densities</h2><span id='topic+plot_global'></span>

<h3>Description</h3>

<p>Create a faceted line plot of global graph measures across a range of graph
densities, calculated from a list of <code>brainGraphList</code> objects. This
requires that the variables of interest are graph-level attributes of the
input graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_global(g.list, xvar = c("density", "threshold"), vline = NULL,
  level.names = "default", exclude = NULL, perms = NULL,
  alt = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_global_+3A_g.list">g.list</code></td>
<td>
<p>List of <code>brainGraphList</code> objects; the length of this list
should equal the number of thresholds/densities in the study</p>
</td></tr>
<tr><td><code id="plot_global_+3A_xvar">xvar</code></td>
<td>
<p>A character string indicating whether the variable of
interest is &ldquo;density&rdquo; or &ldquo;threshold&rdquo; (e.g. with DTI data)</p>
</td></tr>
<tr><td><code id="plot_global_+3A_vline">vline</code></td>
<td>
<p>Numeric of length 1 specifying the x-intercept if you would like
to plot a vertical dashed line (e.g., if there is a particular density of
interest). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_global_+3A_level.names">level.names</code></td>
<td>
<p>Character vector of variable names, which are displayed as
facet labels. If you do not want to change them, specify <code>NULL</code>. By
default, they are changed to pre-set values.</p>
</td></tr>
<tr><td><code id="plot_global_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of variables to exclude. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_global_+3A_perms">perms</code></td>
<td>
<p>A <code>data.table</code> of permutation group differences</p>
</td></tr>
<tr><td><code id="plot_global_+3A_alt">alt</code></td>
<td>
<p>Character vector of alternative hypotheses; required if
<em>perms</em> is provided, but defaults to &ldquo;two.sided&rdquo; for all
variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can choose to insert a dashed vertical line at a specific
density/threshold of interest, rename the variable levels (which become the
facet titles), exclude variables, and include a <code>brainGraph_permute</code>
object of permutation data to add asterisks indicating significant group
differences.
</p>


<h3>Value</h3>

<p>Either a <code>trellis</code> or <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>

<hr>
<h2 id='plot_rich_norm'>Plot normalized rich club coefficients against degree threshold</h2><span id='topic+plot_rich_norm'></span>

<h3>Description</h3>

<p>Returns a line plot of the normalized rich club coefficient. Optionally, can
include a shaded region demarcating the <code><a href="#topic+rich_core">rich_core</a></code> cutoff (if
you supply a list of graph objects to the <code>g</code> argument).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rich_norm(rich.dt, facet.by = c("density", "threshold"), densities,
  alpha = 0.05, fdr = TRUE, g.list = NULL, smooth = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_rich_norm_+3A_rich.dt">rich.dt</code></td>
<td>
<p>A <code>data.table</code> with rich-club coefficients</p>
</td></tr>
<tr><td><code id="plot_rich_norm_+3A_facet.by">facet.by</code></td>
<td>
<p>A character string indicating whether the variable of
interest is &ldquo;density&rdquo; or &ldquo;threshold&rdquo; (e.g. with DTI data)</p>
</td></tr>
<tr><td><code id="plot_rich_norm_+3A_densities">densities</code></td>
<td>
<p>A numeric vector of the densities to plot</p>
</td></tr>
<tr><td><code id="plot_rich_norm_+3A_alpha">alpha</code></td>
<td>
<p>The significance level. Default: <code>0.05</code></p>
</td></tr>
<tr><td><code id="plot_rich_norm_+3A_fdr">fdr</code></td>
<td>
<p>A logical, indicating whether or not to use the FDR-adjusted
p-value for determining significance. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot_rich_norm_+3A_g.list">g.list</code></td>
<td>
<p>A list <code>brainGraphList</code> objects; required if you want to
plot a shaded region demarcating the <code><a href="#topic+rich_core">rich_core</a></code></p>
</td></tr>
<tr><td><code id="plot_rich_norm_+3A_smooth">smooth</code></td>
<td>
<p>Logical indicating whether or not to plot a smooth curve when
data from multiple subjects (per group) are present. Default: <code>TRUE</code>.
Ignored for group-level data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>trellis</code> or <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other Rich-club functions: <code><a href="#topic+Rich+20Club">Rich Club</a></code>,
<code><a href="#topic+rich_club_attrs">rich_club_attrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot_rich_norm(rich.dt, facet.by='density', densities[N:(N+1)], g=g)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_vertex_measures'>Plot vertex-level graph measures at a single density or threshold</h2><span id='topic+plot_vertex_measures'></span>

<h3>Description</h3>

<p>Creates boxplots of a single vertex-level graph measure at a single density
or threshold, grouped by the variable specified by <code>group.by</code> and
optionally faceted by another variable (e.g., <em>lobe</em> or <em>network</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_vertex_measures(g.list, measure, facet.by = NULL,
  group.by = getOption("bg.group"), type = c("violin", "boxplot"),
  show.points = FALSE, ylabel = measure, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_vertex_measures_+3A_g.list">g.list</code></td>
<td>
<p>A <code>brainGraphList</code> or a list of <code>brainGraph</code> objects</p>
</td></tr>
<tr><td><code id="plot_vertex_measures_+3A_measure">measure</code></td>
<td>
<p>A character string of the graph measure to plot</p>
</td></tr>
<tr><td><code id="plot_vertex_measures_+3A_facet.by">facet.by</code></td>
<td>
<p>Character string indicating the variable to facet by (if
any). Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_vertex_measures_+3A_group.by">group.by</code></td>
<td>
<p>Character string indicating which variable to group the data
by. Default: <code>getOption('bg.group')</code></p>
</td></tr>
<tr><td><code id="plot_vertex_measures_+3A_type">type</code></td>
<td>
<p>Character string indicating the plot type. Default:
<code>'violin'</code></p>
</td></tr>
<tr><td><code id="plot_vertex_measures_+3A_show.points">show.points</code></td>
<td>
<p>Logical indicating whether or not to show individual data
points (default: FALSE)</p>
</td></tr>
<tr><td><code id="plot_vertex_measures_+3A_ylabel">ylabel</code></td>
<td>
<p>A character string for the y-axis label</p>
</td></tr>
<tr><td><code id="plot_vertex_measures_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>geom_boxplot</code> or <code>geom_violin</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>trellis</code> or <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p.deg &lt;- plot_vertex_measures(g[[1]], facet.by='network', measure='degree')

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_volumetric'>Plot group distributions of volumetric measures for a given brain region</h2><span id='topic+plot_volumetric'></span>

<h3>Description</h3>

<p>This function takes a &ldquo;tidied&rdquo; dataset of cortical volumetric measures
(thickness, volume, LGI, etc.) and plots a histogram or violin plot for 1 or
more groups, and of 1 or more brain regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_volumetric(dat, regions, type = c("violin", "histogram"),
  all.vals = TRUE, modality = c("thickness", "volume", "lgi", "area"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_volumetric_+3A_dat">dat</code></td>
<td>
<p>A data table of volumetric data; needs columns for 'Group',
'region', and 'value'</p>
</td></tr>
<tr><td><code id="plot_volumetric_+3A_regions">regions</code></td>
<td>
<p>A vector of character strings or integers of the brain
region(s) to plot; if integer, the region(s) is/are chosen from the input
data table based on the index</p>
</td></tr>
<tr><td><code id="plot_volumetric_+3A_type">type</code></td>
<td>
<p>A character string indicating the plot type; either 'histogram'
or 'violin'</p>
</td></tr>
<tr><td><code id="plot_volumetric_+3A_all.vals">all.vals</code></td>
<td>
<p>A logical indicating whether or not to plot horizontal lines
for all observations (only valid for 'violin' plots) (default: TRUE)</p>
</td></tr>
<tr><td><code id="plot_volumetric_+3A_modality">modality</code></td>
<td>
<p>A character string indicating the type of volumetric measure
('thickness', 'volume', 'lgi', or 'area')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>trellis</code> or <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other Structural covariance network functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+IndividualContributions">IndividualContributions</a></code>,
<code><a href="#topic+Residuals">Residuals</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>,
<code><a href="#topic+corr.matrix">corr.matrix</a></code>, <code><a href="#topic+import_scn">import_scn</a></code>
</p>

<hr>
<h2 id='plot.brainGraph'>Plot a brain graph with a specific spatial layout</h2><span id='topic+plot.brainGraph'></span>

<h3>Description</h3>

<p><code>plot.brainGraph</code> plots a graph in which the spatial layout of the nodes
is important. The network itself is plotted over a brain MRI slice from the
MNI152 template by default (when <code>mni=TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brainGraph'
plot(x, plane = c("axial", "sagittal", "circular"),
  hemi = c("both", "L", "R"), mni = TRUE, subgraph = NULL,
  main = NULL, subtitle = "default", label = NULL, side = 1,
  line = -2, adj = 0.025, cex = 2.5, col = "white", font = 2,
  show.legend = FALSE, rescale = FALSE, asp = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.brainGraph_+3A_x">x</code></td>
<td>
<p>A <code>brainGraph</code> graph object</p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_plane">plane</code></td>
<td>
<p>Character string indicating which orientation to plot.
Default: <code>'axial'</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_hemi">hemi</code></td>
<td>
<p>Character string indicating which hemisphere to plot. Default:
<code>'both'</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_mni">mni</code></td>
<td>
<p>Logical indicating whether or not to plot over a slice of the
brain. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_subgraph">subgraph</code></td>
<td>
<p>Character string specifying a logical condition for vertices
to plot. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_main">main</code></td>
<td>
<p>Character string; the main title. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_subtitle">subtitle</code></td>
<td>
<p>Character string; the subtitle. Default: <code>'default'</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_label">label</code></td>
<td>
<p>Character string specifying text to display in one corner of the
plot (e.g., <code>'A.'</code>). Default: NULL</p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_side">side</code></td>
<td>
<p>Label placement. Default: <code>1</code> (bottom)</p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_line">line</code></td>
<td>
<p>Which margin line to place the text.</p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_adj">adj</code></td>
<td>
<p>If <code>side=1</code>, a value closer to 0 places the text closer to
the left margin. Default: <code>0.025</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_cex">cex</code></td>
<td>
<p>Amount of character expansion of the label text. Default:
<code>2.5</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_col">col</code></td>
<td>
<p>Label font color. Default: <code>'white'</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_font">font</code></td>
<td>
<p>Integer specifying the font type. Default: <code>2</code> (bold face)</p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical indicating whether or not to show a legend.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_rescale">rescale</code></td>
<td>
<p>Logical, whether to rescale the coordinates. Default:
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_asp">asp</code></td>
<td>
<p>Numeric constant; the aspect ratio. Default: 0</p>
</td></tr>
<tr><td><code id="plot.brainGraph_+3A_...">...</code></td>
<td>
<p>Other parameters (passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>).
See <code><a href="igraph.html#topic+plot.common">plot.common</a></code> for details.</p>
</td></tr>
</table>


<h3>Selecting specific vertices to display</h3>

<p>With the argument <code>subgraph</code>, you can supply a simple logical expression
specifying which vertices to show. For example, <em>'degree &gt; 10'</em> will
plot only vertices with a <em>degree</em> greater than 10. Combinations of
<em>AND</em> (i.e., <code>&amp;</code>) and <em>OR</em> (i.e., <code>|</code>) are allowed. This
requires that any vertex attribute in the expression must be present in the
graph; e.g., <code>V(g)$degree</code> must exist.
</p>


<h3>Title, subtitle, and label</h3>

<p>By default, a <em>title</em> (i.e., text displayed at the top of the figure) is
not included. You can include one by passing a character string to
<code>main</code>, and control the size with <code>cex.main</code>. A <em>subtitle</em>
(i.e., text at the bottom), is included by default and displays the number of
vertices and edges along with the graph density. To exclude this, specify
<code>subtitle=NULL</code>. A &ldquo;label&rdquo; can be included in one corner of the
figure (for publications). For example, you can choose <code>label='A.'</code> or
<code>label='a)'</code>. Arguments controlling the location and appearance can be
changed, but the default values are optimal for bottom-left placement. See
<code><a href="graphics.html#topic+mtext">mtext</a></code> for more details. The label-specific arguments
are:
</p>

<dl>
<dt>side</dt><dd><p>The location. <code>1</code> is for bottom placement.</p>
</dd>
<dt>line</dt><dd><p>If <code>side=1</code> (bottom), a negative number places the text
<em>above</em> the bottom of the figure; a higher number could result in
the bottom part of the text to be missing. This can differ if
<code>plane='circular'</code>, in which case you may want to specify a positive
number.</p>
</dd>
<dt>adj</dt><dd><p>Seems to be the percentage away from the margin. So, for
example, <code>adj=0.1</code> would place the text closer to the center than
the default value, and <code>adj=0.5</code> places it in the center.</p>
</dd>
<dt>cex</dt><dd><p>The degree of &ldquo;character expansion&rdquo;. A value of 1 would
not increase the text size.</p>
</dd>
<dt>col</dt><dd><p>The text color.</p>
</dd>
<dt>font</dt><dd><p>The font type. The default <code>font=2</code> is bold face. See
<code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other Plotting functions: <code><a href="#topic+Plotting+20GLM+20graphs">Plotting GLM graphs</a></code>,
<code><a href="#topic+plot.brainGraphList">plot.brainGraphList</a></code>,
<code><a href="#topic+plot_brainGraph_multi">plot_brainGraph_multi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(g[[1]], hemi='R')
plot(g[[1]], subgraph='degree &gt; 10 | btwn.cent &gt; 50')

## Place label in upper-left
plot(g.ex, label='A)', side=3, line=-2.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.brainGraphList'>Plot a brainGraphList and write to PDF</h2><span id='topic+plot.brainGraphList'></span>

<h3>Description</h3>

<p>The <code>plot</code> method will write a PDF file containing plots for all graphs
in the given object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brainGraphList'
plot(x, plane, hemi, filename.base,
  diffs = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.brainGraphList_+3A_x">x</code></td>
<td>
<p>A <code>brainGraphList</code> object</p>
</td></tr>
<tr><td><code id="plot.brainGraphList_+3A_plane">plane</code></td>
<td>
<p>Character string indicating which orientation to plot.
Default: <code>'axial'</code></p>
</td></tr>
<tr><td><code id="plot.brainGraphList_+3A_hemi">hemi</code></td>
<td>
<p>Character string indicating which hemisphere to plot. Default:
<code>'both'</code></p>
</td></tr>
<tr><td><code id="plot.brainGraphList_+3A_filename.base">filename.base</code></td>
<td>
<p>Character string specifying the base of the filename</p>
</td></tr>
<tr><td><code id="plot.brainGraphList_+3A_diffs">diffs</code></td>
<td>
<p>Logical, indicating whether edge differences should be
highlighted. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.brainGraphList_+3A_...">...</code></td>
<td>
<p>Other parameters (passed to <code><a href="#topic+plot.brainGraph">plot.brainGraph</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can choose to highlight edge differences between subsequent list
elements; in this case, new/different edges are colored pink. This is useful
mostly for a list of group-level graphs.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other Plotting functions: <code><a href="#topic+Plotting+20GLM+20graphs">Plotting GLM graphs</a></code>,
<code><a href="#topic+plot.brainGraph">plot.brainGraph</a></code>,
<code><a href="#topic+plot_brainGraph_multi">plot_brainGraph_multi</a></code>
</p>

<hr>
<h2 id='Plotting+20GLM+20graphs'>Plot a graph with results from GLM-based analyses</h2><span id='topic+Plotting+20GLM+20graphs'></span><span id='topic+plot.brainGraph_NBS'></span><span id='topic+plot.brainGraph_GLM'></span><span id='topic+plot.brainGraph_mtpc'></span><span id='topic+plot.brainGraph_mediate'></span>

<h3>Description</h3>

<p>These methods are convenience functions for plotting a graph based on results
from GLM-based analyses (i.e., <code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a>,
<a href="#topic+brainGraph_mediate">brainGraph_mediate</a>, <a href="#topic+mtpc">mtpc</a>, <a href="#topic+NBS">NBS</a></code>). There are several
default arguments which differ depending on the input object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brainGraph_NBS'
plot(x, alpha = 0.05,
  subgraph = paste("p.nbs &gt;", 1 - alpha), vertex.label = NA,
  vertex.color = "color.comp", edge.color = "color.comp",
  subtitle = NULL, main = paste0("NBS: ", x$name), cex.main = 2, ...)

## S3 method for class 'brainGraph_GLM'
plot(x, p.sig = c("p", "p.fdr", "p.perm"),
  subgraph = NULL, main = paste0(x$outcome, ": ", x$name),
  subtitle = NULL, cex.main = 2, ...)

## S3 method for class 'brainGraph_mtpc'
plot(x, subgraph = "sig == 1",
  main = paste0(x$outcome, ": ", x$name), subtitle = NULL,
  cex.main = 2, ...)

## S3 method for class 'brainGraph_mediate'
plot(x, subgraph = "p.acme &gt; 0.95",
  main = sprintf("Effect of \"%s\" on\n\"%s\"\nmediated by \"%s\"",
  x$treat, x$outcome, x$mediator), subtitle = NULL, cex.main = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_x">x</code></td>
<td>
<p>A <code>brainGraph_GLM</code>, <code>brainGraph_mtpc</code>,
<code>brainGraph_mediate</code>, or <code>brainGraph_NBS</code> object</p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; the significance level. Default: <code>0.05</code></p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_subgraph">subgraph</code></td>
<td>
<p>Character string specifying the condition for subsetting the
graph.</p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_vertex.label">vertex.label</code></td>
<td>
<p>Character vector of the vertex labels to be displayed.</p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Character string specifying the vertex attribute to color
the vertices by.</p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_edge.color">edge.color</code></td>
<td>
<p>Character string specifying the edge attribute to color
the edges by.</p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_subtitle">subtitle</code></td>
<td>
<p>Character string; the subtitle. Default: <code>'default'</code></p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_main">main</code></td>
<td>
<p>Character string; the main title. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_cex.main">cex.main</code></td>
<td>
<p>Numeric; the scaling factor for text size; see
<code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+plot.brainGraph">plot.brainGraph</a></code></p>
</td></tr>
<tr><td><code id="Plotting+2B20GLM+2B20graphs_+3A_p.sig">p.sig</code></td>
<td>
<p>Character string indicating which p-value to use for determining
significance (default: <code>p</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default arguments are specified so that the user only needs to type
<code>plot(x)</code> at the console, if desired. For all methods, the plot's
<em>subtitle</em> will be omitted.
</p>


<h3>NBS</h3>

<p>By default, a subgraph will be plotted consisting of only those vertices
which are part of a significant connected component. Vertex/edge colors will
correspond to connected component membership. Vertex names will be omitted.
Finally, the plot title will contain the contrast name.
</p>


<h3>brainGraph_GLM</h3>

<p>By default, a subgraph will be plotted consisting of only those vertices for
which <code class="reqn">p &lt; \alpha</code>. It will also include a plot title with the outcome
measure and contrast name.
</p>


<h3>mtpc</h3>

<p>By default, a subgraph will be plotted consisting of only those vertices for
which <code class="reqn">A_{mtpc} &gt; A_{crit}</code>. It will also include a plot title with the
outcome measure and contrast name.
</p>


<h3>brainGraph_mediate</h3>

<p>By default, a subgraph will be plotted consisting of only those vertices for
which <code class="reqn">P_{acme} &lt; \alpha</code>. It will also include a plot title with the
treatment, mediator, and outcome variable names.
</p>


<h3>See Also</h3>

<p>Other Plotting functions: <code><a href="#topic+plot.brainGraphList">plot.brainGraphList</a></code>,
<code><a href="#topic+plot.brainGraph">plot.brainGraph</a></code>,
<code><a href="#topic+plot_brainGraph_multi">plot_brainGraph_multi</a></code>
</p>

<hr>
<h2 id='Random+20Graphs'>Perform an analysis with random graphs for brain MRI data</h2><span id='topic+Random+20Graphs'></span><span id='topic+analysis_random_graphs'></span><span id='topic+sim.rand.graph.par'></span><span id='topic+sim.rand.graph.clust'></span><span id='topic+sim.rand.graph.hqs'></span>

<h3>Description</h3>

<p><code>analysis_random_graphs</code> performs the steps needed for doing typical
graph theory analyses with brain MRI data if you need to generate equivalent
random graphs. This includes calculating <em>small world</em> parameters and
normalized <em>rich club</em> coefficients.
</p>
<p><code>sim.rand.graph.par</code> simulates <code>N</code> simple random graphs with the
same clustering (optional) and degree sequence as the input. Essentially a
wrapper for <code><a href="igraph.html#topic+sample_degseq">sample_degseq</a></code> (or, if you want to match by
clustering, <code><a href="#topic+sim.rand.graph.clust">sim.rand.graph.clust</a></code>) and
<code><a href="#topic+make_brainGraph">make_brainGraph</a></code>. It uses <code><a href="foreach.html#topic+foreach">foreach</a></code> for
parallel processing.
</p>
<p><code>sim.rand.graph.clust</code> simulates a random graph with a given degree
sequence <em>and</em> clustering coefficient. Increasing the <code>max.iters</code>
value will result in a closer match of clustering with the observed graph.
</p>
<p><code>sim.rand.graph.hqs</code> generates a number of random covariance matrices
using the Hirschberger-Qi-Steuer (HQS) algorithm, and create graphs from
those matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analysis_random_graphs(g.list, level = g.list[[1L]]$level, N = 100L,
  savedir = ".", ...)

sim.rand.graph.par(g, level = c("subject", "group"), N = 100L,
  clustering = FALSE, rewire.iters = max(10 * ecount(g), 10000L),
  cl = g$transitivity, max.iters = 100L, ...)

sim.rand.graph.clust(g, rewire.iters = 10000, cl = g$transitivity,
  max.iters = 100)

sim.rand.graph.hqs(resids, level = c("subject", "group"), N = 100L,
  weighted = TRUE, r.thresh = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Random+2B20Graphs_+3A_g.list">g.list</code></td>
<td>
<p>List of <code>brainGraphList</code> objects; the length of this list
should equal the number of thresholds/densities in the study</p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_level">level</code></td>
<td>
<p>Character string indicating whether the graphs are subject-,
group-, or contrast-specific. Default: <code>'subject'</code></p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_n">N</code></td>
<td>
<p>Integer; the number of random graphs to simulate. Default: 100</p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_savedir">savedir</code></td>
<td>
<p>Character string specifying the directory in which to save the
generated graphs. Default: current working directory</p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+make_brainGraph">make_brainGraph</a></code></p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_g">g</code></td>
<td>
<p>A graph object</p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_clustering">clustering</code></td>
<td>
<p>Logical; whether or not to control for clustering. Default:
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_rewire.iters">rewire.iters</code></td>
<td>
<p>Integer; number of rewiring iterations for the initial
graph randomization. Default: 1e4</p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_cl">cl</code></td>
<td>
<p>The clustering measure. Default: <em>transitivity</em></p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_max.iters">max.iters</code></td>
<td>
<p>The maximum number of iterations to perform; choosing a
lower number may result in clustering that is further away from the
observed graph's. Default: 100</p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_resids">resids</code></td>
<td>
<p>A <code>brainGraph_resids</code> object, a <code>data.table</code> of
residuals, or a numeric matrix</p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_weighted">weighted</code></td>
<td>
<p>Logical indicating whether to create weighted graphs. If
true, a threshold must be provided.</p>
</td></tr>
<tr><td><code id="Random+2B20Graphs_+3A_r.thresh">r.thresh</code></td>
<td>
<p>Numeric value for the correlation threshold, if
<code>weighted=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>analysis_random_graphs</code> does the following:
</p>

<ol>
<li><p> Generate <code>N</code> random graphs for each graph and density/threshold
</p>
</li>
<li><p> Write graphs to disk in <code>savedir</code>. Read them back into <code>R</code>
and combine into lists; then write these lists to disk. You can later
delete the individual <code>.rds</code> files afterwards.
</p>
</li>
<li><p> Calculate <em>small world</em> parameters, along with values for a few
global graph measures that may be of interest.
</p>
</li>
<li><p> Calculate <em>normalized rich club coefficients</em> and associated
p-values.
</p>
</li></ol>

<p>If you do not want to match by clustering, then simple rewiring of the input
graph is performed (the number of rewires equaling the larger of <code>1e4</code>
and <code class="reqn">10 \times m</code>, where <code class="reqn">m</code> is the graph's edge count).
</p>
<p><code>sim.rand.graph.hqs</code> - The first step is to create the observed
covariance of residuals (or whatever matrix/data.table is provided). Then
random covariance matrices are created with the same distributional
properties as the observed matrix, they are converted to correlation
matrices, and finally graphs from these matrices. By default, weighted graphs
will be created in which the edge weights represent correlation values. If
you want binary matrices, you must provide a correlation threshold.
</p>


<h3>Value</h3>

<p><code>analysis_random_graphs</code> returns a <em>list</em> containing:
</p>
<table role = "presentation">
<tr><td><code>rich</code></td>
<td>
<p>A data table containing normalized rich-club coefficients and
p-values</p>
</td></tr>
<tr><td><code>small</code></td>
<td>
<p>A data table with small-world parameters</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>A data table with some global graph measures for all random
graphs generated</p>
</td></tr>
</table>
<p><code>sim.rand.graph.par</code> - a <em>list</em> of <em>N</em> random graphs
with some additional vertex and graph attributes
</p>
<p><code>sim.rand.graph.clust</code> - A single <code>igraph</code> graph object
</p>
<p><code>sim.rand.graph.hqs</code> - A list of random graphs from the null
covariance matrices
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Bansal, S. and Khandelwal, S. and Meyers, L.A. (2009) Exploring
biological network structure with clustered random networks. <em>BMC
Bioinformatics</em>, <b>10</b>, 405&ndash;421.
doi: <a href="https://doi.org/10.1186/1471-2105-10-405">10.1186/1471-2105-10-405</a>
</p>
<p>Hirschberger M., Qi Y., Steuer R.E. (2007) Randomly generating
portfolio-selection covariance matrices with specified distributional
characteristics. <em>European Journal of Operational Research</em>.
<b>177</b>, 1610&ndash;1625. doi: <a href="https://doi.org/10.1016/j.ejor.2005.10.014">10.1016/j.ejor.2005.10.014</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+small.world">small.world</a></code>
</p>
<p><code><a href="igraph.html#topic+rewire">rewire</a>, <a href="igraph.html#topic+sample_degseq">sample_degseq</a>,
  <a href="igraph.html#topic+keeping_degseq">keeping_degseq</a></code>
</p>
<p><code><a href="igraph.html#topic+transitivity">transitivity</a></code>
</p>
<p>Other Random graph functions: <code><a href="#topic+Rich+20Club">Rich Club</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rand_all &lt;- analysis_random_graphs(g.norm, 1e2,
  savedir='/home/cwatson/dti/rand', clustering=F)

## End(Not run)
## Not run: 
rand1 &lt;- sim.rand.graph.par(g[[1]][[N]], N=1e3)
rand1.cl &lt;- sim.rand.graph.par(g[[1]][[N]], N=1e2,
  clustering=T, max.iters=1e3)

## End(Not run)
</code></pre>

<hr>
<h2 id='randomise'>GLM non-parametric permutation testing</h2><span id='topic+randomise'></span><span id='topic+partition'></span><span id='topic+randomise_3d'></span>

<h3>Description</h3>

<p><code>randomise</code> and <code>randomise_3d</code> perform non-parametric permutation
testing for analyses in which there is a single or multiple design matrix per
region, respectively. In the latter case, <code>X</code> should be a 3D array.
</p>
<p><code>partition</code> partitions a full design matrix into separate matrices of
covariates of interest and nuisance covariates based on a given contrast and
partition method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(M, contrast, part.method = c("beckmann", "guttman", "ridgway"))

randomise(perm.method, part.method, N, perms, X, y, contrasts, ctype, nC,
  skip = NULL, n = dim(X)[1L], p = qr.default(X)$rank,
  ny = dim(y)[2L], dfR = n - p)

randomise_3d(perm.method, part.method, N, perms, X, y, contrasts, ctype,
  nC, runX = dimnames(X)[[3L]], n = dim(X)[1L], p = qr.default(X[, ,
  1L])$rank, ny = length(runX), dfR = n - p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomise_+3A_m">M</code></td>
<td>
<p>Numeric matrix or array of the full design matrix(es)</p>
</td></tr>
<tr><td><code id="randomise_+3A_contrast">contrast</code></td>
<td>
<p>For <code>partition</code>, a numeric matrix with 1 or more rows
(for T and F contrasts, respectively) representing a <em>single
contrast</em>.</p>
</td></tr>
<tr><td><code id="randomise_+3A_part.method">part.method</code></td>
<td>
<p>Character string; the method of partitioning the design
matrix into covariates of interest and nuisance. Default: <code>'beckmann'</code></p>
</td></tr>
<tr><td><code id="randomise_+3A_perm.method">perm.method</code></td>
<td>
<p>Character string indicating the permutation method.
Default: <code>'freedmanLane'</code></p>
</td></tr>
<tr><td><code id="randomise_+3A_n">N</code></td>
<td>
<p>Integer; number of permutations to create. Default: <code>5e3</code></p>
</td></tr>
<tr><td><code id="randomise_+3A_perms">perms</code></td>
<td>
<p>Matrix of permutations, if you would like to provide your own.
Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="randomise_+3A_x">X</code></td>
<td>
<p>Numeric matrix or 3D array of the design matrix(es)</p>
</td></tr>
<tr><td><code id="randomise_+3A_y">y</code></td>
<td>
<p>Numeric matrix of outcome variables, with 1 column per region, or a
single column if there is a different design matrix per region</p>
</td></tr>
<tr><td><code id="randomise_+3A_contrasts">contrasts</code></td>
<td>
<p>Numeric matrix (for T statistics) or list of matrices (for F
statistics) specifying the contrast(s) of interest; if only one contrast is
desired, you can supply a vector (for T statistics)</p>
</td></tr>
<tr><td><code id="randomise_+3A_ctype">ctype</code></td>
<td>
<p>The contrast type</p>
</td></tr>
<tr><td><code id="randomise_+3A_nc">nC</code></td>
<td>
<p>Integer; the number of contrasts</p>
</td></tr>
<tr><td><code id="randomise_+3A_skip">skip</code></td>
<td>
<p>Integer vector indicating which (if any) contrasts to skip. Only
used by <code><a href="#topic+NBS">NBS</a></code>.</p>
</td></tr>
<tr><td><code id="randomise_+3A_n">n</code>, <code id="randomise_+3A_p">p</code>, <code id="randomise_+3A_ny">ny</code>, <code id="randomise_+3A_dfr">dfR</code></td>
<td>
<p>Integers for the number of observations, design matrix
columns (its rank), number of regions/outcome variables, and residual
degrees of freedom, respectively</p>
</td></tr>
<tr><td><code id="randomise_+3A_runx">runX</code></td>
<td>
<p>Character vector of regions with non-singular designs</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>partition</code> returns a list containing:
</p>
<table role = "presentation">
<tr><td><code>Mp</code></td>
<td>
<p>Numeric array; the combined partitioned arrays</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Numeric array for the covariates of interest</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>Numeric array for the nuisance covariates</p>
</td></tr>
<tr><td><code>eCm</code></td>
<td>
<p>The <em>effective contrast</em>, equivalent to the original, for
the partitioned model <code>[X, Z]</code> and considering all covariates</p>
</td></tr>
<tr><td><code>eCx</code></td>
<td>
<p>Same as <code>eCm</code>, but considering only <code>X</code></p>
</td></tr>
</table>
<p>A numeric array with dimensions <code class="reqn">n_y \times N \times n_c</code>;
the number of rows equals number of regions/outcome variables, number of
columns equals <code>N</code>, and the 3rd dimension is the number of contrasts
</p>


<h3>Model partitioning</h3>

<p>Consider the matrix formulation of the <em>general linear model</em>:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{Y} = \mathbf{M} \psi + \in</code>
</p>

<p>where <code class="reqn">Y</code> is the vector of outcomes, <code class="reqn">M</code> is the full design matrix
(including nuisance covariates), <code class="reqn">\psi</code> is the vector of parameter
estimates, and <code class="reqn">\in</code> is the vector of error terms. In a permutation
framework, algorithms are applied differently depending on the
presence/absence of nuisance covariates; thus the model is separated
depending on the contrast of interest:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{Y} = \mathbf{X}\beta + \mathbf{Z}\gamma + \in</code>
</p>

<p>where <code class="reqn">\mathbf{X}</code> contains covariates of interest, <code class="reqn">\mathbf{Z}</code>
contains nuisance covariates, and <code class="reqn">\beta</code> and <code class="reqn">\gamma</code> are the
associated parameter estimates.
</p>
<p>The manner of partitioning depends on the method. For example, for the
<code>guttman</code> method, <code>X</code> is formed from the columns of <code>contrast</code>
that have non-zero entries.
</p>


<h3>Permutation methods</h3>

<p>The permutation methods can be split into 2 groups, depending on which part
of the model they permute. For full details, see <em>Winkler et al., 2014</em>.
</p>

<dl>
<dt>Permute Y</dt><dd><p>Freedman-Lane, Manly, and ter Braak</p>
</dd>
<dt>Permute X</dt><dd><p>Smith, Draper-Stoneman, and Still-White</p>
</dd>
</dl>

<p>Depending on the size of the data, it may be faster to use a method that
permutes <code>Y</code> instead of <code>X</code>. For example, in <code><a href="#topic+NBS">NBS</a></code> with
dense matrices (more than 400-500 edges), it will be somewhat faster to use
the &ldquo;Smith&rdquo; method compared to &ldquo;Freedman-Lane&rdquo;. If using
<code><a href="#topic+brainGraph_GLM">brainGraph_GLM</a></code>, the number of vertices follows the same
relationship.
</p>
<p>Furthermore, all methods except Still-White include the <code>Z</code> (nuisance
covariate) matrix when calculating the permuted statistics.
</p>


<h3>References</h3>

<p>Beckmann, C.F. and Jenkinson, M. and Smith, S.M. (2001) General
multi-level linear modelling for group analysis in FMRI. Tech Rep.
University of Oxford, Oxford.
</p>
<p>Guttman, I. (1982) <em>Linear Models: An Introduction</em>. Wiley,
New York.
</p>
<p>Ridgway, G.R. (2009) Statistical analysis for longitudinal MR
imaging of dementia. PhD thesis.
</p>
<p>Draper, N.R. and Stoneman, D.M. (1966) Testing for the inclusion
of variables in linear regression by a randomisation technique.
<em>Technometrics</em>. <b>8(4)</b>, 695&ndash;699.
</p>
<p>Freedman, D. and Lane, D. (1983) A nonstochastic interpretation
of reported significance levels. <em>J Bus Econ Stat</em>, <b>1(4)</b>,
292&ndash;298. doi: <a href="https://doi.org/10.1080/07350015.1983.10509354">10.1080/07350015.1983.10509354</a>
</p>
<p>Manly B.F.J. (1986) Randomization and regression methods for
testing for associations with geographical, environmental, and biological
distances between populations. <em>Res Popul Ecol</em>. <b>28(2)</b>,
201&ndash;218.
</p>
<p>Nichols, T.E. and Holmes, A.P. (2001) Nonparametric permutation
tests for functional neuroimaging: A primer with examples. <em>Human
Brain Mapping</em>. <b>15(1)</b>, 1&ndash;25.
doi: <a href="https://doi.org/10.1002/hbm.1058">10.1002/hbm.1058</a>
</p>
<p>Smith, S.M. and Jenkinson, M. and Beckmann, C. and Miller, K. and
Woolrich, M. (2007) Meaningful design and contrast estimability in fMRI.
<em>NeuroImage</em>. <b>34(1)</b>, 127&ndash;36.
doi: <a href="https://doi.org/10.1016/j.neuroimage.2006.09.019">10.1016/j.neuroimage.2006.09.019</a>
</p>
<p>Still, A.W. and White, A.P. (1981) The approximate randomization
test as an alternative to the F test in analysis of variance. <em>Br J
Math Stat Psychol</em>. <b>34(2)</b>, 243&ndash;252.
</p>
<p>ter Braak, C.J.F. 1992. Permutation versus bootstrap significance
tests in multiple regression and ANOVA. <em>Bootstrapping and related
techniques</em>. Springer, Berlin, Heidelberg. 79&ndash;85.
</p>
<p>Winkler, A.M. and Ridgway, G.R. and Webster, M.A. and Smith, S.M.
and Nichols, T.E. (2014) Permutation inference for the general linear
model. <em>NeuroImage</em>. <b>92</b>, 381&ndash;397.
doi: <a href="https://doi.org/10.1016/j.neuroimage.2014.01.060">10.1016/j.neuroimage.2014.01.060</a>
</p>

<hr>
<h2 id='rename_levels'>Rename the levels of global metrics in a data.table</h2><span id='topic+rename_levels'></span>

<h3>Description</h3>

<p>Rename the levels of global metrics in a data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_levels(DT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_levels_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The levels of the <code>variable</code> column after being changed
</p>

<hr>
<h2 id='Residuals'>Linear model residuals in structural covariance networks</h2><span id='topic+Residuals'></span><span id='topic+get.resid'></span><span id='topic+Extract.brainGraph_resids'></span><span id='topic++5B.brainGraph_resids'></span><span id='topic+summary.brainGraph_resids'></span><span id='topic+plot.brainGraph_resids'></span><span id='topic+nobs.brainGraph_resids'></span><span id='topic+case.names.brainGraph_resids'></span><span id='topic+groups.brainGraph_resids'></span><span id='topic+region.names.brainGraph_resids'></span><span id='topic+nregions.brainGraph_resids'></span>

<h3>Description</h3>

<p><code>get.resid</code> runs linear models across brain regions listed in a
<code>data.table</code> (e.g., cortical thickness), adjusting for variables in
<code>covars</code> (e.g. age, sex, etc.), and calculates the
<em>externally Studentized</em> (or <em>leave-one-out</em>) residuals.
</p>
<p>The <code>[</code> method reorders or subsets residuals based on a given
numeric vector. However, this is used in bootstrap and permutation analysis
and should generally not be called directly by the user.
</p>
<p>The <code>summary</code> method prints the number of outliers per region, and the
number of times a given subject was an outlier (i.e., across regions).
</p>
<p>The <code>plot</code> method lets you check the model residuals for each brain
region in a structural covariance analysis. It shows a <em>qqplot</em> of the
studentized residuals, as output from <code><a href="#topic+get.resid">get.resid</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.resid(dt.vol, covars, method = c("comb.groups", "sep.groups"),
  use.mean = FALSE, exclude.cov = NULL, atlas = NULL, ...)

## S3 method for class 'brainGraph_resids'
x[i, g = NULL]

## S3 method for class 'brainGraph_resids'
summary(object, region = NULL,
  outlier.thresh = 2, ...)

## S3 method for class 'brainGraph_resids'
plot(x, region = NULL, outlier.thresh = 2,
  cols = FALSE, ids = TRUE, ...)

## S3 method for class 'brainGraph_resids'
nobs(object, ...)

## S3 method for class 'brainGraph_resids'
case.names(object, ...)

## S3 method for class 'brainGraph_resids'
groups(x)

## S3 method for class 'brainGraph_resids'
region.names(object)

## S3 method for class 'brainGraph_resids'
nregions(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Residuals_+3A_dt.vol">dt.vol</code></td>
<td>
<p>A <code>data.table</code> containing all the volumetric measure of
interest (i.e., the object <code>lhrh</code> as output by
<code><a href="#topic+import_scn">import_scn</a></code>)</p>
</td></tr>
<tr><td><code id="Residuals_+3A_covars">covars</code></td>
<td>
<p>A <code>data.table</code> of the covariates of interest</p>
</td></tr>
<tr><td><code id="Residuals_+3A_method">method</code></td>
<td>
<p>Character string indicating whether to test models for subject
groups separately or combined. Default: <code>comb.groups</code></p>
</td></tr>
<tr><td><code id="Residuals_+3A_use.mean">use.mean</code></td>
<td>
<p>Logical should we control for the mean hemispheric brain
value (e.g. mean LH/RH cortical thickness). Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="Residuals_+3A_exclude.cov">exclude.cov</code></td>
<td>
<p>Character vector of covariates to exclude. Default:
<code>NULL</code></p>
</td></tr>
<tr><td><code id="Residuals_+3A_atlas">atlas</code></td>
<td>
<p>Character string indicating the brain atlas</p>
</td></tr>
<tr><td><code id="Residuals_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+brainGraph_GLM_design">brainGraph_GLM_design</a></code> (optional)</p>
</td></tr>
<tr><td><code id="Residuals_+3A_x">x</code>, <code id="Residuals_+3A_object">object</code></td>
<td>
<p>A <code>brainGraph_resids</code> object</p>
</td></tr>
<tr><td><code id="Residuals_+3A_i">i</code></td>
<td>
<p>Numeric vector of the indices</p>
</td></tr>
<tr><td><code id="Residuals_+3A_g">g</code></td>
<td>
<p>Character string indicating the group. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Residuals_+3A_region">region</code></td>
<td>
<p>Character vector of region(s) to focus on; default behavior is
to show summary for all regions</p>
</td></tr>
<tr><td><code id="Residuals_+3A_outlier.thresh">outlier.thresh</code></td>
<td>
<p>Number indicating how many standard deviations
above/below the mean indicate an outlier. Default: <code>2</code></p>
</td></tr>
<tr><td><code id="Residuals_+3A_cols">cols</code></td>
<td>
<p>Logical indicating whether to color by group. Default:
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="Residuals_+3A_ids">ids</code></td>
<td>
<p>Logical indicating whether to plot subject ID's for outliers.
Otherwise plots the integer index</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can choose to run models for each of your subject groups separately or
combined (the default) via the <code>method</code> argument. You may also choose
whether to include the mean, per-hemisphere structural measure in the
models. Finally, you can specify variables that are present in <code>covars</code>
which you would like to exclude from the models. Optional arguments can be
provided that get passed to <code><a href="#topic+brainGraph_GLM_design">brainGraph_GLM_design</a></code>.
</p>
<p>If you do not explicitly specify the atlas name, then it will be guessed from
the size of your data. This could cause problems if you are using a custom
atlas, with or without the same number of regions as a dataset in the
package.
</p>


<h3>Value</h3>

<p><code>get.resid</code> - an object of class <code>brainGraph_resids</code> with
elements:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A data.table with the input volume/thickness/etc. data as well
as the covariates used in creating the design matrix.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The <em>design matrix</em>, if using default arguments. If
<code>use.mean=TRUE</code> then it will be a <em>named list</em> with a separate
matrix for the left and right hemispheres. If <code>method='sep.groups'</code>, a
nested named list for each group and hemisphere.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The input argument <code>method</code></p>
</td></tr>
<tr><td><code>use.mean</code></td>
<td>
<p>The input argument <code>use.mean</code></p>
</td></tr>
<tr><td><code>resids.all</code></td>
<td>
<p>The &ldquo;wide&rdquo; <code>data.table</code> of residuals</p>
</td></tr>
<tr><td><code>Group</code></td>
<td>
<p>Group names</p>
</td></tr>
<tr><td><code>atlas</code></td>
<td>
<p>The atlas name</p>
</td></tr>
</table>
<p><code><a href="#topic+summary.brainGraph_resids">summary.brainGraph_resids</a></code> returns a list with two
data tables, one of the residuals, and one of only the outlier regions
</p>
<p>The <code>plot</code> method returns a <code>trellis</code> object or a list of
<code>ggplot</code> objects
</p>


<h3>Note</h3>

<p>It is assumed that <code>dt.vol</code> was created using
<code><a href="#topic+import_scn">import_scn</a></code>. In older versions, there were issues when the Study
ID was specified as an integer and was not &ldquo;zero-padded&rdquo;. This is done
automatically by <code><a href="#topic+import_scn">import_scn</a></code>, so if you are using an external
program, please be sure that the Study ID column is matched in both
<code>dt.vol</code> and <code>covars</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+influence.measures">influence.measures</a></code>, <code><a href="stats.html#topic+qqnorm">qqnorm</a></code>
</p>
<p>Other Structural covariance network functions: <code><a href="#topic+Bootstrapping">Bootstrapping</a></code>,
<code><a href="#topic+IndividualContributions">IndividualContributions</a></code>,
<code><a href="#topic+brainGraph_permute">brainGraph_permute</a></code>,
<code><a href="#topic+corr.matrix">corr.matrix</a></code>, <code><a href="#topic+import_scn">import_scn</a></code>,
<code><a href="#topic+plot_volumetric">plot_volumetric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myresids &lt;- get.resids(lhrh, covars)
residPlots &lt;- plot(myresids, cols=TRUE)

## Save as a multi-page PDF
ml &lt;- marrangeGrob(residPlots, nrow=3, ncol=3)
ggsave('residuals.pdf', ml)

## End(Not run)
</code></pre>

<hr>
<h2 id='Rich+20Club'>Rich club calculations</h2><span id='topic+Rich+20Club'></span><span id='topic+rich_club_coeff'></span><span id='topic+rich_club_all'></span><span id='topic+rich_club_norm'></span><span id='topic+rich_core'></span>

<h3>Description</h3>

<p><code>rich_club_coeff</code> calculates the <em>rich club</em> of a graph, returning
the rich-club coefficient, <code class="reqn">\phi</code>, and the subgraph of rich club
vertices.
</p>
<p><code>rich_club_all</code> is a wrapper for <code><a href="#topic+rich_club_coeff">rich_club_coeff</a></code> that
calculates the rich-club coefficient for all degrees present in the graph. It
returns a <code>data.table</code> with the coefficients and vertex and edge counts
for each successive rich club.
</p>
<p><code>rich_club_norm</code> will (optionally) generate a number of random graphs,
calculate their rich club coefficients (<code class="reqn">\phi</code>), and return
<code class="reqn">\phi_{norm}</code> of the graph of interest, which is the observed rich-club
coefficient divided by the mean across the random graphs.
</p>
<p><code>rich_core</code> finds the boundary of the rich core of a graph, based on the
decreasing order of vertex degree. It also calculates the degree that
corresponds to that rank, and the core size relative to the total number of
vertices in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rich_club_coeff(g, k = 1, weighted = FALSE, A = NULL)

rich_club_all(g, weighted = FALSE, A = NULL)

rich_club_norm(g, N = 100, rand = NULL, ...)

rich_core(g, weighted = FALSE, A = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rich+2B20Club_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="Rich+2B20Club_+3A_k">k</code></td>
<td>
<p>Integer; the minimum degree for including a vertex. Default: 1</p>
</td></tr>
<tr><td><code id="Rich+2B20Club_+3A_weighted">weighted</code></td>
<td>
<p>Logical indicating whether or not edge weights should be
used. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="Rich+2B20Club_+3A_a">A</code></td>
<td>
<p>Numeric matrix; the adjacency matrix of the input graph. Default:
<code>NULL</code></p>
</td></tr>
<tr><td><code id="Rich+2B20Club_+3A_n">N</code></td>
<td>
<p>Integer; the number of random graphs to generate. Default: 100</p>
</td></tr>
<tr><td><code id="Rich+2B20Club_+3A_rand">rand</code></td>
<td>
<p>A list of <code>igraph</code> graph objects, if random graphs have
already been generated. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Rich+2B20Club_+3A_...">...</code></td>
<td>
<p>Other parameters (passed to <code><a href="#topic+sim.rand.graph.par">sim.rand.graph.par</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If random graphs have already been generated, you can supply a list as an
argument.
</p>
<p>For weighted graphs, the degree is substituted by a normalized weight:
</p>
<p style="text-align: center;"><code class="reqn">ceiling(A / w_{min})</code>
</p>

<p>where <code class="reqn">w_{min}</code> is the minimum weight (that is greater than 0), and
<code class="reqn">ceiling()</code> is the <em>ceiling</em> function that rounds up to the nearest
integer.
</p>


<h3>Value</h3>

<p><code><a href="#topic+rich_club_coeff">rich_club_coeff</a></code> - a list with components:
</p>
<table role = "presentation">
<tr><td><code>phi</code></td>
<td>
<p>The rich club coefficient, <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code>graph</code></td>
<td>
<p>A subgraph containing only the rich club vertices.</p>
</td></tr>
<tr><td><code>Nk</code>, <code>Ek</code></td>
<td>
<p>The number of vertices/edges in the rich club graph.</p>
</td></tr>
</table>
<p><code><a href="#topic+rich_club_all">rich_club_all</a></code> - a <code>data.table</code> with components:
</p>
<table role = "presentation">
<tr><td><code>k</code></td>
<td>
<p>A vector of all vertex degrees present in the original graph</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>The rich-club coefficient</p>
</td></tr>
<tr><td><code>Nk</code>, <code>Ek</code></td>
<td>
<p>The number of vertices/edges in the rich club for each
successive <em>k</em></p>
</td></tr>
</table>
<p><code><a href="#topic+rich_club_norm">rich_club_norm</a></code> - a data table with columns:
</p>
<table role = "presentation">
<tr><td><code>k</code></td>
<td>
<p>Sequence of degrees</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>Rich-club coefficients for the random graphs</p>
</td></tr>
<tr><td><code>orig</code></td>
<td>
<p>Rich-club coefficients for the original graph.</p>
</td></tr>
<tr><td><code>norm</code></td>
<td>
<p>Normalized rich-club coefficients.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>P-values based on the distribution of <code>rand</code></p>
</td></tr>
<tr><td><code>p.fdr</code></td>
<td>
<p>The FDR-adjusted P-values</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>The observed graph's density</p>
</td></tr>
<tr><td><code>threshold</code>, <code>Group</code>, <code>name</code></td>
<td>
</td></tr>
</table>
<p><code><a href="#topic+rich_core">rich_core</a></code> - a data table with columns:
</p>
<table role = "presentation">
<tr><td><code>density</code></td>
<td>
<p>The density of the graph.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>The rank of the boundary for the rich core.</p>
</td></tr>
<tr><td><code>k.r</code></td>
<td>
<p>The degree/strength of the vertex at the boundary.</p>
</td></tr>
<tr><td><code>core.size</code></td>
<td>
<p>The size of the core relative to the graph size.</p>
</td></tr>
<tr><td><code>weighted</code></td>
<td>
<p>Whether or not weights were used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Zhou, S. and Mondragon, R.J. (2004) The rich-club phenomenon
in the internet topology. <em>IEEE Comm Lett</em>, <b>8</b>, 180&ndash;182.
doi: <a href="https://doi.org/10.4018/978-1-59140-993-9.ch066">10.4018/978-1-59140-993-9.ch066</a>
</p>
<p>Opsahl, T. and Colizza, V. and Panzarasa, P. and Ramasco, J.J.
(2008) Prominence and control: the weighted rich-club effect. <em>Physical
Review Letters</em>, <b>101.16</b>, 168702.
doi: <a href="https://doi.org/10.1103/PhysRevLett.101.168702">10.1103/PhysRevLett.101.168702</a>
</p>
<p>Colizza, V. and Flammini, A. and Serrano, M.A. and Vespignani, A.
(2006) Detecting rich-club ordering in complex networks. <em>Nature
Physics</em>, <b>2</b>, 110&ndash;115. doi: <a href="https://doi.org/10.1038/nphys209">10.1038/nphys209</a>
</p>
<p>Ma, A and Mondragon, R.J. (2015) Rich-cores in networks.
<em>PLoS One</em>, <b>10(3)</b>, e0119678.
doi: <a href="https://doi.org/10.1371/journal.pone.0119678">10.1371/journal.pone.0119678</a>
</p>


<h3>See Also</h3>

<p>Other Rich-club functions: <code><a href="#topic+plot_rich_norm">plot_rich_norm</a></code>,
<code><a href="#topic+rich_club_attrs">rich_club_attrs</a></code>
</p>
<p>Other Random graph functions: <code><a href="#topic+Random+20Graphs">Random Graphs</a></code>
</p>

<hr>
<h2 id='rich_club_attrs'>Assign graph attributes based on rich-club analysis</h2><span id='topic+rich_club_attrs'></span>

<h3>Description</h3>

<p>Assigns vertex- and edge-level attributes based on the results of a
<em>rich-club</em> analysis, based on a range of vertex degrees in which the
rich-club coefficient was determined to be significantly greater than that of
a set of random graphs (see <code><a href="#topic+rich_club_norm">rich_club_norm</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rich_club_attrs(g, deg.range = NULL, adj.vsize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rich_club_attrs_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="rich_club_attrs_+3A_deg.range">deg.range</code></td>
<td>
<p>Numeric vector of the range of degrees indicating
inclusion in the rich-club; if the default <em>NULL</em>, it will be from 1
to the maximum degree in the graph</p>
</td></tr>
<tr><td><code id="rich_club_attrs_+3A_adj.vsize">adj.vsize</code></td>
<td>
<p>Logical indicating whether to adjust vertex size
proportional to degree. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertices which are in the rich club will be assigned an attribute
<code>rich</code>, taking on a binary value. Their colors (attribute
<code>color.rich</code>) will be either <em>red</em> or <em>gray</em>. Their sizes
(attribute <code>size.rich</code>) will either be 10 or will be proportional to
their degree.
</p>
<p>Edge attribute <code>type.rich</code> takes on three values: <em>rich-club</em> (if
it connects two rich-club vertices), <em>feeder</em> (if it connects a rich- to
a non-rich-club vertex), and <em>local</em> (if it connects two non-rich-club
vertices). The <code>color.rich</code> attribute is <em>red</em>, <em>orange</em>, or
<em>green</em>. Edge sizes (<code>size.rich</code>) will be largest for
<em>rich-club</em> connections, then smaller for <em>feeder</em>, and smallest
for <em>local</em>.
</p>


<h3>Value</h3>

<p>An <code>igraph</code> graph object with additional attributes:
</p>
<table role = "presentation">
<tr><td><code>rich</code></td>
<td>
<p>Binary indicating membership in the rich-club</p>
</td></tr>
<tr><td><code>type.rich</code></td>
<td>
<p>Edge attribute indicating the type of connection</p>
</td></tr>
<tr><td><code>color.rich</code></td>
<td>
<p>Edge and vertex attributes</p>
</td></tr>
<tr><td><code>size.rich</code></td>
<td>
<p>Edge and vertex attributes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>See Also</h3>

<p>Other Rich-club functions: <code><a href="#topic+Rich+20Club">Rich Club</a></code>,
<code><a href="#topic+plot_rich_norm">plot_rich_norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- rich_club_attrs(g, rich.dt[density == densities[N] &amp; p.fdr &lt; .01,
                                range(k)])

## End(Not run)
</code></pre>

<hr>
<h2 id='robustness'>Analysis of network robustness</h2><span id='topic+robustness'></span>

<h3>Description</h3>

<p>This function performs a &ldquo;targeted attack&rdquo; of a graph or a
&ldquo;random failure&rdquo; analysis, calculating the size of the largest
component after edge or vertex removal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustness(g, type = c("vertex", "edge"), measure = c("btwn.cent",
  "degree", "random"), N = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robustness_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="robustness_+3A_type">type</code></td>
<td>
<p>Character string; either <code>'vertex'</code> or <code>'edge'</code>
removals. Default: <code>vertex</code></p>
</td></tr>
<tr><td><code id="robustness_+3A_measure">measure</code></td>
<td>
<p>Character string; sort by either <code>'btwn.cent'</code> or
<code>'degree'</code>, or choose <code>'random'</code>. Default: <code>'btwn.cent'</code></p>
</td></tr>
<tr><td><code id="robustness_+3A_n">N</code></td>
<td>
<p>Integer; the number of iterations if <code>'random'</code> is chosen.
Default: <code>1e3</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a targeted attack, it will sort the vertices by either degree or
betweenness centrality (or sort edges by betweenness), and successively
remove the top vertices/edges. Then it calculates the size of the largest
component.
</p>
<p>In a random failure analysis, vertices/edges are removed in a random order.
</p>


<h3>Value</h3>

<p>Data table with elements:
</p>
<table role = "presentation">
<tr><td><code>type</code></td>
<td>
<p>Character string describing the type of analysis performed</p>
</td></tr>
<tr><td><code>measure</code></td>
<td>
<p>The input argument <code>measure</code></p>
</td></tr>
<tr><td><code>comp.size</code></td>
<td>
<p>The size of the largest component after edge/vertex
removal</p>
</td></tr>
<tr><td><code>comp.pct</code></td>
<td>
<p>Numeric vector of the ratio of maximal component size after
each removal to the observed graph's maximal component size</p>
</td></tr>
<tr><td><code>removed.pct</code></td>
<td>
<p>Numeric vector of the ratio of vertices/edges removed</p>
</td></tr>
<tr><td><code>Group</code></td>
<td>
<p>Character string indicating the subject group, if applicable</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Albert, R. and Jeong, H. and Barabasi, A. (2000) Error and attack
tolerance of complex networks. <em>Nature</em>, <b>406</b>, 378&ndash;381.
doi: <a href="https://doi.org/10.1038/35019019">10.1038/35019019</a>
</p>

<hr>
<h2 id='s_core'>Calculate the s-core of a network</h2><span id='topic+s_core'></span>

<h3>Description</h3>

<p>Calculates the <em>s-core</em> decomposition of a network. This is analogous to
the <em>k-core</em> decomposition, but takes into account the <em>strength</em>
of vertices (i.e., in weighted networks). If an unweighted network is
supplied, then the output of the function <code><a href="igraph.html#topic+coreness">coreness</a></code> is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_core(g, W = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s_core_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="s_core_+3A_w">W</code></td>
<td>
<p>Numeric matrix of edge weights (default: <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>s-core</em> consists of all vertices <code class="reqn">i</code> with <code class="reqn">s_i &gt; s</code>, where
<code class="reqn">s</code> is some threshold value. The <code class="reqn">s_0</code> core is the entire network,
and the threshold value of the <code class="reqn">s_{n}</code> core is
</p>
<p style="text-align: center;"><code class="reqn">s_{n-1} = min_i s_i</code>
</p>

<p>for all vertices <code class="reqn">i</code> in the <code class="reqn">s_{n-1}</code> core.
</p>
<p>Note that in networks with a wide distribution of vertex strengths, in which
there are almost as many unique values as there are vertices, then several
separate cores will have a single vertex. See the reference provided below.
</p>


<h3>Value</h3>

<p>Integer vector of the vertices' <em>s-core</em> membership
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Eidsaa, M and Almaas, E. (2013) s-core network decomposition: a
generalization of k-core analysis to weighted networks. <em>Physical
Review E</em>, <b>88</b>, 062819.
doi: <a href="https://doi.org/10.1103/PhysRevE.88.062819">10.1103/PhysRevE.88.062819</a>
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+coreness">coreness</a></code>
</p>

<hr>
<h2 id='set_graph_colors'>Color graph vertices and edges</h2><span id='topic+set_graph_colors'></span>

<h3>Description</h3>

<p><code>set_graph_colors</code> takes an integer vector representing membership of
some grouping (e.g., a community or connected component) and creates a
character vector of colors for each grouping. Isolated vertices will be
colored <em>gray</em>. Edges are assigned the same color if connected to
vertices in the same group, and assigned <em>gray</em> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_graph_colors(g, name, memb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_graph_colors_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="set_graph_colors_+3A_name">name</code></td>
<td>
<p>Character string of the name of the attribute to add</p>
</td></tr>
<tr><td><code id="set_graph_colors_+3A_memb">memb</code></td>
<td>
<p>An integer vector representing membership of e.g. a community</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same graph with additional vertex and edge attributes
</p>

<hr>
<h2 id='small.world'>Calculate graph small-worldness</h2><span id='topic+small.world'></span>

<h3>Description</h3>

<p><code>small.world</code> calculates the normalized characteristic path length and
clustering coefficient based on observed and random graphs, used to calculate
the small-world coefficient <code class="reqn">\sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>small.world(g.list, rand)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="small.world_+3A_g.list">g.list</code></td>
<td>
<p>A <code>brainGraphList</code> object or list of graphs</p>
</td></tr>
<tr><td><code id="small.world_+3A_rand">rand</code></td>
<td>
<p>List of (lists of) equivalent random graphs (output from
<code><a href="#topic+sim.rand.graph.par">sim.rand.graph.par</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>density</code></td>
<td>
<p>The range of density thresholds used.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>The number of random graphs that were generated.</p>
</td></tr>
<tr><td><code>Lp</code>, <code>Lp.rand</code>, <code>Lp.norm</code></td>
<td>
<p>The observed, average random, and normalized
characteristic path length.</p>
</td></tr>
<tr><td><code>Cp</code>, <code>Cp.rand</code>, <code>Cp.norm</code></td>
<td>
<p>The observed, average random, and normalized
clustering coefficient.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The small-world measure of the graph.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Watts, D.J. and Strogatz S.H. (1998) Collective dynamics of
&quot;small-world&quot; networks. <em>Nature</em>, <b>393</b>, 440&ndash;442.
doi: <a href="https://doi.org/10.1038/30918">10.1038/30918</a>
</p>

<hr>
<h2 id='subset_graph'>Subset graphs based on a given logical condition</h2><span id='topic+subset_graph'></span>

<h3>Description</h3>

<p><code>subset_graph</code> will subset a given graph based on the given logical
condition(s). This can be a &ldquo;simple&rdquo; logical equation, or can include
combinations of <em>AND</em> and <em>OR</em> (i.e., <code>&amp;</code> and <code>|</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_graph(g, condition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_graph_+3A_g">g</code></td>
<td>
<p>A graph object</p>
</td></tr>
<tr><td><code id="subset_graph_+3A_condition">condition</code></td>
<td>
<p>Character string specifying an equation for which vertices to
keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph object
</p>

<hr>
<h2 id='update_fs_names'>Update column names in a Freesurfer table</h2><span id='topic+update_fs_names'></span>

<h3>Description</h3>

<p>Updates column names by abbreviating to match with the names in the
<code>brainGraph</code> atlases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_fs_names(filename, modality, parcellation, hemi, exclude.subs)
</code></pre>

<hr>
<h2 id='Utility+20functions'>Utility functions</h2><span id='topic+Utility+20functions'></span><span id='topic+get_metadata'></span><span id='topic+outer_vec'></span><span id='topic+split_string'></span><span id='topic+vec.transform'></span>

<h3>Description</h3>

<p><code>get_metadata</code> adds metadata to a list-like object.
</p>
<p><code>outer_vec</code> simply performs the cross-product, specifically <code>x 
t(y)</code>, and assigns dimnames to the resulting matrix.
</p>
<p><code>split_string</code> inserts separator characters in a character string to
truncate strings for printing.
</p>
<p><code>vec.transform</code> takes a vector and transforms it to have a new range,
given the input, or the default values of [0, 1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metadata(object)

outer_vec(x, y)

split_string(x, max_len = 80L, delim = "\\+", sep = "\n")

vec.transform(x, min.val = 0, max.val = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Utility+2B20functions_+3A_object">object</code></td>
<td>
<p>A list-like object</p>
</td></tr>
<tr><td><code id="Utility+2B20functions_+3A_x">x</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="Utility+2B20functions_+3A_max_len">max_len</code></td>
<td>
<p>Integer; the max length of one line. Default: 80</p>
</td></tr>
<tr><td><code id="Utility+2B20functions_+3A_delim">delim</code></td>
<td>
<p>Character specifying where to end a line if it is longer than
<code>max_len</code>. Default: <code>'+'</code></p>
</td></tr>
<tr><td><code id="Utility+2B20functions_+3A_sep">sep</code></td>
<td>
<p>Character specifying what to split by. Default: <code>'\n'</code> (a
newline character)</p>
</td></tr>
<tr><td><code id="Utility+2B20functions_+3A_min.val">min.val</code></td>
<td>
<p>the minimum value of the new range</p>
</td></tr>
<tr><td><code id="Utility+2B20functions_+3A_max.val">max.val</code></td>
<td>
<p>the maximum value of the new range</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object is a graph, graph-level attributes will be added. The
elements added are:
</p>

<dl>
<dt>version</dt><dd><p>A list with R, brainGraph, and igraph versions</p>
</dd>
<dt>sys</dt><dd><p>Character vector of system information</p>
</dd>
<dt>date</dt><dd><p>The date and time of creation</p>
</dd>
</dl>

<p>The <code>delim</code> argument determines <em>where</em> to insert the separator.
For example, given the default, it will attempt to insert newline characters
only following a plus sign.
</p>


<h3>Value</h3>

<p><code>get_metadata</code> - the same object with version, system, and date
information added
</p>
<p>A vector of the transformed input.
</p>

<hr>
<h2 id='Vertex+20Roles'>Gateway coefficient, participation coefficient, and within-mod degree z-score</h2><span id='topic+Vertex+20Roles'></span><span id='topic+gateway_coeff'></span><span id='topic+part_coeff'></span><span id='topic+within_module_deg_z_score'></span>

<h3>Description</h3>

<p><code>gateway_coeff</code> calculates the gateway coefficient of each vertex,
based on community membership.
</p>
<p><code>part_coeff</code> calculates the participation coefficient of each vertex,
based on community membership.
</p>
<p><code>within_module_deg_z_score</code> is a measure of the connectivity from a
given vertex to other vertices in its module/community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gateway_coeff(g, memb, centr = c("btwn.cent", "degree", "strength"),
  A = NULL, weighted = FALSE)

part_coeff(g, memb, A = NULL, weighted = FALSE)

within_module_deg_z_score(g, memb, A = NULL, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Vertex+2B20Roles_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="Vertex+2B20Roles_+3A_memb">memb</code></td>
<td>
<p>A numeric vector of membership indices of each vertex</p>
</td></tr>
<tr><td><code id="Vertex+2B20Roles_+3A_centr">centr</code></td>
<td>
<p>Character string; the type of centrality to use in calculating
GC. Default: <code>btwn.cent</code></p>
</td></tr>
<tr><td><code id="Vertex+2B20Roles_+3A_a">A</code></td>
<td>
<p>Numeric matrix; the adjacency matrix of the input graph. Default:
<code>NULL</code></p>
</td></tr>
<tr><td><code id="Vertex+2B20Roles_+3A_weighted">weighted</code></td>
<td>
<p>Logical indicating whether to calculate metrics using edge
weights. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gateway coefficient <code class="reqn">G_i</code> of vertex <em>i</em> is:
</p>
<p style="text-align: center;"><code class="reqn">G_i = 1 - \sum_{S=1}^{N_M} \left ( \frac{\kappa_{iS}}{\kappa_i} \right
)^2 (g_{iS})^2</code>
</p>

<p>where <code class="reqn">\kappa_{iS}</code> is the number of edges from vertex <em>i</em> to
vertices in module <em>S</em>, and <code class="reqn">\kappa_i</code> is the degree of vertex
<em>i</em>. <code class="reqn">N_M</code> equals the number of modules. <code class="reqn">g_{ii}</code> is a weight,
defined as:
</p>
<p style="text-align: center;"><code class="reqn">g_{iS} = 1 - \bar{\kappa_{iS}} \bar{c_{iS}}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\bar{\kappa_{iS}} = \frac{\kappa_{iS}}{\sum_j \kappa_{jS}}</code>
</p>

<p>for all nodes <code class="reqn">j</code> in node <code class="reqn">i</code>'s module, and
</p>
<p style="text-align: center;"><code class="reqn">\bar{c_{iS}} = c_{iS} / max(c_n)</code>
</p>

<p>The participation coefficient <code class="reqn">P_i</code> of vertex <em>i</em> is:
</p>
<p style="text-align: center;"><code class="reqn">P_i = 1 - \sum_{s=1}^{N_M} \left ( \frac{\kappa_{is}}{\kappa_i} \right )^2</code>
</p>

<p>where <code class="reqn">\kappa_{is}</code> is the number of edges from vertex <em>i</em> to
vertices in module <em>s</em>, and <code class="reqn">\kappa_s</code> is the degree of vertex
<em>i</em>. <code class="reqn">N_M</code> equals the number of modules.
</p>
<p>As discussed in Guimera et al., <code class="reqn">P_i = 0</code> if vertex <em>i</em> is connected
only to vertices in the same module, and <code class="reqn">P_i = 1</code> if vertex <em>i</em> is
equally connected to all other modules.
</p>
<p>The within-module degree z-score is:
</p>
<p style="text-align: center;"><code class="reqn">z_i = \frac{\kappa_i - \bar{\kappa}_{s_i}}{\sigma_{\kappa_{s_i}}}</code>
</p>

<p>where <code class="reqn">\kappa_i</code> is the number of edges from vertex <em>i</em> to vertices
in the same module <code class="reqn">s_i</code>, <code class="reqn">\bar{\kappa}_{s_i}</code> is the average of
<code class="reqn">\kappa</code> over all vertices in <code class="reqn">s_i</code>, and <code class="reqn">\sigma_{\kappa_{s_i}}</code>
is the standard deviation.
</p>


<h3>Value</h3>

<p>A vector of the participation coefficients, within-module degree
z-scores, or gateway coefficients for each vertex of the graph.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Vargas, E.R. and Wahl, L.M. (2014) The gateway coefficient: a
novel metric for identifying critical connections in modular networks.
<em>Eur Phys J B</em>, <b>87</b>, 161&ndash;170.
doi: <a href="https://doi.org/10.1140/epjb/e2014-40800-7">10.1140/epjb/e2014-40800-7</a>
</p>
<p>Guimera, R. and Amaral, L.A.N. (2005) Cartography of complex
networks: modules and universal roles. <em>Journal of Statistical
Mechanics: Theory and Experiment</em>, <b>02</b>, P02001.
doi: <a href="https://doi.org/10.1088/1742-5468/2005/02/P02001">10.1088/1742-5468/2005/02/P02001</a>
</p>

<hr>
<h2 id='vif.bg_GLM'>Variance inflation factors for <code>bg_GLM</code> objects</h2><span id='topic+vif.bg_GLM'></span>

<h3>Description</h3>

<p>Variance inflation factors for <code>bg_GLM</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif.bg_GLM(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vif.bg_GLM_+3A_mod">mod</code></td>
<td>
<p>A <code>bg_GLM</code> object</p>
</td></tr>
<tr><td><code id="vif.bg_GLM_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named array of VIFs; names of the 3rd dimension are regions
</p>

<hr>
<h2 id='vulnerability'>Calculate graph vulnerability</h2><span id='topic+vulnerability'></span>

<h3>Description</h3>

<p>This function calculates the <em>vulnerability</em> of the vertices of a graph.
Here, vulnerability is considered to be the proportional drop in global
efficiency when a given vertex is removed from the graph. The vulnerability
of the graph is considered the maximum across all vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vulnerability(g, use.parallel = TRUE, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vulnerability_+3A_g">g</code></td>
<td>
<p>An <code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="vulnerability_+3A_use.parallel">use.parallel</code></td>
<td>
<p>Logical indicating whether or not to use <em>foreach</em>
(default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="vulnerability_+3A_weighted">weighted</code></td>
<td>
<p>Logical indicating whether weighted efficiency should be
calculated (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length equal to the vertex count of <em>g</em>
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Latora, V. and Marchiori, M. (2005) Variability and protection of
infrastructure networks. <em>Physical Review E</em>, <b>71</b>, 015103.
doi: <a href="https://doi.org/10.1103/physreve.71.015103">10.1103/physreve.71.015103</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efficiency">efficiency</a></code>
</p>

<hr>
<h2 id='write_brainnet'>Write files to be used for visualization with BrainNet Viewer</h2><span id='topic+write_brainnet'></span>

<h3>Description</h3>

<p>Write the <code>.node</code> and <code>.edge</code> files necessary for visualization
with the BrainNet Viewer software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_brainnet(g, vcolor = "none", vsize = "constant",
  edge.wt = NULL, file.prefix = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_brainnet_+3A_g">g</code></td>
<td>
<p>The <code>igraph</code> graph object of interest</p>
</td></tr>
<tr><td><code id="write_brainnet_+3A_vcolor">vcolor</code></td>
<td>
<p>Character string indicating how to color the vertices (default:
<code>'none'</code>)</p>
</td></tr>
<tr><td><code id="write_brainnet_+3A_vsize">vsize</code></td>
<td>
<p>Character string indicating what size the vertices should be;
can be any vertex-level attribute (default: <code>'constant'</code>)</p>
</td></tr>
<tr><td><code id="write_brainnet_+3A_edge.wt">edge.wt</code></td>
<td>
<p>Character string indicating the edge attribute to use to
return a weighted adjacency matrix (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="write_brainnet_+3A_file.prefix">file.prefix</code></td>
<td>
<p>Character string for the basename of the <code>.node</code> and
<code>.edge</code> files that are written</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>.node</code> file, there are 6 columns:
</p>

<ul>
<li> <p><em>Columns 1-3</em>: Vertex x-, y-, and z-coordinates
</p>
</li>
<li> <p><em>Column 4</em>: Vertex color
</p>
</li>
<li> <p><em>Column 5</em>: Vertex size
</p>
</li>
<li> <p><em>Column 6</em>: Vertex label
</p>
</li></ul>

<p>The <code>.edge</code> file is the graph's associated adjacency matrix; a weighted
adjacency matrix can be returned by using the <code>edge.wt</code> argument.
</p>


<h3>Author(s)</h3>

<p>Christopher G. Watson, <a href="mailto:cgwatson@bu.edu">cgwatson@bu.edu</a>
</p>


<h3>References</h3>

<p>Xia, M. and Wang, J. and He, Y. (2013). BrainNet Viewer: a
network visualization tool for human brain connectomics. <em>PLoS One</em>,
<b>8(7)</b>, e68910. doi: <a href="https://doi.org/10.1371/journal.pone.0068910">10.1371/journal.pone.0068910</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
write_brainnet(g, vcolor='community', vsize='degree', edge.wt='t.stat')

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
