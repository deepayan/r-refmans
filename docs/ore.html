<!DOCTYPE html><html lang="en"><head><title>Help for package ore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#es'><p>Expression substitution</p></a></li>
<li><a href='#glass'><p>Multilingual sample text</p></a></li>
<li><a href='#matches'><p>Extract matching substrings</p></a></li>
<li><a href='#ore'><p>Oniguruma regular expressions</p></a></li>
<li><a href='#ore_dict'><p>Get or set entries in the pattern dictionary</p></a></li>
<li><a href='#ore_escape'><p>Escape regular expression special characters</p></a></li>
<li><a href='#ore_file'><p>Use a file as a text source</p></a></li>
<li><a href='#ore_ismatch'><p>Does text match a regex?</p></a></li>
<li><a href='#ore_lastmatch'><p>Retrieve the last match</p></a></li>
<li><a href='#ore_search'><p>Search for matches to a regular expression</p></a></li>
<li><a href='#ore_split'><p>Split strings using a regex</p></a></li>
<li><a href='#ore_subst'><p>Replace matched substrings with new text</p></a></li>
<li><a href='#ore_switch'><p>String multiplexing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.7.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-14</td>
</tr>
<tr>
<td>Title:</td>
<td>An R Interface to the Onigmo Regular Expression Library</td>
</tr>
<tr>
<td>Suggests:</td>
<td>crayon, rex, tinytest, covr</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an alternative to R's built-in functionality for handling
    regular expressions, based on the Onigmo library. Offers first-class
    compiled regex objects, partial matching and function-based substitutions,
    amongst other features.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENCE</td>
</tr>
<tr>
<td>Collate:</td>
<td>workspace.R file.R dict.R ore.R match.R es.R zzz.R</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jonclayden/ore">https://github.com/jonclayden/ore</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jonclayden/ore/issues">https://github.com/jonclayden/ore/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-14 17:38:27 UTC; jon</td>
</tr>
<tr>
<td>Author:</td>
<td>Jon Clayden <a href="https://orcid.org/0000-0002-6608-0619"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  K Kosako [aut],
  K Takata [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jon Clayden &lt;code@clayden.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='es'>Expression substitution</h2><span id='topic+es'></span>

<h3>Description</h3>

<p>Evaluate R expressions and substitute their values into one or more strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>es(text, round = NULL, signif = NULL, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="es_+3A_text">text</code></td>
<td>
<p>A vector of strings to substitute into.</p>
</td></tr>
<tr><td><code id="es_+3A_round">round</code></td>
<td>
<p><code>NULL</code> or a single integer, giving the number of decimal
digits for rounding numeric expressions. This argument takes priority over
<code>signif</code>.</p>
</td></tr>
<tr><td><code id="es_+3A_signif">signif</code></td>
<td>
<p><code>NULL</code> or a single integer, giving the number of
significant decimal digits to use for numeric expressions. The
<code>round</code> argument takes priority over this one, and will be used if
not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="es_+3A_envir">envir</code></td>
<td>
<p>The environment to evaluate expressions in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each part of the string surrounded by <code>"#{}"</code> is extracted, evaluated
as R code in the specified environment, and then its value is substituted
back into the string. The literal string <code>"#{}"</code> can be obtained by
escaping the hash character, viz. <code>"\\#{}"</code>. The block may contain
multiple R expressions, separated by semicolons, but may not contain
additional braces. Its value will be coerced to character mode, and if the
result has multiple elements then the source string will be duplicated.
</p>


<h3>Value</h3>

<p>The final strings, with expression values substituted into them.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore_subst">ore_subst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>es("pi is #{pi}")
es("pi is \\#{pi}")
es("The square-root of pi is approximately #{sqrt(pi)}", signif=4)
es("1/(1+x) for x=3 is #{x &lt;- 3; 1/(1+x)}")
</code></pre>

<hr>
<h2 id='glass'>Multilingual sample text</h2><span id='topic+glass'></span>

<h3>Description</h3>

<p>This dataset contains translations into many languages of the esoteric
sentence &quot;I can eat glass and it doesn't hurt me&quot;, UTF-8 encoded. Since
this dataset uses characters from a range of scripts, it provides a useful
test set for text handling and character encodings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glass
</code></pre>


<h3>Format</h3>

<p>A named character vector, whose elements are translations of the
sentence, and are named for the appropriate language in each case.
</p>


<h3>Source</h3>

<p>The translations were gathered by Frank da Cruz and written by a
large group of contributors. Notes, commentary and a full list of credits
are online at <a href="https://kermitproject.org/utf8.html">https://kermitproject.org/utf8.html</a>.
</p>

<hr>
<h2 id='matches'>Extract matching substrings</h2><span id='topic+matches'></span><span id='topic+matches.orematches'></span><span id='topic+matches.orematch'></span><span id='topic+matches.default'></span><span id='topic+groups'></span><span id='topic+groups.orematches'></span><span id='topic+groups.orematch'></span><span id='topic+groups.orearg'></span><span id='topic+groups.default'></span>

<h3>Description</h3>

<p>These functions extract entire matches, or just subgroup matches, from
objects of class <code>"orematch"</code>. They can also be applied to lists of
these objects, as returned by <code><a href="#topic+ore_search">ore_search</a></code> when more than one
string is searched. For other objects they return <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matches(object, ...)

## S3 method for class 'orematches'
matches(object, simplify = TRUE, ...)

## S3 method for class 'orematch'
matches(object, ...)

## Default S3 method:
matches(object, ...)

groups(object, ...)

## S3 method for class 'orematches'
groups(object, simplify = TRUE, ...)

## S3 method for class 'orematch'
groups(object, ...)

## S3 method for class 'orearg'
groups(object, ...)

## Default S3 method:
groups(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matches_+3A_object">object</code></td>
<td>
<p>An R object. Methods are provided for generic lists and
<code>"orematch"</code> objects. If no object is provided (i.e. the method is
called with no arguments), the value of <code><a href="#topic+ore_lastmatch">ore_lastmatch</a></code> will
be used as a default.</p>
</td></tr>
<tr><td><code id="matches_+3A_...">...</code></td>
<td>
<p>Further arguments to methods.</p>
</td></tr>
<tr><td><code id="matches_+3A_simplify">simplify</code></td>
<td>
<p>For the list methods, should nonmatching elements be removed
from the result?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, matrix, array, or list of the same, containing full
matches or subgroups. If <code>simplify</code> is <code>TRUE</code>, the result may
have a <code>dropped</code> attribute, giving the indices of nonmatching
elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore_search">ore_search</a></code>
</p>

<hr>
<h2 id='ore'>Oniguruma regular expressions</h2><span id='topic+ore'></span><span id='topic+is_ore'></span><span id='topic+is.ore'></span><span id='topic+print.ore'></span>

<h3>Description</h3>

<p>Create, test for, and print objects of class <code>"ore"</code>, which represent
Oniguruma regular expressions. These are unit-length character vectors with
additional attributes, including a pointer to the compiled version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore(..., options = "", encoding = getOption("ore.encoding"),
  syntax = c("ruby", "fixed"))

is_ore(x)

## S3 method for class 'ore'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_+3A_...">...</code></td>
<td>
<p>One or more strings or dictionary labels, constituting a valid
regular expression after being concatenated together. Elements drawn from
the dictionary will be surrounded by parentheses, turning them into
groups. Note that backslashes should be doubled, to avoid them being
interpreted as character escapes by R. The <code>...</code> argument is ignored
by the <code>print</code> method.</p>
</td></tr>
<tr><td><code id="ore_+3A_options">options</code></td>
<td>
<p>A string composed of characters indicating variations on the
usual interpretation of the regex. These may currently include <code>"i"</code>
for case-insensitive matching, and <code>"m"</code> for multiline matching (in
which case <code>"."</code> matches the newline character).</p>
</td></tr>
<tr><td><code id="ore_+3A_encoding">encoding</code></td>
<td>
<p>A string specifying the encoding that matching will take
place in. The default is given by the <code>"ore.encoding"</code> option, which
is usually set automatically from the current locale when the package is
loaded, but can be modified if needed.</p>
</td></tr>
<tr><td><code id="ore_+3A_syntax">syntax</code></td>
<td>
<p>The regular expression syntax being used. The default is
<code>"ruby"</code>, which reflects the syntax of the Ruby language, which is
very similar to that of Perl. An alternative is <code>"fixed"</code>, for
literal matching without special treatment of characters.</p>
</td></tr>
<tr><td><code id="ore_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ore</code> function returns the final pattern, with class
<code>"ore"</code> and the following attributes:
</p>

<dl>
<dt>.compiled</dt><dd><p>A low-level pointer to the compiled version of the
regular expression.</p>
</dd>
<dt>options</dt><dd><p>Options, copied from the argument of the same name.</p>
</dd>
<dt>encoding</dt><dd><p>The specified or detected encoding.</p>
</dd>
<dt>syntax</dt><dd><p>The specified syntax type.</p>
</dd>
<dt>nGroups</dt><dd><p>The number of groups in the pattern.</p>
</dd>
<dt>groupNames</dt><dd><p>Group names, if applicable.</p>
</dd>
</dl>

<p>The <code>is_ore</code> function returns a logical vector indicating whether
its argument represents an <code>"ore"</code> object.
</p>


<h3>See Also</h3>

<p>For full details of supported syntax, please see
<a href="https://raw.githubusercontent.com/k-takata/Onigmo/master/doc/RE">https://raw.githubusercontent.com/k-takata/Onigmo/master/doc/RE</a>. The
<code><a href="base.html#topic+regex">regex</a></code> page is also useful as a quick reference, since
PCRE (used by base R) and Oniguruma (used by <code>ore</code>) have similar
features. See <code><a href="#topic+ore_dict">ore_dict</a></code> for details of the pattern dictionary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This matches a positive or negative integer
ore("-?\\d+")

# This matches words of exactly four characters
ore("\\b\\w{4}\\b")
</code></pre>

<hr>
<h2 id='ore_dict'>Get or set entries in the pattern dictionary</h2><span id='topic+ore_dict'></span><span id='topic+ore.dict'></span>

<h3>Description</h3>

<p>This function allows the user to get or set entries in the pattern
dictionary, a library of regular expressions whose elements can be referred
to by name in <code><a href="#topic+ore">ore</a></code>, and therefore easily reused.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore_dict(..., enclos = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_dict_+3A_...">...</code></td>
<td>
<p>One or more strings or dictionary keys. Unnamed, literal strings
will be returned unmodified, named strings will be added to the
dictionary, and unquoted names will be resolved using the dictionary.</p>
</td></tr>
<tr><td><code id="ore_dict_+3A_enclos">enclos</code></td>
<td>
<p>Enclosure for resolving names not present in the dictionary.
Passed to <code><a href="base.html#topic+eval">eval</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no arguments are provided, the whole dictionary is returned.
Otherwise the return value is a (possibly named) character vector of
resolved strings.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore">ore</a></code>, which passes its arguments through this function
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Literal strings are returned as-is
ore_dict("protocol")

# Named arguments are added to the dictionary
ore_dict(protocol="\\w+://")

# ... and can be retrieved by name
ore_dict(protocol)

</code></pre>

<hr>
<h2 id='ore_escape'>Escape regular expression special characters</h2><span id='topic+ore_escape'></span><span id='topic+ore.escape'></span>

<h3>Description</h3>

<p>Escape characters that would usually be interpreted specially in a regular
expression, returning a modified version of the argument. This can be
useful when incorporating a general-purpose string into a larger regex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore_escape(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_escape_+3A_text">text</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the argument, with special characters escaped
by prefixing them with a backslash.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore">ore</a></code>
</p>

<hr>
<h2 id='ore_file'>Use a file as a text source</h2><span id='topic+ore_file'></span><span id='topic+orefile'></span><span id='topic+ore.file'></span>

<h3>Description</h3>

<p>Identify a file path to be used as a text source for a subsequent call to
<code><a href="#topic+ore_search">ore_search</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore_file(path, encoding = getOption("ore.encoding"), binary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_file_+3A_path">path</code></td>
<td>
<p>A character string giving the file path.</p>
</td></tr>
<tr><td><code id="ore_file_+3A_encoding">encoding</code></td>
<td>
<p>A character string giving the encoding of the file. This
should match the encoding of the regular expression used in a call to
<code><a href="#topic+ore_search">ore_search</a></code>.</p>
</td></tr>
<tr><td><code id="ore_file_+3A_binary">binary</code></td>
<td>
<p>A logical value: if <code>TRUE</code>, the file will be search
bytewise, and <code>encoding</code> will be fixed to be <code>"ASCII"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of class <code>"orefile"</code>, with the <code>encoding</code> and
<code>binary</code> arguments stored as attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore_search">ore_search</a></code> for actually searching through the file.
</p>

<hr>
<h2 id='ore_ismatch'>Does text match a regex?</h2><span id='topic+ore_ismatch'></span><span id='topic+ore.ismatch'></span><span id='topic++25~+25'></span><span id='topic++25~~+25'></span><span id='topic++25~+7C+25'></span>

<h3>Description</h3>

<p>These functions test whether the elements of a character vector match a
Oniguruma regular expression. The actual match can be retrieved using
<code><a href="#topic+ore_lastmatch">ore_lastmatch</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore_ismatch(regex, text, keepNA = getOption("ore.keepNA", FALSE), ...)

X %~% Y

X %~~% Y

X %~|% Y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_ismatch_+3A_regex">regex</code></td>
<td>
<p>A single character string or object of class <code>"ore"</code>.</p>
</td></tr>
<tr><td><code id="ore_ismatch_+3A_text">text</code></td>
<td>
<p>A character vector of strings to search.</p>
</td></tr>
<tr><td><code id="ore_ismatch_+3A_keepna">keepNA</code></td>
<td>
<p>If <code>TRUE</code>, <code>NA</code>s will be propagated from <code>text</code>
into the return value. Otherwise, they evaluate <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ore_ismatch_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="#topic+ore_search">ore_search</a></code>.</p>
</td></tr>
<tr><td><code id="ore_ismatch_+3A_x">X</code></td>
<td>
<p>A character vector or <code>"ore"</code> object. See Details.</p>
</td></tr>
<tr><td><code id="ore_ismatch_+3A_y">Y</code></td>
<td>
<p>A character vector. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>%~%</code> infix shorthand corresponds to <code>ore_ismatch(..., 
all=FALSE)</code>, while <code>%~~%</code> corresponds to <code>ore_ismatch(...,
all=TRUE)</code>. Either way, the first argument can be an <code>"ore"</code> object,
in which case the second is the text to search, or a character vector, in
which case the second argument is assumed to contain the regex. The
<code>%~|%</code> shorthand returns just those elements of the text vector which
match the regular expression.
</p>


<h3>Value</h3>

<p>A logical vector, indicating whether elements of <code>text</code> match
<code>regex</code>, or not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore_search">ore_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test for the presence of a vowel
ore_ismatch("[aeiou]", c("sky","lake"))  # =&gt; c(FALSE,TRUE)

# The same thing, in shorter form
c("sky","lake") %~% "[aeiou]"

# Same again: the first argument must be an "ore" object this way around
ore("[aeiou]") %~% c("sky","lake")
</code></pre>

<hr>
<h2 id='ore_lastmatch'>Retrieve the last match</h2><span id='topic+ore_lastmatch'></span><span id='topic+ore.lastmatch'></span>

<h3>Description</h3>

<p>This function can be used to obtain the <code>"orematch"</code> object, or list,
corresponding to the last call to <code><a href="#topic+ore_search">ore_search</a></code>. This can be
useful after performing a search implicitly, for example with <code>%~%</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore_lastmatch(simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_lastmatch_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code> and the last match was against a single
string, then the <code>"orematch"</code> object will be returned, instead of a
list with one element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>"orematch"</code> object or list. See <code><a href="#topic+ore_search">ore_search</a></code>
for details.
</p>

<hr>
<h2 id='ore_search'>Search for matches to a regular expression</h2><span id='topic+ore_search'></span><span id='topic+orematch'></span><span id='topic+orematches'></span><span id='topic+ore.search'></span><span id='topic+ore_match'></span><span id='topic+ore.match'></span><span id='topic+is_orematch'></span><span id='topic+is.orematch'></span><span id='topic++5B.orematch'></span><span id='topic++5B.orematches'></span><span id='topic+print.orematch'></span><span id='topic+print.orematches'></span>

<h3>Description</h3>

<p>Search a character vector, or the content of a file or connection, for one
or more matches to an Oniguruma-compatible regular expression. Printing and
indexing methods are available for the results. <code>ore_match</code> is an alias
for <code>ore_search</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore_search(regex, text, all = FALSE, start = 1L, simplify = TRUE,
  incremental = !all)

is_orematch(x)

## S3 method for class 'orematch'
x[j, k, ...]

## S3 method for class 'orematches'
x[i, j, k, ...]

## S3 method for class 'orematch'
print(x, lines = getOption("ore.lines", 0L),
  context = getOption("ore.context", 30L), width = getOption("width", 80L),
  ...)

## S3 method for class 'orematches'
print(x, lines = getOption("ore.lines", 0L),
  simplify = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_search_+3A_regex">regex</code></td>
<td>
<p>A single character string or object of class <code>"ore"</code>. In
the former case, this will first be passed through <code><a href="#topic+ore">ore</a></code>.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_text">text</code></td>
<td>
<p>A vector of strings to match against, or a connection, or the
result of a call to <code><a href="#topic+ore_file">ore_file</a></code> to search in a file. In the
latter case, match offsets will be relative to the file's encoding.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, then all matches within each element of
<code>text</code> will be found. Otherwise, the search will stop at the first
match.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_start">start</code></td>
<td>
<p>An optional vector of offsets (in characters) at which to start
searching. Will be recycled to the length of <code>text</code>.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code>, an object of class <code>"orematch"</code> will
be returned if <code>text</code> is of length 1. Otherwise, a list of such
objects, with class <code>"orematches"</code>, will always be returned. When
printing <code>"orematches"</code> objects, this controls whether or not to omit
nonmatching elements from the output.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_incremental">incremental</code></td>
<td>
<p>If <code>TRUE</code> and the <code>text</code> argument points to a
file, the file is read in increasingly large blocks. This can reduce
search time in large files.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_j">j</code></td>
<td>
<p>For indexing, the match number.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_k">k</code></td>
<td>
<p>For indexing, the group number.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_...">...</code></td>
<td>
<p>For <code>print.orematches</code>, additional arguments to be passed
through to <code>print.orematch</code>.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_i">i</code></td>
<td>
<p>For indexing into an <code>"orematches"</code> object only, the string
number.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_lines">lines</code></td>
<td>
<p>The maximum number of lines to print. The default is zero,
meaning no limit. For <code>"orematches"</code> objects this is split evenly
between the elements printed.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_context">context</code></td>
<td>
<p>The number of characters of context to include either side
of each match.</p>
</td></tr>
<tr><td><code id="ore_search_+3A_width">width</code></td>
<td>
<p>The number of characters in each line of printed output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>ore_search</code>, an <code>"orematch"</code> object, or a list of
the same, each with elements
</p>

<dl>
<dt>text</dt><dd><p>A copy of the <code>text</code> element for the current match, if
it was a character vector; otherwise a single string with the content
retrieved from the file or connection. If the source was a binary file
(from <code>ore_file(..., binary=TRUE)</code>) then this element will be
<code>NULL</code>.</p>
</dd>
<dt>nMatches</dt><dd><p>The number of matches found.</p>
</dd>
<dt>offsets</dt><dd><p>The offsets (in characters) of each match.</p>
</dd>
<dt>byteOffsets</dt><dd><p>The offsets (in bytes) of each match.</p>
</dd>
<dt>lengths</dt><dd><p>The lengths (in characters) of each match.</p>
</dd>
<dt>byteLengths</dt><dd><p>The lengths (in bytes) of each match.</p>
</dd>
<dt>matches</dt><dd><p>The matched substrings.</p>
</dd>
<dt>groups</dt><dd><p>Equivalent metadata for each parenthesised subgroup in
<code>regex</code>, in a series of matrices. If named groups are present in
the regex then <code>dimnames</code> will be set appropriately.</p>
</dd>
</dl>

<p>For <code>is_orematch</code>, a logical vector indicating whether the specified
object has class <code>"orematch"</code>. For extraction with one index, a
vector of matched substrings. For extraction with two indices, a vector
or matrix of substrings corresponding to captured groups.
</p>


<h3>Note</h3>

<p>Only named *or* unnamed groups will currently be captured, not both. If
there are named groups in the pattern, then unnamed groups will be ignored.
</p>
<p>By default the <code>print</code> method uses the <code>crayon</code> package (if it is
available) to determine whether or not the R terminal supports colour.
Alternatively, colour printing may be forced or disabled by setting the
<code>"ore.colour"</code> (or <code>"ore.color"</code>) option to a logical value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore">ore</a></code> for creating regex objects; <code><a href="#topic+matches">matches</a></code>
and <code><a href="#topic+groups">groups</a></code> for an alternative to indexing for extracting
matching substrings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pick out pairs of consecutive word characters
match &lt;- ore_search("(\\w)(\\w)", "This is a test", all=TRUE)

# Find the second matched substring ("is", from "This")
match[2]

# Find the content of the second group in the second match ("s")
match[2,2]
</code></pre>

<hr>
<h2 id='ore_split'>Split strings using a regex</h2><span id='topic+ore_split'></span><span id='topic+ore.split'></span>

<h3>Description</h3>

<p>This function breaks up the strings provided at regions matching a regular
expression, removing those regions from the result. It is analogous to the
<code><a href="base.html#topic+strsplit">strsplit</a></code> function in base R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore_split(regex, text, start = 1L, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_split_+3A_regex">regex</code></td>
<td>
<p>A single character string or object of class <code>"ore"</code>. In
the former case, this will first be passed through <code><a href="#topic+ore">ore</a></code>.</p>
</td></tr>
<tr><td><code id="ore_split_+3A_text">text</code></td>
<td>
<p>A vector of strings to match against.</p>
</td></tr>
<tr><td><code id="ore_split_+3A_start">start</code></td>
<td>
<p>An optional vector of offsets (in characters) at which to start
searching. Will be recycled to the length of <code>text</code>.</p>
</td></tr>
<tr><td><code id="ore_split_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code>, a character vector containing the pieces
will be returned if <code>text</code> is of length 1. Otherwise, a list of such
objects will always be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector or list of substrings.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore_search">ore_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ore_split("-?\\d+", "I have 2 dogs, 3 cats and 4 hamsters")
</code></pre>

<hr>
<h2 id='ore_subst'>Replace matched substrings with new text</h2><span id='topic+ore_subst'></span><span id='topic+ore.subst'></span><span id='topic+ore.repl'></span><span id='topic+ore_repl'></span>

<h3>Description</h3>

<p>These functions substitute new text into strings in regions that match a
regular expression. The substitutions may be simple text, may include
references to matched subgroups, or may be created by an R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore_subst(regex, replacement, text, ..., all = FALSE, start = 1L)

ore_repl(regex, replacement, text, ..., all = FALSE, start = 1L,
  simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_subst_+3A_regex">regex</code></td>
<td>
<p>A single character string or object of class <code>"ore"</code>. In
the former case, this will first be passed through <code><a href="#topic+ore">ore</a></code>.</p>
</td></tr>
<tr><td><code id="ore_subst_+3A_replacement">replacement</code></td>
<td>
<p>A character vector, or a function to be applied to the
matches.</p>
</td></tr>
<tr><td><code id="ore_subst_+3A_text">text</code></td>
<td>
<p>A vector of strings to match against.</p>
</td></tr>
<tr><td><code id="ore_subst_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>replacement</code>, if it is a function.</p>
</td></tr>
<tr><td><code id="ore_subst_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, then all matches within each element of
<code>text</code> will be found. Otherwise, the search will stop at the first
match.</p>
</td></tr>
<tr><td><code id="ore_subst_+3A_start">start</code></td>
<td>
<p>An optional vector of offsets (in characters) at which to start
searching. Will be recycled to the length of <code>text</code>.</p>
</td></tr>
<tr><td><code id="ore_subst_+3A_simplify">simplify</code></td>
<td>
<p>For <code>ore_repl</code>, a character vector of modified strings
will be returned if this is <code>TRUE</code> and <code>text</code> is of length 1.
Otherwise, a list of such objects will always be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions differ in how they are vectorised. <code>ore_subst</code>
vectorises over matches, and returns a vector of the same length as the
<code>text</code> argument. If multiple replacements are given then they are
applied to matches in turn. <code>ore_repl</code> vectorises over replacements,
replicating the elements of <code>text</code> as needed, and (in general)
returns a list the same length as <code>text</code>, whose elements are character
vectors each of the same length as <code>replacement</code> (or its return value,
if a function). Each string combines the first replacement for each match,
the second, and so on.
</p>
<p>If <code>replacement</code> is a character vector, its component strings may
include back-references to captured substrings. <code>"\\0"</code> corresponds
to the whole matching substring, <code>"\\1"</code> is the first captured
group, and so on. Named groups may be referenced as <code>"\\k&lt;name&gt;"</code>.
</p>
<p>If <code>replacement</code> is a function, then it will be passed as its first
argument an object of class <code>"orearg"</code>. This is a character vector
containing as its elements the matched substrings, and with an attribute
containing the matches for parenthesised subgroups, if there are any. A
<code><a href="#topic+groups">groups</a></code> method is available for this class, so the groups
attribute can be easily obtained that way. The substitution function will be
called once per element of <code>text</code> by <code>ore_subst</code>, and once per
match by <code>ore_repl</code>.
</p>


<h3>Value</h3>

<p>Versions of <code>text</code> with the substitutions made.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore_search">ore_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple text substitution (produces "no dogs")
ore_subst("\\d+", "no", "2 dogs")

# Back-referenced substitution (produces "22 dogs")
ore_subst("(\\d+)", "\\1\\1", "2 dogs")

# Function-based substitution (produces "4 dogs")
ore_subst("\\d+", function(i) as.numeric(i)^2, "2 dogs")
</code></pre>

<hr>
<h2 id='ore_switch'>String multiplexing</h2><span id='topic+ore_switch'></span><span id='topic+ore.switch'></span>

<h3>Description</h3>

<p>This function maps one character vector to another, based on sequential
matching to a series of regular expressions. The return value corresponding
to each element in the source text is chosen based on the first matching
regex: once matched, later options are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ore_switch(text, ..., options = "", encoding = getOption("ore.encoding"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ore_switch_+3A_text">text</code></td>
<td>
<p>A vector of strings to match against.</p>
</td></tr>
<tr><td><code id="ore_switch_+3A_...">...</code></td>
<td>
<p>One or more string arguments specifying a possible return value.
These are generally named with a regex, and the string is only used for a
given <code>text</code> element if the regex matches (and no previous one
matched). These strings may reference captured groups. Unnamed arguments
match unconditionally, and will always be taken literally.</p>
</td></tr>
<tr><td><code id="ore_switch_+3A_options">options</code></td>
<td>
<p>A string composed of characters indicating variations on the
usual interpretation of the regex. These may currently include <code>"i"</code>
for case-insensitive matching, and <code>"m"</code> for multiline matching (in
which case <code>"."</code> matches the newline character).</p>
</td></tr>
<tr><td><code id="ore_switch_+3A_encoding">encoding</code></td>
<td>
<p>A string specifying the encoding that matching will take
place in. The default is given by the <code>"ore.encoding"</code> option, which
is usually set automatically from the current locale when the package is
loaded, but can be modified if needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same length as <code>text</code>, containing the
multiplexed strings. If none of the regexes matched, the corresponding
element will be <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ore_subst">ore_subst</a></code> for details of back-reference syntax.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract digits where present; otherwise return zero
ore_switch(c("2 dogs","no dogs"), "\\d+"="\\0", "0")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
