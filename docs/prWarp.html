<!DOCTYPE html><html lang="en"><head><title>Help for package prWarp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prWarp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#array.to.xxyy'><p>Convert (p x k x n) data array into 2D data matrix</p></a></li>
<li><a href='#create.pw.be'><p>Principal warps</p></a></li>
<li><a href='#HomoMidSag'><p>HomoMidSag dataset</p></a></li>
<li><a href='#md.distri'><p>Mardia-Dryden distribution</p></a></li>
<li><a href='#papionin'><p>papionin dataset</p></a></li>
<li><a href='#ssim.distri'><p>Self-similar distribution</p></a></li>
<li><a href='#tps.all'><p>Thin plate spline mapping (2D and 3D) for several sets of landmark coordinates</p></a></li>
<li><a href='#xxyy.to.array'><p>Convert landmark data matrix into array (p x k x n)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Warping Landmark Configurations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-19</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute bending energies, principal warps, partial warp scores, and the non-affine component of shape variation for 2D landmark configurations, as well as Mardia-Dryden distributions and self-similar distributions of landmarks, as described in Mitteroecker et al. (2020) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyaa007">doi:10.1093/sysbio/syaa007</a>&gt;. Working examples to decompose shape variation into small-scale and large-scale components, and to decompose the total shape variation into outline and residual shape components are provided. Two landmark datasets are provided, that quantify skull morphology in humans and papionin primates, respectively from Mitteroecker et al. (2020) &lt;<a href="https://doi.org/10.5061%2Fdryad.j6q573n8s">doi:10.5061/dryad.j6q573n8s</a>&gt; and Grunstra et al. (2020) &lt;<a href="https://doi.org/10.5061%2Fdryad.zkh189373">doi:10.5061/dryad.zkh189373</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Morpho</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, geomorph</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 17:30:06 UTC; Anne</td>
</tr>
<tr>
<td>Author:</td>
<td>Anne Le Maitre <a href="https://orcid.org/0000-0003-2690-7367"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Silvester Bartsch [aut],
  Nicole Grunstra [aut],
  Philipp Mitteroecker [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anne Le Maitre &lt;anne.le.maitre@univie.ac.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='array.to.xxyy'>Convert (p x k x n) data array into 2D data matrix</h2><span id='topic+array.to.xxyy'></span>

<h3>Description</h3>

<p>Convert a three-dimensional array of landmark coordinates into a two-dimensional matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array.to.xxyy(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="array.to.xxyy_+3A_a">A</code></td>
<td>
<p>A 3D array (p x k x n) containing landmark coordinates for a set of specimens</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a two-dimensional matrix of dimension (n x [p x k]),
where rows represent specimens and columns represent variables.
The p first columns correspond to X coordinates, etc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xxyy.to.array">xxyy.to.array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- array(rnorm(40), c(5, 2, 4))  # random 2D coordinates of 5 landmarks for 4 specimens
array.to.xxyy(A)

</code></pre>

<hr>
<h2 id='create.pw.be'>Principal warps</h2><span id='topic+create.pw.be'></span>

<h3>Description</h3>

<p>Computes the principal warps and the bending energy of a reference shape configuration,
as well as the variance of the partial waprs, the partial warp scores and the non-affine component of shape variation
for 2D landmark coordinates (3D not implemented).
Small-scale and large-scale components of shape variation can also be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.pw.be(A, M_ref, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.pw.be_+3A_a">A</code></td>
<td>
<p>a k x 2 x n array, where k is the number of 2D landmarks, and n is the sample size.</p>
</td></tr>
<tr><td><code id="create.pw.be_+3A_m_ref">M_ref</code></td>
<td>
<p>a k x 2 refence matrix (usually the sample mean shape), where k is the number of 2D landmarks</p>
</td></tr>
<tr><td><code id="create.pw.be_+3A_d">d</code></td>
<td>
<p>(optional) an integer value comprised between 1 and (k-3) to compute small-scale shape components (between 1 and d)
and large-scale shape components (between d+1 and k-3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following named components:
</p>
<table role = "presentation">
<tr><td><code>bendingEnergy</code></td>
<td>
<p>the bending energy (the (k-3) eigenvalues of the bending energy matrix)</p>
</td></tr>
<tr><td><code>principalWarps</code></td>
<td>
<p>the k x (k-3) matrix of principal warps (the k eigenvectors of the bending energy matrix)</p>
</td></tr>
<tr><td><code>partialWarpScores</code></td>
<td>
<p>the n x (2k-6) matrix of partial warp (the projection of the vectors of shape coordinates, expressed as deviations from the reference shape, onto the principal warps)</p>
</td></tr>
<tr><td><code>variancePW</code></td>
<td>
<p>the variance of the (k-3) partial warps</p>
</td></tr>
<tr><td><code>Xnonaf</code></td>
<td>
<p>the n x 2k matrix of the non-affine component of shape variation</p>
</td></tr>
<tr><td><code>Xsmall</code></td>
<td>
<p>the n x 2k matrix of the small-scale shape variation (if d is provided)</p>
</td></tr>
<tr><td><code>Xlarge</code></td>
<td>
<p>the n x 2k matrix of the large-scale shape variation (if d is provided)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bookstein FL. (1989).
Principal Warps: Thin-plate splines and the decomposition of deformations.
<em>IEEE Transactions on pattern analysis and machine intelligence 11(6)</em>: 567&ndash;585.
<a href="https://ieeexplore.ieee.org/abstract/document/24792">https://ieeexplore.ieee.org/abstract/document/24792</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="Morpho.html#topic+CreateL">CreateL</a></code> for the creation of the bending energy matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2D landmark coordinates
library("geomorph")
data("HomoMidSag")  # dataset
n_spec &lt;- dim(HomoMidSag)[1]  # number of specimens
k &lt;- dim(HomoMidSag)[2] / 2  # number of landmarks
homo_ar &lt;- arrayspecs(HomoMidSag, k, 2)  # create an array

# Procrustes registration
homo_gpa &lt;- Morpho::procSym(homo_ar)
m_overall &lt;- homo_gpa$rotated  # Procrustes coordinates
m_mshape &lt;- homo_gpa$mshape  # average shape

# Computation of bending energy, partial warp scores etc.
homo_be_pw &lt;- create.pw.be(m_overall, m_mshape)

# Partial warp variance as a function of bending energy
logInvBE &lt;- log((homo_be_pw$bendingEnergy)^(-1))  # inverse log bending energy
logPWvar &lt;- log(homo_be_pw$variancePW)  # log variance of partial warps
mod &lt;- lm(logPWvar ~ logInvBE)  # linear regression
# Plot log PW variance on log BE^-1 with regression line
plot(logInvBE, logPWvar, col = "white", asp = 1,
main = "PW variance against inverse BE", xlab = "log 1/BE", ylab = "log PW variance")
text(logInvBE, logPWvar, labels = names(logPWvar), cex = 0.5)
abline(mod, col = "blue")

</code></pre>

<hr>
<h2 id='HomoMidSag'>HomoMidSag dataset</h2><span id='topic+HomoMidSag'></span>

<h3>Description</h3>

<p>2D Cartesian coordinates of 87 landmarks quantifying the skull morphology along the midsagittal plane for 24 adult modern humans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HomoMidSag)
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 rows and 184 variables
</p>


<h3>References</h3>

<p>Bartsch, Silvester (2019)
The ontogeny of hominid cranial form: A geometric morphometric analysis of coordinated and compensatory processes.
Master's thesis, University of Vienna.
</p>
<p>Mitteroecker, Philipp et al. (2020)
Morphometric variation at different spatial scales: coordination and compensation in the emergence of organismal form.
<em>Systematic Biology</em>, 69(5): 913&ndash;926. doi: 10.1093/sysbio/syaa007
</p>
<p>Mitteroecker, Philipp et al. (2020)
Data form: Morphometric variation at different spatial scales: coordination and compensation in the emergence of organismal form.
<em>Dryad Digital Repository</em>. doi: 10.5061/dryad.j6q573n8s
</p>

<hr>
<h2 id='md.distri'>Mardia-Dryden distribution</h2><span id='topic+md.distri'></span>

<h3>Description</h3>

<p>Create a matrix of 2D shape coordinates drawn from a Mardia-Dryden distribution (3D not implemented)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md.distri(M_ref, n, sd = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="md.distri_+3A_m_ref">M_ref</code></td>
<td>
<p>a k x 2 refence matrix (usually the sample mean shape), where k is the number of 2D landmarks</p>
</td></tr>
<tr><td><code id="md.distri_+3A_n">n</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code id="md.distri_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the distribution (default = 0.02)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the n x 2k matrix of shape coordinates drawn from a Mardia-Dryden distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2D landmark coordinates
library("geomorph")
data("HomoMidSag")  # dataset
n_spec &lt;- dim(HomoMidSag)[1]  # number of specimens
k &lt;- dim(HomoMidSag)[2] / 2  # number of landmarks
homo_ar &lt;- arrayspecs(HomoMidSag, k, 2)  # create an array

# Procrustes registration
homo_gpa &lt;- Morpho::procSym(homo_ar)
m_mshape &lt;- homo_gpa$mshape  # average shape

# Mardia-Dryden distribution
Xmd &lt;- md.distri(m_mshape, n = n_spec, sd = 0.005)
# Visualization
plot(Xmd[, 1:k], Xmd[, (k+1):(2*k)], asp = 1, las = 1, cex = 0.5,
main = "Mardia-Dryden distribution", xlab = "X", ylab = "Y")

</code></pre>

<hr>
<h2 id='papionin'>papionin dataset</h2><span id='topic+papionin'></span>

<h3>Description</h3>

<p>2D Cartesian coordinates of 70 landmarks
quantifying the skull morphology along the midsagittal plane
for 67 adult modern primates (mostly papionins).
The data correspond to a list with the 6 following elements:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(papionin)
</code></pre>


<h3>Format</h3>

<p>A list of 6 elements.
</p>


<h3>Details</h3>


<ul>
<li> <p><strong>coords</strong> The 3D array of landmark coordinates
</p>
</li>
<li> <p><strong>species</strong> The vector of species names
</p>
</li>
<li> <p><strong>semi_lm</strong> The vector of semilandmark numbers of the full dataset
</p>
</li>
<li> <p><strong>curves</strong> The list of curves for sliding semilandmarks of the full dataset
</p>
</li>
<li> <p><strong>links</strong> The matrix of links between landmarks for the full dataset
</p>
</li>
<li> <p><strong>outline</strong> A list of 4 elements for the analysis of the outline shape: <strong>subset</strong>, the landmark numbers for the susbet; <strong>semi_lm</strong>, the vector of semilandmark numbers; <strong>curves</strong>, the list of curves for sliding semilandmarks; <strong>links</strong>, the matrix of links between landmarks for the full dataset.
</p>
</li></ul>



<h3>References</h3>

<p>Grunstra, Nicole D. S. et al. (2021)
Detecting phylogenetic signal and adaptation in papionin cranial shape by decomposing variation at different spatial scales.
<em>Systematic Biology</em>, 70(4): 694&ndash;706. doi: 10.1093/sysbio/syaa093
</p>
<p>Grunstra, Nicole D. S. et al. (2020)
Data form: Detecting phylogenetic signal and adaptation in papionin cranial shape by decomposing variation at different spatial scales.
<em>Dryad Digital Repository</em>. doi: 10.5061/dryad.zkh189373
</p>

<hr>
<h2 id='ssim.distri'>Self-similar distribution</h2><span id='topic+ssim.distri'></span>

<h3>Description</h3>

<p>Create a matrix of 2D shape coordinates drawn from a self-similar distribution (3D not implemented)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssim.distri(M_ref, n, sd = 0.02, f = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssim.distri_+3A_m_ref">M_ref</code></td>
<td>
<p>a k x 2 refence matrix (usually the sample mean shape), where k is the number of 2D landmarks</p>
</td></tr>
<tr><td><code id="ssim.distri_+3A_n">n</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code id="ssim.distri_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the distribution (default = 0.02)</p>
</td></tr>
<tr><td><code id="ssim.distri_+3A_f">f</code></td>
<td>
<p>a scaling factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the n x 2k matrix of shape coordinates drawn from a self-similar distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2D landmark coordinates
library("geomorph")
data("HomoMidSag")  # dataset
n_spec &lt;- dim(HomoMidSag)[1]  # number of specimens
k &lt;- dim(HomoMidSag)[2] / 2  # number of landmarks
homo_ar &lt;- arrayspecs(HomoMidSag, k, 2)  # create an array

# Procrustes registration
homo_gpa &lt;- Morpho::procSym(homo_ar)
m_mshape &lt;- homo_gpa$mshape  # average shape

# Self-similar distribution
Xdefl &lt;- ssim.distri(m_mshape, n = n_spec, sd = 0.05, f = 1)
# Visualization
plot(Xdefl[, 1:k], Xdefl[, (k+1):(2*k)], asp = 1, las = 1, cex = 0.5,
main = "Self-similar distribution", xlab = "X", ylab = "Y")

</code></pre>

<hr>
<h2 id='tps.all'>Thin plate spline mapping (2D and 3D) for several sets of landmark coordinates</h2><span id='topic+tps.all'></span>

<h3>Description</h3>

<p>Maps landmarks via thin plate spline
based on a reference and a target configuration in 2D or in 3D.
This function is an extension of the tps3d function for a set of specimens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tps.all(X_array, REF_array, TAR_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tps.all_+3A_x_array">X_array</code></td>
<td>
<p>original coordinates
- a 3D array (p x k x n) containing original landmark coordinates for a set of specimens</p>
</td></tr>
<tr><td><code id="tps.all_+3A_ref_array">REF_array</code></td>
<td>
<p>reference coordinates (e.g., outline landmarks for all specimens)
- a 3D array (p x k x n) containing reference landmark coordinates for a set of specimens</p>
</td></tr>
<tr><td><code id="tps.all_+3A_tar_matrix">TAR_matrix</code></td>
<td>
<p>target coordinates (e.g., average outline landmarks)
- a matrix (n x k) containing target landmark coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>p is the number of landmark points, k is the number of landmark dimensions (2 or 3), and n is the number of specimens.
</p>


<h3>Value</h3>

<p>Function returns a 3D array (p x k x n) containing the deformed input
(original landmark set warped onto the target matrix).
</p>


<h3>References</h3>

<p>Bookstein FL. (1989).
Principal Warps: Thin-plate splines and the decomposition of deformations.
<em>IEEE Transactions on pattern analysis and machine intelligence</em>, 11(6): 567&ndash;585.
<a href="https://ieeexplore.ieee.org/abstract/document/24792">https://ieeexplore.ieee.org/abstract/document/24792</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="Morpho.html#topic+tps3d">tps3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("papionin")  # load dataset
# Full dataset: 70 landmarks
papionin_ar &lt;- papionin$coords
# Outline dataset: subset of 54 landmarks
outline_ar &lt;- papionin_ar[papionin$outline$subset, , ]

# Subset: Macaca only
mac &lt;- grep("Macaca", papionin$species)  # genus Macaca
papionin_macaca &lt;- papionin_ar[, , mac]
outline_macaca &lt;- outline_ar[, , mac]

# Landmark sliding by minimizing bending energy + superimposition (GPA)
library("Morpho")
papionin_gpa &lt;- procSym(papionin_macaca, SMvector = papionin$semi_lm,
                        outlines = papionin$curves)
outline_gpa &lt;- procSym(outline_macaca, SMvector = papionin$outline$semi_lm,
                       outlines = papionin$outline$curves)

# Warping the slid landmarks of the full landmark dataset to the average outline shape
residual_shape &lt;- tps.all(X_array = papionin_gpa$dataslide,
                          REF_array = outline_gpa$dataslide,
                          TAR_matrix = outline_gpa$mshape)

</code></pre>

<hr>
<h2 id='xxyy.to.array'>Convert landmark data matrix into array (p x k x n)</h2><span id='topic+xxyy.to.array'></span>

<h3>Description</h3>

<p>Convert a matrix of landmark coordinates into a three-dimensional array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xxyy.to.array(M, p, k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xxyy.to.array_+3A_m">M</code></td>
<td>
<p>A matrix of dimension n x [p x k] containing landmark coordinates for a set of specimens.
Each row contains all landmark coordinates for a single specimen.
The first columns correspond to the X coordinates for all landmarks, etc.</p>
</td></tr>
<tr><td><code id="xxyy.to.array_+3A_p">p</code></td>
<td>
<p>Number of landmarks</p>
</td></tr>
<tr><td><code id="xxyy.to.array_+3A_k">k</code></td>
<td>
<p>Number of dimensions (2 or 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a 3D array (p x k x n),
where p is the number of landmark points,
k is the number of landmark dimensions (2 or 3),
and n is the number of specimens.
The third dimension of this array contains names for each specimen
if specified in the original input matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+array.to.xxyy">array.to.xxyy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(40), nrow = 4) # Random 2D coordinates of 5 landmarks for 4 specimens
xxyy.to.array(X, 5, 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
