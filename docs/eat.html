<!DOCTYPE html><html><head><title>Help for package eat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eat-package'><p>EAT: Efficiency Analysis Trees</p></a></li>
<li><a href='#alpha'><p>Alpha Calculation for Pruning Procedure of Efficiency Analysis Trees</p></a></li>
<li><a href='#bagging'><p>Bagging data</p></a></li>
<li><a href='#barplot_importance'><p>Barplot Variable Importance</p></a></li>
<li><a href='#bestEAT'><p>Tuning an Efficiency Analysis Trees model</p></a></li>
<li><a href='#bestRFEAT'><p>Tuning a Random Forest + Efficiency Analysis Trees model</p></a></li>
<li><a href='#CEAT_BCC_in'><p>Banker, Charnes and Cooper programming model with input orientation for a Convexified Efficiency Analysis Trees model</p></a></li>
<li><a href='#CEAT_BCC_out'><p>Banker, Charnes and Cooper programming model with output orientation for a Convexified Efficiency Analysis Trees model</p></a></li>
<li><a href='#CEAT_DDF'><p>Directional Distance Function mathematical programming model for a Convexified Efficiency Analysis Trees model</p></a></li>
<li><a href='#CEAT_RSL_in'><p>Russell Model with input orientation for a Convexified Efficiency Analysis Trees model</p></a></li>
<li><a href='#CEAT_RSL_out'><p>Russell Model with output orientation for a Convexified Efficiency Analysis Trees model</p></a></li>
<li><a href='#CEAT_WAM'><p>Weighted Additive Model for a Convexified Efficiency Analysis Trees model</p></a></li>
<li><a href='#checkEAT'><p>Check Efficiency Analysis Trees.</p></a></li>
<li><a href='#comparePareto'><p>Pareto-dominance relationships</p></a></li>
<li><a href='#deepEAT'><p>Deep Efficiency Analysis Trees</p></a></li>
<li><a href='#EAT'><p>Efficiency Analysis Trees</p></a></li>
<li><a href='#EAT_BCC_in'><p>Banker, Charnes and Cooper Programming Model with Input Orientation for an Efficiency Analysis Trees model</p></a></li>
<li><a href='#EAT_BCC_out'><p>Banker, Charnes and Cooper Programming Model with Output Orientation for an Efficiency Analysis Trees model</p></a></li>
<li><a href='#EAT_DDF'><p>Directional Distance Function Programming Model for an Efficiency Analysis Trees model</p></a></li>
<li><a href='#EAT_frontier_levels'><p>Output Levels in an Efficiency Analysis Trees model</p></a></li>
<li><a href='#EAT_leaf_stats'><p>Descriptive Summary Statistics Table for the Leaf Nodes of an Efficiency Analysis Trees model</p></a></li>
<li><a href='#EAT_object'><p>Create a EAT object</p></a></li>
<li><a href='#EAT_RSL_in'><p>Russell Model with Input Orientation for an Efficiency Analysis Trees model</p></a></li>
<li><a href='#EAT_RSL_out'><p>Russell Model with Output Orientation for an Efficiency Analysis Trees model</p></a></li>
<li><a href='#EAT_size'><p>Number of Leaf Nodes in an Efficiency Analysis Trees model</p></a></li>
<li><a href='#EAT_WAM'><p>Weighted Additive Model for an Efficiency Analysis Trees model</p></a></li>
<li><a href='#efficiencyCEAT'><p>Efficiency Scores computed through a Convexified Efficiency Analysis Trees model.</p></a></li>
<li><a href='#efficiencyDensity'><p>Efficiency Scores Density Plot</p></a></li>
<li><a href='#efficiencyEAT'><p>Efficiency Scores computed through an Efficiency Analysis Trees model.</p></a></li>
<li><a href='#efficiencyJitter'><p>Efficiency Scores Jitter Plot</p></a></li>
<li><a href='#efficiencyRFEAT'><p>Efficiency Scores computed through a Random Forest + Efficiency Analysis Trees model.</p></a></li>
<li><a href='#estimEAT'><p>Estimation of child nodes</p></a></li>
<li><a href='#frontier'><p>Efficiency Analysis Trees Frontier Graph</p></a></li>
<li><a href='#generateLv'><p>Train and Test Sets Generation</p></a></li>
<li><a href='#imp_var_EAT'><p>Breiman's Variable Importance</p></a></li>
<li><a href='#imp_var_RFEAT'><p>Variable Importance through Random Forest + Efficiency Analysis Trees</p></a></li>
<li><a href='#isFinalNode'><p>Is Final Node</p></a></li>
<li><a href='#layout'><p>Layout for nodes in plotEAT</p></a></li>
<li><a href='#M_Breiman'><p>Breiman Importance</p></a></li>
<li><a href='#mse'><p>Mean Squared Error</p></a></li>
<li><a href='#mtry_inputSelection'><p>Random Selection of Variables</p></a></li>
<li><a href='#PISAindex'><p>PISA score and social index by country</p></a></li>
<li><a href='#plotEAT'><p>Efficiency Analysis Trees Plot</p></a></li>
<li><a href='#plotRFEAT'><p>Random Forest + Efficiency Analysis Trees Plot</p></a></li>
<li><a href='#posIdNode'><p>Position of the node</p></a></li>
<li><a href='#predict.EAT'><p>Model Prediction for Efficiency Analysis Trees.</p></a></li>
<li><a href='#predict.RFEAT'><p>Model prediction for Random Forest + Efficiency Analysis Trees model.</p></a></li>
<li><a href='#predictFDH'><p>Model prediction for Free Disposal Hull</p></a></li>
<li><a href='#predictor'><p>Efficiency Analysis Trees Predictor</p></a></li>
<li><a href='#preProcess'><p>Data Preprocessing for Efficiency Analysis Trees</p></a></li>
<li><a href='#RandomEAT'><p>Individual EAT for Random Forest</p></a></li>
<li><a href='#rankingEAT'><p>Ranking of Variables by Efficiency Analysis Trees model.</p></a></li>
<li><a href='#rankingRFEAT'><p>Ranking of variables by Random Forest + Efficiency Analysis Trees model.</p></a></li>
<li><a href='#RBranch'><p>Branch Pruning</p></a></li>
<li><a href='#RCV'><p>RCV</p></a></li>
<li><a href='#RF_predictor'><p>Random Forest + Efficiency Analysis Trees Predictor</p></a></li>
<li><a href='#RFEAT'><p>Random Forest + Efficiency Analysis Trees</p></a></li>
<li><a href='#RFEAT_object'><p>Create a RFEAT object</p></a></li>
<li><a href='#scores'><p>Pruning Scores</p></a></li>
<li><a href='#select_mtry'><p>Select Possible Inputs in Split.</p></a></li>
<li><a href='#selectTk'><p>Select Tk</p></a></li>
<li><a href='#SERules'><p>SERules</p></a></li>
<li><a href='#split'><p>Split node</p></a></li>
<li><a href='#split_forest'><p>Split Node in Random Forest EAT</p></a></li>
<li><a href='#treesForRCV'><p>Trees for RCV</p></a></li>
<li><a href='#X2Y2.sim'><p>2 Inputs &amp; 2 Outputs Data Generation</p></a></li>
<li><a href='#Y1.sim'><p>Single Output Data Generation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Efficiency Analysis Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are provided to determine production frontiers and technical 
    efficiency measures through non-parametric techniques based upon regression trees. 
    The package includes code for estimating radial input, output, directional and 
    additive measures, plotting graphical representations of the scores and the production 
    frontiers by means of trees, and determining rankings of importance of input variables 
    in the analysis. Additionally, an adaptation of Random Forest by a set of individual 
    Efficiency Analysis Trees for estimating technical efficiency is also included. More 
    details in: &lt;<a href="https://doi.org/10.1016%2Fj.eswa.2020.113783">doi:10.1016/j.eswa.2020.113783</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, conflicted, stats, ggplot2, ggparty, partykit, ggrepel,
Rdpack, lpSolveAPI, utils, reshape2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, testthat, knitr, kableExtra, devtools</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://efficiencytools.wordpress.com/">https://efficiencytools.wordpress.com/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MiriamEsteve/EAT/issues">https://github.com/MiriamEsteve/EAT/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-10 08:53:37 UTC; Miriam_Esteve</td>
</tr>
<tr>
<td>Author:</td>
<td>Miriam Esteve <a href="https://orcid.org/0000-0002-5908-0581"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Víctor España <a href="https://orcid.org/0000-0002-1807-6180"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Juan Aparicio <a href="https://orcid.org/0000-0002-0867-0004"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Xavier Barber <a href="https://orcid.org/0000-0003-3079-5855"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Miriam Esteve &lt;mestevecampello@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-10 09:20:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='eat-package'>EAT: Efficiency Analysis Trees</h2><span id='topic+eat'></span><span id='topic+eat-package'></span>

<h3>Description</h3>

<p>This package provides functions to determine production frontiers and technical efficiency measures through non-parametric techniques based upon regression trees. The package includes code for estimating radial input, output, directional and additive measures, plotting graphical representations of the scores and the production frontiers by means of trees, and determining rankings of importance of input variables in the analysis. Additionally, an adaptation of Random Forest by a set of individual Efficiency Analysis Trees for estimating technical efficiency is also included.
</p>


<h3>Author(s)</h3>

<p><strong>Mantainers</strong>: </p>

<ul>
<li><p>Miriam Esteve Campello <a href="mailto:mestevecampello@gmail.es">mestevecampello@gmail.es</a>
</p>
</li>
<li><p>Víctor Javier España Roch
</p>
</li></ul>

<p>Authors:
</p>

<ul>
<li><p>Miriam Esteve Campello
</p>
</li>
<li><p>Víctor Javier España Roch
</p>
</li>
<li><p>Juan Aparicio Baeza
</p>
</li>
<li><p>Xavier Barber Vallés
</p>
</li></ul>



<h3>See Also</h3>

<p>Github: <a href="https://github.com/MiriamEsteve/EAT">https://github.com/MiriamEsteve/EAT</a>
Esteve M, Aparicio J, Rabasa A, Rodriguez-Sala JJ (2020).
&ldquo;Efficiency analysis trees: A new methodology for estimating production frontiers through decision trees.&rdquo;
<em>Expert Systems with Applications</em>, <b>162</b>, 113783.
</p>

<hr>
<h2 id='alpha'>Alpha Calculation for Pruning Procedure of Efficiency Analysis Trees</h2><span id='topic+alpha'></span>

<h3>Description</h3>

<p>This function gets the minimum alpha for each subtree evaluated during the pruning procedure of the Efficiency Analysis Trees technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha_+3A_tree">tree</code></td>
<td>
<p>A <code>list</code> containing the EAT nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value corresponding to the minimum alpha associated with a suitable node to be pruned.
</p>

<hr>
<h2 id='bagging'>Bagging data</h2><span id='topic+bagging'></span>

<h3>Description</h3>

<p>Bootstrap aggregating for data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bagging(data, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bagging_+3A_data">data</code></td>
<td>
<p>Dataframe containing the variables in the model.</p>
</td></tr>
<tr><td><code id="bagging_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="bagging_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing training dataframe and list with binary response as 0 if the observations have been selected for training and 0 in any other case.
</p>

<hr>
<h2 id='barplot_importance'>Barplot Variable Importance</h2><span id='topic+barplot_importance'></span>

<h3>Description</h3>

<p>This function generates a barplot with the importance of each predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barplot_importance(m, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplot_importance_+3A_m">m</code></td>
<td>
<p>Dataframe with the importance of each predictor.</p>
</td></tr>
<tr><td><code id="barplot_importance_+3A_threshold">threshold</code></td>
<td>
<p>Importance score value in which a line should be graphed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Barplot representing each variable on the x-axis and its importance on the y-axis.
</p>

<hr>
<h2 id='bestEAT'>Tuning an Efficiency Analysis Trees model</h2><span id='topic+bestEAT'></span>

<h3>Description</h3>

<p>This funcion computes the root mean squared error (RMSE) for a set of Efficiency Analysis Trees models built with a grid of given hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestEAT(
  training,
  test,
  x,
  y,
  numStop = 5,
  fold = 5,
  max.depth = NULL,
  max.leaves = NULL,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestEAT_+3A_training">training</code></td>
<td>
<p>Training <code>data.frame</code> or <code>matrix</code> containing the variables for model construction.</p>
</td></tr>
<tr><td><code id="bestEAT_+3A_test">test</code></td>
<td>
<p>Test <code>data.frame</code> or <code>matrix</code> containing the variables for model assessment.</p>
</td></tr>
<tr><td><code id="bestEAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>training</code>.</p>
</td></tr>
<tr><td><code id="bestEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>training</code>.</p>
</td></tr>
<tr><td><code id="bestEAT_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="bestEAT_+3A_fold">fold</code></td>
<td>
<p>Folds in which the dataset to apply cross-validation during the pruning is divided.</p>
</td></tr>
<tr><td><code id="bestEAT_+3A_max.depth">max.depth</code></td>
<td>
<p>Maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="bestEAT_+3A_max.leaves">max.leaves</code></td>
<td>
<p>Maximum number of leaf nodes.</p>
</td></tr>
<tr><td><code id="bestEAT_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the sets of hyperparameters and the root mean squared error (RMSE) associated for each model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("PISAindex")

n &lt;- nrow(PISAindex) # Observations in the dataset
selected &lt;- sample(1:n, n * 0.7) # Training indexes
training &lt;- PISAindex[selected, ] # Training set
test &lt;- PISAindex[- selected, ] # Test set

bestEAT(training = training, 
        test = test,
        x = 6:9,
        y = 3,
        numStop = c(3, 5, 7),
        fold = c(5, 7, 10))


</code></pre>

<hr>
<h2 id='bestRFEAT'>Tuning a Random Forest + Efficiency Analysis Trees model</h2><span id='topic+bestRFEAT'></span>

<h3>Description</h3>

<p>This funcion computes the root mean squared error (RMSE) for a set of Random FOrest + Efficiency Analysis Trees models built with a grid of given hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestRFEAT(
  training,
  test,
  x,
  y,
  numStop = 5,
  m = 50,
  s_mtry = c("5", "BRM"),
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestRFEAT_+3A_training">training</code></td>
<td>
<p>Training <code>data.frame</code> or <code>matrix</code> containing the variables for model construction.</p>
</td></tr>
<tr><td><code id="bestRFEAT_+3A_test">test</code></td>
<td>
<p>Test <code>data.frame</code> or <code>matrix</code> containing the variables for model assessment.</p>
</td></tr>
<tr><td><code id="bestRFEAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>training</code>.</p>
</td></tr>
<tr><td><code id="bestRFEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>training</code>.</p>
</td></tr>
<tr><td><code id="bestRFEAT_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="bestRFEAT_+3A_m">m</code></td>
<td>
<p>Number of trees to be built.</p>
</td></tr>
<tr><td><code id="bestRFEAT_+3A_s_mtry">s_mtry</code></td>
<td>
<p><code>character</code>. Number of inputs to be selected in each split. See &ldquo;</p>
</td></tr>
<tr><td><code id="bestRFEAT_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the sets of hyperparameters and the root mean squared error (RMSE) associated for each model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("PISAindex")

n &lt;- nrow(PISAindex) # Observations in the dataset
selected &lt;- sample(1:n, n * 0.7) # Training indexes
training &lt;- PISAindex[selected, ] # Training set
test &lt;- PISAindex[- selected, ] # Test set

bestRFEAT(training = training, 
          test = test,
          x = 6:9,
          y = 3,
          numStop = c(3, 5),
          m = c(20, 30),
          s_mtry = c("1", "BRM"))


</code></pre>

<hr>
<h2 id='CEAT_BCC_in'>Banker, Charnes and Cooper programming model with input orientation for a Convexified Efficiency Analysis Trees model</h2><span id='topic+CEAT_BCC_in'></span>

<h3>Description</h3>

<p>Banker, Charnes and Cooper programming model with input orientation for a Convexified Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEAT_BCC_in(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEAT_BCC_in_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_in_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_in_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_in_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_in_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_in_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_in_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_in_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_in_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with scores.
</p>

<hr>
<h2 id='CEAT_BCC_out'>Banker, Charnes and Cooper programming model with output orientation for a Convexified Efficiency Analysis Trees model</h2><span id='topic+CEAT_BCC_out'></span>

<h3>Description</h3>

<p>Banker, Charnes and Cooper programming model with output orientation for a Convexified Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEAT_BCC_out(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEAT_BCC_out_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_out_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_out_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_out_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_out_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_out_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_out_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_out_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="CEAT_BCC_out_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with efficiency scores.
</p>

<hr>
<h2 id='CEAT_DDF'>Directional Distance Function mathematical programming model for a Convexified Efficiency Analysis Trees model</h2><span id='topic+CEAT_DDF'></span>

<h3>Description</h3>

<p>Directional Distance Function for a Convexified Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEAT_DDF(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEAT_DDF_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="CEAT_DDF_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="CEAT_DDF_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="CEAT_DDF_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="CEAT_DDF_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="CEAT_DDF_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="CEAT_DDF_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="CEAT_DDF_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="CEAT_DDF_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with scores.
</p>

<hr>
<h2 id='CEAT_RSL_in'>Russell Model with input orientation for a Convexified Efficiency Analysis Trees model</h2><span id='topic+CEAT_RSL_in'></span>

<h3>Description</h3>

<p>Russell Model with input orientation for a Convexified Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEAT_RSL_in(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEAT_RSL_in_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_in_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_in_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_in_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_in_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_in_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_in_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_in_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_in_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with scores.
</p>

<hr>
<h2 id='CEAT_RSL_out'>Russell Model with output orientation for a Convexified Efficiency Analysis Trees model</h2><span id='topic+CEAT_RSL_out'></span>

<h3>Description</h3>

<p>Russell Model with output orientation for a Convexified Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEAT_RSL_out(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEAT_RSL_out_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_out_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_out_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_out_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_out_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_out_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_out_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_out_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="CEAT_RSL_out_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with scores.
</p>

<hr>
<h2 id='CEAT_WAM'>Weighted Additive Model for a Convexified Efficiency Analysis Trees model</h2><span id='topic+CEAT_WAM'></span>

<h3>Description</h3>

<p>Weighted Additive Model for a Convexified Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEAT_WAM(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEAT_WAM_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="CEAT_WAM_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="CEAT_WAM_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="CEAT_WAM_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="CEAT_WAM_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="CEAT_WAM_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="CEAT_WAM_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="CEAT_WAM_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="CEAT_WAM_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
<tr><td><code id="CEAT_WAM_+3A_weights">weights</code></td>
<td>
<p><code>"MIP"</code> for Measure of Inefficiency Proportion or <code>"RAM"</code> for Range Adjusted Measure of Inefficiency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with scores.
</p>

<hr>
<h2 id='checkEAT'>Check Efficiency Analysis Trees.</h2><span id='topic+checkEAT'></span>

<h3>Description</h3>

<p>This function verifies if a specific tree keeps to Pareto-dominance properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkEAT(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkEAT_+3A_tree">tree</code></td>
<td>
<p>A <code>list</code> containing the EAT nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Message indicating if the tree is acceptable or warning in case of breaking any Pareto-dominance relationship.
</p>

<hr>
<h2 id='comparePareto'>Pareto-dominance relationships</h2><span id='topic+comparePareto'></span>

<h3>Description</h3>

<p>This function denotes if a node dominates another one or if there is no Pareto-dominance relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparePareto(t1, t2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparePareto_+3A_t1">t1</code></td>
<td>
<p>A first node.</p>
</td></tr>
<tr><td><code id="comparePareto_+3A_t2">t2</code></td>
<td>
<p>A second node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-1 if t1 dominates t2, 1 if t2 dominates t1 and 0 if there are no Pareto-dominance relationships.
</p>

<hr>
<h2 id='deepEAT'>Deep Efficiency Analysis Trees</h2><span id='topic+deepEAT'></span>

<h3>Description</h3>

<p>This function creates a deep Efficiency Analysis Tree and a set of possible prunings by the weakest-link pruning procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deepEAT(data, x, y, numStop = 5, max.depth = NULL, max.leaves = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deepEAT_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="deepEAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="deepEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="deepEAT_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="deepEAT_+3A_max.depth">max.depth</code></td>
<td>
<p>Maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="deepEAT_+3A_max.leaves">max.leaves</code></td>
<td>
<p>Maximum number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing each possible pruning for the deep tree and its associated alpha value.
</p>

<hr>
<h2 id='EAT'>Efficiency Analysis Trees</h2><span id='topic+EAT'></span>

<h3>Description</h3>

<p>This function estimates a stepped production frontier through regression trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT(
  data,
  x,
  y,
  numStop = 5,
  fold = 5,
  max.depth = NULL,
  max.leaves = NULL,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="EAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="EAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="EAT_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="EAT_+3A_fold">fold</code></td>
<td>
<p>Set of number of folds in which the dataset to apply cross-validation during the pruning is divided.</p>
</td></tr>
<tr><td><code id="EAT_+3A_max.depth">max.depth</code></td>
<td>
<p>Depth of the tree.</p>
</td></tr>
<tr><td><code id="EAT_+3A_max.leaves">max.leaves</code></td>
<td>
<p>Maximum number of leaf nodes.</p>
</td></tr>
<tr><td><code id="EAT_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EAT function generates a regression tree model based on CART (Breiman et al. 1984) under a new approach that guarantees obtaining a stepped production frontier that fulfills the property of free disposability. This frontier shares the aforementioned aspects with the FDH frontier (Deprins and Simar 1984) but enhances some of its disadvantages such as the overfitting problem or the underestimation of technical inefficiency. More details in Esteve et al. (2020).
</p>


<h3>Value</h3>

<p>An <code>EAT</code> object containing:
</p>

<ul>
<li><p><code>data</code> </p>

<ul>
<li><p><code>df</code>: data frame containing the variables in the model.
</p>
</li>
<li><p><code>x</code>: input indexes in data.
</p>
</li>
<li><p><code>y</code>: output indexes in data.
</p>
</li>
<li><p><code>input_names</code>: input variable names.
</p>
</li>
<li><p><code>output_names</code>: output variable names.
</p>
</li>
<li><p><code>row_names</code>: rownames in data.</p>
</li></ul>


</li>
<li><p><code>control</code> </p>

<ul>
<li><p><code>fold</code>: fold hyperparameter value.
</p>
</li>
<li><p><code>numStop</code>: numStop hyperparameter value.
</p>
</li>
<li><p><code>max.leaves</code>: max.leaves hyperparameter value.
</p>
</li>
<li><p><code>max.depth</code>: max.depth hyperparameter value.
</p>
</li>
<li><p><code>na.rm</code>: na.rm hyperparameter value.</p>
</li></ul>


</li>
<li><p><code>tree</code>: list structure containing the EAT nodes.
</p>
</li>
<li><p><code>nodes_df</code>: data frame containing the following information for each node. </p>

<ul>
<li><p><code>id</code>: node index.  
</p>
</li>
<li><p><code>SL</code>: left child node index.
</p>
</li>
<li><p><code>N</code>: number of observations at the node. 
</p>
</li>
<li><p><code>Proportion</code>: proportion of observations at the node.
</p>
</li>
<li><p>the output predictions.
</p>
</li>
<li><p><code>R</code>: the error at the node.  
</p>
</li>
<li><p><code>index</code>: observation indexes at the node.</p>
</li></ul>

   
</li>
<li><p><code>model</code> </p>

<ul>
<li><p><code>nodes</code>: total number of nodes at the tree.  
</p>
</li>
<li><p><code>leaf_nodes</code>: number of leaf nodes at the tree.
</p>
</li>
<li><p><code>a</code>: lower bound of the nodes. 
</p>
</li>
<li><p><code>y</code>: output predictions.</p>
</li></ul>


</li></ul>



<h3>References</h3>

<p>Breiman L, Friedman J, Stone CJ, Olshen RA (1984).
<em>Classification and regression trees</em>.
CRC press. <br />
<br />
Deprins D, Simar L (1984).
&ldquo;Measuring labor efficiency in post offices, The Performance of Public Enterprises: Concepts and Measurements, M. Marchand, P. Pestieau and H. Tulkens.&rdquo; <br />
<br />
Esteve M, Aparicio J, Rabasa A, Rodriguez-Sala JJ (2020).
&ldquo;Efficiency analysis trees: A new methodology for estimating production frontiers through decision trees.&rdquo;
<em>Expert Systems with Applications</em>, <b>162</b>, 113783.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ====================== #
# Single output scenario #
# ====================== #

simulated &lt;- Y1.sim(N = 50, nX = 3)
EAT(data = simulated, x = c(1, 2, 3), y = 4, numStop = 10, fold = 5, max.leaves = 6)

# ====================== #
#  Multi output scenario #
# ====================== #

simulated &lt;- X2Y2.sim(N = 50, border = 0.1)
EAT(data = simulated, x = c(1,2), y = c(3, 4), numStop = 10, fold = 7, max.depth = 7)

</code></pre>

<hr>
<h2 id='EAT_BCC_in'>Banker, Charnes and Cooper Programming Model with Input Orientation for an Efficiency Analysis Trees model</h2><span id='topic+EAT_BCC_in'></span>

<h3>Description</h3>

<p>Banker, Charnes and Cooper programming model with input orientation for an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_BCC_in(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_BCC_in_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="EAT_BCC_in_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="EAT_BCC_in_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="EAT_BCC_in_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="EAT_BCC_in_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="EAT_BCC_in_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="EAT_BCC_in_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="EAT_BCC_in_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="EAT_BCC_in_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with efficiency scores.
</p>

<hr>
<h2 id='EAT_BCC_out'>Banker, Charnes and Cooper Programming Model with Output Orientation for an Efficiency Analysis Trees model</h2><span id='topic+EAT_BCC_out'></span>

<h3>Description</h3>

<p>Banker, Charnes and Cooper programming model with output orientation for an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_BCC_out(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_BCC_out_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="EAT_BCC_out_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="EAT_BCC_out_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="EAT_BCC_out_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="EAT_BCC_out_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="EAT_BCC_out_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="EAT_BCC_out_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="EAT_BCC_out_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="EAT_BCC_out_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with efficiency scores.
</p>

<hr>
<h2 id='EAT_DDF'>Directional Distance Function Programming Model for an Efficiency Analysis Trees model</h2><span id='topic+EAT_DDF'></span>

<h3>Description</h3>

<p>Directional Distance Function for an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_DDF(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_DDF_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="EAT_DDF_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="EAT_DDF_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="EAT_DDF_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="EAT_DDF_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="EAT_DDF_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="EAT_DDF_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="EAT_DDF_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="EAT_DDF_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with efficiency scores.
</p>

<hr>
<h2 id='EAT_frontier_levels'>Output Levels in an Efficiency Analysis Trees model</h2><span id='topic+EAT_frontier_levels'></span>

<h3>Description</h3>

<p>This function returns the frontier output levels for an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_frontier_levels(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_frontier_levels_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the frontier output levels at the leaf nodes of the Efficiency Analysis Trees model introduced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated &lt;- Y1.sim(N = 50, nX = 3)
EAT_model &lt;- EAT(data = simulated, x = c(1, 2, 3), y = 4, numStop = 10, fold = 5)
EAT_frontier_levels(EAT_model)

</code></pre>

<hr>
<h2 id='EAT_leaf_stats'>Descriptive Summary Statistics Table for the Leaf Nodes of an Efficiency Analysis Trees model</h2><span id='topic+EAT_leaf_stats'></span>

<h3>Description</h3>

<p>This function returns a descriptive summary statistics table for each output variable calculated from the leaf nodes observations of an Efficiency Analysis Trees model. Specifically, it computes the number of observations, the proportion of observations, the mean, the variance, the standard deviation, the minimum, the first quartile, the median, the third quartile, the maximum and the root mean squared error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_leaf_stats(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_leaf_stats_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> or a <code>data.frame</code> (for 1 output scenario) with the following summary statistics:
</p>

<ul>
<li><p><code>N</code>: number of observations.
</p>
</li>
<li><p><code>Proportion</code>: proportion of observations.
</p>
</li>
<li><p><code>mean</code>: mean.
</p>
</li>
<li><p><code>var</code>: variance.   
</p>
</li>
<li><p><code>sd</code>: standard deviation.
</p>
</li>
<li><p><code>min</code>: minimun.
</p>
</li>
<li><p><code>Q1</code>: first quartile.
</p>
</li>
<li><p><code>median</code>: median.
</p>
</li>
<li><p><code>Q3</code>: third quartile.
</p>
</li>
<li><p><code>max</code>: maximum.
</p>
</li>
<li><p><code>RMSE</code>: root mean squared error.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>simulated &lt;- Y1.sim(N = 50, nX = 3)
EAT_model &lt;- EAT(data = simulated, x = c(1, 2, 3), y = 4, numStop = 10, fold = 5)
EAT_leaf_stats(EAT_model)

</code></pre>

<hr>
<h2 id='EAT_object'>Create a EAT object</h2><span id='topic+EAT_object'></span>

<h3>Description</h3>

<p>This function saves information about the Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_object(
  data,
  x,
  y,
  rownames,
  numStop,
  fold,
  max.depth,
  max.leaves,
  na.rm,
  tree
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_object_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_rownames">rownames</code></td>
<td>
<p><code>string</code>. Data rownames.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_fold">fold</code></td>
<td>
<p>Set of number of folds in which the dataset to apply cross-validation during the pruning is divided.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_max.depth">max.depth</code></td>
<td>
<p>Maximum number of leaf nodes.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_max.leaves">max.leaves</code></td>
<td>
<p>Depth of the tree.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted. If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_tree">tree</code></td>
<td>
<p><code>list</code> containing the nodes of the Efficiency Analysis Trees pruned model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>EAT</code> object.
</p>

<hr>
<h2 id='EAT_RSL_in'>Russell Model with Input Orientation for an Efficiency Analysis Trees model</h2><span id='topic+EAT_RSL_in'></span>

<h3>Description</h3>

<p>Russell Model with input orientation for an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_RSL_in(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_RSL_in_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="EAT_RSL_in_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="EAT_RSL_in_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="EAT_RSL_in_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="EAT_RSL_in_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="EAT_RSL_in_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="EAT_RSL_in_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="EAT_RSL_in_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="EAT_RSL_in_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with efficiency scores.
</p>

<hr>
<h2 id='EAT_RSL_out'>Russell Model with Output Orientation for an Efficiency Analysis Trees model</h2><span id='topic+EAT_RSL_out'></span>

<h3>Description</h3>

<p>Russell Model with output orientation for an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_RSL_out(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_RSL_out_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="EAT_RSL_out_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="EAT_RSL_out_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="EAT_RSL_out_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="EAT_RSL_out_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="EAT_RSL_out_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="EAT_RSL_out_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="EAT_RSL_out_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="EAT_RSL_out_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with efficiency scores.
</p>

<hr>
<h2 id='EAT_size'>Number of Leaf Nodes in an Efficiency Analysis Trees model</h2><span id='topic+EAT_size'></span>

<h3>Description</h3>

<p>This function returns the number of leaf nodes for an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_size(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_size_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of leaf nodes of the Efficiency Analysis Trees model introduced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated &lt;- Y1.sim(N = 50, nX = 3)
EAT_model &lt;- EAT(data = simulated, x = c(1, 2, 3), y = 4, numStop = 10, fold = 5)
EAT_size(EAT_model)

</code></pre>

<hr>
<h2 id='EAT_WAM'>Weighted Additive Model for an Efficiency Analysis Trees model</h2><span id='topic+EAT_WAM'></span>

<h3>Description</h3>

<p>Weighted Additive Model for an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_WAM(j, scores, x_k, y_k, atreeTk, ytreeTk, nX, nY, N_leaves, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_WAM_+3A_j">j</code></td>
<td>
<p>Number of DMUs.</p>
</td></tr>
<tr><td><code id="EAT_WAM_+3A_scores">scores</code></td>
<td>
<p><code>matrix</code>. Empty matrix for scores.</p>
</td></tr>
<tr><td><code id="EAT_WAM_+3A_x_k">x_k</code></td>
<td>
<p><code>data.frame</code>. Set of input variables.</p>
</td></tr>
<tr><td><code id="EAT_WAM_+3A_y_k">y_k</code></td>
<td>
<p><code>data.frame</code> Set of output variables.</p>
</td></tr>
<tr><td><code id="EAT_WAM_+3A_atreetk">atreeTk</code></td>
<td>
<p><code>matrix</code> Set of &quot;a&quot; Pareto-coordinates.</p>
</td></tr>
<tr><td><code id="EAT_WAM_+3A_ytreetk">ytreeTk</code></td>
<td>
<p><code>matrix</code> Set of predictions.</p>
</td></tr>
<tr><td><code id="EAT_WAM_+3A_nx">nX</code></td>
<td>
<p>Number of inputs.</p>
</td></tr>
<tr><td><code id="EAT_WAM_+3A_ny">nY</code></td>
<td>
<p>Number of outputs.</p>
</td></tr>
<tr><td><code id="EAT_WAM_+3A_n_leaves">N_leaves</code></td>
<td>
<p>Number of leaf nodes.</p>
</td></tr>
<tr><td><code id="EAT_WAM_+3A_weights">weights</code></td>
<td>
<p>Character. <code>"MIP"</code> for Measure of Inefficiency Proportion or <code>"RAM"</code> for Range Adjusted Measure of Inefficiency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with efficiency scores.
</p>

<hr>
<h2 id='efficiencyCEAT'>Efficiency Scores computed through a Convexified Efficiency Analysis Trees model.</h2><span id='topic+efficiencyCEAT'></span>

<h3>Description</h3>

<p>This function computes the efficiency scores for each DMU through a Convexified Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiencyCEAT(
  data,
  x,
  y,
  object,
  scores_model,
  digits = 3,
  DEA = TRUE,
  print.table = FALSE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiencyCEAT_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="efficiencyCEAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="efficiencyCEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="efficiencyCEAT_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
<tr><td><code id="efficiencyCEAT_+3A_scores_model">scores_model</code></td>
<td>
<p>Mathematical programming model to calculate scores. 
</p>

<ul>
<li><p><code>BCC.OUT</code> BCC model. Output-oriented. Efficiency level at 1.
</p>
</li>
<li><p><code>BCC.INP</code>  BCC model. Input-oriented. Efficiency level at 1.
</p>
</li>
<li><p><code>DDF</code>     Directional Distance Function. Efficiency level at 0.
</p>
</li>
<li><p><code>RSL.OUT</code> Russell model. Output-oriented. Efficiency level at 1.
</p>
</li>
<li><p><code>RSL.INP</code>  Russell model. Input-oriented. Efficiency level at 1.
</p>
</li>
<li><p><code>WAM.MIP</code> Weighted Additive Model. Measure of Inefficiency Proportions. Efficiency level at 0.
</p>
</li>
<li><p><code>WAM.RAM</code> Weighted Additive Model. Range Adjusted Measure of Inefficiency. Efficiency level at 0.
</p>
</li></ul>
</td></tr>
<tr><td><code id="efficiencyCEAT_+3A_digits">digits</code></td>
<td>
<p>Decimal units for scores.</p>
</td></tr>
<tr><td><code id="efficiencyCEAT_+3A_dea">DEA</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the DEA scores are also calculated with the programming model selected in <code>scores_model</code>.</p>
</td></tr>
<tr><td><code id="efficiencyCEAT_+3A_print.table">print.table</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, a summary descriptive table of the efficiency scores is displayed.</p>
</td></tr>
<tr><td><code id="efficiencyCEAT_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the efficiency scores computed through a Convexified Efficiency Analysis Trees model. Optionally, a summary descriptive table of the efficiency scores can be displayed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

simulated &lt;- X2Y2.sim(N = 50, border = 0.2)
EAT_model &lt;- EAT(data = simulated, x = c(1,2), y = c(3, 4))

efficiencyCEAT(data = simulated, x = c(1, 2), y = c(3, 4), object = EAT_model, 
              scores_model = "BCC.OUT", digits = 2, DEA = TRUE, print.table = TRUE,
              na.rm = TRUE)


</code></pre>

<hr>
<h2 id='efficiencyDensity'>Efficiency Scores Density Plot</h2><span id='topic+efficiencyDensity'></span>

<h3>Description</h3>

<p>Density plot for efficiency scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiencyDensity(df_scores, model = c("EAT", "FDH"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiencyDensity_+3A_df_scores">df_scores</code></td>
<td>
<p><code>data.frame</code> with efficiency scores.</p>
</td></tr>
<tr><td><code id="efficiencyDensity_+3A_model">model</code></td>
<td>
<p><code>chraracter</code> vector. Scoring models in the order of <code>df_scores</code> by columns. The available models are: <code>"EAT"</code>, <code>"FDH"</code>, <code>"CEAT"</code>, <code>"DEA"</code> and <code>"RFEAT"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Density plot for efficiency scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- X2Y2.sim(N = 50, border = 0.2)

EAT_model &lt;- EAT(data = simulated, x = c(1,2), y = c(3, 4))

scores &lt;- efficiencyEAT(data = simulated, x = c(1, 2), y = c(3, 4), object = EAT_model, 
                        scores_model = "BCC.OUT", digits = 2, FDH = TRUE, na.rm = TRUE)
                        
efficiencyDensity(df_scores = scores,
                  model = c("EAT", "FDH"))
 

</code></pre>

<hr>
<h2 id='efficiencyEAT'>Efficiency Scores computed through an Efficiency Analysis Trees model.</h2><span id='topic+efficiencyEAT'></span>

<h3>Description</h3>

<p>This function computes the efficiency scores for each DMU through an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiencyEAT(
  data,
  x,
  y,
  object,
  scores_model,
  digits = 3,
  FDH = TRUE,
  print.table = FALSE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiencyEAT_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="efficiencyEAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="efficiencyEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="efficiencyEAT_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
<tr><td><code id="efficiencyEAT_+3A_scores_model">scores_model</code></td>
<td>
<p>Mathematical programming model to calculate scores. 
</p>

<ul>
<li><p><code>BCC.OUT</code> BCC model. Output-oriented. Efficiency level at 1.
</p>
</li>
<li><p><code>BCC.INP</code>  BCC model. Input-oriented. Efficiency level at 1.
</p>
</li>
<li><p><code>DDF</code>     Directional Distance Function. Efficiency level at 0.
</p>
</li>
<li><p><code>RSL.OUT</code> Russell model. Output-oriented. Efficiency level at 1.
</p>
</li>
<li><p><code>RSL.INP</code>  Russell model. Input-oriented. Efficiency level at 1.
</p>
</li>
<li><p><code>WAM.MIP</code> Weighted Additive Model. Measure of Inefficiency Proportions. Efficiency level at 0.
</p>
</li>
<li><p><code>WAM.RAM</code> Weighted Additive Model. Range Adjusted Measure of Inefficiency. Efficiency level at 0.
</p>
</li></ul>
</td></tr>
<tr><td><code id="efficiencyEAT_+3A_digits">digits</code></td>
<td>
<p>Decimal units for scores.</p>
</td></tr>
<tr><td><code id="efficiencyEAT_+3A_fdh">FDH</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, FDH scores are also computed with the programming model selected in <code>scores_model</code>.</p>
</td></tr>
<tr><td><code id="efficiencyEAT_+3A_print.table">print.table</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, a summary descriptive table of the efficiency scores is displayed.</p>
</td></tr>
<tr><td><code id="efficiencyEAT_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the efficiency scores computed through an Efficiency Analysis Trees model. Optionally, a summary descriptive table of the efficiency scores can be displayed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

simulated &lt;- X2Y2.sim(N = 50, border = 0.2)
EAT_model &lt;- EAT(data = simulated, x = c(1,2), y = c(3, 4))

efficiencyEAT(data = simulated, x = c(1, 2), y = c(3, 4), object = EAT_model, 
              scores_model = "BCC.OUT", digits = 2, FDH = TRUE, print.table = TRUE,
              na.rm = TRUE)


</code></pre>

<hr>
<h2 id='efficiencyJitter'>Efficiency Scores Jitter Plot</h2><span id='topic+efficiencyJitter'></span>

<h3>Description</h3>

<p>This function returns a jitter plot from <code>ggplot2</code>. This graphic shows how DMUs are grouped into leaf nodes in a model built using the <code>EAT</code> function. Each leaf node groups DMUs with the same level of resources. The dot and the black line represent, respectively, the mean value and the standard deviation of the scores of its node. Additionally, efficient DMU labels always are displayed based on the model entered in the <code>scores_model</code> argument. Finally, the user can specify an upper bound <code>upn</code> and a lower bound <code>lwb</code> in order to show, in addition, the labels whose efficiency score lies between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiencyJitter(object, df_scores, scores_model, upb = NULL, lwb = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiencyJitter_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
<tr><td><code id="efficiencyJitter_+3A_df_scores">df_scores</code></td>
<td>
<p><code>data.frame</code> with efficiency scores (from <code>efficiencyEAT</code> or <code>efficiencyCEAT</code>).</p>
</td></tr>
<tr><td><code id="efficiencyJitter_+3A_scores_model">scores_model</code></td>
<td>
<p>Mathematical programming model to calculate scores. 
</p>

<ul>
<li><p><code>BCC.OUT</code> BCC model. Output-oriented.
</p>
</li>
<li><p><code>BCC.INP</code>  BCC model. Input-oriented.
</p>
</li>
<li><p><code>DDF</code>     Directional Distance Function.
</p>
</li>
<li><p><code>RSL.OUT</code> Russell model. Output-oriented.
</p>
</li>
<li><p><code>RSL.INP</code>  Russell model. Input-oriented.
</p>
</li>
<li><p><code>WAM.MIP</code> Weighted Additive Model. Measure of Inefficiency Proportions.
</p>
</li>
<li><p><code>WAM.RAM</code> Weighted Additive Model. Range Adjusted Measure of Inefficiency.
</p>
</li></ul>
</td></tr>
<tr><td><code id="efficiencyJitter_+3A_upb">upb</code></td>
<td>
<p>Numeric. Upper bound for labeling.</p>
</td></tr>
<tr><td><code id="efficiencyJitter_+3A_lwb">lwb</code></td>
<td>
<p>Numeric. Lower bound for labeling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Jitter plot with DMUs and scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- X2Y2.sim(N = 50, border = 0.2)
EAT_model &lt;- EAT(data = simulated, x = c(1,2), y = c(3, 4))

EAT_scores &lt;- efficiencyEAT(data = simulated, x = c(1, 2), y = c(3, 4), object = EAT_model,
                            scores_model = "BCC.OUT", digits = 2, na.rm = TRUE)

efficiencyJitter(object = EAT_model, df_scores = EAT_scores, scores_model = "BCC.OUT")


</code></pre>

<hr>
<h2 id='efficiencyRFEAT'>Efficiency Scores computed through a Random Forest + Efficiency Analysis Trees model.</h2><span id='topic+efficiencyRFEAT'></span>

<h3>Description</h3>

<p>This function computes the efficiency scores for each DMU through a Random Forest + Efficiency Analysis Trees model and the Banker Charnes and Cooper mathematical programming model with output orientation. Efficiency level at 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiencyRFEAT(
  data,
  x,
  y,
  object,
  digits = 3,
  FDH = TRUE,
  print.table = FALSE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiencyRFEAT_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="efficiencyRFEAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="efficiencyRFEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="efficiencyRFEAT_+3A_object">object</code></td>
<td>
<p>A <code>RFEAT</code> object.</p>
</td></tr>
<tr><td><code id="efficiencyRFEAT_+3A_digits">digits</code></td>
<td>
<p>Decimal units for scores.</p>
</td></tr>
<tr><td><code id="efficiencyRFEAT_+3A_fdh">FDH</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, FDH scores are computed.</p>
</td></tr>
<tr><td><code id="efficiencyRFEAT_+3A_print.table">print.table</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, a summary descriptive table of the efficiency scores is displayed.</p>
</td></tr>
<tr><td><code id="efficiencyRFEAT_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the efficiency scores computed through a Random Forest + Efficiency Analysis Trees model. Optionally, a summary descriptive table of the efficiency scores can be displayed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- X2Y2.sim(N = 50, border = 0.2)
RFEAT_model &lt;- RFEAT(data = simulated, x = c(1,2), y = c(3, 4))

efficiencyRFEAT(data = simulated, x = c(1, 2), y = c(3, 4), object = RFEAT_model, 
                digits = 2, FDH = TRUE, na.rm = TRUE)


</code></pre>

<hr>
<h2 id='estimEAT'>Estimation of child nodes</h2><span id='topic+estimEAT'></span>

<h3>Description</h3>

<p>This function gets the estimation of the response variable and updates Pareto-coordinates and the observation index for both new nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimEAT(data, leaves, t, xi, s, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimEAT_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_leaves">leaves</code></td>
<td>
<p>List structure with leaf nodes or pending expansion nodes.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_t">t</code></td>
<td>
<p>Node which is being split.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_xi">xi</code></td>
<td>
<p>Variable index that produces the split.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_s">s</code></td>
<td>
<p>Value of xi variable that produces the split.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Left and right children nodes.
</p>

<hr>
<h2 id='frontier'>Efficiency Analysis Trees Frontier Graph</h2><span id='topic+frontier'></span>

<h3>Description</h3>

<p>This function displays a plot with the frontier estimated by Efficiency Analysis Trees in a scenario of one input and one output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frontier(
  object,
  FDH = FALSE,
  observed.data = FALSE,
  observed.color = "black",
  pch = 19,
  size = 1,
  rwn = FALSE,
  max.overlaps = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frontier_+3A_object">object</code></td>
<td>
<p>An EAT object.</p>
</td></tr>
<tr><td><code id="frontier_+3A_fdh">FDH</code></td>
<td>
<p>Logical. If <code>TRUE</code>, FDH frontier is displayed.</p>
</td></tr>
<tr><td><code id="frontier_+3A_observed.data">observed.data</code></td>
<td>
<p>Logical. If <code>TRUE</code>, observed DMUs are displayed.</p>
</td></tr>
<tr><td><code id="frontier_+3A_observed.color">observed.color</code></td>
<td>
<p>String. Color for observed DMUs.</p>
</td></tr>
<tr><td><code id="frontier_+3A_pch">pch</code></td>
<td>
<p>Integer. Point shape.</p>
</td></tr>
<tr><td><code id="frontier_+3A_size">size</code></td>
<td>
<p>Integer. Point size.</p>
</td></tr>
<tr><td><code id="frontier_+3A_rwn">rwn</code></td>
<td>
<p>Logical. If <code>TRUE</code>, rownames are displayed.</p>
</td></tr>
<tr><td><code id="frontier_+3A_max.overlaps">max.overlaps</code></td>
<td>
<p>Exclude text labels that overlap too many things.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot with estimated production frontier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- Y1.sim(N = 50, nX = 1)

model &lt;- EAT(data = simulated,
             x = 1,
             y = 2)

frontier &lt;- frontier(object = model,
                     FDH = TRUE, 
                     observed.data = TRUE,
                     rwn = TRUE)
plot(frontier)

</code></pre>

<hr>
<h2 id='generateLv'>Train and Test Sets Generation</h2><span id='topic+generateLv'></span>

<h3>Description</h3>

<p>This function splits the original data in two new data sets: a train set and a test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateLv(data, fold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateLv_+3A_data">data</code></td>
<td>
<p>Data to be split into train and test subsets.</p>
</td></tr>
<tr><td><code id="generateLv_+3A_fold">fold</code></td>
<td>
<p>Parts in which the original set is divided, to perform Cross-Validation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> structure with the train and the test set.
</p>

<hr>
<h2 id='imp_var_EAT'>Breiman's Variable Importance</h2><span id='topic+imp_var_EAT'></span>

<h3>Description</h3>

<p>This function recalculates all the possible splits, with the exception of the one being used, and for each node and variable gets the best split based on their degree of importance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imp_var_EAT(data, tree, x, y, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imp_var_EAT_+3A_data">data</code></td>
<td>
<p>Data from EAT object.</p>
</td></tr>
<tr><td><code id="imp_var_EAT_+3A_tree">tree</code></td>
<td>
<p>Tree from EAT object.</p>
</td></tr>
<tr><td><code id="imp_var_EAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="imp_var_EAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="imp_var_EAT_+3A_digits">digits</code></td>
<td>
<p>Decimal units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the best split for each node and its variable importance.
</p>

<hr>
<h2 id='imp_var_RFEAT'>Variable Importance through Random Forest + Efficiency Analysis Trees</h2><span id='topic+imp_var_RFEAT'></span>

<h3>Description</h3>

<p>Variable Importance through Random Forest + Efficiency Analysis Trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imp_var_RFEAT(object, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imp_var_RFEAT_+3A_object">object</code></td>
<td>
<p>A <code>RFEAT</code> object</p>
</td></tr>
<tr><td><code id="imp_var_RFEAT_+3A_digits">digits</code></td>
<td>
<p>Decimal units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of input importance scores
</p>

<hr>
<h2 id='isFinalNode'>Is Final Node</h2><span id='topic+isFinalNode'></span>

<h3>Description</h3>

<p>This function evaluates a node and checks if it fulfills the conditions to be a final node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFinalNode(obs, data, numStop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isFinalNode_+3A_obs">obs</code></td>
<td>
<p>Observation in the evaluated node.</p>
</td></tr>
<tr><td><code id="isFinalNode_+3A_data">data</code></td>
<td>
<p>Data with predictive variable.</p>
</td></tr>
<tr><td><code id="isFinalNode_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node to be split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True if the node is a final node and false in any other case.
</p>

<hr>
<h2 id='layout'>Layout for nodes in plotEAT</h2><span id='topic+layout'></span>

<h3>Description</h3>

<p>This function modifies the coordinates of the nodes in the plotEAT function to overcome overlapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout(py)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_+3A_py">py</code></td>
<td>
<p>A party object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with suitable modifications of the node layout.
</p>

<hr>
<h2 id='M_Breiman'>Breiman Importance</h2><span id='topic+M_Breiman'></span>

<h3>Description</h3>

<p>This function evaluates the importance of each predictor by the notion of surrogate splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M_Breiman(object, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M_Breiman_+3A_object">object</code></td>
<td>
<p>An EAT object.</p>
</td></tr>
<tr><td><code id="M_Breiman_+3A_digits">digits</code></td>
<td>
<p>Decimal units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with one column and the importance of each variable in rows.
</p>

<hr>
<h2 id='mse'>Mean Squared Error</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p>This function calculates the Mean Square Error between the predicted value and the observations in a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(data, t, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="mse_+3A_t">t</code></td>
<td>
<p>A given node.</p>
</td></tr>
<tr><td><code id="mse_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean Square Error at a node.
</p>

<hr>
<h2 id='mtry_inputSelection'>Random Selection of Variables</h2><span id='topic+mtry_inputSelection'></span>

<h3>Description</h3>

<p>This function randomly selects the variables that are evaluated to divide a node and removes those that do not present variability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtry_inputSelection(data, x, t, mtry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtry_inputSelection_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing the training set.</p>
</td></tr>
<tr><td><code id="mtry_inputSelection_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="mtry_inputSelection_+3A_t">t</code></td>
<td>
<p>Node which is being split.</p>
</td></tr>
<tr><td><code id="mtry_inputSelection_+3A_mtry">mtry</code></td>
<td>
<p>Number of inputs selected for a node to be split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Index of the variables by which the node is divided.
</p>

<hr>
<h2 id='PISAindex'>PISA score and social index by country</h2><span id='topic+PISAindex'></span>

<h3>Description</h3>

<p>A dataset containing the PISA score in mathematics, reading and science and 13 variables related to the social index by country for 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PISAindex
</code></pre>


<h3>Format</h3>

<p>A data frame with 72 rows and 18 variables:
</p>

<dl>
<dt>Country</dt><dd><p>Country name</p>
</dd>
<dt>Continent</dt><dd><p>Country continent</p>
</dd>
<dt>S_PISA</dt><dd><p>PISA score in Science</p>
</dd>
<dt>R_PISA</dt><dd><p>PISA score in Reading</p>
</dd>
<dt>M_PISA</dt><dd><p>PISA score in Mathematics</p>
</dd>
<dt>NBMC</dt><dd><p>Nutritional and Basic Medical Care</p>
</dd>
<dt>WS</dt><dd><p>Water and Sanitation</p>
</dd>
<dt>S</dt><dd><p>Shelter</p>
</dd>
<dt>PS</dt><dd><p>Personal Safety</p>
</dd>
<dt>ABK</dt><dd><p>Access to Basic Knowledge</p>
</dd>
<dt>AIC</dt><dd><p>Access to Information and Communication</p>
</dd>
<dt>HW</dt><dd><p>Health and Wellness</p>
</dd>
<dt>EQ</dt><dd><p>Environmental Quality</p>
</dd>
<dt>PR</dt><dd><p>Personal Rights</p>
</dd>
<dt>PFC</dt><dd><p>Personal Freedom and Choice</p>
</dd>
<dt>I</dt><dd><p>Inclusiveness</p>
</dd>
<dt>AAE</dt><dd><p>Access to Advanced Education</p>
</dd>
<dt>GDP_PPP</dt><dd><p>Gross Domestic Product per capita adjusted by purchasing power parity</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.socialprogress.org/">https://www.socialprogress.org/</a>
</p>
<p><a href="https://www.oecd.org/pisa/Combined_Executive_Summaries_PISA_2018.pdf">https://www.oecd.org/pisa/Combined_Executive_Summaries_PISA_2018.pdf</a>
</p>

<hr>
<h2 id='plotEAT'>Efficiency Analysis Trees Plot</h2><span id='topic+plotEAT'></span>

<h3>Description</h3>

<p>Plot a tree-structure for an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEAT(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEAT_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot object with the following elements for each node:
</p>

<ul>
<li><p>id: node index.
</p>
</li>
<li><p>R: error at the node.
</p>
</li>
<li><p>n(t): number of observations at the node.
</p>
</li>
<li><p>an input name: splitting variable.
</p>
</li>
<li><p>y: output prediction.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- X2Y2.sim(N = 50, border = 0.2)
EAT_model &lt;- EAT(data = simulated, x = c(1,2), y = c(3, 4))

plotEAT(EAT_model)


</code></pre>

<hr>
<h2 id='plotRFEAT'>Random Forest + Efficiency Analysis Trees Plot</h2><span id='topic+plotRFEAT'></span>

<h3>Description</h3>

<p>Plot a graph with the Out-of-Bag error for a forest consisting of m trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRFEAT(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRFEAT_+3A_object">object</code></td>
<td>
<p>A <code>RFEAT</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Line plot with the OOB error and the number of trees in the forest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- Y1.sim(N = 150, nX = 6)
RFmodel &lt;- RFEAT(data = simulated, x = 1:6, y = 7, numStop = 10,
                  m = 50, s_mtry = "BRM", na.rm = TRUE)
plotRFEAT(RFmodel)


</code></pre>

<hr>
<h2 id='posIdNode'>Position of the node</h2><span id='topic+posIdNode'></span>

<h3>Description</h3>

<p>This function finds the node where a register is located.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posIdNode(tree, idNode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posIdNode_+3A_tree">tree</code></td>
<td>
<p>A list containing EAT nodes.</p>
</td></tr>
<tr><td><code id="posIdNode_+3A_idnode">idNode</code></td>
<td>
<p>Id of a specific node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Position of the node or -1 if it is not found.
</p>

<hr>
<h2 id='predict.EAT'>Model Prediction for Efficiency Analysis Trees.</h2><span id='topic+predict.EAT'></span>

<h3>Description</h3>

<p>This function predicts the expected output by an <code>EAT</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EAT'
predict(object, newdata, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.EAT_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
<tr><td><code id="predict.EAT_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code>. Set of input variables to predict on.</p>
</td></tr>
<tr><td><code id="predict.EAT_+3A_x">x</code></td>
<td>
<p>Inputs index.</p>
</td></tr>
<tr><td><code id="predict.EAT_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the original data and the predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- X2Y2.sim(N = 50, border = 0.2)
EAT_model &lt;- EAT(data = simulated, x = c(1,2), y = c(3, 4))

predict(object = EAT_model, newdata = simulated, x = c(1, 2))


</code></pre>

<hr>
<h2 id='predict.RFEAT'>Model prediction for Random Forest + Efficiency Analysis Trees model.</h2><span id='topic+predict.RFEAT'></span>

<h3>Description</h3>

<p>This function predicts the expected output by a <code>RFEAT</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RFEAT'
predict(object, newdata, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.RFEAT_+3A_object">object</code></td>
<td>
<p>A <code>RFEAT</code> object.</p>
</td></tr>
<tr><td><code id="predict.RFEAT_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code>. Set of input variables to predict on.</p>
</td></tr>
<tr><td><code id="predict.RFEAT_+3A_x">x</code></td>
<td>
<p>Inputs index.</p>
</td></tr>
<tr><td><code id="predict.RFEAT_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the original data and the predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- X2Y2.sim(N = 50, border = 0.2)
RFEAT_model &lt;- RFEAT(data = simulated, x = c(1, 2), y = c(3, 4))

predict(object = RFEAT_model, newdata = simulated, x = c(1, 2))

</code></pre>

<hr>
<h2 id='predictFDH'>Model prediction for Free Disposal Hull</h2><span id='topic+predictFDH'></span>

<h3>Description</h3>

<p>This function predicts the expected output by a Free Disposal Hull model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictFDH(data, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictFDH_+3A_data">data</code></td>
<td>
<p>Dataframe or matrix containing the variables in the model.</p>
</td></tr>
<tr><td><code id="predictFDH_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="predictFDH_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the original data and the predicted values through a Free Disposal Hull model.
</p>

<hr>
<h2 id='predictor'>Efficiency Analysis Trees Predictor</h2><span id='topic+predictor'></span>

<h3>Description</h3>

<p>This function predicts the expected value based on a set of inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictor(tree, register)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictor_+3A_tree">tree</code></td>
<td>
<p><code>list</code> with the tree nodes.</p>
</td></tr>
<tr><td><code id="predictor_+3A_register">register</code></td>
<td>
<p>Set of independent values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected value of the dependent variable based on the given register.
</p>

<hr>
<h2 id='preProcess'>Data Preprocessing for Efficiency Analysis Trees</h2><span id='topic+preProcess'></span>

<h3>Description</h3>

<p>This function arranges the data in the required format and displays error messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess(
  data,
  x,
  y,
  numStop = 5,
  fold = 5,
  max.depth = NULL,
  max.leaves = NULL,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcess_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_fold">fold</code></td>
<td>
<p>Set of number of folds in which the dataset to apply cross-validation during the pruning is divided.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_max.depth">max.depth</code></td>
<td>
<p>Depth of the tree.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_max.leaves">max.leaves</code></td>
<td>
<p>Maximum number of leaf nodes.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code>data.frame</code> in the required format.
</p>

<hr>
<h2 id='RandomEAT'>Individual EAT for Random Forest</h2><span id='topic+RandomEAT'></span>

<h3>Description</h3>

<p>This function builds an individual tree for Random Forest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomEAT(data, x, y, numStop, s_mtry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RandomEAT_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing the training set.</p>
</td></tr>
<tr><td><code id="RandomEAT_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="RandomEAT_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
<tr><td><code id="RandomEAT_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="RandomEAT_+3A_s_mtry">s_mtry</code></td>
<td>
<p>Number of variables randomly sampled as candidates at each split. The available options are: <code>"BRM"</code>, <code>"DEA1"</code>, <code>"DEA2"</code>, <code>"DEA3"</code>, <code>"DEA4"</code> or any integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of m trees in forest and the error that will be used in the ranking of the importance of the variables.
</p>

<hr>
<h2 id='rankingEAT'>Ranking of Variables by Efficiency Analysis Trees model.</h2><span id='topic+rankingEAT'></span>

<h3>Description</h3>

<p>This function computes the variable importance through an Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankingEAT(object, barplot = TRUE, threshold = 70, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankingEAT_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
<tr><td><code id="rankingEAT_+3A_barplot">barplot</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, a barplot with the importance scores is displayed.</p>
</td></tr>
<tr><td><code id="rankingEAT_+3A_threshold">threshold</code></td>
<td>
<p>Importance score value in which a line is graphed.</p>
</td></tr>
<tr><td><code id="rankingEAT_+3A_digits">digits</code></td>
<td>
<p>Decimal units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the importance scores and a barplot representing the the variable importance if <code>barplot = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- X2Y2.sim(N = 50, border = 0.2)
EAT_model &lt;- EAT(data = simulated, x = c(1,2), y = c(3, 4))

rankingEAT(object = EAT_model,
           barplot = TRUE,
           threshold = 70,
           digits = 2)


</code></pre>

<hr>
<h2 id='rankingRFEAT'>Ranking of variables by Random Forest + Efficiency Analysis Trees model.</h2><span id='topic+rankingRFEAT'></span>

<h3>Description</h3>

<p>This function calculates variable importance through a Random Forest + Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankingRFEAT(object, barplot = TRUE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankingRFEAT_+3A_object">object</code></td>
<td>
<p>A <code>RFEAT</code> object.</p>
</td></tr>
<tr><td><code id="rankingRFEAT_+3A_barplot">barplot</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, a barplot with importance scores is displayed.</p>
</td></tr>
<tr><td><code id="rankingRFEAT_+3A_digits">digits</code></td>
<td>
<p>Decimal units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the importance scores and a barplot representing the variable importance if <code>barplot = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- X2Y2.sim(N = 50, border = 0.2)
RFEAT_model &lt;- RFEAT(data = simulated, x = c(1,2), y = c(3, 4))

rankingRFEAT(object = RFEAT_model,
             barplot = TRUE,
             digits = 2)


</code></pre>

<hr>
<h2 id='RBranch'>Branch Pruning</h2><span id='topic+RBranch'></span>

<h3>Description</h3>

<p>This function computes the error of a branch as the sum of the errors of its child nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RBranch(t, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RBranch_+3A_t">t</code></td>
<td>
<p><code>list</code>. A given EAT node.</p>
</td></tr>
<tr><td><code id="RBranch_+3A_tree">tree</code></td>
<td>
<p>A <code>list</code> containing the EAT nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing (1) the sum of the errors of the child nodes of the pruned node and (2) the total number of leaf nodes that come from it.
</p>

<hr>
<h2 id='RCV'>RCV</h2><span id='topic+RCV'></span>

<h3>Description</h3>

<p>RCV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCV(N, Lv, y, alphaIprim, fold, TAiv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RCV_+3A_n">N</code></td>
<td>
<p>Number of rows in data.</p>
</td></tr>
<tr><td><code id="RCV_+3A_lv">Lv</code></td>
<td>
<p>Test set.</p>
</td></tr>
<tr><td><code id="RCV_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="RCV_+3A_alphaiprim">alphaIprim</code></td>
<td>
<p>Alpha obtained as the square root of the product of two consecutive alpha values in tree_alpha list. It is used to find the best pruning tree.</p>
</td></tr>
<tr><td><code id="RCV_+3A_fold">fold</code></td>
<td>
<p>Parts in which the original data is divided into to perform Cross-Validation.</p>
</td></tr>
<tr><td><code id="RCV_+3A_taiv">TAiv</code></td>
<td>
<p>List with each possible pruning for the deep tree generated with the train set and its associated alpha values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Set of best pruning and the associated error calculated with test sets.
</p>

<hr>
<h2 id='RF_predictor'>Random Forest + Efficiency Analysis Trees Predictor</h2><span id='topic+RF_predictor'></span>

<h3>Description</h3>

<p>This function predicts the expected value based on a set of inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RF_predictor(forest, xn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RF_predictor_+3A_forest">forest</code></td>
<td>
<p><code>list</code> containing the individual Efficiency Analysis Trees.</p>
</td></tr>
<tr><td><code id="RF_predictor_+3A_xn">xn</code></td>
<td>
<p>Row indexes in data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of predictions.
</p>

<hr>
<h2 id='RFEAT'>Random Forest + Efficiency Analysis Trees</h2><span id='topic+RFEAT'></span>

<h3>Description</h3>

<p>This function builds <code>m</code> individual Efficiency Analysis Trees in a forest structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RFEAT(data, x, y, numStop = 5, m = 50, s_mtry = "BRM", na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RFEAT_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="RFEAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="RFEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="RFEAT_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="RFEAT_+3A_m">m</code></td>
<td>
<p>Number of trees to be built.</p>
</td></tr>
<tr><td><code id="RFEAT_+3A_s_mtry">s_mtry</code></td>
<td>
<p>Number of variables randomly sampled as candidates at each split. The available options are:
</p>

<ul>
<li><p><code>"BRM"</code>: <code>in / 3</code>
</p>
</li>
<li><p><code>"DEA1"</code>: <code>(t.obs / 2) - out</code>  
</p>
</li>
<li><p><code>"DEA2"</code>: <code>(t.obs / 3) - out</code>
</p>
</li>
<li><p><code>"DEA3"</code>: <code>t.obs - 2 * out</code>
</p>
</li>
<li><p><code>"DEA4"</code>: <code>min(t.obs / out, (t.obs / 3) - out)</code>
</p>
</li>
<li><p>Any integer
</p>
</li></ul>
</td></tr>
<tr><td><code id="RFEAT_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RFEAT</code> object containing:
</p>

<ul>
<li><p><code>data</code> </p>

<ul>
<li><p><code>df</code>: data frame containing the variables in the model.
</p>
</li>
<li><p><code>x</code>: input indexes in data.
</p>
</li>
<li><p><code>y</code>: output indexes in data.
</p>
</li>
<li><p><code>input_names</code>: input variable names.
</p>
</li>
<li><p><code>output_names</code>: output variable names.
</p>
</li>
<li><p><code>row_names</code>: rownames in data.</p>
</li></ul>


</li>
<li><p><code>control</code> </p>

<ul>
<li><p><code>numStop</code>: numStop hyperparameter value.
</p>
</li>
<li><p><code>m</code>: m hyperparameter value.
</p>
</li>
<li><p><code>s_mtry</code>: s_mtry hyperparameter value.
</p>
</li>
<li><p><code>na.rm</code>: na.rm hyperparameter value.</p>
</li></ul>


</li>
<li><p><code>forest</code>: <code>list</code> containing the individual EAT models.
</p>
</li>
<li><p><code>error</code>: Out-of-Bag error at the forest.   
</p>
</li>
<li><p><code>OOB</code>: <code>list</code> containing Out-of-Bag set for each tree.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
simulated &lt;- X2Y2.sim(N = 50, border = 0.1)

RFmodel &lt;- RFEAT(data = simulated, x = c(1,2), y = c(3, 4), numStop = 5,
                  m = 50, s_mtry = "BRM", na.rm = TRUE)


</code></pre>

<hr>
<h2 id='RFEAT_object'>Create a RFEAT object</h2><span id='topic+RFEAT_object'></span>

<h3>Description</h3>

<p>This function saves information about the Random Forest for Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RFEAT_object(
  data,
  x,
  y,
  rownames,
  numStop,
  m,
  s_mtry,
  na.rm,
  forest,
  error,
  OOB
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RFEAT_object_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_rownames">rownames</code></td>
<td>
<p><code>string</code>. Data rownames.</p>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_numstop">numStop</code></td>
<td>
<p>Minimun number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_m">m</code></td>
<td>
<p>Number of trees to be built.</p>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_s_mtry">s_mtry</code></td>
<td>
<p>Select number of inputs in each split.
</p>

<ul>
<li><p><code>"Breiman"</code>: <code>in / 3</code>
</p>
</li>
<li><p><code>"DEA1"</code>: <code>(t.obs / 2) - out</code>  
</p>
</li>
<li><p><code>"DEA2"</code>: <code>(t.obs / 3) - out</code>
</p>
</li>
<li><p><code>"DEA3"</code>: <code>t.obs - 2 * out</code>
</p>
</li>
<li><p><code>"DEA4"</code>: <code>min(t.obs / out, (t.obs / 3) - out)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_forest">forest</code></td>
<td>
<p><code>list</code> containing the individual Efficiency Analysis Trees.</p>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_error">error</code></td>
<td>
<p>Error in Random Forest for Efficiency Analysis Trees.</p>
</td></tr>
<tr><td><code id="RFEAT_object_+3A_oob">OOB</code></td>
<td>
<p><code>list</code> containing the observations with which each tree has been trained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RFEAT</code> object.
</p>

<hr>
<h2 id='scores'>Pruning Scores</h2><span id='topic+scores'></span>

<h3>Description</h3>

<p>This function calculates the score for each pruning of tree_alpha_list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores(N, Lv_notLv, x, y, fold, numStop, Tk, tree_alpha_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores_+3A_n">N</code></td>
<td>
<p>Number of rows in data.</p>
</td></tr>
<tr><td><code id="scores_+3A_lv_notlv">Lv_notLv</code></td>
<td>
<p>List with train and test sets.</p>
</td></tr>
<tr><td><code id="scores_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="scores_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="scores_+3A_fold">fold</code></td>
<td>
<p>Parts in which the original data set is divided to perform Cross-Validation.</p>
</td></tr>
<tr><td><code id="scores_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations on a node to be split.</p>
</td></tr>
<tr><td><code id="scores_+3A_tk">Tk</code></td>
<td>
<p>Best pruned tree.</p>
</td></tr>
<tr><td><code id="scores_+3A_tree_alpha_list">tree_alpha_list</code></td>
<td>
<p>List with all the possible pruning and its associated alpha.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the best pruning for each fold, the pruning with a lower score and tree_alpha_list with scores updated.
</p>

<hr>
<h2 id='select_mtry'>Select Possible Inputs in Split.</h2><span id='topic+select_mtry'></span>

<h3>Description</h3>

<p>This function selects the number of inputs for a split in Random Forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_mtry(s_mtry, t, nX, nY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_mtry_+3A_s_mtry">s_mtry</code></td>
<td>
<p>Select number of inputs. It could be: <code>"BRM"</code>, <code>"DEA1"</code>, <code>"DEA2"</code>, <code>"DEA3"</code> or <code>"DEA4"</code> or any integer.</p>
</td></tr>
<tr><td><code id="select_mtry_+3A_t">t</code></td>
<td>
<p>Node which is being split.</p>
</td></tr>
<tr><td><code id="select_mtry_+3A_nx">nX</code></td>
<td>
<p>Number of inputs in data.</p>
</td></tr>
<tr><td><code id="select_mtry_+3A_ny">nY</code></td>
<td>
<p>Number of outputs in data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of inputs selected according to the specified rule.
</p>

<hr>
<h2 id='selectTk'>Select Tk</h2><span id='topic+selectTk'></span>

<h3>Description</h3>

<p>This function tries to find a new pruned tree with a shorter length and a score in the range generated for SE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectTk(Tk, tree_alpha_list, SE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectTk_+3A_tk">Tk</code></td>
<td>
<p>Best pruned tree score.</p>
</td></tr>
<tr><td><code id="selectTk_+3A_tree_alpha_list">tree_alpha_list</code></td>
<td>
<p>List with all the possible pruning and its associated alpha and scores.</p>
</td></tr>
<tr><td><code id="selectTk_+3A_se">SE</code></td>
<td>
<p>Value to get a range where new prunings is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same best tree or a new suitable one.
</p>

<hr>
<h2 id='SERules'>SERules</h2><span id='topic+SERules'></span>

<h3>Description</h3>

<p>Based on Validation tests over BestTivs, a new range of scores is obtained to find new pruned trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SERules(N, Lv, y, fold, Tk_score, BestTivs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SERules_+3A_n">N</code></td>
<td>
<p>Number of rows in data.</p>
</td></tr>
<tr><td><code id="SERules_+3A_lv">Lv</code></td>
<td>
<p>Test set.</p>
</td></tr>
<tr><td><code id="SERules_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="SERules_+3A_fold">fold</code></td>
<td>
<p>Parts in which the original data set is divided to perform Cross-Validation.</p>
</td></tr>
<tr><td><code id="SERules_+3A_tk_score">Tk_score</code></td>
<td>
<p>Best pruned tree score.</p>
</td></tr>
<tr><td><code id="SERules_+3A_besttivs">BestTivs</code></td>
<td>
<p>List of best pruned trees for each training set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value to get a range where new pruning is found.
</p>

<hr>
<h2 id='split'>Split node</h2><span id='topic+split'></span>

<h3>Description</h3>

<p>This function gets the variable and split value to be used in estimEAT, selects the best split and updates VarInfo, node indexes and leaves list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split(data, tree, leaves, t, x, y, numStop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="split_+3A_tree">tree</code></td>
<td>
<p>List structure with the tree nodes.</p>
</td></tr>
<tr><td><code id="split_+3A_leaves">leaves</code></td>
<td>
<p>List with leaf nodes or pending expansion nodes.</p>
</td></tr>
<tr><td><code id="split_+3A_t">t</code></td>
<td>
<p>Node which is being split.</p>
</td></tr>
<tr><td><code id="split_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="split_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="split_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node to be split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Leaves and tree lists updated with the new child nodes.
</p>

<hr>
<h2 id='split_forest'>Split Node in Random Forest EAT</h2><span id='topic+split_forest'></span>

<h3>Description</h3>

<p>This function gets the variable and split value to be used in estimEAT, selects the best split, node indexes and leaf list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_forest(data, tree, leaves, t, x, y, numStop, arrayK)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_forest_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="split_forest_+3A_tree">tree</code></td>
<td>
<p>List structure with the tree nodes.</p>
</td></tr>
<tr><td><code id="split_forest_+3A_leaves">leaves</code></td>
<td>
<p>List with leaf nodes or pending expansion nodes.</p>
</td></tr>
<tr><td><code id="split_forest_+3A_t">t</code></td>
<td>
<p>Node which is being split.</p>
</td></tr>
<tr><td><code id="split_forest_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="split_forest_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="split_forest_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations on a node to be split.</p>
</td></tr>
<tr><td><code id="split_forest_+3A_arrayk">arrayK</code></td>
<td>
<p>Column input indexes in data selected by s_mtry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Leaves and tree lists updated with the new child nodes.
</p>

<hr>
<h2 id='treesForRCV'>Trees for RCV</h2><span id='topic+treesForRCV'></span>

<h3>Description</h3>

<p>This function generates a deep EAT and all pruning for each train set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treesForRCV(notLv, x, y, fold, numStop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treesForRCV_+3A_notlv">notLv</code></td>
<td>
<p>Train set.</p>
</td></tr>
<tr><td><code id="treesForRCV_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="treesForRCV_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="treesForRCV_+3A_fold">fold</code></td>
<td>
<p>Parts in which the original set is divided to perform Cross-Validation.</p>
</td></tr>
<tr><td><code id="treesForRCV_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node to be split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with each possible pruning for the deep tree generated with train set and its associated alpha values.
</p>

<hr>
<h2 id='X2Y2.sim'>2 Inputs &amp; 2 Outputs Data Generation</h2><span id='topic+X2Y2.sim'></span>

<h3>Description</h3>

<p>This function is used to simulate the data in a scenario with 2 inputs and 2 outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X2Y2.sim(N, border, noise = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X2Y2.sim_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="X2Y2.sim_+3A_border">border</code></td>
<td>
<p>Percentage of DMUs in the frontier.</p>
</td></tr>
<tr><td><code id="X2Y2.sim_+3A_noise">noise</code></td>
<td>
<p>Random noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with simulated data.
</p>

<hr>
<h2 id='Y1.sim'>Single Output Data Generation</h2><span id='topic+Y1.sim'></span>

<h3>Description</h3>

<p>This function is used to simulate the data in a single output scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y1.sim(N, nX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Y1.sim_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="Y1.sim_+3A_nx">nX</code></td>
<td>
<p>Number of inputs. <code>1</code>, <code>3</code>, <code>6</code>, <code>9</code>, <code>12</code> and <code>15</code> are acceptable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with simulated data.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
