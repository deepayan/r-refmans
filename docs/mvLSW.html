<!DOCTYPE html><html lang="en"><head><title>Help for package mvLSW</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvLSW}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ApxCI'><p>Evaluate the Approximate Confidence Interval of a mvEWS Estimate</p></a></li>
<li><a href='#as.mvLSW'><p>Multivariate Locally Stationary Wavelet Object</p></a></li>
<li><a href='#AutoCorrIP'><p>Wavelet Autocorrelation Inner Product Functions</p></a></li>
<li><a href='#coherence'><p>Local Wavelet Coherence and Partial Coherence</p></a></li>
<li><a href='#mvEWS'><p>Multivariate Evolutionary Wavelet Spectrum</p></a></li>
<li><a href='#mvLSW'><p>Multivariate, Locally Stationary Wavelet Process Estimation</p></a></li>
<li><a href='#plot.mvLSW'><p>Plot mvLSW Object</p></a></li>
<li><a href='#rmvLSW'><p>Sample a Multivariate Locally Stationary Wavelet Process</p></a></li>
<li><a href='#Spectrum2Transfer'><p>Convert Between mvEWS and Transfer Function Matrices</p></a></li>
<li><a href='#summary.mvLSW'><p>Print a Summary of mvLSW Object</p></a></li>
<li><a href='#varEWS'><p>Asymptotic Variance of the mvEWS Estimate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate, Locally Stationary Wavelet Process Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for analysing multivariate time series with wavelets. This includes: simulation of a multivariate locally stationary wavelet (mvLSW) process from a multivariate evolutionary wavelet spectrum (mvEWS); estimation of the mvEWS, local coherence and local partial coherence. See Park, Eckley and Ombao (2014) &lt;<a href="https://doi.org/10.1109%2FTSP.2014.2343937">doi:10.1109/TSP.2014.2343937</a>&gt; for details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2),fields, wavethresh, xts, zoo,methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-14 15:19:28 UTC; grosedj</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Taylor [aut],
  Tim Park [aut],
  Idris Eckley [ths],
  Rebecca Killick [ctb],
  Daniel Grose [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Grose &lt;dan.grose@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-14 15:40:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
</table>
<hr>
<h2 id='ApxCI'>Evaluate the Approximate Confidence Interval of a mvEWS Estimate</h2><span id='topic+ApxCI'></span>

<h3>Description</h3>

<p>Evaluate the approximate confidence interval of a multivariate 
evolutionary wavelet spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ApxCI(object, var = NULL, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ApxCI_+3A_object">object</code></td>
<td>
<p>A <code>mvLSW</code> object containing the multivariate 
evolutionary wavelet spectrum estimate.</p>
</td></tr>
<tr><td><code id="ApxCI_+3A_var">var</code></td>
<td>
<p>A <code>mvLSW</code> object containing the variance estimate of 
the wavelet spectrum. If this is <code>NULL</code> (default) then the 
variance is estimates by calling the <code>varEWS</code> and using 
<code>object</code>.</p>
</td></tr>
<tr><td><code id="ApxCI_+3A_alpha">alpha</code></td>
<td>
<p>Type I error, a single numerical value within (0,0.5].</p>
</td></tr>
<tr><td><code id="ApxCI_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the 
<code><a href="#topic+varEWS">varEWS</a></code> command.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command evaluates the approximate Gaussian confidence 
intervals for the elements of the mvEWS estimate.
</p>


<h3>Value</h3>

<p>Invisibly returns a list containing two <code>mvLSW</code> classed
objects with names &quot;L&quot; and &quot;U&quot; that respectively identify the 
lower and upper interval estimates.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11. 
</p>
<p>Park, T. (2014) Wavelet Methods for Multivariate Nonstationary 
Time Series, PhD thesis, Lancaster University, pp. 91-111.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvEWS">mvEWS</a></code>, <code><a href="#topic+as.mvLSW">as.mvLSW</a></code>, <code><a href="#topic+varEWS">varEWS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define evolutionary wavelet spectrum, structure only on level 2
Spec &lt;- array(0, dim = c(3, 3, 8, 256))
Spec[1, 1, 2, ] &lt;- 10
Spec[2, 2, 2, ] &lt;- c(rep(5, 64), rep(0.6, 64), rep(5, 128))
Spec[3, 3, 2, ] &lt;- c(rep(2, 128), rep(8, 128))
Spec[2, 1, 2, ] &lt;- Spec[1, 2, 2, ] &lt;- punif(1:256, 65, 192)
Spec[3, 1, 2, ] &lt;- Spec[1, 3, 2, ] &lt;- c(rep(-1, 128), rep(5, 128))
Spec[3, 2, 2, ] &lt;- Spec[2, 3, 2, ] &lt;- -0.5
EWS &lt;- as.mvLSW(x = Spec, filter.number = 1, family = "DaubExPhase", 
  min.eig.val = NA)

## Sample time series and estimate the EWS.
set.seed(10)
X &lt;- rmvLSW(Spectrum = EWS)
EWS_X &lt;- mvEWS(X, kernel.name = "daniell", kernel.param = 20)

## Evaluate asymptotic spectral variance 
SpecVar &lt;- varEWS(EWS_X)

## Plot Estimate &amp; 95% confidence interval
CI &lt;- ApxCI(object = EWS_X, var = SpecVar, alpha = 0.05)
plot(x = EWS_X, style = 2, info = 2, Interval = CI)

</code></pre>

<hr>
<h2 id='as.mvLSW'>Multivariate Locally Stationary Wavelet Object</h2><span id='topic+as.mvLSW'></span><span id='topic+is.mvLSW'></span>

<h3>Description</h3>

<p>Constructs a multivariate locally stationary wavelet (mvLSW) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.mvLSW(x, filter.number = 1, family = "DaubExPhase",
    smooth.type = "all", smooth.kernel = kernel("daniell", 0), 
    bias.correct = FALSE, min.eig.val = -Inf, names = NULL)
  
  is.mvLSW(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.mvLSW_+3A_x">x</code></td>
<td>
<p>4D array of order PxPxJxT where P is the number of 
channels of the time series of length T such that T=<code class="reqn">2^J</code> for 
some positive integer J defining the levels of the mvLSW object.</p>
</td></tr>
<tr><td><code id="as.mvLSW_+3A_family">family</code></td>
<td>
<p>Character string specifying the wavelet family. Only two 
options are available, either <code>"DaubExPhase"</code> (default) 
or <code>"DaubLeAsymm"</code>.</p>
</td></tr>
<tr><td><code id="as.mvLSW_+3A_filter.number">filter.number</code></td>
<td>
<p>Integer number defining the number of 
vanishing moments of the wavelet function. By default, 
<code>filter.number=1</code> and so defining the Haar wavelet.</p>
</td></tr>
<tr><td><code id="as.mvLSW_+3A_smooth.type">smooth.type</code></td>
<td>
<p>What type of smoothing regime has been 
applied. Either <code>"all"</code> (default) if the smoothing 
method been applied to all levels. Otherwise <code>"by.level"</code>, 
a different smoothing method is applied to each level.</p>
</td></tr>
<tr><td><code id="as.mvLSW_+3A_smooth.kernel">smooth.kernel</code></td>
<td>
<p>Definition of the smoothing kernel from 
<code>kernel()</code>. By default, the identity kernel is defined.</p>
</td></tr>
<tr><td><code id="as.mvLSW_+3A_bias.correct">bias.correct</code></td>
<td>
<p>Logical, has a bias correction been applied 
to the data. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="as.mvLSW_+3A_min.eig.val">min.eig.val</code></td>
<td>
<p>Minimum eigenvalue from spectral matrices across 
all levels and locations, set at <code>-Inf</code> by default. If <code>NA</code>,
then the minimum eigenvalue is calculated.</p>
</td></tr>
<tr><td><code id="as.mvLSW_+3A_names">names</code></td>
<td>
<p>Character vector containing the channel names of the 
multivariate time series.</p>
</td></tr>
<tr><td><code id="as.mvLSW_+3A_object">object</code></td>
<td>
<p>Any R object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.mvLSW</code> constructs a multivariate locally stationary 
classed object that contains all information about the 
constructions of various multivariate wavelet estimates.
</p>
<p>The command <code>is.mvLSW</code> checks that the supplied R object 
is a valid <code>mvLSW</code> object in that its structure and 
contents are as expected.  
</p>


<h3>Value</h3>

<p>The <code>as.mvLSW</code> command invisibly returns a list with the 
following items:
</p>
<table role = "presentation">
<tr><td><code>spectrum</code></td>
<td>
<p>A 4D array containing the data relating to the 
estimate of interest.</p>
</td></tr>
<tr><td><code>Information</code></td>
<td>
<p>List containing information on the 
estimation procedure.</p>
</td></tr>
</table>
<p>The list <code>Information</code> contains:
</p>
<table role = "presentation">
<tr><td><code>names</code></td>
<td>
<p>Character vector containing the channel names.</p>
</td></tr>
<tr><td><code>dimensions</code></td>
<td>
<p>A list containing items <code>P</code> - the number 
of channels forming of the time series, <code>T</code> - the length 
of the time series and <code>J</code> - the number of levels in the 
wavelet transform of the data.</p>
</td></tr>
<tr><td><code>wavelet</code></td>
<td>
<p>A list containing the <code>filter.number</code> and 
<code>family</code> of the wavelet used in the transformation.</p>
</td></tr>
<tr><td><code>smooth</code></td>
<td>
<p>A list detailing applied smoothing of the estimate. 
Items include: 
</p>
<p><code>  smooth.type</code> - name of the smoothing regime.
</p>
<p><code>  smooth.kernels</code> - a <code>tskernel</code> class from the 
command <code>kernel()</code>.
</p>
<p><code>  GCV</code> - generalized cross-validation 
gamma deviance criterion of the smoothing.
</p>
<p><code>  smooth.eps</code> - smoothing threshold. 
</p>
<p>If <code>smooth.type="by.level"</code>, then 
<code>smooth.kernels</code> is a list containing the <code>tskernel</code> 
object for each level from fine to coarse. In addition, 
<code>GCV</code> is a length J vector containing the criterion 
estimate for each level from fine to coarse.</p>
</td></tr>
<tr><td><code>correction</code></td>
<td>
<p>A list containing <code>bias.correction</code> and 
<code>min.eig.val</code>.</p>
</td></tr>
</table>
<p>The command <code>is.mvLSW</code> returns <code>TRUE</code> if the supplied 
object is a valid <code>mvLSW</code> object as described above. 
Otherwise, the command returns <code>FALSE</code>.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvEWS">mvEWS</a></code>, <code><a href="#topic+varEWS">varEWS</a></code>, <code>kernel</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define evolutionary wavelet spectrum, structure only on level 2
Spec &lt;- array(0, dim = c(3, 3, 8, 256))
Spec[1, 1, 2, ] &lt;- 10
Spec[2, 2, 2, ] &lt;- c(rep(5, 64), rep(0.6, 64), rep(5, 128))
Spec[3, 3, 2, ] &lt;- c(rep(2, 128), rep(8, 128))
Spec[2, 1, 2, ] &lt;- Spec[1, 2, 2, ] &lt;- punif(1:256, 65, 192)
Spec[3, 1, 2, ] &lt;- Spec[1, 3, 2, ] &lt;- c(rep(-1, 128), rep(5, 128))
Spec[3, 2, 2, ] &lt;- Spec[2, 3, 2, ] &lt;- -0.5

## Define EWS as mvLSW object
EWS &lt;- as.mvLSW(x = Spec, filter.number = 1, family = "DaubExPhase", 
  names = c("A", "B", "C"), min.eig.val = NA)
is.mvLSW(EWS)
plot(EWS, style = 2, info = 2)
</code></pre>

<hr>
<h2 id='AutoCorrIP'>Wavelet Autocorrelation Inner Product Functions</h2><span id='topic+AutoCorrIP'></span>

<h3>Description</h3>

<p>Inner product of cross-level wavelet autocorrelation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  AutoCorrIP(J, filter.number = 1, family = "DaubExPhase",
    crop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AutoCorrIP_+3A_j">J</code></td>
<td>
<p>Number of levels.</p>
</td></tr>
<tr><td><code id="AutoCorrIP_+3A_filter.number">filter.number</code></td>
<td>
<p>Number of vanishing moments of the wavelet function.</p>
</td></tr>
<tr><td><code id="AutoCorrIP_+3A_family">family</code></td>
<td>
<p>Wavelet family, either <code>"DaubExPhase"</code> 
or <code>"DaubLeAsymm"</code>. The Haar wavelet is defined as default.</p>
</td></tr>
<tr><td><code id="AutoCorrIP_+3A_crop">crop</code></td>
<td>
<p>Logical, should the output of <code>AutoCorrIP</code> be 
cropped such that the first dimension of the returned array relate 
to the offset range -<code class="reqn">2^J</code>:<code class="reqn">2^J</code>.This is set at <code>TRUE</code> 
by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\psi(x)</code> denote the mother wavelet and the wavelet 
defined for level j as <code class="reqn">\psi_{j,k}(x) = 2^{j/2}\psi(2^{j}x-k)</code>.
The wavelet autocorrelation function between levels j &amp; l 
is therefore:
</p>
<p style="text-align: center;"><code class="reqn">\Psi_{j,l}(\tau) = \sum_\tau \psi_{j,k}(0)\psi_{l,k-\tau}(0)</code>
</p>

<p>Here, integer <code class="reqn">\tau</code> defines the offset of the latter 
wavelet function relative to the first.
</p>
<p>The inner product of this wavelet autocorrelation function is 
defined as follows for level indices j, l &amp; h and offset <code class="reqn">\lambda</code>:
</p>
<p style="text-align: center;"><code class="reqn">A^{\lambda}_{j,l,h} = \sum_{\tau} \Psi_{j,l}(\lambda - \tau) \Psi_{h,h}(\tau)</code>
</p>



<h3>Value</h3>

<p>A 4D array (invisibly returned) of order 
LxJxJxJ where L depends on the specified wavelet function. 
If <code>crop=TRUE</code> then L=<code class="reqn">2^{J+1}</code>+1. The first dimension 
defines the offset <code class="reqn">\lambda</code>, whilst the second to 
fourth dimensions identify the levels indexed by j, l &amp; h 
respectively.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11. 
</p>
<p>Fryzlewicz, P. and Nason, G. (2006) HaarFisz estimation of 
evolutionary wavelet spectra. <em>Journal of the Royal 
Statistical Society. Series B</em>, <strong>68</strong>(4) pp. 611-634.
</p>


<h3>See Also</h3>

<p><code>ipndacw</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot Haar autocorrelation wavelet functions inner product
AInnProd &lt;- AutoCorrIP(J = 8, filter.number = 1, family = "DaubExPhase")
## Not run: 
MaxOffset &lt;- 2^8
for(h in 6:8){
  x11()
  par(mfrow = c(3, 3))
  for(l in 6:8){
    for(j in 6:8){
      plot(-MaxOffset:MaxOffset, AInnProd[, j, l, h], type = "l", 
        xlab = "lambda", ylab = "Autocorr Inner Prod", 
        main = paste("j :", j, "- l :", l, "- h :", h))
    }
  }
}

## End(Not run)

## Special case relating to ipndacw function from wavethresh package
Amat &lt;- matrix(NA, ncol = 8, nrow = 8)
for(j in 1:8) Amat[, j] &lt;- AInnProd[2^8 + 1, j, j, ]
round(Amat, 5)
round(ipndacw(J = -8, filter.number = 1, family = "DaubExPhase"), 5)
</code></pre>

<hr>
<h2 id='coherence'>Local Wavelet Coherence and Partial Coherence</h2><span id='topic+coherence'></span>

<h3>Description</h3>

<p>Wavelet coherence and partial coherence of an evolutionary 
wavelet spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coherence(object, partial = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coherence_+3A_object">object</code></td>
<td>
<p>Multivariate evolutionary wavelet spectrum as a
<code>mvLSW</code> object.</p>
</td></tr>
<tr><td><code id="coherence_+3A_partial">partial</code></td>
<td>
<p>Logical, should the partial coherence be 
calculated. Set as <code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the evolutionary wavelet spectrum of a multivariate locally 
stationary time series, denoted by the matrix sequence <code class="reqn">S_{j,k}</code>, 
then the coherence matrix for level j and location k is:
</p>
<p style="text-align: center;"><code class="reqn">R_{j,k} = D_{j,k} S_{j,k} D_{j,k}</code>
</p>

<p>where <code class="reqn">D_{j,k} = diag\{ (S^{(p,p)}_{j,k})^{-0.5} : p=1,\ldots,P \}</code>.
This measures the linear cross-dependence between different 
channels at a particular level. 
</p>
<p>Notate the inverse spectrum matrix as <code class="reqn">G_{j,k} = S^{-1}_{j,k}</code>, 
then the partial coherence matrix for level j and location k is 
derived as follows:
</p>
<p style="text-align: center;"><code class="reqn">\Gamma_{j,k} = -H_{j,k} G_{j,k} H_{j,k}</code>
</p>

<p>where <code class="reqn">H_{j,k} = diag\{ (G^{(p,p)}_{j,k})^{-0.5} : p=1,\ldots,P \}</code>.
This measures the coherence between channels after removing the 
linear effects if all other channels and so enable the distinction 
between direct and indirect linear dependency between channels.
</p>
<p>For valid calculations of (partial) coherence, values within [-1,1], 
it is important that the spectral matrices are positive definite.
</p>


<h3>Value</h3>

<p>An object of class <code>mvLSW</code>, invisibly.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11.
</p>
<p>Park, T., Eckley, I. and Ombao, H.C. (2014) Estimating 
time-evolving partial coherence between signals via multivariate 
locally stationary wavelet processes. <em>Signal Processing, 
IEEE Transactions on</em> <strong>62</strong>(20) pp. 5240-5250.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.mvLSW">as.mvLSW</a></code>, <code><a href="#topic+mvEWS">mvEWS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample tri-variate time series
##  Series 2 &amp; 3 are dependent indirectly via Series 1
set.seed(100)
X &lt;- matrix(rnorm(3 * 2^8), ncol = 3)
X[1:192, 2] &lt;- X[1:192, 2] + 0.95 * X[1:192, 1]
X[65:256, 3] &lt;- X[65:256, 3] - 0.95 * X[65:256, 1]
X &lt;- as.ts(X)

## Evolutionary Wavelet Spectrum
EWS &lt;- mvEWS(X, filter.number = 4, kernel.name = "daniell", 
  kernel.param = 20)

## Coherence
RHO &lt;- coherence(EWS, partial = FALSE)
plot(RHO, style = 2, info = 1, ylab = "Coherence", diag = FALSE)

## Partial Coherence
PRHO &lt;- coherence(EWS, partial = TRUE)
plot(PRHO, style = 2, info = 1, ylab = "P. Coh.", diag = FALSE) 
#series 2&amp;3 are closer to 0
</code></pre>

<hr>
<h2 id='mvEWS'>Multivariate Evolutionary Wavelet Spectrum</h2><span id='topic+mvEWS'></span>

<h3>Description</h3>

<p>Calculates the multivariate Evolutionary Wavelet Spectrum 
(mvEWS) of a multivariate locally stationary time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mvEWS(X, filter.number = 1, family = "DaubExPhase", 
    smooth = TRUE, type = "all", kernel.name = "daniell", 
    kernel.param = floor(sqrt(nrow(X))), optimize = FALSE, 
    smooth.Jset = NA, bias.correct = TRUE, tol = 1e-10,
    verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvEWS_+3A_x">X</code></td>
<td>
<p>A multivariate time series object of class <code>ts</code>, 
<code>zoo</code>, <code>xts</code> or <code>matrix</code>. The length of the 
time series must be <code class="reqn">2^J</code> for positive integer J.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_filter.number">filter.number</code></td>
<td>
<p>Integer number defining the number of 
vanishing moments of the wavelet function. By default, 
<code>filter.number=1</code> and so defining the Haar wavelet.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_family">family</code></td>
<td>
<p>Character string specifying the wavelet family. 
Only two options are available, either 
<code>"DaubExPhase"</code> (default) or <code>"DaubLeAsymm"</code>.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_smooth">smooth</code></td>
<td>
<p>Logical, should the mvEWS should be smoothed?</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_type">type</code></td>
<td>
<p>How should the smoothing be performed? If <code>"all"</code>
(default) then the same smoothing kernel is applied to all 
levels, else if <code>"by.level"</code> then a different smoothing 
kernel is applied to each level.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_kernel.name">kernel.name</code></td>
<td>
<p>Name of smoothing kernel to be supplied 
to <code>kernel()</code>. Kernel <code>"daniell"</code> is defined by 
default.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_kernel.param">kernel.param</code></td>
<td>
<p>Parameters to be passed to <code>kernel()</code>. 
This argument must be a vector if <code>type="all"</code>, otherwise
it must be a matrix with each column defining the kernel parameters 
for each <code>log2(nrow(X))</code> levels from coarse to fine. If 
the name is <code>"dirichlet"</code> or <code>"fejer"</code> 
then <code>kernel.param</code> must have length 2 (or a matrix with 
2 rows) which are supplied to <code>kernel()</code> as arguments 
<code>m</code> and <code>r</code> respectively. Note that the width of the 
kernel cannot be larger than the time series length. This is set by 
default as the square root of the length of the time series.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_optimize">optimize</code></td>
<td>
<p>Logical, should the smoothing be optimized? 
If <code>FALSE</code> (default) then smoothing is performed as 
specified with <code>kernel.name</code> and <code>kernel.param</code>. 
Otherwise, <code>kernel.param</code> defines the upper parameter bound 
in determining the optimal kernel is determined by minimising 
the generalized cross-validation gamma deviance criterion.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_smooth.jset">smooth.Jset</code></td>
<td>
<p>Integer vector indicating with levels to be 
included in the calculation of the generalized cross-validation 
gamma deviance criterion. This argument is only used if 
<code>type="all"</code> and is set as <code>NA</code> by default, 
implying that all levels should be used.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_bias.correct">bias.correct</code></td>
<td>
<p>Logical, should the correction be applied 
to address the bias in the raw mvEWS estimator.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_tol">tol</code></td>
<td>
<p>Tolerance in applying matrix regularisation 
to ensure each mvEWS matrix per location and level to be 
strictly positive definite.	If <code>NA</code> or <code>-Inf</code> then 
the threshold is not applied. This is 1e-10 by default.</p>
</td></tr>
<tr><td><code id="mvEWS_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Controls the printing of messages whist 
the computations progress. Set as <code>FALSE</code> as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command evaluates the multivariate evolutionary wavelet 
spectrum of a multivariate locally stationary wavelet time series. 
The order of operations are as follows:
</p>
<p>Calculate the non-decimated wavelet coefficients <code class="reqn">\{d^{(p)}_{j,k}\}</code> 
for levels j = 1,...,J, locations k = 0,...,T-1 (T=<code class="reqn">2^J</code>) 
and channels p = 1,...,P(=<code>ncol(X)</code>). The raw periodogram matrices 
are then evaluated by <code class="reqn">I^{(p,q)}_{j,k} = d^{p}_{j,k}d^{q}_{j,k}</code> 
between any channel pair p &amp; q.
</p>
<p>The above estimator is inconsistent and so the matrix sequence is 
smoothed: <code class="reqn">\tilde{I}^{(p,q)}_{j,k} = \sum_i W_i I^{(p,q)}_{j,k+i}</code>. 
The kernel weights <code class="reqn">W_i</code> are derived from the <code>kernel</code> command 
and satisfy <code class="reqn">W_i=W_{-i}</code> and <code class="reqn">\sum_i W_i = 1</code>. The optimal 
parameter for the smoothing kernel is determined by minimising the 
generalized cross-validation gamma deviance criterion 
(see Ombao et al., 2005).
</p>
<p>The raw wavelet periodogram is also a biased estimator. A correction is 
subsequently applied to the smoothed estimate as follows:
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}_{j,k} =\sum_{l=1}^{J} (A^{-1})_{j,l} \hat{I}_{l,k}</code>
</p>

<p>Here, <code class="reqn">A</code> denotes the wavelet autocorrelation inner product matrix.
</p>
<p>If chosen to, the mvEWS matrices at each level and location, 
<code class="reqn">\hat{S}_{j,k}</code>, is regularised to ensure positive definiteness.
</p>


<h3>Value</h3>

<p>An object of class <code>mvLSW</code>, invisibly.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11.
</p>
<p>Park, T., Eckley, I. and Ombao, H.C. (2014) Estimating 
time-evolving partial coherence between signals via multivariate 
locally stationary wavelet processes. <em>Signal Processing, 
IEEE Transactions on</em> <strong>62</strong>(20) pp. 5240-5250.
</p>
<p>Ombao, H., von Sachs, R. and Guo, W. (2005) SLEX analysis 
of multivariate nonstationary time series. <em>Journal 
of the American Statistical Association</em> <strong>100</strong>(470)
pp.519-531.
</p>


<h3>See Also</h3>

<p><code>ts</code>, <code>wd</code>, <code>kernel</code>, <code><a href="#topic+as.mvLSW">as.mvLSW</a></code>, <code>ipndacw</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample bivariate locally stationary time series
set.seed(100)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

## Haar wavelet, apply same smoothing to all levels &amp; optimize
EWS &lt;- mvEWS(X, kernel.name = "daniell", kernel.param = 20, 
  optimize = TRUE)
summary(EWS)
plot(EWS, style = 2, info = 1)

## Over smoothed EWS
EWS_smooth &lt;- mvEWS(X, filter.number = 10, family = "DaubLeAsymm",
  kernel.name = "modified.daniell", kernel.param = c(5, 5),
  optimize = FALSE)
summary(EWS_smooth)
plot(EWS_smooth, style = 2, info = 1)
</code></pre>

<hr>
<h2 id='mvLSW'>Multivariate, Locally Stationary Wavelet Process Estimation</h2><span id='topic+mvLSW'></span>

<h3>Description</h3>

<p>The mvLSW package provides an implementation of the multivariate locally 
stationary time series modelling approach proposed by Park, Eckley and 
Ombao (2014).
</p>
<p>The approach extends the locally stationary wavelet time series work of 
Nason, von Sachs and Kroisandt (2000) to a multivariate setting, introducing 
wavelet-based measures of local coherence and local partial coherence. The 
package implements the estimation scheme by Park et al. (2014) for such 
processes. Note that mvLSW should be used in conjunction with the 
<code>wavethresh</code> package developed by Nason (2016).
</p>


<h3>Details</h3>

<p>Package: mvLSW
</p>
<p>Type: Package
</p>
<p>Version: 1.2.3
</p>
<p>Date: 2019-08-05
</p>
<p>License: GPL(&gt;=3)
</p>


<h3>Author(s)</h3>

<p>Simon Taylor, &lt;s.taylor2@lancaster.ac.uk&gt;
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11. 
</p>
<p>Park, T.A., Eckley, I. and Ombao, H.C. (2014) Estimating 
time-evolving partial coherence between signals via multivariate 
locally stationary wavelet processes <em>IEEE Transactions on 
Signal Processing</em> <strong>62</strong>(20), pp. 5240&ndash;5250.
</p>
<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (2000) Wavelet 
processes and adaptive estimation of the evolutionary wavelet 
spectrum <em>Journal of the Royal Statistical Society B</em> 
<strong>62</strong>, pp. 271&ndash;292.
</p>
<p>Nason, G. (2016) wavethresh: Wavelets Statistics and Transforms. 
R package version 4.6.8. 
</p>
<p>https://CRAN.R-project.org/package=wavethresh
</p>


<h3>See Also</h3>

<p><code>mvEWS</code>, <code>coherence</code>, <code>rmvLSW</code>,
<code><a href="#topic+as.mvLSW">as.mvLSW</a></code>, <code><a href="#topic+mvEWS">mvEWS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See examples in individual help pages
#
</code></pre>

<hr>
<h2 id='plot.mvLSW'>Plot mvLSW Object</h2><span id='topic+plot.mvLSW'></span>

<h3>Description</h3>

<p>Plot the data contained within a <code>mvLSW</code> object based on the 
requested format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mvLSW'
plot(x, style = 1, info = NULL, Interval = NULL, 
    diag = TRUE, sub = "Spectrum", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mvLSW_+3A_x">x</code></td>
<td>
<p>A <code>mvLSW</code> object.</p>
</td></tr>
<tr><td><code id="plot.mvLSW_+3A_style">style</code></td>
<td>
<p>Index stating the type of plotting format for 
the <code>mvLSW</code> object. (See details.)</p>
</td></tr>
<tr><td><code id="plot.mvLSW_+3A_info">info</code></td>
<td>
<p>Vector containing the channel and/or level indices 
defining the slice through <code>x</code> according to the 
requested plotting <code>style</code>. (See details.)</p>
</td></tr>
<tr><td><code id="plot.mvLSW_+3A_interval">Interval</code></td>
<td>
<p>A list containing two items, both <code>mvLSW</code> 
objects with names &quot;L&quot; and &quot;U&quot; that respectively define the lower
and upper pointwise interval values. If <code>NULL</code>, default, 
then no interval is plotted.</p>
</td></tr>
<tr><td><code id="plot.mvLSW_+3A_diag">diag</code></td>
<td>
<p>Logical, should the diagonal panels be drawn when 
<code>style=2</code>. Ideally this should be <code>FALSE</code> if 
<code>object</code> contains the coherence. Set to <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="plot.mvLSW_+3A_sub">sub</code></td>
<td>
<p>Plot subtitle. Set to <code>"Spectrum"</code> by default.</p>
</td></tr>
<tr><td><code id="plot.mvLSW_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command plots the data contained within the <code>mvLSW</code> based 
on requested plotting style.
</p>
<p>Plotting style <code>style=1</code> with information <code>info=c(p,q,j)</code> 
generates a single plot for a 
specified channel pair <code>p</code> &amp; <code>q</code> and level <code>j</code>.
</p>
<p>Plotting style <code>style=2</code> with information <code>info=j</code> 
creates a set of plots from <code>x</code> for all channel pairs in a 
lower-triangular panel corresponding to the specified level j.
If <code>diag=FALSE</code> then the plots along the diagonal are suppressed,
which is ideal when <code>x</code> contain coherence estimates.
</p>
<p>Plotting style <code>style=3</code> with information <code>info=c(p,q)</code>
creates a set of plots from <code>x</code> for all levels (from fine 
to coarse) for channel pair <code>p</code> and <code>q</code>.
</p>
<p>Finally, the plotting style <code>style=4</code> with information 
<code>info=c(p,q)</code> presents the same information as
for the previous case, but in a compact matrix format. Please 
refer to <code>image.plot</code> from the <code>fields</code> library for 
additional information on this plotting style.
</p>
<p>The argument <code>Interval</code> must be supplied in order to draw a 
polygon depicting the pointwise interval. See <code><a href="#topic+ApxCI">ApxCI</a></code> 
for deriving an approximate confidence interval for the evolutionary
wavelet spectrum estimate.
This argument is ignored in the case <code>style=4</code>.
</p>


<h3>Value</h3>

<p>Generates a plot. No data is returned.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11.
</p>


<h3>See Also</h3>

<p><code>plot.default</code>, <code>image.plot</code>, <code><a href="#topic+as.mvLSW">as.mvLSW</a></code>, 
<code><a href="#topic+mvEWS">mvEWS</a></code>, <code><a href="#topic+coherence">coherence</a></code>, <code><a href="#topic+ApxCI">ApxCI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define evolutionary wavelet spectrum, structure only on level 2
Spec &lt;- array(0, dim=c(3, 3, 8, 256))
Spec[1, 1, 2, ] &lt;- 10
Spec[2, 2, 2, ] &lt;- c(rep(5, 64), rep(0.6, 64), rep(5, 128))
Spec[3, 3, 2, ] &lt;- c(rep(2, 128), rep(8, 128))
Spec[2, 1, 2, ] &lt;- Spec[1, 2, 2, ] &lt;- punif(1:256, 65, 192)
Spec[3, 1, 2, ] &lt;- Spec[1, 3, 2, ] &lt;- c(rep(-1, 128), rep(5, 128))
Spec[3, 2, 2, ] &lt;- Spec[2, 3, 2, ] &lt;- -0.5
EWS &lt;- as.mvLSW(x = Spec, filter.number = 1, family = "DaubExPhase",
  min.eig.val = NA)

## Sample time series and estimate the EWS and coherence.
set.seed(10)
X &lt;- rmvLSW(Spectrum = EWS)
EWS_X &lt;- mvEWS(X, kernel.name = "daniell", kernel.param = 20)
RHO_X &lt;- coherence(EWS_X, partial = FALSE)

## Evaluate asymptotic spectral variance 
SpecVar &lt;- varEWS(EWS_X)

## Evaluate 95% approximate confidence interval
CI &lt;- ApxCI(object = EWS_X, var = SpecVar, alpha=0.05)

## Plot mvEWS between channels 1 &amp; 3 at level 2
plot(x = EWS_X, style = 1, info = c(1, 3, 2), Interval = CI)

## Plot coherence between channels 1 &amp; 3 at level 2
plot(x = RHO_X, style = 1, info = c(1, 3, 2), ylab = "Coherence")

## mvEWS panel plot for level 2
plot(x = EWS_X, style = 2, info = 2, Interval = CI)

## Panel plot of coherence for level 2
plot(x = RHO_X, style = 2, info = 2, diag = FALSE, ylab = "Coherence")

## Plot mvEWS for channel pair 1 &amp; 3 at all levels
plot(x = EWS_X, style = 3, info = c(1, 3), Interval = CI)

## Plot coherence for channel pair 1 &amp; 3 at all levels
plot(x = RHO_X, style = 3, info = c(1, 3), ylab = "Coherence")

## Image plot for coherence between channels 1 &amp; 3
plot(x = RHO_X, style = 4, info = c(1, 3), sub = "Coherence")
</code></pre>

<hr>
<h2 id='rmvLSW'>Sample a Multivariate Locally Stationary Wavelet Process</h2><span id='topic+rmvLSW'></span><span id='topic+simulate.mvLSW'></span>

<h3>Description</h3>

<p>Sample a multivariate locally stationary wavelet process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvLSW(Transfer = NULL, Spectrum = NULL, noiseFN = rnorm, ...)  

## S3 method for class 'mvLSW'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmvLSW_+3A_transfer">Transfer</code></td>
<td>
<p>A <code>mvLSW</code> object containing the set of 
transfer function matrices of the process.</p>
</td></tr>
<tr><td><code id="rmvLSW_+3A_spectrum">Spectrum</code>, <code id="rmvLSW_+3A_object">object</code></td>
<td>
<p>A <code>mvLSW</code> object containing the 
multivariate evolutionary wavelet spectrum of the process. 
This argument is only used if <code>Transfer</code> is not supplied.</p>
</td></tr>
<tr><td><code id="rmvLSW_+3A_noisefn">noiseFN</code></td>
<td>
<p>The function for sampling the innovations.</p>
</td></tr>
<tr><td><code id="rmvLSW_+3A_nsim">nsim</code></td>
<td>
<p>Number of mvLSW time series to draw. Only 
<code>nsim = 1</code> is accepted.</p>
</td></tr>
<tr><td><code id="rmvLSW_+3A_seed">seed</code></td>
<td>
<p>Seed for the random number generator.</p>
</td></tr>
<tr><td><code id="rmvLSW_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the function for
sampling the innovation process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples a single multivariate locally stationary wavelet time 
series for the given set of transfer function matrices. These 
are assumed to be lower-triangular (including diagonal) matrices.
If the mvEWS is supplied instead, then 
this is pre-processed by <code>Spectrum2Transfer()</code> to obtain 
the transfer function matrices.
</p>
<p>The <code>Transfer</code> and <code>Spectrum</code> are both <code>mvLSW</code> 
objects and therefore contain information about defining the 
wavelet function.
</p>
<p>The innovation process is assumed to be second order stationary 
with expectation zero, orthogonal and unit variance. The first argument 
of <code>noiseFN</code> must be <code>n</code> and define the number of samples 
to generate. The function must also return a numerical vector 
of length <code>n</code>.
</p>
<p>The <code>simulate</code> command implements <code>rmvLSW</code> under default 
arguments unless specified via <code>...</code>.
</p>


<h3>Value</h3>

<p>A <code>ts</code> matrix object of a multivariate locally stationary 
time series. The columns of the matrix correspond to different 
channels and the rows identify the time axis.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11.
</p>
<p>Park, T., Eckley, I. and Ombao, H.C. (2014) Estimating 
time-evolving partial coherence between signals via multivariate 
locally stationary wavelet processes. <em>Signal Processing, 
IEEE Transactions on</em> <strong>62</strong>(20) pp. 5240-5250.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvLSW">mvLSW</a></code>, <code><a href="#topic+Spectrum2Transfer">Spectrum2Transfer</a></code>, 
<code>rnorm</code>, <code>AvBasis</code>, <code>ts</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define evolutionary wavelet spectrum, structure only on level 2
Spec &lt;- array(0, dim = c(3, 3, 8, 256))
Spec[1, 1, 2, ] &lt;- 10
Spec[2, 2, 2, ] &lt;- c(rep(5, 64), rep(0.6, 64), rep(5, 128))
Spec[3, 3, 2, ] &lt;- c(rep(2, 128), rep(8, 128))
Spec[2, 1, 2, ] &lt;- Spec[1, 2, 2, ] &lt;- punif(1:256, 65, 192)
Spec[3, 1, 2, ] &lt;- Spec[1, 3, 2, ] &lt;- c(rep(-1, 128), rep(5, 128))
Spec[3, 2, 2, ] &lt;- Spec[2, 3, 2, ] &lt;- -0.5

## Define Haar wavelet function and create mvLSW object
EWS &lt;- as.mvLSW(x = Spec, filter.number = 1, family = "DaubExPhase",
  min.eig.val = NA)
plot(EWS, style = 2, info = 2)

## Sample with Gaussian innovations
set.seed(10)
X &lt;- rmvLSW(Spectrum = EWS)
plot(X)

## Alternatively:
X1 &lt;- simulate(object = EWS)
plot(X1)

## Define smoother wavelet function and create mvLSW object
EWS2 &lt;- as.mvLSW(x = Spec, filter.number = 10, family = "DaubExPhase")

## Sample with logistic innovations
set.seed(10)
X2 &lt;- rmvLSW(Spectrum = EWS2, noiseFN = rlogis, scale = sqrt(3)/pi)
plot(X2)
</code></pre>

<hr>
<h2 id='Spectrum2Transfer'>Convert Between mvEWS and Transfer Function Matrices</h2><span id='topic+Spectrum2Transfer'></span>

<h3>Description</h3>

<p>Convert between multivariate evolutionary wavelet spectrum 
and the set of transfer function matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Spectrum2Transfer(object, S2V = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Spectrum2Transfer_+3A_object">object</code></td>
<td>
<p>A <code>mvLSW</code> object containing either the mvEWS 
or matrix transfer function.</p>
</td></tr>
<tr><td><code id="Spectrum2Transfer_+3A_s2v">S2V</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then <code>object</code> 
is the mvEWS and the set of transfer function matrices are to 
be derived. If <code>FALSE</code> the <code>object</code> is the set of 
transfer function matrices and the converse transformation is 
derived.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the mvEWS is supplied, then the set of transfer function matrices 
are derived by the Choleski factorization of a real symmetric 
semi-positive definite square matrix. In the cases where the matrix 
is semi-definite, then the Choleski factorization is applied to the 
submatrix that is positive definite and the remaining lower triangular 
elements are populated such that the resulting matrix is a valid 
factorization.
</p>
<p>Conversely, if the set of transfer function matrices are supplied, 
then the EWS are derived by squaring the matrices.
</p>


<h3>Value</h3>

<p>A <code>mvLSW</code> object containing either the mvEWS or set of transfer 
function matrices depending on the specified transformation 
direction.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11.
</p>
<p>Park, T., Eckley, I. and Ombao, H.C. (2014) Estimating 
time-evolving partial coherence between signals via multivariate 
locally stationary wavelet processes. <em>Signal Processing, 
IEEE Transactions on</em> <strong>62</strong>(20) pp. 5240-5250.
</p>


<h3>See Also</h3>

<p><code>chol</code>, <code><a href="#topic+as.mvLSW">as.mvLSW</a></code>, <code><a href="#topic+mvEWS">mvEWS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define evolutionary wavelet spectrum, structure only on level 2
Spec &lt;- array(0, dim=c(3, 3, 8, 256)) ## Ensure all are positive def.
Spec[1, 1, 2, ] &lt;- 10
Spec[2, 2, 2, ] &lt;- c(rep(5, 64), rep(0.6, 64), rep(5, 128))
Spec[3, 3, 2, ] &lt;- c(rep(2, 128), rep(8, 128))
Spec[2, 1, 2, ] &lt;- Spec[1, 2, 2, ] &lt;- punif(1:256, 65, 192)
Spec[3, 1, 2, ] &lt;- Spec[1, 3, 2, ] &lt;- c(rep(-1, 128), rep(5, 128))
Spec[3, 2, 2, ] &lt;- Spec[2, 3, 2, ] &lt;- -0.5

## Define EWS as mvLSW object
EWS &lt;- as.mvLSW(x = Spec, filter.number = 1, family = "DaubExPhase",
  min.eig.val = NA)
plot(EWS, style = 2, info = 2)

## EWS to Transfer function matrices
Transfer &lt;- Spectrum2Transfer(object = EWS, S2V = TRUE)

## Transfer function matrices to EWS
EWS2 &lt;- Spectrum2Transfer(object = Transfer, S2V = FALSE)
plot(EWS2, style = 2, info = 2)
</code></pre>

<hr>
<h2 id='summary.mvLSW'>Print a Summary of mvLSW Object</h2><span id='topic+summary.mvLSW'></span><span id='topic+print.mvLSW'></span>

<h3>Description</h3>

<p>Prints a summary of the information contained within a <code>mvLSW</code> 
classed object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mvLSW'
summary(object, ...)
  ## S3 method for class 'mvLSW'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mvLSW_+3A_object">object</code>, <code id="summary.mvLSW_+3A_x">x</code></td>
<td>
<p>A <code>mvLSW</code> object.</p>
</td></tr>
<tr><td><code id="summary.mvLSW_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command prints to screen a summary of the information 
contained within a <code>mvLSW</code> object. Information printed 
includes: dimensions, wavelet function, the smoothing regime 
applied, smoothing kernel(s), generalized cross-validation 
gamma deviance criteria score, application of the bias correction 
and minimum eigenvalue from across all spectral matrices.
</p>


<h3>Value</h3>

<p>This command returns nothing, only prints a summary to the console.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvEWS">mvEWS</a></code>, <code><a href="#topic+as.mvLSW">as.mvLSW</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a bivariate time series
set.seed(100)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

## Haar wavelet, apply same smoothing to all levels &amp; optimize
EWS &lt;- mvEWS(X, kernel.name = "daniell", kernel.param = 20,
  optimize = TRUE)
summary(EWS)
print(EWS)
plot(EWS, style = 2, info = 1)
</code></pre>

<hr>
<h2 id='varEWS'>Asymptotic Variance of the mvEWS Estimate</h2><span id='topic+varEWS'></span>

<h3>Description</h3>

<p>Calculates the asymptotic variance of a multivariate 
evolutionary wavelet spectrum estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  varEWS(object, ACWIP = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varEWS_+3A_object">object</code></td>
<td>
<p>A <code>mvLSW</code> object containing the multivariate 
evolutionary wavelet spectrum. Matrices must be positive definite, 
i.e. information item <code>min.eig.val</code> must be greater than zero.</p>
</td></tr>
<tr><td><code id="varEWS_+3A_acwip">ACWIP</code></td>
<td>
<p>4D array containing the wavelet autocorrelation
inner product functions. Set to <code>NULL</code> by default and 
therefore evaluated within the command based on the 
information supplied by <code>object</code>.</p>
</td></tr>
<tr><td><code id="varEWS_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Controls the printing of messages whist 
the computations progress. Set as <code>FALSE</code> as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>varEWS</code> commands evaluate the asymptotic variance of a 
multivariate evolutionary wavelet spectrum (mvEWS) estimate. Note, 
the variance is only applicable when the mvEWS is smoothed 
consistently across all levels with list item <code>smooth.type="all"</code>.
This can be written in terms of the smoothed 
periodogram relating to the bias correction of the mvEWS estimate, 
where <code class="reqn">A_{j,k}</code> is the inner product matrix of the wavelet 
autocorrelation function:
</p>
<p style="text-align: center;"><code class="reqn">Var( \hat{S}^{(p,q)}_{j,k} ) 
    = \sum_{l_1,l_2=1}^{J} (A^{-1})_{j,l_1} (A^{-1})_{j,l_2} 
	Cov( \tilde{I}^{(p,q)}_{l_1,k}, \tilde{I}^{(p,q)}_{l_1,k})</code>
</p>

<p>The covariance between elements of the smoothed periodogram can also 
be expressed in terms of the raw wavelet periodogram:
</p>
<p style="text-align: center;"><code class="reqn">Cov( \tilde{I}^{(p,q)}_{l_1,k}, \tilde{I}^{(p,q)}_{l_1,k}) 
    = \sum_{m_1,m_2} W_{m_1} W_{m_2} Cov( I^{(p,q)}_{l_1,m_1}, 
	  I^{(p,q)}_{l_2,m_2} )</code>
</p>

<p>The weights <code class="reqn">W_i</code>, for integer i, define the smoothing kernel function 
that is evaluated by the <code>kernel</code> command. Note that <code class="reqn">W_i = W_{-i}</code>
and <code class="reqn">\sum_i W_i = 1</code>.
</p>
<p>The final step is to derive the covariance of the raw periodogram. This has 
a long derivation, which can be concisely calculated by:
</p>
<p style="text-align: center;"><code class="reqn">Cov( I^{(p,q)}_{j,k}, I^{(p,q)}_{l,m} ) 
    = E(p,j,k,q,l,m)^2 + E(p,j,k,p,l,m)E(q,j,k,q,l,m)</code>
</p>

<p>where	
</p>
<p style="text-align: center;"><code class="reqn">E(p,j,k,q,l,m) = \sum_{h=1}^{J} A^{k-m}_{j,l,h} S^{(p,q)}_h((k+m)/2T) </code>
</p>

<p>Here, <code class="reqn">A^{\lambda}_{j,l,h}</code> defines the autocorrelation 
wavelet inner product function and <code class="reqn">S^{(p,q)}_{j}(k/T)</code> 
is the true spectrum of the process between channels p &amp; q, 
level j and location k. The true spectrum is not always available 
and so this may be substituted with the smoothed and bias corrected 
mvEWS estimate. For practical purposes, if k+m is odd then the 
average between the available spectrum values at neighbouring 
locations are substituted.
</p>
<p>For efficiency purpose, if the <code>varEWS</code> command is going to 
be called multiple times then it is highly recommended that the 
autocorrelation wavelet inner product should be evaluated beforehand 
by <code>AutoCorrIP</code> and supplied via the <code>ACWIP</code> argument.
</p>


<h3>Value</h3>

<p>Invisibly returns a <code>mvLSW</code> object containing the asymptotic variance 
of the multivariate evolutionary wavelet spectrum.
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate 
locally stationary wavelet analysis with the mvLSW R package.
<em>Journal of statistical software</em> <strong>90</strong>(11) pp. 1&ndash;16,
doi: 10.18637/jss.v090.i11.
</p>
<p>Park, T. (2014) Wavelet Methods for Multivariate Nonstationary 
Time Series, PhD thesis, Lancaster University, pp. 91-111.
</p>


<h3>See Also</h3>

<p><code>ipndacw</code>, <code><a href="#topic+AutoCorrIP">AutoCorrIP</a></code>, 
<code><a href="#topic+as.mvLSW">as.mvLSW</a></code>, <code><a href="#topic+mvEWS">mvEWS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define evolutionary wavelet spectrum, structure only on level 2
Spec &lt;- array(0, dim=c(3, 3, 8, 256))
Spec[1, 1, 2, ] &lt;- 10
Spec[2, 2, 2, ] &lt;- c(rep(5, 64), rep(0.6, 64), rep(5, 128))
Spec[3, 3, 2, ] &lt;- c(rep(2, 128), rep(8, 128))
Spec[2, 1, 2, ] &lt;- Spec[1, 2, 2, ] &lt;- punif(1:256, 65, 192)
Spec[3, 1, 2, ] &lt;- Spec[1, 3, 2, ] &lt;- c(rep(-1, 128), rep(5, 128))
Spec[3, 2, 2, ] &lt;- Spec[2, 3, 2, ] &lt;- -0.5
EWS &lt;- as.mvLSW(x = Spec, filter.number = 1, family = "DaubExPhase",
  min.eig.val = NA)

## Sample time series and estimate the EWS.
set.seed(10)
X &lt;- rmvLSW(Spectrum = EWS)
EWS_X &lt;- mvEWS(X, kernel.name = "daniell", kernel.param = 20)

## Evaluate asymptotic spectral variance 
SpecVar &lt;- varEWS(EWS_X)

## Plot Estimate &amp; 95% confidence interval
CI &lt;- ApxCI(object = EWS_X, var = SpecVar, alpha = 0.05)
plot(x = EWS_X, style = 2, info = 2, Interval = CI)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
