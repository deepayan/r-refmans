<!DOCTYPE html><html><head><title>Help for package qs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#base85_decode'><p>Z85 Decoding</p></a></li>
<li><a href='#base85_encode'><p>Z85 Encoding</p></a></li>
<li><a href='#base91_decode'><p>basE91 Decoding</p></a></li>
<li><a href='#base91_encode'><p>basE91 Encoding</p></a></li>
<li><a href='#blosc_shuffle_raw'><p>Shuffle a raw vector</p></a></li>
<li><a href='#blosc_unshuffle_raw'><p>Un-shuffle a raw vector</p></a></li>
<li><a href='#catquo'><p>catquo</p></a></li>
<li><a href='#decode_source'><p>Decode a compressed string</p></a></li>
<li><a href='#encode_source'><p>Encode and compress a file or string</p></a></li>
<li><a href='#get_altrep_class_info'><p>Get the class information of an ALTREP object</p></a></li>
<li><a href='#is_big_endian'><p>System Endianness</p></a></li>
<li><a href='#lz4_compress_bound'><p>lz4 compress bound</p></a></li>
<li><a href='#lz4_compress_raw'><p>lz4 compression</p></a></li>
<li><a href='#lz4_decompress_raw'><p>lz4 decompression</p></a></li>
<li><a href='#qattributes'><p>qattributes</p></a></li>
<li><a href='#qcache'><p>qcache</p></a></li>
<li><a href='#qdeserialize'><p>qdeserialize</p></a></li>
<li><a href='#qdump'><p>qdump</p></a></li>
<li><a href='#qread'><p>qread</p></a></li>
<li><a href='#qread_fd'><p>qread_fd</p></a></li>
<li><a href='#qread_handle'><p>qread_handle</p></a></li>
<li><a href='#qread_ptr'><p>qread_ptr</p></a></li>
<li><a href='#qread_url'><p>qread_url</p></a></li>
<li><a href='#qreadm'><p>qload</p></a></li>
<li><a href='#qs-package'><p>qs: Quick Serialization of R Objects</p></a></li>
<li><a href='#qsave'><p>qsave</p></a></li>
<li><a href='#qsave_fd'><p>qsave_fd</p></a></li>
<li><a href='#qsave_handle'><p>qsave_handle</p></a></li>
<li><a href='#qsavem'><p>qsavem</p></a></li>
<li><a href='#qserialize'><p>qserialize</p></a></li>
<li><a href='#register_altrep_class'><p>Register ALTREP class for serialization</p></a></li>
<li><a href='#starnames'><p>Official list of IAU Star Names</p></a></li>
<li><a href='#unregister_altrep_class'><p>Unegister ALTREP class for serialization</p></a></li>
<li><a href='#zstd_compress_bound'><p>Zstd compress bound</p></a></li>
<li><a href='#zstd_compress_raw'><p>Zstd compression</p></a></li>
<li><a href='#zstd_decompress_raw'><p>Zstd decompression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quick Serialization of R Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.26.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Travers Ching &lt;traversc@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for quickly writing and reading any R object to and from disk.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, RApiSerialize (&ge; 0.1.1), stringfish (&ge; 0.15.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RApiSerialize, stringfish, BH</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, dplyr, data.table</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Copyright:</td>
<td>This package includes code from the 'zstd' library owned by
Facebook, Inc. and created by Yann Collet; the 'lz4' library
created and owned by Yann Collet; xxHash library created and
owned by Yann Collet; and code derived from the 'Blosc' library
created and owned by Francesc Alted.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/traversc/qs">https://github.com/traversc/qs</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/traversc/qs/issues">https://github.com/traversc/qs/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 08:06:36 UTC; tching</td>
</tr>
<tr>
<td>Author:</td>
<td>Travers Ching [aut, cre, cph],
  Yann Collet [ctb, cph] (Yann Collet is the author of the bundled zstd,
    lz4 and xxHash code),
  Facebook, Inc. [cph] (Facebook is the copyright holder of the bundled
    zstd code),
  Reichardt Tino [ctb, cph] (Contributor/copyright holder of zstd bundled
    code),
  Skibinski Przemyslaw [ctb, cph] (Contributor/copyright holder of zstd
    bundled code),
  Mori Yuta [ctb, cph] (Contributor/copyright holder of zstd bundled
    code),
  Romain Francois [ctb, cph] (Derived example/tutorials for ALTREP
    structures),
  Francesc Alted [ctb, cph] (Shuffling routines derived from Blosc
    library),
  Bryce Chamberlain [ctb] (qsavem and qload functions),
  Salim Brüggemann <a href="https://orcid.org/0000-0002-5329-5987"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (documentation)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-09 03:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='base85_decode'>Z85 Decoding</h2><span id='topic+base85_decode'></span>

<h3>Description</h3>

<p>Decodes a Z85 encoded string back to binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base85_decode(encoded_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base85_decode_+3A_encoded_string">encoded_string</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original raw vector.
</p>

<hr>
<h2 id='base85_encode'>Z85 Encoding</h2><span id='topic+base85_encode'></span>

<h3>Description</h3>

<p>Encodes binary data (a raw vector) as ASCII text using <a href="https://rfc.zeromq.org/spec/32/">Z85 encoding format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base85_encode(rawdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base85_encode_+3A_rawdata">rawdata</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Z85 is a binary to ASCII encoding format created by Pieter Hintjens in 2010 and is part of the ZeroMQ RFC.
The encoding has a dictionary using 85 out of 94 printable ASCII characters.
There are other base 85 encoding schemes, including Ascii85, which is popularized and used by Adobe.
Z85 is distinguished by its choice of dictionary, which is suitable for easier inclusion into source code for many programming languages.
The dictionary excludes all quote marks and other control characters, and requires no special treatment in R and most other languages.
Note: although the official specification restricts input length to multiples of four bytes, the implementation here works with any input length.
The overhead (extra bytes used relative to binary) is 25%. In comparison, base 64 encoding has an overhead of 33.33%.
</p>


<h3>Value</h3>

<p>A string representation of the raw vector.
</p>


<h3>References</h3>

<p>https://rfc.zeromq.org/spec/32/
</p>

<hr>
<h2 id='base91_decode'>basE91 Decoding</h2><span id='topic+base91_decode'></span>

<h3>Description</h3>

<p>Decodes a basE91 encoded string back to binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base91_decode(encoded_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base91_decode_+3A_encoded_string">encoded_string</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original raw vector.
</p>

<hr>
<h2 id='base91_encode'>basE91 Encoding</h2><span id='topic+base91_encode'></span>

<h3>Description</h3>

<p>Encodes binary data (a raw vector) as ASCII text using <a href="https://base91.sourceforge.net/">basE91 encoding format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base91_encode(rawdata, quote_character = "\"")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base91_encode_+3A_rawdata">rawdata</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
<tr><td><code id="base91_encode_+3A_quote_character">quote_character</code></td>
<td>
<p>The character to use in the encoding, replacing the double quote character. Must be either a single quote (<code>"'"</code>), a double quote
(<code style="white-space: pre;">&#8288;"\""&#8288;</code>) or a dash (<code>"-"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>basE91 (capital E for stylization) is a binary to ASCII encoding format created by Joachim Henke in 2005.
The overhead (extra bytes used relative to binary) is 22.97% on average. In comparison, base 64 encoding has an overhead of 33.33%.
The original encoding uses a dictionary of 91 out of 94 printable ASCII characters excluding <code>-</code> (dash), <code style="white-space: pre;">&#8288;\&#8288;</code> (backslash) and <code style="white-space: pre;">&#8288;'&#8288;</code> (single quote).
The original encoding does include double quote characters, which are less than ideal for strings in R. Therefore,
you can use the <code>quote_character</code> parameter to substitute dash or single quote.
</p>


<h3>Value</h3>

<p>A string representation of the raw vector.
</p>


<h3>References</h3>

<p>https://base91.sourceforge.net/
</p>

<hr>
<h2 id='blosc_shuffle_raw'>Shuffle a raw vector</h2><span id='topic+blosc_shuffle_raw'></span>

<h3>Description</h3>

<p>Shuffles a raw vector using BLOSC shuffle routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blosc_shuffle_raw(x, bytesofsize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blosc_shuffle_raw_+3A_x">x</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
<tr><td><code id="blosc_shuffle_raw_+3A_bytesofsize">bytesofsize</code></td>
<td>
<p>Either <code>4</code> or <code>8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The shuffled vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- serialize(1L:1000L, NULL)
xshuf &lt;- blosc_shuffle_raw(x, 4)
xunshuf &lt;- blosc_unshuffle_raw(xshuf, 4)
</code></pre>

<hr>
<h2 id='blosc_unshuffle_raw'>Un-shuffle a raw vector</h2><span id='topic+blosc_unshuffle_raw'></span>

<h3>Description</h3>

<p>Un-shuffles a raw vector using BLOSC un-shuffle routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blosc_unshuffle_raw(x, bytesofsize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blosc_unshuffle_raw_+3A_x">x</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
<tr><td><code id="blosc_unshuffle_raw_+3A_bytesofsize">bytesofsize</code></td>
<td>
<p>Either <code>4</code> or <code>8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unshuffled vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- serialize(1L:1000L, NULL)
xshuf &lt;- blosc_shuffle_raw(x, 4)
xunshuf &lt;- blosc_unshuffle_raw(xshuf, 4)
</code></pre>

<hr>
<h2 id='catquo'>catquo</h2><span id='topic+catquo'></span>

<h3>Description</h3>

<p>Prints a string with single quotes on a new line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catquo(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catquo_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="base.html#topic+cat">cat()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='decode_source'>Decode a compressed string</h2><span id='topic+decode_source'></span>

<h3>Description</h3>

<p>A helper function for encoding and compressing a file or string to ASCII using <code><a href="#topic+base91_encode">base91_encode()</a></code> and <code><a href="#topic+qserialize">qserialize()</a></code> with the highest compression level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_source(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_source_+3A_string">string</code></td>
<td>
<p>A string to decode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original (decoded) object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+encode_source">encode_source()</a></code> for more details.
</p>

<hr>
<h2 id='encode_source'>Encode and compress a file or string</h2><span id='topic+encode_source'></span>

<h3>Description</h3>

<p>A helper function for encoding and compressing a file or string to ASCII using <code><a href="#topic+base91_encode">base91_encode()</a></code> and <code><a href="#topic+qserialize">qserialize()</a></code> with the highest compression level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_source(x = NULL, file = NULL, width = 120)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_source_+3A_x">x</code></td>
<td>
<p>The object to encode (if <code>file</code> is not NULL)</p>
</td></tr>
<tr><td><code id="encode_source_+3A_file">file</code></td>
<td>
<p>The file to encode (if <code>x</code> is not NULL)</p>
</td></tr>
<tr><td><code id="encode_source_+3A_width">width</code></td>
<td>
<p>The output will be broken up into individual strings, with <code>width</code> being the longest allowable string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+encode_source">encode_source()</a></code> and <code><a href="#topic+decode_source">decode_source()</a></code> functions are useful for storing small amounts of data or text inline to a .R or .Rmd file.
</p>


<h3>Value</h3>

<p>A character vector in base91 representing the compressed original file or object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1); data &lt;- sample(500)
result &lt;- encode_source(data)
# Note: the result string is not guaranteed to be consistent between qs or zstd versions
#       but will always properly decode regardless
print(result)
result &lt;- decode_source(result) # [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>

<hr>
<h2 id='get_altrep_class_info'>Get the class information of an ALTREP object</h2><span id='topic+get_altrep_class_info'></span>

<h3>Description</h3>

<p>Gets the formal name of the class and package of an ALTREP object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_altrep_class_info(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_altrep_class_info_+3A_obj">obj</code></td>
<td>
<p>The ALTREP class name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The class information (class name and package name) of an ALTREP object, a character vector of length two.
If the object is not an ALTREP object, returns NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_altrep_class_info(1:5)
</code></pre>

<hr>
<h2 id='is_big_endian'>System Endianness</h2><span id='topic+is_big_endian'></span>

<h3>Description</h3>

<p>Tests system endianness. Intel and AMD based systems are little endian, and so this function will likely return <code>FALSE</code>.
The <code>qs</code> package is not capable of transferring data between systems of different endianness. This should not matter for the large majority of use cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_big_endian()
</code></pre>


<h3>Value</h3>

<p><code>TRUE</code> if big endian, <code>FALSE</code> if little endian.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_big_endian() # returns FALSE on Intel/AMD systems
</code></pre>

<hr>
<h2 id='lz4_compress_bound'>lz4 compress bound</h2><span id='topic+lz4_compress_bound'></span>

<h3>Description</h3>

<p>Exports the compress bound function from the lz4 library. Returns the maximum compressed size of an object of length <code>size</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lz4_compress_bound(size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lz4_compress_bound_+3A_size">size</code></td>
<td>
<p>An integer size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum compressed size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lz4_compress_bound(100000)
#' lz4_compress_bound(1e9)
</code></pre>

<hr>
<h2 id='lz4_compress_raw'>lz4 compression</h2><span id='topic+lz4_compress_raw'></span>

<h3>Description</h3>

<p>Compresses to a raw vector using the lz4 algorithm. Exports the main lz4 compression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lz4_compress_raw(x, compress_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lz4_compress_raw_+3A_x">x</code></td>
<td>
<p>The object to serialize.</p>
</td></tr>
<tr><td><code id="lz4_compress_raw_+3A_compress_level">compress_level</code></td>
<td>
<p>The compression level used. A number &gt; 1 (higher is less compressed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The compressed data as a raw vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:1e6
xserialized &lt;- serialize(x, connection=NULL)
xcompressed &lt;- lz4_compress_raw(xserialized, compress_level = 1)
xrecovered &lt;- unserialize(lz4_decompress_raw(xcompressed))
</code></pre>

<hr>
<h2 id='lz4_decompress_raw'>lz4 decompression</h2><span id='topic+lz4_decompress_raw'></span>

<h3>Description</h3>

<p>Decompresses an lz4 compressed raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lz4_decompress_raw(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lz4_decompress_raw_+3A_x">x</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The de-serialized object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:1e6
xserialized &lt;- serialize(x, connection=NULL)
xcompressed &lt;- lz4_compress_raw(xserialized, compress_level = 1)
xrecovered &lt;- unserialize(lz4_decompress_raw(xcompressed))
</code></pre>

<hr>
<h2 id='qattributes'>qattributes</h2><span id='topic+qattributes'></span>

<h3>Description</h3>

<p>Reads the attributes of an object serialized to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qattributes(file, use_alt_rep=FALSE, strict=FALSE, nthreads=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qattributes_+3A_file">file</code></td>
<td>
<p>The file name/path.</p>
</td></tr>
<tr><td><code id="qattributes_+3A_use_alt_rep">use_alt_rep</code></td>
<td>
<p>Use ALTREP when reading in string data (default <code>FALSE</code>). On R versions prior to 3.5.0, this parameter does nothing.</p>
</td></tr>
<tr><td><code id="qattributes_+3A_strict">strict</code></td>
<td>
<p>Whether to throw an error or just report a warning (default: <code>FALSE</code>, i.e. report warning).</p>
</td></tr>
<tr><td><code id="qattributes_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use. Default <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equivalent to:
</p>
<p><code>attributes(qread(file))</code>
</p>
<p>But more efficient. Attributes are stored towards the end of the file.
This function will read through
the contents of the file (without de-serializing the object itself),
and then de-serializes the attributes only.
</p>
<p>Because it is necessary to read through the file, pulling out attributes could
take a long time if the file is large. However, it should be much faster than
de-serializing the entire object first.
</p>


<h3>Value</h3>

<p>the attributes fo the serialized object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file &lt;- tempfile()
qsave(mtcars, file)

attr1 &lt;- qattributes(file)
attr2 &lt;- attributes(qread(file))

print(attr1)
# $names
# [1] "IAU Name"      "Designation"   "Const." ...

# $row.names
# [1] 1 2 3 4 5
# $class
# [1] "data.frame"

identical(attr1, attr2) # TRUE

</code></pre>

<hr>
<h2 id='qcache'>qcache</h2><span id='topic+qcache'></span>

<h3>Description</h3>

<p>Helper function for caching objects for long running tasks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcache(
  expr,
  name,
  envir = parent.frame(),
  cache_dir = ".cache",
  clear = FALSE,
  prompt = TRUE,
  qsave_params = list(),
  qread_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qcache_+3A_expr">expr</code></td>
<td>
<p>The expression to evaluate.</p>
</td></tr>
<tr><td><code id="qcache_+3A_name">name</code></td>
<td>
<p>The cached expression name (see details).</p>
</td></tr>
<tr><td><code id="qcache_+3A_envir">envir</code></td>
<td>
<p>The environment to evaluate <code>expr</code> in.</p>
</td></tr>
<tr><td><code id="qcache_+3A_cache_dir">cache_dir</code></td>
<td>
<p>The directory to store cached files in.</p>
</td></tr>
<tr><td><code id="qcache_+3A_clear">clear</code></td>
<td>
<p>Set to <code>TRUE</code> to clear the cache (see details).</p>
</td></tr>
<tr><td><code id="qcache_+3A_prompt">prompt</code></td>
<td>
<p>Whether to prompt before clearing.</p>
</td></tr>
<tr><td><code id="qcache_+3A_qsave_params">qsave_params</code></td>
<td>
<p>Parameters passed on to <code>qsave</code>.</p>
</td></tr>
<tr><td><code id="qcache_+3A_qread_params">qread_params</code></td>
<td>
<p>Parameters passed on to <code>qread</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a (very) simple helper function to cache results of long running calculations. There are other packages specializing
in caching data that are more feature complete.
</p>
<p>The evaluated expression is saved with <code><a href="#topic+qsave">qsave()</a></code> in <code style="white-space: pre;">&#8288;&lt;cache_dir&gt;/&lt;name&gt;.qs&#8288;</code>.
If the file already exists instead, the expression is not evaluated and the cached result is read using <code><a href="#topic+qread">qread()</a></code> and returned.
</p>
<p>To clear a cached result, you can manually delete the associated <code>.qs</code> file, or you can call <code><a href="#topic+qcache">qcache()</a></code> with <code>clear = TRUE</code>.
If <code>prompt</code> is also <code>TRUE</code> a prompt will be given asking you to confirm deletion.
If <code>name</code> is not specified, all cached results in <code>cache_dir</code> will be removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cache_dir &lt;- tempdir()

a &lt;- 1
b &lt;- 5

# not cached
result &lt;- qcache({a + b},
                 name="aplusb",
                 cache_dir = cache_dir,
                 qsave_params = list(preset="fast"))

# cached
result &lt;- qcache({a + b},
                 name="aplusb",
                 cache_dir = cache_dir,
                 qsave_params = list(preset="fast"))

# clear cached result
qcache(name="aplusb", clear=TRUE, prompt=FALSE, cache_dir = cache_dir)
</code></pre>

<hr>
<h2 id='qdeserialize'>qdeserialize</h2><span id='topic+qdeserialize'></span>

<h3>Description</h3>

<p>Reads an object from a raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdeserialize(x, use_alt_rep=FALSE, strict=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdeserialize_+3A_x">x</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
<tr><td><code id="qdeserialize_+3A_use_alt_rep">use_alt_rep</code></td>
<td>
<p>Use ALTREP when reading in string data (default <code>FALSE</code>). On R versions prior to 3.5.0, this parameter does nothing.</p>
</td></tr>
<tr><td><code id="qdeserialize_+3A_strict">strict</code></td>
<td>
<p>Whether to throw an error or just report a warning (default: <code>FALSE</code>, i.e. report warning).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+qserialize">qserialize()</a></code> for additional details and examples.
</p>


<h3>Value</h3>

<p>The de-serialized object.
</p>

<hr>
<h2 id='qdump'>qdump</h2><span id='topic+qdump'></span>

<h3>Description</h3>

<p>Exports the uncompressed binary serialization to a list of raw vectors. For testing purposes and exploratory purposes mainly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdump(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdump_+3A_file">file</code></td>
<td>
<p>A file name/path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The uncompressed serialization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
        num = rnorm(1e3),
        char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
        stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qsave(x, myfile)
x2 &lt;- qdump(myfile)
</code></pre>

<hr>
<h2 id='qread'>qread</h2><span id='topic+qread'></span>

<h3>Description</h3>

<p>Reads an object in a file serialized to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qread(file, use_alt_rep=FALSE, strict=FALSE, nthreads=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qread_+3A_file">file</code></td>
<td>
<p>The file name/path.</p>
</td></tr>
<tr><td><code id="qread_+3A_use_alt_rep">use_alt_rep</code></td>
<td>
<p>Use ALTREP when reading in string data (default <code>FALSE</code>). On R versions prior to 3.5.0, this parameter does nothing.</p>
</td></tr>
<tr><td><code id="qread_+3A_strict">strict</code></td>
<td>
<p>Whether to throw an error or just report a warning (default: <code>FALSE</code>, i.e. report warning).</p>
</td></tr>
<tr><td><code id="qread_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use. Default <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The de-serialized object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
        num = rnorm(1e3),
        char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
        stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qsave(x, myfile)
x2 &lt;- qread(myfile)
identical(x, x2) # returns true

# qs support multithreading
qsave(x, myfile, nthreads=2)
x2 &lt;- qread(myfile, nthreads=2)
identical(x, x2) # returns true

# Other examples
z &lt;- 1:1e7
myfile &lt;- tempfile()
qsave(z, myfile)
z2 &lt;- qread(myfile)
identical(z, z2) # returns true

w &lt;- as.list(rnorm(1e6))
myfile &lt;- tempfile()
qsave(w, myfile)
w2 &lt;- qread(myfile)
identical(w, w2) # returns true
</code></pre>

<hr>
<h2 id='qread_fd'>qread_fd</h2><span id='topic+qread_fd'></span>

<h3>Description</h3>

<p>Reads an object from a file descriptor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qread_fd(fd, use_alt_rep=FALSE, strict=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qread_fd_+3A_fd">fd</code></td>
<td>
<p>A file descriptor.</p>
</td></tr>
<tr><td><code id="qread_fd_+3A_use_alt_rep">use_alt_rep</code></td>
<td>
<p>Use ALTREP when reading in string data (default <code>FALSE</code>). On R versions prior to 3.5.0, this parameter does nothing.</p>
</td></tr>
<tr><td><code id="qread_fd_+3A_strict">strict</code></td>
<td>
<p>Whether to throw an error or just report a warning (default: <code>FALSE</code>, i.e. report warning).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+qsave_fd">qsave_fd()</a></code> for additional details and examples.
</p>


<h3>Value</h3>

<p>The de-serialized object.
</p>

<hr>
<h2 id='qread_handle'>qread_handle</h2><span id='topic+qread_handle'></span>

<h3>Description</h3>

<p>Reads an object from a windows handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qread_handle(handle, use_alt_rep=FALSE, strict=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qread_handle_+3A_handle">handle</code></td>
<td>
<p>A windows handle external pointer.</p>
</td></tr>
<tr><td><code id="qread_handle_+3A_use_alt_rep">use_alt_rep</code></td>
<td>
<p>Use ALTREP when reading in string data (default <code>FALSE</code>). On R versions prior to 3.5.0, this parameter does nothing.</p>
</td></tr>
<tr><td><code id="qread_handle_+3A_strict">strict</code></td>
<td>
<p>Whether to throw an error or just report a warning (default: <code>FALSE</code>, i.e. report warning).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+qsave_handle">qsave_handle()</a></code> for additional details and examples.
</p>


<h3>Value</h3>

<p>The de-serialized object.
</p>

<hr>
<h2 id='qread_ptr'>qread_ptr</h2><span id='topic+qread_ptr'></span>

<h3>Description</h3>

<p>Reads an object from an external pointer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qread_ptr(pointer, length, use_alt_rep=FALSE, strict=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qread_ptr_+3A_pointer">pointer</code></td>
<td>
<p>An external pointer to memory.</p>
</td></tr>
<tr><td><code id="qread_ptr_+3A_length">length</code></td>
<td>
<p>The length of the object in memory.</p>
</td></tr>
<tr><td><code id="qread_ptr_+3A_use_alt_rep">use_alt_rep</code></td>
<td>
<p>Use ALTREP when reading in string data (default <code>FALSE</code>). On R versions prior to 3.5.0, this parameter does nothing.</p>
</td></tr>
<tr><td><code id="qread_ptr_+3A_strict">strict</code></td>
<td>
<p>Whether to throw an error or just report a warning (default: <code>FALSE</code>, i.e. report warning).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The de-serialized object.
</p>

<hr>
<h2 id='qread_url'>qread_url</h2><span id='topic+qread_url'></span>

<h3>Description</h3>

<p>A helper function that reads data from the internet to memory and deserializes the object with <code><a href="#topic+qdeserialize">qdeserialize()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qread_url(url, buffer_size, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qread_url_+3A_url">url</code></td>
<td>
<p>The URL where the object is stored</p>
</td></tr>
<tr><td><code id="qread_url_+3A_buffer_size">buffer_size</code></td>
<td>
<p>The buffer size used to read in data (default <code>16777216L</code> i.e. 16 MB)</p>
</td></tr>
<tr><td><code id="qread_url_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+qdeserialize">qdeserialize()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+qdeserialize">qdeserialize()</a></code> for additional details.
</p>


<h3>Value</h3>

<p>The de-serialized object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- qread_url("http://example_url.com/my_file.qs")

## End(Not run)
</code></pre>

<hr>
<h2 id='qreadm'>qload</h2><span id='topic+qreadm'></span><span id='topic+qload'></span>

<h3>Description</h3>

<p>Reads an object in a file serialized to disk using <code><a href="#topic+qsavem">qsavem()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qreadm(file, env = parent.frame(), ...)

qload(file, env = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qreadm_+3A_file">file</code></td>
<td>
<p>The file name/path.</p>
</td></tr>
<tr><td><code id="qreadm_+3A_env">env</code></td>
<td>
<p>The environment where the data should be loaded.</p>
</td></tr>
<tr><td><code id="qreadm_+3A_...">...</code></td>
<td>
<p>additional arguments will be passed to qread.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends qread to replicate the functionality of <code><a href="base.html#topic+load">base::load()</a></code> to load multiple saved objects into your workspace. <code>qload</code> and <code>qreadm</code> are alias of the same function.
</p>


<h3>Value</h3>

<p>Nothing is explicitly returned, but the function will load the saved objects into the workspace.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- data.frame(int = sample(1e3, replace=TRUE),
                 num = rnorm(1e3),
                 char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
                 stringsAsFactors = FALSE)
x2 &lt;- data.frame(int = sample(1e3, replace=TRUE),
                 num = rnorm(1e3),
                 char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
                 stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qsavem(x1, x2, file=myfile)
rm(x1, x2)
qload(myfile)
exists('x1') &amp;&amp; exists('x2') # returns true

# qs support multithreading
qsavem(x1, x2, file=myfile, nthreads=2)
rm(x1, x2)
qload(myfile, nthreads=2)
exists('x1') &amp;&amp; exists('x2') # returns true
</code></pre>

<hr>
<h2 id='qs-package'>qs: Quick Serialization of R Objects</h2><span id='topic+qs'></span><span id='topic+qs-package'></span>

<h3>Description</h3>

<p>Provides functions for quickly writing and reading any R object to and from disk.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Travers Ching <a href="mailto:traversc@gmail.com">traversc@gmail.com</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Yann Collet (Yann Collet is the author of the bundled zstd, lz4 and xxHash code) [contributor, copyright holder]
</p>
</li>
<li><p> Facebook, Inc. (Facebook is the copyright holder of the bundled zstd code) [copyright holder]
</p>
</li>
<li><p> Reichardt Tino (Contributor/copyright holder of zstd bundled code) [contributor, copyright holder]
</p>
</li>
<li><p> Skibinski Przemyslaw (Contributor/copyright holder of zstd bundled code) [contributor, copyright holder]
</p>
</li>
<li><p> Mori Yuta (Contributor/copyright holder of zstd bundled code) [contributor, copyright holder]
</p>
</li>
<li><p> Romain Francois (Derived example/tutorials for ALTREP structures) [contributor, copyright holder]
</p>
</li>
<li><p> Francesc Alted (Shuffling routines derived from Blosc library) [contributor, copyright holder]
</p>
</li>
<li><p> Bryce Chamberlain <a href="mailto:superchordate@gmail.com">superchordate@gmail.com</a> (qsavem and qload functions) [contributor]
</p>
</li>
<li><p> Salim Brüggemann <a href="mailto:salim-b@pm.me">salim-b@pm.me</a> (<a href="https://orcid.org/0000-0002-5329-5987">ORCID</a>) (documentation) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/traversc/qs">https://github.com/traversc/qs</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/traversc/qs/issues">https://github.com/traversc/qs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='qsave'>qsave</h2><span id='topic+qsave'></span>

<h3>Description</h3>

<p>Saves (serializes) an object to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsave(x, file,
preset = "high", algorithm = "zstd", compress_level = 4L,
shuffle_control = 15L, check_hash=TRUE, nthreads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsave_+3A_x">x</code></td>
<td>
<p>The object to serialize.</p>
</td></tr>
<tr><td><code id="qsave_+3A_file">file</code></td>
<td>
<p>The file name/path.</p>
</td></tr>
<tr><td><code id="qsave_+3A_preset">preset</code></td>
<td>
<p>One of <code>"fast"</code>, <code>"balanced"</code>, <code>"high"</code> (default), <code>"archive"</code>, <code>"uncompressed"</code> or <code>"custom"</code>. See section <em>Presets</em> for details.</p>
</td></tr>
<tr><td><code id="qsave_+3A_algorithm">algorithm</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> Compression algorithm used: <code>"lz4"</code>, <code>"zstd"</code>, <code>"lz4hc"</code>, <code>"zstd_stream"</code> or <code>"uncompressed"</code>.</p>
</td></tr>
<tr><td><code id="qsave_+3A_compress_level">compress_level</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> The compression level used.
</p>
<p>For lz4, this number must be &gt; 1 (higher is less compressed).
</p>
<p>For zstd, a number  between <code>-50</code> to <code>22</code> (higher is more compressed). Due to the format of qs, there is very little benefit to compression levels &gt; 5
or so.</p>
</td></tr>
<tr><td><code id="qsave_+3A_shuffle_control">shuffle_control</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> An integer setting the use of byte shuffle compression. A value between <code>0</code> and <code>15</code>
(default <code>15</code>). See section <em>Byte shuffling</em> for details.</p>
</td></tr>
<tr><td><code id="qsave_+3A_check_hash">check_hash</code></td>
<td>
<p>Default <code>TRUE</code>, compute a hash which can be used to verify file integrity during serialization.</p>
</td></tr>
<tr><td><code id="qsave_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use. Default <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serializes and compresses R objects using block compression with the option of byte shuffling.
</p>


<h3>Value</h3>

<p>The total number of bytes written to the file (returned invisibly).
</p>


<h3>Presets</h3>

<p>There are lots of possible parameters. To simplify usage, there are four main presets that are performant over a large variety of data:
</p>

<ul>
<li> <p><strong><code>"fast"</code></strong> is a shortcut for <code>algorithm = "lz4"</code>, <code>compress_level = 100</code> and <code>shuffle_control = 0</code>.
</p>
</li>
<li> <p><strong><code>"balanced"</code></strong> is a shortcut for <code>algorithm = "lz4"</code>, <code>compress_level = 1</code> and <code>shuffle_control = 15</code>.
</p>
</li>
<li> <p><strong><code>"high"</code></strong> is a shortcut for <code>algorithm = "zstd"</code>, <code>compress_level = 4</code> and <code>shuffle_control = 15</code>.
</p>
</li>
<li> <p><strong><code>"archive"</code></strong> is a shortcut for <code>algorithm = "zstd_stream"</code>, <code>compress_level = 14</code> and <code>shuffle_control = 15</code>. (<code>zstd_stream</code> is currently
single-threaded only)
</p>
</li></ul>

<p>To gain more control over compression level and byte shuffling, set <code>preset = "custom"</code>, in which case the individual parameters <code>algorithm</code>,
<code>compress_level</code> and <code>shuffle_control</code> are actually regarded.
</p>


<h3>Byte shuffling</h3>

<p>The parameter <code>shuffle_control</code> defines which numerical R object types are subject to <em>byte shuffling</em>. Generally speaking, the more ordered/sequential an
object is (e.g., <code>1:1e7</code>), the larger the potential benefit of byte shuffling. It is not uncommon to improve compression ratio or compression speed by
several orders of magnitude. The more random an object is (e.g., <code>rnorm(1e7)</code>), the less potential benefit there is, even negative benefit is possible.
Integer vectors almost always benefit from byte shuffling, whereas the results for numeric vectors are mixed. To control block shuffling, add +1 to the
parameter for logical vectors, +2 for integer vectors, +4 for numeric vectors and/or +8 for complex vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
        num = rnorm(1e3),
        char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qsave(x, myfile)
x2 &lt;- qread(myfile)
identical(x, x2) # returns true

# qs support multithreading
qsave(x, myfile, nthreads=2)
x2 &lt;- qread(myfile, nthreads=2)
identical(x, x2) # returns true

# Other examples
z &lt;- 1:1e7
myfile &lt;- tempfile()
qsave(z, myfile)
z2 &lt;- qread(myfile)
identical(z, z2) # returns true

w &lt;- as.list(rnorm(1e6))
myfile &lt;- tempfile()
qsave(w, myfile)
w2 &lt;- qread(myfile)
identical(w, w2) # returns true
</code></pre>

<hr>
<h2 id='qsave_fd'>qsave_fd</h2><span id='topic+qsave_fd'></span>

<h3>Description</h3>

<p>Saves an object to a file descriptor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsave_fd(x, fd,
preset = "high", algorithm = "zstd", compress_level = 4L,
shuffle_control = 15L, check_hash=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsave_fd_+3A_x">x</code></td>
<td>
<p>The object to serialize.</p>
</td></tr>
<tr><td><code id="qsave_fd_+3A_fd">fd</code></td>
<td>
<p>A file descriptor.</p>
</td></tr>
<tr><td><code id="qsave_fd_+3A_preset">preset</code></td>
<td>
<p>One of <code>"fast"</code>, <code>"balanced"</code>, <code>"high"</code> (default), <code>"archive"</code>, <code>"uncompressed"</code> or <code>"custom"</code>. See section <em>Presets</em> for details.</p>
</td></tr>
<tr><td><code id="qsave_fd_+3A_algorithm">algorithm</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> Compression algorithm used: <code>"lz4"</code>, <code>"zstd"</code>, <code>"lz4hc"</code>, <code>"zstd_stream"</code> or <code>"uncompressed"</code>.</p>
</td></tr>
<tr><td><code id="qsave_fd_+3A_compress_level">compress_level</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> The compression level used.
</p>
<p>For lz4, this number must be &gt; 1 (higher is less compressed).
</p>
<p>For zstd, a number  between <code>-50</code> to <code>22</code> (higher is more compressed). Due to the format of qs, there is very little benefit to compression levels &gt; 5
or so.</p>
</td></tr>
<tr><td><code id="qsave_fd_+3A_shuffle_control">shuffle_control</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> An integer setting the use of byte shuffle compression. A value between <code>0</code> and <code>15</code>
(default <code>15</code>). See section <em>Byte shuffling</em> for details.</p>
</td></tr>
<tr><td><code id="qsave_fd_+3A_check_hash">check_hash</code></td>
<td>
<p>Default <code>TRUE</code>, compute a hash which can be used to verify file integrity during serialization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serializes and compresses R objects using block compression with the option of byte shuffling.
</p>


<h3>Value</h3>

<p>The total number of bytes written to the file (returned invisibly).
</p>


<h3>Presets</h3>

<p>There are lots of possible parameters. To simplify usage, there are four main presets that are performant over a large variety of data:
</p>

<ul>
<li> <p><strong><code>"fast"</code></strong> is a shortcut for <code>algorithm = "lz4"</code>, <code>compress_level = 100</code> and <code>shuffle_control = 0</code>.
</p>
</li>
<li> <p><strong><code>"balanced"</code></strong> is a shortcut for <code>algorithm = "lz4"</code>, <code>compress_level = 1</code> and <code>shuffle_control = 15</code>.
</p>
</li>
<li> <p><strong><code>"high"</code></strong> is a shortcut for <code>algorithm = "zstd"</code>, <code>compress_level = 4</code> and <code>shuffle_control = 15</code>.
</p>
</li>
<li> <p><strong><code>"archive"</code></strong> is a shortcut for <code>algorithm = "zstd_stream"</code>, <code>compress_level = 14</code> and <code>shuffle_control = 15</code>. (<code>zstd_stream</code> is currently
single-threaded only)
</p>
</li></ul>

<p>To gain more control over compression level and byte shuffling, set <code>preset = "custom"</code>, in which case the individual parameters <code>algorithm</code>,
<code>compress_level</code> and <code>shuffle_control</code> are actually regarded.
</p>


<h3>Byte shuffling</h3>

<p>The parameter <code>shuffle_control</code> defines which numerical R object types are subject to <em>byte shuffling</em>. Generally speaking, the more ordered/sequential an
object is (e.g., <code>1:1e7</code>), the larger the potential benefit of byte shuffling. It is not uncommon to improve compression ratio or compression speed by
several orders of magnitude. The more random an object is (e.g., <code>rnorm(1e7)</code>), the less potential benefit there is, even negative benefit is possible.
Integer vectors almost always benefit from byte shuffling, whereas the results for numeric vectors are mixed. To control block shuffling, add +1 to the
parameter for logical vectors, +2 for integer vectors, +4 for numeric vectors and/or +8 for complex vectors.
</p>

<hr>
<h2 id='qsave_handle'>qsave_handle</h2><span id='topic+qsave_handle'></span>

<h3>Description</h3>

<p>Saves an object to a windows handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsave_handle(x, handle,
preset = "high", algorithm = "zstd", compress_level = 4L,
shuffle_control = 15L, check_hash=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsave_handle_+3A_x">x</code></td>
<td>
<p>The object to serialize.</p>
</td></tr>
<tr><td><code id="qsave_handle_+3A_handle">handle</code></td>
<td>
<p>A windows handle external pointer.</p>
</td></tr>
<tr><td><code id="qsave_handle_+3A_preset">preset</code></td>
<td>
<p>One of <code>"fast"</code>, <code>"balanced"</code>, <code>"high"</code> (default), <code>"archive"</code>, <code>"uncompressed"</code> or <code>"custom"</code>. See section <em>Presets</em> for details.</p>
</td></tr>
<tr><td><code id="qsave_handle_+3A_algorithm">algorithm</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> Compression algorithm used: <code>"lz4"</code>, <code>"zstd"</code>, <code>"lz4hc"</code>, <code>"zstd_stream"</code> or <code>"uncompressed"</code>.</p>
</td></tr>
<tr><td><code id="qsave_handle_+3A_compress_level">compress_level</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> The compression level used.
</p>
<p>For lz4, this number must be &gt; 1 (higher is less compressed).
</p>
<p>For zstd, a number  between <code>-50</code> to <code>22</code> (higher is more compressed). Due to the format of qs, there is very little benefit to compression levels &gt; 5
or so.</p>
</td></tr>
<tr><td><code id="qsave_handle_+3A_shuffle_control">shuffle_control</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> An integer setting the use of byte shuffle compression. A value between <code>0</code> and <code>15</code>
(default <code>15</code>). See section <em>Byte shuffling</em> for details.</p>
</td></tr>
<tr><td><code id="qsave_handle_+3A_check_hash">check_hash</code></td>
<td>
<p>Default <code>TRUE</code>, compute a hash which can be used to verify file integrity during serialization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serializes and compresses R objects using block compression with the option of byte shuffling.
</p>


<h3>Value</h3>

<p>The total number of bytes written to the file (returned invisibly).
</p>


<h3>Presets</h3>

<p>There are lots of possible parameters. To simplify usage, there are four main presets that are performant over a large variety of data:
</p>

<ul>
<li> <p><strong><code>"fast"</code></strong> is a shortcut for <code>algorithm = "lz4"</code>, <code>compress_level = 100</code> and <code>shuffle_control = 0</code>.
</p>
</li>
<li> <p><strong><code>"balanced"</code></strong> is a shortcut for <code>algorithm = "lz4"</code>, <code>compress_level = 1</code> and <code>shuffle_control = 15</code>.
</p>
</li>
<li> <p><strong><code>"high"</code></strong> is a shortcut for <code>algorithm = "zstd"</code>, <code>compress_level = 4</code> and <code>shuffle_control = 15</code>.
</p>
</li>
<li> <p><strong><code>"archive"</code></strong> is a shortcut for <code>algorithm = "zstd_stream"</code>, <code>compress_level = 14</code> and <code>shuffle_control = 15</code>. (<code>zstd_stream</code> is currently
single-threaded only)
</p>
</li></ul>

<p>To gain more control over compression level and byte shuffling, set <code>preset = "custom"</code>, in which case the individual parameters <code>algorithm</code>,
<code>compress_level</code> and <code>shuffle_control</code> are actually regarded.
</p>


<h3>Byte shuffling</h3>

<p>The parameter <code>shuffle_control</code> defines which numerical R object types are subject to <em>byte shuffling</em>. Generally speaking, the more ordered/sequential an
object is (e.g., <code>1:1e7</code>), the larger the potential benefit of byte shuffling. It is not uncommon to improve compression ratio or compression speed by
several orders of magnitude. The more random an object is (e.g., <code>rnorm(1e7)</code>), the less potential benefit there is, even negative benefit is possible.
Integer vectors almost always benefit from byte shuffling, whereas the results for numeric vectors are mixed. To control block shuffling, add +1 to the
parameter for logical vectors, +2 for integer vectors, +4 for numeric vectors and/or +8 for complex vectors.
</p>

<hr>
<h2 id='qsavem'>qsavem</h2><span id='topic+qsavem'></span>

<h3>Description</h3>

<p>Saves (serializes) multiple objects to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsavem(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsavem_+3A_...">...</code></td>
<td>
<p>Objects to serialize. Named arguments will be passed to <code><a href="#topic+qsave">qsave()</a></code> during saving. Un-named arguments will be saved. A named <code>file</code> argument is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends <code><a href="#topic+qsave">qsave()</a></code> to replicate the functionality of <code><a href="base.html#topic+save">base::save()</a></code> to save multiple objects. Read them back with <code><a href="#topic+qload">qload()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- data.frame(int = sample(1e3, replace=TRUE),
                 num = rnorm(1e3),
                 char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
                 stringsAsFactors = FALSE)
x2 &lt;- data.frame(int = sample(1e3, replace=TRUE),
                 num = rnorm(1e3),
                 char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
                 stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qsavem(x1, x2, file=myfile)
rm(x1, x2)
qload(myfile)
exists('x1') &amp;&amp; exists('x2') # returns true

# qs support multithreading
qsavem(x1, x2, file=myfile, nthreads=2)
rm(x1, x2)
qload(myfile, nthreads=2)
exists('x1') &amp;&amp; exists('x2') # returns true
</code></pre>

<hr>
<h2 id='qserialize'>qserialize</h2><span id='topic+qserialize'></span>

<h3>Description</h3>

<p>Saves an object to a raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qserialize(x, preset = "high",
algorithm = "zstd", compress_level = 4L,
shuffle_control = 15L, check_hash=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qserialize_+3A_x">x</code></td>
<td>
<p>The object to serialize.</p>
</td></tr>
<tr><td><code id="qserialize_+3A_preset">preset</code></td>
<td>
<p>One of <code>"fast"</code>, <code>"balanced"</code>, <code>"high"</code> (default), <code>"archive"</code>, <code>"uncompressed"</code> or <code>"custom"</code>. See section <em>Presets</em> for details.</p>
</td></tr>
<tr><td><code id="qserialize_+3A_algorithm">algorithm</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> Compression algorithm used: <code>"lz4"</code>, <code>"zstd"</code>, <code>"lz4hc"</code>, <code>"zstd_stream"</code> or <code>"uncompressed"</code>.</p>
</td></tr>
<tr><td><code id="qserialize_+3A_compress_level">compress_level</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> The compression level used.
</p>
<p>For lz4, this number must be &gt; 1 (higher is less compressed).
</p>
<p>For zstd, a number  between <code>-50</code> to <code>22</code> (higher is more compressed). Due to the format of qs, there is very little benefit to compression levels &gt; 5
or so.</p>
</td></tr>
<tr><td><code id="qserialize_+3A_shuffle_control">shuffle_control</code></td>
<td>
<p><strong>Ignored unless <code>preset = "custom"</code>.</strong> An integer setting the use of byte shuffle compression. A value between <code>0</code> and <code>15</code>
(default <code>15</code>). See section <em>Byte shuffling</em> for details.</p>
</td></tr>
<tr><td><code id="qserialize_+3A_check_hash">check_hash</code></td>
<td>
<p>Default <code>TRUE</code>, compute a hash which can be used to verify file integrity during serialization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serializes and compresses R objects using block compression with the option of byte shuffling.
</p>


<h3>Value</h3>

<p>A raw vector.
</p>


<h3>Presets</h3>

<p>There are lots of possible parameters. To simplify usage, there are four main presets that are performant over a large variety of data:
</p>

<ul>
<li> <p><strong><code>"fast"</code></strong> is a shortcut for <code>algorithm = "lz4"</code>, <code>compress_level = 100</code> and <code>shuffle_control = 0</code>.
</p>
</li>
<li> <p><strong><code>"balanced"</code></strong> is a shortcut for <code>algorithm = "lz4"</code>, <code>compress_level = 1</code> and <code>shuffle_control = 15</code>.
</p>
</li>
<li> <p><strong><code>"high"</code></strong> is a shortcut for <code>algorithm = "zstd"</code>, <code>compress_level = 4</code> and <code>shuffle_control = 15</code>.
</p>
</li>
<li> <p><strong><code>"archive"</code></strong> is a shortcut for <code>algorithm = "zstd_stream"</code>, <code>compress_level = 14</code> and <code>shuffle_control = 15</code>. (<code>zstd_stream</code> is currently
single-threaded only)
</p>
</li></ul>

<p>To gain more control over compression level and byte shuffling, set <code>preset = "custom"</code>, in which case the individual parameters <code>algorithm</code>,
<code>compress_level</code> and <code>shuffle_control</code> are actually regarded.
</p>


<h3>Byte shuffling</h3>

<p>The parameter <code>shuffle_control</code> defines which numerical R object types are subject to <em>byte shuffling</em>. Generally speaking, the more ordered/sequential an
object is (e.g., <code>1:1e7</code>), the larger the potential benefit of byte shuffling. It is not uncommon to improve compression ratio or compression speed by
several orders of magnitude. The more random an object is (e.g., <code>rnorm(1e7)</code>), the less potential benefit there is, even negative benefit is possible.
Integer vectors almost always benefit from byte shuffling, whereas the results for numeric vectors are mixed. To control block shuffling, add +1 to the
parameter for logical vectors, +2 for integer vectors, +4 for numeric vectors and/or +8 for complex vectors.
</p>

<hr>
<h2 id='register_altrep_class'>Register ALTREP class for serialization</h2><span id='topic+register_altrep_class'></span>

<h3>Description</h3>

<p>Register an ALTREP class to serialize using base R serialization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_altrep_class(classname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_altrep_class_+3A_classname">classname</code></td>
<td>
<p>The ALTREP class name</p>
</td></tr>
<tr><td><code id="register_altrep_class_+3A_pkgname">pkgname</code></td>
<td>
<p>The package the ALTREP class comes from</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>register_altrep_class("compact_intseq", "base")
</code></pre>

<hr>
<h2 id='starnames'>Official list of IAU Star Names</h2><span id='topic+starnames'></span>

<h3>Description</h3>

<p>Data from the International Astronomical Union.
An official list of the 336 internationally recognized named stars,
updated as of June 1, 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(starnames)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with official IAU star names and several properties, such as coordinates.
</p>


<h3>Source</h3>

<p><a href="https://www.iau.org/public/themes/naming_stars/">Naming Stars | International Astronomical Union.</a>
</p>


<h3>References</h3>

<p>E Mamajek et. al. (2018),
<em>WG Triennial Report (2015-2018) - Star Names</em>, Reports on Astronomy, 22 Mar 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(starnames)
</code></pre>

<hr>
<h2 id='unregister_altrep_class'>Unegister ALTREP class for serialization</h2><span id='topic+unregister_altrep_class'></span>

<h3>Description</h3>

<p>Unegister an ALTREP class to not use base R serialization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unregister_altrep_class(classname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unregister_altrep_class_+3A_classname">classname</code></td>
<td>
<p>The ALTREP class name</p>
</td></tr>
<tr><td><code id="unregister_altrep_class_+3A_pkgname">pkgname</code></td>
<td>
<p>The package the ALTREP class comes from</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>unregister_altrep_class("compact_intseq", "base")
</code></pre>

<hr>
<h2 id='zstd_compress_bound'>Zstd compress bound</h2><span id='topic+zstd_compress_bound'></span>

<h3>Description</h3>

<p>Exports the compress bound function from the zstd library. Returns the maximum compressed size of an object of length <code>size</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zstd_compress_bound(size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zstd_compress_bound_+3A_size">size</code></td>
<td>
<p>An integer size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>maximum compressed size
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zstd_compress_bound(100000)
zstd_compress_bound(1e9)
</code></pre>

<hr>
<h2 id='zstd_compress_raw'>Zstd compression</h2><span id='topic+zstd_compress_raw'></span>

<h3>Description</h3>

<p>Compresses to a raw vector using the zstd algorithm. Exports the main zstd compression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zstd_compress_raw(x, compress_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zstd_compress_raw_+3A_x">x</code></td>
<td>
<p>The object to serialize.</p>
</td></tr>
<tr><td><code id="zstd_compress_raw_+3A_compress_level">compress_level</code></td>
<td>
<p>The compression level used (default <code>4</code>). A number between <code>-50</code> to <code>22</code> (higher is more compressed). Due to the format of qs, there is
very little benefit to compression levels &gt; 5 or so.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The compressed data as a raw vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:1e6
xserialized &lt;- serialize(x, connection=NULL)
xcompressed &lt;- zstd_compress_raw(xserialized, compress_level = 1)
xrecovered &lt;- unserialize(zstd_decompress_raw(xcompressed))
</code></pre>

<hr>
<h2 id='zstd_decompress_raw'>Zstd decompression</h2><span id='topic+zstd_decompress_raw'></span>

<h3>Description</h3>

<p>Decompresses a zstd compressed raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zstd_decompress_raw(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zstd_decompress_raw_+3A_x">x</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The de-serialized object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:1e6
xserialized &lt;- serialize(x, connection=NULL)
xcompressed &lt;- zstd_compress_raw(xserialized, compress_level = 1)
xrecovered &lt;- unserialize(zstd_decompress_raw(xcompressed))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
