<!DOCTYPE html><html><head><title>Help for package gesso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gesso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#data.gen'>
<p>Data Generation</p></a></li>
<li><a href='#gesso-package'>
<p>Hierarchical GxE Interactions in a Regularized Regression Model</p></a></li>
<li><a href='#gesso.coef'>
<p>Get model coefficients</p></a></li>
<li><a href='#gesso.coefnum'>
<p>Get model coefficients with specified number of non-zero interactions</p></a></li>
<li><a href='#gesso.cv'>
<p>Cross-Validation</p></a></li>
<li><a href='#gesso.fit'>
<p>gesso fit</p></a></li>
<li><a href='#gesso.predict'>
<p>Predict new outcome vector</p></a></li>
<li><a href='#selection.metrics'>
<p>Selection metrics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical GxE Interactions in a Regularized Regression Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Natalia Zemlianskaia</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Natalia Zemlianskaia &lt;natasha.zemlianskaia@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The method focuses on a single environmental exposure and induces 
    a main-effect-before-interaction hierarchical structure for the joint selection of interaction terms 
    in a regularized regression model. For details see Zemlianskaia et al. (2021) &lt;<a href="https://arxiv.org/abs/2103.13510">arXiv:2103.13510</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.3), Matrix, bigmemory, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>dplyr, R (&ge; 3.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glmnet, testthat, knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, RcppThread, BH, bigmemory</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-28 17:20:02 UTC; nataliazemlianskaia</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-30 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='data.gen'>
Data Generation
</h2><span id='topic+data.gen'></span>

<h3>Description</h3>

<p>Generates genotypes data matrix G (<code>sample_size</code> by <code>p</code>), vector of environmental measurments E, and an outcome vector Y of size <code>sample_size</code>. Simulates training, validation, and test datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen(sample_size = 100, p = 20, n_g_non_zero = 15, n_gxe_non_zero = 10, 
         family = "gaussian", mode = "strong_hierarchical", 
         normalize = FALSE, normalize_response = FALSE, 
         seed = 1, pG = 0.2, pE = 0.3,
         n_confounders = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen_+3A_sample_size">sample_size</code></td>
<td>
<p>sample size of the data</p>
</td></tr>
<tr><td><code id="data.gen_+3A_p">p</code></td>
<td>
<p>total number of main effects</p>
</td></tr>
<tr><td><code id="data.gen_+3A_n_g_non_zero">n_g_non_zero</code></td>
<td>
<p>number of non-zero main effects to generate</p>
</td></tr>
<tr><td><code id="data.gen_+3A_n_gxe_non_zero">n_gxe_non_zero</code></td>
<td>
<p>number of non-zero interaction effects to generate</p>
</td></tr>
<tr><td><code id="data.gen_+3A_family">family</code></td>
<td>
<p>&quot;gaussian&quot; for continous outcome Y and &quot;binomial&quot; for binary 0/1 outcome</p>
</td></tr>
<tr><td><code id="data.gen_+3A_mode">mode</code></td>
<td>
<p>either &quot;strong_hierarchical&quot;, &quot;hierarchical&quot;, or &quot;anti_hierarchical&quot;.
In the <em>strong hierarchical</em> mode the hierarchical structure is maintained (beta_g = 0  then beta_gxe = 0) and also |beta_g| &gt;= |beta_gxe|. In the <em>hierarchical</em> mode the  hierarchical structure is maintained, but |beta_G| &lt; |beta_gxe|. In the <em>anti_hierarchical</em> mode the hierarchical structure is violated (beta_g = 0  then beta_gxe != 0).</p>
</td></tr>
<tr><td><code id="data.gen_+3A_normalize">normalize</code></td>
<td>
<p><code>TRUE</code> to normalize matrix <code>G</code> and vector <code>E</code></p>
</td></tr>
<tr><td><code id="data.gen_+3A_normalize_response">normalize_response</code></td>
<td>
<p><code>TRUE</code> to normalize vector <code>Y</code></p>
</td></tr>
<tr><td><code id="data.gen_+3A_pg">pG</code></td>
<td>
<p>genotypes prevalence, value from 0 to 1</p>
</td></tr>
<tr><td><code id="data.gen_+3A_pe">pE</code></td>
<td>
<p>environment prevalence, value from 0 to 1</p>
</td></tr>
<tr><td><code id="data.gen_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="data.gen_+3A_n_confounders">n_confounders</code></td>
<td>
<p>number of confounders to generate, either <code>NULL</code> or <code>&gt;1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of simulated datasets and generating coefficients
</p>
<table>
<tr><td><code>G_train</code>, <code>G_valid</code>, <code>G_test</code></td>
<td>
<p>generated genotypes matrices</p>
</td></tr>
<tr><td><code>E_train</code>, <code>E_valid</code>, <code>E_test</code></td>
<td>
<p>generated vectors of environmental values</p>
</td></tr>
<tr><td><code>Y_train</code>, <code>Y_valid</code>, <code>Y_test</code></td>
<td>
<p>generated outcome vectors</p>
</td></tr>
<tr><td><code>C_train</code>, <code>C_valid</code>, <code>C_test</code></td>
<td>
<p>generated confounders matrices</p>
</td></tr>
<tr><td><code>GxE_train</code>, <code>GxE_valid</code>, <code>GxE_test</code></td>
<td>
<p>generated GxE matrix</p>
</td></tr>
<tr><td><code>Beta_G</code></td>
<td>
<p>main effect coefficients vector</p>
</td></tr>
<tr><td><code>Beta_GxE</code></td>
<td>
<p>interaction coefficients vector</p>
</td></tr>
<tr><td><code>beta_0</code></td>
<td>
<p>intercept coefficient value</p>
</td></tr>
<tr><td><code>beta_E</code></td>
<td>
<p>environment coefficient value</p>
</td></tr>
<tr><td><code>Beta_C</code></td>
<td>
<p>confounders coefficient values</p>
</td></tr>
<tr><td><code>index_beta_non_zero</code>, <code>index_beta_gxe_non_zero</code>, <code>index_beta_zero</code>, <code>index_beta_gxe_zero</code></td>
<td>
<p>inner data generation variables</p>
</td></tr>
<tr><td><code>n_g_non_zero</code></td>
<td>
<p>number of non-zero main effects generated</p>
</td></tr>
<tr><td><code>n_gxe_non_zero</code></td>
<td>
<p>number of non-zero interactions generated</p>
</td></tr>
<tr><td><code>n_total_non_zero</code></td>
<td>
<p>total number of non-zero variables</p>
</td></tr>
<tr><td><code>SNR_g</code></td>
<td>
<p>signal-to-noise ratio for the main effects</p>
</td></tr>
<tr><td><code>SNR_gxe</code></td>
<td>
<p>signal-to-noise ratio for the interactions</p>
</td></tr>
<tr><td><code>family</code>, <code>p</code>, <code>sample_size</code>, <code>mode</code>, <code>seed</code></td>
<td>
<p>input simulation parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.gen(sample_size=100, p=100)
G = data$G_train; GxE = data$GxE_train
E = data$E_train; Y = data$Y_train
</code></pre>

<hr>
<h2 id='gesso-package'>
Hierarchical GxE Interactions in a Regularized Regression Model
</h2><span id='topic+gesso-package'></span><span id='topic+gesso'></span>

<h3>Description</h3>

<p>The method focuses on a single environmental exposure and induces 
    a main-effect-before-interaction hierarchical structure for the joint selection of interaction terms 
    in a regularized regression model. For details see Zemlianskaia et al. (2021) &lt;arxiv:2103.13510&gt;.
</p>


<h3>Author(s)</h3>

<p>Natalia Zemlianskaia
</p>
<p>Maintainer: Natalia Zemlianskaia &lt;natasha.zemlianskaia@gmail.com&gt;
</p>


<h3>References</h3>

<p>&quot;A Scalable Hierarchical Lasso for Gene-Environment Interactions&quot;, 
Natalia Zemlianskaia, W.James Gauderman, Juan Pablo Lewinger
https://arxiv.org/abs/2103.13510
</p>

<hr>
<h2 id='gesso.coef'>
Get model coefficients
</h2><span id='topic+gesso.coef'></span>

<h3>Description</h3>

<p>A function to obtain coefficients from the model fit object corresponding to the desired pair of tuning parameters <code>lambda</code> = (<code>lambda_1</code>, <code>lambda_2</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gesso.coef(fit, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gesso.coef_+3A_fit">fit</code></td>
<td>
<p>model fit object obtained either by using function <code>gesso.fit</code> or  <code>gesso.cv</code></p>
</td></tr>
<tr><td><code id="gesso.coef_+3A_lambda">lambda</code></td>
<td>
<p>a pair of tuning parameters organized in a tibble (ex: <code>lambda = tibble(lambda_1=grid[1], lambda_2=grid[1])</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of model coefficients corresponding to <code>lambda</code> values of tuning parameters
</p>
<table>
<tr><td><code>beta_0</code></td>
<td>
<p>estimated intercept value</p>
</td></tr>
<tr><td><code>beta_e</code></td>
<td>
<p>estimated environmental coefficient value</p>
</td></tr>
<tr><td><code>beta_g</code></td>
<td>
<p>a vector of estimated main effect coefficients</p>
</td></tr>
<tr><td><code>beta_c</code></td>
<td>
<p>a vector of estimated confounders coefficients</p>
</td></tr>
<tr><td><code>beta_gxe</code></td>
<td>
<p>a vector of estimated interaction coefficients</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.gen()
model = gesso.cv(data$G_train, data$E_train, data$Y_train, grid_size=20, 
        parallel=TRUE, nfolds=3)
gxe_coefficients = gesso.coef(model$fit, model$lambda_min)$beta_gxe                
g_coefficients = gesso.coef(model$fit, model$lambda_min)$beta_g     
</code></pre>

<hr>
<h2 id='gesso.coefnum'>
Get model coefficients with specified number of non-zero interactions 
</h2><span id='topic+gesso.coefnum'></span>

<h3>Description</h3>

<p>A function to obtain coefficients with <code>target_b_gxe_non_zero</code> specified to control the desired sparsity of interactions in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gesso.coefnum(cv_model, target_b_gxe_non_zero, less_than = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gesso.coefnum_+3A_cv_model">cv_model</code></td>
<td>
<p>cross-validated model fit object obtained by using function <code>gesso.cv</code></p>
</td></tr>
<tr><td><code id="gesso.coefnum_+3A_target_b_gxe_non_zero">target_b_gxe_non_zero</code></td>
<td>
<p>number of non-zero interactions we want to inlcude in the model</p>
</td></tr>
<tr><td><code id="gesso.coefnum_+3A_less_than">less_than</code></td>
<td>
<p><code>TRUE</code> if we want to control a number of <em>at most</em> non-zero interactions, <code>FALSE</code> if we want to control a number of <em>at least</em> non-zero interactions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of model coefficients corresponding to the best model that contains at most or at least <code>target_b_gxe_non_zero</code> non-zero interaction terms. 
</p>
<p>The target model is selected based on the averaged cross-validation (cv) results: for each pair of  parameters <code>lambda</code>=(lambda_1, lambda_2) in the grid and each cv fold we obtain a number of non-zero estimated interaction terms, then average cv results by <code>lambda</code> and choose the tuning parameters corresponding to the minimum average cv loss that have <em>at most</em> or <em>at least</em> <code>target_b_gxe_non_zero</code> non-zero interaction terms. Returned coefficients are obtained by fitting the model on the full data with the selected tuning parameters. 
</p>
<p>Note that the number of estimated non-zero interactions will only approximately reflect the numbers obtained on cv datasets.
</p>
<table>
<tr><td><code>beta_0</code></td>
<td>
<p>estimated intercept value</p>
</td></tr>
<tr><td><code>beta_e</code></td>
<td>
<p>estimated environmental coefficient value</p>
</td></tr>
<tr><td><code>beta_g</code></td>
<td>
<p>a vector of estimated main effect coefficients</p>
</td></tr>
<tr><td><code>beta_gxe</code></td>
<td>
<p>a vector of estimated interaction coefficients</p>
</td></tr>
<tr><td><code>beta_c</code></td>
<td>
<p>a vector of estimated confounders coefficients</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.gen()
model = gesso.cv(data$G_train, data$E_train, data$Y_train)
model_coefficients = gesso.coefnum(model, 5)
gxe_coefficients = model_coefficients$beta_gxe; sum(gxe_coefficients!=0)              
</code></pre>

<hr>
<h2 id='gesso.cv'>
Cross-Validation
</h2><span id='topic+gesso.cv'></span>

<h3>Description</h3>

<p>Performs <code>nfolds</code>-fold cross-validation to tune hyperparmeters <code>lambda_1</code> and <code>lambda_2</code> for the gesso model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gesso.cv(G, E, Y, C = NULL, normalize = TRUE, normalize_response = FALSE, grid = NULL,
         grid_size = 20, grid_min_ratio = NULL, alpha = NULL, family = "gaussian", 
         type_measure = "loss", fold_ids = NULL, nfolds = 4, 
         parallel = TRUE, seed = 42, tolerance = 1e-3, max_iterations = 5000, 
         min_working_set_size = 100, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gesso.cv_+3A_g">G</code></td>
<td>
<p>matrix of main effects of size <code>n x p</code>, variables organized by columns</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_e">E</code></td>
<td>
<p>vector of environmental measurments</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_y">Y</code></td>
<td>
<p>outcome vector. Set <code>family="gaussian"</code> for the continuous outcome and 
<code>family="binomial"</code> for the binary outcome with 0/1 levels</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_c">C</code></td>
<td>
<p>matrix of confounders of size <code>n x m</code>, variables organized by columns</p>
</td></tr> 
<tr><td><code id="gesso.cv_+3A_normalize">normalize</code></td>
<td>
<p><code>TRUE</code> to normalize matrix <code>G</code> and vector <code>E</code></p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_normalize_response">normalize_response</code></td>
<td>
<p><code>TRUE</code> to normalize vector <code>Y</code> (for <code>family="gaussian"</code>)</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_grid">grid</code></td>
<td>
<p>grid sequence for tuning hyperparameters, we use the same grid for <code>lambda_1</code> and <code>lambda_2</code></p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_grid_size">grid_size</code></td>
<td>
<p>specify <code>grid_size</code> to generate grid automatically. Grid is generated by calculating <code>max_lambda</code> from the data (smallest lambda such that all the coefficients are zero). <code>min_lambda</code> is calculated as a product of <code>max_lambda</code> and <code>grid_min_ratio</code>. The program then generates <code>grid_size</code> values equidistant on the log10 scale from <code>min_lambda</code> to <code>max_lambda</code></p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_grid_min_ratio">grid_min_ratio</code></td>
<td>
<p>parameter to determine <code>min_lambda</code> (smallest value for the grid of lambdas),
default is 0.1 for p &gt; n, 0.01 otherwise</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_alpha">alpha</code></td>
<td>
<p>if <code>NULL</code> independent 2D grid is used for (<code>lambda_1</code>, <code>lambda_2</code>), else 1D grid is used where <code>lambda_2</code> = <code>alpha</code> * <code>lambda_1</code>, i.e. (<code>lambda_1</code>, <code>alpha</code> * <code>lambda_1</code>)</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_family">family</code></td>
<td>
<p><code>"gaussian"</code> for continuous outcome and <code>"binomial"</code> for binary</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_type_measure">type_measure</code></td>
<td>
<p>loss to use for cross-validation. Specity <code>type_measure="loss"</code> for neative log likelihood or <code>type_measure="auc"</code> for AUC (for <code>family="binomial"</code> only) </p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_fold_ids">fold_ids</code></td>
<td>
<p>option to input custom folds assignments</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the dual gap convergence criterion</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_max_iterations">max_iterations</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_min_working_set_size">min_working_set_size</code></td>
<td>
<p>minimum size of the working set</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_nfolds">nfolds</code></td>
<td>
<p>number of cross-validation splits</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_parallel">parallel</code></td>
<td>
<p><code>TRUE</code> to enable parallel cross-validation</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_seed">seed</code></td>
<td>
<p>set random seed to control random folds assignments</p>
</td></tr>
<tr><td><code id="gesso.cv_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> to print messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects
</p>
<table>
<tr><td><code>cv_result</code></td>
<td>
<p>a tibble with cross-validation results: averaged across folds loss and the number of non-zero coefficients for each value of (<code>lambda_1</code>, <code>lambda_2</code>) path. Could be used for custom parameters tuning (ex: select (<code>lambda_1</code>, <code>lambda_2</code>) with a sertain number of non-zero main effects and/or a sertain number of interactions).
</p>

<ul>
<li><p><code>mean_loss  </code>averaged across folds loss value, vector of size <code>lambda_1</code>*<code>lambda_2</code>
</p>
</li>
<li><p><code>mean_beta_g_nonzero  </code>averaged across folds number of non-zero main effects, vector of size <code>lambda_1</code>*<code>lambda_2</code>
</p>
</li>
<li><p><code>mean_beta_gxe_nonzero  </code>  averaged across folds number of non-zero interactions, vector of size <code>lambda_1</code>*<code>lambda_2</code>
</p>
</li>
<li><p><code>lambda_1  </code><code>lambda_1</code> pass, decreasing
</p>
</li>
<li><p><code>lambda_2  </code><code>lambda_2</code> pass, oscillating
</p>
</li></ul>
</td></tr>
<tr><td><code>lambda_min</code></td>
<td>
<p>a tibble of optimal (<code>lambda_1</code>, <code>lambda_2</code>) values, tuning parameter values that give minimum cross-validation loss (<code>mean_loss</code>)</p>
</td></tr>

<tr><td><code>fit</code></td>
<td>
<p>list, return of the function gesso.fit on the full data</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>vector of values used for hyperparameters tuning</p>
</td></tr>
<tr><td><code>full_cv_result</code></td>
<td>
<p>inner variables</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.gen()
tune_model = gesso.cv(data$G_train, data$E_train, data$Y_train, 
                      grid_size=20, parallel=TRUE, nfolds=3)
gxe_coefficients = gesso.coef(tune_model$fit, tune_model$lambda_min)$beta_gxe        
g_coefficients = gesso.coef(tune_model$fit, tune_model$lambda_min)$beta_g          
</code></pre>

<hr>
<h2 id='gesso.fit'>
gesso fit
</h2><span id='topic+gesso.fit'></span>

<h3>Description</h3>

<p>Fits gesso model over the two dimentional grid of hyperparmeters <code>lambda_1</code> and <code>lambda_2</code>, returns estimated coefficients for each pair of hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gesso.fit(G, E, Y, C = NULL, normalize = TRUE, normalize_response = FALSE,
          grid = NULL, grid_size = 20, grid_min_ratio = NULL, 
          alpha = NULL, family = "gaussian", weights = NULL,
          tolerance = 1e-3, max_iterations = 5000, 
          min_working_set_size = 100,
          verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gesso.fit_+3A_g">G</code></td>
<td>
<p>matrix of main effects of size <code>n x p</code>, variables organized by columns</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_e">E</code></td>
<td>
<p>vector of environmental measurments</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_y">Y</code></td>
<td>
<p>outcome vector. Set <code>family="gaussian"</code> for the continuous outcome and 
<code>family="binomial"</code> for the binary outcome with 0/1 levels</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_c">C</code></td>
<td>
<p>matrix of confounders of size <code>n x m</code>, variables organized by columns</p>
</td></tr>    
<tr><td><code id="gesso.fit_+3A_normalize">normalize</code></td>
<td>
<p><code>TRUE</code> to normalize matrix <code>G</code> and vector <code>E</code></p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_normalize_response">normalize_response</code></td>
<td>
<p><code>TRUE</code> to normalize vector <code>Y</code></p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_grid">grid</code></td>
<td>
<p>grid sequence for tuning hyperparameters, we use the same grid for <code>lambda_1</code> and <code>lambda_2</code></p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_grid_size">grid_size</code></td>
<td>
<p>specify <code>grid_size</code> to generate grid automatically. Grid is generated by calculating <code>max_lambda</code> from the data (smallest lambda such that all the coefficients are zero). <code>min_lambda</code> is calculated as a product of <code>max_lambda</code> and <code>grid_min_ratio</code>. The program then generates <code>grid_size</code> values equidistant on the log10 scale from <code>min_lambda</code> to <code>max_lambda</code></p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_grid_min_ratio">grid_min_ratio</code></td>
<td>
<p>parameter to determine <code>min_lambda</code> (smallest value for the grid of lambdas),
default is 0.1 for p &gt; n, 0.01 otherwise</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_alpha">alpha</code></td>
<td>
<p>if <code>NULL</code> independent 2D grid is used for (<code>lambda_1</code>, <code>lambda_2</code>), else 1D grid is used where <code>lambda_2</code> = <code>alpha</code> * <code>lambda_1</code>, i.e. (<code>lambda_1</code>, <code>alpha</code> * <code>lambda_1</code>)</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_family">family</code></td>
<td>
<p><code>"gaussian"</code> for continuous outcome and <code>"binomial"</code> for binary</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the dual gap convergence criterion</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_max_iterations">max_iterations</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_min_working_set_size">min_working_set_size</code></td>
<td>
<p>minimum size of the working set</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_weights">weights</code></td>
<td>
<p>inner fitting parameter</p>
</td></tr>
<tr><td><code id="gesso.fit_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> to print messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of estimated coefficients and other model fit metrics for each pair of hyperparameters (<code>lambda_1</code>, <code>lambda_2</code>)
</p>
<table>
<tr><td><code>beta_0</code></td>
<td>
<p>vector of estimated intercept values of size <code>lambda_1</code>*<code>lambda_2</code></p>
</td></tr>
<tr><td><code>beta_e</code></td>
<td>
<p>vector of estimated environment coefficients of size <code>lambda_1</code>*<code>lambda_2</code></p>
</td></tr>
<tr><td><code>beta_g</code></td>
<td>
<p>matrix of estimated main effects coefficients organized by rows, size (<code>lambda_1</code>*<code>lambda_2</code>) by <code>p</code></p>
</td></tr>
<tr><td><code>beta_gxe</code></td>
<td>
<p>matrix of estimated interactions coefficients organized by rows, size (<code>lambda_1</code>*<code>lambda_2</code>) by <code>p</code></p>
</td></tr>
<tr><td><code>beta_c</code></td>
<td>
<p>matrix of estimated confounders coefficients organized by rows, size (<code>lambda_1</code>*<code>lambda_2</code>) by <code>m</code>, where <code>m</code> is the number of confounders</p>
</td></tr>
<tr><td><code>num_iterations</code></td>
<td>
<p>number of iterations until convergence for each fit</p>
</td></tr>
<tr><td><code>working_set_size</code></td>
<td>
<p>maximum number of variables in the working set for each fit</p>
</td></tr>
<tr><td><code>has_converged</code></td>
<td>
<p>1 if the model converged within given <code>max_iterations</code>, 0 otherwise</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>
<p>objective function (loss) value for each fit</p>
</td></tr>
<tr><td><code>beta_g_nonzero</code></td>
<td>
<p>number of estimated non-zero main effects for each fit</p>
</td></tr>
<tr><td><code>beta_gxe_nonzero</code></td>
<td>
<p>number of estimated non-zero interactions for each fit</p>
</td></tr>
<tr><td><code>lambda_1</code></td>
<td>
<p><code>lambda_1</code> path values, decreasing</p>
</td></tr>
<tr><td><code>lambda_2</code></td>
<td>
<p><code>lambda_2</code> path values, oscillating</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>vector of values used for hyperparameters tuning</p>
</td></tr>


</table>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.gen()
fit = gesso.fit(G=data$G_train, E=data$E_train, Y=data$Y_train, normalize=TRUE)
plot(fit$beta_g_nonzero, pch=19, cex=0.4, 
     ylab="num of non-zero features", xlab="lambdas path")
points(fit$beta_gxe_nonzero, pch=19, cex=0.4, col="red")
</code></pre>

<hr>
<h2 id='gesso.predict'>
Predict new outcome vector
</h2><span id='topic+gesso.predict'></span>

<h3>Description</h3>

<p>Predict new outcome vector based on the new data and estimated model coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gesso.predict(beta_0, beta_e, beta_g, beta_gxe, new_G, new_E, 
                   beta_c=NULL, new_C=NULL, family = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gesso.predict_+3A_beta_0">beta_0</code></td>
<td>
<p>estimated intercept value</p>
</td></tr>
<tr><td><code id="gesso.predict_+3A_beta_e">beta_e</code></td>
<td>
<p>estimated environmental coefficient value</p>
</td></tr>
<tr><td><code id="gesso.predict_+3A_beta_g">beta_g</code></td>
<td>
<p>a vector of estimated main effect coefficients</p>
</td></tr>
<tr><td><code id="gesso.predict_+3A_beta_gxe">beta_gxe</code></td>
<td>
<p>a vector of estimated interaction coefficients</p>
</td></tr>
<tr><td><code id="gesso.predict_+3A_new_g">new_G</code></td>
<td>
<p>matrix of main effects, variables organized by columns</p>
</td></tr>
<tr><td><code id="gesso.predict_+3A_new_e">new_E</code></td>
<td>
<p>vector of environmental measurments</p>
</td></tr>
<tr><td><code id="gesso.predict_+3A_beta_c">beta_c</code></td>
<td>
<p>a vector of estimated confounders coefficients</p>
</td></tr>
<tr><td><code id="gesso.predict_+3A_new_c">new_C</code></td>
<td>
<p>matrix of confounders, variables organized by columns</p>
</td></tr>
<tr><td><code id="gesso.predict_+3A_family">family</code></td>
<td>
<p>set <code>family="gaussian"</code> for the continuous outcome and 
<code>family="binomial"</code> for the binary outcome with 0/1 levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of predicted values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.gen()
tune_model = gesso.cv(data$G_train, data$E_train, data$Y_train)
coefficients = gesso.coef(tune_model$fit, tune_model$lambda_min)
beta_0 = coefficients$beta_0; beta_e = coefficients$beta_e                   
beta_g = coefficients$beta_g; beta_gxe = coefficients$beta_gxe     

new_G = data$G_test; new_E = data$E_test
new_Y = gesso.predict(beta_0, beta_e, beta_g, beta_gxe, new_G, new_E)
cor(new_Y, data$Y_test)^2
</code></pre>

<hr>
<h2 id='selection.metrics'>
Selection metrics
</h2><span id='topic+selection.metrics'></span>

<h3>Description</h3>

<p>Calculates principal selection metrics for the binary zero/non-zero classification problem (sensitivity, specificity, precision, auc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection.metrics(true_b_g, true_b_gxe, estimated_b_g, estimated_b_gxe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selection.metrics_+3A_true_b_g">true_b_g</code></td>
<td>
<p>vector of true main effect coefficients</p>
</td></tr>
<tr><td><code id="selection.metrics_+3A_true_b_gxe">true_b_gxe</code></td>
<td>
<p>vector of true interaction coefficients</p>
</td></tr>
<tr><td><code id="selection.metrics_+3A_estimated_b_g">estimated_b_g</code></td>
<td>
<p>vector of estimated main effect coefficients</p>
</td></tr>
<tr><td><code id="selection.metrics_+3A_estimated_b_gxe">estimated_b_gxe</code></td>
<td>
<p>vector of estimated interaction coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of principal selection metrics
</p>
<table>
<tr><td><code>b_g_non_zero</code></td>
<td>
<p>number of non-zero main effects</p>
</td></tr>
<tr><td><code>b_gxe_non_zero</code></td>
<td>
<p>number of non-zero interactions</p>
</td></tr>
<tr><td><code>mse_b_g</code></td>
<td>
<p>mean squared error for estimation of main effects effect sizes</p>
</td></tr>
<tr><td><code>mse_b_gxe</code></td>
<td>
<p>mean squared error for estimation of interactions effect sizes</p>
</td></tr>
<tr><td><code>sensitivity_g</code></td>
<td>
<p>recall of the non-zero main effects</p>
</td></tr>
<tr><td><code>specificity_g</code></td>
<td>
<p>recall of the zero main effects</p>
</td></tr>
<tr><td><code>precision_g</code></td>
<td>
<p>precision with respect to non-zero main effects</p>
</td></tr>
<tr><td><code>sensitivity_gxe</code></td>
<td>
<p>recall of the non-zero interactions</p>
</td></tr>
<tr><td><code>specificity_gxe</code></td>
<td>
<p>recall of the zero interactions</p>
</td></tr>
<tr><td><code>precision_gxe</code></td>
<td>
<p>precision with respect to non-zero interactions</p>
</td></tr>
<tr><td><code>auc_g</code></td>
<td>
<p>area under the curve for zero/non-zero binary classification problem for main effects</p>
</td></tr>
<tr><td><code>auc_gxe</code></td>
<td>
<p>area under the curve for zero/non-zero binary classification problem for interactions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.gen()
model = gesso.cv(data$G_train, data$E_train, data$Y_train)
gxe_coefficients = gesso.coef(model$fit, model$lambda_min)$beta_gxe                
g_coefficients = gesso.coef(model$fit, model$lambda_min)$beta_g  
selection.metrics(data$Beta_G, data$Beta_GxE, g_coefficients, gxe_coefficients)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
