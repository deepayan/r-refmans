<!DOCTYPE html><html><head><title>Help for package spdep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spdep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregate.nb'><p>Aggregate a spatial neighbours object</p></a></li>
<li><a href='#airdist'><p>Measure distance from plot</p></a></li>
<li><a href='#autocov_dist'><p>Distance-weighted autocovariate</p></a></li>
<li><a href='#bhicv'><p>Data set with 4 life condition indices of Belo Horizonte region</p></a></li>
<li><a href='#card'><p>Cardinalities for neighbours lists</p></a></li>
<li><a href='#cell2nb'><p>Generate neighbours list for grid cells</p></a></li>
<li><a href='#choynowski'><p>Choynowski probability map values</p></a></li>
<li><a href='#columbus'><p>Columbus OH spatial analysis data set</p></a></li>
<li><a href='#diffnb'><p>Differences between neighbours lists</p></a></li>
<li><a href='#dnearneigh'><p>Neighbourhood contiguity by distance</p></a></li>
<li><a href='#droplinks'><p>Drop links in a neighbours list</p></a></li>
<li><a href='#EBest'><p>Global Empirical Bayes estimator</p></a></li>
<li><a href='#EBImoran.mc'><p>Permutation test for empirical Bayes index</p></a></li>
<li><a href='#EBlocal'><p>Local Empirical Bayes estimator</p></a></li>
<li><a href='#edit.nb'><p>Interactive editing of neighbours lists</p></a></li>
<li><a href='#eire'><p>Eire data sets</p></a></li>
<li><a href='#geary'><p>Compute Geary's C</p></a></li>
<li><a href='#geary.mc'><p>Permutation test for Geary's C statistic</p></a></li>
<li><a href='#geary.test'><p>Geary's C test for spatial autocorrelation</p></a></li>
<li><a href='#globalG.test'><p>Global G test for spatial autocorrelation</p></a></li>
<li><a href='#Graph Components'><p>Depth First Search on Neighbor Lists</p></a></li>
<li><a href='#graphneigh'><p>Graph based spatial weights</p></a></li>
<li><a href='#grid2nb'><p>Construct neighbours for a GridTopology</p></a></li>
<li><a href='#hotspot'><p>Cluster classifications for local indicators of spatial association</p></a></li>
<li><a href='#include.self'><p>Include self in neighbours list</p></a></li>
<li><a href='#is.symmetric.nb'><p>Test a neighbours list for symmetry</p></a></li>
<li><a href='#joincount.mc'><p>Permutation test for same colour join count statistics</p></a></li>
<li><a href='#joincount.multi'><p>BB, BW and Jtot join count statistic for k-coloured factors</p></a></li>
<li><a href='#joincount.test'><p>BB join count statistic for k-coloured factors</p></a></li>
<li><a href='#knearneigh'><p>K nearest neighbours for spatial weights</p></a></li>
<li><a href='#knn2nb'><p>Neighbours list from knn object</p></a></li>
<li><a href='#lag.listw'><p>Spatial lag of a numeric vector</p></a></li>
<li><a href='#lee'><p>Compute Lee's statistic</p></a></li>
<li><a href='#lee.mc'><p>Permutation test for Lee's L statistic</p></a></li>
<li><a href='#lee.test'><p>Lee's L  test for spatial autocorrelation</p></a></li>
<li><a href='#listw2sn'><p>Spatial neighbour sparse representation</p></a></li>
<li><a href='#lm.LMtests'><p>Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models</p></a></li>
<li><a href='#lm.morantest'><p>Moran's I test for residual spatial autocorrelation</p></a></li>
<li><a href='#lm.morantest.exact'><p>Exact global Moran's I test</p></a></li>
<li><a href='#lm.morantest.sad'><p>Saddlepoint approximation of global Moran's I test</p></a></li>
<li><a href='#local_joincount_bv'><p>Calculate the local bivariate join count</p></a></li>
<li><a href='#local_joincount_uni'><p>Calculate the local univariate join count</p></a></li>
<li><a href='#localC'><p>Compute Local Geary statistic</p></a></li>
<li><a href='#localG'><p>G and Gstar local spatial statistics</p></a></li>
<li><a href='#localGS'><p>A local hotspot statistic for analysing multiscale datasets</p></a></li>
<li><a href='#localmoran'><p>Local Moran's I statistic</p></a></li>
<li><a href='#localmoran_bv'><p>Compute the Local Bivariate Moran's I Statistic</p></a></li>
<li><a href='#localmoran.exact'><p>Exact local Moran's Ii tests</p></a></li>
<li><a href='#localmoran.sad'><p>Saddlepoint approximation of local Moran's Ii tests</p></a></li>
<li><a href='#LOSH'><p>Local spatial heteroscedasticity</p></a></li>
<li><a href='#LOSH.cs'><p>Chi-square based test for local spatial heteroscedasticity</p></a></li>
<li><a href='#LOSH.mc'><p>Bootstrapping-based test for local spatial heteroscedasticity</p></a></li>
<li><a href='#mat2listw'><p>Convert a square spatial weights matrix to a weights list object</p></a></li>
<li><a href='#moran'><p>Compute Moran's I</p></a></li>
<li><a href='#moran_bv'><p>Compute the Global Bivariate Moran's I</p></a></li>
<li><a href='#moran.mc'><p>Permutation test for Moran's I statistic</p></a></li>
<li><a href='#moran.plot'><p>Moran scatterplot</p></a></li>
<li><a href='#moran.test'><p>Moran's I test for spatial autocorrelation</p></a></li>
<li><a href='#mstree'><p>Find the minimal spanning tree</p></a></li>
<li><a href='#nb.set.operations'><p>Set operations on neighborhood objects</p></a></li>
<li><a href='#nb2blocknb'><p>Block up neighbour list for location-less observations</p></a></li>
<li><a href='#nb2INLA'><p>Output spatial neighbours for INLA</p></a></li>
<li><a href='#nb2lines'><p>Use vector files for import and export of weights</p></a></li>
<li><a href='#nb2listw'><p>Spatial weights for neighbours lists</p></a></li>
<li><a href='#nb2listwdist'><p>Distance-based spatial weights for neighbours lists</p></a></li>
<li><a href='#nb2mat'><p>Spatial weights matrices for neighbours lists</p></a></li>
<li><a href='#nb2WB'><p>Output spatial weights for WinBUGS</p></a></li>
<li><a href='#nbcosts'><p>Compute cost of edges</p></a></li>
<li><a href='#nbdists'><p>Spatial link distance measures</p></a></li>
<li><a href='#nblag'><p>Higher order neighbours lists</p></a></li>
<li><a href='#oldcol'><p>Columbus OH spatial analysis data set - old numbering</p></a></li>
<li><a href='#p.adjustSP'><p>Adjust local association measures' p-values</p></a></li>
<li><a href='#plot.mst'><p>Plot the Minimum Spanning Tree</p></a></li>
<li><a href='#plot.nb'><p>Plot a neighbours list</p></a></li>
<li><a href='#plot.skater'><p>Plot the object of skater class</p></a></li>
<li><a href='#poly2nb'><p>Construct neighbours list from polygon list</p></a></li>
<li><a href='#probmap'><p>Probability mapping for rates</p></a></li>
<li><a href='#prunecost'><p>Compute cost of prune each edge</p></a></li>
<li><a href='#prunemst'><p>Prune a Minimun Spanning Tree</p></a></li>
<li><a href='#read.gal'><p>Read a GAL lattice file into a neighbours list</p></a></li>
<li><a href='#read.gwt2nb'><p>Read and write spatial neighbour files</p></a></li>
<li><a href='#Rotation'><p> Rotate a set of point by a certain angle</p></a></li>
<li><a href='#SD.RStests'>
<p>Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models</p></a></li>
<li><a href='#set.mcOption'><p>Options for parallel support</p></a></li>
<li><a href='#set.spChkOption'><p>Control checking of spatial object IDs</p></a></li>
<li><a href='#skater'><p>Spatial 'K'luster Analysis by Tree Edge Removal</p></a></li>
<li><a href='#sp.correlogram'><p>Spatial correlogram</p></a></li>
<li><a href='#sp.mantel.mc'><p>Mantel-Hubert spatial general cross product statistic</p></a></li>
<li><a href='#spdep'><p>Return package version number</p></a></li>
<li><a href='#spdep-defunct'><p>Defunct Functions in Package <span class="pkg">spdep</span></p></a></li>
<li><a href='#spweights.constants'><p>Provides constants for spatial weights matrices</p></a></li>
<li><a href='#ssw'><p>Compute the sum of dissimilarity</p></a></li>
<li><a href='#subset.listw'><p>Subset a spatial weights list</p></a></li>
<li><a href='#subset.nb'><p>Subset a neighbours list</p></a></li>
<li><a href='#summary.nb'><p>Print and summary function for neighbours and weights lists</p></a></li>
<li><a href='#tolerance.nb'><p> Function to construct edges based on a tolerance angle and a maximum distance</p></a></li>
<li><a href='#tri2nb'><p>Neighbours list from tri object</p></a></li>
<li><a href='#write.nb.gal'><p>Write a neighbours list as a GAL lattice file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Dependence: Weighting Schemes, Statistics</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), methods, spData (&ge; 0.2.6.0), sf</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, deldir, boot (&ge; 1.3-1), graphics, utils, grDevices,
units, s2, e1071, sp (&ge; 1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spatialreg (&ge; 1.2-1), Matrix, parallel, dbscan,
RColorBrewer, lattice, xtable, foreign, igraph, RSpectra,
knitr, classInt, tmap, spam, ggplot2, rmarkdown, tinytest,
rgeoda</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-spatial/spdep/">https://github.com/r-spatial/spdep/</a>,
<a href="https://r-spatial.github.io/spdep/">https://r-spatial.github.io/spdep/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatial/spdep/issues/">https://github.com/r-spatial/spdep/issues/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to create spatial weights matrix
  objects from polygon 'contiguities', from point patterns by distance and
  tessellations, for summarizing these objects, and for permitting their
  use in spatial data analysis, including regional aggregation by minimum
  spanning tree; a collection of tests for spatial 'autocorrelation',
  including global 'Morans I' and 'Gearys C' proposed by 'Cliff' and 'Ord'
  (1973, ISBN: 0850860369) and (1981, ISBN: 0850860814), 'Hubert/Mantel'
  general cross product statistic, Empirical Bayes estimates and
  'Assunção/Reis' (1999) &lt;<a href="https://doi.org/10.1002/(SICI)1097-0258(19990830)18:16%3C2147::AID-SIM179%3E3.0.CO;2-I">doi:10.1002/(SICI)1097-0258(19990830)18:16%3C2147::AID-SIM179%3E3.0.CO;2-I</a>&gt; Index, 'Getis/Ord' G ('Getis' and 'Ord' 1992)
  &lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.1992.tb00261.x">doi:10.1111/j.1538-4632.1992.tb00261.x</a>&gt; and multicoloured
  join count statistics, 'APLE' ('Li 'et al.' )
  &lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.2007.00708.x">doi:10.1111/j.1538-4632.2007.00708.x</a>&gt;, local 'Moran's I', 'Gearys C' 
  ('Anselin' 1995) &lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.1995.tb00338.x">doi:10.1111/j.1538-4632.1995.tb00338.x</a>&gt; and
  'Getis/Ord' G ('Ord' and 'Getis' 1995)
  &lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.1995.tb00912.x">doi:10.1111/j.1538-4632.1995.tb00912.x</a>&gt;,
  'saddlepoint' approximations ('Tiefelsdorf' 2002)
  &lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.2002.tb01084.x">doi:10.1111/j.1538-4632.2002.tb01084.x</a>&gt; and exact tests
  for global and local 'Moran's I' ('Bivand et al.' 2009)
  &lt;<a href="https://doi.org/10.1016%2Fj.csda.2008.07.021">doi:10.1016/j.csda.2008.07.021</a>&gt; and 'LOSH' local indicators
  of spatial heteroscedasticity ('Ord' and 'Getis')
  &lt;<a href="https://doi.org/10.1007%2Fs00168-011-0492-y">doi:10.1007/s00168-011-0492-y</a>&gt;. The implementation of most of
  these measures is described in 'Bivand' and 'Wong' (2018)
  &lt;<a href="https://doi.org/10.1007%2Fs11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a>&gt;, with further extensions in 'Bivand' (2022)
  &lt;<a href="https://doi.org/10.1111%2Fgean.12319">doi:10.1111/gean.12319</a>&gt;. 'Lagrange' multiplier tests for spatial dependence
  in linear models are provided ('Anselin et al'. 1996)
  &lt;<a href="https://doi.org/10.1016%2F0166-0462%2895%2902111-6">doi:10.1016/0166-0462(95)02111-6</a>&gt;, as are 'Rao' score tests for hypothesised
  spatial 'Durbin' models based on linear models ('Koley' and 'Bera' 2023)
  &lt;<a href="https://doi.org/10.1080%2F17421772.2023.2256810">doi:10.1080/17421772.2023.2256810</a>&gt;.
  From 'spdep' and 'spatialreg' versions &gt;= 1.2-1, the model fitting functions
  previously present in this package are defunct in 'spdep' and may be found
  in 'spatialreg'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>RoxygenNote: 6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 08:22:37 UTC; rsb</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Bivand <a href="https://orcid.org/0000-0003-2392-6140"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Micah Altman [ctb],
  Luc Anselin [ctb],
  Renato Assunção [ctb],
  Anil Bera [ctb],
  Olaf Berke [ctb],
  F. Guillaume Blanchet [ctb],
  Marilia Carvalho [ctb],
  Bjarke Christensen [ctb],
  Yongwan Chun [ctb],
  Carsten Dormann [ctb],
  Stéphane Dray [ctb],
  Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Virgilio Gómez-Rubio [ctb],
  Malabika Koley [ctb],
  Elias Krainski [ctb],
  Pierre Legendre [ctb],
  Nicholas Lewin-Koh [ctb],
  Angela Li [ctb],
  Giovanni Millo [ctb],
  Werner Mueller [ctb],
  Hisaji Ono [ctb],
  Josiah Parry <a href="https://orcid.org/0000-0001-9910-865X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Pedro Peres-Neto [ctb],
  Gianfranco Piras [ctb],
  Markus Reder [ctb],
  Jeff Sauer [ctb],
  Michael Tiefelsdorf [ctb],
  René Westerholt [ctb],
  Levi Wolf [ctb],
  Danlin Yu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger Bivand &lt;Roger.Bivand@nhh.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-07 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregate.nb'>Aggregate a spatial neighbours object</h2><span id='topic+aggregate.nb'></span>

<h3>Description</h3>

<p>The method aggregates a spatial neighbours object, creating a new object listing the neighbours of the aggregates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nb'
aggregate(x, IDs, remove.self = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.nb_+3A_x">x</code></td>
<td>
<p>an nb neighbour object</p>
</td></tr>
<tr><td><code id="aggregate.nb_+3A_ids">IDs</code></td>
<td>
<p>a character vector of IDs grouping the members of the neighbour object</p>
</td></tr>
<tr><td><code id="aggregate.nb_+3A_remove.self">remove.self</code></td>
<td>
<p>default TRUE: remove self-neighbours resulting from aggregation</p>
</td></tr>
<tr><td><code id="aggregate.nb_+3A_...">...</code></td>
<td>
<p>unused - arguments passed through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an nb neighbour object, with empty aggregates dropped.
</p>


<h3>Note</h3>

<p>Method suggested by Roberto Patuelli</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(used.cars, package="spData")
data(state)
cont_st &lt;- match(attr(usa48.nb, "region.id"), state.abb)
cents &lt;- as.matrix(as.data.frame(state.center))[cont_st,]
opar &lt;- par(mfrow=c(2,1))
plot(usa48.nb, cents, xlim=c(-125, -65), ylim=c(25, 50))
IDs &lt;- as.character(state.division[cont_st])
agg_cents &lt;- aggregate(cents, list(IDs), mean)
agg_nb &lt;- aggregate(usa48.nb, IDs)
plot(agg_nb, agg_cents[, 2:3], xlim=c(-125, -65), ylim=c(25, 50))
text(agg_cents[, 2:3], agg_cents[, 1], cex=0.6)
par(opar)
</code></pre>

<hr>
<h2 id='airdist'>Measure distance from plot</h2><span id='topic+airdist'></span>

<h3>Description</h3>

<p>Measure a distance between two points on a plot using <code>locator</code>; the function checks <code>par("plt")</code> and <code>par("usr")</code> to try to ensure that the aspect ratio y/x is 1, that is that the units of measurement in both x and y are equivalent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airdist(ann=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="airdist_+3A_ann">ann</code></td>
<td>
<p>annotate the plot with line measured and distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with members:
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>distance measured</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>coordinates between which distance is measured</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+locator">locator</a></code></p>

<hr>
<h2 id='autocov_dist'>Distance-weighted autocovariate</h2><span id='topic+autocov_dist'></span>

<h3>Description</h3>

<p>Calculates the autocovariate to be used in autonormal, autopoisson or autologistic regression. Three distance-weighting schemes are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocov_dist(z, xy, nbs = 1, type = "inverse", zero.policy = NULL,
 style = "B", longlat=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocov_dist_+3A_z">z</code></td>
<td>
<p>the response variable</p>
</td></tr>
<tr><td><code id="autocov_dist_+3A_xy">xy</code></td>
<td>
<p>a matrix of coordinates or a SpatialPoints, <code>sf</code> or <code>sfc</code> points object</p>
</td></tr>
<tr><td><code id="autocov_dist_+3A_nbs">nbs</code></td>
<td>
<p>neighbourhood radius; default is 1</p>
</td></tr>
<tr><td><code id="autocov_dist_+3A_type">type</code></td>
<td>
<p>the weighting scheme: &quot;one&quot; gives equal weight to all data points in the neighbourhood; &quot;inverse&quot; (the default) weights by inverse distance; &quot;inverse.squared&quot; weights by the square of &quot;inverse&quot;</p>
</td></tr>
<tr><td><code id="autocov_dist_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td></tr>
<tr><td><code id="autocov_dist_+3A_style">style</code></td>
<td>
<p>default &ldquo;B&rdquo; (changed from &ldquo;W&rdquo; 2015-01-27); style can take values &ldquo;W&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;U&rdquo;, and &ldquo;S&rdquo;</p>
</td></tr>
<tr><td><code id="autocov_dist_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are longitude-latitude decimal, in which case distances are measured in kilometers; if xy is a SpatialPoints object, the value is taken from the object itself</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of autocovariate values
</p>


<h3>Note</h3>

<p>The validity of this approach strongly hinges on the correct choice of the
neighbourhood scheme! Using <span class="option">style="B"</span> ensures symmetry of the
neighbourhood matrix (i.e. <code class="reqn">w_{nm} = w_{mn}</code>). Please see Bardos et al. (2015)
for details.</p>


<h3>Author(s)</h3>

<p>Carsten F. Dormann and Roger Bivand</p>


<h3>References</h3>

<p>Augustin N.H., Mugglestone M.A. and Buckland S.T. (1996) An autologistic model for the spatial distribution of wildlife. <em>Journal of Applied Ecology</em>, 33, 339-347; Gumpertz M.L., Graham J.M. and Ristaino J.B. (1997) Autologistic model of spatial pattern of Phytophthora epidemic in bell pepper: effects of soil variables on disease presence. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, 2, 131-156; Bardos, D.C., Guillera-Arroita, G. and Wintle, B.A. (2015) Valid auto-models for spatially autocorrelated occupancy and abundance data. arXiv, 1501.06529.</p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2listw">nb2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
#xy &lt;- cbind(columbus$X, columbus$Y)
xy &lt;- st_coordinates(st_centroid(st_geometry(columbus),
 of_largest_polygon=TRUE))
ac1a &lt;- autocov_dist(columbus$CRIME, xy, nbs=10, style="B",
 type="one")
acinva &lt;- autocov_dist(columbus$CRIME, xy, nbs=10, style="B",
 type="inverse")
acinv2a &lt;- autocov_dist(columbus$CRIME, xy, nbs=10, style="B",
 type="inverse.squared")
plot(ac1a ~ columbus$CRIME, pch=16, ylim=c(0,9000))
points(acinva ~ columbus$CRIME, pch=16, col="red")
points(acinv2a ~ columbus$CRIME, pch=16, col="blue")
legend("topleft", legend=c("one", "inverse", "inverse.squared"),
 col=c("black", "red", "blue"), bty="n", pch=16)
nb &lt;- dnearneigh(xy, 0, 10)
lw &lt;- nb2listw(nb, style="B")
ac1b &lt;- lag(lw, columbus$CRIME)
all.equal(ac1b, ac1a)
nbd &lt;- nbdists(nb, xy)
gl &lt;- lapply(nbd, function(x) 1/x)
lw &lt;- nb2listw(nb, glist=gl, style="B")
acinvb &lt;- lag(lw, columbus$CRIME)
all.equal(acinvb, acinva)
gl2 &lt;- lapply(nbd, function(x) 1/(x^2))
lw &lt;- nb2listw(nb, glist=gl2, style="B")
acinv2b &lt;- lag(lw, columbus$CRIME)
all.equal(acinv2b, acinv2a)
#xy &lt;- SpatialPoints(xy)
#acinva &lt;- autocov_dist(columbus$CRIME, xy, nbs=10, style="W",
# type="inverse")
#nb &lt;- dnearneigh(xy, 0, 10)
#nbd &lt;- nbdists(nb, xy)
#gl &lt;- lapply(nbd, function(x) 1/x)
#lw &lt;- nb2listw(nb, glist=gl)
#acinvb &lt;- lag(lw, columbus$CRIME)
#all.equal(acinvb, acinva)
acinvc &lt;- autocov_dist(columbus$CRIME, st_centroid(st_geometry(columbus),
 of_largest_polygon=TRUE), nbs=10, style="W", type="inverse")
all.equal(acinvc, acinva)
</code></pre>

<hr>
<h2 id='bhicv'>Data set with 4 life condition indices of Belo Horizonte region</h2><span id='topic+bhicv'></span>

<h3>Description</h3>

<p>The data are collected inthe  Atlas of condition indices published 
by the Joao Pinheiro Foundation and UNDP.
</p>


<h3>Format</h3>

<p>A shape polygon object with seven variables:
</p>

<dl>
<dt>id</dt><dd><p>The identificator</p>
</dd>
<dt>Name</dt><dd><p>Name of city</p>
</dd>
<dt>Population</dt><dd><p>The population of city</p>
</dd>
<dt>HLCI</dt><dd><p>Health Life Condition Index</p>
</dd>
<dt>ELCI</dt><dd><p>Education Life Condition Index</p>
</dd>
<dt>CLCI</dt><dd><p>Children Life Condition Index</p>
</dd>
<dt>ELCI</dt><dd><p>Economic Life Condition Index</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>bh &lt;- st_read(system.file("etc/shapes/bhicv.shp",
      package="spdep")[1])
</code></pre>

<hr>
<h2 id='card'>Cardinalities for neighbours lists</h2><span id='topic+card'></span>

<h3>Description</h3>

<p>The function tallies the numbers of neighbours of regions in the neighbours
list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>card(nb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="card_+3A_nb">nb</code></td>
<td>
<p>a neighbours list object of class <code>nb</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;nb&rdquo; objects are stored as lists of integer vectors, where the vectors contain either the indices in the range <code>1:n</code> for <code>n</code> as <code>length(nb)</code> of the neighbours of region <code>i</code>, or <code>as.integer(0)</code> to signal no neighbours. The function <code>card(nb)</code> is used to extract the numbers of neighbours from the &ldquo;nb&rdquo; object.</p>


<h3>Value</h3>

<p>An integer vector of the numbers of neighbours of regions in the neighbours
list.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Bivand R, Pebesma EJ, Gomez-Rubio V, (2008) <em>Applied Spatial Data Analysis with R</em>, Springer, New York, pp. 239-251; Bivand R, Portnov B, (2004) Exploring spatial data analysis techniques using R: the case of observations with no neighbours. In: Anselin L, Florax R, Rey S, (eds.), <em>Advances in Spatial Econometrics, Methodology, Tools and Applications</em>. Berlin: Springer-Verlag, pp. 121-142.</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
table(card(col.gal.nb))
</code></pre>

<hr>
<h2 id='cell2nb'>Generate neighbours list for grid cells</h2><span id='topic+cell2nb'></span><span id='topic+vi2mrc'></span>

<h3>Description</h3>

<p>The function generates a list of neighbours for a grid of cells. Helper
functions are used to convert to and from the vector indices for row and 
column grid positions, and rook (shared edge) or queen (shared edge or 
vertex) neighbour definitions are applied by type. If torus is TRUE, the 
grid is mapped onto a torus, removing edge effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell2nb(nrow, ncol, type="rook", torus=FALSE, legacy=FALSE, x=NULL)
vi2mrc(i, nrow, ncol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell2nb_+3A_nrow">nrow</code></td>
<td>
<p>number of rows in the grid, may also be an object inheriting from class <code>"SpatialGrid"</code> or <code>"GridTopology"</code> only in <code>cell2nb</code></p>
</td></tr>
<tr><td><code id="cell2nb_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in the grid; if <code>nrow</code> or <code>x</code> is an object inheriting from class <code>"SpatialGrid"</code> or <code>"GridTopology"</code>, it may be omitted</p>
</td></tr>
<tr><td><code id="cell2nb_+3A_type">type</code></td>
<td>
<p>default rook, may also be queen</p>
</td></tr>
<tr><td><code id="cell2nb_+3A_torus">torus</code></td>
<td>
<p>default FALSE, if TRUE map grid onto torus</p>
</td></tr>
<tr><td><code id="cell2nb_+3A_legacy">legacy</code></td>
<td>
<p>default FALSE, nrow/ncol reversed, if TRUE wrong col/row directions (see <a href="https://github.com/r-spatial/spdep/issues/20">https://github.com/r-spatial/spdep/issues/20</a>)</p>
</td></tr>
<tr><td><code id="cell2nb_+3A_x">x</code></td>
<td>
<p>if given, an object inheriting from class <code>"SpatialGrid"</code> or <code>"GridTopology"</code>, and replaces <code>nrow</code> and <code>ncol</code></p>
</td></tr>
<tr><td><code id="cell2nb_+3A_i">i</code></td>
<td>
<p>vector of vector indices corresponding to rowcol, a matrix with two columns of row, column indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids. See <code><a href="#topic+card">card</a></code> for details of &ldquo;nb&rdquo; objects.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code>, <code><a href="#topic+card">card</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nb7rt &lt;- cell2nb(7, 7)
summary(nb7rt)
xyc &lt;- attr(nb7rt, "region.id")
xy &lt;- matrix(as.integer(unlist(strsplit(xyc, ":"))), ncol=2, byrow=TRUE)
plot(nb7rt, xy)
nb7rt &lt;- cell2nb(7, 7, torus=TRUE)
summary(nb7rt)
run &lt;- FALSE
if (require("sp", quietly=TRUE)) run &lt;- TRUE
if (run) {
# https://github.com/r-spatial/spdep/issues/20
GT &lt;- GridTopology(c(1, 1), c(1, 1), c(10, 50))
SPix &lt;- as(SpatialGrid(GT), "SpatialPixels")
nb_rook_cont &lt;- poly2nb(as(SPix, "SpatialPolygons"), queen=FALSE)
nb_rook_dist &lt;- dnearneigh(coordinates(SPix), 0, 1.01)
all.equal(nb_rook_cont, nb_rook_dist, check.attributes=FALSE)
## [1] TRUE
}
if (run) {
t.nb &lt;- cell2nb(GT, type='rook', legacy=TRUE)
isTRUE(all.equal(nb_rook_cont, t.nb, check.attributes=FALSE))
## [1] FALSE
}
if (run) {
t.nb &lt;- cell2nb(GT, type='rook')
isTRUE(all.equal(nb_rook_cont, t.nb, check.attributes=FALSE))
## [1] TRUE
}
if (run) {
# https://github.com/r-spatial/spdep/issues/55
# problem reported in issue caused by rep() cycling in unexpected order
GT &lt;- GridTopology(c(1, 1), c(1, 1), c(22, 11))
SPix &lt;- as(SpatialGrid(GT), "SpatialPixels")
nb_rook_cont &lt;- poly2nb(as(SPix, "SpatialPolygons"), queen=FALSE)
nb_rook_dist &lt;- dnearneigh(coordinates(SPix), 0, 1.01)
all.equal(nb_rook_cont, nb_rook_dist, check.attributes=FALSE)
}
if (run) {
t.nb &lt;- cell2nb(GT, type='rook', legacy=TRUE)
isTRUE(all.equal(nb_rook_cont, t.nb, check.attributes=FALSE))
## [1] FALSE
}
if (run) {
t.nb &lt;- cell2nb(GT, type='rook', legacy=FALSE)
isTRUE(all.equal(nb_rook_cont, t.nb, check.attributes=FALSE))
## [1] TRUE
}
</code></pre>

<hr>
<h2 id='choynowski'>Choynowski probability map values</h2><span id='topic+choynowski'></span>

<h3>Description</h3>

<p>Calculates Choynowski probability map values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choynowski(n, x, row.names=NULL, tol = .Machine$double.eps^0.5, legacy=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choynowski_+3A_n">n</code></td>
<td>
<p>a numeric vector of counts of cases</p>
</td></tr>
<tr><td><code id="choynowski_+3A_x">x</code></td>
<td>
<p>a numeric vector of populations at risk</p>
</td></tr>
<tr><td><code id="choynowski_+3A_row.names">row.names</code></td>
<td>
<p>row names passed through to output data frame</p>
</td></tr>
<tr><td><code id="choynowski_+3A_tol">tol</code></td>
<td>
<p>accumulate values for observed counts &gt;= expected until value less than tol</p>
</td></tr>
<tr><td><code id="choynowski_+3A_legacy">legacy</code></td>
<td>
<p>default FALSE using vectorised alternating side <code>ppois</code> version, if true use original version written from sources and iterating down to <code>tol</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns:
</p>
<table>
<tr><td><code>pmap</code></td>
<td>
<p>Poisson probability map values: probablility of getting a more &ldquo;extreme&rdquo; count than actually observed, one-tailed with less than expected and more than expected folded together</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>logical: TRUE if observed count less than expected</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Choynowski, M (1959) Maps based on probabilities, Journal of
the American Statistical Association, 54, 385&ndash;388; Cressie, N, Read,
TRC (1985), Do sudden infant deaths come in clusters? Statistics and
Decisions, Supplement Issue 2, 333&ndash;349; Bailey T, Gatrell A (1995)
Interactive Spatial Data Analysis, Harlow: Longman, pp. 300&ndash;303.</p>


<h3>See Also</h3>

<p><code><a href="#topic+probmap">probmap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>auckland &lt;- st_read(system.file("shapes/auckland.shp", package="spData")[1], quiet=TRUE)
auckland.nb &lt;- poly2nb(auckland)
res &lt;- choynowski(auckland$M77_85, 9*auckland$Und5_81)
resl &lt;- choynowski(auckland$M77_85, 9*auckland$Und5_81, legacy=TRUE)
all.equal(res, resl)
rt &lt;- sum(auckland$M77_85)/sum(9*auckland$Und5_81)
ch_ppois_pmap &lt;- numeric(length(auckland$Und5_81))
side &lt;- c("greater", "less")
for (i in seq(along=ch_ppois_pmap)) {
  ch_ppois_pmap[i] &lt;- poisson.test(auckland$M77_85[i], r=rt,
    T=(9*auckland$Und5_81[i]), alternative=side[(res$type[i]+1)])$p.value
}
all.equal(ch_ppois_pmap, res$pmap)
res1 &lt;- probmap(auckland$M77_85, 9*auckland$Und5_81)
table(abs(res$pmap - res1$pmap) &lt; 0.00001, res$type)
lt005 &lt;- (res$pmap &lt; 0.05) &amp; (res$type)
ge005 &lt;- (res$pmap &lt; 0.05) &amp; (!res$type)
cols &lt;- rep("nonsig", length(lt005))
cols[lt005] &lt;- "low"
cols[ge005] &lt;- "high"
auckland$cols &lt;- factor(cols)
plot(auckland[,"cols"], main="Probability map")
</code></pre>

<hr>
<h2 id='columbus'>Columbus OH spatial analysis data set</h2><span id='topic+columbus'></span><span id='topic+col.gal.nb'></span><span id='topic+coords'></span><span id='topic+bbs'></span><span id='topic+polys'></span>

<h3>Description</h3>

<p>The data set is now part of the spData package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(columbus)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
</code></pre>

<hr>
<h2 id='diffnb'>Differences between neighbours lists</h2><span id='topic+diffnb'></span>

<h3>Description</h3>

<p>The function finds differences between lists of neighbours, returning a <code>nb</code> neighbour list of those found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffnb(x, y, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffnb_+3A_x">x</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="diffnb_+3A_y">y</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="diffnb_+3A_verbose">verbose</code></td>
<td>
<p>default NULL, use global option value; report regions ids taken from object attribute &quot;region.id&quot; with differences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A neighbours list with class <code>nb</code>
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
coords &lt;- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE)
rn &lt;- row.names(columbus)
knn1 &lt;- knearneigh(coords, 1)
knn2 &lt;- knearneigh(coords, 2)
nb1 &lt;- knn2nb(knn1, row.names=rn)
nb2 &lt;- knn2nb(knn2, row.names=rn)
diffs &lt;- diffnb(nb2, nb1)
opar &lt;- par(no.readonly=TRUE)
plot(st_geometry(columbus), border="grey", reset=FALSE,
 main="Plot of first (black) and second (red)\nnearest neighbours")
plot(nb1, coords, add=TRUE)
plot(diffs, coords, add=TRUE, col="red", lty=2)
par(opar)
</code></pre>

<hr>
<h2 id='dnearneigh'>Neighbourhood contiguity by distance</h2><span id='topic+dnearneigh'></span>

<h3>Description</h3>

<p>The function identifies neighbours of region points by Euclidean distance in the metric of the points between lower (greater than or equal to (changed from version 1.1-7)) and upper (less than or equal to) bounds, or with longlat = TRUE, by Great Circle distance in kilometers. If <code>x</code> is an <code>"sf"</code> object and <code>use_s2=</code> is <code>TRUE</code>, spherical distances in km are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c("GE", "LE"),
 use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion("s2") &gt; "1.0.7", k=200,
 dwithin=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnearneigh_+3A_x">x</code></td>
<td>
<p>matrix of point coordinates, an object inheriting from SpatialPoints or an <code>"sf"</code> or <code>"sfc"</code> object; if the <code>"sf"</code> or <code>"sfc"</code> object geometries are in geographical coordinates (<code>use_s2=FALSE</code>, <code>sf::st_is_longlat(x) == TRUE</code> and <code>sf::sf_use_s2() == TRUE</code>), <span class="pkg">s2</span> will be used to find the neighbours because it will (we hope) use spatial indexing <a href="https://github.com/r-spatial/s2/issues/125">https://github.com/r-spatial/s2/issues/125</a> as opposed to the legacy method which uses brute-force (at present <span class="pkg">s2</span> also uses brute-force)</p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_d1">d1</code></td>
<td>
<p>lower distance bound in the metric of the points if planar coordinates, in km if in geographical coordinates</p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_d2">d2</code></td>
<td>
<p>upper distance boundd in the metric of the points if planar coordinates, in km if in geographical coordinates</p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_row.names">row.names</code></td>
<td>
<p>character vector of region ids to be added to the neighbours list as attribute <code>region.id</code>, default <code>seq(1, nrow(x))</code></p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are geographical longitude-latitude decimal degrees, in which case distances are measured in kilometers; if x is a SpatialPoints object, the value is taken from the object itself, and overrides this argument if not NULL</p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_bounds">bounds</code></td>
<td>
<p>character vector of length 2, default <code>c("GE", "LE")</code>, (GE: greater than or equal to, LE: less than or equal to) that is the finite and closed interval <code>[d1, d2]</code>, <code>d1 &lt;= x &lt;= d2</code>. The first element may also be <code>"GT"</code> (GT: greater than), the second <code>"LT"</code> (LT: less than) for finite, open intervals excluding the bounds; the first bound default was changed from <code>"GT"</code> to <code>"GE"</code> in release 1.1-7. When creating multiple distance bands, finite, half-open right-closed intervals may be used until the final interval to avoid overlapping on bounds: <code>"GE", "LT"</code>, that is <code>[d1, d2)</code>, <code>d1 &lt;= x &lt; d2</code></p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_use_kd_tree">use_kd_tree</code></td>
<td>
<p>default TRUE, if TRUE, use <span class="pkg">dbscan</span> <code><a href="dbscan.html#topic+frNN">frNN</a></code> if available (permitting 3D distances).</p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_symtest">symtest</code></td>
<td>
<p>Default FALSE; before release 1.1-7, TRUE - run symmetry check on output object, costly with large numbers of points.</p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_use_s2">use_s2</code></td>
<td>
<p>default=<code>packageVersion("s2") &gt; "1.0.7"</code>, as of <span class="pkg">s2</span> &gt; 1.0-7, distance bound computations use spatial indexing so when <code>sf::sf_use_s2()</code> is TRUE, <code>s2::s2_dwithin_matrix()</code> will be used for distances on the sphere for <code>"sf"</code> or <code>"sfc"</code> objects if <span class="pkg">s2</span> &gt; 1.0-7.</p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_k">k</code></td>
<td>
<p>default 200, the number of closest points to consider when searching when using  <code>s2::s2_closest_edges()</code></p>
</td></tr>
<tr><td><code id="dnearneigh_+3A_dwithin">dwithin</code></td>
<td>
<p>default TRUE, if FALSE, use <code>s2::s2_closest_edges()</code>, both if <code>use_s2=TRUE</code>, <code>sf::st_is_longlat(x) == TRUE</code> and <code>sf::sf_use_s2() == TRUE</code>; <code>s2::s2_dwithin_matrix()</code> yields the same lists of neighbours as <code>s2::s2_closest_edges()</code> is <code>k=</code> is set correctly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of integer vectors giving the region id numbers
for neighbours satisfying the distance criteria. See <code><a href="#topic+card">card</a></code> for details of &ldquo;nb&rdquo; objects.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+knearneigh">knearneigh</a></code>, <code><a href="#topic+card">card</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
coords &lt;- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE)
rn &lt;- row.names(columbus)
k1 &lt;- knn2nb(knearneigh(coords))
all.linked &lt;- max(unlist(nbdists(k1, coords)))
col.nb.0.all &lt;- dnearneigh(coords, 0, all.linked, row.names=rn)
summary(col.nb.0.all, coords)
opar &lt;- par(no.readonly=TRUE)
plot(st_geometry(columbus), border="grey", reset=FALSE,
 main=paste("Distance based neighbours 0-",  format(all.linked), sep=""))
plot(col.nb.0.all, coords, add=TRUE)
par(opar)
(sfc_obj &lt;- st_centroid(st_geometry(columbus)))
col.nb.0.all_sf &lt;- dnearneigh(sfc_obj, 0, all.linked, row.names=rn)
all.equal(col.nb.0.all, col.nb.0.all_sf, check.attributes=FALSE)
data(state)
us48.fipsno &lt;- read.geoda(system.file("etc/weights/us48.txt",
 package="spdep")[1])
if (as.numeric(paste(version$major, version$minor, sep="")) &lt; 19) {
 m50.48 &lt;- match(us48.fipsno$"State.name", state.name)
} else {
 m50.48 &lt;- match(us48.fipsno$"State_name", state.name)
}
xy &lt;- as.matrix(as.data.frame(state.center))[m50.48,]
llk1 &lt;- knn2nb(knearneigh(xy, k=1, longlat=FALSE))
(all.linked &lt;- max(unlist(nbdists(llk1, xy, longlat=FALSE))))
ll.nb &lt;- dnearneigh(xy, 0, all.linked, longlat=FALSE)
summary(ll.nb, xy, longlat=TRUE, scale=0.5)
gck1 &lt;- knn2nb(knearneigh(xy, k=1, longlat=TRUE))
(all.linked &lt;- max(unlist(nbdists(gck1, xy, longlat=TRUE))))
gc.nb &lt;- dnearneigh(xy, 0, all.linked, longlat=TRUE)
summary(gc.nb, xy, longlat=TRUE, scale=0.5)
plot(ll.nb, xy)
plot(diffnb(ll.nb, gc.nb), xy, add=TRUE, col="red", lty=2)
title(main="Differences Euclidean/Great Circle")

#xy1 &lt;- SpatialPoints((as.data.frame(state.center))[m50.48,],
#  proj4string=CRS("+proj=longlat +ellps=GRS80"))
#gck1a &lt;- knn2nb(knearneigh(xy1, k=1))
#(all.linked &lt;- max(unlist(nbdists(gck1a, xy1))))
#gc.nb &lt;- dnearneigh(xy1, 0, all.linked)
#summary(gc.nb, xy1, scale=0.5)

xy1 &lt;- st_as_sf((as.data.frame(state.center))[m50.48,], coords=1:2,
  crs=st_crs("OGC:CRS84"))
old_use_s2 &lt;- sf_use_s2()
sf_use_s2(TRUE)
gck1b &lt;- knn2nb(knearneigh(xy1, k=1))
system.time(o &lt;- nbdists(gck1b, xy1))
(all.linked &lt;- max(unlist(o)))
# use s2 brute-force dwithin_matrix approach for s2 &lt;= 1.0.7
system.time(gc.nb.dwithin &lt;- dnearneigh(xy1, 0, all.linked, use_s2=TRUE, dwithin=TRUE))
summary(gc.nb, xy1, scale=0.5)
# use s2 closest_edges approach s2 &gt; 1.0.7
if (packageVersion("s2") &gt; "1.0.7") {
(system.time(gc.nb.closest &lt;- dnearneigh(xy1, 0, all.linked, dwithin=FALSE)))
}
if (packageVersion("s2") &gt; "1.0.7") {
system.time(gc.nb.dwithin &lt;- dnearneigh(xy1, 0, all.linked, use_s2=TRUE, dwithin=TRUE))
}
if (packageVersion("s2") &gt; "1.0.7") {
summary(gc.nb.dwithin, xy1, scale=0.5)
}
if (packageVersion("s2") &gt; "1.0.7") {
summary(gc.nb.closest, xy1, scale=0.5)
}
# use legacy symmetric brute-force approach
system.time(gc.nb.legacy &lt;- dnearneigh(xy1, 0, all.linked, use_s2=FALSE))
summary(gc.nb, xy1, scale=0.5)
if (packageVersion("s2") &gt; "1.0.7") all.equal(gc.nb.closest, gc.nb.dwithin, check.attributes=FALSE)
# legacy is ellipsoidal, s2 spherical, so minor differences expected
if (packageVersion("s2") &gt; "1.0.7") all.equal(gc.nb, gc.nb.closest, check.attributes=FALSE)
all.equal(gc.nb, gc.nb.dwithin, check.attributes=FALSE)
sf_use_s2(old_use_s2)
# example of reading points with readr::read_csv() yielding a tibble
load(system.file("etc/misc/coords.rda", package="spdep"))
class(coords)
k1 &lt;- knn2nb(knearneigh(coords, k=1))
all.linked &lt;- max(unlist(nbdists(k1, coords)))
dnearneigh(coords, 0, all.linked)
</code></pre>

<hr>
<h2 id='droplinks'>Drop links in a neighbours list</h2><span id='topic+droplinks'></span>

<h3>Description</h3>

<p>Drops links to and from or just to a region from a neighbours list. The example corresponds to Fingleton's Table 1, p. 6, for lattices 5 to 19.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>droplinks(nb, drop, sym=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="droplinks_+3A_nb">nb</code></td>
<td>
<p>a neighbours list object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="droplinks_+3A_drop">drop</code></td>
<td>
<p>either a logical vector the length of <code>nb</code>, or a character vector of named regions corresponding to <code>nb</code>'s region.id attribute, or an integer vector of region numbers</p>
</td></tr>
<tr><td><code id="droplinks_+3A_sym">sym</code></td>
<td>
<p>TRUE for removal of both &quot;row&quot; and &quot;column&quot; links, FALSE for only &quot;row&quot; links</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids. 
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>B. Fingleton (1999) Spurious spatial regression: some Monte Carlo results with a spatial unit root and spatial cointegration, Journal of Regional Science 39, pp. 1&ndash;19.</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.symmetric.nb">is.symmetric.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rho &lt;- c(0.2, 0.5, 0.95, 0.999, 1.0)
ns &lt;- c(5, 7, 9, 11, 13, 15, 17, 19)
mns &lt;- matrix(0, nrow=length(ns), ncol=length(rho))
rownames(mns) &lt;- ns
colnames(mns) &lt;- rho
mxs &lt;- matrix(0, nrow=length(ns), ncol=length(rho))
rownames(mxs) &lt;- ns
colnames(mxs) &lt;- rho
for (i in 1:length(ns)) {
  nblist &lt;- cell2nb(ns[i], ns[i])
  nbdropped &lt;- droplinks(nblist, ((ns[i]*ns[i])+1)/2, sym=FALSE)
  listw &lt;- nb2listw(nbdropped, style="W", zero.policy=TRUE)
  wmat &lt;- listw2mat(listw)
  for (j in 1:length(rho)) {
    mat &lt;- diag(ns[i]*ns[i]) - rho[j] * wmat
    res &lt;- diag(solve(t(mat) %*% mat))
    mns[i,j] &lt;- mean(res)
    mxs[i,j] &lt;- max(res)
  }
}
print(mns)
print(mxs)



</code></pre>

<hr>
<h2 id='EBest'>Global Empirical Bayes estimator</h2><span id='topic+EBest'></span>

<h3>Description</h3>

<p>The function computes global empirical Bayes estimates for rates &quot;shrunk&quot; to the overall mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBest(n, x, family="poisson")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EBest_+3A_n">n</code></td>
<td>
<p>a numeric vector of counts of cases</p>
</td></tr>
<tr><td><code id="EBest_+3A_x">x</code></td>
<td>
<p>a numeric vector of populations at risk</p>
</td></tr>
<tr><td><code id="EBest_+3A_family">family</code></td>
<td>
<p>either &quot;poisson&quot; for rare conditions or &quot;binomial&quot; for non-rare conditions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the implementation for the &quot;poisson&quot; family are to be found in Marshall, p. 284&ndash;5, and Bailey and Gatrell p. 303&ndash;306 and exercise 8.2, pp. 328&ndash;330. For the &quot;binomial&quot; family, see Martuzzi and Elliott (implementation by Olaf Berke).
</p>


<h3>Value</h3>

<p>A data frame with two columns:
</p>
<table>
<tr><td><code>raw</code></td>
<td>
<p>a numerical vector of raw (crude) rates</p>
</td></tr>
<tr><td><code>estmm</code></td>
<td>
<p>a numerical vector of empirical Bayes estimates</p>
</td></tr>
</table>
<p>and a <code>parameters</code> attribute list with components:
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>global method of moments phi value</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>global method of moments gamma value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> and Olaf Berke, Population Medicine, OVC, University of Guelph, CANADA</p>


<h3>References</h3>

<p>Marshall R M (1991) Mapping disease and mortality rates using Empirical Bayes Estimators, Applied Statistics, 40, 283&ndash;294; Bailey T, Gatrell A (1995) Interactive Spatial Data Analysis, Harlow: Longman, pp. 303&ndash;306, Martuzzi M, Elliott P (1996) Empirical Bayes estimation of small area prevalence of non-rare conditions, Statistics in Medicine 15, 1867&ndash;1873.</p>


<h3>See Also</h3>

<p><code><a href="#topic+EBlocal">EBlocal</a></code>, <code><a href="#topic+probmap">probmap</a></code>, <code><a href="#topic+EBImoran.mc">EBImoran.mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>auckland &lt;- st_read(system.file("shapes/auckland.shp", package="spData")[1], quiet=TRUE)
res &lt;- EBest(auckland$M77_85, 9*auckland$Und5_81)
attr(res, "parameters")
auckland$estmm000 &lt;- res$estmm*1000
plot(auckland[,"estmm000"], breaks=c(0,2,2.5,3,3.5,5),
 main="Infant mortality per 1000 per year")
data(huddersfield, package="spData")
res &lt;- EBest(huddersfield$cases, huddersfield$total, family="binomial")
round(res[,1:2],4)*100
</code></pre>

<hr>
<h2 id='EBImoran.mc'>Permutation test for empirical Bayes index</h2><span id='topic+EBImoran.mc'></span><span id='topic+EBImoran'></span>

<h3>Description</h3>

<p>An empirical Bayes index modification of Moran's I for testing for spatial autocorrelation in a rate, typically the number of observed cases in a population at risk. The index value is tested by using nsim random permutations of the index for the given spatial weighting scheme, to establish the rank of the observed statistic in relation to the nsim simulated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBImoran.mc(n, x, listw, nsim, zero.policy = attr(listw, "zero.policy"), 
 alternative = "greater", spChk=NULL, return_boot=FALSE,
 subtract_mean_in_numerator=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EBImoran.mc_+3A_n">n</code></td>
<td>
<p>a numeric vector of counts of cases the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="EBImoran.mc_+3A_x">x</code></td>
<td>
<p>a numeric vector of populations at risk the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="EBImoran.mc_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="EBImoran.mc_+3A_nsim">nsim</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="EBImoran.mc_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="EBImoran.mc_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;two.sided&quot;, or &quot;less&quot;</p>
</td></tr>
<tr><td><code id="EBImoran.mc_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="EBImoran.mc_+3A_return_boot">return_boot</code></td>
<td>
<p>return an object of class <code>boot</code> from the equivalent permutation bootstrap rather than an object of class <code>htest</code></p>
</td></tr>
<tr><td><code id="EBImoran.mc_+3A_subtract_mean_in_numerator">subtract_mean_in_numerator</code></td>
<td>
<p>default TRUE, if TRUE subtract mean of z in numerator of EBI equation on p. 2157 in reference (consulted with Renato Assunção 2016-02-19); until February 2016 the default was FALSE agreeing with the printed paper.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic used is (m is the number of observations):
</p>
<p style="text-align: center;"><code class="reqn">EBI = \frac{m}{\sum_{i=1}^{m}\sum_{j=1}^{m}w_{ij}}
\frac{\sum_{i=1}^{m}\sum_{j=1}^{m}w_{ij}z_i z_j}{\sum_{i=1}^{m}(z_i - \bar{z})^2}
</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">z_i = \frac{p_i - b}{\sqrt{v_i}}</code>
</p>

<p>and:
</p>
<p style="text-align: center;"><code class="reqn">p_i = n_i / x_i</code>
</p>

<p style="text-align: center;"><code class="reqn">v_i = a + (b / x_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">b = \sum_{i=1}^{m} n_i / \sum_{i=1}^{m} x_i </code>
</p>

<p style="text-align: center;"><code class="reqn">a = s^2 - b / (\sum_{i=1}^{m} x_i / m)</code>
</p>

<p style="text-align: center;"><code class="reqn">s^2 = \sum_{i=1}^{m} x_i (p_i - b)^2 / \sum_{i=1}^{m} x_i </code>
</p>



<h3>Value</h3>

<p>A list with class <code>htest</code> and <code>mc.sim</code> containing the 
following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the observed Moran's I.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the rank of the observed Moran's I.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the pseudo p-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data, and the number of simulations.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>nsim simulated values of statistic, final value is observed statistic</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>a numerical vector of Empirical Bayes indices as z above</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Assunção RM, Reis EA 1999 A new proposal to adjust Moran's I for population density. Statistics in Medicine 18, pp. 2147&ndash;2162; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran">moran</a></code>, <code><a href="#topic+moran.mc">moran.mc</a></code>, <code><a href="#topic+EBest">EBest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nc.sids &lt;- st_read(system.file("shapes/sids.shp", package="spData")[1], quiet=TRUE)
rn &lt;- as.character(nc.sids$FIPS)
ncCC89_nb &lt;- read.gal(system.file("weights/ncCC89.gal", package="spData")[1],
 region.id=rn)
EBImoran.mc(nc.sids$SID74, nc.sids$BIR74,
 nb2listw(ncCC89_nb, style="B", zero.policy=TRUE), nsim=999,
 alternative="two.sided", zero.policy=TRUE)
sids.p &lt;- nc.sids$SID74 / nc.sids$BIR74
moran.mc(sids.p, nb2listw(ncCC89_nb, style="B", zero.policy=TRUE),
 nsim=999, alternative="two.sided", zero.policy=TRUE)
</code></pre>

<hr>
<h2 id='EBlocal'>Local Empirical Bayes estimator</h2><span id='topic+EBlocal'></span>

<h3>Description</h3>

<p>The function computes local empirical Bayes estimates for rates &quot;shrunk&quot; to a neighbourhood mean for neighbourhoods given by the <code>nb</code> neighbourhood list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBlocal(ri, ni, nb, zero.policy = NULL, spChk = NULL, geoda=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EBlocal_+3A_ri">ri</code></td>
<td>
<p>a numeric vector of counts of cases the same length as the neighbours list in nb; if there are many zero counts, some estimates may be affected by division by zero, see <a href="https://stat.ethz.ch/pipermail/r-sig-geo/2022-January/028882.html">https://stat.ethz.ch/pipermail/r-sig-geo/2022-January/028882.html</a></p>
</td></tr>
<tr><td><code id="EBlocal_+3A_ni">ni</code></td>
<td>
<p>a numeric vector of populations at risk the same length as the neighbours list in nb</p>
</td></tr>
<tr><td><code id="EBlocal_+3A_nb">nb</code></td>
<td>
<p>a <code>nb</code> object of neighbour relationships</p>
</td></tr>
<tr><td><code id="EBlocal_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="EBlocal_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="EBlocal_+3A_geoda">geoda</code></td>
<td>
<p>default=FALSE, following Marshall's algorithm as interpreted by Bailey and Gatrell, pp. 305-307, and exercise 8.2, pp. 328-330 for the definition of phi; TRUE for the definition of phi used in GeoDa (see discussion on OpenSpace mailing list June 2003: http://agec221.agecon.uiuc.edu/pipermail/openspace/2003-June/thread.html)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the implementation are to be found in Marshall, p. 286, and Bailey and Gatrell p. 307 and exercise 8.2, pp. 328&ndash;330. The example results do not fully correspond to the sources because of slightly differing neighbourhoods, but are generally close. If there are many zero counts, some estimates may be affected by division by zero, see <a href="https://stat.ethz.ch/pipermail/r-sig-geo/2022-January/028882.html">https://stat.ethz.ch/pipermail/r-sig-geo/2022-January/028882.html</a>.
</p>


<h3>Value</h3>

<p>A data frame with two columns:
</p>
<table>
<tr><td><code>raw</code></td>
<td>
<p>a numerical vector of raw (crude) rates</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>a numerical vector of local empirical Bayes estimates</p>
</td></tr>
</table>
<p>and a <code>parameters</code> attribute list with components (if both are zero, the estimate will be <code>NaN</code>, <a href="https://stat.ethz.ch/pipermail/r-sig-geo/2022-January/028882.html">https://stat.ethz.ch/pipermail/r-sig-geo/2022-January/028882.html</a>):
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>a numerical vector of local phi values</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>a numerical vector of local gamma values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a>, based on contributions by Marilia Carvalho</p>


<h3>References</h3>

<p>Marshall R M (1991) Mapping disease and mortality rates using Empirical Bayes Estimators, Applied Statistics, 40, 283&ndash;294; Bailey T, Gatrell A (1995) Interactive Spatial Data Analysis, Harlow: Longman, pp. 303&ndash;306.</p>


<h3>See Also</h3>

<p><code><a href="#topic+EBest">EBest</a></code>, <code><a href="#topic+probmap">probmap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>auckland &lt;- st_read(system.file("shapes/auckland.shp", package="spData")[1], quiet=TRUE)
auckland.nb &lt;- poly2nb(auckland)
res &lt;- EBlocal(auckland$M77_85,  9*auckland$Und5_81, auckland.nb)
auckland$est000 &lt;- res$est*1000
plot(auckland[,"est000"], breaks=c(0,2,2.5,3,3.5,8),
 main="Infant mortality per 1000 per year")
</code></pre>

<hr>
<h2 id='edit.nb'>Interactive editing of neighbours lists</h2><span id='topic+edit.nb'></span>

<h3>Description</h3>

<p>The function provides simple interactive editing of neighbours lists to
allow unneeded links to be deleted, and missing links to be inserted. It uses <code>identify</code> to pick the
endpoints of the link to be deleted or added, and asks for confirmation before
committing. If the result is not assigned to a new object, the editing
will be lost - as in <code>edit</code>.
</p>
<p>This method relies on direct contact with the graphics device. Do not use in RStudio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nb'
edit(name, coords, polys=NULL, ..., use_region.id=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edit.nb_+3A_name">name</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="edit.nb_+3A_coords">coords</code></td>
<td>
<p>matrix of region point coordinates; if missing and polys= inherits from <code>SpatialPolygons</code>, the label points of that object are used</p>
</td></tr>
<tr><td><code id="edit.nb_+3A_polys">polys</code></td>
<td>
<p>if polygon boundaries supplied, will be used as background; must inherit from <code>SpatialPolygons</code></p>
</td></tr>
<tr><td><code id="edit.nb_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="edit.nb_+3A_use_region.id">use_region.id</code></td>
<td>
<p>default <code>FALSE</code>, in <code>identify</code> use 1-based observation numbers, otherwise use the <code>nb</code> <code>region.id</code> attribute values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>nb</code> with the edited list of integer vectors containing neighbour region number ids, with added attributes tallying the added and deleted links.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code>, <code><a href="#topic+plot.nb">plot.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
class(columbus)
if (FALSE) nnb1 &lt;- edit.nb(col.gal.nb, polys=as(columbus, "Spatial"))

## End(Not run)
</code></pre>

<hr>
<h2 id='eire'>Eire data sets</h2><span id='topic+eire'></span><span id='topic+eire.coords.utm'></span><span id='topic+eire.df'></span><span id='topic+eire.nb'></span><span id='topic+eire.polys.utm'></span>

<h3>Description</h3>

<p>The data set is now part of the spData package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eire)</code></pre>

<hr>
<h2 id='geary'>Compute Geary's C</h2><span id='topic+geary'></span>

<h3>Description</h3>

<p>A simple function to compute Geary's C, called by <code>geary.test</code> and <code>geary.mc</code>;
</p>
<p style="text-align: center;"><code class="reqn">C = \frac{(n-1)}{2\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}}
\frac{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}(x_i-x_j)^2}{\sum_{i=1}^{n}(x_i - \bar{x})^2}
</code>
</p>

<p><code>geary.intern</code> is an internal function used to vary the similarity
criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geary(x, listw, n, n1, S0, zero.policy=attr(listw, "zero.policy"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geary_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="geary_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="geary_+3A_n">n</code></td>
<td>
<p>number of zones</p>
</td></tr>
<tr><td><code id="geary_+3A_n1">n1</code></td>
<td>
<p>n - 1</p>
</td></tr>
<tr><td><code id="geary_+3A_s0">S0</code></td>
<td>
<p>global sum of weights</p>
</td></tr>
<tr><td><code id="geary_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with
</p>
<table>
<tr><td><code>C</code></td>
<td>
<p>Geary's C</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>sample kurtosis of x</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 17.</p>


<h3>See Also</h3>

<p><code><a href="#topic+geary.test">geary.test</a></code>, <code><a href="#topic+geary.mc">geary.mc</a></code>, 
<code><a href="#topic+sp.mantel.mc">sp.mantel.mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
col.W &lt;- nb2listw(COL.nb, style="W")
str(geary(COL.OLD$CRIME, col.W, length(COL.nb), length(COL.nb)-1,
 Szero(col.W)))
</code></pre>

<hr>
<h2 id='geary.mc'>Permutation test for Geary's C statistic</h2><span id='topic+geary.mc'></span>

<h3>Description</h3>

<p>A permutation test for Geary's C statistic calculated by using nsim random permutations of x for the given spatial weighting scheme, to establish the rank of the observed statistic in relation to the nsim simulated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geary.mc(x, listw, nsim, zero.policy=attr(listw, "zero.policy"), alternative="greater",
 spChk=NULL, adjust.n=TRUE, return_boot=FALSE, na.action=na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geary.mc_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="geary.mc_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="geary.mc_+3A_nsim">nsim</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="geary.mc_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="geary.mc_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), or &quot;less&quot;; this reversal corresponds to that on <code><a href="#topic+geary.test">geary.test</a></code> described in the section on the output statistic value, based on Cliff and Ord 1973, p. 21 (changed 2011-04-11, thanks to Daniel Garavito).</p>
</td></tr>
<tr><td><code id="geary.mc_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="geary.mc_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="geary.mc_+3A_return_boot">return_boot</code></td>
<td>
<p>return an object of class <code>boot</code> from the equivalent permutation bootstrap rather than an object of class <code>htest</code></p>
</td></tr>
<tr><td><code id="geary.mc_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. <code>na.pass</code> is not permitted because it is meaningless in a permutation test.</p>
</td></tr></table>


<h3>Value</h3>

<p>A list with class <code>htest</code> and <code>mc.sim</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the observed Geary's C.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the rank of the observed Geary's C.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the pseudo p-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data, and the number of simulations.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>nsim simulated values of statistic, final value is observed statistic</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 63-5.</p>


<h3>See Also</h3>

<p><code><a href="#topic+geary">geary</a></code>, <code><a href="#topic+geary.test">geary.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
set.seed(1)
sim1 &lt;- geary.mc(COL.OLD$CRIME, nb2listw(COL.nb, style="W"),
 nsim=99, alternative="less")
sim1
mean(sim1$res)
var(sim1$res)
summary(sim1$res)
colold.lags &lt;- nblag(COL.nb, 3)
sim2 &lt;- geary.mc(COL.OLD$CRIME, nb2listw(colold.lags[[2]],
 style="W"), nsim=99)
sim2
summary(sim2$res)
sim3 &lt;- geary.mc(COL.OLD$CRIME, nb2listw(colold.lags[[3]],
 style="W"), nsim=99)
sim3
summary(sim3$res)
crime &lt;- COL.OLD$CRIME
is.na(crime) &lt;- sample(1:length(crime), 10)
try(geary.mc(crime, nb2listw(COL.nb, style="W"), nsim=99,
 na.action=na.fail))
geary.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, zero.policy=TRUE,
 na.action=na.omit)
geary.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, zero.policy=TRUE,
 return_boot=TRUE, na.action=na.omit)
geary.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, zero.policy=TRUE,
 na.action=na.exclude)
geary.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, zero.policy=TRUE,
 return_boot=TRUE, na.action=na.exclude)
try(geary.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, na.action=na.pass))
</code></pre>

<hr>
<h2 id='geary.test'>Geary's C test for spatial autocorrelation</h2><span id='topic+geary.test'></span>

<h3>Description</h3>

<p>Geary's test for spatial autocorrelation using a spatial weights matrix in weights list form. The assumptions underlying the test are sensitive to the form of the graph of neighbour relationships and other factors, and results may be checked against those of <code>geary.mc</code> permutations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geary.test(x, listw, randomisation=TRUE, zero.policy=attr(listw, "zero.policy"),
    alternative="greater", spChk=NULL, adjust.n=TRUE, na.action=na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geary.test_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="geary.test_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="geary.test_+3A_randomisation">randomisation</code></td>
<td>
<p>variance of I calculated under the assumption of randomisation, if FALSE normality</p>
</td></tr>
<tr><td><code id="geary.test_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="geary.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;less&quot; or &quot;two.sided&quot;.</p>
</td></tr>
<tr><td><code id="geary.test_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="geary.test_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="geary.test_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. <code>na.pass</code> is not permitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the standard deviate of Geary's C, in the order given in Cliff and Ord 1973, p. 21, which is (EC - C) / sqrt(VC), that is with the sign reversed with respect to the more usual (C - EC) / sqrt(VC); this means that the &ldquo;greater&rdquo; alternative for the Geary C test corresponds to the &ldquo;greater&rdquo; alternative for Moran's I test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed Geary's C, its expectation and 
variance under the method assumption.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the assumption used for calculating 
the standard deviate.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The derivation of the test (Cliff and Ord, 1981, p. 18) assumes that the weights matrix is symmetric. For inherently non-symmetric matrices, such as k-nearest neighbour matrices, <code>listw2U()</code> can be used to make the matrix symmetric. In non-symmetric weights matrix cases, the variance of the test statistic may be negative (thanks to Franz Munoz I for a well documented bug report). Geary's C is affected by non-symmetric weights under normality much more than Moran's I. From 0.4-35, the sign of the standard deviate of C is changed to match Cliff and Ord (1973, p. 21).
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 21, Cliff, A. D., Ord, J. K. 1973 Spatial Autocorrelation, Pion, pp. 15-16, 21; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+geary">geary</a></code>, <code><a href="#topic+geary.mc">geary.mc</a></code>, <code><a href="#topic+listw2U">listw2U</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
geary.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"))
geary.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"),
 randomisation=FALSE)
colold.lags &lt;- nblag(COL.nb, 3)
geary.test(COL.OLD$CRIME, nb2listw(colold.lags[[2]],
 style="W"))
geary.test(COL.OLD$CRIME, nb2listw(colold.lags[[3]],
 style="W"), alternative="greater")
print(is.symmetric.nb(COL.nb))
coords.OLD &lt;- cbind(COL.OLD$X, COL.OLD$Y)
COL.k4.nb &lt;- knn2nb(knearneigh(coords.OLD, 4))
print(is.symmetric.nb(COL.k4.nb))
geary.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style="W"))
geary.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style="W"),
 randomisation=FALSE)
cat("Note non-symmetric weights matrix - use listw2U()\n")
geary.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,
 style="W")))
geary.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,
 style="W")), randomisation=FALSE)
crime &lt;- COL.OLD$CRIME
is.na(crime) &lt;- sample(1:length(crime), 10)
try(geary.test(crime, nb2listw(COL.nb, style="W"), na.action=na.fail))
geary.test(crime, nb2listw(COL.nb, style="W"), zero.policy=TRUE,
 na.action=na.omit)
geary.test(crime, nb2listw(COL.nb, style="W"), zero.policy=TRUE,
 na.action=na.exclude)
try(geary.test(crime, nb2listw(COL.nb, style="W"), na.action=na.pass))
</code></pre>

<hr>
<h2 id='globalG.test'>Global G test for spatial autocorrelation</h2><span id='topic+globalG.test'></span>

<h3>Description</h3>

<p>The global G statistic for spatial autocorrelation, complementing the local Gi LISA measures: <code><a href="#topic+localG">localG</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalG.test(x, listw, zero.policy=attr(listw, "zero.policy"), alternative="greater",
 spChk=NULL, adjust.n=TRUE, B1correct=TRUE, adjust.x=TRUE, Arc_all_x=FALSE,
 na.action=na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="globalG.test_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="globalG.test_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code>; if a sequence of distance bands is to be used, it is recommended that the weights style be binary (one of <code>c("B", "C", "U")</code>).</p>
</td></tr>
<tr><td><code id="globalG.test_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="globalG.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;less&quot; or &quot;two.sided&quot;.</p>
</td></tr>
<tr><td><code id="globalG.test_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="globalG.test_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="globalG.test_+3A_b1correct">B1correct</code></td>
<td>
<p>default TRUE, if TRUE, the erratum referenced below: &quot;On page 195, the coefficient of W2 in B1, (just below center of the page) should be 6,  not 3.&quot; is applied; if FALSE, 3 is used (as in CrimeStat IV)</p>
</td></tr>
<tr><td><code id="globalG.test_+3A_adjust.x">adjust.x</code></td>
<td>
<p>default TRUE, if TRUE, x values of observations with no neighbours are omitted in the denominator of G</p>
</td></tr>
<tr><td><code id="globalG.test_+3A_arc_all_x">Arc_all_x</code></td>
<td>
<p>default FALSE, if Arc_all_x=TRUE and adjust.x=TRUE, use the full x vector in part of the denominator term for G</p>
</td></tr>
<tr><td><code id="globalG.test_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. <code>na.pass</code> is not permitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the standard deviate of Getis-Ord G.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed statistic, its expectation and variance.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hisaji ONO <a href="mailto:hi-ono@mn.xdsl.ne.jp">hi-ono@mn.xdsl.ne.jp</a> and Roger Bivand 
<a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Getis. A, Ord, J. K. 1992 The analysis of spatial association by 
use of distance statistics, <em>Geographical Analysis</em>, 24, p. 195; see
also Getis. A, Ord, J. K. 1993 Erratum, <em>Geographical Analysis</em>, 25, 
p. 276; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+localG">localG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nc.sids &lt;- st_read(system.file("shapes/sids.shp", package="spData")[1], quiet=TRUE)
sidsrate79 &lt;- (1000*nc.sids$SID79)/nc.sids$BIR79
dists &lt;- c(10, 20, 30, 33, 40, 50, 60, 70, 80, 90, 100)
ndists &lt;- length(dists)
ZG &lt;- vector(mode="list", length=ndists)
names(ZG) &lt;- as.character(dists)
milesxy &lt;- cbind(nc.sids$east, nc.sids$north)
for (i in 1:ndists) {
  thisnb &lt;- dnearneigh(milesxy, 0, dists[i])
  thislw &lt;- nb2listw(thisnb, style="B", zero.policy=TRUE)
  ZG[[i]] &lt;- globalG.test(sidsrate79, thislw, zero.policy=TRUE)
}
t(sapply(ZG, function(x) c(x$estimate[1], x$statistic, p.value=unname(x$p.value))))
for (i in 1:ndists) {
  thisnb &lt;- dnearneigh(milesxy, 0, dists[i])
  thislw &lt;- nb2listw(thisnb, style="B", zero.policy=TRUE)
  ZG[[i]] &lt;- globalG.test(sidsrate79, thislw, zero.policy=TRUE, alternative="two.sided")
}
t(sapply(ZG, function(x) c(x$estimate[1], x$statistic, p.value=unname(x$p.value))))
data(oldcol)
crime &lt;- COL.OLD$CRIME
is.na(crime) &lt;- sample(1:length(crime), 10)
res &lt;- try(globalG.test(crime, nb2listw(COL.nb, style="B"),
 na.action=na.fail))
res
globalG.test(crime, nb2listw(COL.nb, style="B"), zero.policy=TRUE,
 na.action=na.omit)
globalG.test(crime, nb2listw(COL.nb, style="B"), zero.policy=TRUE,
 na.action=na.exclude)
try(globalG.test(crime, nb2listw(COL.nb, style="B"), na.action=na.pass))
</code></pre>

<hr>
<h2 id='Graph+20Components'>Depth First Search on Neighbor Lists</h2><span id='topic+n.comp.nb'></span>

<h3>Description</h3>

<p><code>n.comp.nb()</code> finds the number of disjoint connected subgraphs in the graph depicted by <code>nb.obj</code> - a spatial neighbours list object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.comp.nb(nb.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Graph+2B20Components_+3A_nb.obj">nb.obj</code></td>
<td>
<p>a neighbours list object of class <code>nb</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>nc</code></td>
<td>
<p>number of disjoint connected subgraphs</p>
</td></tr>
<tr><td><code>comp.id</code></td>
<td>
<p>vector with the indices of the disjoint connected subgraphs that
the nodes in <code>nb.obj</code> belong to</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nb">plot.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_coordinates(st_centroid(st_geometry(columbus)))
plot(col.gal.nb, coords, col="grey")
col2 &lt;- droplinks(col.gal.nb, 21)
res &lt;- n.comp.nb(col2)
table(res$comp.id)
plot(col2, coords, add=TRUE)
points(coords, col=res$comp.id, pch=16)
run &lt;- FALSE
if (require(igraph, quietly=TRUE) &amp;&amp; require(spatialreg, quietly=TRUE)) run &lt;- TRUE
if (run) {
B &lt;- as(nb2listw(col2, style="B", zero.policy=TRUE), "CsparseMatrix")
g1 &lt;- graph.adjacency(B, mode="undirected")
c1 &lt;- clusters(g1)
print(c1$no == res$nc)
}
if (run) {
print(all.equal(c1$membership, res$comp.id))
}
if (run) {
print(all.equal(c1$csize, c(table(res$comp.id)), check.attributes=FALSE))
}
if (run) {
W &lt;- as(nb2listw(col2, style="W", zero.policy=TRUE), "CsparseMatrix")
g1W &lt;- graph.adjacency(W, mode="directed", weighted="W")
c1W &lt;- clusters(g1W)
print(all.equal(c1W$membership, res$comp.id, check.attributes=FALSE))
}
if (run) {
ow &lt;- options("warn")$warn
options("warn"=2L)
# Matrix 1.4-2 vulnerability work-around
B1 &lt;- try(get.adjacency(g1), silent=TRUE)
if (!inherits(B1, "try-error")) {
#B1 &lt;- get.adjacency(g1)
print(all.equal(B, B1))
}
options("warn"=ow)
}
</code></pre>

<hr>
<h2 id='graphneigh'>Graph based spatial weights</h2><span id='topic+gabrielneigh'></span><span id='topic+relativeneigh'></span><span id='topic+soi.graph'></span><span id='topic+plot.Gabriel'></span><span id='topic+plot.relative'></span><span id='topic+graph2nb'></span>

<h3>Description</h3>

<p>Functions return a graph object containing a list with the vertex
coordinates and the to and from indices defining the edges. Some/all of these functions assume that the coordinates are not exactly regularly spaced. The helper
function <code>graph2nb</code> converts a graph
object into a neighbour list. The plot functions plot the graph objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gabrielneigh(coords, nnmult=3)
relativeneigh(coords, nnmult=3)
soi.graph(tri.nb, coords, quadsegs=10)
graph2nb(gob, row.names=NULL,sym=FALSE)
## S3 method for class 'Gabriel'
plot(x, show.points=FALSE, add=FALSE, linecol=par(col), ...)
## S3 method for class 'relative'
plot(x, show.points=FALSE, add=FALSE, linecol=par(col),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphneigh_+3A_coords">coords</code></td>
<td>
<p>matrix of region point coordinates or SpatialPoints object or <code>sfc</code> points object</p>
</td></tr>
<tr><td><code id="graphneigh_+3A_nnmult">nnmult</code></td>
<td>
<p>scaling factor for memory allocation, default 3; if higher values are required, the function will exit with an error; example below thanks to Dan Putler</p>
</td></tr>
<tr><td><code id="graphneigh_+3A_tri.nb">tri.nb</code></td>
<td>
<p>a neighbor list created from tri2nb</p>
</td></tr>
<tr><td><code id="graphneigh_+3A_quadsegs">quadsegs</code></td>
<td>
<p>number of line segments making a quarter circle buffer, see the <code>nQuadSegs</code> argument in <code><a href="sf.html#topic+geos_unary">geos_unary</a></code></p>
</td></tr>
<tr><td><code id="graphneigh_+3A_gob">gob</code></td>
<td>
<p>a graph object created from any of the graph funtions</p>
</td></tr>
<tr><td><code id="graphneigh_+3A_row.names">row.names</code></td>
<td>
<p>character vector of region ids to be added to the
neighbours list as attribute <code>region.id</code>, default <code>seq(1,
      nrow(x))</code></p>
</td></tr>
<tr><td><code id="graphneigh_+3A_sym">sym</code></td>
<td>
<p>a logical argument indicating whether or not neighbors
should be symetric (if i-&gt;j then j-&gt;i)</p>
</td></tr>
<tr><td><code id="graphneigh_+3A_x">x</code></td>
<td>
<p>object to be plotted</p>
</td></tr>
<tr><td><code id="graphneigh_+3A_show.points">show.points</code></td>
<td>
<p>(logical) add points to plot</p>
</td></tr>
<tr><td><code id="graphneigh_+3A_add">add</code></td>
<td>
<p>(logical) add to existing plot</p>
</td></tr>
<tr><td><code id="graphneigh_+3A_linecol">linecol</code></td>
<td>
<p>edge plotting colour</p>
</td></tr>
<tr><td><code id="graphneigh_+3A_...">...</code></td>
<td>
<p>further graphical parameters as in <code>par(..)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph functions produce graphs on a 2d point set that
are all subgraphs of the Delaunay triangulation. The
relative neighbor graph is defined by the relation, x and y are neighbors if
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) \le min(max(d(x,z),d(y,z))| z \in S)</code>
</p>

<p>where d() is the distance, S is the set of points and z is an arbitrary
point in S. The Gabriel graph is a subgraph of the delaunay
triangulation and has the relative neighbor graph as a sub-graph. The
relative neighbor graph is defined by the relation x and y are Gabriel
neighbors if
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) \le min((d(x,z)^2 + d(y,z)^2)^{1/2} |z \in S)</code>
</p>

<p>where x,y,z and S are as before. The sphere of influence graph is
defined for a finite point set S, let <code class="reqn">r_x</code> be the distance from point x
to its nearest neighbor in S, and <code class="reqn">C_x</code> is the circle centered on x. Then
x and y are SOI neigbors iff <code class="reqn">C_x</code> and <code class="reqn">C_y</code> intersect in at
least 2 places. From 2016-05-31, Computational Geometry in C code replaced by calls to functions in <span class="pkg">dbscan</span> and <span class="pkg">sf</span>; with a large <code>quadsegs=</code> argument, the behaviour of the function is the same, otherwise buffer intersections only closely approximate the original function.
</p>
<p>See <code><a href="#topic+card">card</a></code> for details of &ldquo;nb&rdquo; objects.
</p>


<h3>Value</h3>

<p>A list of class <code>Graph</code> with the following elements
</p>
<table>
<tr><td><code>np</code></td>
<td>
<p>number of input points</p>
</td></tr>
<tr><td><code>from</code></td>
<td>
<p>array of origin ids</p>
</td></tr>
<tr><td><code>to</code></td>
<td>
<p>array of destination ids</p>
</td></tr>
<tr><td><code>nedges</code></td>
<td>
<p>number of edges in graph</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>input x coordinates</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>input y coordinates</p>
</td></tr>
</table>
<p>The helper functions return an <code>nb</code> object with a list of integer
vectors containing neighbour region number ids.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a></p>


<h3>References</h3>

<p>Matula, D. W. and Sokal R. R. 1980, Properties of Gabriel
graphs relevant to geographic variation research and the clustering of
points in the plane, Geographic Analysis, 12(3), pp. 205-222.
</p>
<p>Toussaint, G. T. 1980, The relative neighborhood graph of a finite
planar set, Pattern Recognition, 12(4), pp. 261-268.
</p>
<p>Kirkpatrick, D. G. and Radke, J. D. 1985, A framework for
computational morphology. In Computational Geometry,
Ed. G. T. Toussaint, North Holland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knearneigh">knearneigh</a></code>, <code><a href="#topic+dnearneigh">dnearneigh</a></code>,
<code><a href="#topic+knn2nb">knn2nb</a></code>, <code><a href="#topic+card">card</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
sf_obj &lt;- st_centroid(st_geometry(columbus), of_largest_polygon)
sp_obj &lt;- as(sf_obj, "Spatial")
coords &lt;- st_coordinates(sf_obj)
suppressMessages(col.tri.nb &lt;- tri2nb(coords))
col.gab.nb &lt;- graph2nb(gabrielneigh(coords), sym=TRUE)
col.rel.nb &lt;- graph2nb(relativeneigh(coords), sym=TRUE)
par(mfrow=c(2,2))
plot(st_geometry(columbus), border="grey")
plot(col.tri.nb,coords,add=TRUE)
title(main="Delaunay Triangulation", cex.main=0.6)
plot(st_geometry(columbus), border="grey")
plot(col.gab.nb, coords, add=TRUE)
title(main="Gabriel Graph", cex.main=0.6)
plot(st_geometry(columbus), border="grey")
plot(col.rel.nb, coords, add=TRUE)
title(main="Relative Neighbor Graph", cex.main=0.6)
plot(st_geometry(columbus), border="grey")
if (require("dbscan", quietly=TRUE)) {
  col.soi.nb &lt;- graph2nb(soi.graph(col.tri.nb,coords), sym=TRUE)
  plot(col.soi.nb, coords, add=TRUE)
  title(main="Sphere of Influence Graph", cex.main=0.6)
}
par(mfrow=c(1,1))
col.tri.nb_sf &lt;- tri2nb(sf_obj)
all.equal(col.tri.nb, col.tri.nb_sf, check.attributes=FALSE)
col.tri.nb_sp &lt;- tri2nb(sp_obj)
all.equal(col.tri.nb, col.tri.nb_sp, check.attributes=FALSE)
if (require("dbscan", quietly=TRUE)) {
  col.soi.nb_sf &lt;- graph2nb(soi.graph(col.tri.nb, sf_obj), sym=TRUE)
  all.equal(col.soi.nb, col.soi.nb_sf, check.attributes=FALSE)
  col.soi.nb_sp &lt;- graph2nb(soi.graph(col.tri.nb, sp_obj), sym=TRUE)
  all.equal(col.soi.nb, col.soi.nb_sp, check.attributes=FALSE)
}
col.gab.nb_sp &lt;- graph2nb(gabrielneigh(sp_obj), sym=TRUE)
all.equal(col.gab.nb, col.gab.nb_sp, check.attributes=FALSE)
col.gab.nb_sf &lt;- graph2nb(gabrielneigh(sf_obj), sym=TRUE)
all.equal(col.gab.nb, col.gab.nb_sf, check.attributes=FALSE)
col.rel.nb_sp &lt;- graph2nb(relativeneigh(sp_obj), sym=TRUE)
all.equal(col.rel.nb, col.rel.nb_sp, check.attributes=FALSE)
col.rel.nb_sf &lt;- graph2nb(relativeneigh(sf_obj), sym=TRUE)
all.equal(col.rel.nb, col.rel.nb_sf, check.attributes=FALSE)
dx &lt;- rep(0.25*0:4,5)
dy &lt;- c(rep(0,5),rep(0.25,5),rep(0.5,5), rep(0.75,5),rep(1,5))
m &lt;- cbind(c(dx, dx, 3+dx, 3+dx), c(dy, 3+dy, dy, 3+dy))
cat(try(res &lt;- gabrielneigh(m), silent=TRUE), "\n")
res &lt;- gabrielneigh(m, nnmult=4)
summary(graph2nb(res))
grd &lt;- as.matrix(expand.grid(x=1:5, y=1:5)) #gridded data
r2 &lt;- gabrielneigh(grd)
set.seed(1)
grd1 &lt;- as.matrix(expand.grid(x=1:5, y=1:5)) + matrix(runif(50, .0001, .0006), nrow=25)
r3 &lt;- gabrielneigh(grd1)
opar &lt;- par(mfrow=c(1,2))
plot(r2, show=TRUE, linecol=2)
plot(r3, show=TRUE, linecol=2)
par(opar)
# example of reading points with readr::read_csv() yielding a tibble
load(system.file("etc/misc/coords.rda", package="spdep"))
class(coords)
graph2nb(gabrielneigh(coords))
graph2nb(relativeneigh(coords))
</code></pre>

<hr>
<h2 id='grid2nb'>Construct neighbours for a GridTopology</h2><span id='topic+grid2nb'></span>

<h3>Description</h3>

<p>The function builds a neighbours list for a grid topology.
It works for a k-dimentional grid topology, k&gt;=1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2nb(grid, d = grid@cells.dim,
        queen = TRUE, nb = TRUE, self = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid2nb_+3A_grid">grid</code></td>
<td>
<p>An object of class <code>GridTopology</code>. One can avoid to 
supply this by just suplying the dimentions in the <code>d</code> argument.</p>
</td></tr> 
<tr><td><code id="grid2nb_+3A_d">d</code></td>
<td>
<p>A scalar (for one dimentional grid) or a length k vector
specyfying the number of grid cells in each direction of the k
dimentions.</p>
</td></tr>
<tr><td><code id="grid2nb_+3A_queen">queen</code></td>
<td>
<p>Logical. Default is TRUE. To inform if the queen
neighbourhood structure should be considered. If FALSE, only 
a hyper-cube with a common face will be considered neighbour. 
If TRUE, a single shared coordinate meets the contiguity condition.</p>
</td></tr> 
<tr><td><code id="grid2nb_+3A_nb">nb</code></td>
<td>
<p>Default TRUE. If TRUE, return the result as a neighbours
list with class <code>nb</code>. If FALSE, the result is a matrix with
<code>3^k</code> columns if <code>self = TRUE</code> or <code>3^k-1</code> if
<code>self = FALSE</code>. Zeros are used for hyper-cubes at boundaries.</p>
</td></tr>
<tr><td><code id="grid2nb_+3A_self">self</code></td>
<td>
<p>Default FALSE, to indicate if the hyper-cube neighbour
itself should be considered a neighbour.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a matrix, if &ldquo;nb&rdquo; is FALSE or a neighbours list with
class <code>nb</code>. See <code><a href="#topic+card">card</a></code> for details of &ldquo;nb&rdquo;
objects.</p>


<h3>Note</h3>

<p>This applies to a k-dimentional grid topology.
</p>


<h3>Author(s)</h3>

<p>Elias T Krainski <a href="mailto:eliaskrainski@gmail.com">eliaskrainski@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+poly2nb">poly2nb</a></code>, <code><a href="#topic+summary.nb">summary.nb</a></code>,
<code><a href="#topic+card">card</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- grid2nb(d = c(5L, 5L, 5L))
nb
summary(nb)
if (require("sp", quietly=TRUE)) {
gt &lt;- GridTopology(c(.125,.1), c(.25,.2), c(4L, 5L))
nb1 &lt;- grid2nb(gt, queen = FALSE)
nb2 &lt;- grid2nb(gt)

sg &lt;- SpatialGrid(gt)
plot(sg, lwd=3)
plot(nb1, coordinates(sg), add=TRUE, lty=2, col=2, lwd=2)
plot(nb2, coordinates(sg), add=TRUE, lty=3, col=4)

str(grid2nb(d=5))
}
</code></pre>

<hr>
<h2 id='hotspot'>Cluster classifications for local indicators of spatial association</h2><span id='topic+hotspot'></span><span id='topic+hotspot.default'></span><span id='topic+hotspot.localmoran'></span><span id='topic+hotspot.summary.localmoransad'></span><span id='topic+hotspot.data.frame.localmoranex'></span><span id='topic+hotspot.localG'></span><span id='topic+hotspot.localC'></span>

<h3>Description</h3>

<p>Used to return a factor showing so-called cluster classification for local indicators of spatial association for local Moran's I, local Geary's C (and its multivariate variant) and local Getis-Ord G. This factor vector can be added to a spatial object for mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot(obj, ...)

## Default S3 method:
hotspot(obj, ...)

## S3 method for class 'localmoran'
hotspot(obj, Prname, cutoff=0.005, quadrant.type="mean",
 p.adjust="fdr", droplevels=TRUE, ...)
## S3 method for class 'summary.localmoransad'
hotspot(obj, Prname, cutoff=0.005,
 quadrant.type="mean", p.adjust="fdr", droplevels=TRUE, ...)
## S3 method for class 'data.frame.localmoranex'
hotspot(obj, Prname, cutoff=0.005,
 quadrant.type="mean", p.adjust="fdr", droplevels=TRUE, ...)

## S3 method for class 'localG'
hotspot(obj, Prname, cutoff=0.005, p.adjust="fdr", droplevels=TRUE, ...)

## S3 method for class 'localC'
hotspot(obj, Prname, cutoff=0.005, p.adjust="fdr", droplevels=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>localmoran</code>, <code>localC</code> or <code>localG</code></p>
</td></tr>
<tr><td><code id="hotspot_+3A_prname">Prname</code></td>
<td>
<p>A character string, the name of the column containing the probability values to be classified by cluster type if found &ldquo;interesting&rdquo;</p>
</td></tr>
<tr><td><code id="hotspot_+3A_cutoff">cutoff</code></td>
<td>
<p>Default 0.005, the probability value cutoff larger than which the observation is not found &ldquo;interesting&rdquo;</p>
</td></tr>
<tr><td><code id="hotspot_+3A_p.adjust">p.adjust</code></td>
<td>
<p>Default <code>"fdr"</code>, the <code>p.adjust()</code> methood used, one of <code>c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")</code></p>
</td></tr>
<tr><td><code id="hotspot_+3A_droplevels">droplevels</code></td>
<td>
<p>Default <code>TRUE</code>, should empty levels of the input cluster factor be dropped</p>
</td></tr>
<tr><td><code id="hotspot_+3A_quadrant.type">quadrant.type</code></td>
<td>
<p>Default <code>"mean"</code>, for <code>"localmoran"</code> objects only, can be <code>c("mean", "median", "pysal")</code> to partition the Moran scatterplot; <code>"mean"</code> partitions on the means of the variable and its spatial lag, <code>"median"</code> on medians of the variable and its spatial lag, <code>"pysal"</code> at zero for the centred variable and its spatial lag</p>
</td></tr>
<tr><td><code id="hotspot_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor showing so-called cluster classification for local indicators of spatial association.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig &lt;- spData::africa.rook.nb
listw &lt;- nb2listw(orig)
x &lt;- spData::afcon$totcon

set.seed(1)
C &lt;- localC_perm(x, listw)
Ch &lt;- hotspot(C, Prname="Pr(z != E(Ci)) Sim", cutoff=0.05, p.adjust="none")
table(addNA(Ch))
set.seed(1)
I &lt;- localmoran_perm(x, listw)
Ih &lt;- hotspot(I, Prname="Pr(z != E(Ii)) Sim", cutoff=0.05, p.adjust="none")
table(addNA(Ih))
Is &lt;- summary(localmoran.sad(lm(x ~ 1), nb=orig))
Ish &lt;- hotspot(Is, Prname="Pr. (Sad)", cutoff=0.05, p.adjust="none")
table(addNA(Ish))
Ie &lt;- as.data.frame(localmoran.exact(lm(x ~ 1), nb=orig))
Ieh &lt;- hotspot(Ie, Prname="Pr. (exact)", cutoff=0.05, p.adjust="none")
table(addNA(Ieh))
set.seed(1)
G &lt;- localG_perm(x, listw)
Gh &lt;- hotspot(G, Prname="Pr(z != E(Gi)) Sim", cutoff=0.05, p.adjust="none")
table(addNA(Gh))
</code></pre>

<hr>
<h2 id='include.self'>Include self in neighbours list</h2><span id='topic+include.self'></span><span id='topic+remove.self'></span>

<h3>Description</h3>

<p>The function includes the region itself in its own list of neighbours, and sets attribute &quot;self.included&quot; to TRUE; <code>remove.self</code> reverts the effects of <code>include.self</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>include.self(nb)
remove.self(nb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="include.self_+3A_nb">nb</code></td>
<td>
<p>input neighbours list of class <code>nb</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids; attribute &quot;self.included&quot; is set to TRUE.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_coordinates(st_centroid(columbus))
summary(col.gal.nb, coords)
summary(include.self(col.gal.nb), coords)
summary(remove.self(include.self(col.gal.nb)), coords)
</code></pre>

<hr>
<h2 id='is.symmetric.nb'>Test a neighbours list for symmetry</h2><span id='topic+is.symmetric.nb'></span><span id='topic+sym.attr.nb'></span><span id='topic+make.sym.nb'></span><span id='topic+old.make.sym.nb'></span><span id='topic+is.symmetric.glist'></span>

<h3>Description</h3>

<p>Checks a neighbours list for symmetry/transitivity (if i is a neighbour of j,
then j is a neighbour of i). This holds for distance and contiguity based
neighbours, but not for k-nearest neighbours. The helper function
<code>sym.attr.nb()</code> calls <code>is.symmetric.nb()</code> to set the <code>sym</code>
attribute if needed, and <code>make.sym.nb</code> makes a non-symmetric list symmetric by adding neighbors. <code>is.symmetric.glist</code> checks a list of general weights corresponding to neighbours for symmetry for symmetric neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.symmetric.nb(nb, verbose = NULL, force = FALSE)
sym.attr.nb(nb)
make.sym.nb(nb)
old.make.sym.nb(nb)
is.symmetric.glist(nb, glist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.symmetric.nb_+3A_nb">nb</code></td>
<td>
<p>an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids.</p>
</td></tr>
<tr><td><code id="is.symmetric.nb_+3A_verbose">verbose</code></td>
<td>
<p>default NULL, use global option value; if TRUE prints non-matching pairs</p>
</td></tr>
<tr><td><code id="is.symmetric.nb_+3A_force">force</code></td>
<td>
<p>do not respect a neighbours list <code>sym</code> attribute and test anyway</p>
</td></tr>
<tr><td><code id="is.symmetric.nb_+3A_glist">glist</code></td>
<td>
<p>list of general weights corresponding to neighbours</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if symmetric, FALSE if not; is.symmetric.glist returns a value with an attribute, &quot;d&quot;, indicating for failed symmetry the largest failing value.
</p>


<h3>Note</h3>

<p>A new version of <code>make.sym.nb</code> by Bjarke Christensen is now included. The older version has been renamed <code>old.make.sym.nb</code>, and their comparison constitutes a nice demonstration of vectorising speedup using <code>sapply</code> and <code>lapply</code> rather than loops. When any no-neighbour observations are present, <code>old.make.sym.nb</code> is used.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read.gal">read.gal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_coordinates(st_centroid(columbus))
ind &lt;- row.names(as(columbus, "Spatial"))
print(is.symmetric.nb(col.gal.nb, verbose=TRUE, force=TRUE))
k4 &lt;- knn2nb(knearneigh(coords, k=4), row.names=ind)
k4 &lt;- sym.attr.nb(k4)
print(is.symmetric.nb(k4))
k4.sym &lt;- make.sym.nb(k4)
print(is.symmetric.nb(k4.sym))
</code></pre>

<hr>
<h2 id='joincount.mc'>Permutation test for same colour join count statistics</h2><span id='topic+joincount.mc'></span>

<h3>Description</h3>

<p>A permutation test for same colour join count statistics calculated by using nsim random permutations of fx for the given spatial weighting scheme, to establish the ranks of the observed statistics (for each colour) in relation to the nsim simulated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joincount.mc(fx, listw, nsim, zero.policy=attr(listw, "zero.policy"),
 alternative="greater", spChk=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joincount.mc_+3A_fx">fx</code></td>
<td>
<p>a factor of the same length as the neighbours and weights objects in listw</p>
</td></tr>
<tr><td><code id="joincount.mc_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="joincount.mc_+3A_nsim">nsim</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="joincount.mc_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="joincount.mc_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;two.sided&quot;, or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="joincount.mc_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>jclist</code> of lists with class <code>htest</code> and <code>mc.sim</code> for each of the k colours containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the observed statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the rank of the observed statistic.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the pseudo p-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the mean and variance of the simulated distribution.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>nsim simulated values of statistic, the final element is the observed statistic</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 63-5.</p>


<h3>See Also</h3>

<p><code><a href="#topic+joincount.test">joincount.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
HICRIME &lt;- cut(COL.OLD$CRIME, breaks=c(0,35,80), labels=c("low","high"))
names(HICRIME) &lt;- rownames(COL.OLD)
joincount.mc(HICRIME, nb2listw(COL.nb, style="B"), nsim=99, alternative="two.sided")
joincount.test(HICRIME, nb2listw(COL.nb, style="B"), alternative="two.sided")
</code></pre>

<hr>
<h2 id='joincount.multi'>BB, BW and Jtot join count statistic for k-coloured factors</h2><span id='topic+joincount.multi'></span><span id='topic+print.jcmulti'></span>

<h3>Description</h3>

<p>A function for tallying join counts between same-colour and different colour spatial objects, where neighbour relations are defined by a weights list. Given the global counts in each colour, expected counts and variances are calculated under non-free sampling, and a z-value reported. Since multiple tests are reported, no p-values are given, allowing the user to adjust the significance level applied. Jtot is the count of all different-colour joins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joincount.multi(fx, listw, zero.policy = attr(listw, "zero.policy"),
 spChk = NULL, adjust.n=TRUE)
## S3 method for class 'jcmulti'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joincount.multi_+3A_fx">fx</code></td>
<td>
<p>a factor of the same length as the neighbours and weights objects in listw</p>
</td></tr>
<tr><td><code id="joincount.multi_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="joincount.multi_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="joincount.multi_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted consistently (up to and including spdep 0.3-28 the adjustment was inconsistent - thanks to Tomoki NAKAYA for a careful bug report)</p>
</td></tr>
<tr><td><code id="joincount.multi_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="joincount.multi_+3A_x">x</code></td>
<td>
<p>object to be printed</p>
</td></tr>
<tr><td><code id="joincount.multi_+3A_...">...</code></td>
<td>
<p>arguments to be passed through for printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with class <code>jcmulti</code> with row and column names for observed and expected counts, variance, and z-value.
</p>


<h3>Note</h3>

<p>The derivation of the test (Cliff and Ord, 1981, p. 18) assumes that the weights matrix is symmetric. For inherently non-symmetric matrices, such as k-nearest neighbour matrices, <code>listw2U()</code> can be used to make the matrix symmetric. In non-symmetric weights matrix cases, the variance of the test statistic may be negative.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 20; Upton, G., Fingleton, B. 1985 Spatial data analysis by example: point pattern and qualitative data, Wiley, pp. 158&ndash;170.</p>


<h3>See Also</h3>

<p><code><a href="#topic+joincount.test">joincount.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
HICRIME &lt;- cut(columbus$CRIME, breaks=c(0,35,80), labels=c("low","high"))
(nb &lt;- poly2nb(columbus))
lw &lt;- nb2listw(nb, style="B")
joincount.multi(HICRIME, lw)
col_geoms &lt;- st_geometry(columbus)
col_geoms[21] &lt;- st_buffer(col_geoms[21], dist=-0.05)
st_geometry(columbus) &lt;- col_geoms
(nb &lt;- poly2nb(columbus))
lw &lt;- nb2listw(nb, style="B", zero.policy=TRUE)
joincount.multi(HICRIME, lw)
## Not run: 
data(oldcol)
HICRIME &lt;- cut(COL.OLD$CRIME, breaks=c(0,35,80), labels=c("low","high"))
names(HICRIME) &lt;- rownames(COL.OLD)
joincount.multi(HICRIME, nb2listw(COL.nb, style="B"))
data(hopkins, package="spData")
image(1:32, 1:32, hopkins[5:36,36:5], breaks=c(-0.5, 3.5, 20),
 col=c("white", "black"))
box()
hopkins.rook.nb &lt;- cell2nb(32, 32, type="rook")
unlist(spweights.constants(nb2listw(hopkins.rook.nb, style="B")))
hopkins.queen.nb &lt;- cell2nb(32, 32, type="queen")
hopkins.bishop.nb &lt;- diffnb(hopkins.rook.nb, hopkins.queen.nb, verbose=FALSE)
hopkins4 &lt;- hopkins[5:36,36:5]
hopkins4[which(hopkins4 &gt; 3, arr.ind=TRUE)] &lt;- 4
hopkins4.f &lt;- factor(hopkins4)
table(hopkins4.f)
joincount.multi(hopkins4.f, nb2listw(hopkins.rook.nb, style="B"))
cat("replicates Upton &amp; Fingleton table 3.4 (p. 166)\n")
joincount.multi(hopkins4.f, nb2listw(hopkins.bishop.nb, style="B"))
cat("replicates Upton &amp; Fingleton table 3.6 (p. 168)\n")
joincount.multi(hopkins4.f, nb2listw(hopkins.queen.nb, style="B"))
cat("replicates Upton &amp; Fingleton table 3.7 (p. 169)\n")

## End(Not run)
</code></pre>

<hr>
<h2 id='joincount.test'>BB join count statistic for k-coloured factors</h2><span id='topic+joincount.test'></span><span id='topic+print.jclist'></span>

<h3>Description</h3>

<p>The BB join count test for spatial autocorrelation using a spatial
weights matrix in weights list form for testing whether same-colour joins
occur more frequently than would be expected if the zones were labelled
in a spatially random way. The assumptions underlying the test are
sensitive to the form of the graph of neighbour relationships and other
factors, and results may be checked against those of <code>joincount.mc</code>
permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joincount.test(fx, listw, zero.policy=attr(listw, "zero.policy"), alternative="greater",
 sampling="nonfree", spChk=NULL, adjust.n=TRUE)
## S3 method for class 'jclist'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joincount.test_+3A_fx">fx</code></td>
<td>
<p>a factor of the same length as the neighbours and weights objects in listw</p>
</td></tr>
<tr><td><code id="joincount.test_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="joincount.test_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="joincount.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;less&quot; or &quot;two.sided&quot;.</p>
</td></tr>
<tr><td><code id="joincount.test_+3A_sampling">sampling</code></td>
<td>
<p>default &ldquo;nonfree&rdquo;, may be &ldquo;free&rdquo;</p>
</td></tr>
<tr><td><code id="joincount.test_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted consistently (up to and including spdep 0.3-28 the adjustment was inconsistent - thanks to Tomoki NAKAYA for a careful bug report)</p>
</td></tr>
<tr><td><code id="joincount.test_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="joincount.test_+3A_x">x</code></td>
<td>
<p>object to be printed</p>
</td></tr>
<tr><td><code id="joincount.test_+3A_...">...</code></td>
<td>
<p>arguments to be passed through for printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>jclist</code> of lists with class <code>htest</code> for each of the k colours containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the standard deviate of the join count statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed statistic, its expectation and variance under non-free sampling.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The derivation of the test (Cliff and Ord, 1981, p. 18) assumes that the weights matrix is symmetric. For inherently non-symmetric matrices, such as k-nearest neighbour matrices, <code>listw2U()</code> can be used to make the matrix symmetric. In non-symmetric weights matrix cases, the variance of the test statistic may be negative.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, pp. 19-20.</p>


<h3>See Also</h3>

<p><code><a href="#topic+joincount.mc">joincount.mc</a></code>, <code><a href="#topic+joincount.multi">joincount.multi</a></code>, <code><a href="#topic+listw2U">listw2U</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
HICRIME &lt;- cut(COL.OLD$CRIME, breaks=c(0,35,80), labels=c("low","high"))
names(HICRIME) &lt;- rownames(COL.OLD)
joincount.test(HICRIME, nb2listw(COL.nb, style="B"))
joincount.test(HICRIME, nb2listw(COL.nb, style="B"), sampling="free")
joincount.test(HICRIME, nb2listw(COL.nb, style="C"))
joincount.test(HICRIME, nb2listw(COL.nb, style="S"))
joincount.test(HICRIME, nb2listw(COL.nb, style="W"))
by(card(COL.nb), HICRIME, summary)
print(is.symmetric.nb(COL.nb))
coords.OLD &lt;- cbind(COL.OLD$X, COL.OLD$Y)
COL.k4.nb &lt;- knn2nb(knearneigh(coords.OLD, 4))
print(is.symmetric.nb(COL.k4.nb))
joincount.test(HICRIME, nb2listw(COL.k4.nb, style="B"))
cat("Note non-symmetric weights matrix - use listw2U()\n")
joincount.test(HICRIME, listw2U(nb2listw(COL.k4.nb, style="B")))
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
HICRIME &lt;- cut(columbus$CRIME, breaks=c(0,35,80), labels=c("low","high"))
(nb &lt;- poly2nb(columbus))
lw &lt;- nb2listw(nb, style="B")
joincount.test(HICRIME, lw)
col_geoms &lt;- st_geometry(columbus)
col_geoms[21] &lt;- st_buffer(col_geoms[21], dist=-0.05)
st_geometry(columbus) &lt;- col_geoms
(nb &lt;- poly2nb(columbus))
lw &lt;- nb2listw(nb, style="B", zero.policy=TRUE)
joincount.test(HICRIME, lw)
</code></pre>

<hr>
<h2 id='knearneigh'>K nearest neighbours for spatial weights</h2><span id='topic+knearneigh'></span>

<h3>Description</h3>

<p>The function returns a matrix with the indices of points belonging to the set of the k nearest neighbours of each other. If longlat = TRUE, Great Circle distances are used. A warning will be given if identical points are found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knearneigh(x, k=1, longlat = NULL, use_kd_tree=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knearneigh_+3A_x">x</code></td>
<td>
<p>matrix of point coordinates, an object inheriting from SpatialPoints or an <code>"sf"</code> or <code>"sfc"</code> object; if the <code>"sf"</code> or <code>"sfc"</code> object geometries are in geographical coordinates (<code>sf::st_is_longlat(x) == TRUE</code> and <code>sf::sf_use_s2() == TRUE</code>), <span class="pkg">s2</span> will be used to find the neighbours because it uses spatial indexing <a href="https://github.com/r-spatial/s2/issues/125">https://github.com/r-spatial/s2/issues/125</a> as opposed to the legacy method which uses brute-force</p>
</td></tr>
<tr><td><code id="knearneigh_+3A_k">k</code></td>
<td>
<p>number of nearest neighbours to be returned</p>
</td></tr>
<tr><td><code id="knearneigh_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometers; if x is a SpatialPoints object, the value is taken from the object itself; longlat will override <code>kd_tree</code></p>
</td></tr>
<tr><td><code id="knearneigh_+3A_use_kd_tree">use_kd_tree</code></td>
<td>
<p>logical value, if the <span class="pkg">dbscan</span> package is available, use for finding k nearest neighbours when longlat is FALSE, and when there are no identical points; from <a href="https://github.com/r-spatial/spdep/issues/38">https://github.com/r-spatial/spdep/issues/38</a>, the input data may have more than two columns if <span class="pkg">dbscan</span> is used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying legacy C code is based on the <code>knn</code> function in the <span class="pkg">class</span> package. 
</p>


<h3>Value</h3>

<p>A list of class <code>knn</code>
</p>
<table>
<tr><td><code>nn</code></td>
<td>
<p>integer matrix of region number ids</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>number of input points</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>input required k</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>number of columns of x</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>input coordinates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="class.html#topic+knn">knn</a></code>, <code><a href="#topic+dnearneigh">dnearneigh</a></code>,
<code><a href="#topic+knn2nb">knn2nb</a></code>, <code><a href="dbscan.html#topic+kNN">kNN</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
coords &lt;- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE)
col.knn &lt;- knearneigh(coords, k=4)
plot(st_geometry(columbus), border="grey")
plot(knn2nb(col.knn), coords, add=TRUE)
title(main="K nearest neighbours, k = 4")
data(state)
us48.fipsno &lt;- read.geoda(system.file("etc/weights/us48.txt",
 package="spdep")[1])
if (as.numeric(paste(version$major, version$minor, sep="")) &lt; 19) {
 m50.48 &lt;- match(us48.fipsno$"State.name", state.name)
} else {
 m50.48 &lt;- match(us48.fipsno$"State_name", state.name)
}
xy &lt;- as.matrix(as.data.frame(state.center))[m50.48,]
llk4.nb &lt;- knn2nb(knearneigh(xy, k=4, longlat=FALSE))
gck4.nb &lt;- knn2nb(knearneigh(xy, k=4, longlat=TRUE))
plot(llk4.nb, xy)
plot(diffnb(llk4.nb, gck4.nb), xy, add=TRUE, col="red", lty=2)
title(main="Differences between Euclidean and Great Circle k=4 neighbours")
summary(llk4.nb, xy, longlat=TRUE, scale=0.5)
summary(gck4.nb, xy, longlat=TRUE, scale=0.5)

#xy1 &lt;- SpatialPoints((as.data.frame(state.center))[m50.48,],
#  proj4string=CRS("+proj=longlat +ellps=GRS80"))
#gck4a.nb &lt;- knn2nb(knearneigh(xy1, k=4))
#summary(gck4a.nb, xy1, scale=0.5)

xy1 &lt;- st_as_sf((as.data.frame(state.center))[m50.48,], coords=1:2,
  crs=st_crs("OGC:CRS84"))
old_use_s2 &lt;- sf_use_s2()
sf_use_s2(TRUE)
system.time(gck4a.nb &lt;- knn2nb(knearneigh(xy1, k=4)))
summary(gck4a.nb, xy1, scale=0.5)
sf_use_s2(FALSE)
system.time(gck4a.nb &lt;- knn2nb(knearneigh(xy1, k=4)))
summary(gck4a.nb, xy1, scale=0.5)
sf_use_s2(old_use_s2)

# https://github.com/r-spatial/spdep/issues/38
if (require("dbscan", quietly=TRUE)) {
  set.seed(1)
  x &lt;- cbind(runif(50), runif(50), runif(50))
  out &lt;- knearneigh(x, k=5)
  knn2nb(out)
  try(out &lt;- knearneigh(rbind(x, x[1:10,]), k=5))
}
</code></pre>

<hr>
<h2 id='knn2nb'>Neighbours list from knn object</h2><span id='topic+knn2nb'></span>

<h3>Description</h3>

<p>The function converts a <code>knn</code> object returned by <code>knearneigh</code> 
into a neighbours list of class <code>nb</code> with a list of integer vectors 
containing neighbour region number ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn2nb(knn, row.names = NULL, sym = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn2nb_+3A_knn">knn</code></td>
<td>
<p>A knn object returned by <code>knearneigh</code></p>
</td></tr>
<tr><td><code id="knn2nb_+3A_row.names">row.names</code></td>
<td>
<p>character vector of region ids to be added to the neighbours list as attribute <code>region.id</code>, default <code>seq(1, nrow(x))</code></p>
</td></tr>
<tr><td><code id="knn2nb_+3A_sym">sym</code></td>
<td>
<p>force the output neighbours list to symmetry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids. See <code><a href="#topic+card">card</a></code> for details of &ldquo;nb&rdquo; objects.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+knearneigh">knearneigh</a></code>, <code><a href="#topic+card">card</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
coords &lt;- st_coordinates(st_centroid(columbus))
col.knn &lt;- knearneigh(coords, k=4)
plot(st_geometry(columbus), border="grey")
plot(knn2nb(col.knn), coords, add=TRUE)
title(main="K nearest neighbours, k = 4")
# example of reading points with readr::read_csv() yielding a tibble
load(system.file("etc/misc/coords.rda", package="spdep"))
class(coords)
knn2nb(knearneigh(coords, k=4))
</code></pre>

<hr>
<h2 id='lag.listw'>Spatial lag of a numeric vector</h2><span id='topic+lag.listw'></span>

<h3>Description</h3>

<p>Using a <code>listw</code> sparse representation of a spatial weights matrix, compute the lag vector <code class="reqn">V x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'listw'
lag(x, var, zero.policy=attr(listw, "zero.policy"), NAOK=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag.listw_+3A_x">x</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="lag.listw_+3A_var">var</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="lag.listw_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="lag.listw_+3A_naok">NAOK</code></td>
<td>
<p>If 'FALSE', the presence of 'NA' values is regarded as an error; if 'TRUE' then any 'NA' or 'NaN' or 'Inf' values in var are represented as an NA lagged value.</p>
</td></tr>
<tr><td><code id="lag.listw_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector the same length as var
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2listw">nb2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
Vx &lt;- lag.listw(nb2listw(COL.nb, style="W"), COL.OLD$CRIME)
plot(Vx, COL.OLD$CRIME)
plot(ecdf(COL.OLD$CRIME))
plot(ecdf(Vx), add=TRUE, col.points="red", col.hor="red")
is.na(COL.OLD$CRIME[5]) &lt;- TRUE
VxNA &lt;- lag.listw(nb2listw(COL.nb, style="W"), COL.OLD$CRIME, NAOK=TRUE)
</code></pre>

<hr>
<h2 id='lee'>Compute Lee's statistic</h2><span id='topic+lee'></span>

<h3>Description</h3>

<p>A simple function to compute Lee's L statistic for bivariate spatial data;
</p>
<p style="text-align: center;"><code class="reqn">L(x,y) = \frac{n}{\sum_{i=1}^{n}(\sum_{j=1}^{n}w_{ij})^2}
\frac{\sum_{i=1}^{n}(\sum_{j=1}^{n}w_{ij}(x_i-\bar{x})) ((\sum_{j=1}^{n}w_{ij}(y_j-\bar{y}))}{\sqrt{\sum_{i=1}^{n}(x_i - \bar{x})^2} \sqrt{\sum_{i=1}^{n}(y_i - \bar{y})^2}}
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>lee(x, y, listw, n, S2, zero.policy=attr(listw, "zero.policy"), NAOK=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lee_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="lee_+3A_y">y</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="lee_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="lee_+3A_n">n</code></td>
<td>
<p>number of zones</p>
</td></tr>
<tr><td><code id="lee_+3A_s2">S2</code></td>
<td>
<p>Sum of squared sum of weights by rows.</p>
</td></tr>
<tr><td><code id="lee_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="lee_+3A_naok">NAOK</code></td>
<td>
<p>if 'TRUE' then any 'NA' or 'NaN' or 'Inf' values in x are passed on to the foreign function.  If 'FALSE', the presence of 'NA' or 'NaN' or 'Inf' values is regarded as an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>Lee's L statistic</p>
</td></tr>
<tr><td><code>local L</code></td>
<td>
<p>Lee's local L statistic</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand and Virgiio GÃ³mez-Rubio <a href="mailto:Virgilio.Gomez@uclm.es">Virgilio.Gomez@uclm.es</a></p>


<h3>References</h3>

<p>Lee (2001). Developing a bivariate spatial association measure:
An integration of Pearson's r and Moran's I. J Geograph Syst  3: 369-385</p>


<h3>See Also</h3>

<p><code><a href="#topic+lee.mc">lee.mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boston, package="spData")
lw&lt;-nb2listw(boston.soi)

x&lt;-boston.c$CMEDV
y&lt;-boston.c$CRIM
z&lt;-boston.c$RAD

Lxy&lt;-lee(x, y, lw, length(x), zero.policy=TRUE)
Lxz&lt;-lee(x, z, lw, length(x), zero.policy=TRUE)

</code></pre>

<hr>
<h2 id='lee.mc'>Permutation test for Lee's L statistic</h2><span id='topic+lee.mc'></span>

<h3>Description</h3>

<p>A permutation test for Lee's L  statistic calculated by using nsim random permutations of x and y for the given spatial weighting scheme, to establish the rank of the observed statistic in relation to the nsim simulated values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lee.mc(x, y, listw, nsim, zero.policy=attr(listw, "zero.policy"), alternative="greater",
 na.action=na.fail, spChk=NULL, return_boot=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lee.mc_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="lee.mc_+3A_y">y</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="lee.mc_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="lee.mc_+3A_nsim">nsim</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="lee.mc_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="lee.mc_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;two.sided&quot;, or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="lee.mc_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. <code>na.pass</code> is not permitted because it is meaningless in a permutation test.</p>
</td></tr>
<tr><td><code id="lee.mc_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="lee.mc_+3A_return_boot">return_boot</code></td>
<td>
<p>return an object of class <code>boot</code> from the equivalent permutation bootstrap rather than an object of class <code>htest</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> and <code>mc.sim</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the observed Lee's L.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the rank of the observed Lee's L.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the pseudo p-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data, and the number of simulations.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>nsim simulated values of statistic, final value is observed statistic</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand, Virgilio GÃ³mez-Rubio <a href="mailto:Virgilio.Gomez@uclm.es">Virgilio.Gomez@uclm.es</a> </p>


<h3>References</h3>

<p>Lee (2001). Developing a bivariate spatial association measure:
An integration of Pearson's r and Moran's I. J Geograph Syst  3: 369-385</p>


<h3>See Also</h3>

<p><code><a href="#topic+lee">lee</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boston, package="spData")
lw&lt;-nb2listw(boston.soi)

x&lt;-boston.c$CMEDV
y&lt;-boston.c$CRIM

lee.mc(x, y, nsim=99, lw, zero.policy=TRUE, alternative="two.sided")

#Test with missing values
x[1:5]&lt;-NA
y[3:7]&lt;-NA

lee.mc(x, y, nsim=99, lw, zero.policy=TRUE, alternative="two.sided", 
   na.action=na.omit)

</code></pre>

<hr>
<h2 id='lee.test'>Lee's L  test for spatial autocorrelation</h2><span id='topic+lee.test'></span>

<h3>Description</h3>

<p>Lee's L test for spatial autocorrelation using a spatial weights matrix in weights list form. The assumptions underlying the test are sensitive to the form of the graph of neighbour relationships and other factors, and results may be checked against those of <code>lee.mc</code> permutations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lee.test(x, y, listw, zero.policy=attr(listw, "zero.policy"),
 alternative="greater", na.action=na.fail, spChk=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lee.test_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="lee.test_+3A_y">y</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="lee.test_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="lee.test_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="lee.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code id="lee.test_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. If <code>na.pass</code> is used, zero is substituted for NA values in calculating the spatial lag</p>
</td></tr>
<tr><td><code id="lee.test_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the standard deviate of Lee's L.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed Lee's L, its expectation and variance under the method assumption.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the assumption used for calculating the standard deviate.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See Lee (2004) for details on how the asymptotic expectation and
variance of Lee's L is computed. In particular, check Lee (2004), table 1, 
page 1690. 
</p>
<p>This test may fail for large datasets as the computation of the 
asymptotic expectation and variance requires the use of dense matrices.</p>


<h3>Author(s)</h3>

<p>Roger Bivand and Virgilio GÃ³mez-Rubio <a href="mailto:Virgilio.Gomez@uclm.es">Virgilio.Gomez@uclm.es</a></p>


<h3>References</h3>

<p>Lee (2004). A generalized significance testing method for global
measures of spatial association: an extension of the Mantel test.  Environment
and Planning A 2004, volume 36, pages 1687 - 1703</p>


<h3>See Also</h3>

<p><code><a href="#topic+lee">lee</a></code>, <code><a href="#topic+lee.mc">lee.mc</a></code>, <code><a href="#topic+listw2U">listw2U</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
col.W &lt;- nb2listw(COL.nb, style="W")
crime &lt;- COL.OLD$CRIME

lee.test(crime, crime, col.W, zero.policy=TRUE)

#Test with missing values
x&lt;-crime
y&lt;-crime
x[1:5]&lt;-NA
y[3:7]&lt;-NA

lee.test(x, y, col.W, zero.policy=TRUE, na.action=na.omit)
#  lee.test(x, y, col.W, zero.policy=TRUE)#Stops with an error



data(boston, package="spData")
lw&lt;-nb2listw(boston.soi)

x&lt;-boston.c$CMEDV
y&lt;-boston.c$CRIM

lee.test(x, y, lw, zero.policy=TRUE, alternative="less")

#Test with missing values
x[1:5]&lt;-NA
y[3:7]&lt;-NA

lee.test(x, y, lw, zero.policy=TRUE, alternative="less", na.action=na.omit)














</code></pre>

<hr>
<h2 id='listw2sn'>Spatial neighbour sparse representation</h2><span id='topic+listw2sn'></span><span id='topic+sn2listw'></span>

<h3>Description</h3>

<p>The function makes a <code>"spatial neighbour"</code> object representation
(similar to the S-PLUS spatial statististics module representation of a
<code>"listw"</code> spatial weights object. <code>sn2listw()</code> is the inverse function to <code>listw2sn()</code>, creating a <code>"listw"</code> object from a <code>"spatial neighbour"</code> object. </p>


<h3>Usage</h3>

<pre><code class='language-R'>listw2sn(listw)
sn2listw(sn, style = NULL, zero.policy = NULL, from_mat2listw=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listw2sn_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object from for example <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="listw2sn_+3A_sn">sn</code></td>
<td>
<p>a <code>spatial.neighbour</code> object</p>
</td></tr>
<tr><td><code id="listw2sn_+3A_style">style</code></td>
<td>
<p>default NULL, missing, set to &quot;M&quot; and warning given; if not &quot;M&quot;, passed to <code><a href="#topic+nb2listw">nb2listw</a></code> to re-build the object</p>
</td></tr>
<tr><td><code id="listw2sn_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td></tr>
<tr><td><code id="listw2sn_+3A_from_mat2listw">from_mat2listw</code></td>
<td>
<p>default FALSE, set TRUE if called from <code>mat2listw</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>listw2sn()</code>returns a data frame with three columns, and with class <code>spatial.neighbour</code>:
</p>
<table>
<tr><td><code>from</code></td>
<td>
<p>region number id for the start of the link (S-PLUS row.id)</p>
</td></tr>
<tr><td><code>to</code></td>
<td>
<p>region number id for the end of the link (S-PLUS col.id)</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weight for this link</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2listw">nb2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
col.listw &lt;- nb2listw(col.gal.nb)
col.listw$neighbours[[1]]
col.listw$weights[[1]]
col.sn &lt;- listw2sn(col.listw)
str(col.sn)
</code></pre>

<hr>
<h2 id='lm.LMtests'>Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models</h2><span id='topic+lm.LMtests'></span><span id='topic+lm.RStests'></span><span id='topic+print.RStestlist'></span><span id='topic+summary.RStestlist'></span><span id='topic+print.RStestlist.summary'></span>

<h3>Description</h3>

<p>The function reports the estimates of tests chosen among five statistics for
testing for spatial dependence in linear models. The statistics are
the simple RS test for error dependence (&ldquo;RSerr&rdquo;), the simple RS test
for a missing spatially lagged dependent variable (&ldquo;RSlag&rdquo;), variants
of these adjusted for the presence of the other (&ldquo;adjRSerr&rdquo;
tests for error dependence in the possible presence of a missing lagged
dependent variable, &ldquo;adjRSlag&rdquo; the other way round), and a portmanteau test
(&ldquo;SARMA&rdquo;, in fact &ldquo;RSerr&rdquo; + &ldquo;adjRSlag&rdquo;). Note: from spdep 1.3-2, the tests are re-named &ldquo;RS&rdquo; - Rao's score tests, rather than &ldquo;LM&rdquo; - Lagrange multiplier tests to match the naming of tests from the same family in <code>SDM.RStests</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.RStests(model, listw, zero.policy=attr(listw, "zero.policy"), test="RSerr",
 spChk=NULL, naSubset=TRUE)
lm.LMtests(model, listw, zero.policy=attr(listw, "zero.policy"), test="LMerr",
 spChk=NULL, naSubset=TRUE)
## S3 method for class 'RStestlist'
print(x, ...)
## S3 method for class 'RStestlist'
summary(object, p.adjust.method="none", ...)
## S3 method for class 'RStestlist.summary'
print(x, digits=max(3, getOption("digits") - 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.LMtests_+3A_model">model</code></td>
<td>
<p>an object of class <code>lm</code> returned by <code>lm</code>, or optionally a vector of externally calculated residuals (run though <code>na.omit</code> if any NAs present) for use when only &quot;RSerr&quot; is chosen; weights and offsets should not be used in the <code>lm</code> object</p>
</td></tr>
<tr><td><code id="lm.LMtests_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code>,
expected to be row-standardised (W-style)</p>
</td></tr>
<tr><td><code id="lm.LMtests_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without
neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="lm.LMtests_+3A_test">test</code></td>
<td>
<p>a character vector of tests requested chosen from RSerr, RSlag,
adjRSerr, adjRSlag, SARMA; test=&quot;all&quot; computes all the tests.</p>
</td></tr>
<tr><td><code id="lm.LMtests_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="lm.LMtests_+3A_nasubset">naSubset</code></td>
<td>
<p>default TRUE to subset listw object for omitted observations in model object (this is a change from earlier behaviour, when the <code>model$na.action</code> component was ignored, and the listw object had to be subsetted by hand)</p>
</td></tr>
<tr><td><code id="lm.LMtests_+3A_x">x</code>, <code id="lm.LMtests_+3A_object">object</code></td>
<td>
<p>object to be printed</p>
</td></tr>
<tr><td><code id="lm.LMtests_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>a character string specifying the probability value adjustment (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>) for multiple tests, default &quot;none&quot;</p>
</td></tr>
<tr><td><code id="lm.LMtests_+3A_digits">digits</code></td>
<td>
<p>minimum number of significant digits to be used for most numbers</p>
</td></tr>
<tr><td><code id="lm.LMtests_+3A_...">...</code></td>
<td>
<p>printing arguments to be passed through</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two types of dependence are for spatial lag <code class="reqn">\rho</code> and spatial error <code class="reqn">\lambda</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\mathbf{y} = \mathbf{X \beta} + \rho \mathbf{W_{(1)} y} + \mathbf{u},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\mathbf{u} = \lambda \mathbf{W_{(2)} u} + \mathbf{e}
</code>
</p>

<p>where <code class="reqn">\mathbf{e}</code> is a well-behaved, uncorrelated error
term. Tests for a missing spatially lagged dependent variable test
that <code class="reqn">\rho = 0</code>, tests for spatial autocorrelation of
the error <code class="reqn">\mathbf{u}</code> test whether <code class="reqn">\lambda = 0</code>. <code class="reqn">\mathbf{W}</code> is a spatial weights matrix; for the tests used
here they are identical.
</p>


<h3>Value</h3>

<p>A list of class <code>RStestlist</code> of <code>htest</code> objects, each with:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Rao's score (a.k.a Lagrange multiplier) test.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>number of degrees of freedom</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> and Andrew Bernat</p>


<h3>References</h3>

<p>Anselin, L. 1988 Spatial econometrics: methods and
models. (Dordrecht: Kluwer); Anselin, L., Bera, A. K., Florax, R. and
Yoon, M. J. 1996 Simple diagnostic tests for spatial dependence. Regional
Science and Urban Economics, 26, 77&ndash;104 <a href="https://doi.org/10.1016/0166-0462%2895%2902111-6">doi:10.1016/0166-0462(95)02111-6</a>; 
Malabika Koley (2024) Specification Testing under General Nesting Spatial 
Model, <a href="https://sites.google.com/view/malabikakoley/research">https://sites.google.com/view/malabikakoley/research</a>.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+SD.RStests">SD.RStests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
oldcrime.lm &lt;- lm(CRIME ~ HOVAL + INC, data = COL.OLD)
summary(oldcrime.lm)
lw &lt;- nb2listw(COL.nb)
res &lt;- lm.RStests(oldcrime.lm, listw=lw, test="all")
summary(res)
if (require("spatialreg", quietly=TRUE)) {
  oldcrime.slx &lt;- lm(CRIME ~ HOVAL + INC, data = COL.OLD, listw=lw)
  summary(lm.RStests(oldcrime.slx, listw=lw, test=c("adjRSerr", "adjRSlag")))
}
</code></pre>

<hr>
<h2 id='lm.morantest'>Moran's I test for residual spatial autocorrelation</h2><span id='topic+lm.morantest'></span>

<h3>Description</h3>

<p>Moran's I test for spatial autocorrelation in residuals from an estimated linear model (<code>lm()</code>). </p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.morantest(model, listw, zero.policy=attr(listw, "zero.policy"),
 alternative = "greater", spChk=NULL, resfun=weighted.residuals, naSubset=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.morantest_+3A_model">model</code></td>
<td>
<p>an object of class <code>lm</code> returned by <code>lm</code>; weights
may be specified in the <code>lm</code> fit, but offsets should not be used</p>
</td></tr>
<tr><td><code id="lm.morantest_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="lm.morantest_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without
neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="lm.morantest_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of &quot;greater&quot; (default), &quot;less&quot; or &quot;two.sided&quot;.</p>
</td></tr>
<tr><td><code id="lm.morantest_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="lm.morantest_+3A_resfun">resfun</code></td>
<td>
<p>default: weighted.residuals; the function to be used to extract residuals from the <code>lm</code> object, may be <code>residuals</code>, <code>weighted.residuals</code>, <code>rstandard</code>, or <code>rstudent</code></p>
</td></tr>
<tr><td><code id="lm.morantest_+3A_nasubset">naSubset</code></td>
<td>
<p>default TRUE to subset listw object for omitted observations in model object (this is a change from earlier behaviour, when the <code>model$na.action</code> component was ignored, and the listw object had to be subsetted by hand)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the standard deviate of Moran's I.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed Moran's I, its expectation and
variance under the method assumption.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 203, </p>


<h3>See Also</h3>

<p><code><a href="#topic+lm.LMtests">lm.LMtests</a></code>, <code><a href="stats.html#topic+lm">lm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
oldcrime1.lm &lt;- lm(CRIME ~ 1, data = COL.OLD)
oldcrime.lm &lt;- lm(CRIME ~ HOVAL + INC, data = COL.OLD)
lm.morantest(oldcrime.lm, nb2listw(COL.nb, style="W"))
lm.LMtests(oldcrime.lm, nb2listw(COL.nb, style="W"))
lm.morantest(oldcrime.lm, nb2listw(COL.nb, style="S"))
lm.morantest(oldcrime1.lm, nb2listw(COL.nb, style="W"))
moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"),
 randomisation=FALSE)
oldcrime.wlm &lt;- lm(CRIME ~ HOVAL + INC, data = COL.OLD,
 weights = I(1/AREA_PL))
lm.morantest(oldcrime.wlm, nb2listw(COL.nb, style="W"),
 resfun=weighted.residuals)
lm.morantest(oldcrime.wlm, nb2listw(COL.nb, style="W"),
 resfun=rstudent)
</code></pre>

<hr>
<h2 id='lm.morantest.exact'>Exact global Moran's I test</h2><span id='topic+lm.morantest.exact'></span><span id='topic+print.moranex'></span>

<h3>Description</h3>

<p>The function implements Tiefelsdorf's exact global Moran's I test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.morantest.exact(model, listw, zero.policy = attr(listw, "zero.policy"),
 alternative = "greater", spChk = NULL, resfun = weighted.residuals,
 zero.tol = 1e-07, Omega=NULL, save.M=NULL, save.U=NULL, useTP=FALSE,
 truncErr=1e-6, zeroTreat=0.1)
## S3 method for class 'moranex'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.morantest.exact_+3A_model">model</code></td>
<td>
<p>an object of class <code>lm</code> returned by <code>lm</code>; weights
may be specified in the <code>lm</code> fit, but offsets should not be used</p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without
neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_resfun">resfun</code></td>
<td>
<p>default: weighted.residuals; the function to be used to extract residuals from the <code>lm</code> object, may be <code>residuals</code>, <code>weighted.residuals</code>, <code>rstandard</code>, or <code>rstudent</code></p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_zero.tol">zero.tol</code></td>
<td>
<p>tolerance used to find eigenvalues close to absolute zero</p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_omega">Omega</code></td>
<td>
<p>A SAR process matrix may be passed in to test an alternative hypothesis, for example <code>Omega &lt;- invIrW(listw, rho=0.1); Omega &lt;- tcrossprod(Omega)</code>, <code>chol()</code> is taken internally</p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_save.m">save.M</code></td>
<td>
<p>return the full M matrix for use in <code>spdep:::exactMoranAlt</code></p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_save.u">save.U</code></td>
<td>
<p>return the full U matrix for use in <code>spdep:::exactMoranAlt</code></p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_usetp">useTP</code></td>
<td>
<p>default FALSE, if TRUE, use truncation point in integration rather than upper=Inf, see Tiefelsdorf (2000), eq. 6.7, p.69</p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_truncerr">truncErr</code></td>
<td>
<p>when useTP=TRUE, pass truncation error to truncation point function</p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_zerotreat">zeroTreat</code></td>
<td>
<p>when useTP=TRUE, pass zero adjustment to truncation point function</p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_x">x</code></td>
<td>
<p>a moranex object</p>
</td></tr>
<tr><td><code id="lm.morantest.exact_+3A_...">...</code></td>
<td>
<p>arguments to be passed through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>moranex</code> with the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the saddlepoint approximation of the
standard deviate of global Moran's I.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed global Moran's I.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>eigenvalues (excluding zero values)</p>
</td></tr>
<tr><td><code>oType</code></td>
<td>
<p>usually set to &quot;E&quot;</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Reder and Roger Bivand</p>


<h3>References</h3>

<p>Roger Bivand, Werner G. Müller and Markus Reder (2009) &quot;Power calculations for global and local Moran's I.&quot; <em>Computational Statistics &amp; Data Analysis</em> 53, 2859-2872.</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm.morantest.sad">lm.morantest.sad</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>eire &lt;- st_read(system.file("shapes/eire.shp", package="spData")[1])
row.names(eire) &lt;- as.character(eire$names)
st_crs(eire) &lt;- "+proj=utm +zone=30 +ellps=airy +units=km"
eire.nb &lt;- poly2nb(eire)
e.lm &lt;- lm(OWNCONS ~ ROADACC, data=eire)
lm.morantest(e.lm, nb2listw(eire.nb))
lm.morantest.sad(e.lm, nb2listw(eire.nb))
lm.morantest.exact(e.lm, nb2listw(eire.nb))
lm.morantest.exact(e.lm, nb2listw(eire.nb), useTP=TRUE)
</code></pre>

<hr>
<h2 id='lm.morantest.sad'>Saddlepoint approximation of global Moran's I test</h2><span id='topic+lm.morantest.sad'></span><span id='topic+print.moransad'></span><span id='topic+summary.moransad'></span><span id='topic+print.summary.moransad'></span>

<h3>Description</h3>

<p>The function implements Tiefelsdorf's application of the Saddlepoint
approximation to global Moran's I's reference distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.morantest.sad(model, listw, zero.policy=attr(listw, "zero.policy"),
  alternative="greater", spChk=NULL, resfun=weighted.residuals,
  tol=.Machine$double.eps^0.5, maxiter=1000, tol.bounds=0.0001,
  zero.tol = 1e-07, Omega=NULL, save.M=NULL, save.U=NULL)
## S3 method for class 'moransad'
print(x, ...)
## S3 method for class 'moransad'
summary(object, ...)
## S3 method for class 'summary.moransad'
print(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.morantest.sad_+3A_model">model</code></td>
<td>
<p>an object of class <code>lm</code> returned by <code>lm</code>; weights
may be specified in the <code>lm</code> fit, but offsets should not be used</p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without
neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_resfun">resfun</code></td>
<td>
<p>default: weighted.residuals; the function to be used to extract residuals from the <code>lm</code> object, may be <code>residuals</code>, <code>weighted.residuals</code>, <code>rstandard</code>, or <code>rstudent</code></p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance) for <code>uniroot</code></p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations for <code>uniroot</code></p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_tol.bounds">tol.bounds</code></td>
<td>
<p>offset from bounds for <code>uniroot</code></p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_zero.tol">zero.tol</code></td>
<td>
<p>tolerance used to find eigenvalues close to absolute zero</p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_omega">Omega</code></td>
<td>
<p>A SAR process matrix may be passed in to test an alternative hypothesis, for example <code>Omega &lt;- invIrW(listw, rho=0.1); Omega &lt;- tcrossprod(Omega)</code>, <code>chol()</code> is taken internally</p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_save.m">save.M</code></td>
<td>
<p>return the full M matrix for use in <code>spdep:::exactMoranAlt</code></p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_save.u">save.U</code></td>
<td>
<p>return the full U matrix for use in <code>spdep:::exactMoranAlt</code></p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_x">x</code></td>
<td>
<p>object to be printed</p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_object">object</code></td>
<td>
<p>object to be summarised</p>
</td></tr>
<tr><td><code id="lm.morantest.sad_+3A_...">...</code></td>
<td>
<p>arguments to be passed through</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function involves finding the eigenvalues of an n by n matrix, and
numerically finding the root for the Saddlepoint approximation, and should
therefore only be used with care when n is large.
</p>


<h3>Value</h3>

<p>A list of class <code>moransad</code> with the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the saddlepoint approximation of the
standard deviate of global Moran's I.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed global Moran's I.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>internal1</code></td>
<td>
<p>Saddlepoint omega, r and u</p>
</td></tr>
<tr><td><code>internal2</code></td>
<td>
<p>f.root, iter and estim.prec from <code>uniroot</code></p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>eigenvalues (excluding zero values)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Tiefelsdorf, M. 2002 The Saddlepoint approximation of Moran's I 
and local Moran's Ii reference distributions and their numerical evaluation. 
Geographical Analysis, 34, pp. 187&ndash;206; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lm.morantest">lm.morantest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>eire &lt;- st_read(system.file("shapes/eire.shp", package="spData")[1])
row.names(eire) &lt;- as.character(eire$names)
st_crs(eire) &lt;- "+proj=utm +zone=30 +ellps=airy +units=km"
eire.nb &lt;- poly2nb(eire)
e.lm &lt;- lm(OWNCONS ~ ROADACC, data=eire)
lm.morantest(e.lm, nb2listw(eire.nb))
lm.morantest.sad(e.lm, nb2listw(eire.nb))
summary(lm.morantest.sad(e.lm, nb2listw(eire.nb)))
e.wlm &lt;- lm(OWNCONS ~ ROADACC, data=eire, weights=RETSALE)
lm.morantest(e.wlm, nb2listw(eire.nb), resfun=rstudent)
lm.morantest.sad(e.wlm, nb2listw(eire.nb), resfun=rstudent)
</code></pre>

<hr>
<h2 id='local_joincount_bv'>Calculate the local bivariate join count</h2><span id='topic+local_joincount_bv'></span>

<h3>Description</h3>

<p>The bivariate join count (BJC) evaluates event occurrences in predefined regions and tests if the co-occurrence of events deviates from complete spatial randomness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_joincount_bv(
  x,
  z,
  listw,
  nsim = 199,
  alternative = "two.sided"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_joincount_bv_+3A_x">x</code></td>
<td>
<p>a binary variable either numeric or logical</p>
</td></tr>
<tr><td><code id="local_joincount_bv_+3A_z">z</code></td>
<td>
<p>a binary variable either numeric or logical with the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="local_joincount_bv_+3A_listw">listw</code></td>
<td>
<p>a listw object containing binary weights created, for example, with <code>nb2listw(nb, style = "B")</code></p>
</td></tr>
<tr><td><code id="local_joincount_bv_+3A_nsim">nsim</code></td>
<td>
<p>the number of conditional permutation simulations</p>
</td></tr>
<tr><td><code id="local_joincount_bv_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"greater"</code>. One of <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two cases that are evaluated in the bivariate join count. The first being in-situ colocation (CLC) where xi = 1 and zi = 1. The second is the general form of the bivariate join count (BJC) that is used when there is no in-situ colocation.
</p>
<p>The BJC case &quot;is useful when x and z cannot occur in the same location, such as when x and z correspond to two different values of a single categorical variable&quot; or &quot;when x and z can co-locate, but do not&quot; (Anselin and Li, 2019). Whereas the CLC case is useful in evaluating simultaneous occurrences of events.
</p>
<p>The local bivariate join count statistic requires a binary weights list which can be generated with <code>nb2listw(nb, style = "B")</code>.
</p>
<p>P-values are only reported for those regions that match the CLC or BJC criteria. Others will not have an associated p-value.
</p>
<p>P-values are estimated using a conditional permutation approach. This creates a reference distribution from which the observed statistic is compared.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with two columns <code>join_count</code> and <code>p_sim</code> and number of rows equal to the length of arguments <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Josiah Parry <a href="mailto:josiah.parry@gmail.com">josiah.parry@gmail.com</a></p>


<h3>References</h3>

<p>Anselin, L., &amp; Li, X. (2019). Operational Local Join Count Statistics for Cluster Detection. Journal of geographical systems, 21(2), 189–210. <a href="https://doi.org/10.1007/s10109-019-00299-x">doi:10.1007/s10109-019-00299-x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("oldcol")
listw &lt;- nb2listw(COL.nb, style = "B")
# Colocation case
x &lt;- COL.OLD[["CP"]]
z &lt;- COL.OLD[["EW"]]
set.seed(1)
res &lt;- local_joincount_bv(x, z, listw)
na.omit(res)
# no colocation case
z &lt;- 1 - x
set.seed(1)
res &lt;- local_joincount_bv(x, z, listw)
na.omit(res)
</code></pre>

<hr>
<h2 id='local_joincount_uni'>Calculate the local univariate join count</h2><span id='topic+local_joincount_uni'></span>

<h3>Description</h3>

<p>The univariate local join count statistic is used to identify clusters of rarely occurring binary variables. The binary variable of interest should occur less
than half of the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_joincount_uni(
  fx,
  chosen,
  listw,
  alternative = "two.sided",
  nsim = 199,
  iseed = NULL,
  no_repeat_in_row=FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_joincount_uni_+3A_fx">fx</code></td>
<td>
<p>a binary variable either numeric or logical</p>
</td></tr>
<tr><td><code id="local_joincount_uni_+3A_chosen">chosen</code></td>
<td>
<p>a scalar character containing the level of <code>fx</code> that should be considered the observed value (1).</p>
</td></tr>
<tr><td><code id="local_joincount_uni_+3A_listw">listw</code></td>
<td>
<p>a listw object containing binary weights created, for example, with <code>nbwlistw(nb, style = "B")</code></p>
</td></tr>
<tr><td><code id="local_joincount_uni_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"greater"</code>. One of <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="local_joincount_uni_+3A_nsim">nsim</code></td>
<td>
<p>the number of conditional permutation simulations</p>
</td></tr>
<tr><td><code id="local_joincount_uni_+3A_iseed">iseed</code></td>
<td>
<p>default NULL, used to set the seed for possible parallel RNGs</p>
</td></tr>
<tr><td><code id="local_joincount_uni_+3A_no_repeat_in_row">no_repeat_in_row</code></td>
<td>
<p>default <code>FALSE</code>, if <code>TRUE</code>, sample conditionally in each row without replacements to avoid duplicate values, <a href="https://github.com/r-spatial/spdep/issues/124">https://github.com/r-spatial/spdep/issues/124</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The local join count statistic requires a binary weights list which can be generated with <code>nb2listw(nb, style = "B")</code>. Additionally, ensure that the binary variable of interest is rarely occurring in no more than half of observations.
</p>
<p>P-values are estimated using a conditional permutation approach. This creates a reference distribution from which the observed statistic is compared. For more see <a href="https://geodacenter.github.io/glossary.html#ppvalue">Geoda Glossary</a>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with two columns <code>BB</code> and <code>Pr()</code> and number of rows equal to the length of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Josiah Parry <a href="mailto:josiah.parry@gmail.com">josiah.parry@gmail.com</a></p>


<h3>References</h3>

<p>Anselin, L., &amp; Li, X. (2019). Operational Local Join Count Statistics for Cluster Detection. Journal of geographical systems, 21(2), 189–210. <a href="https://doi.org/10.1007/s10109-019-00299-x">doi:10.1007/s10109-019-00299-x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
fx &lt;- as.factor(ifelse(COL.OLD$CRIME &lt; 35, "low-crime", "high-crime"))
listw &lt;- nb2listw(COL.nb, style = "B")
set.seed(1)
(res &lt;- local_joincount_uni(fx, chosen = "high-crime", listw))
</code></pre>

<hr>
<h2 id='localC'>Compute Local Geary statistic</h2><span id='topic+localC'></span><span id='topic+localC.default'></span><span id='topic+localC.formula'></span><span id='topic+localC.list'></span><span id='topic+localC.matrix'></span><span id='topic+localC.data.frame'></span><span id='topic+localC_perm'></span><span id='topic+localC_perm.default'></span><span id='topic+localC_perm.formula'></span>

<h3>Description</h3>

<p>The Local Geary is a local adaptation of Geary's C statistic of spatial autocorrelation. The Local Geary uses squared differences to measure dissimilarity unlike the Local Moran. Low values of the Local Geary indicate positive spatial autocorrelation and large refers to negative spatial autocorrelation.
</p>
<p>Inference for the Local Geary is based on a permutation approach which compares the observed value to the reference distribution under spatial randomness. <code>localC_perm()</code> returns a pseudo p-value. This is not an analytical p-value and is based on the number of permutations and as such should be used with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localC(x, ..., zero.policy=NULL)

## Default S3 method:
localC(x, listw, ..., zero.policy=attr(listw, "zero.policy"))

## S3 method for class 'formula'
localC(formula, data, listw, ..., zero.policy=attr(listw, "zero.policy"))

## S3 method for class 'list'
localC(x, listw, ..., zero.policy=attr(listw, "zero.policy"))

## S3 method for class 'matrix'
localC(x, listw, ..., zero.policy=attr(listw, "zero.policy"))

## S3 method for class 'data.frame'
localC(x, listw, ..., zero.policy=attr(listw, "zero.policy"))

localC_perm(x, ..., zero.policy=NULL, iseed=NULL, no_repeat_in_row=FALSE)

## Default S3 method:
localC_perm(x, listw, nsim = 499, alternative = "two.sided", ...,
 zero.policy=attr(listw, "zero.policy"), iseed=NULL, no_repeat_in_row=FALSE)

## S3 method for class 'formula'
localC_perm(formula, data, listw, nsim = 499,
 alternative = "two.sided", ..., zero.policy=attr(listw, "zero.policy"), iseed=NULL,
 no_repeat_in_row=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localC_+3A_x">x</code></td>
<td>
<p>a numeric vector, numeric matrix, or list. See details for more.</p>
</td></tr>
<tr><td><code id="localC_+3A_formula">formula</code></td>
<td>
<p>A one-sided formula determining which variables to be used.</p>
</td></tr>
<tr><td><code id="localC_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code>.</p>
</td></tr>
<tr><td><code id="localC_+3A_data">data</code></td>
<td>
<p>Used when a formula is provided. A matrix or data frame containing the variables in the formula <code>formula</code>.</p>
</td></tr>
<tr><td><code id="localC_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to be used for permutation test.</p>
</td></tr>
<tr><td><code id="localC_+3A_alternative">alternative</code></td>
<td>
<p>A character defining the alternative hypothesis. Must be one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="localC_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="localC_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA.</p>
</td></tr>
<tr><td><code id="localC_+3A_iseed">iseed</code></td>
<td>
<p>default NULL, used to set the seed for possible parallel RNGs</p>
</td></tr>
<tr><td><code id="localC_+3A_no_repeat_in_row">no_repeat_in_row</code></td>
<td>
<p>default <code>FALSE</code>, if <code>TRUE</code>, sample conditionally in each row without replacements to avoid duplicate values, <a href="https://github.com/r-spatial/spdep/issues/124">https://github.com/r-spatial/spdep/issues/124</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Local Geary can be extended to a multivariate context. When <code>x</code> is a numeric vector, the univariate Local Geary will be calculated. To calculate the multivariate Local Moran provide either a list or a matrix. When <code>x</code> is a list, each element must be a numeric vector of the same length and of the same length as the neighbours in <code>listw</code>. In the case that <code>x</code> is a matrix the number of rows must be the same as the length of the neighbours in <code>listw</code>.
</p>
<p>While not required in the univariate context, the standardized Local Geary is calculated. The multivariate Local Geary is <em>always</em> standardized.
</p>
<p>The univariate Local Geary is calculated as <code class="reqn">c_i = \sum_j w_{ij}(x_i - x_j)^2</code> and the multivariate Local Geary is calculated as <code class="reqn">c_{k,i} = \sum_{v=1}^{k} c_{v,i}</code> as described in Anselin (2019).
</p>


<h3>Value</h3>

<p>A numeric vector containing Local Geary statistic with attribute <code>pseudo-p</code> when <code>localC_perm()</code> is used. <code>pseudo-p</code> is an 8 column matrix containing
</p>
<table>
<tr><td><code>E.Ci</code></td>
<td>
<p>expectation of the Local Geary statistic based on permutation sample</p>
</td></tr>
<tr><td><code>Var.Ci</code></td>
<td>
<p>variance of Local Geary based on permutation sample</p>
</td></tr>
<tr><td><code>Z.Ci</code></td>
<td>
<p>standard deviate of Local Geary based on permutation sample</p>
</td></tr>
<tr><td><code>Pr()</code></td>
<td>
<p>p-value of Local Geary statistic using <code>pnorm()</code> using standard deviates based on permutation sample means and standard deviations</p>
</td></tr>
<tr><td><code>Pr() Sim</code></td>
<td>
<p><code>rank()</code> and <code>punif()</code> of observed statistic rank for [0, 1] p-values using <code>alternative=</code></p>
</td></tr>
<tr><td><code>Pr(folded) Sim</code></td>
<td>
<p>the simulation folded [0, 0.5] range ranked p-value (based on <a href="https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213">https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213</a>)</p>
</td></tr>
<tr><td><code>Skewness</code></td>
<td>
<p>the output of <code>e1071::skewness()</code> for the permutation samples underlying the standard deviates</p>
</td></tr>
<tr><td><code>Kurtosis</code></td>
<td>
<p>the output of <code>e1071::kurtosis()</code> for the permutation samples underlying the standard deviates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Josiah Parry <a href="mailto:josiah.parry@gmail.com">josiah.parry@gmail.com</a> and Roger Bivand
</p>


<h3>References</h3>

<p>Anselin, L. (1995), Local Indicators of Spatial Association—LISA. Geographical Analysis, 27: 93-115. <a href="https://doi.org/10.1111/j.1538-4632.1995.tb00338.x">doi:10.1111/j.1538-4632.1995.tb00338.x</a>
</p>
<p>Anselin, L. (2019), A Local Indicator of Multivariate Spatial Association: Extending Geary's c. Geogr Anal, 51: 133-150. <a href="https://doi.org/10.1111/gean.12164">doi:10.1111/gean.12164</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig &lt;- spData::africa.rook.nb
listw &lt;- nb2listw(orig)
x &lt;- spData::afcon$totcon

(A &lt;- localC(x, listw))
listw1 &lt;- nb2listw(droplinks(sym.attr.nb(orig), 3, sym=TRUE), zero.policy=TRUE)
(A1 &lt;- localC(x, listw1, zero.policy=FALSE))
(A2 &lt;- localC(x, listw1, zero.policy=TRUE))
run &lt;- FALSE
if (require(rgeoda, quietly=TRUE)) run &lt;- TRUE
if (run) {
  W &lt;- create_weights(as.numeric(length(x)))
  for (i in 1:length(listw$neighbours)) {
    set_neighbors_with_weights(W, i, listw$neighbours[[i]], listw$weights[[i]])
    update_weights(W)
  }
  set.seed(1)
  B &lt;- local_geary(W, data.frame(x))
  all.equal(A, lisa_values(B))
}
if (run) {
  set.seed(1)
  C &lt;- localC_perm(x, listw, nsim = 499, conditional=TRUE,
    alternative="two.sided")
  cor(ifelse(lisa_pvalues(B) &lt; 0.5, lisa_pvalues(B), 1-lisa_pvalues(B)),
    attr(C, "pseudo-p")[,6])
}
# pseudo-p values probably wrongly folded https://github.com/GeoDaCenter/rgeoda/issues/28
## Not run: 
tmap_ok &lt;- FALSE
if (require(tmap, quietly=TRUE)) tmap_ok &lt;- TRUE
if (run) {
  # doi: 10.1111/gean.12164
  guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
  g &lt;- st_read(guerry_path)[, 7:12]
  cor(st_drop_geometry(g)) #(Tab. 1)
  lw &lt;- nb2listw(poly2nb(g))
  moran(g$Crm_prs, lw, n=nrow(g), S0=Szero(lw))$I
  moran(g$Crm_prp, lw, n=nrow(g), S0=Szero(lw))$I
  moran(g$Litercy, lw, n=nrow(g), S0=Szero(lw))$I
  moran(g$Donatns, lw, n=nrow(g), S0=Szero(lw))$I
  moran(g$Infants, lw, n=nrow(g), S0=Szero(lw))$I
  moran(g$Suicids, lw, n=nrow(g), S0=Szero(lw))$I
}
if (run) {
  o &lt;- prcomp(st_drop_geometry(g), scale.=TRUE)
  cor(st_drop_geometry(g), o$x[,1:2])^2 #(Tab. 2)
}
if (run) {
  g$PC1 &lt;- o$x[, "PC1"]
  brks &lt;- c(min(g$PC1), natural_breaks(k=6, g["PC1"]), max(g$PC1))
  if (tmap_ok) tm_shape(g) + tm_fill("PC1", breaks=brks, midpoint=0) + 
    tm_borders() # Fig. 1
  else pplot(g["PC1"], breaks=brks)
}
if (run) {
  g$PC2 &lt;- -1*o$x[, "PC2"] # eigenvalue sign arbitrary
  brks &lt;- c(min(g$PC2), natural_breaks(k=6, g["PC2"]), max(g$PC2))
  if (tmap_ok) tm_shape(g) + tm_fill("PC2", breaks=brks, midpoint=0) + 
    tm_borders() # Fig. 2
  else plot(g["PC2"], breaks=brks)
}
if (run) {
  w &lt;- queen_weights(g)
  lm_PC1 &lt;- local_moran(w, g["PC1"], significance_cutoff=0.01,
    permutations=99999)
  g$lm_PC1 &lt;- factor(lisa_clusters(lm_PC1), levels=0:4,
    labels=lisa_labels(lm_PC1)[1:5])
  is.na(g$lm_PC1) &lt;- g$lm_PC1 == "Not significant"
  g$lm_PC1 &lt;- droplevels(g$lm_PC1)
  if (tmap_ok) tm_shape(g) + tm_fill("lm_PC1", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 3
  else plot(g["lm_PC1"])
}
if (run) {
  set.seed(1)
  lm_PC1_spdep &lt;- localmoran_perm(g$PC1, lw, nsim=9999)
  q &lt;- attr(lm_PC1_spdep, "quadr")$pysal
  g$lm_PC1_spdep &lt;- q
  is.na(g$lm_PC1_spdep) &lt;- lm_PC1_spdep[,6] &gt; 0.02 # note folded p-values
  g$lm_PC1_spdep &lt;- droplevels(g$lm_PC1_spdep)
  if (tmap_ok) tm_shape(g) + tm_fill("lm_PC1_spdep", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # rep. Fig. 3
  else plot(g["lm_PC1_spdep"])
}
if (run) {
  lg_PC1 &lt;- local_g(w, g["PC1"], significance_cutoff=0.01,
    permutations=99999)
  g$lg_PC1 &lt;- factor(lisa_clusters(lg_PC1), levels=0:2,
    labels=lisa_labels(lg_PC1)[0:3])
  is.na(g$lg_PC1) &lt;- g$lg_PC1 == "Not significant"
  g$lg_PC1 &lt;- droplevels(g$lg_PC1)
  if (tmap_ok) tm_shape(g) + tm_fill("lg_PC1", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 4 (wrong)
  else plot(g["lg_PC1"])
  g$lg_PC1a &lt;- cut(g$PC1, c(-Inf, mean(g$PC1), Inf), labels=c("Low", "High"))
  is.na(g$lg_PC1a) &lt;- lisa_pvalues(lg_PC1) &gt;= 0.01
  g$lg_PC1a &lt;- droplevels(g$lg_PC1a)
  if (tmap_ok) tm_shape(g) + tm_fill("lg_PC1", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 4 (guess)
  else plot(g["lg_PC1"])
}
if (run) {
  lc_PC1 &lt;- local_geary(w, g["PC1"], significance_cutoff=0.01,
    permutations=99999)
  g$lc_PC1 &lt;- factor(lisa_clusters(lc_PC1), levels=0:4,
    labels=lisa_labels(lc_PC1)[1:5])
  is.na(g$lc_PC1) &lt;- g$lc_PC1 == "Not significant"
  g$lc_PC1 &lt;- droplevels(g$lc_PC1)
  if (tmap_ok) tm_shape(g) + tm_fill("lc_PC1", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 5
  else plot(g["lc_PC1"])
}
if (run) {
  set.seed(1)
  system.time(lc_PC1_spdep &lt;- localC_perm(g$PC1, lw, nsim=9999,
    alternative="two.sided"))
}
if (run) {
  if (require(parallel, quietly=TRUE)) {
    ncpus &lt;- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L
# test with single core
    if (ncpus &gt; 1L) ncpus &lt;- 1L
    cores &lt;- get.coresOption()
    set.coresOption(ncpus)
    system.time(lmc_PC1_spdep1 &lt;- localC_perm(g$PC1, lw, nsim=9999,
      alternative="two.sided", iseed=1))
    set.coresOption(cores)
  }
}
if (run) {
  g$lc_PC1_spdep &lt;- attr(lc_PC1_spdep, "cluster")
  is.na(g$lc_PC1_spdep) &lt;- attr(lc_PC1_spdep, "pseudo-p")[,6] &gt; 0.01
  g$lc_PC1_spdep &lt;- droplevels(g$lc_PC1_spdep)
  if (tmap_ok) tm_shape(g) + tm_fill("lc_PC1_spdep", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # rep. Fig. 5
  else plot(g["lc_PC1_spdep"])
}
if (run) {
  g$both_PC1 &lt;- interaction(g$lc_PC1, g$lm_PC1)
  g$both_PC1 &lt;- droplevels(g$both_PC1)
  if (tmap_ok) tm_shape(g) + tm_fill("both_PC1", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 6
  else plot(g["both_PC1"])
}
if (run) {
  lc005_PC1 &lt;- local_geary(w, g["PC1"], significance_cutoff=0.005,
    permutations=99999)
  g$lc005_PC1 &lt;- factor(lisa_clusters(lc005_PC1), levels=0:4,
    labels=lisa_labels(lc005_PC1)[1:5])
  is.na(g$lc005_PC1) &lt;- g$lc005_PC1 == "Not significant"
  g$lc005_PC1 &lt;- droplevels(g$lc005_PC1)
  if (tmap_ok) tm_shape(g) + tm_fill("lc005_PC1", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 7
  else plot(g["lc005_PC1"])
}
if (run) {
  g$lc005_PC1_spdep &lt;- attr(lc_PC1_spdep, "cluster")
  is.na(g$lc005_PC1_spdep) &lt;- attr(lc_PC1_spdep, "pseudo-p")[,6] &gt; 0.005
  g$lc005_PC1_spdep &lt;- droplevels(g$lc005_PC1_spdep)
  if (tmap_ok) tm_shape(g) + tm_fill("lc005_PC1_spdep", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # rep. Fig. 7
  else plot(g["lc005_PC1_spdep"])
}
if (run) {
  lc001_PC1 &lt;- local_geary(w, g["PC1"], significance_cutoff=0.001,
    permutations=99999)
  g$lc001_PC1 &lt;- factor(lisa_clusters(lc001_PC1), levels=0:4,
    labels=lisa_labels(lc001_PC1)[1:5])
  is.na(g$lc001_PC1) &lt;- g$lc001_PC1 == "Not significant"
  g$lc001_PC1 &lt;- droplevels(g$lc001_PC1)
  if (tmap_ok) tm_shape(g) + tm_fill("lc001_PC1", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 8
  else plot(g["lc001_PC1"])
if (run) {
  g$lc001_PC1_spdep &lt;- attr(lc_PC1_spdep, "cluster")
  is.na(g$lc001_PC1_spdep) &lt;- attr(lc_PC1_spdep, "pseudo-p")[,6] &gt; 0.001
  g$lc001_PC1_spdep &lt;- droplevels(g$lc001_PC1_spdep)
  if (tmap_ok) tm_shape(g) + tm_fill("lc001_PC1_spdep", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # rep. Fig. 8
  else plot(g["lc001_PC1_spdep"])
}
}
if (run) {
  lc_PC2 &lt;- local_geary(w, g["PC2"], significance_cutoff=0.01,
    permutations=99999)
  g$lc_PC2 &lt;- factor(lisa_clusters(lc_PC2), levels=0:4,
    labels=lisa_labels(lc_PC2)[1:5])
  is.na(g$lc_PC2) &lt;- g$lc_PC2 == "Not significant"
  g$lc_PC2 &lt;- droplevels(g$lc_PC2)
  if (tmap_ok) tm_shape(g) + tm_fill("lc_PC2", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 9
  else plot(g["lc_PC2"])
}
if (run) {
  lmc_PC &lt;- local_multigeary(w, g[c("PC1","PC2")], significance_cutoff=0.00247,
    permutations=99999)
  g$lmc_PC &lt;- factor(lisa_clusters(lmc_PC), levels=0:1,
    labels=lisa_labels(lmc_PC)[1:2])
  is.na(g$lmc_PC) &lt;- g$lmc_PC == "Not significant"
  g$lmc_PC &lt;- droplevels(g$lmc_PC)
  table(interaction((p.adjust(lisa_pvalues(lmc_PC), "fdr") &lt; 0.01), g$lmc_PC))
}
if (run) {
  if (tmap_ok) tm_shape(g) + tm_fill("lmc_PC", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 10
  else plot(g["lmc_PC"])
}
if (run) {
  set.seed(1)
  lmc_PC_spdep &lt;- localC_perm(g[c("PC1","PC2")], lw, nsim=9999, alternative="two.sided")
  all.equal(lisa_values(lmc_PC), c(lmc_PC_spdep))
}
if (run) {
  cor(attr(lmc_PC_spdep, "pseudo-p")[,6], lisa_pvalues(lmc_PC))
}
if (run) {
  g$lmc_PC_spdep &lt;- attr(lmc_PC_spdep, "cluster")
  is.na(g$lmc_PC_spdep) &lt;- p.adjust(attr(lmc_PC_spdep, "pseudo-p")[,6], "fdr") &gt; 0.01
  g$lmc_PC_spdep &lt;- droplevels(g$lmc_PC_spdep)
  if (tmap_ok) tm_shape(g) + tm_fill("lmc_PC_spdep", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # rep. Fig. 10
  else plot(g["lmc_PC_spdep"])
}
if (run) {
  lmc_vars &lt;- local_multigeary(w, st_drop_geometry(g)[, 1:6],
    significance_cutoff=0.00247, permutations=99999)
  g$lmc_vars &lt;- factor(lisa_clusters(lmc_vars), levels=0:1,
    labels=lisa_labels(lmc_vars)[1:2])
  is.na(g$lmc_vars) &lt;- g$lmc_vars == "Not significant"
  g$lmc_vars &lt;- droplevels(g$lmc_vars)
  table(interaction((p.adjust(lisa_pvalues(lmc_vars), "fdr") &lt; 0.01),
    g$lmc_vars))
}
if (run) {
  if (tmap_ok) tm_shape(g) + tm_fill("lmc_vars", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # Fig. 11
  else plot(g["lmc_vars"])
}
if (run) {
  set.seed(1)
  system.time(lmc_vars_spdep &lt;- localC_perm(st_drop_geometry(g)[, 1:6], lw,
    nsim=9999, alternative="two.sided"))
}
if (run) {
  all.equal(lisa_values(lmc_vars), c(lmc_vars_spdep))
}
if (run) {
  cor(attr(lmc_vars_spdep, "pseudo-p")[,6], lisa_pvalues(lmc_vars))
}
if (run) {
  if (require(parallel, quietly=TRUE)) {
    ncpus &lt;- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L
# test with single core
    if (ncpus &gt; 1L) ncpus &lt;- 1L
    cores &lt;- get.coresOption()
    set.coresOption(ncpus)
    system.time(lmc_vars_spdep1 &lt;- localC_perm(st_drop_geometry(g)[, 1:6], lw,
      nsim=9999, alternative="two.sided", iseed=1))
    set.coresOption(cores)
  }
}
if (run) {
  all.equal(lisa_values(lmc_vars), c(lmc_vars_spdep1))
}
if (run) {
  cor(attr(lmc_vars_spdep1, "pseudo-p")[,6], lisa_pvalues(lmc_vars))
}
if (run) {
  g$lmc_vars_spdep &lt;- attr(lmc_vars_spdep1, "cluster")
  is.na(g$lmc_vars_spdep) &lt;- p.adjust(attr(lmc_vars_spdep1, "pseudo-p")[,6], "fdr") &gt; 0.01
  g$lmc_vars_spdep &lt;- droplevels(g$lmc_vars_spdep)
  if (tmap_ok) tm_shape(g) + tm_fill("lmc_vars_spdep", textNA="Insignificant",
    colorNA="gray95") + tm_borders() # rep. Fig. 11
  else plot(g["lmc_vars_spdep"])
}


## End(Not run)
## Not run: 
library(reticulate)
use_python("/usr/bin/python", required = TRUE)
gp &lt;- import("geopandas")
ps &lt;- import("libpysal")
W &lt;- listw2mat(listw)
w &lt;- ps$weights$full2W(W, rownames(W))
w$transform &lt;- "R"
esda &lt;- import("esda")
lM &lt;- esda$Moran_Local(x, w)
all.equal(unname(localmoran(x, listw, mlvar=FALSE)[,1]), c(lM$Is))
# confirm x and w the same
lC &lt;- esda$Geary_Local(connectivity=w)$fit(scale(x))
# np$std missing ddof=1
n &lt;- length(x)
D0 &lt;- spdep:::geary.intern((x - mean(x)) / sqrt(var(x)*(n-1)/n), listw, n=n)
# lC components probably wrongly ordered https://github.com/pysal/esda/issues/192
o &lt;- match(round(D0, 6), round(lC$localG, 6))
all.equal(c(lC$localG)[o], D0)
# simulation order not retained
lC$p_sim[o]
attr(C, "pseudo-p")[,6]

## End(Not run)
</code></pre>

<hr>
<h2 id='localG'>G and Gstar local spatial statistics</h2><span id='topic+localG'></span><span id='topic+localG_perm'></span>

<h3>Description</h3>

<p>The local spatial statistic G is calculated for each zone based on the
spatial weights object used. The value returned is a Z-value, and may be
used as a diagnostic tool. High positive values indicate the posibility
of a local cluster of high values of the variable being analysed, very
low relative values a similar cluster of low values. For inference,
a Bonferroni-type test is suggested in the references, where tables of
critical values may be found (see also details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localG(x, listw, zero.policy=attr(listw, "zero.policy"), spChk=NULL, GeoDa=FALSE,
 alternative = "two.sided", return_internals=TRUE)
localG_perm(x, listw, nsim=499, zero.policy=attr(listw, "zero.policy"), spChk=NULL,
 alternative = "two.sided", iseed=NULL, fix_i_in_Gstar_permutations=TRUE,
 no_repeat_in_row=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localG_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="localG_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="localG_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="localG_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="localG_+3A_geoda">GeoDa</code></td>
<td>
<p>default FALSE, if TRUE, drop x values for no-neighbour and self-neighbour only observations from all summations</p>
</td></tr>
<tr><td><code id="localG_+3A_nsim">nsim</code></td>
<td>
<p>default 499, number of conditonal permutation simulations</p>
</td></tr>
<tr><td><code id="localG_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>.</p>
</td></tr>
<tr><td><code id="localG_+3A_return_internals">return_internals</code></td>
<td>
<p>default <code>TRUE</code>, unused</p>
</td></tr>
<tr><td><code id="localG_+3A_iseed">iseed</code></td>
<td>
<p>default NULL, used to set the seed for possible parallel RNGs</p>
</td></tr>
<tr><td><code id="localG_+3A_fix_i_in_gstar_permutations">fix_i_in_Gstar_permutations</code></td>
<td>
<p>default <code>TRUE</code> (fix x at self in permutations for local G-star), set <code>FALSE</code> to use pre-1.2-8 behaviour</p>
</td></tr>
<tr><td><code id="localG_+3A_no_repeat_in_row">no_repeat_in_row</code></td>
<td>
<p>default <code>FALSE</code>, if <code>TRUE</code>, sample conditionally in each row without replacements to avoid duplicate values, <a href="https://github.com/r-spatial/spdep/issues/124">https://github.com/r-spatial/spdep/issues/124</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the neighbours member of listw has a &quot;self.included&quot; attribute set
to TRUE, the Gstar variant, including the self-weight <code class="reqn">w_{ii} &gt; 0</code>,
is calculated and returned.  The returned vector will have a &quot;gstari&quot;
attribute set to TRUE.  Self-weights must be included by using the
<code>include.self</code> function before converting
the neighbour list to a spatial weights list with <code>nb2listw</code> as
shown below in the example.
</p>
<p>The critical values of the statistic under assumptions given in the
references for the 95th percentile are for n=1: 1.645, n=50: 3.083,
n=100: 3.289, n=1000: 3.886.
</p>


<h3>Value</h3>

<p>A vector of G or Gstar standard deviate values, with attributes &quot;gstari&quot; set to TRUE or FALSE, &quot;call&quot; set to the function call, and class &quot;localG&quot;. For conditional permutation, the returned value is the same as for <code>localG()</code>, and the simulated standard deviate is returned as column <code>"StdDev.Gi"</code> in <code>attr(., "internals")</code>.
</p>


<h3>Note</h3>

<p>Conditional permutations added for comparative purposes; permutations are over the whole data vector omitting the observation itself, and from 1.2-8 fixing the observation itself as its own neighbour for local G-star.</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Ord, J. K. and Getis, A. 1995 Local spatial autocorrelation
statistics: distributional issues and an application. <em>Geographical
Analysis</em>, 27, 286&ndash;306; Getis, A. and Ord, J. K. 1996 Local spatial
statistics: an overview. In P. Longley and M. Batty (eds) <em>Spatial
analysis: modelling in a GIS environment</em> (Cambridge: Geoinformation
International), 261&ndash;277; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(getisord, package="spData")
# spData 0.3.2 changes x, y, xyz object names to go_x, go_y, go_xyz to
# avoid putting these objects into the global environment via lazy loading
if (exists("go_xyz") &amp;&amp; packageVersion("spData") &gt;= "0.3.2") {
  xyz &lt;- go_xyz
  x &lt;- go_x
  y &lt;- go_y
}
xycoords &lt;- cbind(xyz$x, xyz$y)
nb30 &lt;- dnearneigh(xycoords, 0, 30)
G30 &lt;- localG(xyz$val, nb2listw(nb30, style="B"))
G30[length(xyz$val)-136]
set.seed(1)
G30_sim &lt;- localG_perm(xyz$val, nb2listw(nb30, style="B"))
G30_sim[length(xyz$val)-136]
nb60 &lt;- dnearneigh(xycoords, 0, 60)
G60 &lt;- localG(xyz$val, nb2listw(nb60, style="B"))
G60[length(xyz$val)-136]
nb90 &lt;- dnearneigh(xycoords, 0, 90)
G90 &lt;- localG(xyz$val, nb2listw(nb90, style="B"))
G90[length(xyz$val)-136]
nb120 &lt;- dnearneigh(xycoords, 0, 120)
G120 &lt;- localG(xyz$val, nb2listw(nb120, style="B"))
G120[length(xyz$val)-136]
nb150 &lt;- dnearneigh(xycoords, 0, 150)
G150 &lt;- localG(xyz$val, nb2listw(nb150, style="B"))
G150[length(xyz$val)-136]
brks &lt;- seq(-5,5,1)
cm.col &lt;- cm.colors(length(brks)-1)
image(x, y, t(matrix(G30, nrow=16, ncol=16, byrow=TRUE)),
  breaks=brks, col=cm.col, asp=1)
text(xyz$x, xyz$y, round(G30, digits=1), cex=0.7)
polygon(c(195,225,225,195), c(195,195,225,225), lwd=2)
title(main=expression(paste("Values of the ", G[i], " statistic")))
G30s &lt;- localG(xyz$val, nb2listw(include.self(nb30),
 style="B"))
cat("value according to Getis and Ord's eq. 14.2, p. 263 (1996)\n")
G30s[length(xyz$val)-136]
cat(paste("value given by Getis and Ord (1996), p. 267",
  "(division by n-1 rather than n \n in variance)\n"))
G30s[length(xyz$val)-136] *
  (sqrt(sum(scale(xyz$val, scale=FALSE)^2)/length(xyz$val)) /
  sqrt(var(xyz$val)))
image(x, y, t(matrix(G30s, nrow=16, ncol=16, byrow=TRUE)),
  breaks=brks, col=cm.col, asp=1)
text(xyz$x, xyz$y, round(G30s, digits=1), cex=0.7)
polygon(c(195,225,225,195), c(195,195,225,225), lwd=2)
title(main=expression(paste("Values of the ", G[i]^"*", " statistic")))
</code></pre>

<hr>
<h2 id='localGS'>A local hotspot statistic for analysing multiscale datasets</h2><span id='topic+localGS'></span>

<h3>Description</h3>

<p>The function implements the <code class="reqn">GS_i</code> test statistic for local hotspots on specific pairwise evaluated distance bands, as proposed by Westerholt et al. (2015).  Like the hotspot estimator <code class="reqn">G_i^*</code>, the <code class="reqn">GS_i</code> statistic is given as z-scores that can be evaluated accordingly. The idea of the method is to identify hotspots in datasets that comprise several, difficult-to-separate processes operating at different scales. This is often the case in complex user-generated datasets such as those from Twitter feeds. For example, a football match could be reflected in tweets from pubs, homes, and the stadium vicinity. These exemplified phenomena represent different processes that may be detected at different geometric scales. The <code class="reqn">GS_i</code> method enables this identification by specifying a geometric scale band and strictly calculating all statistical quantities such as mean and variance solely from respective relevant observations that interact on the range of the adjusted scale band. In addition, in each neighbourhood not only the relationships to the respective central unit, but all scale-relevant relationships are considered. In this way, hotspots can be detected on specific scale ranges independently of other scales. The statistic is given as:
</p>
<p style="text-align: center;"><code class="reqn">GS_i = \frac{\displaystyle\sum_{j; k &lt; j}{w_{ij}w_{ik}\phi_{jk}a_{jk}} - \frac{W_i}{\Phi} \displaystyle\sum_{j; k &lt; j}{\phi_{jk}a_{jk}}}{\sqrt{\frac{W_i}{\Phi}\displaystyle\sum_{j; k &lt; j}{\phi_{jk}a_{jk}^2} + \frac{W_i\left(W_i-1\right)}{\Phi\left(\Phi-1\right)}\left(\Gamma^2 -\!\! \displaystyle\sum_{j; k &lt; j}{\left(\phi_{jk}a_{jk}\right)^2}\right) - \left(\frac{W_i}{\Phi}\displaystyle\sum_{j; k &lt; j}{\phi_{jk}a_{jk}}\right)^2}}</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">a_{jk} = x_j + x_k,\;\;\; W_i = \displaystyle\sum_{j; k &lt; j}{w_{ij}w_{ik}\phi_{jk}},\;\;\; \Phi = \displaystyle\sum_{j; k &lt; j}{\phi_{jk}},\;\;\; \textrm{and} \;\;\; \Gamma = \displaystyle\sum_{j; k &lt; j}{\phi_{jk}a_{jk}}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>localGS(x, listw, dmin, dmax, attr, longlat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localGS_+3A_x">x</code></td>
<td>
<p>a <code>sf</code> or <code>sp</code> object</p>
</td></tr>
<tr><td><code id="localGS_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object</p>
</td></tr>
<tr><td><code id="localGS_+3A_dmin">dmin</code></td>
<td>
<p>a lower distance bound (greater than or equal)</p>
</td></tr>
<tr><td><code id="localGS_+3A_dmax">dmax</code></td>
<td>
<p>an upper distance bound (less than or equal)</p>
</td></tr>
<tr><td><code id="localGS_+3A_attr">attr</code></td>
<td>
<p>the name of the attribute of interest</p>
</td></tr>
<tr><td><code id="localGS_+3A_longlat">longlat</code></td>
<td>
<p>default NULL; TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometres; if x is a SpatialPoints object, the value is taken from the object itself, and overrides this argument if not NULL; distances are measured in map units if FALSE or NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only pairs of observations with a shared distance (in map units) on the interval [<code>dmin</code>, <code>dmax</code>] that are within a maximum radius of <code>dmax</code> around a corresponding output observation are considered. Thereby, also the mean values and variance terms estimated within the measure are adjusted to the scale range under consideration. For application examples of the method see Westerholt et al. (2015) (applied to tweets) and Sonea &amp; Westerholt (2021) (applied in an access to banking scenario).
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">GS_i</code> values that are given as z-scores.
</p>


<h3>Author(s)</h3>

<p>René Westerholt <a href="mailto:rene.westerholt@tu-dortmund.de">rene.westerholt@tu-dortmund.de</a></p>


<h3>References</h3>

<p>Westerholt, R., Resch, B. &amp; Zipf, A. 2015. A local scale-sensitive indicator of spatial autocorrelation for assessing high-and low-value clusters in multiscale datasets. International Journal of Geographical Information Science, 29(5), 868&ndash;887, <a href="https://doi.org/10.1080/13658816.2014.1002499">doi:10.1080/13658816.2014.1002499</a>.
</p>
<p>Sonea, A. and Westerholt, R. (2021): Geographic and temporal access to basic banking services in Wales. Applied Spatial Analysis and Policy, 14 (4), 879&ndash;905, <a href="https://doi.org/10.1007/s12061-021-09386-3">doi:10.1007/s12061-021-09386-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+localG">localG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
boston.tr &lt;- sf::st_read(system.file("shapes/boston_tracts.shp", package="spData")[1])
boston.tr_utm &lt;- st_transform(boston.tr, 32619) #26786

boston_listw1 &lt;- nb2listwdist(dnearneigh(st_centroid(boston.tr_utm), 1, 2000),
    boston.tr_utm, type = "dpd", alpha = 2, zero.policy = TRUE, dmax = 9500)

boston_listw2 &lt;- nb2listwdist(dnearneigh(st_centroid(boston.tr_utm), 5000, 9500), 
    boston.tr_utm, type = "dpd", alpha = 2, zero.policy = TRUE, dmax = 9500)

boston_RM_gsi_1 &lt;- localGS(boston.tr_utm, boston_listw1, 1, 2000, "RM", FALSE)
boston_RM_gsi_2 &lt;- localGS(boston.tr_utm, boston_listw2, 2000, 9500, "RM", FALSE)

</code></pre>

<hr>
<h2 id='localmoran'>Local Moran's I statistic</h2><span id='topic+localmoran'></span><span id='topic+localmoran_perm'></span>

<h3>Description</h3>

<p>The local spatial statistic Moran's I is calculated for each zone based on the
spatial weights object used. The values returned include a Z-value, and may be
used as a diagnostic tool. The statistic is:
</p>
<p style="text-align: center;"><code class="reqn">I_i = \frac{(x_i-\bar{x})}{{\sum_{k=1}^{n}(x_k-\bar{x})^2}/(n-1)}{\sum_{j=1}^{n}w_{ij}(x_j-\bar{x})}</code>
</p>
<p>,
and its expectation and variance were given in Anselin (1995), but those from Sokal et al. (1998) are implemented here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localmoran(x, listw, zero.policy=attr(listw, "zero.policy"), na.action=na.fail,
        conditional=TRUE, alternative = "two.sided", mlvar=TRUE,
        spChk=NULL, adjust.x=FALSE)
localmoran_perm(x, listw, nsim=499, zero.policy=attr(listw, "zero.policy"), 
        na.action=na.fail, alternative = "two.sided", mlvar=TRUE,
        spChk=NULL, adjust.x=FALSE, sample_Ei=TRUE, iseed=NULL,
        no_repeat_in_row=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localmoran_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="localmoran_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="localmoran_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="localmoran_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. If <code>na.pass</code> is used, zero is substituted for NA values in calculating the spatial lag. (Note that na.exclude will only work properly starting from R 1.9.0, na.omit and na.exclude assign the wrong classes in 1.8.*)</p>
</td></tr>
<tr><td><code id="localmoran_+3A_conditional">conditional</code></td>
<td>
<p>default TRUE: expectation and variance are calculated using the conditional randomization null (Sokal 1998 Eqs. A7 &amp; A8). Elaboration of these changes available in Sauer et al. (2021). If FALSE: expectation and variance are calculated using the total randomization null (Sokal 1998 Eqs. A3 &amp; A4).</p>
</td></tr>
<tr><td><code id="localmoran_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater, less or two.sided (default).</p>
</td></tr>
<tr><td><code id="localmoran_+3A_mlvar">mlvar</code></td>
<td>
<p>default TRUE: values of local Moran's I are reported using the variance of the variable of interest (sum of squared deviances over n), but can be reported as the sample variance, dividing by (n-1) instead; both are used in other implementations.</p>
</td></tr>
<tr><td><code id="localmoran_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="localmoran_+3A_adjust.x">adjust.x</code></td>
<td>
<p>default FALSE, if TRUE, x values of observations with no neighbours are omitted in the mean of x</p>
</td></tr>
<tr><td><code id="localmoran_+3A_nsim">nsim</code></td>
<td>
<p>default 499, number of conditonal permutation simulations</p>
</td></tr>
<tr><td><code id="localmoran_+3A_sample_ei">sample_Ei</code></td>
<td>
<p>default TRUE; if conditional permutation, use the sample $E_i$ values, or the analytical values, leaving only variances calculated by simulation.</p>
</td></tr>
<tr><td><code id="localmoran_+3A_iseed">iseed</code></td>
<td>
<p>default NULL, used to set the seed for possible parallel RNGs</p>
</td></tr>
<tr><td><code id="localmoran_+3A_no_repeat_in_row">no_repeat_in_row</code></td>
<td>
<p>default <code>FALSE</code>, if <code>TRUE</code>, sample conditionally in each row without replacements to avoid duplicate values, <a href="https://github.com/r-spatial/spdep/issues/124">https://github.com/r-spatial/spdep/issues/124</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of local Moran's I are divided by the variance (or sample variance) of the variable of interest to accord with Table 1, p. 103, and formula (12), p. 99, in Anselin (1995), rather than his formula (7), p. 98. The variance of the local Moran statistic is taken from Sokal et al. (1998) p. 334, equations 4 &amp; 5 or equations 7 &amp; 8 located depending on user specification. By default, the implementation divides by n, not (n-1) in calculating the variance and higher moments. Conditional code contributed by Jeff Sauer and Levi Wolf.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Ii</code></td>
<td>
<p>local moran statistic</p>
</td></tr>
<tr><td><code>E.Ii</code></td>
<td>
<p>expectation of local moran statistic; for <code>localmoran_perm</code>the permutation sample means</p>
</td></tr>
<tr><td><code>Var.Ii</code></td>
<td>
<p>variance of local moran statistic; for <code>localmoran_perm</code>the permutation sample standard deviations</p>
</td></tr>
<tr><td><code>Z.Ii</code></td>
<td>
<p>standard deviate of local moran statistic; for <code>localmoran_perm</code> based on permutation sample means and standard deviations</p>
</td></tr>
<tr><td><code>Pr()</code></td>
<td>
<p>p-value of local moran statistic using <code>pnorm()</code>; for <code>localmoran_perm</code> using standard deviatse based on permutation sample means and standard deviations</p>
</td></tr>
<tr><td><code>Pr() Sim</code></td>
<td>
<p>For <code>localmoran_perm</code>, <code>rank()</code> and <code>punif()</code> of observed statistic rank for [0, 1] p-values using <code>alternative=</code></p>
</td></tr>
<tr><td><code>Pr(folded) Sim</code></td>
<td>
<p>the simulation folded [0, 0.5] range ranked p-value (based on <a href="https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213">https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213</a>)</p>
</td></tr>
<tr><td><code>Skewness</code></td>
<td>
<p>For <code>localmoran_perm</code>, the output of <code>e1071::skewness()</code> for the permutation samples underlying the standard deviates</p>
</td></tr>
<tr><td><code>Kurtosis</code></td>
<td>
<p>For <code>localmoran_perm</code>, the output of <code>e1071::kurtosis()</code> for the permutation samples underlying the standard deviates</p>
</td></tr>
</table>
<p>In addition, an attribute data frame <code>"quadr"</code> with mean and median quadrant columns, and a column splitting on the demeaned variable and lagged demeaned variable at zero.
</p>


<h3>Note</h3>

<p>Conditional permutations added for comparative purposes; permutations are over the whole data vector omitting the observation itself. For p-value adjustment, use <code>p.adjust()</code> or <code>p.adjustSP()</code> on the output vector.</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Anselin, L. 1995. Local indicators of spatial association,
Geographical Analysis, 27, 93&ndash;115;
Getis, A. and Ord, J. K. 1996 Local spatial
statistics: an overview. In P. Longley and M. Batty (eds) <em>Spatial
analysis: modelling in a GIS environment</em> (Cambridge: Geoinformation
International), 261&ndash;277; Sokal, R. R, Oden, N. L. and Thomson, B. A. 1998. Local Spatial Autocorrelation in a Biological Model. Geographical Analysis, 30. 331&ndash;354; 
Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a>; 
Sauer, J., Oshan, T. M., Rey, S., &amp; Wolf, L. J. 2021. The Importance of Null Hypotheses: Understanding Differences in Local Moran’s under Heteroskedasticity. Geographical Analysis. <a href="https://doi.org/10.1111/gean.12304">doi:10.1111/gean.12304</a>
</p>
<p>Bivand, R. (2022), R Packages for Analyzing Spatial Data: A Comparative Case Study with Areal Data. Geographical Analysis, 54(3), 488-518. <a href="https://doi.org/10.1111/gean.12319">doi:10.1111/gean.12319</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+localG">localG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(afcon, package="spData")
oid &lt;- order(afcon$id)
resI &lt;- localmoran(afcon$totcon, nb2listw(paper.nb))
printCoefmat(data.frame(resI[oid,], row.names=afcon$name[oid]),
 check.names=FALSE)
hist(resI[,5])
mean(resI[,1])
sum(resI[,1])/Szero(nb2listw(paper.nb))
moran.test(afcon$totcon, nb2listw(paper.nb))
# note equality for mean() only when the sum of weights equals
# the number of observations (thanks to Juergen Symanzik)
resI &lt;- localmoran(afcon$totcon, nb2listw(paper.nb))
printCoefmat(data.frame(resI[oid,], row.names=afcon$name[oid]),
 check.names=FALSE)
hist(p.adjust(resI[,5], method="bonferroni"))
totcon &lt;-afcon$totcon
is.na(totcon) &lt;- sample(1:length(totcon), 5)
totcon
resI.na &lt;- localmoran(totcon, nb2listw(paper.nb), na.action=na.exclude,
 zero.policy=TRUE)
if (class(attr(resI.na, "na.action")) == "exclude") {
 print(data.frame(resI.na[oid,], row.names=afcon$name[oid]), digits=2)
} else print(resI.na, digits=2)
resG &lt;- localG(afcon$totcon, nb2listw(include.self(paper.nb)))
print(data.frame(resG[oid], row.names=afcon$name[oid]), digits=2)
set.seed(1)
resI_p &lt;- localmoran_perm(afcon$totcon, nb2listw(paper.nb))
printCoefmat(data.frame(resI_p[oid,], row.names=afcon$name[oid]),
 check.names=FALSE)
</code></pre>

<hr>
<h2 id='localmoran_bv'>Compute the Local Bivariate Moran's I Statistic</h2><span id='topic+localmoran_bv'></span>

<h3>Description</h3>

<p>Given two continuous numeric variables, calculate the bivariate Local Moran's I.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localmoran_bv(x, y, listw, nsim = 199, scale = TRUE, alternative="two.sided",
 iseed=1L, no_repeat_in_row=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localmoran_bv_+3A_x">x</code></td>
<td>
<p>a numeric vector of same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="localmoran_bv_+3A_y">y</code></td>
<td>
<p>a numeric vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="localmoran_bv_+3A_listw">listw</code></td>
<td>
<p>a listw object for example as created by <code>nb2listw()</code>.</p>
</td></tr>
<tr><td><code id="localmoran_bv_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to run.</p>
</td></tr>
<tr><td><code id="localmoran_bv_+3A_scale">scale</code></td>
<td>
<p>default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="localmoran_bv_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;two.sided&quot;, or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="localmoran_bv_+3A_iseed">iseed</code></td>
<td>
<p>default NULL, used to set the seed for possible parallel RNGs.</p>
</td></tr>
<tr><td><code id="localmoran_bv_+3A_no_repeat_in_row">no_repeat_in_row</code></td>
<td>
<p>default <code>FALSE</code>, if <code>TRUE</code>, sample conditionally in each row without replacements to avoid duplicate values, <a href="https://github.com/r-spatial/spdep/issues/124">https://github.com/r-spatial/spdep/issues/124</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bivariate Local Moran, like its global counterpart, evaluates the value
of x at observation i with its spatial neighbors' value of y. The value of <code class="reqn">I_i^B</code> is xi * Wyi. Or, in simpler words, the local bivariate Moran is the result of multiplying x by the spatial lag of y. Formally it is defined as
</p>
<p><code class="reqn">
I_i^B= cx_i\Sigma_j{w_{ij}y_j}
</code>
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing two columns <code>Ib</code> and <code>p_sim</code> containing the local bivariate Moran's I and simulated p-values respectively.
</p>


<h3>Author(s)</h3>

<p>Josiah Parry <a href="mailto:josiah.parry@gmail.com">josiah.parry@gmail.com</a></p>


<h3>References</h3>

<p>Anselin, Luc, Ibnu Syabri, and Oleg Smirnov. 2002. “Visualizing Multivariate Spatial Correlation with Dynamically Linked Windows.” In New Tools for Spatial Data Analysis: Proceedings of the Specialist Meeting, edited by Luc Anselin and Sergio Rey. University of California, Santa Barbara: Center for Spatially Integrated Social Science (CSISS).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load columbus data
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData"))
nb &lt;- poly2nb(columbus)
listw &lt;- nb2listw(nb)
set.seed(1)
(res &lt;- localmoran_bv(columbus$CRIME, columbus$INC, listw, nsim = 499))
</code></pre>

<hr>
<h2 id='localmoran.exact'>Exact local Moran's Ii tests</h2><span id='topic+localmoran.exact'></span><span id='topic+localmoran.exact.alt'></span><span id='topic+print.localmoranex'></span><span id='topic+as.data.frame.localmoranex'></span>

<h3>Description</h3>

<p><code>localmoran.exact</code> provides exact local Moran's Ii tests under the null hypothesis, while <code>localmoran.exact.alt</code> provides exact local Moran's Ii tests under the alternative hypothesis. In this case, the model may be a fitted model derived from a model fitted by <code>spatialreg::errorsarlm</code>, with the covariance matrix can be passed through the <code>Omega=</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localmoran.exact(model, select, nb, glist = NULL, style = "W", 
 zero.policy = NULL, alternative = "two.sided", spChk = NULL, 
 resfun = weighted.residuals, save.Vi = FALSE, useTP=FALSE, truncErr=1e-6, 
 zeroTreat=0.1)
localmoran.exact.alt(model, select, nb, glist = NULL, style = "W",
 zero.policy = NULL, alternative = "two.sided", spChk = NULL,
 resfun = weighted.residuals, Omega = NULL, save.Vi = FALSE,
 save.M = FALSE, useTP=FALSE, truncErr=1e-6, zeroTreat=0.1)
## S3 method for class 'localmoranex'
print(x, ...)
## S3 method for class 'localmoranex'
as.data.frame(x, row.names=NULL, optional=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localmoran.exact_+3A_model">model</code></td>
<td>
<p>an object of class <code>lm</code> returned by <code>lm</code> (assuming no global spatial autocorrelation), or an object of class <code>sarlm</code> returned by a spatial simultaneous autoregressive model fit (assuming global spatial autocorrelation represented by the model spatial coefficient); weights may be specified in the <code>lm</code> fit, but offsets should not be used</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_select">select</code></td>
<td>
<p>an integer vector of the id. numbers of zones to be tested; if missing, all zones</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_nb">nb</code></td>
<td>
<p>a list of neighbours of class <code>nb</code></p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_glist">glist</code></td>
<td>
<p>a list of general weights corresponding to neighbours</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_style">style</code></td>
<td>
<p>can take values W, B, C, and S</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without
neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_resfun">resfun</code></td>
<td>
<p>default: weighted.residuals; the function to be used to extract residuals from the <code>lm</code> object, may be <code>residuals</code>, <code>weighted.residuals</code>, <code>rstandard</code>, or <code>rstudent</code></p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_omega">Omega</code></td>
<td>
<p>A SAR process matrix may be passed in to test an alternative hypothesis, for example <code>Omega &lt;- invIrW(listw, rho=0.1); Omega &lt;- tcrossprod(Omega)</code>, <code>chol()</code> is taken internally</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_save.vi">save.Vi</code></td>
<td>
<p>if TRUE, return the star-shaped weights lists for each zone 
tested</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_save.m">save.M</code></td>
<td>
<p>if TRUE, save a list of left and right M products</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_usetp">useTP</code></td>
<td>
<p>default FALSE, if TRUE, use truncation point in integration rather than upper=Inf, see Tiefelsdorf (2000), eq. 6.7, p.69</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_truncerr">truncErr</code></td>
<td>
<p>when useTP=TRUE, pass truncation error to truncation point function</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_zerotreat">zeroTreat</code></td>
<td>
<p>when useTP=TRUE, pass zero adjustment to truncation point function</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_x">x</code></td>
<td>
<p>object to be printed</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_row.names">row.names</code></td>
<td>
<p>ignored argument to <code>as.data.frame.localmoranex</code>;
row names assigned from localmoranex object</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_optional">optional</code></td>
<td>
<p>ignored argument to <code>as.data.frame.localmoranex</code>;
row names assigned from localmoranex object</p>
</td></tr>
<tr><td><code id="localmoran.exact_+3A_...">...</code></td>
<td>
<p>arguments to be passed through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>localmoranex</code> containing &quot;select&quot; lists, each with
class <code>moranex</code> with the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the exact standard deviate of global Moran's I.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed local Moran's Ii.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>eigenvalues (two extreme values for null, vector for alternative)</p>
</td></tr>
<tr><td><code>oType</code></td>
<td>
<p>usually set to &quot;E&quot;, but set to &quot;N&quot; if the integration leads to an out of domain value for <code>qnorm</code>, when the Normal assumption is substituted. This only occurs when the output p-value would be very close to zero</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code>i</code></td>
<td>
<p>zone tested</p>
</td></tr>
<tr><td><code>Vi</code></td>
<td>
<p>zone tested</p>
</td></tr>
</table>
<p>When the alternative is being tested, a list of left and right M products in attribute M.
</p>


<h3>Author(s)</h3>

<p>Markus Reder and Roger Bivand</p>


<h3>References</h3>

<p>Bivand RS, Müller W, Reder M (2009) Power calculations for global and local Moran’s I. Comput Stat Data Anal 53:2859–2872; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lm.morantest.exact">lm.morantest.exact</a></code>, <code><a href="#topic+localmoran.sad">localmoran.sad</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>eire &lt;- st_read(system.file("shapes/eire.shp", package="spData")[1])
row.names(eire) &lt;- as.character(eire$names)
st_crs(eire) &lt;- "+proj=utm +zone=30 +ellps=airy +units=km"
eire.nb &lt;- poly2nb(eire)
e.lm &lt;- lm(OWNCONS ~ ROADACC, data=eire)
localmoran.sad(e.lm, nb=eire.nb)
localmoran.exact(e.lm, nb=eire.nb)
localmoran.exact(e.lm, nb=eire.nb, useTP=TRUE)
run &lt;- FALSE
if (requireNamespace("spatialreg", quietly=TRUE)) run &lt;- TRUE
if (run) {
e.errorsar &lt;- spatialreg::errorsarlm(OWNCONS ~ ROADACC, data=eire,
 listw=nb2listw(eire.nb))
lm.target &lt;- lm(e.errorsar$tary ~ e.errorsar$tarX - 1)
localmoran.exact.alt(lm.target, nb=eire.nb)
}
if (run) {
Omega &lt;- spatialreg::invIrW(nb2listw(eire.nb), rho=e.errorsar$lambda)
Omega1 &lt;- tcrossprod(Omega)
localmoran.exact.alt(lm.target, nb=eire.nb, Omega=Omega1)
}
if (run) {
localmoran.exact.alt(lm.target, nb=eire.nb, Omega=Omega1, useTP=TRUE)
}
</code></pre>

<hr>
<h2 id='localmoran.sad'>Saddlepoint approximation of local Moran's Ii tests</h2><span id='topic+localmoran.sad'></span><span id='topic+listw2star'></span><span id='topic+print.summary.localmoransad'></span><span id='topic+summary.localmoransad'></span><span id='topic+print.localmoransad'></span><span id='topic+as.data.frame.localmoransad'></span>

<h3>Description</h3>

<p>The function implements Tiefelsdorf's application of the Saddlepoint
approximation to local Moran's Ii's reference distribution. If the model
object is of class &quot;lm&quot;, global independence is assumed; if of class
&quot;sarlm&quot;, global dependence is assumed to be represented by the spatial
parameter of that model. Tests are reported separately for each zone
selected, and may be summarised using <code>summary.localmoransad</code>.
Values of local Moran's Ii agree with those from <code>localmoran()</code>,
but in that function, the standard deviate - here the Saddlepoint
approximation - is based on the randomisation assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localmoran.sad(model, select, nb, glist=NULL, style="W",
 zero.policy=NULL, alternative="two.sided", spChk=NULL,
 resfun=weighted.residuals, save.Vi=FALSE,
 tol = .Machine$double.eps^0.5, maxiter = 1000, tol.bounds=0.0001,
 save.M=FALSE, Omega = NULL)
## S3 method for class 'localmoransad'
print(x, ...)
## S3 method for class 'localmoransad'
summary(object, ...)
## S3 method for class 'summary.localmoransad'
print(x, ...)
listw2star(listw, ireg, style, n, D, a, zero.policy=attr(listw, "zero.policy"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localmoran.sad_+3A_model">model</code></td>
<td>
<p>an object of class <code>lm</code> returned by <code>lm</code> (assuming no global spatial autocorrelation), or an object of class <code>sarlm</code> returned by a spatial simultaneous autoregressive model fit (assuming global spatial autocorrelation represented by the model spatial coefficient); weights may be specified in the <code>lm</code> fit, but offsets should not be used</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_select">select</code></td>
<td>
<p>an integer vector of the id. numbers of zones to be tested; if missing, all zones</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_nb">nb</code></td>
<td>
<p>a list of neighbours of class <code>nb</code></p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_glist">glist</code></td>
<td>
<p>a list of general weights corresponding to neighbours</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_style">style</code></td>
<td>
<p>can take values W, B, C, and S</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without
neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_resfun">resfun</code></td>
<td>
<p>default: weighted.residuals; the function to be used to extract residuals from the <code>lm</code> object, may be <code>residuals</code>, <code>weighted.residuals</code>, <code>rstandard</code>, or <code>rstudent</code></p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_save.vi">save.Vi</code></td>
<td>
<p>if TRUE, return the star-shaped weights lists for each zone 
tested</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance) for <code>uniroot</code></p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations for <code>uniroot</code></p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_tol.bounds">tol.bounds</code></td>
<td>
<p>offset from bounds for <code>uniroot</code></p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_save.m">save.M</code></td>
<td>
<p>if TRUE, save a list of left and right M products in a list for the conditional tests, or a list of the regression model matrix components</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_omega">Omega</code></td>
<td>
<p>A SAR process matrix may be passed in to test an alternative hypothesis, for example <code>Omega &lt;- invIrW(listw, rho=0.1); Omega &lt;- tcrossprod(Omega)</code>, <code>chol()</code> is taken internally</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_x">x</code></td>
<td>
<p>object to be printed</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_object">object</code></td>
<td>
<p>object to be summarised</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_...">...</code></td>
<td>
<p>arguments to be passed through</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_ireg">ireg</code></td>
<td>
<p>a zone number</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_n">n</code></td>
<td>
<p>internal value depending on listw and style</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_d">D</code></td>
<td>
<p>internal value depending on listw and style</p>
</td></tr>
<tr><td><code id="localmoran.sad_+3A_a">a</code></td>
<td>
<p>internal value depending on listw and style</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the analytical eigenvalue calculation together with
trace shortcuts given or suggested in Tiefelsdorf (2002), partly
following remarks by J. Keith Ord, and uses the
Saddlepoint analytical solution from Tiefelsdorf's SPSS code. 
</p>
<p>If a histogram of the probability values of the saddlepoint estimate
for the assumption of global independence is not approximately flat,
the assumption is probably unjustified, and re-estimation with global
dependence is recommended.
</p>
<p>No n by n matrices are needed at any point for the test assuming no global
dependence, the star-shaped weights matrices being handled as listw
lists. When the test is made on residuals from a spatial regression,
taking a global process into account. n by n matrices are necessary,
and memory constraints may be reached for large lattices.
</p>


<h3>Value</h3>

<p>A list with class <code>localmoransad</code> containing &quot;select&quot; lists, each with
class <code>moransad</code> with the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the saddlepoint approximation of the
standard deviate of local Moran's Ii.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed local Moran's Ii.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>internal1</code></td>
<td>
<p>Saddlepoint omega, r and u</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>maximum and minimum analytical eigenvalues</p>
</td></tr>
<tr><td><code>i</code></td>
<td>
<p>zone tested</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Tiefelsdorf, M. 2002 The Saddlepoint approximation of Moran's I 
and local Moran's Ii reference distributions and their numerical evaluation. 
Geographical Analysis, 34, pp. 187&ndash;206.</p>


<h3>See Also</h3>

<p><code><a href="#topic+localmoran">localmoran</a></code>, <code><a href="#topic+lm.morantest">lm.morantest</a></code>,
<code><a href="#topic+lm.morantest.sad">lm.morantest.sad</a></code>, <code><a href="#topic+errorsarlm">errorsarlm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>eire &lt;- st_read(system.file("shapes/eire.shp", package="spData")[1])
row.names(eire) &lt;- as.character(eire$names)
st_crs(eire) &lt;- "+proj=utm +zone=30 +ellps=airy +units=km"
eire.nb &lt;- poly2nb(eire)
lw &lt;- nb2listw(eire.nb)
e.lm &lt;- lm(OWNCONS ~ ROADACC, data=eire)
e.locmor &lt;- summary(localmoran.sad(e.lm, nb=eire.nb))
e.locmor
mean(e.locmor[,1])
sum(e.locmor[,1])/Szero(lw)
lm.morantest(e.lm, lw)
# note equality for mean() only when the sum of weights equals
# the number of observations (thanks to Juergen Symanzik)
hist(e.locmor[,"Pr. (Sad)"])
e.wlm &lt;- lm(OWNCONS ~ ROADACC, data=eire, weights=RETSALE)
e.locmorw1 &lt;- summary(localmoran.sad(e.wlm, nb=eire.nb, resfun=weighted.residuals))
e.locmorw1
e.locmorw2 &lt;- summary(localmoran.sad(e.wlm, nb=eire.nb, resfun=rstudent))
e.locmorw2
run &lt;- FALSE
if (requireNamespace("spatialreg", quietly=TRUE)) run &lt;- TRUE
if (run) {
e.errorsar &lt;- spatialreg::errorsarlm(OWNCONS ~ ROADACC, data=eire,
  listw=lw)
if (packageVersion("spatialreg") &lt; "1.1.7")
  spatialreg::print.sarlm(e.errorsar)
else
  print(e.errorsar)
}
if (run) {
lm.target &lt;- lm(e.errorsar$tary ~ e.errorsar$tarX - 1)
Omega &lt;- tcrossprod(spatialreg::invIrW(lw, rho=e.errorsar$lambda))
e.clocmor &lt;- summary(localmoran.sad(lm.target, nb=eire.nb, Omega=Omega))
e.clocmor
}
if (run) {
hist(e.clocmor[,"Pr. (Sad)"])
}
</code></pre>

<hr>
<h2 id='LOSH'>Local spatial heteroscedasticity</h2><span id='topic+LOSH'></span>

<h3>Description</h3>

<p>Local spatial heteroscedasticity is calculated for each location based on the spatial weights object used. The statistic is:
</p>
<p style="text-align: center;"><code class="reqn">H_i = \frac{\sum_j^n w_{ij} \cdot |e_j|^a}{h_1 \cdot \sum_j^n w_{ij}}</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn">e_j = x_j - \bar{x}_j</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">\bar{x}_j = \frac{\sum_k^n w_{jk} \cdot x_k}{\sum_k^n w_{jk}}</code>
</p>

<p>Its expectation and variance are given in Ord &amp; Getis (2012). The exponent <em>a</em> allows for investigating different types of mean dispersal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LOSH(x, listw, a=2, var_hi=TRUE, zero.policy=attr(listw, "zero.policy"),
 na.action=na.fail, spChk=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOSH_+3A_x">x</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="LOSH_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="LOSH_+3A_a">a</code></td>
<td>
<p>the exponent applied to the local residuals; the default value of 2 leads to a measure of heterogeneity in the spatial variance</p>
</td></tr>
<tr><td><code id="LOSH_+3A_var_hi">var_hi</code></td>
<td>
<p>default TRUE, the moments and the test statistics are calculated for each location; if FALSE, only the plain LOSH measures, <code class="reqn">\bar{x}_i</code> and <code class="reqn">e_i</code> are calculated</p>
</td></tr>
<tr><td><code id="LOSH_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="LOSH_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. If <code>na.pass</code> is used, zero is substituted for NA values in calculating the spatial lag. (Note that na.exclude will only work properly starting from R 1.9.0, na.omit and na.exclude assign the wrong classes in 1.8.*)</p>
</td></tr>
<tr><td><code id="LOSH_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the LOSH measure, the values returned include local spatially weighted mean values <code class="reqn">\bar{x}_i</code> and local residuals <code class="reqn">e_i</code> estimated about these means. These values facilitate the interpretation of LOSH values. Further, if specified through <code>var_hi</code>, the statistical moments and the test statistics as proposed by Ord &amp; Getis (2012) are also calculated and returned.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Hi</code></td>
<td>
<p>LOSH statistic</p>
</td></tr>
<tr><td><code>E.Hi</code></td>
<td>
<p>(optional) expectation of LOSH</p>
</td></tr>
<tr><td><code>Var.Hi</code></td>
<td>
<p>(optional) variance of LOSH</p>
</td></tr>
<tr><td><code>Z.Hi</code></td>
<td>
<p>(optional) the approximately Chi-square distributed test statistics</p>
</td></tr>
<tr><td><code>x_bar_i</code></td>
<td>
<p>local spatially weighted mean values</p>
</td></tr>
<tr><td><code>ei</code></td>
<td>
<p>residuals about local spatially weighted mean values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>René Westerholt <a href="mailto:rene.westerholt@tu-dortmund.de">rene.westerholt@tu-dortmund.de</a></p>


<h3>References</h3>

<p>Ord, J. K., &amp; Getis, A. 2012. Local spatial heteroscedasticity (LOSH),
The Annals of Regional Science, 48 (2), 529&ndash;539.</p>


<h3>See Also</h3>

<p><code><a href="#topic+LOSH.cs">LOSH.cs</a></code>, <code><a href="#topic+LOSH.mc">LOSH.mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(boston, package="spData")
    resLOSH &lt;- LOSH(boston.c$NOX, nb2listw(boston.soi))
    hist(resLOSH[,"Hi"])
    mean(resLOSH[,"Hi"])
  </code></pre>

<hr>
<h2 id='LOSH.cs'>Chi-square based test for local spatial heteroscedasticity</h2><span id='topic+LOSH.cs'></span>

<h3>Description</h3>

<p>The function implements the chi-square based test statistic for local spatial heteroscedasticity (LOSH) as proposed by Ord &amp; Getis (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOSH.cs(x, listw, zero.policy = attr(listw, "zero.policy"), na.action = na.fail, 
                 p.adjust.method = "none", spChk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOSH.cs_+3A_x">x</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="LOSH.cs_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="LOSH.cs_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="LOSH.cs_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. If <code>na.pass</code> is used, zero is substituted for NA values in calculating the spatial lag. (Note that na.exclude will only work properly starting from R 1.9.0, na.omit and na.exclude assign the wrong classes in 1.8.*)</p>
</td></tr>
<tr><td><code id="LOSH.cs_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>a character string specifying the probability value adjustment for multiple tests, default &quot;none&quot;; see <code><a href="#topic+p.adjustSP">p.adjustSP</a></code>. Note that the number of multiple tests for each region is only taken as the number of neighbours + 1 for each region, rather than the total number of regions.</p>
</td></tr>
<tr><td><code id="LOSH.cs_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test uses <em>a = 2</em> (see <code><a href="#topic+LOSH">LOSH</a></code>) because chi-square based inference is not applicable with other exponents. The function makes use of <code><a href="#topic+LOSH">LOSH</a></code> in its calculations.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Hi</code></td>
<td>
<p>LOSH statistic</p>
</td></tr>
<tr><td><code>E.Hi</code></td>
<td>
<p>expectation of LOSH</p>
</td></tr>
<tr><td><code>Var.Hi</code></td>
<td>
<p>variance of LOSH</p>
</td></tr>
<tr><td><code>Z.Hi</code></td>
<td>
<p>the approximately chi-square distributed test statistics</p>
</td></tr>
<tr><td><code>x_bar_i</code></td>
<td>
<p>local spatially weighted mean values</p>
</td></tr>
<tr><td><code>ei</code></td>
<td>
<p>residuals about local spatially weighted mean values</p>
</td></tr>
<tr><td><code>Pr()</code></td>
<td>
<p>p-values for <code>Hi</code> obtained from a non-central Chi-square distribution with <code class="reqn">2/Var.Hi</code> degrees of freedom</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>René Westerholt <a href="mailto:rene.westerholt@tu-dortmund.de">rene.westerholt@tu-dortmund.de</a></p>


<h3>References</h3>

<p>Ord, J. K., &amp; Getis, A. 2012. Local spatial heteroscedasticity (LOSH), The Annals of Regional Science, 48 (2), 529&ndash;539.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LOSH">LOSH</a></code>, <code><a href="#topic+LOSH.mc">LOSH.mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(boston, package="spData")
    resLOSH &lt;- LOSH.cs(boston.c$NOX, nb2listw(boston.soi))
    hist(resLOSH[,"Hi"])
    mean(resLOSH[,"Hi"])
</code></pre>

<hr>
<h2 id='LOSH.mc'>Bootstrapping-based test for local spatial heteroscedasticity</h2><span id='topic+LOSH.mc'></span>

<h3>Description</h3>

<p>The function draws inferences about local spatial heteroscedasticity (LOSH) by means of the randomisation-based Monte-Carlo bootstrap proposed by Xu et al. (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOSH.mc(x, listw, a = 2, nsim = 99, zero.policy = attr(listw, "zero.policy"),
 na.action = na.fail, spChk = NULL, adjust.n = TRUE, p.adjust.method = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOSH.mc_+3A_x">x</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="LOSH.mc_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="LOSH.mc_+3A_a">a</code></td>
<td>
<p>the exponent applied to the local residuals; the default value of 2 leads to a measure of heterogeneity in the spatial variance</p>
</td></tr>
<tr><td><code id="LOSH.mc_+3A_nsim">nsim</code></td>
<td>
<p>the number of randomisations used in the bootstrap</p>
</td></tr>
<tr><td><code id="LOSH.mc_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="LOSH.mc_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. If <code>na.pass</code> is used, zero is substituted for NA values in calculating the spatial lag. (Note that na.exclude will only work properly starting from R 1.9.0, na.omit and na.exclude assign the wrong classes in 1.8.*)</p>
</td></tr>
<tr><td><code id="LOSH.mc_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="LOSH.mc_+3A_adjust.n">adjust.n</code></td>
<td>
<p> default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="LOSH.mc_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>a character string specifying the probability value adjustment for multiple tests, default &quot;none&quot;; see <code><a href="#topic+p.adjustSP">p.adjustSP</a></code>. Note that the number of multiple tests for each region is only taken as the number of neighbours + 1 for each region, rather than the total number of regions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test calculates LOSH (see <code><a href="#topic+LOSH">LOSH</a></code>) and estimates pseudo p-values from a conditional bootstrap. Thereby, the i-th value in each location is held fixed, whereas all other values are permuted <code>nsim</code> times over all other spatial units.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Hi</code></td>
<td>
<p>LOSH statistic</p>
</td></tr>
<tr><td><code>E.Hi</code></td>
<td>
<p>expectation of LOSH</p>
</td></tr>
<tr><td><code>Var.Hi</code></td>
<td>
<p>variance of LOSH</p>
</td></tr>
<tr><td><code>Z.Hi</code></td>
<td>
<p>the approximately chi-square distributed test statistics</p>
</td></tr>
<tr><td><code>x_bar_i</code></td>
<td>
<p>local spatially weighted mean values</p>
</td></tr>
<tr><td><code>ei</code></td>
<td>
<p>residuals about local spatially weighted mean values</p>
</td></tr>
<tr><td><code>Pr()</code></td>
<td>
<p>p-values for <code>Hi</code> obtained from a conditional bootstrap distribution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>René Westerholt <a href="mailto:rene.westerholt@tu-dortmund.de">rene.westerholt@tu-dortmund.de</a></p>


<h3>References</h3>

<p>Ord, J. K., &amp; Getis, A. 2012. Local spatial heteroscedasticity (LOSH), The Annals of Regional Science, 48 (2), 529&ndash;539; Xu, M., Mei, C. L., &amp; Yan, N. 2014. A note on the null distribution of the local spatial heteroscedasticity (LOSH) statistic. The Annals of Regional Science, 52 (3), 697&ndash;710.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LOSH">LOSH</a></code>, <code><a href="#topic+LOSH.mc">LOSH.mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(columbus, package="spData")
    resLOSH_mc &lt;- LOSH.mc(columbus$CRIME, nb2listw(col.gal.nb), 2, 100)
    summary(resLOSH_mc)
    resLOSH_cs &lt;- LOSH.cs(columbus$CRIME, nb2listw(col.gal.nb))
    summary(resLOSH_cs)
    plot(resLOSH_mc[,"Pr()"], resLOSH_cs[,"Pr()"])
</code></pre>

<hr>
<h2 id='mat2listw'>Convert a square spatial weights matrix to a weights list object</h2><span id='topic+mat2listw'></span>

<h3>Description</h3>

<p>The function converts a square spatial weights matrix, 
optionally a sparse matrix to a weights list 
object, optionally adding region IDs from the row names of the matrix, as a 
sequence of numbers 1:nrow(x), or as given as an argument. The style can be imposed by rebuilting the weights list object internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2listw(x, row.names = NULL, style=NULL, zero.policy = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2listw_+3A_x">x</code></td>
<td>
<p>A square non-negative matrix with no NAs representing spatial 
weights; may be a matrix of class &ldquo;sparseMatrix&rdquo;</p>
</td></tr>
<tr><td><code id="mat2listw_+3A_row.names">row.names</code></td>
<td>
<p>row names to use for region IDs</p>
</td></tr>
<tr><td><code id="mat2listw_+3A_style">style</code></td>
<td>
<p>default NULL, missing, set to &quot;M&quot; and warning given; if not &quot;M&quot;, passed to <code><a href="#topic+nb2listw">nb2listw</a></code> to re-build the object</p>
</td></tr>
<tr><td><code id="mat2listw_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>listw</code> object with the following members:
</p>
<table>
<tr><td><code>style</code></td>
<td>
<p>&quot;M&quot;, meaning matrix style, underlying style unknown, or assigned style argument in rebuilt object</p>
</td></tr>
<tr><td><code>neighbours</code></td>
<td>
<p>the derived neighbours list</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights for the neighbours derived from the matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2listw">nb2listw</a></code>, <code><a href="#topic+nb2mat">nb2mat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col005 &lt;- dnearneigh(st_coordinates(st_centroid(st_geometry(columbus),
 of_largest_polygon=TRUE)), 0, 0.5, as.character(columbus$NEIGNO))
summary(col005)
col005.w.mat &lt;- nb2mat(col005, style="W", zero.policy=TRUE)
try(col005.w.b &lt;- mat2listw(col005.w.mat, style="W"))
col005.w.b &lt;- mat2listw(col005.w.mat, style="W", zero.policy=TRUE)
summary(col005.w.b$neighbours)
diffnb(col005, col005.w.b$neighbours)
col005.w.mat.3T &lt;- kronecker(diag(3), col005.w.mat)
col005.w.b.3T &lt;- mat2listw(col005.w.mat.3T, style="W", zero.policy=TRUE)
summary(col005.w.b.3T$neighbours)
run &lt;- FALSE
if (require("spatialreg", quiet=TRUE)) run &lt;- TRUE
if (run) {
W &lt;- as(nb2listw(col005, style="W", zero.policy=TRUE), "CsparseMatrix")
try(col005.spM &lt;- mat2listw(W))
col005.spM &lt;- mat2listw(W, style="W", zero.policy=TRUE)
summary(col005.spM$neighbours)
}
if (run) {
diffnb(col005, col005.spM$neighbours)
}
if (run &amp;&amp; require("Matrix", quiet=TRUE)) {
IW &lt;- kronecker(Diagonal(3), W)
col005.spM.3T &lt;- mat2listw(as(IW, "CsparseMatrix"), style="W", zero.policy=TRUE)
summary(col005.spM.3T$neighbours)
}
</code></pre>

<hr>
<h2 id='moran'>Compute Moran's I</h2><span id='topic+moran'></span>

<h3>Description</h3>

<p>A simple function to compute Moran's I, called by <code>moran.test</code> and <code>moran.mc</code>;
</p>
<p style="text-align: center;"><code class="reqn">I = \frac{n}{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}}
\frac{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}(x_i-\bar{x})(x_j-\bar{x})}{\sum_{i=1}^{n}(x_i - \bar{x})^2}
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>moran(x, listw, n, S0, zero.policy=attr(listw, "zero.policy"), NAOK=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="moran_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="moran_+3A_n">n</code></td>
<td>
<p>number of zones</p>
</td></tr>
<tr><td><code id="moran_+3A_s0">S0</code></td>
<td>
<p>global sum of weights</p>
</td></tr>
<tr><td><code id="moran_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="moran_+3A_naok">NAOK</code></td>
<td>
<p>if 'TRUE' then any 'NA' or 'NaN' or 'Inf' values in x are passed on to the foreign function.  If 'FALSE', the presence of 'NA' or 'NaN' or 'Inf' values is regarded as an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of
</p>
<table>
<tr><td><code>I</code></td>
<td>
<p>Moran's I</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>sample kurtosis of x</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 17.</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran.test">moran.test</a></code>, <code><a href="#topic+moran.mc">moran.mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
col.W &lt;- nb2listw(COL.nb, style="W")
crime &lt;- COL.OLD$CRIME
str(moran(crime, col.W, length(COL.nb), Szero(col.W)))
is.na(crime) &lt;- sample(1:length(crime), 10)
str(moran(crime, col.W, length(COL.nb), Szero(col.W), NAOK=TRUE))
</code></pre>

<hr>
<h2 id='moran_bv'>Compute the Global Bivariate Moran's I</h2><span id='topic+moran_bv'></span>

<h3>Description</h3>

<p>Given two continuous numeric variables, calculate the bivariate Moran's I. See details for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran_bv(x, y, listw, nsim = 499, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran_bv_+3A_x">x</code></td>
<td>
<p>a numeric vector of same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="moran_bv_+3A_y">y</code></td>
<td>
<p>a numeric vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="moran_bv_+3A_listw">listw</code></td>
<td>
<p>a listw object for example as created by <code>nb2listw()</code>.</p>
</td></tr>
<tr><td><code id="moran_bv_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to run.</p>
</td></tr>
<tr><td><code id="moran_bv_+3A_scale">scale</code></td>
<td>
<p>default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Global Bivariate Moran is defined as
</p>
<p><code class="reqn">
I_B = \frac{\Sigma_i(\Sigma_j{w_{ij}y_j\times x_i})}{\Sigma_i{x_i^2}}
</code>
</p>
<p>It is important to note that this is a measure of autocorrelation of X
with the spatial lag of Y. As such, the resultant measure may overestimate the amount of
spatial autocorrelation which may be a product of the inherent correlation of X and Y. The output object is of class <code>"boot"</code>, so that plots and confidence intervals are available using appropriate methods.
</p>


<h3>Value</h3>

<p>An object of class <code>"boot"</code>, with the observed statistic in component <code>t0</code>.
</p>


<h3>Author(s)</h3>

<p>Josiah Parry <a href="mailto:josiah.parry@gmail.com">josiah.parry@gmail.com</a></p>


<h3>References</h3>

<p>Wartenberg, D. (1985), Multivariate Spatial Correlation: A Method for Exploratory Geographical Analysis. Geographical Analysis, 17: 263-283. <a href="https://doi.org/10.1111/j.1538-4632.1985.tb00849.x">doi:10.1111/j.1538-4632.1985.tb00849.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boston, package = "spData")
x &lt;- boston.c$CRIM
y &lt;- boston.c$NOX
listw &lt;- nb2listw(boston.soi)
set.seed(1)
res_xy &lt;- moran_bv(x, y, listw, nsim=499)
res_xy$t0
boot::boot.ci(res_xy, conf=c(0.99, 0.95, 0.9), type="basic")
plot(res_xy)
set.seed(1)
lee_xy &lt;- lee.mc(x, y, listw, nsim=499, return_boot=TRUE)
lee_xy$t0
boot::boot.ci(lee_xy, conf=c(0.99, 0.95, 0.9), type="basic")
plot(lee_xy)
set.seed(1)
res_yx &lt;- moran_bv(y, x, listw, nsim=499)
res_yx$t0
boot::boot.ci(res_yx, conf=c(0.99, 0.95, 0.9), type="basic")
plot(res_yx)
set.seed(1)
lee_yx &lt;- lee.mc(y, x, listw, nsim=499, return_boot=TRUE)
lee_yx$t0
boot::boot.ci(lee_yx, conf=c(0.99, 0.95, 0.9), type="basic")
plot(lee_yx)
</code></pre>

<hr>
<h2 id='moran.mc'>Permutation test for Moran's I statistic</h2><span id='topic+moran.mc'></span>

<h3>Description</h3>

<p>A permutation test for Moran's I statistic calculated by using nsim random permutations of x for the given spatial weighting scheme, to establish the rank of the observed statistic in relation to the nsim simulated values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran.mc(x, listw, nsim, zero.policy=attr(listw, "zero.policy"),
 alternative="greater", na.action=na.fail, spChk=NULL, return_boot=FALSE,
 adjust.n=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran.mc_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="moran.mc_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="moran.mc_+3A_nsim">nsim</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="moran.mc_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="moran.mc_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;two.sided&quot;, or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="moran.mc_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. <code>na.pass</code> is not permitted because it is meaningless in a permutation test.</p>
</td></tr>
<tr><td><code id="moran.mc_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="moran.mc_+3A_return_boot">return_boot</code></td>
<td>
<p>return an object of class <code>boot</code> from the equivalent permutation bootstrap rather than an object of class <code>htest</code></p>
</td></tr>
<tr><td><code id="moran.mc_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> and <code>mc.sim</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the observed Moran's I.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the rank of the observed Moran's I.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the pseudo p-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data, and the number of simulations.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>nsim simulated values of statistic, final value is observed statistic</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 63-5.</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran">moran</a></code>, <code><a href="#topic+moran.test">moran.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
colw &lt;- nb2listw(COL.nb, style="W")
nsim &lt;- 99
set.seed(1234)
sim1 &lt;- moran.mc(COL.OLD$CRIME, listw=colw, nsim=nsim)
sim1
mean(sim1$res[1:nsim])
var(sim1$res[1:nsim])
summary(sim1$res[1:nsim])
colold.lags &lt;- nblag(COL.nb, 3)
set.seed(1234)
sim2 &lt;- moran.mc(COL.OLD$CRIME, nb2listw(colold.lags[[2]],
 style="W"), nsim=nsim)
summary(sim2$res[1:nsim])
sim3 &lt;- moran.mc(COL.OLD$CRIME, nb2listw(colold.lags[[3]],
 style="W"), nsim=nsim)
summary(sim3$res[1:nsim])
crime &lt;- COL.OLD$CRIME
is.na(crime) &lt;- sample(1:length(crime), 10)
try(moran.mc(crime, nb2listw(COL.nb, style="W"), nsim=99,
 na.action=na.fail))
moran.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, zero.policy=TRUE,
 na.action=na.omit)
moran.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, zero.policy=TRUE,
 return_boot=TRUE, na.action=na.omit)
moran.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, zero.policy=TRUE,
 na.action=na.exclude)
moran.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, zero.policy=TRUE,
 return_boot=TRUE, na.action=na.exclude)
try(moran.mc(crime, nb2listw(COL.nb, style="W"), nsim=99, na.action=na.pass))
</code></pre>

<hr>
<h2 id='moran.plot'>Moran scatterplot</h2><span id='topic+moran.plot'></span>

<h3>Description</h3>

<p>A plot of spatial data against its spatially lagged values, augmented by
reporting the summary of influence measures for the linear relationship
between the data and the lag. If zero policy is TRUE, such observations
are also marked if they occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran.plot(x, listw, zero.policy=attr(listw, "zero.policy"), spChk=NULL, labels=NULL,
 xlab=NULL, ylab=NULL, quiet=NULL, plot=TRUE, return_df=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran.plot_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="moran.plot_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="moran.plot_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="moran.plot_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="moran.plot_+3A_labels">labels</code></td>
<td>
<p>character labels for points with high influence measures, if set to FALSE, no labels are plotted for points with large influence</p>
</td></tr>
<tr><td><code id="moran.plot_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis</p>
</td></tr>
<tr><td><code id="moran.plot_+3A_ylab">ylab</code></td>
<td>
<p>label for x axis</p>
</td></tr>
<tr><td><code id="moran.plot_+3A_quiet">quiet</code></td>
<td>
<p>default NULL, use !verbose global option value; if TRUE, output of summary of influence object suppressed</p>
</td></tr>
<tr><td><code id="moran.plot_+3A_plot">plot</code></td>
<td>
<p>default TRUE, if false, plotting is suppressed</p>
</td></tr>
<tr><td><code id="moran.plot_+3A_return_df">return_df</code></td>
<td>
<p>default TRUE, invisibly return a data.frame object; if FALSE invisibly return an influence measures object</p>
</td></tr>
<tr><td><code id="moran.plot_+3A_...">...</code></td>
<td>
<p>further graphical parameters as in <code>par(..)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data.frame object with coordinates and influence measures if <code>return_df</code> is TRUE, or an influence object from <code>influence.measures</code>.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Anselin, L. 1996. The Moran scatterplot as an ESDA tool to
assess local instability in spatial association. pp. 111&ndash;125 in
M. M. Fischer, H. J. Scholten and D. Unwin (eds) Spatial analytical
perspectives on GIS, London, Taylor and Francis; Anselin, L. 1995.
Local indicators of spatial association,
Geographical Analysis, 27, 93&ndash;115</p>


<h3>See Also</h3>

<p><code><a href="#topic+localmoran">localmoran</a></code>, <code><a href="stats.html#topic+influence.measures">influence.measures</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(afcon, package="spData")
mp &lt;- moran.plot(afcon$totcon, nb2listw(paper.nb),
 labels=as.character(afcon$name), pch=19)
moran.plot(as.vector(scale(afcon$totcon)), nb2listw(paper.nb),
 labels=as.character(afcon$name), xlim=c(-2, 4), ylim=c(-2,4), pch=19)
if (require(ggplot2, quietly=TRUE)) {
  xname &lt;- attr(mp, "xname")
  ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) + 
    geom_smooth(formula=y ~ x, method="lm") + 
    geom_hline(yintercept=mean(mp$wx), lty=2) + 
    geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() + 
    geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +
    geom_text(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, vjust=1.5)) +
    xlab(xname) + ylab(paste0("Spatially lagged ", xname))
}
</code></pre>

<hr>
<h2 id='moran.test'>Moran's I test for spatial autocorrelation</h2><span id='topic+moran.test'></span>

<h3>Description</h3>

<p>Moran's test for spatial autocorrelation using a spatial weights matrix in weights list form. The assumptions underlying the test are sensitive to the form of the graph of neighbour relationships and other factors, and results may be checked against those of <code>moran.mc</code> permutations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran.test(x, listw, randomisation=TRUE, zero.policy=attr(listw, "zero.policy"),
 alternative="greater", rank = FALSE, na.action=na.fail, spChk=NULL,
 adjust.n=TRUE, drop.EI2=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran.test_+3A_x">x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="moran.test_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="moran.test_+3A_randomisation">randomisation</code></td>
<td>
<p>variance of I calculated under the assumption of randomisation, if FALSE normality</p>
</td></tr>
<tr><td><code id="moran.test_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="moran.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code id="moran.test_+3A_rank">rank</code></td>
<td>
<p>logical value - default FALSE for continuous variables, if TRUE, uses the adaptation of Moran's I for ranks suggested by Cliff and Ord (1981, p. 46)</p>
</td></tr>
<tr><td><code id="moran.test_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. If <code>na.pass</code> is used, zero is substituted for NA values in calculating the spatial lag</p>
</td></tr>
<tr><td><code id="moran.test_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="moran.test_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="moran.test_+3A_drop.ei2">drop.EI2</code></td>
<td>
<p>default FALSE, if TRUE, emulate CrimeStat &lt;= 4.02</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the standard deviate of Moran's I.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed Moran's I, its expectation and variance under the method assumption.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the assumption used for calculating the standard deviate.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Var(I) is taken from Cliff and Ord (1969, p. 28), and 
Goodchild's CATMOG 47 (1986),
see also Upton &amp; Fingleton (1985) p. 171; it agrees with SpaceStat,
see Tutorial workbook Chapter 22; VI is the second crude moment minus the
square of the first crude moment. The derivation of the test (Cliff and Ord, 1981, p. 18) assumes that the weights matrix is symmetric. For inherently non-symmetric matrices, such as k-nearest neighbour matrices, <code>listw2U()</code> can be used to make the matrix symmetric.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 21; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+moran">moran</a></code>, <code><a href="#topic+moran.mc">moran.mc</a></code>, <code><a href="#topic+listw2U">listw2U</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
coords.OLD &lt;- cbind(COL.OLD$X, COL.OLD$Y)
moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"))
moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="B"))
moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="C"))
moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="S"))
moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style="W"),
 randomisation=FALSE)
colold.lags &lt;- nblag(COL.nb, 3)
moran.test(COL.OLD$CRIME, nb2listw(colold.lags[[2]],
 style="W"))
moran.test(COL.OLD$CRIME, nb2listw(colold.lags[[3]],
 style="W"))
print(is.symmetric.nb(COL.nb))
COL.k4.nb &lt;- knn2nb(knearneigh(coords.OLD, 4))
print(is.symmetric.nb(COL.k4.nb))
moran.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style="W"))
moran.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style="W"),
 randomisation=FALSE)
cat("Note: non-symmetric weights matrix, use listw2U()")
moran.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,
 style="W")))
moran.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,
 style="W")), randomisation=FALSE)
ranks &lt;- rank(COL.OLD$CRIME)
names(ranks) &lt;- rownames(COL.OLD)
moran.test(ranks, nb2listw(COL.nb, style="W"), rank=TRUE)
crime &lt;- COL.OLD$CRIME
is.na(crime) &lt;- sample(1:length(crime), 10)
res &lt;- try(moran.test(crime, nb2listw(COL.nb, style="W"),
 na.action=na.fail))
res
moran.test(crime, nb2listw(COL.nb, style="W"), zero.policy=TRUE,
 na.action=na.omit)
moran.test(crime, nb2listw(COL.nb, style="W"), zero.policy=TRUE,
 na.action=na.exclude)
moran.test(crime, nb2listw(COL.nb, style="W"), na.action=na.pass)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col_geoms &lt;- st_geometry(columbus)
col_geoms[1] &lt;- st_buffer(col_geoms[1], dist=-0.05)
st_geometry(columbus) &lt;- col_geoms
(nb1 &lt;- poly2nb(columbus))
try(lw &lt;- nb2listw(nb1, style="W"))
(lw &lt;- nb2listw(nb1, style="W", zero.policy=TRUE))
moran.test(COL.OLD$CRIME, lw)
</code></pre>

<hr>
<h2 id='mstree'>Find the minimal spanning tree</h2><span id='topic+mstree'></span>

<h3>Description</h3>

<p>The minimal spanning tree is a connected graph with n nodes and n-1
edges. This is a smaller class of possible partitions of a graph by
pruning edges with high dissimilarity. If one edge is removed, the
graph is partioned in two unconnected subgraphs. This function
implements the algorithm due to Prim (1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstree(nbw, ini = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstree_+3A_nbw">nbw</code></td>
<td>
<p>An object of <code>listw</code> class returned by
<code><a href="#topic+nb2listw">nb2listw</a></code> function. See this help for details.</p>
</td></tr>
<tr><td><code id="mstree_+3A_ini">ini</code></td>
<td>
<p>The initial node in the minimal spanning tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum spanning tree algorithm.
</p>
<p>Input a connected graph.
</p>
<p>Begin a empty set of nodes.
</p>
<p>Add an arbitrary note in this set.
</p>
<p>While are nodes not in the set, find a minimum cost edge connecting a
node in the set and a node out of the set and add this node in the
set.
</p>
<p>The set of edges is a minimum spanning tree.  
</p>


<h3>Value</h3>

<p>A matrix with n-1 rows and tree columns. Each row is two nodes and the
cost, i. e. the edge and it cost.
</p>


<h3>Author(s)</h3>

<p>Renato M. Assuncao and Elias T. Krainski</p>


<h3>References</h3>

<p>R. C. Prim (1957) Shortest connection networks and some
generalisations. In: Bell System Technical Journal, 36, pp. 1389-1401 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### loading data
bh &lt;- st_read(system.file("etc/shapes/bhicv.shp",
      package="spdep")[1], quiet=TRUE)
st_crs(bh) &lt;- "OGC:CRS84"
### data padronized
dpad &lt;- data.frame(scale(as.data.frame(bh)[,5:8]))

### neighboorhod list 
bh.nb &lt;- poly2nb(bh)

### calculing costs
lcosts &lt;- nbcosts(bh.nb, dpad)

### making listw
nb.w &lt;- nb2listw(bh.nb, lcosts, style="B")

### find a minimum spanning tree
system.time(mst.bh &lt;- mstree(nb.w,5))
dim(mst.bh)
head(mst.bh)
tail(mst.bh)
### the mstree plot
par(mar=c(0,0,0,0))
plot(st_geometry(bh), border=gray(.5))
plot(mst.bh, st_coordinates(st_centroid(bh)), col=2, 
     cex.lab=.6, cex.circles=0.035, fg="blue", add=TRUE)
</code></pre>

<hr>
<h2 id='nb.set.operations'>Set operations on neighborhood objects</h2><span id='topic+intersect.nb'></span><span id='topic+union.nb'></span><span id='topic+setdiff.nb'></span><span id='topic+complement.nb'></span>

<h3>Description</h3>

<p>Set operations on neighbors list objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect.nb(nb.obj1,nb.obj2)
union.nb(nb.obj1,nb.obj2)
setdiff.nb(nb.obj1,nb.obj2)
complement.nb(nb.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb.set.operations_+3A_nb.obj">nb.obj</code></td>
<td>
<p>a neighbor list created from any of the neighborhood
list funtions</p>
</td></tr>
<tr><td><code id="nb.set.operations_+3A_nb.obj1">nb.obj1</code></td>
<td>
<p>a neighbor list created from any of the neighborhood
list funtions</p>
</td></tr>
<tr><td><code id="nb.set.operations_+3A_nb.obj2">nb.obj2</code></td>
<td>
<p>a neighbor list created from any of the neighborhood
list funtions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform set operations on each element of a
neighborlist. The arguments must be neighbor lists created from the
same coordinates, and the region.id attributes must be identical. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>nb.obj</code></td>
<td>
<p>A new neighborlist created from the set operations on the
input neighbor list(s)</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect.nb">intersect.nb</a></code>, <code><a href="#topic+union.nb">union.nb</a></code>,
<code><a href="#topic+setdiff.nb">setdiff.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_coordinates(st_centroid(columbus))
col.tri.nb &lt;- tri2nb(coords)
oldpar &lt;- par(mfrow=c(1,2))
if (require("dbscan", quietly=TRUE)) {
  col.soi.nb &lt;- graph2nb(soi.graph(col.tri.nb, coords))
  plot(st_geometry(columbus), border="grey")
  plot(col.soi.nb, coords, add=TRUE)
  title(main="Sphere of Influence Graph", cex.main=0.7)
  plot(st_geometry(columbus), border="grey")
  plot(complement.nb(col.soi.nb), coords, add=TRUE)
  title(main="Complement of Sphere of Influence Graph", cex.main=0.7)
}
par(mfrow=c(2,2))
col2 &lt;- droplinks(col.gal.nb, 21)
plot(intersect.nb(col.gal.nb, col2), coords)
title(main="Intersect", cex.main=0.7)
plot(union.nb(col.gal.nb, col2), coords)
title(main="Union", cex.main=0.7)
plot(setdiff.nb(col.gal.nb, col2), coords)
title(main="Set diff", cex.main=0.7)
par(oldpar)
</code></pre>

<hr>
<h2 id='nb2blocknb'>Block up neighbour list for location-less observations</h2><span id='topic+nb2blocknb'></span>

<h3>Description</h3>

<p>The function blocks up a neighbour list for known spatial locations to
create a new neighbour list for multiple location-less observations know to
belong to the spatial locations, using the identification tags of the
locations as the key. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb2blocknb(nb=NULL, ID, row.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb2blocknb_+3A_nb">nb</code></td>
<td>
<p>an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids; if null, an nb object with no neighbours is created the length of <code>unique(as.character(ID))</code></p>
</td></tr>
<tr><td><code id="nb2blocknb_+3A_id">ID</code></td>
<td>
<p>identification tags of the locations for the location-less observations;
</p>
<p><code>sort(unique(as.character(ID)))</code> must be identical to 
</p>
<p><code>sort(as.character(attr(nb, "region.id")))</code>;
</p>
<p>same length as <code>row.names</code> if provided.</p>
</td></tr>
<tr><td><code id="nb2blocknb_+3A_row.names">row.names</code></td>
<td>
<p>character vector of observation ids to be added to the neighbours list as attribute <code>region.id</code>, default <code>seq(1, nrow(x))</code>; same length as <code>ID</code> if provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that there is a list of unique
locations, then a neighbour list can build for that, to create an input
neighbour list. This needs to be &quot;unfolded&quot;, so that observations
belonging to each unique location are observation neighbours, and
observations belonging to the location neighbours of the unique location
in question are also observation neighbours, finally removing the
observation itself (because it should not be its own neighbour). This
scenario also arises when say only post codes are available, and some post
codes contain multiple observations, where all that is known is that they belong
to a specific post code, not where they are located within it (given that 
the post code locations are known).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>nb</code> with a list of integer vectors containing neighbour observation number ids.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+knn2nb">knn2nb</a></code>, <code><a href="#topic+dnearneigh">dnearneigh</a></code>, <code><a href="#topic+cell2nb">cell2nb</a></code>, <code><a href="#topic+tri2nb">tri2nb</a></code>, <code><a href="#topic+poly2nb">poly2nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(boston, package="spData")
summary(as.vector(table(boston.c$TOWN)))
townaggr &lt;- aggregate(boston.utm, list(town=boston.c$TOWN), mean)
block.rel &lt;- graph2nb(relativeneigh(as.matrix(townaggr[,2:3])),
 as.character(townaggr[,1]), sym=TRUE)
block.rel
print(is.symmetric.nb(block.rel))
plot(block.rel, as.matrix(townaggr[,2:3]))
points(boston.utm, pch=18, col="lightgreen")
block.nb &lt;- nb2blocknb(block.rel, as.character(boston.c$TOWN))
block.nb
print(is.symmetric.nb(block.nb))
plot(block.nb, boston.utm)
points(boston.utm, pch=18, col="lightgreen")
n.comp.nb(block.nb)$nc
moran.test(boston.c$CMEDV, nb2listw(boston.soi))
moran.test(boston.c$CMEDV, nb2listw(block.nb))
block.nb &lt;- nb2blocknb(NULL, as.character(boston.c$TOWN))
block.nb
print(is.symmetric.nb(block.nb))
plot(block.nb, boston.utm)
n.comp.nb(block.nb)$nc
moran.test(boston.c$CMEDV, nb2listw(block.nb, zero.policy=TRUE), zero.policy=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='nb2INLA'>Output spatial neighbours for INLA</h2><span id='topic+nb2INLA'></span>

<h3>Description</h3>

<p>Output spatial neighbours for INLA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb2INLA(file, nb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb2INLA_+3A_file">file</code></td>
<td>
<p>file where adjacency matrix will be stored</p>
</td></tr>
<tr><td><code id="nb2INLA_+3A_nb">nb</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned but a file will be created with the representation of
the adjacency matrix as required by INLA for its spatial models.
</p>


<h3>Author(s)</h3>

<p>Virgilio Gomez-Rubio</p>


<h3>References</h3>

<p>http://www.r-inla.org</p>


<h3>Examples</h3>

<pre><code class='language-R'>col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
td &lt;- tempdir()
x &lt;- nb2INLA(paste(td, "columbus-INLA.adj", sep="/"), col.gal.nb)
readLines(paste(td, "columbus-INLA.adj", sep="/"), n=10)
</code></pre>

<hr>
<h2 id='nb2lines'>Use vector files for import and export of weights</h2><span id='topic+nb2lines'></span><span id='topic+listw2lines'></span><span id='topic+df2sn'></span>

<h3>Description</h3>

<p>Use vector files for import and export of weights, storing spatial entity coordinates in the arcs, and the entity indices in the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb2lines(nb, wts, coords, proj4string=NULL, as_sf=FALSE)
listw2lines(listw, coords, proj4string=NULL, as_sf=FALSE)
df2sn(df, i="i", i_ID="i_ID", j="j", wt="wt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb2lines_+3A_nb">nb</code></td>
<td>
<p>a neighbour object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="nb2lines_+3A_wts">wts</code></td>
<td>
<p>list of general weights corresponding to neighbours</p>
</td></tr>
<tr><td><code id="nb2lines_+3A_coords">coords</code></td>
<td>
<p>matrix of region point coordinates, a <code>Spatial</code> object (points or polygons), or an <code>sfc</code> object (points or polygons)</p>
</td></tr>
<tr><td><code id="nb2lines_+3A_proj4string">proj4string</code></td>
<td>
<p>default NULL; if <code>coords</code> is a Spatial or sf object, this value will be used, otherwise the value will be converted appropriately</p>
</td></tr>
<tr><td><code id="nb2lines_+3A_as_sf">as_sf</code></td>
<td>
<p>output object in <code>Spatial</code> or <code>sf</code> format, default FALSE, set to TRUE if coords is an <code>sfc</code> object and FALSE if a <code>Spatial</code> object</p>
</td></tr>
<tr><td><code id="nb2lines_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object of spatial weights</p>
</td></tr>
<tr><td><code id="nb2lines_+3A_df">df</code></td>
<td>
<p>a data frame read from a shapefile, derived from the output of <code>nb2lines</code></p>
</td></tr>
<tr><td><code id="nb2lines_+3A_i">i</code></td>
<td>
<p>character name of column in df with from entity index</p>
</td></tr>
<tr><td><code id="nb2lines_+3A_i_id">i_ID</code></td>
<td>
<p>character name of column in df with from entity region ID</p>
</td></tr>
<tr><td><code id="nb2lines_+3A_j">j</code></td>
<td>
<p>character name of column in df with to entity index</p>
</td></tr>
<tr><td><code id="nb2lines_+3A_wt">wt</code></td>
<td>
<p>character name of column in df with weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The neighbour and weights objects may be retrieved by converting the specified columns of the data slot of the SpatialLinesDataFrame object into a spatial.neighbour object, which is then converted into a weights list object.
</p>


<h3>Value</h3>

<p><code>nb2lines</code> and <code>listw2lines</code> return a SpatialLinesDataFrame object or an sf object; the data frame contains with the from and to indices of the neighbour links and their weights. <code>df2sn</code> converts the data retrieved from reading the data from <code>df</code> back into a <code>spatial.neighbour</code> object.
</p>


<h3>Note</h3>

<p>Original idea due to Gidske Leknes Andersen, Department of Biology, University of Bergen, Norway</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sn2listw">sn2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
res &lt;- listw2lines(nb2listw(col.gal.nb), st_geometry(columbus))
summary(res)
tf &lt;- paste0(tempfile(), ".gpkg")
st_write(res, dsn=tf, driver="GPKG")
inMap &lt;- st_read(tf)
summary(inMap)
diffnb(sn2listw(df2sn(as.data.frame(inMap)))$neighbours, col.gal.nb)
res1 &lt;- listw2lines(nb2listw(col.gal.nb), as(columbus, "Spatial"))
summary(res1)
</code></pre>

<hr>
<h2 id='nb2listw'>Spatial weights for neighbours lists</h2><span id='topic+nb2listw'></span><span id='topic+listw2U'></span>

<h3>Description</h3>

<p>The <code>nb2listw</code> function supplements a neighbours list with spatial weights for the chosen coding scheme. The <code>can.be.simmed</code> helper function checks whether a spatial weights object is similar to symmetric and can be so transformed to yield real eigenvalues or for Cholesky decomposition. The helper function <code>listw2U()</code> constructs a weights list object corresponding to the sparse matrix <code class="reqn">\frac{1}{2} ( \mathbf{W} + \mathbf{W}'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb2listw(neighbours, glist=NULL, style="W", zero.policy=NULL)
listw2U(listw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb2listw_+3A_neighbours">neighbours</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="nb2listw_+3A_glist">glist</code></td>
<td>
<p>list of general weights corresponding to neighbours</p>
</td></tr>
<tr><td><code id="nb2listw_+3A_style">style</code></td>
<td>
<p><code>style</code> can take values &ldquo;W&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;U&rdquo;, &ldquo;minmax&rdquo; and &ldquo;S&rdquo;</p>
</td></tr>
<tr><td><code id="nb2listw_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td></tr>
<tr><td><code id="nb2listw_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting from a binary neighbours list, in which regions are either listed as neighbours or are absent (thus not in the set of neighbours for some definition), the function adds a weights list with values given by the coding scheme style chosen. B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).
</p>
<p>If zero policy is set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row <code>t(rep(0, length=length(neighbours))) %*% x</code>, for arbitraty numerical vector <code>x</code> of length <code>length(neighbours)</code>. The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.
</p>
<p>If the sum of the glist vector for one or more observations is zero, a warning message is issued. The consequence for later operations will be the same as if no-neighbour observations were present and the zero.policy argument set to true.
</p>
<p>The &ldquo;minmax&rdquo; style is based on Kelejian and Prucha (2010), and divides the weights by the minimum of the maximum row sums and maximum column sums of the input weights. It is similar to the C and U styles; it is also available in Stata.
</p>


<h3>Value</h3>

<p>A <code>listw</code> object with the following members:
</p>
<table>
<tr><td><code>style</code></td>
<td>
<p>one of W, B, C, U, S, minmax as above</p>
</td></tr>
<tr><td><code>neighbours</code></td>
<td>
<p>the input neighbours list</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights for the neighbours and chosen style, with attributes set to report the type of relationships (binary or general, if general the form of the glist argument), and style as above</p>
</td></tr>
</table>
<p>and attributes:
</p>
<table>
<tr><td><code>region.id</code></td>
<td>
<p>character, as the neighbour object</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call</p>
</td></tr>
<tr><td><code>zero.policy</code></td>
<td>
<p>logical; the value of <code>zero.policy</code> when the object was created</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Tiefelsdorf, M., Griffith, D. A., Boots, B. 1999 A variance-stabilizing coding scheme for spatial link matrices, Environment and Planning A, 31, pp. 165&ndash;180; Kelejian, H. H., and I. R. Prucha. 2010. Specification and estimation of spatial autoregressive models with autoregressive and heteroskedastic disturbances. Journal of Econometrics, 157: pp. 53&ndash;67.</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code>, <code><a href="#topic+read.gal">read.gal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_coordinates(st_centroid(columbus))
cards &lt;- card(col.gal.nb)
col.w &lt;- nb2listw(col.gal.nb)
plot(cards, unlist(lapply(col.w$weights, sum)),xlim=c(0,10),
ylim=c(0,10), xlab="number of links", ylab="row sums of weights")
col.b &lt;- nb2listw(col.gal.nb, style="B")
points(cards, unlist(lapply(col.b$weights, sum)), col="red")
col.c &lt;- nb2listw(col.gal.nb, style="C")
points(cards, unlist(lapply(col.c$weights, sum)), col="green")
col.u &lt;- nb2listw(col.gal.nb, style="U")
points(cards, unlist(lapply(col.u$weights, sum)), col="orange")
col.s &lt;- nb2listw(col.gal.nb, style="S")
points(cards, unlist(lapply(col.s$weights, sum)), col="blue")
legend(x=c(0, 1), y=c(7, 9), legend=c("W", "B", "C", "U", "S"), bty="n",
col=c("black", "red", "green", "orange", "blue"), pch=rep(1,5), cex=0.8,
y.intersp=2.5)
summary(nb2listw(col.gal.nb, style="minmax"))
dlist &lt;- nbdists(col.gal.nb, coords)
dlist &lt;- lapply(dlist, function(x) 1/x)
col.w.d &lt;- nb2listw(col.gal.nb, glist=dlist)
summary(unlist(col.w$weights))
summary(unlist(col.w.d$weights))
# introducing other conditions into weights - only earlier sales count
# see http://sal.uiuc.edu/pipermail/openspace/2005-October/000610.html
data(baltimore, package="spData")
set.seed(211)
dates &lt;- sample(1:500, nrow(baltimore), replace=TRUE)
nb_15nn &lt;- knn2nb(knearneigh(cbind(baltimore$X, baltimore$Y), k=15))
glist &lt;- vector(mode="list", length=length(nb_15nn))
for (i in seq(along=nb_15nn))
  glist[[i]] &lt;- ifelse(dates[i] &gt; dates[nb_15nn[[i]]], 1, 0)
listw_15nn_dates &lt;- nb2listw(nb_15nn, glist=glist, style="B")
which(lag(listw_15nn_dates, baltimore$PRICE) == 0.0)
which(sapply(glist, sum) == 0)
ex &lt;- which(sapply(glist, sum) == 0)[1]
dates[ex]
dates[nb_15nn[[ex]]]
</code></pre>

<hr>
<h2 id='nb2listwdist'>Distance-based spatial weights for neighbours lists</h2><span id='topic+nb2listwdist'></span>

<h3>Description</h3>

<p>The <code>nb2listwdist</code> function supplements a neighbours list with spatial weights for the chosen types of distance modelling and coding scheme. While the offered coding schemes parallel those of the <code>nb2listw</code> function, three distance-based types of weights are available: inverse distance weighting (IDW), double-power distance weights, and exponential distance decay. The <code>can.be.simmed</code> helper function checks whether a spatial weights object is similar to symmetric and can be so transformed to yield real eigenvalues or for Cholesky decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb2listwdist(neighbours, x, type="idw", style="raw", 
  alpha = 1, dmax = NULL, longlat = NULL, zero.policy=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb2listwdist_+3A_neighbours">neighbours</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="nb2listwdist_+3A_x">x</code></td>
<td>
<p>an <code>sp</code> <code>sf</code>, or <code>sfc</code> object</p>
</td></tr>
<tr><td><code id="nb2listwdist_+3A_type">type</code></td>
<td>
<p>default &ldquo;idw&rdquo;; the intended type of distance modelling, can take values &ldquo;idw&rdquo;, &ldquo;exp&rdquo;, and &ldquo;dpd&rdquo;</p>
</td></tr>
<tr><td><code id="nb2listwdist_+3A_style">style</code></td>
<td>
<p>default &ldquo;raw&rdquo;; <code>style</code> can take values &ldquo;raw&rdquo;, &ldquo;W&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;U&rdquo;, &ldquo;minmax&rdquo;, and &ldquo;S&rdquo;</p>
</td></tr>
<tr><td><code id="nb2listwdist_+3A_alpha">alpha</code></td>
<td>
<p>default 0; a parameter for controlling the distance modelling, see &ldquo;Details&rdquo;</p>
</td></tr>
<tr><td><code id="nb2listwdist_+3A_dmax">dmax</code></td>
<td>
<p>default NULL, maximum distance threshold that is required for type &ldquo;dpd&rdquo; but optional for all other types</p>
</td></tr>
<tr><td><code id="nb2listwdist_+3A_longlat">longlat</code></td>
<td>
<p>default NULL; TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in metres; if x is a SpatialPoints object, the value is taken from the object itself, and overrides this argument if not NULL; distances are measured in map units if FALSE or NULL</p>
</td></tr>
<tr><td><code id="nb2listwdist_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL; use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting from a binary neighbours list, in which regions are either listed as neighbours or are absent (thus not in the set of neighbours for some definition), the function adds a distance-based weights list. Three types of distance weight calculations based on pairwise distances <code class="reqn">d_{ij}</code> are possible, all of which are controlled by parameter &ldquo;alpha&rdquo; (<code class="reqn">\alpha</code> below):
</p>
<p style="text-align: center;"><code class="reqn">\textrm{idw: } w_{ij} = d_{ij}^{-\alpha},</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{exp: } w_{ij} = \exp(-\alpha \cdot d_{ij}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{dpd: } w_{ij} = \left[1 - \left(d_{ij}/d_{\textrm{max}}\right)^{\alpha}\right]^{\alpha},</code>
</p>

<p>the latter of which leads to <code class="reqn">w_{ij} = 0</code> for all <code class="reqn">d_{ij} &gt; d_{\textrm{max}}</code>. Note that IDW weights show extreme behaviour close to 0 and can take on the value infinity. In such cases, the infinite values are replaced by the largest finite weight present in the weights list.
</p>
<p>The default coding scheme is &ldquo;raw&rdquo;, which outputs the raw distance-based weights without applying any kind of normalisation. In addition, the same coding scheme styles that are also available in the <code>nb2listw</code> function can be chosen. B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilising coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n). The &ldquo;minmax&rdquo; style is based on Kelejian and Prucha (2010), and divides the weights by the minimum of the maximum row sums and maximum column sums of the input weights. It is similar to the C and U styles; it is also available in Stata.
</p>
<p>If zero.policy is set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row <code>t(rep(0, length=length(neighbours))) %*% x</code>, for arbitraty numerical vector <code>x</code> of length <code>length(neighbours)</code>. The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.
</p>


<h3>Value</h3>

<p>A <code>listw</code> object with the following members:
</p>
<table>
<tr><td><code>style</code></td>
<td>
<p>one of W, B, C, U, S, minmax as above</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>one of idw, exp, dpd as above</p>
</td></tr>
<tr><td><code>neighbours</code></td>
<td>
<p>the input neighbours list</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights for the neighbours and chosen style, with attributes set to report the type of relationships (binary or general, if general the form of the glist argument), and style as above</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rene Westerholt <a href="mailto:rene.westerholt@tu-dortmund.de">rene.westerholt@tu-dortmund.de</a></p>


<h3>References</h3>

<p>Tiefelsdorf, M., Griffith, D. A., Boots, B. 1999 A variance-stabilizing coding scheme for spatial link matrices, Environment and Planning A, 31, pp. 165&ndash;180; Kelejian, H. H., and I. R. Prucha. 2010. Specification and estimation of spatial autoregressive models with autoregressive and heteroskedastic disturbances. Journal of Econometrics, 157: pp. 53&ndash;67.</p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2listw">nb2listw</a></code>, <code><a href="#topic+summary.nb">summary.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># World examples
data(world, package="spData")
# neighbours on distance interval [0, 1000] kilometres
# suppressWarnings(st_crs(world) &lt;- "+proj=longlat") # for older PROJ
pts &lt;- st_centroid(st_transform(world, 3857))
nb_world &lt;- dnearneigh(pts, 0, 1000000)
# Moran's I (life expectancy) with IDW with alpha = 2, no coding scheme
world_weights &lt;- nb2listwdist(nb_world, as(pts, "Spatial"), type = "idw",
  alpha = 2, zero.policy = TRUE)
moran.test(world$lifeExp, world_weights, zero.policy = TRUE, na.action = na.pass)
## Not run: 
# Moran's I (life expectancy) with IDW with alpha = 2, no coding scheme
world_weights &lt;- nb2listwdist(nb_world, pts, type = "idw",
  alpha = 2, zero.policy = TRUE)
moran.test(world$lifeExp, world_weights, zero.policy = TRUE, na.action = na.pass)
# Moran's I (life expectancy), DPD, alpha = 2, dmax = 1000 km, no coding scheme
world_weights &lt;- nb2listwdist(nb_world, pts, type = "dpd",
  dmax = 1000000, alpha = 2, zero.policy = TRUE)
moran.test(world$lifeExp, world_weights, zero.policy = TRUE, na.action = na.pass)
# Boston examples
data(boston, package="spData")
boston_coords &lt;- data.frame(x = boston.utm[,1], y = boston.utm[,2])
boston.geoms &lt;- st_as_sf(boston_coords, coords = c("x", "y"), remove = FALSE)
nb_boston &lt;- dnearneigh(boston.geoms, 0, 3)
# Moran's I (crime) with exp weights with alpha = 2, no coding scheme
boston_weights &lt;- nb2listwdist(nb_boston, boston.geoms, type = "exp", alpha = 2,
  style="raw", zero.policy = TRUE)
moran.test(boston.c$CRIM, boston_weights, zero.policy = TRUE, na.action = na.pass)
# Moran's I (crime) with idw weights with alpha = 2, coding scheme = W
boston_weights &lt;- nb2listwdist(nb_boston, boston.geoms, type = "idw", alpha = 2,
  style="W", zero.policy = TRUE)
moran.test(boston.c$CRIM, boston_weights, zero.policy = TRUE, na.action = na.pass)

## End(Not run)
</code></pre>

<hr>
<h2 id='nb2mat'>Spatial weights matrices for neighbours lists</h2><span id='topic+nb2mat'></span><span id='topic+listw2mat'></span>

<h3>Description</h3>

<p>The function generates a weights matrix for a neighbours list with spatial weights for the chosen coding scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb2mat(neighbours, glist=NULL, style="W", zero.policy=NULL)
listw2mat(listw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb2mat_+3A_neighbours">neighbours</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="nb2mat_+3A_glist">glist</code></td>
<td>
<p>list of general weights corresponding to neighbours</p>
</td></tr>
<tr><td><code id="nb2mat_+3A_style">style</code></td>
<td>
<p><code>style</code> can take values W, B, C, and S</p>
</td></tr>
<tr><td><code id="nb2mat_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td></tr>
<tr><td><code id="nb2mat_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object from for example <code>nb2listw</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting from a binary neighbours list, in which regions are either listed as neighbours or are absent (thus not in the set of neighbours for some definition), the function creates an n by n weights matrix with values given by the coding scheme style chosen. B is the basic binary coding, W is row standardised, C is globally standardised, while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168.
</p>
<p>The function leaves matrix rows as zero for any regions with zero neighbours fore zero.policy TRUE. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row <code>t(rep(0, length=length(neighbours))) %*% x</code>, for arbitraty numerical vector <code>x</code> of length <code>length(neighbours)</code>. The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.
</p>


<h3>Value</h3>

<p>An n by n matrix, where n=length(neighbours)
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Tiefelsdorf, M., Griffith, D. A., Boots, B. 1999 A variance-stabilizing coding scheme for spatial link matrices, Environment and Planning A, 31, pp. 165-180.</p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2listw">nb2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col005 &lt;- dnearneigh(st_coordinates(st_centroid(st_geometry(columbus),
 of_largest_polygon=TRUE)), 0, 0.5, as.character(columbus$NEIGNO))
summary(col005)
col005.w.mat &lt;- nb2mat(col005, style="B", zero.policy=TRUE)
table(round(rowSums(col005.w.mat)))
</code></pre>

<hr>
<h2 id='nb2WB'>Output spatial weights for WinBUGS</h2><span id='topic+nb2WB'></span><span id='topic+listw2WB'></span>

<h3>Description</h3>

<p>Output spatial weights for WinBUGS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb2WB(nb)
listw2WB(listw) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb2WB_+3A_nb">nb</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="nb2WB_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object from for example <code>nb2listw</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list suitable for convering using <code>dput</code> for WinBUGS
</p>


<h3>Author(s)</h3>

<p>Virgilio Gomez-Rubio</p>


<h3>References</h3>

<p>http://www.mrc-bsu.cam.ac.uk/bugs/winbugs/geobugs12manual.pdf</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+dput">dput</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
x &lt;- nb2WB(col.gal.nb)
dput(x, control=NULL)
x &lt;- listw2WB(nb2listw(col.gal.nb))
dput(x, control=NULL)
</code></pre>

<hr>
<h2 id='nbcosts'>Compute cost of edges</h2><span id='topic+nbcosts'></span><span id='topic+nbcost'></span>

<h3>Description</h3>

<p>The cost of each edge is the distance between it nodes. This function
compute this distance using a data.frame with observations vector in
each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbcost(data, id, id.neigh,  method = c("euclidean", "maximum", 
    "manhattan", "canberra", "binary", "minkowski", "mahalanobis"),
    p = 2, cov, inverted = FALSE)
nbcosts(nb, data,  method = c("euclidean", "maximum", 
    "manhattan", "canberra", "binary", "minkowski", "mahalanobis"),
    p = 2, cov, inverted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbcosts_+3A_nb">nb</code></td>
<td>
<p>An object of <code>nb</code> class. See <code><a href="#topic+poly2nb">poly2nb</a></code> for
details.</p>
</td></tr> 
<tr><td><code id="nbcosts_+3A_data">data</code></td>
<td>
<p>A matrix with observations in the nodes.</p>
</td></tr>
<tr><td><code id="nbcosts_+3A_id">id</code></td>
<td>
<p>Node index to compute the cost</p>
</td></tr>
<tr><td><code id="nbcosts_+3A_id.neigh">id.neigh</code></td>
<td>
<p>Idex of neighbours nodes of node <code>id</code></p>
</td></tr>
<tr><td><code id="nbcosts_+3A_method">method</code></td>
<td>
<p>Character or function to declare distance method.
If <code>method</code> is character, method must be &quot;mahalanobis&quot; or
&quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;
or &quot;minkowisk&quot;.
If <code>method</code> is one of &quot;euclidean&quot;, &quot;maximum&quot;,
&quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowisk&quot;, see
<code><a href="stats.html#topic+dist">dist</a></code> for details,
because this function as used to compute the distance.
If <code>method="mahalanobis"</code>, the mahalanobis distance
is computed between neighbour areas.
If <code>method</code> is a <code>function</code>, this function is
used to compute the distance.</p>
</td></tr>
<tr><td><code id="nbcosts_+3A_p">p</code></td>
<td>
<p>The power of the Minkowski distance.</p>
</td></tr>
<tr><td><code id="nbcosts_+3A_cov">cov</code></td>
<td>
<p>The covariance matrix used to compute the mahalanobis 
distance.</p>
</td></tr>
<tr><td><code id="nbcosts_+3A_inverted">inverted</code></td>
<td>
<p>logical.  If 'TRUE', 'cov' is supposed to contain the
inverse of the covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object of <code>nbdist</code> class. See <code><a href="#topic+nbdists">nbdists</a></code> for
details.
</p>


<h3>Note</h3>

<p>The neighbours must be a connected graph.</p>


<h3>Author(s)</h3>

<p>Elias T. Krainski and Renato M. Assuncao</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+nbdists">nbdists</a></code>, <code><a href="#topic+nb2listw">nb2listw</a></code></p>

<hr>
<h2 id='nbdists'>Spatial link distance measures</h2><span id='topic+nbdists'></span>

<h3>Description</h3>

<p>Given a list of spatial neighbour links (a neighbours list of object type
<code>nb</code>), the function returns the Euclidean distances along the links
in a list of the same form as the neighbours list. If longlat = TRUE, Great
Circle distances are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbdists(nb, coords, longlat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbdists_+3A_nb">nb</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="nbdists_+3A_coords">coords</code></td>
<td>
<p>matrix of point coordinates, an object inheriting from SpatialPoints or an <code>"sf"</code> or <code>"sfc"</code> object; if the <code>"sf"</code> or <code>"sfc"</code> object geometries are in geographical coordinates (<code>sf::st_is_longlat(x) == TRUE</code> and <code>sf::sf_use_s2() == TRUE</code>), <span class="pkg">s2</span> will be used to find distances <a href="https://github.com/r-spatial/s2/issues/125">https://github.com/r-spatial/s2/issues/125</a></p>
</td></tr>
<tr><td><code id="nbdists_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometers; if coords is a SpatialPoints object, the value is taken from the object itself</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>nbdist</code>
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code>, <code><a href="#topic+nb2listw">nb2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_coordinates(st_centroid(columbus))
dlist &lt;- nbdists(col.gal.nb, coords)
dlist &lt;- lapply(dlist, function(x) 1/x)
stem(unlist(dlist))
</code></pre>

<hr>
<h2 id='nblag'>Higher order neighbours lists</h2><span id='topic+nblag'></span><span id='topic+nblag_cumul'></span>

<h3>Description</h3>

<p>The function creates higher order neighbour lists, where higher order neighbours are only <code>lags</code> links from each other on the graph described by the input neighbours list. It will refuse to lag neighbours lists with the attribute self.included set to TRUE. <code>nblag_cumul</code> cumulates neighbour lists to a single neighbour list (&ldquo;nb&rdquo; object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nblag(neighbours, maxlag)
nblag_cumul(nblags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nblag_+3A_neighbours">neighbours</code></td>
<td>
<p>input neighbours list of class <code>nb</code></p>
</td></tr>
<tr><td><code id="nblag_+3A_maxlag">maxlag</code></td>
<td>
<p>the maximum lag to be constructed</p>
</td></tr>
<tr><td><code id="nblag_+3A_nblags">nblags</code></td>
<td>
<p>a list of neighbour lists as output by <code>nblag</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of lagged neighbours lists each with class <code>nb</code>
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> and Giovanni Millo</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_coordinates(st_centroid(columbus))
summary(col.gal.nb, coords)
col.lags &lt;- nblag(col.gal.nb, 2)
print(col.lags)
summary(col.lags[[2]], coords)
plot(st_geometry(columbus), border="grey")
plot(col.gal.nb, coords, add=TRUE)
title(main="GAL order 1 (black) and 2 (red) links")
plot(col.lags[[2]], coords, add=TRUE, col="red", lty=2)
cuml &lt;- nblag_cumul(col.lags)
cuml
run &lt;- FALSE
if (require(igraph, quietly=TRUE) &amp;&amp; require(spatialreg, quietly=TRUE)) run &lt;- TRUE
if (run) {
W &lt;- as(nb2listw(col.gal.nb), "CsparseMatrix")
G &lt;- graph.adjacency(W, mode="directed", weight="W")
D &lt;- diameter(G)
nbs &lt;- nblag(col.gal.nb, maxlag=D)
n &lt;- length(col.gal.nb)
lmat &lt;- lapply(nbs, nb2mat, style="B", zero.policy=TRUE)
mat &lt;- matrix(0, n, n)
for (i in seq(along=lmat)) mat = mat + i*lmat[[i]]
G2 &lt;- shortest.paths(G)
print(all.equal(G2, mat, check.attributes=FALSE))
}
</code></pre>

<hr>
<h2 id='oldcol'>Columbus OH spatial analysis data set - old numbering</h2><span id='topic+oldcol'></span><span id='topic+COL.OLD'></span><span id='topic+COL.nb'></span>

<h3>Description</h3>

<p>The <code>COL.OLD</code> data frame has 49 rows and 22 columns. The observations are
ordered and numbered as in the original analyses of the data set in the
SpaceStat documentation and in Anselin, L. 1988 Spatial econometrics: methods and models, Dordrecht: Kluwer.
Unit of analysis: 49 neighbourhoods in Columbus, OH, 1980 data.
In addition the data set includes <code>COL.nb</code>, the neighbours list
as used in Anselin (1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oldcol)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>AREA_PL</dt><dd><p>computed by ArcView (agrees with areas of polygons in the &ldquo;columbus&rdquo; data set</p>
</dd>
<dt>PERIMETER</dt><dd><p>computed by ArcView</p>
</dd>
<dt>COLUMBUS.</dt><dd><p>internal polygon ID (ignore)</p>
</dd>
<dt>COLUMBUS.I</dt><dd><p>another internal polygon ID (ignore)</p>
</dd>
<dt>POLYID</dt><dd><p>yet another polygon ID</p>
</dd>
<dt>NEIG</dt><dd><p>neighborhood id value (1-49);
conforms to id value used in Spatial Econometrics book.</p>
</dd>
<dt>HOVAL</dt><dd><p>housing value (in $1,000)</p>
</dd>
<dt>INC</dt><dd><p>household income (in $1,000)</p>
</dd>
<dt>CRIME</dt><dd><p>residential burglaries and vehicle thefts per thousand
households in the neighborhood</p>
</dd>
<dt>OPEN</dt><dd><p>open space in neighborhood</p>
</dd>
<dt>PLUMB</dt><dd><p>percentage housing units without plumbin</p>
</dd>
<dt>DISCBD</dt><dd><p>distance to CBD</p>
</dd>
<dt>X</dt><dd><p>x coordinate (in arbitrary digitizing units, not polygon coordinates)</p>
</dd>
<dt>Y</dt><dd><p>y coordinate (in arbitrary digitizing units, not polygon coordinates)</p>
</dd>
<dt>AREA_SS</dt><dd><p>neighborhood area (computed by SpaceStat)</p>
</dd>
<dt>NSA</dt><dd><p>north-south dummy (North=1)</p>
</dd>
<dt>NSB</dt><dd><p>north-south dummy (North=1)</p>
</dd>
<dt>EW</dt><dd><p>east-west dummy (East=1)</p>
</dd>
<dt>CP</dt><dd><p>core-periphery dummy (Core=1)</p>
</dd>
<dt>THOUS</dt><dd><p>constant=1,000</p>
</dd>
<dt>NEIGNO</dt><dd><p>NEIG+1,000, alternative neighborhood id value</p>
</dd>
<dt>PERIM</dt><dd><p>polygon perimeter (computed by SpaceStat)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The row names of <code>COL.OLD</code> and the <code>region.id</code> attribute of
<code>COL.nb</code> are set to <code>columbus$NEIGNO</code>.
</p>


<h3>Note</h3>

<p>All source data files prepared by
Luc Anselin, Spatial Analysis Laboratory, Department of Agricultural and Consumer Economics, University of Illinois, Urbana-Champaign.
</p>


<h3>Source</h3>

<p>Anselin, Luc.  1988.  Spatial econometrics: methods and
models.  Dordrecht: Kluwer Academic, Table 12.1 p. 189.
</p>

<hr>
<h2 id='p.adjustSP'>Adjust local association measures' p-values</h2><span id='topic+p.adjustSP'></span>

<h3>Description</h3>

<p>Make an adjustment to local association measures' p-values based on the number of neighbours (+1) of each region, rather than the total number of regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.adjustSP(p, nb, method = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.adjustSP_+3A_p">p</code></td>
<td>
<p>vector of p-values</p>
</td></tr>
<tr><td><code id="p.adjustSP_+3A_nb">nb</code></td>
<td>
<p>a list of neighbours of class <code>nb</code></p>
</td></tr>
<tr><td><code id="p.adjustSP_+3A_method">method</code></td>
<td>
<p>correction method as defined in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>: &quot;The adjustment methods include the Bonferroni correction ('&quot;bonferroni&quot;') in which the p-values are multiplied by the number of comparisons.  Four less conservative corrections are also included by Holm (1979) ('holm'), Hochberg (1988) ('hochberg'), Hommel (1988) ('hommel') and Benjamini &amp; Hochberg (1995) ('fdr'), respectively. A pass-through option ('none') is also included.&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of corrected p-values using only the number of neighbours + 1.
</p>


<h3>Author(s)</h3>

<p>Danlin Yu and Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+p.adjust">p.adjust</a></code>, <code><a href="#topic+localG">localG</a></code>, <code><a href="#topic+localmoran">localmoran</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(afcon, package="spData")
oid &lt;- order(afcon$id)
resG &lt;- as.vector(localG(afcon$totcon, nb2listw(include.self(paper.nb))))
non &lt;- format.pval(pnorm(2*(abs(resG)), lower.tail=FALSE), 2)
bon &lt;- format.pval(p.adjustSP(pnorm(2*(abs(resG)), lower.tail=FALSE),
 paper.nb, "bonferroni"), 2)
tot &lt;- format.pval(p.adjust(pnorm(2*(abs(resG)), lower.tail=FALSE),
 "bonferroni", n=length(resG)), 2)
data.frame(resG, non, bon, tot, row.names=afcon$name)[oid,]
</code></pre>

<hr>
<h2 id='plot.mst'>Plot the Minimum Spanning Tree</h2><span id='topic+plot.mst'></span>

<h3>Description</h3>

<p>This function plots a MST, the nodes are circles and the edges are
segments. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mst'
plot(x, coords, label.areas = NULL, 
   cex.circles = 1, cex.labels = 1, add=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mst_+3A_x">x</code></td>
<td>
<p>Object of <code>mst</code> class.</p>
</td></tr>
<tr><td><code id="plot.mst_+3A_coords">coords</code></td>
<td>
<p>A two column matrix with the coordinates of nodes.</p>
</td></tr>
<tr><td><code id="plot.mst_+3A_label.areas">label.areas</code></td>
<td>
<p>A vector with the labels of nodes</p>
</td></tr>
<tr><td><code id="plot.mst_+3A_cex.circles">cex.circles</code></td>
<td>
<p>The length of circles to plot.</p>
</td></tr>
<tr><td><code id="plot.mst_+3A_cex.labels">cex.labels</code></td>
<td>
<p>The length of nodes labels ploted.</p>
</td></tr>
<tr><td><code id="plot.mst_+3A_add">add</code></td>
<td>
<p>default FALSE, create new plot</p>
</td></tr>
<tr><td><code id="plot.mst_+3A_...">...</code></td>
<td>
<p>Further arguments passed to plotting functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elias T. Krainski and Renato M. Assuncao</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+skater">skater</a></code> and <code><a href="#topic+mstree">mstree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### see example in mstree function documentation
</code></pre>

<hr>
<h2 id='plot.nb'>Plot a neighbours list</h2><span id='topic+plot.nb'></span><span id='topic+plot.listw'></span>

<h3>Description</h3>

<p>A function to plot a neighbours list given point coordinates to represent the region in two dimensions; <code>plot.listw</code> is a wrapper that passes its neighbours component to <code>plot.nb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nb'
plot(x, coords, col="black", points=TRUE, add=FALSE, arrows=FALSE,
 length=0.1, xlim=NULL, ylim=NULL, ...)
## S3 method for class 'listw'
plot(x, coords, col="black", points=TRUE, add=FALSE, arrows=FALSE,
 length=0.1, xlim=NULL, ylim=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nb_+3A_x">x</code></td>
<td>
<p>an object of class <code>nb</code> or (for <code>plot.listw</code>) class <code>listw</code></p>
</td></tr>
<tr><td><code id="plot.nb_+3A_coords">coords</code></td>
<td>
<p>matrix of region point coordinates, a <code>Spatial</code> object (points or polygons), or an <code>sfc</code> object (points or polygons)</p>
</td></tr>
<tr><td><code id="plot.nb_+3A_col">col</code></td>
<td>
<p>plotting colour</p>
</td></tr>
<tr><td><code id="plot.nb_+3A_points">points</code></td>
<td>
<p>(logical) add points to plot</p>
</td></tr>
<tr><td><code id="plot.nb_+3A_add">add</code></td>
<td>
<p>(logical) add to existing plot</p>
</td></tr>
<tr><td><code id="plot.nb_+3A_arrows">arrows</code></td>
<td>
<p>(logical) draw arrowheads for asymmetric neighbours</p>
</td></tr>
<tr><td><code id="plot.nb_+3A_length">length</code></td>
<td>
<p>length in plot inches of arrow heads drawn for asymmetric
neighbours lists</p>
</td></tr>
<tr><td><code id="plot.nb_+3A_xlim">xlim</code>, <code id="plot.nb_+3A_ylim">ylim</code></td>
<td>
<p>plot window bounds</p>
</td></tr>
<tr><td><code id="plot.nb_+3A_...">...</code></td>
<td>
<p>further graphical parameters as in <code>par(..)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
plot(col.gal.nb, st_geometry(columbus))
title(main="GAL order 1 links with first nearest neighbours in red", cex.main=0.6)
plot(col.gal.nb, as(columbus, "Spatial"))
title(main="GAL order 1 links with first nearest neighbours in red", cex.main=0.6)
coords &lt;- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE)
col.knn &lt;- knearneigh(coords, k=1)
plot(knn2nb(col.knn), coords, add=TRUE, col="red", length=0.08)
</code></pre>

<hr>
<h2 id='plot.skater'>Plot the object of skater class</h2><span id='topic+plot.skater'></span>

<h3>Description</h3>

<p>This function displays the results of the skater function. The subgraphs
are plotted with different colours. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skater'
plot(x, coords, label.areas = NULL, 
   groups.colors, cex.circles = 1, cex.labels = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.skater_+3A_x">x</code></td>
<td>
<p>An object of <code>skater</code> class.</p>
</td></tr>
<tr><td><code id="plot.skater_+3A_coords">coords</code></td>
<td>
<p>A matrix of two colums with coordinates of nodes.</p>
</td></tr>
<tr><td><code id="plot.skater_+3A_label.areas">label.areas</code></td>
<td>
<p>A vector of labels of nodes.</p>
</td></tr>
<tr><td><code id="plot.skater_+3A_groups.colors">groups.colors</code></td>
<td>
<p>A vector with colors of groups ou sub-graphs.</p>
</td></tr>
<tr><td><code id="plot.skater_+3A_cex.circles">cex.circles</code></td>
<td>
<p>The length of circles with represent the nodes.</p>
</td></tr>
<tr><td><code id="plot.skater_+3A_cex.labels">cex.labels</code></td>
<td>
<p>The length of labels of nodes.</p>
</td></tr>
<tr><td><code id="plot.skater_+3A_...">...</code></td>
<td>
<p>Further arguments passed to plotting funcitons.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elias T. Krainski and Renato M. Assuncao</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+skater">skater</a></code> and <code><a href="#topic+mstree">mstree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### see example in the skater function documentation
</code></pre>

<hr>
<h2 id='poly2nb'>Construct neighbours list from polygon list</h2><span id='topic+poly2nb'></span>

<h3>Description</h3>

<p>The function builds a neighbours list based on regions with contiguous boundaries, that is sharing one or more boundary point. The current function is in part interpreted and may run slowly for many regions or detailed boundaries, but from 0.2-16 should not fail because of lack of memory when single polygons are built of very many border coordinates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly2nb(pl, row.names = NULL, snap=sqrt(.Machine$double.eps),
 queen=TRUE, useC=TRUE, foundInBox=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly2nb_+3A_pl">pl</code></td>
<td>
<p>list of polygons of class extending <code>SpatialPolygons</code>, or an <code>sf</code> or <code>sfc</code> object containing non-empty (multi-)polygon objects</p>
</td></tr>
<tr><td><code id="poly2nb_+3A_row.names">row.names</code></td>
<td>
<p>character vector of region ids to be added to the neighbours list as attribute <code>region.id</code>, default <code>seq(1, nrow(x))</code>; if <code>pl</code> has <code>row.names</code>, they are used instead of the default sequence.</p>
</td></tr>
<tr><td><code id="poly2nb_+3A_snap">snap</code></td>
<td>
<p>boundary points less than <code>snap</code> distance apart are considered to indicate contiguity; used both to find candidate and actual neighbours for planar geometries, but only actual neighbours for spherical geometries, as spherical spatial indexing itself injects some fuzzyness.</p>
</td></tr>
<tr><td><code id="poly2nb_+3A_queen">queen</code></td>
<td>
<p>if TRUE, a single shared boundary point meets the contiguity condition, if FALSE, more than one shared point is required; note that more than one shared boundary point does not necessarily mean a shared boundary line</p>
</td></tr>
<tr><td><code id="poly2nb_+3A_usec">useC</code></td>
<td>
<p>default TRUE, doing the work loop in C, may be set to false to revert to R code calling two C functions in an <code>n*k</code> work loop, where <code>k</code> is the average number of candidate neighbours</p>
</td></tr>
<tr><td><code id="poly2nb_+3A_foundinbox">foundInBox</code></td>
<td>
<p>default NULL using R code or <code>st_intersects()</code> to generate candidate neighbours (using <code>snap=</code> if the geometries are not spherical); if not NULL (for legacy purposes) a list of length <code>(n-1)</code> with integer vectors of candidate neighbours <code>(j &gt; i)</code> (as created by the <code>poly_findInBoxGEOS</code> function in <span class="pkg">rgeos</span> for clean polygons)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A neighbours list with class <code>nb</code>. See <code><a href="#topic+card">card</a></code> for details of &ldquo;nb&rdquo; objects.
</p>


<h3>Note</h3>

<p>From 0.5-8, the function includes faster bounding box indexing and other improvements contributed by Micah Altman. If a cluster is provided using <code>set.ClusterOption</code>, it will be used for finding candidate bounding box overlaps for exact testing for contiguity.
</p>
<p>Until 1.1-7, <code>sf</code> polygons included both start and end points, so could erroneously report queen neighbourhood where only rook was present, see <a href="https://github.com/r-spatial/spdep/issues/50">https://github.com/r-spatial/spdep/issues/50</a>.
</p>
<p>From 1.1-9 with <span class="pkg">sf</span> 1.0-0, <span class="pkg">s2</span> is used in bounding box indexing internally when <code>pl</code> is in geographical coordinates. Because the topology engine of <span class="pkg">s2</span> differs from the use of GEOS for planar coordinates by <span class="pkg">sf</span>, some output differences may be expected. Since treating spherical geometries as planar is also questionable, it is not clear whether spherical contiguous polygon neighbours should simply follow neighbours found by treating the geometries as planar <a href="https://github.com/r-spatial/s2/issues/125#issuecomment-864403372">https://github.com/r-spatial/s2/issues/125#issuecomment-864403372</a>. However, current advice is not necessarily to use <span class="pkg">s2</span> for finding contiguity neighbours, or at least to check output.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> with contributions from Micah Altman</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code>, <code><a href="#topic+card">card</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_coordinates(st_centroid(st_geometry(columbus)))
xx &lt;- poly2nb(as(columbus, "Spatial"))
dxx &lt;- diffnb(xx, col.gal.nb)
plot(st_geometry(columbus), border="grey")
plot(col.gal.nb, coords, add=TRUE)
plot(dxx, coords, add=TRUE, col="red")
title(main=paste("Differences (red) in Columbus GAL weights (black)",
 "and polygon generated queen weights", sep="\n"), cex.main=0.6)
# poly2nb with sf sfc_MULTIPOLYGON objects
sf_xx &lt;- poly2nb(columbus)
diffnb(sf_xx, xx)
sfc_xx &lt;- poly2nb(st_geometry(columbus))
diffnb(sfc_xx, xx)
xxx &lt;- poly2nb(as(columbus, "Spatial"), queen=FALSE)
dxxx &lt;- diffnb(xxx, col.gal.nb)
plot(st_geometry(columbus), border = "grey")
plot(col.gal.nb, coords, add = TRUE)
plot(dxxx, coords, add = TRUE, col = "red")
title(main=paste("Differences (red) in Columbus GAL weights (black)",
 "and polygon generated rook weights", sep="\n"), cex.main=0.6)
cards &lt;- card(xx)
maxconts &lt;- which(cards == max(cards))
if(length(maxconts) &gt; 1) maxconts &lt;- maxconts[1]
fg &lt;- rep("grey", length(cards))
fg[maxconts] &lt;- "red"
fg[xx[[maxconts]]] &lt;- "green"
plot(st_geometry(columbus), col=fg)
title(main="Region with largest number of contiguities", cex.main=0.6)
nc.sids &lt;- st_read(system.file("shapes/sids.shp", package="spData")[1], quiet=TRUE)
system.time(xxnb &lt;- poly2nb(nc.sids))
system.time(xxnb &lt;- poly2nb(as(nc.sids, "Spatial")))
plot(st_geometry(nc.sids))
plot(xxnb, st_coordinates(st_centroid(nc.sids)), add=TRUE, col="blue")
sq &lt;- st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,1), c(0,0))))
sq2 &lt;- sq + c(0,1)
sq3 &lt;- sq + c(1,0)
sq4 &lt;- sq + c(1,1)
gm &lt;- st_sfc(list(sq, sq2, sq3, sq4))
df &lt;- st_as_sf(gm, id=1:4)
plot(st_geometry(df))
text(st_coordinates(st_centroid(gm)), as.character(df$id))
unclass(poly2nb(df, queen = FALSE))
col_geoms &lt;- st_geometry(columbus)
col_geoms[1] &lt;- st_buffer(col_geoms[1], dist=-0.05)
st_geometry(columbus) &lt;- col_geoms
poly2nb(columbus)
</code></pre>

<hr>
<h2 id='probmap'>Probability mapping for rates</h2><span id='topic+probmap'></span>

<h3>Description</h3>

<p>The function returns a data frame of rates for counts in populations at risk with crude rates, expected counts of cases, relative risks, and Poisson probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probmap(n, x, row.names=NULL, alternative="less")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probmap_+3A_n">n</code></td>
<td>
<p>a numeric vector of counts of cases</p>
</td></tr>
<tr><td><code id="probmap_+3A_x">x</code></td>
<td>
<p>a numeric vector of populations at risk</p>
</td></tr>
<tr><td><code id="probmap_+3A_row.names">row.names</code></td>
<td>
<p>row names passed through to output data frame</p>
</td></tr>
<tr><td><code id="probmap_+3A_alternative">alternative</code></td>
<td>
<p>default &ldquo;less&rdquo;, may be set to &ldquo;greater&rdquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a data frame, from which rates may be mapped after class intervals have been chosen. The class intervals used in the examples are mostly taken from the referenced source.
</p>


<h3>Value</h3>

<table>
<tr><td><code>raw</code></td>
<td>
<p>raw (crude) rates</p>
</td></tr>
<tr><td><code>expCount</code></td>
<td>
<p>expected counts of cases assuming global rate</p>
</td></tr>
<tr><td><code>relRisk</code></td>
<td>
<p>relative risks: ratio of observed and expected counts of cases multiplied by 100</p>
</td></tr>
<tr><td><code>pmap</code></td>
<td>
<p>Poisson probability map values: probablility of getting a more &ldquo;extreme&rdquo; count than actually observed - one-tailed, default alternative observed &ldquo;less&rdquo; than expected</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Bailey T, Gatrell A (1995) Interactive Spatial Data Analysis, Harlow: Longman, pp. 300&ndash;303.</p>


<h3>See Also</h3>

<p><code><a href="#topic+EBest">EBest</a></code>, <code><a href="#topic+EBlocal">EBlocal</a></code>, <code><a href="stats.html#topic+ppois">ppois</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>auckland &lt;- st_read(system.file("shapes/auckland.shp", package="spData")[1], quiet=TRUE)
res &lt;- probmap(auckland$M77_85, 9*auckland$Und5_81)
rt &lt;- sum(auckland$M77_85)/sum(9*auckland$Und5_81)
ppois_pmap &lt;- numeric(length(auckland$Und5_81))
for (i in seq(along=ppois_pmap)) {
ppois_pmap[i] &lt;- poisson.test(auckland$M77_85[i], r=rt,
  T=(9*auckland$Und5_81[i]), alternative="less")$p.value
all.equal(ppois_pmap, res$pmap)
}
res$id &lt;- 1:nrow(res)
auckland$id &lt;- res$id &lt;- 1:nrow(res)
auckland_res &lt;- merge(auckland, res, by="id")
plot(auckland_res[, "raw"], main="Crude (raw) estimates")
plot(auckland_res[, "relRisk"], main="Standardised mortality ratios")
plot(auckland_res[, "pmap"], main="Poisson probabilities",
 breaks=c(0, 0.05, 0.1, 0.5, 0.9, 0.95, 1))
</code></pre>

<hr>
<h2 id='prunecost'>Compute cost of prune each edge</h2><span id='topic+prunecost'></span>

<h3>Description</h3>

<p>If any edge are dropped, the MST are pruned. This generate a two
subgraphs. So, it makes a tree graphs and tree dissimilarity values
are computed, one for each graph. The dissimilarity is the sum over
sqared differences between the observactions in the nodes and mean
vector of observations in the graph. The dissimilarity of original
graph and the sum of dissimilarity of subgraphs are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prunecost(edges, data, method = c("euclidean", "maximum", "manhattan", 
    "canberra", "binary", "minkowski", "mahalanobis"), 
    p = 2, cov, inverted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prunecost_+3A_edges">edges</code></td>
<td>
<p>A matrix with 2 colums with each row is one edge</p>
</td></tr>
<tr><td><code id="prunecost_+3A_data">data</code></td>
<td>
<p>A data.frame with observations in the nodes.</p>
</td></tr>
<tr><td><code id="prunecost_+3A_method">method</code></td>
<td>
<p>Character or function to declare distance method.
If <code>method</code> is character, method must be &quot;mahalanobis&quot; or
&quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;
or &quot;minkowisk&quot;.
If <code>method</code> is one of &quot;euclidean&quot;, &quot;maximum&quot;,
&quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowisk&quot;, see
<code><a href="stats.html#topic+dist">dist</a></code> for details,
because this function as used to compute the distance.
If <code>method="mahalanobis"</code>, the mahalanobis distance
is computed between neighbour areas.
If <code>method</code> is a <code>function</code>, this function is
used to compute the distance.</p>
</td></tr>
<tr><td><code id="prunecost_+3A_p">p</code></td>
<td>
<p>The power of the Minkowski distance.</p>
</td></tr>
<tr><td><code id="prunecost_+3A_cov">cov</code></td>
<td>
<p>The covariance matrix used to compute the mahalanobis
distance.</p>
</td></tr>
<tr><td><code id="prunecost_+3A_inverted">inverted</code></td>
<td>
<p>logical.  If 'TRUE', 'cov' is supposed to contain the
inverse of the covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the differences between the dissimilarity of all nodes
and the dissimilarity sum of all subgraphs obtained by pruning one
edge each time.
</p>


<h3>Author(s)</h3>

<p>Elias T. Krainski and Renato M. Assuncao</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+prunemst">prunemst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(a=-2:2, b=runif(5))
e &lt;- matrix(c(1,2, 2,3, 3,4, 4,5), ncol=2, byrow=TRUE)

sum(sweep(d, 2, colMeans(d))^2)

prunecost(e, d)
</code></pre>

<hr>
<h2 id='prunemst'>Prune a Minimun Spanning Tree</h2><span id='topic+prunemst'></span>

<h3>Description</h3>

<p>This function deletes a first edge and makes two subsets of edges. Each
subset is a Minimun Spanning Treee.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prunemst(edges, only.nodes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prunemst_+3A_edges">edges</code></td>
<td>
<p>A matrix with two colums with each row is one edge</p>
</td></tr>
<tr><td><code id="prunemst_+3A_only.nodes">only.nodes</code></td>
<td>
<p>If <code>only.nodes=FALSE</code>, return a edges and nodes
of each MST resulted. If <code>only.nodes=TRUE</code>, return a two sets of
nodes. Defalt is TRUE</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A list of length two. If <code>only.nodes=TRUE</code> each element is a
vector of nodes. If <code>only.nodes=FALSE</code> each element is a list with
nodes and edges.
</p>


<h3>Author(s)</h3>

<p>Elias T. Krainski and Renato M. Assuncao</p>


<h3>See Also</h3>

<p> See Also as <code><a href="#topic+mstree">mstree</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- matrix(c(2,3, 1,2, 3,4, 4,5), ncol=2, byrow=TRUE)
e
prunemst(e)
prunemst(e, only.nodes=FALSE)
</code></pre>

<hr>
<h2 id='read.gal'>Read a GAL lattice file into a neighbours list</h2><span id='topic+read.gal'></span><span id='topic+read.geoda'></span>

<h3>Description</h3>

<p>The function <code>read.gal()</code> reads a GAL lattice file into a neighbours list for spatial analysis. It will read old and new style (GeoDa) GAL files. The function <code>read.geoda</code> is a helper file for reading comma separated value data files, calling <code>read.csv()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.gal(file, region.id=NULL, override.id=FALSE)
read.geoda(file, row.names=NULL, skip=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.gal_+3A_file">file</code></td>
<td>
<p>name of file with GAL lattice data</p>
</td></tr>
<tr><td><code id="read.gal_+3A_region.id">region.id</code></td>
<td>
<p>region IDs in specified order to coerse neighbours list order and numbering to that of the region.id</p>
</td></tr>
<tr><td><code id="read.gal_+3A_override.id">override.id</code></td>
<td>
<p>override any given (or NULL) region.id, collecting region.id numbering and order from the GAL file.</p>
</td></tr>
<tr><td><code id="read.gal_+3A_row.names">row.names</code></td>
<td>
<p>as in row.names in <code>read.csv()</code>, typically a character string naming the column of the file to be used</p>
</td></tr>
<tr><td><code id="read.gal_+3A_skip">skip</code></td>
<td>
<p>skip number of lines, as in <code>read.csv()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Luc Anselin (2003): Spatial Analysis Laboratory, Department of Agricultural and Consumer Economics, University of Illinois, Urbana-Champaign, now dead link: http://www.csiss.org/gispopsci/workshops/2011/PSU/readings/W15_Anselin2007.pdf; Luc Anselin (2003) <em>GeoDa 0.9 User's Guide</em>, pp. 80&ndash;81, Spatial Analysis Laboratory, Department of Agricultural and Consumer Economics, University of Illinois, Urbana-Champaign, <a href="http://geodacenter.github.io/docs/geoda093.pdf">http://geodacenter.github.io/docs/geoda093.pdf</a>; GAL - Geographical Algorithms Library, University of Newcastle</p>


<h3>Value</h3>

<p>The function <code>read.gal()</code> returns an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids. The function <code>read.geoda</code> returns a data frame, and issues a warning if the returned object has only one column.
</p>


<h3>Note</h3>

<p>Example data originally downloaded from now dead link: http://sal.agecon.uiuc.edu/weights/zips/us48.zip</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nb">summary.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>us48.fipsno &lt;- read.geoda(system.file("etc/weights/us48.txt",
 package="spdep")[1])
us48.q &lt;- read.gal(system.file("etc/weights/us48_q.GAL", package="spdep")[1],
 us48.fipsno$Fipsno)
us48.r &lt;- read.gal(system.file("etc/weights/us48_rk.GAL", package="spdep")[1],
 us48.fipsno$Fipsno)
data(state)
if (as.numeric(paste(version$major, version$minor, sep="")) &lt; 19) {
 m50.48 &lt;- match(us48.fipsno$"State.name", state.name)
} else {
 m50.48 &lt;- match(us48.fipsno$"State_name", state.name)
}
plot(us48.q, as.matrix(as.data.frame(state.center))[m50.48,])
plot(diffnb(us48.r, us48.q),
 as.matrix(as.data.frame(state.center))[m50.48,], add=TRUE, col="red")
title(main="Differences between rook and queen criteria imported neighbours lists")
</code></pre>

<hr>
<h2 id='read.gwt2nb'>Read and write spatial neighbour files</h2><span id='topic+read.gwt2nb'></span><span id='topic+write.sn2gwt'></span><span id='topic+read.dat2listw'></span><span id='topic+write.sn2dat'></span>

<h3>Description</h3>

<p>The &quot;gwt&quot; functions read and write GeoDa GWT files (the example file baltk4.GWT was downloaded from the site given in the reference), and the &quot;dat&quot; functions read and write Matlab sparse matrix files as used by James LeSage's Spatial Econometrics Toolbox (the example file wmat.dat was downloaded from the site given in the reference). The body of the files after any headers should have three columns separated by white space, and the third column must be numeric in the locale of the reading platform (correct decimal separator).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.gwt2nb(file, region.id=NULL)
write.sn2gwt(sn, file, shpfile=NULL, ind=NULL, useInd=FALSE, legacy=FALSE)
read.dat2listw(file)
write.sn2dat(sn, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.gwt2nb_+3A_file">file</code></td>
<td>
<p>name of file with weights data</p>
</td></tr>
<tr><td><code id="read.gwt2nb_+3A_region.id">region.id</code></td>
<td>
<p>region IDs</p>
</td></tr>
<tr><td><code id="read.gwt2nb_+3A_sn">sn</code></td>
<td>
<p>a <code>spatial.neighbour</code> object</p>
</td></tr>
<tr><td><code id="read.gwt2nb_+3A_shpfile">shpfile</code></td>
<td>
<p>character string: if not given Shapefile name taken from GWT file for this dataset</p>
</td></tr>
<tr><td><code id="read.gwt2nb_+3A_ind">ind</code></td>
<td>
<p>character string: region id indicator field name</p>
</td></tr>
<tr><td><code id="read.gwt2nb_+3A_useind">useInd</code></td>
<td>
<p>default FALSE, if TRUE, write <code>region.id</code> attribute ID key tags to output file (use in OpenGeoDa will depend on the shapefile having the field named in the <code>ind</code> argument matching the exported tags)</p>
</td></tr>
<tr><td><code id="read.gwt2nb_+3A_legacy">legacy</code></td>
<td>
<p>default FALSE; if TRUE, header has single field with number of observations only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attempts to honour the region.id argument given when reading GWT files. If the region IDs given in <code>region.id=</code> do not match the origins or destinations in the GWT file, an error will be thrown reporting <code>Error: !anyNA(reg*dij) is not TRUE</code> where '*' may be &lsquo;o&rsquo; for origins or &lsquo;d&rsquo; for destinations.
</p>


<h3>Value</h3>

<p><code>read.gwt2nb</code> returns a neighbour &quot;nb&quot; object with the generalised weights stored as a list element called &quot;dlist&quot; of the &quot;GeoDa&quot; attribute.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Luc Anselin (2003) <em>GeoDa 0.9 User's Guide</em>, pp. 80&ndash;81, Spatial Analysis Laboratory, Department of Agricultural and Consumer Economics, University of Illinois, Urbana-Champaign, <a href="http://geodacenter.github.io/docs/geoda093.pdf">http://geodacenter.github.io/docs/geoda093.pdf</a>; also <a href="http://spatial-econometrics.com/data/contents.html">http://spatial-econometrics.com/data/contents.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read.gal">read.gal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(baltimore, package="spData")
STATION &lt;- baltimore$STATION
gwt1 &lt;- read.gwt2nb(system.file("weights/baltk4.GWT", package="spData")[1],
 STATION)
cat(paste("Neighbours list symmetry;", is.symmetric.nb(gwt1, FALSE, TRUE),
 "\n"))
listw1 &lt;- nb2listw(gwt1, style="B", glist=attr(gwt1, "GeoDa")$dist)
tmpGWT &lt;- tempfile()
write.sn2gwt(listw2sn(listw1), tmpGWT)
gwt2 &lt;- read.gwt2nb(tmpGWT, STATION)
cat(paste("Neighbours list symmetry;", is.symmetric.nb(gwt2, FALSE, TRUE),
 "\n"))
diffnb(gwt1, gwt2)
data(oldcol)
tmpMAT &lt;- tempfile()
COL.W &lt;- nb2listw(COL.nb)
write.sn2dat(listw2sn(COL.W), tmpMAT)
listwmat1 &lt;- read.dat2listw(tmpMAT)
diffnb(listwmat1$neighbours, COL.nb, verbose=TRUE)
listwmat2 &lt;- read.dat2listw(system.file("etc/weights/wmat.dat", 
 package="spdep")[1])
diffnb(listwmat1$neighbours, listwmat2$neighbours, verbose=TRUE)
</code></pre>

<hr>
<h2 id='Rotation'> Rotate a set of point by a certain angle </h2><span id='topic+Rotation'></span>

<h3>Description</h3>

<p>Rotate a set of XY coordinates by an angle (in radians)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rotation(xy, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotation_+3A_xy">xy</code></td>
<td>
<p> A 2-columns matrix or data frame containing a set of X and Y coordinates. </p>
</td></tr>
<tr><td><code id="Rotation_+3A_angle">angle</code></td>
<td>
<p> Numeric. A scalar giving the angle at which the points should be rotated. The angle is in radians. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-columns matrix of the same size as <code>xy</code> giving the rotated coordinates.
</p>


<h3>Author(s)</h3>

<p> F. Guillaume Blanchet </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
### Create a set of coordinates
coords &lt;- cbind(runif(20), runif(20))

### Create a series of angles
rad &lt;- seq(0, pi, l=20)

opar &lt;- par(mfrow=c(5,4), mar=c(3,3,1,1))
for(i in rad){
	coords.rot &lt;- Rotation(coords, i)
	plot(coords.rot, xlab="", ylab="")
}
par(opar)

### Rotate the coordinates by an angle of 90 degrees
coords.90 &lt;- Rotation(coords, 90*pi/180)
coords.90

plot(coords, xlim=range(rbind(coords.90,coords)[,1]),
 ylim=range(rbind(coords.90,coords)[,2]), asp=1)
points(coords.90, pch=19)
</code></pre>

<hr>
<h2 id='SD.RStests'>
Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models
</h2><span id='topic+SD.RStests'></span>

<h3>Description</h3>

<p>Rao's score and adjusted Rao's score tests of linear hypotheses applied to a fitted linear model to examine whether either the spatially lagged dependent variable <code>lag</code> or the spatially lagged independent variable(s) <code>WX</code> should be included in the model, or both (SDM). Adjusted tests are provided for <code>lag</code> and <code>WX</code> adapting to the presence of the other, and a joint test for both. The joint test is equal to the unadjusted of one plus the adjusted of the other. In addition, draft tests are added from Koley (2024, section 6) for spatial Durbin error models to examine whether either the spatially lagged error <code>err</code> or the spatially lagged independent variable(s) <code>WX</code> should be included in the model, or both (SDEM); because of orthogonality, no adjusted tests are required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SD.RStests(model, listw, zero.policy = attr(listw, "zero.policy"), test = "SDM",
 Durbin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SD.RStests_+3A_model">model</code></td>
<td>
<p>an object of class <code>lm</code> returned by <code>lm</code></p>
</td></tr>
<tr><td><code id="SD.RStests_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code>,
expected to be row-standardised (W-style)</p>
</td></tr>
<tr><td><code id="SD.RStests_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without
neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="SD.RStests_+3A_test">test</code></td>
<td>
<p>test=&ldquo;SDM&rdquo; computes the SDM tests, a character vector of tests requested chosen from SDM_RSlag, SDM_adjRSlag, SDM_RSWX, SDM_adjRSWX, SDM_Joint, test=&ldquo;SDEM&rdquo; computes the SDEM tests, a character vector of tests requested chosen from SDEM_RSerr, SDEM_RSWX, SDEM_Joint; test=&ldquo;all&rdquo; computes all the tests</p>
</td></tr>
<tr><td><code id="SD.RStests_+3A_durbin">Durbin</code></td>
<td>
<p>default TRUE for Durbin models including WX; if TRUE, full spatial Durbin model; if a formula object, the subset of explanatory variables to lag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>LMtestlist</code> of <code>htest</code> objects, each with:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Lagrange Multiplier test.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>number of degrees of freedom</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The results in the example below agree with those in Table 3, p. 22 in Koley and Bera (2024).
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a>, Malabika Koley and Anil K. Bera</p>


<h3>References</h3>

<p>Malabika Koley and Anil K. Bera (2024) To use, or not to use the spatial Durbin model? – that is the question, Spatial Economic Analysis, 19:1, 30-56, <a href="https://doi.org/10.1080/17421772.2023.2256810">doi:10.1080/17421772.2023.2256810</a>; Malabika Koley (2024) Specification Testing under General Nesting Spatial Model (Appendix C), <a href="https://sites.google.com/view/malabikakoley/research">https://sites.google.com/view/malabikakoley/research</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+lm.RStests">lm.RStests</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- sf::st_read(system.file("shapes/columbus.shp", package="spData")[1])
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
col.listw &lt;- nb2listw(col.gal.nb, style="W")
lm_obj &lt;- lm(CRIME ~ INC + HOVAL, data=columbus)
summary(lm.RStests(lm_obj, col.listw, test="all"))
res &lt;- SD.RStests(lm_obj, col.listw, test="SDM")
summary(res)
all.equal(unname(res$SDM_Joint$statistic),
 unname(res$SDM_RSlag$statistic + res$SDM_adjRSWX$statistic))
all.equal(unname(res$SDM_Joint$statistic),
 unname(res$SDM_adjRSlag$statistic + res$SDM_RSWX$statistic))
res &lt;- SD.RStests(lm_obj, col.listw, test="SDEM")
summary(res)
all.equal(unname(res$SDEM_Joint$statistic),
 unname(res$SDEM_RSerr$statistic + res$SDEM_RSWX$statistic))
summary(SD.RStests(lm_obj, nb2listw(col.gal.nb, style="C"), test="all"))
summary(SD.RStests(lm_obj, col.listw, test="all", Durbin= ~ INC))
lm_obj0 &lt;- lm(I(scale(CRIME)) ~ 0 + I(scale(INC)) + I(scale(HOVAL)),
 data=columbus)
summary(SD.RStests(lm_obj0, col.listw, test="all"))
columbusNA &lt;- columbus
columbusNA$HOVAL[15] &lt;- NA
lm_objNA &lt;- lm(CRIME ~ INC + HOVAL, data=columbusNA)
summary(SD.RStests(lm_objNA, col.listw, test="all"))
</code></pre>

<hr>
<h2 id='set.mcOption'>Options for parallel support</h2><span id='topic+set.ClusterOption'></span><span id='topic+get.ClusterOption'></span><span id='topic+set.mcOption'></span><span id='topic+get.coresOption'></span><span id='topic+set.coresOption'></span><span id='topic+get.mcOption'></span>

<h3>Description</h3>

<p>Provides support for the use of parallel computation in the parallel package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.mcOption(value)
get.mcOption()
set.coresOption(value)
get.coresOption()
set.ClusterOption(cl)
get.ClusterOption()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.mcOption_+3A_value">value</code></td>
<td>
<p>valid replacement value</p>
</td></tr>
<tr><td><code id="set.mcOption_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by <code>makeCluster</code> in <span class="pkg">parallel</span></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Options in the spdep package are held in an environment local to the package namespace and not exported. Option values are set and retrieved with pairs of access functions, get and set. The <code>mc</code> option is set by default to FALSE on Windows systems, as they cannot fork the R session; by default it is TRUE on other systems, but may be set FALSE. If <code>mc</code> is FALSE, the <code>Cluster</code> option is used: if <code>mc</code> is FALSE and the <code>Cluster</code> option is NULL no parallel computing is done, or the <code>Cluster</code> option is passed a &ldquo;cluster&rdquo; object created by the parallel or snow package for access without being passed as an argument. The <code>cores</code> option is set to NULL by default, and can be used to store the number of cores to use as an integer. If <code>cores</code> is NULL, facilities from the parallel package will not be used.
</p>


<h3>Value</h3>

<p>The option access functions return their current settings, the assignment functions usually return the previous value of the option.
</p>


<h3>Note</h3>

<p>An extended example is shown in the documentation of <code><a href="spatialreg.html#topic+aple.mc">aple.mc</a></code>, including treatment of seeding of RNG for multicore/cluster.</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>ls(envir=spdep:::.spdepOptions)
if (require(parallel, quietly=TRUE)) {
 nc &lt;- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L
 nc
# set nc to 1L here
 if (nc &gt; 1L) nc &lt;- 1L
#nc &lt;- ifelse(nc &gt; 2L, 2L, nc)
 coresOpt &lt;- get.coresOption()
 coresOpt
 if (!is.na(nc)) {
  invisible(set.coresOption(nc))
  print(exists("moran.mc"))
  if(.Platform$OS.type == "windows") {
# forking not permitted on Windows - start cluster
   print(get.mcOption())
   cl &lt;- makeCluster(get.coresOption())
   print(clusterEvalQ(cl, exists("moran.mc")))
   set.ClusterOption(cl)
   clusterEvalQ(get.ClusterOption(), library(spdep))
   print(clusterEvalQ(cl, exists("moran.mc")))
   clusterEvalQ(get.ClusterOption(), detach(package:spdep))
   set.ClusterOption(NULL)
   print(clusterEvalQ(cl, exists("moran.mc")))
   stopCluster(cl)
  } else {
   mcOpt &lt;- get.mcOption()
   print(mcOpt)
   print(mclapply(1:get.coresOption(), function(i) exists("moran.mc"),
    mc.cores=get.coresOption()))
   invisible(set.mcOption(FALSE))
   cl &lt;- makeCluster(nc)
   print(clusterEvalQ(cl, exists("moran.mc")))
   set.ClusterOption(cl)
   clusterEvalQ(get.ClusterOption(), library(spdep))
   print(clusterEvalQ(cl, exists("moran.mc")))
   clusterEvalQ(get.ClusterOption(), detach(package:spdep))
   set.ClusterOption(NULL)
   print(clusterEvalQ(cl, exists("moran.mc")))
   stopCluster(cl)
   invisible(set.mcOption(mcOpt))
  }
  invisible(set.coresOption(coresOpt))
 }
}
</code></pre>

<hr>
<h2 id='set.spChkOption'>Control checking of spatial object IDs</h2><span id='topic+set.spChkOption'></span><span id='topic+get.spChkOption'></span><span id='topic+chkIDs'></span><span id='topic+spNamedVec'></span><span id='topic+set.VerboseOption'></span><span id='topic+get.VerboseOption'></span><span id='topic+set.SubgraphOption'></span><span id='topic+get.SubgraphOption'></span><span id='topic+set.ZeroPolicyOption'></span><span id='topic+get.ZeroPolicyOption'></span><span id='topic+set.listw_is_CsparseMatrix_Option'></span><span id='topic+get.listw_is_CsparseMatrix_Option'></span>

<h3>Description</h3>

<p>Provides support for checking the mutual integrity of spatial neighbour weights and spatial data; similar mechanisms are used for passing global verbose and zero.policy options, and for causing functions creating neighbour objects to warn if there are multiple subgraphs. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.spChkOption(check)
get.spChkOption()
chkIDs(x, listw)
spNamedVec(var, data)
set.VerboseOption(check)
get.VerboseOption()
set.ZeroPolicyOption(check)
get.ZeroPolicyOption()
set.SubgraphOption(check)
get.SubgraphOption()
set.listw_is_CsparseMatrix_Option(check)
get.listw_is_CsparseMatrix_Option()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.spChkOption_+3A_check">check</code></td>
<td>
<p>a logical value, TRUE or FALSE</p>
</td></tr>
<tr><td><code id="set.spChkOption_+3A_x">x</code></td>
<td>
<p>a vector the same length, or a two-dimensional array, or data frame with the same number of rows as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="set.spChkOption_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object or <code>nb</code> object inheriting from &quot;nb&quot;</p>
</td></tr>
<tr><td><code id="set.spChkOption_+3A_var">var</code></td>
<td>
<p>a character string or integer value for the column to be selected</p>
</td></tr>
<tr><td><code id="set.spChkOption_+3A_data">data</code></td>
<td>
<p>a two-dimensional array or data frame containing var</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Analysis functions will have an spChk argument by default set to NULL, and will call <code>get.spChkOption()</code> to get the global spatial option for whether to check or not &mdash; this is initialised to FALSE, and consequently should not break anything. It can be changed to TRUE using <code>set.spChkOption(TRUE)</code>, or the spChk argument can be assigned in analysis functions. <code>spNamedVec()</code> is provided to ensure that rownames are passed on to single columns taken from two-dimensional arrays and data frames.
</p>


<h3>Value</h3>

<p><code>set.spChkOption()</code> returns the old logical value, <code>get.spChkOption()</code> returns the current logical value, and <code>chkIDs()</code> returns a logical value for the test lack of difference. <code>spNamedVec()</code> returns the selected column with the names set to the row names of the object from which it has been extracted.
</p>


<h3>Note</h3>

<p>The motivation for this mechanism is provided by the observation that spatial objects on a map and their attribute data values need to be linked uniquely, to avoid spurious results. The reordering between the legacy Columbus data set used the earlier publications and that available for download from the Spacestat website is just one example of a common problem.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
rownames(COL.OLD)
data(columbus, package="spData")
rownames(columbus)
get.spChkOption()
oldChk &lt;- set.spChkOption(TRUE)
get.spChkOption()
chkIDs(COL.OLD, nb2listw(COL.nb))
chkIDs(columbus, nb2listw(col.gal.nb))
chkIDs(columbus, nb2listw(COL.nb))
tmp &lt;- try(moran.test(spNamedVec("CRIME", COL.OLD), nb2listw(COL.nb)))
print(tmp)
tmp &lt;- try(moran.test(spNamedVec("CRIME", columbus), nb2listw(col.gal.nb)))
print(tmp)
tmp &lt;- try(moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb)))
print(tmp)
set.spChkOption(FALSE)
get.spChkOption()
moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb))
tmp &lt;- try(moran.test(spNamedVec("CRIME", columbus), nb2listw(COL.nb),
 spChk=TRUE), silent=TRUE)
print(tmp)
set.spChkOption(oldChk)
get.spChkOption()
</code></pre>

<hr>
<h2 id='skater'>Spatial 'K'luster Analysis by Tree Edge Removal</h2><span id='topic+skater'></span>

<h3>Description</h3>

<p>This function implements a SKATER procedure for spatial clustering
analysis. This procedure essentialy begins with an edges set, a data set and
a number of cuts. The output is an object of 'skater' class and is
valid for input again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skater(edges, data, ncuts, crit, vec.crit, method = c("euclidean", 
    "maximum", "manhattan", "canberra", "binary", "minkowski", 
    "mahalanobis"), p = 2, cov, inverted = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skater_+3A_edges">edges</code></td>
<td>
<p>A matrix with 2 colums with each row is an edge</p>
</td></tr>
<tr><td><code id="skater_+3A_data">data</code></td>
<td>
<p>A data.frame with data observed over nodes.</p>
</td></tr>
<tr><td><code id="skater_+3A_ncuts">ncuts</code></td>
<td>
<p>The number of cuts</p>
</td></tr>
<tr><td><code id="skater_+3A_crit">crit</code></td>
<td>
<p>A scalar or two dimensional vector with
criteria for groups. Examples: limits of group size or
limits of population size. If scalar, is the minimum
criteria for groups.</p>
</td></tr>
<tr><td><code id="skater_+3A_vec.crit">vec.crit</code></td>
<td>
<p>A vector for evaluating criteria.</p>
</td></tr>
<tr><td><code id="skater_+3A_method">method</code></td>
<td>
<p>Character or function to declare distance method.
If <code>method</code> is character, method must be &quot;mahalanobis&quot; or
&quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;
or &quot;minkowisk&quot;.
If <code>method</code> is one of &quot;euclidean&quot;, &quot;maximum&quot;,
&quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot;, see
<code><a href="stats.html#topic+dist">dist</a></code> for details,
because this function as used to compute the distance.
If <code>method="mahalanobis"</code>, the mahalanobis distance
is computed between neighbour areas.
If <code>method</code> is a <code>function</code>, this function is
used to compute the distance.</p>
</td></tr>
<tr><td><code id="skater_+3A_p">p</code></td>
<td>
<p>The power of the Minkowski distance.</p>
</td></tr>
<tr><td><code id="skater_+3A_cov">cov</code></td>
<td>
<p>The covariance matrix used to compute the mahalanobis
distance.</p>
</td></tr>
<tr><td><code id="skater_+3A_inverted">inverted</code></td>
<td>
<p>logical.  If 'TRUE', 'cov' is supposed to contain the
inverse of the covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object of <code>skater</code> class with:
</p>
<table>
<tr><td><code>groups</code></td>
<td>
<p>A vector with length equal the number of nodes. Each
position identifies the group of node</p>
</td></tr> 
<tr><td><code>edges.groups</code></td>
<td>
<p>A list of length equal the number of groups with
each element is a set of edges</p>
</td></tr> 
<tr><td><code>not.prune</code></td>
<td>
<p>A vector identifying the groups with are not
candidates to partition.</p>
</td></tr>
<tr><td><code>candidates</code></td>
<td>
<p>A vector identifying the groups with are candidates
to partition.</p>
</td></tr> 
<tr><td><code>ssto</code></td>
<td>
<p>The total dissimilarity in each step of edge removal.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Renato M. Assuncao and Elias T. Krainski</p>


<h3>References</h3>

<p>Assuncao, R.M., Lage J.P., and Reis, E.A. (2002). Analise de
conglomerados espaciais via arvore geradora minima. Revista Brasileira
de Estatistica, 62, 1-23. 
</p>
<p>Assuncao, R. M, Neves, M. C., Camara, G. and Freitas, C. da
C. (2006). Efficient regionalization techniques for socio-economic
geographical units using minimum spanning trees. International Journal
of Geographical Information Science Vol. 20, No. 7, August 2006,
797-811 
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+mstree">mstree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### loading data
bh &lt;- st_read(system.file("etc/shapes/bhicv.shp",
      package="spdep")[1], quiet=TRUE)
st_crs(bh) &lt;- "OGC:CRS84"
### data standardized 
dpad &lt;- data.frame(scale(as.data.frame(bh)[,5:8]))

### neighboorhod list
bh.nb &lt;- poly2nb(bh)

### calculating costs
lcosts &lt;- nbcosts(bh.nb, dpad)

### making listw
nb.w &lt;- nb2listw(bh.nb, lcosts, style="B")

### find a minimum spanning tree
mst.bh &lt;- mstree(nb.w,5)

### the mstree plot
par(mar=c(0,0,0,0))
plot(st_geometry(bh), border=gray(.5))
pts &lt;- st_coordinates(st_centroid(bh))
plot(mst.bh, pts, col=2, 
     cex.lab=.6, cex.circles=0.035, fg="blue", add=TRUE)
### three groups with no restriction
res1 &lt;- skater(mst.bh[,1:2], dpad, 2)

### groups size
table(res1$groups)

### the skater plot
opar &lt;- par(mar=c(0,0,0,0))
plot(res1, pts, cex.circles=0.035, cex.lab=.7)

### the skater plot, using other colors
plot(res1, pts, cex.circles=0.035, cex.lab=.7,
     groups.colors=heat.colors(length(res1$ed)))

### the Spatial Polygons plot
plot(st_geometry(bh), col=heat.colors(length(res1$edg))[res1$groups])

par(opar)
### EXPERT OPTIONS

### more one partition
res1b &lt;- skater(res1, dpad, 1)

### length groups frequency
table(res1$groups)

table(res1b$groups)

### thee groups with minimum population 
res2 &lt;- skater(mst.bh[,1:2], dpad, 2, 200000, bh$Pop)
table(res2$groups)

### thee groups with minimun number of areas
res3 &lt;- skater(mst.bh[,1:2], dpad, 2, 3, rep(1,nrow(bh)))
table(res3$groups)

### thee groups with minimun and maximun number of areas
res4 &lt;- skater(mst.bh[,1:2], dpad, 2, c(20,50), rep(1,nrow(bh)))
table(res4$groups)

### if I want to get groups with 20 to 40 elements
res5 &lt;- skater(mst.bh[,1:2], dpad, 2,
   c(20,40), rep(1,nrow(bh))) ## DON'T MAKE DIVISIONS 
table(res5$groups)

### In this MST don't have groups with this restrictions
### In this case, first I do one division
### with the minimun criteria
res5a &lt;- skater(mst.bh[,1:2], dpad, 1, 20, rep(1,nrow(bh))) 
table(res5a$groups)

### and do more one division with the full criteria
res5b &lt;- skater(res5a, dpad, 1, c(20, 40), rep(1,nrow(bh)))
table(res5b$groups)

### and do more one division with the full criteria
res5c &lt;- skater(res5b, dpad, 1, c(20, 40), rep(1,nrow(bh)))
table(res5c$groups)

### It don't have another divison with this criteria
res5d &lt;- skater(res5c, dpad, 1, c(20, 40), rep(1,nrow(bh)))
table(res5d$groups)

## Not run: 
data(boston, package="spData")
bh.nb &lt;- boston.soi
dpad &lt;- data.frame(scale(boston.c[,c(7:10)]))
### calculating costs
system.time(lcosts &lt;- nbcosts(bh.nb, dpad))
### making listw
nb.w &lt;- nb2listw(bh.nb, lcosts, style="B")
### find a minimum spanning tree
mst.bh &lt;- mstree(nb.w,5)
### three groups with no restriction
system.time(res1 &lt;- skater(mst.bh[,1:2], dpad, 2))
library(parallel)
nc &lt;- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L
# set nc to 1L here
if (nc &gt; 1L) nc &lt;- 1L
coresOpt &lt;- get.coresOption()
invisible(set.coresOption(nc))
if(!get.mcOption()) {
# no-op, "snow" parallel calculation not available
  cl &lt;- makeCluster(get.coresOption())
  set.ClusterOption(cl)
}
### calculating costs
system.time(plcosts &lt;- nbcosts(bh.nb, dpad))
all.equal(lcosts, plcosts, check.attributes=FALSE)
### making listw
pnb.w &lt;- nb2listw(bh.nb, plcosts, style="B")
### find a minimum spanning tree
pmst.bh &lt;- mstree(pnb.w,5)
### three groups with no restriction
system.time(pres1 &lt;- skater(pmst.bh[,1:2], dpad, 2))
if(!get.mcOption()) {
  set.ClusterOption(NULL)
  stopCluster(cl)
}
all.equal(res1, pres1, check.attributes=FALSE)
invisible(set.coresOption(coresOpt))

## End(Not run)
</code></pre>

<hr>
<h2 id='sp.correlogram'>Spatial correlogram</h2><span id='topic+sp.correlogram'></span><span id='topic+plot.spcor'></span><span id='topic+print.spcor'></span>

<h3>Description</h3>

<p>Spatial correlograms for Moran's I and the autocorrelation coefficient, with
print and plot helper functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp.correlogram(neighbours, var, order = 1, method = "corr",
 style = "W", randomisation = TRUE, zero.policy = NULL, spChk=NULL)
## S3 method for class 'spcor'
plot(x, main, ylab, ylim, ...)
## S3 method for class 'spcor'
print(x, p.adj.method="none", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp.correlogram_+3A_neighbours">neighbours</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_var">var</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_order">order</code></td>
<td>
<p>maximum lag order</p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_method">method</code></td>
<td>
<p>&quot;corr&quot; for correlation, &quot;I&quot; for Moran's I, &quot;C&quot; for Geary's C</p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_style">style</code></td>
<td>
<p><code>style</code> can take values W, B, C, and S</p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_randomisation">randomisation</code></td>
<td>
<p>variance of I or C calculated under the assumption of randomisation, if FALSE normality</p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, 
if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_x">x</code></td>
<td>
<p>an object from <code>sp.correlogram()</code> of class <code>spcor</code></p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_p.adj.method">p.adj.method</code></td>
<td>
<p>correction method as in <code>p.adjust</code></p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_main">main</code></td>
<td>
<p>an overall title for the plot</p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis</p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot</p>
</td></tr>
<tr><td><code id="sp.correlogram_+3A_...">...</code></td>
<td>
<p>further arguments passed through</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print function also calculates the standard deviates of Moran's I or Geary's C and a two-sided probability value, optionally using <code>p.adjust</code> to correct by the nymber of lags. The plot function plots a bar from the estimated Moran's I, or Geary's C value to +/- twice the square root of its variance (in previous releases only once, not twice). The table includes the count of included observations in brackets after the lag order. Care needs to be shown when interpreting results for few remaining included observations as lag order increases.
</p>


<h3>Value</h3>

<p>returns a list of class <code>spcor</code>:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>for &quot;corr&quot; a vector of values; for &quot;I&quot;, a matrix of estimates of &quot;I&quot;, expectations, and variances</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>&quot;I&quot; or &quot;corr&quot;</p>
</td></tr>
<tr><td><code>cardnos</code></td>
<td>
<p>list of tables of neighbour cardinalities for the lag orders used</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variable name</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand, <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 <em>Spatial processes</em>, Pion, pp. 
118&ndash;122, Martin, R. L., Oeppen, J. E. 1975 The identification of regional
forecasting models using space-time correlation functions, <em>Transactions
of the Institute of British Geographers</em>, 66, 95&ndash;118.</p>


<h3>See Also</h3>

<p><code><a href="#topic+nblag">nblag</a></code>, <code><a href="#topic+moran">moran</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nc.sids &lt;- st_read(system.file("shapes/sids.shp", package="spData")[1], quiet=TRUE)
rn &lt;- as.character(nc.sids$FIPS)
ncCC89_nb &lt;- read.gal(system.file("weights/ncCC89.gal", package="spData")[1],
 region.id=rn)
ft.SID74 &lt;- sqrt(1000)*(sqrt(nc.sids$SID74/nc.sids$BIR74) +
  sqrt((nc.sids$SID74+1)/nc.sids$BIR74))
tr.SIDS74 &lt;- ft.SID74*sqrt(nc.sids$BIR74)
cspc &lt;- sp.correlogram(ncCC89_nb, tr.SIDS74, order=8, method="corr",
 zero.policy=TRUE)
print(cspc)
plot(cspc)
Ispc &lt;- sp.correlogram(ncCC89_nb, tr.SIDS74, order=8, method="I",
 zero.policy=TRUE)
print(Ispc)
print(Ispc, "bonferroni")
plot(Ispc)
Cspc &lt;- sp.correlogram(ncCC89_nb, tr.SIDS74, order=8, method="C",
 zero.policy=TRUE)
print(Cspc)
print(Cspc, "bonferroni")
plot(Cspc)
drop.no.neighs &lt;- !(1:length(ncCC89_nb) %in% which(card(ncCC89_nb) == 0))
sub.ncCC89.nb &lt;- subset(ncCC89_nb, drop.no.neighs)
plot(sp.correlogram(sub.ncCC89.nb, subset(tr.SIDS74,  drop.no.neighs),
 order=8, method="corr"))
</code></pre>

<hr>
<h2 id='sp.mantel.mc'>Mantel-Hubert spatial general cross product statistic</h2><span id='topic+sp.mantel.mc'></span><span id='topic+plot.mc.sim'></span>

<h3>Description</h3>

<p>A permutation test for the spatial general cross product statistic with
Moran (<code class="reqn">C_{ij} = z_i z_j</code>), Geary 
(<code class="reqn">C_{ij} = (z_i - z_j)^2</code>), and Sokal 
(<code class="reqn">C_{ij} = |z_i - z_j|</code>) criteria, for
<code class="reqn">z_i = (x_i - \bar{x}) / \sigma_{x}</code>.
<code>plot.mc.sim</code> is a helper function to plot the outcomes of the
permutation test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp.mantel.mc(var, listw, nsim, type = "moran", zero.policy = attr(listw, "zero.policy"),
 alternative = "greater", spChk=NULL, return_boot=FALSE)
## S3 method for class 'mc.sim'
plot(x, xlim, xlab, main, sub, ..., ptype="density")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp.mantel.mc_+3A_var">var</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_nsim">nsim</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_type">type</code></td>
<td>
<p>&quot;moran&quot;, &quot;geary&quot; or &quot;sokal&quot; criteria for similarity</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without 
neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, 
must be one of &quot;greater&quot; (default), &quot;two.sided&quot;, or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_return_boot">return_boot</code></td>
<td>
<p>return an object of class <code>boot</code> from the equivalent permutation bootstrap rather than an object of class <code>htest</code></p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_x">x</code></td>
<td>
<p>the object to be plotted</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_xlim">xlim</code></td>
<td>
<p>the range of the x axis</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_main">main</code></td>
<td>
<p>an overall title for the plot</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_sub">sub</code></td>
<td>
<p>a sub title for the plot</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_ptype">ptype</code></td>
<td>
<p>either &quot;density&quot; or &quot;hist&quot;</p>
</td></tr>
<tr><td><code id="sp.mantel.mc_+3A_...">...</code></td>
<td>
<p>further arguments passed through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> and <code>mc.sim</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the observed Geary's C.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the rank of the observed Geary's C.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data, and the 
number of simulations.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the pseudo p-value of the test.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>nsim simulated values of statistic, final value is observed 
statistic</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the mean and variance of the simulated distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 22-24,
Haining, R. 1990 <em>Spatial data analysis in the social
and environmental sciences</em>, Cambridge: Cambridge University Press, p. 230&ndash;1.
The function has been checked against general matrix code posted to the 
r-help list by Ben Bolker on 1 May 2001; another <code>mantel()</code> function
is in the vegan package.</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran.mc">moran.mc</a></code>, <code><a href="#topic+joincount.mc">joincount.mc</a></code>, 
<code><a href="#topic+geary.mc">geary.mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
sim1 &lt;- sp.mantel.mc(COL.OLD$CRIME, nb2listw(COL.nb),
 nsim=99, type="geary", alternative="two.sided")
sim1
plot(sim1)
sp.mantel.mc(COL.OLD$CRIME, nb2listw(COL.nb), nsim=99,
 type="sokal", alternative="two.sided")
sp.mantel.mc(COL.OLD$CRIME, nb2listw(COL.nb), nsim=99,
 type="moran")
</code></pre>

<hr>
<h2 id='spdep'>Return package version number</h2><span id='topic+spdep'></span>

<h3>Description</h3>

<p>The function retreives package version and build information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdep(build = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spdep_+3A_build">build</code></td>
<td>
<p>if TRUE, also returns build information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with one or two elements
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>

<hr>
<h2 id='spdep-defunct'>Defunct Functions in Package <span class="pkg">spdep</span></h2><span id='topic+spdep-defunct'></span><span id='topic+lextrB'></span><span id='topic+lextrW'></span><span id='topic+lextrS'></span><span id='topic+l_max'></span><span id='topic+griffith_sone'></span><span id='topic+subgraph_eigenw'></span><span id='topic+mom_calc'></span><span id='topic+mom_calc_int2'></span><span id='topic+stsls'></span><span id='topic+print.stsls'></span><span id='topic+print.summary.stsls'></span><span id='topic+summary.stsls'></span><span id='topic+residuals.stsls'></span><span id='topic+coef.stsls'></span><span id='topic+deviance.stsls'></span><span id='topic+impacts.stsls'></span><span id='topic+GMerrorsar'></span><span id='topic+residuals.gmsar'></span><span id='topic+deviance.gmsar'></span><span id='topic+coef.gmsar'></span><span id='topic+fitted.gmsar'></span><span id='topic+print.gmsar'></span><span id='topic+summary.gmsar'></span><span id='topic+print.summary.gmsar'></span><span id='topic+Hausman.test.gmsar'></span><span id='topic+impacts.gmsar'></span><span id='topic+GMargminImage'></span><span id='topic+gstsls'></span><span id='topic+impacts.lagmess'></span><span id='topic+lagmess'></span><span id='topic+print.lagmess'></span><span id='topic+print.summary.lagmess'></span><span id='topic+summary.lagmess'></span><span id='topic+residuals.lagmess'></span><span id='topic+deviance.lagmess'></span><span id='topic+coef.lagmess'></span><span id='topic+fitted.lagmess'></span><span id='topic+logLik.lagmess'></span><span id='topic+ME'></span><span id='topic+print.ME_res'></span><span id='topic+fitted.ME_res'></span><span id='topic+SpatialFiltering'></span><span id='topic+print.SFResult'></span><span id='topic+fitted.SFResult'></span><span id='topic+LR.sarlm'></span><span id='topic+LR1.sarlm'></span><span id='topic+Wald1.sarlm'></span><span id='topic+Hausman.test'></span><span id='topic+Hausman.test.sarlm'></span><span id='topic+logLik.sarlm'></span><span id='topic+as.spam.listw'></span><span id='topic+as_dgRMatrix_listw'></span><span id='topic+as_dsTMatrix_listw'></span><span id='topic+as_dsCMatrix_I'></span><span id='topic+as_dsCMatrix_IrW'></span><span id='topic+Jacobian_W'></span><span id='topic+coerce+2Clistw+2CCsparseMatrix-method'></span><span id='topic+coerce+2Clistw+2CRsparseMatrix-method'></span><span id='topic+coerce+2Clistw+2CsymmetricMatrix-method'></span><span id='topic+powerWeights'></span><span id='topic+impacts.lagmess'></span><span id='topic+plot.lagImpact'></span><span id='topic+print.lagImpact'></span><span id='topic+summary.lagImpact'></span><span id='topic+print.summary.lagImpact'></span><span id='topic+HPDinterval.lagImpact'></span><span id='topic+can.be.simmed'></span><span id='topic+eigenw'></span><span id='topic+similar.listw'></span><span id='topic+do_ldet'></span><span id='topic+jacobianSetup'></span><span id='topic+eigen_setup'></span><span id='topic+eigen_pre_setup'></span><span id='topic+mcdet_setup'></span><span id='topic+cheb_setup'></span><span id='topic+spam_setup'></span><span id='topic+spam_update_setup'></span><span id='topic+Matrix_setup'></span><span id='topic+Matrix_J_setup'></span><span id='topic+LU_setup'></span><span id='topic+LU_prepermutate_setup'></span><span id='topic+moments_setup'></span><span id='topic+SE_classic_setup'></span><span id='topic+SE_whichMin_setup'></span><span id='topic+SE_interp_setup'></span><span id='topic+MCMCsamp'></span><span id='topic+MCMCsamp.spautolm'></span><span id='topic+MCMCsamp.sarlm'></span><span id='topic+spautolm'></span><span id='topic+residuals.spautolm'></span><span id='topic+deviance.spautolm'></span><span id='topic+coef.spautolm'></span><span id='topic+fitted.spautolm'></span><span id='topic+print.spautolm'></span><span id='topic+summary.spautolm'></span><span id='topic+LR1.spautolm'></span><span id='topic+logLik.spautolm'></span><span id='topic+print.summary.spautolm'></span><span id='topic+spBreg_sac'></span><span id='topic+impacts.MCMC_sar_g'></span><span id='topic+impacts.MCMC_sem_g'></span><span id='topic+impacts.MCMC_sac_g'></span><span id='topic+spBreg_err'></span><span id='topic+spBreg_lag'></span><span id='topic+predict.SLX'></span><span id='topic+lmSLX'></span><span id='topic+impacts.SLX'></span><span id='topic+create_WX'></span><span id='topic+anova.sarlm'></span><span id='topic+bptest.sarlm'></span><span id='topic+errorsarlm'></span><span id='topic+impacts'></span><span id='topic+impacts.sarlm'></span><span id='topic+intImpacts'></span><span id='topic+lagsarlm'></span><span id='topic+predict.sarlm'></span><span id='topic+print.sarlm.pred'></span><span id='topic+as.data.frame.sarlm.pred'></span><span id='topic+residuals.sarlm'></span><span id='topic+deviance.sarlm'></span><span id='topic+coef.sarlm'></span><span id='topic+vcov.sarlm'></span><span id='topic+fitted.sarlm'></span><span id='topic+sacsarlm'></span><span id='topic+summary.sarlm'></span><span id='topic+print.sarlm'></span><span id='topic+print.summary.sarlm'></span><span id='topic+trW'></span><span id='topic+aple.mc'></span><span id='topic+aple.plot'></span><span id='topic+localAple'></span><span id='topic+aple'></span>

<h3>Description</h3>

<p>These functions are defunct from release 1.2-1. The
functions have been moved to the <span class="pkg">spatialreg</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aple.plot()
localAple()
aple.mc()
aple()
lextrB()
lextrW()
lextrS()
griffith_sone()
subgraph_eigenw()
mom_calc()
mom_calc_int2()
stsls()
## S3 method for class 'stsls'
impacts()
GMerrorsar()
## S3 method for class 'gmsar'
summary()
gstsls() 
## S3 method for class 'gmsar'
impacts()
## S3 method for class 'gmsar'
Hausman.test()
lagmess()
ME()
SpatialFiltering()
LR.sarlm()
## S3 method for class 'sarlm'
logLik()
LR1.sarlm()
Wald1.sarlm()
## S3 method for class 'sarlm'
Hausman.test()
as.spam.listw()
as_dgRMatrix_listw()
as_dsTMatrix_listw()
as_dsCMatrix_I()
as_dsCMatrix_IrW()
Jacobian_W()
powerWeights()
## S3 method for class 'lagImpact'
plot()
## S3 method for class 'lagImpact'
print()
## S3 method for class 'lagImpact'
summary()
## S3 method for class 'lagImpact'
HPDinterval()
intImpacts()
can.be.simmed()
eigenw()
similar.listw()
do_ldet()
jacobianSetup()
cheb_setup()
mcdet_setup()
eigen_setup()
eigen_pre_setup()
spam_setup()
spam_update_setup()
Matrix_setup()
Matrix_J_setup()
LU_setup()
LU_prepermutate_setup()
moments_setup()
SE_classic_setup()
SE_whichMin_setup()
SE_interp_setup()
MCMCsamp()
## S3 method for class 'spautolm'
MCMCsamp()
## S3 method for class 'sarlm'
MCMCsamp()
spautolm()
## S3 method for class 'spautolm'
summary()
spBreg_sac()
## S3 method for class 'MCMC_sar_g'
impacts()
## S3 method for class 'MCMC_sem_g'
impacts()
## S3 method for class 'MCMC_sac_g'
impacts()
spBreg_err()
spBreg_lag()
## S3 method for class 'SLX'
predict()
lmSLX()
## S3 method for class 'SLX'
impacts()
create_WX()
## S3 method for class 'sarlm'
anova()
bptest.sarlm()
errorsarlm()
## S3 method for class 'sarlm'
impacts()
lagsarlm()
## S3 method for class 'sarlm'
predict()
## S3 method for class 'sarlm.pred'
print()
## S3 method for class 'sarlm.pred'
as.data.frame()
## S3 method for class 'sarlm'
residuals()
## S3 method for class 'sarlm'
deviance()
## S3 method for class 'sarlm'
coef()
## S3 method for class 'sarlm'
vcov()
## S3 method for class 'sarlm'
fitted()
sacsarlm()
## S3 method for class 'sarlm'
summary()
## S3 method for class 'sarlm'
print()
## S3 method for class 'summary.sarlm'
print()
trW()
</code></pre>


<h3>Details</h3>

<p>Model-fitting functions and functions supporting model fitting have been moved to the <span class="pkg">spatialreg</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Defunct">Defunct</a></code>
</p>

<hr>
<h2 id='spweights.constants'>Provides constants for spatial weights matrices</h2><span id='topic+spweights.constants'></span><span id='topic+Szero'></span>

<h3>Description</h3>

<p>The function calculates the constants needed for tests of spatial autocorrelation for general weights matrices represented as <code>listw</code> objects. Note: from spdep 0.3-32, the values of S1 and S2 are returned correctly for both underlying symmetric and asymmetric neighbour lists, before 0.3-32, S1 and S2 were wrong for listw objects based on asymmetric neighbour lists, such as k-nearest neighbours (thanks to Luc Anselin for finding the bug).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spweights.constants(listw, zero.policy=attr(listw, "zero.policy"), adjust.n=TRUE)
Szero(listw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spweights.constants_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object from for example <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="spweights.constants_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE ignore zones without neighbours, if FALSE fail when encountered</p>
</td></tr>
<tr><td><code id="spweights.constants_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>n</code></td>
<td>
<p>number of zones</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>n - 1</p>
</td></tr>
<tr><td><code>n2</code></td>
<td>
<p>n - 2</p>
</td></tr>
<tr><td><code>n3</code></td>
<td>
<p>n - 3</p>
</td></tr>
<tr><td><code>nn</code></td>
<td>
<p>n * n</p>
</td></tr>
<tr><td><code>S0</code></td>
<td>
<p>global sum of weights</p>
</td></tr>
<tr><td><code>S1</code></td>
<td>
<p>S1 sum of weights</p>
</td></tr>
<tr><td><code>S2</code></td>
<td>
<p>S2 sum of weights</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Haining, R. 1990 Spatial data analysis in the social and environmental sciences, Cambridge University Press, p. 233; Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 19, 21.</p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2listw">nb2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oldcol)
B &lt;- spweights.constants(nb2listw(COL.nb, style="B"))
W &lt;- spweights.constants(nb2listw(COL.nb, style="W"))
C &lt;- spweights.constants(nb2listw(COL.nb, style="C"))
S &lt;- spweights.constants(nb2listw(COL.nb, style="S"))
U &lt;- spweights.constants(nb2listw(COL.nb, style="U"))
print(data.frame(rbind(unlist(B), unlist(W), unlist(C), unlist(S), unlist(U)),
  row.names=c("B", "W", "C", "S", "U")))
</code></pre>

<hr>
<h2 id='ssw'>Compute the sum of dissimilarity</h2><span id='topic+ssw'></span>

<h3>Description</h3>

<p>This function computes the sum of dissimilarity between each 
observation and the mean (scalar of vector) of the observations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssw(data, id, method = c("euclidean", "maximum", 
    "manhattan", "canberra", "binary", "minkowski",
    "mahalanobis"), p = 2, cov, inverted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssw_+3A_data">data</code></td>
<td>
<p>A matrix with observations in the nodes.</p>
</td></tr>
<tr><td><code id="ssw_+3A_id">id</code></td>
<td>
<p>Node index to compute the cost</p>
</td></tr>
<tr><td><code id="ssw_+3A_method">method</code></td>
<td>
<p>Character or function to declare distance method.
If <code>method</code> is character, method must be &quot;mahalanobis&quot; or
&quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;
or &quot;minkowisk&quot;.
If <code>method</code> is one of &quot;euclidean&quot;, &quot;maximum&quot;,
&quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowisk&quot;, see
<code><a href="stats.html#topic+dist">dist</a></code> for details,
because this function as used to compute the distance.
If <code>method="mahalanobis"</code>, the mahalanobis distance
is computed between neighbour areas.
If <code>method</code> is a <code>function</code>, this function is
used to compute the distance.</p>
</td></tr>
<tr><td><code id="ssw_+3A_p">p</code></td>
<td>
<p>The power of the Minkowski distance.</p>
</td></tr>
<tr><td><code id="ssw_+3A_cov">cov</code></td>
<td>
<p>The covariance matrix used to compute the mahalanobis 
distance.</p>
</td></tr>
<tr><td><code id="ssw_+3A_inverted">inverted</code></td>
<td>
<p>logical.  If 'TRUE', 'cov' is supposed to contain the
inverse of the covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric, the sum of dissimilarity between the observations 
<code>id</code> of <code>data</code> and the mean (scalar of vector) of 
this observations.
</p>


<h3>Author(s)</h3>

<p>Elias T. Krainski and Renato M. Assuncao</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+nbcost">nbcost</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
n &lt;- nrow(USArrests)
ssw(USArrests, 1:n)
ssw(USArrests, 1:(n/2))
ssw(USArrests, (n/2+1):n)
ssw(USArrests, 1:(n/2)) + ssw(USArrests, (n/2+1):n)
</code></pre>

<hr>
<h2 id='subset.listw'>Subset a spatial weights list</h2><span id='topic+subset.listw'></span>

<h3>Description</h3>

<p>The function subsets a spatial weights list, retaining objects for which the subset argument vector is TRUE. At present it will only subset non-general weights lists (that is those created by <code>nb2listw</code> with <code>glist=NULL</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'listw'
subset(x, subset, zero.policy = attr(x, "zero.policy"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.listw_+3A_x">x</code></td>
<td>
<p>an object of class <code>listw</code></p>
</td></tr>
<tr><td><code id="subset.listw_+3A_subset">subset</code></td>
<td>
<p>logical expression</p>
</td></tr>
<tr><td><code id="subset.listw_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(x, "zero.policy")</code> as set when <code>x</code> was created, if attribute not set, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors - passed through to <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="subset.listw_+3A_...">...</code></td>
<td>
<p>generic function pass-through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>listw</code> with component <code>style</code> the same as the input object, component <code>neighbours</code> a list of integer vectors containing neighbour region number ids (compacted to run from 1:number of regions in subset), and component <code>weights</code> as the weights computed for <code>neighbours</code> using <code>style</code>. If no-neighbour observations are created by subsetting and <code>zero.policy</code> in the input weights object was FALSE, it will be set to TRUE and a warning issued.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2listw">nb2listw</a></code>, <code><a href="#topic+subset.nb">subset.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
to.be.dropped &lt;- c(31, 34, 36, 39, 42, 46)
pre &lt;- nb2listw(col.gal.nb)
print(pre)
post &lt;- subset(pre, !(1:length(col.gal.nb) %in% to.be.dropped))
print(post)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
nb &lt;- poly2nb(columbus)
lw &lt;- nb2listw(nb, style="W")
attr(lw, "zero.policy")
(lwa &lt;- subset(lw, 1:nrow(columbus) != c(21)))
attr(lwa, "zero.policy")
(lwb &lt;- subset(lw, !(1:nrow(columbus) %in% c(21, 36, 39))))
attr(lwb, "zero.policy")
</code></pre>

<hr>
<h2 id='subset.nb'>Subset a neighbours list</h2><span id='topic+subset.nb'></span>

<h3>Description</h3>

<p>The function subsets a neighbors list, retaining objects for which the subset argument vector is TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nb'
subset(x, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.nb_+3A_x">x</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="subset.nb_+3A_subset">subset</code></td>
<td>
<p>logical expression</p>
</td></tr>
<tr><td><code id="subset.nb_+3A_...">...</code></td>
<td>
<p>generic function pass-through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>nb</code> with a list of
integer vectors containing neighbour region number ids (compacted to
run from 1:number of regions in subset).
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nb2listw">nb2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_coordinates(st_centroid(columbus))
plot(col.gal.nb, coords)
to.be.dropped &lt;- c(31, 34, 36, 39, 42, 46)
text(coords[to.be.dropped,1], coords[to.be.dropped,2], labels=to.be.dropped,
  pos=2, offset=0.3)
sub.col.gal.nb &lt;- subset(col.gal.nb,
  !(1:length(col.gal.nb) %in% to.be.dropped))
plot(sub.col.gal.nb, coords[-to.be.dropped,], col="red", add=TRUE)
which(!(attr(col.gal.nb, "region.id") %in%
  attr(sub.col.gal.nb, "region.id")))
</code></pre>

<hr>
<h2 id='summary.nb'>Print and summary function for neighbours and weights lists</h2><span id='topic+summary.nb'></span><span id='topic+print.summary.nb'></span><span id='topic+print.nb'></span><span id='topic+summary.listw'></span><span id='topic+print.summary.listw'></span><span id='topic+print.listw'></span>

<h3>Description</h3>

<p>The function prints summary measures for links in a neighbours list. If a
matrix of coordinates is given as well, summary descriptive measures for
the link lengths are also printed. Print and summary functions are also available for <code>"listw"</code> weights list objects, also reporting constants (S0, S1, S2) used in inference for global spatial autocorrelation statistics such as Moran's I, Geary's C, join-count tests and Getis-Ord G.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nb'
summary(object, coords=NULL, longlat = NULL, scale = 1, ...)
## S3 method for class 'nb'
print(x, ...)
## S3 method for class 'listw'
summary(object, coords, longlat, zero.policy = attr(object, "zero.policy"), 
 scale = 1, adjust.n=TRUE, ...)
## S3 method for class 'listw'
print(x, zero.policy = attr(x, "zero.policy"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nb_+3A_object">object</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="summary.nb_+3A_coords">coords</code></td>
<td>
<p>matrix of region point coordinates or a SpatialPoints object or an <code>sfc</code> points object</p>
</td></tr>
<tr><td><code id="summary.nb_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometers; if coords is a SpatialPoints object, the value is taken from the object itself</p>
</td></tr>
<tr><td><code id="summary.nb_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the output produced</p>
</td></tr>
<tr><td><code id="summary.nb_+3A_x">x</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="summary.nb_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if FALSE stop with error for any empty neighbour sets</p>
</td></tr>
<tr><td><code id="summary.nb_+3A_scale">scale</code></td>
<td>
<p>passed through to <code>stem()</code> for control of plot length</p>
</td></tr>
<tr><td><code id="summary.nb_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations in <code>spweights.constants</code> is adjusted</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nb">plot.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
coords &lt;- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE)
col.gal.nb
summary(col.gal.nb, coords)
col.listw &lt;- nb2listw(col.gal.nb, style="W")
col.listw
summary(col.listw)
col_geoms &lt;- st_geometry(columbus)
col_geoms[21] &lt;- st_buffer(col_geoms[21], dist=-0.05)
st_geometry(columbus) &lt;- col_geoms
nb &lt;- poly2nb(columbus)
summary(nb)
try(nb2listw(nb, style="W"))
summary(nb2listw(nb, style="W", zero.policy=TRUE))
summary(nb2listw(nb, style="W", zero.policy=TRUE), adjust.n=FALSE)
</code></pre>

<hr>
<h2 id='tolerance.nb'> Function to construct edges based on a tolerance angle and a maximum distance </h2><span id='topic+tolerance.nb'></span>

<h3>Description</h3>

<p>This function creates an object of class <code>nb</code> (defined in the library spdep) containing a connexion diagram. The edges between sites are based on a tolerance angle and a maximum distance. The angle is directional; its direction is always from the bottow to the top of the screen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tolerance.nb(coords, unit.angle = "degrees", max.dist, tolerance, rot.angle,
 plot.sites=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tolerance.nb_+3A_coords">coords</code></td>
<td>
<p> A matrix or a data frame containing the X and Y coordinates of the study sites. </p>
</td></tr>
<tr><td><code id="tolerance.nb_+3A_unit.angle">unit.angle</code></td>
<td>
<p> Character. The measurement units in which angles are defined: either &quot;degrees&quot; (default) or &quot;radians&quot;. </p>
</td></tr>
<tr><td><code id="tolerance.nb_+3A_max.dist">max.dist</code></td>
<td>
<p> Numeric. The maximum distance of an edge linking two sites together. </p>
</td></tr>
<tr><td><code id="tolerance.nb_+3A_tolerance">tolerance</code></td>
<td>
<p> Numeric. The tolerance angle in which a site can influence another site. The angle is measured vertically and from bottom to top of the pictures after rotation of the points.</p>
</td></tr>
<tr><td><code id="tolerance.nb_+3A_rot.angle">rot.angle</code></td>
<td>
<p> Numeric, optional. An angle at which a set of coordinates should be rotated before creating the connexion diagram. The set of coordinates is rotated counterclockwise. Negative values will produce a clockwise rotation.</p>
</td></tr>
<tr><td><code id="tolerance.nb_+3A_plot.sites">plot.sites</code></td>
<td>
<p> Logical (<code>TRUE</code>, <code>FALSE</code>) determining if the site should be plotted in a graphic window. This graph allows one to make sure the points are rotated in a correct direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Even though this function creates a connexion diagram based on a tolerance angle going from the bottom to the top of the screen, the resulting object is symmetric, meaning that a site influences another and vice versa. The final object does not represent a directional connexion network. 
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>nb</code> with a list of integer vectors  corresponding to neighbour region numbers.
</p>


<h3>Warning</h3>

<p>This function was not design to handle a large number of rows in <code>coords</code>.
To use this function for a set of coordinates with more than 1500 entries is memory intensive.
</p>


<h3>Author(s)</h3>

<p> F. Guillaume Blanchet </p>


<h3>See Also</h3>

  <p><code><a href="#topic+dnearneigh">dnearneigh</a></code>, <code><a href="#topic+cell2nb">cell2nb</a></code>, <code><a href="#topic+graphneigh">graphneigh</a></code>, <code><a href="#topic+tri2nb">tri2nb</a></code>, <code><a href="#topic+knn2nb">knn2nb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
ex.data&lt;-cbind(runif(50),rexp(50))

### Construct object of class nb with a tolerance angle of 30 degrees
### and a maximum distance of 2 m.
nb.ex&lt;-tolerance.nb(ex.data, unit.angle = "degrees", max.dist=1,
 tolerance = 30)

### Construct object of class nb with a tolerance angle of 30 degrees
### and a maximum distance of 2 m. The coordinates are rotated at an angle
### of 45 degrees counterclockwise.
nb.ex2&lt;-tolerance.nb(ex.data, unit.angle = "degrees", max.dist=1,
 tolerance = 30, rot.angle = 45)

### Construct object of class nb with a tolerance angle of pi/8 radians
### and a maximum distance of 1.5 m. The coordinates are rotated at
### an angle of pi/4 radians clockwise.
nb.ex3&lt;-tolerance.nb(ex.data, unit.angle = "radians", max.dist=1.5,
 tolerance = pi/8, rot.angle = -pi*2/3)

par(mfrow=c(1,3))
plot(nb.ex,ex.data,asp=1)
plot(nb.ex2,ex.data,asp=1)
plot(nb.ex3,ex.data,asp=1)
</code></pre>

<hr>
<h2 id='tri2nb'>Neighbours list from tri object</h2><span id='topic+tri2nb'></span>

<h3>Description</h3>

<p>The function uses the <code>deldir</code> package to convert a matrix of
two-dimensional coordinates into a neighbours list of class <code>nb</code>
with a list of integer vectors containing neighbour region number
ids. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri2nb(coords, row.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri2nb_+3A_coords">coords</code></td>
<td>
<p>matrix, data.frame or tibble of point coordinates with two columns, a SpatialPoints object or an <code>sfc</code> points object</p>
</td></tr>
<tr><td><code id="tri2nb_+3A_row.names">row.names</code></td>
<td>
<p>character vector of region ids to be added to the neighbours list as attribute <code>region.id</code>, default <code>seq(1, nrow(x))</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If coordinates are duplicated, this function cannot be used.
If the coordinates are from a grid, then they need to be ordered
such that the first three are not collinear, so that the first triangle
can be constructed. This can be achieved by randomising the order of
the coordinates (possibly several times), and then re-ordering the order
of the data to match the new order of the neighbour list - if this fix
is used, remember to re-order the row.names argument as well as the
coordinates! Please also note that triangulation of grid points will
give arbitrary diagonal neighbours, which may not be a sensible outcome,
and <code>dnearneigh()</code> may serve better where <code>tri2nb()</code> cannot
be used.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+knn2nb">knn2nb</a></code>, <code><a href="#topic+dnearneigh">dnearneigh</a></code>, <code><a href="#topic+cell2nb">cell2nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
coords &lt;- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE)
ind &lt;- row.names(columbus)
suppressPackageStartupMessages(require(deldir))
col.tri.nb &lt;- tri2nb(coords, row.names=ind)
plot(st_geometry(columbus), border="grey")
plot(col.tri.nb, coords, add=TRUE)
title(main="Raw triangulation links", cex.main=0.6)
x &lt;- seq(0,1,0.1)
y &lt;- seq(0,2,0.2)
xy &lt;- expand.grid(x, y)
try(xy.nb &lt;- tri2nb(xy))
seed &lt;- 1234
xid &lt;- sample(1:nrow(xy))
xy.nb &lt;- tri2nb(xy[xid,])
plot(xy.nb, xy[xid,])
# example of reading points with readr::read_csv() yielding a tibble
load(system.file("etc/misc/coords.rda", package="spdep"))
class(coords)
nb &lt;- tri2nb(coords)
plot(nb, coords)
</code></pre>

<hr>
<h2 id='write.nb.gal'>Write a neighbours list as a GAL lattice file</h2><span id='topic+write.nb.gal'></span>

<h3>Description</h3>

<p>Write a neighbours list as a GAL lattice file, may also use newer GeoDa header format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.nb.gal(nb, file, oldstyle=TRUE, shpfile=NULL, ind=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.nb.gal_+3A_nb">nb</code></td>
<td>
<p>an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids.</p>
</td></tr>
<tr><td><code id="write.nb.gal_+3A_file">file</code></td>
<td>
<p>name of file with GAL lattice data</p>
</td></tr>
<tr><td><code id="write.nb.gal_+3A_oldstyle">oldstyle</code></td>
<td>
<p>if TRUE, first line of file contains only number of spatial units, if FALSE, uses newer GeoDa style</p>
</td></tr>
<tr><td><code id="write.nb.gal_+3A_shpfile">shpfile</code></td>
<td>
<p>Shapefile name taken from GAL file for this dataset</p>
</td></tr>
<tr><td><code id="write.nb.gal_+3A_ind">ind</code></td>
<td>
<p>region id indicator variable name</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read.gal">read.gal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>col.gal.nb &lt;- read.gal(system.file("weights/columbus.gal", package="spData")[1])
GALfile &lt;- tempfile("GAL")
write.nb.gal(col.gal.nb, GALfile)
col.queen &lt;- read.gal(GALfile)
summary(diffnb(col.queen, col.gal.nb))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
