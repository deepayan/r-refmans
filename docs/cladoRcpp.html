<!DOCTYPE html><html><head><title>Help for package cladoRcpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cladoRcpp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#areas_list_to_states_list_old'><p>Convert a list of areas to a list of geographic ranges (states); original R version</p></a></li>
<li><a href='#cladoRcpp-package'><p>Phylogenetic probability calculations using Rcpp</p></a></li>
<li><a href='#numstates_from_numareas'><p>Calculate the number of states, given a certain number of areas</p></a></li>
<li><a href='#rcpp_areas_list_to_states_list'><p>Make a list of 0-based indices of possible combinations of input areas</p></a></li>
<li><a href='#rcpp_calc_anclikes_sp'><p>Calculate probability of ancestral states below a speciation event, given probabilities of the states on each descendant branch</p></a></li>
<li><a href='#rcpp_calc_anclikes_sp_COOprobs'><p>Faster version of rcpp_calc_anclikes_sp</p></a></li>
<li><a href='#rcpp_calc_anclikes_sp_COOweights_faster'><p>Even faster version of rcpp_calc_anclikes_sp</p></a></li>
<li><a href='#rcpp_calc_anclikes_sp_prebyte'><p>Calculate probability of ancestral states below a speciation event, given probabilities of the states on each descendant branch</p></a></li>
<li><a href='#rcpp_calc_anclikes_sp_rowsums'><p>Calculate the number of cladogenesis events of nonzero probability for each ancestral state</p></a></li>
<li><a href='#rcpp_calc_anclikes_sp_using_COOprobs'><p>Calculate ancestral likelihoods given a COO-like probability matrix</p></a></li>
<li><a href='#rcpp_calc_rowsums_for_COOweights_columnar'><p>Calculate sum of weights for each ancestral state</p></a></li>
<li><a href='#rcpp_calc_splitlikes_using_COOweights_columnar'><p>Calculate the split likelihoods using <code>COO_weights_columnar</code></p></a></li>
<li><a href='#Rcpp_combn_zerostart'><p>Get all the combinations of descendent state pairs, in 0-based index form</p></a></li>
<li><a href='#rcpp_convolve'><p>Run C++ version of convolve(x,y, conj=TRUE, type=&quot;open&quot;)</p></a></li>
<li><a href='#rcpp_mult2probvect'><p>Get the product of multiplying each pair of values in a vector (cross-product)</p></a></li>
<li><a href='#rcpp_states_list_to_DEmat'><p>C++ conversion of a states list to a dispersal-extinction matrix (DEmat)</p></a></li>
<li><a href='#strsplit3'><p>String splitting shortcut</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>C++ Implementations of Phylogenetic Cladogenesis Calculations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.15.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-11-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas J. Matzke [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas J. Matzke &lt;nickmatzke.ncse@gmail.com&gt;</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Description:</td>
<td>Various cladogenesis-related calculations that are slow in pure R are implemented in C++ with Rcpp. These include the calculation of the probability of various scenarios for the inheritance of geographic range at the divergence events on a phylogenetic tree, and other calculations necessary for models which are not continuous-time markov chains (CTMC), but where change instead occurs instantaneously at speciation events.  Typically these models must assess the probability of every possible combination of (ancestor state, left descendent state, right descendent state).  This means that there are up to (# of states)^3 combinations to investigate, and in biogeographical models, there can easily be hundreds of states, so calculation time becomes an issue.  C++ implementation plus clever tricks (many combinations can be eliminated a priori) can greatly speed the computation time over naive R implementations.  CITATION INFO: This package is the result of my Ph.D. research, please cite the package if you use it!  Type: citation(package="cladoRcpp") to get the citation information.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://phylo.wikidot.com/biogeobears">http://phylo.wikidot.com/biogeobears</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-20 23:11:08 UTC; nmat471</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-11-21 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='areas_list_to_states_list_old'>Convert a list of areas to a list of geographic ranges (states); original R version</h2><span id='topic+areas_list_to_states_list_old'></span>

<h3>Description</h3>

<p>This is the original R version of the function which converts a list of possible areas to
a list of all possible states (geographic ranges).  This gets slow for large numbers of areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areas_list_to_states_list_old(areas = c("A", "B", "C"),
  maxareas = length(areas), include_null_range = TRUE,
  split_ABC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areas_list_to_states_list_old_+3A_areas">areas</code></td>
<td>
<p>a list of areas (character or number; the function converts these to numbers, starting with 0)</p>
</td></tr>
<tr><td><code id="areas_list_to_states_list_old_+3A_maxareas">maxareas</code></td>
<td>
<p>maximum number of areas in this analyses</p>
</td></tr>
<tr><td><code id="areas_list_to_states_list_old_+3A_include_null_range">include_null_range</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, should the <code>NULL</code> range be included in the possible states? (e.g., LAGRANGE default is yes)</p>
</td></tr>
<tr><td><code id="areas_list_to_states_list_old_+3A_split_abc">split_ABC</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> If <code>TRUE</code> the output will consist of a list of lists (c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;), c(&quot;A&quot;,&quot;B&quot;), c(&quot;A&quot;,&quot;D&quot;), etc.); 
if <code>FALSE</code>, the list of areas will be collapsed (&quot;ABC&quot;, &quot;AB&quot;, &quot;AD&quot;, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is mostly replaced by <code><a href="#topic+rcpp_areas_list_to_states_list">rcpp_areas_list_to_states_list</a></code> in optimized code, but is still used in some places
for display purposes.
</p>


<h3>Value</h3>

<p><code>states_list</code> A list of the states.
</p>


<h3>Note</h3>

<p>No notes.
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>References</h3>

<p><a href="http://phylo.wikidot.com/matzke-2013-international-biogeography-society-poster">http://phylo.wikidot.com/matzke-2013-international-biogeography-society-poster</a>
<a href="https://code.google.com/p/lagrange/">https://code.google.com/p/lagrange/</a>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
@cite ReeSmith2008
</p>


<h3>See Also</h3>

<p><code><a href="#topic+numstates_from_numareas">numstates_from_numareas</a></code>, <code><a href="#topic+rcpp_areas_list_to_states_list">rcpp_areas_list_to_states_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>areas = c("A","B","C")
areas_list_to_states_list_old(areas=areas, maxareas=length(areas), 
include_null_range=TRUE, split_ABC=TRUE)
areas_list_to_states_list_old(areas=areas, maxareas=length(areas), 
include_null_range=TRUE, split_ABC=FALSE)
areas_list_to_states_list_old(areas=areas, maxareas=length(areas), 
include_null_range=FALSE, split_ABC=TRUE)
areas_list_to_states_list_old(areas=areas, maxareas=length(areas), 
include_null_range=FALSE, split_ABC=FALSE)
areas_list_to_states_list_old(areas=areas, maxareas=2, 
include_null_range=TRUE, split_ABC=TRUE)
areas_list_to_states_list_old(areas=areas, maxareas=2, 
include_null_range=TRUE, split_ABC=FALSE)
areas_list_to_states_list_old(areas=areas, maxareas=2, 
include_null_range=FALSE, split_ABC=TRUE)
areas_list_to_states_list_old(areas=areas, maxareas=2, 
include_null_range=FALSE, split_ABC=FALSE)
areas_list_to_states_list_old(areas=areas, maxareas=1, 
include_null_range=TRUE, split_ABC=TRUE)
areas_list_to_states_list_old(areas=areas, maxareas=1, 
include_null_range=TRUE, split_ABC=FALSE)
areas_list_to_states_list_old(areas=areas, maxareas=1, 
include_null_range=FALSE, split_ABC=TRUE)
areas_list_to_states_list_old(areas=areas, maxareas=1, 
include_null_range=FALSE, split_ABC=FALSE)

</code></pre>

<hr>
<h2 id='cladoRcpp-package'>Phylogenetic probability calculations using Rcpp</h2><span id='topic+cladoRcpp'></span><span id='topic+cladoRcpp-package'></span><span id='topic+cladorcpp'></span><span id='topic+cladorcpp-package'></span>

<h3>Description</h3>

<p>Cladogenic probability calculations using Rcpp
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> cladoRcpp</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;">
  Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;"> 0.15.1</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;">
  2018-11-21</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;"> LazyLoad: </td><td style="text-align: left;">
  yes</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p><b>Summary:</b> This package implements in C++/Rcpp
various cladogenesis-related calculations that are slow
in pure R. These include the calculation of the
probability of various scenarios for the inheritance of
geographic range at the divergence events on a
phylogenetic tree, and other calculations necessary for
models which are not continuous-time markov chains
(CTMC), but where change instead occurs instantaneously
at speciation events.  Typically these models must assess
the probability of every possible combination of
(ancestor state, left descendent state, right descendent
state).  This means that there are up to (# of states)^3
combinations to investigate, and in biogeographical
models, there can easily be hundreds of states, so
calculation time becomes an issue.  C++ implementation
plus clever tricks (many combinations can be eliminated a
priori) can greatly speed the computation time over naive
R implementations.
</p>
<p>CITATION INFO: This package is the result of my Ph.D.
research, please cite the package if you use it! Type:
<code>citation(package="cladoRcpp")</code> to get the citation
information.
</p>
<p>See also the citation information for the sister
packages, <code>citation(package="rexpokit")</code> and
<code>citation(package="BioGeoBEARS")</code>
</p>
<p><b>Further information:</b> In particular, in
<code>cladoRcpp</code>, functions are implemented to calculate
the probability, given a model, of various scenarios for
the inheritance of geographic range at speciation events,
where the left and right branches may inherit ranges
different from each other and different from the
ancestor.
</p>
<p>The documentation for
<code><a href="#topic+rcpp_areas_list_to_states_list">rcpp_areas_list_to_states_list</a></code>, and
<code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> contain the basic
introduction to the logic of ancestral states and
cladogenesis probabilities with historical-biogeography
models.
</p>
<p>The widely-used historical biogeography program
<code>LAGRANGE</code> (Ree &amp; Smith 2008) has only one
cladogenesis model, which is fixed and therefore not
subject to inference. LAGRANGE's cladogenesis model gives
equal weight/equal probability to all allowed
cladogenesis events.  LAGRANGE allows:
</p>
<p><b>1.</b> sympatric speciation (copying the ancestral
range to descendant ranges), but only for ranges of
size=1 area<br /> <b>2.</b> vicariant speciation (the
descendant range is divided between the 2 descendant
species), but at least one of the descendants must have a
ranges of size=1 area<br /> <b>3.</b> sympatric &quot;subset&quot;
speciation (one species starts inside the ancestral
range, the other inherits the ancestral range); again,
one of the descendants must have a ranges of size=1
area<br />
</p>
<p>But, another range inheritance scenario is imaginable:
</p>
<p><b>4.</b> founder-event speciation, where one descendant
species inherits the ancestral range, and the other
species has a range completely outside of the ancestral
range
</p>
<p><code>cladoRcpp</code> allows specification of these different
models, including allowing different weights for the
different processes, if users would like to infer the
optimal model, rather than simply fixing it ahead of
time.  The optimization and model choice is done with the
help of the sister packages, <code>rexpokit</code> and
<code>BioGeoBEARS</code>.
</p>
<p><em>Note:</em> I began this package with a little bit of
code from Rcpp and the various examples that have been
written with it, as well as from the following:
</p>
<p>1. phyloRcppExamples by Vladimir Minin
(https://r-forge.r-project.org/scm/viewvc.php/pkg/phyloRcppExamples/?root=evolmod
and
http://markovjumps.blogspot.com/2012/01/packaging-and-exposing-rcpp-functions.html)
&ndash; which shows how to do phylogenetic operations in C++,
accessed with R
</p>
<p>2. rcppbugs by Whit Armstrong
(https://github.com/armstrtw/rcppbugs and
http://cran.r-project.org/web/packages/rcppbugs/index.html)
&ndash; which does BUGS-style MCMC via C++ functions wrapped
in R.  It does this much faster than MCMCpack and rjags.
</p>


<h3>Note</h3>

<p>Some starting code borrowed from Rcpp examples, Whit
Armstrong's rcppbugs, and Vladimir Minin's
phyloRcppExamples.
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>References</h3>

<p><a href="http://phylo.wikidot.com/biogeobears">http://phylo.wikidot.com/biogeobears</a>
</p>
<p>Matzke N (2012). &quot;Founder-event speciation in BioGeoBEARS
package dramatically improves likelihoods and alters
parameter inference in Dispersal-Extinction-Cladogenesis
(DEC) analyses.&quot; _Frontiers of Biogeography_, *4*(suppl.
1), pp. 210. ISSN 1948-6596, Poster abstract published in
the Conference Program and Abstracts of the International
Biogeography Society 6th Biannual Meeting, Miami,
Florida. Poster Session P10: Historical and
Paleo-Biogeography. Poster 129B. January 11, 2013, &lt;URL:
<a href="http://phylo.wikidot.com/matzke-2013-international-biogeography-society-poster">http://phylo.wikidot.com/matzke-2013-international-biogeography-society-poster</a>&gt;.
</p>
<p>Ree RH, Moore BR, Webb CO and Donoghue MJ (2005). &quot;A
likelihood framework for inferring the evolution of
geographic range on phylogenetic trees.&quot; _Evolution_,
*59*(11), pp. 2299-311. Ree, Richard H Moore, Brian R
Webb, Campbell O Donoghue, Michael J Research Support,
U.S. Gov't, Non-P.H.S. United States Evolution;
international journal of organic evolution Evolution.
2005 Nov;59(11):2299-311., &lt;URL:
http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&amp;db=PubMed&amp;dopt=Citation&amp;list_uids=16396171&gt;.
</p>
<p>Ree RH and Smith SA (2008). &quot;Maximum likelihood inference
of geographic range evolution by dispersal, local
extinction, and cladogenesis.&quot; _Systematic Biology_,
*57*(1), pp. 4-14. &lt;URL:
http://dx.doi.org/10.1080/10635150701883881&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&amp;db=PubMed&amp;dopt=Citation&amp;list_uids=18253896&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>,
<code><a href="#topic+rcpp_areas_list_to_states_list">rcpp_areas_list_to_states_list</a></code>, Rcpp,
RcppArmadillo
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To get citation information for cladoRcpp, type:
citation(package="cladoRcpp")

# Please also cite the sister packages I created to utilize rexpokit:
# citation(package="rexpokit")		# Roger Sidje is a coauthor
                                 	# of rexpokit and author of
                                 	# the FORTRAN EXPOKIT
# citation(package="BioGeoBEARS")

library(cladoRcpp)
# Test this first as it causes problems for --gct or --use-valgrind
areas_list = c("A", "B", "C")
areas_list

# Calculate the list of 0-based indices for each possible
# geographic range, i.e. each combination of areas
## Not run: 

states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=3,
include_null_range=FALSE)


## End(Not run)

#################################################################################
# Examples using C++ to speed up the slow step of getting all possible combinations
# of areas (important when when number_of_areas &gt;= 7, as this can mean
# 2^number_of_areas states, and (2^number_of_areas)^2 imaginable descendant pairs
# from each ancestral state.
#################################################################################

#######################################################
# Set up 2 vectors, then convolve them
#######################################################
ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)
rcpp_convolve(a=ca, b=cb)
#'
# Same as:
convolve(ca, cb, conj=TRUE, type="open")



#######################################################
# Cross-products
#######################################################
ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)
rcpp_mult2probvect(a=ca, b=cb)

# Same as:
c(ca %o% cb)

# Or:
outer(ca, cb)
c(outer(ca, cb))

# Or:
tcrossprod(ca, cb)
c(tcrossprod(ca, cb))





#################################################################################
# Calculate the number of states (i.e., number of difference geographic ranges,
# i.e. number of different combinations of presence/absence in areas) based on
# the number of areas
#################################################################################
numstates_from_numareas(numareas=3, maxareas=3, include_null_range=FALSE)
numstates_from_numareas(numareas=3, maxareas=3, include_null_range=TRUE)
numstates_from_numareas(numareas=3, maxareas=2, include_null_range=TRUE)
numstates_from_numareas(numareas=3, maxareas=1, include_null_range=TRUE)
numstates_from_numareas(numareas=7, maxareas=7, include_null_range=TRUE)
numstates_from_numareas(numareas=7, maxareas=2, include_null_range=TRUE)
numstates_from_numareas(numareas=8, maxareas=8, include_null_range=TRUE)
numstates_from_numareas(numareas=8, maxareas=2, include_null_range=TRUE)
numstates_from_numareas(numareas=20, maxareas=20, include_null_range=TRUE)
numstates_from_numareas(numareas=20, maxareas=2, include_null_range=TRUE)
numstates_from_numareas(numareas=20, maxareas=3, include_null_range=TRUE)




#################################################################################
# Generate the list of states based on the list of areas
# And then generate the continuous-time transition matrix (Q matrix)
# for changes that happen along branches
# (the changes that happen at nodes are cladogenesis events)
#################################################################################
# Specify the areas
areas_list = c("A", "B", "C")
areas_list

# Let's try Rcpp_combn_zerostart, in case that is the source of a
# problem found via AddressSanitizer
Rcpp_combn_zerostart(n_to_choose_from=4, k_to_choose=2, maxlim=1e+07)
Rcpp_combn_zerostart(n_to_choose_from=4, k_to_choose=3, maxlim=1e+07)


# Calculate the list of 0-based indices for each possible
# geographic range, i.e. each combination of areas
## Not run: 

states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=3,
include_null_range=FALSE)
states_list
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=3,
include_null_range=TRUE)
states_list
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=2,
include_null_range=TRUE)
states_list
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=1,
include_null_range=TRUE)
states_list


## End(Not run)

# Hard-code the along-branch dispersal and extinction rates
d = 0.2
e = 0.1

# Calculate the dispersal weights matrix and the extinction weights matrix
# Equal dispersal in all directions (unconstrained)
areas = areas_list
distances_mat = matrix(1, nrow=length(areas), ncol=length(areas))
dmat = matrix(d, nrow=length(areas), ncol=length(areas))
dmat

# Equal extinction probability for all areas
elist = rep(e, length(areas))
elist

# Set up the instantaneous rate matrix (Q matrix, Qmat)
# DON'T force a sparse-style (COO-formatted) matrix here
## Not run: 

force_sparse = FALSE
Qmat = rcpp_states_list_to_DEmat(areas_list, states_list, dmat, elist,
include_null_range=TRUE, normalize_TF=TRUE, makeCOO_TF=force_sparse)
Qmat

# DO force a sparse-style (COO-formatted) matrix here
force_sparse = TRUE
Qmat = rcpp_states_list_to_DEmat(areas_list, states_list, dmat, elist,
include_null_range=TRUE, normalize_TF=TRUE, makeCOO_TF=force_sparse)
Qmat

## End(Not run)








#################################################################################
# Calculate the probability of each (ancestral range) --&gt;
# (Left,Right descendant range pair) directly
#################################################################################

#######################################################
# Silly example, but which shows the math:
#######################################################
ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# Another silly example, but which shows the normalization effect of specifying
# Rsp_rowsums:
ca_1s = c(1,1,1,1,1)
cb_1s = c(1,1,1,1,1)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))

# Get the Rsp_rowsums (sum across each row; each row=an ancestral state)
Rsp_rowsums = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca_1s, Rcpp_rightprobs=cb_1s,
l=temp_states_indices,  s=0.33, v=0.33, j=0, y=0.33, printmat=TRUE)
Rsp_rowsums

condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

#######################################################
# Silly example, but which shows the math -- redo with same cladogenesis model,
# specified differently
#######################################################
ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=0.33, v=0.33, j=0, y=0.33, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# Another silly example, but which shows the normalization effect of specifying
# Rsp_rowsums:
ca_1s = c(1,1,1,1,1)
cb_1s = c(1,1,1,1,1)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))

# Get the Rsp_rowsums (sum across each row; each row=an ancestral state)
Rsp_rowsums = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca_1s, Rcpp_rightprobs=cb_1s,
l=temp_states_indices,  s=0.33, v=0.33, j=0, y=0.33, printmat=TRUE)
Rsp_rowsums

condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=0.33, v=0.33, j=0, y=0.33,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state



#######################################################
# Silly example, but which shows the math -- redo with different cladogenesis model
# (sympatric-copying only, maximum range size of 1)
#######################################################
ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=0, v=0, j=0, y=1, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# Another silly example, but which shows the normalization effect of specifying
# Rsp_rowsums:
ca_1s = c(1,1,1,1,1)
cb_1s = c(1,1,1,1,1)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))

# Get the Rsp_rowsums (sum across each row; each row=an ancestral state)
Rsp_rowsums = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca_1s, Rcpp_rightprobs=cb_1s,
l=temp_states_indices,  s=0, v=0, j=0, y=1, printmat=TRUE)
Rsp_rowsums

# Note that you get NaNs because some of your states (2 areas) are impossible on
# this model
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=0, v=0, j=0, y=1,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state



#######################################################
# Silly example, but which shows the math -- redo with different
# cladogenesis model (BayArea, sympatric-copying only)
#######################################################
ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
numareas = 3
	maxent01y = matrix(0, nrow = numareas, ncol = numareas)
	maxent01y[, 1] = seq(1, numareas)
	maxent01y[2:3, 2] = seq(2, numareas)
	maxent01y[3, 3] = seq(3, numareas)

condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=0, v=0, j=0, y=1, maxent01y=maxent01y,
max_minsize_as_function_of_ancsize=rep(3,numareas), printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# Another silly example, but which shows the normalization effect of specifying
# Rsp_rowsums:
ca_1s = c(1,1,1,1,1)
cb_1s = c(1,1,1,1,1)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))

# Get the Rsp_rowsums (sum across each row; each row=an ancestral state)
Rsp_rowsums = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca_1s, Rcpp_rightprobs=cb_1s,
l=temp_states_indices, s=0, v=0, j=0, y=1, maxent01y=maxent01y,
max_minsize_as_function_of_ancsize=rep(3,numareas), printmat=TRUE)
Rsp_rowsums

condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=0, v=0, j=0, y=1, maxent01y=maxent01y,
max_minsize_as_function_of_ancsize=rep(3,numareas), printmat=TRUE)
condlike_of_data_for_each_ancestral_state











#######################################################
# Actual example
#######################################################
# When ca &amp; cb are 1s, and s, v, j, y are 1s or 0s:
# ...this shows how many possible descendant pairs are possible from each
# possible ancestor, under the model
# i.e., how many specific cladogenesis scenarios are possible from each
# possible ancestor
# This is the LAGRANGE model
ca = c(1,1,1,1,1)
cb = c(1,1,1,1,1)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
Rsp_rowsums = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca, Rcpp_rightprobs=cb,
l=temp_states_indices, s=1, v=1, j=0, y=1, printmat=TRUE)
Rsp_rowsums

# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches ARE equal
# WITHOUT the weights correction
ca = c(0.2,0.2,0.2,0.2,0.2)
cb = c(0.2,0.2,0.2,0.2,0.2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# WITH the weights correction
ca = c(0.2,0.2,0.2,0.2,0.2)
cb = c(0.2,0.2,0.2,0.2,0.2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state



# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches are NOT equal
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# WITH the weights correction
# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches ARE equal
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches are NOT equal
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state








#######################################################
# Actual example -- for another model (allowing jump dispersal equal probability
# with the rest)
#######################################################
# When ca &amp; cb are 1s, and s, v, j, y are 1s or 0s:
# ...this shows how many possible descendant pairs are possible from each possible
# ancestor, under the model
# i.e., how many specific cladogenesis scenarios are possible from each possible
# ancestor
# This is the LAGRANGE model
ca = c(1,1,1,1,1)
cb = c(1,1,1,1,1)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
Rsp_rowsums = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca, Rcpp_rightprobs=cb,
l=temp_states_indices, s=1, v=1, j=1, y=1, printmat=TRUE)
Rsp_rowsums

# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches ARE equal
# WITHOUT the weights correction
ca = c(0.2,0.2,0.2,0.2,0.2)
cb = c(0.2,0.2,0.2,0.2,0.2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=1, y=1, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# WITH the weights correction
ca = c(0.2,0.2,0.2,0.2,0.2)
cb = c(0.2,0.2,0.2,0.2,0.2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=1, y=1,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state



# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches are NOT equal
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=1, y=1, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# WITH the weights correction
# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches ARE equal
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=1, y=1,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state

# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches are NOT equal
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=1, y=1, Rsp_rowsums=Rsp_rowsums,
printmat=TRUE)
condlike_of_data_for_each_ancestral_state
















#######################################################
# Calculate the sums of each row (i.e. for each ancestral state) --
# changes only based on the model
#######################################################
# Standard LAGRANGE model
# Rcpp_leftprobs=ca, Rcpp_rightprobs=cb are irrelevant except for length,
# rcpp_calc_anclikes_sp_rowsums() actually treats them as arrays of 1s
# if s, v, j, y are 1s or 0s, then Rsp_rowsums = counts of the events
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
Rsp_rowsums = rcpp_calc_anclikes_sp_rowsums(Rcpp_leftprobs=ca, Rcpp_rightprobs=cb,
l=temp_states_indices, s=1, v=1, j=0, y=1, printmat=TRUE)
Rsp_rowsums

# Standard LAGRANGE model, adding jump dispersal
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
Rsp_rowsums = rcpp_calc_anclikes_sp_rowsums(Rcpp_leftprobs=ca, Rcpp_rightprobs=cb,
l=temp_states_indices, s=1, v=1, j=1, y=1, printmat=TRUE)
Rsp_rowsums

# Same models, parameterized differently
# Allowing jump dispersal to areas outside of the ancestral range
Rsp_rowsums = rcpp_calc_anclikes_sp_rowsums(Rcpp_leftprobs=ca, Rcpp_rightprobs=cb,
l=temp_states_indices, s=0.5, v=0.5, j=0, y=0.5, printmat=TRUE)
Rsp_rowsums

# Allowing jump dispersal to areas outside of the ancestral range
Rsp_rowsums = rcpp_calc_anclikes_sp_rowsums(Rcpp_leftprobs=ca, Rcpp_rightprobs=cb,
l=temp_states_indices, s=0.5, v=0.5, j=0.5, y=0.5, printmat=TRUE)
Rsp_rowsums






#######################################################
# The relative weights of the different types of cladogenesis events doesn't matter,
# if the correction factor is included
#######################################################

# LAGRANGE+founder-event speciation
# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches are NOT equal
# s,v,j,y weights set to 1
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
uncorrected_condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(
Rcpp_leftprobs=ca, Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=1, y=1,
printmat=TRUE)
uncorrected_condlike_of_data_for_each_ancestral_state

Rsp_rowsums = rcpp_calc_anclikes_sp_rowsums(Rcpp_leftprobs=ca, Rcpp_rightprobs=cb,
l=temp_states_indices, s=1, v=1, j=1, y=1, printmat=TRUE)
Rsp_rowsums

condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=1, y=1,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state


# s,v,j,y weights set to 0.5
ca = c(0.05,0.1,0.15,0.2,0.5)
cb = c(0.05,0.1,0.15,0.2,0.5)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
uncorrected_condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(
Rcpp_leftprobs=ca, Rcpp_rightprobs=cb, l=temp_states_indices, s=0.5, v=0.5, j=0.5,
y=0.5, printmat=TRUE)
uncorrected_condlike_of_data_for_each_ancestral_state

Rsp_rowsums = rcpp_calc_anclikes_sp_rowsums(Rcpp_leftprobs=ca, Rcpp_rightprobs=cb,
l=temp_states_indices, s=0.5, v=0.5, j=0.5, y=0.5, printmat=TRUE)
Rsp_rowsums

condlike_of_data_for_each_ancestral_state = rcpp_calc_anclikes_sp(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=0.5, v=0.5, j=0.5, y=0.5,
Rsp_rowsums=Rsp_rowsums, printmat=TRUE)
condlike_of_data_for_each_ancestral_state







#######################################################
# For large state spaces (many areas, a great many possible geographic ranges i.e.
# combinations of areas),
# rcpp_calc_anclikes_sp() gets slow, even with C++ implementation, as it loops
# through every possible combination
# of ancestral and descendant states.  rcpp_calc_anclikes_sp_COOprobs() is a partial
# speedup which takes various shortcuts.
#
# Instead of having the weights/probabilites represented internally, and producing
# the conditional likelihoods as output,
# rcpp_calc_anclikes_sp_COOprobs() produces 3 lists, giving the coordinates of
# nonzero cells in the transition matrix.
#
# List #1: 0-based index of states on the Left branch, for each of the ancestral
# states
# List #2: 0-based index of states on the Right branch, for each of the ancestral
# states
# List #3: Weight of each transition, for each of the ancestral states
#######################################################


# Silly example, but which shows the math:
ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
list_weights_of_transitions = rcpp_calc_anclikes_sp_COOprobs(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1, printmat=TRUE)
list_weights_of_transitions

# List #1: 0-based index of states on the Left branch, for each of the ancestral states
# List #2: 0-based index of states on the Right branch, for each of the ancestral
# states
# List #3: Weight of each transition, for each of the ancestral states



# Get the Rsp_rowsums (sums of the rows of the cladogenesis P matrix)
# Set the weights to 1
ca = c(1,1,1,1,1)
cb = c(1,1,1,1,1)
COO_probs_list_for_rowsums = rcpp_calc_anclikes_sp_COOprobs(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1, printmat=TRUE)
COO_probs_list_for_rowsums
Rsp_rowsums = sapply(X=COO_probs_list_for_rowsums[[3]], FUN=sum)
Rsp_rowsums


# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches ARE equal
ca = c(0.2,0.2,0.2,0.2,0.2)
cb = c(0.2,0.2,0.2,0.2,0.2)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
COO_weights_list = rcpp_calc_anclikes_sp_COOprobs(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1, printmat=TRUE)
COO_weights_list

COO_weights_list_rowsums = sapply(X=COO_probs_list_for_rowsums[[3]], FUN=sum)
COO_weights_list_rowsums

# To see the transitional probabilities for each ancestral state, under the model:
COO_format_transition_probability_matrix = COO_probs_list_for_rowsums

for (i in 1:length(COO_format_transition_probability_matrix[[3]]))
	{
	COO_format_transition_probability_matrix[[3]][[i]] =
 COO_format_transition_probability_matrix[[3]][[i]] / COO_weights_list_rowsums[[i]]
	}
COO_format_transition_probability_matrix

# And you can see that the probabilities now sum to 1 for each row
sapply(X=COO_format_transition_probability_matrix[[3]], FUN=sum)




# The following is what you would get for the conditional likelihoods of the
# data given each ancestral state, WITHOUT making each row
# of the transition matrix sum to 1
uncorrected_COO_condlikes_list = rcpp_calc_anclikes_sp_using_COOprobs(
Rcpp_leftprobs=ca, Rcpp_rightprobs=cb, RCOO_left_i_list=COO_weights_list[[1]],
RCOO_right_j_list=COO_weights_list[[2]], RCOO_probs_list=COO_weights_list[[3]],
Rsp_rowsums=rep(1,length(ca)), printmat=TRUE)
uncorrected_COO_condlikes_list

# This is what you get if you correct, so that each row sums to 1,
# using the sums of the rows to normalize
corrected_COO_condlikes_list = rcpp_calc_anclikes_sp_using_COOprobs(
Rcpp_leftprobs=ca, Rcpp_rightprobs=cb, RCOO_left_i_list=COO_weights_list[[1]],
RCOO_right_j_list=COO_weights_list[[2]], RCOO_probs_list=COO_weights_list[[3]],
Rsp_rowsums=COO_weights_list_rowsums, printmat=TRUE)
corrected_COO_condlikes_list





#################################################################################
# rcpp_calc_anclikes_sp_COOweights_faster():
# An even faster method "intelligently" looks for allowed transitions with
# nonzero weights
# The output is stored in 4 lists / columns in COO_weights_columnar:
# List #1. 0-based index of ancestral states / geographic ranges
# List #2. 0-based index of Left descendant states / geographic ranges
# List #3. 0-based index of Right descendant states / geographic ranges
# List #4. Weight (or probability, if each weight has been divided by the sum
# of the weights for the row) of the
#    transition specified by that cell.
#################################################################################




# Get the Rsp_rowsums (sums of the rows of the cladogenesis P matrix)
# Set the weights to 1
ca = c(1,1,1,1,1) # ca and cb don't matter here, since we are just calculating
# the weights
cb = c(1,1,1,1,1)
temp_states_indices = list(c(0), c(1), c(2), c(0,1), c(1,2))
COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(
Rcpp_leftprobs=ca, Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1,
j=0, y=1, printmat=TRUE)
COO_weights_columnar

# List #1. 0-based index of ancestral states / geographic ranges
# List #2. 0-based index of Left descendant states / geographic ranges
# List #3. 0-based index of Right descendant states / geographic ranges
# List #4. Weight (or probability, if each weight has been divided by the
# sum of the weights for the row) of the
#    transition specified by that cell.

# Calculate the sums of the weights for each row/ancestral state
numstates = 1+max(sapply(X=COO_weights_columnar, FUN=max)[1:3])
Rsp_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(
COO_weights_columnar=COO_weights_columnar, numstates=numstates)
Rsp_rowsums



# Silly example, but which shows the math:
ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)

# WITHOUT using appropriate correction (correction = dividing by the
# sum of the weights for each row)
uncorrected_condlikes_list = rcpp_calc_splitlikes_using_COOweights_columnar(
Rcpp_leftprobs=ca, Rcpp_rightprobs=cb, COO_weights_columnar=COO_weights_columnar,
Rsp_rowsums=rep(1,numstates), printmat=TRUE)
uncorrected_condlikes_list

# WITH using appropriate correction (correction = dividing by the sum
# of the weights for each row)
corrected_condlikes_list = rcpp_calc_splitlikes_using_COOweights_columnar(
Rcpp_leftprobs=ca, Rcpp_rightprobs=cb, COO_weights_columnar=COO_weights_columnar,
Rsp_rowsums, printmat=TRUE)
corrected_condlikes_list




# Calculate likelihoods of ancestral states if probabilities of each state
# at the base of the left and right branches ARE equal
# Get the Rsp_rowsums (sums of the rows of the cladogenesis P matrix)
# Set the weights to 1
ca = c(0.2,0.2,0.2,0.2,0.2) # ca and cb don't matter here, since we are just
# calculating the weights
cb = c(0.2,0.2,0.2,0.2,0.2)
COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=ca,
Rcpp_rightprobs=cb, l=temp_states_indices, s=1, v=1, j=0, y=1, printmat=TRUE)
COO_weights_columnar

# List #1. 0-based index of ancestral states / geographic ranges
# List #2. 0-based index of Left descendant states / geographic ranges
# List #3. 0-based index of Right descendant states / geographic ranges
# List #4. Weight (or probability, if each weight has been divided by the
# sum of the weights for the row) of the
#    transition specified by that cell.

# Calculate the sums of the weights for each row/ancestral state
numstates = 1+max(sapply(X=COO_weights_columnar, FUN=max)[1:3])
Rsp_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(
COO_weights_columnar=COO_weights_columnar, numstates=numstates)
Rsp_rowsums


# WITHOUT using appropriate correction (correction = dividing by
# the sum of the weights for each row)
uncorrected_condlikes_list = rcpp_calc_splitlikes_using_COOweights_columnar(
Rcpp_leftprobs=ca, Rcpp_rightprobs=cb, COO_weights_columnar=COO_weights_columnar,
Rsp_rowsums=rep(1,numstates), printmat=TRUE)
uncorrected_condlikes_list

# WITH using appropriate correction (correction = dividing by the sum of the
# weights for each row)
corrected_condlikes_list = rcpp_calc_splitlikes_using_COOweights_columnar(
Rcpp_leftprobs=ca, Rcpp_rightprobs=cb, COO_weights_columnar=COO_weights_columnar,
Rsp_rowsums, printmat=TRUE)
corrected_condlikes_list
</code></pre>

<hr>
<h2 id='numstates_from_numareas'>Calculate the number of states, given a certain number of areas</h2><span id='topic+numstates_from_numareas'></span>

<h3>Description</h3>

<p>This function calculates the number of discrete states that are needed to 
represent the possible combinations of presence and absence in a set of 
discrete areas.  The number of states is a function of the number of areas,
and the maximum allowed range size (in number of areas) of a species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numstates_from_numareas(numareas = 3, maxareas = numareas,
  include_null_range = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numstates_from_numareas_+3A_numareas">numareas</code></td>
<td>
<p>The number of areas in the analysis.</p>
</td></tr>
<tr><td><code id="numstates_from_numareas_+3A_maxareas">maxareas</code></td>
<td>
<p>The maximum number of areas that any single species/lineage can occupy.</p>
</td></tr>
<tr><td><code id="numstates_from_numareas_+3A_include_null_range">include_null_range</code></td>
<td>
<p>If FALSE (default), the null range is not included in the count.
If TRUE, the null range is included, adding +1 to the count of the states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, with 3 areas (A, B, C), there are 8 possible states, if a null
range is allowed (null, A, B, C, AB, BC, AC, ABC).  If the maximum range size is
2 areas, then there are only 7 possible states.
</p>
<p>The formula for the number of geographic states, based on the number of areas (<em>N</em>),
is the sum of <em>N</em> choose <em>k</em>, from <em>k</em>=1 to <em>m</em>
(maximum range size) </p>
<p style="text-align: center;"><code class="reqn">s = \sum_{k=1}^{m}{N\choose k}</code>
</p>

<p>This equation assumes that the null range (a species lives in no areas, i.e. is extinct)
is not allowed. In the LAGRANGE program of <cite>ReeSmith2008</cite>), the null range is included
in the transition matrix, and thus this is one more state.  This situation is represented in 
<code>numstates_from_numareas</code> by setting <code>include_null_range=TRUE</code>.
</p>
<p>Users might manually remove states from the states list, if prior information indicates that
some configurations of presence/absence in areas are impossible as geographic ranges for
species.  If so, they should manually subtract from the number of states.
</p>


<h3>Value</h3>

<p><code>nstates</code> Number of states
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+convolve">convolve</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
@cite ReeSmith2008
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numstates_from_numareas(numareas=3, maxareas=3, 
include_null_range=FALSE)
numstates_from_numareas(numareas=3, maxareas=3, 
include_null_range=TRUE)
numstates_from_numareas(numareas=3, maxareas=2, 
include_null_range=TRUE)
numstates_from_numareas(numareas=3, maxareas=1, 
include_null_range=TRUE)
numstates_from_numareas(numareas=7, maxareas=7, 
include_null_range=TRUE)
numstates_from_numareas(numareas=7, maxareas=2, 
include_null_range=TRUE)
numstates_from_numareas(numareas=8, maxareas=8, 
include_null_range=TRUE)
numstates_from_numareas(numareas=8, maxareas=2, 
include_null_range=TRUE)
numstates_from_numareas(numareas=20, maxareas=20, 
include_null_range=TRUE)
numstates_from_numareas(numareas=20, maxareas=2, 
include_null_range=TRUE)
numstates_from_numareas(numareas=20, maxareas=3, 
include_null_range=TRUE)
</code></pre>

<hr>
<h2 id='rcpp_areas_list_to_states_list'>Make a list of 0-based indices of possible combinations of input areas</h2><span id='topic+rcpp_areas_list_to_states_list'></span>

<h3>Description</h3>

<p>Given a list of areas (actually a list of anything; all that is important is the length of the list)
<code>rcpp_areas_list_to_states_list</code> calculates all possible combinations of these areas,
listing them by the 0-based indices that specify the position of each area in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_areas_list_to_states_list(areas = c("A", "B", "C"),
  maxareas = length(areas), include_null_range = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_areas_list_to_states_list_+3A_areas">areas</code></td>
<td>
<p>a list of areas (character or number; the function converts these to numbers, starting with 0)</p>
</td></tr>
<tr><td><code id="rcpp_areas_list_to_states_list_+3A_maxareas">maxareas</code></td>
<td>
<p>maximum number of areas in this analyses</p>
</td></tr>
<tr><td><code id="rcpp_areas_list_to_states_list_+3A_include_null_range">include_null_range</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, should the <code>NULL</code> range be included in the possible states? (e.g., <code>LAGRANGE</code> default is yes)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using 0-based indexing is convenient in the C++ code called by the other functions, rather than having
to keep track of the various people might label their areas (names, abbreviations, letters, numbers).
</p>
<p>As in LAGRANGE (Ree &amp; Smith 2008), the maximum range size (i.e. the maximum number of areas in a range) can be specified by the 
user.  Having a smaller maximum range size drastically reduces the number of states, and thus the size of
the transition matrix and the cladogenesis matrix.
</p>


<h3>Value</h3>

<p><code>R_states_list</code> A list of the states, where each state is a list of areas in the form of 0-based indices
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+numstates_from_numareas">numstates_from_numareas</a></code>, <code><a href="#topic+areas_list_to_states_list_old">areas_list_to_states_list_old</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
@cite ReeSmith2008
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Specify the areas
areas_list = c("A", "B", "C")
areas_list

# Let's try Rcpp_combn_zerostart, in case that is the source of a
# problem found via AddressSanitizer
Rcpp_combn_zerostart(n_to_choose_from=4, k_to_choose=2, maxlim=1e+07)
Rcpp_combn_zerostart(n_to_choose_from=4, k_to_choose=3, maxlim=1e+07)


## Not run: 

# Calculate the list of 0-based indices for each possible geographic range, i.e.
# each combination of areas
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=3, 
include_null_range=FALSE)
states_list
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=3, 
include_null_range=TRUE)
states_list
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=2, 
include_null_range=TRUE)
states_list
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=1, 
include_null_range=TRUE)
states_list


## End(Not run)

</code></pre>

<hr>
<h2 id='rcpp_calc_anclikes_sp'>Calculate probability of ancestral states below a speciation event, given probabilities of the states on each descendant branch</h2><span id='topic+rcpp_calc_anclikes_sp'></span>

<h3>Description</h3>

<p>This function, given parameters on the Relative weight of different geographic range inheritance
scenarios at cladogenesis (speciation) events, calculates the probability of each possible ancestral
state given the probabilities of each possible combination of tip states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_anclikes_sp(Rcpp_leftprobs, Rcpp_rightprobs, l, s = 1, v = 1,
  j = 0, y = 1, dmat = NULL, maxent01s = NULL, maxent01v = NULL,
  maxent01j = NULL, maxent01y = NULL,
  max_minsize_as_function_of_ancsize = NULL, Rsp_rowsums = rep(1,
  length(Rcpp_leftprobs)), printmat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_rcpp_leftprobs">Rcpp_leftprobs</code></td>
<td>
<p>Probabilities of the states at the base of the left descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_rcpp_rightprobs">Rcpp_rightprobs</code></td>
<td>
<p>Probabilities of the states at the base of the right descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_l">l</code></td>
<td>
<p>List of state indices (0-based)</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_s">s</code></td>
<td>
<p>Relative weight of sympatric &quot;subset&quot; speciation. Default <code>s=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_v">v</code></td>
<td>
<p>Relative weight of vicariant speciation. Default <code>v=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_j">j</code></td>
<td>
<p>Relative weight of &quot;founder event speciation&quot;/jump speciation. Default <code>j=0</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_y">y</code></td>
<td>
<p>Relative weight of fully sympatric speciation (range-copying). Default <code>y=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_dmat">dmat</code></td>
<td>
<p>If given, a matrix of rank numareas giving multipliers for the probability
of each dispersal event between areas. Default NULL, which sets every cell of the 
<code>dmat</code> matrix to value 1.  Users may construct their own parameterized <code>dmat</code>
(for example, making <code>dmat</code> a function of distance) for inclusion in ML or
Bayesian analyses.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_maxent01s">maxent01s</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a subset-sympatric speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_maxent01v">maxent01v</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a vicariance speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_maxent01j">maxent01j</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a founder-event speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_maxent01y">maxent01y</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a full-sympatric (range-copying) 
speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_max_minsize_as_function_of_ancsize">max_minsize_as_function_of_ancsize</code></td>
<td>
<p>If given, any state with a range larger that this value will 
be given a probability of zero (for the branch with the smaller rangesize).  This means that not every
possible combination of ranges has to be checked, which can get very slow for large state spaces.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_rsp_rowsums">Rsp_rowsums</code></td>
<td>
<p>A vector of size (numstates)  giving the sum of the relative probabilites of 
each combination of descendant states, assuming the probabilities of the left- and right-states are 
all equal (set to 1). This is thus the sum of the weights, and dividing by this normalization vector 
means that the each row of the speciation probability matrix will sum to 1.  Default assumes the 
weights sum to 1 but this is not usually the case. Rsp_rowsums need only be calculated once per 
tree+model combination, stored, and then re-used for each node in the tree, yielding significant 
time savings.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_+3A_printmat">printmat</code></td>
<td>
<p>Should the probability matrix output be printed to screen? (useful for debugging, but 
can be dramatically slow in R.app for some reason for even moderate numbers of states; perhaps 
overrunning the line length...)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Python/C++ program LAGRANGE (Ree &amp; Smith 2008) gives a fixed equal probability to each 
range-inheritance scenario it allows:
</p>
<p>(1) sympatric speciation with 1 area (e.g. A &ndash;&gt; A,A);<br />
(2) sympatric speciation where one species inherits the ancestral range, and the other inherits
a 1-area subset of the ancestral range (e.g. ABC &ndash;&gt; ABC,B);<br />
(3) vicariant speciation with one daughter occupying an area of size 1 (e.g. ABCD &ndash;&gt; ACD,B)<br />
</p>
<p>For example, if the ancestral range is ABC, the possible daughters are:
</p>
<p>(Left, Right)
</p>
<p>Vicariance:
A,BC
AB,C
AC,B
BC,A
C,AB
B,AC
</p>
<p>Sympatric subset:
A,ABC
B,ABC
C,ABC
ABC,A
ABC,B
ABC,C
</p>
<p>There are 12 possibilities, so LAGRANGE would give each a probability of 1/12, conditional on the
ancestor having range ABC.  All other imaginable scenarios are given probability 0 &ndash; e.g., sympatric
speciation of a widespread range (ABC &ndash;&gt; ABC,ABC), or jump dispersal leading to founder-event speciation
(ABC &ndash;&gt; ABC,D).
</p>
<p>In <code>BioGeoBEARS</code>, the relative probability (or weight) of these categories is set by the <code>s</code> 
(sympatric-subset), <code>v</code> (vicariance), <code>j</code> (jump/founder-event), and <code>y</code> 
(sympatric-range-copying) parameters. These parameters do not have to sum to 1, they just give the 
<em>relative</em> weight of an event of each type.  E.g., if <code>s=1</code>, <code>v=1</code>, <code>j=0</code>, <code>y=1</code>, 
then each allowed sympatric-range-copying, sympatric-subset, and vicariance event is given equal probability 
(this is the LAGRANGE cladogenesis model) .
</p>
<p>The <code>rcpp_calc_anclikes_sp</code> function gets slow for large state spaces, as every possible combination of states at Left and
Right branches is checked.  Even in C++ this will get slow, as the <code>(number of states) = 2^(number of areas)</code>,
and as the number of possible combinations of (ancestor, left,right) states is 
<code>(number of states)*(number of states)*(number of states)</code>.
</p>
<p>Note: the <code>maxent</code> parameters allow the user to specify the probability distribution for different range sizes of the 
smaller-ranged descendant lineage.  The defaults set these parameters so that the LAGRANGE model is implemented (the smaller
descendant always has range size 1).
</p>
<p>See <code><a href="#topic+rcpp_calc_anclikes_sp_COOprobs">rcpp_calc_anclikes_sp_COOprobs</a></code> and <code><a href="#topic+rcpp_calc_anclikes_sp_COOweights_faster">rcpp_calc_anclikes_sp_COOweights_faster</a></code>
for successively faster solutions to this problem.
</p>
<p>This is the byte-compiled version of <code><a href="#topic+rcpp_calc_anclikes_sp_prebyte">rcpp_calc_anclikes_sp_prebyte</a></code>.
<code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> is byte-compiled, which (might) make it faster.
</p>
<p>For information on byte-compiling, see <a href="http://www.r-statistics.com/2012/04/speed-up-your-r-code-using-a-just-in-time-jit-compiler/">http://www.r-statistics.com/2012/04/speed-up-your-r-code-using-a-just-in-time-jit-compiler/</a> and <code><a href="compiler.html#topic+cmpfun">cmpfun</a></code> in the <code><a href="compiler.html#topic+cmpfun">compiler</a></code> package.
</p>


<h3>Value</h3>

<p><code>prob_ancestral_states</code> The probabilities of the ancestral states.
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>, <code><a href="#topic+rcpp_calc_anclikes_sp_COOprobs">rcpp_calc_anclikes_sp_COOprobs</a></code>, 
<code><a href="#topic+rcpp_calc_anclikes_sp_COOweights_faster">rcpp_calc_anclikes_sp_COOweights_faster</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
@cite ReeSmith2008
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the basic logic of a probablistic cladogenesis model, see
?rcpp_calc_anclikes_sp

# For examples of running the functions, see the comparison of all functions at:
# ?cladoRcpp

</code></pre>

<hr>
<h2 id='rcpp_calc_anclikes_sp_COOprobs'>Faster version of rcpp_calc_anclikes_sp</h2><span id='topic+rcpp_calc_anclikes_sp_COOprobs'></span>

<h3>Description</h3>

<p>This function is a faster version of <code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>. Like
<code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>, this function calculates the conditional
probability of every allowed combination of ancestral range, left descendent range,
and right descendent range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_anclikes_sp_COOprobs(Rcpp_leftprobs, Rcpp_rightprobs, l, s = 1,
  v = 1, j = 0, y = 1, dmat = NULL, maxent01s = NULL,
  maxent01v = NULL, maxent01j = NULL, maxent01y = NULL,
  max_minsize_as_function_of_ancsize = NULL, printmat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_rcpp_leftprobs">Rcpp_leftprobs</code></td>
<td>
<p>Probabilities of the states at the base of the left descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_rcpp_rightprobs">Rcpp_rightprobs</code></td>
<td>
<p>Probabilities of the states at the base of the right descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_l">l</code></td>
<td>
<p>List of state indices (0-based)</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_s">s</code></td>
<td>
<p>Relative weight of sympatric &quot;subset&quot; speciation. Default <code>s=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_v">v</code></td>
<td>
<p>Relative weight of vicariant speciation. Default <code>v=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_j">j</code></td>
<td>
<p>Relative weight of &quot;founder event speciation&quot;/jump speciation. Default <code>j=0</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_y">y</code></td>
<td>
<p>Relative weight of fully sympatric speciation (range-copying). Default <code>y=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_dmat">dmat</code></td>
<td>
<p>If given, a matrix of rank numareas giving multipliers for the probability
of each dispersal event between areas. Default NULL, which sets every cell of the 
<code>dmat</code> matrix to value 1.  Users may construct their own parameterized <code>dmat</code>
(for example, making <code>dmat</code> a function of distance) for inclusion in ML or
Bayesian analyses.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_maxent01s">maxent01s</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a subset-sympatric speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_maxent01v">maxent01v</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a vicariance speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_maxent01j">maxent01j</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a founder-event speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_maxent01y">maxent01y</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a full-sympatric (range-copying) 
speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_max_minsize_as_function_of_ancsize">max_minsize_as_function_of_ancsize</code></td>
<td>
<p>If given, any state with a range larger that this value will 
be given a probability of zero (for the branch with the smaller rangesize).  This means that not every
possible combination of ranges has to be checked, which can get very slow for large state spaces.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOprobs_+3A_printmat">printmat</code></td>
<td>
<p>Should the probability matrix output be printed to screen? (useful for debugging, but 
can be dramatically slow in R.app for some reason for even moderate numbers of states; perhaps 
overrunning the line length...)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function improves upon <code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> by
returning a COO-like list of the nonzero cells in the transition matrix
for the speciation event.
</p>
<p>(COO = Coordinate list format for a matrix, see 
<a href="http://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">http://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29</a>
</p>
<p>Whereas a COO-formatted square matrix stores, for each nonzero cell, the row #, column #, and 
cell value, <code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> returns lists containing, for each nonzero cell:
</p>
<p>1. 0-based index of the ancestral state<br />
2. 0-based index of the left state<br />
3. 0-based index of the right state<br />
4. Value of the specified nonzero cell<br />
</p>
<p>Time savings over <code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> are realized by skipping many 
ancestor/descendent combinations which are impossible transitions on the model, and 
neither recording, nor storing, nor passing them.  This becomes important with 
large state spaces.
</p>


<h3>Value</h3>

<p><code>list_weights_of_transitions</code> A list of 3 lists. Each list has (numstates) items, 
representing the ancestral states.  List #1 gives the 0-based state index for the nonzero left descendents
of each ancestral state. List #2 gives the 0-based state index for the nonzero right descendents
of each ancestral state. List #3 gives the weight of each nonzero transition from each ancestral state.
Summing these weights within each ancestral state for list #3 gives the total of the weights for
each ancestral state.  Dividing the weights by the sum of weights gives the conditional probability
of each descendent state, conditional on the ancestral state.  These conditional probabilities
need only be calculated once per 
tree+model combination, stored, and then re-used for each node in the tree, yielding significant 
time savings.
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>, <code><a href="#topic+rcpp_calc_anclikes_sp_COOprobs">rcpp_calc_anclikes_sp_COOprobs</a></code>, 
<code><a href="#topic+rcpp_calc_anclikes_sp_COOweights_faster">rcpp_calc_anclikes_sp_COOweights_faster</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
@cite ReeSmith2008
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the basic logic of a probablistic cladogenesis model, see
?rcpp_calc_anclikes_sp

# For examples of running the functions, see the comparison of all functions at:
# ?cladoRcpp

</code></pre>

<hr>
<h2 id='rcpp_calc_anclikes_sp_COOweights_faster'>Even faster version of rcpp_calc_anclikes_sp</h2><span id='topic+rcpp_calc_anclikes_sp_COOweights_faster'></span>

<h3>Description</h3>

<p>This function improves on <code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> and
<code><a href="#topic+rcpp_calc_anclikes_sp_COOprobs">rcpp_calc_anclikes_sp_COOprobs</a></code>.  In addition to the compressed
COO-like storage format, the internal C++ code here explicitly
enumerates the allowed transitions, rather than searching through
every possibility and testing whether or not it is allowed.  This 
appears to scale well to very large state spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs, Rcpp_rightprobs, l,
  s = 1, v = 1, j = 0, y = 1, dmat = NULL, maxent01s = NULL,
  maxent01v = NULL, maxent01j = NULL, maxent01y = NULL,
  max_minsize_as_function_of_ancsize = NULL, printmat = TRUE,
  m = NULL, m_null_range = TRUE, jts_matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_rcpp_leftprobs">Rcpp_leftprobs</code></td>
<td>
<p>Probabilities of the states at the base of the left descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_rcpp_rightprobs">Rcpp_rightprobs</code></td>
<td>
<p>Probabilities of the states at the base of the right descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_l">l</code></td>
<td>
<p>List of state indices (0-based)</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_s">s</code></td>
<td>
<p>Relative weight of sympatric &quot;subset&quot; speciation. Default <code>s=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_v">v</code></td>
<td>
<p>Relative weight of vicariant speciation. Default <code>v=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_j">j</code></td>
<td>
<p>Relative weight of &quot;founder event speciation&quot;/jump speciation. Default <code>j=0</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_y">y</code></td>
<td>
<p>Relative weight of fully sympatric speciation (range-copying). Default <code>y=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_dmat">dmat</code></td>
<td>
<p>If given, a matrix of rank numareas giving multipliers for the probability
of each dispersal event between areas. Default NULL, which sets every cell of the 
<code>dmat</code> matrix to value 1.  Users may construct their own parameterized <code>dmat</code>
(for example, making <code>dmat</code> a function of distance) for inclusion in ML or
Bayesian analyses.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_maxent01s">maxent01s</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a subset-sympatric speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_maxent01v">maxent01v</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a vicariance speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_maxent01j">maxent01j</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a founder-event speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_maxent01y">maxent01y</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a full-sympatric (range-copying) 
speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_max_minsize_as_function_of_ancsize">max_minsize_as_function_of_ancsize</code></td>
<td>
<p>If given, any state with a range larger that this value will 
be given a probability of zero (for the branch with the smaller rangesize).  This means that not every
possible combination of ranges has to be checked, which can get very slow for large state spaces.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_printmat">printmat</code></td>
<td>
<p>Should the probability matrix output be printed to screen? (useful for debugging, but 
can be dramatically slow in R.app for some reason for even moderate numbers of states; perhaps 
overrunning the line length...)</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_m">m</code></td>
<td>
<p>This is a vector of rate/weight multipliers for dispersal, conditional on the values of some
(non-biogeographical) trait. For example, one might hypothesize that flight/flightlessness effects
dispersal probability, and manually put a multiplier of 0.001 on the flightlessness state. Or, 
one might attempt to estimate this. The strategy used in cladoRcpp is to expand the default cladogenetic
rate matrix by length(m) times. I.e., if <em>m</em> is not <code>NULL</code>, then loop through the values of <em>m</em> and apply the 
multipliers to <em>d</em> (and <em>j</em>, and <em>a</em>) events. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_m_null_range">m_null_range</code></td>
<td>
<p>Is the null range included in the state space in the general 
analysis? (The function needs to know this, when there are traits, to index
the state space correctly.)</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_COOweights_faster_+3A_jts_matrix">jts_matrix</code></td>
<td>
<p>A numtraits x numtraits matrix containing the proportions for 
trait transitions during j events. E.g., for a sudden switch from 
trait 1 (flight) to trait 2 (flightlessness) during a jump event.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This should be faster, i.e. by look for each type of event individually.
</p>
<p>Returns results as 4 columns: ancestral index, left index, right index, conditional
probability given ancestral states (assuming likelihood of descendants is 1). Indexes
are 0-based.
</p>
<p>Keep in mind that cladogenesis matrices exclude the null state
(a range of 0 areas), so if your states list starts with the 
null range (as is typical/default in DEC-style models)
then to get the R 1-based state indices requires e.g. 
COO_weights_columnar[[1]] + 2.
</p>
<p>When the calculation is run at each node in the tree, all that is required is one
pass through the COO-like array, with the downpassed probabilities of the
states on the left and right branches multiplied by the probability column.
</p>


<h3>Value</h3>

<p><code>COO_weights_columnar</code> Transition weights matrix in COO-like format as 4 columns: 
ancestral index, left index, right index, and weight of the specified transition. Indexes are
0-based. 
Keep in mind that cladogenesis matrices exclude the null state
(a range of 0 areas), so if your states list starts with the 
null range (as is typical/default in DEC-style models)
then to get the R 1-based state indices requires e.g. 
COO_weights_columnar[[1]] + 2.
</p>
<p>Dividing the
weights by the sum of the weights for a particular ancestral state yields the conditional
probabilities of each transition at the speciation event.
(assuming likelihood of descendants is 1).
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>, <code><a href="#topic+rcpp_calc_anclikes_sp_COOprobs">rcpp_calc_anclikes_sp_COOprobs</a></code>, 
<code><a href="#topic+rcpp_calc_anclikes_sp_COOweights_faster">rcpp_calc_anclikes_sp_COOweights_faster</a></code>
</p>
<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
@cite ReeSmith2008
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the basic logic of a probablistic cladogenesis model, see
?rcpp_calc_anclikes_sp

# For examples of running the functions, see the comparison of all functions at:
# ?cladoRcpp

</code></pre>

<hr>
<h2 id='rcpp_calc_anclikes_sp_prebyte'>Calculate probability of ancestral states below a speciation event, given probabilities of the states on each descendant branch</h2><span id='topic+rcpp_calc_anclikes_sp_prebyte'></span>

<h3>Description</h3>

<p>This is the pre-byte compiled version of <code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>.  <code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> is 
byte-compiled, which (might) make it faster.  See <code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> for full description and help.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_anclikes_sp_prebyte(Rcpp_leftprobs, Rcpp_rightprobs, l, s = 1,
  v = 1, j = 0, y = 1, dmat = NULL, maxent01s = NULL,
  maxent01v = NULL, maxent01j = NULL, maxent01y = NULL,
  max_minsize_as_function_of_ancsize = NULL, Rsp_rowsums = rep(1,
  length(Rcpp_leftprobs)), printmat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_rcpp_leftprobs">Rcpp_leftprobs</code></td>
<td>
<p>Probabilities of the states at the base of the left descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_rcpp_rightprobs">Rcpp_rightprobs</code></td>
<td>
<p>Probabilities of the states at the base of the right descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_l">l</code></td>
<td>
<p>List of state indices (0-based)</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_s">s</code></td>
<td>
<p>Relative weight of sympatric &quot;subset&quot; speciation. Default <code>s=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_v">v</code></td>
<td>
<p>Relative weight of vicariant speciation. Default <code>v=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_j">j</code></td>
<td>
<p>Relative weight of &quot;founder event speciation&quot;/jump speciation. Default <code>j=0</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_y">y</code></td>
<td>
<p>Relative weight of fully sympatric speciation (range-copying). Default <code>y=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_dmat">dmat</code></td>
<td>
<p>If given, a matrix of rank numareas giving multipliers for the probability
of each dispersal event between areas. Default NULL, which sets every cell of the 
<code>dmat</code> matrix to value 1.  Users may construct their own parameterized <code>dmat</code>
(for example, making <code>dmat</code> a function of distance) for inclusion in ML or
Bayesian analyses.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_maxent01s">maxent01s</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a subset-sympatric speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_maxent01v">maxent01v</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a vicariance speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_maxent01j">maxent01j</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a founder-event speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_maxent01y">maxent01y</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a full-sympatric (range-copying) 
speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_max_minsize_as_function_of_ancsize">max_minsize_as_function_of_ancsize</code></td>
<td>
<p>If given, any state with a range larger that this value 
will be given a probability of zero (for the branch with the smaller rangesize).  This means that 
not every possible combination of ranges has to be checked, which can get very slow for large 
state spaces.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_rsp_rowsums">Rsp_rowsums</code></td>
<td>
<p>A vector of size (numstates)  giving the sum of the relative probabilites of 
each combination of descendant states, assuming the probabilities of the left- and right-states are 
all equal (set to 1). This is thus the sum of the weights, and dividing by this normalization 
vector means that the each row of the speciation probability matrix will sum to 1.  Default assumes 
the weights sum to 1 but this is not usually the case. Rsp_rowsums need only be calculated once 
per tree+model combination, stored, and then re-used for each node in the tree, yielding 
significant time savings.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_prebyte_+3A_printmat">printmat</code></td>
<td>
<p>Should the probability matrix output be printed to screen? (useful for debugging, but 
can be dramatically slow in R.app for some reason for even moderate numbers of states; perhaps 
overrunning the line length...)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gets slow for large state spaces.
</p>
<p>For information on byte-compiling, see <a href="http://www.r-statistics.com/2012/04/speed-up-your-r-code-using-a-just-in-time-jit-compiler/">http://www.r-statistics.com/2012/04/speed-up-your-r-code-using-a-just-in-time-jit-compiler/</a> and <code><a href="compiler.html#topic+cmpfun">cmpfun</a></code> in the <code><a href="compiler.html#topic+cmpfun">compiler</a></code> package.
</p>


<h3>Value</h3>

<p><code>prob_ancestral_states</code> The probabilities of the ancestral states.
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
@cite ReeSmith2008
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the basic logic of a probablistic cladogenesis model, see
?rcpp_calc_anclikes_sp

# For examples of running the functions, see the comparison of all functions at:
# ?cladoRcpp

</code></pre>

<hr>
<h2 id='rcpp_calc_anclikes_sp_rowsums'>Calculate the number of cladogenesis events of nonzero probability for each ancestral state</h2><span id='topic+rcpp_calc_anclikes_sp_rowsums'></span>

<h3>Description</h3>

<p>This function takes the list of possible states (<em>l</em>), and the parameters of a cladogenesis model
(<em>s</em>, <em>v</em>, <em>j</em>, <em>y</em>) (which are the relative weights of each of type of cladogenic range inheritance event)
and, for each ancestral state, sums the weights of allowed descendant events.  Dividing the weights in each row, by the sum of 
the weights for that row, provides the absolute probabilities of each transition, conditional on the ancestral state for that row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_anclikes_sp_rowsums(Rcpp_leftprobs, Rcpp_rightprobs, l, s = 1,
  v = 1, j = 0, y = 1, dmat = NULL, maxent01s = NULL,
  maxent01v = NULL, maxent01j = NULL, maxent01y = NULL,
  max_minsize_as_function_of_ancsize = NULL, printmat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_rcpp_leftprobs">Rcpp_leftprobs</code></td>
<td>
<p>Probabilities of the states at the base of the left descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_rcpp_rightprobs">Rcpp_rightprobs</code></td>
<td>
<p>Probabilities of the states at the base of the right descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_l">l</code></td>
<td>
<p>List of state indices (0-based)</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_s">s</code></td>
<td>
<p>Relative weight of sympatric &quot;subset&quot; speciation. Default <code>s=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_v">v</code></td>
<td>
<p>Relative weight of vicariant speciation. Default <code>v=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_j">j</code></td>
<td>
<p>Relative weight of &quot;founder event speciation&quot;/jump speciation. Default <code>j=0</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_y">y</code></td>
<td>
<p>Relative weight of fully sympatric speciation (range-copying). Default <code>y=1</code> mimics LAGRANGE model.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_dmat">dmat</code></td>
<td>
<p>If given, a matrix of rank numareas giving multipliers for the probability
of each dispersal event between areas. Default NULL, which sets every cell of the 
<code>dmat</code> matrix to value 1.  Users may construct their own parameterized <code>dmat</code>
(for example, making <code>dmat</code> a function of distance) for inclusion in ML or
Bayesian analyses.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_maxent01s">maxent01s</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a subset-sympatric speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_maxent01v">maxent01v</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a vicariance speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_maxent01j">maxent01j</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a founder-event speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_maxent01y">maxent01y</code></td>
<td>
<p>Matrix giving the relative weight of each possible descendant rangesize for 
the smaller range, for a given ancestral rangesize, for a full-sympatric (range-copying) 
speciation event. 
Default is <code>NULL</code>, which means the script will set up the LAGRANGE model (one descendent 
always has range size 1).</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_max_minsize_as_function_of_ancsize">max_minsize_as_function_of_ancsize</code></td>
<td>
<p>If given, any state with a range larger that this value will 
be given a probability of zero (for the branch with the smaller rangesize).  This means that not every
possible combination of ranges has to be checked, which can get very slow for large state spaces.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_rowsums_+3A_printmat">printmat</code></td>
<td>
<p>Should the probability matrix output be printed to screen? (useful for debugging, but 
can be dramatically slow in R.app for some reason for even moderate numbers of states; perhaps 
overrunning the line length...)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inputs <code>Rcpp_leftprobs</code> and <code>Rcpp_rightprobs</code> are basically irrelevant here, but 
retained for symmetry with the other functions.  In effect, this function is identical with
<code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> except that <code>Rcpp_leftprobs</code> and <code>Rcpp_rightprobs</code>
are arrays of 1s of <code>length(l)</code>, i.e. <code>length(number_of_states)</code>.
</p>
<p>This function is no longer used in <code>BioGeoBEARS</code>, but has been retained to enable easy counting of
the number of events.  When all nonzero-probability events are of equal probability (e.g. as in LAGRANGE; Ree &amp; Smith 2008)
the function could be used for normalization, but it is safer to use <code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code> or 
one of the faster COO-like equivalents.
</p>


<h3>Value</h3>

<p><code>Rsp_rowsums</code> A vector of size (numstates)  giving the number of events of nonzero probability 
for each ancestral states.
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>, <code><a href="#topic+rcpp_calc_anclikes_sp_COOprobs">rcpp_calc_anclikes_sp_COOprobs</a></code>, 
<code><a href="#topic+rcpp_calc_anclikes_sp_COOweights_faster">rcpp_calc_anclikes_sp_COOweights_faster</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
@cite ReeSmith2008
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the basic logic of a probablistic cladogenesis model, see
?rcpp_calc_anclikes_sp

# For examples of running the functions, see the comparison of all functions at:
# ?cladoRcpp

</code></pre>

<hr>
<h2 id='rcpp_calc_anclikes_sp_using_COOprobs'>Calculate ancestral likelihoods given a COO-like probability matrix</h2><span id='topic+rcpp_calc_anclikes_sp_using_COOprobs'></span>

<h3>Description</h3>

<p>This function does a pass through a COO-like transition probability matrix 
for a node, inputting the probabilities that have been passed down
from above for the left and right branch, and the sum of weights for
each ancestral state, and returns the ancestral relative probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_anclikes_sp_using_COOprobs(Rcpp_leftprobs, Rcpp_rightprobs,
  RCOO_left_i_list, RCOO_right_j_list, RCOO_probs_list, Rsp_rowsums,
  printmat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_anclikes_sp_using_COOprobs_+3A_rcpp_leftprobs">Rcpp_leftprobs</code></td>
<td>
<p>Probabilities of the states at the base of the left descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_using_COOprobs_+3A_rcpp_rightprobs">Rcpp_rightprobs</code></td>
<td>
<p>Probabilities of the states at the base of the right descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_using_COOprobs_+3A_rcoo_left_i_list">RCOO_left_i_list</code></td>
<td>
<p>0-based index of the allowed left states<br /></p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_using_COOprobs_+3A_rcoo_right_j_list">RCOO_right_j_list</code></td>
<td>
<p>0-based index of the allowed right states<br /></p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_using_COOprobs_+3A_rcoo_probs_list">RCOO_probs_list</code></td>
<td>
<p>Value of the specified nonzero cells<br /></p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_using_COOprobs_+3A_rsp_rowsums">Rsp_rowsums</code></td>
<td>
<p>A vector of size (numstates)  giving the sum of the relative probabilites of 
each combination of descendant states, assuming the probabilities of the left- and right-states are 
all equal (set to 1). This is thus the sum of the weights, and dividing by this normalization vector 
means that the each row of the speciation probability matrix will sum to 1.  Default assumes the 
weights sum to 1 but this is not usually the case. Rsp_rowsums need only be calculated once per 
tree+model combination, stored, and then re-used for each node in the tree, yielding significant 
time savings.</p>
</td></tr>
<tr><td><code id="rcpp_calc_anclikes_sp_using_COOprobs_+3A_printmat">printmat</code></td>
<td>
<p>Should the probability matrix output be printed to screen? (useful for debugging, but 
can be dramatically slow in R.app for some reason for even moderate numbers of states; perhaps 
overrunning the line length...)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This C++ implementation should be slightly faster than the R version,
although for a simple pass through an array the difference may not
be great.
</p>


<h3>Value</h3>

<p><code>R_anc_relprobs</code> Vector of the probabilities of the ancestral states
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>
</p>
<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the basic logic of a probablistic cladogenesis model, see
?rcpp_calc_anclikes_sp

# For examples of running the functions, see the comparison of all functions at:
# ?cladoRcpp

</code></pre>

<hr>
<h2 id='rcpp_calc_rowsums_for_COOweights_columnar'>Calculate sum of weights for each ancestral state</h2><span id='topic+rcpp_calc_rowsums_for_COOweights_columnar'></span>

<h3>Description</h3>

<p>This is a C++ implementation of <code><a href="#topic+rcpp_calc_anclikes_sp_rowsums">rcpp_calc_anclikes_sp_rowsums</a></code>.  It should
be substantially faster, as it requires only one pass through <code>COO_weights_columnar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar,
  numstates = 1 + max(sapply(X = COO_weights_columnar, FUN = max)[1:3]),
  printmat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_rowsums_for_COOweights_columnar_+3A_coo_weights_columnar">COO_weights_columnar</code></td>
<td>
<p>Transition probability matrix in COO-like format as 4 columns: 
ancestral index, left index, right index, conditional probability given ancestral states.
(assuming likelihood of descendants is 1). Indexes are 0-based.
Keep in mind that cladogenesis matrices exclude the null state
(a range of 0 areas), so if your states list starts with the 
null range (as is typical/default in DEC-style models)
then to get the R 1-based state indices requires e.g. 
COO_weights_columnar[[1]] + 2.</p>
</td></tr>
<tr><td><code id="rcpp_calc_rowsums_for_COOweights_columnar_+3A_numstates">numstates</code></td>
<td>
<p>The user should provide the number of states (WITHOUT counting the null range),
in case they are not all
present in <code>COO_weights_columnar</code>.  If empty, the function assumes that the highest 
index represents the last state, and adds 1 to get the number of states. This may be a 
hazardous assumption.</p>
</td></tr>
<tr><td><code id="rcpp_calc_rowsums_for_COOweights_columnar_+3A_printmat">printmat</code></td>
<td>
<p>Should the probability matrix output be printed to screen? (useful for debugging, but 
can be dramatically slow in R.app for some reason for even moderate numbers of states; perhaps 
overrunning the line length...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rowsums</code> A vector of size (numstates)  giving the sum of the relative probabilites of 
each combination of descendant states, assuming the probabilities of the left- and right-states are 
all equal (set to 1). This is thus the sum of the weights, and dividing by this normalization vector 
means that the each row of the speciation probability matrix will sum to 1.  Default assumes the 
weights sum to 1 but this is not usually the case. Rsp_rowsums need only be calculated once per 
tree+model combination, stored, and then re-used for each node in the tree, yielding significant 
time savings.
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the basic logic of a probablistic cladogenesis model, see
?rcpp_calc_anclikes_sp

# For examples of running the functions, see the comparison of all functions at:
# ?cladoRcpp

</code></pre>

<hr>
<h2 id='rcpp_calc_splitlikes_using_COOweights_columnar'>Calculate the split likelihoods using <code>COO_weights_columnar</code></h2><span id='topic+rcpp_calc_splitlikes_using_COOweights_columnar'></span>

<h3>Description</h3>

<p>Calculates the split likelihoods using <code>COO_weights_columnar</code>, i.e. the weights as produced by
<code><a href="#topic+rcpp_calc_anclikes_sp_COOweights_faster">rcpp_calc_anclikes_sp_COOweights_faster</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_splitlikes_using_COOweights_columnar(Rcpp_leftprobs,
  Rcpp_rightprobs, COO_weights_columnar, Rsp_rowsums, printmat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_splitlikes_using_COOweights_columnar_+3A_rcpp_leftprobs">Rcpp_leftprobs</code></td>
<td>
<p>Probabilities of the states at the base of the left descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_splitlikes_using_COOweights_columnar_+3A_rcpp_rightprobs">Rcpp_rightprobs</code></td>
<td>
<p>Probabilities of the states at the base of the right descendant branch</p>
</td></tr>
<tr><td><code id="rcpp_calc_splitlikes_using_COOweights_columnar_+3A_coo_weights_columnar">COO_weights_columnar</code></td>
<td>
<p>Transition probability matrix in COO-like format as 4 columns: 
ancestral index, left index, right index, conditional probability given ancestral states.
(assuming likelihood of descendants is 1). Indexes are 0-based.
Keep in mind that cladogenesis matrices exclude the null state
(a range of 0 areas), so if your states list starts with the 
null range (as is typical/default in DEC-style models)
then to get the R 1-based state indices requires e.g. 
COO_weights_columnar[[1]] + 2.</p>
</td></tr>
<tr><td><code id="rcpp_calc_splitlikes_using_COOweights_columnar_+3A_rsp_rowsums">Rsp_rowsums</code></td>
<td>
<p>A vector of size (numstates)  giving the sum of the relative probabilites of 
each combination of descendant states, assuming the probabilities of the left- and right-states are 
all equal (set to 1). This is thus the sum of the weights, and dividing by this normalization vector 
means that the each row of the speciation probability matrix will sum to 1.  Default assumes the 
weights sum to 1 but this is not usually the case. Rsp_rowsums need only be calculated once per 
tree+model combination, stored, and then re-used for each node in the tree, yielding significant 
time savings.</p>
</td></tr>
<tr><td><code id="rcpp_calc_splitlikes_using_COOweights_columnar_+3A_printmat">printmat</code></td>
<td>
<p>Should the probability matrix output be printed to screen? (useful for debugging, but 
can be dramatically slow in R.app for some reason for even moderate numbers of states; perhaps 
overrunning the line length...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>splitlikes</code> Vector of the probabilities of each allowed split
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the basic logic of a probablistic cladogenesis model, see
?rcpp_calc_anclikes_sp

# For examples of running the functions, see the comparison of all functions at:
# ?cladoRcpp

</code></pre>

<hr>
<h2 id='Rcpp_combn_zerostart'>Get all the combinations of descendent state pairs, in 0-based index form</h2><span id='topic+Rcpp_combn_zerostart'></span>

<h3>Description</h3>

<p>Given the number of states, this function returns all of the
pairs of indexes corresponding to those states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rcpp_combn_zerostart(n_to_choose_from, k_to_choose, maxlim = 1e+07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rcpp_combn_zerostart_+3A_n_to_choose_from">n_to_choose_from</code></td>
<td>
<p>N in N choose K</p>
</td></tr>
<tr><td><code id="Rcpp_combn_zerostart_+3A_k_to_choose">k_to_choose</code></td>
<td>
<p>K in N choose K</p>
</td></tr>
<tr><td><code id="Rcpp_combn_zerostart_+3A_maxlim">maxlim</code></td>
<td>
<p>To avoid memory overruns, the number of combinations can be no larger than <code>maxlim</code>
(default: 1e+07)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The C++ version is MUCH faster than the plain-R version.
</p>


<h3>Value</h3>

<p><code>outarray</code> an integer matrix with <code>outarray</code> rows; the number of columns is the
number of combinations.
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcpp_calc_anclikes_sp">rcpp_calc_anclikes_sp</a></code>, <code><a href="#topic+rcpp_mult2probvect">rcpp_mult2probvect</a></code>, <code><a href="#topic+rcpp_convolve">rcpp_convolve</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rcpp_combn_zerostart(n_to_choose_from=4, k_to_choose=2, maxlim=1e+07)
Rcpp_combn_zerostart(n_to_choose_from=4, k_to_choose=3, maxlim=1e+07)

</code></pre>

<hr>
<h2 id='rcpp_convolve'>Run C++ version of convolve(x,y, conj=TRUE, type=&quot;open&quot;)</h2><span id='topic+rcpp_convolve'></span>

<h3>Description</h3>

<p>This function runs a C++ version of the R function <code><a href="stats.html#topic+convolve">convolve</a></code>, 
specifically: <code>convolve(x,y, conj=TRUE, type="open")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_convolve(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_convolve_+3A_a">a</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="rcpp_convolve_+3A_b">b</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The R function <code><a href="stats.html#topic+convolve">convolve</a></code> is an example of an R function that 
gets very slow when the input vectors are large. This C++ version, <code>rcpp_convolve</code>
can be dramatically faster for large vectors.
</p>
<p><code>rcpp_convolve</code> produces the same output as: <code>convolve(ca, cb, conj=TRUE, type="open")</code>
</p>
<p>Note: The C++ code is from the Rcpp examples in: Eddelbuettel &amp; Francois (2011). Rcpp: Seamless R and C++ Integration. <em>Journal of Statistical Software</em>, 40(8), 1-18.
</p>


<h3>Value</h3>

<p><code>convolve_result_vector</code> the vector which is the product of the convolution
</p>


<h3>Author(s)</h3>

<p>C++ code by: Dirk Eddelbuettel &lt;edd at debian.org&gt; &amp; Romain Francois (2011); This R wrapper &amp; documentation: Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="Rcpp.html#topic+Rcpp">Rcpp</a></code>, <code><a href="stats.html#topic+convolve">convolve</a></code>, <code><a href="#topic+rcpp_mult2probvect">rcpp_mult2probvect</a></code>, <code><a href="#topic+Rcpp_combn_zerostart">Rcpp_combn_zerostart</a></code>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Eddelbuettel_Francois_2011
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up 2 vectors, then convolve them
ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)
rcpp_convolve(a=ca, b=cb)

# Same as:
convolve(ca, cb, conj=TRUE, type="open")

</code></pre>

<hr>
<h2 id='rcpp_mult2probvect'>Get the product of multiplying each pair of values in a vector (cross-product)</h2><span id='topic+rcpp_mult2probvect'></span>

<h3>Description</h3>

<p>This function calls a C++ function which multiplies two vectors by each other elementwise,
such that the output is of length(a) * length(b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_mult2probvect(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_mult2probvect_+3A_a">a</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="rcpp_mult2probvect_+3A_b">b</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the cross-product operation, which exists in R (<code><a href="base.html#topic++25o+25">%o%</a></code> or 
<code><a href="base.html#topic+tcrossprod">tcrossprod</a></code>). However, it is handy to have is as a C++ function
for calculating the probability of pairs of descendant states, given the
probability of each state individually.
</p>


<h3>Value</h3>

<p><code>tcross_product_vector</code> the vector which is the product of the convolution
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic++25o+25">%o%</a></code>, <code><a href="base.html#topic+tcrossprod">tcrossprod</a></code>, <code><a href="#topic+Rcpp_combn_zerostart">Rcpp_combn_zerostart</a></code>, <code><a href="#topic+rcpp_convolve">rcpp_convolve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ca = c(1,2,3,4,5)
cb = c(2,2,2,2,2)
rcpp_mult2probvect(a=ca, b=cb)

# Same as:
c(ca %o% cb)

# Or:
c(outer(ca, cb))

# Or:
tcrossprod(ca, cb)

</code></pre>

<hr>
<h2 id='rcpp_states_list_to_DEmat'>C++ conversion of a states list to a dispersal-extinction matrix (DEmat)</h2><span id='topic+rcpp_states_list_to_DEmat'></span>

<h3>Description</h3>

<p>This function takes a list of states/ranges, a matrix describing relative dispersal probability (dmat) for each pair of areas, and
a list describing the local extirpation probability for each area (elist), and calculates a transition matrix Qmat accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_states_list_to_DEmat(areas_list, states_list, dmat, elist,
  amat = NULL, include_null_range = TRUE, normalize_TF = TRUE,
  makeCOO_TF = FALSE, min_precision = 1e-26)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_states_list_to_DEmat_+3A_areas_list">areas_list</code></td>
<td>
<p>a list of lists of areas (numbers, starting with 0)</p>
</td></tr>
<tr><td><code id="rcpp_states_list_to_DEmat_+3A_states_list">states_list</code></td>
<td>
<p>a list of lists of areas (numbers, starting with 0)</p>
</td></tr>
<tr><td><code id="rcpp_states_list_to_DEmat_+3A_dmat">dmat</code></td>
<td>
<p>dispersal matrix from area to area</p>
</td></tr>
<tr><td><code id="rcpp_states_list_to_DEmat_+3A_elist">elist</code></td>
<td>
<p>a list of extinction probabilities</p>
</td></tr>
<tr><td><code id="rcpp_states_list_to_DEmat_+3A_amat">amat</code></td>
<td>
<p>A matrix specifying the probability of instantaneous transition from one area to another (as in standard character rate matrices).</p>
</td></tr>
<tr><td><code id="rcpp_states_list_to_DEmat_+3A_include_null_range">include_null_range</code></td>
<td>
<p>include the null () range (NA) in the matrix (LAGRANGE default=TRUE)</p>
</td></tr>
<tr><td><code id="rcpp_states_list_to_DEmat_+3A_normalize_tf">normalize_TF</code></td>
<td>
<p>should the columns be -1 * rowsums?</p>
</td></tr>
<tr><td><code id="rcpp_states_list_to_DEmat_+3A_makecoo_tf">makeCOO_TF</code></td>
<td>
<p>should the returned matrix be COO or standard dense (the latter is default).</p>
</td></tr>
<tr><td><code id="rcpp_states_list_to_DEmat_+3A_min_precision">min_precision</code></td>
<td>
<p>what is the effective minimum size for 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The size of the matrix will expand dramatically with the number of areas.  See <code><a href="#topic+numstates_from_numareas">numstates_from_numareas</a></code> for the calculation.
</p>
<p>Above 7 or so areas, making <code>Qmat</code> a COO-formatted matrix (COO=Coordinate list, see wikipedia, <a href="http://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">http://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29</a> ) which can then be used in <code>rexpokit</code>'s sparse-matrix algorithms,
should be more efficient. (Sparse matrices are matrices made of mostly 0s.)
</p>


<h3>Value</h3>

<p>dmat (a standard Q matrix)
</p>


<h3>Author(s)</h3>

<p>Nicholas Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">http://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29</a>
#bibliography /Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp_refs.bib
@cite Matzke_2013
@cite Matzke_2014
@cite ReeSmith2008
</p>


<h3>See Also</h3>

<p><code><a href="#topic+numstates_from_numareas">numstates_from_numareas</a></code>, <code><a href="stats.html#topic+convolve">convolve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Specify the areas
areas_list_txt = c("A", "B", "C")
areas_list_txt

# rcpp_states_list_to_DEmat function requires a 0-based list of areas
areas_list = seq(0, length(areas_list_txt)-1, 1)
areas_list

## Not run: 

# Calculate the list of 0-based indices for each possible 
#geographic range, i.e. each combination of areas
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=3, 
include_null_range=FALSE)
states_list
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=3, 
include_null_range=TRUE)
states_list
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=2, 
include_null_range=TRUE)
states_list
states_list = rcpp_areas_list_to_states_list(areas=areas_list, maxareas=1, 
include_null_range=TRUE)
states_list

# Hard-code the along-branch dispersal and extinction rates
d = 0.2
e = 0.1

# Calculate the dispersal weights matrix and the extinction weights matrix
# Equal dispersal in all directions (unconstrained)
areas = areas_list
distances_mat = matrix(1, nrow=length(areas), ncol=length(areas))
dmat = matrix(d, nrow=length(areas), ncol=length(areas))
dmat

# Equal extinction probability for all areas
elist = rep(e, length(areas))
elist

# Set up the instantaneous rate matrix (Q matrix, Qmat)
# DON'T force a sparse-style (COO-formatted) matrix here
force_sparse = FALSE
Qmat = rcpp_states_list_to_DEmat(areas_list, states_list, dmat, elist, 
include_null_range=TRUE, normalize_TF=TRUE, makeCOO_TF=force_sparse)
Qmat

# DO force a sparse-style (COO-formatted) matrix here
force_sparse = TRUE
Qmat = rcpp_states_list_to_DEmat(areas_list, states_list, dmat, elist, 
include_null_range=TRUE, normalize_TF=TRUE, makeCOO_TF=force_sparse)
Qmat


# Repeat with an amat
amat = dmat
amat[is.numeric(amat)] = 0.33

# Set up the instantaneous rate matrix (Q matrix, Qmat)
# DON'T force a sparse-style (COO-formatted) matrix here
force_sparse = FALSE
Qmat = rcpp_states_list_to_DEmat(areas_list, states_list, dmat, elist, amat, 
include_null_range=TRUE, normalize_TF=TRUE, makeCOO_TF=force_sparse)
Qmat

# DO force a sparse-style (COO-formatted) matrix here
force_sparse = TRUE
Qmat = rcpp_states_list_to_DEmat(areas_list, states_list, dmat, elist, amat, 
include_null_range=TRUE, normalize_TF=TRUE, makeCOO_TF=force_sparse)
Qmat

## End(Not run)


</code></pre>

<hr>
<h2 id='strsplit3'>String splitting shortcut</h2><span id='topic+strsplit3'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+strsplit">strsplit</a></code> returns the results inside a list, which is annoying. <code>strsplit3</code> shortens the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsplit3(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strsplit3_+3A_x">x</code></td>
<td>
<p>A string to split</p>
</td></tr>
<tr><td><code id="strsplit3_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="base.html#topic+strsplit">strsplit</a></code>.  The argument <code>split</code> is <em>required</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>out</code> The output from inside the list.
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">strsplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# strsplit returns the results inside a list element
out = strsplit("ABC", split="")
out
# I.e....
out[[1]]

# If this is annoying/ugly in the code, use strsplit3:
out = strsplit3("ABC", split="")
out

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
