<!DOCTYPE html><html><head><title>Help for package cabootcrs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cabootcrs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cabootcrs-package'>
<p>Bootstrap Confidence Regions for Simple and Multiple Correspondence Analysis</p></a></li>
<li><a href='#addsupplementary'><p>Calculate coordinates for supplementary points, with option to add to the currently selected plot.</p></a></li>
<li><a href='#allvarscovs'><p>Extract all variances and covariances in readable form as a data frame</p></a></li>
<li><a href='#AsbestosData'><p>Asbestos data</p></a></li>
<li><a href='#AttachmentData'><p>van Ijzendoorn's attachment data</p></a></li>
<li><a href='#cabasicresults-class'><p>A class containing the basic results from CA</p></a></li>
<li><a href='#cabootcrs'><p>Calculate category point variances using bootstrapping</p></a></li>
<li><a href='#cabootcrsresults-class'><p>A class containing the results from CA with bootstrapping</p></a></li>
<li><a href='#convert'><p>Converting a data matrix from one format into another</p></a></li>
<li><a href='#covmat'><p>Extract a single 2 by 2 covariance matrix</p></a></li>
<li><a href='#DreamData'><p>Maxwell's dream data set, with simplified labels</p></a></li>
<li><a href='#DreamData223by3'><p>Maxwell's dream data set with added totally random column</p></a></li>
<li><a href='#DreamDataNames'><p>Maxwell's dream data set, using full original labels</p></a></li>
<li><a href='#getBurt'><p>Converting a data matrix into a Burt matrix</p></a></li>
<li><a href='#getCT'><p>Converting a data matrix into a contingency table</p></a></li>
<li><a href='#getdoubled'><p>Converting a data matrix into a doubled matrix</p></a></li>
<li><a href='#getindicator'><p>Converting a data matrix into an indicator matrix</p></a></li>
<li><a href='#myresamplefn'><p>Example of a user-generated resampling routine.</p></a></li>
<li><a href='#NishData'><p>Nishisato's Singapore data</p></a></li>
<li><a href='#OsteoData'><p>Osteoarchaeological data with categories given as numbers</p></a></li>
<li><a href='#OsteoDataNames'><p>Osteoarchaeological data with named categories</p></a></li>
<li><a href='#plotca'><p>Plotting results with confidence regions</p></a></li>
<li><a href='#printca'><p>Prints reasonably full results, including variances</p></a></li>
<li><a href='#rearrange'><p>Rearranges bootstrap axes by comparing to sample axes</p></a></li>
<li><a href='#rearrange_old'><p>Old and rubbish algorithm to rearrange bootstrap axes by comparing to sample axes</p></a></li>
<li><a href='#reflectaxes'><p>Reflect coordinates for chosen axes</p></a></li>
<li><a href='#reordercategories'><p>Reorder categories for chosen variable in MCA case only</p></a></li>
<li><a href='#sca'><p>Performs standard Correspondence Analysis calculations</p></a></li>
<li><a href='#settingsinertias'><p>Internal function to be used by printca and summaryca</p></a></li>
<li><a href='#SuicideData'><p>Suicide data</p></a></li>
<li><a href='#summaryca'><p>Prints brief 2-d results, with standard deviations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bootstrap Confidence Regions for Simple and Multiple
Correspondence Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor Ringrose</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevor Ringrose &lt;t.j.ringrose@cranfield.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs simple correspondence analysis on a two-way contingency table, 
    or multiple correspondence analysis (homogeneity analysis) 
    on data with p categorical variables,
    and produces bootstrap-based elliptical confidence regions around the 
    projected coordinates for the category points. 
    Includes routines to plot the results in a variety of styles. 
    Also reports the standard numerical output for correspondence analysis.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), lpSolve, colorspace</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ellipse</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-02 22:42:06 UTC; Teapot</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-02 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cabootcrs-package'>
Bootstrap Confidence Regions for Simple and Multiple Correspondence Analysis
</h2><span id='topic+cabootcrs-package'></span>

<h3>Description</h3>

<p>Performs simple (classical) correspondence analysis
on a two-way contingency table and produces bootstrap-based confidence regions
around the projected coordinates for the category points.
Includes additional routines for summarising the output and for
plotting the results in a variety of ways, including both french and biplot styles.
</p>
<p>Performs multiple correspondence analysis (homogeneity analysis)
of a Burt matrix (a matrix of two-way contingency tables for p variables)
and produces bootstrap-based confidence regions
around the projected coordinates for the variable category points.
This includes a new method to correct the confidence regions
for the well-known distortion of the results
caused by the diagonal of the Burt matrix.
Also contains a highly experimental method to produce confidence regions
when analysing an indicator matrix.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> cabootcrs</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-02-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> lpSolve, colorspace </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><strong>Simple Correspondence Analysis:</strong>
</p>
<p>Correspondence Analysis plots usually only show the coordinates for each of
the row and column category points projected onto the new axes, with no indication of
the degree of sampling variation. This package produces bootstrap-based confidence
ellipses for each of the row and column points with respect to the axes shown.
</p>
<p>These confidence regions are based on the sampling variation of the difference between
sample and population points when both are projected onto the sample axes, allowing for
variation in both the points and the axes and the correlation between them. Hence the coverage
percentage is the chance of drawing a sample such that the confidence ellipse contains
the population point when it is projected onto the samples axes as a supplementary point.
See the reference below for further details.
</p>
<p>There are options for different ways of generating the bootstrap resamples,
notably based on either the Poisson or the multinomial distribution, with
the latter allowing the option of fixed row or column sums.
</p>
<p>Correspondence analysis results can be plotted in two main ways.
The default option here is to produce a biplot where the row category
points are plotted in principal coordinates
(i.e. coordinates which allow for the different inertias of the axes)
and the confidence ellipses are shown for these row category points.
The column category points are shown in standard coordinates on this plot
and drawn as directions in the common biplot style.
A second biplot is also produced where the roles of the rows and columns are reversed.
</p>
<p>The other main plotting option is to produce a &quot;french-style&quot; plot where both
row categories and column categories are plotted as points in principal coordinates.
However, again two plots are produced, one with confidence ellipses
for the row category points and one with confidence ellipses for the
column category points. This is a deliberate restriction, partly to reduce
plot clutter but mostly to emphasize that the row and column points
are in different spaces and that their relative positions should not be over-interpreted.
</p>
<p>There are several options for different ways of plotting the data,
with simple choices to vary the colour schemes, or to suppress point labels,
or to show only a few of the ellipses, intended particularly to reduce
the clutter in pictures with large data matrices.
There is also an option for fuller control over the graphics, by supplying
either files or data frames to define groups of points which can be plotted
in common colours and symbols, or to suppress their point labels and ellipses.
</p>
<p>The package can also be used just to perform Correspondence Analysis as usual,
but with the above plotting options available.
</p>
<p>The package can also be used just to produce the covariance matrices for each
of the category points, which for example can then be used with ellipse() to add
confidence ellipses to results from the ca() and mjca() (below) routines in the ca package.
</p>
<p><strong>Multiple Correspondence Analysis:</strong>
</p>
<p>The same principles as above carry over to the Multiple Correspondence Analysis
case with p categorical variables.
</p>
<p>The recommended approach is to bootstrap the indicator matrix
and then apply MCA to the derived Burt matrix.
A new method is provided in the variance calculations to correct for the
well-known problems induced by the diagonal of the Burt matrix.
</p>
<p>Standard options for correcting inertias and coordinates are also given.
In particular options exists such that MCA with p=2 gives the same
results as SCA, so that MCA can be regarded as a proper generalisation of SCA
(not all would agree with this, however).
</p>
<p>The default plotting of the results is to produce p plots,
with each plot showing confidence ellipses for all of the categories of just one variable.
This is again done to reduce plot clutter, albeit at the expense of more plots.
Again, numerous options for controlling the plots are provided.
</p>
<p>Bootstrapping can also be applied to the analysis of an indicator matrix or a doubled matrix,
but the procedure is highly experimental and very slow.
</p>
<p>The data set can be input in numerous formats, and routines are provided
to convert between them. However note that the data cannot be inputted as
a Burt matrix because this loses some of the information in the data.
</p>
<p><strong>Changes from Version 1.0:</strong>
</p>
<p>Multiple correspondence analysis routines added.
</p>
<p>Hungarian algorithm added for axis rearranging, to replace the embarrassingly poor
method used previously.
</p>
<p>Bootstrap critical values added, and are now the default.
</p>
<p>Numerous fairly minor changes made to existing simple correspondence analysis routines.
</p>
<p>New routines to convert data between different formats.
</p>
<p>There may be a little backwards incompatibility as some options to the routines
have changed a bit, but standard use with few options will still work.
Any changes should produce easily fixable failures to run.
</p>
<p><strong>Changes from Version 2.0:</strong>
</p>
<p>Debugging, including for plotca to call dev.new() when in R but not Rstudio,
and option to call it from Rstudio.
</p>
<p>New routines to reflect axes and reorder categories,
e.g. for when using results with other packages.
</p>
<p>New routine to add supplementary points to plots.
</p>
<p>More options and examples for plotting.
</p>
<p><strong>Final Notes:</strong>
</p>
<p>The package does not use any routines from any of the
other Correspondence Analysis packages, only base R routines.
This was deliberate, in order to maintain control over the precise details.
The only external routines used are lp.assign, from the lpSolve package, for the Hungarian algorithm,
and some hcl functions from the colo(u)rspace package for plotting.
</p>
<p>The results can be used as input to other packages, such as using ellipse()
to draw the ellipses on a plot from ca(), see <code><a href="#topic+covmat">covmat</a></code>
and <code><a href="#topic+plotca">plotca</a></code> for this.
</p>


<h3>Author(s)</h3>

<p>T.J. Ringrose &lt;t.j.ringrose@cranfield.ac.uk&gt;
</p>


<h3>References</h3>

<p>Ringrose, T.J. (2012).
Bootstrap confidence regions for correspondence analysis. <br />
Journal of Statistical Computation and Simulation.
Vol 83, No. 10, October 2012, 1397-1413.<br /><br />
A paper on the application to MCA is in preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs">cabootcrs</a></code> ,
<code><a href="#topic+plotca">plotca</a></code> ,
<code><a href="#topic+summaryca">summaryca</a></code> ,
<code><a href="#topic+printca">printca</a></code> ,
<code><a href="#topic+convert">convert</a></code> ,
<code><a href="#topic+covmat">covmat</a></code> ,
<code><a href="#topic+allvarscovs">allvarscovs</a></code> ,
<code><a href="#topic+reflectaxes">reflectaxes</a></code> ,
<code><a href="#topic+reordercategories">reordercategories</a></code> ,
<code><a href="#topic+addsupplementary">addsupplementary</a></code> ,
<code><a href="#topic+sca">sca</a></code> ,
<code><a href="#topic+rearrange">rearrange</a></code> ,
<code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code> ,
<code><a href="#topic+cabasicresults-class">cabasicresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data frame of a contingency table, with row and column labels

data(DreamData)

# Perform (simple) correspondence analysis, calculate variances and show confidence ellipses.
# Use all defaults: 999 bootstrap replicates, Poisson resampling, calculate variances
# only for first two axes, but give usual output for up to the first 4 axes.
# Show one biplot with confidence ellipses for row points in principal coordinates,
# another biplot with confidence ellipses for column points in principal coordinates.
# In each case the other set of points are in standard coordinates, but note that the
# lines are cropped to fit the plot by default, as it is the directions that matter most.

bd &lt;- cabootcrs(DreamData)

# Plot in "french" style where both rows and columns are in principal coordinates,
# not as a biplot, but still produce two plots, with row ellipses in one plot
# and column ellipses in the other.

plotca(bd, plottype="french")

## Not run: 

# See the stored results, an object of type cabootcrsresults

bd

# Prettier printed output, no plots.

printca(bd)

# Brief summary output, similar style to ca package, no plots

summaryca(bd,datasetname="Dreams")

# Extract the covariance matrix of:
# row 4 for axes 1 and 2;
# column 1 for axes 1 and 2.

vmr4 &lt;- covmat(bd,4,"row",1,2)
vmc1 &lt;- covmat(bd,1,"column",1,2)

# Display all variances and covariances for each row and column, axes 1-2

allvarscovs(bd, "rows")
allvarscovs(bd, "columns")

# Convert the data set into a 223 individuals by 2 variables
# matrix of category membership values

ddnbyp &lt;- convert(DreamData,input="CT",output="nbyp")$result

# Perform multiple correspondence analysis with all defaults:
# non-parametric resampling, analyse Burt matrix, correct for
# the Burt diagonal in the inertias, coordinates and bootstrapping.
# Note that the coordinates, inertias etc are identical to those
# from simple CA above, while the standard deviations and hence
# the ellipses are very similar, but not quite the same.

bdmca &lt;- cabootcrs(ddnbyp, catype="mca")


## End(Not run)

</code></pre>

<hr>
<h2 id='addsupplementary'>Calculate coordinates for supplementary points, with option to add to the currently selected plot.</h2><span id='topic+addsupplementary'></span>

<h3>Description</h3>

<p><code>addsupplementary</code> calculates principal coordinate values for supplementary rows or columns in SCA,
or supplementary variables in MCA, then plots them on the current selected graph, which it assumes to be appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addsupplementary(
  x,
  supp,
  thing = "columns",
  suppsymbol = "*",
  suppcolour = "blue",
  plotsupp = TRUE,
  varandcat = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addsupplementary_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code></p>
</td></tr>
<tr><td><code id="addsupplementary_+3A_supp">supp</code></td>
<td>
<p>A data frame in the format:<br />
SCA supplementary rows: each row is a supplementary row category, the columns are the same as in the original data,
each cell value is the cross-classified count.<br />
SCA supplementary columns: each row is a supplementary column category, the columns are the same as the rows in the original data,
each cell value is the cross-classified count.<br />
MCA supplementary variables: each row is the same individual as in the original data, each column is a supplementary variable,
each cell value is the category which that individual belongs to.</p>
</td></tr>
<tr><td><code id="addsupplementary_+3A_thing">thing</code></td>
<td>
<p>Whether to calculate the supplementary principal coordinates for
</p>

<dl>
<dt>&quot;rows&quot;</dt><dd><p>rows, or</p>
</dd>
<dt>&quot;columns&quot;</dt><dd><p>columns</p>
</dd>
</dl>

<p>Note that &quot;rows&quot; is only needed for supplementary rows in SCA.</p>
</td></tr>
<tr><td><code id="addsupplementary_+3A_suppsymbol">suppsymbol</code></td>
<td>
<p>The plot symbol used for the supplementary points</p>
</td></tr>
<tr><td><code id="addsupplementary_+3A_suppcolour">suppcolour</code></td>
<td>
<p>The colour of the supplementary points and their labels</p>
</td></tr>
<tr><td><code id="addsupplementary_+3A_plotsupp">plotsupp</code></td>
<td>
<p>TRUE if you want the points plotted on the currently active graph, FALSE otherwise</p>
</td></tr>
<tr><td><code id="addsupplementary_+3A_varandcat">varandcat</code></td>
<td>
<p>Flag for how to construct column names for supplementary variables in MCA:
</p>

<dl>
<dt>TRUE</dt><dd><p>if many variables have the same categories, e.g. Likert, column names will be varname:catname</p>
</dd>
<dt>FALSE</dt><dd><p>when variables have distinct categories, column names will just be category names</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>To add supplementary rows in SCA, define the parameter supp as a data frame with one named row for each supplementary row
and with the columns the same as in the original data.<br />
If plotting the points, ensure that the plot for rows is selected.
</p>
<p>To add supplementary columns in SCA define the parameter supp as a data frame with one named row for each supplementary column
and with the columns the same as the rows in the original data.<br />
If plotting the points, ensure that the plot for columns is selected.
</p>
<p>To add supplementary variables in MCA define the parameter supp as a data frame with one column for each supplementary variable in
individuals by variables format.
Each row represents the same individual as the same row in the original data,
and each entry is the category value for that supplementary variable.
Hence the new columns should just look exactly like new columns in the 'nbyp' format.<br />
If plotting the points, any of the standard plots is suitable.
</p>


<h3>Value</h3>

<p>A matrix containing the principal coordinates of the supplementary points
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>, <code><a href="#topic+plotca">plotca</a></code>, <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- cabootcrs(DreamData)
# SCA case two supplementary columns, make sure that the Columns plot is active
suppcols &lt;- data.frame(rbind(c(5,3,6,8,12),c(1,7,3,1,5)))
suppcolpc &lt;- addsupplementary(results, suppcols)
suppcolpc

## Not run: 
# SCA case one supplementary row, make sure that the Rows plot is active
supprow &lt;- data.frame(cbind(12,4,8,3),row.names="supprow")
supprowpc &lt;- addsupplementary(results, supprow, thing="rows")
supprowpc

# MCA case, one or two supplementary variables, plots the same on any of the usual plots
results3 &lt;- cabootcrs(DreamData223by3, catype="mca", varandcat=FALSE,
                      datasetname="Dream data with extra random column")
newsupcol &lt;- c(rep(c(rep("s1",10),rep("s2",10),rep("s3",10)),8))[1:223]
newsupcol2 &lt;- c(rep(c(rep("t1",5),rep("t2",15),rep("t3",25),rep("t4",35)),5))[1:223]
newsupcols &lt;- cbind(newsupcol,newsupcol2)
suppvarpc &lt;- addsupplementary(results3, newsupcol, varandcat=FALSE)
supp2varpc &lt;- addsupplementary(results3, newsupcols, varandcat=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='allvarscovs'>Extract all variances and covariances in readable form as a data frame</h2><span id='topic+allvarscovs'></span>

<h3>Description</h3>

<p><code>allvarscovs</code> extracts all variances and covariances for either rows or columns
and puts them in a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allvarscovs(x, thing = "columns")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allvarscovs_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code></p>
</td></tr>
<tr><td><code id="allvarscovs_+3A_thing">thing</code></td>
<td>
<p>Whether to extract the variances for
</p>

<dl>
<dt>&quot;rows&quot;</dt><dd><p>rows, or</p>
</dd>
<dt>&quot;columns&quot;</dt><dd><p>columns</p>
</dd>
</dl>

<p>Note that default is &quot;columns&quot; as this is more convenient for MCA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row for each row or column category
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>,
<code><a href="#topic+covmat">covmat</a></code>, <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- cabootcrs(DreamData, showresults=FALSE)
rowvars &lt;- allvarscovs(results,"rows")
colvars &lt;- allvarscovs(results,"columns")

## Not run: 

resultsmca &lt;- cabootcrs(DreamData223by3, catype="mca", showresults=FALSE)
allvars &lt;- allvarscovs(resultsmca)


## End(Not run)

</code></pre>

<hr>
<h2 id='AsbestosData'>Asbestos data</h2><span id='topic+AsbestosData'></span>

<h3>Description</h3>

<p>Cases and severity of asbestosis, classified by years working with asbestos
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AsbestosData
</code></pre>


<h3>Format</h3>

<p>A contingency table with 5 rows and 4 columns
</p>

<dl>
<dt>rows</dt><dd><p>Years working with asbestos: 0-9, 10-19, 20-29, 30-39, 40+</p>
</dd>
<dt>columns</dt><dd><p>Has asbestosis or not: No (N), severity graded as 1-3 (G1-G3)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Still looking for it
</p>

<hr>
<h2 id='AttachmentData'>van Ijzendoorn's attachment data</h2><span id='topic+AttachmentData'></span>

<h3>Description</h3>

<p>Classification of mother's attachment to her child and child's reaction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AttachmentData
</code></pre>


<h3>Format</h3>

<p>A contingency table with 4 rows and 4 columns
</p>

<dl>
<dt>rows</dt><dd><p>Infant response: Avoidant, Secure, Resistant, Disorganised</p>
</dd>
<dt>columns</dt><dd><p>Mother's Classification: Dismissing, Autonomous, Preoccupied, Unresolved</p>
</dd>
</dl>



<h3>Source</h3>

<p>E.J. Beh,
<em>Elliptical confidence regions for simple correspondence analysis</em>,
Journal of Statistical Planning and Inference 140 (2010), pp. 2582&ndash;2588.
</p>

<hr>
<h2 id='cabasicresults-class'>A class containing the basic results from CA</h2><span id='topic+cabasicresults-class'></span>

<h3>Description</h3>

<p>This is intended for internal use within <code><a href="#topic+cabootcrs">cabootcrs</a></code> and only contains the
data structures required for each bootstrap replicate
</p>


<h3>Slots</h3>


<dl>
<dt><code>Rprofile</code></dt><dd><p>Row profile matrix, class <code>"matrix"</code></p>
</dd>
<dt><code>Cprofile</code></dt><dd><p>Column profile matrix, class <code>"matrix"</code></p>
</dd>
<dt><code>Rweights</code></dt><dd><p>Matrix of weights for row points: square roots of inverse column sums, class <code>"matrix"</code></p>
</dd>
<dt><code>Cweights</code></dt><dd><p>Matrix of weights for column points: square roots of inverse row sums, class <code>"matrix"</code></p>
</dd>
<dt><code>Raxes</code></dt><dd><p>Matrix of axes for row points: right singular vectors of weighted, centred data matrix, class <code>"matrix"</code></p>
</dd>
<dt><code>Caxes</code></dt><dd><p>Matrix of axes for column points: left singular vectors of weighted, centred data matrix, class <code>"matrix"</code></p>
</dd>
<dt><code>r</code></dt><dd><p>Rank of weighted, centred data matrix, class <code>"numeric"</code></p>
</dd>
<dt><code>realr</code></dt><dd><p>In multiple CA, the number of singular values (Burt matrix) or squared singular values
(indicator matrix) exceeding <code class="reqn">1/p</code> where <code class="reqn">p</code> is the number of variables,
class <code>"numeric"</code></p>
</dd>
<dt><code>mu</code></dt><dd><p>Singular values of weighted, centred data matrix, class <code>"numeric"</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>

<hr>
<h2 id='cabootcrs'>Calculate category point variances using bootstrapping</h2><span id='topic+cabootcrs'></span>

<h3>Description</h3>

<p><code>cabootcrs</code> performs simple or multiple correspondence analysis
and uses bootstrap resampling to
construct confidence ellipses for each appropriate category point,
printing and plotting the results;
for help on the package see <code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cabootcrs(
  xobject = NULL,
  datafile = NULL,
  datasetname = NULL,
  nboots = 999,
  resampledistn = "Poisson",
  multinomialtype = "whole",
  printdims = 4,
  lastaxis = 4,
  maxrearrange = 6,
  rearrangemethod = "lpassign",
  usebootcrits = TRUE,
  groupings = NULL,
  grouplabels = NULL,
  varnames = NULL,
  plotsymbolscolours = c(19, "inferno", 18, "inferno"),
  othersmonochrome = "grey",
  crpercent = 95,
  catype = "sca",
  scainput = "CT",
  mcainput = "nbyp",
  mcatype = "Burt",
  mcavariant = "mca",
  mcasupplementary = "offdiag",
  mcaadjustinertias = TRUE,
  mcauseadjustinertiasum = FALSE,
  mcaadjustcoords = TRUE,
  mcaadjustmassctr = FALSE,
  mcaoneploteach = TRUE,
  mcashowindividuals = FALSE,
  mcavariablecolours = FALSE,
  mcacategorycolours = FALSE,
  Jk = NULL,
  varandcat = TRUE,
  likertarrows = FALSE,
  mcastoreindicator = TRUE,
  mcaindividualboot = FALSE,
  mcalikertnoise = 0.1,
  poissonzeronewmean = 0,
  newzeroreset = 0,
  bootstdcoords = FALSE,
  reflectonly = FALSE,
  showresults = TRUE,
  eps = 1e-15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cabootcrs_+3A_xobject">xobject</code></td>
<td>
<p>Name of data object (data frame or similar class that can be coerced to data frame).<br />
For simple CA (SCA) the default is contingency table format, recommended that rows &gt;= columns. <br />
For multiple CA (MCA) the default is an n individuals by p variables matrix of category values (numbers or text).</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_datafile">datafile</code></td>
<td>
<p>Name of a text file (in &quot; &quot;) containing the data, same defaults as xobject, ignored if xobject is non-null</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_datasetname">datasetname</code></td>
<td>
<p>A string to use as the name of the data set in the plots, defaults to name of xobject or datafile</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_nboots">nboots</code></td>
<td>
<p>Number of boostrap replicate matrices used, default and recommended minimum is 999,
but 9999 is recommended if machine and data set size allows;
the calculated variances will sometimes differ
around the third decimal place, but the pictures should look the same. <br />
If nboots=0 then correspondence analysis is performed as usual with no variances calculated</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_resampledistn">resampledistn</code></td>
<td>
<p>Poisson resampling is the default for SCA,<br />
nonparametric is the default for MCA (Poisson and multinomial will both default to nonparametric)
</p>

<dl>
<dt>&quot;Poisson&quot;</dt><dd><p>resampled matrices constructed using Poisson resampling on each cell separately (only SCA)</p>
</dd>
<dt>&quot;multinomial&quot;</dt><dd><p>resampled matrices constructed using multinomial resampling, treating the
cells as defining one or more multinomial distributions (only SCA)</p>
</dd>
<dt>&quot;nonparametric&quot;</dt><dd><p>non-parametric resampling of the rows of the n individuals by p variables matrix, equivalent to multinomial (only MCA)</p>
</dd>
<dt>&quot;balanced&quot;</dt><dd><p>multinomial resampling balanced so that each data point occurs equally often over the resamples (only MCA)</p>
</dd>
<dt>&quot;myresample&quot;</dt><dd><p>resampling algorithm is contained in a file called myresample.R</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_multinomialtype">multinomialtype</code></td>
<td>
<p>Only relevant for multinomial sampling in SCA, otherwise ignored:
</p>

<dl>
<dt>&quot;whole&quot;</dt><dd><p>all cells define a single multinomial distribution</p>
</dd>
<dt>&quot;rowsfixed&quot;</dt><dd><p>row sums fixed, each row defines a separate multinomial distribution</p>
</dd>
<dt>&quot;columnsfixed&quot;</dt><dd><p>column sums fixed, each column defines a separate multinomial distribution</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_printdims">printdims</code></td>
<td>
<p>Print full correspondence analysis coordinates, contributions, correlations etc for all output
dimensions up to and including this one</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_lastaxis">lastaxis</code></td>
<td>
<p>Calculate variances and covariances for all output axes (dimensions) up to this one
(or the number of dimensions in the solution if smaller). <br />
Recommended maximum is maxrearrange-1 as variances for those above this axis may be inaccurate</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_maxrearrange">maxrearrange</code></td>
<td>
<p>The maximum number of axes to consider when rearranging</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_rearrangemethod">rearrangemethod</code></td>
<td>
<p>The method used to rearrange the axes:
</p>

<dl>
<dt>&quot;lpassign&quot;</dt><dd><p>The Hungarian algorithm in the lpSolve package</p>
</dd>
<dt>anything else</dt><dd><p>The embarrassingly slow direct comparison method used in version 1.0 - don't use it</p>
</dd>
</dl>

<p>Option is only included in case something weird goes wrong with lpSolve.</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_usebootcrits">usebootcrits</code></td>
<td>
<p>To be passed to the plot routine, see <code><a href="#topic+plotca">plotca</a></code> for details</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_groupings">groupings</code></td>
<td>
<p>To be passed to the plot routine, see <code><a href="#topic+plotca">plotca</a></code> for details</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_grouplabels">grouplabels</code></td>
<td>
<p>To be passed to the plot routine, see <code><a href="#topic+plotca">plotca</a></code> for details</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_varnames">varnames</code></td>
<td>
<p>Character p-vector naming the variables, defaults to c(&quot;Rows&quot;,&quot;Columns&quot;) in sca</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_plotsymbolscolours">plotsymbolscolours</code></td>
<td>
<p>To be passed to the plot routine, see <code><a href="#topic+plotca">plotca</a></code> for details</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_othersmonochrome">othersmonochrome</code></td>
<td>
<p>To be passed to the plot routine, see <code><a href="#topic+plotca">plotca</a></code> for details</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_crpercent">crpercent</code></td>
<td>
<p>To be passed to the plot routine, see <code><a href="#topic+plotca">plotca</a></code> for details</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_catype">catype</code></td>
<td>
<p>Type of correspondence analysis:
</p>

<dl>
<dt>&quot;sca&quot;</dt><dd><p>Simple (classical) correspondence analysis of a contingency table</p>
</dd>
<dt>&quot;mca&quot;</dt><dd><p>Multiple correspondence analysis of a Burt, indicator or doubled matrix</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_scainput">scainput</code></td>
<td>
<p>Format of input data, only applies for SCA:
</p>

<dl>
<dt>&quot;CT&quot;</dt><dd><p>Contingency table of counts, preferably with rows &gt;= columns</p>
</dd>
<dt>&quot;nbyp&quot;</dt><dd><p>An n individuals/objects/data points by p=2 categorical variables matrix,
where each row is a different data point and each column contains the category
for that data point on that variable, where these categories can be numbers, strings or factors</p>
</dd>
<dt>&quot;nbypcounts&quot;</dt><dd><p>Similar to the above, but each row represents all of the data points taking
the same combination of categories, and the first column contains the count for this combination
(hence the name used here is a bit of a misnomer, but it emphasises the similarities to an n by p=2)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcainput">mcainput</code></td>
<td>
<p>Format of input data, only applies for MCA:
</p>

<dl>
<dt>&quot;nbyp&quot;</dt><dd><p>An n individuals/objects/data points by p categorical variables matrix,
where each row is a different data point and each column contains the category
for that data point on that variable, where these categories can be numbers, strings or factors</p>
</dd>
<dt>&quot;nbypcounts&quot;</dt><dd><p>Similar to the above, but each row represents all of the data points taking
the same combination of categories, and the now first column contains the count for this combination,
so that the input matrix is n by p+1
(hence the name used here is a bit of a misnomer, but it emphasises the similarities to an n by p)</p>
</dd>
<dt>&quot;indicator&quot;</dt><dd><p>An n by sum-of-distinct-variable-categories (i.e. sum of elements of Jk) indicator matrix</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcatype">mcatype</code></td>
<td>
<p>Format of data matrix analysed, only applies for MCA:
</p>

<dl>
<dt>&quot;Burt&quot;</dt><dd><p>Analyse the Burt matrix. Output will be given for the column (variable category) points but
not for the (identical) row points. <br />
NOTE: it is highly recommended that this version is used</p>
</dd>
<dt>&quot;indicator&quot;</dt><dd><p>Analyse the indicator matrix. Output will be given for the column (variable category)
points but not usually for the row (individual) points. <br />
NOTE: the bootstrap method used in this case is highly experimental and very slow, see Details section part (2)</p>
</dd>
<dt>&quot;doubled&quot;</dt><dd><p>Analyse the doubled matrix. Output will be given for the column
points (two points, high and low, for each variable) but not usually for the row (individual) points. <br />
NOTE: the bootstrap method used in this case is highly experimental and very slow, see Details section part (2)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcavariant">mcavariant</code></td>
<td>
<p>Currently must be &quot;mca&quot;, placeholder for future updates</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcasupplementary">mcasupplementary</code></td>
<td>
<p>How the sample points are projected as supplementary points onto the bootstrap axes
when calculating the variances in MCA of a Burt matrix, see Details section for full explanation
</p>

<dl>
<dt>&quot;offdiag&quot;</dt><dd><p>Only the off-diagonal parts of the Burt matrix are used in the projection</p>
</dd>
<dt>&quot;all&quot;</dt><dd><p>Projection is calculated in the usual way</p>
</dd>
</dl>

<p>If &quot;offdiag&quot; then when p=2 the variances will be very similar to those from SCA. <br /><br />
If &quot;all&quot; then the fact that the diagonal elements of the Burt matrix are by definition
the same for both the sample and bootstrap matrices
means that the projected differences between sample and population points,
and hence the variances, will be artificially small. <br /><br />
NOTE: if mcaadjustinertias is FALSE then mcasupplementary will be set to &quot;all&quot;,
because adjusting the coordinates in the calculation of the variances but not adjusting
the inertias makes no sense</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcaadjustinertias">mcaadjustinertias</code></td>
<td>
<p>Whether to adjust inertias to allow for the meaningless inertia terms
induced by the diagonal of the Burt matrix in MCA:
</p>

<dl>
<dt>TRUE</dt><dd><p>Analysing Burt matrix: subtract 1/p from all singular values, then positive singular values are
multiplied by p/(p-1) while negative ones are ignored <br />
Analysing indicator matrix: same applies but to the squared singular values </p>
</dd>
<dt>FALSE</dt><dd><p>No adjustment</p>
</dd>
</dl>

<p>If TRUE then when p=2 the inertias will agree with those from SCA. <br /><br />
NOTE: inertias are the square (Burt) or fourth power (indicator) of the (adjusted) singular values.<br /><br />
NOTE: if mcaadjustinertias is FALSE then mcaadjustcoords will also be set to FALSE and mcasupplementary
set to &quot;all&quot;, as adjusting the coordinates but not the inertias makes no sense</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcauseadjustinertiasum">mcauseadjustinertiasum</code></td>
<td>
<p>How to define the total inertia in MCA,
whether to just use the sum of the adjusted inertias:
</p>

<dl>
<dt>TRUE</dt><dd><p>The inertias are expressed as a percentage of the sum of the adjusted inertias (Benzecri)</p>
</dd>
<dt>FALSE</dt><dd><p>The inertias are expressed as a percentage of the average of off-diagonal inertias (Greenacre),
note that this will be incorrect if Jk includes categories that are not observed in the data </p>
</dd>
</dl>

<p>If TRUE then when p=2 the inertias will agree with those from SCA <br />
If TRUE then the percentage inertias will sum to 100% <br />
If FALSE then the percentage inertias will usually sum to less than 100%</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcaadjustcoords">mcaadjustcoords</code></td>
<td>
<p>Whether to adjust the principal coordinates in MCA using the adjusted
inertias above, as in Greenacre and Blasius, p68:
</p>

<dl>
<dt>TRUE</dt><dd><p>Adjust coordinates, but only for column points</p>
</dd>
<dt>FALSE</dt><dd><p>No adjustment</p>
</dd>
</dl>

<p>If TRUE then when p=2 the coordinates will agree with those from SCA. <br /><br />
NOTE: if mcaadjustinertias is FALSE then mcaadjustcoords will also be set to FALSE, as adjusting the coordinates
but not the inertias makes no sense</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcaadjustmassctr">mcaadjustmassctr</code></td>
<td>
<p>Whether to adjust the point masses and column contributions in MCA so that the masses and contributions are
with respect to each variable (as in SCA) rather than with respect to all variables together:
</p>

<dl>
<dt>TRUE</dt><dd><p>Multiply point masses and contributions by p so that they sum to p over all variables</p>
</dd>
<dt>FALSE</dt><dd><p>No adjustment</p>
</dd>
</dl>

<p>If TRUE then when p=2 the CTR will agree with those from SCA,
though when p&gt;2 the contributions can be &gt;1</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcaoneploteach">mcaoneploteach</code></td>
<td>
<p>Parameter passed to <code><a href="#topic+plotca">plotca</a></code> for MCA.<br /><br />
A flag saying whether to produce one plot for each variable,
where confidence ellipses are shown for that variable but not others:
</p>

<dl>
<dt>TRUE</dt><dd><p>p plots are produced, each showing confidence regions for the category points
for just one variable</p>
</dd>
<dt>FALSE</dt><dd><p>only one plot produced, with confidence regions shown for each category
point of each variable, which could be very &quot;busy&quot;</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcashowindividuals">mcashowindividuals</code></td>
<td>
<p>Parameter passed to <code><a href="#topic+plotca">plotca</a></code> for MCA.<br /><br />
For MCA on an indicator matrix only, a flag saying whether to plot the individuals:
</p>

<dl>
<dt>TRUE</dt><dd><p>plot the individuals, which could be very &quot;busy&quot;. <br />
NOTE: if mcaindividualboot=TRUE this also plots the CRs constructed using the experimental method,
see Details section part (2)</p>
</dd>
<dt>FALSE</dt><dd><p>don't plot the individuals</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcavariablecolours">mcavariablecolours</code></td>
<td>
<p>Parameter passed to <code><a href="#topic+plotca">plotca</a></code> for MCA:
</p>

<dl>
<dt>TRUE</dt><dd><p>In MCA each variable has its own colour, and all category
points and ellipses for that variable have the same colour</p>
</dd>
<dt>FALSE</dt><dd><p>Colours chosen in the default way</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcacategorycolours">mcacategorycolours</code></td>
<td>
<p>Parameter passed to <code><a href="#topic+plotca">plotca</a></code> for MCA:
</p>

<dl>
<dt>TRUE</dt><dd><p>In MCA each category number has its own colour,
and all points and ellipses for that category number have the same colour,
for all variables (intended for Likert type data so that all category 1 points are
the same colour etc)</p>
</dd>
<dt>FALSE</dt><dd><p>Colours chosen in the default way</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_jk">Jk</code></td>
<td>
<p>The number of classes for each variable in MCA, as a list or vector, which only needs
specifying when inputting an indicator matrix, as in other cases it can be derived from the input matrix</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_varandcat">varandcat</code></td>
<td>
<p>Flag for how to construct variable category names:
</p>

<dl>
<dt>TRUE</dt><dd><p>names are varname:catname, to be used if many variables have the same categories, e.g. Likert</p>
</dd>
<dt>FALSE</dt><dd><p>names are just category names, to be used if variables all have distinct categories</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cabootcrs_+3A_likertarrows">likertarrows</code></td>
<td>
<p>Parameter passed to <code><a href="#topic+plotca">plotca</a></code> for MCA.<br /><br />
If TRUE then, for likert-type ordered categorical data,
draw arrows connecting the category points for each variable,
with the arrow drawn from a category point to the next higher category point</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcastoreindicator">mcastoreindicator</code></td>
<td>
<p>If TRUE then store the indicator matrix created for MCA</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcaindividualboot">mcaindividualboot</code></td>
<td>
<p>If TRUE then use the experimental method to bootstrap an indicator or doubled matrix,
see Details section part (2) for full explanation</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_mcalikertnoise">mcalikertnoise</code></td>
<td>
<p>The &quot;noise&quot; value to use in the experimental method (above)
to bootstrap an indicator or doubled matrix,
see Details section part (2) for full explanation</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_poissonzeronewmean">poissonzeronewmean</code></td>
<td>
<p>Experimental method for SCA to deal with contingency tables where zero cells
could have been non-zero, i.e. they are not structural zeros.<br />
Only relevant for Poisson sampling in SCA, otherwise ignored:<br />
0 : no effect, method as described in paper <br />
1 : cells which are zero in the data are instead resampled from a
Poisson distribution with this mean, which should be very small (say 0.1);
this is for situations where rare cases did not occur but could have done,
so that it might be appropriate for zero cells in the sample to be
occasionally non-zero in resamples</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_newzeroreset">newzeroreset</code></td>
<td>
<p>Experimental method for SCA to deal with sparse contingency tables.<br />
Only relevant for SCA, otherwise ignored:<br />
0 : no effect, method as described in paper<br />
1 : if a cell value is non-zero in the sample but zero in the resample
then it is reset to 1 in the resample, so that the sparsity structure
of the sample is maintained in the resample. This can be useful with
sparse data sets and, in effect, conditions on the sample sparsity structure</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_bootstdcoords">bootstdcoords</code></td>
<td>
<p>If TRUE then produce bootstrap variances for points in standard coordinates
instead of principal coordinates<br />
Note: intended only for experiments with the methodology</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_reflectonly">reflectonly</code></td>
<td>
<p>If TRUE then just allow for axis reflections and not axis reorderings<br />
Note: intended only for experiments with the methodology</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_showresults">showresults</code></td>
<td>
<p>If TRUE then output the results using <code><a href="#topic+summaryca">summaryca</a></code>
and <code><a href="#topic+plotca">plotca</a></code>, otherwise output suppressed</p>
</td></tr>
<tr><td><code id="cabootcrs_+3A_eps">eps</code></td>
<td>
<p>Any value less than this is treated as zero in some calculations and comparisons</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine performs all of the usual Correspondence Analysis calculations while also using bootstrapping
to estimate the variance of the difference between the sample and population point when both are projected
onto the sample axes in principal coordinates.
This is done for each row and column category on each dimension of the solution,
allowing for sampling variation in both the points and the axes.
</p>
<p>It hence constructs confidence ellipses for each category point, plots the results
by a call to <code><a href="#topic+plotca">plotca</a></code> and prints the usual Correspondence Analysis summary
output and the calculated standard deviations through a call to <code><a href="#topic+summaryca">summaryca</a></code>.
Use <code><a href="#topic+printca">printca</a></code> for more detailed numerical results.
</p>
<p>For further examples and help on the package as a whole see <code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>.
</p>
<p><strong>(1) Corrections for Burt diagonal</strong>
</p>
<p>It is well-known that in multiple CA (MCA) the results are distorted by the diagonal elements of
the Burt matrix. As well as the standard methods to correct for this, here we propose
and implement a new method to correct for this when bootstrapping.
If bootstrapping is applied in a naive way then, even when the standard corrections are used,
the estimated variances will be much too small because diagonal elements of the standardised Burt matrix are
the same in every bootstrap replicate, thus underestimating the true variation in the data.
</p>
<p>All bootstrapping is performed on the indicator matrix (or equivalently the n by p matrix)
and the resampled Burt matrix is then constructed from the resampled indicator matrix in the usual way.
</p>
<p>Included here are the usual corrections to the
inertias (mcaadjustinertias=TRUE, the default)
and the coordinates (mcaadjustcoords=TRUE, the default).
In addition you can choose to use, as the total inertia, either
the sum of these adjusted inertias (mcauseadjustinertiasum=TRUE) as proposed by Benzecri or
the average of the off-diagonal inertias (mcauseadjustinertiasum=FALSE, the default)
as proposed by Greenacre.
You can adjust (multiply by p) the Contribution figures in MCA so that they sum to p over all variables,
i.e. an average of 1 for each variable as in SCA (mcaadjustmassctr=TRUE),
rather than a total of 1 over all variables, as usually in MCA (mcaadjustmassctr=FALSE, the default).
Note that when p=2 this will be the same as in SCA, but when p&gt;3 you can get contributions
greater than 1, so use with caution.
This also adjusts (multiplies by p) the point masses so that they sum to
1 for each variable, rather than over all variables, same caveat applies.
</p>
<p>The fundamental problem with MCA is that in a Burt matrix each diagonal element is the
value of a variable category cross-classified with itself, so it is always equal
to the number of times that category appears.
Hence if a category appears k times then the row (or column) in the Burt matrix
consists of p blocks each of which sum to k, so its row (and column) sum is kp.
</p>
<p>Therefore when the row (or column) profile matrix
is calculated the diagonal elements of the Burt matrix are always all 1/p while
the elements for the categories in the offdiagonal blocks sum to 1/p in each block.
Hence when the projected difference between the sample and resample row (or column)
profile matrices is calculated this is artificially small because the
diagonals of the two matrices are always the same, no matter how different
the off-diagonal elements are.
</p>
<p>The new method to correct for the diagonal elements of the Burt matrix when
calculating variances therefore works by re-expressing the coordinates
purely in terms of the interesting and variable off-diagonal elements,
excluding the uninteresting and constant diagonal elements.
</p>
<p>First calculate the Burt principal coordinates (PC), but with the
diagonal elements of the profile matrix ignored (or set to zero).
It is easy to verify that the usual Burt principal coordinates can be re-expressed,
using the singular values (SV), as
</p>
<p>Burt PC = ( Burt SV / (Burt SV - (1/p)) ) x Burt PC without diagonal element
</p>
<p>Hence in the bootstrapping the sample and resample points are re-expressed in this way
and their differences when projected onto the bootstrap axes are calculated as usual.
</p>
<p>Similarly the adjusted principal coordinates are calculated as
</p>
<p>adj Burt PC = (p/(p-1)) x ( (Burt SV - (1/p)) / Burt SV ) x Burt PC
</p>
<p>So, when using the usual adjusted coordinates (and adjusted inertias),
both of the above will be used, hence ending up with just a correction of (p/(p-1)).
The unadjusted coordinates can be used, but this is not recommended.
</p>
<p>One consequence of this correction is that when mcaadjustinertias=TRUE, mcaadjustcoords=TRUE,
mcauseadjustinertiasum=TRUE, mcaadjustmassctr=TRUE and mcasupplementary=&quot;offdiag&quot;
then when p=2 the bootstrap
variances for MCA are almost the same as those for SCA, while all other results
for MCA are the same as those for SCA. The package author regards this as a good thing,
making MCA more of a proper generalisation of MCA, but recognises that some people
regard MCA as a fundamentally different method to SCA, linked only by the common algebra.
</p>
<p>Note that if this adjustment is not made then in the p=2 case it is easy to see that the
projected differences are half those in the SCA case and the standard deviations
are a quarter the size.
</p>
<p>The new method will be written up for publication once this update to the package is finished.
</p>
<p><strong>(2) Experimental method for bootstrapping indicator matrices</strong>
</p>
<p>A highly experimental method is included for bootstrapping with an indicator or doubled matrix
in the case of ordered categorical (e.g. Likert scale) data.
This has not been studied or optimised extensively, and is currently very slow, so use is very
much at the user's discretion and at user's risk. To try it, choose:<br /><br />
mcatype=&quot;indicator&quot; or mcatype=&quot;doubled&quot; with nboots&gt;0<br /><br />
If CRs are required for the individual points then also choose:<br /><br />
mcaindividualboot=TRUE
</p>
<p>The bootstrap methodology used here relies on the comparison of bootstrap to sample points when
both are projected onto bootstrap axes. In SCA this is fine because when looking at column points
the axes are given by the rows and vice versa, and row i and column j each represent the same
category in all bootstrap replicates. Similarly in MCA with a Burt matrix when looking at column
points the axes are given by the rows, which again each represent the same category in all bootstrap replicates.
</p>
<p>However, with an indicator or doubled matrix, row i of the matrix does not represent the same
individual in each replicate, it just represents the i-th individual drawn in the resampling
for that particular replicate.
In order for this type of bootstrapping to work with an indicator or doubled matrix we would
need a resampling method whereby the i-th row represents the i-th individual in all bootstrap replicates.
The resampled row would need to represent the answers of the same individual &quot;on another day&quot;.
This might make sense with questionnaire data where an individual's answers have uncertainty
attached, in that if asked the same questions on multiple occasions they would give different answers
due to random variation rather than temporal change. If a believable model for the sampling,
and hence the resampling, could be derived (CUB models perhaps) then this could lead to CRs
for an individual point, representing the uncertainty in what that person actually thinks.
</p>
<p>The method here uses the same idea of treating the sample row as
representing an individual, and bootstrap replicates of that row as representing the variability
in how that individual might have answered the questionnaire (or similar).
However, instead of an explicit model to represent this variability, it is generated
by the data themselves. The bootstrap replicate indicator (or doubled) matrix is generated as usual,
by either non-parametric (multinomial) or balanced resampling, and then its rows are &quot;matched&quot;
to the rows of the sample indicator (or doubled) matrix. The rows of the resampled matrix
are reordered so that the rows of the resampled matrix are, overall, as similar as possible
to the same rows of the sample matrix. Hence the resampled rows can reasonably be viewed
as representing the same individual in each bootstrap replicate, and hence variances for
the column points (categories) and row points (individuals) can be produced.
</p>
<p>The matching again uses the Hungarian algorithm from lpSolve. This only makes sense if
all variables are ordered categorical. Applying this to (ordered) categorical data results
in a very large number of ties, so the mcalikertnoise parameter defines the standard deviation
of white noise added to each of the sample and resample category numbers for the purpose
of the matching (only).
</p>
<p>Note that this is very slow for all but small data sets, and if all of the CRs for individuals
are shown then the plot is impossibly busy. Hence it is recommended that this experimental
method only be used for fairly small data sets where CRs are wanted for only a few example individuals.
A better approach might be to average the CRs of all of the individuals who give the
same results in the sample, but this is not implemented yet.
</p>
<p>Note that supplementary row points in indicator matrix MCA are usually regarded as different people answering
the same questions, whereas in this case for CRs to make any sense we need to regard them
as the same people answering the same questions on different days.
</p>
<p><strong>(3) Critical values</strong>
</p>
<p>Bootstrap critical values are calculated by re-using the bootstrap replicates used to calculate
the variances, with a critical value calculated for each ellipse.
The projected differences between bootstrap and sample points are ordered and the appropriate
percentile value picked. These are usually slightly larger than the <code class="reqn">\chi^2</code> critical values.
Only 90%, 95% (default) and 99% critical values are calculated.
</p>
<p>Alternatively use <code class="reqn">\chi^2</code> critical values, usually with df=2, but with df=1 if only 2 non-zero cells in row/col.
</p>
<p>The experimental method to construct ellipses for individuals in MCA always uses bootstrap critical values
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>,
<code><a href="#topic+plotca">plotca</a></code>, <code><a href="#topic+printca">printca</a></code>, <code><a href="#topic+summaryca">summaryca</a></code>,
<code><a href="#topic+covmat">covmat</a></code>, <code><a href="#topic+allvarscovs">allvarscovs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple CA (SCA) of a 5 by 4 contingency table, using all SCA defaults:
# 999 bootstraps, Poisson resampling, variances for up to first four axes,
# usual output for up to the first 4 axes,
# one biplot with CRs for rows in principal coordinates and another with
# CRs for columns in principal coordinates

bd &lt;- cabootcrs(DreamData)

## Not run: 

# Same data set with a completely random three-category third variable added,
# analysed with MCA but with standardisations which mimic SCA as much as possible

bd3 &lt;- cabootcrs(DreamData223by3, catype="mca")

Explicitly stating what the rows and columns represent, often needed for a contingency table

bd &lt;- cabootcrs(DreamData, datasetname="Maxwell's dream data",
                varnames=c("What the rows are","What the columns are"))

# Multiple CA (MCA) of 3 categorical variables with all defaults:
# non-parametric resampling, Burt matrix analysed,
# each variable has one plot with it in colour with CRs shown, other variables in monochrome.
# Same data set but now as 223 by 3 matrix, with random 3rd column (with 3 categories) added.

bd3 &lt;- cabootcrs(DreamData223by3, catype="mca")

# Comparison of SCA to MCA with p=2, by converting contingency table to 223 by 2 matrix.
# Note that the coordinates and inertias etc are the same while the standard deviations
# and hence the ellipses are very similar but not identical.

bd &lt;- cabootcrs(DreamData)
DreamData223by2 &lt;- convert(DreamData,input="CT",output="nbyp")$result
bdmca &lt;- cabootcrs(DreamData223by2, catype="mca", varandcat=FALSE)

# Not adjusting inertias, which means that coordinates will also not be adjusted and
# the bootstrapping will use the Burt diagonal.
# Note how the coordinates are larger but the inertias and ellipses are smaller.

bdmcaunadj &lt;- cabootcrs(DreamData223by2, catype="mca", varandcat=FALSE, mcaadjustinertias=FALSE)

# Applying the standard adjustments to inertias and coordinates, but with
# the bootstrapping still using the Burt diagonal.
# Note how inertias and coordinates are now the same as SCA, but ellipses are smaller.

bdmcaadjbutall &lt;- cabootcrs(DreamData223by2, catype="mca", varandcat=FALSE, mcasupplementary="all")


# Effect of sample size in SCA:

bdx4 &lt;- cabootcrs(4*DreamData)
bdx9 &lt;- cabootcrs(9*DreamData)

ba &lt;- cabootcrs(AttachmentData)

bs &lt;- cabootcrs(SuicideData)

bas &lt;- cabootcrs(AsbestosData)


# Options for SCA:

# SCA with multinomial resampling, with the matrix treated as a single multinomial distribution

bdm &lt;- cabootcrs(DreamData, resampledistn="multinomial")

# Fix the row sums, i.e. keep sum of age group constant

bdmrf &lt;- cabootcrs(DreamData, resampledistn="multinomial", multinomialtype="rowsfixed")

# Use chi-squared critical values for the CRs

bdchisq &lt;- cabootcrs(DreamData, usebootcrits=FALSE)

# Just perform correspondence analysis, without bootstrapping

bdnb0 &lt;- cabootcrs(DreamData, nboots=0)


# Effect of sample size in MCA:

bn &lt;- cabootcrs(NishData, catype="mca")


# Options for MCA

# Using default settings the SCA and MCA standard results are the same when p=2,
# bootstrap standard deviations (multinomial/nonparametric) are similar but not identical

bdsca &lt;- cabootcrs(DreamData,resampledistn="multinomial")
bdmca &lt;- cabootcrs(convert(DreamData,input="CT",output="nbyp")$result, catype="mca")

# Row A can be labelled A rather than R:A
# because the three variables have all different category names

bd3l &lt;- cabootcrs(DreamData223by3, catype="mca", varandcat=FALSE)

# Balanced resampling, each of the 223 rows occurs 999 times in the 999 resamples

bd3b &lt;- cabootcrs(DreamData223by3, catype="mca", resampledistn="balanced")

# Do not adjust inertias, coordinates or contributions
# (if inertias are not adjusted then coordinates are also not adjusted)

bd3unadj &lt;- cabootcrs(DreamData223by3, catype="mca",mcaadjustinertias=FALSE)

## Comparisons to ellipses from FactoMineR

# Generate some completely random uniform categorical data, construct ellipses.
# The cabootcrs ellipses are very large and overlap extensively, as you would expect
# from completely random data.
# The FactoMineR ellipses are much smaller, often with minimal overlaps,
# giving a completely false impression of genuine differences between categories.

library(FactoMineR)
p &lt;- 4
maxcat &lt;- 5
n &lt;- 100
Xnpr &lt;- apply( as.data.frame( matrix( round(runif(n*p,0.5,maxcat+0.5)), n, p)), 2, factor )
fr &lt;- MCA(Xnpr, method="Burt")
plotellipses(fr)
br &lt;- cabootcrs(Xnpr, catype="mca", showresults=FALSE)
plotca(br, mcacategorycolours = TRUE, showcolumnlabels=FALSE)

## Comparisons to results in ca and FactoMineR

Summary: If using unadjusted inertias, coordinates the packages produce identical results,
apart from differences in presentation (rounding off, the naming of rep/cor/cos2).

Summary: When using adjusted inertias and coordinates (not an option in FactoMineR::MCA)
the correlations in ca::mjca no longer sum to 1 over all dimensions, in cabootcrs they do.
Ratios are the same for each dimension, but not each point, they are standardised differently.

# Example comparisons with random data
library(FactoMineR)
library(ca)
p &lt;- 4
maxcat &lt;- 5
n &lt;- 100
Xnpdf &lt;- as.data.frame( matrix( round(runif(n*p,0.5,maxcat+0.5)), n, p))
Xnpr &lt;- apply( Xnpdf, 2, factor )

# Note that ca::mjca only accepts the data as numerical,
# FactoMineR::MCA only acccepts the data as characters
rbun &lt;- cabootcrs(Xnpr, catype="mca", nboots=0, mcaadjustinertias = FALSE)
rcun &lt;-  mjca(Xnpdf,lambda="Burt")
summary(rcun)
rfm &lt;- MCA(Xnpr,method="Burt", graph=FALSE)
summary(rfm)
rb &lt;- cabootcrs(Xnpr, catype="mca", nboots=0)
rc &lt;- mjca(Xnpdf)
summary(rc)
realr &lt;- rb@br@realr
rb@ColREP[,1:realr]
rc$colcor[,1:realr]
apply(rb@ColREP[,1:realr],1,"sum")
apply(rc$colcor[,1:realr],1,"sum")


## End(Not run)

</code></pre>

<hr>
<h2 id='cabootcrsresults-class'>A class containing the results from CA with bootstrapping</h2><span id='topic+cabootcrsresults-class'></span>

<h3>Description</h3>

<p>This contains all of the usual output from simple or multiple CA,
plus the results of the bootstrap analysis and the various settings used for this.
</p>


<h3>Details</h3>

<p>The meanings and possible values for the settings are described in <code><a href="#topic+cabootcrs">cabootcrs</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>br</code></dt><dd><p>The basic results from CA, class <code><a href="#topic+cabasicresults-class">cabasicresults</a></code></p>
</dd>
<dt><code>datasetname</code></dt><dd><p>Name of the data set for printing, class <code>"character"</code></p>
</dd>
<dt><code>DataMatrix</code></dt><dd><p>The sample data matrix, class <code>"matrix"</code></p>
</dd>
<dt><code>rows</code></dt><dd><p>Number of rows, class <code>"numeric"</code></p>
</dd>
<dt><code>columns</code></dt><dd><p>Number of columns, class <code>"numeric"</code></p>
</dd>
<dt><code>rowlabels</code></dt><dd><p>Row category labels, class <code>"character"</code></p>
</dd>
<dt><code>collabels</code></dt><dd><p>Column category labels, class <code>"character"</code></p>
</dd>
<dt><code>varnames</code></dt><dd><p>Names of the variables, class <code>"character"</code></p>
</dd>
<dt><code>Rowprinccoord</code></dt><dd><p>Principal coordinates for row points, class <code>"matrix"</code></p>
</dd>
<dt><code>Colprinccoord</code></dt><dd><p>Principal coordinates for column points, class <code>"matrix"</code></p>
</dd>
<dt><code>Rowstdcoord</code></dt><dd><p>Standard coordinates for row points, class <code>"matrix"</code></p>
</dd>
<dt><code>Colstdcoord</code></dt><dd><p>Standard coordinates for column points, class <code>"matrix"</code></p>
</dd>
<dt><code>RowCTR</code></dt><dd><p>Contributions for row points, class <code>"matrix"</code></p>
</dd>
<dt><code>RowREP</code></dt><dd><p>Representations for row points, class <code>"matrix"</code></p>
</dd>
<dt><code>ColCTR</code></dt><dd><p>Contributions for column points, class <code>"matrix"</code></p>
</dd>
<dt><code>ColREP</code></dt><dd><p>Representations for column points, class <code>"matrix"</code></p>
</dd>
<dt><code>RowVar</code></dt><dd><p>Variances for row points, class <code>"matrix"</code></p>
</dd>
<dt><code>RowCov</code></dt><dd><p>Covariances for row points, class <code>"array"</code></p>
</dd>
<dt><code>ColVar</code></dt><dd><p>Variances for column points, class <code>"matrix"</code></p>
</dd>
<dt><code>ColCov</code></dt><dd><p>Covariances for column points, class <code>"array"</code></p>
</dd>
<dt><code>inertiasum</code></dt><dd><p>Total inertia, class <code>"numeric"</code></p>
</dd>
<dt><code>inertias</code></dt><dd><p>Axis inertias, class <code>"matrix"</code></p>
</dd>
<dt><code>rowmasses</code></dt><dd><p>Masses of row points, class <code>"numeric"</code></p>
</dd>
<dt><code>colmasses</code></dt><dd><p>Masses of column points, class <code>"numeric"</code></p>
</dd>
<dt><code>nboots</code></dt><dd><p>Number of bootstrap replicates used to calculate the (co)variances, class <code>"numeric"</code>. <br />
If nboots=0 then standard CA or MCA is performed with no confidence regions produced.</p>
</dd>
<dt><code>resampledistn</code></dt><dd><p>Distribution used for resampling, class <code>"character"</code></p>
</dd>
<dt><code>multinomialtype</code></dt><dd><p>Form of multinomial resampling used, class <code>"character"</code></p>
</dd>
<dt><code>sameaxisorder</code></dt><dd><p>Number of resamples with no reordering in first six bootstrap axes, class <code>"numeric"</code></p>
</dd>
<dt><code>poissonzeronewmean</code></dt><dd><p>Mean used for resampling zero cells, class <code>"numeric"</code></p>
</dd>
<dt><code>newzeroreset</code></dt><dd><p>Option to reset resample zero cells, class <code>"numeric"</code></p>
</dd>
<dt><code>printdims</code></dt><dd><p>Number of dimensions to print, though note that all are stored, class <code>"numeric"</code></p>
</dd>
<dt><code>axisvariances</code></dt><dd><p>Number of axes for which variances were calculated and are stored, class <code>"numeric"</code></p>
</dd>
<dt><code>bootcritR</code></dt><dd><p>Bootstrap critical values for row points, class <code>"array"</code></p>
</dd>
<dt><code>bootcritC</code></dt><dd><p>Bootstrap critical values for column points, class <code>"array"</code></p>
</dd>
<dt><code>usebootcrits</code></dt><dd><p>Whether to use bootstrap critical values for confidence ellipses, class <code>"logical"</code></p>
</dd>
<dt><code>catype</code></dt><dd><p>Type of correspondence analysis performed, class <code>"character"</code></p>
</dd>
<dt><code>mcatype</code></dt><dd><p>Type of multiple correspondence analysis performed, class <code>"character"</code></p>
</dd>
<dt><code>mcaindividualboot</code></dt><dd><p>Whether the experimental method to bootstrap an indicator or doubled matrix was used, class <code>"logical"</code></p>
</dd>
<dt><code>IndicatorMatrix</code></dt><dd><p>The indicator matrix derived from the data matrix, class <code>"matrix"</code></p>
</dd>
<dt><code>Jk</code></dt><dd><p>The number of classes for each variable, class <code>"numeric"</code></p>
</dd>
<dt><code>p</code></dt><dd><p>The number of variables, class <code>"numeric"</code></p>
</dd>
<dt><code>mcalikertnoise</code></dt><dd><p>The noise value used in the experimental method to bootstrap an indicator or doubled matrix, class <code>"numeric"</code></p>
</dd>
<dt><code>mcaadjustinertias</code></dt><dd><p>Whether MCA inertias were adjusted, class <code>"logical"</code></p>
</dd>
<dt><code>mcauseadjustinertiasum</code></dt><dd><p>Whether the adjusted MCA inertia sum was used, class <code>"logical"</code></p>
</dd>
<dt><code>mcaadjustcoords</code></dt><dd><p>Whether the MCA coordinates were adjusted, class <code>"logical"</code></p>
</dd>
<dt><code>mcaadjustmassctr</code></dt><dd><p>Whether the MCA masses and contributions were adjusted, class <code>"logical"</code></p>
</dd>
<dt><code>mcasupplementary</code></dt><dd><p>How supplementary points were calculated when bootstrapping a Burt matrix, class <code>"character"</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+cabasicresults-class">cabasicresults</a></code>
</p>

<hr>
<h2 id='convert'>Converting a data matrix from one format into another</h2><span id='topic+convert'></span>

<h3>Description</h3>

<p><code>convert</code> recodes a data matrix from one format, used by versions of correspondence analysis,
into another (n objects by p variables, counts for distinct combinations of p variables, indicator matrix, contingency table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert(
  Xinput,
  input = "nbyp",
  output = "indicator",
  Jk = NULL,
  maxcat = NULL,
  varandcat = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_+3A_xinput">Xinput</code></td>
<td>
<p>A data matrix, in the form of a data frame or similar</p>
</td></tr>
<tr><td><code id="convert_+3A_input">input</code></td>
<td>
<p>The format of the input matrix:
</p>

<dl>
<dt>&quot;nbyp&quot;</dt><dd><p>An n individuals/objects/data points by p categorical variables matrix,
where each row is a different data point and each column contains the category
for that data point on that variable, where these categories can be numbers, strings or factors</p>
</dd>
<dt>&quot;nbypcounts&quot;</dt><dd><p>Similar to the above, but each row represents all of the data points taking
the same combination of categories, and the first column contains the count for this combination
(hence the name used here is a bit of a misnomer, but it emphasises the similarities to an n by p)</p>
</dd>
<dt>&quot;indicator&quot;</dt><dd><p>An indicator matrix, similar to the n by p matrix except that a variable with J_k categories
is represented by J_k columns and a data point taking the i-th category has 1 in the i-th
of these columns and a zero in the others</p>
</dd>
<dt>&quot;CT&quot;</dt><dd><p>A contingency table of counts</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="convert_+3A_output">output</code></td>
<td>
<p>The format of the output matrix:
</p>

<dl>
<dt>&quot;nbyp&quot;</dt><dd><p>As above</p>
</dd>
<dt>&quot;nbypcounts&quot;</dt><dd><p>As above</p>
</dd>
<dt>&quot;indicator&quot;</dt><dd><p>As above</p>
</dd>
<dt>&quot;doubled&quot;</dt><dd><p>Similar to indicator but each variable is now represented by 2 columns, and a data point
taking the i-th category for a variable with J_k categories is given the values
J_k-i in the first (low) column and i-1 in the second (high) column</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="convert_+3A_jk">Jk</code></td>
<td>
<p>A list containing the number of distinct categories for each variable.<br />
Either Jk or maxcat must be specified if input is &quot;indicator&quot;</p>
</td></tr>
<tr><td><code id="convert_+3A_maxcat">maxcat</code></td>
<td>
<p>The maximum category value, for use when all variables are Likert on a scale of 1 to maxcat.<br />
Either Jk or maxcat must be specified if input is &quot;indicator&quot;</p>
</td></tr>
<tr><td><code id="convert_+3A_varandcat">varandcat</code></td>
<td>
<p>Flag for how to construct column names in an indicator matrix:
</p>

<dl>
<dt>TRUE</dt><dd><p>if many variables have the same categories, e.g. Likert, column names will be varname:catname</p>
</dd>
<dt>FALSE</dt><dd><p>when variables have distinct categories, column names will just be category names</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>result</dt><dd><p>the output data matrix formatted according to the output argument</p>
</dd>
<dt>varnames</dt><dd><p>a list of length p containing the names of each variable</p>
</dd>
<dt>catnames</dt><dd><p>a list/array (of length p) containing the lists (of length Jk[i]) of category names for each variable</p>
</dd>
<dt>Jk</dt><dd><p>a list of length p containing the number of distinct categories for each variable</p>
</dd>
<dt>p</dt><dd><p>the number of variables</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+getBurt">getBurt</a></code> to obtain a Burt matrix or a subset of an existing one<br />
<code><a href="#topic+getCT">getCT</a></code> to obtain a contingency table (only if p=2)<br />
<code><a href="#topic+getindicator">getindicator</a></code> to obtain an indicator matrix<br />
<code><a href="#topic+getdoubled">getdoubled</a></code> to obtain a doubled matrix if all variables are ordered categorical with numbered categories
</p>
<p>Other conversion functions: 
<code><a href="#topic+getBurt">getBurt</a>()</code>,
<code><a href="#topic+getCT">getCT</a>()</code>,
<code><a href="#topic+getdoubled">getdoubled</a>()</code>,
<code><a href="#topic+getindicator">getindicator</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dreamdataCT &lt;- DreamData
dreamdatanbyplist &lt;- convert(dreamdataCT,input="CT",output="nbyp")
dreamdatanbyp &lt;- dreamdatanbyplist$result

## Not run: 

dreamdataCTb &lt;- table(dreamdatanbyp)
dreamdatanbypcounts &lt;- convert(dreamdatanbyp,input="nbyp",output="nbypcounts")$result
dreamdataindicatorlist &lt;- convert(dreamdatanbypcounts,input="nbypcounts",output="indicator")
dreamdatanbypb &lt;- convert(dreamdataindicatorlist$result,input="indicator",
                          output="nbyp",Jk=dreamdataindicatorlist$Jk)$result

nishdatanbyp &lt;- NishData
nishdataindicator &lt;- convert(nishdatanbyp)$result
nishdataBurt &lt;- t(nishdataindicator)%*%nishdataindicator


## End(Not run)

</code></pre>

<hr>
<h2 id='covmat'>Extract a single 2 by 2 covariance matrix</h2><span id='topic+covmat'></span>

<h3>Description</h3>

<p><code>covmat</code> extracts a 2 by 2 covariance matrix for one data point on two dimensions,
allowing the confidence ellipse to be plotted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmat(x, i, thing = "column", axis1 = 1, axis2 = 2, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmat_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code></p>
</td></tr>
<tr><td><code id="covmat_+3A_i">i</code></td>
<td>
<p>The number of the row or column, note that in MCA this will be the number of the variable category
(e.g. for p=3 variables with 5 categories each, column 8 is the 3rd category of the 2nd variable)</p>
</td></tr>
<tr><td><code id="covmat_+3A_thing">thing</code></td>
<td>
<p>Whether to extract the covariance matrix for the i-th
</p>

<dl>
<dt>&quot;row&quot;</dt><dd><p>row, or</p>
</dd>
<dt>&quot;column&quot;</dt><dd><p>column</p>
</dd>
</dl>

<p>Note that default is &quot;column&quot; as this is more convenient for MCA</p>
</td></tr>
<tr><td><code id="covmat_+3A_axis1">axis1</code></td>
<td>
<p>First axis for which (co)variances are required</p>
</td></tr>
<tr><td><code id="covmat_+3A_axis2">axis2</code></td>
<td>
<p>Second axis for which (co)variances are required</p>
</td></tr>
<tr><td><code id="covmat_+3A_show">show</code></td>
<td>
<p>If TRUE then print the extracted covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be used with the ellipse() package to add the confidence ellipse to a picture from another package<br />
</p>
<p>Example: confidence ellipse for row or column i on axes 1,2 from cabootcrs() output Results is:<br />
</p>
<p>lines( ellipse(x=covmat(Results,i,&quot;row&quot;,1,2,FALSE),
centre=Results@Rowprinccoord[i,cbind(1,2)], npoints=1000),
cex=1, pch=&quot;.&quot;, col=&quot;blue&quot;)<br />
lines( ellipse(x=covmat(Results,i,&quot;column&quot;,1,2,FALSE),
centre=Results@Colprinccoord[i,cbind(1,2)], npoints=1000),
cex=1, pch=&quot;.&quot;, col=&quot;blue&quot;)
</p>
<p>Note that <code><a href="#topic+reflectaxes">reflectaxes</a></code> will be needed if cabootcrs() and ca() axes
are reflected with respect to each other
</p>


<h3>Value</h3>

<p>An object of class <code>"matrix"</code> (square symmetric, 2 by 2)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>, <code><a href="#topic+allvarscovs">allvarscovs</a></code>,
<code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- cabootcrs(DreamData, showresults=FALSE)
row2covmataxes12 &lt;- covmat(results,2,"row")
col3covmataxes23 &lt;- covmat(results,3,"column",2,3)

## Not run: 

# There are now 3 variables with 5,4,3 categories, hence 12 columns
resultsmca &lt;- cabootcrs(DreamData223by3, catype="mca", showresults=FALSE)
row2covmataxes12mca &lt;- covmat(resultsmca,2,"column")
col3covmataxes23mca &lt;- covmat(resultsmca,8,"column",2,3)
newvarcat2covmataxes12mca &lt;- covmat(resultsmca,11,"column")


# Use ellipse() to put confidence regions around row points on a plot produced by ca().
# Note that reflectaxes() will be needed if cabootcrs() and ca() axes
# are reflected with respect to each other

library(ca)
library(ellipse)
TheData &lt;- DreamData
Results &lt;- cabootcrs(TheData, showresults=FALSE)
caResults &lt;- ca(TheData)
plot(caResults)
for (i in 1:dim(TheData)[1]) {
  lines( ellipse(x=covmat(Results,i,"row",1,2,FALSE),
                 centre=Results@Rowprinccoord[i,cbind(1,2)], npoints=1000),
        cex=1, pch=".", col="blue")
}

## End(Not run)

</code></pre>

<hr>
<h2 id='DreamData'>Maxwell's dream data set, with simplified labels</h2><span id='topic+DreamData'></span>

<h3>Description</h3>

<p>Reported disturbance of dreams among boys, using labels A, a etc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DreamData
</code></pre>


<h3>Format</h3>

<p>A contingency table with 5 rows and 4 columns
</p>

<dl>
<dt>rows</dt><dd><p>Age group: 5-7 (A), 8-9 (B), 10-11 (C), 12-13 (D), 13-14 (E)</p>
</dd>
<dt>columns</dt><dd><p>Severity of disturbance of dream: lowest (a) to highest (d)</p>
</dd>
</dl>



<h3>Source</h3>

<p>G. Iliopoulos, M. Kateri and I. Ntzoufras,
<em>Bayesian estimation of unrestricted and order-restricted association
models for a two-way contingency table</em>,
Computational Statistics and Data Analysis 51 (2007), pp. 4643&ndash;4655.
</p>

<hr>
<h2 id='DreamData223by3'>Maxwell's dream data set with added totally random column</h2><span id='topic+DreamData223by3'></span>

<h3>Description</h3>

<p>Reported disturbance of dreams among boys, plus a random column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DreamData223by3
</code></pre>


<h3>Format</h3>

<p>A matrix of 223 individuals by 3 variables
</p>

<dl>
<dt>Age group - R</dt><dd><p>5-7 (A), 8-9 (B), 10-11 (C), 12-13 (D), 13-14 (E)</p>
</dd>
<dt>Severity of disturbance of dream - C</dt><dd><p>Severity of disturbance of dream: lowest (a) to highest (d)</p>
</dd>
<dt>Random fake variable - V</dt><dd><p>1 to 3</p>
</dd>
</dl>



<h3>Source</h3>

<p>Adapted from G. Iliopoulos, M. Kateri and I. Ntzoufras,
<em>Bayesian estimation of unrestricted and order-restricted association
models for a two-way contingency table</em>,
Computational Statistics and Data Analysis 51 (2007), pp. 4643&ndash;4655.
</p>

<hr>
<h2 id='DreamDataNames'>Maxwell's dream data set, using full original labels</h2><span id='topic+DreamDataNames'></span>

<h3>Description</h3>

<p>Reported disturbance of dreams among boys, using ages and original code for severities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DreamDataNames
</code></pre>


<h3>Format</h3>

<p>A contingency table with 5 rows and 4 columns
</p>

<dl>
<dt>rows</dt><dd><p>Age group: 5-7 (A), 8-9 (B), 10-11 (C), 12-13 (D), 13-14 (E)</p>
</dd>
<dt>columns</dt><dd><p>Severity of disturbance of dream: lowest (1) to highest (4)</p>
</dd>
</dl>



<h3>Source</h3>

<p>G. Iliopoulos, M. Kateri and I. Ntzoufras,
<em>Bayesian estimation of unrestricted and order-restricted association
models for a two-way contingency table</em>,
Computational Statistics and Data Analysis 51 (2007), pp. 4643&ndash;4655.
</p>

<hr>
<h2 id='getBurt'>Converting a data matrix into a Burt matrix</h2><span id='topic+getBurt'></span>

<h3>Description</h3>

<p><code>getBurt</code> recodes a data matrix from one format (n objects by p variables,
counts for distinct combinations of p variables, contingency table) into a Burt matrix,
or extracts a subset of a Burt matrix for selected variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBurt(
  Xinput,
  input = "nbyp",
  Jk = NULL,
  maxcat = NULL,
  varandcat = TRUE,
  vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBurt_+3A_xinput">Xinput</code></td>
<td>
<p>A data matrix, in the form of a data frame or similar</p>
</td></tr>
<tr><td><code id="getBurt_+3A_input">input</code></td>
<td>
<p>The format of the input matrix:
</p>

<dl>
<dt>&quot;nbyp&quot;</dt><dd><p>An n individuals/objects/data points by p categorical variables matrix,
where each row is a different data point and each column contains the category
for that data point on that variable, where these categories can be numbers, strings or factors</p>
</dd>
<dt>&quot;nbypcounts&quot;</dt><dd><p>Similar to the above, but each row represents all of the data points taking
the same combination of categories, and the first column contains the count for this combination
(hence the name used here is a bit of a misnomer, but it emphasises the similarities to an n by p)</p>
</dd>
<dt>&quot;indicator&quot;</dt><dd><p>An indicator matrix, similar to the n by p matrix except that a variable with J_k categories
is represented by J_k columns and a data point taking the i-th category has 1 in the i-th
of these columns and a zero in the others</p>
</dd>
<dt>&quot;Burt&quot;</dt><dd><p>A Burt matrix, symmetrical and block-diagonal with each block being a
contingency table for a pair of variables</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getBurt_+3A_jk">Jk</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getBurt_+3A_maxcat">maxcat</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getBurt_+3A_varandcat">varandcat</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getBurt_+3A_vars">vars</code></td>
<td>
<p>A list of the variable numbers to be used in the Burt matrix, if only a subset is wanted.<br />
If not all variables are wanted and the input is not n by p then Jk must be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Burt matrix, symmetrical and block-diagonal with each block being a contingency table for a pair of variables
</p>


<h3>See Also</h3>

<p>Other conversion functions: 
<code><a href="#topic+convert">convert</a>()</code>,
<code><a href="#topic+getCT">getCT</a>()</code>,
<code><a href="#topic+getdoubled">getdoubled</a>()</code>,
<code><a href="#topic+getindicator">getindicator</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nishburt &lt;- getBurt(NishData)
nishburtvars1to3 &lt;- getBurt(NishData,vars=1:3)
nishburtvars2and4 &lt;- getBurt(nishburt,input="Burt",Jk=rep(3,4),vars=c(2,4))

</code></pre>

<hr>
<h2 id='getCT'>Converting a data matrix into a contingency table</h2><span id='topic+getCT'></span>

<h3>Description</h3>

<p><code>getCT</code> recodes a data matrix from one format (n objects by p variables,
counts for distinct combinations of p variables, indicator matrix or Burt matrix) into a contingency table,
for cases where table() doesn't work
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCT(
  Xinput,
  input = "nbyp",
  Jk = NULL,
  maxcat = NULL,
  varandcat = TRUE,
  vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCT_+3A_xinput">Xinput</code></td>
<td>
<p>A data matrix, in the form of a data frame or similar</p>
</td></tr>
<tr><td><code id="getCT_+3A_input">input</code></td>
<td>
<p>See <code><a href="#topic+getBurt">getBurt</a></code></p>
</td></tr>
<tr><td><code id="getCT_+3A_jk">Jk</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getCT_+3A_maxcat">maxcat</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getCT_+3A_varandcat">varandcat</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getCT_+3A_vars">vars</code></td>
<td>
<p>A list of the variable numbers to be used in the contingency table when there are more than 2. <br />
If not all variables are wanted and the input is not n by p then Jk must be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contingency table, giving counts for the two cross-classified variables
</p>


<h3>See Also</h3>

<p>Other conversion functions: 
<code><a href="#topic+convert">convert</a>()</code>,
<code><a href="#topic+getBurt">getBurt</a>()</code>,
<code><a href="#topic+getdoubled">getdoubled</a>()</code>,
<code><a href="#topic+getindicator">getindicator</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nishCTvars23 &lt;- getCT(NishData,Jk=rep(3,4),vars=2:3)

</code></pre>

<hr>
<h2 id='getdoubled'>Converting a data matrix into a doubled matrix</h2><span id='topic+getdoubled'></span>

<h3>Description</h3>

<p><code>getdoubled</code> recodes a data matrix from one format (n objects by p variables,
counts for distinct combinations of p variables, contingency table) into a doubled matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getdoubled(Xinput, input = "nbyp", Jk = NULL, maxcat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getdoubled_+3A_xinput">Xinput</code></td>
<td>
<p>A data matrix, in the form of a data frame or similar,
all variables must be ordered categorical with numerical categories</p>
</td></tr>
<tr><td><code id="getdoubled_+3A_input">input</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getdoubled_+3A_jk">Jk</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getdoubled_+3A_maxcat">maxcat</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A doubled matrix, where each variable is represented by 2 columns, and a data point
taking the i-th category for a variable with J_k categories is given the values
J_k-i in the first (low) column and i-1 in the second (high) column
</p>


<h3>See Also</h3>

<p>Other conversion functions: 
<code><a href="#topic+convert">convert</a>()</code>,
<code><a href="#topic+getBurt">getBurt</a>()</code>,
<code><a href="#topic+getCT">getCT</a>()</code>,
<code><a href="#topic+getindicator">getindicator</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nishdoubled &lt;- getdoubled(NishData)

</code></pre>

<hr>
<h2 id='getindicator'>Converting a data matrix into an indicator matrix</h2><span id='topic+getindicator'></span>

<h3>Description</h3>

<p><code>getindicator</code> recodes a data matrix from one format (n objects by p variables,
counts for distinct combinations of p variables, contingency table) into an indicator matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getindicator(
  Xinput,
  input = "nbyp",
  Jk = NULL,
  maxcat = NULL,
  varandcat = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getindicator_+3A_xinput">Xinput</code></td>
<td>
<p>A data matrix, in the form of a data frame or similar</p>
</td></tr>
<tr><td><code id="getindicator_+3A_input">input</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getindicator_+3A_jk">Jk</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getindicator_+3A_maxcat">maxcat</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
<tr><td><code id="getindicator_+3A_varandcat">varandcat</code></td>
<td>
<p>See <code><a href="#topic+convert">convert</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An indicator matrix, where a variable with J_k categories is represented by J_k columns and a
data point taking the i-th category has 1 in the i-th of these columns and a zero in the others
</p>


<h3>See Also</h3>

<p>Other conversion functions: 
<code><a href="#topic+convert">convert</a>()</code>,
<code><a href="#topic+getBurt">getBurt</a>()</code>,
<code><a href="#topic+getCT">getCT</a>()</code>,
<code><a href="#topic+getdoubled">getdoubled</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nishindicator &lt;- getindicator(NishData)

</code></pre>

<hr>
<h2 id='myresamplefn'>Example of a user-generated resampling routine.</h2><span id='topic+myresamplefn'></span>

<h3>Description</h3>

<p><code>myresamplefn</code> in this case assumes that each pair of cells represents 50 people
answering yes or no to a question, with undecideds not recorded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myresamplefn(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myresamplefn_+3A_x">X</code></td>
<td>
<p>a data matrix, to be resampled from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is only intended as an example of a user-generated resampling routine,
users should replace it with their own function of this name
</p>
<p>In this example we assume that rows groups of 50 people have each been
asked columns/2 questions, with possible answers yes/no/undecided.
It uses binomial bootstrapping for pairs of columns, assuming that
successive columns are &quot;yes&quot; and &quot;no&quot; answers, with others undecided,
with sums of pairs of columns having a maximum, in this case 50.
</p>


<h3>Value</h3>

<p>a resampled version of the input data matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Five groups of people answer two yes/no/undecided questions
# Note: this is just an example, and does not intend to claim that this
# is the correct analysis for such a data set

x &lt;- as.matrix( rbind( c(22,25,18,22), c(12,23,21,27),
                       c(31,12,28,22), c(29,14,35,11), c(7,31,12,21)))
xresampled &lt;- myresamplefn(x)
bmr &lt;- cabootcrs(x,"myresample",nboots=199)

</code></pre>

<hr>
<h2 id='NishData'>Nishisato's Singapore data</h2><span id='topic+NishData'></span>

<h3>Description</h3>

<p>Questionnaire data collected at a Dual Scaling workshop in Singapore
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NishData
</code></pre>


<h3>Format</h3>

<p>A matrix of 13 individuals by 4 variables each with 3 possible answers
</p>

<dl>
<dt>Age - a</dt><dd><p>20-29 (1), 30-39 (2), 40+ (3)</p>
</dd>
<dt>Children are less disciplined now - b</dt><dd><p>Agree (1), Disagree (2), Can't tell (3)</p>
</dd>
<dt>Children are less fortunate now - c</dt><dd><p>Agree (1), Disagree (2), Can't tell (3)</p>
</dd>
<dt>Religions should not be taught in school - d</dt><dd><p>Agree (1), Disagree (2), Indifferent (3)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Nishisato, S. (1994).
<em>Elements of Dual Scaling: An Introduction to Practical Data Analysis</em>.
Lawrence Erlbaum Associates, New Jersey. (p153)
</p>

<hr>
<h2 id='OsteoData'>Osteoarchaeological data with categories given as numbers</h2><span id='topic+OsteoData'></span>

<h3>Description</h3>

<p>Animal bones classified by 11 different variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OsteoData
</code></pre>


<h3>Format</h3>

<p>A matrix of 6027 bones by 11 variables, each with 2-12 categories
</p>

<dl>
<dt>Species/Taxon - Taxa</dt><dd><p>1-10</p>
</dd>
<dt>Anatomical element - Elem</dt><dd><p>1-12</p>
</dd>
<dt>Recent breakage - Rec</dt><dd><p>P/A</p>
</dd>
<dt>Cut marks - Cut</dt><dd><p>P/A</p>
</dd>
<dt>Gnawing - Gnaw</dt><dd><p>P/A</p>
</dd>
<dt>Weathering stage - Weat</dt><dd><p>1-4 or A</p>
</dd>
<dt>Thermal stage - Therm</dt><dd><p>1-5 or A</p>
</dd>
<dt>Trampling - Tram</dt><dd><p>P/A</p>
</dd>
<dt>Root etching - Root</dt><dd><p>P/A</p>
</dd>
<dt>Post-depositional - Post</dt><dd><p>P/A</p>
</dd>
<dt>Context - Context</dt><dd><p>1-4</p>
</dd>
</dl>



<h3>Source</h3>

<p>Macheridis, S.
<em>The Use of Multiple Correspondence Analysis (MCA) in Taphonomy: The Case of Middle Helladic Asine, Greece</em>
International Journal of Osteoarchaeology 27 (2017), pp. 477-487.
</p>

<hr>
<h2 id='OsteoDataNames'>Osteoarchaeological data with named categories</h2><span id='topic+OsteoDataNames'></span>

<h3>Description</h3>

<p>Animal bones classified by 11 different variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OsteoDataNames
</code></pre>


<h3>Format</h3>

<p>A matrix of 6027 bones by 11 variables, each with 2-12 categories
</p>

<dl>
<dt>Species/Taxon - Taxa</dt><dd><p>Sheep/goat,Pig,Cattle,Deer,Dog,Equid,Large,Medium,Small,Size:indet</p>
</dd>
<dt>Anatomical element - Elem</dt><dd><p>Horn/antler,Head,Neck,Axial,Upper_front,Lower_front,Upper_hind,Lower_hind,Feet,Metapodials,Long_bone,Element:indet</p>
</dd>
<dt>Recent breakage - Rec</dt><dd><p>P/A</p>
</dd>
<dt>Cut marks - Cut</dt><dd><p>P/A</p>
</dd>
<dt>Gnawing - Gnaw</dt><dd><p>P/A</p>
</dd>
<dt>Weathering stage - Weat</dt><dd><p>stage 1-4 or A</p>
</dd>
<dt>Thermal stage - Therm</dt><dd><p>stage 1-5 or A</p>
</dd>
<dt>Trampling - Tram</dt><dd><p>P/A</p>
</dd>
<dt>Root etching - Root</dt><dd><p>P/A</p>
</dd>
<dt>Post-depositional - Post</dt><dd><p>P/A</p>
</dd>
<dt>Context - Context</dt><dd><p>Secondary,Room_fills,Primary,Floors</p>
</dd>
</dl>



<h3>Source</h3>

<p>Macheridis, S.
<em>The Use of Multiple Correspondence Analysis (MCA) in Taphonomy: The Case of Middle Helladic Asine, Greece</em>
International Journal of Osteoarchaeology 27 (2017), pp. 477-487.
</p>

<hr>
<h2 id='plotca'>Plotting results with confidence regions</h2><span id='topic+plotca'></span>

<h3>Description</h3>

<p><code>plotca</code> produces one or more scatterplots of the results of simple or multiple
correspondence analysis, with elliptical confidence regions around chosen points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotca(
  x,
  datasetname = NULL,
  mytitles = NULL,
  showrowlabels = TRUE,
  showcolumnlabels = TRUE,
  plotsymbolscolours = c(19, "inferno", 18, "inferno"),
  othersmonochrome = "grey",
  crpercent = 95,
  usebootcrits = NULL,
  plottype = "biplot",
  showrowcrs = TRUE,
  showcolumncrs = TRUE,
  likertarrows = FALSE,
  firstaxis = 1,
  lastaxis = 2,
  plotallpairs = "successive",
  picsize = NULL,
  mcaoneploteach = TRUE,
  mcashowindividuals = FALSE,
  mcavariablecolours = FALSE,
  mcacategorycolours = FALSE,
  groupings = NULL,
  grouplabels = NULL,
  eps = 1e-15,
  plotwithdevnew = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotca_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code></p>
</td></tr>
<tr><td><code id="plotca_+3A_datasetname">datasetname</code></td>
<td>
<p>A string to use as the name of the data set in the plots, defaults to that in cabootcrs object</p>
</td></tr>
<tr><td><code id="plotca_+3A_mytitles">mytitles</code></td>
<td>
<p>A list of text strings, to be used instead of the default titles of the plots,
where the list must be at least as long as the number of plots to be produced</p>
</td></tr>
<tr><td><code id="plotca_+3A_showrowlabels">showrowlabels</code></td>
<td>
<p>If TRUE then label row points as usual, otherwise
suppress labels of row points.
</p>
<p>Note: when analysing a Burt matrix the columns points are plotted</p>
</td></tr>
<tr><td><code id="plotca_+3A_showcolumnlabels">showcolumnlabels</code></td>
<td>
<p>If TRUE then label column points as usual, otherwise
suppress labels of column points.
</p>
<p>Note: when analysing a Burt matrix the columns points are plotted</p>
</td></tr>
<tr><td><code id="plotca_+3A_plotsymbolscolours">plotsymbolscolours</code></td>
<td>
<p>A vector/list of length 1, 2, 4 or equal to the number of category points to be plotted.
</p>
<p>(a) If longer than length 4 then it contains the colours for all the points, their ellipses and labels.
</p>
<p>Taken to be a vector or list of valid R colours, length at least equal to the number of category points to be plotted,
in the order rows followed by columns for sca or variable categories in order for mca.
The colours can be named (e.g. &quot;azure2&quot;) or RGB hexadecimal (e.g. &quot;#1173B3&quot;),
and can be subsetted from colours() or from the colo(u)rspace library's palettes.
</p>
<p>(b) If length 4 then it takes the form:
</p>
<p>c(row symbol, &quot;row colour&quot;, column symbol, &quot;column colour&quot;)
</p>
<p>giving plot symbols and colours for row and column points and ellipses when they are the primary points.
</p>

<dl>
<dt>First element:</dt><dd><p>The plot symbol for row points - either an R number code (usually 0-25), or a character (in &quot; &quot;)</p>
</dd>
<dt>Second element:</dt><dd><p>The colour for row points, their ellipses and labels - either a valid R colour name (in &quot; &quot;)  or <br />
&quot;differentreds&quot; - each row is plotted with a different shade of red to green, using the grDevices rainbow palette <br />
&quot;differentblues&quot; - each row is plotted with a different shade of green to blue, using the grDevices rainbow palette <br />
&quot;alldifferent&quot; - each row is plotted with a different colour, using the grDevices rainbow palette from reds to blues<br />
&quot;viridis&quot; - each row is plotted with a different colour, using the grDevices viridis palette<br />
&quot;inferno&quot; - each row is plotted with a different colour, using the grDevices inferno palette, though not the extremes of it</p>
</dd>
<dt>Third element:</dt><dd><p>As first element but for column points</p>
</dd>
<dt>Fourth element:</dt><dd><p>As second element but for column points</p>
</dd>
</dl>

<p>(c1) If length 2 and the first element is a valid colour choice as above then it takes the form:
</p>
<p>c(&quot;row colour&quot;, &quot;column colour&quot;)
</p>
<p>giving colours for row and column points and ellipses when they are the primary points.
</p>

<dl>
<dt>First element:</dt><dd><p>The colour for row points, choices as second element above</p>
</dd>
<dt>Second element:</dt><dd><p>The colour for column points, choices as second element above</p>
</dd>
</dl>

<p>(c2) If length 2 and the first element is *not* a valid colour choice as above then it takes the form:
</p>
<p>c(column symbol, &quot;column colour&quot;)
</p>
<p>giving plot symbols and colours for column points and ellipses when they are the primary points.
</p>

<dl>
<dt>First element:</dt><dd><p>The plot symbol for column points, choices as first element above</p>
</dd>
<dt>Second element:</dt><dd><p>The colour for column points, choices as second element above</p>
</dd>
</dl>

<p>(d) If length 1 then it takes the form:
</p>
<p>&quot;column colour&quot;
</p>
<p>giving colours for column points and ellipses when they are the primary points, choices as second element above.
</p>
<p>Note: colour can also be specified as colours()[i] which picks out the i-th colour.
</p>
<p>Note: when analysing a Burt matrix the columns points are plotted.
</p>
<p>The idea behind &quot;alldifferent&quot; etc is that the colours change gradually, so that if the order of the rows/columns is
meaningful then the colour change tracks this.
</p>
<p>Note: groupings and grouplabels below override all this.</p>
</td></tr>
<tr><td><code id="plotca_+3A_othersmonochrome">othersmonochrome</code></td>
<td>
<p>Either:
</p>

<dl>
<dt>NULL</dt><dd><p>secondary points plotted using same colours as when they are primary points</p>
</dd>
<dt>a valid R colour (in &quot; &quot;)</dt><dd><p>all secondary points are plotted in this colour</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plotca_+3A_crpercent">crpercent</code></td>
<td>
<p>The nominal coverage percentage of the confidence ellipses
(90, 95 or 99 only if using bootstrap critical values)</p>
</td></tr>
<tr><td><code id="plotca_+3A_usebootcrits">usebootcrits</code></td>
<td>
<p>Whether to use bootstrap critical values for the ellipses:
</p>

<dl>
<dt>TRUE</dt><dd><p>use bootstrap critical values</p>
</dd>
<dt>FALSE</dt><dd><p>use <code class="reqn">\chi^2</code> critical values</p>
</dd>
<dt>NULL</dt><dd><p>inherit this choice from the chosen object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code> </p>
</dd>
</dl>

<p>Note: only 90%, 95% and 99% bootstrap critical values are available</p>
</td></tr>
<tr><td><code id="plotca_+3A_plottype">plottype</code></td>
<td>
<p>This is only relevant for simple CA, in MCA the choice is automatic.
</p>

<dl>
<dt>&quot;biplot&quot;</dt><dd><p>One plot with confidence regions for rows in principal coordinates
while columns are shown as directions in standard coordinates, another
plot with confidence regions for columns in principal coordinates while rows
are shown as directions in standard coordinates</p>
</dd>
<dt>&quot;french&quot;</dt><dd><p>Two plots each with both rows and columns in principal coordinates,
one plot shows confidence regions for the rows and the other shows
confidence regions for the columns</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plotca_+3A_showrowcrs">showrowcrs</code></td>
<td>
<p>Whether to plot confidence ellipses for row points:
</p>

<dl>
<dt>TRUE</dt><dd><p>plot all confidence ellipses for row points as usual</p>
</dd>
<dt>A row number or vector of row numbers</dt><dd><p>plot confidence ellipses only for these row points,
which can be specified in any standard R format such as 7 or c(1,4,9) or 5:11</p>
</dd>
<dt>FALSE</dt><dd><p>suppress plotting of all confidence ellipses for row points</p>
</dd>
</dl>

<p>Note: when analysing a Burt matrix the columns points are plotted</p>
</td></tr>
<tr><td><code id="plotca_+3A_showcolumncrs">showcolumncrs</code></td>
<td>
<p>Whether to plot confidence ellipses for column points:
</p>

<dl>
<dt>TRUE</dt><dd><p>plot all confidence ellipses for column points as usual</p>
</dd>
<dt>A column number or vector of column numbers</dt><dd><p>plot confidence ellipses only for these column points,
which can be specified in any standard R format such as 7 or c(1,4,9) or 5:11</p>
</dd>
<dt>FALSE</dt><dd><p>suppress plotting of all confidence ellipses for column points</p>
</dd>
</dl>

<p>Note: when analysing a Burt or indicator matrix the column points are plotted, the columns
being all of the variable categories, ordered by variable number,
e.g. for p=3 variables each with 5 categories then columns 6:10 are variable 2.
</p>
<p>Note: in MCA this is overridden by mcaoneploteach=TRUE, in which case there is one plot
per variable, automatically giving ellipses for each of its categories.</p>
</td></tr>
<tr><td><code id="plotca_+3A_likertarrows">likertarrows</code></td>
<td>
<p>If TRUE then, for MCA on likert-type ordered categorical data,
draw arrows connecting the category points for each variable,
with the arrows drawn from a category point to the next higher category point.<br />
Note: will only be drawn from category points with ellipses shown.</p>
</td></tr>
<tr><td><code id="plotca_+3A_firstaxis">firstaxis</code></td>
<td>
<p>Number of the first (i.e. highest inertia) axis to be plotted</p>
</td></tr>
<tr><td><code id="plotca_+3A_lastaxis">lastaxis</code></td>
<td>
<p>Number of the last (i.e. lowest inertia) axis to be plotted,
which must be &lt;= axisvariances value for x.</p>
</td></tr>
<tr><td><code id="plotca_+3A_plotallpairs">plotallpairs</code></td>
<td>
<p>Whether to plot all pairs of axes against each other:
</p>

<dl>
<dt>&quot;onlythese&quot;</dt><dd><p>plot firstaxis v lastaxis only</p>
</dd>
<dt>&quot;successive&quot;</dt><dd><p>plot all successive pairs of axes between firstaxis and lastaxis</p>
</dd>
<dt>&quot;all&quot;</dt><dd><p>plot all possible pairs of axes between firstaxis and lastaxis</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plotca_+3A_picsize">picsize</code></td>
<td>
<p>A 2-vector/list or 4-vector/list specifying the plot size:
</p>

<dl>
<dt>2-vector</dt><dd><p>minimum and maximum of both x and y axes on each plot</p>
</dd>
<dt>4-vector</dt><dd><p>min and max of x axis followed by min and max of y axis, where the difference
between max and min must be the same in both cases</p>
</dd>
</dl>

<p>All plots have an aspect ratio of 1.
</p>
<p>The same scales are used for all plots, so in the biplot case it
might occasionally be preferred to run plotca twice with different
picsize values, one being better for rows in principal coordinates
and the other better for columns in principal coordinates.
</p>
<p>If picsize is used to focus in on a particular area
of the plot then biplot labels might not appear properly.
</p>
<p>If using Rstudio then it may override this somewhat, especially if you resize the plot window
after plotting.
</p>
<p>If Rstudio has too much of a mind of its own when plotting then try plotwithdevnew=TRUE to
put each plot in a new window, as in standard R.</p>
</td></tr>
<tr><td><code id="plotca_+3A_mcaoneploteach">mcaoneploteach</code></td>
<td>
<p>For MCA only, a flag or list of column numbers saying whether to produce one plot for each variable,
where confidence ellipses are shown for that variable but not others:
</p>

<dl>
<dt>TRUE</dt><dd><p>p plots are produced, each showing confidence regions for all of the category points
for just one variable, overriding showcolumncrs</p>
</dd>
<dt>number or vector of numbers</dt><dd><p>produce one plot for each of the specified variable numbers, as above</p>
</dd>
<dt>FALSE</dt><dd><p>only one plot is produced, with confidence regions shown for each category
point of each variable, although this can be controlled by showcolumncrs</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plotca_+3A_mcashowindividuals">mcashowindividuals</code></td>
<td>
<p>For MCA on an indicator matrix only, a flag saying whether to
plot the individuals on the plot(s):
</p>

<dl>
<dt>TRUE</dt><dd><p>plot the individuals, which could be very &quot;busy&quot;</p>
</dd>
<dt>FALSE</dt><dd><p>don't plot the individuals</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plotca_+3A_mcavariablecolours">mcavariablecolours</code></td>
<td>

<dl>
<dt>TRUE</dt><dd><p>In MCA each variable has its own colour, and all category
points and ellipses for that variable have the same colour</p>
</dd>
<dt>FALSE</dt><dd><p>Colours chosen in the default way</p>
</dd>
</dl>

<p>If TRUE then the only valid colour options for plotsymbolscolours are &quot;viridis&quot;, &quot;inferno&quot;, &quot;alldifferent&quot;, &quot;differentreds&quot; or &quot;differentblues&quot; as above. <br />
Hence if TRUE then colours vary from variable 1 to variable p with each variable having all its categories
plotted with the same colour, while if FALSE then colours vary from variable 1 category 1 to variable p category J_p.
</p>
<p>Note: if plotsymbolscolours has length &gt; 4, and so is specifying a colour for each category, then it overrides this.</p>
</td></tr>
<tr><td><code id="plotca_+3A_mcacategorycolours">mcacategorycolours</code></td>
<td>

<dl>
<dt>TRUE</dt><dd><p>In MCA each category number has its own colour,
and all points and ellipses for that category number have the same colour,
for all variables (intended for Likert type data so that all category 1 points are
the same colour etc)</p>
</dd>
<dt>FALSE</dt><dd><p>Colours chosen in the default way</p>
</dd>
</dl>

<p>If TRUE then the only valid colour options for plotsymbolscolours are &quot;viridis&quot;, &quot;inferno&quot;, &quot;alldifferent&quot;, &quot;differentreds&quot; or &quot;differentblues&quot; as above. <br />
Hence if TRUE then colours vary from category 1 to category J_k with category i being the same colour for each variable,
while if FALSE then colours vary from variable 1 category 1 to variable p category J_p.
</p>
<p>Note: if plotsymbolscolours has length &gt; 4, and so is specifying a colour for each category, then it overrides this.</p>
</td></tr>
<tr><td><code id="plotca_+3A_groupings">groupings</code></td>
<td>
<p>The name of a file (in &quot; &quot;) or data frame containing group structure of row and column points:
</p>
<p>the n rows are divided into m groups and the p columns divided into k groups
</p>
<p>the file or data frame is n+p by 2, where:
</p>
<p>first column is 1..n 1..p (to make the file easier to read) <br />
second column contains the number of the group-of-rows (1..m)
or group-of-columns (1..k) that the row or column belongs to.
</p>
<p>Hence the file or data frame is:
</p>
<p>1 &lt;the number of the group-of-rows to which row 1 belongs&gt; <br />
... <br />
n &lt;the number of the group-of-rows to which row n belongs&gt; <br />
1 &lt;the number of the group-of-columns to which column 1 belongs&gt; <br />
... <br />
p &lt;the number of the group-of-columns to which column p belongs&gt;</p>
</td></tr>
<tr><td><code id="plotca_+3A_grouplabels">grouplabels</code></td>
<td>
<p>The name of the file (in &quot; &quot;) or data frame containing the colours and labels to be used,
in association with the groupings option above, in a m+k by 5 array:
</p>
<p>1 &lt;legend&gt; &lt;plot symbol&gt; &lt;plot colour&gt; &lt;draw ellipse?&gt; <br />
... <br />
m &lt;legend&gt; &lt;plot symbol&gt; &lt;plot colour&gt; &lt;draw ellipse?&gt; <br />
1 &lt;legend&gt; &lt;plot symbol&gt; &lt;plot colour&gt; &lt;draw ellipse?&gt; <br />
... <br />
k &lt;legend&gt; &lt;plot symbol&gt; &lt;plot colour&gt; &lt;draw ellipse?&gt;
</p>
<p>The first column contains the number of the group-of-rows or group-of-columns, the others are:
</p>

<dl>
<dt>legend (in &quot; &quot; if in data frame but not in file)</dt><dd><p>for this group of rows/columns, to be shown on plot</p>
</dd>
<dt>symbol</dt><dd><p>for all rows/columns in this group, either an R number code for a symbol
or a character (the latter in &quot; &quot; if in a data frame but not if in a file)<br />
Note: both rows and columns need to be either all numbers or all characters, or the legend will
not come out right</p>
</dd>
<dt>colour (in &quot; &quot;)</dt><dd><p>for symbols and ellipses for this group</p>
</dd>
<dt>draw?</dt><dd><p>T or F to draw or suppress ellipses and label points for this group
(both in &quot; &quot; in data frame but not in file)</p>
</dd>
</dl>

<p>See Details section and examples below to make more sense of this.
</p>
<p>This can also be used for multiple CA, remembering that only column points are shown (usually)
and that columns are ordered by variable and then by category, so that three variables each with
5 categories will be columns 1:5, 6:10 and 11:15 respectively.
It should not be used when mcaoneploteach=TRUE, however, as that already takes care of this sort of grouping.
</p>
<p>These options are particularly intended for large data sets,
to allow attention to be drawn to some points above others,
to emphasize any group structure within the data, or to show only the
most important ellipses in order to make the picture less cluttered.</p>
</td></tr>
<tr><td><code id="plotca_+3A_eps">eps</code></td>
<td>
<p>Any value less than this is treated as zero in some calculations and comparisons</p>
</td></tr>
<tr><td><code id="plotca_+3A_plotwithdevnew">plotwithdevnew</code></td>
<td>
<p>When using Rstudio, a flag saying whether to put each
plot in a new device (plot window) or just use the default Rstudio plot pane:
</p>

<dl>
<dt>TRUE</dt><dd><p>Each plot gets its own new plot window, as in standard R outside Rstudio</p>
</dd>
<dt>FALSE</dt><dd><p>All plots appear squashed into the usual Rstudio plot pane</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>In the following, the categories for which confidence regions are being shown are referred
to as the primary points, the others as the secondary points.
The primary points are always plotted in principal coordinates while the secondary
points can be in standard (biplot style in simple CA) or principal
(french style in simple CA, always in multiple CA) coordinates.
</p>
<p>The default colour scheme is for the primary points and their confidence ellipses
to be plotted each in a different colour, as this makes it easier to see which
ellipse goes with which point, while the secondary points are all plotted in monochrome
to make it easier to distinguish between the two sets of points.
This can all be controlled by the user.
Note that a point will still be treated as a primary point and plotted with its own
colour even when the plotting of its ellipse is suppressed with the showrowcrs or showcolumncrs options.
</p>
<p>Note that the plots will look better if saved as .eps or .pdf rather than as .jpg or .png.
</p>
<p><strong>(1) Simple CA</strong>
</p>
<p>Two plots are produced, in each plot one set of points (rows or columns) is regarded as
the primary set and is plotted in principal coordinates with confidence regions shown:<br />
- one plot shows confidence regions for rows in principal coordinates<br />
- one plot shows confidence regions for columns in principal coordinates<br />
The other set of points (columns or rows) is regarded as the secondary set and the plotting
depends on the choice of biplot or french-style plot:<br />
biplot - secondary points shown as directions in standard coordinates<br />
french - secondary points shown in principal coordinates
</p>
<p><strong>(2) Multiple CA</strong>
</p>
<p>All points are plotted in principal coordinates (&quot;french&quot;)
</p>
<p>Burt matrix (mcatype=&quot;Burt&quot;):
</p>
<p>a) only plot the columns of the Burt matrix (the rows are the same)<br />
b) plot all variable categories, i.e. columns<br />
c) if mcaoneploteach=TRUE then produce p plots, each with CRs for all categories of one of the variables,<br />
otherwise produce one plot showing CRs for all variables (busy)<br />
d) Columns are ordered by variable then category
(e.g. for p=3 with 5 categories each, columns 6:10 are variable 2)
</p>
<p>Indicator matrix (mcatype=&quot;indicator&quot;):
</p>
<p>a) if mcashowindividuals=TRUE then plot individual (row) points, without CRs<br />
b) as Burt for variables
</p>
<p>Indicator matrix (mcatype=&quot;indicator&quot;) with experimental likert resampling (cabootcrs had mcaindividualboot=TRUE):
</p>
<p>a) if mcashowindividuals=TRUE then plot individual (row) points, with CRs (busy)<br />
b) as Burt for variables
</p>
<p><strong>(3) Critical values</strong>
</p>
<p>Critical values for the ellipses default to those specified in cabootcrs,
which default to bootstrap critical values
</p>
<p><strong>(4) Choosing colours and which ellipses to show</strong>
</p>
<p>The showrowcrs, showcolumncrs, showrowlabels, showcolumnlabels
and othersmonochrome options are available as ways of reducing plot
clutter in large data sets, for example by showing the column points
unlabelled and monochrome as a way of drawing the eye to the
multicoloured row points and ellipses.
</p>
<p>The default is for each primary point to be in a different colour,
with secondary points in the colour defined by othersmonochrome (default grey).
If othersmonochrome=NULL then secondary points are also plotted with different colours.
</p>
<p>The plotsymbolscolours option can be used to specify quickly the set of symbols and colours used,
with the options described in (5) below giving far more control at the cost of extra work.
</p>
<p>The default colour scheme is grDevices:inferno, but with k+2 colours picked and then 2:k+1 used,
because the end colour is a bit too yellow and hard to see.
</p>
<p>Note that french-style plots in simple CA
are often less cluttered because they omit the biplot lines,
while they also show the two sets of points on similar scales
so that it is easier to fit all the points on one picture
without cropping or excessive empty space.
</p>
<p><strong>(5) Specifying colours for (groups of) points and ellipses</strong>
</p>
<p>For large matrices the plots from exploratory multivariate methods
are often so busy that the whole point of the method, to clarify
the structure of the data, is nullified. This is even more of a
problem when confidence regions are shown on the plots.
</p>
<p>Hence points can be defined in groups as below, so you can divide them into groups
in one or more ways, e.g. rows 1-3 in red and rows 4-8 in blue,
or rows 1-5 in green and rows 6-8 in orange etc.
</p>
<p>The groupings and grouplabels options are chosen via separate text files
or data frames to define the groups of points.
If groupings is left null then plotsymbolscolours is used instead.
</p>
<p>There are two ways of defining groupings and group labels. The first of these is by
defining a pair of data frames within R and supplying them as parameters either to
cabootcrs initially or to plotca. This method works in R CMD check and hence is the
one used in the examples, but as you can see is rather hard to follow.
</p>
<p>To plot with colours defined using groups-of-points:
</p>
<p>bd &lt;- cabootcrs(DreamData)
</p>
<p>Then define the groups using data frames in R or text files:
</p>
<p><strong>(5a) Using data frames</strong>
</p>
<p>These data frames define the same groupings and colours as the files below,
see the files for a clearer explanation:
</p>
<pre>
bd &lt;- cabootcrs(DreamData)
groupingsframe &lt;- cbind(c(1:5,1:4),c(1,1,2,2,3,1,1,2,2))
grouplabframe &lt;- cbind( c(1,2,3,1,2), c("AB","CD","E","ab","cd"), c(19,20,21,"+","*"), c("green","blue","yellow","red","orange"), "T" )
plotca(bd, groupings=groupingsframe, grouplabels=grouplabframe)
</pre>
<p><strong>(5b) Using text files</strong>
</p>
<p>A version which produces identical results, but does not work in R CMD check, is
usually much easier for the user as they can be edited outside R.
The groupings and group labels are defined in files,
present in the directory specified in setwd().
To obtain identical results to the above, create two text files as below:
</p>
<p>DreamGroupings.txt contains
</p>
<pre>
1 1
2 1
3 2
4 2
5 3
1 1
2 1
3 2
4 2
</pre>
<p>e.g. the first two lines show that rows 1,2 belong to group-of-rows 1,
while the last two lines show that columns 3,4 belong to group-of-columns 2.
</p>
<p>DreamGroupLabels.txt contains
</p>
<pre>
1 AB 19  "green"  T
2 CD 20  "blue"   T
3  E 21  "yellow" T
1 ab  +  "red"    T
2 cd  *  "orange"  T
</pre>
<p>e.g. group-of-rows 1 will be shown in green and plotted with symbol 19, with the legend AB.
</p>
<pre>
bd &lt;- cabootcrs(DreamData, showresults=FALSE)
plotca(bd, groupings="DreamGroupings.txt", grouplabels="DreamGroupLabels.txt")
</pre>
<p><strong>(5c) General use</strong>
</p>
<p>Even without groupings this can be used to specify all colours, simply by specifying each point as its own group,
in this case rows 1-5 and columns 1-4 define row groups 1-5 and column groups 1-4, no legend is required so repeat &quot;&quot;,
choose 9 plot symbols and 9 colours.
</p>
<p>Hence to plot each point with its own specified colour and symbol:
</p>
<pre>
bd &lt;- cabootcrs(DreamData, showresults=FALSE)
groupingsframe &lt;- cbind(c(1:5,1:4),c(1:5,1:4))
grouplabframe &lt;- cbind( c(1:5,1:4), rep("",9), 11:19, c("green","blue","yellow","red","orange","grey1","grey22","grey44","grey66"), "T" )
plotca(bd, groupings=groupingsframe, grouplabels=grouplabframe)
</pre>
<p>Note: plotsymbolscolours can be used to plot with a different colour for each category point, but with default symbols.
</p>
<p><strong>(5d) MCA use</strong>
</p>
<p>As before, but need to specify for both row and column categories even though only column categories will be plotted,
so just duplicate the data frames (yes I know it's a bodge). <br />
Hence to plot each point with your own choice of colour and symbol:
</p>
<pre>
bd3 &lt;- cabootcrs(DreamData223by3, catype="mca", varandcat=FALSE)
groupingsframe &lt;- cbind(1:12,1:12)
groupingsframe &lt;- rbind(groupingsframe,groupingsframe)
grouplabframe &lt;- cbind( 1:12, rep("",12), 11:22, c("green","blue","yellow","red","orange","grey1","grey22","grey44","grey66","coral1","coral2","coral3"), "T" )
grouplabframe &lt;- rbind(grouplabframe,grouplabframe)
plotca(bd3, groupings=groupingsframe, grouplabels=grouplabframe)
</pre>
<p>This can also be used to specify colours and symbols for each variable in MCA, but note that you are still specifying for each column point,
so that you need to know how many categories each variable has - a simpler way to do this will be added to a later update.
</p>
<pre>
ost &lt;- cabootcrs(OsteoDataNames, catype="mca", varandcat=FALSE)
totcolumns &lt;- ost@columns
totvars &lt;- ost@p
numcats &lt;- ost@Jk
cats &lt;- NULL
for (i in 1:totvars) { cats &lt;- c(cats,rep(i,numcats[i])) }
groupingsframe &lt;- cbind(1:totcolumns,cats)
groupingsframe &lt;- rbind(groupingsframe,groupingsframe)
grouplabframe &lt;- cbind( 1:totvars, rep("",totvars), rep(19,totvars), c("blue","red","green","darkgreen","green3","black","grey1","coral1","coral2","coral3","navy"), "T" )
grouplabframe &lt;- rbind(grouplabframe,grouplabframe)
plotca(ost, groupings=groupingsframe, grouplabels=grouplabframe)
</pre>
<p>This can also be used to plot the individual points with colours to denote groups, for example in the below
the first 100 individual points are plotted with one colour, the rest with another, while all columns get their own colour.
</p>
<pre>
bd3indnoboot &lt;- cabootcrs(DreamData223by3,catype="mca",mcatype="indicator",varandcat=FALSE,nboots=0)
rowgroups &lt;- cbind( 1:223, c(rep(1,100),rep(2,123)) )
colgroups &lt;- cbind(1:12,1:12)
groupingsframe &lt;- rbind( rowgroups, colgroups )
rowlabs &lt;- cbind( 1:2, c("1-100","101-223"), c("+","+"), c("black","grey"), "T")
collabs &lt;- cbind( 1:12, rep("",12), "*", c("green","cyan","yellow","red","orange","blue","blue1","blue2","blue3","coral1","coral2","coral3"), "T" )
grouplabframe &lt;- rbind(rowlabs,collabs)
plotca(bd3indnoboot, groupings=groupingsframe, grouplabels=grouplabframe, mcashowindividuals=TRUE, mcaoneploteach=FALSE, showrowlabels=FALSE, othersmonochrome=NULL, picsize=c(-.36,.36))
</pre>
<p><strong>(6) Plotting results from cabootcrs() using ellipse() or ca()</strong>
</p>
<p>This can be used with the ellipse() package to add the confidence ellipse to a picture from another package
</p>
<p>Example: confidence ellipse for row or column i on axes 1,2 from cabootcrs output Results is:
</p>
<pre>
lines(ellipse(x=covmat(Results,i,"row",1,2,FALSE), centre=Results@Rowprinccoord[i,cbind(1,2)], npoints=1000), cex=1, pch=".", col="blue")
lines(ellipse(x=covmat(Results,i,"column",1,2,FALSE), centre=Results@Colprinccoord[i,cbind(1,2)], npoints=1000), cex=1, pch=".", col="blue")
</pre>
<p>Example: to add row CRs to a plot from the ca() package to data set TheData
</p>
<pre>
Results &lt;- cabootcrs(TheData, showresults=FALSE)
caResults &lt;- ca(TheData)
plot(caResults)
for (i in 1:dim(TheData)[1]) {
  lines(ellipse(x=covmat(Results,i,"row",1,2,FALSE), centre=Results@Rowprinccoord[i,cbind(1,2)], npoints=1000), cex=1, pch=".", col="blue")
}
</pre>
<p>However note that reflectaxes() may also be needed.
</p>
<p><strong>(7) Note</strong>
</p>
<p>Note that plotca, summaryca and printca are all defined as new functions,
rather than as overloaded versions of plot, summary and print,
simply in order to avoid complication and unintended consequences within R
</p>


<h3>Value</h3>

<p>One or more plots are produced but no output object is created
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>,
<code><a href="#topic+printca">printca</a></code>, <code><a href="#topic+summaryca">summaryca</a></code>, <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the main function also calls plotca with the default options

bd &lt;- cabootcrs(DreamDataNames, datasetname="Maxwell's dream data",
                varnames=c("Age groups","Severity of disturbance"),showresults=FALSE)
plotca(bd)

## Not run: 

### Plot options for SCA:

# Note that Rstudio changes plots depending on the size of your plot window,
# so the picsize parameter (used for xlim, ylim in the plot command) is partially
# overridden, so warnings that a point is outside the plot limits may not be correct

# Plot with specified size to fit the whole of the arrows in without cropping

plotca(bd, picsize=c(-2.5,2.5))

# or smaller, note the warning

plotca(bd, picsize=c(-0.5,0.5))

# Replacing the plot titles with your own

plotca(bd, mytitles=c("Plot 1 Title line 1\nline 2\nline 3","Plot 2 Title line 1\nline 2\nline 3" ))

# All points in colour

plotca(bd,othersmonochrome=NULL)

# 90% regions in reds and blue

plotca(bd, plotsymbolscolours=c(3,"differentreds","*","blue"), crpercent=90)

# Many different colour schemes and ways of specifying colours and symbols

# Specify colour/colour scheme and symbols
plotca(bd, plotsymbolscolours=c(3,"differentreds","*","blue") )
plotca(bd, plotsymbolscolours=c(3,"viridis") )
plotca(bd, plotsymbolscolours="inferno" )
plotca(bd, plotsymbolscolours=colours()[641] )

# Just give a list of colours, one for each category point
plotca(bd,
plotsymbolscolours=c("green","blue","yellow","red","orange","red","blue","tan1","orchid4") )
plotca(bd, plotsymbolscolours=colours()[161:170] )
plotca(bd, plotsymbolscolours=colours()[c(111:115,561:564)] )

# This time using colo(u)rspace package colour palettes
library(colorspace)
plotca(bd, plotsymbolscolours=hcl.colors(9,palette="Peach") )
plotca(bd, plotsymbolscolours=hcl.colors(50,palette="Mint")[c(11:15,31:34)] )
plotca(bd,
plotsymbolscolours=c(sequential_hcl(bd@rows,"Blues 3"),sequential_hcl(bd@columns,"Reds 3")) )

# suppress labels for column points, to de-clutter row points picture,
# this is mostly useful for larger data sets than this one

plotca(bd, showcolumnlabels=FALSE)

# only show ellipses for rows 1, 1-2 and 1-3 respectively

plotca(bd, showrowcrs=1)
plotca(bd, showrowcrs=c(1,2))
plotca(bd, showrowcrs=1:3)

# plot axes 1 v 2, 1 v 3 and 2 v 3

plotca(bd, firstaxis=1, lastaxis=3, plotallpairs="all")

# If the cell values were all 10 times larger

bdx10 &lt;- cabootcrs(10*DreamData)
plotca(bdx10,plottype = "french",picsize=c(-0.4,0.4))

# Various plots for a larger data set, note that the default colour scheme picks out
# males, females and ages because of the ordering of the rows

bs &lt;- cabootcrs(SuicideData)
plotca(bs, picsize=c(-0.7,0.8))
plotca(bs, plottype="french", picsize=c(-0.7,0.8))
plotca(bs, plottype="french", picsize=c(-0.7,0.8),
           plotsymbolscolours=c(".","inferno","+","black"))

# Note that the ellipses follow the horseshoe

bas &lt;- cabootcrs(AsbestosData)

# more complicated plotting, define group structure in data frames

groupingsframe &lt;- cbind( c(1:5,1:4), c(1,1,2,2,3,1,1,2,2) )
grouplabframe &lt;- cbind( c(1,2,3,1,2), c("AB","CD","E","ab","cd"), c(19,20,21,"+","*"),
                        c("green","blue","yellow","red","orange"), "T" )
plotca(bd, groupings=groupingsframe, grouplabels=grouplabframe)

plotca(bd, groupings=groupingsframe, grouplabels=grouplabframe, plottype="french")

# This can also be used for custom colour schemes other than "differentreds" etc as
# defined in the plotsymbolscolours option, though note that R colours are not ordered in the
# way you might expect, so the colour scheme below is purely illustrative and not very sensible

customframe &lt;- cbind( c(1:5,1:4), c(1:5,1:4) )
customlabframe &lt;- cbind( c(1:5,1:4), rep("",9), c(rep(18,5),rep(19,4)),
                         colours()[c(seq(10,130,30),seq(440,590,50))], "T" )

plotca(bd, groupings=customframe, grouplabels=customlabframe)


### Plot options for MCA:

# Use one of the below, labelling row A as R:A or just A (etc) as preferred

bd3 &lt;- cabootcrs(DreamData223by3, catype="mca",
                 datasetname="Dream data with extra random column")
bd3 &lt;- cabootcrs(DreamData223by3, catype="mca", varandcat=FALSE,
                 datasetname="Dream data with extra random column")

# just variable 2

plotca(bd3,mcaoneploteach=2)

# just variables 1 and 3

plotca(bd3,mcaoneploteach=c(1,3))

# one plot showing CRs for all variable categories (busy)

plotca(bd3,mcaoneploteach=FALSE)

# each variable has its own colour

plotca(bd3,mcavariablecolours=TRUE)

# each category number has its own colour

plotca(bd3,mcacategorycolours=TRUE)

# draw arrows between successive ordered categories

plotca(bd3,likertarrows=TRUE)

# secondary points black rather than grey

plotca(bd3,othersmonochrome="black")

# 99% CRs

plotca(bd3,crpercent=99)

# Plot together CRs for the first category of each variable

plotca(bd3,showcolumncrs=c(1,6,10),mcaoneploteach=FALSE)

# Plot together CRs for the second category of each variable

plotca(bd3,showcolumncrs=c(2,7,11),mcaoneploteach=FALSE)

# One plot with CRs only for variable 3

plotca(bd3,showcolumncrs=10:12,mcaoneploteach=FALSE)

# Three plots, various colour schemes

plotca(bd3,othersmonochrome="black")
plotca(bd3,othersmonochrome="black",mcacategorycolours=TRUE)
plotca(bd3,mcavariablecolours=TRUE,likertarrows=TRUE)

# All on one plot, various colour schemes, very busy

plotca(bd3,mcaoneploteach=FALSE,showcolumncrs=1:5,othersmonochrome="black")
plotca(bd3,mcaoneploteach=FALSE,showcolumncrs=1:5,likertarrows=TRUE)
plotca(bd3,mcaoneploteach=FALSE,likertarrows=TRUE,mcacategorycolours=TRUE)
plotca(bd3,mcaoneploteach=FALSE,likertarrows=TRUE,mcavariablecolours=TRUE)

# Plots with more complicated colour and grouping structure, as above but now in MCA case.
# Note the need to duplicate both data frames as groupings must be specified for both rows
# and columns, though only columns are used.
# Note also that symbol types need to be defined either all as numbers or all as symbols

groupingsframe &lt;- cbind(1:12,c(1,1,2,2,3,4,4,5,5,6,7,7))
groupingsframe &lt;- rbind(groupingsframe,groupingsframe)
grouplabframe &lt;- cbind( 1:7, c("AB","CD","E","ab","cd","v1","v23"), 19:25,
                        c("cyan","deepskyblue","blue","red","tomato","chartreuse","green"),
                        "T" )
grouplabframe &lt;- rbind(grouplabframe,grouplabframe)
plotca(bd3, groupings=groupingsframe, grouplabels=grouplabframe,
       mcaoneploteach=FALSE)


### Adding confidence ellipses to plots from ca package ca() and mjca() functions

## Simple CA

# Adding confidence ellipses for row points to plots from ca() using ellipse()
# Note: reflectaxes() is needed if cabootcrs() and ca() axes are reflected wrt each other

library(ca)
library(ellipse)
cad &lt;- ca(DreamData)
plot(cad)
for (i in 1:dim(DreamData)[1]) {
  lines( ellipse(x=covmat(bd,i,"row",1,2,FALSE), centre=bd@Rowprinccoord[i,cbind(1,2)],
                 npoints=1000),
         cex=1, pch=".", col="blue")
}

# These plots can also be produced almost identically here

bd &lt;- cabootcrs(DreamData, showresults=FALSE)

# both plots almost the same as the default plot from ca()

plotca(bd, plottype="french", showrowcrs=FALSE, showcolumncrs=FALSE, othersmonochrome=NULL,
       plotsymbolscolours=c(19,"blue",17,"red"), picsize=c(-0.5,0.6) )

# plot almost the same as the ca() plot, but with ellipses added

plotca(bd, plottype="french", othersmonochrome=NULL, plotsymbolscolours=c(19,"blue",17,"red"),
       picsize=c(-0.5,0.6))


## Multiple CA

# Adding confidence ellipses for category points to plots from mjca() using ellipse()
# Note that ca also uses standardised inertias and coordinates by default

library(ca)
library(ellipse)
cad3 &lt;- mjca(DreamData223by3)

# Obtain covariance matrices, using same scalings and standardisations

bd3 &lt;- cabootcrs(DreamData223by3, catype="mca", showresults=FALSE)

# Reflect axis 1 for consistency (may differ on other machines)

bd3 &lt;- reflectaxes(bd3,1)

# Plot and then add ellipses for categories of variable 1 only

plot(cad3)
for (i in 1:bd3@Jk[1]) {
  lines( ellipse(x=covmat(bd3,i,"column",1,2,FALSE), centre=bd3@Colprinccoord[i,cbind(1,2)],
                 npoints=1000),
         cex=1, pch=".", col="red")
}

# These plots can also be produced almost identically here

plotca(bd3,picsize=c(-0.35,0.35), mcaoneploteach=FALSE, mcavariablecolours=TRUE,
           showcolumncrs=FALSE)
plotca(bd3,picsize=c(-0.35,0.35), mcaoneploteach=FALSE, plotsymbolscolours=c(17,"red"),
           showcolumncrs=FALSE)
plotca(bd3,picsize=c(-0.35,0.35), mcaoneploteach=FALSE, mcacategorycolours=TRUE,
           showcolumncrs=1:5 )

# Three separate plots with ellipses for one variable on each

for (j in 1:length(bd3@Jk)) {
  plot(cad3)
  if (j==1) { firstcol &lt;- 1 } else { firstcol &lt;- cumsum(bd3@Jk)[j-1]+1 }
  for (i in firstcol:cumsum(bd3@Jk)[j]) {
    lines( ellipse(x=covmat(bd3,i,"column",1,2,FALSE), centre=bd3@Colprinccoord[i,cbind(1,2)],
                   npoints=1000),
           cex=1, pch=".", col="red")
  }
}

# For comparison, default plot with one plot each showing the ellipses for each variable

plotca(bd3,picsize=c(-0.35,0.35), mcacategorycolours=TRUE )


## End(Not run)

</code></pre>

<hr>
<h2 id='printca'>Prints reasonably full results, including variances</h2><span id='topic+printca'></span>

<h3>Description</h3>

<p><code>printca</code> prints full correspondence analysis results, including inertias, coordinates,
representations, contributions, variances, covariances and critical values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printca(x, datasetname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printca_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code></p>
</td></tr>
<tr><td><code id="printca_+3A_datasetname">datasetname</code></td>
<td>
<p>The name (in &quot;&quot;) of the data set, to be used in the output, defaults to name in cabootcrs object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed results, no plots or objects produced
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>, <code><a href="#topic+summaryca">summaryca</a></code>, <code><a href="#topic+plotca">plotca</a></code>,
<code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- cabootcrs(DreamData, showresults=FALSE)
printca(results, datasetname="Dreams")

</code></pre>

<hr>
<h2 id='rearrange'>Rearranges bootstrap axes by comparing to sample axes</h2><span id='topic+rearrange'></span>

<h3>Description</h3>

<p><code>rearrange</code> compares one set of axes for row points and column points (from the bootstrap
data matrix) to another (from the sample data matrix) by looking at all possible
reorderings and reflections (only) of the bootstrap axes and picking the one which
best matches the sample axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rearrange(
  RS,
  RB,
  CS,
  CB,
  r,
  reflectonly = FALSE,
  catype = "sca",
  mcatype = "Burt",
  mcaindividualboot = FALSE,
  maxrearrange = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rearrange_+3A_rs">RS</code></td>
<td>
<p>Sample axes for row points (as columns)</p>
</td></tr>
<tr><td><code id="rearrange_+3A_rb">RB</code></td>
<td>
<p>Bootstrap axes for row points (as columns)</p>
</td></tr>
<tr><td><code id="rearrange_+3A_cs">CS</code></td>
<td>
<p>Sample axes for column points (as columns)</p>
</td></tr>
<tr><td><code id="rearrange_+3A_cb">CB</code></td>
<td>
<p>Bootstrap axes for column points (as columns)</p>
</td></tr>
<tr><td><code id="rearrange_+3A_r">r</code></td>
<td>
<p>Rank of the bootstrap matrix</p>
</td></tr>
<tr><td><code id="rearrange_+3A_reflectonly">reflectonly</code></td>
<td>
<p>TRUE to reflect the axes only, no reordering</p>
</td></tr>
<tr><td><code id="rearrange_+3A_catype">catype</code></td>
<td>
<p>Can be &quot;sca&quot; for simple or &quot;mca&quot; for multiple CA.<br />
If &quot;sca&quot; then the rearranging will use both row axes and column axes,<br />
if &quot;mca&quot; then this depends on the mcatype parameter</p>
</td></tr>
<tr><td><code id="rearrange_+3A_mcatype">mcatype</code></td>
<td>
<p>&quot;Burt&quot; if using Burt matrix rows and columns are the same, so only use column axes<br />
&quot;indicator&quot; if using indicator matrix, only use row axes</p>
</td></tr>
<tr><td><code id="rearrange_+3A_mcaindividualboot">mcaindividualboot</code></td>
<td>
<p>TRUE to use highly experimental method</p>
</td></tr>
<tr><td><code id="rearrange_+3A_maxrearrange">maxrearrange</code></td>
<td>
<p>Maximum number of axes to rearrange</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is only intended for internal use by the <code><a href="#topic+cabootcrs">cabootcrs</a></code> function.
</p>
<p>Finds the rearrangement of columns of RB and CB to maximise match = tr( abs(RS'*RB + CS'*CB) )
</p>
<p>Uses the Hungarian algorithm via lp.assign in lpSolve up to a maximum of maxrearrange vectors.
</p>
<p>Algorithm assigns columns (B) to rows (S), hence transpose matrix so postmultiplication moves B to coincide with S.
</p>
<p>In effect this is Procrustes rotation of bootstrap axes to best match sample axes,
except that there is no rotation, only reflection and reordering of axes (aka rearranging).
</p>
<p>Note that this seeks the best fit to all axes, not best fit just to the ones
whose variances are being calculated, and does not weight the reordering
by eigenvalues or restrict how far a vector can be reordered by.
Hence a fairly low maxrearrange may be preferable.
</p>
<p>Faster than full comparison when rank &gt;= 4, for maxrearrange=6,
but can take much longer if rearrange all axes
</p>
<p>Rearranging more axes means higher chance of finding a matching axis,
so std dev can be decreased by average of 1-2% if all axes are rearranged.
</p>
<p>Limited testing suggests that rearranging all axes tends to over-reorder
and hence underestimate variances, due to ignoring eigenvalues,
hence seems best to rearrange 6 as before, unless very large numbers
of close eigenvalues.
</p>
<p>When mca bootstrap replicate has fewer &quot;real&quot; singular values (i.e. &gt; 1/p)
than the sample matrix then only the first B@realr axes will be compared,
so that the last sample axis will get nothing from this replicate and the
&quot;real&quot; bootstrap axes will be matched only with the same first few sample ones.
</p>
<p>r = rank of bootstrap matrix, so if &lt; sample rank will ignore last sample axis
</p>


<h3>Value</h3>

<p>list containing: <br />
T = matrix to rearrange xB so it is equivalent to xS, i.e. xS &lt;- xB * T <br />
numre = number of axes checked for rearranging = min(r,maxrearrange)<br />
match = assign$objval from the Hungarian algorithm<br />
same = flag for whether there was no reordering of axes (but may have been reflection)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not intended for direct call by users

</code></pre>

<hr>
<h2 id='rearrange_old'>Old and rubbish algorithm to rearrange bootstrap axes by comparing to sample axes</h2><span id='topic+rearrange_old'></span>

<h3>Description</h3>

<p><code>rearrange_old</code> compares one set of axes for row points and column points (from the bootstrap
data matrix) to another (from the sample data matrix) by looking at all possible
reorderings and reflections (only) of the bootstrap axes and picking the one which
best matches the sample axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rearrange_old(RS, RB, CS, CB, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rearrange_old_+3A_rs">RS</code></td>
<td>
<p>Sample axes for row points (as columns)</p>
</td></tr>
<tr><td><code id="rearrange_old_+3A_rb">RB</code></td>
<td>
<p>Bootstrap axes for row points (as columns)</p>
</td></tr>
<tr><td><code id="rearrange_old_+3A_cs">CS</code></td>
<td>
<p>Sample axes for column points (as columns)</p>
</td></tr>
<tr><td><code id="rearrange_old_+3A_cb">CB</code></td>
<td>
<p>Bootstrap axes for column points (as columns)</p>
</td></tr>
<tr><td><code id="rearrange_old_+3A_r">r</code></td>
<td>
<p>Rank of the bootstrap matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is only intended for internal use by the <code><a href="#topic+cabootcrs">cabootcrs</a></code> function, and only for
simple CA if for some reason the lpSolve package is unavailable.
</p>
<p>It has not been used with MCA, and so will almost certainly not work properly in that case.
</p>
<p>Finds the rearrangement of columns of RB and CB to maximise match = tr( abs(RS'*RB + CS'*CB) )
</p>
<p>Goes through all possible orderings and so is painfully slow.
</p>


<h3>Value</h3>

<p>list containing: <br />
T = matrix to rearrange xB so it is equivalent to xS, i.e. xS &lt;- xB * T <br />
numre = number of axes checked for rearranging = min(r,maxrearrange)<br />
match = assign$objval from the Hungarian algorithm<br />
same = flag for whether there was no reordering of axes (but may have been reflection)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>,  <code><a href="#topic+rearrange">rearrange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not intended for direct call by users

</code></pre>

<hr>
<h2 id='reflectaxes'>Reflect coordinates for chosen axes</h2><span id='topic+reflectaxes'></span>

<h3>Description</h3>

<p><code>reflectaxes</code> reflects the principal and standard coordinates
of the axes chosen, and the appropriate covariances where needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reflectaxes(x, axes = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reflectaxes_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code></p>
</td></tr>
<tr><td><code id="reflectaxes_+3A_axes">axes</code></td>
<td>
<p>A list or vector containing the numbers of the axes to be reflected</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This may be useful when comparing results between different data sets,
or from different packages
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>, <code><a href="#topic+reordercategories">reordercategories</a></code>, <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- cabootcrs(DreamData)
resultsreflectfirstaxis &lt;- reflectaxes(results, 1)
summaryca(resultsreflectfirstaxis)
plotca(resultsreflectfirstaxis)

## Not run: 

# Often needed when comparing results between different packages,
# or same package on different machines,
# or to allow ellipses from this package to be added to plots from other packages

library(ca)
cad3 &lt;- mjca(DreamData223by3)
bd3 &lt;- cabootcrs(DreamData223by3, catype="mca")
summary(cad3)
bd3reflect1 &lt;- reflectaxes(bd3,1)
summaryca(bd3reflect1)


## End(Not run)

</code></pre>

<hr>
<h2 id='reordercategories'>Reorder categories for chosen variable in MCA case only</h2><span id='topic+reordercategories'></span>

<h3>Description</h3>

<p><code>reordercategories</code> reorders the principal and standard coordinates, CTR, REP,
variances and covariances of the categories for a single MCA variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reordercategories(x, varno, newcats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reordercategories_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code></p>
</td></tr>
<tr><td><code id="reordercategories_+3A_varno">varno</code></td>
<td>
<p>The number of the variable to be reordered</p>
</td></tr>
<tr><td><code id="reordercategories_+3A_newcats">newcats</code></td>
<td>
<p>A vector of length equal to the number of categories for this variable,
giving the new order for the categories
(e.g. c(4,1,2,3) means that the original 4th category is moved to first)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This may be useful when comparing results between different data sets or from different packages
</p>
<p>Note: does not reorder anything in the <code><a href="#topic+cabasicresults-class">cabasicresults</a></code>
part of the <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code> object
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>, <code><a href="#topic+reflectaxes">reflectaxes</a></code>, <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bd3 &lt;- cabootcrs(DreamData223by3, catype="mca", nboots=0, showresults=FALSE)
bd3reorderedvar2 &lt;- reordercategories(bd3, 2, c(3,2,4,1))
summaryca(bd3)
summaryca(bd3reorderedvar2)

## Not run: 

# Can be used when comparing results in different packages,
# or when adding ellipses from this package to output from others

library(FactoMineR)
library(ca)
data(tea)
# remove duplicated age variable
teamod &lt;- tea[,c(1:18,20:36)]

# ca package uses standardised coordinates and inertias by default
catea &lt;- mjca(teamod)
btea &lt;- cabootcrs(teamod, catype="mca", showresults=FALSE, nboots=0, varandcat=FALSE)

# FactoMineR package uses unstandardised coordinates and inertias by default
fmtea &lt;- MCA(teamod, method="Burt", graph=FALSE)
bteaunstd &lt;- cabootcrs(teamod, catype="mca", showresults=FALSE, nboots=0,
                       mcaadjustinertias = FALSE, mcaadjustcoords = FALSE, varandcat=FALSE)

summary(fmtea)
summaryca(bteaunstd)
summary(catea)
summaryca(btea)

# slight difference due to different orderings of categories for these two
fmtea$var$coord / bteaunstd@Colprinccoord[,1:5]
catea$colpcoord[,1:5] / btea@Colprinccoord[,1:5]
fmtea$var$coord / catea$colpcoord[,1:5]

# Variables 22 and 23, in columns 57-65, are the problem
# The coordinates agree (apart from reflection) but the categories are in a different order
fmtea$var$coord[57:65,1:3]
bteaunstd@Colprinccoord[57:65,1:3]

catea$colpcoord[57:65,1:3]
btea@Colprinccoord[57:65,1:3]

# Coordinates agree when categories reordered and axes reflected
bteaunstdreord &lt;- reordercategories(bteaunstd,22,c(2:5,1))
bteaunstdreord &lt;- reordercategories(bteaunstdreord,23,c(3,2,1,4))
bteaunstdreordreflect &lt;- reflectaxes(bteaunstdreord,c(1,4))
fmtea$var$coord / bteaunstdreordreflect@Colprinccoord[,1:5]

bteareord &lt;- reordercategories(btea,22,c(2:5,1))
bteareord &lt;- reordercategories(bteareord,23,c(3,2,1,4))
bteareordreflect &lt;- reflectaxes(bteareord,c(2,5))
catea$colpcoord[,1:5] / bteareordreflect@Colprinccoord[,1:5]


## End(Not run)

</code></pre>

<hr>
<h2 id='sca'>Performs standard Correspondence Analysis calculations</h2><span id='topic+sca'></span>

<h3>Description</h3>

<p><code>sca</code> returns all the basic results from a CA of a matrix with rows &gt;= cols,
in an object of class <code><a href="#topic+cabasicresults-class">cabasicresults</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sca(X, catype = "sca", mcatype = NULL, p = 2, needtrans = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sca_+3A_x">X</code></td>
<td>
<p>A data matrix with rows &gt;= cols</p>
</td></tr>
<tr><td><code id="sca_+3A_catype">catype</code></td>
<td>
<p>Can be &quot;sca&quot; for simple CA or &quot;mca&quot; for multiple CA</p>
</td></tr>
<tr><td><code id="sca_+3A_mcatype">mcatype</code></td>
<td>
<p>If catype=&quot;mca&quot; then this can be &quot;Burt&quot;, &quot;Indicator&quot;
or &quot;doubled&quot; depending on the analysis required.<br />
This affects the number of meaningful singular values, as does p below</p>
</td></tr>
<tr><td><code id="sca_+3A_p">p</code></td>
<td>
<p>Number of variables, only needed if catype=&quot;mca&quot;</p>
</td></tr>
<tr><td><code id="sca_+3A_needtrans">needtrans</code></td>
<td>
<p>TRUE if rows &lt; columns so need to transpose in the routine</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is only intended for internal use by the <code><a href="#topic+cabootcrs">cabootcrs</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+cabasicresults-class">cabasicresults</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>, <code><a href="#topic+cabasicresults-class">cabasicresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- sca(as.matrix(DreamData))

</code></pre>

<hr>
<h2 id='settingsinertias'>Internal function to be used by printca and summaryca</h2><span id='topic+settingsinertias'></span>

<h3>Description</h3>

<p><code>settingsinertias</code> prints the settings and the inertias
</p>


<h3>Usage</h3>

<pre><code class='language-R'>settingsinertias(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="settingsinertias_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>printed output only
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summaryca">summaryca</a></code>, <code><a href="#topic+printca">printca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Purely internal, not intended for use by users

</code></pre>

<hr>
<h2 id='SuicideData'>Suicide data</h2><span id='topic+SuicideData'></span>

<h3>Description</h3>

<p>Methods of suicide in Germany, 1974-1977
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuicideData
</code></pre>


<h3>Format</h3>

<p>A contingency table with 34 rows and 9 columns
</p>

<dl>
<dt>rows</dt><dd><p>Gender and age of individual: Females aged 10-15 (F10) to males aged 90+ (M90)</p>
</dd>
<dt>columns</dt><dd><p>Method: drugs/poison (Mat), gas at home (Gas.h), gas-others (Gas.o), hanging (Hang),
drowning (Drown), gunshot (Gun), stabbing (Stab), jumping (Jump), Other</p>
</dd>
</dl>



<h3>Source</h3>

<p>Nishisato, S. (1994).
<em>Elements of Dual Scaling: An Introduction to Practical Data Analysis</em>.
Lawrence Erlbaum Associates, New Jersey. (p12)
</p>

<hr>
<h2 id='summaryca'>Prints brief 2-d results, with standard deviations</h2><span id='topic+summaryca'></span>

<h3>Description</h3>

<p><code>summaryca</code> prints correspondence analysis results for the first two dimensions,
giving inertias, coordinates,
representations, contributions and standard deviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryca(x, datasetname = NULL, mcaprintindividuals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryca_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code></p>
</td></tr>
<tr><td><code id="summaryca_+3A_datasetname">datasetname</code></td>
<td>
<p>The name (in &quot;&quot;) of the data set, to be used in the output, defaults to that in cabootcrs object</p>
</td></tr>
<tr><td><code id="summaryca_+3A_mcaprintindividuals">mcaprintindividuals</code></td>
<td>
<p>If TRUE then print individual (row) point results in multiple
correspondence analysis when using indicator or doubled matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed results, no plots or objects produced
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cabootcrs-package">cabootcrs-package</a></code>, <code><a href="#topic+cabootcrs">cabootcrs</a></code>, <code><a href="#topic+printca">printca</a></code>, <code><a href="#topic+plotca">plotca</a></code>,
<code><a href="#topic+cabootcrsresults-class">cabootcrsresults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- cabootcrs(DreamData, showresults=FALSE)
summaryca(results, datasetname="Dreams")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
