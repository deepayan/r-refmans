<!DOCTYPE html><html><head><title>Help for package dendextend</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dendextend}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dendextend-package'><p>Functions for extending dendrogram objects</p></a></li>
<li><a href='#all_couple_rotations_at_k'><p>Rotate tree branches for k</p></a></li>
<li><a href='#all_unique'><p>Check if all the elements in a vector are unique</p></a></li>
<li><a href='#all.equal.dendrogram'><p>Global Comparison of two (or more) dendrograms</p></a></li>
<li><a href='#as_hclust_fixed'><p>Convert dendrogram Objects to Class hclust</p></a></li>
<li><a href='#as.dendlist'><p>Try to coerce something into a dendlist</p></a></li>
<li><a href='#as.phylo.dendrogram'><p>Convert a dendrogram into phylo</p></a></li>
<li><a href='#assign_dendextend_options'><p>Populates dendextend functions into dendextend_options</p></a></li>
<li><a href='#assign_values_to_branches_edgePar'><p>Assign values to edgePar of dendrogram's branches</p></a></li>
<li><a href='#assign_values_to_leaves_edgePar'><p>Assign values to edgePar of dendrogram's leaves</p></a></li>
<li><a href='#assign_values_to_leaves_nodePar'><p>Assign values to nodePar of dendrogram's leaves</p></a></li>
<li><a href='#assign_values_to_nodes_nodePar'><p>Assign values to nodePar of dendrogram's nodes</p></a></li>
<li><a href='#bakers_gamma_for_2_k_matrix'><p>Bakers Gamma for two k matrices</p></a></li>
<li><a href='#Bk'><p>Bk - Calculating Fowlkes-Mallows Index for two dendrogram</p></a></li>
<li><a href='#Bk_permutations'><p>Bk permutation - Calculating Fowlkes-Mallows Index for two dendrogram</p></a></li>
<li><a href='#Bk_plot'><p>Bk plot - ploting the Fowlkes-Mallows Index of two dendrogram for various k's</p></a></li>
<li><a href='#branches_attr_by_clusters'><p>Change col/lwd/lty of branches based on clusters</p></a></li>
<li><a href='#branches_attr_by_labels'><p>Change col/lwd/lty of branches matching labels condition</p></a></li>
<li><a href='#branches_attr_by_lists'><p>Change col/lwd/lty of branches from the root down to clusters defined by list of labels of respective members</p></a></li>
<li><a href='#circlize_dendrogram'><p>Plot a circlized dendrograms</p></a></li>
<li><a href='#click_rotate'><p>Interactively rotate a tree object</p></a></li>
<li><a href='#collapse_branch'><p>Collapse branches under a tolerance level</p></a></li>
<li><a href='#collapse_labels'><p>Collapse a sub dendrogram of adjacent labels within a dend</p></a></li>
<li><a href='#color_branches'><p>Color tree's branches according to sub-clusters</p></a></li>
<li><a href='#color_labels'><p>Color dend's labels according to sub-clusters</p></a></li>
<li><a href='#color_unique_labels'><p>Color unique labels in a dendrogram</p></a></li>
<li><a href='#colored_bars'><p>Add colored bars to a dendrogram</p></a></li>
<li><a href='#colored_dots'><p>Add colored dots beside a dendrogram</p></a></li>
<li><a href='#common_subtrees_clusters'><p>Find clusters of common subtrees</p></a></li>
<li><a href='#cor_bakers_gamma'><p>Baker's Gamma correlation coefficient</p></a></li>
<li><a href='#cor_common_nodes'><p>Proportion of commong nodes between two trees</p></a></li>
<li><a href='#cor_cophenetic'><p>Cophenetic correlation between two trees</p></a></li>
<li><a href='#cor_FM_index'><p>Correlation of FM_index for some k</p></a></li>
<li><a href='#cor.dendlist'><p>Correlation matrix between a list of trees.</p></a></li>
<li><a href='#count_terminal_nodes'><p>Counts the number of terminal nodes (merging 0 nodes!)</p></a></li>
<li><a href='#cut_lower_fun'><p>Cut a dendrogram - and run a function on the output</p></a></li>
<li><a href='#cutree'><p>Cut a Tree (Dendrogram/hclust/phylo) into Groups of Data</p></a></li>
<li><a href='#cutree_1h.dendrogram'><p>cutree for dendrogram (by 1 height only!)</p></a></li>
<li><a href='#cutree_1k.dendrogram'><p>cutree for dendrogram (by 1 k value only!)</p></a></li>
<li><a href='#dend_diff'><p>Plots two trees side by side, highlighting edges unique to each tree in red.</p></a></li>
<li><a href='#dend_expend'><p>Finds a &quot;good&quot; dendrogram for a dist</p></a></li>
<li><a href='#dendextend_options'><p>Access to dendextend_options</p></a></li>
<li><a href='#dendlist'><p>Creating a dendlist object from several dendrograms</p></a></li>
<li><a href='#DendSer.dendrogram'><p>Tries to run DendSer on a dendrogram</p></a></li>
<li><a href='#dist_long'><p>Turns a dist object to a &quot;long&quot; table</p></a></li>
<li><a href='#dist.dendlist'><p>Topological Distances Between Two dendrograms</p></a></li>
<li><a href='#distinct_edges'><p>Finds distinct edges in one tree compared to another</p></a></li>
<li><a href='#duplicate_leaf'><p>Duplicate a leaf X times</p></a></li>
<li><a href='#entanglement'><p>Measures entanglement between two trees</p></a></li>
<li><a href='#fac2num'><p>Turns a factor into a number</p></a></li>
<li><a href='#find_dendrogram'><p>Search for the sub-dendrogram structure composed of selected labels</p></a></li>
<li><a href='#find_k'><p>Find the (estimated) number of clusters for a dendrogram using average silhouette width</p></a></li>
<li><a href='#fix_members_attr.dendrogram'><p>Fix members attr in a dendrogram</p></a></li>
<li><a href='#flatten.dendrogram'><p>Flatten the branches of a dendrogram's root</p></a></li>
<li><a href='#flip_leaves'><p>Flip leaves</p></a></li>
<li><a href='#FM_index'><p>Calculating Fowlkes-Mallows Index</p></a></li>
<li><a href='#FM_index_permutation'><p>Calculating Fowlkes-Mallows Index under H0</p></a></li>
<li><a href='#FM_index_R'><p>Calculating Fowlkes-Mallows index in R</p></a></li>
<li><a href='#get_branches_heights'><p>Get height attributes from a dendrogram</p></a></li>
<li><a href='#get_childrens_heights'><p>Get height attributes from a dendrogram's children</p></a></li>
<li><a href='#get_leaves_attr'><p>Get/set attributes of dendrogram's leaves</p></a></li>
<li><a href='#get_leaves_branches_attr'><p>Get an attribute of the branches of a dendrogram's leaves</p></a></li>
<li><a href='#get_leaves_branches_col'><p>Get the colors of the branches of a dendrogram's leaves</p></a></li>
<li><a href='#get_leaves_edgePar'><p>Get edgePar of dendrogram's leaves</p></a></li>
<li><a href='#get_leaves_nodePar'><p>Get nodePar of dendrogram's leaves</p></a></li>
<li><a href='#get_nodes_attr'><p>Get attributes of dendrogram's nodes</p></a></li>
<li><a href='#get_nodes_xy'><p>Get the x-y coordinates of a dendrogram's nodes</p></a></li>
<li><a href='#get_root_branches_attr'><p>get attributes from the dendrogram's root(!) branches</p></a></li>
<li><a href='#get_subdendrograms'><p>Extract a list of <em>k</em> subdendrograms from a given dendrogram</p>
object</a></li>
<li><a href='#ggdend'><p>Creates dendrogram plot using ggplot.</p></a></li>
<li><a href='#hang.dendrogram'><p>Hang dendrogram leaves</p></a></li>
<li><a href='#has_component_in_attribute'><p>Does a dendrogram has an edgePar/nodePar component?</p></a></li>
<li><a href='#heights_per_k.dendrogram'><p>Which height will result in which k for a dendrogram</p></a></li>
<li><a href='#highlight_branches_col'><p>Highlight a dendrogram's branches heights via color and line-width</p></a></li>
<li><a href='#highlight_distinct_edges'><p>Highlight distint edges in a tree (compared to another one)</p></a></li>
<li><a href='#identify.dendrogram'><p>Identify Clusters in a Dendrogram (not hclust)</p></a></li>
<li><a href='#intersect_trees'><p>Intersect trees</p></a></li>
<li><a href='#is_null_list'><p>Checks if the value is and empty list()</p></a></li>
<li><a href='#is_some_class'><p>Is the object of some class</p></a></li>
<li><a href='#is.natural.number'><p>Check if numbers are natural</p></a></li>
<li><a href='#khan'><p>Microarray gene expression dataset from Khan et al., 2001. Subset of 306 genes.</p></a></li>
<li><a href='#labels_cex'><p>Retrieve/assign cex to the labels of a dendrogram</p></a></li>
<li><a href='#labels_colors'><p>Retrieve/assign colors to the labels of a dendrogram</p></a></li>
<li><a href='#labels&lt;-'><p>&quot;label&quot; assignment operator</p></a></li>
<li><a href='#ladderize'><p>Ladderize a Tree</p></a></li>
<li><a href='#leaf_Colors'><p>Return the leaf Colors of a dendrogram</p></a></li>
<li><a href='#lowest_common_branch'><p>Find lowest common branch were the two items are shared</p></a></li>
<li><a href='#match_order_by_labels'><p>Adjust the order of one dendrogram based on another (using labels)</p></a></li>
<li><a href='#match_order_dendrogram_by_old_order'><p>Adjust the order of one dendrogram based on another (using order)</p></a></li>
<li><a href='#min_depth'><p>Find minimum/maximum depth of a dendrogram</p></a></li>
<li><a href='#na_locf'><p>Last Observation Carried Forward</p></a></li>
<li><a href='#nleaves'><p>Counts the number of leaves in a tree</p></a></li>
<li><a href='#nnodes'><p>Counts the number of nodes (Vertices) in a tree</p></a></li>
<li><a href='#noded_with_condition'><p>Find which nodes satisfies a condition</p></a></li>
<li><a href='#order.dendrogram&lt;-'><p>order.dendrogram&lt;- assignment operator</p></a></li>
<li><a href='#order.hclust'><p>Ordering of the Leaves in a hclust Dendrogram</p></a></li>
<li><a href='#partition_leaves'><p>A list with labels for each subtree (edge)</p></a></li>
<li><a href='#plot_horiz.dendrogram'><p>Plotting a left-tip-adjusted horizontal dendrogram</p></a></li>
<li><a href='#prune'><p>Prunes a tree (using leaves' labels)</p></a></li>
<li><a href='#prune_common_subtrees.dendlist'><p>Prune trees to their common subtrees</p></a></li>
<li><a href='#prune_leaf'><p>Trims one leaf from a dendrogram</p></a></li>
<li><a href='#pvclust_edges'><p>Get Pvclust Edges Information</p></a></li>
<li><a href='#pvclust_show_signif'><p>The significant branches in a dendrogram, based on a pvclust object</p></a></li>
<li><a href='#pvclust_show_signif_gradient'><p>Significance gradient of branches in a dendrogram (via pvclust)</p></a></li>
<li><a href='#pvrect2'><p>Draw Rectangles Around a Dendrogram's Clusters with High/Low P-values</p></a></li>
<li><a href='#raise.dendrogram'><p>Raise the height of a dendrogram tree</p></a></li>
<li><a href='#rank_branches'><p>Rank branches' heights</p></a></li>
<li><a href='#rank_order.dendrogram'><p>Fix rank of leaves order values in a dendrogram</p></a></li>
<li><a href='#rank_values_with_clusters'><p>Rank a vector based on clusters</p></a></li>
<li><a href='#rect.dendrogram'><p>Draw Rectangles Around a Dendrogram's Clusters</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reindex_dend'><p>Reindexing a pruned dendrogram</p></a></li>
<li><a href='#remove_branches_edgePar'><p>Remove all edgePar values from a dendrogram's branches</p></a></li>
<li><a href='#remove_leaves_nodePar'><p>Remove all nodePar values from a dendrogram's leaves</p></a></li>
<li><a href='#remove_nodes_nodePar'><p>Remove all nodePar values from a dendrogram's nodes</p></a></li>
<li><a href='#rllply'><p>recursivly apply a function on a list</p></a></li>
<li><a href='#rotate'><p>Rotate a tree object</p></a></li>
<li><a href='#rotate_DendSer'><p>Rotates dend based on DendSer</p></a></li>
<li><a href='#sample.dendrogram'><p>Sample a tree</p></a></li>
<li><a href='#seriate_dendrogram'><p>Rotates a dendrogram based on a seriation of a distance matrix</p></a></li>
<li><a href='#set'><p>Set (/update) features to a dendrogram</p></a></li>
<li><a href='#set_labels'><p>Set/place new labels in a dendrogram</p></a></li>
<li><a href='#shuffle'><p>Random rotation of trees</p></a></li>
<li><a href='#sort_2_clusters_vectors'><p>Sorts two clusters vector by their names</p></a></li>
<li><a href='#sort_dist_mat'><p>Sorts a distance matrix by rows and columns names</p></a></li>
<li><a href='#sort_levels_values'><p>Sort the values level in a vector</p></a></li>
<li><a href='#tanglegram'><p>Tanglegram plot</p></a></li>
<li><a href='#theme_dendro'><p>Creates completely blank theme in ggplot</p></a></li>
<li><a href='#unbranch'><p>unbranch trees</p></a></li>
<li><a href='#unclass_dend'><p>unclass an entire dendrogram tree</p></a></li>
<li><a href='#untangle'><p>untangle dendrograms</p></a></li>
<li><a href='#untangle_DendSer'><p>Tries to run DendSer on a dendrogram</p></a></li>
<li><a href='#untangle_random_search'><p>Untangle - random search</p></a></li>
<li><a href='#untangle_step_rotate_1side'><p>Stepwise untangle one tree compared to another</p></a></li>
<li><a href='#untangle_step_rotate_2side'><p>Stepwise untangle two trees one at a time</p></a></li>
<li><a href='#which_leaf'><p>Which node is a leaf?</p></a></li>
<li><a href='#which_node'><p>Which node id is common to a group of labels</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extending 'dendrogram' Functionality in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.17.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Offers a set of functions for extending
    'dendrogram' objects in R, letting you visualize and compare trees of
    'hierarchical clusterings'. You can (1) Adjust a tree's graphical parameters
    - the color, size, type, etc of its branches, nodes and labels. (2)
    Visually and statistically compare different 'dendrograms' to one another.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, datasets, magrittr (&ge; 1.0.1), ggplot2, viridis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, seriation, colorspace, ape,
microbenchmark, gplots, heatmaply, dynamicTreeCut, pvclust,
corrplot, DendSer, MASS, cluster, fpc, circlize (&ge; 0.2.5),
covr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>ggdendro, dendroextras, Hmisc, data.table, rpart, WGCNA,
moduleColor, distory, phangorn, zoo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://talgalili.github.io/dendextend/">http://talgalili.github.io/dendextend/</a>,
<a href="https://github.com/talgalili/dendextend/">https://github.com/talgalili/dendextend/</a>,
<a href="https://cran.r-project.org/package=dendextend">https://cran.r-project.org/package=dendextend</a>,
<a href="https://www.r-statistics.com/tag/dendextend/">https://www.r-statistics.com/tag/dendextend/</a>,
<a href="https://academic.oup.com/bioinformatics/article/31/22/3718/240978/dendextend-an-R-package-for-visualizing-adjusting">https://academic.oup.com/bioinformatics/article/31/22/3718/240978/dendextend-an-R-package-for-visualizing-adjusting</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/talgalili/dendextend/issues">https://github.com/talgalili/dendextend/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-24 12:24:05 UTC; talgalili</td>
</tr>
<tr>
<td>Author:</td>
<td>Tal Galili [aut, cre, cph] (https://www.r-statistics.com),
  Yoav Benjamini [ths],
  Gavin Simpson [ctb],
  Gregory Jefferis [aut, ctb] (imported code from his dendroextras
    package),
  Marco Gallotta [ctb] (a.k.a: marcog),
  Johan Renaudie [ctb] (https://github.com/plannapus),
  The R Core Team [ctb] (Thanks for the Infastructure, and code in the
    examples),
  Kurt Hornik [ctb],
  Uwe Ligges [ctb],
  Andrej-Nikolai Spiess [ctb],
  Steve Horvath [ctb],
  Peter Langfelder [ctb],
  skullkey [ctb],
  Mark Van Der Loo [ctb] (https://github.com/markvanderloo d3dendrogram),
  Andrie de Vries [ctb] (ggdendro author),
  Zuguang Gu [ctb] (circlize author),
  Cath [ctb] (https://github.com/CathG),
  John Ma [ctb] (https://github.com/JohnMCMa),
  Krzysiek G [ctb] (https://github.com/storaged),
  Manuela Hummel [ctb] (https://github.com/hummelma),
  Chase Clark [ctb] (https://github.com/chasemc),
  Lucas Graybuck [ctb] (https://github.com/hypercompetent),
  jdetribol [ctb] (https://github.com/jdetribol),
  Ben Ho [ctb] (https://github.com/SplitInf),
  Samuel Perreault [ctb] (https://github.com/samperochkin),
  Christian Hennig [ctb] (http://www.homepages.ucl.ac.uk/~ucakche/),
  David Bradley [ctb] (https://github.com/DBradley27),
  Houyun Huang [ctb] (https://github.com/houyunhuang),
  Patrick Schupp [ctb] (https://github.com/pschupp)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tal Galili &lt;tal.galili@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-25 12:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='dendextend-package'>Functions for extending dendrogram objects</h2><span id='topic+dendextend-package'></span><span id='topic+dendextend'></span>

<h3>Description</h3>

<p>Offers a set of functions for extending 'dendrogram' objects in R, 
letting you visualize and compare trees of 'hierarchical clusterings'.
You can (1) Adjust a tree's graphical parameters - 
the color, size, type, etc of its branches, nodes and labels.
(2) Visually and statistically compare different 'dendrograms' to one another.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dendrogram">dendrogram</a>, <a href="stats.html#topic+hclust">hclust</a></code> in <code><a href="stats.html#topic+stats">stats</a></code> package.
</p>

<hr>
<h2 id='all_couple_rotations_at_k'>Rotate tree branches for k</h2><span id='topic+all_couple_rotations_at_k'></span>

<h3>Description</h3>

<p>Given a tree and a k number of clusters, the tree is rotated so that the
extra clusters added from k-1 to k clusters are flipped.
</p>
<p>This is useful for finding good trees for a <a href="#topic+tanglegram">tanglegram</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_couple_rotations_at_k(dend, k, dend_heights_per_k, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_couple_rotations_at_k_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="all_couple_rotations_at_k_+3A_k">k</code></td>
<td>
<p>integer scalar with the number of clusters the tree should be cut into.</p>
</td></tr>
<tr><td><code id="all_couple_rotations_at_k_+3A_dend_heights_per_k">dend_heights_per_k</code></td>
<td>
<p>a named vector that resulted from running
<a href="#topic+heights_per_k.dendrogram">heights_per_k.dendrogram</a>. When running the function many times,
supplying this object will help improve the running time if using the
<a href="#topic+cutree.dendrogram">cutree.dendrogram</a> method..</p>
</td></tr>
<tr><td><code id="all_couple_rotations_at_k_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with dendrogram objects with all the possible rotations
for k clusters (beyond the k-1 clusters!).
</p>


<h3>See Also</h3>

<p><a href="#topic+tanglegram">tanglegram</a>, <a href="#topic+match_order_by_labels">match_order_by_labels</a>,
<a href="#topic+entanglement">entanglement</a>, <a href="#topic+flip_leaves">flip_leaves</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
dend1 &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend2 &lt;- all_couple_rotations_at_k(dend1, k = 2)[[2]]
tanglegram(dend1, dend2)
entanglement(dend1, dend2, L = 2) # 0.5

dend2 &lt;- all_couple_rotations_at_k(dend1, k = 3)[[2]]
tanglegram(dend1, dend2)
entanglement(dend1, dend2, L = 2) # 0.4

dend2 &lt;- all_couple_rotations_at_k(dend1, k = 4)[[2]]
tanglegram(dend1, dend2)
entanglement(dend1, dend2, L = 2) # 0.05

## End(Not run)
</code></pre>

<hr>
<h2 id='all_unique'>Check if all the elements in a vector are unique</h2><span id='topic+all_unique'></span>

<h3>Description</h3>

<p>Checks if all the elements in a vector are unique
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_unique(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_unique_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="all_unique_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical (are all the elements in the vector unique)
</p>


<h3>Source</h3>

<p><a href="https://www.mail-archive.com/r-help@r-project.org/msg77592.html">https://www.mail-archive.com/r-help@r-project.org/msg77592.html</a>
OLD (no longer working): https://r.789695.n4.nabble.com/Is-there-a-function-to-test-if-all-the-elements-in-a-vector-are-unique-td931833.html
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+unique">unique</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
all_unique(c(1:5, 1, 1))
all_unique(c(1, 1, 2))
all_unique(c(1, 1, 2, 3, 3, 3, 3))
all_unique(c(1, 3, 2))
all_unique(c(1:10))
</code></pre>

<hr>
<h2 id='all.equal.dendrogram'>Global Comparison of two (or more) dendrograms</h2><span id='topic+all.equal.dendrogram'></span><span id='topic+all.equal.dendlist'></span>

<h3>Description</h3>

<p>This function makes a global comparison of two or more dendrograms trees.
</p>
<p>The function can get two <a href="#topic+dendlist">dendlist</a> objects and compare
them using <a href="base.html#topic+all.equal.list">all.equal.list</a>. If a dendlist is in only &quot;target&quot;
(and not &quot;current&quot;), it will go through the dendlist and
compare all of the dendrograms within it to one another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'equal.dendrogram'
all(
  target,
  current,
  use.edge.length = TRUE,
  use.tip.label.order = FALSE,
  use.tip.label = TRUE,
  use.topology = TRUE,
  tolerance = .Machine$double.eps^0.5,
  scale = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.dendrogram_+3A_target">target</code></td>
<td>
<p>an object of type <a href="stats.html#topic+dendrogram">dendrogram</a> or <a href="#topic+dendlist">dendlist</a></p>
</td></tr>
<tr><td><code id="all.equal.dendrogram_+3A_current">current</code></td>
<td>
<p>an object of type <a href="stats.html#topic+dendrogram">dendrogram</a></p>
</td></tr>
<tr><td><code id="all.equal.dendrogram_+3A_use.edge.length">use.edge.length</code></td>
<td>
<p>logical (TRUE). If to check branches' heights.</p>
</td></tr>
<tr><td><code id="all.equal.dendrogram_+3A_use.tip.label.order">use.tip.label.order</code></td>
<td>
<p>logical (FALSE). If to check labels are in the same and in identical order</p>
</td></tr>
<tr><td><code id="all.equal.dendrogram_+3A_use.tip.label">use.tip.label</code></td>
<td>
<p>logical (TRUE). If to check that labels are the same (regardless of order)</p>
</td></tr>
<tr><td><code id="all.equal.dendrogram_+3A_use.topology">use.topology</code></td>
<td>
<p>logical (TRUE). If to check teh existence of distinct edges</p>
</td></tr>
<tr><td><code id="all.equal.dendrogram_+3A_tolerance">tolerance</code></td>
<td>
<p>the numeric tolerance used to compare the branch lengths.</p>
</td></tr>
<tr><td><code id="all.equal.dendrogram_+3A_scale">scale</code></td>
<td>
<p>a positive number (NULL as default), comparison of branch height is made after scaling (i.e., dividing) them by this number.</p>
</td></tr>
<tr><td><code id="all.equal.dendrogram_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either TRUE (NULL for attr.all.equal) or a vector of mode &quot;character&quot; describing the differences
between target and current.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+all.equal">all.equal</a>, <a href="ape.html#topic+all.equal.phylo">all.equal.phylo</a>, <a href="base.html#topic+identical">identical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- sample(1:150, 10)
dend1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("single") %&gt;%
  as.dendrogram()
dend3 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("ave") %&gt;%
  as.dendrogram()
dend4 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("centroid") %&gt;%
  as.dendrogram()
#    cutree(dend1)

all.equal(dend1, dend1)
all.equal(dend1, dend2)
all.equal(dend1, dend2, use.edge.length = FALSE)
all.equal(dend1, dend2, use.edge.length = FALSE, use.topology = FALSE)

all.equal(dend2, dend4, use.edge.length = TRUE)
all.equal(dend2, dend4, use.edge.length = FALSE)

all.equal(dendlist(dend1, dend2, dend3, dend4))
all.equal(dendlist(dend1, dend2, dend3, dend4), use.edge.length = FALSE)
all.equal(dendlist(dend1, dend1, dend1))

## End(Not run)
</code></pre>

<hr>
<h2 id='as_hclust_fixed'>Convert dendrogram Objects to Class hclust</h2><span id='topic+as_hclust_fixed'></span>

<h3>Description</h3>

<p>Convert dendrogram Objects to Class hclust while preserving
the call/method/dist.method values of the original hclust object (hc)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_hclust_fixed(x, hc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_hclust_fixed_+3A_x">x</code></td>
<td>
<p>any object which has an as.hclust method.
(mostly used for dendrogram)</p>
</td></tr>
<tr><td><code id="as_hclust_fixed_+3A_hc">hc</code></td>
<td>
<p>an old hclust object from which to re-use
the call/method/dist.method values</p>
</td></tr>
<tr><td><code id="as_hclust_fixed_+3A_...">...</code></td>
<td>
<p>passed to as.hclust</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An hclust object (from a dendrogram) with the original hclust
call/method/dist.method values
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+as.hclust">as.hclust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)

as.hclust(dend)
as_hclust_fixed(dend, hc)
</code></pre>

<hr>
<h2 id='as.dendlist'>Try to coerce something into a dendlist</h2><span id='topic+as.dendlist'></span>

<h3>Description</h3>

<p>It removes stuff that are not dendgrogram/dendlist
and turns what is left into a dendlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.dendlist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.dendlist_+3A_x">x</code></td>
<td>
<p>a list with several dendrogram/hclust/phylo or dendlist objects
and other junk that should be omitted.</p>
</td></tr>
<tr><td><code id="as.dendlist_+3A_...">...</code></td>
<td>
<p>NOT USED</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class dendlist where each item
is a dendrogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dend &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend2 &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust(method = "single") %&gt;%
  as.dendrogram()

x &lt;- list(dend, 1, dend2)
as.dendlist(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='as.phylo.dendrogram'>Convert a dendrogram into phylo</h2><span id='topic+as.phylo.dendrogram'></span>

<h3>Description</h3>

<p>Based on <a href="stats.html#topic+as.hclust.dendrogram">as.hclust.dendrogram</a> with <a href="ape.html#topic+as.phylo.hclust">as.phylo.hclust</a>
</p>
<p>In the future I hope a more direct link will be made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.phylo.dendrogram(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.phylo.dendrogram_+3A_x">x</code></td>
<td>
<p>a dendrogram</p>
</td></tr>
<tr><td><code id="as.phylo.dendrogram_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phylo class object
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+as.dendrogram">as.dendrogram</a>, <a href="stats.html#topic+as.hclust">as.hclust</a>, <a href="ape.html#topic+as.phylo">as.phylo</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(dendextend)
library(ape)
dend &lt;- iris[1:30, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend2 &lt;- as.phylo(dend)
plot(dend2, type = "fan")

library(dendextend)
library(ggplot2)
# no longer needed: library(ggdendro)
dend &lt;- iris[1:30, -5] %&gt;%
   dist() %&gt;%
   hclust() %&gt;%
   as.dendrogram()
# there is a bug in the location of the labels 
# If you want to solve it - please send a Pull Request to:
# https://github.com/talgalili/dendextend/
ggplot(dend) +
   scale_y_reverse(expand = c(0.2, 0)) + coord_polar(start = 1, theta="x") 
   

## End(Not run)


# see: https://github.com/klutometis/roxygen/issues/796
#
</code></pre>

<hr>
<h2 id='assign_dendextend_options'>Populates dendextend functions into dendextend_options</h2><span id='topic+assign_dendextend_options'></span>

<h3>Description</h3>

<p>Populates dendextend functions into dendextend_options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_dendextend_options()
</code></pre>

<hr>
<h2 id='assign_values_to_branches_edgePar'>Assign values to edgePar of dendrogram's branches</h2><span id='topic+assign_values_to_branches_edgePar'></span>

<h3>Description</h3>

<p>Go through the dendrogram branches and updates the values inside its edgePar
</p>
<p>If the value has Inf then the value in edgePar will not be changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_values_to_branches_edgePar(
  dend,
  value,
  edgePar,
  skip_leaves = FALSE,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_values_to_branches_edgePar_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="assign_values_to_branches_edgePar_+3A_value">value</code></td>
<td>
<p>a new value scalar for the edgePar attribute.</p>
</td></tr>
<tr><td><code id="assign_values_to_branches_edgePar_+3A_edgepar">edgePar</code></td>
<td>
<p>a character indicating the value inside edgePar to adjust.
Can be either &quot;col&quot;, &quot;lty&quot;, or &quot;lwd&quot;.</p>
</td></tr>
<tr><td><code id="assign_values_to_branches_edgePar_+3A_skip_leaves">skip_leaves</code></td>
<td>
<p>logical (FALSE) - should the leaves be skipped/ignored?</p>
</td></tr>
<tr><td><code id="assign_values_to_branches_edgePar_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="assign_values_to_branches_edgePar_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after adjusting the edgePar attribute in all of its branches,
</p>


<h3>See Also</h3>

<p><a href="#topic+get_root_branches_attr">get_root_branches_attr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This failed before - now it works fine. (thanks to Martin Maechler)
dend &lt;- 1:2 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend %&gt;%
  set("branches_lty", 1:2) %&gt;%
  set("branches_col", c("topbranch_never_plots", "black", "orange")) %&gt;%
  plot()
## Not run: 

dend &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
plot(dend)
dend &lt;- assign_values_to_branches_edgePar(dend = dend, value = 2, edgePar = "lwd")
plot(dend)
dend &lt;- assign_values_to_branches_edgePar(dend = dend, value = 2, edgePar = "col")
plot(dend)
dend &lt;- assign_values_to_branches_edgePar(dend = dend, value = "orange", edgePar = "col")
plot(dend)
dend2 &lt;- assign_values_to_branches_edgePar(dend = dend, value = 2, edgePar = "lty")
plot(dend2)

dend2 %&gt;%
  unclass() %&gt;%
  str()

## End(Not run)

</code></pre>

<hr>
<h2 id='assign_values_to_leaves_edgePar'>Assign values to edgePar of dendrogram's leaves</h2><span id='topic+assign_values_to_leaves_edgePar'></span>

<h3>Description</h3>

<p>Go through the dendrogram leaves and updates the values inside its edgePar
</p>
<p>If the value has Inf then the value in edgePar will not be changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_values_to_leaves_edgePar(
  dend,
  value,
  edgePar,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_values_to_leaves_edgePar_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="assign_values_to_leaves_edgePar_+3A_value">value</code></td>
<td>
<p>a new value vector for the edgePar attribute. It should be
the same length as the number of leaves in the tree. If not, it will recycle
the value and issue a warning.</p>
</td></tr>
<tr><td><code id="assign_values_to_leaves_edgePar_+3A_edgepar">edgePar</code></td>
<td>
<p>the value inside edgePar to adjust.</p>
</td></tr>
<tr><td><code id="assign_values_to_leaves_edgePar_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="assign_values_to_leaves_edgePar_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after adjusting the edgePar attribute in all of its leaves,
</p>


<h3>See Also</h3>

<p><a href="#topic+get_leaves_attr">get_leaves_attr</a>, linkassign_values_to_leaves_nodePar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dend &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust("ave") %&gt;%
  as.dendrogram()

plot(dend)
dend &lt;- assign_values_to_leaves_edgePar(dend = dend, value = c(3, 2), edgePar = "col")
plot(dend)
dend &lt;- assign_values_to_leaves_edgePar(dend = dend, value = c(3, 2), edgePar = "lwd")
plot(dend)
dend &lt;- assign_values_to_leaves_edgePar(dend = dend, value = c(3, 2), edgePar = "lty")
plot(dend)

get_leaves_attr(dend, "edgePar", simplify = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='assign_values_to_leaves_nodePar'>Assign values to nodePar of dendrogram's leaves</h2><span id='topic+assign_values_to_leaves_nodePar'></span>

<h3>Description</h3>

<p>Go through the dendrogram leaves and updates the values inside its nodePar
</p>
<p>If the value has Inf then the value in edgePar will not be changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_values_to_leaves_nodePar(
  dend,
  value,
  nodePar,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_values_to_leaves_nodePar_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="assign_values_to_leaves_nodePar_+3A_value">value</code></td>
<td>
<p>a new value vector for the nodePar attribute. It should be
the same length as the number of leaves in the tree. If not, it will recycle
the value and issue a warning.</p>
</td></tr>
<tr><td><code id="assign_values_to_leaves_nodePar_+3A_nodepar">nodePar</code></td>
<td>
<p>the value inside nodePar to adjust.</p>
</td></tr>
<tr><td><code id="assign_values_to_leaves_nodePar_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="assign_values_to_leaves_nodePar_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after adjusting the nodePar attribute in all of its leaves,
</p>


<h3>See Also</h3>

<p><a href="#topic+get_leaves_attr">get_leaves_attr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dend &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust("ave") %&gt;%
  as.dendrogram()

# reproduces "labels_colors&lt;-"
# although it does force us to run through the tree twice,
# hence "labels_colors&lt;-" is better...
plot(dend)
dend &lt;- assign_values_to_leaves_nodePar(dend = dend, value = c(3, 2), nodePar = "lab.col")
plot(dend)

dend &lt;- assign_values_to_leaves_nodePar(dend, 1, "pch")
plot(dend)
# fix the annoying pch=1:
dend &lt;- assign_values_to_leaves_nodePar(dend, NA, "pch")
plot(dend)
# adjust the cex:
dend &lt;- assign_values_to_leaves_nodePar(dend, 19, "pch")
dend &lt;- assign_values_to_leaves_nodePar(dend, 2, "lab.cex")
plot(dend)

str(unclass(dend))

get_leaves_attr(dend, "nodePar", simplify = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='assign_values_to_nodes_nodePar'>Assign values to nodePar of dendrogram's nodes</h2><span id='topic+assign_values_to_nodes_nodePar'></span>

<h3>Description</h3>

<p>Go through the dendrogram nodes and updates the values inside its nodePar
</p>
<p>If the value has Inf then the value in edgePar will not be changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_values_to_nodes_nodePar(
  dend,
  value,
  nodePar = c("pch", "cex", "col", "xpd", "bg"),
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_values_to_nodes_nodePar_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="assign_values_to_nodes_nodePar_+3A_value">value</code></td>
<td>
<p>a new value vector for the nodePar attribute. It should be
the same length as the number of nodes in the tree. If not, it will recycle
the value and issue a warning.</p>
</td></tr>
<tr><td><code id="assign_values_to_nodes_nodePar_+3A_nodepar">nodePar</code></td>
<td>
<p>the value inside nodePar to adjust.
This may contain components named pch, cex, col, xpd, and/or bg.</p>
</td></tr>
<tr><td><code id="assign_values_to_nodes_nodePar_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="assign_values_to_nodes_nodePar_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after adjusting the nodePar attribute in all of its nodes,
</p>


<h3>See Also</h3>

<p><a href="#topic+get_leaves_attr">get_leaves_attr</a>, <a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dend &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust("ave") %&gt;%
  as.dendrogram()

# reproduces "labels_colors&lt;-"
# although it does force us to run through the tree twice,
# hence "labels_colors&lt;-" is better...
plot(dend)
dend2 &lt;- dend %&gt;%
  assign_values_to_nodes_nodePar(value = 19, nodePar = "pch") %&gt;%
  assign_values_to_nodes_nodePar(value = c(1, 2), nodePar = "cex") %&gt;%
  assign_values_to_nodes_nodePar(value = c(2, 1), nodePar = "col")
plot(dend2)


### Making sure this works for NA with character.
dend %&gt;%
  assign_values_to_nodes_nodePar(value = 19, nodePar = "pch") %&gt;%
  assign_values_to_nodes_nodePar(value = c("red", NA), nodePar = "col") -&gt; dend2
plot(dend2)

## End(Not run)

</code></pre>

<hr>
<h2 id='bakers_gamma_for_2_k_matrix'>Bakers Gamma for two k matrices</h2><span id='topic+bakers_gamma_for_2_k_matrix'></span>

<h3>Description</h3>

<p>Bakers Gamma for two k matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bakers_gamma_for_2_k_matrix(
  k_matrix_dend1,
  k_matrix_dend2,
  to_plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bakers_gamma_for_2_k_matrix_+3A_k_matrix_dend1">k_matrix_dend1</code></td>
<td>
<p>a matrix of k cluster groupings from a dendrogram</p>
</td></tr>
<tr><td><code id="bakers_gamma_for_2_k_matrix_+3A_k_matrix_dend2">k_matrix_dend2</code></td>
<td>
<p>a (second) matrix of k cluster groupings from a dendrogram</p>
</td></tr>
<tr><td><code id="bakers_gamma_for_2_k_matrix_+3A_to_plot">to_plot</code></td>
<td>
<p>logical (FALSE). Should a scaterplot be plotted, showing the
correlation between the lowest shared branch between two items in the two
compared trees.</p>
</td></tr>
<tr><td><code id="bakers_gamma_for_2_k_matrix_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Baker's Gamma coefficient.
</p>


<h3>See Also</h3>

<p><a href="#topic+cor_bakers_gamma">cor_bakers_gamma</a>
</p>

<hr>
<h2 id='Bk'>Bk - Calculating Fowlkes-Mallows Index for two dendrogram</h2><span id='topic+Bk'></span>

<h3>Description</h3>

<p>Bk is the calculation of Fowlkes-Mallows index for a series of k cuts
for two dendrograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bk(tree1, tree2, k, warn = dendextend_options("warn"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bk_+3A_tree1">tree1</code></td>
<td>
<p>a dendrogram/hclust/phylo object.</p>
</td></tr>
<tr><td><code id="Bk_+3A_tree2">tree2</code></td>
<td>
<p>a dendrogram/hclust/phylo object.</p>
</td></tr>
<tr><td><code id="Bk_+3A_k">k</code></td>
<td>
<p>an integer scalar or vector with the desired number
of cluster groups.
If missing - the Bk will be calculated for a default k range of
2:(nleaves-1).
No point in checking k=1/k=n, since both will give Bk=1.</p>
</td></tr>
<tr><td><code id="Bk_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="Bk_+3A_...">...</code></td>
<td>
<p>Ignored (passed to FM_index_R).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Wikipedia:
</p>
<p>Fowlkes-Mallows index (see references) is an external evaluation method
that is used to determine the similarity between two clusterings
(clusters obtained after a clustering algorithm). This measure of similarity
could be either between two hierarchical clusterings or a clustering and
a benchmark classification. A higher the value for the Fowlkes-Mallows index
indicates a greater similarity between the clusters and the benchmark
classifications.
</p>


<h3>Value</h3>

<p>A list (of k's length) of Fowlkes-Mallows index between two dendrogram for
a scalar/vector of k values.
The names of the lists' items is the k for which it was calculated.
</p>


<h3>References</h3>

<p>Fowlkes, E. B.; Mallows, C. L. (1 September 1983).
&quot;A Method for Comparing Two Hierarchical Clusterings&quot;.
Journal of the American Statistical Association 78 (383): 553.
</p>
<p><a href="https://en.wikipedia.org/wiki/Fowlkes-Mallows_index">https://en.wikipedia.org/wiki/Fowlkes-Mallows_index</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+FM_index">FM_index</a>, <a href="#topic+cor_bakers_gamma">cor_bakers_gamma</a>, <a href="#topic+Bk_plot">Bk_plot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- TRUE # sample(1:150, 10 )
hc1 &lt;- hclust(dist(iris[ss, -5]), "com")
hc2 &lt;- hclust(dist(iris[ss, -5]), "single")
tree1 &lt;- as.dendrogram(hc1)
tree2 &lt;- as.dendrogram(hc2)
#    cutree(tree1)

Bk(hc1, hc2, k = 3)
Bk(hc1, hc2, k = 2:10)
Bk(hc1, hc2)

Bk(tree1, tree2, k = 3)
Bk(tree1, tree2, k = 2:5)

system.time(Bk(hc1, hc2, k = 2:5)) # 0.01
system.time(Bk(hc1, hc2)) # 1.28
system.time(Bk(tree1, tree2, k = 2:5)) # 0.24 # after fixes.
system.time(Bk(tree1, tree2, k = 2:10)) # 0.31 # after fixes.
system.time(Bk(tree1, tree2)) # 7.85
Bk(tree1, tree2, k = 99:101)

y &lt;- Bk(hc1, hc2, k = 2:10)
plot(unlist(y) ~ c(2:10), type = "b", ylim = c(0, 1))

# can take a few seconds
y &lt;- Bk(hc1, hc2)
plot(unlist(y) ~ as.numeric(names(y)),
  main = "Bk plot", pch = 20,
  xlab = "k", ylab = "FM Index",
  type = "b", ylim = c(0, 1)
)
# we are still missing some hypothesis testing here.
# for this we'll have the Bk_plot function.

## End(Not run)
</code></pre>

<hr>
<h2 id='Bk_permutations'>Bk permutation - Calculating Fowlkes-Mallows Index for two dendrogram</h2><span id='topic+Bk_permutations'></span>

<h3>Description</h3>

<p>Bk is the calculation of Fowlkes-Mallows index for a series of k cuts
for two dendrograms.
</p>
<p>Bk permutation calculates the Bk under the null hypothesis of no similarirty
between the two trees by randomally shuffling the labels of the two trees
and calculating their Bk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bk_permutations(
  tree1,
  tree2,
  k,
  R = 1000,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bk_permutations_+3A_tree1">tree1</code></td>
<td>
<p>a dendrogram/hclust/phylo object.</p>
</td></tr>
<tr><td><code id="Bk_permutations_+3A_tree2">tree2</code></td>
<td>
<p>a dendrogram/hclust/phylo object.</p>
</td></tr>
<tr><td><code id="Bk_permutations_+3A_k">k</code></td>
<td>
<p>an integer scalar or vector with the desired number
of cluster groups.
If missing - the Bk will be calculated for a default k range of
2:(nleaves-1).
No point in checking k=1/k=n, since both will give Bk=1.</p>
</td></tr>
<tr><td><code id="Bk_permutations_+3A_r">R</code></td>
<td>
<p>integer (Default is 1000). The number of Bk permutation to perform for each k.</p>
</td></tr>
<tr><td><code id="Bk_permutations_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
If set to TRUE, extra checks are made to varify that the two clusters have
the same size and the same labels.</p>
</td></tr>
<tr><td><code id="Bk_permutations_+3A_...">...</code></td>
<td>
<p>Ignored (passed to FM_index_R).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Wikipedia:
</p>
<p>Fowlkes-Mallows index (see references) is an external evaluation method
that is used to determine the similarity between two clusterings
(clusters obtained after a clustering algorithm). This measure of similarity
could be either between two hierarchical clusterings or a clustering and
a benchmark classification. A higher the value for the Fowlkes-Mallows index
indicates a greater similarity between the clusters and the benchmark
classifications.
</p>


<h3>Value</h3>

<p>A list (of the length of k's), where each element of the list has
R (number of permutations) calculations of Fowlkes-Mallows index
between two dendrogram after having their labels shuffled.
</p>
<p>The names of the lists' items is the k for which it was calculated.
</p>


<h3>References</h3>

<p>Fowlkes, E. B.; Mallows, C. L. (1 September 1983).
&quot;A Method for Comparing Two Hierarchical Clusterings&quot;.
Journal of the American Statistical Association 78 (383): 553.
</p>
<p><a href="https://en.wikipedia.org/wiki/Fowlkes-Mallows_index">https://en.wikipedia.org/wiki/Fowlkes-Mallows_index</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FM_index">FM_index</a></code>, <a href="#topic+Bk">Bk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- TRUE # sample(1:150, 10 )
hc1 &lt;- hclust(dist(iris[ss, -5]), "com")
hc2 &lt;- hclust(dist(iris[ss, -5]), "single")
# tree1 &lt;- as.treerogram(hc1)
# tree2 &lt;- as.treerogram(hc2)
#    cutree(tree1)

some_Bk &lt;- Bk(hc1, hc2, k = 20)
some_Bk_permu &lt;- Bk_permutations(hc1, hc2, k = 20)

# we can see that the Bk is much higher than the permutation Bks:
plot(
  x = rep(1, 1000), y = some_Bk_permu[[1]],
  main = "Bk distribution under H0",
  ylim = c(0, 1)
)
points(1, y = some_Bk, pch = 19, col = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='Bk_plot'>Bk plot - ploting the Fowlkes-Mallows Index of two dendrogram for various k's</h2><span id='topic+Bk_plot'></span>

<h3>Description</h3>

<p>Bk is the calculation of Fowlkes-Mallows index for a series of k cuts
for two dendrograms.
A Bk plot is simply a scatter plot of Bk versus k.
This plot helps in identifiying the similarity between two dendrograms in
different levels of k (number of clusters).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bk_plot(
  tree1,
  tree2,
  k,
  add_E = TRUE,
  rejection_line_asymptotic = TRUE,
  rejection_line_permutation = FALSE,
  R = 1000,
  k_permutation,
  conf.level = 0.95,
  p.adjust.methods = c("none", "bonferroni"),
  col_line_Bk = 1,
  col_line_asymptotic = 2,
  col_line_permutation = 4,
  warn = dendextend_options("warn"),
  main = "Bk plot",
  xlab = "k (number of clusters)",
  ylab = "Bk (Fowlkes-Mallows Index)",
  xlim,
  ylim = c(0, 1),
  try_cutree_hclust = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bk_plot_+3A_tree1">tree1</code></td>
<td>
<p>a dendrogram/hclust/phylo object.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_tree2">tree2</code></td>
<td>
<p>a dendrogram/hclust/phylo object.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_k">k</code></td>
<td>
<p>an integer scalar or vector with the desired number
of cluster groups.
If missing - the Bk will be calculated for a default k range of
2:(nleaves-1).
No point in checking k=1/k=n, since both will give Bk=1.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_add_e">add_E</code></td>
<td>
<p>logical (TRUE). Should we add a line of the Expected Bk value
for each k, under the null hypothesis of no relation between the clusterings?</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_rejection_line_asymptotic">rejection_line_asymptotic</code></td>
<td>
<p>logical (TRUE). Should we add a line of
the one sided rejection region based on the asymptotic distribution
of Bk values, for each k, under the null hypothesis of no relation
between the clusterings?</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_rejection_line_permutation">rejection_line_permutation</code></td>
<td>
<p>logical (FALSE). Should we add a line of
the one sided rejection region based on the asymptotic distribution
of Bk values, for each k, under the null hypothesis of no relation
between the clusterings?</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_r">R</code></td>
<td>
<p>integer (Default is 1000). The number of Bk permutation to perform
for each k. Applicable only if rejection_line_permutation is TRUE.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_k_permutation">k_permutation</code></td>
<td>
<p>the k's to be used for permutation (sometimes we might
be only interested in some k's and it is not important to run the simulation
for all possible ks). If missing - k itself will be used.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_conf.level">conf.level</code></td>
<td>
<p>the level of one sided confidence interval used for creation
of the rejection lines.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_p.adjust.methods">p.adjust.methods</code></td>
<td>
<p>a character scalar of either &quot;none&quot; (default), or
&quot;bonferroni&quot;. This controls the multiple correction method to use for the
critical rejection values. Currently only the Bonferroni method
is implemented (based on the number of different k values).</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_col_line_bk">col_line_Bk</code></td>
<td>
<p>the color of the Bk line.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_col_line_asymptotic">col_line_asymptotic</code></td>
<td>
<p>the color of the rejection asymptotic Bk line.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_col_line_permutation">col_line_permutation</code></td>
<td>
<p>the color of the rejection asymptotic Bk line.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
If set to TRUE, extra checks are made to varify that the two clusters have
the same size and the same labels.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_main">main</code></td>
<td>
<p>passed to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_xlab">xlab</code></td>
<td>
<p>passed to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_ylab">ylab</code></td>
<td>
<p>passed to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_xlim">xlim</code></td>
<td>
<p>passed to <a href="base.html#topic+plot">plot</a>. If missign, xlim is from 2 to nleaves-1</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_ylim">ylim</code></td>
<td>
<p>passed to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_try_cutree_hclust">try_cutree_hclust</code></td>
<td>
<p>logical (TRUE). Since cutree for hclust is MUCH
faster than for dendrogram - Bk_plot will first try to change the dendrogram
into an hclust object. If it will fail (for example, with unbranched trees),
it will continue using the cutree.dendrogram functions.
If try_cutree_hclust=FALSE, it will force to use cutree.dendrogram and
not cutree.hclust.</p>
</td></tr>
<tr><td><code id="Bk_plot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Wikipedia:
</p>
<p>Fowlkes-Mallows index (see references) is an external evaluation method
that is used to determine the similarity between two clusterings
(clusters obtained after a clustering algorithm). This measure of similarity
could be either between two hierarchical clusterings or a clustering and
a benchmark classification. A higher the value for the Fowlkes-Mallows index
indicates a greater similarity between the clusters and the benchmark
classifications.
</p>
<p>The default Bk plot comes with a line with dots (type &quot;b&quot;) of the Bk values.
Also with a fragmented (lty=2) line (of the same color) of the expected Bk
line under H0,
And a solid red line of the upper critical Bk values for rejection
</p>


<h3>Value</h3>

<p>After plotting the Bk plot.
Returns (invisible) the output of the elements used for constructing the plot:
The Bk values, Bk permutations (if used), Bk theoratical values, etc.
</p>


<h3>References</h3>

<p>Fowlkes, E. B.; Mallows, C. L. (1 September 1983).
&quot;A Method for Comparing Two Hierarchical Clusterings&quot;.
Journal of the American Statistical Association 78 (383): 553.
</p>
<p><a href="https://en.wikipedia.org/wiki/Fowlkes-Mallows_index">https://en.wikipedia.org/wiki/Fowlkes-Mallows_index</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FM_index">FM_index</a></code>, <a href="#topic+Bk">Bk</a>, <a href="#topic+Bk_permutations">Bk_permutations</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- TRUE # sample(1:150, 10 )
hc1 &lt;- hclust(dist(iris[ss, -5]), "com")
hc2 &lt;- hclust(dist(iris[ss, -5]), "single")
# tree1 &lt;- as.treerogram(hc1)
# tree2 &lt;- as.treerogram(hc2)
#    cutree(tree1)

Bk_plot(hc1, hc2, k = 2:20, xlim = c(2, 149))
Bk_plot(hc1, hc2)

Bk_plot(hc1, hc2, k = 3)
Bk_plot(hc1, hc2, k = 3:10)
Bk_plot(hc1, hc2)
Bk_plot(hc1, hc2, p.adjust.methods = "bonferroni") # higher rejection lines

# this one can take a bit of time:
Bk_plot(hc1, hc2,
  rejection_line_permutation = TRUE,
  k_permutation = c(2, 4, 6, 8, 10, 20, 30, 40, 50), R = 100
)
# we can see that the permutation line is VERY close to the asymptotic line.
# This is great since it means one can often use the asymptotic results
# Without having to do many simulations.

# works just as well for dendrograms:
dend1 &lt;- as.dendrogram(hc1)
dend2 &lt;- as.dendrogram(hc2)
Bk_plot(dend1, dend2, k = 2:3, try_cutree_hclust = FALSE) # slower than hclust, but works...
Bk_plot(hc1, dend2, k = 2:3, try_cutree_hclust = FALSE) # slower than hclust, but works...
Bk_plot(dend1, dend1, k = 2:3, try_cutree_hclust = TRUE) # slower than hclust, but works...
Bk_plot(hc1, hc1, k = 2:3) # slower than hclust, but works...
# for some reason it can't turn dend2 back to hclust :(
a &lt;- Bk_plot(hc1, hc2, k = 2:3, try_cutree_hclust = TRUE) # slower than hclust, but works...

hc1_mixed &lt;- as.hclust(sample(as.dendrogram(hc1)))
Bk_plot(
  tree1 = hc1, tree2 = hc1_mixed,
  add_E = FALSE,
  rejection_line_permutation = TRUE, k_permutation = c(2, 4, 6, 8, 10, 20, 30, 40, 50), R = 100
)

## End(Not run)
</code></pre>

<hr>
<h2 id='branches_attr_by_clusters'>Change col/lwd/lty of branches based on clusters</h2><span id='topic+branches_attr_by_clusters'></span>

<h3>Description</h3>

<p>The user supplies a dend, a vector of clusters, and what to modify (and how).
</p>
<p>And the function returns a dendrogram with branches col/lwd/lty accordingly.
(the function assumes unique labels)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branches_attr_by_clusters(
  dend,
  clusters,
  values,
  attr = c("col", "lwd", "lty"),
  branches_changed_have_which_labels = c("any", "all"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branches_attr_by_clusters_+3A_dend">dend</code></td>
<td>
<p>a dendrogram dend</p>
</td></tr>
<tr><td><code id="branches_attr_by_clusters_+3A_clusters">clusters</code></td>
<td>
<p>an integer vector of clusters.
This HAS to be of the same length as the number of leaves.
Items that belong to no cluster should get the value 0.
The vector should be of the same order as that of the labels in the dendrogram.
If you create the clusters from something like <a href="#topic+cutree">cutree</a> you would first
need to use <a href="stats.html#topic+order.dendrogram">order.dendrogram</a> on it, before using it in the function.</p>
</td></tr>
<tr><td><code id="branches_attr_by_clusters_+3A_values">values</code></td>
<td>
<p>the attributes to use for non 0 values.
This should be of the same length as the number of unique non-0 clusters.
If it is shorter, it is recycled.
</p>
<p>OR, this can also be of the same length as the number of leaves in the tree
In which case, the values will be aggreagted (i.e.: <a href="base.html#topic+tapply">tapply</a>), to match
the number of clusters. The first value of each cluster will be used as the main
value.
</p>
<p>TODO: So far, the function doesn't deal well with NA values. (this might be changed in the future)</p>
</td></tr>
<tr><td><code id="branches_attr_by_clusters_+3A_attr">attr</code></td>
<td>
<p>a character with one of the following values: col/lwd/lty</p>
</td></tr>
<tr><td><code id="branches_attr_by_clusters_+3A_branches_changed_have_which_labels">branches_changed_have_which_labels</code></td>
<td>
<p>character with either &quot;any&quot; (default) or &quot;all&quot;.
Inidicates how the branches should be updated.</p>
</td></tr>
<tr><td><code id="branches_attr_by_clusters_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is probably NOT a very fast implementation of the function, but it works.
</p>
<p>This function was designed to enable the manipulation (mainly coloring) of
branches, based on the results from the <a href="dynamicTreeCut.html#topic+cutreeDynamic">cutreeDynamic</a>
function.
</p>


<h3>Value</h3>

<p>A dendrogram with modified branches (col/lwd/lty).
</p>


<h3>See Also</h3>

<p><a href="#topic+branches_attr_by_labels">branches_attr_by_labels</a>,
<a href="#topic+get_leaves_attr">get_leaves_attr</a>, <a href="#topic+nnodes">nnodes</a>, <a href="#topic+nleaves">nleaves</a>
<a href="dynamicTreeCut.html#topic+cutreeDynamic">cutreeDynamic</a>,
<a href="WGCNA.html#topic+plotDendroAndColors">plotDendroAndColors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

### Getting the hc object
iris_dist &lt;- iris[, -5] %&gt;% dist()
hc &lt;- iris_dist %&gt;% hclust()
# This is how it looks without any colors:
dend &lt;- as.dendrogram(hc)
plot(dend)

# Both functions give the same outcome
# options 1:
dend %&gt;%
  set("branches_k_color", k = 4) %&gt;%
  plot()
# options 2:
clusters &lt;- cutree(dend, 4)[order.dendrogram(dend)]
dend %&gt;%
  branches_attr_by_clusters(clusters) %&gt;%
  plot()

# and the second option is much slower:
system.time(set(dend, "branches_k_color", k = 4)) # 0.26 sec
system.time(branches_attr_by_clusters(dend, clusters)) # 1.61 sec
# BUT, it also allows us to do more flaxible things!

#--------------------------
#   Plotting dynamicTreeCut
#--------------------------

# let's get the clusters
library(dynamicTreeCut)
clusters &lt;- cutreeDynamic(hc, distM = as.matrix(iris_dist))
# we need to sort them to the order of the dendrogram:
clusters &lt;- clusters[order.dendrogram(dend)]

# get some functions:
library(colorspace)
no0_unique &lt;- function(x) {
  u_x &lt;- unique(x)
  u_x[u_x != 0]
}

clusters_numbers &lt;- no0_unique(clusters)
n_clusters &lt;- length(clusters_numbers)
cols &lt;- rainbow_hcl(n_clusters)
dend2 &lt;- branches_attr_by_clusters(dend, clusters, values = cols)
# dend2 &lt;- branches_attr_by_clusters(dend, clusters)
plot(dend2)
# add colored bars:
ord_cols &lt;- rainbow_hcl(n_clusters)[order(clusters_numbers)]
tmp_cols &lt;- rep(1, length(clusters))
tmp_cols[clusters != 0] &lt;- ord_cols[clusters != 0][clusters]
colored_bars(tmp_cols, y_shift = -1.1, rowLabels = "")
# all of the ordering is to handle the fact that the cluster numbers are not ascending...

# How is this compared with the usual cutree?
dend3 &lt;- color_branches(dend, k = n_clusters)
labels(dend2) &lt;- as.character(labels(dend2))
# this needs fixing, since the labels are not character!
# Well, both cluster solutions are not perfect, but at least they are interesting...
tanglegram(dend2, dend3,
  main_left = "cutreeDynamic", main_right = "cutree",
  columns_width = c(5, .5, 5),
  color_lines = cols[iris[order.dendrogram(dend2), 5]]
)
# (Notice how the color_lines is of the true Species of each Iris)
# The main difference is at the bottom,

## End(Not run)
</code></pre>

<hr>
<h2 id='branches_attr_by_labels'>Change col/lwd/lty of branches matching labels condition</h2><span id='topic+branches_attr_by_labels'></span>

<h3>Description</h3>

<p>The user supplies a dend, labels, and type of condition (all/any), and TF_values
And the function returns a dendrogram with branches col/lwd/lty accordingly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branches_attr_by_labels(
  dend,
  labels,
  TF_values = c(2, Inf),
  attr = c("col", "lwd", "lty"),
  type = c("all", "any"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branches_attr_by_labels_+3A_dend">dend</code></td>
<td>
<p>a dendrogram dend</p>
</td></tr>
<tr><td><code id="branches_attr_by_labels_+3A_labels">labels</code></td>
<td>
<p>a character vector of labels from the tree</p>
</td></tr>
<tr><td><code id="branches_attr_by_labels_+3A_tf_values">TF_values</code></td>
<td>
<p>a two dimensional vector with the TF_values to use in case a branch fulfills the condition (TRUE)
and in the case that it does not (FALSE). Defaults are 2/Inf for col, lwd and lty.
(so it will insert the first value, and will not change all the FALSE cases)</p>
</td></tr>
<tr><td><code id="branches_attr_by_labels_+3A_attr">attr</code></td>
<td>
<p>a character with one of the following values: col/lwd/lty</p>
</td></tr>
<tr><td><code id="branches_attr_by_labels_+3A_type">type</code></td>
<td>
<p>a character vector of either &quot;all&quot; or &quot;any&quot;, indicating which of
the branches should be painted: ones that all of their labels belong to the supplied labels,
or also ones that even some of their labels are included in the labels vector.</p>
</td></tr>
<tr><td><code id="branches_attr_by_labels_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram with modified branches (col/lwd/lty).
</p>


<h3>See Also</h3>

<p><a href="#topic+noded_with_condition">noded_with_condition</a>, <a href="#topic+get_leaves_attr">get_leaves_attr</a>, <a href="#topic+nnodes">nnodes</a>, <a href="#topic+nleaves">nleaves</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(dendextend)

set.seed(23235)
ss &lt;- sample(1:150, 10)

# Getting the dend dend
dend &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend %&gt;% plot()

dend %&gt;%
  branches_attr_by_labels(c("123", "126", "23", "29")) %&gt;%
  plot()
dend %&gt;%
  branches_attr_by_labels(c("123", "126", "23", "29"), "all") %&gt;%
  plot() # the same as above
dend %&gt;%
  branches_attr_by_labels(c("123", "126", "23", "29"), "any") %&gt;%
  plot()

dend %&gt;%
  branches_attr_by_labels(
    c("123", "126", "23", "29"),
    "any", "col", c("blue", "red")
  ) %&gt;%
  plot()
dend %&gt;%
  branches_attr_by_labels(
    c("123", "126", "23", "29"),
    "any", "lwd", c(4, 1)
  ) %&gt;%
  plot()
dend %&gt;%
  branches_attr_by_labels(
    c("123", "126", "23", "29"),
    "any", "lty", c(2, 1)
  ) %&gt;%
  plot()

## End(Not run)
</code></pre>

<hr>
<h2 id='branches_attr_by_lists'>Change col/lwd/lty of branches from the root down to clusters defined by list of labels of respective members</h2><span id='topic+branches_attr_by_lists'></span>

<h3>Description</h3>

<p>The user supplies a dend, lists, and type of condition (all/any), and TF_values
And the function returns a dendrogram with branches col/lwd/lty accordingly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branches_attr_by_lists(
  dend,
  lists,
  TF_values = c(2, 1),
  attr = c("col", "lwd", "lty"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branches_attr_by_lists_+3A_dend">dend</code></td>
<td>
<p>a dendrogram dend</p>
</td></tr>
<tr><td><code id="branches_attr_by_lists_+3A_lists">lists</code></td>
<td>
<p>a list where each element contains the labels of members in selected nodes
down to which the branches shall be adapted</p>
</td></tr>
<tr><td><code id="branches_attr_by_lists_+3A_tf_values">TF_values</code></td>
<td>
<p>a two dimensional vector with the TF_values to use in case a branch fulfills the condition (TRUE)
and in the case that it does not (FALSE). Defaults are 2/1 for col, lwd and lty.
(so it will insert the first value, and will not change all the FALSE cases)</p>
</td></tr>
<tr><td><code id="branches_attr_by_lists_+3A_attr">attr</code></td>
<td>
<p>a character with one of the following values: col/lwd/lty</p>
</td></tr>
<tr><td><code id="branches_attr_by_lists_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram with modified branches (col/lwd/lty).
</p>


<h3>See Also</h3>

<p><a href="#topic+branches_attr_by_labels">branches_attr_by_labels</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(dendextend)

set.seed(23235)
ss &lt;- sample(1:150, 10)

# Getting the dend dend
dend &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend %&gt;% plot()

# define a list of nodes
L &lt;- list(c("109", "123", "126", "145"), "29", c("59", "67", "97"))
dend %&gt;%
  branches_attr_by_lists(L) %&gt;%
  plot()

# choose different color, and also change lwd and lty
dend %&gt;%
  branches_attr_by_lists(L, TF_value = "blue") %&gt;%
  branches_attr_by_lists(L, attr = "lwd", TF_value = 4) %&gt;%
  branches_attr_by_lists(L, attr = "lty", TF_value = 3) %&gt;%
  plot()

## End(Not run)
</code></pre>

<hr>
<h2 id='circlize_dendrogram'>Plot a circlized dendrograms</h2><span id='topic+circlize_dendrogram'></span>

<h3>Description</h3>

<p>Plot a circlized dendrograms using the circlize package (must be installed for the function to work).
</p>
<p>This type of plot is also sometimes called fan tree plot (although the name fan-plot is also used for a different
plot in time series analysis), radial tree plot, polar tree plot, circular tree plot, and probably other names as well.
</p>
<p>An advantage for using the circlize package directly is for plotting a
circular dendrogram so that you can add more graphics for the elements
in the tree just by adding more tracks using <a href="circlize.html#topic+circos.track">circos.track</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circlize_dendrogram(
  dend,
  facing = c("outside", "inside"),
  labels = TRUE,
  labels_track_height = 0.1,
  dend_track_height = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circlize_dendrogram_+3A_dend">dend</code></td>
<td>
<p>a <a href="stats.html#topic+dendrogram">dendrogram</a> object</p>
</td></tr>
<tr><td><code id="circlize_dendrogram_+3A_facing">facing</code></td>
<td>
<p>Is the dendromgrams facing inside to the circle or outside.</p>
</td></tr>
<tr><td><code id="circlize_dendrogram_+3A_labels">labels</code></td>
<td>
<p>logical (TRUE) - should the labels be plotted as well.</p>
</td></tr>
<tr><td><code id="circlize_dendrogram_+3A_labels_track_height">labels_track_height</code></td>
<td>
<p>a value for adjusting the room for the labels.
It is 0.2 by default, but if NULL or NA, it will adjust automatically based on
the max width of the labels. However, if this is too long, the plot will give an error:
Error in check.track.position(track.index, track.start, track.height) :
not enough space for cells at track index '2'.</p>
</td></tr>
<tr><td><code id="circlize_dendrogram_+3A_dend_track_height">dend_track_height</code></td>
<td>
<p>a value for adjusting the room for the dendrogram.</p>
</td></tr>
<tr><td><code id="circlize_dendrogram_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dend that was used for plotting.
</p>


<h3>Author(s)</h3>

<p>Zuguang Gu, Tal Galili
</p>


<h3>Source</h3>

<p>This code is based on the work of Zuguang Gu. If you use the function, please cite both
dendextend (see: <code>citation("dendextend")</code>), as well as the circlize package (see: <code>citation("circlize")</code>).
</p>


<h3>See Also</h3>

<p><a href="circlize.html#topic+circos.dendrogram">circos.dendrogram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dend &lt;- iris[1:40, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("branches_k_color", k = 3) %&gt;%
  set("branches_lwd", c(5, 2, 1.5)) %&gt;%
  set("branches_lty", c(1, 1, 3, 1, 1, 2)) %&gt;%
  set("labels_colors") %&gt;%
  set("labels_cex", c(.9, 1.2)) %&gt;%
  set("nodes_pch", 19) %&gt;%
  set("nodes_col", c("orange", "black", "plum", NA))

circlize_dendrogram(dend)
circlize_dendrogram(dend, labels = FALSE)
circlize_dendrogram(dend, facing = "inside", labels = FALSE)


# In the following we get the dendrogram but can also get extra information on top of it
circos.initialize("foo", xlim = c(0, 40))
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
  circos.rect(1:40 - 0.8, rep(0, 40), 1:40 - 0.2, runif(40), col = rand_color(40), border = NA)
}, bg.border = NA)
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
  circos.text(1:40 - 0.5, rep(0, 40), labels(dend),
    col = labels_colors(dend),
    facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5)
  )
}, bg.border = NA, track.height = 0.1)
max_height &lt;- attr(dend, "height")
circos.track(ylim = c(0, max_height), panel.fun = function(x, y) {
  circos.dendrogram(dend, max_height = max_height)
}, track.height = 0.5, bg.border = NA)
circos.clear()

## End(Not run)
</code></pre>

<hr>
<h2 id='click_rotate'>Interactively rotate a tree object</h2><span id='topic+click_rotate'></span><span id='topic+click_rotate.default'></span><span id='topic+click_rotate.dendrogram'></span>

<h3>Description</h3>

<p>Lets te user click a plot of dendrogram
and rotates the tree based on the location of the click.
</p>
<p>Code for mouse selection of (sub-)cluster to be rotated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>click_rotate(x, ...)

## Default S3 method:
click_rotate(x, ...)

## S3 method for class 'dendrogram'
click_rotate(
  x,
  plot = TRUE,
  plot_after = plot,
  horiz = FALSE,
  continue = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="click_rotate_+3A_x">x</code></td>
<td>
<p>a tree object (either a <code>dendrogram</code> or <code>hclust</code>)</p>
</td></tr>
<tr><td><code id="click_rotate_+3A_...">...</code></td>
<td>
<p>parameters passed to the plot</p>
</td></tr>
<tr><td><code id="click_rotate_+3A_plot">plot</code></td>
<td>
<p>(logical) should the dendrogram first be plotted.</p>
</td></tr>
<tr><td><code id="click_rotate_+3A_plot_after">plot_after</code></td>
<td>
<p>(logical) should the dendrogram be plotted after
the rotation?</p>
</td></tr>
<tr><td><code id="click_rotate_+3A_horiz">horiz</code></td>
<td>
<p>logical. Should the plot be normal or horizontal?</p>
</td></tr>
<tr><td><code id="click_rotate_+3A_continue">continue</code></td>
<td>
<p>logical. If TRUE, allows the user to keep
clicking the plot until a click is made on the labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rotated tree object
</p>


<h3>Author(s)</h3>

<p>Andrej-Nikolai Spiess, Tal Galili
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotate.dendrogram">rotate.dendrogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the dend:
dend &lt;- USArrests %&gt;%
  dist() %&gt;%
  hclust("ave") %&gt;%
  as.dendrogram() %&gt;%
  color_labels()
## Not run: 
# play with the rotation once
dend &lt;- click_rotate(dend)
dend &lt;- click_rotate(dend, horiz = TRUE)
# keep playing with the rotation:
while (TRUE) dend &lt;- click_rotate(dend)
# the same as
dend &lt;- click_rotate(dend, continue = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='collapse_branch'>Collapse branches under a tolerance level</h2><span id='topic+collapse_branch'></span>

<h3>Description</h3>

<p>Collapse branches under a tolerance level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_branch(dend, tol = 1e-08, lower = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_branch_+3A_dend">dend</code></td>
<td>
<p>dendrogram object</p>
</td></tr>
<tr><td><code id="collapse_branch_+3A_tol">tol</code></td>
<td>
<p>a numeric value giving the tolerance to consider a branch length significantly greater than zero</p>
</td></tr>
<tr><td><code id="collapse_branch_+3A_lower">lower</code></td>
<td>
<p>logical (TRUE). collapse branches which are lower than tol?</p>
</td></tr>
<tr><td><code id="collapse_branch_+3A_...">...</code></td>
<td>
<p>passed on (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram with both of the root's branches of the same height
</p>


<h3>See Also</h3>

<p><a href="ape.html#topic+multi2di">multi2di</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# # ladderize is like sort(..., type = "node")
dend &lt;- iris[1:5, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
par(mfrow = c(1, 3))
dend %&gt;%
  ladderize() %&gt;%
  plot(horiz = TRUE)
abline(v = .2, col = 2, lty = 2)
dend %&gt;%
  collapse_branch(tol = 0.2) %&gt;%
  ladderize() %&gt;%
  plot(horiz = TRUE)
dend %&gt;%
  collapse_branch(tol = 0.2) %&gt;%
  ladderize() %&gt;%
  hang.dendrogram(hang = 0) %&gt;%
  plot(horiz = TRUE)

par(mfrow = c(1, 2))
dend %&gt;%
  collapse_branch(tol = 0.2, lower = FALSE) %&gt;%
  plot(horiz = TRUE, main = "dendrogram")
library(ape)
dend %&gt;%
  as.phylo() %&gt;%
  di2multi(tol = 0.2) %&gt;%
  plot(main = "phylo")
</code></pre>

<hr>
<h2 id='collapse_labels'>Collapse a sub dendrogram of adjacent labels within a dend</h2><span id='topic+collapse_labels'></span>

<h3>Description</h3>

<p>Given a dendrogram object, and a set of labels that are in the same sub-dendrogram,
the function performs a recursive DFS algorithm to determine
the sub-dendrogram which is composed of (exactly) all 'selected_labels'.
It then squashes this sub-dendrogram, and returns the original dendrogram with the squashed 
dendrogram with it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_labels(dend, selected_labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_labels_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="collapse_labels_+3A_selected_labels">selected_labels</code></td>
<td>
<p>A character vector with the labels we expect to have 
in the sub-dendrogram. This doesn't have to be in the same order as in the dendrogram.</p>
</td></tr>
<tr><td><code id="collapse_labels_+3A_...">...</code></td>
<td>
<p>elipsis (passed to squash_dendrogram)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the original dend.
Or, if the labels properly are in the dend by each other, a dend with
a squashed sub-dendrogram inside it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dendextend")

set.seed(23235)
ss &lt;- sample(1:150, 5)

# Getting the dend object
dend25 &lt;- iris[ss, -5] %&gt;%
   dist() %&gt;%
   hclust() %&gt;%
   as.dendrogram() %&gt;% 
   set("labels", letters[1:5])

par(mfrow = c(1,4))
plot(dend25)
plot(collapse_labels(dend25, c("d", "e")))
plot(collapse_labels(dend25, c("c", "d", "e")))
plot(collapse_labels(dend25, c("c", "d", "e"), squashed_original_height=TRUE))
</code></pre>

<hr>
<h2 id='color_branches'>Color tree's branches according to sub-clusters</h2><span id='topic+color_branches'></span><span id='topic+colour_branches'></span><span id='topic+branches_color'></span>

<h3>Description</h3>

<p>This function is for dendrogram and hclust objects.
This function colors both the terminal leaves of a dend's cluster and the edges
leading to those leaves. The edgePar attribute of nodes will be augmented by
a new list item col.
The groups will be defined by a call to <code><a href="#topic+cutree">cutree</a></code>
using the k or h parameters.
</p>
<p>If col is a color vector with a different length than the number of clusters
(k) - then a recycled color vector will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_branches(
  dend,
  k = NULL,
  h = NULL,
  col,
  groupLabels = NULL,
  clusters,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_branches_+3A_dend">dend</code></td>
<td>
<p>A <code>dendrogram</code> or <code>hclust</code> tree object</p>
</td></tr>
<tr><td><code id="color_branches_+3A_k">k</code></td>
<td>
<p>number of groups (passed to <code><a href="#topic+cutree">cutree</a></code>)</p>
</td></tr>
<tr><td><code id="color_branches_+3A_h">h</code></td>
<td>
<p>height at which to cut tree (passed to <code><a href="#topic+cutree">cutree</a></code>)</p>
</td></tr>
<tr><td><code id="color_branches_+3A_col">col</code></td>
<td>
<p>Function or vector of Colors. By default it tries to use
<a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a> from the <code>colorspace</code> package.
(with parameters c=90 and l=50). If <code>colorspace</code> is not available,
It will fall back on the <a href="grDevices.html#topic+rainbow">rainbow</a> function.</p>
</td></tr>
<tr><td><code id="color_branches_+3A_grouplabels">groupLabels</code></td>
<td>
<p>If TRUE add numeric group label - see Details for options</p>
</td></tr>
<tr><td><code id="color_branches_+3A_clusters">clusters</code></td>
<td>
<p>an integer vector of clusters. This is passed to <a href="#topic+branches_attr_by_clusters">branches_attr_by_clusters</a>.
This HAS to be of the same length as the number of leaves.
Items that belong to no cluster should get the value 0.
The vector should be of the same order as that of the labels in the dendrogram.
If you create the clusters from something like <a href="#topic+cutree">cutree</a> you would first
need to use <a href="stats.html#topic+order.dendrogram">order.dendrogram</a> on it, before using it in the function.</p>
</td></tr>
<tr><td><code id="color_branches_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="color_branches_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>groupLabels=TRUE</code> then numeric group labels will be added
to each cluster. If a vector is supplied then these entries will be used as
the group labels. If a function is supplied then it will be passed a
numeric vector of groups (e.g. 1:5) and must return the formatted group
labels.
</p>
<p>If the <a href="base.html#topic+labels">labels</a> of the dendrogram are NOT character (but, for example
integers) - they are coerced into character. This step is essential for the
proper operation of the function. A dendrogram labels might happen to be
integers if they are based on an <a href="stats.html#topic+hclust">hclust</a> performed on a <a href="stats.html#topic+dist">dist</a>
of an object without <a href="base.html#topic+rownames">rownames</a>.
</p>


<h3>Value</h3>

<p>a tree object of class <a href="stats.html#topic+dendrogram">dendrogram</a>.
</p>


<h3>Author(s)</h3>

<p>Tal Galili, extensively based on code by Gregory Jefferis
</p>


<h3>Source</h3>

<p>This function is a derived work from the <code><a href="dendroextras.html#topic+color_clusters">color_clusters</a></code>
function, with some ideas from the <code><a href="dendroextras.html#topic+slice">slice</a></code> function -
both are from the <span class="pkg">dendroextras</span> package by jefferis.
</p>
<p>It extends it by using <a href="#topic+cutree.dendrogram">cutree.dendrogram</a> - allowing
the function to work for trees that hclust can not handle
(unbranched and non-ultrametric trees).
Also, it allows REPEATED cluster color assignments to branches on to
the same tree. Something which the original function was not able to handle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutree">cutree</a></code>,<code><a href="stats.html#topic+dendrogram">dendrogram</a></code>,
<code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+labels_colors">labels_colors</a></code>,
<code><a href="#topic+branches_attr_by_clusters">branches_attr_by_clusters</a></code>, <a href="#topic+get_leaves_branches_col">get_leaves_branches_col</a>,
<a href="#topic+color_labels">color_labels</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
par(mfrow = c(1, 2))
dend &lt;- USArrests %&gt;%
  dist() %&gt;%
  hclust(method = "ave") %&gt;%
  as.dendrogram()
d1 &lt;- color_branches(dend, k = 5, col = c(3, 1, 1, 4, 1))
plot(d1) # selective coloring of branches :)
d2 &lt;- color_branches(dend, 5)
plot(d2)

par(mfrow = c(1, 2))
d1 &lt;- color_branches(dend, 5, col = c(3, 1, 1, 4, 1), groupLabels = TRUE)
plot(d1) # selective coloring of branches :)
d2 &lt;- color_branches(dend, 5, groupLabels = TRUE)
plot(d2)

par(mfrow = c(1, 3))
d5 &lt;- color_branches(dend, 5)
plot(d5)
d5g &lt;- color_branches(dend, 5, groupLabels = TRUE)
plot(d5g)
d5gr &lt;- color_branches(dend, 5, groupLabels = as.roman)
plot(d5gr)

par(mfrow = c(1, 1))

# messy - but interesting:
dend_override &lt;- color_branches(dend, 2, groupLabels = as.roman)
dend_override &lt;- color_branches(dend_override, 4, groupLabels = as.roman)
dend_override &lt;- color_branches(dend_override, 7, groupLabels = as.roman)
plot(dend_override)

d5 &lt;- color_branches(dend = dend[[1]], k = 5)


library(dendextend)
data(iris, envir = environment())
d_iris &lt;- dist(iris[, -5])
hc_iris &lt;- hclust(d_iris)
dend_iris &lt;- as.dendrogram(hc_iris)
dend_iris &lt;- color_branches(dend_iris, k = 3)

library(colorspace)
labels_colors(dend_iris) &lt;-
  rainbow_hcl(3)[sort_levels_values(
    as.numeric(iris[, 5])[order.dendrogram(dend_iris)]
  )]

plot(dend_iris,
  main = "Clustered Iris dataset",
  sub = "labels are colored based on the true cluster"
)



# cutree(dend_iris,k=3, order_clusters_as_data=FALSE,
#  try_cutree_hclust=FALSE)
# cutree(dend_iris,k=3, order_clusters_as_data=FALSE)

library(colorspace)

data(iris, envir = environment())
d_iris &lt;- dist(iris[, -5])
hc_iris &lt;- hclust(d_iris)
labels(hc_iris) # no labels, because "iris" has no row names
dend_iris &lt;- as.dendrogram(hc_iris)
is.integer(labels(dend_iris)) # this could cause problems...

iris_species &lt;- rev(levels(iris[, 5]))
dend_iris &lt;- color_branches(dend_iris, k = 3, groupLabels = iris_species)
is.character(labels(dend_iris)) # labels are no longer "integer"

# have the labels match the real classification of the flowers:
labels_colors(dend_iris) &lt;-
  rainbow_hcl(3)[sort_levels_values(
    as.numeric(iris[, 5])[order.dendrogram(dend_iris)]
  )]

# We'll add the flower type
labels(dend_iris) &lt;- paste(as.character(iris[, 5])[order.dendrogram(dend_iris)],
  "(", labels(dend_iris), ")",
  sep = ""
)

dend_iris &lt;- hang.dendrogram(dend_iris, hang_height = 0.1)

# reduce the size of the labels:
dend_iris &lt;- assign_values_to_leaves_nodePar(dend_iris, 0.5, "lab.cex")

par(mar = c(3, 3, 3, 7))
plot(dend_iris,
  main = "Clustered Iris dataset
     (the labels give the true flower species)",
  horiz = TRUE, nodePar = list(cex = .007)
)
legend("topleft", legend = iris_species, fill = rainbow_hcl(3))
a &lt;- dend_iris[[1]]
dend_iris1 &lt;- color_branches(a, k = 3)
plot(dend_iris1)

# str(dendrapply(d2, unclass))
# unclass(d1)

c(1:5) %&gt;% # take some data
  dist() %&gt;% # calculate a distance matrix,
  # on it compute hierarchical clustering using the "average" method,
  hclust(method = "single") %&gt;%
  as.dendrogram() %&gt;%
  color_branches(k = 3) %&gt;%
  plot() # nice, returns the tree as is...


# Example of the "clusters" parameter
par(mfrow = c(1, 2))
dend &lt;- c(1:5) %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend %&gt;%
  color_branches(k = 3) %&gt;%
  plot()
dend %&gt;%
  color_branches(clusters = c(1, 1, 2, 2, 3)) %&gt;%
  plot()


# another example, based on the question here:
# https://stackoverflow.com/q/45432271/256662


library(cluster)
set.seed(999)
iris2 &lt;- iris[sample(x = 1:150, size = 50, replace = F), ]
clust &lt;- diana(iris2)
dend &lt;- as.dendrogram(clust)

temp_col &lt;- c("red", "blue", "green")[as.numeric(iris2$Species)]
temp_col &lt;- temp_col[order.dendrogram(dend)]
temp_col &lt;- factor(temp_col, unique(temp_col))

library(dendextend)
dend %&gt;%
  color_branches(clusters = as.numeric(temp_col), col = levels(temp_col)) %&gt;%
  set("labels_colors", as.character(temp_col)) %&gt;%
  plot()

## End(Not run)

</code></pre>

<hr>
<h2 id='color_labels'>Color dend's labels according to sub-clusters</h2><span id='topic+color_labels'></span><span id='topic+colour_labels'></span>

<h3>Description</h3>

<p>This function is for dendrogram and hclust objects.
This function colors tree's labels.
</p>
<p>The groups will be defined by a call to <code><a href="#topic+cutree">cutree</a></code>
using the k or h parameters.
</p>
<p>If col is a color vector with a different length than the number of clusters
(k) - then a recycled color vector will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_labels(
  dend,
  k = NULL,
  h = NULL,
  labels,
  col,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_labels_+3A_dend">dend</code></td>
<td>
<p>A <code>dendrogram</code> or <code>hclust</code> tree object</p>
</td></tr>
<tr><td><code id="color_labels_+3A_k">k</code></td>
<td>
<p>number of groups (passed to <code><a href="#topic+cutree">cutree</a></code>)</p>
</td></tr>
<tr><td><code id="color_labels_+3A_h">h</code></td>
<td>
<p>height at which to cut tree (passed to <code><a href="#topic+cutree">cutree</a></code>)</p>
</td></tr>
<tr><td><code id="color_labels_+3A_labels">labels</code></td>
<td>
<p>character vecotor. If not missing, it overrides k and h,
and simply colors these labels in the tree based on &quot;col&quot; parameter.</p>
</td></tr>
<tr><td><code id="color_labels_+3A_col">col</code></td>
<td>
<p>Function or vector of Colors. By default it tries to use
<a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a> from the <code>colorspace</code> package.
(with parameters c=90 and l=50). If <code>colorspace</code> is not available,
It will fall back on the <a href="grDevices.html#topic+rainbow">rainbow</a> function.</p>
</td></tr>
<tr><td><code id="color_labels_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
(in case h/k/labels are not supplied, or if col is too short)</p>
</td></tr>
<tr><td><code id="color_labels_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tree object of class dendrogram.
</p>


<h3>Source</h3>

<p>This function is in the style of <code><a href="#topic+color_branches">color_branches</a></code>, and
based on <code><a href="#topic+labels_colors">labels_colors</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutree">cutree</a></code>,<code><a href="stats.html#topic+dendrogram">dendrogram</a></code>,
<code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+labels_colors">labels_colors</a></code>, <code><a href="#topic+color_branches">color_branches</a></code>,
<a href="#topic+assign_values_to_leaves_edgePar">assign_values_to_leaves_edgePar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
hc &lt;- hclust(dist(USArrests), "ave")
dend &lt;- as.dendrogram(hc)
dend &lt;- color_labels(dend, 5, col = c(3, 1, 1, 4, 1))
dend &lt;- color_branches(dend, 5, col = c(3, 1, 1, 4, 1))
plot(dend) # selective coloring of branches AND labels :)

# coloring some labels, based on label names:
dend &lt;- color_labels(dend, col = "red", labels = labels(dend)[c(4, 16)])
plot(dend) # selective coloring of branches AND labels :)

d5 &lt;- color_branches(dend, 5)
plot(d5)
d5g &lt;- color_branches(dend, 5, groupLabels = TRUE)
plot(d5g)
d5gr &lt;- color_branches(dend, 5, groupLabels = as.roman)
plot(d5gr)

## End(Not run)

</code></pre>

<hr>
<h2 id='color_unique_labels'>Color unique labels in a dendrogram</h2><span id='topic+color_unique_labels'></span>

<h3>Description</h3>

<p>Color unique labels in a dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_unique_labels(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_unique_labels_+3A_dend">dend</code></td>
<td>
<p>a dend object</p>
</td></tr>
<tr><td><code id="color_unique_labels_+3A_...">...</code></td>
<td>
<p>NOT USED</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram after the colors of its labels have been updated (a different color for each unique label).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(2011, 2011, 2012, 2012, 2015, 2015, 2015)
names(x) &lt;- x
dend &lt;- as.dendrogram(hclust(dist(x)))

par(mfrow = c(1, 2))
plot(dend)
dend2 &lt;- color_unique_labels(dend)
plot(dend2)
</code></pre>

<hr>
<h2 id='colored_bars'>Add colored bars to a dendrogram</h2><span id='topic+colored_bars'></span>

<h3>Description</h3>

<p>Add colored bars to a dendrogram, usually
corresponding to either clusters or some outside
categorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colored_bars(
  colors,
  dend,
  rowLabels = NULL,
  cex.rowLabels = 0.9,
  add = TRUE,
  y_scale,
  y_shift,
  text_shift = 1,
  sort_by_labels_order = TRUE,
  horiz = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colored_bars_+3A_colors">colors</code></td>
<td>
<p>Coloring of objects on the dendrogram. Either a vector (one color per object)
or a matrix (can also be an array or a data frame)
with each column giving one group with color per object.
Each column will be plotted as a horizontal row of colors (when horiz = FALSE)
under the dendrogram.
As long as the sort_by_labels_order paramter is TRUE (default), the colors vector/matrix should
be provided in the order of the original data order (and it will be re-ordered automaticall to
the order of the dendrogram)</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object. If missing, the colors are plotted without and re-ordering
(this assumes that the colors are already ordered based on the dend's labels)
This is also important in order to get the correct height/location of the colored bars
(i.e.: adjusting the y_scale and y_shift)</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_rowlabels">rowLabels</code></td>
<td>
<p>Labels for the colorings given in <code>colors</code>. The labels will be printed to the
left of the color rows in the plot. If the argument is given, it must be a vector of length
equal to the number of columns in <code>colors</code>. If not given, <code>names(colors)</code>
will be used if available. If not, sequential numbers
starting from 1 will be used.</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_cex.rowlabels">cex.rowLabels</code></td>
<td>
<p>Font size scale factor for the row labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_add">add</code></td>
<td>
<p>logical(TRUE), should the colored bars be added to an existing
dendrogram plot?</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_y_scale">y_scale</code></td>
<td>
<p>how much should the bars be stretched on the y axis?
If no dend is supplied - the default will be 1</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_y_shift">y_shift</code></td>
<td>
<p>where should the bars be plotted underneath the x axis?
By default it will try to locate the bars underneath the labels (it may miss,
in which case you would need to enter a number manually)
If no dend is supplied - the default will be 0</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_text_shift">text_shift</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_sort_by_labels_order">sort_by_labels_order</code></td>
<td>
<p>logical(TRUE) - if TRUE (default), then the order of the
colored bars will be sorted based on the order needed to change the original
order of the observations to the current order of the labels in the dendrogram.
If FALSE the colored bars are plotted as-is, based on the order
of the colors vector.</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_horiz">horiz</code></td>
<td>
<p>logical (FALSE by default). Set to TRUE when using plot(dend, horiz = TRUE)</p>
</td></tr>
<tr><td><code id="colored_bars_+3A_...">...</code></td>
<td>
<p>ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You will often needs to adjust the y_scale, y_shift and the text_shift
parameters, in order to get the bars in the location you would want.
</p>
<p>(this can probably be done automatically, but will require more work.
since it has to do with the current mar settings,
the number of groups, and each computer's specific graphic device.
patches for smarter defaults will be appreciated)
</p>


<h3>Value</h3>

<p>An invisible vector/matrix with the ordered colors.
</p>


<h3>Author(s)</h3>

<p>Steve Horvath <a href="mailto:SHorvath@mednet.ucla.edu">SHorvath@mednet.ucla.edu</a>,
Peter Langfelder <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>,
Tal Galili <a href="mailto:Tal.Galili@gmail.com">Tal.Galili@gmail.com</a>
</p>


<h3>Source</h3>

<p>This function is based on the <a href="moduleColor.html#topic+plotHclustColors">plotHclustColors</a> from the
moduleColor R package. It was modified so that it would
work with dendrograms (and not just hclust objects), as well allow to
add the colored bars on top of an existing plot (and not only as a seperate plot).
</p>
<p>See: <a href="https://cran.r-project.org/package=moduleColor">https://cran.r-project.org/package=moduleColor</a>
For more details.
</p>


<h3>See Also</h3>

<p><a href="#topic+branches_attr_by_clusters">branches_attr_by_clusters</a>,
<a href="WGCNA.html#topic+plotDendroAndColors">plotDendroAndColors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

rows_picking &lt;- c(1:5, 25:30)
dend &lt;- (iris[rows_picking, -5] * 10) %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
odd_numbers &lt;- rows_picking %% 2
cols &lt;- c("gold", "grey")[odd_numbers + 1]
# scale is off
plot(dend)
colored_bars(cols, dend)
# move and scale a bit
plot(dend)
colored_bars(cols, dend,
  y_shift = -1,
  rowLabels = "Odd\n numbers"
)
# Now let's cut the tree and add that info to the plot:
k2 &lt;- cutree(dend, k = 2)
cols2 &lt;- c("#0082CE", "#CC476B")[k2]
plot(dend)
colored_bars(cbind(cols2, cols), dend,
  rowLabels = c("2 clusters", "Odd numbers")
)

# The same, but with an horizontal plot!
par(mar = c(6, 2, 2, 4))
plot(dend, horiz = TRUE)
colored_bars(cbind(cols2, cols), dend,
  rowLabels = c("2 clusters", "Odd numbers"),
  horiz = TRUE
)



# let's add clusters color
# notice how we need to play with the colors a bit
# this is because color_branches places colors from
# left to right. Which means we need to give colored_bars
# the colors of the items so that ofter sorting they would be
# from left to right. Here is how it can be done:
the_k &lt;- 3
library(colorspace)
cols3 &lt;- rainbow_hcl(the_k, c = 90, l = 50)
dend %&gt;%
  set("branches_k_color", k = the_k, with = cols3) %&gt;%
  plot()

kx &lt;- cutree(dend, k = the_k)
ord &lt;- order.dendrogram(dend)
kx &lt;- sort_levels_values(kx[ord])
kx &lt;- kx[match(seq_along(ord), ord)]

par(mar = c(5, 5, 2, 2))
plot(dend)
colored_bars(cbind(cols3[kx], cols2, cols), dend,
  rowLabels = c("3 clusters", "2 clusters", "Odd numbers")
)



## mtcars example

# Create the dend:
dend &lt;- as.dendrogram(hclust(dist(mtcars)))

# Create a vector giving a color for each car to which company it belongs to
car_type &lt;- rep("Other", length(rownames(mtcars)))
is_x &lt;- grepl("Merc", rownames(mtcars))
car_type[is_x] &lt;- "Mercedes"
is_x &lt;- grepl("Mazda", rownames(mtcars))
car_type[is_x] &lt;- "Mazda"
is_x &lt;- grepl("Toyota", rownames(mtcars))
car_type[is_x] &lt;- "Toyota"
car_type &lt;- factor(car_type)
n_car_types &lt;- length(unique(car_type))
col_car_type &lt;- colorspace::rainbow_hcl(n_car_types, c = 70, l = 50)[car_type]

# extra: showing the various clusters cuts
k234 &lt;- cutree(dend, k = 2:4)

# color labels by car company:
labels_colors(dend) &lt;- col_car_type[order.dendrogram(dend)]
# color branches based on cutting the tree into 4 clusters:
dend &lt;- color_branches(dend, k = 4)

### plots
par(mar = c(12, 4, 1, 1))
plot(dend)
colored_bars(cbind(k234[, 3:1], col_car_type), dend,
  rowLabels = c(paste0("k = ", 4:2), "Car Type")
)

# horiz version:
par(mar = c(4, 1, 1, 12))
plot(dend, horiz = TRUE)
colored_bars(cbind(k234[, 3:1], col_car_type), dend,
  rowLabels = c(paste0("k = ", 4:2), "Car Type"), horiz = TRUE
)
</code></pre>

<hr>
<h2 id='colored_dots'>Add colored dots beside a dendrogram</h2><span id='topic+colored_dots'></span>

<h3>Description</h3>

<p>Add colored dots next to a dendrogram, usually
corresponding to either clusters or some outside
categorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colored_dots(
  colors,
  dend,
  rowLabels = NULL,
  cex.rowLabels = 0.9,
  add = TRUE,
  y_scale,
  y_shift,
  text_shift = 1,
  sort_by_labels_order = TRUE,
  horiz = FALSE,
  dot_size = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colored_dots_+3A_colors">colors</code></td>
<td>
<p>Coloring of the dots beside the dendrogram. Either a vector (one color per object)
or a matrix (can also be an array or a data frame)
with each column giving one group with color per object.
Each column will be plotted as a colored point (when horiz = FALSE)
under the dendrogram.
As long as the sort_by_labels_order paramter is TRUE (default), the colors vector/matrix should
be provided in the order of the original data order (and it will be re-ordered automatically to
the order of the dendrogram)</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object. If missing, the colors are plotted without and re-ordering
(this assumes that the colors are already ordered based on the dend's labels)
This is also important in order to get the correct height/location of the colored dots
(i.e.: adjusting the y_scale and y_shift)</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_rowlabels">rowLabels</code></td>
<td>
<p>Labels for the colorings given in <code>colors</code>. The labels will be printed to the
left of the color rows in the plot. If the argument is given, it must be a vector of length
equal to the number of columns in <code>colors</code>. If not given, <code>names(colors)</code>
will be used if available. If not, sequential numbers
starting from 1 will be used.</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_cex.rowlabels">cex.rowLabels</code></td>
<td>
<p>Font size scale factor for the row labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_add">add</code></td>
<td>
<p>logical(TRUE), should the colored dots be added to an existing
dendrogram plot?</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_y_scale">y_scale</code></td>
<td>
<p>how much should the dots be stretched on the y axis?
If no dend is supplied - the default will be 1</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_y_shift">y_shift</code></td>
<td>
<p>where should the dots be plotted underneath the x axis?
By default it will try to locate the dots underneath the labels (it may miss,
in which case you would need to enter a number manually)
If no dend is supplied - the default will be 0</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_text_shift">text_shift</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_sort_by_labels_order">sort_by_labels_order</code></td>
<td>
<p>logical(TRUE) - if TRUE (default), then the order of the
colored dots will be sorted based on the order needed to change the original
order of the observations to the current order of the labels in the dendrogram.
If FALSE the colored dots are plotted as-is, based on the order
of the colors vector.</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_horiz">horiz</code></td>
<td>
<p>logical (FALSE by default). Set to TRUE when using plot(dend, horiz = TRUE)</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_dot_size">dot_size</code></td>
<td>
<p>numeric (1 by default). Passed to cex argument in points</p>
</td></tr>
<tr><td><code id="colored_dots_+3A_...">...</code></td>
<td>
<p>ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reason you might choose colored_dots over colored_bars is when you have
a lot of group types and/or a really large dendrogram.
Hint: Make a group for each categorical factor and color it one color when true,
and assign a fully transparent color when false.
</p>
<p>You will often need to adjust the y_scale, y_shift and the text_shift
parameters, in order to get the dots in the location you would want.
</p>
<p>(This can probably be done automatically, but will require more work.
since it has to do with the current mar settings,
the number of groups, and each computer's specific graphic device.
patches for smarter defaults will be appreciated)
</p>


<h3>Value</h3>

<p>An invisible vector/matrix with the ordered colors.
</p>


<h3>Author(s)</h3>

<p>Steve Horvath <a href="mailto:SHorvath@mednet.ucla.edu">SHorvath@mednet.ucla.edu</a>,
Tal Galili <a href="mailto:Tal.Galili@gmail.com">Tal.Galili@gmail.com</a>,
Peter Langfelder <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>,
Chase Clark <a href="mailto:chasec288@gmail.com">chasec288@gmail.com</a>
</p>


<h3>Source</h3>

<p>This function is based on the <a href="moduleColor.html#topic+plotHclustColors">plotHclustColors</a> from the
moduleColor R package. It was modified so that it would
work with dendrograms (and not just hclust objects), as well allow to
add the colored dots on top of an existing plot (and not only as a seperate plot).
</p>
<p>See: <a href="https://cran.r-project.org/package=moduleColor">https://cran.r-project.org/package=moduleColor</a>
For more details.
</p>


<h3>See Also</h3>

<p><a href="#topic+branches_attr_by_clusters">branches_attr_by_clusters</a>,
<a href="WGCNA.html#topic+plotDendroAndColors">plotDendroAndColors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rows_picking &lt;- c(1:5, 25:30)
dend &lt;- (iris[rows_picking, -5] * 10) %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
odd_numbers &lt;- rows_picking %% 2
cols &lt;- c("red", "white")[odd_numbers + 1]
plot(dend)
colored_dots(cols, dend)
# Example of adjusting postion of dots
plot(dend)
colored_dots(cols, dend,
  y_shift = -1,
  rowLabels = "Odd\n numbers"
)



rows_picking &lt;- c(1:5, 25:30)
dend &lt;- (iris[rows_picking, -5] * 10) %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
odd_numbers &lt;- rows_picking %% 2
# For leaves that shouldn't have dots, make them the same color as the background,
# or set the alpha value to fully transparant
cols &lt;- c("black", "white")[odd_numbers + 1]
# scale is off
plot(dend)
colored_dots(cols, dend)
# move and scale a bit
plot(dend)
colored_dots(cols, dend,
  y_shift = -1,
  rowLabels = "Odd\n numbers"
)
# Now let's cut the tree and add that info to the plot:
k2 &lt;- cutree(dend, k = 2)
cols2 &lt;- c("#1b9e77", "#d95f02")[k2]

par(mar = c(5, 6, 1, 1))
plot(dend)
colored_dots(cbind(cols2, cols), dend,
  rowLabels = c("2 clusters", "Even numbers")
)

# The same, but with an horizontal plot!
par(mar = c(6, 2, 2, 4))
plot(dend, horiz = TRUE)
colored_dots(cbind(cols2, cols), dend,
  rowLabels = c("2 clusters", "Even numbers"),
  horiz = TRUE
)

# ==============================
# ==============================

## mtcars example

# Create the dend:
dend &lt;- as.dendrogram(hclust(dist(mtcars)))

# Get all company names
comp_names &lt;- unlist(lapply(rownames(mtcars), function(x) strsplit(x, " ")[[1]][[1]]))
# Get the top three occurring companies
top_three &lt;- sort(table(comp_names), decreasing = TRUE)[1:3]
# Match the top three companies to where they are found in the dendrogram labels
top_three &lt;- sapply(names(top_three), function(x) grepl(x, labels(dend)))
top_three &lt;- as.data.frame(top_three)
# "top_three" is now a data frame of the top three companies as columns.
# Each column represents a vector (rows) which is the length of labels(dend).
# The vector has values TRUE and FALSE, for whether the company name matched
# labels(dend)[i]

# Colorblind friendly vector of HEX colors
colorblind_friendly &lt;- c("#1b9e77", "#d95f02", "#7570b3")

# If we run the for-loop on "top_three" we will turn the vectors into a character-type too early,
# so make a copy to "colored_dataframe" which we will work on
colored_dataframe &lt;- top_three

for (i in 1:3) {
  # This replaces TRUE values with a color from our vector of colors
  colored_dataframe[top_three[, i], i] &lt;- colorblind_friendly[[i]]
  # This replaces FALSE values with black HEX, but fully transparent (invisible on plot)
  colored_dataframe[!top_three[, i], i] &lt;- "#00000000"
}

# Color branches and labels by "cutting" the dendrogram at an arbitrary height
dend &lt;- color_branches(dend, h = 170)
dend &lt;- color_labels(dend, h = 170)

### plots
par(mar = c(12, 4, 1, 1))
plot(dend)
colored_dots(colored_dataframe, dend,
  rowLabels = colnames(colored_dataframe), horiz = FALSE, sort_by_labels_order = FALSE
)
# Show a dotted line where tree was "cut"
abline(h = 170, lty = 3)

# horiz version:
par(mar = c(4, 1, 1, 12))
plot(dend, horiz = TRUE)
colored_dots(colored_dataframe, dend,
  rowLabels = colnames(colored_dataframe), horiz = TRUE, sort_by_labels_order = FALSE
)
# Show a dotted line where the tree was "cut"
abline(v = 170, lty = 3)
</code></pre>

<hr>
<h2 id='common_subtrees_clusters'>Find clusters of common subtrees</h2><span id='topic+common_subtrees_clusters'></span>

<h3>Description</h3>

<p>Gets a dend and the output from &quot;nodes_with_shared_labels&quot;
and returns a vector (length of labels), indicating the clusters
forming shared subtrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_subtrees_clusters(dend1, dend2, leaves_get_0_cluster = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="common_subtrees_clusters_+3A_dend1">dend1</code></td>
<td>
<p>a <a href="stats.html#topic+dendrogram">dendrogram</a>.</p>
</td></tr>
<tr><td><code id="common_subtrees_clusters_+3A_dend2">dend2</code></td>
<td>
<p>a <a href="stats.html#topic+dendrogram">dendrogram</a>.</p>
</td></tr>
<tr><td><code id="common_subtrees_clusters_+3A_leaves_get_0_cluster">leaves_get_0_cluster</code></td>
<td>
<p>logical (TRUE). Should the leaves which are not part of
a larger common subtree get a unique cluster number, or the value 0.</p>
</td></tr>
<tr><td><code id="common_subtrees_clusters_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector, with values indicating which leaves in dend1 form
a common subtree cluster, with ones available in dend2
</p>


<h3>See Also</h3>

<p><a href="#topic+color_branches">color_branches</a>, <a href="#topic+tanglegram">tanglegram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(dendextend)
dend1 &lt;- 1:6 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend2 &lt;- dend1 %&gt;% set("labels", c(1:4, 6:5))
tanglegram(dend1, dend2)

clusters1 &lt;- common_subtrees_clusters(dend1, dend2)
dend1_2 &lt;- color_branches(dend1, clusters = clusters1)
plot(dend1_2)
plot(dend1_2, horiz = TRUE)
tanglegram(dend1_2, dend2, highlight_distinct_edges = FALSE)
tanglegram(dend1_2, dend2)
</code></pre>

<hr>
<h2 id='cor_bakers_gamma'>Baker's Gamma correlation coefficient</h2><span id='topic+cor_bakers_gamma'></span><span id='topic+cor_bakers_gamma.dendrogram'></span><span id='topic+cor_bakers_gamma.hclust'></span><span id='topic+cor_bakers_gamma.dendlist'></span><span id='topic+cor_bakers_gamma.default'></span>

<h3>Description</h3>

<p>Calculate Baker's Gamma correlation coefficient for two trees
(also known as Goodman-Kruskal-gamma index).
</p>
<p>Assumes the labels in the two trees fully match. If they do not
please first use <a href="#topic+intersect_trees">intersect_trees</a> to have them matched.
</p>
<p>WARNING: this can be quite slow for medium/large trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_bakers_gamma(dend1, ...)

## Default S3 method:
cor_bakers_gamma(dend1, dend2, ...)

## S3 method for class 'dendrogram'
cor_bakers_gamma(
  dend1,
  dend2,
  use_labels_not_values = TRUE,
  to_plot = FALSE,
  warn = dendextend_options("warn"),
  ...
)

## S3 method for class 'hclust'
cor_bakers_gamma(
  dend1,
  dend2,
  use_labels_not_values = TRUE,
  to_plot = FALSE,
  warn = dendextend_options("warn"),
  ...
)

## S3 method for class 'dendlist'
cor_bakers_gamma(dend1, which = c(1L, 2L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_bakers_gamma_+3A_dend1">dend1</code></td>
<td>
<p>a tree (dendrogram/hclust/phylo)</p>
</td></tr>
<tr><td><code id="cor_bakers_gamma_+3A_...">...</code></td>
<td>
<p>Passed to <a href="#topic+cutree">cutree</a>.</p>
</td></tr>
<tr><td><code id="cor_bakers_gamma_+3A_dend2">dend2</code></td>
<td>
<p>a tree (dendrogram/hclust/phylo)</p>
</td></tr>
<tr><td><code id="cor_bakers_gamma_+3A_use_labels_not_values">use_labels_not_values</code></td>
<td>
<p>logical (TRUE). Should labels be used in the
k matrix when using cutree? Set to FALSE will make the function a bit faster
BUT, it assumes the two trees have the exact same leaves order values for
each labels. This can be assured by using <a href="#topic+match_order_by_labels">match_order_by_labels</a>.</p>
</td></tr>
<tr><td><code id="cor_bakers_gamma_+3A_to_plot">to_plot</code></td>
<td>
<p>logical (FALSE). Passed to <a href="#topic+bakers_gamma_for_2_k_matrix">bakers_gamma_for_2_k_matrix</a></p>
</td></tr>
<tr><td><code id="cor_bakers_gamma_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
should a warning be issued when using <a href="#topic+cutree">cutree</a>?</p>
</td></tr>
<tr><td><code id="cor_bakers_gamma_+3A_which">which</code></td>
<td>
<p>an integer vector of length 2, indicating
which of the trees in the dendlist object should be plotted (relevant for dendlist)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Baker's Gamma (see reference) is a measure of accosiation (similarity)
between two trees of heirarchical clustering (dendrograms).
</p>
<p>It is calculated by taking two items, and see what is the heighst
possible level of k (number of cluster groups created when cutting the tree)
for which the two item still belongs to the same tree. That k is returned,
and the same is done for these two items for the second tree.
There are n over 2 combinations of such pairs of items from the items in
the tree, and all of these numbers are calculated for each of the two trees.
Then, these two sets of numbers (a set for the items in each tree)
are paired according to the pairs of items compared, and a spearman
correlation is calculated.
</p>
<p>The value can range between -1 to 1. With near 0 values meaning that
the two trees are not statistically similar.
For exact p-value one should result to a permutation test. One such option
will be to permute over the labels of one tree many times, and calculating
the distriubtion under the null hypothesis (keeping the trees topologies
constant).
</p>
<p>Notice that this measure is not affected by the height of a branch but only
of its relative position compared with other branches.
</p>


<h3>Value</h3>

<p>Baker's Gamma association Index between two trees (a number between -1 to 1)
</p>


<h3>References</h3>

<p>Baker, F. B., Stability of Two Hierarchical Grouping Techniques Case
1: Sensitivity to Data Errors. Journal of the American Statistical
Association, 69(346), 440 (1974).
</p>


<h3>See Also</h3>

<p><a href="#topic+cor_cophenetic">cor_cophenetic</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- sample(1:150, 10)
hc1 &lt;- hclust(dist(iris[ss, -5]), "com")
hc2 &lt;- hclust(dist(iris[ss, -5]), "single")
dend1 &lt;- as.dendrogram(hc1)
dend2 &lt;- as.dendrogram(hc2)
#    cutree(dend1)

cor_bakers_gamma(hc1, hc2)
cor_bakers_gamma(dend1, dend2)

dend1 &lt;- match_order_by_labels(dend1, dend2) # if you are not sure
cor_bakers_gamma(dend1, dend2, use_labels_not_values = FALSE)

library(microbenchmark)
microbenchmark(
  with_labels = cor_bakers_gamma(dend1, dend2, try_cutree_hclust = FALSE),
  with_values = cor_bakers_gamma(dend1, dend2,
    use_labels_not_values = FALSE, try_cutree_hclust = FALSE
  ),
  times = 10
)


cor_bakers_gamma(dend1, dend1, use_labels_not_values = FALSE)
cor_bakers_gamma(dend1, dend1, use_labels_not_values = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='cor_common_nodes'>Proportion of commong nodes between two trees</h2><span id='topic+cor_common_nodes'></span>

<h3>Description</h3>

<p>Calculates the number of nodes, in each tree, that are common (i.e.: that have the same exact list of labels).
The correlation is between 0 (actually, 2*(nnodes-1)/(2*nnodes), for two trees with
the same list of labels - since the top node will always be identical for them).
Where 1 means that every node in the one tree, has a node in the other tree with the exact
same list of labels.
Notice this measure is non-parameteric (it ignores the heights and relative position of the nodes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_common_nodes(dend1, dend2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_common_nodes_+3A_dend1">dend1</code></td>
<td>
<p>a dendrogram.</p>
</td></tr>
<tr><td><code id="cor_common_nodes_+3A_dend2">dend2</code></td>
<td>
<p>a dendrogram.</p>
</td></tr>
<tr><td><code id="cor_common_nodes_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation value between 0 to 1 (almost identical trees)
</p>


<h3>See Also</h3>

<p><a href="#topic+distinct_edges">distinct_edges</a>, <a href="#topic+cor.dendlist">cor.dendlist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(23235)
ss &lt;- sample(1:150, 10)
hc1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com")
hc2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("single")
dend1 &lt;- as.dendrogram(hc1)
dend2 &lt;- as.dendrogram(hc2)

cor_cophenetic(dend1, dend2)
cor_common_nodes(dend1, dend2)
tanglegram(dend1, dend2)
# we can see we have only two nodes which are different...
</code></pre>

<hr>
<h2 id='cor_cophenetic'>Cophenetic correlation between two trees</h2><span id='topic+cor_cophenetic'></span><span id='topic+cor_cophenetic.default'></span><span id='topic+cor_cophenetic.dendlist'></span>

<h3>Description</h3>

<p>Cophenetic correlation coefficient for two trees.
</p>
<p>Assumes the labels in the two trees fully match. If they do not
please first use <a href="#topic+intersect_trees">intersect_trees</a> to have them matched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_cophenetic(dend1, ...)

## Default S3 method:
cor_cophenetic(
  dend1,
  dend2,
  method_coef = c("pearson", "kendall", "spearman"),
  ...
)

## S3 method for class 'dendlist'
cor_cophenetic(
  dend1,
  which = c(1L, 2L),
  method_coef = c("pearson", "kendall", "spearman"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_cophenetic_+3A_dend1">dend1</code></td>
<td>
<p>a tree (dendrogram/hclust/phylo, or dendlist)</p>
</td></tr>
<tr><td><code id="cor_cophenetic_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="cor_cophenetic_+3A_dend2">dend2</code></td>
<td>
<p>Either a tree (dendrogram/hclust/phylo), or a <a href="stats.html#topic+dist">dist</a> object (for example, from the original data matrix).</p>
</td></tr>
<tr><td><code id="cor_cophenetic_+3A_method_coef">method_coef</code></td>
<td>
<p>a character string indicating which correlation coefficient
is to be computed. One of &quot;pearson&quot; (default), &quot;kendall&quot;, or &quot;spearman&quot;,
can be abbreviated. Passed to <a href="stats.html#topic+cor">cor</a>.</p>
</td></tr>
<tr><td><code id="cor_cophenetic_+3A_which">which</code></td>
<td>
<p>an integer vector of length 2, indicating
which of the trees in a dendlist object should have
their cor_cophenetic calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From <a href="stats.html#topic+cophenetic">cophenetic</a>:
The cophenetic distance between two observations that have been clustered
is defined to be the intergroup dissimilarity at which the two observations
are first combined into a single cluster. Note that this distance has many
ties and restrictions.
</p>
<p>cor_cophenetic calculates the correlation between two cophenetic distance
matrices of the two trees.
</p>
<p>The value can range between -1 to 1. With near 0 values meaning that
the two trees are not statistically similar.
For exact p-value one should result to a permutation test. One such option
will be to permute over the labels of one tree many times, and calculating
the distriubtion under the null hypothesis (keeping the trees topologies
constant).
</p>
<p>Notice that this measure IS affected by the height of a branch.
</p>


<h3>Value</h3>

<p>The correlation between cophenetic
</p>


<h3>References</h3>

<p>Sokal, R. R. and F. J. Rohlf. 1962. The comparison of dendrograms by
objective methods. Taxon, 11:33-40
</p>
<p>Sneath, P.H.A. and Sokal, R.R. (1973) Numerical Taxonomy: The Principles
and Practice of Numerical Classification, p. 278 ff; Freeman, San Francisco.
</p>
<p><a href="https://en.wikipedia.org/wiki/Cophenetic_correlation">https://en.wikipedia.org/wiki/Cophenetic_correlation</a>
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+cophenetic">cophenetic</a>, <a href="#topic+cor_bakers_gamma">cor_bakers_gamma</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- sample(1:150, 10)
hc1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com")
hc2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("single")
dend1 &lt;- as.dendrogram(hc1)
dend2 &lt;- as.dendrogram(hc2)
#    cutree(dend1)

cophenetic(hc1)
cophenetic(hc2)
# notice how the dist matrix for the dendrograms have different orders:
cophenetic(dend1)
cophenetic(dend2)

cor(cophenetic(hc1), cophenetic(hc2)) # 0.874
cor(cophenetic(dend1), cophenetic(dend2)) # 0.16
# the difference is becasue the order of the distance table in the case of
# stats:::cophenetic.dendrogram will change between dendrograms!

# however, this is consistant (since I force-sort the rows/columns):
cor_cophenetic(hc1, hc2)
cor_cophenetic(dend1, dend2)

cor_cophenetic(dendlist(dend1, dend2))

# we can also use different cor methods (almost the same result though):
cor_cophenetic(hc1, hc2, method = "spearman") # 0.8456014
cor_cophenetic(dend1, dend2, method = "spearman") #


# cophenetic correlation is about 10 times (!) faster than bakers_gamma cor:
library(microbenchmark)
microbenchmark(
  cor_bakers_gamma = cor_bakers_gamma(dend1, dend2, try_cutree_hclust = FALSE),
  cor_cophenetic = cor_cophenetic(dend1, dend2),
  times = 10
)

# but only because of the cutree for dendrogram. When allowing hclust cutree
# it is only about twice as fast:
microbenchmark(
  cor_bakers_gamma = cor_bakers_gamma(dend1, dend2, try_cutree_hclust = TRUE),
  cor_cophenetic = cor_cophenetic(dend1, dend2),
  times = 10
)

## End(Not run)

</code></pre>

<hr>
<h2 id='cor_FM_index'>Correlation of FM_index for some k</h2><span id='topic+cor_FM_index'></span>

<h3>Description</h3>

<p>Calculates the FM_index Correlation for some k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_FM_index(dend1, dend2, k, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_FM_index_+3A_dend1">dend1</code></td>
<td>
<p>a dendrogram.</p>
</td></tr>
<tr><td><code id="cor_FM_index_+3A_dend2">dend2</code></td>
<td>
<p>a dendrogram.</p>
</td></tr>
<tr><td><code id="cor_FM_index_+3A_k">k</code></td>
<td>
<p>an integer (number of clusters to cut the tree)</p>
</td></tr>
<tr><td><code id="cor_FM_index_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation value between 0 to 1 (almost identical clusters for some k)
</p>


<h3>See Also</h3>

<p><a href="#topic+FM_index">FM_index</a>, <a href="#topic+cor.dendlist">cor.dendlist</a>, <a href="#topic+Bk">Bk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(23235)
ss &lt;- sample(1:150, 10)
hc1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com")
hc2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("single")
dend1 &lt;- as.dendrogram(hc1)
dend2 &lt;- as.dendrogram(hc2)

cor_FM_index(dend1, dend2, k = 2)
cor_FM_index(dend1, dend2, k = 3)
cor_FM_index(dend1, dend2, k = 4)
</code></pre>

<hr>
<h2 id='cor.dendlist'>Correlation matrix between a list of trees.</h2><span id='topic+cor.dendlist'></span>

<h3>Description</h3>

<p>A correlation matrix between a list of trees.
</p>
<p>Assumes the labels in the two trees fully match. If they do not
please first use <a href="#topic+intersect_trees">intersect_trees</a> to have them matched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.dendlist(
  dend,
  method = c("cophenetic", "baker", "common_nodes", "FM_index"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor.dendlist_+3A_dend">dend</code></td>
<td>
<p>a <a href="#topic+dendlist">dendlist</a> of trees</p>
</td></tr>
<tr><td><code id="cor.dendlist_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient
is to be computed. One of &quot;cophenetic&quot; (default),  &quot;baker&quot;,
&quot;common_nodes&quot;, or &quot;FM_index&quot;.
It can be abbreviated.</p>
</td></tr>
<tr><td><code id="cor.dendlist_+3A_...">...</code></td>
<td>
<p>passed to cor functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix between the different trees
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+cophenetic">cophenetic</a>, <a href="#topic+cor_cophenetic">cor_cophenetic</a>, <a href="#topic+cor_bakers_gamma">cor_bakers_gamma</a>,
<a href="#topic+cor_common_nodes">cor_common_nodes</a>, <a href="#topic+cor_FM_index">cor_FM_index</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- sample(1:150, 10)
dend1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("single") %&gt;%
  as.dendrogram()
dend3 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("ave") %&gt;%
  as.dendrogram()
dend4 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("centroid") %&gt;%
  as.dendrogram()
#    cutree(dend1)
cors &lt;- cor.dendlist(dendlist(d1 = dend1, d2 = dend2, d3 = dend3, d4 = dend4))

cors

# a nice plot for them:
library(corrplot)
corrplot(cor.dendlist(dend1234), "pie", "lower")

## End(Not run)
</code></pre>

<hr>
<h2 id='count_terminal_nodes'>Counts the number of terminal nodes (merging 0 nodes!)</h2><span id='topic+count_terminal_nodes'></span>

<h3>Description</h3>

<p>This function counts the number of &quot;practical&quot; terminal nodes (nodes which are not leaves, but has 0 height to them are considered &quot;terminal&quot; nodes).
If the tree is standard, that would simply be the number of leaves (only the leaves will have height 0).
However, in cases where the tree has several nodes (before the leaves) with 0 height,
the count_terminal_nodes counts such nodes as terminal nodes
</p>
<p>The function is recursive in that it either returns 1 if it reached a terminal node (either a leaf or a 0 height node),
else: it will count the number of terminal nodes in each of its sub-nodes, sum them up, and return them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_terminal_nodes(dend_node, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_terminal_nodes_+3A_dend_node">dend_node</code></td>
<td>
<p>a dendrogram object for which to count its number of terminal nodes (leaves or 0 height nodes).</p>
</td></tr>
<tr><td><code id="count_terminal_nodes_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of terminal nodes (excluding the leaves of nodes of height 0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)

###
# Trivial case
count_terminal_nodes(dend) # 3 terminal nodes
length(labels(dend)) # 3 - the same number
plot(dend,
  main = "This is considered a tree \n with THREE terminal nodes (leaves)"
)

###
# NON-Trivial case
str(dend)
attr(dend[[2]], "height") &lt;- 0
count_terminal_nodes(dend) # 2 terminal nodes, why? see this plot:
plot(dend,
  main = "This is considered a tree \n with TWO terminal nodes only"
)
# while we have 3 leaves, in practice we have only 2 terminal nodes
# (this is a feature, not a bug.)
</code></pre>

<hr>
<h2 id='cut_lower_fun'>Cut a dendrogram - and run a function on the output</h2><span id='topic+cut_lower_fun'></span><span id='topic+dendextend_cut_lower_fun'></span>

<h3>Description</h3>

<p>Cuts the dend at height h and returns a list with the FUN function
implemented on all the sub trees created by cut at height h.
This is used for creating a <a href="#topic+cutree.dendrogram">cutree.dendrogram</a> function,
by using the <code>labels</code> function as FUN.
</p>
<p>This is the Rcpp version of the function, offering a 10-60 times improvement
in speed (depending on the tree size it is used on).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_lower_fun(dend, h, FUN = labels, warn = dendextend_options("warn"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_lower_fun_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object.</p>
</td></tr>
<tr><td><code id="cut_lower_fun_+3A_h">h</code></td>
<td>
<p>a scalar of height to cut the dend by.</p>
</td></tr>
<tr><td><code id="cut_lower_fun_+3A_fun">FUN</code></td>
<td>
<p>a function to run. (default is &quot;labels&quot;)</p>
</td></tr>
<tr><td><code id="cut_lower_fun_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
Should the user be warned if reverting to default?</p>
</td></tr>
<tr><td><code id="cut_lower_fun_+3A_...">...</code></td>
<td>
<p>passed to FUN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the output of running FUN on each of the
sub dends derived from cutting &quot;dend&quot;
</p>


<h3>Author(s)</h3>

<p>Tal Galili
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+labels">labels</a></code>, <code><a href="stats.html#topic+dendrogram">dendrogram</a></code>,
<a href="#topic+cutree.dendrogram">cutree.dendrogram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dend &lt;- as.dendrogram(hclust(dist(iris[1:4, -5])))
# this is really cool!
cut_lower_fun(dend, .4, labels)
lapply(cut(dend, h = .4)$lower, labels)
cut_lower_fun(dend, .4, order.dendrogram)

</code></pre>

<hr>
<h2 id='cutree'>Cut a Tree (Dendrogram/hclust/phylo) into Groups of Data</h2><span id='topic+cutree'></span><span id='topic+cutree.default'></span><span id='topic+cutree.hclust'></span><span id='topic+cutree.phylo'></span><span id='topic+cutree.agnes'></span><span id='topic+cutree.diana'></span><span id='topic+cutree.dendrogram'></span>

<h3>Description</h3>

<p>Cuts a dendrogram tree into several groups
by specifying the desired number of clusters k(s), or cut height(s).
</p>
<p>For <code>hclust.dendrogram</code> -
In case there exists no such k for which exists a relevant split of the
dendrogram, a warning is issued to the user, and NA is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutree(tree, k = NULL, h = NULL, ...)

## Default S3 method:
cutree(tree, k = NULL, h = NULL, ...)

## S3 method for class 'hclust'
cutree(
  tree,
  k = NULL,
  h = NULL,
  use_labels_not_values = TRUE,
  order_clusters_as_data = TRUE,
  warn = dendextend_options("warn"),
  NA_to_0L = TRUE,
  ...
)

## S3 method for class 'phylo'
cutree(tree, k = NULL, h = NULL, ...)

## S3 method for class 'phylo'
cutree(tree, k = NULL, h = NULL, ...)

## S3 method for class 'agnes'
cutree(tree, k = NULL, h = NULL, ...)

## S3 method for class 'diana'
cutree(tree, k = NULL, h = NULL, ...)

## S3 method for class 'dendrogram'
cutree(
  tree,
  k = NULL,
  h = NULL,
  dend_heights_per_k = NULL,
  use_labels_not_values = TRUE,
  order_clusters_as_data = TRUE,
  warn = dendextend_options("warn"),
  try_cutree_hclust = TRUE,
  NA_to_0L = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutree_+3A_tree">tree</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="cutree_+3A_k">k</code></td>
<td>
<p>numeric scalar (OR a vector) with the number of clusters
the tree should be cut into.</p>
</td></tr>
<tr><td><code id="cutree_+3A_h">h</code></td>
<td>
<p>numeric scalar (OR a vector) with a height where the tree
should be cut.</p>
</td></tr>
<tr><td><code id="cutree_+3A_...">...</code></td>
<td>
<p>(not currently in use)</p>
</td></tr>
<tr><td><code id="cutree_+3A_use_labels_not_values">use_labels_not_values</code></td>
<td>
<p>logical, defaults to TRUE. If the actual labels of the
clusters do not matter - and we want to gain speed (say, 10 times faster) -
then use FALSE (gives the &quot;leaves order&quot; instead of their labels.).
This is passed to <code>cutree_1h.dendrogram</code>.</p>
</td></tr>
<tr><td><code id="cutree_+3A_order_clusters_as_data">order_clusters_as_data</code></td>
<td>
<p>logical, defaults to TRUE. There are two ways by which
to order the clusters: 1) By the order of the original data. 2) by the order of the
labels in the dendrogram. In order to be consistent with <a href="stats.html#topic+cutree">cutree</a>, this is set
to TRUE.
This is passed to <code>cutree_1h.dendrogram</code>.</p>
</td></tr>
<tr><td><code id="cutree_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
Should the function send a warning in case the desried k is not available?</p>
</td></tr>
<tr><td><code id="cutree_+3A_na_to_0l">NA_to_0L</code></td>
<td>
<p>logical. default is TRUE. When no clusters are possible,
Should the function return 0 (TRUE, default), or NA (when set to FALSE).</p>
</td></tr>
<tr><td><code id="cutree_+3A_dend_heights_per_k">dend_heights_per_k</code></td>
<td>
<p>a named vector that resulted from running.
<code>heights_per_k.dendrogram</code>. When running the function many times,
supplying this object will help improve the running time if using k!=NULL .</p>
</td></tr>
<tr><td><code id="cutree_+3A_try_cutree_hclust">try_cutree_hclust</code></td>
<td>
<p>logical. default is TRUE. Since cutree for hclust is
MUCH faster than for dendrogram - cutree.dendrogram will first try to change the
dendrogram into an hclust object. If it will fail (for example, with unbranched trees),
it will continue using the cutree.dendrogram function.
If try_cutree_hclust=FALSE, it will force to use cutree.dendrogram and not
cutree.hclust.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At least one of k or h must be specified, k overrides h if both are given.
</p>
<p>as opposed to <a href="stats.html#topic+cutree">cutree</a> for hclust, <code>cutree.dendrogram</code> allows the
cutting of trees at a given height also for non-ultrametric trees
(ultrametric tree == a tree with monotone clustering heights).
</p>


<h3>Value</h3>

<p>If k or h are scalar - <code>cutree.dendrogram</code> returns an integer vector with group
memberships.
Otherwise a matrix with group memberships is returned where each column
corresponds to the elements of k or h, respectively
(which are also used as column names).
</p>
<p>In case there exists no such k for which exists a relevant split of the
dendrogram, a warning is issued to the user, and NA is returned.
</p>


<h3>Author(s)</h3>

<p><code>cutree.dendrogram</code> was written by Tal Galili.
<code>cutree.hclust</code> is redirecting the function
to <a href="stats.html#topic+cutree">cutree</a> from base R.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+cutree">cutree</a></code>,
<code><a href="#topic+cutree_1h.dendrogram">cutree_1h.dendrogram</a></code>, <code><a href="#topic+cutree_1k.dendrogram">cutree_1k.dendrogram</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
hc &lt;- hclust(dist(USArrests[c(1, 6, 13, 20, 23), ]), "ave")
dend &lt;- as.dendrogram(hc)
unbranch_dend &lt;- unbranch(dend, 2)

cutree(hc, k = 2:4) # on hclust
cutree(dend, k = 2:4) # on dendrogram

cutree(hc, k = 2) # on hclust
cutree(dend, k = 2) # on dendrogram

cutree(dend, h = c(20, 25.5, 50, 170))
cutree(hc, h = c(20, 25.5, 50, 170))

# the default (ordered by original data's order)
cutree(dend, k = 2:3, order_clusters_as_data = FALSE)
labels(dend)

# as.hclust(unbranch_dend) # ERROR - can not do this...
cutree(unbranch_dend, k = 2) # all NA's
cutree(unbranch_dend, k = 1:4)
cutree(unbranch_dend, h = c(20, 25.5, 50, 170))
cutree(dend, h = c(20, 25.5, 50, 170))


library(microbenchmark)
## this shows how as.hclust is expensive - but still worth it if possible
microbenchmark(
  cutree(hc, k = 2:4),
  cutree(as.hclust(dend), k = 2:4),
  cutree(dend, k = 2:4),
  cutree(dend, k = 2:4, try_cutree_hclust = FALSE)
)
# the dendrogram is MUCH slower...

# Unit: microseconds
##                       expr      min       lq    median        uq       max neval
##        cutree(hc, k = 2:4)   91.270   96.589   99.3885  107.5075   338.758   100
##    tree(as.hclust(dend),
## 			  k = 2:4)           1701.629 1767.700 1854.4895 2029.1875  8736.591   100
##      cutree(dend, k = 2:4) 1807.456 1869.887 1963.3960 2125.2155  5579.705   100
##  cutree(dend, k = 2:4,
## 	try_cutree_hclust = FALSE) 8393.914 8570.852 8755.3490 9686.7930 14194.790   100

# and trying to "hclust" is not expensive (which is nice...)
microbenchmark(
  cutree_unbranch_dend = cutree(unbranch_dend, k = 2:4),
  cutree_unbranch_dend_not_trying_to_hclust =
    cutree(unbranch_dend, k = 2:4, try_cutree_hclust = FALSE)
)


## Unit: milliseconds
##                   expr      min       lq   median       uq      max neval
## cutree_unbranch_dend       7.309329 7.428314 7.494107 7.752234 17.59581   100
## cutree_unbranch_dend_not
## _trying_to_hclust        6.945375 7.079198 7.148629 7.577536 16.99780   100
## There were 50 or more warnings (use warnings() to see the first 50)

# notice that if cutree can't find clusters for the desired k/h, it will produce 0's instead!
# (It will produce a warning though...)
# This is a different behaviout than stats::cutree
# For example:
cutree(as.dendrogram(hclust(dist(c(1, 1, 1, 2, 2)))),
  k = 5
)

## End(Not run)

</code></pre>

<hr>
<h2 id='cutree_1h.dendrogram'>cutree for dendrogram (by 1 height only!)</h2><span id='topic+cutree_1h.dendrogram'></span>

<h3>Description</h3>

<p>Cuts a dendrogram tree into several groups
by specifying the desired cut height (only a single height!).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutree_1h.dendrogram(
  dend,
  h,
  order_clusters_as_data = TRUE,
  use_labels_not_values = TRUE,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutree_1h.dendrogram_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="cutree_1h.dendrogram_+3A_h">h</code></td>
<td>
<p>numeric scalar (NOT a vector) with a height where the dend should be cut.</p>
</td></tr>
<tr><td><code id="cutree_1h.dendrogram_+3A_order_clusters_as_data">order_clusters_as_data</code></td>
<td>
<p>logical, defaults to TRUE. There are two ways by which
to order the clusters: 1) By the order of the original data. 2) by the order of the
labels in the dendrogram. In order to be consistent with <a href="stats.html#topic+cutree">cutree</a>, this is set
to TRUE.</p>
</td></tr>
<tr><td><code id="cutree_1h.dendrogram_+3A_use_labels_not_values">use_labels_not_values</code></td>
<td>
<p>logical, defaults to TRUE. If the actual labels of the
clusters do not matter - and we want to gain speed (say, 10 times faster) -
then use FALSE (gives the &quot;leaves order&quot; instead of their labels.).</p>
</td></tr>
<tr><td><code id="cutree_1h.dendrogram_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="cutree_1h.dendrogram_+3A_...">...</code></td>
<td>
<p>(not currently in use)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cutree_1h.dendrogram</code> returns an integer vector with group memberships
</p>


<h3>Author(s)</h3>

<p>Tal Galili
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+cutree">cutree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[c(1, 6, 13, 20, 23), ]), "ave")
dend &lt;- as.dendrogram(hc)
cutree(hc, h = 50) # on hclust
cutree_1h.dendrogram(dend, h = 50) # on a dendrogram

labels(dend)

# the default (ordered by original data's order)
cutree_1h.dendrogram(dend, h = 50, order_clusters_as_data = TRUE)

# A different order of labels - order by their order in the tree
cutree_1h.dendrogram(dend, h = 50, order_clusters_as_data = FALSE)


# make it faster
## Not run: 
library(microbenchmark)
microbenchmark(
  cutree_1h.dendrogram(dend, h = 50),
  cutree_1h.dendrogram(dend, h = 50, use_labels_not_values = FALSE)
)
# 0.8 vs 0.6 sec - for 100 runs

## End(Not run)

</code></pre>

<hr>
<h2 id='cutree_1k.dendrogram'>cutree for dendrogram (by 1 k value only!)</h2><span id='topic+cutree_1k.dendrogram'></span>

<h3>Description</h3>

<p>Cuts a dendrogram tree into several groups
by specifying the desired number of clusters k (only a single k value!).
</p>
<p>In case there exists no such k for which exists a relevant split of the
dendrogram, a warning is issued to the user, and NA is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutree_1k.dendrogram(
  dend,
  k,
  dend_heights_per_k = NULL,
  use_labels_not_values = TRUE,
  order_clusters_as_data = TRUE,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutree_1k.dendrogram_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="cutree_1k.dendrogram_+3A_k">k</code></td>
<td>
<p>numeric scalar (not a vector!) with the number of clusters
the tree should be cut into.</p>
</td></tr>
<tr><td><code id="cutree_1k.dendrogram_+3A_dend_heights_per_k">dend_heights_per_k</code></td>
<td>
<p>a named vector that resulted from running.
<code>heights_per_k.dendrogram</code>. When running the function many times,
supplying this object will help improve the running time.</p>
</td></tr>
<tr><td><code id="cutree_1k.dendrogram_+3A_use_labels_not_values">use_labels_not_values</code></td>
<td>
<p>logical, defaults to TRUE. If the actual labels of the
clusters do not matter - and we want to gain speed (say, 10 times faster) -
then use FALSE (gives the &quot;leaves order&quot; instead of their labels.).
This is passed to <code>cutree_1h.dendrogram</code>.</p>
</td></tr>
<tr><td><code id="cutree_1k.dendrogram_+3A_order_clusters_as_data">order_clusters_as_data</code></td>
<td>
<p>logical, defaults to TRUE. There are two ways by which
to order the clusters: 1) By the order of the original data. 2) by the order of the
labels in the dendrogram. In order to be consistent with <a href="stats.html#topic+cutree">cutree</a>, this is set
to TRUE.
This is passed to <code>cutree_1h.dendrogram</code>.</p>
</td></tr>
<tr><td><code id="cutree_1k.dendrogram_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
Should the function send a warning in case the desried k is not available?</p>
</td></tr>
<tr><td><code id="cutree_1k.dendrogram_+3A_...">...</code></td>
<td>
<p>(not currently in use)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cutree_1k.dendrogram</code> returns an integer vector with group
memberships.
</p>
<p>In case there exists no such k for which exists a relevant split of the
dendrogram, a warning is issued to the user, and NA is returned.
</p>


<h3>Author(s)</h3>

<p>Tal Galili
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+cutree">cutree</a></code>,
<code><a href="#topic+cutree_1h.dendrogram">cutree_1h.dendrogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[c(1, 6, 13, 20, 23), ]), "ave")
dend &lt;- as.dendrogram(hc)
cutree(hc, k = 3) # on hclust
cutree_1k.dendrogram(dend, k = 3) # on a dendrogram

labels(dend)

# the default (ordered by original data's order)
cutree_1k.dendrogram(dend, k = 3, order_clusters_as_data = TRUE)

# A different order of labels - order by their order in the tree
cutree_1k.dendrogram(dend, k = 3, order_clusters_as_data = FALSE)


# make it faster
## Not run: 
library(microbenchmark)
dend_ks &lt;- heights_per_k.dendrogram
microbenchmark(
  cutree_1k.dendrogram = cutree_1k.dendrogram(dend, k = 4),
  cutree_1k.dendrogram_no_labels = cutree_1k.dendrogram(dend,
    k = 4, use_labels_not_values = FALSE
  ),
  cutree_1k.dendrogram_no_labels_per_k = cutree_1k.dendrogram(dend,
    k = 4, use_labels_not_values = FALSE,
    dend_heights_per_k = dend_ks
  )
)
# the last one is the fastest...

## End(Not run)

</code></pre>

<hr>
<h2 id='dend_diff'>Plots two trees side by side, highlighting edges unique to each tree in red.</h2><span id='topic+dend_diff'></span><span id='topic+dend_diff.dendrogram'></span><span id='topic+dend_diff.dendlist'></span>

<h3>Description</h3>

<p>Plots two trees side by side, highlighting edges unique to each tree in red.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dend_diff(dend, ...)

## S3 method for class 'dendrogram'
dend_diff(dend, dend2, horiz = TRUE, ...)

## S3 method for class 'dendlist'
dend_diff(dend, ..., which = c(1L, 2L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dend_diff_+3A_dend">dend</code></td>
<td>
<p>a dendrogram or <a href="#topic+dendlist">dendlist</a> to compre with</p>
</td></tr>
<tr><td><code id="dend_diff_+3A_...">...</code></td>
<td>
<p>passed to <a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a></p>
</td></tr>
<tr><td><code id="dend_diff_+3A_dend2">dend2</code></td>
<td>
<p>a dendrogram to compare with</p>
</td></tr>
<tr><td><code id="dend_diff_+3A_horiz">horiz</code></td>
<td>
<p>logical (TRUE) indicating if the dendrogram should be drawn horizontally or not.</p>
</td></tr>
<tr><td><code id="dend_diff_+3A_which">which</code></td>
<td>
<p>an integer vector indicating, in the case &quot;dend&quot; is a dendlist,
on which of the trees should the modification be performed.
If missing - the change will be performed on all of objects in the dendlist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <a href="#topic+dendlist">dendlist</a> of both trees.
</p>


<h3>Source</h3>

<p>A <a href="stats.html#topic+dendrogram">dendrogram</a> implementation for <a href="distory.html#topic+phylo.diff">phylo.diff</a> from the distory package
</p>


<h3>See Also</h3>

<p><a href="#topic+distinct_edges">distinct_edges</a>, <a href="#topic+highlight_distinct_edges">highlight_distinct_edges</a>,
<a href="#topic+dist.dendlist">dist.dendlist</a>, <a href="#topic+tanglegram">tanglegram</a>
<a href="#topic+assign_values_to_branches_edgePar">assign_values_to_branches_edgePar</a>,
<a href="distory.html#topic+distinct.edges">distinct.edges</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:5 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
y &lt;- set(x, "labels", 5:1)

dend_diff(x, y)
dend_diff(dendlist(x, y))
dend_diff(dendlist(y, x))

dend1 &lt;- 1:10 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend2 &lt;- dend1 %&gt;% set("labels", c(1, 3, 2, 4, 5:10))
dend_diff(dend1, dend2)
</code></pre>

<hr>
<h2 id='dend_expend'>Finds a &quot;good&quot; dendrogram for a dist</h2><span id='topic+dend_expend'></span><span id='topic+find_dend'></span>

<h3>Description</h3>

<p>There are many options for choosing distance and linkage functions for hclust.
This function goes through various combinations of the two and helps find the one
that is most &quot;similar&quot; to the original distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dend_expend(
  x,
  dist_methods = c("euclidean", "maximum", "manhattan", "canberra", "binary",
    "minkowski"),
  hclust_methods = c("ward.D", "ward.D2", "single", "complete", "average", "mcquitty",
    "median", "centroid"),
  hclust_fun = hclust,
  optim_fun = cor_cophenetic,
  ...
)

find_dend(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dend_expend_+3A_x">x</code></td>
<td>
<p>A matrix or a data.frame. Can also be a <a href="stats.html#topic+dist">dist</a> object.</p>
</td></tr>
<tr><td><code id="dend_expend_+3A_dist_methods">dist_methods</code></td>
<td>
<p>A vector of possible <a href="stats.html#topic+dist">dist</a> methods.</p>
</td></tr>
<tr><td><code id="dend_expend_+3A_hclust_methods">hclust_methods</code></td>
<td>
<p>A vector of possible <a href="stats.html#topic+hclust">hclust</a> methods.</p>
</td></tr>
<tr><td><code id="dend_expend_+3A_hclust_fun">hclust_fun</code></td>
<td>
<p>By default <a href="stats.html#topic+hclust">hclust</a>.</p>
</td></tr>
<tr><td><code id="dend_expend_+3A_optim_fun">optim_fun</code></td>
<td>
<p>A function that accepts a dend and a dist and returns how the two
are in agreement. Default is <a href="#topic+cor_cophenetic">cor_cophenetic</a>.</p>
</td></tr>
<tr><td><code id="dend_expend_+3A_...">...</code></td>
<td>
<p>options passed from find_dend to dend_expend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dend_expend:
A list with three items. The first item is called &quot;dends&quot; and includes
a dendlist with all the possible dendrogram combinations. The second is &quot;dists&quot; and
includes a list with all the possible distance matrix combination.
The third. &quot;performance&quot;, is data.frame with three columns: dist_methods, hclust_methods, and optim.
optim is calculated (by default) as the cophenetic correlation (see: <a href="#topic+cor_cophenetic">cor_cophenetic</a>) between the distance matrix and
the <a href="stats.html#topic+cophenetic">cophenetic</a> distance of the hclust object.
</p>
<p>find_dend: A dendrogram which is &quot;optimal&quot; based on the output from dend_expend.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- datasets::mtcars
out &lt;- dend_expend(x, dist_methods = c("euclidean", "manhattan"))
out$performance

dend_expend(dist(x))$performance

best_dend &lt;- find_dend(x, dist_methods = c("euclidean", "manhattan"))
plot(best_dend)
</code></pre>

<hr>
<h2 id='dendextend_options'>Access to dendextend_options</h2><span id='topic+dendextend_options'></span>

<h3>Description</h3>

<p>This is a function inside its own environment. This enables a bunch of
functions to be manipulated outside the package, even when they are called
from function within the dendextend package.
</p>
<p>TODO: describe options.
</p>
<p>A new &quot;warn&quot; dendextend_options parameter. logical (FALSE). Should warning be issued?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dendextend_options(option, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dendextend_options_+3A_option">option</code></td>
<td>
<p>a character scalar of the value of the options we would
like to access or update.</p>
</td></tr>
<tr><td><code id="dendextend_options_+3A_value">value</code></td>
<td>
<p>any value that we would like to update into the &quot;option&quot;
element in dendextend_options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with functions
</p>


<h3>Author(s)</h3>

<p>Kurt Hornik
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dendextend_options("a")
dendextend_options("a", 1)
dendextend_options("a")
dendextend_options("a", NULL)
dendextend_options("a")
dendextend_options()
</code></pre>

<hr>
<h2 id='dendlist'>Creating a dendlist object from several dendrograms</h2><span id='topic+dendlist'></span><span id='topic+plot.dendlist'></span>

<h3>Description</h3>

<p>It accepts several dendrograms and or dendlist objects
and chain them all together.
This function aim to help with the usability of
comparing two or more dendrograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dendlist(..., which)

## S3 method for class 'dendlist'
plot(x, which = c(1L, 2L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dendlist_+3A_...">...</code></td>
<td>
<p>several dendrogram/hclust/phylo or dendlist objects
If an object is hclust or phylo - it will be converted
into a dendrogram.</p>
</td></tr>
<tr><td><code id="dendlist_+3A_which">which</code></td>
<td>
<p>an integer vector of length 2, indicating
which of the trees in the dendlist object should be plotted (relevant for dendlist)
</p>
<p>When used inside dendlist, which is still an integer, but it can be of any length,
and it can be used to create a smaller dendlist.</p>
</td></tr>
<tr><td><code id="dendlist_+3A_x">x</code></td>
<td>
<p>a dendlist object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It there are list() in the ..., they are omitted.
If ... is missing, it returns an empty dendlist.
</p>


<h3>Value</h3>

<p>A list of class dendlist where each item
is a dendrogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dend &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend2 &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust(method = "single") %&gt;%
  as.dendrogram()
dendlist(1:4, 5, a = dend) # Error
# dendlist &lt;- function (...) list(...)
dendlist(dend)
dendlist(dend, dend)
dendlist(dend, dend, dendlist(dend))
#  notice how the order of
dendlist(dend, dend2)
dendlist(dend) %&gt;% dendlist(dend2)
dendlist(dend) %&gt;%
  dendlist(dend2) %&gt;%
  dendlist(dend)
dendlist(dend, dend2) %&gt;% tanglegram()
tanglegram(tree1 = dendlist(dend, dend2))

dend &lt;- iris[1:20, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend2 &lt;- iris[1:20, -5] %&gt;%
  dist() %&gt;%
  hclust(method = "single") %&gt;%
  as.dendrogram()

x &lt;- dendlist(dend, dend2)
plot(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='DendSer.dendrogram'>Tries to run DendSer on a dendrogram</h2><span id='topic+DendSer.dendrogram'></span>

<h3>Description</h3>

<p>Implements dendrogram seriation.
The function tries to turn the dend into hclust, on
which it runs <a href="DendSer.html#topic+DendSer">DendSer</a>.
</p>
<p>Also, if a distance matrix is missing, it will try
to use the <a href="stats.html#topic+cophenetic">cophenetic</a> distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DendSer.dendrogram(dend, ser_weight, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DendSer.dendrogram_+3A_dend">dend</code></td>
<td>
<p>An object of class dendrogram</p>
</td></tr>
<tr><td><code id="DendSer.dendrogram_+3A_ser_weight">ser_weight</code></td>
<td>
<p>Used by cost function to evaluate
ordering. For cost=costLS, this is a vector of
object weights. Otherwise is a dist or symmetric matrix.
passed to DendSer.
If it is missing, the cophenetic distance is used instead.</p>
</td></tr>
<tr><td><code id="DendSer.dendrogram_+3A_...">...</code></td>
<td>
<p>parameters passed to <a href="DendSer.html#topic+DendSer">DendSer</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector giving an optimal dendrogram order
</p>


<h3>See Also</h3>

<p><code><a href="DendSer.html#topic+DendSer">DendSer</a></code>, <a href="#topic+DendSer.dendrogram">DendSer.dendrogram</a> ,
<a href="#topic+untangle_DendSer">untangle_DendSer</a>, <a href="#topic+rotate_DendSer">rotate_DendSer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(DendSer) # already used from within the function
hc &lt;- hclust(dist(USArrests[1:4, ]), "ave")
dend &lt;- as.dendrogram(hc)
DendSer.dendrogram(dend)

## End(Not run)
</code></pre>

<hr>
<h2 id='dist_long'>Turns a dist object to a &quot;long&quot; table</h2><span id='topic+dist_long'></span>

<h3>Description</h3>

<p>Turns a dist object from a &quot;wide&quot; to a &quot;long&quot; table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_long(d, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_long_+3A_d">d</code></td>
<td>
<p>a distance object</p>
</td></tr>
<tr><td><code id="dist_long_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with two columns of rows and column names of the dist object
and a third column (distance) with the distance between the two.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris[2:6, -5] %&gt;%
  dist() %&gt;%
  data.matrix()
iris[2:6, -5] %&gt;%
  dist() %&gt;%
  as.vector()
iris[2:6, -5] %&gt;%
  dist() %&gt;%
  dist_long()
# This can later be used to making a network plot based on the distances.
</code></pre>

<hr>
<h2 id='dist.dendlist'>Topological Distances Between Two dendrograms</h2><span id='topic+dist.dendlist'></span>

<h3>Description</h3>

<p>This function seems to bring different results than ape - 
checking this out is still an open issue: <a href="https://github.com/talgalili/dendextend/issues/97">github issue</a>
</p>
<p>This function computes the <a href="https://en.wikipedia.org/wiki/Robinson%E2%80%93Foulds_metric">Robinson-Foulds distance</a> 
(also known as symmetric difference)
between two dendrograms. This is the number of edges (branches) in tree_1
with a combination of labels that exist in
it but not in any subtree of tree2,
plus the same calculation of tree2 when compared to tree1.
This is the sum of length of <a href="#topic+distinct_edges">distinct_edges</a>(x,y) with
<a href="#topic+distinct_edges">distinct_edges</a>(y,x).
</p>
<p>This function might implement other topological distances in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.dendlist(dend, method = c("edgeset"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.dendlist_+3A_dend">dend</code></td>
<td>
<p>a <a href="#topic+dendlist">dendlist</a></p>
</td></tr>
<tr><td><code id="dist.dendlist_+3A_method">method</code></td>
<td>
<p>currently only 'edgeset' is implemented.</p>
</td></tr>
<tr><td><code id="dist.dendlist_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="stats.html#topic+dist">dist</a> object with topological distances between all trees
</p>


<h3>See Also</h3>

<p><a href="#topic+distinct_edges">distinct_edges</a>,
<a href="ape.html#topic+dist.topo">dist.topo</a>,
<a href="distory.html#topic+dist.multiPhylo">dist.multiPhylo</a>,
<a href="phangorn.html#topic+treedist">treedist</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:5 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
y &lt;- set(x, "labels", 5:1)

dist.dendlist(dendlist(x1 = x, x2 = x, y1 = y))
dend_diff(x, y)

# Larger trees
x &lt;- 1:6 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
y &lt;- set(x, "labels", c(1:3, 6, 4, 5))

dend_diff(x, y)
dist.dendlist(dendlist(x, y))
distinct_edges(x, y)
distinct_edges(y, x)
length(distinct_edges(x, y)) + length(distinct_edges(y, x)) # dist.dendlist
</code></pre>

<hr>
<h2 id='distinct_edges'>Finds distinct edges in one tree compared to another</h2><span id='topic+distinct_edges'></span>

<h3>Description</h3>

<p>Finds the edges present in the first tree but not in the second
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct_edges(dend, dend2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct_edges_+3A_dend">dend</code></td>
<td>
<p>a dendrogram to find unique edges in</p>
</td></tr>
<tr><td><code id="distinct_edges_+3A_dend2">dend2</code></td>
<td>
<p>a dendrogram to compare with</p>
</td></tr>
<tr><td><code id="distinct_edges_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of edge ids for the first tree (dend) that are not present in the second tree (dend2).
</p>


<h3>Source</h3>

<p>A <a href="stats.html#topic+dendrogram">dendrogram</a> implementation for <a href="distory.html#topic+distinct.edges">distinct.edges</a> from the distory package
</p>


<h3>See Also</h3>

<p><a href="#topic+distinct_edges">distinct_edges</a>, <a href="#topic+highlight_distinct_edges">highlight_distinct_edges</a>,
<a href="#topic+dist.dendlist">dist.dendlist</a>, <a href="#topic+tanglegram">tanglegram</a>
<a href="distory.html#topic+distinct.edges">distinct.edges</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:5 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
y &lt;- set(x, "labels", 5:1)
distinct_edges(x, y)
distinct_edges(y, x)
dend_diff(x, y)
# tanglegram(x, y)
</code></pre>

<hr>
<h2 id='duplicate_leaf'>Duplicate a leaf X times</h2><span id='topic+duplicate_leaf'></span>

<h3>Description</h3>

<p>Duplicates a leaf in a tree. Useful for non-parametric bootstraping trees
since it emulates what would have happened if the tree was constructed based
on a row-sample with replacments from the original data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicate_leaf(
  dend,
  leaf_label,
  times,
  fix_members = TRUE,
  fix_order = TRUE,
  fix_midpoint = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicate_leaf_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="duplicate_leaf_+3A_leaf_label">leaf_label</code></td>
<td>
<p>the label of the laef to replicate.</p>
</td></tr>
<tr><td><code id="duplicate_leaf_+3A_times">times</code></td>
<td>
<p>the number of times we will have this leaf after replication</p>
</td></tr>
<tr><td><code id="duplicate_leaf_+3A_fix_members">fix_members</code></td>
<td>
<p>logical (TRUE). Fix the number of members in attr
using <a href="#topic+fix_members_attr.dendrogram">fix_members_attr.dendrogram</a></p>
</td></tr>
<tr><td><code id="duplicate_leaf_+3A_fix_order">fix_order</code></td>
<td>
<p>logical (TRUE). Fix the leaves order</p>
</td></tr>
<tr><td><code id="duplicate_leaf_+3A_fix_midpoint">fix_midpoint</code></td>
<td>
<p>logical (TRUE). Fix the midpoint value.
If TRUE, it overrides &quot;fix_members&quot; and turns it into TRUE (since it must
have a correct number of members in order to work).
values using <a href="#topic+rank_order.dendrogram">rank_order.dendrogram</a></p>
</td></tr>
<tr><td><code id="duplicate_leaf_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after duplicating one of its leaves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# define dendrogram object to play with:
dend &lt;- USArrests[1:3, ] %&gt;%
  dist() %&gt;%
  hclust(method = "ave") %&gt;%
  as.dendrogram()
plot(dend)
duplicate_leaf(dend, "Alaska", 3)
duplicate_leaf(dend, "Arizona", 2, fix_members = FALSE, fix_order = FALSE)
plot(duplicate_leaf(dend, "Alaska", 2))
plot(duplicate_leaf(dend, "Alaska", 4))
plot(duplicate_leaf(dend, "Arizona", 2))
plot(duplicate_leaf(dend, "Arizona", 4))

## End(Not run)

</code></pre>

<hr>
<h2 id='entanglement'>Measures entanglement between two trees</h2><span id='topic+entanglement'></span><span id='topic+entanglement.hclust'></span><span id='topic+entanglement.phylo'></span><span id='topic+entanglement.dendlist'></span><span id='topic+entanglement.dendrogram'></span>

<h3>Description</h3>

<p>Measures the entanglement between two trees.
Entanglement is a measure between 1 (full entanglement) and 0
(no entanglement). The exact behavior of the number depends on the L norm
which is chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entanglement(dend1, ...)

## S3 method for class 'hclust'
entanglement(dend1, dend2, ...)

## S3 method for class 'phylo'
entanglement(dend1, dend2, ...)

## S3 method for class 'dendlist'
entanglement(dend1, which = c(1L, 2L), ...)

## S3 method for class 'dendrogram'
entanglement(
  dend1,
  dend2,
  L = 1.5,
  leaves_matching_method = c("labels", "order"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entanglement_+3A_dend1">dend1</code></td>
<td>
<p>a tree object (of class dendrogram/hclust/phylo).</p>
</td></tr>
<tr><td><code id="entanglement_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="entanglement_+3A_dend2">dend2</code></td>
<td>
<p>a tree object (of class dendrogram/hclust/phylo).</p>
</td></tr>
<tr><td><code id="entanglement_+3A_which">which</code></td>
<td>
<p>an integer vector of length 2, indicating
which of the trees in a dendlist object should have
their entanglement calculated</p>
</td></tr>
<tr><td><code id="entanglement_+3A_l">L</code></td>
<td>
<p>the distance norm to use for measuring the distance between the
two trees. It can be any positive number, often one will want to
use 0, 1, 1.5, 2 (see 'details' for more).</p>
</td></tr>
<tr><td><code id="entanglement_+3A_leaves_matching_method">leaves_matching_method</code></td>
<td>
<p>a character scalar, either &quot;order&quot;
or &quot;labels&quot; (default) . If using &quot;labels&quot;, then we use the labels for
matching the leaves order value (safer).
</p>
<p>And if &quot;order&quot; then we use the old leaves order value for matching the
leaves order value.
</p>
<p>Using &quot;order&quot; is faster, but &quot;labels&quot; is safer. &quot;order&quot; will assume that
the original two trees had their labels and order values MATCHED.
</p>
<p>Hence, it is best to make sure that the trees used here have the same labels
and the SAME values matched to these values - and then use &quot;order&quot; (for
fastest results).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entanglement is measured by giving the left tree's labels the values of
1 till tree size, and than match these numbers with the right tree.
Now, entanglement is the L norm distance between these two vectors.
That is, we take the sum of the absolute difference (each one in the power
of L). e.g: <code>sum(abs(x-y)^L)</code>.
And this is devided by the &quot;worst case&quot; entanglement level (e.g:
when the right tree is the complete reverse of the left tree).
</p>
<p>L tells us which panelty level we are at (L0, L1, L2, partial L's etc).
L&gt;1 means that we give a big panelty for sharp angles.
While L-&gt;0 means that any time something is not a streight horizontal line,
it gets a large penalty
If L=0.1 it means that we much prefer streight lines over non streight lines
</p>


<h3>Value</h3>

<p>The number of leaves in the tree
</p>


<h3>See Also</h3>

<p><a href="#topic+tanglegram">tanglegram</a>, <a href="#topic+match_order_by_labels">match_order_by_labels</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
dend1 &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust("sin") %&gt;%
  as.dendrogram()
dend12 &lt;- dendlist(dend1, dend2)
tanglegram(dend12)

entanglement(dend12)
entanglement(dend12, L = 0)
entanglement(dend12, L = 0.25)
entanglement(dend1, dend2, L = 0) # 1
entanglement(dend1, dend2, L = 0.25) # 0.97
entanglement(dend1, dend2, L = 1) # 0.93
entanglement(dend1, dend2, L = 2) # 0.88

# a somewhat better tanglegram
tanglegram(sort(dend1), sort(dend2))
# and alos a MUCH better entanglement
entanglement(sort(dend1), sort(dend2), L = 1.5) # 0.0811
# but not that much, for L=0.25
entanglement(sort(dend1), sort(dend2), L = .25) # 0.579



##################
##################
##################
# massing up the order of leaves is dangerous:
entanglement(dend1, dend2, 1.5, "order") # 0.91
order.dendrogram(dend2) &lt;- seq_len(nleaves(dend2))
# this 0.95 number is NO LONGER correct!!
entanglement(dend1, dend2, 1.5, "order") # 0.95
# but if we use the "labels" method - we still get the correct number:
entanglement(dend1, dend2, 1.5, "labels") # 0.91

# however, we can fix our dend2, as follows:
dend2 &lt;- match_order_by_labels(dend2, dend1)
# Now that labels and order are matched - entanglement is back at working fine:
entanglement(dend1, dend2, 1.5, "order") # 0.91

## End(Not run)
</code></pre>

<hr>
<h2 id='fac2num'>Turns a factor into a number</h2><span id='topic+fac2num'></span>

<h3>Description</h3>

<p>Turning a factor into a number is not trivial.
Using <code>as.numeric</code> would only return to us the indicator numbers
and NOT the factor levels turned into a number.
fac2num simply turns a factor into a number, as we often need.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac2num(x, force_integer = FALSE, keep_names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac2num_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="fac2num_+3A_force_integer">force_integer</code></td>
<td>
<p>logical (FALSE). Should the values returned be integers?</p>
</td></tr>
<tr><td><code id="fac2num_+3A_keep_names">keep_names</code></td>
<td>
<p>logical (TRUE). Should the values returned keep the <a href="base.html#topic+names">names</a>
of the original vector?</p>
</td></tr>
<tr><td><code id="fac2num_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if x is an object - it returns logical - is the object of class dendrogram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- factor(3:5)
as.numeric(x) # 1 2 3
fac2num(x) # 3 4 5
</code></pre>

<hr>
<h2 id='find_dendrogram'>Search for the sub-dendrogram structure composed of selected labels</h2><span id='topic+find_dendrogram'></span>

<h3>Description</h3>

<p>Given a dendrogram object, the function performs a recursive DFS algorithm to determine
the sub-dendrogram which is composed of (exactly) all 'selected_labels'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dendrogram(dend, selected_labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_dendrogram_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="find_dendrogram_+3A_selected_labels">selected_labels</code></td>
<td>
<p>A character vector with the labels we expect to have 
in the sub-dendrogram. This doesn't have to be in the same order as in the dendrogram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a sub-dendrogram composed of only members of selected_labels.
If such a sub-dendrogram doesn't exist, the function returns NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# define dendrogram object to play with:
dend &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("labels_to_character") %&gt;%
  color_branches(k = 5)
first.subdend.only &lt;- names(cutree(dend, 4)[cutree(dend, 4) == 1])
sub.dend &lt;- find_dendrogram(dend, first.subdend.only)
# Plotting the result
par(mfrow = c(1, 2))
plot(dend, main = "Original dendrogram")
plot(sub.dend, main = "First subdendrogram")

  dend &lt;- 1:10 %&gt;%
dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("labels_to_character") %&gt;%
  color_branches(k = 5)

selected_labels &lt;- as.character(1:4)
sub_dend &lt;- find_dendrogram(dend, selected_labels)
plot(dend, main = "Original dendrogram")
plot(sub_dend, main = "First subdendrogram")



## End(Not run)

</code></pre>

<hr>
<h2 id='find_k'>Find the (estimated) number of clusters for a dendrogram using average silhouette width</h2><span id='topic+find_k'></span><span id='topic+plot.find_k'></span>

<h3>Description</h3>

<p>This function estimates the number of clusters based on the maximal average <a href="cluster.html#topic+silhouette">silhouette</a> width
derived from running <a href="cluster.html#topic+pam">pam</a> on the <a href="stats.html#topic+cophenetic">cophenetic</a> distance matrix of
the <a href="stats.html#topic+dendrogram">dendrogram</a>. The output is based on the <a href="fpc.html#topic+pamk">pamk</a> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_k(dend, krange = 2:min(10, (nleaves(dend) - 1)), ...)

## S3 method for class 'find_k'
plot(
  x,
  xlab = "Number of clusters (k)",
  ylab = "Average silhouette width",
  main = "Estimating the number of clusters using\n average silhouette width",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_k_+3A_dend">dend</code></td>
<td>
<p>A dendrogram (or hclust) tree object</p>
</td></tr>
<tr><td><code id="find_k_+3A_krange">krange</code></td>
<td>
<p>integer vector. Numbers of clusters which are to be compared
by the average silhouette width criterion.
Note: average silhouette width and Calinski-Harabasz can't estimate number
of clusters nc=1. If 1 is included, a Duda-Hart test is applied and 1 is
estimated if this is not significant.</p>
</td></tr>
<tr><td><code id="find_k_+3A_...">...</code></td>
<td>
<p>passed to <a href="fpc.html#topic+pamk">pamk</a> (the current defaults criterion=&quot;asw&quot; and usepam=TRUE can not be changes).</p>
</td></tr>
<tr><td><code id="find_k_+3A_x">x</code></td>
<td>
<p>An object of class &quot;find_k&quot; (has its own S3 plot method).</p>
</td></tr>
<tr><td><code id="find_k_+3A_xlab">xlab</code>, <code id="find_k_+3A_ylab">ylab</code>, <code id="find_k_+3A_main">main</code></td>
<td>
<p>parameters passed to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="fpc.html#topic+pamk">pamk</a> output. This is a list with the following components:
1) pamobject - The output of the optimal run of the pam-function.
2) nc	- the optimal number of clusters.
3) crit - vector of criterion values for numbers of clusters. crit[1] is the p-value of the Duda-Hart test if 1 is in krange and diss=FALSE.
4) k - a copy of nc (just to make it easier to extract - since k is often used in other functions)
</p>


<h3>See Also</h3>

<p><a href="fpc.html#topic+pamk">pamk</a>, <a href="cluster.html#topic+pam">pam</a>, <a href="cluster.html#topic+silhouette">silhouette</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dend &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend_k &lt;- find_k(dend)
plot(dend_k)
plot(color_branches(dend, k = dend_k$nc))

library(cluster)
sil &lt;- silhouette(dend_k$pamobject)
plot(sil)

dend &lt;- USArrests %&gt;%
  dist() %&gt;%
  hclust(method = "ave") %&gt;%
  as.dendrogram()
dend_k &lt;- find_k(dend)
plot(dend_k)
plot(color_branches(dend, k = dend_k$nc))
</code></pre>

<hr>
<h2 id='fix_members_attr.dendrogram'>Fix members attr in a dendrogram</h2><span id='topic+fix_members_attr.dendrogram'></span>

<h3>Description</h3>

<p>Fix members attr in a dendrogram after (for example), the tree was pruned
or manipulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_members_attr.dendrogram(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_members_attr.dendrogram_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="fix_members_attr.dendrogram_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after adjusting the members attr in all of its nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)
# plot(dend)
# prune one leaf
dend[[2]] &lt;- dend[[2]][[1]]
# plot(dend)
dend # but it is NO LONGER true that it has 3 members total!
fix_members_attr.dendrogram(dend) # it now knows it has only 2 members :)

hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)

identical(prune_leaf(dend, "Alaska"), fix_members_attr.dendrogram(prune_leaf(dend, "Alaska")))
str(unclass(prune_leaf(dend, "Alaska")))
str(unclass(fix_members_attr.dendrogram(prune_leaf(dend, "Alaska"))))
</code></pre>

<hr>
<h2 id='flatten.dendrogram'>Flatten the branches of a dendrogram's root</h2><span id='topic+flatten.dendrogram'></span>

<h3>Description</h3>

<p>The function makes sure the two branches of the root of a dendrogram will have the same height.
The user can choose how to decide which height to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten.dendrogram(dend, FUN = max, new_height, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten.dendrogram_+3A_dend">dend</code></td>
<td>
<p>dendrogram object</p>
</td></tr>
<tr><td><code id="flatten.dendrogram_+3A_fun">FUN</code></td>
<td>
<p>how to choose the new height of both branches (defaults to taking the max between the two)</p>
</td></tr>
<tr><td><code id="flatten.dendrogram_+3A_new_height">new_height</code></td>
<td>
<p>overrides FUN, and sets the new height of the two branches manually</p>
</td></tr>
<tr><td><code id="flatten.dendrogram_+3A_...">...</code></td>
<td>
<p>passed on (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram with both of the root's branches of the same height
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[2:9, ]), "com")
dend &lt;- as.dendrogram(hc)
attr(dend[[1]], "height") &lt;- 150 # make the height un-equal

par(mfrow = c(1, 2))
plot(dend, main = "original tree")
plot(flatten.dendrogram(dend), main = "Raised tree")
</code></pre>

<hr>
<h2 id='flip_leaves'>Flip leaves</h2><span id='topic+flip_leaves'></span>

<h3>Description</h3>

<p>Rotate a branch in a tree so that the locations of two bundles of leaves
are flipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip_leaves(dend, leaves1, leaves2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip_leaves_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="flip_leaves_+3A_leaves1">leaves1</code></td>
<td>
<p>a vector of leaves order value to flip.</p>
</td></tr>
<tr><td><code id="flip_leaves_+3A_leaves2">leaves2</code></td>
<td>
<p>a (second) vector of leaves order value to flip.</p>
</td></tr>
<tr><td><code id="flip_leaves_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on a bunch of string manipulation functions. There
may be a smarter/better way for doing it...
</p>


<h3>Value</h3>

<p>A dendrogram object with flipped leaves.
</p>


<h3>See Also</h3>

<p><a href="#topic+tanglegram">tanglegram</a>, <a href="#topic+match_order_by_labels">match_order_by_labels</a>,
<a href="#topic+entanglement">entanglement</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
dend1 &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend2 &lt;- flip_leaves(dend1, c(3, 5), c(1, 2))
tanglegram(dend1, dend2)
entanglement(dend1, dend2, L = 2) # 0.4

## End(Not run)
</code></pre>

<hr>
<h2 id='FM_index'>Calculating Fowlkes-Mallows Index</h2><span id='topic+FM_index'></span>

<h3>Description</h3>

<p>Calculating Fowlkes-Mallows index.
</p>
<p>The <code>FM_index_R</code> function calculates the expectancy and variance of the FM Index
under the null hypothesis of no relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_index(
  A1_clusters,
  A2_clusters,
  assume_sorted_vectors = FALSE,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_index_+3A_a1_clusters">A1_clusters</code></td>
<td>
<p>a numeric vector of cluster grouping (numeric) of items,
with a name attribute of item name for each element from group A1.
These are often obtained by using some k cut on a dendrogram.</p>
</td></tr>
<tr><td><code id="FM_index_+3A_a2_clusters">A2_clusters</code></td>
<td>
<p>a numeric vector of cluster grouping (numeric) of items,
with a name attribute of item name for each element from group A2.
These are often obtained by using some k cut on a dendrogram.</p>
</td></tr>
<tr><td><code id="FM_index_+3A_assume_sorted_vectors">assume_sorted_vectors</code></td>
<td>
<p>logical (FALSE). Can we assume to two group
vectors are sorter so that they have the same order of items?
IF FALSE (default), then the vectors will be sorted based on their
name attribute.</p>
</td></tr>
<tr><td><code id="FM_index_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="FM_index_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Wikipedia:
</p>
<p>Fowlkes-Mallows index (see references) is an external evaluation method
that is used to determine the similarity between two clusterings
(clusters obtained after a clustering algorithm). This measure of similarity
could be either between two hierarchical clusterings or a clustering and
a benchmark classification. A higher the value for the Fowlkes-Mallows index
indicates a greater similarity between the clusters and the benchmark
classifications.
</p>


<h3>Value</h3>

<p>The Fowlkes-Mallows index between two vectors of clustering groups.
</p>
<p>Includes the attributes E_FM and V_FM for the relevant expectancy and
variance under the null hypothesis of no-relation.
</p>


<h3>References</h3>

<p>Fowlkes, E. B.; Mallows, C. L. (1 September 1983).
&quot;A Method for Comparing Two Hierarchical Clusterings&quot;.
Journal of the American Statistical Association 78 (383): 553.
</p>
<p><a href="https://en.wikipedia.org/wiki/Fowlkes-Mallows_index">https://en.wikipedia.org/wiki/Fowlkes-Mallows_index</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+cor_bakers_gamma">cor_bakers_gamma</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- TRUE # sample(1:150, 10 )
hc1 &lt;- hclust(dist(iris[ss, -5]), "com")
hc2 &lt;- hclust(dist(iris[ss, -5]), "single")
# dend1 &lt;- as.dendrogram(hc1)
# dend2 &lt;- as.dendrogram(hc2)
#    cutree(dend1)

FM_index(cutree(hc1, k = 3), cutree(hc1, k = 3)) # 1 with EV

# checking speed gains
library(microbenchmark)
microbenchmark(
  FM_index(cutree(hc1, k = 3), cutree(hc1, k = 3)),
  FM_index(cutree(hc1, k = 3), cutree(hc1, k = 3),
    assume_sorted_vectors = TRUE
  ),
  FM_index(cutree(hc1, k = 3), cutree(hc1, k = 3),
    assume_sorted_vectors = TRUE
  )
)
# C code is 1.2-1.3 times faster.

set.seed(1341)
FM_index(cutree(hc1, k = 3), sample(cutree(hc1, k = 3)),
  assume_sorted_vectors = TRUE
) # 0.38037
FM_index(cutree(hc1, k = 3), sample(cutree(hc1, k = 3)),
  assume_sorted_vectors = FALSE
) # 1 again :)
FM_index(cutree(hc1, k = 3), cutree(hc2, k = 3)) # 0.8059
FM_index(cutree(hc1, k = 30), cutree(hc2, k = 30)) # 0.4529

fo &lt;- function(k) FM_index(cutree(hc1, k), cutree(hc2, k))
lapply(1:4, fo)
ks &lt;- 1:150
plot(sapply(ks, fo) ~ ks, type = "b", main = "Bk plot for the iris dataset")

## End(Not run)
</code></pre>

<hr>
<h2 id='FM_index_permutation'>Calculating Fowlkes-Mallows Index under H0</h2><span id='topic+FM_index_permutation'></span>

<h3>Description</h3>

<p>Calculating Fowlkes-Mallows index under the null hypothesis of no relation
between the clusterings (random order of the items labels).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_index_permutation(
  A1_clusters,
  A2_clusters,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_index_permutation_+3A_a1_clusters">A1_clusters</code></td>
<td>
<p>a numeric vector of cluster grouping (numeric) of items,
with a name attribute of item name for each element from group A1.
These are often obtained by using some k cut on a dendrogram.</p>
</td></tr>
<tr><td><code id="FM_index_permutation_+3A_a2_clusters">A2_clusters</code></td>
<td>
<p>a numeric vector of cluster grouping (numeric) of items,
with a name attribute of item name for each element from group A2.
These are often obtained by using some k cut on a dendrogram.</p>
</td></tr>
<tr><td><code id="FM_index_permutation_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="FM_index_permutation_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Fowlkes-Mallows index between two vectors of clustering groups.
Under H0. (a double without attr)
</p>


<h3>References</h3>

<p>Fowlkes, E. B.; Mallows, C. L. (1 September 1983).
&quot;A Method for Comparing Two Hierarchical Clusterings&quot;.
Journal of the American Statistical Association 78 (383): 553.
</p>
<p><a href="https://en.wikipedia.org/wiki/Fowlkes-Mallows_index">https://en.wikipedia.org/wiki/Fowlkes-Mallows_index</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+cor_bakers_gamma">cor_bakers_gamma</a>,
<code><a href="#topic+FM_index_R">FM_index_R</a></code>, <code><a href="#topic+FM_index">FM_index</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- TRUE # sample(1:150, 10 )
hc1 &lt;- hclust(dist(iris[ss, -5]), "com")
hc2 &lt;- hclust(dist(iris[ss, -5]), "single")
# dend1 &lt;- as.dendrogram(hc1)
# dend2 &lt;- as.dendrogram(hc2)
#    cutree(dend1)

# small k
A1_clusters &lt;- cutree(hc1, k = 3) # will give a right tailed distribution
# large k
A1_clusters &lt;- cutree(hc1, k = 50) # will give a discrete distribution
# "medium" k
A1_clusters &lt;- cutree(hc1, k = 25) # gives almost the normal distribution!
A2_clusters &lt;- A1_clusters

R &lt;- 10000
set.seed(414130)
FM_index_H0 &lt;- replicate(R, FM_index_permutation(A1_clusters, A2_clusters)) # can take 10 sec
plot(density(FM_index_H0), main = "FM Index distribution under H0\n (10000 permutation)")
abline(v = mean(FM_index_H0), col = 1, lty = 2)


# The permutation distribution is with a heavy right tail:
# Source of the skew functions is based on: library(psych)

skew &lt;- function (x, na.rm = TRUE) {
  x &lt;- na.omit(x)
  sum((x - mean(x))^3)/(length(x) * sd(x)^3)
}
skew(FM_index_H0) # 1.254


mean(FM_index_H0)
var(FM_index_H0)
the_FM_index &lt;- FM_index(A1_clusters, A2_clusters)
the_FM_index
our_dnorm &lt;- function(x) {
  dnorm(x,
    mean = attr(the_FM_index, "E_FM"),
    sd = sqrt(attr(the_FM_index, "V_FM"))
  )
}
# our_dnorm(0.35)
curve(our_dnorm,
  col = 4,
  from = -1, to = 1, n = R, add = TRUE
)
abline(v = attr(the_FM_index, "E_FM"), col = 4, lty = 2)

legend("topright", legend = c("asymptotic", "permutation"), fill = c(4, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='FM_index_R'>Calculating Fowlkes-Mallows index in R</h2><span id='topic+FM_index_R'></span>

<h3>Description</h3>

<p>Calculating Fowlkes-Mallows index.
</p>
<p>The <code>FM_index_R</code>
function also calculates the expectancy and variance of the FM Index
under the null hypothesis of no relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_index_R(
  A1_clusters,
  A2_clusters,
  assume_sorted_vectors = FALSE,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_index_R_+3A_a1_clusters">A1_clusters</code></td>
<td>
<p>a numeric vector of cluster grouping (numeric) of items,
with a name attribute of item name for each element from group A1.
These are often obtained by using some k cut on a dendrogram.</p>
</td></tr>
<tr><td><code id="FM_index_R_+3A_a2_clusters">A2_clusters</code></td>
<td>
<p>a numeric vector of cluster grouping (numeric) of items,
with a name attribute of item name for each element from group A2.
These are often obtained by using some k cut on a dendrogram.</p>
</td></tr>
<tr><td><code id="FM_index_R_+3A_assume_sorted_vectors">assume_sorted_vectors</code></td>
<td>
<p>logical (FALSE). Can we assume to two group
vectors are sorter so that they have the same order of items?
IF FALSE (default), then the vectors will be sorted based on their
name attribute.</p>
</td></tr>
<tr><td><code id="FM_index_R_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="FM_index_R_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Wikipedia:
</p>
<p>Fowlkes-Mallows index (see references) is an external evaluation method
that is used to determine the similarity between two clusterings
(clusters obtained after a clustering algorithm). This measure of similarity
could be either between two hierarchical clusterings or a clustering and
a benchmark classification. A higher the value for the Fowlkes-Mallows index
indicates a greater similarity between the clusters and the benchmark
classifications.
</p>


<h3>Value</h3>

<p>The Fowlkes-Mallows index between two vectors of clustering groups.
</p>
<p>Includes the attributes E_FM and V_FM for the relevant expectancy and
variance under the null hypothesis of no-relation.
</p>


<h3>References</h3>

<p>Fowlkes, E. B.; Mallows, C. L. (1 September 1983).
&quot;A Method for Comparing Two Hierarchical Clusterings&quot;.
Journal of the American Statistical Association 78 (383): 553.
</p>
<p><a href="https://en.wikipedia.org/wiki/Fowlkes-Mallows_index">https://en.wikipedia.org/wiki/Fowlkes-Mallows_index</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+cor_bakers_gamma">cor_bakers_gamma</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- TRUE # sample(1:150, 10 )
hc1 &lt;- hclust(dist(iris[ss, -5]), "com")
hc2 &lt;- hclust(dist(iris[ss, -5]), "single")
# dend1 &lt;- as.dendrogram(hc1)
# dend2 &lt;- as.dendrogram(hc2)
#    cutree(dend1)

FM_index_R(cutree(hc1, k = 3), cutree(hc1, k = 3)) # 1
set.seed(1341)
FM_index_R(cutree(hc1, k = 3),
           sample(cutree(hc1, k = 3)), 
           assume_sorted_vectors = TRUE) # 0.38037
FM_index_R(cutree(hc1, k = 3), 
           sample(cutree(hc1, k = 3)), 
           assume_sorted_vectors = FALSE) # 1 again :)
FM_index_R(cutree(hc1, k = 3), 
           cutree(hc2, k = 3)) # 0.8059
FM_index_R(cutree(hc1, k = 30), 
           cutree(hc2, k = 30)) # 0.4529

fo &lt;- function(k) FM_index_R(cutree(hc1, k), cutree(hc2, k))
lapply(1:4, fo)
ks &lt;- 1:150
plot(sapply(ks, fo) ~ ks, type = "b", main = "Bk plot for the iris dataset")

clu_1 &lt;- cutree(hc2, k = 100) # this is a lie - since this one is NOT well defined!
clu_2 &lt;- cutree(as.dendrogram(hc2), k = 100) # We see that we get a vector of NAs for this...

FM_index_R(clu_1, clu_2) # NA

## End(Not run)
</code></pre>

<hr>
<h2 id='get_branches_heights'>Get height attributes from a dendrogram</h2><span id='topic+get_branches_heights'></span>

<h3>Description</h3>

<p>Get height attributes of a dendrogram's branches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_branches_heights(
  dend,
  sort = TRUE,
  decreasing = FALSE,
  include_leaves = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_branches_heights_+3A_dend">dend</code></td>
<td>
<p>a dendrogram.</p>
</td></tr>
<tr><td><code id="get_branches_heights_+3A_sort">sort</code></td>
<td>
<p>logical. Should the heights be sorted?</p>
</td></tr>
<tr><td><code id="get_branches_heights_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort be increasing or decreasing? Not available for partial sorting.</p>
</td></tr>
<tr><td><code id="get_branches_heights_+3A_include_leaves">include_leaves</code></td>
<td>
<p>logical (FALSE). Should the output include the leaves value (0's).</p>
</td></tr>
<tr><td><code id="get_branches_heights_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the dendrogram's nodes heights (excluding leaves).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hc &lt;- hclust(dist(USArrests[1:4, ]), "ave")
dend &lt;- as.dendrogram(hc)
get_branches_heights(dend)
</code></pre>

<hr>
<h2 id='get_childrens_heights'>Get height attributes from a dendrogram's children</h2><span id='topic+get_childrens_heights'></span>

<h3>Description</h3>

<p>Get height attributes from a dendrogram's children nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_childrens_heights(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_childrens_heights_+3A_dend">dend</code></td>
<td>
<p>a dendrogram.</p>
</td></tr>
<tr><td><code id="get_childrens_heights_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the heights of a dendrogram's current node's
(first level) children.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_branches_heights">get_branches_heights</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hc &lt;- hclust(dist(USArrests[1:4, ]), "ave")
dend &lt;- as.dendrogram(hc)
get_childrens_heights(dend)
</code></pre>

<hr>
<h2 id='get_leaves_attr'>Get/set attributes of dendrogram's leaves</h2><span id='topic+get_leaves_attr'></span>

<h3>Description</h3>

<p>Get/set attributes of dendrogram's leaves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_leaves_attr(dend, attribute, simplify = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_leaves_attr_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="get_leaves_attr_+3A_attribute">attribute</code></td>
<td>
<p>character scalar of the attribute (<code>attr</code>)
we wish to get/set from the leaves</p>
</td></tr>
<tr><td><code id="get_leaves_attr_+3A_simplify">simplify</code></td>
<td>
<p>logical. If TRUE (default), then the return vector is
after using <code>unlist</code> on it.</p>
</td></tr>
<tr><td><code id="get_leaves_attr_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (or a list) with the dendrogram's leaves attribute
</p>


<h3>Source</h3>

<p>Heavily inspired by the code in the
function <code>labels.dendrogram</code>,
so credit should go to Martin Maechler.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_nodes_attr">get_nodes_attr</a>, <a href="#topic+nnodes">nnodes</a>,
<a href="#topic+nleaves">nleaves</a>, <a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)

# get_leaves_attr(dend) # error :)
get_leaves_attr(dend, "label")
labels(dend, "label")
get_leaves_attr(dend, "height") # should be 0's
get_nodes_attr(dend, "height")

get_leaves_attr(dend, "nodePar")


get_leaves_attr(dend, "leaf") # should be TRUE's
get_nodes_attr(dend, "leaf") # conatins NA's


get_leaves_attr(dend, "members") # should be 1's
get_nodes_attr(dend, "members") #


get_leaves_attr(dend, "members", simplify = FALSE) # should be 1's
</code></pre>

<hr>
<h2 id='get_leaves_branches_attr'>Get an attribute of the branches of a dendrogram's leaves</h2><span id='topic+get_leaves_branches_attr'></span>

<h3>Description</h3>

<p>This is helpful to get the attributes of branches of the leaves.
For example, after we use <a href="#topic+color_branches">color_branches</a>, to get the colors
of the labels to match (since getting the colors of branches to match
those of the labels can be tricky).
This is based on <a href="#topic+get_leaves_edgePar">get_leaves_edgePar</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_leaves_branches_attr(dend, attr = c("col", "lwd", "lty"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_leaves_branches_attr_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="get_leaves_branches_attr_+3A_attr">attr</code></td>
<td>
<p>character, the attr to get. Can be either &quot;col&quot;, &quot;lwd&quot;, or &quot;lty&quot;.</p>
</td></tr>
<tr><td><code id="get_leaves_branches_attr_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the dendrogram's leaves nodePar attribute
</p>


<h3>See Also</h3>

<p><a href="#topic+get_nodes_attr">get_nodes_attr</a>, <a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>, <a href="#topic+labels_colors">labels_colors</a>
<a href="#topic+get_leaves_nodePar">get_leaves_nodePar</a>, <a href="#topic+get_leaves_edgePar">get_leaves_edgePar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)

dend &lt;- dend %&gt;%
  color_branches(k = 3) %&gt;%
  set("branches_lwd", c(2, 1, 2)) %&gt;%
  set("branches_lty", c(1, 2, 1))

plot(dend)

get_leaves_branches_attr(dend, "col")
get_leaves_branches_attr(dend, "lwd")
get_leaves_branches_attr(dend, "lty")

labels_colors(dend) &lt;- get_leaves_branches_attr(dend, "col")
plot(dend)
</code></pre>

<hr>
<h2 id='get_leaves_branches_col'>Get the colors of the branches of a dendrogram's leaves</h2><span id='topic+get_leaves_branches_col'></span>

<h3>Description</h3>

<p>It is useful to get the colors of branches of the leaves,
after we use <a href="#topic+color_branches">color_branches</a>, so to then match the colors of the labels
to that of the branches (since getting the colors of branches to match
those of the labels can be tricky).
This is based on <a href="#topic+get_leaves_branches_attr">get_leaves_branches_attr</a> which is based on
<a href="#topic+get_leaves_edgePar">get_leaves_edgePar</a>.
</p>
<p>TODO: The function get_leaves_branches_col may behave oddly when extracting
colors with missing col attributes when the lwd attribute is available.
This may resolt in a vector with the wrong length (with omitted NA values).
This might need to be fixed in the future, and attention should be given to this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_leaves_branches_col(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_leaves_branches_col_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="get_leaves_branches_col_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the dendrogram's leaves' branches' colors
</p>


<h3>See Also</h3>

<p><a href="#topic+get_nodes_attr">get_nodes_attr</a>, <a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>, <a href="#topic+labels_colors">labels_colors</a>
<a href="#topic+get_leaves_nodePar">get_leaves_nodePar</a>, <a href="#topic+get_leaves_edgePar">get_leaves_edgePar</a>, <a href="#topic+get_leaves_branches_attr">get_leaves_branches_attr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)

par(mfrow = c(1, 2), mar = c(5, 2, 1, 0))
dend &lt;- dend %&gt;%
  color_branches(k = 3) %&gt;%
  set("branches_lwd", c(2, 1, 2)) %&gt;%
  set("branches_lty", c(1, 2, 1))

plot(dend)

labels_colors(dend) &lt;- get_leaves_branches_col(dend)
plot(dend)
</code></pre>

<hr>
<h2 id='get_leaves_edgePar'>Get edgePar of dendrogram's leaves</h2><span id='topic+get_leaves_edgePar'></span>

<h3>Description</h3>

<p>This is helpful to get the attributes of branches of the leaves.
For example, after we use <a href="#topic+color_branches">color_branches</a>, to get the colors
of the labels to match (since getting the colors of branches to match
those of the labels can be tricky).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_leaves_edgePar(dend, simplify = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_leaves_edgePar_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="get_leaves_edgePar_+3A_simplify">simplify</code></td>
<td>
<p>logical (default is FALSE). If TRUE, then the return vector is
after using <code>unlist</code> on it.</p>
</td></tr>
<tr><td><code id="get_leaves_edgePar_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (or a vector) with the dendrogram's leaves edgePar attribute
</p>


<h3>See Also</h3>

<p><a href="#topic+get_nodes_attr">get_nodes_attr</a>, <a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>, <a href="#topic+labels_colors">labels_colors</a>
<a href="#topic+get_leaves_nodePar">get_leaves_nodePar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)

# get_leaves_edgePar(dend) # error :)
get_leaves_edgePar(dend)
dend &lt;- color_branches(dend, k = 3)
get_leaves_edgePar(dend)
get_leaves_edgePar(dend, TRUE)

dend &lt;- dend %&gt;% set("branches_lwd", c(2, 1, 2))
get_leaves_edgePar(dend)

plot(dend)
</code></pre>

<hr>
<h2 id='get_leaves_nodePar'>Get nodePar of dendrogram's leaves</h2><span id='topic+get_leaves_nodePar'></span>

<h3>Description</h3>

<p>Get the nodePar attributes of dendrogram's leaves (includes pch, color, and cex)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_leaves_nodePar(dend, simplify = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_leaves_nodePar_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="get_leaves_nodePar_+3A_simplify">simplify</code></td>
<td>
<p>logical (default is FALSE). If TRUE, then the return vector is
after using <code>unlist</code> on it.</p>
</td></tr>
<tr><td><code id="get_leaves_nodePar_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (or a vector) with the dendrogram's leaves nodePar attribute
</p>


<h3>See Also</h3>

<p><a href="#topic+get_nodes_attr">get_nodes_attr</a>, <a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>, <a href="#topic+labels_colors">labels_colors</a>
<a href="#topic+get_leaves_edgePar">get_leaves_edgePar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)

# get_leaves_attr(dend) # error :)
get_leaves_nodePar(dend)
labels_colors(dend) &lt;- 1:3
get_leaves_nodePar(dend)

dend &lt;- assign_values_to_leaves_nodePar(dend, 2, "lab.cex")
get_leaves_nodePar(dend)

plot(dend)
</code></pre>

<hr>
<h2 id='get_nodes_attr'>Get attributes of dendrogram's nodes</h2><span id='topic+get_nodes_attr'></span>

<h3>Description</h3>

<p>Allows easy access to attributes of branches and/or leaves, with option
of returning a vector with/withough NA's (for marking the missing attr value)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nodes_attr(
  dend,
  attribute,
  id,
  include_leaves = TRUE,
  include_branches = TRUE,
  simplify = TRUE,
  na.rm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nodes_attr_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="get_nodes_attr_+3A_attribute">attribute</code></td>
<td>
<p>character scalar of the attribute (<code>attr</code>)
we wish to get from the nodes</p>
</td></tr>
<tr><td><code id="get_nodes_attr_+3A_id">id</code></td>
<td>
<p>integer vector. If given - only the attr of these nodes id will be returned (via depth first search)</p>
</td></tr>
<tr><td><code id="get_nodes_attr_+3A_include_leaves">include_leaves</code></td>
<td>
<p>logical. Should leaves attributes be included as well?</p>
</td></tr>
<tr><td><code id="get_nodes_attr_+3A_include_branches">include_branches</code></td>
<td>
<p>logical. Should non-leaf (branch node)
attributes be included as well?</p>
</td></tr>
<tr><td><code id="get_nodes_attr_+3A_simplify">simplify</code></td>
<td>
<p>logical (default is TRUE). should the result be simplified
to a vector (using <a href="base.html#topic+simplify2array">simplify2array</a> ) if possible? If it is not possible
it will return a matrix. When FALSE, a list is returned.</p>
</td></tr>
<tr><td><code id="get_nodes_attr_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should NA attributes be REMOVED from the resulting vector?</p>
</td></tr>
<tr><td><code id="get_nodes_attr_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the dendrogram's nodes attribute. If an attribute is missing
from some nodes, it will return NA in that vector.
</p>


<h3>Source</h3>

<p>Heavily inspired by the code in the
function <code>labels.dendrogram</code>,
so credit should go to Martin Maechler.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_leaves_attr">get_leaves_attr</a>, <a href="#topic+nnodes">nnodes</a>, <a href="#topic+nleaves">nleaves</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)

# get_leaves_attr(dend) # error :)
get_leaves_attr(dend, "label")
labels(dend, "label")
get_leaves_attr(dend, "height") # should be 0's
get_nodes_attr(dend, "height")


get_leaves_attr(dend, "leaf") # should be TRUE's
get_nodes_attr(dend, "leaf") # conatins NA's


get_leaves_attr(dend, "members") # should be 1's
get_nodes_attr(dend, "members", include_branches = FALSE, na.rm = TRUE) #
get_nodes_attr(dend, "members") #
get_nodes_attr(dend, "members", simplify = FALSE)
get_nodes_attr(dend, "members", include_leaves = FALSE, na.rm = TRUE) #

get_nodes_attr(dend, "members", id = c(1, 3), simplify = FALSE)
get_nodes_attr(dend, "members", id = c(1, 3)) #


hang_dend &lt;- hang.dendrogram(dend)
get_leaves_attr(hang_dend, "height") # no longer 0!
get_nodes_attr(hang_dend, "height") # does not include any 0s!

# does not include leaves values:
get_nodes_attr(hang_dend, "height", include_leaves = FALSE)
# remove leaves values all together:
get_nodes_attr(hang_dend, "height", include_leaves = FALSE, na.rm = TRUE)
## Not run: 
library(microbenchmark)
# get_leaves_attr is twice faster than get_nodes_attr
microbenchmark(
  get_leaves_attr(dend, "members"), # should be 1's
  get_nodes_attr(dend, "members", include_branches = FALSE, na.rm = TRUE)
)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_nodes_xy'>Get the x-y coordinates of a dendrogram's nodes</h2><span id='topic+get_nodes_xy'></span>

<h3>Description</h3>

<p>Get the x-y coordinates of a dendrogram's nodes. Can be used to add text or images on the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nodes_xy(
  dend,
  type = c("rectangle", "triangle"),
  center = FALSE,
  horiz = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nodes_xy_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="get_nodes_xy_+3A_type">type</code></td>
<td>
<p>type of plot.</p>
</td></tr>
<tr><td><code id="get_nodes_xy_+3A_center">center</code></td>
<td>
<p>logical; if TRUE, nodes are plotted centered with respect to the
leaves in the branch. Otherwise (default),
plot them in the middle of all direct child nodes.</p>
</td></tr>
<tr><td><code id="get_nodes_xy_+3A_horiz">horiz</code></td>
<td>
<p>logical indicating if the dendrogram should be drawn horizontally or not.</p>
</td></tr>
<tr><td><code id="get_nodes_xy_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-dimensional matrix, with rows as the number of nodes,
and the first column is the x location, while the second is the
y location.
</p>


<h3>Source</h3>

<p>This is a striped down version of the
function <code><a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a></code>.
It performs (almost) the same task, only it does not do any plotting
but it does save the x-y coordiantes of the nodes.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_nodes_attr">get_nodes_attr</a>, <a href="#topic+nnodes">nnodes</a>,
<a href="#topic+nleaves">nleaves</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# If we would like to see the numbers from plot:
# ?getOption("verbose")
# options(verbose=TRUE)
# options(verbose=FALSE)

# -----
# Draw a depth first search illustration
# -----

dend &lt;- 1:5 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
get_nodes_xy(dend)

# polygon(get_nodes_xy(dend), col = 2)
plot(dend,
  leaflab = "none",
  main = "Depth-first search in a dendrogram"
)
xy &lt;- get_nodes_xy(dend)
for (i in 1:(nrow(xy) - 1)) {
  arrows(xy[i, 1], xy[i, 2],
    angle = 17,
    length = .5,
    xy[i + 1, 1], xy[i + 1, 2],
    lty = 1, col = 3, lwd = 1.5
  )
}
points(xy, pch = 19, cex = 4)
text(xy, labels = 1:nnodes(dend), cex = 1.2, col = "white", adj = c(0.4, 0.4))

## End(Not run)
</code></pre>

<hr>
<h2 id='get_root_branches_attr'>get attributes from the dendrogram's root(!) branches</h2><span id='topic+get_root_branches_attr'></span>

<h3>Description</h3>

<p>get attributes from the dendrogram's root(!) branches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_root_branches_attr(dend, the_attr, warn = dendextend_options("warn"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_root_branches_attr_+3A_dend">dend</code></td>
<td>
<p>dendrogram object</p>
</td></tr>
<tr><td><code id="get_root_branches_attr_+3A_the_attr">the_attr</code></td>
<td>
<p>the attribute to get from the branches (for example &quot;height&quot;)</p>
</td></tr>
<tr><td><code id="get_root_branches_attr_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
Should a warning be printed when
the function is used on an object which is NOT a dendrogram.</p>
</td></tr>
<tr><td><code id="get_root_branches_attr_+3A_...">...</code></td>
<td>
<p>passed on to attr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The attributes of the branches (often two) of the dendrogram's root
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+attr">attr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[2:9, ]), "com")
dend &lt;- as.dendrogram(hc)

get_root_branches_attr(dend, "height") # 0.00000 71.96247
# plot(dend)
str(dend, 2)
</code></pre>

<hr>
<h2 id='get_subdendrograms'>Extract a list of <em>k</em> subdendrograms from a given dendrogram
object</h2><span id='topic+get_subdendrograms'></span>

<h3>Description</h3>

<p>Extracts a list (<a href="#topic+dendlist">dendlist</a>) of subdendrogram structures based on the cutree <code><a href="#topic+cutree.dendrogram">cutree.dendrogram</a></code> function
from a given dendrogram object. It can be useful in case we're interested in a visual investigation of 
specific clustering results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subdendrograms(dend, k, order_clusters_as_data = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subdendrograms_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="get_subdendrograms_+3A_k">k</code></td>
<td>
<p>the number of subdendrograms that should be extracted</p>
</td></tr>
<tr><td><code id="get_subdendrograms_+3A_order_clusters_as_data">order_clusters_as_data</code></td>
<td>
<p>passed to <a href="#topic+cutree">cutree</a>, default is FALSE 
(while the cutree default is TRUE). The reason is since it's easier to look at the dendrogram plot
and then get subtrees that are in the same order is in the plot/dendrogram object.
This is in contrast to more traditional use of cutree, where it is used with the original order or rows from the data.</p>
</td></tr>
<tr><td><code id="get_subdendrograms_+3A_...">...</code></td>
<td>
<p>parameters that should be passed to the cutree
<code><a href="#topic+cutree.dendrogram">cutree.dendrogram</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <em>k</em> subdendrograms, based on the cutree
<code><a href="#topic+cutree.dendrogram">cutree.dendrogram</a></code> clustering
clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# needed packages:
# install.packages(gplots)
# install.packages(viridis)
# install.packages(devtools)
# devtools::install_github('talgalili/dendextend') #' dendextend from github

# define dendrogram object to play with:
dend &lt;- iris[1:20, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  # set("labels_to_character") %&gt;%
  color_branches(k = 5)
labels(dend) &lt;- letters[1:20]
plot(dend)
dend_list &lt;- get_subdendrograms(dend, 5)
lapply(dend_list, labels)
# [[1]]
# [1] "a" "b"
# 
# [[2]]
# [1] "c" "d" "e" "f" "g"
# 
# [[3]]
# [1] "h" "i"
# 
# [[4]]
# [1] "j" "k" "l" "m"
# 
# [[5]]
# [1] "n" "o" "p" "q" "r" "s" "t"

# define dendrogram object to play with:
dend &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("labels_to_character") %&gt;%
  color_branches(k = 5)
dend_list &lt;- get_subdendrograms(dend, 5)

# Plotting the result
par(mfrow = c(2, 3))
plot(dend, main = "Original dendrogram")
sapply(dend_list, plot)

# plot a heatmap of only one of the sub dendrograms
par(mfrow = c(1, 1))
library(gplots)
sub_dend &lt;- dend_list[[1]] #' get the sub dendrogram
# make sure of the size of the dend
nleaves(sub_dend)
length(order.dendrogram(sub_dend))
# get the subset of the data
subset_iris &lt;- as.matrix(iris[order.dendrogram(sub_dend), -5])
# update the dendrogram's internal order so to not cause an error in heatmap.2
order.dendrogram(sub_dend) &lt;- as.integer(rank(order.dendrogram(sub_dend)))
heatmap.2(subset_iris, Rowv = sub_dend, trace = "none", col = viridis::viridis(100))
</code></pre>

<hr>
<h2 id='ggdend'>Creates dendrogram plot using ggplot.</h2><span id='topic+ggdend'></span><span id='topic+as.ggdend'></span><span id='topic+as.ggdend.dendrogram'></span><span id='topic+prepare.ggdend'></span><span id='topic+ggplot.ggdend'></span><span id='topic+ggplot.dendrogram'></span><span id='topic+print.ggdend'></span>

<h3>Description</h3>

<p>Several functions for creating a dendrogram plot using ggplot2.
The core process is to transform a dendrogram into a ggdend object using as.ggdend,
and then plot it using ggplot. These two steps can be done in one command with either the function
ggplot or ggdend.
</p>
<p>The reason we want to have as.ggdend (and not only ggplot.dendrogram), is (1) so that you could
create your own mapping of ggdend and, (2) since as.ggdend might be slow for large trees,
it is probably better to be able to run it only once for such cases.
</p>
<p>A ggdend class object is a list with 3 componants: segments, labels, nodes.
Each one contains the graphical parameters from the original dendrogram, but in a tabular form that
can be used by ggplot2+geom_segment+geom_text to create a dendrogram plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggdend(...)

as.ggdend(dend, ...)

## S3 method for class 'dendrogram'
as.ggdend(dend, type = c("rectangle", "triangle"), edge.root = FALSE, ...)

prepare.ggdend(data, ...)

## S3 method for class 'ggdend'
ggplot(
  data = NULL,
  mapping = aes(),
  ...,
  segments = TRUE,
  labels = TRUE,
  nodes = TRUE,
  horiz = FALSE,
  theme = theme_dendro(),
  offset_labels = 0,
  na.rm = TRUE,
  environment = parent.frame()
)

## S3 method for class 'dendrogram'
ggplot(data, ...)

## S3 method for class 'ggdend'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggdend_+3A_...">...</code></td>
<td>
<p>mostly ignored.</p>
</td></tr>
<tr><td><code id="ggdend_+3A_dend">dend</code></td>
<td>
<p>a <a href="stats.html#topic+dendrogram">dendrogram</a> tree (to be turned into a ggdend object)</p>
</td></tr>
<tr><td><code id="ggdend_+3A_type">type</code></td>
<td>
<p>The type of plot, indicating the shape of the dendrogram.  &quot;rectangle&quot; will draw
rectangular lines, while &quot;triangle&quot; will draw triangular lines.</p>
</td></tr>
<tr><td><code id="ggdend_+3A_edge.root">edge.root</code></td>
<td>
<p>currently ignored. One day it might do the following: logical; if true, draw an edge to the root node.</p>
</td></tr>
<tr><td><code id="ggdend_+3A_data">data</code>, <code id="ggdend_+3A_x">x</code></td>
<td>
<p>a ggdend class object (passed to ggplot.dendrogram or print.ggdend).</p>
</td></tr>
<tr><td><code id="ggdend_+3A_mapping">mapping</code></td>
<td>
<p>(passed in ggplot.ggdend) Default list of aesthetic mappings to use for plot. If not specified, must be supplied in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggdend_+3A_segments">segments</code></td>
<td>
<p>a logical (TRUE) if to plot the segments (branches).</p>
</td></tr>
<tr><td><code id="ggdend_+3A_labels">labels</code></td>
<td>
<p>a logical (TRUE) if to plot the labels.</p>
</td></tr>
<tr><td><code id="ggdend_+3A_nodes">nodes</code></td>
<td>
<p>a logical (TRUE) if to plot the nodes (points).</p>
</td></tr>
<tr><td><code id="ggdend_+3A_horiz">horiz</code></td>
<td>
<p>a logical (TRUE) indicating if the dendrogram should be drawn horizontally or not.</p>
</td></tr>
<tr><td><code id="ggdend_+3A_theme">theme</code></td>
<td>
<p>the ggplot2 theme to use (default is <a href="#topic+theme_dendro">theme_dendro</a>, can also be NULL
for the default ggplot2 theme)</p>
</td></tr>
<tr><td><code id="ggdend_+3A_offset_labels">offset_labels</code></td>
<td>
<p>a numeric value to offset the labels from the leaves</p>
</td></tr>
<tr><td><code id="ggdend_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical (TRUE) to control removal of missing values. Passed to
<a href="ggplot2.html#topic+geom_line">geom_line</a> and <a href="ggplot2.html#topic+geom_point">geom_point</a></p>
</td></tr>
<tr><td><code id="ggdend_+3A_environment">environment</code></td>
<td>
<p>(passed in ggplot.ggdend) deprecated / ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prepare.ggdend</code> is used by <code>plot.ggdend</code> to take the <code>ggdend</code> object
and prepare it for plotting. This is because the defaults of various parameters in <a href="stats.html#topic+dendrogram">dendrogram</a>'s
are not always stored in the object itself, but are built-in into the <a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a> function.
For example, the color of the labels is not (by default) specified in the dendrogram (only if we change it
from black to something else). Hence, when taking the object into a different plotting engine (say ggplot2), we
want to prepare the object by filling-in various defaults.
This function is autmatically invoked within the <code>plot.ggdend</code> function. You would probably use
it only if you'd wish to build your own ggplot2 mapping.
</p>


<h3>Value</h3>


<ul>
<li><p><code>as.ggdend</code> - returns an object of class ggdend which is a list with 3 componants: segments, labels, nodes.
Each one contains the graphical parameters from the original dendrogram, but in a tabular form that
can be used by ggplot2+geom_segment+geom_text to create a dendrogram plot.
</p>
</li>
<li><p><code>prepare.ggdend</code> - a <code>ggdend</code> object (after filling it with various default values)
</p>
</li>
<li><p><code>ggplot.ggdend</code> - a <a href="ggplot2.html#topic+ggplot">ggplot</a> object
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tal Galili, using code modified from Andrie de Vries
</p>


<h3>Source</h3>

<p>These are extended versions of the functions <a href="ggdendro.html#topic+ggdendrogram">ggdendrogram</a>, <a href="ggdendro.html#topic+dendro_data">dendro_data</a> (and the hidden dendrogram_data)
from Andrie de Vries's ggdendro package. The motivation for this fork is the need to add more graphical parameters
to the plotted tree. This required a strong mixter of functions from ggdendro and dendextend (to the point that
it seemed better to just fork the code into its current form)
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+dendrogram">dendrogram</a>, <a href="#topic+get_nodes_attr">get_nodes_attr</a>, <a href="#topic+get_leaves_nodePar">get_leaves_nodePar</a>,
<a href="ggplot2.html#topic+ggplot">ggplot</a>,
<a href="ggdendro.html#topic+ggdendrogram">ggdendrogram</a>, <a href="ggdendro.html#topic+dendro_data">dendro_data</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(dendextend)
# library(ggdendro)
# Create a complex dend:
dend &lt;- iris[1:30, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("branches_k_color", k = 3) %&gt;%
  set("branches_lwd", c(1.5, 1, 1.5)) %&gt;%
  set("branches_lty", c(1, 1, 3, 1, 1, 2)) %&gt;%
  set("labels_colors") %&gt;%
  set("labels_cex", c(.9, 1.2))
# plot the dend in usual "base" plotting engine:
plot(dend)
# Now let's do it in ggplot2 :)
ggd1 &lt;- as.ggdend(dend)
library(ggplot2)
ggplot(ggd1) # reproducing the above plot in ggplot2 :)

# Triangle version:
plot(dend, type = "triangle")
ggd2 &lt;- as.ggdend(dend, type = "triangle")
ggplot(ggd2) 


# More modifications:
labels(dend) &lt;- paste0(labels(dend), "00000")
ggd1 &lt;- as.ggdend(dend)
# Use ylim to deal with long labels in ggplot2
ggplot(ggd1) + ylim(-.4, max(get_branches_heights(dend)))


ggplot(ggd1, horiz = TRUE) # horiz plot in ggplot2
# Adding some extra spice to it...
# creating a radial plot:
ggplot(ggd1) + scale_y_reverse(expand = c(0.2, 0)) + coord_polar(theta = "x")
# The text doesn't look so great, so let's remove it:
ggplot(ggd1, labels = FALSE) + scale_y_reverse(expand = c(0.2, 0)) + coord_polar(theta = "x")

# This can now be sent to plot.ly - which adds zoom-in abilities, and more.
# Here is how it might look like: https://plot.ly/~talgalili/6/y-vs-x/

## Quick guide:
# install.packages("devtools")
# library("devtools")
# devtools::install_github("ropensci/plotly")
# library(plotly)
# set_credentials_file(...)
# you'll need to get it from here: https://plot.ly/ggplot2/getting-started/

# ggplot(ggd1)
# py &lt;- plotly()
# py$ggplotly()

# And you'll get something like this: https://plot.ly/~talgalili/6/y-vs-x/

# Another example: https://plot.ly/ggplot2/

## End(Not run)
</code></pre>

<hr>
<h2 id='hang.dendrogram'>Hang dendrogram leaves</h2><span id='topic+hang.dendrogram'></span>

<h3>Description</h3>

<p>Adjust the height attr in all of the dendrogram leaves so that
the tree will hang. This is similar to as.dendrogram(hclust, hang=0.1)
Only that it now works on other object than hclust turned into a dendrogram.
For example, this allows us to hang non-binary trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hang.dendrogram(dend, hang = 0.1, hang_height, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hang.dendrogram_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="hang.dendrogram_+3A_hang">hang</code></td>
<td>
<p>The fraction of the plot height by which labels should hang below
the rest of the plot. A negative value will cause the labels to
hang down from 0.</p>
</td></tr>
<tr><td><code id="hang.dendrogram_+3A_hang_height">hang_height</code></td>
<td>
<p>is missing, then using &quot;hang&quot;. If a number is given,
it overrides &quot;hang&quot; (except if &quot;hang&quot; is negative)</p>
</td></tr>
<tr><td><code id="hang.dendrogram_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after adjusting the height attr in all of its leaves,
so that the tree will hang.
</p>


<h3>Source</h3>

<p>Noticing that as.dendrogram has a &quot;hang&quot; parameter was thanks to Enrique Ramos's answer here::
<a href="https://stackoverflow.com/questions/17088136/plot-horizontal-dendrogram-with-hanging-leaves-r">https://stackoverflow.com/questions/17088136/plot-horizontal-dendrogram-with-hanging-leaves-r</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)

par(mfrow = c(1, 2))
plot(hang.dendrogram(dend))
plot(hc)
# identical(as.dendrogram(hc, hang = 0.1), hang.dendrogram(dend, hang = 0.1))
# TRUE!!


par(mfrow = c(1, 4))

plot(dend)
plot(hang.dendrogram(dend, hang = 0.1))
plot(hang.dendrogram(dend, hang = 0))
plot(hang.dendrogram(dend, hang = -0.1))

par(mfrow = c(1, 1))
plot(hang.dendrogram(dend), horiz = TRUE)
</code></pre>

<hr>
<h2 id='has_component_in_attribute'>Does a dendrogram has an edgePar/nodePar component?</h2><span id='topic+has_component_in_attribute'></span><span id='topic+has_edgePar'></span><span id='topic+has_nodePar'></span>

<h3>Description</h3>

<p>Does a dendrogram has an edgePar/nodePar component?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_component_in_attribute(dend, component, the_attrib = "edgePar", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_component_in_attribute_+3A_dend">dend</code></td>
<td>
<p>a <a href="stats.html#topic+dendrogram">dendrogram</a> object.</p>
</td></tr>
<tr><td><code id="has_component_in_attribute_+3A_component">component</code></td>
<td>
<p>a character value to be checked if exists in the tree. For edgePar the list: &quot;col&quot;, &quot;lty&quot; and &quot;lwd&quot; (for the segments),
&quot;p.col&quot;, &quot;p.lwd&quot;, and &quot;p.lty&quot; (for the polygon around the text) and &quot;t.col&quot; for the text color.
For edgePar &quot;pch&quot;, &quot;cex&quot;, &quot;col&quot;, &quot;xpd&quot;, and/or &quot;bg&quot;.</p>
</td></tr>
<tr><td><code id="has_component_in_attribute_+3A_the_attrib">the_attrib</code></td>
<td>
<p>A character of the attribute for which to check the existence of the component.
Often either &quot;edgePar&quot; or &quot;nodePar&quot;.</p>
</td></tr>
<tr><td><code id="has_component_in_attribute_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. TRUE if such a component is defined somewhere in the tree, FALSE otherwise.
If dend is not a dendrogram, the function will return FALSE.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_nodes_attr">get_nodes_attr</a>, <a href="#topic+set">set</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- iris[1:20, -5]
hca &lt;- hclust(dist(dat))
hca2 &lt;- hclust(dist(dat), method = "single")
dend &lt;- as.dendrogram(hca)
dend2 &lt;- as.dendrogram(hca2)

dend %&gt;%
  set("branches_lwd", 2) %&gt;%
  set("branches_lty", 2) %&gt;%
  plot()
dend %&gt;%
  set("branches_lwd", 2) %&gt;%
  set("branches_lty", 2) %&gt;%
  has_edgePar("lty")
dend %&gt;%
  set("branches_lwd", 2) %&gt;%
  has_edgePar("lty")
dend %&gt;%
  set("branches_lwd", 2) %&gt;%
  has_edgePar("lwd")

dend %&gt;%
  set("branches_lwd", 2) %&gt;%
  set("clear_branches") %&gt;%
  has_edgePar("lwd")
</code></pre>

<hr>
<h2 id='heights_per_k.dendrogram'>Which height will result in which k for a dendrogram</h2><span id='topic+heights_per_k.dendrogram'></span><span id='topic+dendextend_heights_per_k.dendrogram'></span>

<h3>Description</h3>

<p>Which height will result in which k for a dendrogram.
This helps with speeding up the <a href="#topic+cutree.dendrogram">cutree.dendrogram</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heights_per_k.dendrogram(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heights_per_k.dendrogram_+3A_dend">dend</code></td>
<td>
<p>a dendrogram.</p>
</td></tr>
<tr><td><code id="heights_per_k.dendrogram_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of heights, with its names being the k clusters that will
result for cutting the dendrogram at each height.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hc &lt;- hclust(dist(USArrests[1:4, ]), "ave")
dend &lt;- as.dendrogram(hc)
heights_per_k.dendrogram(dend)
##       1        2        3        4
## 86.47086 68.84745 45.98871 28.36531

cutree(hc, h = 68.8) # and indeed we get 2 clusters

unbranch_dend &lt;- unbranch(dend, 2)
plot(unbranch_dend)
heights_per_k.dendrogram(unbranch_dend)
# 1        3        4
# 97.90023 57.41808 16.93594
# we do NOT have a height for k=2 because of the tree's structure.


## End(Not run)
</code></pre>

<hr>
<h2 id='highlight_branches_col'>Highlight a dendrogram's branches heights via color and line-width</h2><span id='topic+highlight_branches_col'></span><span id='topic+highlight_branches_lwd'></span><span id='topic+highlight_branches'></span>

<h3>Description</h3>

<p>Highlights (update) the color (col) and/or line width (lwd) of each branch in
a dendrogram based on it's node's height.
This is a powerful pre-processing for a <a href="#topic+tanglegram">tanglegram</a> plot of two dendrograms, as
it emphasizes the toplogical structure of each tree (and hence, their similarity and differences).
</p>
<p>The colors are based on the viridis pallette, and the line width is on the range of 1 to 10.
These can be manually changed when using highlight_branches_col and highlight_branches_lwd
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight_branches_col(dend, values = rev(viridis(1000, end = 0.9)), ...)

highlight_branches_lwd(dend, values = seq(1, 10, length.out = 1000), ...)

highlight_branches(dend, type = c("col", "lwd"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="highlight_branches_col_+3A_dend">dend</code></td>
<td>
<p>a <a href="stats.html#topic+dendrogram">dendrogram</a> tree (to be turned into a ggdend object)</p>
</td></tr>
<tr><td><code id="highlight_branches_col_+3A_values">values</code></td>
<td>
<p>the gradient of values to be used for each branch.
The colors are based on the viridis pallette, and the line width is on the range of 1 to 10.
These can be manually changed when using highlight_branches_col and highlight_branches_lwd
respectively.</p>
</td></tr>
<tr><td><code id="highlight_branches_col_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="highlight_branches_col_+3A_type">type</code></td>
<td>
<p>a character vector. Either &quot;col&quot;, &quot;lwd&quot;, or both. Based on
whichever is chosen the dendrogram's branches will be updated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <a href="stats.html#topic+dendrogram">dendrogram</a>, with colors/line-width in the branches
that are proportional to each branche's height (measured by its lower tip).
</p>


<h3>See Also</h3>

<p><a href="#topic+set">set</a>, <a href="#topic+color_branches">color_branches</a>, <a href="#topic+get_branches_heights">get_branches_heights</a>,
<a href="viridis.html#topic+viridis">viridis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dat &lt;- iris[1:20, -5]
hca &lt;- hclust(dist(dat))
hca2 &lt;- hclust(dist(dat), method = "single")
dend &lt;- as.dendrogram(hca)
dend2 &lt;- as.dendrogram(hca2)

par(mfrow = c(1, 3))
dend %&gt;%
  highlight_branches_col() %&gt;%
  plot(main = "Coloring branches")
dend %&gt;%
  highlight_branches_lwd() %&gt;%
  plot(main = "Emphasizing line-width")
dend %&gt;%
  highlight_branches() %&gt;%
  plot(main = "Emphasizing color\n and line-width")

library(viridis)
par(mfrow = c(1, 3))
dend %&gt;%
  highlight_branches_col() %&gt;%
  plot(main = "Coloring branches \n(default is reversed viridis)")
dend %&gt;%
  highlight_branches_col(viridis(100)) %&gt;%
  plot(main = "It is better to use\nlighter colors in the leaves")
dend %&gt;%
  highlight_branches_col(rev(magma(1000))) %&gt;%
  plot(main = "The magma color pallatte\n is also good")

dl &lt;- dendlist(dend, dend2)
tanglegram(dl,
  sort = TRUE, common_subtrees_color_lines = FALSE,
  highlight_distinct_edges = FALSE, highlight_branches_lwd = FALSE
)
tanglegram(dl)
tanglegram(dl, fast = TRUE)

dl &lt;- dendlist(highlight_branches(dend), highlight_branches(dend2))
tanglegram(dl, sort = TRUE, common_subtrees_color_lines = FALSE, highlight_distinct_edges = FALSE)

dend %&gt;%
  set("highlight_branches_col") %&gt;%
  plot()

dl &lt;- dendlist(dend, dend2) %&gt;% set("highlight_branches_col")
tanglegram(dl, sort = TRUE, common_subtrees_color_lines = FALSE, highlight_distinct_edges = FALSE)


# This is also useful for heatmaps
# --------------------------
# library(dendextend)

x &lt;- as.matrix(datasets::mtcars)

Rowv &lt;- x %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("branches_k_color", k = 3) %&gt;%
  set("highlight_branches_lwd") %&gt;%
  ladderize()
#    rotate_DendSer(ser_weight = dist(x))
Colv &lt;- x %&gt;%
  t() %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("branches_k_color", k = 2) %&gt;%
  set("highlight_branches_lwd") %&gt;%
  ladderize()
#    rotate_DendSer(ser_weight = dist(t(x)))

library(gplots)
heatmap.2(x, Rowv = Rowv, Colv = Colv)
</code></pre>

<hr>
<h2 id='highlight_distinct_edges'>Highlight distint edges in a tree (compared to another one)</h2><span id='topic+highlight_distinct_edges'></span><span id='topic+highlight_distinct_edges.dendrogram'></span><span id='topic+highlight_distinct_edges.dendlist'></span>

<h3>Description</h3>

<p>Highlight distint edges in a tree (compared to another one) by changing
the branches' color, line width, or line type.
</p>
<p>This function enables this feature in <a href="#topic+dend_diff">dend_diff</a> and <a href="#topic+tanglegram">tanglegram</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight_distinct_edges(dend, ...)

## S3 method for class 'dendrogram'
highlight_distinct_edges(
  dend,
  dend2,
  value = 2,
  edgePar = c("col", "lty", "lwd"),
  ...
)

## S3 method for class 'dendlist'
highlight_distinct_edges(dend, ..., which = c(1L, 2L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="highlight_distinct_edges_+3A_dend">dend</code></td>
<td>
<p>a dendrogram or <a href="#topic+dendlist">dendlist</a> to find unique edges in (to highlight)</p>
</td></tr>
<tr><td><code id="highlight_distinct_edges_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="highlight_distinct_edges_+3A_dend2">dend2</code></td>
<td>
<p>a dendrogram to compare with</p>
</td></tr>
<tr><td><code id="highlight_distinct_edges_+3A_value">value</code></td>
<td>
<p>a new value scalar for the edgePar attribute.</p>
</td></tr>
<tr><td><code id="highlight_distinct_edges_+3A_edgepar">edgePar</code></td>
<td>
<p>a character indicating the value inside edgePar to adjust.
Can be either &quot;col&quot;, &quot;lty&quot;, or &quot;lwd&quot;.</p>
</td></tr>
<tr><td><code id="highlight_distinct_edges_+3A_which">which</code></td>
<td>
<p>an integer vector indicating, in the case &quot;dend&quot; is a dendlist,
on which of the trees should the modification be performed.
If missing - the change will be performed on all of objects in the dendlist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram with modified edges - the distinct ones are changed (color, line width, or line type)
</p>


<h3>See Also</h3>

<p><a href="#topic+distinct_edges">distinct_edges</a>, <a href="#topic+highlight_distinct_edges">highlight_distinct_edges</a>,
<a href="#topic+dist.dendlist">dist.dendlist</a>, <a href="#topic+tanglegram">tanglegram</a>
<a href="#topic+assign_values_to_branches_edgePar">assign_values_to_branches_edgePar</a>,
<a href="distory.html#topic+distinct.edges">distinct.edges</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:5 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
y &lt;- set(x, "labels", 5:1)
distinct_edges(x, y)
distinct_edges(y, x)

par(mfrow = c(1, 2))
plot(highlight_distinct_edges(x, y))
plot(y)

# tanglegram(highlight_distinct_edges(x, y),y)
# dend_diff(x, y)
## Not run: 

# using  highlight_distinct_edges combined with dendlist and set
# to clearly highlight "stable" branches.
data(iris)
ss &lt;- c(1:5, 51:55, 101:105)
iris1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust(method = "single") %&gt;%
  as.dendrogram()
iris2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust(method = "complete") %&gt;%
  as.dendrogram()
iris12 &lt;- dendlist(iris1, iris2) %&gt;%
  set("branches_k_color", k = 3) %&gt;%
  set("branches_lwd", 3) %&gt;%
  highlight_distinct_edges(value = 1, edgePar = "lwd")
iris12 %&gt;%
  untangle(method = "step2side") %&gt;%
  tanglegram(
    sub = "Iris dataset", main_left = "'single' clustering",
    main_right = "'complete' clustering"
  )

## End(Not run)

</code></pre>

<hr>
<h2 id='identify.dendrogram'>Identify Clusters in a Dendrogram (not hclust)</h2><span id='topic+identify.dendrogram'></span>

<h3>Description</h3>

<p>Just like <a href="stats.html#topic+identify.hclust">identify.hclust</a>:
reads the position of the graphics pointer when the (first)
mouse button is pressed. It then cuts the tree at the vertical
position of the pointer and highlights the cluster containing
the horizontal position of the pointer. Optionally a function is applied
to the index of data points contained in the cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dendrogram'
identify(
  x,
  FUN = NULL,
  N = 20,
  MAXCLUSTER,
  DEV.FUN = NULL,
  horiz = FALSE,
  stop_if_out = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.dendrogram_+3A_x">x</code></td>
<td>
<p>a <a href="stats.html#topic+dendrogram">dendrogram</a> object.</p>
</td></tr>
<tr><td><code id="identify.dendrogram_+3A_fun">FUN</code></td>
<td>
<p>(optional) function to be applied to the index numbers of the
data points in a cluster (see 'Details' below).</p>
</td></tr>
<tr><td><code id="identify.dendrogram_+3A_n">N</code></td>
<td>
<p>the maximum number of clusters to be identified.</p>
</td></tr>
<tr><td><code id="identify.dendrogram_+3A_maxcluster">MAXCLUSTER</code></td>
<td>
<p>the maximum number of clusters that can be produced by
a cut (limits the effective vertical range of the pointer).</p>
</td></tr>
<tr><td><code id="identify.dendrogram_+3A_dev.fun">DEV.FUN</code></td>
<td>
<p>(optional) integer scalar. If specified, the corresponding
graphics device is made active before FUN is applied.</p>
</td></tr>
<tr><td><code id="identify.dendrogram_+3A_horiz">horiz</code></td>
<td>
<p>logical (FALSE), indicating if the rectangles
should be drawn horizontally or not (for when using
plot(dend, horiz = TRUE) ) .</p>
</td></tr>
<tr><td><code id="identify.dendrogram_+3A_stop_if_out">stop_if_out</code></td>
<td>
<p>logical (default is FALSE). This default makes the function
NOT stop if k of the locator is outside the range (this default is different than the behavior
of the identify.hclust function - but it is nicer for the user.).</p>
</td></tr>
<tr><td><code id="identify.dendrogram_+3A_...">...</code></td>
<td>
<p>further arguments to FUN.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default clusters can be identified using the mouse and an invisible
list of indices of the respective data points is returned.
If FUN is not NULL, then the index vector of data points is passed to this
function as first argument, see the examples below. The active
graphics device for FUN can be specified using DEV.FUN.
The identification process is terminated by pressing any mouse button other
than the first, see also identify.
</p>


<h3>Value</h3>

<p>(Invisibly) returns a list where each element contains a vector
of data points contained in the respective cluster.
</p>


<h3>Source</h3>

<p>This function is based on <a href="stats.html#topic+identify.hclust">identify.hclust</a>, with slight modifications
to have it work with a dendrogram, as well as adding &quot;horiz&quot;
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+identify.hclust">identify.hclust</a>,
<a href="stats.html#topic+rect.hclust">rect.hclust</a>, <a href="stats.html#topic+order.dendrogram">order.dendrogram</a>, <a href="#topic+cutree.dendrogram">cutree.dendrogram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(23235)
ss &lt;- sample(1:150, 10)
hc &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust()
dend &lt;- hc %&gt;% as.dendrogram()

plot(dend)
identify(dend)

plot(dend, horiz = TRUE)
identify(dend, horiz = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='intersect_trees'>Intersect trees</h2><span id='topic+intersect_trees'></span>

<h3>Description</h3>

<p>Return two trees after pruning them so that the only leaves left are the intersection of their labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect_trees(dend1, dend2, warn = dendextend_options("warn"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect_trees_+3A_dend1">dend1</code></td>
<td>
<p>tree object (dendrogram/hclust/phylo)</p>
</td></tr>
<tr><td><code id="intersect_trees_+3A_dend2">dend2</code></td>
<td>
<p>tree object (dendrogram/hclust/phylo)</p>
</td></tr>
<tr><td><code id="intersect_trees_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
Should a warning be issued if there was a need to perform intersaction.</p>
</td></tr>
<tr><td><code id="intersect_trees_+3A_...">...</code></td>
<td>
<p>passed on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+dendlist">dendlist</a> with two pruned trees
</p>


<h3>See Also</h3>

<p><a href="#topic+prune">prune</a>, <a href="base.html#topic+intersect">intersect</a>, <a href="base.html#topic+labels">labels</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)
labels(dend) &lt;- 1:5
dend1 &lt;- prune(dend, 1)
dend2 &lt;- prune(dend, 5)
intersect_dend &lt;- intersect_trees(dend1, dend2)

layout(matrix(c(1, 1, 2, 3, 4, 5), 3, 2, byrow = TRUE))
plot(dend, main = "Original tree")
plot(dend1, main = "Tree 1:\n original with label 1 pruned")
plot(dend2, main = "Tree 2:\n original with label 2 pruned")
plot(intersect_dend[[1]],
  main = "Tree 1 pruned
      with the labels that intersected with those of Tree 2"
)
plot(intersect_dend[[2]],
  main = "Tree 2 pruned
      with the labels that intersected with those of Tree 1"
)
</code></pre>

<hr>
<h2 id='is_null_list'>Checks if the value is and empty list()</h2><span id='topic+is_null_list'></span>

<h3>Description</h3>

<p>Checks if the value is and empty list(). Can be useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_null_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_null_list_+3A_x">x</code></td>
<td>
<p>whatever object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'># I can run this only if I'd make is_null_list exported
## Not run: 
# TRUE:
is_null_list(list())
# FALSE
is_null_list(list(1))
is_null_list(1)

x &lt;- list(1, list(), 123)
ss_list &lt;- sapply(x, is_null_list)
x &lt;- x[!ss_list]
x

x &lt;- list(1, list(), 123)
ss_list &lt;- sapply(x, is_null_list)
x &lt;- list(list())
x

## End(Not run)

## Not run: 
# error
is_null_list()

## End(Not run)
</code></pre>

<hr>
<h2 id='is_some_class'>Is the object of some class</h2><span id='topic+is_some_class'></span><span id='topic+is.hclust'></span><span id='topic+is.dendrogram'></span><span id='topic+is.phylo'></span><span id='topic+is.dendlist'></span><span id='topic+is.dist'></span>

<h3>Description</h3>

<p>Returns TRUE if some class (based on the name of the function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.hclust(x)

is.dendrogram(x)

is.phylo(x)

is.dendlist(x)

is.dist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_some_class_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if some class (based on the name of the function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TRUE:
is.dendlist(dendlist())
# FALSE
is.dendlist(1)
# TRUE:
is.dist(dist(mtcars))
# FALSE
is.dist(mtcars)
</code></pre>

<hr>
<h2 id='is.natural.number'>Check if numbers are natural</h2><span id='topic+is.natural.number'></span>

<h3>Description</h3>

<p>Vectorized function for checking if numbers are natural or not.
Helps in checking if a vector is of type &quot;order&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.natural.number(x, tol = .Machine$double.eps^0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.natural.number_+3A_x">x</code></td>
<td>
<p>a vector of numbers</p>
</td></tr>
<tr><td><code id="is.natural.number_+3A_tol">tol</code></td>
<td>
<p>tolerence to floating point issues.</p>
</td></tr>
<tr><td><code id="is.natural.number_+3A_...">...</code></td>
<td>
<p>(not currently in use)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical - is the entered number natural or not.
</p>


<h3>Author(s)</h3>

<p>Marco Gallotta (a.k.a: marcog), Tal Galili
</p>


<h3>Source</h3>

<p>This function was written by marcog, as an answer to my question here:
<a href="https://stackoverflow.com/questions/4562257/what-is-the-fastest-way-to-check-if-a-number-is-a-positive-natural-number-in-r">https://stackoverflow.com/questions/4562257/what-is-the-fastest-way-to-check-if-a-number-is-a-positive-natural-number-in-r</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.numeric">is.numeric</a></code>, <code><a href="base.html#topic+is.double">is.double</a></code>, <code><a href="base.html#topic+is.integer">is.integer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.natural.number(1) # is TRUE
(x &lt;- seq(-1, 5, by = 0.5))
is.natural.number(x)
# is.natural.number( "a" )
all(is.natural.number(x))
</code></pre>

<hr>
<h2 id='khan'>Microarray gene expression dataset from Khan et al., 2001. Subset of 306 genes.</h2><span id='topic+khan'></span>

<h3>Description</h3>

<p>Khan contains gene expression profiles of four types of small round
blue cell tumours of childhood (SRBCT) published by Khan et al. (2001).
It also contains further gene annotation retrieved from SOURCE at <a href="http://source.stanford.edu/">http://source.stanford.edu/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>khan
</code></pre>


<h3>Format</h3>

<p>Khan is dataset containing the following:
</p>

<ul>
<li><p>train:<code><a href="base.html#topic+data.frame">data.frame</a></code> of 306 rows and 64 columns.
The training dataset of 64 arrays and 306 gene expression values
</p>
</li>
<li><p>test:<code><a href="base.html#topic+data.frame">data.frame</a></code>, of 306 rows and 25 columns.
The test dataset of 25 arrays and 306 genes expression values
</p>
</li>
<li><p>gene.labels.imagesID:<code>vector</code> of 306 Image clone identifiers
corresponding to the rownames of train and test.
</p>
</li>
<li><p>train.classes:<code><a href="base.html#topic+factor">factor</a></code> with 4 levels &quot;EWS&quot;,
&quot;BL-NHL&quot;, &quot;NB&quot; and &quot;RMS&quot;, which correspond to the four groups in
the train dataset
</p>
</li>
<li><p>test.classes:<code><a href="base.html#topic+factor">factor</a></code> with 5 levels &quot;EWS&quot;,
&quot;BL-NHL&quot;, &quot;NB&quot;, &quot;RMS&quot; and &quot;Norm&quot; which correspond to the five
groups in the test dataset
</p>
</li>
<li><p>annotation:<code><a href="base.html#topic+data.frame">data.frame</a></code> of 306 rows and 8 columns.
This table contains further gene annotation retrieved from SOURCE
<a href="http://SOURCE.stanford.edu">http://SOURCE.stanford.edu</a> in May 2004.  For each of the 306 genes,
it contains: </p>

<ul>
<li><p>CloneIDImage Clone ID
</p>
</li>
<li><p>UGClusterThe Unigene cluster to which the gene is assigned
</p>
</li>
<li><p>SymbolThe HUGO gene symbol
</p>
</li>
<li><p>LLIDThe locus ID
</p>
</li>
<li><p>UGRepAccNucleotide sequence accession number
</p>
</li>
<li><p>LLRepProtAccProtein sequence accession number
</p>
</li>
<li><p>Chromosomechromosome location
</p>
</li>
<li><p>Cytobandcytoband location
</p>
</li></ul>


</li></ul>



<h3>Details</h3>

<p>Khan et al., 2001 used cDNA microarrays containing 6567 clones of which
3789 were known genes and 2778 were ESTs to study the expression of
genes in of four types of small round blue cell tumours of childhood (SRBCT).
These were neuroblastoma (NB), rhabdomyosarcoma (RMS), Burkitt lymphoma, a
subset of non-Hodgkin lymphoma (BL), and the Ewing family of tumours
(EWS). Gene expression profiles from both tumour biopsy and cell line
samples were obtained and are contained in this dataset. The dataset downloaded
from the website contained the filtered dataset of 2308 gene expression profiles as described
by Khan et al., 2001.  This dataset is available from the <a href="http://bioinf.ucd.ie/people/aedin/R/">http://bioinf.ucd.ie/people/aedin/R/</a>.
</p>
<p>In order to reduce the size of the MADE4 package, and produce small example datasets, the top 50 genes from the
ends of 3 axes following <code>bga</code> were selected. This produced a reduced datasets of 306 genes.
</p>


<h3>Source</h3>

<p><code>khan</code> contains a filtered data of 2308 gene expression profiles
as published and provided by Khan et al. (2001) on the supplementary
web site to their publication
OLD (site no longer found): https://research.nhgri.nih.gov/microarray/
</p>
<p>The data was copied from the made4 package (<a href="https://www.bioconductor.org/packages/release/bioc/html/made4.html">https://www.bioconductor.org/packages/release/bioc/html/made4.html</a>)
</p>


<h3>References</h3>

<p>Culhane AC, et al., 2002 Between-group analysis of microarray
data. Bioinformatics. 18(12):1600-8.
</p>
<p>Khan,J., Wei,J.S., Ringner,M., Saal,L.H., Ladanyi,M., Westermann,F.,
Berthold,F., Schwab,M., Antonescu,C.R., Peterson,C. et al. (2001) Classification and diagnostic
prediction of cancers using gene expression profiling and artificial neural networks.
Nat. Med., 7, 673-679.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(khan)
summary(khan)
</code></pre>

<hr>
<h2 id='labels_cex'>Retrieve/assign cex to the labels of a dendrogram</h2><span id='topic+labels_cex'></span><span id='topic+labels_cex+3C-'></span>

<h3>Description</h3>

<p>Retrieve/assign cex to the labels of a dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels_cex(dend, ...)

labels_cex(dend, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_cex_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="labels_cex_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="labels_cex_+3A_value">value</code></td>
<td>
<p>a vector of cex to be used as new label's size for the dendrogram</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the dendrogram's labels sizes (NULL if none are supplied).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
dend &lt;- as.dendrogram(hclust(dist(USArrests[1:3, ]), "ave"))

# Defaults:
labels_cex(dend)
plot(dend)

# let's add some color:
labels_cex(dend) &lt;- 1:3
labels_cex(dend)
plot(dend)

labels_cex(dend) &lt;- 1
labels_cex(dend)
plot(dend)
</code></pre>

<hr>
<h2 id='labels_colors'>Retrieve/assign colors to the labels of a dendrogram</h2><span id='topic+labels_colors'></span><span id='topic+labels_col'></span><span id='topic+labels_colors+3C-'></span>

<h3>Description</h3>

<p>Retrieve/assign colors to the labels of a dendrogram. Note that usually dend objects come without any color assignment (and the output will be NULL, until colors are assigned).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels_colors(dend, labels = TRUE, ...)

labels_col(dend, labels = TRUE, ...)

labels_colors(dend, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_colors_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="labels_colors_+3A_labels">labels</code></td>
<td>
<p>Boolean (default is TRUE), should the returned vector of colors
return with the leaves labels as names.</p>
</td></tr>
<tr><td><code id="labels_colors_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="labels_colors_+3A_value">value</code></td>
<td>
<p>a vector of colors to be used as new label's colors for the dendrogram</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the dendrogram's labels colors (or a colored dendrogram,
in case assignment is used). The colors are labeled.
</p>


<h3>Source</h3>

<p>Heavily inspired by the code in the example of <a href="stats.html#topic+dendrapply">dendrapply</a>,
so credit should go to Martin Maechler.
I also implemented some ideas from Gregory Jefferis's dendroextras package
(having the &quot;names&quot; of the returned vector be the labels).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutree">cutree</a></code>,<code><a href="stats.html#topic+dendrogram">dendrogram</a></code>,
<code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+color_labels">color_labels</a></code>, <code><a href="#topic+color_branches">color_branches</a></code>,
<a href="#topic+assign_values_to_leaves_edgePar">assign_values_to_leaves_edgePar</a>, <a href="#topic+get_leaves_branches_col">get_leaves_branches_col</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)

# Defaults:
labels_colors(dend)
plot(dend)

# let's add some color:
labels_colors(dend) &lt;- 2:4
labels_colors(dend)
plot(dend)


# doesn't work...
#  get_nodes_attr(dend, "nodePar", include_branches = FALSE)

# changing color to black
labels_colors(dend) &lt;- 1
labels_colors(dend)
plot(dend)

# removing color (and the nodePar completely - if it has no other attributed but lab.col)
suppressWarnings(labels_colors(dend) &lt;- NULL)
labels_colors(dend)
plot(dend)
</code></pre>

<hr>
<h2 id='labels+26lt+3B-'>&quot;label&quot; assignment operator</h2><span id='topic+labels+3C-'></span><span id='topic+labels+3C-.default'></span><span id='topic+labels+3C-.dendrogram'></span><span id='topic+labels.hclust'></span><span id='topic+labels+3C-.hclust'></span><span id='topic+labels.phylo'></span><span id='topic+labels+3C-.phylo'></span>

<h3>Description</h3>

<p>&quot;label&quot; assignment operator for vectors, dendrogram, and hclust classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels(object, ...) &lt;- value

## Default S3 replacement method:
labels(object, ...) &lt;- value

## S3 replacement method for class 'dendrogram'
labels(object, ...) &lt;- value

## S3 method for class 'hclust'
labels(object, order = TRUE, ...)

## S3 replacement method for class 'hclust'
labels(object, ...) &lt;- value

## S3 method for class 'phylo'
labels(object, ...)

## S3 replacement method for class 'phylo'
labels(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a variable name (possibly quoted) who's label are to be updated</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>parameters passed (not currently in use)</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a value to be assigned to object's label</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_order">order</code></td>
<td>
<p>default is FALSE. Only relevant for extracting labels from an
<a href="stats.html#topic+hclust">hclust</a> object (with labels.hclust). Setting order=TRUE will return
labels in their order in the dendrogram, instead of the riginal labels order
retained from object$labels - which ususally corresponding to
the row or column names of the <a href="stats.html#topic+dist">dist</a> object provided to
the <a href="stats.html#topic+hclust">hclust</a> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>###################
</p>


<h3>Value</h3>

<p>The updated object
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson, Tal Galili
(with some ideas from Gregory Jefferis's dendroextras package)
</p>


<h3>Source</h3>

<p>The functions here are based on code by Gavin and kohske from
(adopted to dendrogram by Tal Galili):
<a href="https://stackoverflow.com/questions/4614223/how-to-have-the-following-work-labelsx-some-value-r-question">https://stackoverflow.com/questions/4614223/how-to-have-the-following-work-labelsx-some-value-r-question</a>
Also with some ideas from Gregory Jefferis's dendroextras package.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+labels">labels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
labels(x)
labels(x) &lt;- letters[1:3]
labels(x) # [1] "a" "b" "c"
x
# a b c
# 1 2 3


# get("labels&lt;-")

################
# Example for using the assignment with dendrogram and hclust objects:
hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)

labels(hc) # "Arizona" "Alabama" "Alaska"
labels(hc) &lt;- letters[1:3]
labels(hc) # "a" "b" "c"
labels(dend) # "Arizona" "Alabama" "Alaska"
labels(dend) &lt;- letters[1:3]
labels(dend) # "a" "b" "c"
suppressWarnings(labels(dend) &lt;- LETTERS[1:2]) # will produce a warning
labels(dend) # "A" "B" "A"
labels(dend) &lt;- LETTERS[4:6] # will replace the labels correctly
# (the fact the tree had duplicate labels will not cause a problem)
labels(dend) # "D" "E" "F"
</code></pre>

<hr>
<h2 id='ladderize'>Ladderize a Tree</h2><span id='topic+ladderize'></span><span id='topic+ladderize.dendrogram'></span><span id='topic+ladderize.phylo'></span><span id='topic+ladderize.dendlist'></span>

<h3>Description</h3>

<p>This function reorganizes the internal structure of the tree to get the ladderized effect when plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ladderize(x, right = TRUE, ...)

## S3 method for class 'dendrogram'
ladderize(x, right = TRUE, ...)

## S3 method for class 'phylo'
ladderize(x, right = TRUE, phy, ...)

## S3 method for class 'dendlist'
ladderize(x, right = TRUE, which, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ladderize_+3A_x">x</code></td>
<td>
<p>a tree object (either a <a href="stats.html#topic+dendrogram">dendrogram</a>, <a href="#topic+dendlist">dendlist</a>, or <a href="ape.html#topic+phylo">phylo</a>)</p>
</td></tr>
<tr><td><code id="ladderize_+3A_right">right</code></td>
<td>
<p>a logical (TRUE) specifying whether the smallest clade is on the right-hand side (when the tree is plotted upwards), or the opposite (if FALSE).</p>
</td></tr>
<tr><td><code id="ladderize_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="ladderize_+3A_phy">phy</code></td>
<td>
<p>a placeholder in case the user uses &quot;phy =&quot;</p>
</td></tr>
<tr><td><code id="ladderize_+3A_which">which</code></td>
<td>
<p>an integer (can have any number of elements).
It indicates the elements in the <a href="#topic+dendlist">dendlist</a> to ladderize.
If missing, it will ladderize all the dendrograms in the dendlist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rotated tree object
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+ladderize">ladderize</a></code>,
<code><a href="stats.html#topic+rev.dendrogram">rev.dendrogram</a></code>, <code><a href="#topic+rotate">rotate</a></code> (dendextend), <code><a href="ape.html#topic+rotate">rotate</a></code> (ape)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dend &lt;- USArrests[1:8, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("labels_colors") %&gt;%
  set("branches_k_color", k = 5)
set.seed(123)
dend &lt;- shuffle(dend)

par(mfrow = c(1, 3))
dend %&gt;% plot(main = "Original")
dend %&gt;%
  ladderize(TRUE) %&gt;%
  plot(main = "Right (default)")
dend %&gt;%
  ladderize(FALSE) %&gt;%
  plot(main = "Left (rev of right)")
</code></pre>

<hr>
<h2 id='leaf_Colors'>Return the leaf Colors of a dendrogram</h2><span id='topic+leaf_Colors'></span><span id='topic+leaf_colors'></span>

<h3>Description</h3>

<p>The returned Colors will be in dendrogram order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaf_Colors(d, col_to_return = c("edge", "node", "label"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaf_Colors_+3A_d">d</code></td>
<td>
<p>the dendrogram</p>
</td></tr>
<tr><td><code id="leaf_Colors_+3A_col_to_return">col_to_return</code></td>
<td>
<p>Character scalar - kind of Color attribute to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named character vector of Colors, NA_character_ where missing
</p>


<h3>Author(s)</h3>

<p>jefferis
</p>


<h3>See Also</h3>

<p><code><a href="dendroextras.html#topic+slice">slice</a>,<a href="#topic+color_branches">color_branches</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dend &lt;- USArrests %&gt;%
  dist() %&gt;%
  hclust(method = "ave") %&gt;%
  as.dendrogram()
d5 &lt;- color_branches(dend, 5)
leaf_Colors(d5)
</code></pre>

<hr>
<h2 id='lowest_common_branch'>Find lowest common branch were the two items are shared</h2><span id='topic+lowest_common_branch'></span>

<h3>Description</h3>

<p>Given two vectors, for two items, of cluster belonging - the function finds
the lowest branch (e.g: largest number of k clusters) for which the two
items are in the same cluster for the two trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowest_common_branch(item1, item2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowest_common_branch_+3A_item1">item1</code></td>
<td>
<p>a named numeric vector (of cluster group with names of k level)</p>
</td></tr>
<tr><td><code id="lowest_common_branch_+3A_item2">item2</code></td>
<td>
<p>a named numeric vector (of cluster group with names of k level)</p>
</td></tr>
<tr><td><code id="lowest_common_branch_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first location (from left) where the two vectors have the same A dendrogram, after adjusting the members attr in all of its nodes.
</p>


<h3>See Also</h3>

<p><a href="#topic+cor_bakers_gamma">cor_bakers_gamma</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
item1 &lt;- structure(c(1L, 1L, 1L, 1L), .Names = c("1", "2", "3", "4"))
item2 &lt;- structure(c(1L, 1L, 2L, 2L), .Names = c("1", "2", "3", "4"))
lowest_common_branch(item1, item2)
</code></pre>

<hr>
<h2 id='match_order_by_labels'>Adjust the order of one dendrogram based on another (using labels)</h2><span id='topic+match_order_by_labels'></span>

<h3>Description</h3>

<p>Takes one dendrogram and adjusts its order leaves valeus based on the order
of another dendrogram. The values are matached based on the labels of the
two dendrograms.
</p>
<p>This allows for faster <a href="#topic+entanglement">entanglement</a> running time, since we can be
sure that the leaves order is just as using their labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_order_by_labels(
  dend_change,
  dend_template,
  check_that_labels_match = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_order_by_labels_+3A_dend_change">dend_change</code></td>
<td>
<p>tree object (dendrogram)</p>
</td></tr>
<tr><td><code id="match_order_by_labels_+3A_dend_template">dend_template</code></td>
<td>
<p>tree object (dendrogram)</p>
</td></tr>
<tr><td><code id="match_order_by_labels_+3A_check_that_labels_match">check_that_labels_match</code></td>
<td>
<p>logical (TRUE). If to check that the labels
in the two dendrogram match. (if they do not, the function aborts)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dend_change after adjusting its order values to
be like dend_template.
</p>


<h3>See Also</h3>

<p><a href="#topic+entanglement">entanglement</a> , <a href="#topic+tanglegram">tanglegram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

dend &lt;- USArrests[1:4, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
order.dendrogram(dend) #  c(4L, 3L, 1L, 2L)

dend_changed &lt;- dend
order.dendrogram(dend_changed) &lt;- 1:4
order.dendrogram(dend_changed) # c(1:4)

# now let's fix the order of the new object to be as it was:
dend_changed &lt;- match_order_by_labels(dend_changed, dend)
# these two are now the same:
order.dendrogram(dend_changed)
order.dendrogram(dend)

## End(Not run)
</code></pre>

<hr>
<h2 id='match_order_dendrogram_by_old_order'>Adjust the order of one dendrogram based on another (using order)</h2><span id='topic+match_order_dendrogram_by_old_order'></span>

<h3>Description</h3>

<p>Takes one dendrogram and adjusts its order leaves valeus based on the order
of another dendrogram. The values are matached based on the order of the
two dendrograms.
</p>
<p>This allows for faster <a href="#topic+entanglement">entanglement</a> running time, since we can be
sure that the leaves order is just as using their labels.
</p>
<p>This is a function is FASTER than <a href="#topic+match_order_by_labels">match_order_by_labels</a>, but it
assumes that the order and the labels of the two trees are matching!!
</p>
<p>This will allow for a faster calculation of <a href="#topic+entanglement">entanglement</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_order_dendrogram_by_old_order(
  dend_change,
  dend_template,
  dend_change_old_order,
  check_that_labels_match = FALSE,
  check_that_leaves_order_match = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_order_dendrogram_by_old_order_+3A_dend_change">dend_change</code></td>
<td>
<p>tree object (dendrogram)</p>
</td></tr>
<tr><td><code id="match_order_dendrogram_by_old_order_+3A_dend_template">dend_template</code></td>
<td>
<p>tree object (dendrogram)</p>
</td></tr>
<tr><td><code id="match_order_dendrogram_by_old_order_+3A_dend_change_old_order">dend_change_old_order</code></td>
<td>
<p>a numeric vector with the order of leaves in
dend_change (at least before it was changes for some reason).
This is the vector based on which we adjust the new values of dend_change.</p>
</td></tr>
<tr><td><code id="match_order_dendrogram_by_old_order_+3A_check_that_labels_match">check_that_labels_match</code></td>
<td>
<p>logical (FALSE). If to check that the labels
in the two dendrogram match. (if they do not, the function aborts)</p>
</td></tr>
<tr><td><code id="match_order_dendrogram_by_old_order_+3A_check_that_leaves_order_match">check_that_leaves_order_match</code></td>
<td>
<p>logical (FALSE). If to check that
the order in the two dendrogram match. (if they do not, the function aborts)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dend_change after adjusting its order values to
be like dend_template.
</p>


<h3>See Also</h3>

<p><a href="#topic+entanglement">entanglement</a> , <a href="#topic+tanglegram">tanglegram</a>,
<a href="#topic+match_order_by_labels">match_order_by_labels</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

dend &lt;- USArrests[1:4, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
order.dendrogram(dend) #  c(4L, 3L, 1L, 2L)


# Watch this!
dend_changed &lt;- dend
dend_changed &lt;- rev(dend_changed)
expect_false(identical(order.dendrogram(dend_changed), order.dendrogram(dend)))
# we keep the order of dend_change, so that the leaves order are synced
# with their labels JUST LIKE dend:
old_dend_changed_order &lt;- order.dendrogram(dend_changed)
# now we change dend_changed leaves order values:
order.dendrogram(dend_changed) &lt;- 1:4
# and we can fix them again, based on their old kept leaves order:
dend_changed &lt;- match_order_dendrogram_by_old_order(
  dend_changed, dend,
  old_dend_changed_order
)
expect_identical(order.dendrogram(dend_changed), order.dendrogram(dend))

## End(Not run)
</code></pre>

<hr>
<h2 id='min_depth'>Find minimum/maximum depth of a dendrogram</h2><span id='topic+min_depth'></span><span id='topic+max_depth'></span>

<h3>Description</h3>

<p>As the name implies. This can also work for non-dendrogram nested lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_depth(dend, ...)

max_depth(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_depth_+3A_dend">dend</code></td>
<td>
<p>Any nested list object (including <a href="stats.html#topic+dendrogram">dendrogram</a>).</p>
</td></tr>
<tr><td><code id="min_depth_+3A_...">...</code></td>
<td>
<p>unused at the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer, the (min/max) number of nodes from the root to the leafs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hc &lt;- hclust(dist(USArrests), "ave")
(dend1 &lt;- as.dendrogram(hc)) # "print()" method
is.list(dend1)
is.list(dend1[[1]][[1]][[1]])
dend1[[1]][[1]][[1]]
plot(dend1)
min_depth(dend1)
max_depth(dend1)
</code></pre>

<hr>
<h2 id='na_locf'>Last Observation Carried Forward</h2><span id='topic+na_locf'></span>

<h3>Description</h3>

<p>A function for replacing each NA with the most recent non-NA prior to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_locf(x, first_na_value = 0, recursive = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_locf_+3A_x">x</code></td>
<td>
<p>some vector</p>
</td></tr>
<tr><td><code id="na_locf_+3A_first_na_value">first_na_value</code></td>
<td>
<p>If the first observation is NA, fill it with &quot;first_na_value&quot;</p>
</td></tr>
<tr><td><code id="na_locf_+3A_recursive">recursive</code></td>
<td>
<p>logical (TRUE). Should na_locf be re-run until all NA values are filled?</p>
</td></tr>
<tr><td><code id="na_locf_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original vector, but with all the missing values filled by the value
before them.
</p>


<h3>Source</h3>

<p><a href="https://stat.ethz.ch/pipermail/r-help/2003-November/042126.html">https://stat.ethz.ch/pipermail/r-help/2003-November/042126.html</a>
<a href="https://stackoverflow.com/questions/5302049/last-observation-carried-forward-na-locf-on-panel-cross-section-time-series">https://stackoverflow.com/questions/5302049/last-observation-carried-forward-na-locf-on-panel-cross-section-time-series</a>
</p>
<p>This could probably be solved MUCH faster using Rcpp.
</p>


<h3>See Also</h3>

<p><a href="zoo.html#topic+na.locf">na.locf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na_locf(c(NA, NA))
na_locf(c(1, NA))
na_locf(c(1, NA, NA, NA))
na_locf(c(1, NA, NA, NA, 2, 2, NA, 3, NA, 4))
na_locf(c(1, NA, NA, NA, 2, 2, NA, 3, NA, 4), recursive = FALSE)
## Not run: 

# library(microbenchmark)
# library(zoo)

# microbenchmark(
#  na_locf = na_locf(c(1, NA, NA, NA, 2, 2, NA, 3, NA, 4)),
#  na.locf = na.locf(c(1, NA, NA, NA, 2, 2, NA, 3, NA, 4))
#) # my implementation is 6 times faster :)

#microbenchmark(
#  na_locf = na_locf(rep(c(1, NA, NA, NA, 2, 2, NA, 3, NA, 4), 1000)),
#  na.locf = na.locf(rep(c(1, NA, NA, NA, 2, 2, NA, 3, NA, 4), 1000))
# ) # my implementation is 3 times faster


## End(Not run)

</code></pre>

<hr>
<h2 id='nleaves'>Counts the number of leaves in a tree</h2><span id='topic+nleaves'></span><span id='topic+nleaves.default'></span><span id='topic+nleaves.dendrogram'></span><span id='topic+nleaves.dendlist'></span><span id='topic+nleaves.hclust'></span><span id='topic+nleaves.phylo'></span>

<h3>Description</h3>

<p>Counts the number of leaves in a tree (dendrogram or hclust).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nleaves(x, ...)

## Default S3 method:
nleaves(x, ...)

## S3 method for class 'dendrogram'
nleaves(x, method = c("members", "order"), ...)

## S3 method for class 'dendlist'
nleaves(x, ...)

## S3 method for class 'hclust'
nleaves(x, ...)

## S3 method for class 'phylo'
nleaves(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nleaves_+3A_x">x</code></td>
<td>
<p>tree object (dendrogram/hclust/phylo,<a href="#topic+dendlist">dendlist</a>)</p>
</td></tr>
<tr><td><code id="nleaves_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="nleaves_+3A_method">method</code></td>
<td>
<p>a character scalar (default is &quot;members&quot;). If &quot;order&quot;
than nleaves is based on length of <a href="stats.html#topic+order.dendrogram">order.dendrogram</a>.
If &quot;members&quot;, than length is trusting what is written in the
dendrogram's root <a href="base.html#topic+attr">attr</a>.
&quot;members&quot; is about 4 times faster than &quot;order&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea for the name is from functions like ncol, and nrow.
</p>
<p>Also, it is worth noting that the nleaves.dendrogram is based on
order.dendrogram instead of labels.dendrogram since the first is
MUCH faster than the later.
</p>
<p>The phylo method is based on turning the phylo to hclust and than to
dendrogram. It may not work for complex phylo trees.
</p>


<h3>Value</h3>

<p>The number of leaves in the tree
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+nrow">nrow</a>, <a href="#topic+count_terminal_nodes">count_terminal_nodes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)

nleaves(dend) # 5
nleaves(hc) # 5
</code></pre>

<hr>
<h2 id='nnodes'>Counts the number of nodes (Vertices) in a tree</h2><span id='topic+nnodes'></span><span id='topic+nnodes.default'></span><span id='topic+nnodes.dendrogram'></span><span id='topic+nnodes.hclust'></span><span id='topic+nnodes.phylo'></span>

<h3>Description</h3>

<p>Counts the number of nodes in a tree (dendrogram, hclust, phylo).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnodes(x, ...)

## Default S3 method:
nnodes(x, ...)

## S3 method for class 'dendrogram'
nnodes(x, ...)

## S3 method for class 'hclust'
nnodes(x, ...)

## S3 method for class 'phylo'
nnodes(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnodes_+3A_x">x</code></td>
<td>
<p>tree object (dendrogram or hclust)</p>
</td></tr>
<tr><td><code id="nnodes_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea for the name is from functions like ncol, and nrow.
</p>
<p>The phylo method is based on turning the phylo to hclust and than to
dendrogram. It may not work for complex phylo trees.
</p>


<h3>Value</h3>

<p>The number of leaves in the tree
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+nrow">nrow</a>, <a href="#topic+count_terminal_nodes">count_terminal_nodes</a>, <a href="#topic+nleaves">nleaves</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)

nnodes(dend) # 9
nnodes(hc) # 9
</code></pre>

<hr>
<h2 id='noded_with_condition'>Find which nodes satisfies a condition</h2><span id='topic+noded_with_condition'></span>

<h3>Description</h3>

<p>Goes through a tree's nodes in order to return a vector
with whether (TRUE/FALSE) each node satisies some condition (function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noded_with_condition(
  dend,
  condition,
  include_leaves = TRUE,
  include_branches = TRUE,
  na.rm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noded_with_condition_+3A_dend">dend</code></td>
<td>
<p>a dendrogram dend</p>
</td></tr>
<tr><td><code id="noded_with_condition_+3A_condition">condition</code></td>
<td>
<p>a function that gets a node and return TRUE or FALSE
(based on whether or not that node/tree fulfills the &quot;condition&quot;)</p>
</td></tr>
<tr><td><code id="noded_with_condition_+3A_include_leaves">include_leaves</code></td>
<td>
<p>logical. Should leaves attributes be included as well?</p>
</td></tr>
<tr><td><code id="noded_with_condition_+3A_include_branches">include_branches</code></td>
<td>
<p>logical. Should non-leaf (branch node)
attributes be included as well?</p>
</td></tr>
<tr><td><code id="noded_with_condition_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should NA attributes be REMOVED from the resulting vector?</p>
</td></tr>
<tr><td><code id="noded_with_condition_+3A_...">...</code></td>
<td>
<p>passed to the condition function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector with TRUE/FALSE, specifying for each of the dendrogram's nodes if it fulfills the condition or not.
</p>


<h3>See Also</h3>

<p><a href="#topic+branches_attr_by_labels">branches_attr_by_labels</a>, <a href="#topic+get_leaves_attr">get_leaves_attr</a>, <a href="#topic+nnodes">nnodes</a>, <a href="#topic+nleaves">nleaves</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(dendextend)

set.seed(23235)
ss &lt;- sample(1:150, 10)

# Getting the dend dend
dend &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend %&gt;% plot()



# this is the basis for branches_attr_by_labels
has_any_labels &lt;- function(sub_dend, the_labels) any(labels(sub_dend) %in% the_labels)
cols &lt;- noded_with_condition(dend, has_any_labels,
  the_labels = c("126", "109", "59")
) %&gt;%
  ifelse(2, 1)
set(dend, "branches_col", cols) %&gt;% plot()

# Similar to branches_attr_by_labels - but for heights!
high_enough &lt;- function(sub_dend, height) attr(sub_dend, "height") &gt; height
cols &lt;- noded_with_condition(dend, high_enough, height = 1) %&gt;% ifelse(2, 1)
set(dend, "branches_col", cols) %&gt;% plot()

## End(Not run)

</code></pre>

<hr>
<h2 id='order.dendrogram+26lt+3B-'>order.dendrogram&lt;- assignment operator</h2><span id='topic+order.dendrogram+3C-'></span>

<h3>Description</h3>

<p>order.dendrogram&lt;- assignment operator.  This is useful in cases where some object is turned into a dendrogram but its leaves values (the order) are all mixed up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.dendrogram(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order.dendrogram+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a variable name (possibly quoted) who's label are to be updated</p>
</td></tr>
<tr><td><code id="order.dendrogram+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>parameters passed (not currently in use)</p>
</td></tr>
<tr><td><code id="order.dendrogram+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a value to be assigned to object's leaves value (their &quot;order&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dendrogram with updated order leaves values
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+order.dendrogram">order.dendrogram</a></code>, <code><a href="#topic+labels+3C-">labels&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################
# Example for using the assignment with dendrogram and hclust objects:
hc &lt;- hclust(dist(USArrests[1:4, ]), "ave")
dend &lt;- as.dendrogram(hc)

str(dend)
order.dendrogram(dend) # 4 3 1 2
order.dendrogram(dend) &lt;- 1:4
order.dendrogram(dend) # 1 2 3 4
str(dend) # the structure is still fine.

# This function is very useful if we try playing with subtrees
# For example:
hc &lt;- hclust(dist(USArrests[1:6, ]), "ave")
dend &lt;- as.dendrogram(hc)
sub_dend &lt;- dend[[1]]
order.dendrogram(sub_dend) # 4 6
# now using as.hclust(sub_dend) will cause trouble:
# labels(as.hclust(sub_dend)) # As of R 3.1.1-patched - this will produce an Error (as it should) :)
# let's fix it:

order.dendrogram(sub_dend) &lt;- rank(order.dendrogram(sub_dend), ties.method = "first")
labels(as.hclust(sub_dend)) # We now have labels :)
</code></pre>

<hr>
<h2 id='order.hclust'>Ordering of the Leaves in a hclust Dendrogram</h2><span id='topic+order.hclust'></span>

<h3>Description</h3>

<p>Ordering of the Leaves in a hclust Dendrogram. Like <a href="stats.html#topic+order.dendrogram">order.dendrogram</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.hclust(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order.hclust_+3A_x">x</code></td>
<td>
<p>ab hclust object a distance matrix.</p>
</td></tr>
<tr><td><code id="order.hclust_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with length equal to the number of
leaves in the hclust dendrogram is returned.
From r &lt;- order.hclust(), each element is
the index into the original data
(from which the hclust was computed).
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+order.dendrogram">order.dendrogram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(23235)
ss &lt;- sample(1:150, 10)
hc &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust()
# dend &lt;- hc %&gt;% as.dendrogram
order.hclust(hc)
</code></pre>

<hr>
<h2 id='partition_leaves'>A list with labels for each subtree (edge)</h2><span id='topic+partition_leaves'></span>

<h3>Description</h3>

<p>Returns the set of all bipartitions from all edges, that is: a list with the labels
for each of the nodes in the dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_leaves(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_leaves_+3A_dend">dend</code></td>
<td>
<p>a dendrogram</p>
</td></tr>
<tr><td><code id="partition_leaves_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the labels for each of the nodes in the dendrogram.
</p>


<h3>Source</h3>

<p>A <a href="stats.html#topic+dendrogram">dendrogram</a> implementation for <a href="distory.html#topic+partition.leaves">partition.leaves</a> from the distory package
</p>


<h3>See Also</h3>

<p><a href="#topic+distinct_edges">distinct_edges</a>, <a href="#topic+highlight_distinct_edges">highlight_distinct_edges</a>,
<a href="#topic+dist.dendlist">dist.dendlist</a>, <a href="#topic+tanglegram">tanglegram</a>,
<a href="distory.html#topic+partition.leaves">partition.leaves</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:3 %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
plot(x)
partition_leaves(x)
## Not run: 
set.seed(23235)
ss &lt;- sample(1:150, 10)
dend1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("single") %&gt;%
  as.dendrogram()

partition_leaves(dend1)
partition_leaves(dend2)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_horiz.dendrogram'>Plotting a left-tip-adjusted horizontal dendrogram</h2><span id='topic+plot_horiz.dendrogram'></span>

<h3>Description</h3>

<p>The default <code>plot(dend, horiz = TRUE)</code>, gives us a dendrogram tree plot
with the tips turned right. The current function enables the creation of
the same tree, but with the tips turned left. The main challange in doing this
is finding the distance of the labels from the leaves tips - which is solved
with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_horiz.dendrogram(
  x,
  type = c("rectangle", "triangle"),
  center = FALSE,
  edge.root = is.leaf(x) || !is.null(attr(x, "edgetext")),
  dLeaf = NULL,
  horiz = TRUE,
  xaxt = "n",
  yaxt = "s",
  xlim = NULL,
  ylim = NULL,
  nodePar = NULL,
  edgePar = list(),
  leaflab = c("perpendicular", "textlike", "none"),
  side = TRUE,
  text_pos = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_horiz.dendrogram_+3A_x">x</code></td>
<td>
<p>tree object (dendrogram)</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_type">type</code></td>
<td>
<p>a character vector with either &quot;rectangle&quot; or &quot;triangle&quot; (passed to <a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a>)</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_center">center</code></td>
<td>
<p>logical; if TRUE, nodes are plotted centered with respect to
the leaves in the branch. Otherwise (default), plot them in the
middle of all direct child nodes.</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_edge.root">edge.root</code></td>
<td>
<p>logical; if true, draw an edge to the root node.</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_dleaf">dLeaf</code></td>
<td>
<p>a number specifying the distance in user coordinates between
the tip of a leaf and its label. If NULL as per default, 3/4 of a letter
width is used.</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_horiz">horiz</code></td>
<td>
<p>logical indicating if the dendrogram should be
drawn horizontally or not. In this function it MUST be TRUE!</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_xaxt">xaxt</code></td>
<td>
<p>graphical parameters, or arguments for other methods.</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_yaxt">yaxt</code></td>
<td>
<p>graphical parameters, or arguments for other methods.</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_xlim">xlim</code></td>
<td>
<p>(NULL) optional x- and y-limits of the plot, passed to plot.default.
The defaults for these show the full dendrogram.</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_ylim">ylim</code></td>
<td>
<p>(NULL) optional x- and y-limits of the plot, passed to plot.default.
The defaults for these show the full dendrogram.</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_nodepar">nodePar</code></td>
<td>
<p>NULL.</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_edgepar">edgePar</code></td>
<td>
<p>list()</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_leaflab">leaflab</code></td>
<td>
<p>c(&quot;perpendicular&quot;, &quot;textlike&quot;, &quot;none&quot;)</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_side">side</code></td>
<td>
<p>logical (TRUE). Should the tips of the drawn tree be facing
the left side. This is the important feature of this function.</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_text_pos">text_pos</code></td>
<td>
<p>integer from either 1 to 4 (2). Two relevant values
are 2 and 4. 2 (default) means that the labels are alligned to the
tips of the tree leaves. 4 will have the labels allign to the left,
making them look like they were when the tree was on the left side
(with leaves tips facing to the right).</p>
</td></tr>
<tr><td><code id="plot_horiz.dendrogram_+3A_...">...</code></td>
<td>
<p>passed to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The invisiable dLeaf value.
</p>


<h3>Source</h3>

<p>This function is based on replicating <a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a>.
In fact, I'd be happy if in the future, some tweaks could be make to
<a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a>, so that it would replace the need for this function.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a>, <a href="#topic+tanglegram">tanglegram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dend &lt;- USArrests[1:10, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()

par(mfrow = c(1, 2), mar = rep(6, 4))
plot_horiz.dendrogram(dend, side = FALSE)
plot_horiz.dendrogram(dend, side = TRUE)
# plot_horiz.dendrogram(dend, side=TRUE, dLeaf= 0)
# plot_horiz.dendrogram(dend, side=TRUE, nodePar = list(pos = 1))
# sadly, lab.pos is not implemented yet,
## so the labels can not be right aligned...


plot_horiz.dendrogram(dend, side = F)
plot_horiz.dendrogram(dend, side = TRUE, dLeaf = 0, xlim = c(100, -10)) # bad
plot_horiz.dendrogram(dend, side = TRUE, text_offset = 0)
plot_horiz.dendrogram(dend, side = TRUE, text_offset = 0, text_pos = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='prune'>Prunes a tree (using leaves' labels)</h2><span id='topic+prune'></span><span id='topic+prune.default'></span><span id='topic+prune.dendrogram'></span><span id='topic+prune.hclust'></span><span id='topic+prune.phylo'></span><span id='topic+prune.rpart'></span>

<h3>Description</h3>

<p>Trimms a tree (dendrogram, hclust) from a set of leaves based on their labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune(dend, ...)

## Default S3 method:
prune(dend, ...)

## S3 method for class 'dendrogram'
prune(dend, leaves, reindex_dend = TRUE, ...)

## S3 method for class 'hclust'
prune(dend, leaves, ...)

## S3 method for class 'phylo'
prune(dend, ...)

## S3 method for class 'rpart'
prune(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_+3A_dend">dend</code></td>
<td>
<p>tree object (dendrogram/hclust/phylo)</p>
</td></tr>
<tr><td><code id="prune_+3A_...">...</code></td>
<td>
<p>passed on</p>
</td></tr>
<tr><td><code id="prune_+3A_leaves">leaves</code></td>
<td>
<p>a character vector of the label(S) of the tip(s) (leaves) we wish to prune off the tree.</p>
</td></tr>
<tr><td><code id="prune_+3A_reindex_dend">reindex_dend</code></td>
<td>
<p>logical (default is TRUE). If TRUE, the leaves of the new dendrograms
include the rank of the old order.dendrogram.
This insures that their values are just like the number of leaves.
When FALSE, the values in the leaves is that of the original dendrogram. Thie is useful
if prunning a dendrogram but then wanting to use <a href="stats.html#topic+order.dendrogram">order.dendrogram</a> with the original values.
When using prune.hclust, then reindex_dend is used by default since otherwise the <a href="stats.html#topic+as.hclust">as.hclust</a> function
would return an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I was not sure if to call this function drop.tip (from ape), snip/prune (from rpart) or just remove.leaves.  I ended up deciding on prune.
</p>


<h3>Value</h3>

<p>A pruned tree
</p>


<h3>See Also</h3>

<p><a href="#topic+prune_leaf">prune_leaf</a>, <a href="ape.html#topic+drop.tip">drop.tip</a> ape
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)

par(mfrow = c(1, 2))
plot(dend, main = "original tree")
plot(prune(dend, c("Alaska", "California")), main = "tree without Alaska and California")


# this works because prune uses reindex_dend = TRUE by default
as.hclust(prune(dend, c("Alaska", "California")))
prune(hc, c("Alaska", "California"))
</code></pre>

<hr>
<h2 id='prune_common_subtrees.dendlist'>Prune trees to their common subtrees</h2><span id='topic+prune_common_subtrees.dendlist'></span>

<h3>Description</h3>

<p>Prune trees to their common subtrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_common_subtrees.dendlist(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_common_subtrees.dendlist_+3A_dend">dend</code></td>
<td>
<p>a <a href="#topic+dendlist">dendlist</a> of length two</p>
</td></tr>
<tr><td><code id="prune_common_subtrees.dendlist_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendlist after prunning the labels to only include
those that are part of common subtrees in both dendrograms.
</p>


<h3>See Also</h3>

<p><a href="#topic+common_subtrees_clusters">common_subtrees_clusters</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# NULL
</code></pre>

<hr>
<h2 id='prune_leaf'>Trims one leaf from a dendrogram</h2><span id='topic+prune_leaf'></span>

<h3>Description</h3>

<p>Trims (prunes) one leaf from a dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_leaf(dend, leaf_name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_leaf_+3A_dend">dend</code></td>
<td>
<p>dendrogram object</p>
</td></tr>
<tr><td><code id="prune_leaf_+3A_leaf_name">leaf_name</code></td>
<td>
<p>a character string as the label of the tip we wish to prune</p>
</td></tr>
<tr><td><code id="prune_leaf_+3A_...">...</code></td>
<td>
<p>passed on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used through <a href="#topic+prune">prune</a>
</p>


<h3>Value</h3>

<p>A dendrogram with a leaf pruned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)

par(mfrow = c(1, 2))
plot(dend, main = "original tree")
plot(prune_leaf(dend, "Alaska"), main = "tree without Alaska")
</code></pre>

<hr>
<h2 id='pvclust_edges'>Get Pvclust Edges Information</h2><span id='topic+pvclust_edges'></span>

<h3>Description</h3>

<p>Get pvclust edges information such as au and bp and return dataframe with proper sample labels.
This function is useful when there are a lot of samples involved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvclust_edges(pvclust_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pvclust_edges_+3A_pvclust_obj">pvclust_obj</code></td>
<td>
<p>pvclust object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with leaves on column 1 and 2, followed by the rest of the information from edge
</p>


<h3>References</h3>

<p>hclust object descriptions <a href="https://stat.ethz.ch/R-manual/R-patched/library/stats/html/hclust.html">https://stat.ethz.ch/R-manual/R-patched/library/stats/html/hclust.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(pvclust)
data(lung) # 916 genes for 73 subjects
set.seed(13134)
result &lt;- pvclust(lung[, 1:20], method.dist = "cor", method.hclust = "average", nboot = 100)
pvclust_edges(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='pvclust_show_signif'>The significant branches in a dendrogram, based on a pvclust object</h2><span id='topic+pvclust_show_signif'></span>

<h3>Description</h3>

<p>Shows the significant branches in a dendrogram, based on a pvclust object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvclust_show_signif(
  dend,
  pvclust_obj,
  signif_type = c("bp", "au"),
  alpha = 0.05,
  signif_value = c(5, 1),
  show_type = c("lwd", "col"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pvclust_show_signif_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_+3A_pvclust_obj">pvclust_obj</code></td>
<td>
<p>a pvclust object</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_+3A_signif_type">signif_type</code></td>
<td>
<p>a character scalar (either &quot;bp&quot; or &quot;au&quot;), indicating
which of the two should be used to update the dendrogram.</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_+3A_alpha">alpha</code></td>
<td>
<p>a number between 0 to 1, default is .05. Indicates what is the
cutoff from which branches will be updated.</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_+3A_signif_value">signif_value</code></td>
<td>
<p>a 2d vector (deafult: c(5,1)),
with the first element tells us what the significant branches will get,
and the second element which value the non-significant branches will get.</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_+3A_show_type">show_type</code></td>
<td>
<p>a character scalar (either &quot;lwd&quot; or &quot;col&quot;), indicating
which parameter of the branches should be updated based on significance.</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram with updated branches
</p>


<h3>See Also</h3>

<p><a href="#topic+pvclust_show_signif">pvclust_show_signif</a>, <a href="#topic+pvclust_show_signif_gradient">pvclust_show_signif_gradient</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pvclust)
data(lung) # 916 genes for 73 subjects
set.seed(13134)
result &lt;- pvclust(lung[, 1:20], method.dist = "cor", method.hclust = "average", nboot = 100)

dend &lt;- as.dendrogram(result)
result %&gt;%
  as.dendrogram() %&gt;%
  hang.dendrogram() %&gt;%
  plot(main = "Cluster dendrogram with AU/BP values (%)")
result %&gt;% text()
result %&gt;% pvrect(alpha = 0.95)

dend %&gt;%
  pvclust_show_signif(result) %&gt;%
  plot()
dend %&gt;%
  pvclust_show_signif(result, show_type = "lwd") %&gt;%
  plot()
result %&gt;% text()
result %&gt;% pvrect(alpha = 0.95)

dend %&gt;%
  pvclust_show_signif_gradient(result) %&gt;%
  plot()

dend %&gt;%
  pvclust_show_signif_gradient(result) %&gt;%
  pvclust_show_signif(result) %&gt;%
  plot(main = "Cluster dendrogram with AU/BP values (%)\n bp values are highlighted by signif")
result %&gt;% text()
result %&gt;% pvrect(alpha = 0.95)

## End(Not run)
</code></pre>

<hr>
<h2 id='pvclust_show_signif_gradient'>Significance gradient of branches in a dendrogram (via pvclust)</h2><span id='topic+pvclust_show_signif_gradient'></span>

<h3>Description</h3>

<p>Shows the gradient of significance of branches in a dendrogram, based on a pvclust object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvclust_show_signif_gradient(
  dend,
  pvclust_obj,
  signif_type = c("bp", "au"),
  signif_col_fun = colorRampPalette(c("black", "darkred", "red")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pvclust_show_signif_gradient_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_gradient_+3A_pvclust_obj">pvclust_obj</code></td>
<td>
<p>a pvclust object</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_gradient_+3A_signif_type">signif_type</code></td>
<td>
<p>a character scalar (either &quot;bp&quot; or &quot;au&quot;), indicating
which of the two should be used to update the dendrogram.</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_gradient_+3A_signif_col_fun">signif_col_fun</code></td>
<td>
<p>a function to create colors for the significant
gradient. Default is: colorRampPalette(c(&quot;black&quot;, &quot;darkred&quot;, &quot;red&quot;))</p>
</td></tr>
<tr><td><code id="pvclust_show_signif_gradient_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram with updated branches
</p>


<h3>See Also</h3>

<p><a href="#topic+pvclust_show_signif">pvclust_show_signif</a>, <a href="#topic+pvclust_show_signif_gradient">pvclust_show_signif_gradient</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pvclust)
data(lung) # 916 genes for 73 subjects
set.seed(13134)
result &lt;- pvclust(lung[, 1:20], method.dist = "cor", method.hclust = "average", nboot = 100)

dend &lt;- as.dendrogram(result)
result %&gt;%
  as.dendrogram() %&gt;%
  hang.dendrogram() %&gt;%
  plot(main = "Cluster dendrogram with AU/BP values (%)")
result %&gt;% text()
result %&gt;% pvrect(alpha = 0.95)

dend %&gt;%
  pvclust_show_signif(result) %&gt;%
  plot()
dend %&gt;%
  pvclust_show_signif(result, show_type = "lwd") %&gt;%
  plot()
result %&gt;% text()
result %&gt;% pvrect(alpha = 0.95)

dend %&gt;%
  pvclust_show_signif_gradient(result) %&gt;%
  plot()

dend %&gt;%
  pvclust_show_signif_gradient(result) %&gt;%
  pvclust_show_signif(result) %&gt;%
  plot(main = "Cluster dendrogram with AU/BP values (%)\n bp values are highlighted by signif")
result %&gt;% text()
result %&gt;% pvrect(alpha = 0.95)

## End(Not run)
</code></pre>

<hr>
<h2 id='pvrect2'>Draw Rectangles Around a Dendrogram's Clusters with High/Low P-values</h2><span id='topic+pvrect2'></span>

<h3>Description</h3>

<p>Draws rectangles around the branches of a dendrogram highlighting the corresponding clusters with low p-values.
This is based on <a href="pvclust.html#topic+pvrect">pvrect</a>, allowing to draw the rects till the bottom of the labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvrect2(
  x,
  alpha = 0.95,
  pv = "au",
  type = "geq",
  max.only = TRUE,
  border = 2,
  xpd = TRUE,
  lower_rect,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pvrect2_+3A_x">x</code></td>
<td>
<p>object of class pvclust.</p>
</td></tr>
<tr><td><code id="pvrect2_+3A_alpha">alpha</code></td>
<td>
<p>threshold value for p-values., Default: 0.95</p>
</td></tr>
<tr><td><code id="pvrect2_+3A_pv">pv</code></td>
<td>
<p>character string which specifies the p-value to be used. It should be either of &quot;au&quot; or &quot;bp&quot;, corresponding to AU p-value or BP value, respectively. See plot.pvclust for details. , Default: 'au'</p>
</td></tr>
<tr><td><code id="pvrect2_+3A_type">type</code></td>
<td>
<p>one of &quot;geq&quot;, &quot;leq&quot;, &quot;gt&quot; or &quot;lt&quot;. If &quot;geq&quot; is specified, clusters with p-value greater than or equals the threshold given by &quot;alpha&quot; are returned or displayed. Likewise &quot;leq&quot; stands for lower than or equals, &quot;gt&quot; for greater than and &quot;lt&quot; for lower than the threshold value. The default is &quot;geq&quot;., Default: 'geq'</p>
</td></tr>
<tr><td><code id="pvrect2_+3A_max.only">max.only</code></td>
<td>
<p>logical. If some of clusters with high/low p-values have inclusion relation, only the largest cluster is returned (or displayed) when max.only=TRUE., Default: TRUE</p>
</td></tr>
<tr><td><code id="pvrect2_+3A_border">border</code></td>
<td>
<p>numeric value which specifies the color of borders of rectangles., Default: 2</p>
</td></tr>
<tr><td><code id="pvrect2_+3A_xpd">xpd</code></td>
<td>
<p>A logical value (or NA.), passed to par. Default is TRUE, in order to allow the rect to be below the labels. If FALSE, all plotting is clipped to the plot region, if TRUE, all plotting is clipped to the figure region, and if NA, all plotting is clipped to the device region. See also clip., Default: TRUE</p>
</td></tr>
<tr><td><code id="pvrect2_+3A_lower_rect">lower_rect</code></td>
<td>
<p>a (scalar) value of how low should the lower part of the rect be. If missing, it will take the value of par(&quot;usr&quot;)[3L] (or par(&quot;usr&quot;)[2L], depending if horiz = TRUE or not), with also the width of the labels. (notice that we would like to keep xpd = TRUE if we want the rect to be after the labels!) You can use a value such as 0, to get the rect above the labels.</p>
</td></tr>
<tr><td><code id="pvrect2_+3A_...">...</code></td>
<td>
<p>passed to <a href="graphics.html#topic+rect">rect</a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="pvclust.html#topic+pvrect">pvrect</a>, <a href="#topic+pvclust_show_signif">pvclust_show_signif</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 


library(dendextend)
library(pvclust)
data(lung) # 916 genes for 73 subjects
set.seed(13134)
result &lt;- pvclust(lung[, 1:20], method.dist = "cor", method.hclust = "average", nboot = 10)

par(mar = c(9, 2.5, 2, 0))
dend &lt;- as.dendrogram(result)
dend %&gt;%
  pvclust_show_signif(result, signif_value = c(3, .5)) %&gt;%
  pvclust_show_signif(result, signif_value = c("black", "grey"), show_type = "col") %&gt;%
  plot(main = "Cluster dendrogram with AU/BP values (%)")
pvrect2(result, alpha = 0.95)
# getting the rects to the tips / above the labels
pvrect2(result, lower_rect = .15, border = 4, alpha = 0.95, lty = 2)
# Original function
# pvrect(result, alpha=0.95)
text(result, alpha = 0.95)

## End(Not run)

</code></pre>

<hr>
<h2 id='raise.dendrogram'>Raise the height of a dendrogram tree</h2><span id='topic+raise.dendrogram'></span>

<h3>Description</h3>

<p>Raise the height of nodes in a dendrogram tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raise.dendrogram(dend, heiget_to_add, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raise.dendrogram_+3A_dend">dend</code></td>
<td>
<p>dendrogram object</p>
</td></tr>
<tr><td><code id="raise.dendrogram_+3A_heiget_to_add">heiget_to_add</code></td>
<td>
<p>how much height to add to all the branches (not leaves) in the dendrogram</p>
</td></tr>
<tr><td><code id="raise.dendrogram_+3A_...">...</code></td>
<td>
<p>passed on (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raised dendrogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[2:9, ]), "com")
dend &lt;- as.dendrogram(hc)

par(mfrow = c(1, 2))
plot(dend, main = "original tree")
plot(raise.dendrogram(dend, 100), main = "Raised tree")
</code></pre>

<hr>
<h2 id='rank_branches'>Rank branches' heights</h2><span id='topic+rank_branches'></span>

<h3>Description</h3>

<p>Adjust the height attr in all of the dendrogram nodes so that
the tree will have a distance of 1 unit between each parent/child nodes.
It can be thought of as ranking the branches between themselves.
</p>
<p>This is intended for easier comparison of the topology of two trees.
</p>
<p>Notice that this function changes the height of all the leaves into 0,
thus erasing the effect of <a href="#topic+hang.dendrogram">hang.dendrogram</a> (which should be run
again, if that is the visualization you are intereted in).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_branches(dend, diff_height = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_branches_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="rank_branches_+3A_diff_height">diff_height</code></td>
<td>
<p>Numeric scalar (1). Affects the difference in height
between two branches.</p>
</td></tr>
<tr><td><code id="rank_branches_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after adjusting the height attr in all of its branches.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_branches_heights">get_branches_heights</a>, <a href="#topic+get_childrens_heights">get_childrens_heights</a>,
<a href="#topic+hang.dendrogram">hang.dendrogram</a>, <a href="#topic+tanglegram">tanglegram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define dendrogram object to play with:
dend &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()

par(mfrow = c(1, 3))

plot(dend)
plot(rank_branches(dend))
plot(hang.dendrogram(rank_branches(dend)))
</code></pre>

<hr>
<h2 id='rank_order.dendrogram'>Fix rank of leaves order values in a dendrogram</h2><span id='topic+rank_order.dendrogram'></span>

<h3>Description</h3>

<p>Generally, leaves order value should be a sequence of integer values.
From 1 to nleaves(dend).
This function fixes trees by using <a href="base.html#topic+rank">rank</a> on existing leaves order
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_order.dendrogram(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_order.dendrogram_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="rank_order.dendrogram_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after fixing its leaves order values.
</p>


<h3>See Also</h3>

<p><a href="#topic+prune">prune</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define dendrogram object to play with:
dend &lt;- USArrests[1:4, ] %&gt;%
  dist() %&gt;%
  hclust(method = "ave") %&gt;%
  as.dendrogram()
# plot(dend)
order.dendrogram(dend)
dend2 &lt;- prune(dend, "Alaska")
order.dendrogram(dend2)
order.dendrogram(rank_order.dendrogram(dend2))
</code></pre>

<hr>
<h2 id='rank_values_with_clusters'>Rank a vector based on clusters</h2><span id='topic+rank_values_with_clusters'></span>

<h3>Description</h3>

<p>Rank a vector based on clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_values_with_clusters(x, ignore0 = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_values_with_clusters_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="rank_values_with_clusters_+3A_ignore0">ignore0</code></td>
<td>
<p>logical (FALSE). If TRUE, will ignore the 0's in the vector</p>
</td></tr>
<tr><td><code id="rank_values_with_clusters_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector with the number of unique values
as the number of uniques in the original vector.
And the values are ranked from 1 (in the beginning of the vector)
to the number of unique clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rank_values_with_clusters(c(1, 2, 3))
rank_values_with_clusters(c(1, 1, 3))
rank_values_with_clusters(c(0.1, 0.1, 3000))
rank_values_with_clusters(c(3, 1, 2))
rank_values_with_clusters(c(1, 3, 3, 3, 3, 3, 3, 4, 2, 2))

rank_values_with_clusters(c(3, 1, 2), ignore0 = TRUE)
rank_values_with_clusters(c(3, 1, 2), ignore0 = FALSE)
rank_values_with_clusters(c(3, 1, 0, 2), ignore0 = TRUE)
rank_values_with_clusters(c(3, 1, 0, 2), ignore0 = FALSE)
</code></pre>

<hr>
<h2 id='rect.dendrogram'>Draw Rectangles Around a Dendrogram's Clusters</h2><span id='topic+rect.dendrogram'></span>

<h3>Description</h3>

<p>Draws rectangles around the branches of a dendrogram
highlighting the corresponding clusters.
First the dendrogram is cut at a certain level,
then a rectangle is drawn around selected branches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rect.dendrogram(
  tree,
  k = NULL,
  which = NULL,
  x = NULL,
  h = NULL,
  border = 2,
  cluster = NULL,
  horiz = FALSE,
  density = NULL,
  angle = 45,
  text = NULL,
  text_cex = 1,
  text_col = 1,
  xpd = TRUE,
  lower_rect,
  upper_rect = 0,
  prop_k_height = 0.5,
  stop_if_out = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rect.dendrogram_+3A_tree">tree</code></td>
<td>
<p>a <a href="stats.html#topic+dendrogram">dendrogram</a> object.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_k">k</code></td>
<td>
<p>Scalar. Cut the dendrogram such that exactly k clusters (if possible) are produced.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_which">which</code></td>
<td>
<p>A vector selecting the clusters around
which a rectangle should be drawn. which selects clusters by number
(from left to right in the tree), Default is which = 1:k.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_x">x</code></td>
<td>
<p>A vector selecting the clusters around
which a rectangle should be drawn. x selects clusters
containing the respective horizontal coordinates.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_h">h</code></td>
<td>
<p>Scalar. Cut the dendrogram by cutting at height h. (k overrides h)</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_border">border</code></td>
<td>
<p>Vector with border colors for the rectangles.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_cluster">cluster</code></td>
<td>
<p>Optional vector with cluster memberships as returned by
cutree(dend_obj, k = k), can be specified for efficiency if already computed.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_horiz">horiz</code></td>
<td>
<p>logical (FALSE), indicating if the rectangles
should be drawn horizontally or not (for when using
plot(dend, horiz = TRUE) ) .</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_density">density</code></td>
<td>
<p>Passed to <a href="graphics.html#topic+rect">rect</a>: the density of shading lines,
in lines per inch. The default value of NULL means that
no shading lines are drawn. A zero value of density means
no shading lines whereas negative values (and NA)
suppress shading (and so allow color filling).
If border is a vector of colors, the color of density will default to 1.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_angle">angle</code></td>
<td>
<p>Passed to <a href="graphics.html#topic+rect">rect</a>: angle (in degrees) of the shading lines.
(default is 45)</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_text">text</code></td>
<td>
<p>a character vector of labels to plot underneath the clusters.
When NULL (default), no text is displayed.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_text_cex">text_cex</code></td>
<td>
<p>a numeric (scalar) value of the text's cex value.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_text_col">text_col</code></td>
<td>
<p>a (scalar) value of the text's col(or) value.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_xpd">xpd</code></td>
<td>
<p>A logical value (or NA.), passed to <a href="graphics.html#topic+par">par</a>.
Default is TRUE, in order to allow the rect to be below the labels.
If FALSE, all plotting is clipped to the plot region, if TRUE,
all plotting is clipped to the figure region, and if NA, all plotting
is clipped to the device region. See also <a href="graphics.html#topic+clip">clip</a>.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_lower_rect">lower_rect</code></td>
<td>
<p>a (scalar) value of how low should the lower part of the rect be.
If missing, it will take the value of par(&quot;usr&quot;)[3L] (or par(&quot;usr&quot;)[2L], depending
if horiz = TRUE or not), with also the width of the labels. (notice that we
would like to keep xpd = TRUE if we want the rect to be after the labels!)
You can use a value such as 0, to get the rect above the labels.
</p>
<p>Notice that for a plot with small margins, it would be better to set this
parameter manually.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_upper_rect">upper_rect</code></td>
<td>
<p>a (scalar) value to add (default is 0) to how high should the upper part of the rect be.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_prop_k_height">prop_k_height</code></td>
<td>
<p>a (scalar) value (should be between 0 to 1), indicating what proportion
of the height our rect will be between the height needed for k and k+1 clustering.</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_stop_if_out">stop_if_out</code></td>
<td>
<p>logical (default is TRUE). This makes the function
stop if k of the locator is outside the range (this default reproduces the behavior
of the rect.hclust function).</p>
</td></tr>
<tr><td><code id="rect.dendrogram_+3A_...">...</code></td>
<td>
<p>parameters passed to rect (such as lwd, lty, etc.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(Invisibly) returns a list where each element contains a vector
of data points contained in the respective cluster.
</p>


<h3>Source</h3>

<p>This function is based on <a href="stats.html#topic+rect.hclust">rect.hclust</a>, with slight modifications
to have it work with a dendrogram, as well as a few added features
(e.g: ... to rect, and horiz)
</p>
<p>The idea of adding text and shading lines under the clusters comes from
skullkey from here:
<a href="https://stackoverflow.com/questions/4720307/change-dendrogram-leaves">https://stackoverflow.com/questions/4720307/change-dendrogram-leaves</a>
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+rect.hclust">rect.hclust</a>, <a href="stats.html#topic+order.dendrogram">order.dendrogram</a>, <a href="#topic+cutree.dendrogram">cutree.dendrogram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(23235)
ss &lt;- sample(1:150, 10)
hc &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust()
dend &lt;- hc %&gt;% as.dendrogram()

plot(dend)
rect.dendrogram(dend, 2, border = 2)
rect.dendrogram(dend, 3, border = 4)
Vectorize(rect.dendrogram, "k")(dend, 4:5, border = 6)

plot(dend)
rect.dendrogram(dend, 3,
  border = 1:3,
  density = 2, text = c("1", "b", "miao"), text_cex = 3
)

plot(dend)
rect.dendrogram(dend, 4, which = c(1, 3), border = c(2, 3))
rect.dendrogram(dend, 4, x = 5, border = c(4))
rect.dendrogram(dend, 3, border = 3, lwd = 2, lty = 2)
# now THIS, you can not do with the old rect.hclust
plot(dend, horiz = TRUE)
rect.dendrogram(dend, 2, border = 2, horiz = TRUE)
rect.dendrogram(dend, 4, border = 4, lty = 2, lwd = 3, horiz = TRUE)

# This had previously failed since it worked with a wrong k.

dend15 &lt;- c(1:5) %&gt;%
  dist() %&gt;%
  hclust(method = "average") %&gt;%
  as.dendrogram()
# dend15 &lt;- c(1:25) %&gt;% dist %&gt;% hclust(method = "average") %&gt;% as.dendrogram
dend15 %&gt;%
  set("branches_k_color") %&gt;%
  plot()
dend15 %&gt;% rect.dendrogram(
  k = 3,
  border = 8, lty = 5, lwd = 2
)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reindex_dend'>Reindexing a pruned dendrogram</h2><span id='topic+reindex_dend'></span>

<h3>Description</h3>

<p><code>prune_leaf</code> does not update leaf indices as it prune
leaves. As a result, some leaves of the pruned dendrogram may have leaf
indeices larger than the number of leaves in the pruned dendrogram, which may
cause errors in downstream functions such as <code>as.hclust</code>.
</p>
<p>This function re-indexes the leaves such that the leaf indices are no larger
than the total number of leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reindex_dend(dend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reindex_dend_+3A_dend">dend</code></td>
<td>
<p>dendrogram object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dendrogram</code> object with the leaf reindexed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[1:5, ]), "ave")
dend &lt;- as.dendrogram(hc)

dend_pruned &lt;- prune(dend, c("Alaska", "California"), reindex_dend = FALSE)

## A leave have an index larger than the number of leaves:
unlist(dend_pruned)
# [1] 4 3 1
#'
dend_pruned_reindexed &lt;- reindex_dend(dend_pruned)

## All leaf indices are no larger than the number of leaves:
unlist(dend_pruned_reindexed)
# [1] 3 2 1

## The dendrograms are equal:
all.equal(dend_pruned, dend_pruned_reindexed)
# TRUE
</code></pre>

<hr>
<h2 id='remove_branches_edgePar'>Remove all edgePar values from a dendrogram's branches</h2><span id='topic+remove_branches_edgePar'></span>

<h3>Description</h3>

<p>Go through the dendrogram branches and remove its edgePar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_branches_edgePar(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_branches_edgePar_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="remove_branches_edgePar_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after removing the edgePar attribute in all of its branches,
</p>


<h3>See Also</h3>

<p><a href="#topic+get_root_branches_attr">get_root_branches_attr</a>, <a href="#topic+assign_values_to_branches_edgePar">assign_values_to_branches_edgePar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dend &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend &lt;- color_branches(dend, 3)
par(mfrow = c(1, 2))
plot(dend)
plot(remove_branches_edgePar(dend))

## End(Not run)

</code></pre>

<hr>
<h2 id='remove_leaves_nodePar'>Remove all nodePar values from a dendrogram's leaves</h2><span id='topic+remove_leaves_nodePar'></span>

<h3>Description</h3>

<p>Go through the dendrogram leaves and remove its nodePar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_leaves_nodePar(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_leaves_nodePar_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="remove_leaves_nodePar_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after removing the nodePar attribute in all of its leaves,
</p>


<h3>See Also</h3>

<p><a href="#topic+get_leaves_attr">get_leaves_attr</a>, <a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dend &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()

dend &lt;- color_labels(dend, 3)
par(mfrow = c(1, 2))
plot(dend)
plot(remove_leaves_nodePar(dend))


get_leaves_attr(dend, "nodePar")
get_leaves_attr(remove_leaves_nodePar(dend), "nodePar")

## End(Not run)

</code></pre>

<hr>
<h2 id='remove_nodes_nodePar'>Remove all nodePar values from a dendrogram's nodes</h2><span id='topic+remove_nodes_nodePar'></span>

<h3>Description</h3>

<p>Go through the dendrogram nodes and remove its nodePar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_nodes_nodePar(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_nodes_nodePar_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="remove_nodes_nodePar_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after removing the nodePar attribute in all of its nodes,
</p>


<h3>See Also</h3>

<p><a href="#topic+get_root_branches_attr">get_root_branches_attr</a>, <a href="#topic+assign_values_to_branches_edgePar">assign_values_to_branches_edgePar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dend &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend &lt;- color_branches(dend, 3)
par(mfrow = c(1, 2))
plot(dend)
plot(remove_branches_edgePar(dend))

## End(Not run)

</code></pre>

<hr>
<h2 id='rllply'>recursivly apply a function on a list</h2><span id='topic+rllply'></span>

<h3>Description</h3>

<p>recursivly apply a function on a list - and returns the output as a list,
following the naming convention in the plyr package
the big difference between this and rapply is that this will also apply
the function on EACH element of the list, even if it's not a &quot;terminal node&quot;
inside the list tree.
An attribute is added to indicate if the value returned is
from a branch or a leaf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rllply(x, FUN, add_notation = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rllply_+3A_x">x</code></td>
<td>
<p>a list.</p>
</td></tr>
<tr><td><code id="rllply_+3A_fun">FUN</code></td>
<td>
<p>a function to apply on each element of the list</p>
</td></tr>
<tr><td><code id="rllply_+3A_add_notation">add_notation</code></td>
<td>
<p>logical. Should each node be
added a &quot;position_type&quot; attribute, stating if it is a &quot;Branch&quot; or a &quot;Leaf&quot;.</p>
</td></tr>
<tr><td><code id="rllply_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with ALL of the nodes (from the original &quot;x&quot; list),
that FUN was applied on.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- list(1)
x
rllply(x, function(x) {
  x
}, add_notation = TRUE)

x &lt;- list(1, 2, list(31))
x
rllply(x, function(x) {
  x
}, add_notation = TRUE)
# the first element is the entire tree
# after FUN was applied to its root element.

hc &lt;- hclust(dist(USArrests[1:4, ]), "ave")
dend &lt;- as.dendrogram(hc)
rllply(dend, function(x) {
  attr(x, "height")
})
rllply(dend, function(x) {
  attr(x, "members")
})

## End(Not run)
</code></pre>

<hr>
<h2 id='rotate'>Rotate a tree object</h2><span id='topic+rotate'></span><span id='topic+rotate.default'></span><span id='topic+rotate.dendrogram'></span><span id='topic+rotate.hclust'></span><span id='topic+rotate.phylo'></span><span id='topic+sort.dendrogram'></span><span id='topic+sort.hclust'></span><span id='topic+sort.dendlist'></span><span id='topic+rev.hclust'></span>

<h3>Description</h3>

<p>Rotates, rev and sort the branches of a tree object (dendrogram, hclust)
based on a vector - eithor of labels order (numbers) or the labels in their
new order (character).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate(x, ...)

## Default S3 method:
rotate(x, order, ...)

## S3 method for class 'dendrogram'
rotate(x, order, ...)

## S3 method for class 'hclust'
rotate(x, order, ...)

## S3 method for class 'phylo'
rotate(x, ..., phy)

## S3 method for class 'dendrogram'
sort(x, decreasing = FALSE, type = c("labels", "nodes"), ...)

## S3 method for class 'hclust'
sort(x, decreasing = FALSE, ...)

## S3 method for class 'dendlist'
sort(x, ...)

## S3 method for class 'hclust'
rev(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_x">x</code></td>
<td>
<p>a tree object (either a <code>dendrogram</code> or <code>hclust</code>)</p>
</td></tr>
<tr><td><code id="rotate_+3A_...">...</code></td>
<td>
<p>parameters passed (for example, in case of sort)</p>
</td></tr>
<tr><td><code id="rotate_+3A_order">order</code></td>
<td>
<p>Either numeric or character vector.
Is numeric: it is a numeric vector with the order of the value to be
assigned to object's label. The numbers say are just like when you use <a href="base.html#topic+order">order</a>:
which of the items on the tree-plot should be &quot;first&quot; (e.g: most left),
second etc. (this is relevant only to <code>rotate</code>)
Is character: it must be a vector with the content of labels(x), in the
order we'd like to have the new tree.</p>
</td></tr>
<tr><td><code id="rotate_+3A_phy">phy</code></td>
<td>
<p>a placeholder in case the user uses &quot;phy =&quot;</p>
</td></tr>
<tr><td><code id="rotate_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort be increasing or decreasing? Not available for partial sorting. (relevant only to <code>sort</code>)</p>
</td></tr>
<tr><td><code id="rotate_+3A_type">type</code></td>
<td>
<p>a character indicating how to sort. If &quot;labels&quot; then by lexicographic
order of the labels. If &quot;nodes&quot;, then by using <a href="#topic+ladderize">ladderize</a> (order so that
recursively, the leftmost branch will be the smallest)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The motivation for this function came from the function
<code><a href="stats.html#topic+order.dendrogram">order.dendrogram</a></code> NOT being very intuitive.
What <code>rotate</code> aims to do is give a simple tree rotation function which
is based on the order which the user would like to see the tree rotated by
(just as <code><a href="base.html#topic+order">order</a></code> works for numeric vectors).
</p>
<p><code><a href="stats.html#topic+rev.dendrogram">rev.dendrogram</a></code> is part of base R, and returns the tree object
after rotating it so that the order of the labels is reversed.
Here we added an S3 method for hclust objects.
</p>
<p>The <code>sort</code> methods sort the labels of the tree (using <code>order</code>)
and then attempts to rotate the tree to fit that order.
</p>
<p>The hclust method of &quot;<code>rotate</code>&quot; works by first changing the object into
dendrogram, performing the rotation, and then changing it back to hclust.
Special care is taken in preserving some of the properties of the hclust
object.
</p>
<p>The ape package has its own <code><a href="ape.html#topic+rotate">rotate</a></code>(ape) function
(Which is sadly not S3, so cannot be easily connected with the
current implementation).  Still, there is an S3 plug that makes sure people
loading first ape and then dendextend will still be able to
use <code>rotate</code> without a problem.
Notice that if you will first load ape and only then dendextend,
using &quot;rotate&quot; will fail with the error: &quot;Error in rotate(dend, ____) :
object &quot;phy&quot; is not of class &quot;phylo&quot;&quot; - this is because rotate in ape
is not S3 and will fail to find the rotate.dendrogram function.
In such a case simply run <code>unloadNamespace(ape)</code>. Or, you can run:
<code>unloadNamespace("dendextend"); attachNamespace("dendextend")</code>
The solution for this is that if you have ape installed on your machine,
It will be loaded when you load dendextend (but after it).
This way, <code>rotate</code> will work fine for both dendrogram AND phylo
objects.
</p>


<h3>Value</h3>

<p>A rotated tree object
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+order.dendrogram">order.dendrogram</a></code>,  <code><a href="base.html#topic+order">order</a></code>,
<code><a href="stats.html#topic+rev.dendrogram">rev.dendrogram</a></code>, <code><a href="ape.html#topic+rotate">rotate</a></code> (ape), <a href="#topic+ladderize">ladderize</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[c(1, 6, 13, 20, 23), ]), "ave")
dend &lt;- as.dendrogram(hc)

# For dendrogram objects:
labels_colors(dend) &lt;- rainbow(nleaves(dend))
# let's color the labels to make the followup of the rotation easier
par(mfrow = c(1, 2))
plot(dend, main = "Original tree")
plot(rotate(dend, c(2:5, 1)),
  main =
    "Rotates the left most leaf \n into the right side of the tree"
)
par(mfrow = c(1, 2))
plot(dend, main = "Original tree")
plot(sort(dend), main = "Sorts the labels by alphabetical order \n
and rotates the tree to give the best fit possible")
par(mfrow = c(1, 2))
plot(dend, main = "Original tree")
plot(rev(dend), main = "Reverses the order of the tree labels")

# For hclust objects:
plot(hc)
plot(rotate(hc, c(2:5, 1)), main = "Rotates the left most leaf \n
into the right side of the tree")

par(mfrow = c(1, 3))
dend %&gt;% plot(main = "Original tree")
dend %&gt;%
  sort() %&gt;%
  plot(main = "labels sort")
dend %&gt;%
  sort(type = "nodes") %&gt;%
  plot(main = "nodes (ladderize) sort")
</code></pre>

<hr>
<h2 id='rotate_DendSer'>Rotates dend based on DendSer</h2><span id='topic+rotate_DendSer'></span>

<h3>Description</h3>

<p>Rotates a dendrogram based on its seriation
</p>
<p>The function tries to turn the dend into hclust using
<a href="#topic+DendSer.dendrogram">DendSer.dendrogram</a> (based on <a href="DendSer.html#topic+DendSer">DendSer</a>)
</p>
<p>Also, if a distance matrix is missing, it will try
to use the <a href="stats.html#topic+cophenetic">cophenetic</a> distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_DendSer(dend, ser_weight, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_DendSer_+3A_dend">dend</code></td>
<td>
<p>An object of class dendrogram</p>
</td></tr>
<tr><td><code id="rotate_DendSer_+3A_ser_weight">ser_weight</code></td>
<td>
<p>Used by cost function to evaluate
ordering. For cost=costLS, this is a vector of
object weights. Otherwise is a dist or symmetric matrix.
passed to <a href="#topic+DendSer.dendrogram">DendSer.dendrogram</a> and from
there to <a href="DendSer.html#topic+DendSer">DendSer</a>.
</p>
<p>If it is missing, the cophenetic distance is used instead.</p>
</td></tr>
<tr><td><code id="rotate_DendSer_+3A_...">...</code></td>
<td>
<p>parameters passed to <a href="DendSer.html#topic+DendSer">DendSer</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector giving an optimal dendrogram order
</p>


<h3>See Also</h3>

<p><code><a href="DendSer.html#topic+DendSer">DendSer</a></code>, <a href="#topic+DendSer.dendrogram">DendSer.dendrogram</a> ,
<a href="#topic+untangle_DendSer">untangle_DendSer</a>, <a href="#topic+rotate_DendSer">rotate_DendSer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(DendSer) # already used from within the function

dend &lt;- USArrests[1:4, ] %&gt;%
  dist() %&gt;%
  hclust("ave") %&gt;%
  as.dendrogram()
DendSer.dendrogram(dend)

tanglegram(dend, rotate_DendSer(dend))

## End(Not run)
</code></pre>

<hr>
<h2 id='sample.dendrogram'>Sample a tree</h2><span id='topic+sample.dendrogram'></span>

<h3>Description</h3>

<p>Samples a tree, either by permuting the labels (which is usefull for
a permutation test), or by repeated sampling of the same labels (essential
for bootstraping when we don't have access to the original data which
produced the tree).
</p>
<p>Duplicates a leaf in a tree. Useful for non-parametric bootstraping trees
since it emulates what would have happened if the tree was constructed based
on a row-sample with replacments from the original data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.dendrogram(
  dend,
  replace = FALSE,
  dend_labels,
  sampled_labels,
  fix_members = TRUE,
  fix_order = TRUE,
  fix_midpoint = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.dendrogram_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="sample.dendrogram_+3A_replace">replace</code></td>
<td>
<p>logical (FALSE). Should we shuffle the labels (if FALSE),
or should we replicate the same leaf over and over, while omitting other
leaves? (this is when set to TRUE).</p>
</td></tr>
<tr><td><code id="sample.dendrogram_+3A_dend_labels">dend_labels</code></td>
<td>
<p>a character vector of the tree's labels.
This can save the time it takes for getting the tree labels (in case we run
a simulating, computing this once might save some running time).
If missing, it uses <a href="base.html#topic+labels">labels</a> in order to get the labels.</p>
</td></tr>
<tr><td><code id="sample.dendrogram_+3A_sampled_labels">sampled_labels</code></td>
<td>
<p>a character vector of the tree's sampled labels.
This can help us if we wish to compare two trees. In such a case we'd like
to be able to have the same sample of labels used on both trees.
If missing, it uses <a href="base.html#topic+sample">sample</a> in order to get the sampled labels.
</p>
<p>Only works when replace=TRUE!</p>
</td></tr>
<tr><td><code id="sample.dendrogram_+3A_fix_members">fix_members</code></td>
<td>
<p>logical (TRUE). Fix the number of members in attr
using <a href="#topic+fix_members_attr.dendrogram">fix_members_attr.dendrogram</a></p>
</td></tr>
<tr><td><code id="sample.dendrogram_+3A_fix_order">fix_order</code></td>
<td>
<p>logical (TRUE). Fix the leaves order</p>
</td></tr>
<tr><td><code id="sample.dendrogram_+3A_fix_midpoint">fix_midpoint</code></td>
<td>
<p>logical (TRUE). Fix the midpoint value.
If TRUE, it overrides &quot;fix_members&quot; and turns it into TRUE (since it must
have a correct number of members in order to work).
values using <a href="#topic+rank_order.dendrogram">rank_order.dendrogram</a></p>
</td></tr>
<tr><td><code id="sample.dendrogram_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram, after &quot;sampling&quot; its leaves.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+sample">sample</a>, <a href="#topic+duplicate_leaf">duplicate_leaf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# define dendrogram object to play with:
dend &lt;- USArrests[1:5, ] %&gt;%
  dist() %&gt;%
  hclust(method = "ave") %&gt;%
  as.dendrogram()
plot(dend)

# # same tree, with different order of labels
plot(sample.dendrogram(dend, replace = FALSE))

# # A different tree (!), with some labels duplicated,
# while others are pruned
plot(sample.dendrogram(dend, replace = TRUE))

## End(Not run)

</code></pre>

<hr>
<h2 id='seriate_dendrogram'>Rotates a dendrogram based on a seriation of a distance matrix</h2><span id='topic+seriate_dendrogram'></span>

<h3>Description</h3>

<p>Rotates a dendrogram so it confirms to an order of a provided distance object.
The seriation algorithm is based on <a href="seriation.html#topic+seriate">seriate</a>, which tries to find
a linear order for objects using data in form of a dissimilarity matrix (one mode data).
</p>
<p>This is useful for heatmap visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriate_dendrogram(dend, x, method = c("OLO", "GW"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriate_dendrogram_+3A_dend">dend</code></td>
<td>
<p>An object of class <a href="stats.html#topic+dendrogram">dendrogram</a> or <a href="stats.html#topic+hclust">hclust</a></p>
</td></tr>
<tr><td><code id="seriate_dendrogram_+3A_x">x</code></td>
<td>
<p>a <a href="stats.html#topic+dist">dist</a> object.</p>
</td></tr>
<tr><td><code id="seriate_dendrogram_+3A_method">method</code></td>
<td>
<p>a character vector of either &quot;OLO&quot; or &quot;GW&quot;:
&quot;OLO&quot; - Optimal leaf ordering, optimzes the Hamiltonian path length that is restricted by the dendrogram structure - works in O(n^4)
&quot;GW&quot; - Gruvaeus and Wainer heuristic to optimze the Hamiltonian path length that is restricted by the dendrogram structure</p>
</td></tr>
<tr><td><code id="seriate_dendrogram_+3A_...">...</code></td>
<td>
<p>parameters passed to <a href="seriation.html#topic+seriate">seriate</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram that is rotated based on the optimal ordering of the distance matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotate">rotate</a></code>, <a href="seriation.html#topic+seriate">seriate</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# library(dendextend)
d &lt;- dist(USArrests)
hc &lt;- hclust(d, "ave")
dend &lt;- as.dendrogram(hc)

heatmap(as.matrix(USArrests))

dend2 &lt;- seriate_dendrogram(dend, d)
heatmap(as.matrix(USArrests), Rowv = dend)

## End(Not run)
</code></pre>

<hr>
<h2 id='set'>Set (/update) features to a dendrogram</h2><span id='topic+set'></span><span id='topic+set.dendrogram'></span><span id='topic+set.dendlist'></span><span id='topic+set.data.table'></span>

<h3>Description</h3>

<p>a master function for updating various attributes and
features of dendrogram objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set(dend, ...)

## S3 method for class 'dendrogram'
set(
  dend,
  what = c("labels", "labels_colors", "labels_cex", "labels_to_character", "leaves_pch",
    "leaves_cex", "leaves_col", "leaves_bg", "nodes_pch", "nodes_cex", "nodes_col",
    "nodes_bg", "hang_leaves", "rank_branches", "branches_k_color", "branches_k_lty",
    "branches_col", "branches_lwd", "branches_lty", "by_labels_branches_col",
    "by_labels_branches_lwd", "by_labels_branches_lty", "by_lists_branches_col",
    "by_lists_branches_lwd", "by_lists_branches_lty", "highlight_branches_col",
    "highlight_branches_lwd", "clear_branches", 
     "clear_leaves"),
  value,
  order_value = FALSE,
  ...
)

## S3 method for class 'dendlist'
set(dend, ..., which)

## S3 method for class 'data.table'
set(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_+3A_dend">dend</code></td>
<td>
<p>a tree (<a href="stats.html#topic+dendrogram">dendrogram</a>, or <a href="#topic+dendlist">dendlist</a>)</p>
</td></tr>
<tr><td><code id="set_+3A_...">...</code></td>
<td>
<p>passed to the specific function for more options.</p>
</td></tr>
<tr><td><code id="set_+3A_what">what</code></td>
<td>
<p>a character indicating what is the property of
the tree that should be set/updated. (see the usage and the example section
for the different options)</p>
</td></tr>
<tr><td><code id="set_+3A_value">value</code></td>
<td>
<p>an object with the value to set in the dendrogram tree.
(the type of the value depends on the &quot;what&quot;)</p>
</td></tr>
<tr><td><code id="set_+3A_order_value">order_value</code></td>
<td>
<p>logical. Default is FALSE. If TRUE, it means the order of
the value is in the order of the data which produced the <a href="stats.html#topic+hclust">hclust</a>
or <a href="stats.html#topic+dendrogram">dendrogram</a> - and will reorder the value to conform with the order
of the labels in the dendrogram.</p>
</td></tr>
<tr><td><code id="set_+3A_which">which</code></td>
<td>
<p>an integer vector indicating, in the case &quot;dend&quot; is
a dendlist, on which of the trees should the modification be performed.
If missing - the change will be performed on all of dends in the dendlist.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for many of the main tasks we
might wish to perform on a dendrogram before plotting.
</p>
<p>The options of by_labels_branches_col, by_labels_branches_lwd, by_labels_branches_lty
have extra parameters: type, attr, TF_value, and by_lists_branches_col, by_lists_branches_lwd,
by_lists_branches_lty have extra parameters: attr, TF_value. You can read more about them here:
<a href="#topic+branches_attr_by_labels">branches_attr_by_labels</a> and <a href="#topic+branches_attr_by_lists">branches_attr_by_lists</a>
</p>
<p>The &quot;what&quot; parameter&quot; can accept the following options:
</p>

<ul>
<li><p>labels - set the labels (<a href="#topic+labels+3C-.dendrogram">labels&lt;-.dendrogram</a>)
</p>
</li>
<li><p>labels_colors - set the labels' colors (<a href="#topic+color_labels">color_labels</a>)
</p>
</li>
<li><p>labels_cex - set the labels' size (<a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>)
</p>
</li>
<li><p>labels_to_character - set the labels' to be characters
</p>
</li>
<li><p>leaves_pch - set the leaves' point type (<a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>). A leave is the terminal node of the tree.
</p>
</li>
<li><p>leaves_cex - set the leaves' point size (<a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>). For using this you MUST also set leaves_pch, a good value to use is 19.
</p>
</li>
<li><p>leaves_col - set the leaves' point color (<a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>). For using this you MUST also set leaves_pch, a good value to use is 19.
</p>
</li>
<li><p>leaves_bg - set the leaves' point fill color (<a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>). For using this you MUST also set leaves_pch with values from 21-25.
</p>
</li>
<li><p>nodes_pch - set the nodes' point type (<a href="#topic+assign_values_to_nodes_nodePar">assign_values_to_nodes_nodePar</a>)
</p>
</li>
<li><p>nodes_cex - set the nodes' point size (<a href="#topic+assign_values_to_nodes_nodePar">assign_values_to_nodes_nodePar</a>)
</p>
</li>
<li><p>nodes_col - set the nodes' point color (<a href="#topic+assign_values_to_nodes_nodePar">assign_values_to_nodes_nodePar</a>)
</p>
</li>
<li><p>nodes_bg - set the nodes' point fill color (<a href="#topic+assign_values_to_nodes_nodePar">assign_values_to_nodes_nodePar</a>). For using this you MUST also set leaves_pch with values from 21-25.
</p>
</li>
<li><p>hang_leaves - hang the leaves (<a href="#topic+hang.dendrogram">hang.dendrogram</a>)
</p>
</li>
<li><p>branches_k_color - color the branches (<a href="#topic+color_branches">color_branches</a>), a <code>k</code> parameter needs to be supplied.
</p>
</li>
<li><p>branches_k_lty - updates the lwd of the branches (similar to branches_k_color), a <code>k</code> parameter needs to be supplied.
</p>
</li>
<li><p>branches_col - set the color of branches (<a href="#topic+assign_values_to_branches_edgePar">assign_values_to_branches_edgePar</a>) 
</p>
</li>
<li><p>branches_lwd - set the line width of branches (<a href="#topic+assign_values_to_branches_edgePar">assign_values_to_branches_edgePar</a>) 
</p>
</li>
<li><p>branches_lty - set the line type of branches (<a href="#topic+assign_values_to_branches_edgePar">assign_values_to_branches_edgePar</a>) 
</p>
</li>
<li><p>by_labels_branches_col - set the color of branches with specific labels (<a href="#topic+branches_attr_by_labels">branches_attr_by_labels</a>) 
</p>
</li>
<li><p>by_labels_branches_lwd - set the line width of branches with specific labels (<a href="#topic+branches_attr_by_labels">branches_attr_by_labels</a>) 
</p>
</li>
<li><p>by_labels_branches_lty - set the line type of branches with specific labels (<a href="#topic+branches_attr_by_labels">branches_attr_by_labels</a>) 
</p>
</li>
<li><p>by_lists_branches_col - set the color of branches from the root of the tree down to (possibly inner) nodes with specified members (<a href="#topic+branches_attr_by_lists">branches_attr_by_lists</a>) 
</p>
</li>
<li><p>by_lists_branches_lwd - set the line width of branches from the root of the tree down to (possibly inner) nodes with specified members (<a href="#topic+branches_attr_by_lists">branches_attr_by_lists</a>) 
</p>
</li>
<li><p>by_lists_branches_lty - set the line type of branches from the root of the tree down to (possibly inner) nodes with specified members (<a href="#topic+branches_attr_by_lists">branches_attr_by_lists</a>) 
</p>
</li>
<li><p>highlight_branches_col - highlight branches color based on branches' heights (<a href="#topic+highlight_branches_col">highlight_branches_col</a>) 
</p>
</li>
<li><p>highlight_branches_lwd - highlight branches line-width based on branches' heights (<a href="#topic+highlight_branches_lwd">highlight_branches_lwd</a>) 
</p>
</li>
<li><p>clear_branches - clear branches' attributes (<a href="#topic+remove_branches_edgePar">remove_branches_edgePar</a>)
</p>
</li>
<li><p>clear_leaves - clear leaves' attributes (<a href="#topic+remove_branches_edgePar">remove_branches_edgePar</a>)
</p>
</li></ul>



<h3>Value</h3>

<p>An updated dendrogram (or dendlist), with some change to
the parameters of it
</p>


<h3>See Also</h3>

<p><a href="#topic+labels+3C-.dendrogram">labels&lt;-.dendrogram</a>, <a href="#topic+labels_colors+3C-">labels_colors&lt;-</a>,
<a href="#topic+hang.dendrogram">hang.dendrogram</a>, <a href="#topic+color_branches">color_branches</a>,
<a href="#topic+assign_values_to_leaves_nodePar">assign_values_to_leaves_nodePar</a>,
<a href="#topic+assign_values_to_branches_edgePar">assign_values_to_branches_edgePar</a>,
<a href="#topic+remove_branches_edgePar">remove_branches_edgePar</a>, <a href="#topic+remove_leaves_nodePar">remove_leaves_nodePar</a>,
<a href="#topic+noded_with_condition">noded_with_condition</a>, <a href="#topic+branches_attr_by_labels">branches_attr_by_labels</a>, <a href="#topic+branches_attr_by_lists">branches_attr_by_lists</a>,
<a href="stats.html#topic+dendrogram">dendrogram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- sample(1:150, 10)

# Getting the dend object
dend &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend %&gt;% plot()

dend %&gt;% labels()
dend %&gt;%
  set("labels", 1:10) %&gt;%
  labels()
dend %&gt;%
  set("labels", 1:10) %&gt;%
  plot()
dend %&gt;%
  set("labels_color") %&gt;%
  plot()
dend %&gt;%
  set("labels_col", c(1, 2)) %&gt;%
  plot() # Works also with partial matching :)
dend %&gt;%
  set("labels_cex", c(1, 1.2)) %&gt;%
  plot()
dend %&gt;%
  set("leaves_pch", NA) %&gt;%
  plot()
dend %&gt;%
  set("leaves_pch", c(1:5)) %&gt;%
  plot()
dend %&gt;%
  set("leaves_pch", c(19, 19, NA)) %&gt;%
  set("leaves_cex", c(1, 2)) %&gt;%
  plot()
dend %&gt;%
  set("leaves_pch", c(19, 19, NA)) %&gt;%
  set("leaves_cex", c(1, 2)) %&gt;%
  set("leaves_col", c(1, 1, 2, 2)) %&gt;%
  plot()
dend %&gt;%
  set("hang") %&gt;%
  plot()

# using bg for leaves and nodes

set.seed(23235)
ss &lt;- sample(1:150, 25)

# Getting the dend object
dend25 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()

dend25 %&gt;%
  set("labels", 1:25) %&gt;%
  set("nodes_pch", 21) %&gt;% # set all nodes to be pch 21
  set("nodes_col", "darkred") %&gt;%
  set("nodes_bg", "gold") %&gt;%
  set("leaves_pch", 1:25) %&gt;% # Change the leaves pch to move from 1 to 25
  set("leaves_col", "darkred") %&gt;%
  set("leaves_bg", "gold") %&gt;%
  plot(main = "pch 21 to 25 supports the\nnodes_bg and leaves_bg parameters")
  
  
dend %&gt;%
  set("branches_k_col") %&gt;%
  plot()
dend %&gt;%
  set("branches_k_col", c(1, 2)) %&gt;%
  plot()
dend %&gt;%
  set("branches_k_col", c(1, 2, 3), k = 3) %&gt;%
  plot()
dend %&gt;%
  set("branches_k_col", k = 3) %&gt;%
  plot()

dend %&gt;%
  set("branches_k_lty", k = 3) %&gt;%
  plot()
dend %&gt;%
  set("branches_k_col", k = 3) %&gt;%
  set("branches_k_lty", k = 3) %&gt;%
  plot()

dend %&gt;%
  set("branches_col", c(1, 2, 1, 2, NA)) %&gt;%
  plot()
dend %&gt;%
  set("branches_lwd", c(2, 1, 2)) %&gt;%
  plot()
dend %&gt;%
  set("branches_lty", c(1, 2, 1)) %&gt;%
  plot()

#    clears all of the things added to the leaves
dend %&gt;%
  set("labels_color", c(19, 19, NA)) %&gt;%
  set("leaves_pch", c(19, 19, NA)) %&gt;% # plot
  set("clear_leaves") %&gt;% # remove all of what was done until this point
  plot()
# Different order
dend %&gt;%
  set("leaves_pch", c(19, 19, NA)) %&gt;%
  set("labels_color", c(19, 19, NA)) %&gt;%
  set("clear_leaves") %&gt;%
  plot()


# doing this without chaining (%&gt;%) will NOT be fun:
dend %&gt;%
  set("labels", 1:10) %&gt;%
  set("labels_color") %&gt;%
  set("branches_col", c(1, 2, 1, 2, NA)) %&gt;%
  set("branches_lwd", c(2, 1, 2)) %&gt;%
  set("branches_lty", c(1, 2, 1)) %&gt;%
  set("hang") %&gt;%
  plot()

par(mfrow = c(1, 3))
dend %&gt;%
  set("highlight_branches_col") %&gt;%
  plot()
dend %&gt;%
  set("highlight_branches_lwd") %&gt;%
  plot()
dend %&gt;%
  set("highlight_branches_col") %&gt;%
  set("highlight_branches_lwd") %&gt;%
  plot()
par(mfrow = c(1, 1))

#----------------------------
# Examples for: by_labels_branches_col, by_labels_branches_lwd, by_labels_branches_lty

old_labels &lt;- labels(dend)
dend %&gt;%
  set("labels", seq_len(nleaves(dend))) %&gt;%
  set("by_labels_branches_col", c(1:4, 7)) %&gt;%
  set("by_labels_branches_lwd", c(1:4, 7)) %&gt;%
  set("by_labels_branches_lty", c(1:4, 7)) %&gt;%
  set("labels", old_labels) %&gt;%
  plot()

dend %&gt;%
  set("labels", seq_len(nleaves(dend))) %&gt;%
  set("by_labels_branches_col", c(1:4, 7), type = "any", TF_values = c(4, 2)) %&gt;%
  set("by_labels_branches_lwd", c(1:4, 7), type = "all", TF_values = c(4, 1)) %&gt;%
  set("by_labels_branches_lty", c(1:4, 7), TF_values = c(4, 1)) %&gt;%
  plot()

#---- using order_value
# This is probably not what you want, since cutree
# returns clusters in the order of the original data:
dend %&gt;%
  set("labels_colors", cutree(dend, k = 3)) %&gt;%
  plot()
# The way to fix it, is to use order_value = TRUE
# so that value is assumed to be in the order of the data:
dend %&gt;%
  set("labels_colors", cutree(dend, k = 3), order_value = TRUE) %&gt;%
  plot()


#----------------------------
# Example for: by_lists_branches_col, by_lists_branches_lwd, by_lists_branches_lty

L &lt;- list(c("109", "123", "126", "145"), "29", c("59", "67", "97"))
dend %&gt;%
  set("by_lists_branches_col", L, TF_value = "blue") %&gt;%
  set("by_lists_branches_lwd", L, TF_value = 4) %&gt;%
  set("by_lists_branches_lty", L, TF_value = 3) %&gt;%
  plot()


#----------------------------
# A few dendlist examples:
dendlist(dend, dend) %&gt;%
  set("hang") %&gt;%
  plot()
dendlist(dend, dend) %&gt;%
  set("branches_k_col", k = 3) %&gt;%
  plot()
dendlist(dend, dend) %&gt;%
  set("labels_col", c(1, 2)) %&gt;%
  plot()

dendlist(dend, dend) %&gt;%
  set("hang") %&gt;%
  set("labels_col", c(1, 2), which = 1) %&gt;%
  set("branches_k_col", k = 3, which = 2) %&gt;%
  set("labels_cex", 1.2) %&gt;%
  plot()


#----------------------------
# example of modifying the dendrogram in a heatmap:

library(gplots)
data(mtcars)
x &lt;- as.matrix(mtcars)
rc &lt;- rainbow(nrow(x), start = 0, end = .3)
cc &lt;- rainbow(ncol(x), start = 0, end = .3)

##
##' demonstrate the effect of row and column dendrogram options
##
Rowv_dend &lt;- x %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("branches_k", k = 3) %&gt;%
  set("branches_lwd", 2) %&gt;%
  ladderize() # rotate_DendSer
Colv_dend &lt;- t(x) %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("branches_k", k = 3) %&gt;%
  set("branches_lwd", 2) %&gt;%
  ladderize() # rotate_DendSer
heatmap.2(x, Rowv = Rowv_dend, Colv = Colv_dend)

## End(Not run)
</code></pre>

<hr>
<h2 id='set_labels'>Set/place new labels in a dendrogram</h2><span id='topic+set_labels'></span><span id='topic+place_labels'></span>

<h3>Description</h3>

<p>Convenience functions for updating the labels of a dendrogram.
set_labels and place_labels differs in their assumption about the order of the labels.
* set_labels assumes the labels are in the same order as that of the labels in the dendrogram.
* place_labels assumes the labels has the same order as that of the items in the original data matrix.
This is useful for renaming labels based on some other columns in the data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_labels(dend, labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_labels_+3A_dend">dend</code></td>
<td>
<p>a <a href="stats.html#topic+dendrogram">dendrogram</a> object</p>
</td></tr>
<tr><td><code id="set_labels_+3A_labels">labels</code></td>
<td>
<p>A vector of values to insert in the labels of a dendrogram.</p>
</td></tr>
<tr><td><code id="set_labels_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <a href="stats.html#topic+dendrogram">dendrogram</a> object
</p>


<h3>Author(s)</h3>

<p>Tal Galili, Garrett Grolemund
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+labels">labels</a></code>, <code><a href="#topic+set">set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ss &lt;- c(
  50, 114, 17, 102, 76, 10, 107, 84, 31, 37, 49, 106, 44, 119,
  104, 145, 67, 85, 12, 77, 22, 136, 38, 135, 70
)

small_iris &lt;- iris[ss, ]

small_iris[, -5] %&gt;%
  dist() %&gt;%
  hclust(method = "complete") %&gt;%
  as.dendrogram() %&gt;%
  color_branches(k = 3) %&gt;%
  color_labels(k = 3) %&gt;%
  plot()

# example for using place_labels
small_iris[, -5] %&gt;%
  dist() %&gt;%
  hclust(method = "complete") %&gt;%
  as.dendrogram() %&gt;%
  color_branches(k = 3) %&gt;%
  color_labels(k = 3) %&gt;%
  place_labels(paste(small_iris$Species, 1:25, sep = "_")) %&gt;%
  plot()

# example for using set_labels
small_iris[, -5] %&gt;%
  dist() %&gt;%
  hclust(method = "complete") %&gt;%
  as.dendrogram() %&gt;%
  color_branches(k = 3) %&gt;%
  color_labels(k = 3) %&gt;%
  set_labels(1:25) %&gt;%
  plot()
</code></pre>

<hr>
<h2 id='shuffle'>Random rotation of trees</h2><span id='topic+shuffle'></span><span id='topic+shuffle.default'></span><span id='topic+shuffle.dendrogram'></span><span id='topic+shuffle.dendlist'></span><span id='topic+shuffle.hclust'></span><span id='topic+shuffle.phylo'></span>

<h3>Description</h3>

<p>'shuffle' randomilly rotates (&quot;shuffles&quot;) a tree, changing its presentation
while preserving its topolgoy.
'shuffle' is based on <a href="#topic+rotate">rotate</a> and through its methods can
work for any of the major tree objects in R (<a href="stats.html#topic+dendrogram">dendrogram</a>/<a href="stats.html#topic+hclust">hclust</a>/<a href="ape.html#topic+phylo">phylo</a>).
</p>
<p>This function is useful in combination with <a href="#topic+tanglegram">tanglegram</a> and <a href="#topic+entanglement">entanglement</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle(dend, ...)

## Default S3 method:
shuffle(dend, ...)

## S3 method for class 'dendrogram'
shuffle(dend, ...)

## S3 method for class 'dendlist'
shuffle(dend, which, ...)

## S3 method for class 'hclust'
shuffle(dend, ...)

## S3 method for class 'phylo'
shuffle(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shuffle_+3A_dend">dend</code></td>
<td>
<p>a tree object (<a href="stats.html#topic+dendrogram">dendrogram</a>/<a href="stats.html#topic+hclust">hclust</a>/<a href="ape.html#topic+phylo">phylo</a>)</p>
</td></tr>
<tr><td><code id="shuffle_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="shuffle_+3A_which">which</code></td>
<td>
<p>an integer vector for indicating
which of the trees in the dendlist object should be plotted
default is missing, in which case all the dends in dendlist
will be shuffled</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'shuffle' is a function that randomilly rotates (&quot;shuffles&quot;) a tree.
a dendrogram leaves order (by means of rotation)
</p>


<h3>Value</h3>

<p>A randomlly rotated tree object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tanglegram">tanglegram</a></code>,  <code><a href="#topic+entanglement">entanglement</a></code>,
<code><a href="#topic+rotate">rotate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dend &lt;- USArrests %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
set.seed(234238)
dend2 &lt;- shuffle(dend)

tanglegram(dend, dend2, margin_inner = 7)
entanglement(dend, dend2) # 0.3983

# although these ARE the SAME tree:
tanglegram(sort(dend), sort(dend2), margin_inner = 7)
</code></pre>

<hr>
<h2 id='sort_2_clusters_vectors'>Sorts two clusters vector by their names</h2><span id='topic+sort_2_clusters_vectors'></span>

<h3>Description</h3>

<p>Sorts two clusters vector by their names and returns a list with the sorted vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_2_clusters_vectors(
  A1_clusters,
  A2_clusters,
  assume_sorted_vectors = FALSE,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_2_clusters_vectors_+3A_a1_clusters">A1_clusters</code></td>
<td>
<p>a numeric vector of cluster grouping (numeric) of items,
with a name attribute of item name for each element from group A1.
These are often obtained by using some k cut on a dendrogram.</p>
</td></tr>
<tr><td><code id="sort_2_clusters_vectors_+3A_a2_clusters">A2_clusters</code></td>
<td>
<p>a numeric vector of cluster grouping (numeric) of items,
with a name attribute of item name for each element from group A2.
These are often obtained by using some k cut on a dendrogram.</p>
</td></tr>
<tr><td><code id="sort_2_clusters_vectors_+3A_assume_sorted_vectors">assume_sorted_vectors</code></td>
<td>
<p>logical (FALSE). Can we assume to two group
vectors are sorter so that they have the same order of items?
IF FALSE (default), then the vectors will be sorted based on their
name attribute.</p>
</td></tr>
<tr><td><code id="sort_2_clusters_vectors_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.</p>
</td></tr>
<tr><td><code id="sort_2_clusters_vectors_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements, corresponding to the two clustering vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set.seed(23235)
ss &lt;- sample(1:150, 4)
hc1 &lt;- hclust(dist(iris[ss, -5]), "com")
hc2 &lt;- hclust(dist(iris[ss, -5]), "single")
# dend1 &lt;- as.dendrogram(hc1)
# dend2 &lt;- as.dendrogram(hc2)
#    cutree(dend1)

A1_clusters &lt;- cutree(hc1, k = 3)
A2_clusters &lt;- sample(cutree(hc1, k = 3))

sort_2_clusters_vectors(A1_clusters, A2_clusters, assume_sorted_vectors = TRUE) # no sorting
sort_2_clusters_vectors(A1_clusters, A2_clusters, assume_sorted_vectors = FALSE) # Sorted

## End(Not run)
</code></pre>

<hr>
<h2 id='sort_dist_mat'>Sorts a distance matrix by rows and columns names</h2><span id='topic+sort_dist_mat'></span>

<h3>Description</h3>

<p>Sorts a distance matrix by the names of the rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_dist_mat(dist_mat, by_rows = TRUE, by_cols = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_dist_mat_+3A_dist_mat">dist_mat</code></td>
<td>
<p>a distance matrix.</p>
</td></tr>
<tr><td><code id="sort_dist_mat_+3A_by_rows">by_rows</code></td>
<td>
<p>logical (TRUE). Sort the distance matrix by rows?</p>
</td></tr>
<tr><td><code id="sort_dist_mat_+3A_by_cols">by_cols</code></td>
<td>
<p>logical (TRUE). Sort the distance matrix by columns?</p>
</td></tr>
<tr><td><code id="sort_dist_mat_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix (after sorting)
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+dist">dist</a>, <a href="#topic+cor_cophenetic">cor_cophenetic</a>
</p>

<hr>
<h2 id='sort_levels_values'>Sort the values level in a vector</h2><span id='topic+sort_levels_values'></span>

<h3>Description</h3>

<p>Takes a numeric vector and sort its values so that they
would be increasing from left to right.
It is different from <code><a href="base.html#topic+sort">sort</a></code> in that the function
will only &quot;sort&quot; the values levels, and not the vector itself.
</p>
<p>This function is useful for <a href="#topic+cutree">cutree</a> - making the
sort_cluster_numbers parameter possible. Using that parameter with TRUE
makes the clusters id's from cutree to be ordered from left to right.
e.g: the left most cluster in the tree will be numbered &quot;1&quot;, the one
after it will be &quot;2&quot; etc...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_levels_values(
  x,
  MARGIN = 2,
  decreasing = FALSE,
  force_integer = FALSE,
  warn = dendextend_options("warn"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_levels_values_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="sort_levels_values_+3A_margin">MARGIN</code></td>
<td>
<p>passed to <a href="base.html#topic+apply">apply</a>. It is a vector giving the subscripts
which the function will be applied over.
E.g., for a matrix 1 indicates rows, 2 indicates columns,
c(1, 2) indicates rows and columns. Where X has named dimnames,
it can be a character vector selecting dimension names.</p>
</td></tr>
<tr><td><code id="sort_levels_values_+3A_decreasing">decreasing</code></td>
<td>
<p>logical (FALSE). Should the sort be increasing or decreasing?</p>
</td></tr>
<tr><td><code id="sort_levels_values_+3A_force_integer">force_integer</code></td>
<td>
<p>logical (FALSE). Should the values returned be integers?</p>
</td></tr>
<tr><td><code id="sort_levels_values_+3A_warn">warn</code></td>
<td>
<p>logical (default from dendextend_options(&quot;warn&quot;) is FALSE).
Set if warning are to be issued, it is safer to keep this at TRUE,
but for keeping the noise down, the default is FALSE.
(for example when x had NA values in it)</p>
</td></tr>
<tr><td><code id="sort_levels_values_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if x is an object - it returns logical - is the object of class dendrogram.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sort">sort</a></code>, <code><a href="#topic+fac2num">fac2num</a></code>, <code><a href="#topic+cutree">cutree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:4
sort_levels_values(x) # 1 2 3 4

x &lt;- c(4:1)
names(x) &lt;- letters[x]
attr(x, "keep_me") &lt;- "a cat"
sort_levels_values(x) # 1 2 3 4

x &lt;- c(4:1, 4, 2)
sort_levels_values(x) # 1 2 3 4 1 3

x &lt;- c(2, 2, 3, 2, 1)
sort_levels_values(x) # 1 1 2 1 3

x &lt;- matrix(16:1, 4, 4)
rownames(x) &lt;- letters[1:4]
x
apply(x, 2, sort_levels_values)
</code></pre>

<hr>
<h2 id='tanglegram'>Tanglegram plot</h2><span id='topic+tanglegram'></span><span id='topic+tanglegram.default'></span><span id='topic+tanglegram.hclust'></span><span id='topic+tanglegram.phylo'></span><span id='topic+tanglegram.dendlist'></span><span id='topic+tanglegram.dendrogram'></span><span id='topic+dendbackback'></span>

<h3>Description</h3>

<p>Plots a tanglegram plot of a side by side trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tanglegram(dend1, ...)

## Default S3 method:
tanglegram(dend1, ...)

## S3 method for class 'hclust'
tanglegram(dend1, ...)

## S3 method for class 'phylo'
tanglegram(dend1, ...)

## S3 method for class 'dendlist'
tanglegram(
  dend1,
  which = c(1L, 2L),
  main_left,
  main_right,
  just_one = TRUE,
  ...
)

## S3 method for class 'dendrogram'
tanglegram(
  dend1,
  dend2,
  sort = FALSE,
  color_lines,
  lwd = 3.5,
  edge.lwd = NULL,
  columns_width = c(5, 3, 5),
  margin_top = 3,
  margin_bottom = 2.5,
  margin_inner = 3,
  margin_outer = 0.5,
  left_dendo_mar = c(margin_bottom, margin_outer, margin_top, margin_inner),
  right_dendo_mar = c(margin_bottom, margin_inner, margin_top, margin_outer),
  intersecting = TRUE,
  dLeaf = NULL,
  dLeaf_left = dLeaf,
  dLeaf_right = dLeaf,
  axes = TRUE,
  type = "r",
  lab.cex = NULL,
  remove_nodePar = FALSE,
  main = "",
  main_left = "",
  main_right = "",
  sub = "",
  k_labels = NULL,
  k_branches = NULL,
  rank_branches = FALSE,
  hang = FALSE,
  match_order_by_labels = TRUE,
  cex_main = 2,
  cex_main_left = cex_main,
  cex_main_right = cex_main,
  cex_sub = cex_main,
  highlight_distinct_edges = TRUE,
  common_subtrees_color_lines = TRUE,
  common_subtrees_color_lines_default_single_leaf_color = "grey",
  common_subtrees_color_branches = FALSE,
  highlight_branches_col = FALSE,
  highlight_branches_lwd = TRUE,
  faster = FALSE,
  just_one = TRUE,
  ...
)

dendbackback(
  dend1,
  dend2,
  sort = FALSE,
  color_lines,
  lwd = 3.5,
  edge.lwd = NULL,
  columns_width = c(5, 3, 5),
  margin_top = 3,
  margin_bottom = 2.5,
  margin_inner = 3,
  margin_outer = 0.5,
  left_dendo_mar = c(margin_bottom, margin_outer, margin_top, margin_inner),
  right_dendo_mar = c(margin_bottom, margin_inner, margin_top, margin_outer),
  intersecting = TRUE,
  dLeaf = NULL,
  dLeaf_left = dLeaf,
  dLeaf_right = dLeaf,
  axes = TRUE,
  type = "r",
  lab.cex = NULL,
  remove_nodePar = FALSE,
  main = "",
  main_left = "",
  main_right = "",
  sub = "",
  k_labels = NULL,
  k_branches = NULL,
  rank_branches = FALSE,
  hang = FALSE,
  match_order_by_labels = TRUE,
  cex_main = 2,
  cex_main_left = cex_main,
  cex_main_right = cex_main,
  cex_sub = cex_main,
  highlight_distinct_edges = TRUE,
  common_subtrees_color_lines = TRUE,
  common_subtrees_color_lines_default_single_leaf_color = "grey",
  common_subtrees_color_branches = FALSE,
  highlight_branches_col = FALSE,
  highlight_branches_lwd = TRUE,
  faster = FALSE,
  just_one = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tanglegram_+3A_dend1">dend1</code></td>
<td>
<p>tree object (dendrogram/dendlist/hclust/phylo), plotted on the left</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_which">which</code></td>
<td>
<p>an integer vector of length 2, indicating
which of the trees in the dendlist object should be plotted</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_main_left">main_left</code></td>
<td>
<p>Character. Title of the left dendrogram.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_main_right">main_right</code></td>
<td>
<p>Character. Title of the right dendrogram.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_just_one">just_one</code></td>
<td>
<p>logical (TRUE). If FALSE, it means at least two tanglegrams
will be plotted on the same page and so <a href="graphics.html#topic+layout">layout</a> is not passed.
See: <a href="https://stackoverflow.com/q/39784746/4137985">https://stackoverflow.com/q/39784746/4137985</a></p>
</td></tr>
<tr><td><code id="tanglegram_+3A_dend2">dend2</code></td>
<td>
<p>tree object (dendrogram/hclust/phylo), plotted on the right</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_sort">sort</code></td>
<td>
<p>logical (FALSE). Should the dendrogram's labels be &quot;sorted&quot;?
(might give a better tree in some cases).</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_color_lines">color_lines</code></td>
<td>
<p>a vector of colors for the lines connected the labels.
If the colors are shorter than the number of labels, they are recycled
(and a warning is issued).
The colors in the vector are applied on the lines from the bottom up.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_lwd">lwd</code></td>
<td>
<p>width of the lines connecting the labels. (default is 3.5)</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_edge.lwd">edge.lwd</code></td>
<td>
<p>width of the dendrograms lines. Default is NULL.
If set, then it switches 'highlight_branches_lwd' to FALSE. If you want thicker
lines which reflect the height, please use <a href="#topic+highlight_branches_lwd">highlight_branches_lwd</a> on the
dendrograms/dendlist.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_columns_width">columns_width</code></td>
<td>
<p>a vector with three elements, giving the relative
sizes of the the three plots (left dendrogram, connecting lines,
right dendrogram). This is passed to <a href="graphics.html#topic+layout">layout</a> if parameter just_one is TRUE.
The default is: c(5,3,5)</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_margin_top">margin_top</code></td>
<td>
<p>the number of lines of margin to be specified on the top
of the plots.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_margin_bottom">margin_bottom</code></td>
<td>
<p>the number of lines of margin to be specified on the
bottom of the plots.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_margin_inner">margin_inner</code></td>
<td>
<p>margin_bottom the number of lines of margin
to be specified on the inner distence between the dendrograms
and the connecting lines.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_margin_outer">margin_outer</code></td>
<td>
<p>margin_bottom the number of lines of margin
to be specified on the outer distence between the dendrograms
and the connecting lines.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_left_dendo_mar">left_dendo_mar</code></td>
<td>
<p>mar parameters of the left dendrgoram.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_right_dendo_mar">right_dendo_mar</code></td>
<td>
<p>mar parameters of the right dendrgoram.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_intersecting">intersecting</code></td>
<td>
<p>logical (TRUE). Should the leaves of the two dendrograms
be pruned so that the two trees will have the same labels?</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_dleaf">dLeaf</code></td>
<td>
<p>a number specifying the distance in user coordinates between
the tip of a leaf and its label. If NULL, as per default,
3/4 of a letter width or height is used.
</p>
<p>Notice that if we are comparing two dendrograms with different
heights, manually changing dLeaf will affect both trees differently.
In such a case, it is recommanded to manually change dLeaf_left
and dLeaf_right.
This can be especially important when changing the lab.cex of the
dendrogram's labels.
Alternatively, one could manually set the xlim parameter for both
trees, which will force the proportion of distances of the
labels from the trees to remain the same.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_dleaf_left">dLeaf_left</code></td>
<td>
<p>dLeaf of the left dendrogram, by default it is equal to dLeaf (often negative).</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_dleaf_right">dLeaf_right</code></td>
<td>
<p>dLeaf of the right dendrogram, by default it is equal to minus dLeaf (often positive).</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_axes">axes</code></td>
<td>
<p>logical (TRUE). Should plot axes be plotted?</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_type">type</code></td>
<td>
<p>type of plot (&quot;t&quot;/&quot;r&quot; = triangle or rectangle)</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_lab.cex">lab.cex</code></td>
<td>
<p>numeric scalar, influanicing the cex size of the labels.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_remove_nodepar">remove_nodePar</code></td>
<td>
<p>logical (FALSE). Should the nodePar of the leaves be
removed? (useful when the trees' leaves has too many parameters on them)</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_main">main</code></td>
<td>
<p>Character. Title above the connecting lines.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_sub">sub</code></td>
<td>
<p>Character. Title below the connecting lines.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_k_labels">k_labels</code></td>
<td>
<p>integer. Number of groups by which to color the leaves.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_k_branches">k_branches</code></td>
<td>
<p>integer. Number of groups by which to color the branches.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_rank_branches">rank_branches</code></td>
<td>
<p>logical (FALSE). Should the branches heights be adjusted?
(setting this to TRUE - can make it easier for
comparing topological differences)</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_hang">hang</code></td>
<td>
<p>logical (FALSE). Should we hang the leaves of the trees?</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_match_order_by_labels">match_order_by_labels</code></td>
<td>
<p>logical (TRUE). Should the leaves value order
be matched between the two trees based on labels? This is a MUST in order
to have the lines connect the correct labels. Set this to FALSE if you
want to make the plotting a bit faster, and only after you are sure
the labels and orders are correctly aligned.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_cex_main">cex_main</code></td>
<td>
<p>A numerical value giving the amount by which plotting title
should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_cex_main_left">cex_main_left</code></td>
<td>
<p>see cex_main.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_cex_main_right">cex_main_right</code></td>
<td>
<p>see cex_main.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_cex_sub">cex_sub</code></td>
<td>
<p>see cex_main.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_highlight_distinct_edges">highlight_distinct_edges</code></td>
<td>
<p>logical (default is TRUE). If to highlight distinct edges in each tree (by changing their line types to 2).
(notice that this can be slow on large trees)
</p>
<p>This parameter will automatically be turned off if the tree already comes with a &quot;lty&quot; edgePar
(this is checked using <a href="#topic+has_edgePar">has_edgePar</a>). A &quot;lty&quot; can be removed by using set(&quot;clear_branches&quot;), by
removing all of the edgePar parameters of the dendrogram.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_common_subtrees_color_lines">common_subtrees_color_lines</code></td>
<td>
<p>logical (default is TRUE). color the connecting line based on the common subtrees of both dends.
This only works if
(notice that this can be slow on large trees)</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_common_subtrees_color_lines_default_single_leaf_color">common_subtrees_color_lines_default_single_leaf_color</code></td>
<td>
<p>When representing edges between common subtrees 
(i.e. common_subtrees_color_branches = TRUE), this parameter sets the color of edges for subtrees that are NOT common.
Default is &quot;grey&quot;</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_common_subtrees_color_branches">common_subtrees_color_branches</code></td>
<td>
<p>logical (default is FALSE).
Color the branches of both dends based on the common subtrees.
(notice that this can be slow on large trees)
This is FALSE by default since it will override the colors of the existing tree.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_highlight_branches_col">highlight_branches_col</code></td>
<td>
<p>logical (default is FALSE). Should <a href="#topic+highlight_branches_col">highlight_branches_col</a> be used on the dendrograms.
</p>
<p>This parameter will automatically be turned off if the tree already comes with a &quot;col&quot; edgePar
(this is checked using <a href="#topic+has_edgePar">has_edgePar</a>). A &quot;lty&quot; can be removed by using set(&quot;clear_branches&quot;), by
removing all of the edgePar parameters of the dendrogram.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_highlight_branches_lwd">highlight_branches_lwd</code></td>
<td>
<p>logical (default is TRUE). Should <a href="#topic+highlight_branches_lwd">highlight_branches_lwd</a> be used on the dendrograms.
</p>
<p>This parameter will automatically be turned off if the tree already comes with a &quot;lwd&quot; edgePar
(this is checked using <a href="#topic+has_edgePar">has_edgePar</a>). A &quot;lty&quot; can be removed by using set(&quot;clear_branches&quot;), by
removing all of the edgePar parameters of the dendrogram.</p>
</td></tr>
<tr><td><code id="tanglegram_+3A_faster">faster</code></td>
<td>
<p>logical (FALSE). If TRUE, it overrides some other parameters to
have them turned off so that the plotting will go a tiny bit faster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notice that tanglegram does not &quot;resize&quot; well. In case you are resizing your
window you would need to re-run the function.
</p>


<h3>Value</h3>

<p>An invisible <a href="#topic+dendlist">dendlist</a>, with two trees after being
modified during the creation of the tanglegram.
</p>


<h3>Author(s)</h3>

<p>Tal Galili, Johan Renaudie
</p>


<h3>Source</h3>

<p>The function is based on code from Johan Renaudie (plannapus), after major revisions. See:
<a href="https://stackoverflow.com/questions/12456768/duelling-dendrograms-in-r-placing-dendrograms-back-to-back-in-r">https://stackoverflow.com/questions/12456768/duelling-dendrograms-in-r-placing-dendrograms-back-to-back-in-r</a>
</p>
<p>As far as I could tell, this code was originally inspired by Dylan Beaudette
function <code>dueling.dendrograms</code> from the sharpshootR package:
<a href="https://CRAN.R-project.org/package=sharpshootR">https://CRAN.R-project.org/package=sharpshootR</a>
tanglegram
</p>


<h3>See Also</h3>

<p><a href="#topic+remove_leaves_nodePar">remove_leaves_nodePar</a>, <a href="#topic+plot_horiz.dendrogram">plot_horiz.dendrogram</a>, <a href="#topic+rank_branches">rank_branches</a>,
<a href="#topic+hang.dendrogram">hang.dendrogram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(23235)
ss &lt;- sample(1:150, 10)
dend1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("sin") %&gt;%
  as.dendrogram()
dend12 &lt;- dendlist(dend1, dend2)

dend12 %&gt;% tanglegram()

tanglegram(dend1, dend2)
tanglegram(dend1, dend2, sort = TRUE)
tanglegram(dend1, dend2, remove_nodePar = TRUE)
tanglegram(dend1, dend2, k_labels = 6, k_branches = 4)

tanglegram(dend1, dend2,
  lab.cex = 2, edge.lwd = 3,
  margin_inner = 5, type = "t", center = TRUE
)


## works nicely:
tanglegram(dend1, dend2,
  lab.cex = 2, edge.lwd = 3,
  margin_inner = 3.5, type = "t", center = TRUE,
  dLeaf = -0.1, xlim = c(7, 0),
  k_branches = 3
)


# using rank_branches can make the comparison even easier
tanglegram(rank_branches(dend1), rank_branches(dend2),
  lab.cex = 2, edge.lwd = 3,
  margin_inner = 3.5, type = "t", center = TRUE,
  dLeaf = -0.1, xlim = c(5.1, 0), columns_width = c(5, 1, 5),
  k_branches = 3
)



########
## Nice example of some colored trees

# see the coloring of common sub trees:
set.seed(23235)
ss &lt;- sample(1:150, 10)
dend1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("sin") %&gt;%
  as.dendrogram()
dend12 &lt;- dendlist(dend1, dend2)
# dend12 %&gt;% untangle %&gt;% tanglegram
dend12 %&gt;% tanglegram(common_subtrees_color_branches = TRUE)


set.seed(22133513)
ss &lt;- sample(1:150, 10)
dend1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("sin") %&gt;%
  as.dendrogram()
dend12 &lt;- dendlist(dend1, dend2)
# dend12 %&gt;% untangle %&gt;% tanglegram
dend12 %&gt;% tanglegram(common_subtrees_color_branches = TRUE)
dend12 %&gt;% tanglegram()

## End(Not run)
</code></pre>

<hr>
<h2 id='theme_dendro'>Creates completely blank theme in ggplot</h2><span id='topic+theme_dendro'></span>

<h3>Description</h3>

<p>Sets most of the ggplot options to blank, by returning blank theme elements for the panel grid, panel background, axis title, axis text, axis line and axis ticks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_dendro()
</code></pre>


<h3>Author(s)</h3>

<p>Andrie de Vries
</p>


<h3>Source</h3>

<p>This function is from Andrie de Vries's ggdendro package.
</p>
<p>The motivation for this fork is the need to add more graphical parameters to the plotted tree.
This required a strong mixter of functions from ggdendro and dendextend (to the point that
it seemed better to just fork the code into its current form)
</p>


<h3>See Also</h3>

<p><a href="#topic+ggdend">ggdend</a>
</p>

<hr>
<h2 id='unbranch'>unbranch trees</h2><span id='topic+unbranch'></span><span id='topic+unbranch.default'></span><span id='topic+unbranch.dendrogram'></span><span id='topic+unbranch.hclust'></span><span id='topic+unbranch.phylo'></span>

<h3>Description</h3>

<p>unbranch trees and merges the subtree to the parent node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbranch(dend, ...)

## Default S3 method:
unbranch(dend, ...)

## S3 method for class 'dendrogram'
unbranch(dend, branch_becoming_root = 1, new_root_height, ...)

## S3 method for class 'hclust'
unbranch(dend, branch_becoming_root = 1, new_root_height, ...)

## S3 method for class 'phylo'
unbranch(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbranch_+3A_dend">dend</code></td>
<td>
<p>a dendrogram (or hclust) object</p>
</td></tr>
<tr><td><code id="unbranch_+3A_...">...</code></td>
<td>
<p>passed on</p>
</td></tr>
<tr><td><code id="unbranch_+3A_branch_becoming_root">branch_becoming_root</code></td>
<td>
<p>a numeric choosing the branch of the root which will become the new root (from left to right)</p>
</td></tr>
<tr><td><code id="unbranch_+3A_new_root_height">new_root_height</code></td>
<td>
<p>the new height of the branch which will become the new root.
If the parameter is not given - the height of the original root is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unbranched dendrogram
</p>


<h3>See Also</h3>

<p><a href="ape.html#topic+unroot">unroot</a> ape
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests[2:9, ]), "com")
dend &lt;- as.dendrogram(hc)

par(mfrow = c(1, 3))
plot(dend, main = "original tree")
plot(unbranch(dend, 1), main = "unbranched tree (left branch)")
plot(unbranch(dend, 2), main = "tree without  (right branch)")
</code></pre>

<hr>
<h2 id='unclass_dend'>unclass an entire dendrogram tree</h2><span id='topic+unclass_dend'></span>

<h3>Description</h3>

<p>unclass all the nodes in a dendrogram tree. (Helps in cases when a dendrapply function was used wrongly)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unclass_dend(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unclass_dend_+3A_dend">dend</code></td>
<td>
<p>a dendrogram object</p>
</td></tr>
<tr><td><code id="unclass_dend_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list which was the dendrogram (but without a class)
</p>


<h3>See Also</h3>

<p><a href="#topic+nleaves">nleaves</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define dendrogram object to play with:
hc &lt;- hclust(dist(USArrests[1:3, ]), "ave")
dend &lt;- as.dendrogram(hc)

itself &lt;- function(x) x
dend &lt;- dendrapply(dend, itself)
unclass(dend) # this only returns a list with
# two dendrogram objects inside it.
str(dend) # this is a great way to show a dendrogram,
# but it doesn't help us understand how the R object is built.
str(unclass(dend)) # this is a great way to show a dendrogram,
# but it doesn't help us understand how the R object is built.
unclass_dend(dend) # this only returns a list
#  with two dendrogram objects inside it.
str(unclass_dend(dend)) # NOW we can more easily understand
# how the dendrogram object is structured...
</code></pre>

<hr>
<h2 id='untangle'>untangle dendrograms</h2><span id='topic+untangle'></span><span id='topic+untangle.default'></span><span id='topic+untangle_labels'></span><span id='topic+untangle.dendrogram'></span><span id='topic+untangle.dendlist'></span>

<h3>Description</h3>

<p>One untangle function to rule them all.
</p>
<p>This function untangles dendrogram lists (dendlist),
Using various heuristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untangle(dend1, ...)

## Default S3 method:
untangle(dend1, ...)

untangle_labels(dend1, dend2, ...)

## S3 method for class 'dendrogram'
untangle(
  dend1,
  dend2,
  method = c("labels", "ladderize", "random", "step1side", "step2side", "DendSer"),
  ...
)

## S3 method for class 'dendlist'
untangle(
  dend1,
  method = c("labels", "ladderize", "random", "step1side", "step2side", "DendSer"),
  which = c(1L, 2L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untangle_+3A_dend1">dend1</code></td>
<td>
<p>a dednrogram or a dendlist object</p>
</td></tr>
<tr><td><code id="untangle_+3A_...">...</code></td>
<td>
<p>passed to the releavnt untangle function</p>
</td></tr>
<tr><td><code id="untangle_+3A_dend2">dend2</code></td>
<td>
<p>A second dednrogram (to untangle against)</p>
</td></tr>
<tr><td><code id="untangle_+3A_method">method</code></td>
<td>
<p>a character indicating the type of untangle
heuristic to use.</p>
</td></tr>
<tr><td><code id="untangle_+3A_which">which</code></td>
<td>
<p>an integer vector of length 2, indicating
which of the trees in the dendlist object should be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps all of the untagnle functions,
in order to make it easier to find our about (and use) them.
</p>


<h3>Value</h3>

<p>A <a href="#topic+dendlist">dendlist</a>, with two trees after
they have been untangled.
</p>
<p>If the dendlist was originally larger than 2, it will return the original dendlist
but with the relevant trees properly rotate.
</p>


<h3>Author(s)</h3>

<p>Tal Galili
</p>


<h3>See Also</h3>

<p><a href="#topic+tanglegram">tanglegram</a>, <a href="#topic+untangle_random_search">untangle_random_search</a>,
<a href="#topic+untangle_step_rotate_1side">untangle_step_rotate_1side</a>, <a href="#topic+untangle_step_rotate_2side">untangle_step_rotate_2side</a>,
<a href="#topic+untangle_DendSer">untangle_DendSer</a>,
<a href="#topic+entanglement">entanglement</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(23235)
ss &lt;- sample(1:150, 10)
dend1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("sin") %&gt;%
  as.dendrogram()
dend12 &lt;- dendlist(dend1, dend2)

dend12 %&gt;% tanglegram()

untangle(dend1, dend2, method = "random", R = 5) %&gt;% tanglegram()

# it works, and we get something different:
set.seed(1234)
dend12 %&gt;%
  untangle(method = "random", R = 5) %&gt;%
  tanglegram()

set.seed(1234)
# fixes it completely:
dend12 %&gt;%
  untangle(method = "random", R = 5) %&gt;%
  untangle(method = "step1") %&gt;%
  tanglegram()
# not good enough
dend12 %&gt;%
  untangle(method = "step1") %&gt;%
  tanglegram()
# not good enough
dend12 %&gt;%
  untangle(method = "step2") %&gt;%
  tanglegram()
# How we might wish to use it:
set.seed(12777)
dend12 %&gt;%
  untangle(method = "random", R = 1) %&gt;%
  untangle(method = "step2") %&gt;%
  tanglegram()

## End(Not run)
</code></pre>

<hr>
<h2 id='untangle_DendSer'>Tries to run DendSer on a dendrogram</h2><span id='topic+untangle_DendSer'></span>

<h3>Description</h3>

<p>The function tries to turn the dend into hclust.
It then uses the <a href="stats.html#topic+cophenetic">cophenetic</a> distance matrix
for optimizing the tree's rotation.
</p>
<p>This is a good (and fast) starting point for linkuntangle_step_rotate_2side
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untangle_DendSer(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untangle_DendSer_+3A_dend">dend</code></td>
<td>
<p>An object of class <a href="#topic+dendlist">dendlist</a></p>
</td></tr>
<tr><td><code id="untangle_DendSer_+3A_...">...</code></td>
<td>
<p>NOT USED</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendlist object with ordered dends
</p>


<h3>See Also</h3>

<p><code><a href="DendSer.html#topic+DendSer">DendSer</a></code>, <a href="#topic+DendSer.dendrogram">DendSer.dendrogram</a> ,
<a href="#topic+untangle_DendSer">untangle_DendSer</a>, <a href="#topic+rotate_DendSer">rotate_DendSer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(232)
ss &lt;- sample(1:150, 20)
dend1 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust("sin") %&gt;%
  as.dendrogram()
dend12 &lt;- dendlist(dend1, dend2)

# bad solutions
dend12 %&gt;% tanglegram()
dend12 %&gt;%
  untangle("step2") %&gt;%
  tanglegram()
dend12 %&gt;%
  untangle_DendSer() %&gt;%
  tanglegram()
# but the combination is quite awsome:
dend12 %&gt;%
  untangle_DendSer() %&gt;%
  untangle("step2") %&gt;%
  tanglegram()

## End(Not run)
</code></pre>

<hr>
<h2 id='untangle_random_search'>Untangle - random search</h2><span id='topic+untangle_random_search'></span>

<h3>Description</h3>

<p>Searches for two untangled dendrogram by randomlly shuflling them and each
time checking if their entanglement was improved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untangle_random_search(
  dend1,
  dend2,
  R = 100L,
  L = 1,
  leaves_matching_method = c("labels", "order"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untangle_random_search_+3A_dend1">dend1</code></td>
<td>
<p>a tree object (of class dendrogram/hclust/phylo).</p>
</td></tr>
<tr><td><code id="untangle_random_search_+3A_dend2">dend2</code></td>
<td>
<p>a tree object (of class dendrogram/hclust/phylo).</p>
</td></tr>
<tr><td><code id="untangle_random_search_+3A_r">R</code></td>
<td>
<p>numeric (default is 100). The number of shuffles to perform.</p>
</td></tr>
<tr><td><code id="untangle_random_search_+3A_l">L</code></td>
<td>
<p>the distance norm to use for measuring the distance between the
two trees. It can be any positive number, often one will want to
use 0, 1, 1.5, 2 (see 'details' for more).
It is passed to <a href="#topic+entanglement">entanglement</a>.</p>
</td></tr>
<tr><td><code id="untangle_random_search_+3A_leaves_matching_method">leaves_matching_method</code></td>
<td>
<p>a character scalar passed to <a href="#topic+entanglement">entanglement</a>.
It can be either &quot;order&quot; or &quot;labels&quot; (default). If using &quot;labels&quot;,
then we use the labels for matching the leaves order value.
And if &quot;order&quot; then we use the old leaves order value for matching the
leaves order value.
</p>
<p>Using &quot;order&quot; is faster, but &quot;labels&quot; is safer. &quot;order&quot; will assume that
the original two trees had their labels and order values MATCHED.
</p>
<p>Hence, it is best to make sure that the trees used here have the same labels
and the SAME values matched to these values - and then use &quot;order&quot; (for
fastest results).
</p>
<p>If &quot;order&quot; is used, the function first calls <a href="#topic+match_order_by_labels">match_order_by_labels</a>
in order to make sure that the two trees have their labels synced with
their leaves order values.</p>
</td></tr>
<tr><td><code id="untangle_random_search_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Untangaling two trees is a hard combinatorical problem without a closed
form solution. One way for doing it is to run through a random spectrom
of options and look for the &quot;best&quot; two trees. This is what this function
offers.
</p>


<h3>Value</h3>

<p>A dendlist with two trees with the best entanglement that was found.
</p>


<h3>See Also</h3>

<p><a href="#topic+tanglegram">tanglegram</a>, <a href="#topic+match_order_by_labels">match_order_by_labels</a>,
<a href="#topic+entanglement">entanglement</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
dend1 &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust("com") %&gt;%
  as.dendrogram()
dend2 &lt;- iris[, -5] %&gt;%
  dist() %&gt;%
  hclust("sin") %&gt;%
  as.dendrogram()
tanglegram(dend1, dend2)

set.seed(65168)
dend12 &lt;- untangle_random_search(dend1, dend2, R = 10)
tanglegram(dend12[[1]], dend12[[2]])
tanglegram(dend12)

entanglement(dend1, dend2, L = 2) # 0.8894
entanglement(dend12[[1]], dend12[[2]], L = 2) # 0.0998

## End(Not run)
</code></pre>

<hr>
<h2 id='untangle_step_rotate_1side'>Stepwise untangle one tree compared to another</h2><span id='topic+untangle_step_rotate_1side'></span>

<h3>Description</h3>

<p>Given a fixed tree and a tree we wish to rotate, this function goes
through all of the k number of clusters (from 2 onward), and each time
rotates the branch which was introduced in the new k'th cluster.
This rotated tree is compared with the fixed tree, and if it has a better
entanglement, it will be used for the following iterations.
</p>
<p>This is a greedy forward selection algorithm for rotating the tree and
looking for a better match.
</p>
<p>This is useful for finding good trees for a <a href="#topic+tanglegram">tanglegram</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untangle_step_rotate_1side(
  dend1,
  dend2_fixed,
  L = 1.5,
  direction = c("forward", "backward"),
  k_seq = NULL,
  dend_heights_per_k,
  leaves_matching_method = c("labels", "order"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untangle_step_rotate_1side_+3A_dend1">dend1</code></td>
<td>
<p>a dendrogram object. The one we will rotate to best fit
dend2_fixed.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_1side_+3A_dend2_fixed">dend2_fixed</code></td>
<td>
<p>a dendrogram object. This one is kept fixed.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_1side_+3A_l">L</code></td>
<td>
<p>the distance norm to use for measuring the distance between the
two trees. It can be any positive number,
often one will want to use 0, 1, 1.5, 2 (see 'details' in <a href="#topic+entanglement">entanglement</a>).</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_1side_+3A_direction">direction</code></td>
<td>
<p>a character scalar, either &quot;forward&quot; (default) or &quot;backward&quot;.
Impacts the direction of clustering that are tried. Either from 2 and up
(in case of &quot;forward&quot;), or from nleaves to down (in case of &quot;backward&quot;)
</p>
<p>If k_seq is not NULL, then it overrides &quot;direction&quot;.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_1side_+3A_k_seq">k_seq</code></td>
<td>
<p>a sequence of k clusters to go through for improving
dend1. If NULL (default), then we use the &quot;direction&quot; parameter.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_1side_+3A_dend_heights_per_k">dend_heights_per_k</code></td>
<td>
<p>a numeric vector of values which indicate which height will produce which number of clusters (k)</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_1side_+3A_leaves_matching_method">leaves_matching_method</code></td>
<td>
<p>a character scalar passed to <a href="#topic+entanglement">entanglement</a>.
It can be either &quot;order&quot; or &quot;labels&quot; (default). If using &quot;labels&quot;,
then we use the labels for matching the leaves order value.
And if &quot;order&quot; then we use the old leaves order value for matching the
leaves order value.
</p>
<p>Using &quot;order&quot; is faster, but &quot;labels&quot; is safer. &quot;order&quot; will assume that
the original two trees had their labels and order values MATCHED.
</p>
<p>Hence, it is best to make sure that the trees used here have the same labels
and the SAME values matched to these values - and then use &quot;order&quot; (for
fastest results).
</p>
<p>If &quot;order&quot; is used, the function first calls <a href="#topic+match_order_by_labels">match_order_by_labels</a>
in order to make sure that the two trees have their labels synced with
their leaves order values.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_1side_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendlist with
1) dend1 after it was rotated to best fit dend2_fixed.
2) dend2_fixed.
</p>


<h3>See Also</h3>

<p><a href="#topic+tanglegram">tanglegram</a>, <a href="#topic+match_order_by_labels">match_order_by_labels</a>,
<a href="#topic+entanglement">entanglement</a>, <a href="#topic+flip_leaves">flip_leaves</a>, <a href="#topic+all_couple_rotations_at_k">all_couple_rotations_at_k</a>,
<a href="#topic+untangle_step_rotate_2side">untangle_step_rotate_2side</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
dend1 &lt;- USArrests[1:10, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
set.seed(3525)
dend2 &lt;- shuffle(dend1)
tanglegram(dend1, dend2)
entanglement(dend1, dend2, L = 2) # 0.4727

dend2_corrected &lt;- untangle_step_rotate_1side(dend2, dend1)[[1]]
tanglegram(dend1, dend2_corrected) # FIXED.
entanglement(dend1, dend2_corrected, L = 2) # 0

## End(Not run)
</code></pre>

<hr>
<h2 id='untangle_step_rotate_2side'>Stepwise untangle two trees one at a time</h2><span id='topic+untangle_step_rotate_2side'></span>

<h3>Description</h3>

<p>This is a greedy forward selection algorithm for rotating the tree and
looking for a better match.
</p>
<p>This is useful for finding good trees for a <a href="#topic+tanglegram">tanglegram</a>.
</p>
<p>It goes through rotating dend1, then dend2, and so on - until a locally optimal solution is found.
</p>
<p>Similar to &quot;step1side&quot;, one tree is held fixed and the other tree is rotated.
This function goes through all of the k number of clusters (from 2 onward),
and each time rotates the branch which was introduced in the new k'th cluster.
This rotated tree is compared with the fixed tree, and if it has a better
entanglement, it will be used for the following iterations.
Once finished the rotated tree is held fixed, and the fixed tree
is now rotated. This continues until a local optimal solution is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untangle_step_rotate_2side(
  dend1,
  dend2,
  L = 1.5,
  direction = c("forward", "backward"),
  max_n_iterations = 10L,
  print_times = dendextend_options("warn"),
  k_seq = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untangle_step_rotate_2side_+3A_dend1">dend1</code></td>
<td>
<p>a dendrogram object. The one we will rotate to best fit
dend2.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_2side_+3A_dend2">dend2</code></td>
<td>
<p>a dendrogram object. The one we will rotate to best fit
dend1.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_2side_+3A_l">L</code></td>
<td>
<p>the distance norm to use for measuring the distance between the
two trees. It can be any positive number,
often one will want to use 0, 1, 1.5, 2 (see 'details' in <a href="#topic+entanglement">entanglement</a>).</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_2side_+3A_direction">direction</code></td>
<td>
<p>a character scalar, either &quot;forward&quot; (default) or &quot;backward&quot;.
Impacts the direction of clustering that are tried. Either from 2 and up
(in case of &quot;forward&quot;), or from nleaves to down (in case of &quot;backward&quot;)
</p>
<p>If k_seq is not NULL, then it overrides &quot;direction&quot;.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_2side_+3A_max_n_iterations">max_n_iterations</code></td>
<td>
<p>integer. The maximal number of times to switch between optimizing one tree with another.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_2side_+3A_print_times">print_times</code></td>
<td>
<p>logical (TRUE), should we print how many times we switched between rotating the two trees?</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_2side_+3A_k_seq">k_seq</code></td>
<td>
<p>a sequence of k clusters to go through for improving
dend1. If NULL (default), then we use the &quot;direction&quot; parameter.</p>
</td></tr>
<tr><td><code id="untangle_step_rotate_2side_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two dendrograms (dend1/dend2),
after they are rotated to best fit one another.
</p>


<h3>See Also</h3>

<p><a href="#topic+tanglegram">tanglegram</a>, <a href="#topic+match_order_by_labels">match_order_by_labels</a>,
<a href="#topic+entanglement">entanglement</a>, <a href="#topic+flip_leaves">flip_leaves</a>, <a href="#topic+all_couple_rotations_at_k">all_couple_rotations_at_k</a>.
<a href="#topic+untangle_step_rotate_1side">untangle_step_rotate_1side</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
dend1 &lt;- USArrests[1:20, ] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend2 &lt;- USArrests[1:20, ] %&gt;%
  dist() %&gt;%
  hclust(method = "single") %&gt;%
  as.dendrogram()
set.seed(3525)
dend2 &lt;- shuffle(dend2)
tanglegram(dend1, dend2, margin_inner = 6.5)
entanglement(dend1, dend2, L = 2) # 0.79

dend2_corrected &lt;- untangle_step_rotate_1side(dend2, dend1)
tanglegram(dend1, dend2_corrected, margin_inner = 6.5) # Good.
entanglement(dend1, dend2_corrected, L = 2) # 0.0067
# it is better, but not perfect. Can we improve it?

dend12_corrected &lt;- untangle_step_rotate_2side(dend1, dend2)
tanglegram(dend12_corrected[[1]], dend12_corrected[[2]], margin_inner = 6.5) # Better...
entanglement(dend12_corrected[[1]], dend12_corrected[[2]], L = 2) # 0.0045


# best combination:
dend12_corrected_1 &lt;- untangle_random_search(dend1, dend2)
dend12_corrected_2 &lt;- untangle_step_rotate_2side(dend12_corrected_1[[1]], dend12_corrected_1[[2]])
tanglegram(dend12_corrected_2[[1]], dend12_corrected_2[[2]], margin_inner = 6.5) # Better...
entanglement(dend12_corrected_2[[1]], dend12_corrected_2[[2]], L = 2) # 0 - PERFECT.

## End(Not run)
</code></pre>

<hr>
<h2 id='which_leaf'>Which node is a leaf?</h2><span id='topic+which_leaf'></span>

<h3>Description</h3>

<p>Gives a vector as the number of nodes (<a href="#topic+nnodes">nnodes</a>),
which gives a TRUE when a node is a leaf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_leaf(dend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_leaf_+3A_dend">dend</code></td>
<td>
<p>a dendrogram dend</p>
</td></tr>
<tr><td><code id="which_leaf_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector with the length of <a href="#topic+nnodes">nnodes</a>,
which gives a TRUE when a node is a leaf.
</p>


<h3>See Also</h3>

<p><a href="#topic+noded_with_condition">noded_with_condition</a>, <a href="stats.html#topic+is.leaf">is.leaf</a>, <a href="#topic+nnodes">nnodes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(dendextend)

# Getting the dend dend
set.seed(23235)
ss &lt;- sample(1:150, 10)
dend &lt;- iris[ss, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram()
dend %&gt;% plot()

which_leaf(dend)

## End(Not run)
</code></pre>

<hr>
<h2 id='which_node'>Which node id is common to a group of labels</h2><span id='topic+which_node'></span>

<h3>Description</h3>

<p>This function identifies which edge(s) in a tree has group of labels (&quot;tips&quot;) in common.
By default it only returns the edge (node) with the heighest id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_node(dend, labels, max_id = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_node_+3A_dend">dend</code></td>
<td>
<p>a dendrogram dend</p>
</td></tr>
<tr><td><code id="which_node_+3A_labels">labels</code></td>
<td>
<p>a character vector of labels from the tree</p>
</td></tr>
<tr><td><code id="which_node_+3A_max_id">max_id</code></td>
<td>
<p>logical (TRUE) - if to return only the max id</p>
</td></tr>
<tr><td><code id="which_node_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer with the id(s) of the nodes which includes all of the labels.
</p>


<h3>See Also</h3>

<p><a href="#topic+noded_with_condition">noded_with_condition</a>, <a href="#topic+branches_attr_by_clusters">branches_attr_by_clusters</a>,
<a href="#topic+nnodes">nnodes</a>, <a href="#topic+branches_attr_by_labels">branches_attr_by_labels</a>, <a href="#topic+get_nodes_attr">get_nodes_attr</a>
<a href="ape.html#topic+which.edge">which.edge</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dend &lt;- iris[1:10, -5] %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("labels", 1:10)
dend %&gt;% plot()

which_node(dend, c(1, 2), max_id = FALSE)
which_node(dend, c(2, 3), max_id = FALSE)
which_node(dend, c(2, 3))

dend %&gt;% plot()
the_h &lt;- get_nodes_attr(dend, "height", which_node(dend, c(4, 6)))
the_h
abline(h = the_h, lty = 2, col = 2)
get_nodes_attr(dend, "height", which_node(dend, c(4, 6)))
get_nodes_attr(dend, "members", which_node(dend, c(4, 6)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
