<!DOCTYPE html><html lang="en-US"><head><title>Help for package colorednoise</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {colorednoise}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#colorednoise-package'><p>colorednoise: Simulate Temporally Autocorrelated Populations</p></a></li>
<li><a href='#autocorr_sim'><p>Simulate Temporally Autocorrelated Populations for Every Combination of</p>
Parameters</a></li>
<li><a href='#autocorrelation'><p>Estimate the Temporal Autocorrelation of a Numeric Vector</p></a></li>
<li><a href='#colored_multi_rnorm'><p>Generate Multiple Cross-Correlated &amp; Autocorrelated Variables</p></a></li>
<li><a href='#colored_noise'><p>Generate Autocorrelated Noise</p></a></li>
<li><a href='#cor2cov'><p>Convert from Correlation Matrix to Covariance Matrix</p></a></li>
<li><a href='#matrix_model'><p>Temporally Autocorrelated Matrix Population Models</p></a></li>
<li><a href='#multi_rnorm'><p>Generate Correlated Normal Random Numbers</p></a></li>
<li><a href='#stdev_transform'><p>Translate Standard Deviation from the Natural Scale to the Log or Logit Scale</p></a></li>
<li><a href='#unstructured_pop'><p>Simulated Time Series of an Unstructured Temporally Autocorrelated Population</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate Temporally Autocorrelated Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-23</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>July Pilowsky &lt;pilowskyj@caryinstitute.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Temporally autocorrelated populations are correlated in their vital rates (growth, death, etc.) from year to year. It is very common for populations, whether they be bacteria, plants, or humans, to be temporally autocorrelated. This poses a challenge for stochastic population modeling, because a temporally correlated population will behave differently from an uncorrelated one.
    This package provides tools for simulating populations with white noise (no temporal autocorrelation), red noise (positive temporal autocorrelation), and blue noise (negative temporal autocorrelation).  The algebraic formulation for autocorrelated noise comes from Ruokolainen et al. (2009) &lt;<a href="https://doi.org/10.1016%2Fj.tree.2009.04.009">doi:10.1016/j.tree.2009.04.009</a>&gt;. Models for unstructured populations and for structured populations (matrix models) are available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats (&ge; 3.3.2), purrr (&ge; 0.2.3), Rcpp (&ge; 1.0.5),
data.table (&ge; 1.12.8)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/japilo/colorednoise/issues">https://github.com/japilo/colorednoise/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2 (&ge; 2.2.1), knitr (&ge; 1.17), rmarkdown (&ge; 1.6),
testthat (&ge; 1.0.2), covr (&ge; 3.0.0), pkgdown (&ge; 1.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-28 17:51:41 UTC; japil</td>
</tr>
<tr>
<td>Author:</td>
<td>July Pilowsky <a href="https://orcid.org/0000-0002-6376-2585"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='colorednoise-package'>colorednoise: Simulate Temporally Autocorrelated Populations</h2><span id='topic+colorednoise'></span><span id='topic+colorednoise-package'></span>

<h3>Description</h3>

<p>Temporally autocorrelated populations are correlated in their vital rates (growth, death, etc.) from year to year. It is very common for populations, whether they be bacteria, plants, or humans, to be temporally autocorrelated. This poses a challenge for stochastic population modeling, because a temporally correlated population will behave differently from an uncorrelated one. This package provides tools for simulating populations with white noise (no temporal autocorrelation), red noise (positive temporal autocorrelation), and blue noise (negative temporal autocorrelation). The algebraic formulation for autocorrelated noise comes from Ruokolainen et al. (2009) <a href="https://doi.org/10.1016/j.tree.2009.04.009">doi:10.1016/j.tree.2009.04.009</a>. Models for unstructured populations and for structured populations (matrix models) are available.
</p>
<p>Simulate Temporally Autocorrelated Populations
</p>


<h3>Details</h3>

<p>See the README on <a href="https://github.com/japilo/colorednoise#readme">GitHub</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: July Pilowsky <a href="mailto:pilowskyj@caryinstitute.org">pilowskyj@caryinstitute.org</a> (<a href="https://orcid.org/0000-0002-6376-2585">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/japilo/colorednoise/issues">https://github.com/japilo/colorednoise/issues</a>
</p>
</li></ul>


<hr>
<h2 id='autocorr_sim'>Simulate Temporally Autocorrelated Populations for Every Combination of
Parameters</h2><span id='topic+autocorr_sim'></span>

<h3>Description</h3>

<p>Essentially a loop of <code><a href="#topic+unstructured_pop">unstructured_pop</a></code>, this function simulates a
population with temporally autocorrelated vital rates for every combination
of parameters you specify, with as many replicates as desired. It also
estimates the sample mean survival and fertility for each simulated
population. Please be advised that this function can be very computationally
intensive if you provide many possible parameter values and/or ask for many
replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorr_sim(
  timesteps,
  start,
  survPhi,
  fecundPhi,
  survMean,
  survSd,
  fecundMean,
  fecundSd,
  replicates
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autocorr_sim_+3A_timesteps">timesteps</code></td>
<td>
<p>The number of timesteps you want to simulate. Individuals
are added and killed off every timestep according to the survival and
fertility rates. Can be a scalar or a vector of values to loop over.</p>
</td></tr>
<tr><td><code id="autocorr_sim_+3A_start">start</code></td>
<td>
<p>The starting population size. Can be a scalar or vector.</p>
</td></tr>
<tr><td><code id="autocorr_sim_+3A_survphi">survPhi</code></td>
<td>
<p>The temporal autocorrelation of survival. 0 is white noise (uncorrelated),
positive values are red noise (directly correlated) and negative values are
blue noise (inversely correlated). Can be a scalar or a vector.</p>
</td></tr>
<tr><td><code id="autocorr_sim_+3A_fecundphi">fecundPhi</code></td>
<td>
<p>The temporal autocorrelation of fecundity. As above.</p>
</td></tr>
<tr><td><code id="autocorr_sim_+3A_survmean">survMean</code></td>
<td>
<p>The mean survival from timestep to timestep. Must be a value
between 0 (all individuals die) and 1 (all individuals live). Can be a scalar
or a vector.</p>
</td></tr>
<tr><td><code id="autocorr_sim_+3A_survsd">survSd</code></td>
<td>
<p>The standard deviation of the survival from timestep to
timestep. Must be a value between 0 and 1. Can be a scalar or a vector.</p>
</td></tr>
<tr><td><code id="autocorr_sim_+3A_fecundmean">fecundMean</code></td>
<td>
<p>The mean fertility: mean offspring produced by each individual per timestep. Can be a scalar or a vector.</p>
</td></tr>
<tr><td><code id="autocorr_sim_+3A_fecundsd">fecundSd</code></td>
<td>
<p>The standard deviation of the fertility. Can be a scalar or a vector of values.</p>
</td></tr>
<tr><td><code id="autocorr_sim_+3A_replicates">replicates</code></td>
<td>
<p>How many replicates you would like of each possible
combination of parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames, each with fourteen variables: timestep,
newborns (new individuals added this timestep), survivors (individuals
alive last year who survived this timestep), population (total individuals
alive), growth (the increase or decrease in population size from last
year), estimated survival in the timestep, estimated fecundity in the
timestep, and the seven parameters used to generate the simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>survival_range &lt;- autocorr_sim(timesteps = 30, start = 200, survPhi = 0.3, fecundPhi = 0.1,
                               survMean = c(0.2, 0.3, 0.4, 0.5, 0.6), survSd = 0.5,
                               fecundMean = 1.1, fecundSd = 0.5, replicates = 50)
head(survival_range[[1]])
</code></pre>

<hr>
<h2 id='autocorrelation'>Estimate the Temporal Autocorrelation of a Numeric Vector</h2><span id='topic+autocorrelation'></span>

<h3>Description</h3>

<p>A wrapper for the <code><a href="stats.html#topic+acf">acf</a></code> function from the stats package that
extracts only the temporal autocorrelation at a lag of one timestep (which is
the type of temporal autocorrelation that this package simulates). The function omits
NA values in the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorrelation(x, biasCorrection = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autocorrelation_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="autocorrelation_+3A_biascorrection">biasCorrection</code></td>
<td>
<p>Autocorrelation estimates are biased for short time series. The function can
correct for this bias in the manner proposed by Quenouille (1949). Set to TRUE by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value: the estimate of the temporal autocorrelation with a lag of 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rednoise &lt;- colored_noise(timesteps = 50, mean = 0.5, sd = 0.2, phi = 0.3)
autocorrelation(rednoise)
</code></pre>

<hr>
<h2 id='colored_multi_rnorm'>Generate Multiple Cross-Correlated &amp; Autocorrelated Variables</h2><span id='topic+colored_multi_rnorm'></span>

<h3>Description</h3>

<p>Generates random variables that are correlated to each other and temporally autocorrelated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colored_multi_rnorm(timesteps, mean, sd, phi, covMatrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colored_multi_rnorm_+3A_timesteps">timesteps</code></td>
<td>
<p>The number of temporally autocorrelated random numbers (one
per timestep) you want.</p>
</td></tr>
<tr><td><code id="colored_multi_rnorm_+3A_mean">mean</code></td>
<td>
<p>A vector giving the mean of each variable.</p>
</td></tr>
<tr><td><code id="colored_multi_rnorm_+3A_sd">sd</code></td>
<td>
<p>A vector giving the standard deviation of each variable.</p>
</td></tr>
<tr><td><code id="colored_multi_rnorm_+3A_phi">phi</code></td>
<td>
<p>A vector giving the temporal autocorrelation of each variable.</p>
</td></tr>
<tr><td><code id="colored_multi_rnorm_+3A_covmatrix">covMatrix</code></td>
<td>
<p>A valid covariance matrix. The number of rows/columns must match the length of the mu, sigma, and phi vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with as many rows as timesteps and as many columns as mu/sigma/phi values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov &lt;- matrix(c(1, 0.53, 0.73, 0.53, 1, 0.44, 0.73, 0.44, 1), nrow = 3)
test &lt;- colored_multi_rnorm(100, c(0, 3, 5), c(1, 0.5, 1), c(0.5, -0.3, 0), cov)
var(test)
library(data.table)
as.data.table(test)[, .(V1_mean = mean(V1), V2_mean = mean(V2), V3_mean = mean(V3),
V1_sd = sd(V1), V2_sd = sd(V2), V3_sd = sd(V3),
V1_autocorrelation = autocorrelation(V1), V2_autocorrelation = autocorrelation(V2),
V3_autocorrelation = autocorrelation(V3))]
</code></pre>

<hr>
<h2 id='colored_noise'>Generate Autocorrelated Noise</h2><span id='topic+colored_noise'></span>

<h3>Description</h3>

<p>Generates temporally autocorrelated random numbers with a mean,
standard deviation, and autocorrelation you specify.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colored_noise(timesteps, mean, sd, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colored_noise_+3A_timesteps">timesteps</code></td>
<td>
<p>The number of temporally autocorrelated random numbers (one
per timestep) you want.</p>
</td></tr>
<tr><td><code id="colored_noise_+3A_mean">mean</code></td>
<td>
<p>The mean of the temporally autocorrelated random numbers.</p>
</td></tr>
<tr><td><code id="colored_noise_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the temporally autocorrelated random
numbers.</p>
</td></tr>
<tr><td><code id="colored_noise_+3A_phi">phi</code></td>
<td>
<p>The temporal autocorrelation. 0 is white noise (uncorrelated),
positive values are red noise (directly correlated) and negative values are blue
noise (inversely correlated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of temporally autocorrelated random numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rednoise &lt;- colored_noise(timesteps = 30, mean = 0.5, sd = 0.2, phi = 0.3)
rednoise
</code></pre>

<hr>
<h2 id='cor2cov'>Convert from Correlation Matrix to Covariance Matrix</h2><span id='topic+cor2cov'></span>

<h3>Description</h3>

<p>Convert a correlation matrix to a covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2cov(sigma, corrMatrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor2cov_+3A_sigma">sigma</code></td>
<td>
<p>A vector of standard deviations for the variables you're describing. Length must be the same as the number of rows/columns of CorrMatrix.</p>
</td></tr>
<tr><td><code id="cor2cov_+3A_corrmatrix">corrMatrix</code></td>
<td>
<p>A valid correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix with the same dimensions as corrMatrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr &lt;- matrix(c(1, 0.53, 0.73, 0.53, 1, 0.44, 0.73, 0.44, 1), nrow = 3)
sigmas &lt;- c(2, 0.3, 1.2)
covar &lt;- cor2cov(sigmas, corr)
cov2cor(covar)
</code></pre>

<hr>
<h2 id='matrix_model'>Temporally Autocorrelated Matrix Population Models</h2><span id='topic+matrix_model'></span>

<h3>Description</h3>

<p>Simulate a structured population with temporal autocorrelation using standard Leslie matrices.
Each element in the Leslie matrix has a specified mean, variance, and temporal autocorrelation value.
The matrix can have arbitrary dimensions and can have transitions besides linear survival. This model
includes environmental stochasticity with colored noise. Density dependence and demographic stochasticity not currently supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_model(
  data,
  initialPop,
  timesteps,
  covMatrix = NULL,
  colNames = NULL,
  matrixStructure = NULL,
  repeatElements = NULL,
  survivalOverflow = "scale"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix_model_+3A_data">data</code></td>
<td>
<p>The input data can be one of two formats: a list of three matrices, or a data frame
with three columns. <br />
If it is a list of three matrices, they must be standard Leslie matrices: the first
a matrix of mean values for each matrix element, the second a matrix of standard deviations, and the third
a matrix of temporal autocorrelations. <br />
If it is a data frame, there must be three columns, one for mean vital rates, one for standard deviations, and one labeled 'autocorrelation.' <br />
If the population has n stages, the first n rows of the data frame must be the matrix elements for the first stage,
and the next n*(1-n) rows must be the transition probabilities, each row of the matrix from first to last transposed vertically. <br />
If you want to run a matrix population model without temporal autocorrelation, simply set all autocorrelation values to zero.</p>
</td></tr>
<tr><td><code id="matrix_model_+3A_initialpop">initialPop</code></td>
<td>
<p>An initial population vector. The length must be the same as the number of classes in the matrices.</p>
</td></tr>
<tr><td><code id="matrix_model_+3A_timesteps">timesteps</code></td>
<td>
<p>The number of timesteps you would like to simulate the population.</p>
</td></tr>
<tr><td><code id="matrix_model_+3A_covmatrix">covMatrix</code></td>
<td>
<p>Optional: Add a covariance matrix describing within-year covariances between matrix elements. The matrix elements must be
in the same order as they are in the data frame format above: a Leslie matrix turned into a vector row-wise. There should be as many
columns as matrix elements, excluding repeat elements (see below) or structural zeros.</p>
</td></tr>
<tr><td><code id="matrix_model_+3A_colnames">colNames</code></td>
<td>
<p>Optional: If the mean, sd, and autocorrelation columns of your data frame input are not
named 'mean', 'sd', and 'autocorrelation', provide their names here in a character vector, e.g.,
&lsquo;c(mean = &rsquo;Mean', sd = 'Standard Deviation', autocorrelation = 'phi')'</p>
</td></tr>
<tr><td><code id="matrix_model_+3A_matrixstructure">matrixStructure</code></td>
<td>
<p>Optional: By default, the function assumes that the first row of the matrix gives fecundities while
the rest of the matrix gives transition or survival probabilities. However, these assumptions do not apply to
many plant matrices. If your matrix has transition probabilities in the first row or fecundities beyond the first row
(e.g., clonal reproduction), provide a character matrix here with the same dimensions as your matrix that gives in
strings whether each element is 'fecundity' or 'transition'.</p>
</td></tr>
<tr><td><code id="matrix_model_+3A_repeatelements">repeatElements</code></td>
<td>
<p>Optional: Sometimes not all matrix elements can be measured, and some transitions or fertilities
are generalized across classes. If you have any matrix elements that are copies of other matrix elements (e.g., stage 3
is assumed to have the same fertility as stage 4) indicate them here with a matrix of <em>rowwise</em> (not column-wise)
indices that show which elements are repeats and which are unique. For example in a 2x2 matrix where both classes are
assumed to have the same fertility, input 'matrix(c(1, 1, 3, 4), byrow = T, ncol = 2)'. If you indicate repeat elements
and you include a covariance matrix, the covariance matrix must only have as many columns as <em>unique matrix elements</em>.
Structural zeros should <em>not</em> be included here as repeats, as they are automatically detected in the function.</p>
</td></tr>
<tr><td><code id="matrix_model_+3A_survivaloverflow">survivalOverflow</code></td>
<td>
<p>If the survival for a stage is very high or very variable, the function may sometimes generate
projection matrices with survival that exceeds 1 for that stage. The function has two methods of dealing with this problem:
either discard all projection matrices and generate new ones until the survival falls within acceptable bounds (&quot;redraw&quot;) or
divide all the non-fertility matrix elements for that stage by the survival such that they add to 1 (&quot;scale&quot;). The default
is &quot;scale&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with n + 2 columns, where n is the number of stages in the matrix. One column indicates the timestep,
there is one column with the population size for each stage, and one column for total population size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meanMat &lt;- matrix(c(0.55, 0.6, 0.24, 0.4), byrow = TRUE, ncol = 2)
sdMat &lt;- matrix(c(0.3, 0.35, 0.05, 0.1), byrow = TRUE, ncol = 2)
phiMat &lt;- matrix(c(-0.2, -0.2, 0, 0), byrow = TRUE, ncol = 2)
initialPop &lt;- c(100, 100)
sim &lt;- matrix_model(list(meanMat, sdMat, phiMat), initialPop, 50)
head(sim)
</code></pre>

<hr>
<h2 id='multi_rnorm'>Generate Correlated Normal Random Numbers</h2><span id='topic+multi_rnorm'></span>

<h3>Description</h3>

<p>Generate random numbers from a multivariate normal distribution.
It can be used to create correlated random numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_rnorm(n, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_rnorm_+3A_n">n</code></td>
<td>
<p>The number of samples desired for each variable.</p>
</td></tr>
<tr><td><code id="multi_rnorm_+3A_mean">mean</code></td>
<td>
<p>A vector giving the mean of each variable.</p>
</td></tr>
<tr><td><code id="multi_rnorm_+3A_sd">sd</code></td>
<td>
<p>A valid covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with n rows and as many columns as mean values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mus &lt;- c(0, 3, 5)
sigmas &lt;- matrix(c(1, 0.265, 2.19, 0.265, 0.25, 0.66, 2.19, 0.66, 9), ncol = 3)
mat &lt;- multi_rnorm(100, mus, sigmas)
var(mat)
</code></pre>

<hr>
<h2 id='stdev_transform'>Translate Standard Deviation from the Natural Scale to the Log or Logit Scale</h2><span id='topic+stdev_transform'></span>

<h3>Description</h3>

<p>This function changes a given standard deviation so that when a vector of samples is drawn from the given distribution,
the original standard deviation will be recovered once it is back-transformed from the log or logit scale. In effect,
the function &quot;translates&quot; a standard deviation from the natural scale to the log or logit scale for the purposes of
random draws from a probability distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdev_transform(mu, sigma, dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stdev_transform_+3A_mu">mu</code></td>
<td>
<p>The mean of the distribution on the natural scale.</p>
</td></tr>
<tr><td><code id="stdev_transform_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the distribution on the natural scale.</p>
</td></tr>
<tr><td><code id="stdev_transform_+3A_dist">dist</code></td>
<td>
<p>The distribution to which the standard deviation should be transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The standard deviation translated to the log or logit scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean &lt;- 10
stdev &lt;- 2
mean_trans &lt;- log(mean)
stdev_trans &lt;- stdev_transform(mean, stdev, "log")
draws &lt;- rnorm(50, mean_trans, stdev_trans)
natural_scale &lt;- exp(draws)
mean(draws)
sd(draws)
</code></pre>

<hr>
<h2 id='unstructured_pop'>Simulated Time Series of an Unstructured Temporally Autocorrelated Population</h2><span id='topic+unstructured_pop'></span>

<h3>Description</h3>

<p>This function simulates an unstructured population with
temporally autocorrelated vital rates (survival and fertility). In other
words, this function will show you the dynamics over time of a population
whose survival and fertility is stochastic, but also correlated to the
survival and fertility in the previous year, respectively. The assumptions of the
simulation are that the population is asexually reproducing or female-only,
survival and fertility are the same at all ages / stages,
and that individuals continue to be reproductively capable until they die. The function
includes demographic stochasticity as well as environmental stochasticity, and
does not support density dependence at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unstructured_pop(
  start,
  timesteps,
  survPhi,
  fecundPhi,
  survMean,
  survSd,
  fecundMean,
  fecundSd
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unstructured_pop_+3A_start">start</code></td>
<td>
<p>The starting population size.</p>
</td></tr>
<tr><td><code id="unstructured_pop_+3A_timesteps">timesteps</code></td>
<td>
<p>The number of timesteps you want to simulate. Individuals
are added and killed off every timestep according to the survival and
fertility rates. In ecological applications, timesteps are usually years,
but theoretically they can be any length of time.</p>
</td></tr>
<tr><td><code id="unstructured_pop_+3A_survphi">survPhi</code></td>
<td>
<p>The temporal autocorrelation of survival. 0 is white noise (uncorrelated),
positive values are red noise (directly correlated) and negative values are
blue noise (inversely correlated).</p>
</td></tr>
<tr><td><code id="unstructured_pop_+3A_fecundphi">fecundPhi</code></td>
<td>
<p>The temporal autocorrelation of fecundity. As above.</p>
</td></tr>
<tr><td><code id="unstructured_pop_+3A_survmean">survMean</code></td>
<td>
<p>The mean survival from timestep to timestep. Must be a value
between 0 (all individuals die) and 1 (all individuals live).</p>
</td></tr>
<tr><td><code id="unstructured_pop_+3A_survsd">survSd</code></td>
<td>
<p>The standard deviation of the survival from timestep to
timestep. Must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="unstructured_pop_+3A_fecundmean">fecundMean</code></td>
<td>
<p>The mean fertility: mean offspring produced by each individual per timestep.</p>
</td></tr>
<tr><td><code id="unstructured_pop_+3A_fecundsd">fecundSd</code></td>
<td>
<p>The standard deviation of the fertility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be advised that not all combinations of values will work. If you set survival and
fertility unrealistically high, the population size will tend toward infinity and
the simulation will fail because the numbers are too large to handle. Use your
common sense as a demographer / population biologist.
</p>


<h3>Value</h3>

<p>A data frame with four variables: timestep, population (total individuals
alive at the start of the timestep), newborns (new individuals
born this timestep), and survivors (individuals who survive this timestep).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series1 &lt;- unstructured_pop(start = 20, timesteps = 10, survPhi = 0.7, fecundPhi = -0.1,
survMean = 0.6, survSd = 0.52, fecundMean = 1.2, fecundSd = 0.7)
head(series1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
