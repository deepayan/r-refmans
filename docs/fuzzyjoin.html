<!DOCTYPE html><html lang="en"><head><title>Help for package fuzzyjoin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fuzzyjoin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#difference_join'><p>Join two tables based on absolute difference between their columns</p></a></li>
<li><a href='#distance_join'><p>Join two tables based on a distance metric of one or more columns</p></a></li>
<li><a href='#fuzzy_join'><p>Join two tables based not on exact matches, but with a function</p>
describing whether two vectors are matched or not</a></li>
<li><a href='#genome_join'><p>Join two tables based on overlapping genomic intervals: both a</p></a></li>
<li><a href='#geo_join'><p>Join two tables based on a geo distance of longitudes and latitudes</p></a></li>
<li><a href='#interval_join'><p>Join two tables based on overlapping (low, high) intervals</p></a></li>
<li><a href='#misspellings'><p>A corpus of common misspellings, for examples and</p>
practice</a></li>
<li><a href='#regex_join'><p>Join two tables based on a regular expression in one column</p>
matching the other</a></li>
<li><a href='#stringdist_join'><p>Join two tables based on fuzzy string matching of their columns</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Join Tables Together on Inexact Matching</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Robinson &lt;admiral.david@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Join tables together based not on whether columns
  match exactly, but whether they are similar by some comparison.
  Implementations include string distance and regular expression
  matching.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringdist, stringr, dplyr (&ge; 0.8.1), tidyr (&ge; 0.4.0),
purrr, geosphere, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, ggplot2, qdapDictionaries, readr, rvest,
rmarkdown, maps, IRanges, covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dgrtwo/fuzzyjoin">https://github.com/dgrtwo/fuzzyjoin</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dgrtwo/fuzzyjoin/issues">https://github.com/dgrtwo/fuzzyjoin/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-15 03:30:53 UTC; drobinson</td>
</tr>
<tr>
<td>Author:</td>
<td>David Robinson [aut, cre],
  Jennifer Bryan [ctb],
  Joran Elias [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-15 05:50:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='difference_join'>Join two tables based on absolute difference between their columns</h2><span id='topic+difference_join'></span><span id='topic+difference_inner_join'></span><span id='topic+difference_left_join'></span><span id='topic+difference_right_join'></span><span id='topic+difference_full_join'></span><span id='topic+difference_semi_join'></span><span id='topic+difference_anti_join'></span>

<h3>Description</h3>

<p>Join two tables based on absolute difference between their columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difference_join(
  x,
  y,
  by = NULL,
  max_dist = 1,
  mode = "inner",
  distance_col = NULL
)

difference_inner_join(x, y, by = NULL, max_dist = 1, distance_col = NULL)

difference_left_join(x, y, by = NULL, max_dist = 1, distance_col = NULL)

difference_right_join(x, y, by = NULL, max_dist = 1, distance_col = NULL)

difference_full_join(x, y, by = NULL, max_dist = 1, distance_col = NULL)

difference_semi_join(x, y, by = NULL, max_dist = 1, distance_col = NULL)

difference_anti_join(x, y, by = NULL, max_dist = 1, distance_col = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="difference_join_+3A_x">x</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="difference_join_+3A_y">y</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="difference_join_+3A_by">by</code></td>
<td>
<p>Columns by which to join the two tables</p>
</td></tr>
<tr><td><code id="difference_join_+3A_max_dist">max_dist</code></td>
<td>
<p>Maximum distance to use for joining</p>
</td></tr>
<tr><td><code id="difference_join_+3A_mode">mode</code></td>
<td>
<p>One of &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;full&quot; &quot;semi&quot;, or &quot;anti&quot;</p>
</td></tr>
<tr><td><code id="difference_join_+3A_distance_col">distance_col</code></td>
<td>
<p>If given, will add a column with this
name containing the difference between the two</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

head(iris)
sepal_lengths &lt;- data_frame(Sepal.Length = c(5, 6, 7), Type = 1:3)

iris %&gt;%
  difference_inner_join(sepal_lengths, max_dist = .5)

</code></pre>

<hr>
<h2 id='distance_join'>Join two tables based on a distance metric of one or more columns</h2><span id='topic+distance_join'></span><span id='topic+distance_inner_join'></span><span id='topic+distance_left_join'></span><span id='topic+distance_right_join'></span><span id='topic+distance_full_join'></span><span id='topic+distance_semi_join'></span><span id='topic+distance_anti_join'></span>

<h3>Description</h3>

<p>This differs from <code><a href="#topic+difference_join">difference_join</a></code> in that it considers
all of the columns together when computing distance. This allows it
to use metrics such as Euclidean or Manhattan that depend on multiple
columns. Note that if you are computing with longitude or latitude,
you probably want to use <code><a href="#topic+geo_join">geo_join</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_join(
  x,
  y,
  by = NULL,
  max_dist = 1,
  method = c("euclidean", "manhattan"),
  mode = "inner",
  distance_col = NULL
)

distance_inner_join(
  x,
  y,
  by = NULL,
  method = "euclidean",
  max_dist = 1,
  distance_col = NULL
)

distance_left_join(
  x,
  y,
  by = NULL,
  method = "euclidean",
  max_dist = 1,
  distance_col = NULL
)

distance_right_join(
  x,
  y,
  by = NULL,
  method = "euclidean",
  max_dist = 1,
  distance_col = NULL
)

distance_full_join(
  x,
  y,
  by = NULL,
  method = "euclidean",
  max_dist = 1,
  distance_col = NULL
)

distance_semi_join(
  x,
  y,
  by = NULL,
  method = "euclidean",
  max_dist = 1,
  distance_col = NULL
)

distance_anti_join(
  x,
  y,
  by = NULL,
  method = "euclidean",
  max_dist = 1,
  distance_col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_join_+3A_x">x</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="distance_join_+3A_y">y</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="distance_join_+3A_by">by</code></td>
<td>
<p>Columns by which to join the two tables</p>
</td></tr>
<tr><td><code id="distance_join_+3A_max_dist">max_dist</code></td>
<td>
<p>Maximum distance to use for joining</p>
</td></tr>
<tr><td><code id="distance_join_+3A_method">method</code></td>
<td>
<p>Method to use for computing distance, either euclidean (default)
or manhattan.</p>
</td></tr>
<tr><td><code id="distance_join_+3A_mode">mode</code></td>
<td>
<p>One of &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;full&quot; &quot;semi&quot;, or &quot;anti&quot;</p>
</td></tr>
<tr><td><code id="distance_join_+3A_distance_col">distance_col</code></td>
<td>
<p>If given, will add a column with this
name containing the distance between the two</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

head(iris)
sepal_lengths &lt;- data_frame(Sepal.Length = c(5, 6, 7),
                            Sepal.Width = 1:3)

iris %&gt;%
  distance_inner_join(sepal_lengths, max_dist = 2)

</code></pre>

<hr>
<h2 id='fuzzy_join'>Join two tables based not on exact matches, but with a function
describing whether two vectors are matched or not</h2><span id='topic+fuzzy_join'></span><span id='topic+fuzzy_inner_join'></span><span id='topic+fuzzy_left_join'></span><span id='topic+fuzzy_right_join'></span><span id='topic+fuzzy_full_join'></span><span id='topic+fuzzy_semi_join'></span><span id='topic+fuzzy_anti_join'></span>

<h3>Description</h3>

<p>The <code>match_fun</code> argument is called once on a vector with all pairs
of unique comparisons: thus, it should be efficient and vectorized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_join(
  x,
  y,
  by = NULL,
  match_fun = NULL,
  multi_by = NULL,
  multi_match_fun = NULL,
  index_match_fun = NULL,
  mode = "inner",
  ...
)

fuzzy_inner_join(x, y, by = NULL, match_fun, ...)

fuzzy_left_join(x, y, by = NULL, match_fun, ...)

fuzzy_right_join(x, y, by = NULL, match_fun, ...)

fuzzy_full_join(x, y, by = NULL, match_fun, ...)

fuzzy_semi_join(x, y, by = NULL, match_fun, ...)

fuzzy_anti_join(x, y, by = NULL, match_fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzy_join_+3A_x">x</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="fuzzy_join_+3A_y">y</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="fuzzy_join_+3A_by">by</code></td>
<td>
<p>Columns of each to join</p>
</td></tr>
<tr><td><code id="fuzzy_join_+3A_match_fun">match_fun</code></td>
<td>
<p>Vectorized function given two columns, returning
TRUE or FALSE as to whether they are a match. Can be a list of functions
one for each pair of columns specified in <code>by</code> (if a named list, it
uses the names in x).
If only one function is given it is used on all column pairs.</p>
</td></tr>
<tr><td><code id="fuzzy_join_+3A_multi_by">multi_by</code></td>
<td>
<p>Columns to join, where all columns will be used to
test matches together</p>
</td></tr>
<tr><td><code id="fuzzy_join_+3A_multi_match_fun">multi_match_fun</code></td>
<td>
<p>Function to use for testing matches, performed
on all columns in each data frame simultaneously</p>
</td></tr>
<tr><td><code id="fuzzy_join_+3A_index_match_fun">index_match_fun</code></td>
<td>
<p>Function to use for matching tables. Unlike
<code>match_fun</code> and <code>index_match_fun</code>, this is performed on the
original columns and returns pairs of indices.</p>
</td></tr>
<tr><td><code id="fuzzy_join_+3A_mode">mode</code></td>
<td>
<p>One of &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;full&quot; &quot;semi&quot;, or &quot;anti&quot;</p>
</td></tr>
<tr><td><code id="fuzzy_join_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to match_fun</p>
</td></tr>
</table>


<h3>Details</h3>

<p>match_fun should return either a logical vector, or a data
frame where the first column is logical. If the latter, the
additional columns will be appended to the output. For example,
these additional columns could contain the distance metrics that
one is filtering on.
</p>
<p>Note that as of now, you cannot give both <code>match_fun</code>
and <code>multi_match_fun</code>- you can either compare each column
individually or compare all of them.
</p>
<p>Like in dplyr's join operations, <code>fuzzy_join</code> ignores groups,
but preserves the grouping of x in the output.
</p>

<hr>
<h2 id='genome_join'>Join two tables based on overlapping genomic intervals: both a</h2><span id='topic+genome_join'></span><span id='topic+genome_inner_join'></span><span id='topic+genome_left_join'></span><span id='topic+genome_right_join'></span><span id='topic+genome_full_join'></span><span id='topic+genome_semi_join'></span><span id='topic+genome_anti_join'></span>

<h3>Description</h3>

<p>This is an extension of <code><a href="#topic+interval_join">interval_join</a></code> specific to genomic intervals.
Genomic intervals include both a chromosome ID and an interval: items are only
considered matching if the chromosome ID matches and the interval overlaps.
Note that there must be three arguments to by, and that they must be in the order
c(&quot;chromosome&quot;, &quot;start&quot;, &quot;end&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genome_join(x, y, by = NULL, mode = "inner", ...)

genome_inner_join(x, y, by = NULL, ...)

genome_left_join(x, y, by = NULL, ...)

genome_right_join(x, y, by = NULL, ...)

genome_full_join(x, y, by = NULL, ...)

genome_semi_join(x, y, by = NULL, ...)

genome_anti_join(x, y, by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genome_join_+3A_x">x</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="genome_join_+3A_y">y</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="genome_join_+3A_by">by</code></td>
<td>
<p>Names of columns to join on, in order c(&quot;chromosome&quot;, &quot;start&quot;, &quot;end&quot;).
A match will be counted only if the chromosomes are equal and the start/end pairs
overlap.</p>
</td></tr>
<tr><td><code id="genome_join_+3A_mode">mode</code></td>
<td>
<p>One of &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;full&quot; &quot;semi&quot;, or &quot;anti&quot;</p>
</td></tr>
<tr><td><code id="genome_join_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on to <code><a href="IRanges.html#topic+findOverlaps">findOverlaps</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the extra arguments to <code><a href="#topic+interval_join">interval_join</a></code>, which are
passed on to <code><a href="IRanges.html#topic+findOverlaps">findOverlaps</a></code>, work for <code>genome_join</code>
as well. These include <code>maxgap</code> and <code>minoverlap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

x1 &lt;- tibble(id1 = 1:4,
             chromosome = c("chr1", "chr1", "chr2", "chr2"),
             start = c(100, 200, 300, 400),
             end = c(150, 250, 350, 450))

x2 &lt;- tibble(id2 = 1:4,
             chromosome = c("chr1", "chr2", "chr2", "chr1"),
             start = c(140, 210, 400, 300),
             end = c(160, 240, 415, 320))

if (requireNamespace("IRanges", quietly = TRUE)) {
  # note that the the third and fourth items don't join (even though
  # 300-350 and 300-320 overlap) since the chromosomes are different:
  genome_inner_join(x1, x2, by = c("chromosome", "start", "end"))

  # other functions:
  genome_full_join(x1, x2, by = c("chromosome", "start", "end"))
  genome_left_join(x1, x2, by = c("chromosome", "start", "end"))
  genome_right_join(x1, x2, by = c("chromosome", "start", "end"))
  genome_semi_join(x1, x2, by = c("chromosome", "start", "end"))
  genome_anti_join(x1, x2, by = c("chromosome", "start", "end"))
}

</code></pre>

<hr>
<h2 id='geo_join'>Join two tables based on a geo distance of longitudes and latitudes</h2><span id='topic+geo_join'></span><span id='topic+geo_inner_join'></span><span id='topic+geo_left_join'></span><span id='topic+geo_right_join'></span><span id='topic+geo_full_join'></span><span id='topic+geo_semi_join'></span><span id='topic+geo_anti_join'></span>

<h3>Description</h3>

<p>This allows joining based on combinations of longitudes and latitudes. If
you are using a distance metric that is *not* based on latitude and
longitude, use <code><a href="#topic+distance_join">distance_join</a></code> instead. Distances are
calculated based on the <code>distHaversine</code>, <code>distGeo</code>,
<code>distCosine</code>, etc methods in the geosphere package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_join(
  x,
  y,
  by = NULL,
  max_dist,
  method = c("haversine", "geo", "cosine", "meeus", "vincentysphere",
    "vincentyellipsoid"),
  unit = c("miles", "km"),
  mode = "inner",
  distance_col = NULL,
  ...
)

geo_inner_join(
  x,
  y,
  by = NULL,
  method = "haversine",
  max_dist = 1,
  distance_col = NULL,
  ...
)

geo_left_join(
  x,
  y,
  by = NULL,
  method = "haversine",
  max_dist = 1,
  distance_col = NULL,
  ...
)

geo_right_join(
  x,
  y,
  by = NULL,
  method = "haversine",
  max_dist = 1,
  distance_col = NULL,
  ...
)

geo_full_join(
  x,
  y,
  by = NULL,
  method = "haversine",
  max_dist = 1,
  distance_col = NULL,
  ...
)

geo_semi_join(
  x,
  y,
  by = NULL,
  method = "haversine",
  max_dist = 1,
  distance_col = NULL,
  ...
)

geo_anti_join(
  x,
  y,
  by = NULL,
  method = "haversine",
  max_dist = 1,
  distance_col = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_join_+3A_x">x</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="geo_join_+3A_y">y</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="geo_join_+3A_by">by</code></td>
<td>
<p>Columns by which to join the two tables</p>
</td></tr>
<tr><td><code id="geo_join_+3A_max_dist">max_dist</code></td>
<td>
<p>Maximum distance to use for joining</p>
</td></tr>
<tr><td><code id="geo_join_+3A_method">method</code></td>
<td>
<p>Method to use for computing distance: one of
&quot;haversine&quot; (default), &quot;geo&quot;, &quot;cosine&quot;, &quot;meeus&quot;, &quot;vincentysphere&quot;,
&quot;vincentyellipsoid&quot;</p>
</td></tr>
<tr><td><code id="geo_join_+3A_unit">unit</code></td>
<td>
<p>Unit of distance for threshold (default &quot;miles&quot;)</p>
</td></tr>
<tr><td><code id="geo_join_+3A_mode">mode</code></td>
<td>
<p>One of &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;full&quot; &quot;semi&quot;, or &quot;anti&quot;</p>
</td></tr>
<tr><td><code id="geo_join_+3A_distance_col">distance_col</code></td>
<td>
<p>If given, will add a column with this
name containing the geographical distance between the two</p>
</td></tr>
<tr><td><code id="geo_join_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on to the distance method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;Haversine&quot; was chosen as default since in some tests it is
approximately the fastest method. Note that by far the slowest method is
vincentyellipsoid, and on fuzzy joins should only be used when there are
very few pairs and accuracy is imperative.
</p>
<p>If you need to use a custom geo method, you may want to write it directly
with the <code>multi_by</code> and <code>multi_match_fun</code> arguments to
<code>fuzzy_join</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
data("state")

# find pairs of US states whose centers are within
# 200 miles of each other
states &lt;- data_frame(state = state.name,
                     longitude = state.center$x,
                     latitude = state.center$y)

s1 &lt;- rename(states, state1 = state)
s2 &lt;- rename(states, state2 = state)

pairs &lt;- s1 %&gt;%
 geo_inner_join(s2, max_dist = 200) %&gt;%
 filter(state1 != state2)

pairs

# plot them
library(ggplot2)
ggplot(pairs, aes(x = longitude.x, y = latitude.x,
                  xend = longitude.y, yend = latitude.y)) +
  geom_segment(color = "red") +
  borders("state") +
  theme_void()

# also get distances
s1 %&gt;%
  geo_inner_join(s2, max_dist = 200, distance_col = "distance")

</code></pre>

<hr>
<h2 id='interval_join'>Join two tables based on overlapping (low, high) intervals</h2><span id='topic+interval_join'></span><span id='topic+interval_inner_join'></span><span id='topic+interval_left_join'></span><span id='topic+interval_right_join'></span><span id='topic+interval_full_join'></span><span id='topic+interval_semi_join'></span><span id='topic+interval_anti_join'></span>

<h3>Description</h3>

<p>Joins tables based on overlapping intervals: for example, joining
the row (1, 4) with (3, 6), but not with (5, 10). This operation is sped up
using interval trees as implemented in the IRanges package. You
can specify particular relationships between intervals (such as a maximum gap,
or a minimum overlap) through arguments passed on to
<code><a href="IRanges.html#topic+findOverlaps">findOverlaps</a></code>. See that documentation for descriptions
of such arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval_join(x, y, by, mode = "inner", ...)

interval_inner_join(x, y, by = NULL, ...)

interval_left_join(x, y, by = NULL, ...)

interval_right_join(x, y, by = NULL, ...)

interval_full_join(x, y, by = NULL, ...)

interval_semi_join(x, y, by = NULL, ...)

interval_anti_join(x, y, by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interval_join_+3A_x">x</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="interval_join_+3A_y">y</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="interval_join_+3A_by">by</code></td>
<td>
<p>Columns by which to join the two tables. If provided, this must be
two columns: start of interval, then end of interval</p>
</td></tr>
<tr><td><code id="interval_join_+3A_mode">mode</code></td>
<td>
<p>One of &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;full&quot; &quot;semi&quot;, or &quot;anti&quot;</p>
</td></tr>
<tr><td><code id="interval_join_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on to <code><a href="IRanges.html#topic+findOverlaps">findOverlaps</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This allows joining on date or datetime intervals. It throws an
error if the type of date/datetime disagrees between the two tables.
</p>
<p>This requires the IRanges package from Bioconductor. See here for installation:
<a href="https://bioconductor.org/packages/release/bioc/html/IRanges.html">https://bioconductor.org/packages/release/bioc/html/IRanges.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("IRanges", quietly = TRUE)) {
  x1 &lt;- data.frame(id1 = 1:3, start = c(1, 5, 10), end = c(3, 7, 15))
  x2 &lt;- data.frame(id2 = 1:3, start = c(2, 4, 16), end = c(4, 8, 20))

  interval_inner_join(x1, x2)

  # Allow them to be separated by a gap with a maximum:
  interval_inner_join(x1, x2, maxgap = 1)   # let 1 join with 2
  interval_inner_join(x1, x2, maxgap = 20)  # everything joins each other

  # Require that they overlap by more than a particular amount
  interval_inner_join(x1, x2, minoverlap = 3)

  # other types of joins:
  interval_full_join(x1, x2)
  interval_left_join(x1, x2)
  interval_right_join(x1, x2)
  interval_semi_join(x1, x2)
  interval_anti_join(x1, x2)
}

</code></pre>

<hr>
<h2 id='misspellings'>A corpus of common misspellings, for examples and
practice</h2><span id='topic+misspellings'></span>

<h3>Description</h3>

<p>This is a codetbl_df mapping misspellings of their words, compiled by
Wikipedia, where it is licensed under the CC-BY SA license.
(Three words with non-ASCII characters were filtered out).
If you'd like to reproduce this dataset from Wikipedia, see the example
code below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>misspellings
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 4505 rows and 2 columns.
</p>


<h3>Source</h3>

<p><a href="https://en.wikipedia.org/wiki/Wikipedia:Lists_of_common_misspellings/For_machines">https://en.wikipedia.org/wiki/Wikipedia:Lists_of_common_misspellings/For_machines</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(rvest)
library(readr)
library(dplyr)
library(stringr)
library(tidyr)

u &lt;- "https://en.wikipedia.org/wiki/Wikipedia:Lists_of_common_misspellings/For_machines"
h &lt;- read_html(u)

misspellings &lt;- h %&gt;%
  html_nodes("pre") %&gt;%
  html_text() %&gt;%
  readr::read_delim(col_names = c("misspelling", "correct"), delim = "&gt;",
                    skip = 1) %&gt;%
  mutate(misspelling = str_sub(misspelling, 1, -2)) %&gt;%
  unnest(correct = str_split(correct, ", ")) %&gt;%
  filter(Encoding(correct) != "UTF-8")

## End(Not run)

</code></pre>

<hr>
<h2 id='regex_join'>Join two tables based on a regular expression in one column
matching the other</h2><span id='topic+regex_join'></span><span id='topic+regex_inner_join'></span><span id='topic+regex_left_join'></span><span id='topic+regex_right_join'></span><span id='topic+regex_full_join'></span><span id='topic+regex_semi_join'></span><span id='topic+regex_anti_join'></span>

<h3>Description</h3>

<p>Join a table with a string column by a regular expression column
in another table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regex_join(x, y, by = NULL, mode = "inner", ignore_case = FALSE)

regex_inner_join(x, y, by = NULL, ignore_case = FALSE)

regex_left_join(x, y, by = NULL, ignore_case = FALSE)

regex_right_join(x, y, by = NULL, ignore_case = FALSE)

regex_full_join(x, y, by = NULL, ignore_case = FALSE)

regex_semi_join(x, y, by = NULL, ignore_case = FALSE)

regex_anti_join(x, y, by = NULL, ignore_case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regex_join_+3A_x">x</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="regex_join_+3A_y">y</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="regex_join_+3A_by">by</code></td>
<td>
<p>Columns by which to join the two tables</p>
</td></tr>
<tr><td><code id="regex_join_+3A_mode">mode</code></td>
<td>
<p>One of &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;full&quot; &quot;semi&quot;, or &quot;anti&quot;</p>
</td></tr>
<tr><td><code id="regex_join_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Whether to be case insensitive (default no)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>str_detect</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)
data(diamonds)

diamonds &lt;- tbl_df(diamonds)

d &lt;- data_frame(regex_name = c("^Idea", "mium", "Good"),
                type = 1:3)

# When they are inner_joined, only Good&lt;-&gt;Good matches
diamonds %&gt;%
  inner_join(d, by = c(cut = "regex_name"))

# but we can regex match them
diamonds %&gt;%
 regex_inner_join(d, by = c(cut = "regex_name"))

</code></pre>

<hr>
<h2 id='stringdist_join'>Join two tables based on fuzzy string matching of their columns</h2><span id='topic+stringdist_join'></span><span id='topic+stringdist_inner_join'></span><span id='topic+stringdist_left_join'></span><span id='topic+stringdist_right_join'></span><span id='topic+stringdist_full_join'></span><span id='topic+stringdist_semi_join'></span><span id='topic+stringdist_anti_join'></span>

<h3>Description</h3>

<p>Join two tables based on fuzzy string matching of their columns.
This is useful, for example, in matching free-form inputs in
a survey or online form, where it can catch misspellings and
small personal changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringdist_join(
  x,
  y,
  by = NULL,
  max_dist = 2,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw",
    "soundex"),
  mode = "inner",
  ignore_case = FALSE,
  distance_col = NULL,
  ...
)

stringdist_inner_join(x, y, by = NULL, distance_col = NULL, ...)

stringdist_left_join(x, y, by = NULL, distance_col = NULL, ...)

stringdist_right_join(x, y, by = NULL, distance_col = NULL, ...)

stringdist_full_join(x, y, by = NULL, distance_col = NULL, ...)

stringdist_semi_join(x, y, by = NULL, distance_col = NULL, ...)

stringdist_anti_join(x, y, by = NULL, distance_col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stringdist_join_+3A_x">x</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="stringdist_join_+3A_y">y</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="stringdist_join_+3A_by">by</code></td>
<td>
<p>Columns by which to join the two tables</p>
</td></tr>
<tr><td><code id="stringdist_join_+3A_max_dist">max_dist</code></td>
<td>
<p>Maximum distance to use for joining</p>
</td></tr>
<tr><td><code id="stringdist_join_+3A_method">method</code></td>
<td>
<p>Method for computing string distance, see
<code>stringdist-metrics</code> in the stringdist package.</p>
</td></tr>
<tr><td><code id="stringdist_join_+3A_mode">mode</code></td>
<td>
<p>One of &quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;full&quot; &quot;semi&quot;, or &quot;anti&quot;</p>
</td></tr>
<tr><td><code id="stringdist_join_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Whether to be case insensitive (default yes)</p>
</td></tr>
<tr><td><code id="stringdist_join_+3A_distance_col">distance_col</code></td>
<td>
<p>If given, will add a column with this
name containing the difference between the two</p>
</td></tr>
<tr><td><code id="stringdist_join_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>stringdist</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method = "soundex"</code>, the <code>max_dist</code> is
automatically set to 0.5, since soundex returns either a 0 (match)
or a 1 (no match).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)
data(diamonds)

d &lt;- data_frame(approximate_name = c("Idea", "Premiums", "Premioom",
                                     "VeryGood", "VeryGood", "Faiir"),
                type = 1:6)

# no matches when they are inner-joined:
diamonds %&gt;%
  inner_join(d, by = c(cut = "approximate_name"))

# but we can match when they're fuzzy joined
diamonds %&gt;%
 stringdist_inner_join(d, by = c(cut = "approximate_name"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
