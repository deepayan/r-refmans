<!DOCTYPE html><html lang="en"><head><title>Help for package spmoran</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spmoran}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addlearn_local'><p>Additional learning of local processes and prediction for large samples</p></a></li>
<li><a href='#besf'><p>Spatial regression with RE-ESF for very large samples</p></a></li>
<li><a href='#besf_vc'><p>Spatially and non-spatially varying coefficient (SNVC) modeling for very large samples</p></a></li>
<li><a href='#coef_marginal'><p>Marginal effects evaluation</p></a></li>
<li><a href='#coef_marginal_vc'><p>Marginal effects evaluation from models with varying coefficients</p></a></li>
<li><a href='#esf'><p>Spatial regression with eigenvector spatial filtering</p></a></li>
<li><a href='#lsem'><p>Low rank spatial error model (LSEM) estimation</p></a></li>
<li><a href='#lslm'><p>Low rank spatial lag model (LSLM) estimation</p></a></li>
<li><a href='#meigen'><p>Extraction of Moran eigenvectors</p></a></li>
<li><a href='#meigen_f'><p>Fast approximation of Moran eigenvectors</p></a></li>
<li><a href='#meigen0'><p>Nystrom extension of Moran eigenvectors</p></a></li>
<li><a href='#nongauss_y'><p>Parameter setup for modeling non-Gaussian continuous data and count data</p></a></li>
<li><a href='#plot_n'><p>Plot non-spatially varying coefficients (NVCs)</p></a></li>
<li><a href='#plot_qr'><p>Plot quantile regression coefficients estimated from SF-UQR</p></a></li>
<li><a href='#plot_s'><p>Mapping spatially and spatio-temporally varying coefficients</p></a></li>
<li><a href='#predict0'><p>Spatial and spatio-temporal predictions</p></a></li>
<li><a href='#resf'><p>spatial and spatio-temporal regression models</p></a></li>
<li><a href='#resf_qr'><p>Spatial filter unconditional quantile regression</p></a></li>
<li><a href='#resf_vc'><p>spatial and spatio-temporal regression models with varying coefficients</p></a></li>
<li><a href='#weigen'><p>Extract eigenvectors from a spatial weight matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Spatial and Spatio-Temporal Regression using Moran
Eigenvectors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daisuke Murakami &lt;dmuraka@ism.ac.jp&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions for estimating spatial and spatio-temporal regression models. Moran eigenvectors are used as spatial basis functions to efficiently approximate spatially dependent Gaussian processes (i.e., random effects eigenvector spatial filtering; see Murakami and Griffith 2015 &lt;<a href="https://doi.org/10.1007%2Fs10109-015-0213-7">doi:10.1007/s10109-015-0213-7</a>&gt;). The implemented models include linear regression with residual spatial dependence, spatially/spatio-temporally varying coefficient models (Murakami et al., 2017, 2024; &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2016.12.001%26gt%3B%2C%26lt%3Bdoi%3A10.48550%2FarXiv.2410.07229">doi:10.1016/j.spasta.2016.12.001&gt;,&lt;doi:10.48550/arXiv.2410.07229</a>&gt;), spatially filtered unconditional quantile regression (Murakami and Seya, 2019 &lt;<a href="https://doi.org/10.1002%2Fenv.2556">doi:10.1002/env.2556</a>&gt;), Gaussian and non-Gaussian spatial mixed models through compositionally-warping (Murakami et al. 2021, &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2021.100520">doi:10.1016/j.spasta.2021.100520</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, fields, vegan, Matrix, doParallel, foreach, ggplot2,
spdep, rARPACK, RColorBrewer, splines, FNN, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, spData (&ge; 2.3.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dmuraka/spmoran">https://github.com/dmuraka/spmoran</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Daisuke Murakami [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-04 16:18:56 UTC; murak</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-05 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addlearn_local'>Additional learning of local processes and prediction for large samples</h2><span id='topic+addlearn_local'></span>

<h3>Description</h3>

<p>This function performs an additional learning of local variations in spatially varying coefficients (SVC). While the SVC model implemented in <code><a href="#topic+resf_vc">resf_vc</a></code> or <code><a href="#topic+besf_vc">besf_vc</a></code> can be less accurate for large samples (e.g., n &gt; 5,000) due to a degeneracy/over-smoothing problem, this additional learning mitigates this problem by synthesizing/averaging the model with local SVC models. The resulting spatial prediction implemented in this function is expected to be more accurate than the resf_vc function.
</p>
<p>Note that this function is not yet supported for spatio-temporal models with <code>!is.null(meig$coords_z)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addlearn_local( mod, meig0 = NULL, x0 = NULL, xconst0=NULL, xgroup0=NULL,
           cl_num=NULL, cl=NULL, parallel=FALSE, ncores=NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addlearn_local_+3A_mod">mod</code></td>
<td>
<p>Outpot from <code><a href="#topic+resf">resf</a></code>, <code><a href="#topic+resf_vc">resf_vc</a></code> or  <code><a href="#topic+besf_vc">besf_vc</a></code> function</p>
</td></tr>
<tr><td><code id="addlearn_local_+3A_meig0">meig0</code></td>
<td>
<p>Moran eigenvectors at prediction sites. Output from <code><a href="#topic+meigen0">meigen0</a></code></p>
</td></tr>
<tr><td><code id="addlearn_local_+3A_x0">x0</code></td>
<td>
<p>Matrix of explanatory variables at prediction sites whose coefficients are allowed to vary across geographical space (N_0 x K). Default is NULL</p>
</td></tr>
<tr><td><code id="addlearn_local_+3A_xconst0">xconst0</code></td>
<td>
<p>Matrix of explanatory variables at prediction sites whose coefficients are assumed constant (or NVC) across space (N_0 x K_const). Default is NULL</p>
</td></tr>
<tr><td><code id="addlearn_local_+3A_xgroup0">xgroup0</code></td>
<td>
<p>Matrix of group indeces at prediction sites that may be group IDs (integers) or group names (N_0 x K_g). Default is NULL</p>
</td></tr>
<tr><td><code id="addlearn_local_+3A_cl_num">cl_num</code></td>
<td>
<p>Number of local sub-models being aggregated/averaged. If NULL, the number is determined so that the number of samples per sub-model equals approximately 600. Default is NULL</p>
</td></tr>
<tr><td><code id="addlearn_local_+3A_cl">cl</code></td>
<td>
<p>Vector of cluster ID for each sample (N x 1). If specified, the local sub-models are given by this ID. If NULL, k-means clustering based on spatial coordinates is performed to obtain spatial clusters each of which contain approximately 600 samples. Default is NULL</p>
</td></tr>
<tr><td><code id="addlearn_local_+3A_parallel">parallel</code></td>
<td>
<p>If TRUE, the model is estimated through parallel computation. The default is FALSE</p>
</td></tr>
<tr><td><code id="addlearn_local_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for the parallel computation. If ncores = NULL and parallel = TRUE, the number of available cores - 2 is used. Default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b_vc</code></td>
<td>
<p>Matrix of estimated spatially varying coefficients (SVCs) on x (N x K)</p>
</td></tr>
<tr><td><code>bse_vc</code></td>
<td>
<p>Matrix of standard errors for the SVCs on x (N x k)</p>
</td></tr>
<tr><td><code>z_vc</code></td>
<td>
<p>Matrix of z-values for the SVCs on x (N x K)</p>
</td></tr>
<tr><td><code>p_vc</code></td>
<td>
<p>Matrix of p-values for the SVCs on x (N x K)</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Matrix with columns for the estimated coefficients on xconst, their standard errors, z-values, and p-values (K_c x 4)</p>
</td></tr>
<tr><td><code>b_g</code></td>
<td>
<p>List of K_g matrices with columns for the estimated group effects, their standard deviations, and t-values</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>List of 2 elements summarizing variance parameters characterizing SVCs of each local sub-model. The first element contains standard deviations of each SVCs while the second elementcontains their Moran's I values that are scaled to take a value between 0 (no spatial dependence) and 1 (strongest positive spatial dependence). Based on Griffith (2003), the scaled Moran'I value is interpretable as follows: 0.25-0.50:weak; 0.50-0.70:moderate; 0.70-0.90:strong; 0.90-1.00:marked</p>
</td></tr>
<tr><td><code>s_global</code></td>
<td>
<p>The same variance parameters for the globa sub-model</p>
</td></tr>
<tr><td><code>s_g</code></td>
<td>
<p>Vector of standard deviations of the group effects</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Error statistics. It includes residual standard error (resid_SE), adjusted conditional R2 (adjR2(cond)), restricted log-likelihood (rlogLik), Akaike information criterion (AIC), and Bayesian information criterion (BIC)</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Matrix of predicted values for y (pred) and their standard errors (pred_se) (N x 2)</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Vector of residuals (N x 1)</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>Vector of cluster ID being used (N x 1)</p>
</td></tr>
<tr><td><code>pred0</code></td>
<td>
<p>Matrix of predicted values for y (pred) and their standard errors (pred_se) at prediction sites (N_0 x 2)</p>
</td></tr>
<tr><td><code>b_vc0</code></td>
<td>
<p>Matrix of estimated spatially varying coefficients (SVCs) at prediction sites (N_0 x K)</p>
</td></tr>
<tr><td><code>bse_vc0</code></td>
<td>
<p>Matrix of standard errors for the SVCs at prediction sites (N_0 x k)</p>
</td></tr>
<tr><td><code>z_vc0</code></td>
<td>
<p>Matrix of z-values for the SVCs at prediction sites (N x K)</p>
</td></tr>
<tr><td><code>p_vc0</code></td>
<td>
<p>Matrix of p-values for the SVCs at prediction sites (N x K)</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Murakami, D., Sugasawa, S., T., Seya, H., and Griffith, D.A. (2024) Sub-model aggregation-based scalable eigenvector spatial filtering: application to spatially varying coefficient modeling. Geographical Analysis, DOI: 10.1111/gean.12393.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resf">resf</a></code>, <code><a href="#topic+resf_vc">resf_vc</a></code>, <code><a href="#topic+besf_vc">besf_vc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spdep)
data(house)
dat0    &lt;- data.frame(house@coords,house@data)
dat     &lt;- dat0[dat0$yrbuilt&gt;=1980,]

###### purpose 1: improve SVC modeling accuracy ######
###### (i.e., addressing the over-smoothing problem) #
y	      &lt;- log(dat[,"price"])
x       &lt;- dat[,c("age","rooms")]
xconst  &lt;- dat[,c("lotsize","s1994","s1995","s1996","s1997","s1998")]
coords  &lt;- dat[ ,c("long","lat")]
meig    &lt;- meigen_f( coords )

## Not run
# res0  &lt;- resf_vc(y = y,x = x, xconst = xconst, meig = meig)
# res   &lt;- addlearn_local(res0) # It adjusts SVCs to model local patterns
# res

####### parallel version for very large samples (e.g., n &gt;100,000)
# bes0  &lt;- besf_vc(y = y,x = x, xconst = xconst, coords=coords)
# bes	  &lt;- addlearn_local( bes0 )


####### purpose 2: improve predictive accuracy ########

#samp    &lt;- sample( dim( dat )[ 1 ], 2500)
#d       &lt;- dat[ samp, ]    ## Data at observed sites
#y	     &lt;- log(d[,"price"])
#x       &lt;- d[,c("age","rooms")]
#xconst  &lt;- d[,c("lotsize","s1994","s1995","s1996","s1997","s1998")]
#coords  &lt;- d[ ,c("long","lat")]

#d0      &lt;- dat[-samp, ]    ## Data at observed sites
#y0	     &lt;- log(d0[,"price"])
#x0      &lt;- d0[,c("age","rooms")]
#xconst0 &lt;- d0[,c("lotsize","s1994","s1995","s1996","s1997","s1998")]
#coords0 &lt;- d0[ ,c("long","lat")]

#meig    &lt;- meigen_f( coords )
#meig0   &lt;- meigen0( meig=meig, coords0=coords0 )
#
#res0    &lt;- resf(y = y,x = cbind(x,xconst), meig = meig)
#res     &lt;- addlearn_local(res0, meig0=meig0, x0=cbind(x0,xconst0))
#pred    &lt;- res$pred0       ## Predictive values
#
## OR
#res0    &lt;- resf_vc(y = y,x = x, xconst = xconst, meig = meig)
#res     &lt;- addlearn_local(res0, meig0=meig0, x0=x0, xconst0=xconst0)
#pred    &lt;- res$pred0       ## Predictive values

</code></pre>

<hr>
<h2 id='besf'>Spatial regression with RE-ESF for very large samples</h2><span id='topic+besf'></span>

<h3>Description</h3>

<p>Parallel and memory-free implementation of RE-ESF-based spatial regression for very large samples. This model estimates residual spatial dependence, constant coefficients, and non-spatially varying coefficients (NVC; coefficients varying with respect to explanatory variable value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besf( y, x = NULL, nvc = FALSE, nvc_sel = TRUE, coords, s_id = NULL,
      covmodel="exp", enum = 200, method = "reml", penalty = "bic", nvc_num = 5,
      maxiter = 30, bsize = 4000, ncores = NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="besf_+3A_y">y</code></td>
<td>
<p>Vector of explained variables (N x 1)</p>
</td></tr>
<tr><td><code id="besf_+3A_x">x</code></td>
<td>
<p>Matrix of explanatory variables (N x K)</p>
</td></tr>
<tr><td><code id="besf_+3A_nvc">nvc</code></td>
<td>
<p>If TRUE, NVCs are assumed on x. Otherwise, constant coefficients are assumed. Default is FALSE</p>
</td></tr>
<tr><td><code id="besf_+3A_nvc_sel">nvc_sel</code></td>
<td>
<p>If TRUE, type of coefficients (NVC or constant) is selected through a BIC (default) or AIC minimization. If FALSE, NVCs are assumed across x. Alternatively, nvc_sel can be given by column number(s) of x. For example, if nvc_sel = 2, the coefficient on the second explanatory variable in x is NVC and the other coefficients are constants. The Default is TRUE</p>
</td></tr>
<tr><td><code id="besf_+3A_coords">coords</code></td>
<td>
<p>Matrix of spatial point coordinates (N x 2)</p>
</td></tr>
<tr><td><code id="besf_+3A_s_id">s_id</code></td>
<td>
<p>Optional. ID specifying groups modeling spatially dependent process (N x 1). If it is specified, group-level spatial process is estimated. It is useful. e.g., for multilevel modeling (s_id is given by the group ID) and panel data modeling (s_id is given by individual location id). Default is NULL</p>
</td></tr>
<tr><td><code id="besf_+3A_covmodel">covmodel</code></td>
<td>
<p>Type of kernel to model spatial dependence. The currently available options are &quot;exp&quot; for the exponential kernel, &quot;gau&quot; for the Gaussian kernel, and &quot;sph&quot; for the spherical kernel</p>
</td></tr>
<tr><td><code id="besf_+3A_enum">enum</code></td>
<td>
<p>Number of Moran eigenvectors to be used for spatial process modeling (scalar). Default is 200</p>
</td></tr>
<tr><td><code id="besf_+3A_method">method</code></td>
<td>
<p>Estimation method. Restricted maximum likelihood method (&quot;reml&quot;) and maximum likelihood method (&quot;ml&quot;) are available. Default is &quot;reml&quot;</p>
</td></tr>
<tr><td><code id="besf_+3A_penalty">penalty</code></td>
<td>
<p>Penalty to select type of coefficients (NVC or constant) to stablize the estimates. The current options are &quot;bic&quot; for the Baysian information criterion-type penalty (N x log(K)) and &quot;aic&quot; for the Akaike information criterion  (2K) (see Muller et al., 2013). Default is &quot;bic&quot;</p>
</td></tr>
<tr><td><code id="besf_+3A_nvc_num">nvc_num</code></td>
<td>
<p>Number of basis functions used to model NVC. An intercept and nvc_num natural spline basis functions are used to model each NVC. Default is 5</p>
</td></tr>
<tr><td><code id="besf_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. Default is 30</p>
</td></tr>
<tr><td><code id="besf_+3A_bsize">bsize</code></td>
<td>
<p>Block/badge size. bsize x bsize elements are iteratively processed during the parallelized computation. Default is 4000</p>
</td></tr>
<tr><td><code id="besf_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for the parallel computation. If ncores = NULL, the number of available cores - 2 is detected and used. Default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>Matrix with columns for the estimated coefficients on x, their standard errors, z-values, and p-values (K x 4). Effective if nvc =FALSE</p>
</td></tr>
<tr><td><code>c_vc</code></td>
<td>
<p>Matrix of estimated NVCs on x (N x K). Effective if nvc =TRUE</p>
</td></tr>
<tr><td><code>cse_vc</code></td>
<td>
<p>Matrix of standard errors for the NVCs on x (N x K). Effective if nvc =TRUE</p>
</td></tr>
<tr><td><code>ct_vc</code></td>
<td>
<p>Matrix of t-values for the NVCs on x (N x K). Effective if nvc =TRUE</p>
</td></tr>
<tr><td><code>cp_vc</code></td>
<td>
<p>Matrix of p-values for the NVCs on x (N x K). Effective if nvc =TRUE</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Vector of estimated variance parameters (2 x 1). The first and the second elements denote the standard deviation and the Moran's I value of the estimated spatially dependent component, respectively. The Moran's I value is scaled to take a value between 0 (no spatial dependence) and 1 (the maximum possible spatial dependence). Based on Griffith (2003), the scaled Moran'I value is interpretable as follows: 0.25-0.50:weak; 0.50-0.70:moderate; 0.70-0.90:strong; 0.90-1.00:marked</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Vector whose elements are residual standard error (resid_SE), adjusted conditional R2 (adjR2(cond)), restricted log-likelihood (rlogLik), Akaike information criterion (AIC), and Bayesian information criterion (BIC). When method = &quot;ml&quot;, restricted log-likelihood (rlogLik) is replaced with log-likelihood (logLik)</p>
</td></tr>
<tr><td><code>vc</code></td>
<td>
<p>List indicating whether NVC are removed or not during the BIC/AIC minimization. 1 indicates not removed whreas 0 indicates removed</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Vector of estimated random coefficients on Moran's eigenvectors (L x 1)</p>
</td></tr>
<tr><td><code>sf</code></td>
<td>
<p>Vector of estimated spatial dependent component (N x 1)</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Vector of predicted values (N x 1)</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Vector of residuals (N x 1)</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Griffith, D. A. (2003). Spatial autocorrelation and spatial filtering: gaining understanding through theory and scientific visualization. Springer Science &amp; Business Media.
</p>
<p>Murakami, D. and Griffith, D.A. (2015) Random effects specifications in eigenvector spatial filtering: a simulation study. Journal of Geographical Systems, 17 (4), 311-331.
</p>
<p>Murakami, D. and Griffith, D.A. (2019) A memory-free spatial additive mixed modeling for big spatial data. Japan Journal of Statistics and Data Science. DOI:10.1007/s42081-019-00063-x.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resf">resf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spdep)
data(boston)
y	&lt;- boston.c[, "CMEDV" ]
x	&lt;- boston.c[,c("CRIM","ZN","INDUS", "CHAS", "NOX","RM", "AGE",
                       "DIS" ,"RAD", "TAX", "PTRATIO", "B", "LSTAT")]
xgroup  &lt;- boston.c[,"TOWN"]
coords  &lt;- boston.c[,c("LON", "LAT")]

######## Regression considering spatially dependent residuals
#res	  &lt;- besf(y = y, x = x, coords=coords)
#res

######## Regression considering spatially dependent residuals and NVC
######## (coefficients or NVC is selected)
#res2  &lt;- besf(y = y, x = x, coords=coords, nvc = TRUE)

######## Regression considering spatially dependent residuals and NVC
######## (all the coefficients are NVCs)
#res3  &lt;- besf(y = y, x = x, coords=coords, nvc = TRUE, nvc_sel=FALSE)

</code></pre>

<hr>
<h2 id='besf_vc'>Spatially and non-spatially varying coefficient (SNVC) modeling for very large samples</h2><span id='topic+besf_vc'></span>

<h3>Description</h3>

<p>Parallel and memory-free implementation of SNVC modeling for very large samples. The model estimates residual spatial dependence, constant coefficients, spatially varying coefficients (SVCs), non-spatially varying coefficients (NVC; coefficients varying with respect to explanatory variable value), and SNVC (= SVC + NVC). Type of coefficients can be selected through BIC/AIC minimization. By default, it estimates a SVC model. SNVCs can be mapped just like SVCs. Unlike SVC models, SNVC model is robust against spurious correlation (multicollinearity), so, stable (see Murakami and Griffith, 2020). This function is not yet supported for spatio-temporal modeling.
</p>
<p>Note: The SVC model can be less accurate for large samples due to a degeneracy/over-smoothing problem (see Murakami et al., 2023). The <code><a href="#topic+addlearn_local">addlearn_local</a></code> is useful to mitigate this problem (See the coding example below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besf_vc( y, x, xconst = NULL, coords, s_id = NULL, x_nvc = FALSE, xconst_nvc = FALSE,
         x_sel = TRUE, x_nvc_sel = TRUE, xconst_nvc_sel = TRUE, nvc_num=5,
         method = "reml", penalty = "bic", maxiter = 30, tol = 1e-30,
                      covmodel="exp",enum = 200, bsize = 4000, ncores=NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="besf_vc_+3A_y">y</code></td>
<td>
<p>Vector of explained variables (N x 1)</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_x">x</code></td>
<td>
<p>Matrix of explanatory variables with spatially varying coefficients (SVC) (N x K)</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_xconst">xconst</code></td>
<td>
<p>Matrix of explanatory variables with constant coefficients (N x K_c). Default is NULL</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_coords">coords</code></td>
<td>
<p>Matrix of spatial point coordinates (N x 2)</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_s_id">s_id</code></td>
<td>
<p>Optional. ID specifying groups modeling spatially dependent process (N x 1). If it is specified, group-level spatial process is estimated. It is useful for multilevel modeling (s_id is given by the group ID) and panel data modeling (s_id is given by individual location id). Default is NULL</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_x_nvc">x_nvc</code></td>
<td>
<p>If TRUE, SNVCs are assumed on x. Otherwise, SVCs are assumed. Default is FALSE</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_xconst_nvc">xconst_nvc</code></td>
<td>
<p>If TRUE, NVCs are assumed on xconst. Otherwise, constant coefficients are assumed. Default is FALSE</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_x_sel">x_sel</code></td>
<td>
<p>If TRUE, type of coefficient (SVC or constant) on x is selected through a BIC (default) or AIC minimization. If FALSE, SVCs are assumed across x. Alternatively, x_sel can be given by column number(s) of x. For example, if x_sel = 2, the coefficient on the second explanatory variable in x is SVC and the other coefficients are constants. The Default is TRUE</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_x_nvc_sel">x_nvc_sel</code></td>
<td>
<p>If TRUE, type of coefficient (NVC or constant) on x is selected through the BIC (default) or AIC minimization. If FALSE, NVCs are assumed across x. Alternatively, x_nvc_sel can be given by column number(s) of x. For example, if x_nvc_sel = 2, the coefficient on the second explanatory variable in x is NVC and the other coefficients are constants. The Default is TRUE</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_xconst_nvc_sel">xconst_nvc_sel</code></td>
<td>
<p>If TRUE, type of coefficient (NVC or constant) on xconst is selected through the BIC (default) or AIC minimization. If FALSE, NVCs are assumed across xconst. Alternatively, xconst_nvc_sel can be given by column number(s) of xconst. For example, if xconst_nvc_sel = 2, the coefficient on the second explanatory variable in xconst is NVC and the other coefficients are constants.The Default is TRUE</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_nvc_num">nvc_num</code></td>
<td>
<p>Number of basis functions used to model NVC. An intercept and nvc_num natural spline basis functions are used to model each NVC. Default is 5</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_method">method</code></td>
<td>
<p>Estimation method. Restricted maximum likelihood method (&quot;reml&quot;) and maximum likelihood method (&quot;ml&quot;) are available. Default is &quot;reml&quot;</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_penalty">penalty</code></td>
<td>
<p>Penalty to select type of coefficients (SNVC, SVC, NVC, or constant) to stablize the estimates. The current options are &quot;bic&quot; for the Baysian information criterion-type penalty (N x log(K)) and &quot;aic&quot; for the Akaike information criterion  (2K) (see Muller et al., 2013). Default is &quot;bic&quot;</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. Default is 30</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_tol">tol</code></td>
<td>
<p>The tolerance for matrix inversion. Some errors regarding singular fit can be avoided by reducing the value, but the output can be unstable. Default is 1e-30</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_covmodel">covmodel</code></td>
<td>
<p>Type of kernel to model spatial dependence. The currently available options are &quot;exp&quot; for the exponential kernel, &quot;gau&quot; for the Gaussian kernel, and &quot;sph&quot; for the spherical kernel</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_enum">enum</code></td>
<td>
<p>Number of Moran eigenvectors to be used for spatial process modeling (scalar). Default is 200</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_bsize">bsize</code></td>
<td>
<p>Block/badge size. bsize x bsize elements are iteratively processed during the parallelized computation. Default is 4000</p>
</td></tr>
<tr><td><code id="besf_vc_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for the parallel computation. If ncores = NULL, the number of available cores - 2 is detected and used. Default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b_vc</code></td>
<td>
<p>Matrix of estimated SNVC (= SVC + NVC) on x (N x K)</p>
</td></tr>
<tr><td><code>bse_vc</code></td>
<td>
<p>Matrix of standard errors for the SNVCs on x (N x k)</p>
</td></tr>
<tr><td><code>z_vc</code></td>
<td>
<p>Matrix of z-values for the SNVCs on x (N x K)</p>
</td></tr>
<tr><td><code>p_vc</code></td>
<td>
<p>Matrix of p-values for the SNVCs on x (N x K)</p>
</td></tr>
<tr><td><code>B_vc_s</code></td>
<td>
<p>List summarizing estimated SVCs (in SNVC) on x. The four elements are the SVCs (N x K), the standard errors (N x K), z-values (N x K), and p-values (N x K), respectively</p>
</td></tr>
<tr><td><code>B_vc_n</code></td>
<td>
<p>List summarizing estimated NVCs (in SNVC) on x. The four elements are the NVCs (N x K), the standard errors (N x K), z-values (N x K), and p-values (N x K), respectively</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Matrix with columns for the estimated coefficients on xconst, their standard errors, z-values, and p-values (K_c x 4). Effective if xconst_nvc = FALSE</p>
</td></tr>
<tr><td><code>c_vc</code></td>
<td>
<p>Matrix of estimated NVCs on xconst (N x K_c). Effective if xconst_nvc = TRUE</p>
</td></tr>
<tr><td><code>cse_vc</code></td>
<td>
<p>Matrix of standard errors for the NVCs on xconst (N x K_c). Effective if xconst_nvc = TRUE</p>
</td></tr>
<tr><td><code>cz_vc</code></td>
<td>
<p>Matrix of z-values for the NVCs on xconst (N x K_c). Effective if xconst_nvc = TRUE</p>
</td></tr>
<tr><td><code>cp_vc</code></td>
<td>
<p>Matrix of p-values for the NVCs on xconst (N x K_c). Effective if xconst_nvc = TRUE</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>List of variance parameters in the SNVC (SVC + NVC) on x. The first element is a 2 x K matrix summarizing variance parameters for SVC. The (1, k)-th element is the standard deviation of the k-th SVC, while the (2, k)-th element is the Moran's I value that is scaled to take a value between 0 (no spatial dependence) and 1 (strongest spatial dependence). Based on Griffith (2003), the scaled Moran'I value is interpretable as follows: 0.25-0.50:weak; 0.50-0.70:moderate; 0.70-0.90:strong; 0.90-1.00:marked. The second element of s is the vector of standard deviations of the NVCs</p>
</td></tr>
<tr><td><code>s_c</code></td>
<td>
<p>Vector of standard deviations of the NVCs on xconst</p>
</td></tr>
<tr><td><code>vc</code></td>
<td>
<p>List indicating whether SVC/NVC are removed or not during the BIC/AIC minimization. 1 indicates not removed (replaced with constant) whreas 0 indicates removed</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Vector whose elements are residual standard error (resid_SE), adjusted conditional R2 (adjR2(cond)), restricted log-likelihood (rlogLik), Akaike information criterion (AIC), and Bayesian information criterion (BIC). When method = &quot;ml&quot;, restricted log-likelihood (rlogLik) is replaced with log-likelihood (logLik)</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Vector of predicted values (N x 1)</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Vector of residuals (N x 1)</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Muller, S., Scealy, J.L., and Welsh, A.H. (2013) Model selection in linear mixed models. Statistical Science, 28 (2), 136-167.
</p>
<p>Murakami, D., Yoshida, T., Seya, H., Griffith, D.A., and Yamagata, Y. (2017) A Moran coefficient-based mixed effects approach to investigate spatially varying relationships. Spatial Statistics, 19, 68-89.
</p>
<p>Murakami, D., and Griffith, D.A. (2019). Spatially varying coefficient modeling for large datasets: Eliminating N from spatial regressions. Spatial Statistics, 30, 39-64.
</p>
<p>Murakami, D. and Griffith, D.A. (2019) A memory-free spatial additive mixed modeling for big spatial data. Japan Journal of Statistics and Data Science. DOI:10.1007/s42081-019-00063-x.
</p>
<p>Murakami, D., and Griffith, D.A. (2020) Balancing spatial and non-spatial variations in varying coefficient modeling: a remedy for spurious correlation. ArXiv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resf_vc">resf_vc</a></code>, <code><a href="#topic+addlearn_local">addlearn_local</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spdep)
data(boston)
y	      &lt;- boston.c[, "CMEDV"]
x       &lt;- boston.c[,c("CRIM", "AGE")]
xconst  &lt;- boston.c[,c("ZN","DIS","RAD","NOX",  "TAX","RM", "PTRATIO", "B")]
xgroup  &lt;- boston.c[,"TOWN"]
coords  &lt;- boston.c[,c("LON", "LAT")]

############## SVC modeling1 #################
######## (SVC on x; Constant coefficients on xconst)
#res	    &lt;- besf_vc(y=y,x=x,xconst=xconst,coords=coords, x_sel = FALSE )
#res
#plot_s(res,0) # Spatially varying intercept
#plot_s(res,1) # 1st SVC
#plot_s(res,2) # 2nd SVC
#
######## For large samples (n &gt; 5,000), the following additional learning
######## mitigates an degeneracy/over-smoothing problem in SVCs
#res1     &lt;- addlearn_local(res)
#res1
#plot_s(res1,0) # Spatially varying intercept
#plot_s(res1,1) # 1st SVC
#plot_s(res1,2) # 2nd SVC


############## SVC modeling2 #################
######## (SVC or constant coefficients on x; Constant coefficients on xconst)
#res2	  &lt;- besf_vc(y=y,x=x,xconst=xconst,coords=coords )

############## SVC modeling3 #################
######## - Group-level SVC or constant coefficients on x
######## - Constant coefficients on xconst
#res3	  &lt;- besf_vc(y=y,x=x,xconst=xconst,coords=coords, s_id=xgroup)

############## SNVC modeling1 #################
######## - SNVC, SVC, NVC, or constant coefficients on x
######## - Constant coefficients on xconst

#res4	  &lt;- besf_vc(y=y,x=x,xconst=xconst,coords=coords, x_nvc =TRUE)

############## SNVC modeling2 #################
######## - SNVC, SVC, NVC, or constant coefficients on x
######## - NVC or Constant coefficients on xconst

#res5	  &lt;- besf_vc(y=y,x=x,xconst=xconst,coords=coords, x_nvc =TRUE, xconst_nvc=TRUE)
#plot_s(res5,0)            # Spatially varying intercept
#plot_s(res5,1)            # 1st SNVC (SVC + NVC)
#plot_s(res5,1,btype="svc")# SVC in the 1st SNVC
#plot_n(res5,1,xtype="x")  # NVC in the 1st NVC on x
#plot_n(res5,6,xtype="xconst")# NVC in the 6t NVC on xcnost


</code></pre>

<hr>
<h2 id='coef_marginal'>Marginal effects evaluation</h2><span id='topic+coef_marginal'></span>

<h3>Description</h3>

<p>This function evaluates the marginal effects from x (dy/dx) based on the estimation result of <code><a href="#topic+resf">resf</a></code>. This funtion is for non-Gaussian models transforming y using <code><a href="#topic+nongauss_y">nongauss_y</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_marginal( mod )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_marginal_+3A_mod">mod</code></td>
<td>
<p>Output from <code><a href="#topic+resf">resf</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>Marginal effects from x (dy/dx)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+resf">resf</a></code>
</p>

<hr>
<h2 id='coef_marginal_vc'>Marginal effects evaluation from models with varying coefficients</h2><span id='topic+coef_marginal_vc'></span>

<h3>Description</h3>

<p>This function evaluates the marginal effects from x (dy/dx) based on the estimation result of <code><a href="#topic+resf_vc">resf_vc</a></code>. This funtion is for non-Gaussian models transforming y using <code><a href="#topic+nongauss_y">nongauss_y</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_marginal_vc( mod )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_marginal_vc_+3A_mod">mod</code></td>
<td>
<p>Output from <code><a href="#topic+resf_vc">resf_vc</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b_vc</code></td>
<td>
<p>Matrix of the marginal effects of x (dy/dx) (N x K)</p>
</td></tr>
<tr><td><code>B_vc_n</code></td>
<td>
<p>Matrix of the sub-marginal effects of x explained by the spatially varying coefficients (N x K)</p>
</td></tr>
<tr><td><code>B_vc_s</code></td>
<td>
<p>Matrix of the sub-marginal effects explained by the non-spatially varying coefficients (N x K)</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Matrix of the marginal effects of xconst (N x K_const)</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+resf_vc">resf_vc</a></code>
</p>

<hr>
<h2 id='esf'>Spatial regression with eigenvector spatial filtering</h2><span id='topic+esf'></span>

<h3>Description</h3>

<p>This function estimates the linear eigenvector spatial filtering (ESF) model. The eigenvectors are selected by a forward stepwise method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esf( y, x = NULL, vif = NULL, meig, fn = "r2" )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="esf_+3A_y">y</code></td>
<td>
<p>Vector of explained variables (N x 1)</p>
</td></tr>
<tr><td><code id="esf_+3A_x">x</code></td>
<td>
<p>Matrix of explanatory variables (N x K). Default is NULL</p>
</td></tr>
<tr><td><code id="esf_+3A_vif">vif</code></td>
<td>
<p>Maximum acceptable value of the variance inflation factor (VIF) (scalar). For example, if vif = 10, eigenvectors are selected so that the maximum VIF value among explanatory variables and eigenvectors is equal to or less than 10. Default is NULL</p>
</td></tr>
<tr><td><code id="esf_+3A_meig">meig</code></td>
<td>
<p>Moran eigenvectors and eigenvalues. Output from <code><a href="#topic+meigen">meigen</a></code> or <code><a href="#topic+meigen_f">meigen_f</a></code></p>
</td></tr>
<tr><td><code id="esf_+3A_fn">fn</code></td>
<td>
<p>Objective function for the stepwise eigenvector selection. The adjusted R2 (&quot;r2&quot;), AIC (&quot;aic&quot;), or BIC (&quot;bic&quot;) are available. Alternatively, all the eigenvectors in meig are used without the stepwise selection if fn = &quot;all&quot;. This is acceptable for large samples (see Murakami and Griffith, 2019). Default is &quot;r2&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>Matrix with columns for the estimated coefficients on x, their standard errors, t-values, and p-values (K x 4)</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Vector of statistics for the estimated spatial component (2 x 1). The first element is the standard deviation and the second element is the Moran's I value of the estimated spatially dependent component. The Moran's I value is scaled to take a value between 0 (no spatial dependence) and 1 (the maximum possible spatial dependence). Based on Griffith (2003), the scaled Moran'I value is interpretable as follows: 0.25-0.50:weak; 0.50-0.70:moderate; 0.70-0.90:strong; 0.90-1.00:marked</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Matrix with columns for the estimated coefficients on Moran's eigenvectors, their standard errors, t-values, and p-values (L x 4)</p>
</td></tr>
<tr><td><code>vif</code></td>
<td>
<p>Vector of variance inflation factors of the explanatory variables (N x 1)</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Vector whose elements are residual standard error (resid_SE), adjusted R2 (adjR2), log-likelihood (logLik), AIC, and BIC</p>
</td></tr>
<tr><td><code>sf</code></td>
<td>
<p>Vector of estimated spatial dependent component (E<code class="reqn">\gamma</code>) (N x 1)</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Vector of predicted values (N x 1)</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Vector of residuals (N x 1)</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Griffith, D. A. (2003). Spatial autocorrelation and spatial filtering: gaining understanding through theory and scientific visualization. Springer Science &amp; Business Media.
</p>
<p>Tiefelsdorf, M., and Griffith, D. A. (2007). Semiparametric filtering of spatial autocorrelation: the eigenvector approach. Environment and Planning A, 39 (5), 1193-1221.
</p>
<p>Murakami, D. and Griffith, D.A. (2019) Eigenvector spatial filtering for large data sets: fixed and random effects approaches. Geographical Analysis, 51 (1), 23-49.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resf">resf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spdep)
data(boston)
y	&lt;- boston.c[, "CMEDV" ]
x	&lt;- boston.c[,c("CRIM","ZN","INDUS", "CHAS", "NOX","RM", "AGE")]
coords  &lt;- boston.c[,c("LON", "LAT")]

#########Distance-based ESF
meig 	&lt;- meigen(coords=coords)
esfD	&lt;- esf(y=y,x=x,meig=meig, vif=5)
esfD

#########Fast approximation
meig_f&lt;- meigen_f(coords=coords)
esfD	&lt;- esf(y=y,x=x,meig=meig_f, vif=10, fn="all")
esfD

############################Not run
#########Topoligy-based ESF (it is commonly used in regional science)
#
#cknn	&lt;- knearneigh(coordinates(coords), k=4) #4-nearest neighbors
#cmat	&lt;- nb2mat(knn2nb(cknn), style="B")
#meig &lt;- meigen(cmat=cmat, threshold=0.25)
#esfT	&lt;- esf(y=y,x=x,meig=meig)
#esfT
</code></pre>

<hr>
<h2 id='lsem'>Low rank spatial error model (LSEM) estimation</h2><span id='topic+lsem'></span>

<h3>Description</h3>

<p>This function estimates the low rank spatial error model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsem( y, x, weig, method = "reml" )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lsem_+3A_y">y</code></td>
<td>
<p>Vector of explained variables (N x 1)</p>
</td></tr>
<tr><td><code id="lsem_+3A_x">x</code></td>
<td>
<p>Matrix of explanatory variables (N x K)</p>
</td></tr>
<tr><td><code id="lsem_+3A_weig">weig</code></td>
<td>
<p>eigenvectors and eigenvalues of a spatial weight matrix. Output from <code><a href="#topic+weigen">weigen</a></code></p>
</td></tr>
<tr><td><code id="lsem_+3A_method">method</code></td>
<td>
<p>Estimation method. Restricted maximum likelihood method (&quot;reml&quot;) and maximum likelihood method (&quot;ml&quot;) are available. Default is &quot;reml&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>Matrix with columns for the estimated coefficients on x, their standard errors, t-values, and p-values (K x 4)</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Vector of estimated variance parameters (2 x 1). The first and the second elements denote the estimated rho parameter (sp_lambda) quantfying the scale of spatial dependent process, and the standard error of the process (sp_SE), respectively.</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Vector whose elements are residual standard error (resid_SE), adjusted conditional R2 (adjR2(cond)), restricted log-likelihood (rlogLik), Akaike information criterion (AIC), and Bayesian information criterion (BIC). When method = &quot;ml&quot;, restricted log-likelihood (rlogLik) is replaced with log-likelihood (logLik)</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Vector of estimated random coefficients on the spatial eigenvectors (L x 1)</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Vector of predicted values (N x 1)</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Vector of residuals (N x 1)</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Murakami, D., Seya, H. and Griffith, D.A. (2018) Low rank spatial econometric models. Arxiv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meigen">meigen</a></code>, <code><a href="#topic+meigen_f">meigen_f</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spdep)
data(boston)
y	&lt;- boston.c[, "CMEDV" ]
x	&lt;- boston.c[,c("CRIM","ZN","INDUS", "CHAS", "NOX","RM", "AGE",
                       "DIS" ,"RAD", "TAX", "PTRATIO", "B", "LSTAT")]
coords&lt;- boston.c[,c("LON", "LAT")]
weig 	&lt;- weigen( coords )
res	  &lt;- lsem(y=y,x=x,weig=weig)
res
</code></pre>

<hr>
<h2 id='lslm'>Low rank spatial lag model (LSLM) estimation</h2><span id='topic+lslm'></span>

<h3>Description</h3>

<p>This function estimates the low rank spatial lag model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lslm( y, x, weig, method = "reml", boot = FALSE, iter = 200 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lslm_+3A_y">y</code></td>
<td>
<p>Vector of explained variables (N x 1)</p>
</td></tr>
<tr><td><code id="lslm_+3A_x">x</code></td>
<td>
<p>Matrix of explanatory variables (N x K)</p>
</td></tr>
<tr><td><code id="lslm_+3A_weig">weig</code></td>
<td>
<p>eigenvectors and eigenvalues of a spatial weight matrix. Output from <code><a href="#topic+weigen">weigen</a></code></p>
</td></tr>
<tr><td><code id="lslm_+3A_method">method</code></td>
<td>
<p>Estimation method. Restricted maximum likelihood method (&quot;reml&quot;) and maximum likelihood method (&quot;ml&quot;) are available. Default is &quot;reml&quot;</p>
</td></tr>
<tr><td><code id="lslm_+3A_boot">boot</code></td>
<td>
<p>If it is TRUE, confidence intervals for the spatial dependence parameters (s), the mean direct effects (de), and the mean indirect effects (ie), are estimated through a parametric bootstrapping. Default is FALSE</p>
</td></tr>
<tr><td><code id="lslm_+3A_iter">iter</code></td>
<td>
<p>The number of bootstrap replicates. Default is 200</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>Matrix with columns for the estimated coefficients on x, their standard errors, t-values, and p-values (K x 4)</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Vector of estimated shrinkage parameters (2 x 1). The first and the second elements denote the estimated rho parameter (sp_rho) quantfying the scale of spatial dependence, and the standard error of the spatial dependent component (sp_SE), respectively. If boot = TRUE, their 95 percent confidence intervals and the resulting p-values are also provided</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Vector whose elements are residual standard error (resid_SE), adjusted conditional R2 (adjR2(cond)), restricted log-likelihood (rlogLik), Akaike information criterion (AIC), and Bayesian information criterion (BIC). When method = &quot;ml&quot;, restricted log-likelihood (rlogLik) is replaced with log-likelihood (logLik)</p>
</td></tr>
<tr><td><code>de</code></td>
<td>
<p>Matrix with columns for the estimated mean direct effects on x. If boot = TRUE, their 95 percent confidence intervals and the resulting p-values are also provided</p>
</td></tr>
<tr><td><code>ie</code></td>
<td>
<p>Matrix with columns for the estimated mean indirect effects on x. If boot = TRUE, their 95 percent confidence intervals and the resulting p-values are also provided</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Vector of estimated random coefficients on the spatial eigenvectors (L x 1)</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Vector of predicted values (N x 1)</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Vector of residuals (N x 1)</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Murakami, D., Seya, H. and Griffith, D.A. (2018) Low rank spatial econometric models. Arxiv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weigen">weigen</a></code>, <code><a href="#topic+lsem">lsem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spdep)
data(boston)
y	&lt;- boston.c[, "CMEDV" ]
x	&lt;- boston.c[,c("CRIM","ZN","INDUS", "CHAS", "NOX","RM", "AGE",
                       "DIS" ,"RAD", "TAX", "PTRATIO", "B", "LSTAT")]
coords  &lt;- boston.c[,c("LON", "LAT")]
weig 	  &lt;- weigen(coords)
res	    &lt;- lslm(y=y,x=x,weig=weig)
## res  &lt;- lslm(y=y,x=x,weig=weig, boot=TRUE)
res

</code></pre>

<hr>
<h2 id='meigen'>Extraction of Moran eigenvectors</h2><span id='topic+meigen'></span>

<h3>Description</h3>

<p>This function extracts spatial and temporal eigenvectors (i.e., basis functions describing spatial and temporal patterns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meigen( coords = NULL,model = "exp", enum = NULL, s_id = NULL,
        threshold = 0, cmat = NULL, coords_z=NULL, enum_z=NULL,
        interact=TRUE, interact_max_dim = 600  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meigen_+3A_coords">coords</code></td>
<td>
<p>Matrix of spatial coordinates (N x 2). If cmat is specified, it is ignored</p>
</td></tr>
<tr><td><code id="meigen_+3A_model">model</code></td>
<td>
<p>Type of kernel to model spatial dependence. The currently available options are &quot;exp&quot; for the exponential kernel, &quot;gau&quot; for the Gaussian kernel, and &quot;sph&quot; for the spherical kernel. Default is &quot;exp&quot;</p>
</td></tr>
<tr><td><code id="meigen_+3A_enum">enum</code></td>
<td>
<p>Optional. The maximum mumber of spatial eigenvectors to be extracted (scalar)</p>
</td></tr>
<tr><td><code id="meigen_+3A_s_id">s_id</code></td>
<td>
<p>Optional. Location/zone ID for modeling inter-group spatial effects. If specified, Moran eigenvectors are extracted by groups. It is useful e.g. for multilevel modeling (s_id is the groups) and panel data modeling (s_id is given by individual location id). Default is NULL</p>
</td></tr>
<tr><td><code id="meigen_+3A_threshold">threshold</code></td>
<td>
<p>Optional. Threshold for the eigenvalues. Suppose that lambda_1 is the maximum eigenvalue, this function extracts eigenvectors whose corresponding eigenvalue is equal or greater than (threshold x lambda_1). threshold must be a value between 0 and 1. Default is zero (see Details)</p>
</td></tr>
<tr><td><code id="meigen_+3A_cmat">cmat</code></td>
<td>
<p>Optional. A user-specified spatial connectivity matrix (N x N). It must be provided when the user wants to use a spatial connectivity matrix other than the default matrices</p>
</td></tr>
<tr><td><code id="meigen_+3A_coords_z">coords_z</code></td>
<td>
<p>Optional. One- or two-column matrix whose t-th column represents t-th temporal coordinate (N x 1 or N x 2).</p>
</td></tr>
<tr><td><code id="meigen_+3A_enum_z">enum_z</code></td>
<td>
<p>Optional. The maximum mumber of temporal eigenvectors to be extracted (scalar)</p>
</td></tr>
<tr><td><code id="meigen_+3A_interact">interact</code></td>
<td>
<p>Optional. If TRUE, space-time eigenvectors (space x time) are considered in addition to spatial eigenvectors and temporal eigenvectors</p>
</td></tr>
<tr><td><code id="meigen_+3A_interact_max_dim">interact_max_dim</code></td>
<td>
<p>Optional. The maximum mumber of the space-time eigenvectors to be extracted (scalar)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts spatial eigenvectors from MCM, where M = I - 11'/N is a centering operator. By default, C is a N x N connectivity matrix whose (i, j)-th element equals exp(-d(i,j)/h), where d(i,j) is the spatial Euclidean distance between the sample sites i and j. h is the maximum length of the minimum spanning tree connecting sample sites (see Dray et al., 2006). If cmat is provided, this function performs the same calculation after C is replaced with cmat.
</p>
<p>The temporal eigenvectors are extracted in the same way where the spatial distance d(i,j) is replaced with temporal difference. If two temporal coordinates are given, their eigenvectors are evaluated respectively.
</p>
<p>If threshold = 0.00 (default), all the eigenvectors corresponding to positive eigenvalues explaining positive spatial/temporal dependence are extracted. threshold = 0.00 or 0.25 are standard assumptions (see Griffith, 2003; Murakami and Griffith, 2015).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sf</code></td>
<td>
<p>Matrix of the spatial eigenvectors (N x L)</p>
</td></tr>
<tr><td><code>ev</code></td>
<td>
<p>Vector of the spatial eigenvalues (L x 1), scaled to have the maximum value of 1</p>
</td></tr>
<tr><td><code>sf_z</code></td>
<td>
<p>List. t-th element is the matrix of the t-th temporal eigenvectors (N x L_t)</p>
</td></tr>
<tr><td><code>ev_z</code></td>
<td>
<p>List. t-th element is the vector of the t-th temporal eigenvalues (L_t x 1), scaled to have the maximum value of 1</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outcomes, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Dray, S., Legendre, P., and Peres-Neto, P.R. (2006) Spatial modelling: a comprehensive framework for principal coordinate analysis of neighbour matrices (PCNM). Ecological Modelling, 196 (3), 483-493.
</p>
<p>Griffith, D.A. (2003) Spatial autocorrelation and spatial filtering: gaining understanding through theory and scientific visualization. Springer Science &amp; Business Media.
</p>
<p>Murakami, D. and Griffith, D.A. (2015) Random effects specifications in eigenvector spatial filtering: a simulation study. Journal of Geographical Systems, 17 (4), 311-331.
</p>
<p>Murakami, D., Shirota, S., Kajita, S., and Kajita, S. (2024) Fast spatio-temporally varying coefficient modeling with reluctant interaction selection. ArXiv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meigen_f">meigen_f</a></code> for fast eigen-decomposition
</p>

<hr>
<h2 id='meigen_f'>Fast approximation of Moran eigenvectors</h2><span id='topic+meigen_f'></span>

<h3>Description</h3>

<p>This function approximates spatial and temporal eigenvectors (i.e., basis functions describing spatial and temporal patterns) computationally efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meigen_f( coords, model = "exp", enum = 200, s_id = NULL, threshold = 0,
          coords_z = NULL, enum_z = 200, interact = TRUE,
          interact_max_dim = 600 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meigen_f_+3A_coords">coords</code></td>
<td>
<p>Matrix of spatial coordinates (N x 2)</p>
</td></tr>
<tr><td><code id="meigen_f_+3A_model">model</code></td>
<td>
<p>Type of kernel to model spatial dependence. The currently available options are &quot;exp&quot; for the exponential kernel, &quot;gau&quot; for the Gaussian kernel, and &quot;sph&quot; for the spherical kernel. Default is &quot;exp&quot;</p>
</td></tr>
<tr><td><code id="meigen_f_+3A_enum">enum</code></td>
<td>
<p>Number of eigenvectors and eigenvalues to be extracted (scalar). Default is 200</p>
</td></tr>
<tr><td><code id="meigen_f_+3A_s_id">s_id</code></td>
<td>
<p>Optional. Location/zone ID for modeling inter-group spatial effects. If specified, Moran eigenvectors are extracted by groups. It is useful e.g. for multilevel modeling (s_id is the groups) and panel data modeling (s_id is given by individual location id). Default is NULL</p>
</td></tr>
<tr><td><code id="meigen_f_+3A_threshold">threshold</code></td>
<td>
<p>Optional. Threshold for the eigenvalues. Suppose that lambda_1 is the maximum eigenvalue, this function extracts eigenvectors whose corresponding eigenvalue is equal or greater than (threshold x lambda_1). threshold must be a value between 0 and 1. Default is zero</p>
</td></tr>
<tr><td><code id="meigen_f_+3A_coords_z">coords_z</code></td>
<td>
<p>Optional. One- or two-column matrix of temporal coordinates (N x 1 or N x 2).</p>
</td></tr>
<tr><td><code id="meigen_f_+3A_enum_z">enum_z</code></td>
<td>
<p>Optional. The maximum mumber of temporal eigenvectors to be extracted (scalar)</p>
</td></tr>
<tr><td><code id="meigen_f_+3A_interact">interact</code></td>
<td>
<p>Optional. If TRUE, space-time eigenvectors (space x time) are considered in addition to spatial eigenvectors and temporal eigenvectors</p>
</td></tr>
<tr><td><code id="meigen_f_+3A_interact_max_dim">interact_max_dim</code></td>
<td>
<p>Optional. The maximum mumber of the space-time eigenvectors to be extracted (scalar)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts approximated spatial eigenvectors from MCM. M = I - 11'/N is a centering operator, and C is a spatial connectivity matrix whose (i, j)-th element is given by exp( -d(i,j)/h), where d(i,j) is the Euclidean distance between the sample sites i and j, and h is a range parameter given by the maximum length of the minimum spanning tree connecting sample sites (see Dray et al., 2006). Following a simulation result in Murakami and Griffith (2019), this function approximates the 200 eigenvectors corresponding to the 200 largest eigenvalues by default (i.e., enum = 200). If enum is given by a smaller value like 100, the computation time will be shorter, but with greater approximation error.
</p>
<p>The temporal eigenvectors are extracted in the same way where the spatial distance d(i,j) is replaced with temporal difference. If two temporal coordinates are given, their eigenvectors are evaluated respectively.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sf</code></td>
<td>
<p>Matrix of the spatial eigenvectors (N x L)</p>
</td></tr>
<tr><td><code>ev</code></td>
<td>
<p>Vector of the spatial eigenvalues (L x 1), scaled to have the maximum value of 1</p>
</td></tr>
<tr><td><code>sf_z</code></td>
<td>
<p>List. t-th element is the matrix of the t-th temporal eigenvectors (N x L_t)</p>
</td></tr>
<tr><td><code>ev_z</code></td>
<td>
<p>List. t-th element is the vector of the t-th temporal eigenvalues (L_t x 1), scaled to have the maximum value of 1</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outcomes, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Dray, S., Legendre, P., and Peres-Neto, P.R. (2006) Spatial modelling: a comprehensive framework for principal coordinate analysis of neighbour matrices (PCNM). Ecological Modelling, 196 (3), 483-493.
</p>
<p>Murakami, D. and Griffith, D.A. (2019) Eigenvector spatial filtering for large data sets: fixed and random effects approaches. Geographical Analysis, 51 (1), 23-49.
</p>
<p>Murakami, D., Shirota, S., Kajita, S., and Kajita, S. (2024) Fast spatio-temporally varying coefficient modeling with reluctant interaction selection. ArXiv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meigen">meigen</a></code>
</p>

<hr>
<h2 id='meigen0'>Nystrom extension of Moran eigenvectors</h2><span id='topic+meigen0'></span>

<h3>Description</h3>

<p>This function estimates Moran eigenvectors at unobserved sites using the Nystrom extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meigen0( meig, coords0, coords_z0 = NULL, s_id0 = NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meigen0_+3A_meig">meig</code></td>
<td>
<p>Moran eigenvectors and eigenvalues. Output from <code><a href="#topic+meigen">meigen</a></code> or <code><a href="#topic+meigen_f">meigen_f</a></code></p>
</td></tr>
<tr><td><code id="meigen0_+3A_coords0">coords0</code></td>
<td>
<p>Matrix of spatial point coordinates of prediction sites (N_0 x 2)</p>
</td></tr>
<tr><td><code id="meigen0_+3A_coords_z0">coords_z0</code></td>
<td>
<p>Optional. One- or two-column matrix whose t-th column represents the t-th temporal coordinate of prediction times (N_0 x 1 or N_0 x 2).</p>
</td></tr>
<tr><td><code id="meigen0_+3A_s_id0">s_id0</code></td>
<td>
<p>Optional. ID specifying groups modeling spatial effects (N_0 x 1). If specified, Moran eigenvectors are extracted by groups. It is useful e.g. for multilevel modeling (s_id is the groups) and panel data modeling (s_id is given by individual location id). Default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sf</code></td>
<td>
<p>Matrix of the first L eigenvectors at unobserved sites (N_0 x L)</p>
</td></tr>
<tr><td><code>ev</code></td>
<td>
<p>Vector of the first L eigenvalues (L x 1)</p>
</td></tr>
<tr><td><code>sf_z</code></td>
<td>
<p>List. t-th element is the matrix of the t-th temporal eigenvectors (N x L_t)</p>
</td></tr>
<tr><td><code>ev_z</code></td>
<td>
<p>List. t-th element is the vector of the t-th temporal eigenvalues (L_t x 1)</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Drineas, P. and Mahoney, M.W. (2005) On the Nystrom method for approximating a gram matrix for improved kernel-based learning. Journal of Machine Learning Research, 6 (2005), 2153-2175.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meigen">meigen</a></code>, <code><a href="#topic+meigen_f">meigen_f</a></code>
</p>

<hr>
<h2 id='nongauss_y'>Parameter setup for modeling non-Gaussian continuous data and count data</h2><span id='topic+nongauss_y'></span>

<h3>Description</h3>

<p>Parameter setup for modeling non-Gaussian continuous data and count data. The SAL transformation (see details) is used to model a wide variety of non-Gaussian data without explicitly assuming data distribution (see Murakami et al., 2021 for further detail). In addition, Box-Cox transformation is used for non-negative continuous variables while another transformation approximating overdispersed Poisson distribution is used for count variables. The output from this function is used as an input of the resf and resf_vc functions. For further details about its implementation and case study examples, see Murakami (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nongauss_y( y_type = "continuous", y_nonneg = FALSE, tr_num = 0 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nongauss_y_+3A_y_type">y_type</code></td>
<td>
<p>Type of explained variables y. &quot;continuous&quot; for continuous variables and &quot;count&quot; for count variables</p>
</td></tr>
<tr><td><code id="nongauss_y_+3A_y_nonneg">y_nonneg</code></td>
<td>
<p>Effective if y_type = &quot;continuous&quot;. TRUE if y cannot take negative value. If y_nonneg = TRUE and tr_num = 0, the Box-Cox transformation is applied to y. If y_nonneg = TRUE and tr_num &gt; 0, the Box-Cox transformation is applied first to roughly Gaussianize y. Then, the SAL transformation is iterated tr_num times to improve the modeling accuracy. Default is FALSE</p>
</td></tr>
<tr><td><code id="nongauss_y_+3A_tr_num">tr_num</code></td>
<td>
<p>Number of the SAL transformations (SinhArcsinh and Affine, where the use of &quot;L&quot; stems from the &quot;Linear&quot;) applied to Gaussianize y. Default is 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If tr_num &gt;0, the SAL transformation is iterated tr_num times to Gaussianize y. The SAL transformation is defined as SAL(y)=a+b*sinh(c*arcsinh(y)-d) where a,b,c,d are parameters. Based on Rios and Tobar (2019), the iteration of the SAL transformation approximates a wide variety of non-Gaussian distributions without explicitly assuming data distribution. The resf and resf_vc functions return tr_par, which is a list whose k-th element includes the a,b,c,d parameters used for the k-th SAL transformation.
</p>
<p>In addition, for non-negative y (y_nonneg = TRUE), the Box-Cox transformation is applied prior to the iterative SAL transformation. tr_num and y_nonneg can be selected by comparing the BIC (or AIC) values across models. This compositionally-warped spatial regression approach is detailed in Murakami et al. (2021).
</p>
<p>For count data (y_type = &quot;count&quot;), an overdispersed Poisson distribution (Gaussian approximation) is assumed. If tr_num &gt; 0, the distribution is adjusted to fit the data (y) through the iterative SAL transformations. y_nonneg is ignored if y_type = &quot;count&quot;.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nongauss</code></td>
<td>
<p>List of parameters for modeling non-Gaussian data</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rios, G. and Tobar, F. (2019) Compositionally-warped Gaussian processes. Neural Networks, 118, 235-246.
</p>
<p>Murakami, D. (2021) Transformation-based generalized spatial regression using the spmoran package: Case study examples, ArXiv.
</p>
<p>Murakami, D., Kajita, M., Kajita, S. and Matsui, T. (2021) Compositionally-warped additive mixed modeling for a wide variety of non-Gaussian data. Spatial Statistics, 43, 100520.
</p>
<p>Murakami, D., &amp; Matsui, T. (2021). Improved log-Gaussian approximation for over-dispersed Poisson regression: application to spatial analysis of COVID-19. ArXiv, 2104.13588.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resf">resf</a></code>, <code><a href="#topic+resf_vc">resf_vc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###### Regression for non-negative data (BC trans.)
ng1  &lt;-nongauss_y( y_nonneg = TRUE )
ng1

###### General non-Gaussian regression for continuous data (two SAL trans.)
ng2  &lt;-nongauss_y( tr_num = 2 )
ng2

###### General non-Gaussian regression for non-negative continuous data
ng3  &lt;-nongauss_y( y_nonneg = TRUE, tr_num = 5 )
ng3

###### Over-dispersed Poisson regression for count data
ng4  &lt;-nongauss_y( y_type = "count" )
ng4

###### A general non-Gaussian regression for count data
ng5  &lt;-nongauss_y( y_type = "count", tr_num = 5 )
ng5

############################## Fitting example
require(spdep);require(Matrix)
data(boston)
y	    &lt;- boston.c[, "CMEDV" ]
x	    &lt;- boston.c[,c("CRIM","ZN","INDUS", "CHAS", "NOX","RM", "AGE",
                     "DIS" ,"RAD", "TAX", "PTRATIO", "B", "LSTAT")]
xgroup&lt;- boston.c[,"TOWN"]
coords&lt;- boston.c[,c("LON","LAT")]
meig 	&lt;- meigen(coords=coords)
res	  &lt;- resf(y = y, x = x, meig = meig,nongauss=ng2)
res                    # Estimation results

plot(res$pdf,type="l") # Estimated probability density function
res$skew_kurt          # Skew and kurtosis of the estimated PDF
res$pred_quantile[1:2,]# predicted value by quantile
coef_marginal(res)     # Estimated marginal effects (dy/dx)
</code></pre>

<hr>
<h2 id='plot_n'>Plot non-spatially varying coefficients (NVCs)</h2><span id='topic+plot_n'></span>

<h3>Description</h3>

<p>This function plots non-spatially varying coefficients (NVCs; coefficients varying with respect to explanatory variable value) and their 95 percent confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_n( mod, xnum = 1, xtype = "x", cex.lab = 20,
        cex.axis = 15, lwd = 1.5, ylim = NULL, nmax = 20000 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_n_+3A_mod">mod</code></td>
<td>
<p>Outpot from <code><a href="#topic+resf">resf</a></code>, <code><a href="#topic+besf">besf</a></code>, <code><a href="#topic+resf_vc">resf_vc</a></code>, or  <code><a href="#topic+besf_vc">besf_vc</a></code> function</p>
</td></tr>
<tr><td><code id="plot_n_+3A_xnum">xnum</code></td>
<td>
<p>The NVC on the xnum-th explanatory variable is plotted. Default is 1</p>
</td></tr>
<tr><td><code id="plot_n_+3A_xtype">xtype</code></td>
<td>
<p>Effective for <code><a href="#topic+resf_vc">resf_vc</a></code> and <code><a href="#topic+besf_vc">besf_vc</a></code>.  If &quot;x&quot;, the num-th NVC in the spatially and non-spatially varying coefficients on x is plotted. If &quot;xconst&quot;, the num-th NVC on xconst is plotted. Default is &quot;x&quot;</p>
</td></tr>
<tr><td><code id="plot_n_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The size of the x and y axis labels</p>
</td></tr>
<tr><td><code id="plot_n_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The size of the tick label numbers</p>
</td></tr>
<tr><td><code id="plot_n_+3A_lwd">lwd</code></td>
<td>
<p>The width of the line drawing the coefficient estimates</p>
</td></tr>
<tr><td><code id="plot_n_+3A_ylim">ylim</code></td>
<td>
<p>The limints of the y-axis</p>
</td></tr>
<tr><td><code id="plot_n_+3A_nmax">nmax</code></td>
<td>
<p>If sample size exceeds nmax, nmax samples are randomly selected and plotted. Default is 20,000</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+resf">resf</a></code>, <code><a href="#topic+besf">besf</a></code>, <code><a href="#topic+resf_vc">resf_vc</a></code>, <code><a href="#topic+besf_vc">besf_vc</a></code>
</p>

<hr>
<h2 id='plot_qr'>Plot quantile regression coefficients estimated from SF-UQR</h2><span id='topic+plot_qr'></span>

<h3>Description</h3>

<p>This function plots regression coefficients estimated from the spatial filter unconditional quantile regression (SF-UQR) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_qr( mod, pnum = 1, par = "b", cex.main = 20, cex.lab = 18, cex.axis = 15, lwd = 1.5 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_qr_+3A_mod">mod</code></td>
<td>
<p>Outpot from the <code><a href="#topic+resf_qr">resf_qr</a></code> function</p>
</td></tr>
<tr><td><code id="plot_qr_+3A_pnum">pnum</code></td>
<td>
<p>A number specifying the parameter being plotted. If par = &quot;b&quot;, the coefficients on the pnum-th explanatory variable are plotted (intercepts are plotted if pnum = 1). If par = &quot;s&quot; and pnum = 1, the estimated standard errors for the reidual spatial process are plotted. If par = &quot;s&quot; and pnum = 2, the Moran's I values of the residual spatial process are plotted. The Moran's I value is scaled to take a value between 0 (no spatial dependence) and 1 (the maximum possible spatial dependence). Based on Griffith (2003), the scaled Moran'I value is interpretable as follows: 0.25-0.50:weak; 0.50-0.70:moderate; 0.70-0.90:strong; 0.90-1.00:marked</p>
</td></tr>
<tr><td><code id="plot_qr_+3A_par">par</code></td>
<td>
<p>If it is &quot;b&quot;, regression coefficeints are plotted. If it is &quot;s&quot;, shrinkage (variance) parameters for the residual spatial process are plotted. Default is &quot;b&quot;</p>
</td></tr>
<tr><td><code id="plot_qr_+3A_cex.main">cex.main</code></td>
<td>
<p>Graphical parameter specifying the size of the main title</p>
</td></tr>
<tr><td><code id="plot_qr_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Graphical parameter specifying the size of the x and y axis labels</p>
</td></tr>
<tr><td><code id="plot_qr_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Graphical parameter specifying the size of the tick label numbers</p>
</td></tr>
<tr><td><code id="plot_qr_+3A_lwd">lwd</code></td>
<td>
<p>Graphical parameters specifying the width of the line drawing the coefficient estimates</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See <code><a href="graphics.html#topic+par">par</a></code> for the graphical parameters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resf_qr">resf_qr</a></code>
</p>

<hr>
<h2 id='plot_s'>Mapping spatially and spatio-temporally varying coefficients</h2><span id='topic+plot_s'></span>

<h3>Description</h3>

<p>This function plots spatially varying coefficients (SVC) and spatio-temporally varying coefficients (STVC) with/without coefficient varying with respect to the value of the explanatory variable (NVC). Namely, the full varying coefficient equals STVC + NVC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_s( mod, xnum = 0, btype = "all", xtype = "x", pmax = NULL, ncol = 8,
        col = NULL, inv =FALSE, brks = "regular", cex = 1, pch = 20,
        nmax = 20000, coords_z1_lim=NULL, coords_z2_lim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_s_+3A_mod">mod</code></td>
<td>
<p>Outpot from <code><a href="#topic+resf">resf</a></code>, <code><a href="#topic+besf">besf</a></code>, <code><a href="#topic+resf_vc">resf_vc</a></code>, <code><a href="#topic+besf_vc">besf_vc</a></code>, or <code><a href="#topic+addlearn_local">addlearn_local</a></code> function</p>
</td></tr>
<tr><td><code id="plot_s_+3A_xnum">xnum</code></td>
<td>
<p>For <code><a href="#topic+resf_vc">resf_vc</a></code>, <code><a href="#topic+besf_vc">besf_vc</a></code>, and  <code><a href="#topic+addlearn_local">addlearn_local</a></code>, xnum-th SVC/STVC is plotted. If num = 0, varying intercept is plotted. For <code><a href="#topic+resf">resf</a></code> and <code><a href="#topic+besf">besf</a></code>, estimated spatially dependent residual process is plotted irrespective of the xnum value. Default is 0</p>
</td></tr>
<tr><td><code id="plot_s_+3A_btype">btype</code></td>
<td>
<p>Effective if x_nvc =TRUE in <code><a href="#topic+resf_vc">resf_vc</a></code> and <code><a href="#topic+besf_vc">besf_vc</a></code>. If &quot;all&quot; (default), the estiamted varying coefficients (S(T)VC + NVC) are plotted as they are. If &quot;svc&quot;, S(T)VC is plotted. If &quot;nvc&quot;, NVC is plotted.</p>
</td></tr>
<tr><td><code id="plot_s_+3A_xtype">xtype</code></td>
<td>
<p>If &quot;x&quot; (default), coefficients on x is plotted. If &quot;xconst&quot;, those on xconst is plotted</p>
</td></tr>
<tr><td><code id="plot_s_+3A_pmax">pmax</code></td>
<td>
<p>The maximum p-value for the varying coefficients to be displayed. For example, if pmax = 0.05, the only coefficients that are statistically significant at the 5 percent level are plotted. If NULL, all the coefficients are plotted. Default is NULL</p>
</td></tr>
<tr><td><code id="plot_s_+3A_ncol">ncol</code></td>
<td>
<p>Number of colors in the color palette. Default is 8</p>
</td></tr>
<tr><td><code id="plot_s_+3A_col">col</code></td>
<td>
<p>Color palette used for the mapping. If NULL, the blue-pink-yellow color scheme is used. Palettes in the RColorBrewer package are available. Default is NULL</p>
</td></tr>
<tr><td><code id="plot_s_+3A_inv">inv</code></td>
<td>
<p>If TRUE, the color palett is inverted. Default is FALSE</p>
</td></tr>
<tr><td><code id="plot_s_+3A_brks">brks</code></td>
<td>
<p>If &quot;regular&quot;, color is changed at regular intervals. If &quot;quantile&quot;, color is changed for each quantile</p>
</td></tr>
<tr><td><code id="plot_s_+3A_cex">cex</code></td>
<td>
<p>Size of the dots representing sample sites</p>
</td></tr>
<tr><td><code id="plot_s_+3A_pch">pch</code></td>
<td>
<p>A number indicating the symbol to use</p>
</td></tr>
<tr><td><code id="plot_s_+3A_nmax">nmax</code></td>
<td>
<p>If sample size exceeds nmax, nmax samples are randomly selected and plotted. Default is 20,000</p>
</td></tr>
<tr><td><code id="plot_s_+3A_coords_z1_lim">coords_z1_lim</code></td>
<td>
<p>Value range for coords_z[,1] in the <code><a href="#topic+meigen">meigen</a></code>/<code><a href="#topic+meigen_f">meigen_f</a></code> function (vector). If is has two elements, the samples whose coords_z[,1] values are in between these values are plotted. If it is a scalar, samples satisfying coords_z[,1]==coords_z1_lim is plotted</p>
</td></tr>
<tr><td><code id="plot_s_+3A_coords_z2_lim">coords_z2_lim</code></td>
<td>
<p>Value range for coords_z[,2] (vector).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+resf">resf</a></code>, <code><a href="#topic+besf">besf</a></code>, <code><a href="#topic+resf_vc">resf_vc</a></code>, <code><a href="#topic+besf_vc">besf_vc</a></code>, <code><a href="#topic+addlearn_local">addlearn_local</a></code>
</p>

<hr>
<h2 id='predict0'>Spatial and spatio-temporal predictions</h2><span id='topic+predict0'></span>

<h3>Description</h3>

<p>It is a function for spatial/spatio-temporal pprediction using the model estimated from <code><a href="#topic+esf">esf</a></code>, <code><a href="#topic+resf">resf</a></code>, or <code><a href="#topic+resf_vc">resf_vc</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict0( mod, meig0, x0 = NULL, xconst0 = NULL, xgroup0 = NULL, offset0 = NULL,
weight0 = NULL, compute_se=FALSE, compute_quantile = FALSE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict0_+3A_mod">mod</code></td>
<td>
<p>Output from <code><a href="#topic+esf">esf</a></code> <code><a href="#topic+resf">resf</a></code></p>
</td></tr></table>
<p>, or <code><a href="#topic+resf_vc">resf_vc</a></code>
</p>
<table role = "presentation">
<tr><td><code id="predict0_+3A_meig0">meig0</code></td>
<td>
<p>Moran eigenvectors at prediction sites. Output from <code><a href="#topic+meigen0">meigen0</a></code></p>
</td></tr>
<tr><td><code id="predict0_+3A_x0">x0</code></td>
<td>
<p>Matrix of explanatory variables at prediction sites (N_0 x K). Each column of x0 must correspond to those in x in the input model (mod). Default is NULL</p>
</td></tr>
<tr><td><code id="predict0_+3A_xconst0">xconst0</code></td>
<td>
<p>Effective for <code><a href="#topic+resf_vc">resf_vc</a></code>. Matrix of explanatory variables at prediction sites whose coefficients are assumed constant across space (N_0 x K_const). Each column of xconst0 must correspond to those in xconst in the input model. Default is NULL</p>
</td></tr>
<tr><td><code id="predict0_+3A_xgroup0">xgroup0</code></td>
<td>
<p>Matrix/vector of group IDs at prediction sites that may be integer or name by group (N_0 x K_g). Default is NULL</p>
</td></tr>
<tr><td><code id="predict0_+3A_offset0">offset0</code></td>
<td>
<p>Vector of offset variables at prediction sites (N_0 x 1). Effective if y is count (see <code><a href="#topic+nongauss_y">nongauss_y</a></code>). Default is NULL</p>
</td></tr>
<tr><td><code id="predict0_+3A_weight0">weight0</code></td>
<td>
<p>Vector of weights for prediction sites (N_0 x 1). Required if compute_se = TRUE or compute_quantile = TRUE, and weight in the input model is not NULL</p>
</td></tr>
<tr><td><code id="predict0_+3A_compute_se">compute_se</code></td>
<td>
<p>If TRUE, predictive standard error is evaulated. It is currently supported only for continuous variables. If nongauss is specified in the input model (mod), standard error for the transformed y is evaluated. Default is FALSE</p>
</td></tr>
<tr><td><code id="predict0_+3A_compute_quantile">compute_quantile</code></td>
<td>
<p>If TRUE, Matrix of the quantiles for the predicted values (N x 15) is evaulated. It is currently supported only for continuous variables. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>Matrix with the first column for the predicted values (pred). The second and the third columns are the predicted trend component (xb) and the residual spatial process (sf_residual). If xgroup0 is specified, the fourth column is the predicted group effects (group). If tr_num &gt; 0 or tr_nonneg ==TRUE (i.e., y is transformed) in mod, there is another column of the predicted values in the transformed/normalized scale (pred_trans). In addition, if compute_quantile =TRUE, predictive standard error (pred_se) is evaluated and added as another column</p>
</td></tr>
<tr><td><code>pred_quantile</code></td>
<td>
<p>Effective if compute_quantile = TRUE. Matrix of the quantiles for the predicted values (N x 15). It is useful for evaluating uncertainty in the predictive values</p>
</td></tr>
<tr><td><code>b_vc</code></td>
<td>
<p>Matrix of estimated spatially (spatio-temporally) varying coefficients (S(T)VCs) on x0 (N_0 x K)</p>
</td></tr>
<tr><td><code>bse_vc</code></td>
<td>
<p>Matrix of estimated standard errors for the S(T)VCs (N_0 x K)</p>
</td></tr>
<tr><td><code>t_vc</code></td>
<td>
<p>Matrix of estimated t-values for the S(T)VCs (N_0 x K)</p>
</td></tr>
<tr><td><code>p_vc</code></td>
<td>
<p>Matrix of estimated p-values for the S(T)VCs (N_0 x K)</p>
</td></tr>
<tr><td><code>c_vc</code></td>
<td>
<p>Matrix of estimated non-spatially varying coefficients (NVCs) on x0 (N x K). Effective if nvc =TRUE in <code><a href="#topic+resf">resf</a></code></p>
</td></tr>
<tr><td><code>cse_vc</code></td>
<td>
<p>Matrix of standard errors for the NVCs on x0 (N x K).Effective if nvc =TRUE in <code><a href="#topic+resf">resf</a></code></p>
</td></tr>
<tr><td><code>ct_vc</code></td>
<td>
<p>Matrix of t-values for the NVCs on x0 (N x K). Effective if nvc =TRUE in <code><a href="#topic+resf">resf</a></code></p>
</td></tr>
<tr><td><code>cp_vc</code></td>
<td>
<p>Matrix of p-values for the NVCs on x0 (N x K). Effective if nvc =TRUE in <code><a href="#topic+resf">resf</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+meigen0">meigen0</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(spdep)
data(boston)
samp    &lt;- sample( dim( boston.c )[ 1 ], 300)

d       &lt;- boston.c[ samp, ]    ## Data at observed sites
y	      &lt;- d[, "CMEDV"]
x       &lt;- d[,c("ZN", "LSTAT")]
xconst  &lt;- d[,c("CRIM", "NOX", "AGE", "DIS", "RAD", "TAX", "PTRATIO", "B", "RM")]
coords  &lt;- d[,c("LON", "LAT")]

d0      &lt;- boston.c[-samp, ]    ## Data at unobserved sites
y0      &lt;- d0[, "CMEDV"]
x0      &lt;- d0[,c("ZN", "LSTAT")]
xconst0 &lt;- d0[,c("CRIM", "NOX", "AGE", "DIS", "RAD", "TAX", "PTRATIO", "B", "RM")]
coords0 &lt;- d0[,c("LON", "LAT")]

meig 	  &lt;- meigen( coords = coords )
meig0 	&lt;- meigen0( meig = meig, coords0 = coords0 )

############ Spatial prediction ############
#### model with residual spatial dependence
mod	    &lt;- resf(y=y, x=x, meig=meig)
pred0   &lt;- predict0( mod = mod, x0 = x0, meig0 = meig0 )
pred0$pred[1:5,]  # Predicted values

#### model with spatially varying coefficients (SVCs)
mod	    &lt;- resf_vc(y=y, x=x, xconst=xconst, meig=meig )
pred0   &lt;- predict0( mod = mod, x0 = x0, xconst0=xconst0, meig0 = meig0 )
pred0$pred[1:5,]  # Predicted values
pred0$b_vc[1:5,]  # SVCs
pred0$bse_vc[1:5,]# standard errors of the SVCs
pred0$t_vc[1:5,]  # t-values of the SNVCs
pred0$p_vc[1:5,]  # p-values of the SNVCs

plot(y0,pred0$pred[,1]);abline(0,1)


</code></pre>

<hr>
<h2 id='resf'>spatial and spatio-temporal regression models</h2><span id='topic+resf'></span>

<h3>Description</h3>

<p>This model estimates regression coefficients, coefficients varying depending on x (non-spatially varying coefficients; NVC), and group effects, considering residual spatial/spatio-temporal dependence. The random-effects eigenvector spatial filtering, which is an approximate Gaussian process approach, is used for modeling the residual dependence. If nonugauss is specified, non-Gaussian explained variables are Gaussianized using a compositional warping function (see <code><a href="#topic+nongauss_y">nongauss_y</a></code>). This augument allows the resf function to be applied to non-Gaussian explained variables, including count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resf( y, x = NULL, xgroup = NULL, weight = NULL, offset = NULL,
      nvc = FALSE, nvc_sel = TRUE, nvc_num = 5, meig,
      method = "reml", penalty = "bic", nongauss = NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resf_+3A_y">y</code></td>
<td>
<p>Vector of explained variables (N x 1)</p>
</td></tr>
<tr><td><code id="resf_+3A_x">x</code></td>
<td>
<p>Matrix of explanatory variables (N x K). Default is NULL</p>
</td></tr>
<tr><td><code id="resf_+3A_xgroup">xgroup</code></td>
<td>
<p>Matrix of group IDs. The IDs may be group numbers or group names (N x K_g). Default is NULL</p>
</td></tr>
<tr><td><code id="resf_+3A_weight">weight</code></td>
<td>
<p>Vector of weights for samples (N x 1). If non-NULL, the adjusted R-squared value is evaluated for weighted explained variables. Default is NULL</p>
</td></tr>
<tr><td><code id="resf_+3A_offset">offset</code></td>
<td>
<p>Vector of offset variables (N x 1). Available if y is count (y_type = &quot;count&quot; is specified in the <code><a href="#topic+nongauss_y">nongauss_y</a></code> function). Default is NULL</p>
</td></tr>
<tr><td><code id="resf_+3A_nvc">nvc</code></td>
<td>
<p>If TRUE, a non-linear function of x (NVC; a spline function) is used as a varying coefficient. If FALSE, constant coefficients are assumed. Default is FALSE</p>
</td></tr>
<tr><td><code id="resf_+3A_nvc_sel">nvc_sel</code></td>
<td>
<p>If TRUE, type of each coefficient (NVC or constant) is selected through a BIC minimization. If FALSE, NVCs are assumed across x. Alternatively, nvc_sel can be given by column number(s) of x. For example, if nvc_sel = 2, the coefficient on the second explanatory variable is NVC and the other coefficients are constants. Default is TRUE</p>
</td></tr>
<tr><td><code id="resf_+3A_nvc_num">nvc_num</code></td>
<td>
<p>Number of natural spline basis functions to be used to model NVC. Default is 5</p>
</td></tr>
<tr><td><code id="resf_+3A_meig">meig</code></td>
<td>
<p>Moran eigenvectors and eigenvalues. Output from <code><a href="#topic+meigen">meigen</a></code> or <code><a href="#topic+meigen_f">meigen_f</a></code></p>
</td></tr>
<tr><td><code id="resf_+3A_method">method</code></td>
<td>
<p>Estimation method. Restricted maximum likelihood method (&quot;reml&quot;) and maximum likelihood method (&quot;ml&quot;) are available. Default is &quot;reml&quot;</p>
</td></tr>
<tr><td><code id="resf_+3A_penalty">penalty</code></td>
<td>
<p>Penalty to select type of coefficients (NVC or constant) to stablize the estimates. The current options are &quot;bic&quot; for the Baysian information criterion-type penalty (N x log(K)) and &quot;aic&quot; for the Akaike information criterion (2K). Default is &quot;bic&quot;</p>
</td></tr>
<tr><td><code id="resf_+3A_nongauss">nongauss</code></td>
<td>
<p>Parameter setup for modeling non-Gaussian continuous data or count data. Output from <code><a href="#topic+nongauss_y">nongauss_y</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For modeling non-Gaussian data including count data, see <code><a href="#topic+nongauss_y">nongauss_y</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>Matrix with columns for the estimated constant coefficients on x, their standard errors, t-values, and p-values (K x 4)</p>
</td></tr>
<tr><td><code>b_g</code></td>
<td>
<p>List of K_g matrices with columns for the estimated group effects, their standard errors, and t-values</p>
</td></tr>
<tr><td><code>c_vc</code></td>
<td>
<p>Matrix of estimated NVCs on x (N x K). Effective if nvc = TRUE</p>
</td></tr>
<tr><td><code>cse_vc</code></td>
<td>
<p>Matrix of standard errors for the NVCs on x (N x K). Effective if nvc = TRUE</p>
</td></tr>
<tr><td><code>ct_vc</code></td>
<td>
<p>Matrix of t-values for the NVCs on x (N x K). Effective if nvc = TRUE</p>
</td></tr>
<tr><td><code>cp_vc</code></td>
<td>
<p>Matrix of p-values for the NVCs on x (N x K). Effective if nvc = TRUE</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Vector of estimated variance parameters (2 x 1). The first and the second elements are the standard deviation and the Moran's I value of the estimated spatially (and temporally) dependent process, respectively. The Moran's I value is scaled to take a value between 0 (no spatial dependence) and 1 (the maximum possible spatial dependence). Based on Griffith (2003), the scaled Moran'I value is interpretable as follows: 0.25-0.50:weak; 0.50-0.70:moderate; 0.70-0.90:strong; 0.90-1.00:marked</p>
</td></tr>
<tr><td><code>s_c</code></td>
<td>
<p>Vector of standard deviations of the NVCs on xconst</p>
</td></tr>
<tr><td><code>s_g</code></td>
<td>
<p>Vector of estimated standard deviations of the group effects</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Error statistics. When y_type=&quot;continuous&quot;, it includes residual standard error (resid_SE), adjusted conditional R2 (adjR2(cond)), restricted log-likelihood (rlogLik), Akaike information criterion (AIC), and Bayesian information criterion (BIC). rlogLik is replaced with log-likelihood (logLik) if method = &quot;ml&quot;. resid_SE is replaced with the residual standard error for the transformed y (resid_SE_trans) if nongauss is specified. When y_type=&quot;count&quot;, the error statistics contains root mean squared error (RMSE), Gaussian likelihood approximating the model, AIC and BIC based on the likelihood, and the proportion of the null deviance explained by the model (deviance explained (%)). deviance explained, which is also used in the mgcv package, corresponds to the adjusted R2 in case of the linear regression</p>
</td></tr>
<tr><td><code>vc</code></td>
<td>
<p>List indicating whether NVC are removed or not during the BIC minimization. 1 indicates not removed whreas 0 indicates removed</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Vector of estimated random coefficients on the Moran's eigenvectors (L x 1)</p>
</td></tr>
<tr><td><code>sf</code></td>
<td>
<p>Vector of estimated spatial dependent component (N x 1)</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Matrix of predicted values for y (pred) and their standard errors (pred_se) (N x 2). If y is transformed by specifying <code><a href="#topic+nongauss_y">nongauss_y</a></code>, the predicted values in the transformed/normalized scale are added as another column named pred_trans</p>
</td></tr>
<tr><td><code>pred_quantile</code></td>
<td>
<p>Matrix of the quantiles for the predicted values (N x 15). It is useful to evaluate uncertainty in the predictive value</p>
</td></tr>
<tr><td><code>tr_par</code></td>
<td>
<p>List of the parameter estimates for the tr_num SAL transformations. The k-th element of the list includes the four parameters for the k-th SAL transformation (see <code><a href="#topic+nongauss_y">nongauss_y</a></code>)</p>
</td></tr>
<tr><td><code>tr_bpar</code></td>
<td>
<p>The estimated parameter in the Box-Cox transformation</p>
</td></tr>
<tr><td><code>tr_y</code></td>
<td>
<p>Vector of the transformed explaied variables</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Vector of residuals (N x 1)</p>
</td></tr>
<tr><td><code>pdf</code></td>
<td>
<p>Matrix whose first column consists of evenly spaced values within the value range of y and the second column consists of the estimated value of the probability density function for y if y_type in <code><a href="#topic+nongauss_y">nongauss_y</a></code> is &quot;continuous&quot; and probability mass function (PMF) if y_type = &quot;count&quot;. If offset is specified (and y_type = &quot;count&quot;), the PMF given median offset value is evaluated</p>
</td></tr>
<tr><td><code>skew_kurt</code></td>
<td>
<p>Skewness and kurtosis of the estimated probability density/mass function of y</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Murakami, D. and Griffith, D.A. (2015) Random effects specifications in eigenvector spatial filtering: a simulation study. Journal of Geographical Systems, 17 (4), 311-331.
</p>
<p>Murakami, D., and Griffith, D.A. (2020) Balancing spatial and non-spatial variations in varying coefficient modeling: a remedy for spurious correlation. Geographical Analysis, DOI: 10.1111/gean.12310.
</p>
<p>Murakami, D., Kajita, M., Kajita, S. and Matsui, T. (2021) Compositionally-warped additive mixed modeling for a wide variety of non-Gaussian data. Spatial Statistics, 43, 100520.
</p>
<p>Murakami, D., Shirota, S., Kajita, S., and Kajita, S. (2024) Fast spatio-temporally varying coefficient modeling with reluctant interaction selection. ArXiv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meigen">meigen</a></code>, <code><a href="#topic+meigen_f">meigen_f</a></code>, <code><a href="#topic+coef_marginal">coef_marginal</a></code>, <code><a href="#topic+besf">besf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####################################################
############ Spatial regression modeling ############
#####################################################
require(spdep);require(Matrix)
data(boston)
y	    &lt;- boston.c[, "CMEDV" ]
x	    &lt;- boston.c[,c("CRIM","ZN","INDUS", "CHAS", "NOX","RM", "AGE",
                     "DIS" ,"RAD", "TAX", "PTRATIO", "B", "LSTAT")]
xgroup&lt;- boston.c[,"TOWN"]
coords&lt;- boston.c[,c("LON","LAT")]
meig 	&lt;- meigen(coords=coords)
# meig&lt;- meigen_f(coords=coords)  ## for large samples

#####################################################
####### Gaussian regression #########################
res	  &lt;- resf(y = y, x = x, meig = meig)
res
plot_s(res)    ## spatially dependent component (intercept)

#### Group-wise random intercepts
#res2 &lt;- resf(y = y, x = x, meig = meig, xgroup = xgroup)

#### Group-level spatial dependence (s_id) + random intercepts (xgroup)

#meig_g&lt;- meigen(coords=coords, s_id = xgroup)
#res3  &lt;- resf(y = y, x = x, meig = meig_g, xgroup = xgroup)

#### Coefficients varying depending on x

#res4  &lt;- resf(y = y, x = x, meig = meig, nvc = TRUE)
#res4

#plot_s(res4)   # spatially dependent component (intercept)
#plot_s(res4,5) # spatial plot of the 5-th NVC
#plot_s(res4,6) # spatial plot of the 6-th NVC
#plot_s(res4,13)# spatial plot of the 13-th NVC

#plot_n(res4,5) # 1D plot of the 5-th NVC
#plot_n(res4,6) # 1D plot of the 6-th NVC
#plot_n(res4,13)# 1D plot of the 13-th NVC

#####################################################
###### Non-Gaussian regression ######################

#### Model for non-Gaussian continuous data
# - Probability distribution is estimated from data

#ng5    &lt;- nongauss_y( tr_num = 2 )# 2 SAL transformations to Gaussianize y
#res5	  &lt;- resf(y = y, x = x, meig = meig, nongauss = ng5)
#res5              ## tr_num may be selected by comparing BIC

#plot(res5$pdf,type="l") # Estimated probability density function
#res5$skew_kurt          # Skew and kurtosis of the estimated PDF
#res5$pred_quantile[1:2,]# predicted value by quantile
#coef_marginal(res5)     # Estimated marginal effects (dy/dx)


#### Model for non-Gaussian and non-negative continuous data
# - Probability distribution is estimated from data

#ng6    &lt;- nongauss_y( tr_num = 2, y_nonneg = TRUE )
#res6	  &lt;- resf(y = y, x = x, meig = meig, nongauss = ng6 )
#coef_marginal(res6)

#### Overdispersed Poisson model for count data
# - y: count data

#ng7    &lt;- nongauss_y( y_type = "count" )
#res7	  &lt;- resf(y = y, x = x, meig = meig, nongauss = ng7 )

#### General model for count data
# - y: count data
# - Probability distribution is estimated from data

#ng8    &lt;- nongauss_y( y_type = "count", tr_num = 2 )
#res8	  &lt;- resf(y = y, x = x, meig = meig, nongauss = ng8 )


#####################################################
################ STVC modeling ######################
#####################################################
# See \url{https://github.com/dmuraka/spmoran}

#require(spData)
#data(house)
#dat0    &lt;- st_as_sf(house)
#dat     &lt;- data.frame(st_coordinates(dat0), dat0)
#y	     &lt;- log(dat[,"price"])
#x       &lt;- dat[,c("lotsize","TLA", "rooms","beds")]

#byear   &lt;- house$yrbuilt
#syear   &lt;- as.numeric(as.character(house$syear))#factor -&gt; numeric
#coords_z&lt;- cbind(byear,syear)
#meig 	 &lt;- meigen_f(coords=coords, coords_z=cbind(byear,syear),interact=TRUE)
#res9	   &lt;- resf(y=y,x=x,meig=meig )
#res9
</code></pre>

<hr>
<h2 id='resf_qr'>Spatial filter unconditional quantile regression</h2><span id='topic+resf_qr'></span>

<h3>Description</h3>

<p>This function estimates the spatial filter unconditional quantile regression (SF-UQR) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resf_qr( y, x = NULL, meig, tau = NULL, boot = TRUE,
         iter = 200, parallel=FALSE, ncores=NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resf_qr_+3A_y">y</code></td>
<td>
<p>Vector of explained variables (N x 1)</p>
</td></tr>
<tr><td><code id="resf_qr_+3A_x">x</code></td>
<td>
<p>Matrix of explanatory variables (N x K). Default is NULL</p>
</td></tr>
<tr><td><code id="resf_qr_+3A_meig">meig</code></td>
<td>
<p>Moran eigenvectors and eigenvalues. Output from <code><a href="#topic+meigen">meigen</a></code> or <code><a href="#topic+meigen_f">meigen_f</a></code></p>
</td></tr>
<tr><td><code id="resf_qr_+3A_tau">tau</code></td>
<td>
<p>The quantile(s) to be modeled. It must be a number (or a vector of numbers) strictly between 0 and 1. By default, tau = c(0.1, 0.2, ..., 0.9)</p>
</td></tr>
<tr><td><code id="resf_qr_+3A_boot">boot</code></td>
<td>
<p>If it is TRUE, confidence intervals of regression coefficients are estimated by a semiparametric bootstrapping. Default is TRUE</p>
</td></tr>
<tr><td><code id="resf_qr_+3A_iter">iter</code></td>
<td>
<p>The number of bootstrap replications. Default is 200</p>
</td></tr>
<tr><td><code id="resf_qr_+3A_parallel">parallel</code></td>
<td>
<p>If TRUE, the bootstrapping for estimating confidence intervals is parallelized. Default is FALSE</p>
</td></tr>
<tr><td><code id="resf_qr_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for the parallel computation. If ncores=NULL, which is the default, the number of available cores - 2 is detected and used</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>Matrix of estimated regression coefficients (K x Q), where Q is the number of quantiles (i.e., the length of tau)</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Matrix of estimated random coefficients on Moran eigenvectors (L x Q)</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Vector of estimated variance parameters (2 x 1). The first and the second elements denote the standard deviation and the Moran's I value of the estimated spatially dependent component, respectively. The Moran's I value is scaled to take a value between 0 (no spatial dependence) and 1 (the maximum possible spatial dependence). Based on Griffith (2003), the scaled Moran'I value is interpretable as follows: 0.25-0.50:weak; 0.50-0.70:moderate; 0.70-0.90:strong; 0.90-1.00:marked</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Vector whose elements are residual standard error (resid_SE) and adjusted quasi conditional R2 (quasi_adjR2(cond))</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Q matrices (K x 4) summarizing bootstrapped estimates for the regression coefficients. Columns of these matrices consist of the estimated coefficients, the lower and upper bounds for the 95 percent confidencial intervals, and p-values. It is returned if boot = TRUE</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Q matrices (2 x 3) summarizing bootstrapped estimates for the variance parameters. Columns of these matrices consist of the estimated parameters, the lower and upper bounds for the 95 percent confidencial intervals. It is returned if boot = TRUE</p>
</td></tr>
<tr><td><code>B0</code></td>
<td>
<p>List of Q matrices (K x iter) summarizing bootstrapped coefficients. The q-th matrix consists of the coefficients on the q-th quantile. Effective if boot = TRUE</p>
</td></tr>
<tr><td><code>S0</code></td>
<td>
<p>List of Q matrices (2 x iter) summarizing bootstrapped variance parameters. The q-th matrix consists of the parameters on the q-th quantile. Effective if boot = TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Murakami, D. and Seya, H. (2017) Spatially filtered unconditional quantile regression. ArXiv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_qr">plot_qr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spdep)
data(boston)
y	&lt;- boston.c[, "CMEDV" ]
x	&lt;- boston.c[,c("CRIM","ZN","INDUS", "CHAS", "NOX","RM", "AGE",
                       "DIS" ,"RAD", "TAX", "PTRATIO", "B", "LSTAT")]
coords  &lt;- boston.c[,c("LON", "LAT")]
meig 	  &lt;- meigen(coords=coords)
res	    &lt;- resf_qr(y=y,x=x,meig=meig, boot=FALSE)
res
plot_qr(res,1)     # Intercept
plot_qr(res,2)     # Coefficient on CRIM
plot_qr(res,1,"s") # spcomp_SE
plot_qr(res,2,"s") # spcomp_Moran.I/max(Moran.I)

###Not run
#res	&lt;- resf_qr(y=y,x=x,meig=meig, boot=TRUE)
#res
#plot_qr(res,1)     # Intercept + 95 percent confidence interval (CI)
#plot_qr(res,2)     # Coefficient on CRIM + 95 percent CI
#plot_qr(res,1,"s") # spcomp_SE + 95 percent CI
#plot_qr(res,2,"s") # spcomp_Moran.I/max(Moran.I) + 95 percent CI
</code></pre>

<hr>
<h2 id='resf_vc'>spatial and spatio-temporal regression models with varying coefficients</h2><span id='topic+resf_vc'></span>

<h3>Description</h3>

<p>This function estimates spatially varying coefficients (SVC) or spatio-temporally varying coefficients (STVC), group effects, considering residual spatial/spatio-temporal dependence. A non-linear function of x (NVC) can be added on each SVC/STVC mainly to stablize the estimation (see Murakami and Griffith, 2020). Approximate Gaussian processes based on Moran eigenvectors are used for modeling the spatio-temporal processes. Type of coefficients (constant or varying) is selected through a BIC minimization. If nonugauss is specified, non-Gaussian explained variables are Gaussianized using a compositional warping function (see <code><a href="#topic+nongauss_y">nongauss_y</a></code>). This augument allows the resf function to be applied to non-Gaussian explained variables, including count data.
</p>
<p>Note that, for very large samples, this function can overlook small-scale spatial variations. <code><a href="#topic+addlearn_local">addlearn_local</a></code> applies an model aggregation/averaging technique to address this problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resf_vc(y, x, xconst = NULL, xgroup = NULL, weight = NULL, offset = NULL,
        x_nvc = FALSE, xconst_nvc = FALSE, x_sel = TRUE, x_nvc_sel = TRUE,
        xconst_nvc_sel = TRUE,
        nvc_num = 5, meig, method = "reml", penalty = "bic", nongauss = NULL,
        miniter=NULL, maxiter = 30, tol = 1e-30 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resf_vc_+3A_y">y</code></td>
<td>
<p>Vector of explained variables (N x 1)</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_x">x</code></td>
<td>
<p>Matrix of explanatory variables assuming SVC/STVC (N x K)</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_xconst">xconst</code></td>
<td>
<p>Matrix of explanatory variables assuming constant coefficients (N x K_c). Default is NULL</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_xgroup">xgroup</code></td>
<td>
<p>Matrix of group IDs for modeling group-wise random effects. The IDs may be group numbers or group names (N x K_g). Default is NULL</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_weight">weight</code></td>
<td>
<p>Vector of weights for samples (N x 1). If non-NULL, the adjusted R-squared value is evaluated for weighted explained variables. Default is NULL</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_offset">offset</code></td>
<td>
<p>Vector of offset variables (N x 1). Available if y is count (y_type = &quot;count&quot; is specified in the <code><a href="#topic+nongauss_y">nongauss_y</a></code> function). Default is NULL</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_x_nvc">x_nvc</code></td>
<td>
<p>If TRUE, a non-linear function of x (NVC) is added on each varying coefficient on x to stablize the estimate. Default is FALSE</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_xconst_nvc">xconst_nvc</code></td>
<td>
<p>If TRUE, NVCs is added on each constant coefficient on xconst model estimate non-linear influence from xconst</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_x_sel">x_sel</code></td>
<td>
<p>If TRUE, type of coefficient on x (STVC, SVC, or constant) is selected through a BIC minimization. If FALSE, S(T)VCs are assumed across x. Alternatively, x_sel can be given by column number(s) of x. For example, if x_sel = 2, the coefficient on the second explanatory variable is S(T)VC and the other coefficients are constants. The Default is TRUE</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_x_nvc_sel">x_nvc_sel</code></td>
<td>
<p>If TRUE, with/without NVC on x is selected. If FALSE, NVCs are assumed across x. Alternatively, x_nvc_sel can be given by column number(s) of x. For example, if x_nvc_sel = 2, the coefficient on the second explanatory variable is NVC and the other coefficients are constants. The Default is TRUE</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_xconst_nvc_sel">xconst_nvc_sel</code></td>
<td>
<p>If TRUE, with/without NVC on xconst is selected. If FALSE, NVCs are assumed across xconst. Alternatively, xconst_nvc_sel can be given by column number(s) of xconst. For example, if xconst_nvc_sel = 2, the coefficient on xconst[,2] becomes constant + NVC while the other coefficients become constants.The Default is TRUE</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_nvc_num">nvc_num</code></td>
<td>
<p>Number of natural spline basis functions to be used in NVC. Default is 5</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_meig">meig</code></td>
<td>
<p>Moran eigenvectors and eigenvalues. Output from <code><a href="#topic+meigen">meigen</a></code> or <code><a href="#topic+meigen_f">meigen_f</a></code></p>
</td></tr>
<tr><td><code id="resf_vc_+3A_method">method</code></td>
<td>
<p>Estimation method. Restricted maximum likelihood method (&quot;reml&quot;) and maximum likelihood method (&quot;ml&quot;) are available. Default is &quot;reml&quot;</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_penalty">penalty</code></td>
<td>
<p>Penalty for model estimation and selection. &quot;bic&quot; for the Baysian information criterion-type penalty (N x log(K)) and &quot;aic&quot; for the Akaike information criterion  (2K). Default is &quot;bic&quot;</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_nongauss">nongauss</code></td>
<td>
<p>Parameter setup for modeling non-Gaussian continuous and count data. Output from <code><a href="#topic+nongauss_y">nongauss_y</a></code></p>
</td></tr>
<tr><td><code id="resf_vc_+3A_miniter">miniter</code></td>
<td>
<p>Minimum number of iterations. Default is NULL</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. Default is 30</p>
</td></tr>
<tr><td><code id="resf_vc_+3A_tol">tol</code></td>
<td>
<p>The tolerance for matrix inversion. Some errors regarding singular fit can be avoided by reducing the value, but the output can be unstable. Default is 1e-30</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For modeling non-Gaussian data including count data, see <code><a href="#topic+nongauss_y">nongauss_y</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b_vc</code></td>
<td>
<p>Matrix of estimated spatially/spatio-temporally varying coefficients (S(T)VC + NVC) on x (N x K)</p>
</td></tr>
<tr><td><code>bse_vc</code></td>
<td>
<p>Matrix of standard errors for the varying coefficients on x (N x k)</p>
</td></tr>
<tr><td><code>t_vc</code></td>
<td>
<p>Matrix of t-values for the coefficients on x (N x K)</p>
</td></tr>
<tr><td><code>p_vc</code></td>
<td>
<p>Matrix of p-values for the coefficients on x (N x K)</p>
</td></tr>
<tr><td><code>B_vc_s</code></td>
<td>
<p>List of the estimated S(T)VCs in b_vc (= S(T)VC + NVC). The elements are the S(T)VCs (N x K), the standard errors (N x K), t-values (N x K), and p-values (N x K), respectively</p>
</td></tr>
<tr><td><code>B_vc_n</code></td>
<td>
<p>List of the estimated NVCs in b_vc (= S(T)VC + NVC). The elements are the NVCs (N x K), the standard errors (N x K), t-values (N x K), and p-values (N x K), respectively</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Matrix with columns for the estimated coefficients on xconst, their standard errors, t-values, and p-values (K_c x 4). Effective if xconst_nvc = FALSE</p>
</td></tr>
<tr><td><code>c_vc</code></td>
<td>
<p>Matrix of estimated NVCs on xconst (N x K_c). Effective if xconst_nvc = TRUE</p>
</td></tr>
<tr><td><code>cse_vc</code></td>
<td>
<p>Matrix of standard errors for the NVCs on xconst (N x k_c). Effective if xconst_nvc = TRUE</p>
</td></tr>
<tr><td><code>ct_vc</code></td>
<td>
<p>Matrix of t-values for the NVCs on xconst (N x K_c). Effective if xconst_nvc = TRUE</p>
</td></tr>
<tr><td><code>cp_vc</code></td>
<td>
<p>Matrix of p-values for the NVCs on xconst (N x K_c). Effective if xconst_nvc = TRUE</p>
</td></tr>
<tr><td><code>b_g</code></td>
<td>
<p>List of K_g matrices with columns for the estimated group effects, their standard errors, and t-values</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>List of the variance parameters for the varying coefficient on x. The first element is a 2 x K matrix summarizing variance parameters for S(T)VC. The (1, k)-th element is the standard deviation of the k-th SVC, while the (2, k)-th element is the Moran's I value that  is scaled to take a value between 0 (no spatial dependence) and 1 (strongest spatial dependence). Based on Griffith (2003), the scaled Moran'I value is interpretable as follows: 0.25-0.50:weak; 0.50-0.70:moderate; 0.70-0.90:strong; 0.90-1.00:marked. The second element of s is the vector of standard deviations of the NVCs</p>
</td></tr>
<tr><td><code>s_c</code></td>
<td>
<p>Vector of standard deviations of the NVCs on xconst</p>
</td></tr>
<tr><td><code>s_g</code></td>
<td>
<p>Vector of standard deviations of the group effects</p>
</td></tr>
<tr><td><code>vc</code></td>
<td>
<p>List indicating whether S(T)VC/NVC are removed or not during the BIC minimization. 1 indicates not removed (replaced with constant) whreas 0 indicates removed</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Error statistics. When y_type=&quot;continuous&quot;, it includes residual standard error (resid_SE), adjusted conditional R2 (adjR2(cond)), restricted log-likelihood (rlogLik), Akaike information criterion (AIC), and Bayesian information criterion (BIC). rlogLik is replaced with log-likelihood (logLik) if method = &quot;ml&quot;. resid_SE is replaced with the residual standard error for the transformed y (resid_SE_trans) if nongauss is specified. When y_type=&quot;count&quot;, the error statistics includes root mean squared error (RMSE), Gaussian likelihood approximating the model, AIC and BIC based on the likelihood, and the proportion of the null deviance explained by the model (deviance explained (%)). deviance explained, which is also used in the mgcv package, corresponds to the adjusted R2 in case of the linear regression</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Matrix of predicted values for y (pred) and their standard errors (pred_se) (N x 2). If y is transformed by specifying <code><a href="#topic+nongauss_y">nongauss_y</a></code>, the predicted values in the transformed/normalized scale are added as another column named pred_trans</p>
</td></tr>
<tr><td><code>pred_quantile</code></td>
<td>
<p>Matrix of the quantiles for the predicted values (N x 15). It is useful to evaluate uncertainty in the predictive value</p>
</td></tr>
<tr><td><code>tr_par</code></td>
<td>
<p>List of the parameter estimates for the tr_num SAL transformations. The k-th element of the list includes the four parameters for the k-th SAL transformation (see <code><a href="#topic+nongauss_y">nongauss_y</a></code>)</p>
</td></tr>
<tr><td><code>tr_bpar</code></td>
<td>
<p>The estimated parameter in the Box-Cox transformation</p>
</td></tr>
<tr><td><code>tr_y</code></td>
<td>
<p>Vector of the transformed explaied variables</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Vector of residuals (N x 1)</p>
</td></tr>
<tr><td><code>pdf</code></td>
<td>
<p>Matrix whose first column consists of evenly spaced values within the value range of y and the second column consists of the estimated value of the probability density function for y if y_type in <code><a href="#topic+nongauss_y">nongauss_y</a></code> is &quot;continuous&quot; and probability mass function if y_type = &quot;count&quot;.  If offset is specified (and y_type = &quot;count&quot;), the PMF given median offset value is evaluated</p>
</td></tr>
<tr><td><code>skew_kurt</code></td>
<td>
<p>Skewness and kurtosis of the estimated probability density/mass function of y</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outputs, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Murakami, D., Yoshida, T., Seya, H., Griffith, D.A., and Yamagata, Y. (2017) A Moran coefficient-based mixed effects approach to investigate spatially varying relationships. Spatial Statistics, 19, 68-89.
</p>
<p>Murakami, D., Kajita, M., Kajita, S. and Matsui, T. (2021) Compositionally-warped additive mixed modeling for a wide variety of non-Gaussian data. Spatial Statistics, 43, 100520.
</p>
<p>Murakami, D., and Griffith, D.A. (2021) Balancing spatial and non-spatial variations in varying coefficient modeling: a remedy for spurious correlation. Geographical Analysis, DOI: 10.1111/gean.12310.
</p>
<p>Murakami, D., Shirota, S., Kajita, S., and Kajita, S. (2024) Fast spatio-temporally varying coefficient modeling with reluctant interaction selection. ArXiv.
</p>
<p>Griffith, D. A. (2003) Spatial autocorrelation and spatial filtering: gaining understanding through theory and scientific visualization. Springer Science &amp; Business Media.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meigen">meigen</a></code>, <code><a href="#topic+meigen_f">meigen_f</a></code>, <code><a href="#topic+coef_marginal">coef_marginal</a></code>, <code><a href="#topic+besf_vc">besf_vc</a></code>, <code><a href="#topic+addlearn_local">addlearn_local</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####################################################
################ SVC modeling #######################
#####################################################
require(spdep)
data(boston)
y	      &lt;- boston.c[, "CMEDV"]
x       &lt;- boston.c[,c("CRIM", "AGE")]
xconst  &lt;- boston.c[,c("ZN","DIS","RAD","NOX",  "TAX","RM", "PTRATIO", "B")]
xgroup  &lt;- boston.c[,"TOWN"]
coords  &lt;- boston.c[,c("LON", "LAT")]
meig 	  &lt;- meigen(coords=coords)
# meig	&lt;- meigen_f(coords=coords)  ## for large samples

#####################################################
####### Gaussian regression with SVC ################

res	    &lt;- resf_vc(y=y,x=x,xconst=xconst,meig=meig )
res
plot_s(res,0) # Spatially varying intercept
plot_s(res,1) # 1st SVC (Not shown because the SVC is estimated constant)
plot_s(res,2) # 2nd SVC

#### For large samples (e.g., n &gt; 5,000), the following
#### additional learning often improves the modeling accuracy
# res_adj&lt;- addlearn_local(res)
# res_adj
# plot_s(res_adj,0)
# plot_s(res_adj,1)
# plot_s(res_adj,2)

#### Group-level SVC (s_id) + random intercepts (xgroup)
# meig_g &lt;- meigen(coords, s_id=xgroup)
# res2	  &lt;- resf_vc(y=y,x=x,xconst=xconst,meig=meig_g,xgroup=xgroup)


#####################################################
####### Gaussian regression with SVC + NVC ##########

# res3	  &lt;- resf_vc(y=y,x=x,xconst=xconst,meig=meig, x_nvc =TRUE)
# plot_s(res3,0)            # Spatially varying intercept
# plot_s(res3,1)            # Spatial plot of the varying coefficient (SVC + NVC) on x[,1]
# plot_s(res3,1,btype="svc")# Spatial plot of SVC in the coefficient
# plot_s(res3,1,btype="nvc")# Spatial plot of NVC in the coefficient
# plot_n(res3,1)            # 1D plot of the NVC


#####################################################
######## Non-Gaussian regression with SVC ###########

#### Model for non-Gaussian continuous data
# - Probability distribution is estimated from data

# ng4     &lt;- nongauss_y( tr_num = 2 )# 2 SAL transformations to Gaussianize y
# res4	  &lt;- resf_vc(y=y,x=x,xconst=xconst,meig=meig, nongauss = ng4 )
# res4                    # tr_num may be selected by comparing BIC

# coef_marginal_vc(res4)  # marginal effects from x (dy/dx)
# plot(res4$pdf,type="l") # Estimated probability density function
# res4$skew_kurt          # Skew and kurtosis of the estimated PDF
# res4$pred_quantile[1:2,]# predicted value by quantile


#### Model for non-Gaussian and non-negative continuous data
# - Probability distribution is estimated from data

## 2 SAL trans. + 1 Box-Cox trans. to Gaussianize y
# ng5     &lt;- nongauss_y( tr_num = 2, y_nonneg = TRUE )
# res5	  &lt;- resf_vc(y=y,x=x,xconst=xconst,meig=meig, nongauss = ng5 )
# coef_marginal_vc(res5)

#### Overdispersed Poisson model for count data
# - y: count data

#ng6    &lt;- nongauss_y( y_type = "count" )
#res6	  &lt;- resf_vc(y=y,x=x,xconst=xconst,meig=meig, nongauss = ng6 )

#### General model for count data
# - y: count data
# - Probability distribution is estimated from data

#ng7    &lt;- nongauss_y( y_type = "count", tr_num = 2 )
#res7	  &lt;- resf_vc(y=y,x=x,xconst=xconst,meig=meig, nongauss = ng7 )


#####################################################
################ STVC modeling ######################
#####################################################
# See \url{https://github.com/dmuraka/spmoran}

#require(spData)
#data(house)
#dat0    &lt;- st_as_sf(house)
#dat     &lt;- data.frame(st_coordinates(dat0), dat0)
#y	     &lt;- log(dat[,"price"])
#x       &lt;- dat[,c("lotsize","TLA")]
#xconst  &lt;- dat[,c("rooms","beds")]

#byear   &lt;- house$yrbuilt
#syear   &lt;- as.numeric(as.character(house$syear))#factor -&gt; numeric
#coords_z&lt;- cbind(byear,syear)
#meig 	 &lt;- meigen_f(coords=coords, coords_z=cbind(byear,syear),interact=TRUE)
#res8	   &lt;- resf_vc(y=y,x=x,xconst=xconst,meig=meig )
#res8

## Varying intercept for byear &lt;=1950 and syear==1998
#plot_s(res8,0, coords_z1_lim=c(-Inf, 1950),coords_z2_lim=1998)

## 1st STVCs which are significant at the 5 percent level, for byear &lt;= 1950
#plot_s(res8,1, coords_z1_lim=c(-Inf, 1950), pmax=0.05)

## 2nd STVC for byear &gt;= 1951
#plot_s(res8,2, coords_z1_lim=c(1951,Inf))
</code></pre>

<hr>
<h2 id='weigen'>Extract eigenvectors from a spatial weight matrix</h2><span id='topic+weigen'></span>

<h3>Description</h3>

<p>This function extracts eigenvectors and eigenvalues from a spatial weight matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weigen( x = NULL, type = "knn", k = 4, threshold = 0.25, enum = NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weigen_+3A_x">x</code></td>
<td>
<p>Matrix of spatial point coordinates (N x 2), sf polygon object (N spatial units), or an user-specified spatial weight matrix (N x N) (see Details)</p>
</td></tr>
<tr><td><code id="weigen_+3A_type">type</code></td>
<td>
<p>Type of spatial weights. The currently available options are &quot;knn&quot; for the k-nearest neighbor-based weights, and &quot;tri&quot; for the Delaunay triangulation-based weights. If sf polygons are provided for x, type is ignored, and the rook-type neighborhood matrix is created</p>
</td></tr>
<tr><td><code id="weigen_+3A_k">k</code></td>
<td>
<p>Number of nearest neighbors. It is used if type =&quot;knn&quot;</p>
</td></tr>
<tr><td><code id="weigen_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for the eigenvalues (scalar). Suppose that lambda_1 is the maximum eigenvalue. Then, this fucntion extracts eigenvectors whose corresponding eigenvalues are equal or greater than [threshold x lambda_1]. It must be a value between 0 and 1. Default is 0.25 (see Details)</p>
</td></tr>
<tr><td><code id="weigen_+3A_enum">enum</code></td>
<td>
<p>Optional. The muximum acceptable mumber of eigenvectors to be used for spatial modeling (scalar)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If user-specified spatial weight matrix is provided for x, this function returns the eigen-pairs of the matrix. Otherwise, if sf polygon object is provided to x, the rook-type neighborhood matrix is created using this polygon, and eigen-decomposed. Otherwise, if point coordinats are provided to x, a spatial weight matrix is created according to type, and eigen-decomposed.
</p>
<p>By default, the ARPACK routine is implemented for fast eigen-decomposition.
</p>
<p>threshold = 0.25 (default) is a standard setting for topology-based ESF (see Tiefelsdorf and Griffith, 2007) while threshold = 0.00 is a usual setting for distance-based ESF.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sf</code></td>
<td>
<p>Matrix of the first L eigenvectors (N x L)</p>
</td></tr>
<tr><td><code>ev</code></td>
<td>
<p>Vector of the first L eigenvalues (L x 1)</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>List of other outcomes, which are internally used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daisuke Murakami
</p>


<h3>References</h3>

<p>Tiefelsdorf, M. and Griffith, D.A. (2007) Semiparametric filtering of spatial autocorrelation: the eigenvector approach. Environment and Planning A, 39 (5), 1193-1221.
</p>
<p>Murakami, D. and Griffith, D.A. (2018) Low rank spatial econometric models. Arxiv, 1810.02956.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meigen">meigen</a></code>, <code><a href="#topic+meigen_f">meigen_f</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spdep)
data(boston)
if (require("spData", quietly=TRUE)) {
########## Rook adjacency-based W
poly	    &lt;- st_read(system.file("shapes/boston_tracts.gpkg", package="spData")[1])
weig1	    &lt;- weigen( poly )

########## knn-based W
coords    &lt;- boston.c[,c("LON", "LAT")]
weig2	    &lt;- weigen( coords, type = "knn" )

########## Delaunay triangulation-based W
coords    &lt;- boston.c[,c("LON", "LAT")]
weig3	    &lt;- weigen( coords, type = "tri")

########## User-specified W
dmat      &lt;- as.matrix(dist(coords))
cmat 	    &lt;- exp(-dmat)
diag(cmat)&lt;- 0
weig4	    &lt;- weigen( cmat, threshold = 0 )
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
