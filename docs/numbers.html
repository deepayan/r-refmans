<!DOCTYPE html><html><head><title>Help for package numbers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {numbers}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agm'>
<p>Arithmetic-geometric Mean</p></a></li>
<li><a href='#bell'>
<p>Bell Numbers</p></a></li>
<li><a href='#Bernoulli numbers'>
<p>Bernoulli Numbers</p></a></li>
<li><a href='#Carmichael numbers'>
<p>Carmichael Numbers</p></a></li>
<li><a href='#catalan'>
<p>Catalan Numbers</p></a></li>
<li><a href='#cf2num'>
<p>Generalized Continous Fractions</p></a></li>
<li><a href='#chinese remainder theorem'><p>Chinese Remainder Theorem</p></a></li>
<li><a href='#collatz'>
<p>Collatz Sequences</p></a></li>
<li><a href='#contfrac'>
<p>Continued Fractions</p></a></li>
<li><a href='#coprime'><p>Coprimality</p></a></li>
<li><a href='#div'><p>Integer Division</p></a></li>
<li><a href='#divisors'>
<p>List of Divisors</p></a></li>
<li><a href='#dropletPi'>
<p>Droplet Algorithm for pi and e</p></a></li>
<li><a href='#egyptian_complete'>
<p>Egyptian Fractions - Complete Search</p></a></li>
<li><a href='#egyptian_methods'>
<p>Egyptian Fractions - Specialized Methods</p></a></li>
<li><a href='#eulersPhi'><p>Eulers's Phi Function</p></a></li>
<li><a href='#extGCD'><p>Extended Euclidean Algorithm</p></a></li>
<li><a href='#Farey Numbers'>
<p>Farey Approximation and Series</p></a></li>
<li><a href='#fibonacci'>
<p>Fibonacci and Lucas Series</p></a></li>
<li><a href='#GCD, LCM'><p>GCD and LCM Integer Functions</p></a></li>
<li><a href='#Hermite normal form'>
<p>Hermite Normal Form</p></a></li>
<li><a href='#iNthroot'>
<p>Integer N-th Root</p></a></li>
<li><a href='#isIntpower'>
<p>Powers of Integers</p></a></li>
<li><a href='#isNatural'>
<p>Natural Number</p></a></li>
<li><a href='#isPrime'><p>isPrime Property</p></a></li>
<li><a href='#isPrimroot'>
<p>Primitive Root Test</p></a></li>
<li><a href='#legendre_sym'><p>Legendre and Jacobi Symbol</p></a></li>
<li><a href='#mersenne'>
<p>Mersenne Numbers</p></a></li>
<li><a href='#miller_rabin'><p>Miller-Rabin Test</p></a></li>
<li><a href='#mod'><p>Modulo Operator</p></a></li>
<li><a href='#modinv, modsqrt'><p>Modular Inverse and Square Root</p></a></li>
<li><a href='#modlin'><p>Modular Linear Equation Solver</p></a></li>
<li><a href='#modlog'>
<p>Modular (or: Discrete) Logarithm</p></a></li>
<li><a href='#modpower'>
<p>Power Function modulo m</p></a></li>
<li><a href='#moebius'><p>Moebius Function</p></a></li>
<li><a href='#necklace'><p>Necklace and Bracelet Functions</p></a></li>
<li><a href='#nextPrime'><p>Next Prime</p></a></li>
<li><a href='#numbers-package'>
<p>Number-Theoretic Functions</p></a></li>
<li><a href='#omega'><p>Number of Prime Factors</p></a></li>
<li><a href='#ordpn'>
<p>Order in Faculty</p></a></li>
<li><a href='#Pascal triangle'>
<p>Pascal Triangle</p></a></li>
<li><a href='#periodicCF'>
<p>Periodic continued fraction</p></a></li>
<li><a href='#previousPrime'><p>Previous Prime</p></a></li>
<li><a href='#primeFactors'><p>Prime Factors</p></a></li>
<li><a href='#Primes'><p>Prime Numbers</p></a></li>
<li><a href='#primroot'>
<p>Primitive Root</p></a></li>
<li><a href='#pythagorean_triples'>
<p>Pythagorean Triples</p></a></li>
<li><a href='#quadratic_residues'><p>Quadratic Residues</p></a></li>
<li><a href='#rem'><p>Integer Remainder</p></a></li>
<li><a href='#Sigma'><p>Divisor Functions</p></a></li>
<li><a href='#solvePellsEq'>
<p>Solve Pell's Equation</p></a></li>
<li><a href='#Stern-Brocot'>
<p>Stern-Brocot Sequence</p></a></li>
<li><a href='#twinPrimes'><p>Twin Primes</p></a></li>
<li><a href='#zeck'>
<p>Zeckendorf Representation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Number-Theoretic Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Hans Werner Borchers</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hans W. Borchers &lt;hwborchers@googlemail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gmp (&ge; 0.5-1)</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Provides number-theoretic functions for factorization, prime 
    numbers, twin primes, primitive roots, modular logarithm and
    inverses, extended GCD, Farey series and continued fractions.
    Includes Legendre and Jacobi symbols, some divisor functions,
    Euler's Phi function, etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-22 18:59:22 UTC; hwb</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-23 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='agm'>
Arithmetic-geometric Mean
</h2><span id='topic+agm'></span>

<h3>Description</h3>

<p>The arithmetic-geometric mean of real or complex numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agm(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agm_+3A_a">a</code>, <code id="agm_+3A_b">b</code></td>
<td>
<p>real or complex numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arithmetic-geometric mean is defined as the common limit of the two
sequences <code class="reqn">a_{n+1} = (a_n + b_n)/2</code> and <code class="reqn">b_{n+1} = \sqrt(a_n b_n)</code>.
</p>


<h3>Value</h3>

<p>Returnes one value, the algebraic-geometric mean.
</p>


<h3>Note</h3>

<p>The calculation of the AGM is continued until the two values of <code>a</code> and
<code>b</code> are identical (in machine accuracy).
</p>


<h3>References</h3>

<p>Borwein, J. M., and P. B. Borwein (1998). Pi and the AGM: A Study in
Analytic Number Theory and Computational Complexity. Second, reprinted
Edition, A Wiley-interscience publication.
</p>


<h3>See Also</h3>

<p>Arithmetic, geometric, and harmonic mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Gauss constant
1 / agm(1, sqrt(2))  # 0.834626841674073

##  Calculate the (elliptic) integral 2/pi \int_0^1 dt / sqrt(1 - t^4)
f &lt;- function(t) 1 / sqrt(1-t^4)
2 / pi * integrate(f, 0, 1)$value
1 / agm(1, sqrt(2))

##  Calculate pi with quadratic convergence (modified AGM)
#   See algorithm 2.1 in Borwein and Borwein
y &lt;- sqrt(sqrt(2))
x &lt;- (y+1/y)/2
p &lt;- 2+sqrt(2)
for (i in 1:6){
  cat(format(p, digits=16), "\n")
  p &lt;- p * (1+x) / (1+y)
  s &lt;- sqrt(x)
  y &lt;- (y*s + 1/s) / (1+y)
  x &lt;- (s+1/s)/2
  }

## Not run: 
##  Calculate pi with arbitrary precision using the Rmpfr package
require("Rmpfr")
vpa &lt;- function(., d = 32) mpfr(., precBits = 4*d)
# Function to compute \pi to d decimal digits accuracy, based on the 
# algebraic-geometric mean, correct digits are doubled in each step.
agm_pi &lt;- function(d) {
    a &lt;- vpa(1, d)
    b &lt;- 1/sqrt(vpa(2, d))
    s &lt;- 1/vpa(4, d)
    p &lt;- 1
    n &lt;- ceiling(log2(d));
    for (k in 1:n) {
        c &lt;- (a+b)/2
        b &lt;- sqrt(a*b)
        s &lt;- s - p * (c-a)^2
        p &lt;- 2 * p
        a &lt;- c
    }
    return(a^2/s)
}
d &lt;- 64
pia &lt;- agm_pi(d)
print(pia, digits = d)
# 3.141592653589793238462643383279502884197169399375105820974944592
# 3.1415926535897932384626433832795028841971693993751058209749445923 exact

## End(Not run)
</code></pre>

<hr>
<h2 id='bell'>
Bell Numbers
</h2><span id='topic+bell'></span>

<h3>Description</h3>

<p>Generate Bell numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bell(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bell_+3A_n">n</code></td>
<td>
<p>integer, asking for the n-th Bell number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bell numbers, commonly denoted as <code class="reqn">B_n</code>, are defined as the number of
partitions of a set of <code>n</code> elements. They can easily be calculated
recursively.
</p>
<p>Bell numbers also appear as moments of probability distributions, for example
<code>B_n</code> is the n-th momentum of the Poisson distribution with mean 1.
</p>


<h3>Value</h3>

<p>A single integer, as long as <code>n&lt;=22</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapply(0:10, bell)
#      1      1      2      5     15     52    203    877   4140  21147 115975
</code></pre>

<hr>
<h2 id='Bernoulli+20numbers'>
Bernoulli Numbers
</h2><span id='topic+bernoulli_numbers'></span>

<h3>Description</h3>

<p>Generate the Bernoulli numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernoulli_numbers(n, big = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bernoulli+2B20numbers_+3A_n">n</code></td>
<td>
<p>integer; starting from 0.</p>
</td></tr>
<tr><td><code id="Bernoulli+2B20numbers_+3A_big">big</code></td>
<td>
<p>logical; shall double or GMP big numbers be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate the <code>n+1</code> Bernoulli numbers <code>B_0,B_1, ...,B_n</code>,
i.e. from 0 to <code>n</code>. We assume <code>B1 = +1/2</code>.
</p>
<p>With <code>big=FALSE</code> double integers up to <code>2^53-1</code> will be used,
with <code>big=TRUE</code> GMP big rationals (through the 'gmp' package).
<code>B_25</code> is the highest such number that can be expressed as an
integer in double float.
</p>


<h3>Value</h3>

<p>Returns a matrix with two columns, the first the numerator, the second
the denominator of the Bernoulli number.
</p>


<h3>References</h3>

<p>M. Kaneko. The Akiyama-Tanigawa algorithm for Bernoulli numbers.
Journal of Integer Sequences, Vol. 3, 2000.
</p>
<p>D. Harvey. A multimodular algorithm for computing Bernoulli numbers.
Mathematics of Computation, Vol. 79(272), pp. 2361-2370, Oct. 2010.
arXiv 0807.1347v2, Oct. 2018.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pascal_triangle">pascal_triangle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bernoulli_numbers(3); bernoulli_numbers(3, big=TRUE)
##                    Big Integer ('bigz') 4 x 2 matrix:
##      [,1] [,2]          [,1] [,2]
## [1,]    1    1     [1,] 1    1   
## [1,]    1    2     [2,] 1    2   
## [2,]    1    6     [3,] 1    6   
## [3,]    0    1     [4,] 0    1   

## Not run: 
bernoulli_numbers(24)[25,]
## [1] -236364091       2730

bernoulli_numbers(30, big=TRUE)[31,]
## Big Integer ('bigz') 1 x 2 matrix:
##      [,1]          [,2] 
## [1,] 8615841276005 14322

## End(Not run)
</code></pre>

<hr>
<h2 id='Carmichael+20numbers'>
Carmichael Numbers
</h2><span id='topic+carmichael'></span>

<h3>Description</h3>

<p>Checks whether a number is a Carmichael number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  carmichael(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Carmichael+2B20numbers_+3A_n">n</code></td>
<td>
<p>natural number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A natural number <code>n</code> is a Carmichael number if it is a Fermat
pseudoprime for every <code>a</code>, that is <code>a^(n-1) = 1 mod n</code>, but
is composite, not prime.
</p>
<p>Here the Korselt criterion is used to tell whether a number <code>n</code> is
a Carmichael number.
</p>


<h3>Value</h3>

<p>Returns TRUE or FALSE
</p>


<h3>Note</h3>

<p>There are infinitely many Carmichael numbers, specifically there should
be at least <code>n^(2/7)</code> Carmichael numbers up to n (for n large enough).
</p>


<h3>References</h3>

<p>R. Crandall and C. Pomerance. Prime Numbers - A Computational Perspective.
Second Edition, Springer Science+Business Media, New York 2005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+primeFactors">primeFactors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>carmichael(561)  # TRUE

## Not run: 
for (n in 1:100000)
    if (carmichael(n)) cat(n, '\n')
##    561     2821    15841    52633 
##   1105     6601    29341    62745 
##   1729     8911    41041    63973 
##   2465    10585    46657    75361 

## End(Not run)
</code></pre>

<hr>
<h2 id='catalan'>
Catalan Numbers
</h2><span id='topic+catalan'></span>

<h3>Description</h3>

<p>Generate Catalan numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catalan(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catalan_+3A_n">n</code></td>
<td>
<p>integer, asking for the n-th Catalan number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Catalan numbers, commonly denoted as <code class="reqn">C_n</code>, are defined as
</p>
<p style="text-align: center;"><code class="reqn">C_n = \frac{1}{n+1} {2 n \choose n}</code>
</p>

<p>and occur regularly in all kinds of enumeration problems.
</p>


<h3>Value</h3>

<p>A single integer, as long as <code>n&lt;=30</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- numeric(10)
for (i in 1:10) C[i] &lt;- catalan(i)
C[5]                                #=&gt; 42
</code></pre>

<hr>
<h2 id='cf2num'>
Generalized Continous Fractions
</h2><span id='topic+cf2num'></span>

<h3>Description</h3>

<p>Evaluate a generalized continuous fraction as an alternating sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf2num(a, b = 1, a0 = 0, finite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf2num_+3A_a">a</code></td>
<td>
<p>numeric vector of length greater than 2.</p>
</td></tr>
<tr><td><code id="cf2num_+3A_b">b</code></td>
<td>
<p>numeric vector of length 1 or the same length as a.</p>
</td></tr>
<tr><td><code id="cf2num_+3A_a0">a0</code></td>
<td>
<p>absolute term, integer part of the continuous fraction.</p>
</td></tr>
<tr><td><code id="cf2num_+3A_finite">finite</code></td>
<td>
<p>logical; shall Algorithm 1 be applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the numerical value of (simple or generalized) continued
fractions of the form
</p>
<p style="text-align: center;"><code class="reqn"> a_0 + \frac{b1}{a1+} \frac{b2}{a2+} \frac{b3}{a3+...} </code>
</p>

<p>by converting it into an alternating sum and then applying the
accelleration Algorithm 1 of Cohen et al. (2000).
</p>
<p>The argument <code class="reqn">b</code> is by default set to <code class="reqn">b = (1, 1, ...)</code>,
that is the continued fraction is treated in its simple form.
</p>
<p>With <code>finite=TRUE</code> the accelleration is turned off.
</p>


<h3>Value</h3>

<p>Returns a numerical value, an approximation of the continued fraction.
</p>


<h3>Note</h3>

<p>This function is <em>not</em> vectorized.
</p>


<h3>References</h3>

<p>H. Cohen, F. R. Villegas, and Don Zagier (2000).
Experimental Mathematics, Vol. 9, No. 1, pp. 3-12.
&lt;www.emis.de/journals/EM&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contfrac">contfrac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Examples from Wolfram Mathworld
print(cf2num(1:25), digits=16)  # 0.6977746579640077, eps()

a = 2*(1:25) + 1; b = 2*(1:25); a0 = 1  # 1/(sqrt(exp(1))-1)
cf2num(a, b, a0)                        # 1.541494082536798

a &lt;- b &lt;- 1:25                          # 1/(exp(1)-1)
cf2num(a, b)                            # 0.5819767068693286

a &lt;- rep(1, 100); b &lt;- 1:100; a0 &lt;- 1   # 1.5251352761609812
cf2num(a, b, a0, finite = FALSE)        # 1.525135276161128
cf2num(a, b, a0, finite = TRUE)         # 1.525135259240266
</code></pre>

<hr>
<h2 id='chinese+20remainder+20theorem'>Chinese Remainder Theorem</h2><span id='topic+chinese'></span>

<h3>Description</h3>

<p>Executes the Chinese Remainder Theorem (CRT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chinese(a, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chinese+2B20remainder+2B20theorem_+3A_a">a</code></td>
<td>
<p>sequence of integers, of the same length as <code>m</code>.</p>
</td></tr>
<tr><td><code id="chinese+2B20remainder+2B20theorem_+3A_m">m</code></td>
<td>
<p>sequence of natural numbers, relatively prime to each other.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Chinese Remainder Theorem says that given integers <code class="reqn">a_i</code> and
natural numbers <code class="reqn">m_i</code>, relatively prime (i.e., coprime) to each other,
there exists a unique solution <code class="reqn">x = x_i</code> such that the following
system of linear modular equations is satisfied:
</p>
<p style="text-align: center;"><code class="reqn">x_i = a_i \, \mod \, m_i, \quad 1 \le i \le n </code>
</p>

<p>More generally, a solution exists if the following condition is satisfied:
</p>
<p style="text-align: center;"><code class="reqn">a_i = a_j \, \mod \, \gcd(m_i, m_j)</code>
</p>

<p>This version of the CRT is not yet implemented.
</p>


<h3>Value</h3>

<p>Returns th (unique) solution of the system of modular equalities as an
integer between <code>0</code> and <code>M=prod(m)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extGCD">extGCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- c(3, 4, 5)
a &lt;- c(2, 3, 1)
chinese(a, m)    #=&gt; 11

# ... would be sufficient
# m &lt;- c(50, 210, 154)
# a &lt;- c(44,  34, 132)
# x = 4444
</code></pre>

<hr>
<h2 id='collatz'>
Collatz Sequences
</h2><span id='topic+collatz'></span>

<h3>Description</h3>

<p>Generates Collatz sequences with n -&gt; k*n+l for n odd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collatz(n, k = 3, l = 1, short = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collatz_+3A_n">n</code></td>
<td>
<p>integer to start the Collatz sequence with.</p>
</td></tr>
<tr><td><code id="collatz_+3A_k">k</code>, <code id="collatz_+3A_l">l</code></td>
<td>
<p>parameters for computing <code>k*n+l</code>.</p>
</td></tr>
<tr><td><code id="collatz_+3A_short">short</code></td>
<td>
<p>logical, abbreviate stps with <code>(k*n+l)/2</code></p>
</td></tr>
<tr><td><code id="collatz_+3A_check">check</code></td>
<td>
<p>logical, check for nontrivial cycles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>n, k, l</code> generates iterative sequences starting with
<code>n</code> and calculating the next number as <code>n/2</code> if <code>n</code> is
even and <code>k*n+l</code> if <code>n</code> is odd. It stops automatically when
1 is reached.
</p>
<p>The default parameters <code>k=3, l=1</code> generate the classical Collatz
sequence. The Collatz conjecture says that every such sequences will end
in the trivial cycle <code>...,4,2,1</code>. For other parameters this does not
necessarily happen.
</p>
<p><code>k</code> and <code>l</code> are not allowed to be both even or both odd &ndash; to make
<code>k*n+l</code> even for <code>n</code> odd. Option <code>short=TRUE</code> calculates 
<code>(k*n+l)/2</code> when <code>n</code> is odd (as <code>k*n+l</code> is even in this case),
shortening the sequence a bit.
</p>
<p>With option <code>check=TRUE</code> will check for nontrivial cycles, stopping
with the first integer that repeats in the sequence. The check is disabled
for the default parameters in the light of the Collatz conjecture.
</p>


<h3>Value</h3>

<p>Returns the integer sequence generated from the iterative rule.
</p>
<p>Sends out a message if a nontrivial cycle was found (i.e. the sequence 
is not ending with 1 and end in an infinite cycle). Throws an error if
an integer overflow is detected.
</p>


<h3>Note</h3>

<p>The Collatz or <code>3n+1</code>-conjecture has been experimentally verified
for all start numbers <code>n</code> up to <code>10^20</code> at least.
</p>


<h3>References</h3>

<p>See the Wikipedia entry on the 'Collatz Conjecture'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collatz(7)  # n -&gt; 3n+1
## [1]  7 22 11 34 17 52 26 13 40 20 10  5 16  8  4  2  1
collatz(9, short = TRUE)
## [1]  9 14  7 11 17 26 13 20 10  5  8  4  2  1

collatz(7, l = -1)  # n -&gt; 3n-1
## Found a non-trivial cycle for n = 7 !
##     [1]  7 20 10  5 14  7

## Not run: 
collatz(5, k = 7, l = 1)  # n -&gt; 7n+1
## [1]  5 36 18  9 64 32 16  8  4  2  1
collatz(5, k = 7, l = -1)  # n -&gt; 7n-1
## Info: 5 --&gt; 1.26995e+16 too big after 280 steps.
## Error in collatz(5, k = 7, l = -1) : 
##     Integer overflow, i.e. greater than 2^53-1

## End(Not run)
</code></pre>

<hr>
<h2 id='contfrac'>
Continued Fractions
</h2><span id='topic+contfrac'></span>

<h3>Description</h3>

<p>Evaluate a continued fraction or generate one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contfrac(x, tol = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contfrac_+3A_x">x</code></td>
<td>
<p>a numeric scalar or vector.</p>
</td></tr>
<tr><td><code id="contfrac_+3A_tol">tol</code></td>
<td>
<p>tolerance; default <code>1e-12</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a scalar its continued fraction will be generated up to
the accuracy prescribed in <code>tol</code>. If it is of length greater 1, the
function assumes this to be a continued fraction and computes its value
and convergents.
</p>
<p>The continued fraction <code class="reqn">[b_0; b_1, \ldots, b_{n-1}]</code> is assumed to be
finite and neither periodic nor infinite. For implementation uses the
representation of continued fractions through 2-by-2 matrices
(i.e. Wallis' recursion formula from 1644).
</p>


<h3>Value</h3>

<p>If <code>x</code> is a scalar, it will return a list with components <code>cf</code>
the continued fraction as a vector, <code>rat</code> the rational approximation,
and <code>prec</code> the difference between the value and this approximation.
</p>
<p>If <code>x</code> is a vector, the continued fraction, then it will return a list
with components <code>f</code> the numerical value, <code>p</code> and <code>q</code> the
convergents, and <code>prec</code> an estimated precision.
</p>


<h3>Note</h3>

<p>This function is <em>not</em> vectorized.
</p>


<h3>References</h3>

<p>Hardy, G. H., and E. M. Wright (1979). An Introduction to the Theory of
Numbers. Fifth Edition, Oxford University Press, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cf2num">cf2num</a></code>, <code><a href="#topic+ratFarey">ratFarey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>contfrac(pi)
contfrac(c(3, 7, 15, 1))        # rational Approx: 355/113

contfrac(0.555)                 #  0  1  1  4 22
contfrac(c(1, rep(2, 25)))      #  1.414213562373095, sqrt(2)
</code></pre>

<hr>
<h2 id='coprime'>Coprimality</h2><span id='topic+coprime'></span>

<h3>Description</h3>

<p>Determine whether two numbers are coprime, i.e. do not have a common
prime divisor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coprime(n,m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coprime_+3A_n">n</code>, <code id="coprime_+3A_m">m</code></td>
<td>
<p>integer scalars</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two numbers are coprime iff their greatest common divisor is 1.
</p>


<h3>Value</h3>

<p>Logical, being TRUE if the numbers are coprime.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GCD">GCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coprime(46368, 75025)  # Fibonacci numbers are relatively prime to each other
coprime(1001, 1334)
</code></pre>

<hr>
<h2 id='div'>Integer Division</h2><span id='topic+div'></span>

<h3>Description</h3>

<p>Integer division.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>div(n, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="div_+3A_n">n</code></td>
<td>
<p>numeric vector (preferably of integers)</p>
</td></tr>
<tr><td><code id="div_+3A_m">m</code></td>
<td>
<p>integer vector (positive, zero, or negative)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>div(n, m)</code> is integer division, that is discards the fractional part, 
with the same effect as <code>n %/% m</code>.
It can be defined as <code>floor(n/m)</code>.
</p>


<h3>Value</h3>

<p>A numeric (integer) value or vector/matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mod">mod</a></code>, <code><a href="#topic+rem">rem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>div(c(-5:5), 5)
div(c(-5:5), -5)
div(c(1, -1), 0)  #=&gt; Inf -Inf
div(0,c(0, 1))    #=&gt; NaN  0      
</code></pre>

<hr>
<h2 id='divisors'>
List of Divisors
</h2><span id='topic+divisors'></span>

<h3>Description</h3>

<p>Generates a list of divisors of an integer number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisors(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divisors_+3A_n">n</code></td>
<td>
<p>integer whose divisors will be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of all divisors of an integer <code>n</code> will be calculated
and returned in ascending order, including 1 and the number itself.
For <code>n&gt;=1000</code> the list of prime factors of <code>n</code> will be
used, for smaller <code>n</code> a total search is applied.
</p>


<h3>Value</h3>

<p>Returns a vector integers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+primeFactors">primeFactors</a></code>, <code><a href="#topic+Sigma">Sigma</a></code>, <code><a href="#topic+tau">tau</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>divisors(1)          # 1
divisors(2)          # 1 2
divisors(2^5)        # 1  2  4  8 16 32
divisors(1000)       # 1  2  4  5  8 10 ... 100 125 200 250 500 1000
divisors(1001)       # 1  7 11 13 77 91 143 1001
</code></pre>

<hr>
<h2 id='dropletPi'>
Droplet Algorithm for pi and e
</h2><span id='topic+dropletPi'></span><span id='topic+dropletE'></span>

<h3>Description</h3>

<p>Generates digits for pi resp. the Euler number e.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropletPi(n)
dropletE(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropletPi_+3A_n">n</code></td>
<td>
<p>number of digits after the decimal point; should not exceed 1000
much as otherwise it will be <em>very</em> slow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a formula discovered by S. Rabinowitz and S. Wagon.
</p>
<p>The droplet algorithm for pi uses the Euler transform of the alternating
Leibniz series and the so-called &ldquo;radix conversion&quot;.
</p>


<h3>Value</h3>

<p>String containing &ldquo;3.1415926...&quot; resp. &ldquo;2.718281828...&quot; with
<code>n</code> digits after the decimal point (i.e., internal decimal places).
</p>


<h3>References</h3>

<p>Borwein, J., and K. Devlin (2009). The Computer as Crucible: An Introduction
to Experimental Mathematics. A K Peters, Ltd.
</p>
<p>Arndt, J., and Ch. Haenel (2000). Pi &ndash; Algorithmen, Computer, Arithmetik.
Springer-Verlag, Berlin Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Example
dropletE(20)                    # [1] "2.71828182845904523536"
print(exp(1), digits=20)        # [1]  2.7182818284590450908

dropletPi(20)                   # [1] "3.14159265358979323846"
print(pi, digits=20)            # [1]  3.141592653589793116

## Not run: 
E &lt;- dropletE(1000)
table(strsplit(substring(E, 3, 1002), ""))
#    0   1   2   3   4   5   6   7   8   9 
#  100  96  97 109 100  85  99  99 103 112

Pi &lt;- dropletPi(1000)
table(strsplit(substring(Pi, 3, 1002), ""))
#   0   1   2   3   4   5   6   7   8   9 
#  93 116 103 102  93  97  94  95 101 106 
## End(Not run)
</code></pre>

<hr>
<h2 id='egyptian_complete'>
Egyptian Fractions - Complete Search
</h2><span id='topic+egyptian_complete'></span>

<h3>Description</h3>

<p>Generate all Egyptian fractions of length 2 and 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  egyptian_complete(a, b, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egyptian_complete_+3A_a">a</code>, <code id="egyptian_complete_+3A_b">b</code></td>
<td>
<p>integers, a != 1, a &lt; b and a, b relatively prime.</p>
</td></tr>
<tr><td><code id="egyptian_complete_+3A_show">show</code></td>
<td>
<p>logical; shall solutions found be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a rational number <code>0 &lt; a/b &lt; 1</code>, generates all Egyptian fractions
of length 2 and three, that is finds integers <code>x1, x2, x3</code> such that
</p>
<p><code>a/b = 1/x1 + 1/x2</code><br />
<code>a/b = 1/x1 + 1/x2 + 1/x3</code>.
</p>


<h3>Value</h3>

<p>All solutions found will be printed to the console if <code>show=TRUE</code>;
returns invisibly the number of solutions found. 
</p>


<h3>References</h3>

<p><a href="https://www.ics.uci.edu/~eppstein/numth/egypt/">https://www.ics.uci.edu/~eppstein/numth/egypt/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+egyptian_methods">egyptian_methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>egyptian_complete(6, 7)         # 1/2 + 1/3 + 1/42
egyptian_complete(8, 11)        # no solution with 2 or 3 fractions

# TODO
# 2/9 = 1/9 + 1/10 + 1/90       # is not recognized, as similar cases,
                                # because 1/n is not considered in m/n.
</code></pre>

<hr>
<h2 id='egyptian_methods'>
Egyptian Fractions - Specialized Methods
</h2><span id='topic+egyptian_methods'></span>

<h3>Description</h3>

<p>Generate Egyptian fractions with specialized methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  egyptian_methods(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egyptian_methods_+3A_a">a</code>, <code id="egyptian_methods_+3A_b">b</code></td>
<td>
<p>integers, a != 1, a &lt; b and a, b relatively prime.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a rational number <code>0 &lt; a/b &lt; 1</code>, generates Egyptian fractions
that is finds integers <code>x1, x2, ..., xk</code> such that
</p>
<p><code>a/b = 1/x1 + 1/x2 + ... + 1/xk</code>
</p>
<p>using the following methods:
</p>

<ul>
<li><p>&lsquo;greedy&rsquo;
</p>
</li>
<li><p>Fibonacci-Sylvester
</p>
</li>
<li><p>Golomb (same as with Farey sequences)
</p>
</li>
<li><p>continued fractions (not yet implemented)
</p>
</li></ul>



<h3>Value</h3>

<p>No return value, all solutions found will be printed to the console.
</p>


<h3>References</h3>

<p><a href="https://www.ics.uci.edu/~eppstein/numth/egypt/">https://www.ics.uci.edu/~eppstein/numth/egypt/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+egyptian_complete">egyptian_complete</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>egyptian_methods(8, 11)
# 8/11 = 1/2 +  1/5 + 1/37 + 1/4070  (Fibonacci-Sylvester)
# 8/11 = 1/2 +  1/6 + 1/21 + 1/77    (Golomb-Farey)

# Other solutions
# 8/11 = 1/2 +  1/8 + 1/11 + 1/88
# 8/11 = 1/2 + 1/12 + 1/22 + 1/121
</code></pre>

<hr>
<h2 id='eulersPhi'>Eulers's Phi Function</h2><span id='topic+eulersPhi'></span>

<h3>Description</h3>

<p>Euler's Phi function (aka Euler's &lsquo;totient&rsquo; function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eulersPhi(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eulersPhi_+3A_n">n</code></td>
<td>
<p>Positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>phi</code> function is defined to be the number of positive integers
less than or equal to <code>n</code> that are <em>coprime</em> to <code>n</code>, i.e.
have no common factors other than 1.
</p>


<h3>Value</h3>

<p>Natural number, the number of coprime integers <code>&lt;= n</code>.
</p>


<h3>Note</h3>

<p>Works well up to <code>10^9</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+primeFactors">primeFactors</a></code>, <code><a href="#topic+Sigma">Sigma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eulersPhi(9973)  == 9973 - 1                       # for prime numbers
eulersPhi(3^10)  == 3^9 * (3 - 1)                  # for prime powers
eulersPhi(12*35) == eulersPhi(12) * eulersPhi(35)  # TRUE if coprime

## Not run: 
x &lt;- 1:100; y &lt;- sapply(x, eulersPhi)
plot(1:100, y, type="l", col="blue",
               xlab="n", ylab="phi(n)", main="Euler's totient function")
points(1:100, y, col="blue", pch=20)
grid()
## End(Not run)
</code></pre>

<hr>
<h2 id='extGCD'>Extended Euclidean Algorithm</h2><span id='topic+extGCD'></span>

<h3>Description</h3>

<p>The extended Euclidean algorithm computes the greatest common divisor and
solves Bezout's identity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extGCD(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extGCD_+3A_a">a</code>, <code id="extGCD_+3A_b">b</code></td>
<td>
<p>integer scalars</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extended Euclidean algorithm not only computes the greatest common
divisor <code class="reqn">d</code> of <code class="reqn">a</code> and <code class="reqn">b</code>, but also two numbers <code class="reqn">n</code> and 
<code class="reqn">m</code> such that <code class="reqn">d = n a + m b</code>.
</p>
<p>This algorithm provides an easy approach to computing the modular inverse.
</p>


<h3>Value</h3>

<p>a numeric vector of length three, <code>c(d, n, m)</code>, where <code>d</code> is the
greatest common divisor of <code>a</code> and <code>b</code>, and <code>n</code> and <code>m</code>
are integers such that <code>d = n*a + m*b</code>.
</p>


<h3>Note</h3>

<p>There is also a shorter, more elegant recursive version for the extended
Euclidean algorithm. For R the procedure suggested by Blankinship appeared
more appropriate.
</p>


<h3>References</h3>

<p>Blankinship, W. A. &ldquo;A New Version of the Euclidean Algorithm.&quot;
Amer. Math. Monthly 70, 742-745, 1963.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GCD">GCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extGCD(12, 10)
extGCD(46368, 75025)  # Fibonacci numbers are relatively prime to each other
</code></pre>

<hr>
<h2 id='Farey+20Numbers'>
Farey Approximation and Series
</h2><span id='topic+ratFarey'></span><span id='topic+farey_seq'></span>

<h3>Description</h3>

<p>Rational approximation of real numbers through Farey fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratFarey(x, n, upper = TRUE)

farey_seq(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Farey+2B20Numbers_+3A_x">x</code></td>
<td>
<p>real number.</p>
</td></tr>
<tr><td><code id="Farey+2B20Numbers_+3A_n">n</code></td>
<td>
<p>integer, highest allowed denominator in a rational approximation.</p>
</td></tr>
<tr><td><code id="Farey+2B20Numbers_+3A_upper">upper</code></td>
<td>
<p>logical; shall the Farey fraction be grater than <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rational approximation of real numbers through Farey fractions,
i.e. find for <code>x</code> the nearest fraction in the Farey series of
rational numbers with denominator not larger than <code>n</code>.
</p>
<p><code>farey_seq(n)</code> generates the full Farey sequence of rational
numbers with denominators not larger than <code>n</code>. Returns the
fractions as 'big rational' class in 'gmp'.
</p>


<h3>Value</h3>

<p>Returns a vector with two natural numbers, nominator and denominator.
</p>


<h3>Note</h3>

<p><code>farey_seq</code> is very slow even for <code>n &gt; 40</code>, due to the
handling of rational numbers as 'big rationals'.
</p>


<h3>References</h3>

<p>Hardy, G. H., and E. M. Wright (1979). An Introduction to the Theory of
Numbers. Fifth Edition, Oxford University Press, New York.
</p>


<h3>See Also</h3>

<p><code>contFrac</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ratFarey(pi, 100)                          # 22/7    0.0013
ratFarey(pi, 100, upper = FALSE)           # 311/99  0.0002
ratFarey(-pi, 100)                         # -22/7
ratFarey(pi - 3, 70)                       # pi ~= 3 + (3/8)^2
ratFarey(pi, 1000)                         # 355/113
ratFarey(pi, 10000, upper = FALSE)         # id.
ratFarey(pi, 1e5, upper = FALSE)           # 312689/99532 - pi ~= 3e-11

ratFarey(4/5, 5)                           # 4/5
ratFarey(4/5, 4)                           # 1/1
ratFarey(4/5, 4, upper = FALSE)            # 3/4
</code></pre>

<hr>
<h2 id='fibonacci'>
Fibonacci and Lucas Series
</h2><span id='topic+fibonacci'></span><span id='topic+lucas'></span>

<h3>Description</h3>

<p>Generates single Fibonacci numbers or a Fibonacci sequence;
or generates a Lucas series based on the Fibonacci series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fibonacci(n, sequence = FALSE)
lucas(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fibonacci_+3A_n">n</code></td>
<td>
<p>an integer.</p>
</td></tr>
<tr><td><code id="fibonacci_+3A_sequence">sequence</code></td>
<td>
<p>logical; default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates the <code>n</code>-th Fibonacci number, or the whole Fibonacci sequence
from the first to the <code>n</code>-th number; starts with (1, 1, 2, 3, ...).
Generates only single Lucas numbers. The Lucas series can be extenden to
the left and starts as (... -4, 3, -1, 2, 1, 3, 4, ...).
</p>
<p>The recursive version is too slow for values <code>n&gt;=30</code>. Therefore, an
iterative approach is used. For numbers <code>n &gt; 78</code> Fibonacci numbers
cannot be represented exactly in R as integers (<code>&gt;2^53-1</code>).
</p>


<h3>Value</h3>

<p>A single integer, or a vector of integers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fibonacci(0)                            # 0
fibonacci(2)                            # 1
fibonacci(2, sequence = TRUE)           # 1 1
fibonacci(78)                           # 8944394323791464 &lt; 9*10^15

lucas(0)                                # 2
lucas(2)                                # 3
lucas(76)                               # 7639424778862807

# Golden ratio
F &lt;- fibonacci(25, sequence = TRUE)     # ... 46368 75025
f25 &lt;- F[25]/F[24]                      # 1.618034
phi &lt;- (sqrt(5) + 1)/2
abs(f25 - phi)                          # 2.080072e-10

# Fibonacci numbers w/o iteration
  fibo &lt;- function(n) {
    phi &lt;- (sqrt(5) + 1)/2
    fib &lt;- (phi^n - (1-phi)^n) / (2*phi - 1)
    round(fib)
  }
fibo(30:33)                             # 832040 1346269 2178309 3524578

for (i in -8:8) cat(lucas(i), " ")
# 47  -29  18  -11  7  -4  3  -1  2  1  3  4  7  11  18  29  47

# Lucas numbers w/o iteration
  luca &lt;- function(n) {
    phi &lt;- (sqrt(5) + 1)/2
    luc &lt;- phi^n + (1-phi)^n
    round(luc)
  }
luca(0:10)
# [1]   2   1   3   4   7  11  18  29  47  76 123

# Lucas primes
#   for (j in 0:76) {
#     l &lt;- lucas(j)
#     if (isPrime(l)) cat(j, "\t", l, "\n")
#   }
# 0   2
# 2   3
# ...
# 71  688846502588399
</code></pre>

<hr>
<h2 id='GCD+2C+20LCM'>GCD and LCM Integer Functions</h2><span id='topic+GCD'></span><span id='topic+LCM'></span><span id='topic+mGCD'></span><span id='topic+mLCM'></span>

<h3>Description</h3>

<p>Greatest common divisor and least common multiple
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GCD(n, m)
LCM(n, m)

mGCD(x)
mLCM(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GCD+2B2C+2B20LCM_+3A_n">n</code>, <code id="GCD+2B2C+2B20LCM_+3A_m">m</code></td>
<td>
<p>integer scalars.</p>
</td></tr>
<tr><td><code id="GCD+2B2C+2B20LCM_+3A_x">x</code></td>
<td>
<p>a vector of integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation based on the Euclidean algorithm without using the extended
version.
</p>
<p><code>mGCD</code> (the multiple GCD) computes the greatest common divisor for
all numbers in the integer vector <code>x</code> together.
</p>


<h3>Value</h3>

<p>A numeric (integer) value.
</p>


<h3>Note</h3>

<p>The following relation is always true:
</p>
<p><code>n * m = GCD(n, m) * LCM(n, m)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extGCD">extGCD</a></code>, <code><a href="#topic+coprime">coprime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GCD(12, 10)
GCD(46368, 75025)  # Fibonacci numbers are relatively prime to each other

LCM(12, 10)
LCM(46368, 75025)  # = 46368 * 75025

mGCD(c(2, 3, 5, 7) * 11)
mGCD(c(2*3, 3*5, 5*7))
mLCM(c(2, 3, 5, 7) * 11)
mLCM(c(2*3, 3*5, 5*7))
</code></pre>

<hr>
<h2 id='Hermite+20normal+20form'>
Hermite Normal Form
</h2><span id='topic+hermiteNF'></span>

<h3>Description</h3>

<p>Hermite normal form over integers (in column-reduced form).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hermiteNF(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hermite+2B20normal+2B20form_+3A_a">A</code></td>
<td>
<p>integer matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>mxn</code>-matrix of rank <code>r</code> with integer entries is said to be
in Hermite normal form if:
</p>
<p>(i) the first r columns are nonzero, the other columns are all zero;<br />
(ii) The first r diagonal elements are nonzero and d[i-1] divides d[i]
for i = 2,...,r .<br />
(iii) All entries to the left of nonzero diagonal elements are non-negative<br />
and strictly less than the corresponding diagonal entry.
</p>
<p>The lower-triangular Hermite normal form of A is obtained by the following 
three types of column operations:
</p>
<p>(i) exchange two columns<br />
(ii) multiply a column by -1<br />
(iii) Add an integral multiple of a column to another column
</p>
<p>U is the unitary matrix such that AU = H, generated by these operations.
</p>


<h3>Value</h3>

<p>List with two matrices, the Hermite normal form <code>H</code> and the unitary
matrix <code>U</code>.
</p>


<h3>Note</h3>

<p>Another normal form often used in this context is the Smith normal form.
</p>


<h3>References</h3>

<p>Cohen, H. (1993). A Course in Computational Algebraic Number Theory.
Graduate Texts in Mathematics, Vol. 138, Springer-Verlag, Berlin, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chinese">chinese</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 4; m &lt;- 5
A = matrix(c(
 9,  6,  0, -8,  0,
-5, -8,  0,  0,  0,
 0,  0,  0,  4,  0,
 0,  0,  0, -5,  0), n, m, byrow = TRUE)
 
Hnf &lt;- hermiteNF(A); Hnf
# $H =  1    0    0    0    0
#       1    2    0    0    0
#      28   36   84    0    0
#     -35  -45 -105    0    0
# $U = 11   14   32    0    0
#      -7   -9  -20    0    0
#       0    0    0    1    0
#       7    9   21    0    0
#       0    0    0    0    1

r &lt;- 3                  # r = rank(H)
H &lt;- Hnf$H; U &lt;- Hnf$U
all(H == A %*% U)       #=&gt; TRUE

##  Example: Compute integer solution of A x = b
#   H = A * U, thus H * U^-1 * x = b, or H * y = b
b &lt;- as.matrix(c(-11, -21, 16, -20))

y &lt;- numeric(m)
y[1] &lt;- b[1] / H[1, 1]
for (i in 2:r)
    y[i] &lt;- (b[i] - sum(H[i, 1:(i-1)] * y[1:(i-1)])) / H[i, i]
# special solution:
xs &lt;- U %*% y         #  1 2 0 4 0

# and the general solution is xs + U * c(0, 0, 0, a, b), or
# in other words the basis are the m-r vectors c(0,...,0, 1, ...).
# If the special solution is not integer, there are no integer solutions.
</code></pre>

<hr>
<h2 id='iNthroot'>
Integer N-th Root
</h2><span id='topic+iNthroot'></span>

<h3>Description</h3>

<p>Determine the integer <code>n</code>-th root of .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  iNthroot(p, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iNthroot_+3A_p">p</code></td>
<td>
<p>any positive number.</p>
</td></tr>
<tr><td><code id="iNthroot_+3A_n">n</code></td>
<td>
<p>a natural number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the highest natural number below the <code>n</code>-th root of
<code>p</code> in a more integer based way than simply <code>floor(p^{1/n})</code>.
</p>


<h3>Value</h3>

<p>An integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iNthroot(0.5, 6)    # 0
iNthroot(1, 6)      # 1
iNthroot(5^6, 6)    # 5
iNthroot(5^6-1, 6)  # 4
## Not run: 
# Define a function that tests whether 
isNthpower &lt;- function(p, n) {
    q &lt;- iNthroot(p, n)
    if (q^n == p) { return(TRUE)
    } else { return(FALSE) }
  }
  
## End(Not run)
</code></pre>

<hr>
<h2 id='isIntpower'>
Powers of Integers
</h2><span id='topic+isIntpower'></span><span id='topic+isSquare'></span><span id='topic+isSquarefree'></span>

<h3>Description</h3>

<p>Determine whether <code>p</code> is the power of an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isIntpower(p)

  isSquare(p)
  isSquarefree(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isIntpower_+3A_p">p</code></td>
<td>
<p>any integer number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isIntpower(p)</code> determines whether <code>p</code> is the power of an integer
and returns a tupel <code>(n, m)</code> such that <code>p=n^m</code> where <code>m</code> is
as small as possible. E.g., if <code>p</code> is prime it returns <code>c(p,1)</code>.
</p>
<p><code>isSquare(p)</code> determines whether <code>p</code> is the square of an integer;
and <code>isSquarefree(p)</code> determines if <code>p</code> contains a square number
as a divisor.
</p>


<h3>Value</h3>

<p>A 2-vector of integers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isIntpower(1)    #  1  1
isIntpower(15)   # 15  1
isIntpower(17)   # 17  1
isIntpower(64)   #  8  2
isIntpower(36)   #  6  2
isIntpower(100)  # 10  2
## Not run: 
  for (p in 5^7:7^5) {
      pp &lt;- isIntpower(p)
      if (pp[2] != 1) cat(p, ":\t", pp, "\n")
  }
## End(Not run)
</code></pre>

<hr>
<h2 id='isNatural'>
Natural Number
</h2><span id='topic+isNatural'></span>

<h3>Description</h3>

<p>Natural number type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isNatural(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNatural_+3A_n">n</code></td>
<td>
<p>any numeric number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>TRUE</code> for natural (or: whole) numbers between 1 and 2^53-1.
</p>


<h3>Value</h3>

<p>Boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IsNatural &lt;- Vectorize(isNatural)
IsNatural(c(-1, 0, 1, 5.1, 10, 2^53-1, 2^53, Inf))  # isNatural(NA) ?
</code></pre>

<hr>
<h2 id='isPrime'>isPrime Property</h2><span id='topic+isPrime'></span>

<h3>Description</h3>

<p>Vectorized version, returning for a vector or matrix of positive integers
a vector of the same size containing 1 for the elements that are prime and
0 otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isPrime(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isPrime_+3A_x">x</code></td>
<td>
<p>vector or matrix of nonnegative integers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an array of positive integers returns an array of the same size
of 0 and 1, where the i indicates a prime number in the same position.
</p>


<h3>Value</h3>

<p>array of elements 0, 1 with 1 indicating prime numbers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+primeFactors">primeFactors</a>, <a href="#topic+Primes">Primes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- matrix(1:10, nrow=10, ncol=10, byrow=TRUE)
  x * isPrime(x)

  # Find first prime number octett:
  octett &lt;- c(0, 2, 6, 8, 30, 32, 36, 38) - 19
  while (TRUE) {
      octett &lt;- octett + 210
      if (all(isPrime(octett))) {
          cat(octett, "\n", sep="  ")
          break
      }
  }
</code></pre>

<hr>
<h2 id='isPrimroot'>
Primitive Root Test
</h2><span id='topic+isPrimroot'></span>

<h3>Description</h3>

<p>Determine whether <code>g</code> generates the multiplicative group
modulo p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isPrimroot(g, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isPrimroot_+3A_g">g</code></td>
<td>
<p>integer greater 2 (and smaller than p).</p>
</td></tr>
<tr><td><code id="isPrimroot_+3A_p">p</code></td>
<td>
<p>prime number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Test is done by determining the order of <code>g</code> modulo <code>p</code>.
</p>


<h3>Value</h3>

<p>Returns TRUE or FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isPrimroot(2, 7)
isPrimroot(2, 71)
isPrimroot(7, 71)
</code></pre>

<hr>
<h2 id='legendre_sym'>Legendre and Jacobi Symbol</h2><span id='topic+legendre_sym'></span><span id='topic+jacobi_sym'></span>

<h3>Description</h3>

<p>Legendre and Jacobi Symbol for quadratic residues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendre_sym(a, p)

jacobi_sym(a, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legendre_sym_+3A_a">a</code>, <code id="legendre_sym_+3A_n">n</code></td>
<td>
<p>integers.</p>
</td></tr>
<tr><td><code id="legendre_sym_+3A_p">p</code></td>
<td>
<p>prime number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Legendre Symbol <code>(a/p)</code>, where <code>p</code> must be a prime number,
denotes whether <code>a</code> is a quadratic residue modulo <code>p</code> or not.
</p>
<p>The Jacobi symbol <code>(a/p)</code> is the product of <code>(a/p)</code> of all prime
factors <code>p</code> on <code>n</code>.
</p>


<h3>Value</h3>

<p>Returns 0, 1, or -1 if <code>p</code> divides <code>a</code>, <code>a</code> is a quadratic 
residue, or if not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadratic_residues">quadratic_residues</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lsym &lt;- Vectorize(legendre_sym, 'a')

# all quadratic residues of p = 17
qr17 &lt;- which(Lsym(1:16, 17) == 1)      #  1  2  4  8  9 13 15 16
sort(unique((1:16)^2 %% 17))            #  the same

## Not run: 
# how about large numbers?
p &lt;- 1198112137                         #  isPrime(p) TRUE
x &lt;- 4652356
a &lt;- mod(x^2, p)                        #  520595831
legendre_sym(a, p)                      #  1
legendre_sym(a+1, p)                    # -1
  
## End(Not run)

jacobi_sym(11, 12)                      # -1
</code></pre>

<hr>
<h2 id='mersenne'>
Mersenne Numbers
</h2><span id='topic+mersenne'></span>

<h3>Description</h3>

<p>Determines whether <code class="reqn">p</code> is a Mersenne number, that is such that
<code class="reqn">2^p - 1</code> is prime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mersenne(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mersenne_+3A_p">p</code></td>
<td>
<p>prime number, not very large.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies the Lucas-Lehmer test on <code>p</code>. Because intermediate numbers will
soon get very large, uses &lsquo;gmp&rsquo; from the beginning.
</p>


<h3>Value</h3>

<p>Returns TRUE or FALSE, indicating whether <code>p</code> is a Mersenne number or not.
</p>


<h3>References</h3>

<p>https://mathworld.wolfram.com/Lucas-LehmerTest.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mersenne(2)

## Not run: 
  P &lt;- Primes(32)
  M &lt;- c()
  for (p in P)
      if (mersenne(p)) M &lt;- c(M, p)
  # Next Mersenne numpers with primes are 521 and 607 (below 1200)
  M                       # 2   3   5    7    13      17  19  31  61  89  107
  gmp::as.bigz(2)^M - 1   # 3   7  31  127  8191  131071  ... 
## End(Not run) 
</code></pre>

<hr>
<h2 id='miller_rabin'>Miller-Rabin Test</h2><span id='topic+miller_rabin'></span>

<h3>Description</h3>

<p>Probabilistic Miller-Rabin primality test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  miller_rabin(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miller_rabin_+3A_n">n</code></td>
<td>
<p>natural number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Miller-Rabin test is an efficient probabilistic primality test based
on strong pseudoprimes. This implementation uses the first seven prime
numbers (if necessary) as test cases. It is thus exact for all numbers
<code>n &lt; 341550071728321</code>.
</p>


<h3>Value</h3>

<p>Returns TRUE or FALSE.
</p>


<h3>Note</h3>

<p><code>miller_rabin()</code> will only work if package <code>gmp</code> has been loaded
by the user separately.
</p>


<h3>References</h3>

<p><a href="https://mathworld.wolfram.com/Rabin-MillerStrongPseudoprimeTest.html">https://mathworld.wolfram.com/Rabin-MillerStrongPseudoprimeTest.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isPrime">isPrime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>miller_rabin(2)

## Not run: 
  miller_rabin(4294967297)  #=&gt; FALSE
  miller_rabin(4294967311)  #=&gt; TRUE

  # Rabin-Miller 10 times faster than nextPrime()
  N &lt;- n &lt;- 2^32 + 1
  system.time(while (!miller_rabin(n)) n &lt;- n + 1)  # 0.003
  system.time(p &lt;- nextPrime(N))                    # 0.029

  N &lt;- c(2047, 1373653, 25326001, 3215031751, 2152302898747,
          3474749660383, 341550071728321)
  for (n in N) {
      p &lt;- nextPrime(n)
      T &lt;- system.time(r &lt;- miller_rabin(p))
      cat(n, p, r, T[3], "\n")}
## End(Not run)
</code></pre>

<hr>
<h2 id='mod'>Modulo Operator</h2><span id='topic+mod'></span><span id='topic+modq'></span>

<h3>Description</h3>

<p>Modulo operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod(n, m)

modq(a, b, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod_+3A_n">n</code></td>
<td>
<p>numeric vector (preferably of integers)</p>
</td></tr>
<tr><td><code id="mod_+3A_m">m</code></td>
<td>
<p>integer vector (positive, zero, or negative)</p>
</td></tr>
<tr><td><code id="mod_+3A_a">a</code>, <code id="mod_+3A_b">b</code></td>
<td>
<p>whole numbers (scalars)</p>
</td></tr>
<tr><td><code id="mod_+3A_k">k</code></td>
<td>
<p>integer greater than 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mod(n, m)</code> is the modulo operator and returns <code>n mod m</code>.
<code>mod(n, 0)</code> is <code>n</code>, and the result always has the same sign
as <code>m</code>.
</p>
<p><code>modq(a, b, k)</code> is the modulo operator for rational numbers and
returns <code>a/b mod k</code>. <code>b</code> and <code>k</code> must be coprime,
otherwise <code>NA</code> is returned. 
</p>


<h3>Value</h3>

<p>a numeric (integer) value or vector/matrix, resp. an integer number
</p>


<h3>Note</h3>

<p>The following relation is fulfilled (for <code>m != 0</code>):
</p>
<p><code>mod(n, m) = n - m * floor(n/m)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rem">rem</a></code>, <code><a href="#topic+div">div</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod(c(-5:5), 5)
mod(c(-5:5), -5)
mod(0, 1)         #=&gt; 0
mod(1, 0)         #=&gt; 1

modq(5, 66, 5)    # 0  (Bernoulli 10)
modq(5, 66, 7)    # 4
modq(5, 66, 13)   # 5
modq(5, 66, 25)   # 5
modq(5, 66, 35)   # 25
modq(-1,  30, 7)  # 3  (Bernoulli 8)
modq( 1, -30, 7)  # 3

# Warning messages:
# modq(5, 66, 77)       : Arguments 'b' and 'm' must be coprime.
# Error messages
# modq(5, 66, 1)        : Argument 'm' mustbe a natural number &gt; 1.
# modq(5, 66, 1.5)      : All arguments of 'modq' must be integers.
# modq(5, 66, c(5, 7))  : Function 'modq' is *not* vectorized.
</code></pre>

<hr>
<h2 id='modinv+2C+20modsqrt'>Modular Inverse and Square Root</h2><span id='topic+modinv'></span><span id='topic+modsqrt'></span>

<h3>Description</h3>

<p>Computes the modular inverse of <code>n</code> modulo <code>m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modinv(n, m)

modsqrt(a, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modinv+2B2C+2B20modsqrt_+3A_n">n</code>, <code id="modinv+2B2C+2B20modsqrt_+3A_m">m</code></td>
<td>
<p>integer scalars.</p>
</td></tr>
<tr><td><code id="modinv+2B2C+2B20modsqrt_+3A_a">a</code>, <code id="modinv+2B2C+2B20modsqrt_+3A_p">p</code></td>
<td>
<p>integer modulo p, p a prime.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modular inverse of <code>n</code> modulo <code>m</code> is the unique natural
number <code>0 &lt; n0 &lt; m</code> such that <code>n * n0 = 1 mod m</code>. It is a
simple application of the extended GCD algorithm.
</p>
<p>The modular square root of <code>a</code> modulo a prime <code>p</code> is a number
<code>x</code> such that <code>x^2 = a mod p</code>. If <code>x</code> is a solution, then
<code>p-x</code> is also a solution module <code>p</code>. The function will always
return the smaller value.
</p>
<p><code>modsqrt</code> implements the Tonelli-Shanks algorithm which also works
for square roots modulo prime powers. The general case is NP-hard.
</p>


<h3>Value</h3>

<p>A natural number smaller <code>m</code>, if <code>n</code> and <code>m</code> are coprime,
else <code>NA</code>. <code>modsqrt</code> will return 0 if there is no solution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extGCD">extGCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modinv(5, 1001)  #=&gt; 801, as 5*801 = 4005 = 1 mod 1001

Modinv &lt;- Vectorize(modinv, "n")
((1:10)*Modinv(1:10, 11)) %% 11     #=&gt; 1 1 1 1 1 1 1 1 1 1

modsqrt( 8, 23)  # 10 because 10^2 = 100 = 8 mod 23
modsqrt(10, 17)  #  0 because 10 is not a quadratic residue mod 17
</code></pre>

<hr>
<h2 id='modlin'>Modular Linear Equation Solver</h2><span id='topic+modlin'></span>

<h3>Description</h3>

<p>Solves the modular equation <code>a x = b mod n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modlin(a, b, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modlin_+3A_a">a</code>, <code id="modlin_+3A_b">b</code>, <code id="modlin_+3A_n">n</code></td>
<td>
<p>integer scalars</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solves the modular equation <code>a x = b mod n</code>. This eqation is solvable
if and only if <code>gcd(a,n)|b</code>. The function uses the extended greatest
common divisor approach.
</p>


<h3>Value</h3>

<p>Returns a vector of integer solutions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extGCD">extGCD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modlin(14, 30, 100)             # 95 45
modlin(3, 4, 5)                 # 3
modlin(3, 5, 6)                 # []
modlin(3, 6, 9)                 # 2 5 8
</code></pre>

<hr>
<h2 id='modlog'>
Modular (or: Discrete) Logarithm
</h2><span id='topic+modlog'></span>

<h3>Description</h3>

<p>Realizes the modular (or discrete) logarithm modulo a prime number
<code class="reqn">p</code>, that is determines the unique exponent <code class="reqn">n</code> such that
<code class="reqn">g^n = x \, \mathrm{mod} \, p</code>, <code>g</code> a primitive root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  modlog(g, x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modlog_+3A_g">g</code></td>
<td>
<p>a primitive root mod p.</p>
</td></tr>
<tr><td><code id="modlog_+3A_x">x</code></td>
<td>
<p>an integer.</p>
</td></tr>
<tr><td><code id="modlog_+3A_p">p</code></td>
<td>
<p>prime number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is in principle a complete search, cut short by &quot;Shank's 
trick&quot;, the giantstep-babystep approach, see Forster
(1996, pp. 65f). <code>g</code> has to be a primitive root modulo <code>p</code>,
otherwise exponentiation is not bijective.
</p>


<h3>Value</h3>

<p>Returns an integer.
</p>


<h3>References</h3>

<p>Forster, O. (1996). Algorithmische Zahlentheorie. Friedr. Vieweg u. 
Sohn Verlagsgesellschaft mbH, Wiesbaden.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+primroot">primroot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modlog(11, 998, 1009)  # 505 , i.e., 11^505 = 998 mod 1009
</code></pre>

<hr>
<h2 id='modpower'>
Power Function modulo m
</h2><span id='topic+modpower'></span><span id='topic+modorder'></span>

<h3>Description</h3>

<p>Calculates powers and orders modulo <code>m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modpower(n, k, m)
modorder(n, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modpower_+3A_n">n</code>, <code id="modpower_+3A_k">k</code>, <code id="modpower_+3A_m">m</code></td>
<td>
<p>Natural numbers, <code>m &gt;= 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modpower</code> calculates <code>n</code> to the power of <code>k</code> modulo
<code>m</code>.<br />
Uses modular exponentiation, as described in the Wikipedia article.
</p>
<p><code>modorder</code> calculates the order of <code>n</code> in the multiplicative
group module <code>m</code>. <code>n</code> and <code>m</code> must be coprime.<br />
Uses brute force, trick to use binary expansion and square is not more
efficient in an R implementation.
</p>


<h3>Value</h3>

<p>Natural number.
</p>


<h3>Note</h3>

<p>This function is <em>not</em> vectorized.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+primroot">primroot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modpower(2, 100, 7)  #=&gt; 2
modpower(3, 100, 7)  #=&gt; 4
modorder(7, 17)      #=&gt; 16, i.e. 7 is a primitive root mod 17

##  Gauss' table of primitive roots modulo prime numbers &lt; 100
proots &lt;- c(2,  2,  3,  2,  2,  6,  5, 10, 10, 10, 2,  2, 10, 17,  5,  5,
            6, 28, 10, 10, 26, 10, 10,  5, 12, 62, 5, 29, 11, 50, 30, 10)
P &lt;- Primes(100)
for (i in seq(along=P)) {
    cat(P[i], "\t", modorder(proots[i], P[i]), proots[i], "\t", "\n")
}

## Not run: 
##  Lehmann's primality test
lehmann_test &lt;- function(n, ntry = 25) {
    if (!is.numeric(n) || ceiling(n) != floor(n) || n &lt; 0)
        stop("Argument 'n' must be a natural number")
    if (n &gt;= 9e7)
        stop("Argument 'n' should be smaller than 9e7.")

    if (n &lt; 2)                      return(FALSE)
    else if (n == 2)                return(TRUE)
    else if (n &gt; 2 &amp;&amp; n %% 2 == 0)  return(FALSE)

    k &lt;- floor(ntry)
    if (k &lt; 1) k &lt;- 1
    if (k &gt; n-2) a &lt;- 2:(n-1)
    else         a &lt;- sample(2:(n-1), k, replace = FALSE) 

    for (i in 1:length(a)) {
        m &lt;- modpower(a[i], (n-1)/2, n)
        if (m != 1 &amp;&amp; m != n-1) return(FALSE)
    }
    return(TRUE)
}

##  Examples
for (i in seq(1001, 1011, by = 2))
    if (lehmann_test(i)) cat(i, "\n")
# 1009
system.time(lehmann_test(27644437, 50))    # TRUE
#    user  system elapsed 
#   0.086   0.151   0.235

## End(Not run)
</code></pre>

<hr>
<h2 id='moebius'>Moebius Function</h2><span id='topic+moebius'></span><span id='topic+mertens'></span>

<h3>Description</h3>

<p>The classical Moebius and Mertens functions in number theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moebius(n)
mertens(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moebius_+3A_n">n</code></td>
<td>
<p>Positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>moebius(n)</code> is <code>+1</code> if n is a square-free positive integer
with an even number of prime factors, or <code>+1</code> if there are an odd
of prime factors. It is <code>0</code> if <code>n</code> is not square-free.
</p>
<p><code>mertens(n)</code> is the aggregating summary function, that sums up all
values of <code>moebius</code> from <code>1</code> to <code>n</code>. 
</p>


<h3>Value</h3>

<p>For <code>moebius</code>, <code>0, 1</code> or <code>-1</code>, depending on the prime
decomposition of <code>n</code>.
</p>
<p>For <code>mertens</code> the values will very slowly grow.
</p>


<h3>Note</h3>

<p>Works well up to <code>10^9</code>, but will become very slow for the Mertens
function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+primeFactors">primeFactors</a></code>, <code><a href="#topic+eulersPhi">eulersPhi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapply(1:16, moebius)
sapply(1:16, mertens)

## Not run: 
x &lt;- 1:50; y &lt;- sapply(x, moebius)
plot(c(1, 50), c(-3, 3), type="n")
grid()
points(1:50, y, pch=18, col="blue")

x &lt;- 1:100; y &lt;- sapply(x, mertens)
plot(c(1, 100), c(-5, 3), type="n")
grid()
lines(1:100, y, col="red", type="s")
## End(Not run)
</code></pre>

<hr>
<h2 id='necklace'>Necklace and Bracelet Functions</h2><span id='topic+necklace'></span><span id='topic+bracelet'></span>

<h3>Description</h3>

<p>Necklace and bracelet problems in combinatorics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>necklace(k, n)

bracelet(k, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="necklace_+3A_k">k</code></td>
<td>
<p>The size of the set or alphabet to choose from.</p>
</td></tr>
<tr><td><code id="necklace_+3A_n">n</code></td>
<td>
<p>the length of the necklace or bracelet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A necklace is a closed string of length <code>n</code> over a set of size
<code>k</code> (numbers, characters, clors, etc.), where all rotations are
taken as equivalent. A bracelet is a necklace where strings may also
be equivalent under reflections.
</p>
<p>Polya's enumeration theorem can be utilized to enumerate all necklaces
or bracelets. The final calculation involves Euler's Phi or totient
function, in this package implemented as <code>eulersPhi</code>.
</p>


<h3>Value</h3>

<p>Returns the number of necklaces resp. bracelets.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Necklace_(combinatorics)">https://en.wikipedia.org/wiki/Necklace_(combinatorics)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>necklace(2, 5)
necklace(3, 6)

bracelet(2, 5)
bracelet(3, 6)
</code></pre>

<hr>
<h2 id='nextPrime'>Next Prime</h2><span id='topic+nextPrime'></span>

<h3>Description</h3>

<p>Find the next prime above <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nextPrime(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextPrime_+3A_n">n</code></td>
<td>
<p>natural number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nextPrime</code> finds the next prime number greater than <code>n</code>, while
<code>previousPrime</code> finds the next prime number below <code>n</code>.
In general the next prime will occur in the interval <code>[n+1,n+log(n)]</code>.
</p>
<p>In double precision arithmetic integers are represented exactly only up to
2^53 - 1, therefore this is the maximal allowed value.
</p>


<h3>Value</h3>

<p>Integer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Primes">Primes</a></code>, <code><a href="#topic+isPrime">isPrime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- nextPrime(1e+6)  # 1000003
isPrime(p)            # TRUE
</code></pre>

<hr>
<h2 id='numbers-package'>
Number-Theoretic Functions
</h2><span id='topic+numbers-package'></span><span id='topic+numbers'></span>

<h3>Description</h3>


<p>    Provides number-theoretic functions for factorization, prime 
    numbers, twin primes, primitive roots, modular logarithm and
    inverses, extended GCD, Farey series and continued fractions.
    Includes Legendre and Jacobi symbols, some divisor functions,
    Euler's Phi function, etc.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> numbers</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Number-Theoretic Functions</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.8-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-11-22</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Hans Werner Borchers</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Hans W. Borchers &lt;hwborchers@googlemail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 4.1.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> gmp (&gt;= 0.5-1)</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> 
    Provides number-theoretic functions for factorization, prime 
    numbers, twin primes, primitive roots, modular logarithm and
    inverses, extended GCD, Farey series and continued fractions.
    Includes Legendre and Jacobi symbols, some divisor functions,
    Euler's Phi function, etc.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
GCD                     GCD and LCM Integer Functions
Primes                  Prime Numbers
Sigma                   Divisor Functions
agm                     Arithmetic-geometric Mean
bell                    Bell Numbers
bernoulli_numbers       Bernoulli Numbers
carmichael              Carmichael Numbers
catalan                 Catalan Numbers
cf2num                  Generalized Continous Fractions
chinese                 Chinese Remainder Theorem
collatz                 Collatz Sequences
contfrac                Continued Fractions
coprime                 Coprimality
div                     Integer Division
divisors                List of Divisors
dropletPi               Droplet Algorithm for pi and e
egyptian_complete       Egyptian Fractions - Complete Search
egyptian_methods        Egyptian Fractions - Specialized Methods
eulersPhi               Eulers's Phi Function
extGCD                  Extended Euclidean Algorithm
fibonacci               Fibonacci and Lucas Series
hermiteNF               Hermite Normal Form
iNthroot                Integer N-th Root
isIntpower              Powers of Integers
isNatural               Natural Number
isPrime                 isPrime Property
isPrimroot              Primitive Root Test
legendre_sym            Legendre and Jacobi Symbol
mersenne                Mersenne Numbers
miller_rabin            Miller-Rabin Test
mod                     Modulo Operator
modinv                  Modular Inverse and Square Root
modlin                  Modular Linear Equation Solver
modlog                  Modular (or: Discrete) Logarithm
modpower                Power Function modulo m
moebius                 Moebius Function
necklace                Necklace and Bracelet Functions
nextPrime               Next Prime
numbers-package         Number-Theoretic Functions
omega                   Number of Prime Factors
ordpn                   Order in Faculty
pascal_triangle         Pascal Triangle
periodicCF              Periodic continued fraction
previousPrime           Previous Prime
primeFactors            Prime Factors
primroot                Primitive Root
pythagorean_triples     Pythagorean Triples
quadratic_residues      Quadratic Residues
ratFarey                Farey Approximation and Series
rem                     Integer Remainder
solvePellsEq            Solve Pell's Equation
stern_brocot_seq        Stern-Brocot Sequence
twinPrimes              Twin Primes
zeck                    Zeckendorf Representation
</pre>
<p>Although R does not have a true integer data type, integers can be
represented exactly up to 2^53-1 . The numbers package attempts to 
provided basic number-theoretic functions that will work correcty
and relatively fast up to this level.
</p>


<h3>Author(s)</h3>

<p>Hans Werner Borchers
</p>
<p>Maintainer: Hans W. Borchers &lt;hwborchers@googlemail.com&gt;
</p>


<h3>References</h3>

<p>Hardy, G. H., and E. M. Wright (1980). An Introduction to the
Theory of Numbers. 5th Edition, Oxford University Press.
</p>
<p>Riesel, H. (1994). Prime Numbers and Computer Methods for
Factorization. Second Edition, Birkhaeuser Boston.
</p>
<p>Crandall, R., and C. Pomerance (2005). Prime Numbers:
A Computational Perspective. Springer Science+Business.
</p>
<p>Shoup, V. (2009). A Computational Introduction to Number Theory
and Algebra. Second Edition, Cambridge University Press.
</p>
<p>Arndt, J. (2010). Matters Computational: Ideas, Algorithms,
Source Code. 2011 Edition, Springer-Verlag, Berlin Heidelberg.
</p>
<p>Forster, O. (2014). Algorithmische Zahlentheorie. 2. Auflage,
Springer Spektrum Wiesbaden.
</p>

<hr>
<h2 id='omega'>Number of Prime Factors</h2><span id='topic+omega'></span><span id='topic+Omega'></span>

<h3>Description</h3>

<p>Number of prime factors resp. sum of all exponents of prime factors
in the prime decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omega(n)
Omega(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omega_+3A_n">n</code></td>
<td>
<p>Positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'omega(n)' returns the number of prime factors of 'n' while 'Omega(n)'
returns the sum of their exponents in the prime decomposition.
'omega' and 'Omega' are identical if there are no quadratic factors.
</p>
<p>Remark: <code>(-1)^Omega(n)</code> is the Liouville function.
</p>


<h3>Value</h3>

<p>Natural number.
</p>


<h3>Note</h3>

<p>Works well up to <code>10^9</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sigma">Sigma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>omega(2*3*5*7*11*13*17*19)  #=&gt; 8
Omega(2 * 3^2 * 5^3 * 7^4)  #=&gt; 10


</code></pre>

<hr>
<h2 id='ordpn'>
Order in Faculty
</h2><span id='topic+ordpn'></span>

<h3>Description</h3>

<p>Calculates the order of a prime number <code>p</code> in <code>n!</code>, i.e. the 
highest exponent <code>e</code> such that <code>p^e|n!</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordpn(p, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordpn_+3A_p">p</code></td>
<td>
<p>prime number.</p>
</td></tr>
<tr><td><code id="ordpn_+3A_n">n</code></td>
<td>
<p>natural number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies the well-known formula adding terms <code>floor(n/p^k)</code>.
</p>


<h3>Value</h3>

<p>Returns the exponent <code>e</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ordpn(2, 100)         #=&gt; 97
  ordpn(7, 100)         #=&gt; 16
  ordpn(101, 100)       #=&gt;  0
  ordpn(997, 1000)      #=&gt;  1
</code></pre>

<hr>
<h2 id='Pascal+20triangle'>
Pascal Triangle
</h2><span id='topic+pascal_triangle'></span>

<h3>Description</h3>

<p>Generates the Pascal triangle in rectangular form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pascal_triangle(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pascal+2B20triangle_+3A_n">n</code></td>
<td>
<p>integer number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pascal numbers will be generated with the usual recursion formula and
stored in a rectangular scheme.
</p>
<p>For <code>n&gt;50</code> integer overflow would happen, so use the arbitrary
precision version <code>gmp::chooseZ(n, 0:n)</code> instead for calculating
binomial numbers.
</p>


<h3>Value</h3>

<p>Returns the Pascal triangle as an (n+1)x(n+1) rectangle with zeros filled in.
</p>


<h3>References</h3>

<p>See Wolfram MathWorld or the Wikipedia.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5; P &lt;- pascal_triangle(n)
for (i in 1:(n+1)) {
    cat(P[i, 1:i], '\n')
}
## 1 
## 1 1 
## 1 2 1 
## 1 3 3 1 
## 1 4 6 4 1 
## 1 5 10 10 5 1 

## Not run: 
P &lt;- pascal_triangle(50)
max(P[51, ])
## [1] 126410606437752

## End(Not run)
</code></pre>

<hr>
<h2 id='periodicCF'>
Periodic continued fraction
</h2><span id='topic+periodicCF'></span>

<h3>Description</h3>

<p>Generates a periodic continued fraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodicCF(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodicCF_+3A_d">d</code></td>
<td>
<p>positive integer that is not a square number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the periodic continued fraction of the square root of
an integer that itself shall not be a square (because otherwise the integer
square root will be returned). Note that the continued fraction of an
irrational quadratic number is always a periodic continued fraction.
</p>
<p>The first term is the biggest integer below <code>sqrt(d)</code> and the rest is
the period of the continued fraction. The period is always exact, there is
no floating point inaccuracy involved (though integer overflow may happen
for very long fractions).
</p>
<p>The underlying algorithm is sometimes called &quot;The Fundamental Algorithm
for Quadratic Numbers&quot;. The function will be utilized especially when
solving Pell's equation.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table>
<tr><td><code>cf</code></td>
<td>
<p>the continued fraction with integer part and first period.</p>
</td></tr>
<tr><td><code>plen</code></td>
<td>
<p>the length of the period.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Integer overflow may happen for very long continued fractions.
</p>


<h3>Author(s)</h3>

<p>Hans Werner Borchers
</p>


<h3>References</h3>

<p>Mak Trifkovic. Algebraic Theory of Quadratic Numbers. Springer Verlag,
Universitext, New York 2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solvePellsEq">solvePellsEq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  periodicCF(2)    # sqrt(2) = [1; 2,2,2,...] = [1; (2)]

  periodicCF(1003)
  ## $cf
  ## [1] 31  1  2 31  2  1 62
  ## $plen
  ## [1] 6
</code></pre>

<hr>
<h2 id='previousPrime'>Previous Prime</h2><span id='topic+previousPrime'></span>

<h3>Description</h3>

<p>Find the next prime below <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  previousPrime(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="previousPrime_+3A_n">n</code></td>
<td>
<p>natural number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>previousPrime</code> finds the next prime number smaller than <code>n</code>, 
while <code>nextPrime</code> finds the next prime number below <code>n</code>.
In general the previousn prime will occur in the interval 
<code>[n-1,n-log(n)]</code>.
</p>
<p>In double precision arithmetic integers are represented exactly only up to
2^53 - 1, therefore this is the maximal allowed value.
</p>


<h3>Value</h3>

<p>Integer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Primes">Primes</a></code>, <code><a href="#topic+isPrime">isPrime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- previousPrime(1e+6)  # 999983
isPrime(p)                # TRUE
</code></pre>

<hr>
<h2 id='primeFactors'>Prime Factors</h2><span id='topic+primeFactors'></span><span id='topic+radical'></span>

<h3>Description</h3>

<p><code>primeFactors</code> computes a vector containing the prime factors of 
<code>n</code>. <code>radical</code> returns the product of those unique prime
factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  primeFactors(n)
  radical(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primeFactors_+3A_n">n</code></td>
<td>
<p>nonnegative integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the prime factors of <code>n</code> in ascending order,
each one as often as its multiplicity requires, such that 
<code>n == prod(primeFactors(n))</code>.
</p>
<p>## radical() is used in the abc-conjecture:
</p>
<p># abc-triple: 1 &lt;= a &lt; b, a, b coprime, c = a + b
</p>
<p># for every e &gt; 0 there are only finitely many abc-triples with
</p>
<p># c &gt; radical(a*b*c)^(1+e)
</p>


<h3>Value</h3>

<p>Vector containing the prime factors of <code>n</code>, resp.
the product of unique prime factors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+divisors">divisors</a></code>, <code>gmp::factorize</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  primeFactors(1002001)         # 7  7  11  11  13  13
  primeFactors(65537)           # is prime
  # Euler's calculation
  primeFactors(2^32 + 1)        # 641  6700417

  radical(1002001)              # 1001

## Not run: 
  for (i in 1:99) {
    for (j in (i+1):100) {
      if (coprime(i, j)) {
        k = i + j
        r = radical(i*j*k)
        q = log(k) / log(r)  # 'quality' of the triple
        if (q &gt; 1)
          cat(q, ":\t", i, ",", j, ",", k, "\n")
        }
      }
    }
## End(Not run)
</code></pre>

<hr>
<h2 id='Primes'>Prime Numbers</h2><span id='topic+Primes'></span><span id='topic+atkin_sieve'></span>

<h3>Description</h3>

<p>Eratosthenes resp. Atkin sieve methods to generate a list of prime numbers
less or equal <code>n</code>, resp. between <code>n1</code> and <code>n2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Primes(n1, n2 = NULL)

  atkin_sieve(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Primes_+3A_n">n</code>, <code id="Primes_+3A_n1">n1</code>, <code id="Primes_+3A_n2">n2</code></td>
<td>
<p>natural numbers with <code>n1 &lt;= n2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of prime numbers up to <code>n</code> is generated using the &quot;sieve of
Eratosthenes&quot;. This approach is reasonably fast, but may require a lot of
main memory when <code>n</code> is large.
</p>
<p><code>Primes</code> computes first all primes up to <code>sqrt(n2)</code> and then
applies a refined sieve on the numbers from <code>n1</code> to <code>n2</code>, thereby
drastically reducing the need for storing long arrays of numbers.
</p>
<p>The sieve of Atkins is a modified version of the ancient prime number sieve 
of Eratosthenes. It applies a modulo-sixty arithmetic and requires less
memory, but in R is not faster because of a double for-loop.
</p>
<p>In double precision arithmetic integers are represented exactly only up to
2^53 - 1, therefore this is the maximal allowed value.
</p>


<h3>Value</h3>

<p>vector of integers representing prime numbers
</p>


<h3>References</h3>

<p>A. Atkin and D. Bernstein (2004), Prime sieves using quadratic forms.
Mathematics of Computation, Vol. 73, pp. 1023-1030.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isPrime">isPrime</a></code>, <code>gmp::factorize</code>, <code>pracma::expint1</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Primes(1000)
Primes(1949, 2019)

atkin_sieve(1000)

## Not run: 
##  Appendix:  Logarithmic Integrals and Prime Numbers (C.F.Gauss, 1846)

library('gsl')
# 'European' form of the logarithmic integral
Li &lt;- function(x) expint_Ei(log(x)) - expint_Ei(log(2))

# No. of primes and logarithmic integral for 10^i, i=1..12
i &lt;- 1:12;  N &lt;- 10^i
# piN &lt;- numeric(12)
# for (i in 1:12) piN[i] &lt;- length(primes(10^i))
piN &lt;- c(4, 25, 168, 1229, 9592, 78498, 664579,
         5761455, 50847534, 455052511, 4118054813, 37607912018)
cbind(i, piN, round(Li(N)), round((Li(N)-piN)/piN, 6))

#  i     pi(10^i)      Li(10^i)  rel.err  
# --------------------------------------      
#  1            4            5  0.280109
#  2           25           29  0.163239
#  3          168          177  0.050979
#  4         1229         1245  0.013094
#  5         9592         9629  0.003833
#  6        78498        78627  0.001637
#  7       664579       664917  0.000509
#  8      5761455      5762208  0.000131
#  9     50847534     50849234  0.000033
# 10    455052511    455055614  0.000007
# 11   4118054813   4118066400  0.000003
# 12  37607912018  37607950280  0.000001
# --------------------------------------
## End(Not run)
</code></pre>

<hr>
<h2 id='primroot'>
Primitive Root
</h2><span id='topic+primroot'></span>

<h3>Description</h3>

<p>Find the smallest primitive root modulo m, or find all primitive roots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primroot(m, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primroot_+3A_m">m</code></td>
<td>
<p>A prime integer.</p>
</td></tr>
<tr><td><code id="primroot_+3A_all">all</code></td>
<td>
<p>boolean; shall all primitive roots module p be found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every prime number <code class="reqn">m</code> there exists a natural number <code class="reqn">n</code> that
generates the field <code class="reqn">F_m</code>, i.e. <code class="reqn">n, n^2, ..., n^{m-1} mod (m)</code> are
all different.
</p>
<p>The computation here is all brute force. As most primitive roots are
relatively small, so it is still reasonable fast.
</p>
<p>One trick is to factorize <code class="reqn">m-1</code> and test only for those prime factors.
In R this is not more efficient as factorization also takes some time.
</p>


<h3>Value</h3>

<p>A natural number if <code>m</code> is prime, else <code>NA</code>.
</p>


<h3>Note</h3>

<p>This function is <em>not</em> vectorized.
</p>


<h3>References</h3>

<p>Arndt, J. (2010). Matters Computational: Ideas, Algorithms, Source Code.
Springer-Verlag, Berlin Heidelberg Dordrecht.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modpower">modpower</a></code>, <code><a href="#topic+modorder">modorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- Primes(100)
R &lt;- c()
for (p in P) {
    R &lt;- c(R, primroot(p))
}
cbind(P, R)  # 7 is the biggest prime root here (for p=71)
</code></pre>

<hr>
<h2 id='pythagorean_triples'>
Pythagorean Triples
</h2><span id='topic+pythagorean_triples'></span>

<h3>Description</h3>

<p>Generates all primitive Pythagorean triples <code class="reqn">(a, b, c)</code> of integers
such that <code class="reqn">a^2 + b^2 = c^2</code>, where <code class="reqn">a, b, c</code> are coprime (have no
common divisor) and <code class="reqn">c_1 \le c \le c_2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pythagorean_triples(c1, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pythagorean_triples_+3A_c1">c1</code>, <code id="pythagorean_triples_+3A_c2">c2</code></td>
<td>
<p>lower and upper limit of the hypothenuses <code>c</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">(a, b, c)</code> is a primitive Pythagorean triple, there are integers
<code class="reqn">m, n</code> with <code class="reqn">1 \le n &lt; m</code> such that
</p>
<p style="text-align: center;"><code class="reqn">a = m^2 - n^2, b = 2 m n, c = m^2 + n^2</code>
</p>

<p>with <code class="reqn">gcd(m, n) = 1</code> and <code class="reqn">m - n</code> being odd.
</p>


<h3>Value</h3>

<p>Returns a matrix, one row for each Pythagorean triple, of the form
<code>(m  n  a  b  c)</code>.
</p>


<h3>References</h3>

<p><a href="https://mathworld.wolfram.com/PythagoreanTriple.html">https://mathworld.wolfram.com/PythagoreanTriple.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pythagorean_triples(100, 200)
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]   10    1   99   20  101
##  [2,]   10    3   91   60  109
##  [3,]    8    7   15  112  113
##  [4,]   11    2  117   44  125
##  [5,]   11    4  105   88  137
##  [6,]    9    8   17  144  145
##  [7,]   12    1  143   24  145
##  [8,]   10    7   51  140  149
##  [9,]   11    6   85  132  157
## [10,]   12    5  119  120  169
## [11,]   13    2  165   52  173
## [12,]   10    9   19  180  181
## [13,]   11    8   57  176  185
## [14,]   13    4  153  104  185
## [15,]   12    7   95  168  193
## [16,]   14    1  195   28  197
</code></pre>

<hr>
<h2 id='quadratic_residues'>Quadratic Residues</h2><span id='topic+quadratic_residues'></span>

<h3>Description</h3>

<p>List all quadratic residues of an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadratic_residues(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadratic_residues_+3A_n">n</code></td>
<td>
<p>integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Squares all numbers between 0 and <code>n/2</code> and generate a unique list of 
all these numbers modulo <code>n</code>.
</p>


<h3>Value</h3>

<p>Vector of integers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+legendre_sym">legendre_sym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quadratic_residues(17)
</code></pre>

<hr>
<h2 id='rem'>Integer Remainder</h2><span id='topic+rem'></span>

<h3>Description</h3>

<p>Integer remainder function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rem(n, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rem_+3A_n">n</code></td>
<td>
<p>numeric vector (preferably of integers)</p>
</td></tr>
<tr><td><code id="rem_+3A_m">m</code></td>
<td>
<p>must be a scalar integer (positive, zero, or negative)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rem(n, m)</code> is the same modulo operator and returns <code class="reqn">n\,mod\,m</code>.
<code>mod(n, 0)</code> is <code>NaN</code>, and the result always has the same sign
as <code>n</code> (for <code>n != m</code> and <code>m != 0</code>).
</p>


<h3>Value</h3>

<p>a numeric (integer) value or vector/matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mod">mod</a></code>, <code><a href="#topic+div">div</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rem(c(-5:5), 5)
rem(c(-5:5), -5)
rem(0, 1)         #=&gt; 0
rem(1, 1)         #=&gt; 0  (always for n == m)
rem(1, 0)         #   NA  (should be NaN)
rem(0, 0)         #=&gt; NaN
</code></pre>

<hr>
<h2 id='Sigma'>Divisor Functions</h2><span id='topic+Sigma'></span><span id='topic+tau'></span>

<h3>Description</h3>

<p>Sum of powers of all divisors of a natural number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sigma(n, k = 1, proper = FALSE)

tau(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sigma_+3A_n">n</code></td>
<td>
<p>Positive integer.</p>
</td></tr>
<tr><td><code id="Sigma_+3A_k">k</code></td>
<td>
<p>Numeric scalar, the exponent to be used.</p>
</td></tr>
<tr><td><code id="Sigma_+3A_proper">proper</code></td>
<td>
<p>Logical; if <code>TRUE</code>, n will <em>not</em> be considered
as a divisor of itself; default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Total sum of all integer divisors of <code>n</code> to the power of <code>k</code>,
including <code>1</code> and <code>n</code>.
</p>
<p>For <code>k=0</code> this is the number of divisors, for <code>k=1</code>
it is the sum of all divisors of <code>n</code>.
</p>
<p><code>tau</code> is Ramanujan's <em>tau</em> function, here computed using
<code>Sigma(., 5)</code> and <code>Sigma(., 11)</code>.
</p>
<p>A number is called <em>refactorable</em>, if <code>tau(n)</code> divides <code>n</code>,
for example <code>n=12</code> or <code>n=18</code>.
</p>


<h3>Value</h3>

<p>Natural number, the number or sum of all divisors.
</p>


<h3>Note</h3>

<p>Works well up to <code>10^9</code>.
</p>


<h3>References</h3>

<p><code>https://en.wikipedia.org/wiki/Divisor_function</code>
</p>
<p><code>https://en.wikipedia.org/wiki/Ramanujan_tau_function</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+primeFactors">primeFactors</a></code>, <code><a href="#topic+divisors">divisors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapply(1:16, Sigma, k = 0)
sapply(1:16, Sigma, k = 1)
sapply(1:16, Sigma, proper = TRUE)
</code></pre>

<hr>
<h2 id='solvePellsEq'>
Solve Pell's Equation
</h2><span id='topic+solvePellsEq'></span>

<h3>Description</h3>

<p>Find the basic, that is minimal, solution for Pell's equation, applying
the technique of (periodic) continued fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solvePellsEq(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solvePellsEq_+3A_d">d</code></td>
<td>
<p>non-square integer greater 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solving Pell's equation means to find integer solutions <code>(x,y)</code>
for the Diophantine equation </p>
<p style="text-align: center;"><code class="reqn">x^2 - d\,y^2 = 1</code>
</p>
<p> for <code class="reqn">d</code> a
non-square integer. These solutions are important in number theory and
for the theory of quadratic number fields.
</p>
<p>The procedure goes as follows: First find the periodic continued
fraction for <code class="reqn">\sqrt{d}</code>, then determine the convergents of this
continued fraction. The last pair of convergents will provide the
solution for Pell's equation.
</p>
<p>The solution found is the minimal or <em>fundamental</em> solution.
All other solutions can be derived from this one &ndash; but the numbers
grow up very rapidly.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>solution (x,y) of Pell's equation.</p>
</td></tr>
<tr><td><code>plen</code></td>
<td>
<p>length of the period.</p>
</td></tr>
<tr><td><code>doubled</code></td>
<td>
<p>logical: was the period doubled?</p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p>message either &quot;Success&quot; or &quot;Integer overflow&quot;.</p>
</td></tr>
</table>
<p>If 'doubled' was TRUE, there exists also a solution for the
<em>negative</em> Pell equation
</p>


<h3>Note</h3>

<p>Integer overflow may happen for the convergents, but very rarely.
More often, the terms <code>x^2</code> or <code>y^2</code> can overflow the
maximally representable integer <code>2^53-1</code> and checking Pell's
equation may end with a value differing from <code>1</code>, though in
reality the solution is correct.
</p>


<h3>Author(s)</h3>

<p>Hans Werner Borchers
</p>


<h3>References</h3>

<p>H.W. Lenstra Jr. Solving the Pell Equation. Notices of the AMS,
Vol. 49, No. 2, February 2002.
</p>
<p>See the &quot;List of fundamental solutions of Pell's equations&quot; in the
Wikipedia entry for &quot;Pell's Equation&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+periodicCF">periodicCF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  s = solvePellsEq(1003)                # $x = 9026, $y = 285
  9026^2 - 1003*285^2 == 1
  # TRUE
</code></pre>

<hr>
<h2 id='Stern-Brocot'>
Stern-Brocot Sequence
</h2><span id='topic+stern_brocot_seq'></span>

<h3>Description</h3>

<p>The function generates the Stern-Brocot sequence up to 
length <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stern_brocot_seq(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Stern-Brocot_+3A_n">n</code></td>
<td>
<p>integer; length of the sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Stern-Brocot sequence is a sequence <code>S</code> of natural 
numbers beginning with
</p>
<p><code>1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 2, 5, 3, 4, 1, ...</code>
</p>
<p>defined with <code>S[1] = S[2] = 1</code> and the following rules:
</p>
<p><code>S[k] = S[k/2]</code> if <code>k</code> is even <br />
<code>S[k] = S[(k-1)/2] + S[(k+1)/2]</code> if <code>k</code> is not even
</p>
<p>The Stern-Brocot has the remarkable properties that
</p>
<p>(1) Consecutive values in this sequence are coprime;<br /> 
(2) the list of rationals <code>S[k+1]/S[k]</code> (all in reduced
form) covers all positive rational numbers once and once only.
</p>


<h3>Value</h3>

<p>Returns a sequence of length <code>n</code> of natural numbers.
</p>


<h3>References</h3>

<p>N. Calkin and H.S. Wilf. Recounting the rationals.
The American Mathematical Monthly, Vol. 7(4), 2000.
</p>
<p>Graham, Knuth, and Patashnik. Concrete Mathematics - 
A Foundation for Computer Science. Addison-Wesley, 1989.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fibonacci">fibonacci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( S &lt;- stern_brocot_seq(92) )
# 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 2, 5, 3, 4, 1,  5, 4, 7, 
# 3, 8, 5, 7, 2, 7, 5, 8, 3, 7, 4, 5, 1, 6, 5, 9, 4, 11, 7, 10, 
# 3, 11, 8, 13, 5, 12, 7, 9, 2, 9, 7, 12, 5, 13, 8, 11, 3, 10, 7, 11, 
# 4, 9, 5, 6, 1, 7, 6, 11, 5, 14, 9, 13, 4, 15, 11, 18, 7, 17, 10, 13, 
# 3, 14, 11, 19, 8, 21, 13, 18, 5, 17, 12, 19, 7, ...

table(S)
## S
##  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 17 18 19 21 
##  7  5  9  7 12  3 11  5  5  3  7  3  5  2  1  2  2  2  1 

which(S == 1)  # 1  2  4  8 16 32 64

## Not run: 
# Find the rational number p/q in S
# note that 1/2^n appears in position S[c(2^(n-1), 2^(n-1)+1)]
occurs &lt;- function(p, q, s){
    # Find i such that (p, q) = s[i, i+1]
    inds &lt;- seq.int(length = length(s)-1)
    inds &lt;- inds[p == s[inds]]
    inds[q == s[inds + 1]]
}
p = 3; q = 7        # 3/7
occurs(p, q, S)     # S[28, 29]

'%//%' &lt;- function(p, q) gmp::as.bigq(p, q)
n &lt;- length(S)
S[1:(n-1)] %//% S[2:n]
## Big Rational ('bigq') object of length 91:
##  [1] 1     1/2  2     1/3   3/2   2/3   3     1/4   4/3   3/5   
## [11] 5/2   2/5  5/3   3/4   4     1/5   5/4   4/7   7/3   3/8   ...

as.double(S[1:(n-1)] %//% S[2:n])
## [1] 1.000000 0.500000 2.000000 0.333333 1.500000 0.666667 3.000000
## [8] 0.250000 1.333333 0.600000 2.500000 0.400000 1.666667 0.750000 ...

## End(Not run)
</code></pre>

<hr>
<h2 id='twinPrimes'>Twin Primes</h2><span id='topic+twinPrimes'></span>

<h3>Description</h3>

<p>Generate a list of twin primes between <code>n1</code> and <code>n2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  twinPrimes(n1, n2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twinPrimes_+3A_n1">n1</code>, <code id="twinPrimes_+3A_n2">n2</code></td>
<td>
<p>natural numbers with <code>n1 &lt;= n2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>twinPrimes</code> uses <code>Primes</code> and uses <code>diff</code> to find all
twin primes in the given interval.
</p>
<p>In double precision arithmetic integers are represented exactly only up to
2^53 - 1, therefore this is the maximal allowed value.
</p>


<h3>Value</h3>

<p>Returnes a <code>nx2</code>-matrix, where <code>n</code>is the number of twin primes
found, and each twin tuple fills one row.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Primes">Primes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twinPrimes(1e6+1, 1e6+1001)
</code></pre>

<hr>
<h2 id='zeck'>
Zeckendorf Representation
</h2><span id='topic+zeck'></span>

<h3>Description</h3>

<p>Generates the Zeckendorf representation of an integer as a sum of
Fibonacci numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeck(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeck_+3A_n">n</code></td>
<td>
<p>integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to Zeckendorfs theorem from 1972, each integer can be uniquely
represented as a sum of Fibonacci numbers such that no two of these are 
consecutive in the Fibonacci sequence.
</p>
<p>The computation is simply the greedy algorithm of finding the highest
Fibonacci number below <code>n</code>, subtracting it and iterating.
</p>


<h3>Value</h3>

<p>List with components <code>fibs</code> the Fibonacci numbers that add sum up to
<code>n</code>, and <code>inds</code> their indices in the Fibonacci sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zeck(  10)  #=&gt; 2 + 8 = 10
zeck( 100)  #=&gt; 3 + 8 + 89 = 100
zeck(1000)  #=&gt; 13 + 987 = 1000
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
