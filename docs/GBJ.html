<!DOCTYPE html><html><head><title>Help for package GBJ</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GBJ}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BJ'><p>BJ.R</p></a></li>
<li><a href='#calc_score_stats'><p>calc_score_stats.R</p></a></li>
<li><a href='#calc_var_nonzero_mu'><p>calc_var_mu_nonzero.R</p></a></li>
<li><a href='#ebb_loglik'><p>ebb_loglik.R</p></a></li>
<li><a href='#estimate_ss_cor'><p>estimate_ss_cor.R</p></a></li>
<li><a href='#FGFR2'><p>Genotypes at FGFR2 SNPs for subjects from 'GBR' population in the 1000 Genomes Project.</p></a></li>
<li><a href='#GBJ'><p>GBJ.R</p></a></li>
<li><a href='#GBJ_objective'><p>GBJ_objective.R</p></a></li>
<li><a href='#GBJ_pvalue'><p>GBJ_pvalue.R</p></a></li>
<li><a href='#gbr_pcs'><p>Simulated Principal Components for 'GBR' population in the 1000 Genomes Project.</p></a></li>
<li><a href='#GHC'><p>GHC.R</p></a></li>
<li><a href='#GHC_objective'><p>GHC_objective.R</p></a></li>
<li><a href='#HC'><p>HC.R</p></a></li>
<li><a href='#herm_poly_diff_t'><p>herm_poly_diff_t.R</p></a></li>
<li><a href='#minP'><p>minP.R</p></a></li>
<li><a href='#OMNI_individual'><p>omni_individual.R</p></a></li>
<li><a href='#OMNI_ss'><p>omni_ss.R</p></a></li>
<li><a href='#parse_input'><p>parse_input.R</p></a></li>
<li><a href='#qnorm_mu'><p>qnorm_mu.R</p></a></li>
<li><a href='#score_stats_only'><p>score_stats_only.R</p></a></li>
<li><a href='#surv'><p>surv.R</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Berk-Jones Test for Set-Based Inference in Genetic
Association Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Offers the Generalized Berk-Jones (GBJ) test for set-based inference in genetic
	association studies. The GBJ is designed as an alternative to tests such as Berk-Jones (BJ),
    Higher Criticism (HC), Generalized Higher Criticism (GHC), Minimum p-value (minP), and Sequence
    Kernel Association Test (SKAT). All of these other methods (except for SKAT) are also implemented 
    in this package, and we additionally provide an omnibus test (OMNI) which integrates information from each of the tests.
    The GBJ has been shown to outperform other tests in genetic association studies when signals
    are correlated and moderately sparse. Please see the vignette for a quickstart guide or Sun and Lin
    (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1710.02469">doi:10.48550/arXiv.1710.02469</a>&gt; for more details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.7), mvtnorm, SKAT, stats, BH</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bindata, rje, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 20:35:15 UTC; rsun3</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Sun [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan Sun &lt;ryansun.work@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 08:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='BJ'>BJ.R</h2><span id='topic+BJ'></span>

<h3>Description</h3>

<p>Calculate the Berk-Jones test statistic and p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BJ(test_stats, cor_mat = NULL, pairwise_cors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BJ_+3A_test_stats">test_stats</code></td>
<td>
<p>Vector of test statistics for each factor in the set (i.e. marginal
test statistic for each SNP in a gene).</p>
</td></tr>
<tr><td><code id="BJ_+3A_cor_mat">cor_mat</code></td>
<td>
<p>d*d matrix of the correlations between all the test statistics in
the set, where d is the total number of test statistics in the set.
You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
<tr><td><code id="BJ_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test
statistics. You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>BJ</code></td>
<td>
<p>The observed Berk-Jones test statistic.</p>
</td></tr>
<tr><td><code>BJ_pvalue</code></td>
<td>
<p>The p-value of this observed value, given the size of the set and
correlation structure.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Should return statistic = 1.243353 and p_value = 0.256618
set.seed(100)
Z_vec &lt;- rnorm(5) + rep(1,5)
cor_Z &lt;- matrix(data=0.2, nrow=5, ncol=5)
diag(cor_Z) &lt;- 1
BJ(test_stats=Z_vec, cor_mat=cor_Z)
</code></pre>

<hr>
<h2 id='calc_score_stats'>calc_score_stats.R</h2><span id='topic+calc_score_stats'></span>

<h3>Description</h3>

<p>Starting with individual-level data on p factors, generate score test statistics for each
factor for input into GBJ/GHC/HC/BJ/minP.  Also get the correlations between these test statistics.
Designed to be used with linear or logistic or log-linear regression null models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_score_stats(null_model, factor_matrix, link_function, P_mat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_score_stats_+3A_null_model">null_model</code></td>
<td>
<p>An R regression model fitted using glm().  Do not use lm(), even for linear regression!</p>
</td></tr>
<tr><td><code id="calc_score_stats_+3A_factor_matrix">factor_matrix</code></td>
<td>
<p>An n*p matrix with each factor as one column.  There should be no missing data.</p>
</td></tr>
<tr><td><code id="calc_score_stats_+3A_link_function">link_function</code></td>
<td>
<p>Either &quot;linear&quot; or &quot;logit&quot; or &quot;log&quot;</p>
</td></tr>
<tr><td><code id="calc_score_stats_+3A_p_mat">P_mat</code></td>
<td>
<p>The projection matrix used in calculation may be passed in to speed up the calculation.
See paper for details. Default is null.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>test_stats</code></td>
<td>
<p>The p score test statistics.</p>
</td></tr>
<tr><td><code>cor_mat</code></td>
<td>
<p>The p*p matrix giving the pairwise correlation of every two test statistics.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rbinom(n=100, size=1, prob=0.5)
null_mod &lt;- glm(Y~1, family=binomial(link="logit"))
factor_mat &lt;- matrix(data=rnorm(n=100*5), nrow=100)
calc_score_stats(null_mod, factor_mat, "logit")
</code></pre>

<hr>
<h2 id='calc_var_nonzero_mu'>calc_var_mu_nonzero.R</h2><span id='topic+calc_var_nonzero_mu'></span>

<h3>Description</h3>

<p>Internal function to calculate variance of S(t) when the Z_1,...,Z_d have nonzero mean.  
See GBJ paper for more details.  Vectorized in t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_var_nonzero_mu(d, t, mu, pairwise_cors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_var_nonzero_mu_+3A_d">d</code></td>
<td>
<p>The number of test statistics in the set.</p>
</td></tr>
<tr><td><code id="calc_var_nonzero_mu_+3A_t">t</code></td>
<td>
<p>The threshold which determines the properties of S(t).</p>
</td></tr>
<tr><td><code id="calc_var_nonzero_mu_+3A_mu">mu</code></td>
<td>
<p>The common mean of the test statistics Z_1,...,Z_d</p>
</td></tr>
<tr><td><code id="calc_var_nonzero_mu_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test 
statistics, where d is total number of test statistics in the set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance of S(t) when the Z_1,...,Z_d have nonzero mean mu.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calc_var_nonzero_mu(d=5, t=1, mu=1, pairwise_cors=rep(0.3, 10))
</code></pre>

<hr>
<h2 id='ebb_loglik'>ebb_loglik.R</h2><span id='topic+ebb_loglik'></span>

<h3>Description</h3>

<p>An internal function only (doesn't do error checking or take care of boundary cases).
The log-likelihood (log-PMF) calculation for the Extended Beta-Binomial proposed by Prentice (1986).
Takes in a vectorized argument because we apply() it in run_BB_GBJ().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebb_loglik(x, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebb_loglik_+3A_x">x</code></td>
<td>
<p>A vector of length 3 with (1) value of outcome (2) mu parameter (3) gamma parameter</p>
</td></tr>
<tr><td><code id="ebb_loglik_+3A_d">d</code></td>
<td>
<p>The number of test stsatistics in the set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log( Pr(V=x[1]) ) where V~EBB(mu,gamma; d)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ebb_loglik(x=c(1, 0.5, 0.1), d=10)	
</code></pre>

<hr>
<h2 id='estimate_ss_cor'>estimate_ss_cor.R</h2><span id='topic+estimate_ss_cor'></span>

<h3>Description</h3>

<p>Estimate the correlations between GWAS summary statistics using reference panel eigenvectors
and reference panel genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_ss_cor(ref_pcs, ref_genotypes, link_function)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_ss_cor_+3A_ref_pcs">ref_pcs</code></td>
<td>
<p>An n*m matrix containing PCs calculated from the reference panel. Here n is the
number of subjects in the reference panel and m is roughly the number of PCs used in the original
analysis which produced the summary statistics.</p>
</td></tr>
<tr><td><code id="estimate_ss_cor_+3A_ref_genotypes">ref_genotypes</code></td>
<td>
<p>An n*d matrix holding the genotypes from the reference panel, where the d columns
correspond to the d SNPs for which we have summary statistics. No missing data allowed.</p>
</td></tr>
<tr><td><code id="estimate_ss_cor_+3A_link_function">link_function</code></td>
<td>
<p>Either &quot;linear&quot; or &quot;logit&quot; or &quot;log&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>cor_mat</code></td>
<td>
<p>The d*d matrix giving the pairwise correlation of every two test statistics.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ref_pcs &lt;- matrix(data=runif(n=1000, min=-0.2, max=0.2), ncol=5)
ref_genotypes &lt;- matrix(data=rbinom(n=2000, size=2, prob=0.3), ncol=10)
estimate_ss_cor(ref_pcs=ref_pcs, ref_genotypes=ref_genotypes, link_function="linear")
</code></pre>

<hr>
<h2 id='FGFR2'>Genotypes at FGFR2 SNPs for subjects from 'GBR' population in the 1000 Genomes Project.</h2><span id='topic+FGFR2'></span>

<h3>Description</h3>

<p>A dataset containing the genotypes (number of minor alleles) for each of 91 subjects
from the 'GBR' population in the 1000 Genomes Projects.  There are 64 SNPs documented
here, all residing in the FGFR2 gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FGFR2)
</code></pre>


<h3>Format</h3>

<p>A matrix with 91 rows (one for each subject) and 64 columns (one for each SNP)
</p>


<h3>Source</h3>

<p><a href="https://www.internationalgenome.org/data">https://www.internationalgenome.org/data</a>
</p>

<hr>
<h2 id='GBJ'>GBJ.R</h2><span id='topic+GBJ'></span>

<h3>Description</h3>

<p>Calculate the Generalized Berk-Jones test statistic and p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBJ(test_stats, cor_mat = NULL, pairwise_cors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GBJ_+3A_test_stats">test_stats</code></td>
<td>
<p>Vector of test statistics for each factor in the set (i.e. marginal
test statistic for each SNP in a gene).</p>
</td></tr>
<tr><td><code id="GBJ_+3A_cor_mat">cor_mat</code></td>
<td>
<p>d*d matrix of the correlations between all the test statistics in
the set, where d is the total number of test statistics in the set.
You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
<tr><td><code id="GBJ_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test
statistics. You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>GBJ</code></td>
<td>
<p>The observed Generalized Higher Criticism test statistic.</p>
</td></tr>
<tr><td><code>GBJ_pvalue</code></td>
<td>
<p>The p-value of this observed value, given the size of the set and
correlation structure.</p>
</td></tr>
<tr><td><code>err_code</code></td>
<td>
<p>Sometimes if your p-value is very small (&lt;10^(-12) usually), R/C++ do not
have enough precision in their standard routines to calculate the number accurately. In
these cases (and very rarely others) we switch to standard Berk-Jones instead (more stable
numerically) and let you know with a message here.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Should return statistic = 0.9248399 and p_value = 0.2670707
set.seed(100)
Z_vec &lt;- rnorm(5) + rep(1,5)
cor_Z &lt;- matrix(data=0.2, nrow=5, ncol=5)
diag(cor_Z) &lt;- 1
GBJ(test_stats=Z_vec, cor_mat=cor_Z)
</code></pre>

<hr>
<h2 id='GBJ_objective'>GBJ_objective.R</h2><span id='topic+GBJ_objective'></span>

<h3>Description</h3>

<p>Calculates the GBJ objective function at given threshold points.  Used both to calculate the
observed GBJ statistic and also to find the boundary points for p-value calculation (through uniroot).
Mostly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBJ_objective(t_vec, d, k_vec = NULL, pairwise_cors, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GBJ_objective_+3A_t_vec">t_vec</code></td>
<td>
<p>A scalar or vector of threshold points (magnitudes of test statistics)
to calculate the objective at.</p>
</td></tr>
<tr><td><code id="GBJ_objective_+3A_d">d</code></td>
<td>
<p>The total number of test statistics in the set.</p>
</td></tr>
<tr><td><code id="GBJ_objective_+3A_k_vec">k_vec</code></td>
<td>
<p>If t_vec is not a vector all of the test statistics, let us know which ordered
objective functions we are calculating (can be a vector with the same length as t).</p>
</td></tr>
<tr><td><code id="GBJ_objective_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test
statistics, where d is total number of test statistics in the set.</p>
</td></tr>
<tr><td><code id="GBJ_objective_+3A_offset">offset</code></td>
<td>
<p>Used if we want to subtract the observed gbj value for uniroot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The GBJ objective at t (for given d, kkk, pairwise_cors) minus the offset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GBJ_objective(t_vec=1:5, d=5, k_vec=NULL, pairwise_cors=rep(0.2,10), offset=0)
</code></pre>

<hr>
<h2 id='GBJ_pvalue'>GBJ_pvalue.R</h2><span id='topic+GBJ_pvalue'></span>

<h3>Description</h3>

<p>Calculate the p-value for the Generalized Berk-Jones (GBJ) statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBJ_pvalue(observed_gbj, d, pairwise_cors, times_to_try = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GBJ_pvalue_+3A_observed_gbj">observed_gbj</code></td>
<td>
<p>The observed value of the GBJ statistic.</p>
</td></tr>
<tr><td><code id="GBJ_pvalue_+3A_d">d</code></td>
<td>
<p>The number of test statistics in the set.</p>
</td></tr>
<tr><td><code id="GBJ_pvalue_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test
statistics, where d is total number of test statistics in the set.</p>
</td></tr>
<tr><td><code id="GBJ_pvalue_+3A_times_to_try">times_to_try</code></td>
<td>
<p>Sometimes the numerical root-finder is finnicky, so we have to give
it extra chances to try and calculate the p-value if first time is failure.  Recommend
setting this parameter to 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value of the GBJ test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GBJ_pvalue(observed_gbj=2, d=5, pairwise_cors=rep(0.2,10))
</code></pre>

<hr>
<h2 id='gbr_pcs'>Simulated Principal Components for 'GBR' population in the 1000 Genomes Project.</h2><span id='topic+gbr_pcs'></span>

<h3>Description</h3>

<p>A dataset containing 5 simulated Principal Components (PCs) for each of 91 subjects
from the 'GBR' population in the 1000 Genomes Projects.  These would normally be
used as covariates in a regression model to control for population stratification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gbr_pcs)
</code></pre>


<h3>Format</h3>

<p>A matrix with 91 rows (one for each subject) and 5 columns (one for each PC)
</p>

<hr>
<h2 id='GHC'>GHC.R</h2><span id='topic+GHC'></span>

<h3>Description</h3>

<p>Calculate the Generalized Higher Criticism test statistic and p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GHC(test_stats, cor_mat = NULL, pairwise_cors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GHC_+3A_test_stats">test_stats</code></td>
<td>
<p>Vector of test statistics for each factor in the set (i.e. marginal
test statistic for each SNP in a gene).</p>
</td></tr>
<tr><td><code id="GHC_+3A_cor_mat">cor_mat</code></td>
<td>
<p>d*d matrix of the correlations between all the test statistics in
the set, where d is the total number of test statistics in the set.
You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
<tr><td><code id="GHC_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test
statistics. You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>GHC</code></td>
<td>
<p>The observed Generalized Higher Criticism test statistic.</p>
</td></tr>
<tr><td><code>GHC_pvalue</code></td>
<td>
<p>The p-value of this observed value, given the size of the set and
correlation structure.</p>
</td></tr>
<tr><td><code>err_code</code></td>
<td>
<p>Sometimes if your p-value is very small (&lt;10^(-12) usually), R/C++ do not
have enough precision in their standard routines to calculate the number accurately. In
these cases (and very rarely others) we switch to standard Higher Criticism instead (more stable
numerically) and let you know with a message here.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
Z_vec &lt;- rnorm(5)
cor_Z &lt;- matrix(data=0.2, nrow=5, ncol=5)
diag(cor_Z) &lt;- 1
GHC(test_stats=Z_vec, cor_mat=cor_Z)
</code></pre>

<hr>
<h2 id='GHC_objective'>GHC_objective.R</h2><span id='topic+GHC_objective'></span>

<h3>Description</h3>

<p>Internal function to calculate the value of the kth GHC objective (possibly minus an offset)
when the kth p-value order statistic is x, for a set of size d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GHC_objective(x, k, d, offset, pairwise_cors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GHC_objective_+3A_x">x</code></td>
<td>
<p>The p-value of the kth p-value order statistic.</p>
</td></tr>
<tr><td><code id="GHC_objective_+3A_k">k</code></td>
<td>
<p>Which objective to use.</p>
</td></tr>
<tr><td><code id="GHC_objective_+3A_d">d</code></td>
<td>
<p>The size of the set.</p>
</td></tr>
<tr><td><code id="GHC_objective_+3A_offset">offset</code></td>
<td>
<p>Used to zero the correct value when we put this into uniroot</p>
</td></tr>
<tr><td><code id="GHC_objective_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test 
statistics, where d is total number of test statistics in the set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the kth HC objective
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GHC_objective(x=0.1, k=2, d=5, offset=0, pairwise_cors=rep(0.2,10))
</code></pre>

<hr>
<h2 id='HC'>HC.R</h2><span id='topic+HC'></span>

<h3>Description</h3>

<p>Calculate the Higher Criticism test statistic and p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HC(test_stats, cor_mat = NULL, pairwise_cors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HC_+3A_test_stats">test_stats</code></td>
<td>
<p>Vector of test statistics for each factor in the set (i.e. marginal
test statistic for each SNP in a gene).</p>
</td></tr>
<tr><td><code id="HC_+3A_cor_mat">cor_mat</code></td>
<td>
<p>d*d matrix of the correlations between all the test statistics in
the set, where d is the total number of test statistics in the set.
You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
<tr><td><code id="HC_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test
statistics. You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>HC</code></td>
<td>
<p>The observed Higher Criticism test statistic.</p>
</td></tr>
<tr><td><code>HC_pvalue</code></td>
<td>
<p>The p-value of this observed value, given the size of the set and
correlation structure.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Should return statistic = 2.067475 and p_value = 0.2755146
set.seed(100)
Z_vec &lt;- rnorm(5) + rep(1,5)
cor_Z &lt;- matrix(data=0.2, nrow=5, ncol=5)
diag(cor_Z) &lt;- 1
HC(test_stats=Z_vec, cor_mat=cor_Z)
</code></pre>

<hr>
<h2 id='herm_poly_diff_t'>herm_poly_diff_t.R</h2><span id='topic+herm_poly_diff_t'></span>

<h3>Description</h3>

<p>Internal function to add up the infinite sum term in calculating the variance of S(t) when
the test statistics Z_1,...,Z_d have a non-zero mean.  See GBJ paper for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>herm_poly_diff_t(t1, t2, pairwise_cors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="herm_poly_diff_t_+3A_t1">t1</code></td>
<td>
<p>t1 and t2 are interchangeable.  One should be t-mu and one should be -t-mu.</p>
</td></tr>
<tr><td><code id="herm_poly_diff_t_+3A_t2">t2</code></td>
<td>
<p>t1 and t2 are interchangeable.  One should be t-mu and one should be -t-mu.</p>
</td></tr>
<tr><td><code id="herm_poly_diff_t_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test 
statistics, where d is total number of test statistics in the set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the infinite sum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>herm_poly_diff_t(t1=0, t2=0, pairwise_cors=rep(0.3, 10))
</code></pre>

<hr>
<h2 id='minP'>minP.R</h2><span id='topic+minP'></span>

<h3>Description</h3>

<p>Given a vector of individual test statistics and their pairwise correlations, calculate
the MinimumP (see Conneely and Boehnke, 2007) second-level test statistic and it's p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minP(test_stats, cor_mat = NULL, pairwise_cors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minP_+3A_test_stats">test_stats</code></td>
<td>
<p>Vector of test statistics for each factor in the set (i.e. marginal
test statistic for each SNP in a gene)</p>
</td></tr>
<tr><td><code id="minP_+3A_cor_mat">cor_mat</code></td>
<td>
<p>d*d matrix of the correlations between all the test statistics in
the set, where d is the total number of test statistics in the set.
You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
<tr><td><code id="minP_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>A vector of all d(d-1)/2 pairwise correlations between the test
statistics. You only need to specify EITHER cor_mat OR pairwise_cors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>minP</code></td>
<td>
<p>The observed MinimumP test statistic.</p>
</td></tr>
<tr><td><code>minP_pvalue</code></td>
<td>
<p>The p-value of this observed value, given the size of the set and
correlation structure.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Should return statistic = 0.05918928 and p_value = 0.2525972.
set.seed(100)
Z_vec &lt;- rnorm(5) + rep(1,5)
cor_Z &lt;- matrix(data=0.2, nrow=5, ncol=5)
diag(cor_Z) &lt;- 1
minP(test_stats=Z_vec, cor_mat=cor_Z)
</code></pre>

<hr>
<h2 id='OMNI_individual'>omni_individual.R</h2><span id='topic+OMNI_individual'></span>

<h3>Description</h3>

<p>Computes the omnibus test statistic combining GBJ, GHC, minP, and SKAT.
This version of the function assumes you have the individual factor data (i.e. genotypes)
for each subject.  If you only have summary statistics, use omni_ss().
You WILL NOT be able to use this function unless you have also loaded
the SKAT package (install.packages(&quot;SKAT&quot;); library(SKAT)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OMNI_individual(null_model, factor_matrix, link_function, num_boots = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OMNI_individual_+3A_null_model">null_model</code></td>
<td>
<p>An R regression model fitted using glm().  Do not use lm(), even for linear regression!</p>
</td></tr>
<tr><td><code id="OMNI_individual_+3A_factor_matrix">factor_matrix</code></td>
<td>
<p>An n*d matrix with each factor (i.e. each SNP) as one column.  There should be no missing data.</p>
</td></tr>
<tr><td><code id="OMNI_individual_+3A_link_function">link_function</code></td>
<td>
<p>Either &quot;linear&quot; or &quot;logit&quot; or &quot;log&quot;.</p>
</td></tr>
<tr><td><code id="OMNI_individual_+3A_num_boots">num_boots</code></td>
<td>
<p>Number of bootstrap repetitions to find correlation matrix of set-based statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>OMNI</code></td>
<td>
<p>The observed omnibus test statistic.</p>
</td></tr>
<tr><td><code>OMNI_pvalue</code></td>
<td>
<p>The p-value of the OMNI test</p>
</td></tr>
<tr><td><code>err_code</code></td>
<td>
<p>Sometimes if your p-value is very small (&lt; 1*10^(-10)), R may run into numerical
issues. This message will alert you if such a situation occurs.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>factor_matrix &lt;- matrix(data=rbinom(n=1000, size=2, prob=0.3), ncol=5)
Y &lt;- rnorm(n=200)
null_mod &lt;- glm(Y ~ 1)
OMNI_individual(null_model=null_mod, factor_matrix=factor_matrix,
link_function='linear', num_boots=5)
</code></pre>

<hr>
<h2 id='OMNI_ss'>omni_ss.R</h2><span id='topic+OMNI_ss'></span>

<h3>Description</h3>

<p>Computes the omnibus test statistic combining GBJ, GHC, minP, and SKAT.
This version of the function assumes you are using GWAS summary statistics.
If you individual-level genotype data, use omni_individual().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OMNI_ss(test_stats, cor_mat, num_boots = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OMNI_ss_+3A_test_stats">test_stats</code></td>
<td>
<p>Vector of test statistics for each factor in the set (i.e. marginal
test statistic for each SNP in a gene)</p>
</td></tr>
<tr><td><code id="OMNI_ss_+3A_cor_mat">cor_mat</code></td>
<td>
<p>d*d matrix of the correlations between all the test statistics in
the set, where d is the total number of test statistics in the set.</p>
</td></tr>
<tr><td><code id="OMNI_ss_+3A_num_boots">num_boots</code></td>
<td>
<p>Number of bootstrap repetitions to find correlation matrix of set-based statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>OMNI</code></td>
<td>
<p>The observed omnibus test statistic.</p>
</td></tr>
<tr><td><code>OMNI_pvalue</code></td>
<td>
<p>The p-value of the OMNI test</p>
</td></tr>
<tr><td><code>err_code</code></td>
<td>
<p>Sometimes if your p-value is very small (&lt; 1*10^(-10)), R may run into numerical
issues. This message will alert you if such a situation occurs.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cor_mat &lt;- matrix(data=0.3, nrow=5, ncol=5)
diag(cor_mat) &lt;- 1
test_stats &lt;- as.numeric(mvtnorm::rmvnorm(n=1, sigma=cor_mat))
OMNI_ss(test_stats=test_stats, cor_mat=cor_mat, num_boots=5)
</code></pre>

<hr>
<h2 id='parse_input'>parse_input.R</h2><span id='topic+parse_input'></span>

<h3>Description</h3>

<p>Internal function to accept the input as unsorted Z-statistics and either a matrix
or vector of correlations, and return the t_vec and pairwise_cors. Also do limited
error checking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_input(test_stats, cor_mat = NULL, pairwise_cors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_input_+3A_test_stats">test_stats</code></td>
<td>
<p>All test statistics in the set</p>
</td></tr>
<tr><td><code id="parse_input_+3A_cor_mat">cor_mat</code></td>
<td>
<p>The correlation matrix of the test statistics</p>
</td></tr>
<tr><td><code id="parse_input_+3A_pairwise_cors">pairwise_cors</code></td>
<td>
<p>The vector of all pairwise correlations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>t_vec</code></td>
<td>
<p>The sorted magnitudes of test statistics</p>
</td></tr>
<tr><td><code>pairwise_cors</code></td>
<td>
<p>The vector of all pairwise correlations</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>parse_input(test_stats=rnorm(5), pairwise_cors=rep(0.3,10))
</code></pre>

<hr>
<h2 id='qnorm_mu'>qnorm_mu.R</h2><span id='topic+qnorm_mu'></span>

<h3>Description</h3>

<p>Internal function to calculate Pr(-t &lt; Z &lt; t) - kkk/d for Z~N(mu,1).
Take the root of this function to find the mu such that P(|Z|&gt;=t_k) = k/d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qnorm_mu(mu, t, kkk, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qnorm_mu_+3A_mu">mu</code></td>
<td>
<p>The mean of the normal random variable.</p>
</td></tr>
<tr><td><code id="qnorm_mu_+3A_t">t</code></td>
<td>
<p>The threshold (boundaries) we are interested in.</p>
</td></tr>
<tr><td><code id="qnorm_mu_+3A_kkk">kkk</code></td>
<td>
<p>We decided to make you input the fraction in two parts.</p>
</td></tr>
<tr><td><code id="qnorm_mu_+3A_d">d</code></td>
<td>
<p>We decided to make you input the fraction in two parts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pr(-t &lt; Z &lt; t) - kkk/d for Z~N(mu,1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qnorm_mu(mu=0, t=1.96, kkk=1, d=5)		# Should return 0
</code></pre>

<hr>
<h2 id='score_stats_only'>score_stats_only.R</h2><span id='topic+score_stats_only'></span>

<h3>Description</h3>

<p>Starting with individual-level data on p factors, generate score test statistics for each
factor for input into GBJ/GHC/HC/BJ/minP.  DOES NOT get the correlations (assumed known).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_stats_only(null_model, factor_matrix, link_function, P_mat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_stats_only_+3A_null_model">null_model</code></td>
<td>
<p>An R regression model fitted using glm().  Do not use lm(), even for linear regression!</p>
</td></tr>
<tr><td><code id="score_stats_only_+3A_factor_matrix">factor_matrix</code></td>
<td>
<p>An n*d matrix with each factor as one column.  There should be no missing data.</p>
</td></tr>
<tr><td><code id="score_stats_only_+3A_link_function">link_function</code></td>
<td>
<p>Either &quot;linear&quot; or &quot;logit&quot; or &quot;log&quot;.</p>
</td></tr>
<tr><td><code id="score_stats_only_+3A_p_mat">P_mat</code></td>
<td>
<p>The projection matrix used in calculation may be passed in to speed up the calculation.
See paper for details. Default is null.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The d score test statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rbinom(n=100, size=1, prob=0.5)
null_mod &lt;- glm(Y~1, family=binomial(link="logit"))
factor_matrix &lt;- matrix(data=rnorm(n=100*5), nrow=100)
score_stats_only(null_mod, factor_matrix, "logit")
</code></pre>

<hr>
<h2 id='surv'>surv.R</h2><span id='topic+surv'></span>

<h3>Description</h3>

<p>Survival (1 minus the CDF) function of standard normal random variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability that a standard normal random variable is greater than x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surv(0)		# Should return 0.5
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
