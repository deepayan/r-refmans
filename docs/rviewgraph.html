<!DOCTYPE html><html><head><title>Help for package rviewgraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rviewgraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rviewgraph-package'><p>Animated Graph Layout Viewer</p></a></li>
<li><a href='#rViewGraph'><p>This is a function to create and start a 'Java' graph animation GUI.</p></a></li>
<li><a href='#vg'><p>Animated graph viewer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Animated Graph Layout Viewer</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Alun Thomas</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alun Thomas &lt;Alun.Thomas@utah.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides 'Java' graphical user interfaces 
    for viewing, manipulating and plotting graphs. 
    Graphs may be directed or undirected.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Enhances:</td>
<td>igraph, Matrix</td>
</tr>
<tr>
<td>Depends:</td>
<td>rJava</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 8)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-10 17:35:48 UTC; alun</td>
</tr>
<tr>
<td>Collate:</td>
<td>'onLoad.R' 'rviewgraph-package.R' 'rViewGraph.R' 'vg.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-10 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rviewgraph-package'>Animated Graph Layout Viewer</h2><span id='topic+rviewgraph-package'></span><span id='topic+_PACKAGE'></span><span id='topic+rviewgraph'></span>

<h3>Description</h3>

<p>for graph viewing, manipulation and plotting.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> rviewgraph</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-10-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirements: </td><td style="text-align: left;"> 'Java' &gt;= 8</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Provides 'Java' graphical user interfaces (GUI) for viewing, manipulating
and plotting graphs. Graphs may be directed or undirected. 
</p>
<p>The original program, <code>rViewGraph</code> takes
a graph specified as an incidence matrix, array of edges, or in <code>igraph</code> format
and runs a graphical user interface that shows an
animation of a force directed algorithm positioning the vertices in two dimensions.
If run from a non-interactive R session, <code>rViewGraph</code> prints an
error message and returns <code>NULL</code>.
</p>
<p>A new program, <code>vg</code>, is an alternative interface to the underlying 
'Java' program that provides a more coherent way of specifying the graph,
and more control over how the vertices appear in the GUI. Specifically, 
<code>vg</code> allows for arbitrary integer indices to identify the vertices,
and allows changes to the graph's vertex and edge sets. The text labels,
colours, shapes and sizes of the vertices can also be specified, either before
or after vertices are added to the graph. These changes can be made while the
vertex positioning animation is running. <code>vg</code> also provides 
functions for saving and restoring the state of the graph including
vertices and edges,
vertex positions, and vertex appearances.
<code>vg()</code> can be run non-interactively without a GUI which allows a 
graph structure to be built and saved for a future interactive session.
</p>
<p>Both programs can also start a dialog box to print the current view of the graph.
</p>
<p>The underlying positioning methods works well for graphs of various structure
of up to a few thousand vertices. It's not fazed by graphs that comprise several
components.
</p>


<h3>See Also</h3>

<p>vg rViewGraph
</p>
<p>#' There is a vignette on 'Building a simple graph sampler'.
</p>

<hr>
<h2 id='rViewGraph'>This is a function to create and start a 'Java' graph animation GUI.</h2><span id='topic+rViewGraph'></span><span id='topic+rViewGraph.default'></span><span id='topic+rViewGraph.igraph'></span>

<h3>Description</h3>

<p>Creates and starts an animated graphical user interface (GUI) for 
positioning the vertices of a graph in 2 dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rViewGraph(object, names, cols, shapes, layout, directed, running, ...)

## Default S3 method:
rViewGraph(
  object,
  names = NULL,
  cols = "yellow",
  shapes = 0,
  layout = NULL,
  directed = FALSE,
  running = TRUE,
  ...
)

## S3 method for class 'igraph'
rViewGraph(
  object,
  names = igraph::V(object)$name,
  cols = "yellow",
  shapes = 0,
  layout = igraph::layout.random(object),
  directed = igraph::is.directed(object),
  running = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rViewGraph_+3A_object">object</code></td>
<td>
<p>the object specifying the graph. This can be specified in various ways:
</p>

<ul>
<li><p> A square <code>n = dim(object)[1]</code> by <code>n</code> real valued incidence matrix. 
This will create a graph with <code>n</code> vertices indexed
by <code>1:n</code> and edges between vertices with indices <code>i</code> and <code>j</code> if <code>object[i,j] != 0</code>.
If the graph is directed edges are directed from <code>i</code> to <code>j</code> if the entry is positive,
and from <code>j</code> to <code>i</code> if the entry is negative.
</p>
</li>
<li><p> An <code>m = dim(object)[1]</code> by 2 matrix of positive integers
specifying the indexes of the vertices at the ends of <code>m</code> edges. This will create a graph with
<code>n = max(object)</code> vertices indexed by <code>1:max(object)</code> and edges connecting the vertex
indexed by  <code>object[i,1]</code> to 
the vertex indexed by  <code>object[i,2]</code> for each <code>i</code> in <code>1:m</code>.
If the graph is directed, the edges are directed from <code>object[i,1]</code> to <code>object[i,2]</code>.
NOTE: A 2 by 2 matrix will be interpreted as an incidence matrix, not an array of edges.
</p>
</li>
<li><p> A vector of <code>2*m</code> positive integers specifying the indexes of the vertices at 
the ends of <code>m = length(object)/2</code> edges. This is the way in which <code>igraph</code>
specifies edges. If <code>x</code> is such a vector, calling <code>rViewGraph{x}</code> is equivalent
to calling <code>rViewGraph(matrix(x,ncol=2,byrow=F))</code>.
</p>
</li>
<li><p> An <code>igraph</code> graph object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rViewGraph_+3A_names">names</code></td>
<td>
<p>the names of the vertices. This is an object that can be interpreted
as a vector of 
strings that will be used to label the vertices. If the length is less than the number of
vertices, the names will be cycled. The default is <code>names = 1:n</code>, where <code>n</code>
is the number of vertices. If unlabeled vertices are required use, for example, <code>names=" "</code>.
The size of the string is used to determine the size of the vertex so, for instance,
<code>names = " A "</code> will produce bigger vertices than <code>names = "A"</code>.</p>
</td></tr>
<tr><td><code id="rViewGraph_+3A_cols">cols</code></td>
<td>
<p>the colours of the vertices. This is on object that can be 
interpreted as a vector of colours specified in the usual <code>R</code> ways. 
If the length is less than the number of vertices, the colours
will be cycled. The default is <code>cols = "yellow"</code>.</p>
</td></tr>
<tr><td><code id="rViewGraph_+3A_shapes">shapes</code></td>
<td>
<p>the shapes of the vertices. This is a vector of integers specifying the shapes
of the vertices. The available shapes are:
</p>

<ul>
<li><p> 0 = rectangle
</p>
</li>
<li><p> 1 = oval
</p>
</li>
<li><p> 2 = diamond
</p>
</li>
<li><p> any other values are taken as 0.
</p>
</li></ul>

<p>The default is <code>shapes = 0</code>.</p>
</td></tr>
<tr><td><code id="rViewGraph_+3A_layout">layout</code></td>
<td>
<p>the starting positions of the vertices. This is an <code>n</code> by 2 array
of reals with <code>layout[i,]</code> specifying the horizontal and vertical coordinates
for the starting point 
of the <code>i</code>th vertex. By default this is set to <code>NULL</code> in which case
random starting points are used.</p>
</td></tr>
<tr><td><code id="rViewGraph_+3A_directed">directed</code></td>
<td>
<p>indicates whether or not the graph is directed.</p>
</td></tr>
<tr><td><code id="rViewGraph_+3A_running">running</code></td>
<td>
<p>indicates whether or not to start with the animation running.</p>
</td></tr>
<tr><td><code id="rViewGraph_+3A_...">...</code></td>
<td>
<p>passed along extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates and starts a 'Java' GUI showing a real time animation of a Newton-Raphson
optimization of a force function specified between the vertices of an arbitrary graph.
There are attractive forces between 
adjacent vertices and repulsive forces between all vertices.
The repulsions go smoothly to zero in a finite distance between vertices so that,
unlike some other methods, different components don't send each other off to infinity.
</p>
<p>The program is controlled by a slide bar, some buttons, the arrow, home and
shift keys, but mostly by mouse operations. All three mouse buttons are used.
The interactive mouse, key and slide bar operations are described below.
</p>


<h3>Value</h3>

<p><code>rViewGraph</code> is intended only for interactive use. When used in a non-interactive environment
it immediately exits returning the value <code>NULL</code>.
Otherwise, all versions of <code>rViewGraph</code> return a list of functions that control the actions of 
the interactive viewer. 
</p>
<table>
<tr><td><code>run()</code></td>
<td>
<p>Starts the GUI running if it's not already doing so.</p>
</td></tr>
<tr><td><code>stop()</code></td>
<td>
<p>Stops the GUI running if it's running.</p>
</td></tr>
<tr><td><code>hide()</code></td>
<td>
<p>Stops the GUI and hides it.</p>
</td></tr>
<tr><td><code>show()</code></td>
<td>
<p>Shows the GUI. If it was running when <code>hide</code> was called, it starts running again.</p>
</td></tr>
<tr><td><code>getLayout()</code></td>
<td>
<p>Returns the coordinates of the vertices as currently shown in the GUI.
These are given as an <code>n</code> by 2 array as required for the <code>layout</code> parameter
of <code>rViewGraph</code> itself.</p>
</td></tr>
<tr><td><code>setLayout(layout = NULL)</code></td>
<td>
<p>Sets the coordinates of the vertices to the given values. <code>layout</code>
is specified in the same way as required for the <code>layout</code> parameter of <code>rViewGraph</code>
itself. The default has <code>layout</code> set to <code>NULL</code>, and new random coordinates are generated.</p>
</td></tr>
<tr><td><code>hidePaper()</code></td>
<td>
<p>By default the GUI indicates, with a different colour, the portion
of the plane that corresponds to the current choice of paper for printing. This function
removes that area.</p>
</td></tr>
<tr><td><code>showPaper(size = "letter"</code>, <code>landscape = TRUE)</code></td>
<td>
<p>Indicates, with a different colour, the portion of the
plane corresponding to a choice of paper for printing. <code>size</code> can be any of 
<code>letter</code>, <code>A4</code>, <code>A3</code>, <code>A2</code>, <code>A1</code>, <code>A0</code>, <code>C1</code>, or <code>C0</code>.
<code>landscape</code> can be either <code>TRUE</code> or <code>FALSE</code>, in which case portrait orientation
is used. The default is to show the portion of the plane that would be printed on
US letter in landscape orientation.</p>
</td></tr>
<tr><td><code>hideAxes()</code></td>
<td>
<p>By default, axes are shown to indicate the origin. This
function hides them.</p>
</td></tr>
<tr><td><code>showAxes()</code></td>
<td>
<p>Shows the axes if they are hidden.</p>
</td></tr>
<tr><td><code>writePostScript()</code></td>
<td>
<p>This starts a <code>Java</code> PostScript print job dialog box that can be
used send the current view of the graph to a printer or to write a PostScript file. The plot
produced should closely match what is indicated by <code>showPaper</code>.</p>
</td></tr>
<tr><td><code>ps()</code></td>
<td>
<p>Alias for <code>writePostScript</code>.</p>
</td></tr>
</table>


<h3>Interactive mouse, key and slide bar controls</h3>


<ul>
<li><p> Slide bars at the bottom of the GUI control the 
repulsive force in the energy
equation used to set the coordinates.
If the graph is undirected, there is a single 'Repulsion' parameter, 
if directed, there
are 'X-Repulsion' and 'Y-Repulsion' parameters, 
and a 'Gravity' parameter that influences
how these are combined.
</p>
</li>
<li><p> Mouse operations without shift key and without control key pressed.
</p>

<ol>
<li><p> Left mouse: Drags a vertex. Vertex is free on release. 
</p>
</li>
<li><p> Middle mouse: Drags a vertex. Vertex is fixed at release position. 
</p>
</li>
<li><p> Right mouse: Translates the view by the amount dragged. 
A bit like putting
your finger on a piece of paper and moving it. 
</p>
</li>
<li><p> Double click with any mouse button in the background: 
Resets the vertices to new random positions. 
</p>
</li></ol>

</li>
<li><p> Mouse operations with shift key but without control key pressed.
</p>

<ol>
<li><p> Left mouse: Drags a vertex and the component it is in. 
Vertex and component free on release.
</p>
</li>
<li><p> Middle mouse: Drags a vertex and the component it is in. 
Vertex and component are fixed at release positions.
</p>
</li>
<li><p> Right mouse: Translates the positions of the vertices relative to 
the position of the canvas by the amount dragged. This is useful to center 
the picture on the canvas ready for outputting.
</p>
</li></ol>

</li>
<li><p> Mouse operations without shift key but with control key pressed.
</p>

<ol>
<li><p> Left mouse: Click on a vertex to un-hide any hidden neighbours.
</p>
</li>
<li><p> Middle mouse: Click on a vertex to hide it.
</p>
</li>
<li><p> Double click left mouse: Un-hides all hidden vertices.
</p>
</li>
<li><p> Double click middle mouse: Hides all vertices.
</p>
</li></ol>

</li>
<li><p> Mouse operations with shift key and with control key pressed.
</p>

<ol>
<li><p> Left mouse: Click on a vertex to un-hide all vertices 
in the same component.
</p>
</li>
<li><p> Middle mouse: Click on a vertex to hide it and the component it is in.
</p>
</li></ol>

</li>
<li><p> Key functions without shift key pressed. 
Mouse has to be in the picture canvas.
</p>

<ol>
<li><p> Up arrow: Increases the scale of viewing by 10%.
</p>
</li>
<li><p> Down arrow: Decreases the scale of viewing by 10%.
</p>
</li>
<li><p> Left arrow: Rotates the view by 15 degrees clockwise.
</p>
</li>
<li><p> Right arrow: Rotates the view by 15 degrees anticlockwise.
</p>
</li>
<li><p> Home key: Undoes all scalings and rotations and places the origin at
the top left corner of the canvas.
</p>
</li></ol>

</li>
<li><p> Key functions with shift key pressed. 
Mouse has to be in the picture canvas.
</p>

<ol>
<li><p> Up arrow: Increases the vertex positions by 10% 
relative to the scale of the canvas.
</p>
</li>
<li><p> Down arrow: Decreases the vertex positions by 10% 
relative to the scale of the canvas.
</p>
</li>
<li><p> Left arrow: Rotates the vertex positions by 15 
degrees clockwise relative to the canvas orientation.
</p>
</li>
<li><p> Right arrow: Rotates the vertex positions by 15 
degrees anticlockwise relative to the canvas orientation.
</p>
</li></ol>

</li></ul>



<h3>Author(s)</h3>

<p>Alun Thomas
</p>


<h3>Source</h3>

<p>A full description of the force function and algorithm used 
is given by
C Cannings and A Thomas, 
Inference, simulation and enumeration of genealogies.
In D J Balding, M Bishop, and C Cannings, editors, The Handbook of Statistical
Genetics. Third Edition, pages 781-805. John Wiley &amp; Sons, Ltd, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rviewgraph)

# First generate the random edges of an Erdos Renyi random graph.
f = sample(100,size=200,replace=TRUE)
t = sample(100,size=200,replace=TRUE)

# The following should all show the same graph:
# ... specified as a two column matrix.
v1 = rViewGraph(cbind(f,t))

# ... in 'igraph' preferred format.
v2 = rViewGraph(c(f,t))

# ... as an adjacency matrix.
x = matrix(0,ncol=max(f,t),nrow=max(f,t))
for (i in 1:length(f)) x[f[i],t[i]] = 1
v3 = rViewGraph(x)


# Specifying names, colours and shapes.

# Use unlabeled vertices, as red, green and blue diamonds.
v4 = rViewGraph(cbind(f,t), names = "  ", cols = c(2,3,4), shapes=2)

# Use yellow vertices with random shapes, labeled with capital letters.
y = matrix(sample(1:26,100,TRUE),ncol=2)
v5 = rViewGraph(y,names=LETTERS,cols="cyan",shapes=sample(0:2,26,TRUE))


# Controlling a currently active GUI.
if (!is.null(v5))
{
	# Shift the coordinates, although this is more 
# easily done with mouse controls.
	v5$setLayout(100 + v5$getLayout())

# Reset the coordinates to random values.
v5$setLayout()

	# Pepare a plot for printing, fix it, and start a PostScript print job.
	v5$hideAxes()
	v5$showPaper("A3",F)
	v5$stop()
	v5$writePostScript()
}


</code></pre>

<hr>
<h2 id='vg'>Animated graph viewer</h2><span id='topic+vg'></span><span id='topic+vg.list'></span><span id='topic+vg.NULL'></span><span id='topic+vg.default'></span>

<h3>Description</h3>

<p><code>vg</code> creates and starts an animated graphical user interface for 
positioning the vertices of a graph in 2 dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vg(grob, directed, running)

## S3 method for class 'list'
vg(grob, directed = grob$directed, running = grob$running)

## S3 method for class ''NULL''
vg(grob = NULL, directed = FALSE, running = TRUE)

## Default S3 method:
vg(grob = NULL, directed = FALSE, running = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vg_+3A_grob">grob</code></td>
<td>
<p>is a graphical object state saved as a <code>list</code>
from a previous run 
of <code>vg</code> using the <code>save()</code> function.
If <code>grob</code> is <code>NULL</code> or not a <code>list</code>,
<code>vg</code> starts with an empty graph.</p>
</td></tr>
<tr><td><code id="vg_+3A_directed">directed</code></td>
<td>
<p>indicates whether or not the graph is directed. By default
<code>directed = FALSE</code>.
If the graph is directed, the edges have arrows indicating direction, and 
there are three slide bars to control the repulsion parameters. For an 
undirected graph there is a single control.</p>
</td></tr>
<tr><td><code id="vg_+3A_running">running</code></td>
<td>
<p>indicates whether or not the viewer is started 
with the animation running. By default <code>running = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates and starts a 'Java' graphical user interface
(GUI) showing a real time animation of a 
Newton-Raphson optimization of a force function specified 
between the vertices of an arbitrary graph.
There are attractive forces between 
adjacent vertices and repulsive forces between all vertices.
The repulsions go smoothly to zero in a finite distance between 
vertices so that, unlike some other methods, different 
components don't send each other off to infinity.
</p>
<p>The program is controlled by a slide bar, some buttons, the arrow, home and
shift keys, but mostly by mouse operations. All three mouse buttons are used.
These operations are described below.
</p>
<p><code>vg</code> will replace <code>rViewGraph</code>, although the latter is
still currently available.
<code>vg</code> allows for far more control of the graph than <code>rViewGraph</code>, 
including adding and removing vertices and edges, and changing 
the appearance of the vertices,
all of which can be done while the animation is running.
It has a different set of force parameter controls that are useful for 
directed acyclic graphs (DAGs) specifically, but also, 
to a lesser extent, for arbitrary directed graphs. 
It also provides functions for saving and restoring a graphical state
including vertices and edges, vertex positions, and vertex appearances.
</p>
<p><code>vg</code> is intended primarily for interactive use. 
When used in a non-interactive environment
it will run without a visible GUI, however, a graph structure can be
created and saved and viewed in future, interactive, R sessions.
</p>


<h3>Value</h3>

<p><code>vg</code> returns a list of functions that 
specify and query the graph, coordinates and appearance, and control the viewer.
</p>
<table>
<tr><td><code>add(i)</code></td>
<td>
<p>If the graph does not contain vertices indexed by <code>i</code>,
they are added to it. <code>i</code> may be any integer or integer vector.</p>
</td></tr>
<tr><td><code>remove(i)</code></td>
<td>
<p>If the graph contains vertices indexed by <code>i</code>, 
they are disconnected from
their neighbours and removed from the graph. <code>i</code> may be 
any integer or integer vector.</p>
</td></tr>
<tr><td><code>connect(i</code>, <code>j)</code></td>
<td>
<p>If the graph does not have edges between vertices 
indexed by <code>i</code>
and <code>j</code>, they are made. 
If <code>i</code> and <code>j</code> are of different lengths, only the 
first <code>min(length(i),length(j))</code> values are used.
If the relevant vertices are are not already in the graph,
they are first made and added.
<code>i</code> and <code>j</code> 
may be any integers or integer vectors.</p>
</td></tr>
<tr><td><code>disconnect(i</code>, <code>j)</code></td>
<td>
<p>If the graph has edges between vertices 
indexed by <code>i</code> and 
<code>j</code> they are removed. If <code>i</code> and <code>j</code> are of 
different lengths, only the 
first <code>min(length(i),length(j))</code> values are used.
The vertices themselves are not removed, even if they have no
other neighbours. <code>i</code> and <code>j</code> may be any integers 
or integer vectors.</p>
</td></tr>
<tr><td><code>clear()</code></td>
<td>
<p>All vertices and edges are removed from the graph, 
however, any customizations
made to the appearance of the vertices will persist 
until <code>clearMap()</code> is called.</p>
</td></tr>
<tr><td><code>isDirected()</code></td>
<td>
<p>Returns <code>TRUE</code> if the graph's edges are directed,
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code>getIds()</code></td>
<td>
<p>Returns a vector of all the vertex 
indices that the viewer has 
encountered, whether or not they are currently in the graph.</p>
</td></tr>
<tr><td><code>contains(id)</code></td>
<td>
<p>Returns a vector of booleans indicating whether the
vertices corresponding to the given indices are currently in the graph.</p>
</td></tr>
<tr><td><code>connects(i</code>, <code>j)</code></td>
<td>
<p>Returns a vector of booleans indicating whether the
vertices with the indices in vector <code>i</code> are 
connected to the corresponding
vertices in <code>j</code>. If <code>i</code> and <code>j</code> are of 
different lengths, only 
first <code>min(length(i),length(j))</code> values are queried.</p>
</td></tr>
<tr><td><code>neighbours(i)</code></td>
<td>
<p>Returns a list of vectors containing
the neighbours of the vertices indexed by <code>i</code>. If the graph is
directed, both in and out neighbours are included. If a vertex is
unconnected, an empty vector is returned. If an index is for a vertex
that is not currently in the graph, <code>NULL</code> is returned.</p>
</td></tr>
<tr><td><code>neighbors(i)</code></td>
<td>
<p>Alias for <code>neighbours(i)</code>.</p>
</td></tr>
<tr><td><code>inNeighbours(i)</code></td>
<td>
<p>Returns a list of vectors containing the
indices of vertices with edges from them to the ones in <code>i</code>.
If the graph is undirected, this is the same as <code>neighbours(i)</code>.</p>
</td></tr>
<tr><td><code>inNeighbors(i)</code></td>
<td>
<p>Alias for <code>inNeighbours(i)</code>.</p>
</td></tr>
<tr><td><code>outNeighbours(i)</code></td>
<td>
<p>Returns a list of vectors containing the
indices of vertices with edges to them from the ones in <code>i</code>.
If the graph is undirected, this is the same as <code>neighbours(i)</code>.</p>
</td></tr>
<tr><td><code>outNeighbors(i)</code></td>
<td>
<p>Alias for <code>outNeighbours(i)</code>.</p>
</td></tr>
<tr><td><code>getVertices()</code></td>
<td>
<p>Returns a vector of the indices of 
all vertices currently 
in the graph.</p>
</td></tr>
<tr><td><code>getEdges()</code></td>
<td>
<p>Returns a matrix with 2 columns and a row for each edge
in the current graph. Each row gives the indices of the vertices that the
edge connects. If the edges are directed, 
the connections are oriented from vertices
in the first column to those in the second.</p>
</td></tr>
<tr><td><code>getX(id)</code></td>
<td>
<p>Returns the current horizontal 
coordinates of the vertices with
indices in <code>id</code>. Returns 0 if an index has not previously been seen.</p>
</td></tr>
<tr><td><code>getY(id)</code></td>
<td>
<p>Returns the current vertical coordinates of the vertices with
indices in <code>id</code>. Returns 0 if an index has not previously been seen.</p>
</td></tr>
<tr><td><code>setXY(id</code>, <code>x</code>, <code>y)</code></td>
<td>
<p>Sets the horizontal and vertical coordinates for the
vertices with indices in <code>id</code>. If <code>x</code> or <code>y</code> are not as long
as <code>id</code> their values are repeated cyclically to get vectors of the
right length.</p>
</td></tr>
<tr><td><code>label(i</code>, <code>lab=i)</code></td>
<td>
<p>Sets the strings shown on the 
vertices indexed by <code>i</code> to those specified
by <code>lab</code>. If <code>lab</code> is not as long as <code>i</code>, 
its values are repeated cyclically to
get a vector of the right length. 
An error will occur if <code>lab</code> can't be interpreted as 
a vector of strings.</p>
</td></tr>
<tr><td><code>colour(i</code>, <code>col="yellow")</code></td>
<td>
<p>Sets the colours of the 
vertices indexed by <code>i</code> to those specified
by <code>col</code>. If <code>col</code> is not as long as <code>i</code>, 
its values are repeated cyclically to 
get a vector of the right length. 
Colours can be specified in the usual <code>R</code> ways.</p>
</td></tr>
<tr><td><code>color(i</code>, <code>col="yellow")</code></td>
<td>
<p>Alias for <code>colours(i,col)</code>.</p>
</td></tr>
<tr><td><code>shape(i</code>, <code>shp=0)</code></td>
<td>
<p>Sets the shapes of the vertices 
indexed by <code>i</code> to those specified by 
<code>shp</code>. If <code>shp</code> is not as long as <code>i</code>, 
its values are repeated cyclically to
get a vector or the right length. Shapes are specified as integers:
</p>

<ul>
<li><p> 0 = rectangle
</p>
</li>
<li><p> 1 = oval
</p>
</li>
<li><p> 2 = diamond
</p>
</li>
<li><p> any other values are taken as 0.
</p>
</li></ul>
</td></tr>
<tr><td><code>size(i</code>, <code>width=-1</code>, <code>height=width)</code></td>
<td>
<p>Sets the sizes of the 
vertices indexed by <code>i</code> to those specified by 
<code>width</code> and <code>height</code>. 
If, for a certain index, both <code>width</code> and <code>height</code> are
non-negative, the size of the vertex is fixed.
If either of <code>width</code> or <code>height</code> is negative, 
the size of the vertex
is chosen adaptively to fit the current label.
If <code>width</code> or <code>height</code> are not as long as <code>i</code>,
their values are repeated cyclically to get vectors of the right length.
</p>
</td></tr>
<tr><td><code>map(i</code>, <code>lab=i</code>, <code>col="yellow"</code>, <code>shp=0</code>, <code>width=-1</code>, <code>height=width</code></td>
<td>
<p>Combines 
<code>label()</code>, <code>colour()</code>, <code>shape()</code> and <code>size()</code> in a 
single index-to-appearance mapping function. 
These functions can be called before or
after the vertices have been added to the graph, 
and the representations will persist for
vertices removed from, and replaced in, the graph until 
until they are explicitly changed or <code>clearMap()</code> is called.</p>
</td></tr>
<tr><td><code>clearMap()</code></td>
<td>
<p>Resets all vertices to the default 
appearance of yellow rectangle labeled
with the index.</p>
</td></tr>
<tr><td><code>run()</code></td>
<td>
<p>Starts the GUI running if it's not already doing so.</p>
</td></tr>
<tr><td><code>stop()</code></td>
<td>
<p>Stops the GUI running if it's running.</p>
</td></tr>
<tr><td><code>isRunning()</code></td>
<td>
<p>Returns <code>TRUE</code> if the animation is running, 
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code>show()</code></td>
<td>
<p>Shows the GUI. If it was running 
when <code>hide()</code> was called, it starts running again.</p>
</td></tr>
<tr><td><code>hide()</code></td>
<td>
<p>Stops the GUI and hides it.</p>
</td></tr>
<tr><td><code>showPaper(size = "letter"</code>, <code>landscape = TRUE)</code></td>
<td>
<p>Indicates, 
with a different colour, the portion of the
plane corresponding to a choice of paper for printing. 
<code>size</code> can be any of 
<code>letter</code>, <code>A4</code>, <code>A3</code>, <code>A2</code>, <code>A1</code>, 
<code>A0</code>, <code>C1</code>, or <code>C0</code>.
<code>landscape</code> can be either <code>TRUE</code> or <code>FALSE</code>, 
in which case portrait orientation
is used. The default is to show the portion of the plane 
that would be printed on
US letter in landscape orientation.</p>
</td></tr>
<tr><td><code>hidePaper()</code></td>
<td>
<p>By default the GUI indicates, 
with a different colour, the portion
of the plane that corresponds to the current 
choice of paper for printing. This function
removes that area.</p>
</td></tr>
<tr><td><code>showAxes()</code></td>
<td>
<p>Shows the axes if they are hidden.</p>
</td></tr>
<tr><td><code>hideAxes()</code></td>
<td>
<p>By default, axes are shown to indicate the origin. This
function hides them.</p>
</td></tr>
<tr><td><code>ps()</code></td>
<td>
<p>Starts a <code>Java</code> PostScript print job dialog box that can be
used send the current view of the graph to a printer or to write a 
PostScript file. The plot
produced should closely match what is indicated by <code>showPaper</code>.</p>
</td></tr>
<tr><td><code>save()</code></td>
<td>
<p>Returns a <code>list</code> specifying the current state of the
graph structure, vertex coordinates, and vertex appearance map.</p>
</td></tr>
<tr><td><code>restore(grob)</code></td>
<td>
<p>Restores a saved graph and map state.</p>
</td></tr>
</table>


<h3>Interactive mouse, key and slide bar controls</h3>


<ul>
<li><p> Slide bars at the bottom of the GUI control the 
repulsive force in the energy
equation used to set the coordinates.
If the graph is undirected, there is a single 'Repulsion' parameter, 
if directed, there
are 'X-Repulsion' and 'Y-Repulsion' parameters, 
and a 'Gravity' parameter that influences
how these are combined.
</p>
</li>
<li><p> Mouse operations without shift key and without control key pressed.
</p>

<ol>
<li><p> Left mouse: Drags a vertex. Vertex is free on release. 
</p>
</li>
<li><p> Middle mouse: Drags a vertex. Vertex is fixed at release position. 
</p>
</li>
<li><p> Right mouse: Translates the view by the amount dragged. 
A bit like putting
your finger on a piece of paper and moving it. 
</p>
</li>
<li><p> Double click with any mouse button in the background: 
Resets the vertices to new random positions. 
</p>
</li></ol>

</li>
<li><p> Mouse operations with shift key but without control key pressed.
</p>

<ol>
<li><p> Left mouse: Drags a vertex and the component it is in. 
Vertex and component free on release.
</p>
</li>
<li><p> Middle mouse: Drags a vertex and the component it is in. 
Vertex and component are fixed at release positions.
</p>
</li>
<li><p> Right mouse: Translates the positions of the vertices relative to 
the position of the canvas by the amount dragged. This is useful to center 
the picture on the canvas ready for outputting.
</p>
</li></ol>

</li>
<li><p> Mouse operations without shift key but with control key pressed.
</p>

<ol>
<li><p> Left mouse: Click on a vertex to un-hide any hidden neighbours.
</p>
</li>
<li><p> Middle mouse: Click on a vertex to hide it.
</p>
</li>
<li><p> Double click left mouse: Un-hides all hidden vertices.
</p>
</li>
<li><p> Double click middle mouse: Hides all vertices.
</p>
</li></ol>

</li>
<li><p> Mouse operations with shift key and with control key pressed.
</p>

<ol>
<li><p> Left mouse: Click on a vertex to un-hide all vertices 
in the same component.
</p>
</li>
<li><p> Middle mouse: Click on a vertex to hide it and the component it is in.
</p>
</li></ol>

</li>
<li><p> Key functions without shift key pressed. 
Mouse has to be in the picture canvas.
</p>

<ol>
<li><p> Up arrow: Increases the scale of viewing by 10%.
</p>
</li>
<li><p> Down arrow: Decreases the scale of viewing by 10%.
</p>
</li>
<li><p> Left arrow: Rotates the view by 15 degrees clockwise.
</p>
</li>
<li><p> Right arrow: Rotates the view by 15 degrees anticlockwise.
</p>
</li>
<li><p> Home key: Undoes all scalings and rotations and places the origin at
the top left corner of the canvas.
</p>
</li></ol>

</li>
<li><p> Key functions with shift key pressed. 
Mouse has to be in the picture canvas.
</p>

<ol>
<li><p> Up arrow: Increases the vertex positions by 10% 
relative to the scale of the canvas.
</p>
</li>
<li><p> Down arrow: Decreases the vertex positions by 10% 
relative to the scale of the canvas.
</p>
</li>
<li><p> Left arrow: Rotates the vertex positions by 15 
degrees clockwise relative to the canvas orientation.
</p>
</li>
<li><p> Right arrow: Rotates the vertex positions by 15 
degrees anticlockwise relative to the canvas orientation.
</p>
</li></ol>

</li></ul>



<h3>Author(s)</h3>

<p>Alun Thomas
</p>


<h3>References</h3>

<p>A full description of the force function and algorithm used is given by
C Cannings and A Thomas, 
Inference, simulation and enumeration of genealogies.
In D J Balding, M Bishop, and C Cannings, editors, 
The Handbook of Statistical
Genetics. Third Edition, pages 781-805. John Wiley &amp; Sons, Ltd, 2007.
</p>


<h3>See Also</h3>

<p>rViewGraph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Start the viewer.
# This will print a warning message if not run interactively.
require(rviewgraph)
v = vg()

# Generate some random vertices to connect with edges.
from = sample(1:20,15,TRUE)
to = sample(1:20,15,TRUE)

# Connect these edges in the viewer.
v$connect(from,to)

# Negative vertex indices are also allowed.
v$connect(-from,-to)

# Add some new vertices, unconnected to any others.
v$add(30:35)

# Remove some vertices.
v$rem((-5:5)*2)

# Query some of the structure of the graph.
v$contains(1)
v$contains(-1)
v$connects(1,-1)
v$contains(1:50)
v$connects(from,to)
v$connects(from,-to+2)
v$neighbours(from)

# Change what some of the vertices look like.
v$map(-10:10, lab = "", col=1, shp=1, width=1:15)
v$label(10:36, lab=LETTERS)
v$colour((-1000:-1),"cyan")
v$shape((-1000:-1)*2,2)

# Hide the axes.
v$hideAxes()

# Stop the animation. 
# Not necessary for outputting but sometimes helpful.
v$stop()

# Change the paper size and orientation to A4 portrait.
v$showPaper("A4",FALSE)

# Start the print dialog box.
#v$ps()

# Restart the animation, and check that it's running.
v$run()
v$isRunning()

# Save the application.
s = v$save()

# Change the graph and appearance.
v$colour(-1000:1000,"red")
v$connect(rep(1,100),1:100)

# Then decide you didn't like the changes so restore 
# the saved state.
v$restore(s)

# Can also restore a state in a new GUI.
v2 = vg(s)

# Get a vector of all the indices that the viewer has seen.
ids = v$getIds()

# Get a vector of the indices of the vertices currently 
# in the graph.
verts = v$getVertices()

# Get a matrix with 2 columns specifying the current edges 
# of the graph.
edges = v$getEdges()

# Get the current coordinates of the specified vertices. 
x = v$getX(verts)
y = v$getY(verts)

# Change the current coordinates of the vertices.
v$setXY(verts,2*x,0.5*y+2)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
