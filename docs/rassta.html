<!DOCTYPE html><html lang="en"><head><title>Help for package rassta</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rassta}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dummies'><p>Create Dummy Layers from Categorical Raster Layers</p></a></li>
<li><a href='#engine'><p>Predictive Modeling Engine</p></a></li>
<li><a href='#figure'><p>Reproduce Figures from Fuentes et al. (n.d.)</p></a></li>
<li><a href='#locations'><p>Select Representative Sampling Locations for Stratification Units</p></a></li>
<li><a href='#observation'><p>Select the Representative Response Observation for Stratification Units</p></a></li>
<li><a href='#plot3D'><p>Interactive Maps of 3D surfaces</p></a></li>
<li><a href='#predict_functions'><p>Predict Distribution Functions Across Geographic Space</p></a></li>
<li><a href='#select_functions'><p>Select Constrained Univariate Distribution Functions</p></a></li>
<li><a href='#signature'><p>Calculate the Spatial Signature of Classification Units</p></a></li>
<li><a href='#similarity'><p>Calculate the Landscape Similarity to Stratification Units</p></a></li>
<li><a href='#som_gap'><p>Self-Organizing Map and Selection of k</p></a></li>
<li><a href='#som_pam'><p>Rasterization of Self-Organizing Map and Partitioning Around Medoids</p></a></li>
<li><a href='#strata'><p>Create Stratification Units</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Raster-Based Spatial Stratification Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for the spatial stratification of landscapes, sampling and modeling of 
    spatially-varying phenomena. These algorithms offer a simple framework for the stratification 
    of geographic space based on raster layers representing landscape factors and/or factor scales. 
    The stratification process follows a hierarchical approach, which is based on first level units 
    (i.e., classification units) and second-level units (i.e., stratification units). Nonparametric 
    techniques allow to measure the correspondence between the geographic space and the landscape 
    configuration represented by the units. These correspondence metrics are useful to define 
    sampling schemes and to model the spatial variability of environmental phenomena. The 
    theoretical background of the algorithms and code examples are presented in Fuentes et al. (2022). 
    &lt;<a href="https://doi.org/10.32614%2FRJ-2022-036">doi:10.32614/RJ-2022-036</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bryan A. Fuentes &lt;bryandrep@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bafuentes.github.io/rassta/">https://bafuentes.github.io/rassta/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bafuentes/rassta/issues/">https://github.com/bafuentes/rassta/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster (&ge; 2.1.2), data.table (&ge; 1.14.0), dplyr (&ge; 1.0.7),
DT (&ge; 0.18), foreach (&ge; 1.5.1), GGally (&ge; 2.1.2), ggplot2
(&ge; 3.3.5), grDevices, histogram (&ge; 0.0.25), KernSmooth (&ge;
2.23.18), kohonen (&ge; 3.0.10), plotly (&ge; 4.9.4.1), rlang (&ge;
0.4.11), scales (&ge; 1.1.1), shiny (&ge; 1.6.0), stats, stringdist
(&ge; 0.9.6.3), stringi (&ge; 1.7.2), terra (&ge; 1.3.4), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), tinytest (&ge; 1.3.1), doParallel (&ge;
1.0.16), mgcv (&ge; 1.8.40), knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-18 23:49:48 UTC; bryan</td>
</tr>
<tr>
<td>Author:</td>
<td>Bryan A. Fuentes <a href="https://orcid.org/0000-0003-3506-7101"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Minerva J. Dorantes
    <a href="https://orcid.org/0000-0002-2877-832X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  John R. Tipton [aut],
  Robert J. Hijmans <a href="https://orcid.org/0000-0001-5872-2872"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Andrew G. Brown [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-19 06:20:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='dummies'>Create Dummy Layers from Categorical Raster Layers</h2><span id='topic+dummies'></span>

<h3>Description</h3>

<p>Given a SpatRaster whose cell values represent categories (e.g., soil types,
land use/cover classes), a dummy layer indicating the presence/absence of
each category is created, and optionally written on disk. Each category in
the raster layer must be represented by a unique integer cell value. Output
values indicating the presence or absence of categories in the dummy layers
may be set using <em>preval</em> and <em>absval</em> arguments, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummies(
  ca.rast,
  vals = NULL,
  preval = 100,
  absval = 0,
  to.disk = FALSE,
  outdir = ".",
  extension = ".tif",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dummies_+3A_ca.rast">ca.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Single-layer
SpatRaster whose (integer) cell values represent numeric IDs for
categories.</p>
</td></tr>
<tr><td><code id="dummies_+3A_vals">vals</code></td>
<td>
<p>Integer. Vector or sequence of values representing the categories
for which dummy layers will be created. If NULL, all categories will be
processed. Default: NULL</p>
</td></tr>
<tr><td><code id="dummies_+3A_preval">preval</code></td>
<td>
<p>Integer. Value indicating presence of category. Default: 100</p>
</td></tr>
<tr><td><code id="dummies_+3A_absval">absval</code></td>
<td>
<p>Integer. Value indicating absence of category. Default: 0</p>
</td></tr>
<tr><td><code id="dummies_+3A_to.disk">to.disk</code></td>
<td>
<p>Boolean. Write output dummy layers to disk? Default: FALSE</p>
</td></tr>
<tr><td><code id="dummies_+3A_outdir">outdir</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, string specifying the path
for the output dummy raster layers. Default: &quot;.&quot;</p>
</td></tr>
<tr><td><code id="dummies_+3A_extension">extension</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, String specifying the
extension for the output raster layers (see <strong>Details</strong>). Default:
&quot;.tif&quot;</p>
</td></tr>
<tr><td><code id="dummies_+3A_...">...</code></td>
<td>
<p>If <em>to.disk = TRUE</em>, additional arguments as for
<code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mainly differs from <code><a href="terra.html#topic+segregate">segregate</a></code> in
that presence and absence values can be set arbitrarily, thus allowing for
values other than those traditionally used in one-hot/dummy encoding (i.e.,
1 and 0).
</p>
<p>Please note that the argument <em>extension</em> does not correspond to the
argument <em>filetype</em> in <code><a href="terra.html#topic+writeRaster">writeRaster</a></code>. However,
<code><a href="terra.html#topic+writeRaster">writeRaster</a></code> should recognize the appropriate extension
for the output raster layers from the <em>extension</em> argument. For
instance, by setting <em>extension = &quot;.tif&quot;</em>,
<code><a href="terra.html#topic+writeRaster">writeRaster</a></code> will recognize the extension as
<em>GeoTiff</em>, which is the GDAL driver name.
</p>


<h3>Value</h3>

<p>Single-layer or multi-layer SpatRaster with dummy layer(s).
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+segregate">segregate</a></code>
</p>
<p>Other Miscellaneous Functions: 
<code><a href="#topic+figure">figure</a>()</code>,
<code><a href="#topic+plot3D">plot3D</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Single-layer SpatRaster of geologic units
f &lt;- list.files(path = p, pattern = "geology2.tif", full.names = TRUE)
geol &lt;- terra::rast(f)
# Dummy layer from geologic unit 1
dums &lt;- dummies(ca.rast = geol, vals = 1, preval = 100, absval = 0)

</code></pre>

<hr>
<h2 id='engine'>Predictive Modeling Engine</h2><span id='topic+engine'></span>

<h3>Description</h3>

<p>Modeling of spatially varying phenomena based on landscape similarity to
stratification units. If each stratification unit across geographic space
represents a distinct landscape configuration (in terms of multiple landscape
factors and/or factor scales), and if each landscape configuration influences
a phenomenon in a distinct way, then the spatial variability of that
phenomenon can be assessed across a landscape by relating each geographic
location to each distinct landscape configuration. Therefore, the more
similar a geographic location is to the landscape configuration represented
by a given stratification unit, then also the more similar the response of a
phenomenon will be at that location to the typical response for conditions
within the given stratification unit. Both continuous and categorical
response variables are supported. For categorical responses, each category
must be identified by an integer value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine(
  res.type = "cont",
  ls.rast,
  n.win = 3,
  su.repobs,
  tiles,
  parallel = FALSE,
  outdir = ".",
  tile.rm = TRUE,
  extension = ".tif",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_+3A_res.type">res.type</code></td>
<td>
<p>Character. Type of response to model. Options are &quot;cont&quot; for
continuous, and &quot;cat&quot; for categorical response. Default: &quot;cont&quot;</p>
</td></tr>
<tr><td><code id="engine_+3A_ls.rast">ls.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Multi-layer
SpatRaster representing landscape similarities to stratification units.
Only similarities for units with a representative observation are allowed.
Character prefix in the file name of similarities is allowed.</p>
</td></tr>
<tr><td><code id="engine_+3A_n.win">n.win</code></td>
<td>
<p>Integer. Positive number indicating how many winning
stratification units should be considered. See <strong>Details</strong>. Default: 3</p>
</td></tr>
<tr><td><code id="engine_+3A_su.repobs">su.repobs</code></td>
<td>
<p>Data frame. The first column of this data frame must contain
only the numeric code for the stratification units (without prefix). Each
additional column must contain the value of the representative response
observation for each stratification unit. Multiple response variables are
allowed (one per column). Note that all response variables in the data
frame must share the same type (<em>res.type</em>). See example on issues
related to <strong>non-explicit column names</strong>.</p>
</td></tr>
<tr><td><code id="engine_+3A_tiles">tiles</code></td>
<td>
<p>SpatVector, as in <code><a href="terra.html#topic+vect">vect</a></code>. Spatial vector of
polygon geometry with the boundaries of the area of interest. This vector
can be subdivided in regions (i.e., tiles) to balance memory allocation and
processing speed (see <strong>Details</strong>). If this vector is tiled, then its
attribute table must only contain an ID column with a unique identifier for
each tile (1,2,...,n). Additionally, This vector must have the same
coordinate reference system as <em>ls.rast</em>.</p>
</td></tr>
<tr><td><code id="engine_+3A_parallel">parallel</code></td>
<td>
<p>Boolean. Perform parallel processing? A parallel backend
needs to be registered beforehand with
<code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code>. Moreover, a tiled spatial
vector should be supplied for <em>tiles</em>. Default: FALSE</p>
</td></tr>
<tr><td><code id="engine_+3A_outdir">outdir</code></td>
<td>
<p>Character. String specifying the path for the output raster
tiles/layer(s) of modeled response(s). Default: &quot;.&quot;</p>
</td></tr>
<tr><td><code id="engine_+3A_tile.rm">tile.rm</code></td>
<td>
<p>Boolean. Should the tiles of modeled response(s) be removed
from disk after the tile merging process? Default: TRUE</p>
</td></tr>
<tr><td><code id="engine_+3A_extension">extension</code></td>
<td>
<p>Character. String specifying the extension for the output
raster layer(s) of modeled response(s). Default: &quot;.tif&quot;</p>
</td></tr>
<tr><td><code id="engine_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Show warning messages in the console? Default: FALSE</p>
</td></tr>
<tr><td><code id="engine_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predictive modeling process is cell-wise, which means that it operates on
a cell-by-cell basis. For a given cell occurring in the geographic space
supported by a raster layer, the predictive modeling engine first identifies
the <em>n</em> stratification units to which the given cell is most similar
(i.e., 'winning stratification units'). The engine is able to identify the
winning stratification units thanks to the user-provided set of landscape
similarity layers <em>ls.rast</em>. Subsequently, the response value from the
representative observation for each winning stratification unit is
identified. In the case of a continuous response, a weighted average of
representative response values is performed. For each representative response
value, the weight is proportional to the corresponding stratification unit's
landscape similarity value in the given cell. The result of the weighted
average is assigned as the response value in the given cell. In the case of a
categorical response, the modal value from the representative response values
of the <em>n</em> winning stratification units is assigned to the given cell.
</p>
<p>Note that the name for each raster layer in <em>ls.rast</em> should match the
numeric code of the corresponding stratification unit, which is obtained from
the column of numeric codes in <em>su.repobs</em>. Nevertheless, raster layer
names in <em>ls.rast</em> with a character prefix in the numeric code and/or
file extension should work fine (e.g., &quot;su_1101.tif&quot; instead of &quot;1101&quot;). If
the landscape similarity layers in <em>ls.rast</em> were created with
<code><a href="#topic+similarity">similarity</a></code>, then raster layer names will not have any prefix
nor extension as part of the numeric code.
</p>
<p>When dealing with large geographic spaces, high raster resolutions (i.e.,
small cell sizes), or both, a considerable amount of memory is required to
perform the modeling process. To reduce memory usage, the predictive modeling
engine performs tile-based processing of landscape similarity layers and
<strong>writes results directly on disk</strong>. Tile-based processing increases the
computational time, thus parallelization is allowed by setting up a parallel
backend. If parallelization is enabled, then care must be taken with the size
of the tiles since larger sizes will have a greater impact on memory usage.
Consequently, the parallel, tile-based processing will be less useful.
</p>


<h3>Value</h3>

<p>Multi-layer or single-layer SpatRaster with modeled response(s).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+similarity">similarity</a></code>, <code><a href="#topic+observation">observation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Multi-layer SpatRaster of landscape similarities
fls &lt;- list.files(path = p, pattern = "su_", full.names = TRUE)
ls &lt;- terra::rast(fls)
# Numeric code and representative response value for stratification units
fro &lt;-list.files(path = p, pattern = "repobs.csv", full.names = TRUE)
ro &lt;- read.csv(fro)
# Extract only those stratification units with representative value
ls &lt;- ls[[as.character(ro$SU)]]
# SpatVector with processing tiles
fti &lt;- list.files(path = p, pattern = "tiles.shp", full.names = TRUE)
ti &lt;- terra::vect(fti)
# Directory for temporary files
o &lt;- tempdir()
# Perform predictive modeling of continuous response
r &lt;- engine(res.type = "cont", ls.rast = ls, n.win = 2, su.repobs = ro,
            tiles = ti, outdir = o, overwrite = TRUE
           )
# Plot modeled response
if(interactive()){plot(r)}
# Clean temporary files
file.remove(list.files(path = o, pattern = "soc.tif", full.names = TRUE))
#
#-------
# A note on non-explicit response's names (obtained from su.repobs):

## This will result in incorrectly modeled response values
x &lt;- c("SOM", "SOM_30cm", "SOM_45cm")    # SOM = soil organic matter
grep(x[1], x)                            # Non explicit
grep(x[2], x)                            # Explicit
grep(x[3], x)                            # Explicit

## This will result in correct values
x &lt;- c("SOM_15cm", "SOM_30cm", "SOM_45cm")
grep(x[1], x)                            # Explicit
grep(x[2], x)                            # Explicit
grep(x[3], x)                            # Explicit

</code></pre>

<hr>
<h2 id='figure'>Reproduce Figures from Fuentes et al. (n.d.)</h2><span id='topic+figure'></span>

<h3>Description</h3>

<p>This function is intended to reproduce the figures presented in <em>rassta:
Raster-based Spatial Stratification Algorithms</em> (Fuentes et al., 2021). Note
that this function assumes that all the necessary inputs for each figure are
loaded in the working environment. For the creation of each input, please
refer to the data and examples presented in the aforementioned work. Also,
please note that the use of this function is not intended for RStudio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>figure(x, d, scaling = 100, to.disk = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="figure_+3A_x">x</code></td>
<td>
<p>Integer. Number identifying the figure to reproduce.</p>
</td></tr>
<tr><td><code id="figure_+3A_d">d</code></td>
<td>
<p>List. List with the data required for the figure to reproduce.</p>
</td></tr>
<tr><td><code id="figure_+3A_scaling">scaling</code></td>
<td>
<p>Integer. This number scales (i.e., resizes) the R's plotting
device, such that <em>width = x/scaling &amp; height = x/scaling</em>,
with <em>x</em> = pixels. The default pixel size (not adjustable) and scaling
value should work fine. Default = 100</p>
</td></tr>
<tr><td><code id="figure_+3A_to.disk">to.disk</code></td>
<td>
<p>Boolean. Save figure to disk? Default = FALSE</p>
</td></tr>
<tr><td><code id="figure_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Show warning messages in the console? Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>B.A. Fuentes, M.J. Dorantes, and J.R. Tipton. rassta: Raster-based Spatial
Stratification Algorithms. EarthArXiv, 2021.
<a href="https://doi.org/10.31223/X50S57">doi:10.31223/X50S57</a>
</p>


<h3>See Also</h3>

<p>Other Miscellaneous Functions: 
<code><a href="#topic+dummies">dummies</a>()</code>,
<code><a href="#topic+plot3D">plot3D</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Single-layer SpatRaster of geologic units
f &lt;- list.files(path = p, pattern = "geology.tif", full.names = TRUE)
geol &lt;- terra::rast(f)
# Dummy layers from geologic units
mat.sig &lt;- dummies(ca.rast = geol, preval = 100, absval = 0)
figure(17, d = mat.sig)
}

</code></pre>

<hr>
<h2 id='locations'>Select Representative Sampling Locations for Stratification Units</h2><span id='topic+locations'></span>

<h3>Description</h3>

<p>Selection of the <em>representative sampling locations</em> based on landscape
similarity values. For a give stratification unit, the representative
sampling location is the XY position where the highest landscape similarity
value occurs. This location is assumed to best reflect the influence that the
landscape configuration of a given stratification unit exerts on response
phenomena. Currently, two selection methods are supported: (1) <em>maximum
similarity within buffer zones</em> (&quot;buffer&quot;), and (2) <em>absolute maximum
similarity</em> (&quot;absolute&quot;). For the buffer method, the <em>n</em> largest zones
enclosing landscape similarity values above a certain threshold are first
identified. Then, for each zone, one sample is placed at the <em>XY</em>
location where the landscape similarity value is maximized. For the absolute
method, a sample is placed at the <em>XY</em> locations with the <em>n</em>
maximum landscape similarity values. In both methods, it is possible to
constrain the sampling process to the boundaries of the stratification unit.
Constraining the process ensures that the sampling locations determined for a
given unit are placed within the boundaries of that unit. See
<strong>Details</strong> for some guidance in the use of this function for
classification units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locations(
  ls.rast,
  su.rast,
  method = "buffer",
  constrained = TRUE,
  buf.quant = 0.9,
  buf.n = 1,
  abs.n = 1,
  tol = 1,
  parallel = FALSE,
  to.disk = FALSE,
  outdir = ".",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locations_+3A_ls.rast">ls.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Multi-layer
SpatRaster representing landscape similarities to stratification units.</p>
</td></tr>
<tr><td><code id="locations_+3A_su.rast">su.rast</code></td>
<td>
<p>SpatRaster. Single-layer SpatRaster representing the
stratification units occurring across geographic space. Integer values are
expected as cell values (i.e., numeric codes) of stratification units.</p>
</td></tr>
<tr><td><code id="locations_+3A_method">method</code></td>
<td>
<p>Character. String denoting the sampling method. Current options
are &quot;buffer&quot; for the maximum similarity within buffer zones method, and
&quot;absolute&quot; for the absolute maximum similarity method. Default: &quot;buffer&quot;</p>
</td></tr>
<tr><td><code id="locations_+3A_constrained">constrained</code></td>
<td>
<p>Boolean. Should the sampling process be constrained to the
boundaries of each stratification unit? See <strong>Details</strong>. Default: TRUE</p>
</td></tr>
<tr><td><code id="locations_+3A_buf.quant">buf.quant</code></td>
<td>
<p>Numeric. Number expressed in quantile notation (0-1)
indicating the similarity threshold for the creation of buffer zones. Only
zones enclosing raster cells with <em>landscape similarity &gt;= buf.quant</em>
will be created and thus, considered for sampling. See <strong>Details</strong>.
Default: 0.9</p>
</td></tr>
<tr><td><code id="locations_+3A_buf.n">buf.n</code></td>
<td>
<p>Integer. Positive integer indicating the <em>n</em> largest buffer
zones for which sampling locations will be selected (<em>n</em> buffer zones
per stratification unit, one sampling location per buffer zone). Default: 1</p>
</td></tr>
<tr><td><code id="locations_+3A_abs.n">abs.n</code></td>
<td>
<p>Integer. When <em>method = &quot;absolute&quot;</em>, Positive integer
indicating the number of sampling locations to select for each
stratification unit. See <strong>Details</strong>. Default: 1</p>
</td></tr>
<tr><td><code id="locations_+3A_tol">tol</code></td>
<td>
<p>Numeric. When <em>method = &quot;absolute&quot;</em>, this number will be
subtracted from the sampled maximum value of a landscape similarity layer
to ensure that the requested number of sampling locations will be found
(see <strong>Details</strong>). The default assumes that landscape similarity
values are on a scale of 1 to 100. If these values are on a different scale
(e.g., decimal), then, <em>tol</em> needs to be adjusted accordingly.
Default: 1</p>
</td></tr>
<tr><td><code id="locations_+3A_parallel">parallel</code></td>
<td>
<p>Boolean. Perform parallel processing? A parallel backend must
be registered beforehand with <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code>.
Keep in mind that the amount of RAM to allocate when performing parallel
processing can result prohibitive for large data sets. Default: FALSE</p>
</td></tr>
<tr><td><code id="locations_+3A_to.disk">to.disk</code></td>
<td>
<p>Boolean. Should output SpatVector(s) (as in
<code><a href="terra.html#topic+vect">vect</a></code>) be written to disk? Default: FALSE</p>
</td></tr>
<tr><td><code id="locations_+3A_outdir">outdir</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, string specifying the path
for the output SpatVector(s). Default: &quot;.&quot;</p>
</td></tr>
<tr><td><code id="locations_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Show warning messages in the console? Default: FALSE</p>
</td></tr>
<tr><td><code id="locations_+3A_...">...</code></td>
<td>
<p>Additional arguments, as for <code><a href="terra.html#topic+writeVector">writeVector</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Except when <em>buf.n = 1</em> or <em>abs.n = 1</em>, the number of returned
sampling locations per stratification unit may be smaller than requested,
especially when <em>constrained = TRUE</em>. For the constrained buffer method,
reducing the landscape similarity threshold value <em>buf.quant</em> will not
always result in more buffer zones; i.e., more sampling locations. The reason
for this is that reducing the threshold value for the creation of buffer
zones may actually promote the spatial contiguity of zones. For instance, two
buffer zones created at <em>buf.quant = 0.9</em>, may be merged into a single
buffer zone when <em>buf.quant = 0.80</em>. This will occur if the raster cells
between the two buffer zones satisfy: <em>landscape similarity &gt;=
quantile(landscape similarity, 0.8)</em>. For the absolute method, increasing the
value of the <em>tol</em> argument will ensure a safer search for <em>n</em>
sampling locations and thus, greater chances of getting the total number of
requested sampling locations per stratification unit.
</p>
<p>Note that this sampling scheme can be applied for classification units. In
order to do this, one should replace the multi-layer SpatRaster of landscape
similarities with a multi-layer SpatRaster of spatial signatures. One should
also replace the raster layer of stratification units with that of
classification units.
</p>


<h3>Value</h3>

<p>If <em>method = &quot;buffer&quot;</em> and <em>constrained = TRUE</em>, a list with the
following components:
</p>
<p><strong>locations</strong>: SpatVector of point geometry. Each point in this vector
represents the sampling location placed at the maximum landscape similarity
value within a stratification unit's buffer zone. Tabular attributes in this
SpatVector are (1) <em>SU</em> = stratification unit's numeric code, (2)
<em>land_sim</em> = landscape similarity value, (3) <em>x</em> = X coordinate,
and (4) <em>y</em> = Y coordinate.
</p>
<p><strong>buffer</strong>: SpatVector of polygon geometry. Each polygon in this vector
represents the buffer zone of an stratification unit.
</p>
<p>If <em>method = &quot;buffer&quot;</em> and <em>constrained = FALSE</em>:
</p>
<p><strong>locations</strong>: Same as <strong>locations</strong> from <em>method = &quot;buffer&quot;</em>
and <em>constrained = TRUE</em>.
</p>
<p>If <em>method = &quot;absolute&quot;</em>:
</p>
<p><strong>locations</strong>: SpatVector of point geometry. Each point in this vector
represents the sampling location placed at the maximum landscape similarity
value for an stratification unit. Tabular attributes in this SpatVector are
(1) <em>SU</em> = stratification unit's numeric code, (2) <em>land_sim</em> =
landscape similarity value, (3) <em>x</em> = X coordinate, and (4) <em>y</em> = Y
coordinate.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+similarity">similarity</a></code>, <code><a href="#topic+strata">strata</a></code>
</p>
<p>Other Functions for Stratified Sampling: 
<code><a href="#topic+observation">observation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Multi-layer SpatRaster of landscape similarities
fls &lt;- list.files(path = p, pattern = "su_", full.names = TRUE)
ls &lt;- terra::rast(fls)
# Single-layer SpatRaster of stratification units
fsu &lt;- list.files(path = p, pattern = "strata.tif", full.names = TRUE)
su &lt;- terra::rast(fsu)
# Get 1 representative sampling location per stratification unit
rl &lt;- locations(ls.rast = ls, su.rast = su)
# Plot representative locations (including buffer areas)
if(interactive()){
  plot(su, type = "classes", fun = function() c(points(rl$locations),
                                                polys(rl$buffers))
      )}

</code></pre>

<hr>
<h2 id='observation'>Select the Representative Response Observation for Stratification Units</h2><span id='topic+observation'></span>

<h3>Description</h3>

<p>Selection of the <em>representative response observation</em> for each
stratification unit occurring across geographic space. One observation from a
set of <em>n</em> observations of a response variable sampled/measured within
the spatial boundaries of a given stratification unit is selected according
to the following criteria: (1) <em>maximum landscape similarity</em>, (2)
<em>median response value</em>, and (3) <em>random selection</em>. The maximum
landscape similarity (mls) selects the observation at the <em>XY</em> spatial
location where the landscape similarity value is maximized for a given
stratification unit. The median response value (mrv) selects the observation
whose response value is (closest to) the median of all response values, as
measured from the observations spatially enclosed by a given stratification
unit. The random selection, as implied by the name, randomly selects one
observation from the set of observations spatially enclosed by a given
stratification unit. See <strong>Details</strong> for some guidance in the use of
this function for classification units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observation(
  su.rast,
  obs,
  col.id,
  col.resp,
  method = "mls",
  ls.rast,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="observation_+3A_su.rast">su.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Single-layer
SpatRaster representing the stratification units occurring across
geographic space. Integer values are expected as cell values (i.e., numeric
codes) of stratification units.</p>
</td></tr>
<tr><td><code id="observation_+3A_obs">obs</code></td>
<td>
<p>SpatVector, as in <code><a href="terra.html#topic+vect">vect</a></code>. Vector of point
geometry whose tabular attributes should contain an ID column (1,2,...,n)
and a column of the response' values.</p>
</td></tr>
<tr><td><code id="observation_+3A_col.id">col.id</code></td>
<td>
<p>Integer. Index of the ID column in the tabular attributes of
<em>obs</em>.</p>
</td></tr>
<tr><td><code id="observation_+3A_col.resp">col.resp</code></td>
<td>
<p>Integer. Index of the response' values column in the tabular
attributes of <em>obs</em>.</p>
</td></tr>
<tr><td><code id="observation_+3A_method">method</code></td>
<td>
<p>Character. String specifying the selection method for the
response representative observation. Options are &quot;mls&quot; for the maximum
landscape similarity value, &quot;mrv&quot; for the median response value, and
&quot;random&quot; for random selection. Default: &quot;mls&quot;</p>
</td></tr>
<tr><td><code id="observation_+3A_ls.rast">ls.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Multi-layer
SpatRaster representing landscape similarities to stratification units.
Only required if <em>method = &quot;mls&quot;</em>.</p>
</td></tr>
<tr><td><code id="observation_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Show warning messages in the console? Default: FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This selection scheme can be applied to classification units. For
classification units, one should replace the multi-layer SpatRaster of
landscape similarities with a multi-layer SpatRaster of spatial signatures.
One should also replace the raster layer of stratification units with that of
classification units.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<p><strong>su.repobs</strong>: Data table with the following attributes: (1) Original
IDs of the selected observation, (2) representative response value, (3)
stratification unit's numeric code, and (4) landscape similarity value at the
<em>XY</em> location of the selected observation (only if <em>method =
&quot;mls&quot;</em>).
</p>
<p><strong>su.norepobs</strong>: List of the numeric codes of stratification units
without observations.
</p>
<p><strong>su.repobs.sp</strong>: SpatVector of point geometry with the representative
response observation for each stratification unit represented in
<em>su.rast</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strata">strata</a></code>, <code><a href="#topic+similarity">similarity</a></code>
</p>
<p>Other Functions for Stratified Sampling: 
<code><a href="#topic+locations">locations</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Single-layer SpatRaster of stratification units
fsu &lt;- list.files(path = p, pattern = "strata.tif", full.names = TRUE)
su &lt;- terra::rast(fsu)
# Observations with response values.
## For this example, soil organic carbon (SOC) collected at 15 cm soil depth
fob &lt;- list.files(path = p, pattern = "soc.shp", full.names = TRUE)
ob &lt;- terra::vect(fob)
# Column indices for ID and measured response value
id &lt;- 1
re &lt;- 2
# Multi-layer SpatRaster of landscape similarities
fls &lt;- list.files(path = p, pattern = "su_", full.names = TRUE)
ls &lt;- terra::rast(fls)
# Selection of representative response observations for stratification units
ro &lt;- observation(su.rast = su, obs = ob, col.id = id, col.resp = re,
                  ls.rast = ls
                 )
# Plot representative observations
if(interactive()){plot(su, type = "classes",
                       fun = function() points(ro$su_repobs.sp)
                      )}

</code></pre>

<hr>
<h2 id='plot3D'>Interactive Maps of 3D surfaces</h2><span id='topic+plot3D'></span>

<h3>Description</h3>

<p>Interactive maps showing the 3-dimensional (<em>XYZ</em>) variability in raster
layers representing continuous variables. The <em>XYZ</em> reference positions
will be obtained from an elevation layer and the values of the continuous
variables will be used as a surface color gradient. For this function to
work, there must be a raster layer of elevation (e.g., digital terrain model)
and at least one continuous variable among the raster layers to map. The maps
produced are interactive, meaning that manual axis rotation and zoom are
possible. Special consideration must be taken with large raster layers (large
spatial coverage and/or high spatial resolution). This function can
aggregates the spatial resolution (i.e., cell size) in order to handle large
raster layers. This is achieved by internally calling
<code><a href="terra.html#topic+aggregate">aggregate</a></code>. An aggregation factor will determine the
final cell size, where <em>final cell size = cell size*aggregation factor</em>.
In addition, a spatial extent can be provided to reduce the total mapping
area and thus, to further reduce processing time. This function uses the
<strong>plotly</strong> library. See <strong>Details</strong> for current limitations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3D(
  var.rast,
  z,
  ex = 0.1,
  agg = FALSE,
  fact = NULL,
  spext = NULL,
  pals = NA,
  rev = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot3D_+3A_var.rast">var.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Multi-layer
SpatRaster of <em>n</em> continuous variables and one layer representing the
surface/terrain elevation.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_z">z</code></td>
<td>
<p>Integer. Position (index) of the raster layer of elevation in
<em>var.rast</em>.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_ex">ex</code></td>
<td>
<p>Numeric. Value indicating the <em>exaggeration</em> factor for the
<em>Z</em> axis. This can be useful to enhance the visualization of subtle
topographic variability. Default: 0.1</p>
</td></tr>
<tr><td><code id="plot3D_+3A_agg">agg</code></td>
<td>
<p>Boolean. Should the spatial resolution be aggregated to reduce
processing time? Default: FALSE</p>
</td></tr>
<tr><td><code id="plot3D_+3A_fact">fact</code></td>
<td>
<p>Numeric. If <em>agg = TRUE</em>, value indicating the aggregation
factor. Default: NULL</p>
</td></tr>
<tr><td><code id="plot3D_+3A_spext">spext</code></td>
<td>
<p>Numeric. List with the coordinates of the bounding box for
spatial subset (xmin, xmax, ymin, ymax). SpatRaster or SpatVector from
which a spatial extent can be calculated are also an acceptable input.
Default: NULL</p>
</td></tr>
<tr><td><code id="plot3D_+3A_pals">pals</code></td>
<td>
<p>Character. List of strings with the names of the <em>n</em> color
ramps (one per continuous variable). See
<code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>. Default: NA</p>
</td></tr>
<tr><td><code id="plot3D_+3A_rev">rev</code></td>
<td>
<p>Character. List of <em>n</em> Booleans indicating whether or not to
reverse the color ramp for each continuous variable. Default: NA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, this function does not allow to adjust the labels for <em>XY</em>
axes so that actual coordinates are shown. Instead, the relative position
values are shown on these axes.
</p>


<h3>Value</h3>

<p>List with <strong>plotly-htmlwidget</strong> objects. Each object calls the 3D map
for a continuous variable in <em>var.rast</em>.
</p>


<h3>See Also</h3>

<p>Other Miscellaneous Functions: 
<code><a href="#topic+dummies">dummies</a>()</code>,
<code><a href="#topic+figure">figure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Multi-layer SpatRaster of topographic variables
ft &lt;- list.files(path = p, pattern = "^height|^slope|^wetness",
                 full.names = TRUE
                )
tvars &lt;- terra::rast(ft)
# Single-layer SpatRaster of terrain elevation
fe &lt;- list.files(path = p, pattern = "^elevation", full.names = TRUE)
e &lt;- terra::rast(fe)
# Add elevation to the SpatRaster of topographic variables
etvars &lt;- c(e, tvars)
# Interactive 3D maps
maps &lt;- plot3D(var.rast = etvars, z = 1, ex = 0.2,
               pals = c("Zissou", "Plasma", "Spectral")
              )
if(interactive()){maps}

</code></pre>

<hr>
<h2 id='predict_functions'>Predict Distribution Functions Across Geographic Space</h2><span id='topic+predict_functions'></span>

<h3>Description</h3>

<p>Predicts constrained, univariate distribution functions across the geographic
space supported by raster layers. For a given continuous variable used to
create a classification unit, this function first calculates a user-defined
distribution function for that variable using only observations selected from
within the classification unit. In this way, the distribution function is
univariate and constrained. Subsequently, a <em>locally-estimated
scatterplot smoothing</em> (LOESS) or a <em>generalized additive model</em> (GAM)
is fitted. This model is fitted using the variable’s observations as
explanatory values and the values from the distribution function as the
response values. Finally, the fitted model is predicted on the complete
geographic space supported by the raster layer of the given variable. This
process is iterated for all of the continuous variables and classification
units. Each resulting layer can be thought of as a landscape correspondence
measurement between an <em>XY</em> location in geographic space and the
landscape configuration represented by a given classification unit in terms
of a specific variable. The following distribution functions are currently
supported: the probability density function (PDF), the empirical cumulative
density function (ECDF), and the inverse of the empirical cumulative density
function (iECDF). Please refer to <strong>Details</strong> for more information about
how each distribution function is calculated. Also, see details on parallel
processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_functions(
  cuvar.rast,
  cu.ind,
  cu,
  vars,
  dif,
  hist.type = "regular",
  hist.pen = "default",
  grid.mult = 1,
  kern = "normal",
  quant.sep = 0.01,
  method = "loess",
  span = 0.6,
  k = 20,
  discrete = TRUE,
  to.disk = FALSE,
  outdir = ".",
  prefix = "",
  extension = ".tif",
  overwrite = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_functions_+3A_cuvar.rast">cuvar.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Multi-layer
SpatRaster containing <em>n</em> continuous raster layers (i.e., variables)
and one raster layer of classification units with integer cell values
(i.e., Numeric identifiers).</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_cu.ind">cu.ind</code></td>
<td>
<p>Integer. Position (index) of the raster layer of classification
units in <em>cuvar.rast</em>.</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_cu">cu</code></td>
<td>
<p>Integer. Vector of integer values that correspond to the numeric
identifiers of the units in the raster layer of classification units.</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_vars">vars</code></td>
<td>
<p>Character. Vector of strings containing the names of the <em>n</em>
continuous variables in <em>cuvar.rast</em>. These names have to be
sequentially repeated according to the number of classification units (See
<strong>Examples</strong>).</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_dif">dif</code></td>
<td>
<p>Character. Vector of strings containing the distribution function
to calculate for each continuous variable within each classification unit.
The function will match the position of the name of the distribution
function with that of the name of the continuous variable in <em>vars</em>.</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_hist.type">hist.type</code></td>
<td>
<p>Character. Type of histogram to calculate. Options are
&quot;regular&quot;, &quot;irregular&quot; (unequally-sized bins, very slow), and &quot;combined&quot;
(the one with greater penalized likelihood is returned). See
<code><a href="histogram.html#topic+histogram">histogram</a></code>. Default: &quot;regular&quot;</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_hist.pen">hist.pen</code></td>
<td>
<p>Character. Penalty to apply when calculating the histogram
(see <code><a href="histogram.html#topic+histogram">histogram</a></code>). Default: &quot;default&quot;</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_grid.mult">grid.mult</code></td>
<td>
<p>Numeric. Multiplying factor to increase/decrease the size of
the &quot;optimal&quot; grid size for the <em>Kernel Density Estimate</em> (KDE).
Default: 1</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_kern">kern</code></td>
<td>
<p>Character. Type of kernel to use for the KDE. Default: &quot;normal&quot;</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_quant.sep">quant.sep</code></td>
<td>
<p>Numeric. Spacing between quantiles for the calculation of
the ECDF and iECDF. Quantiles are in the range of 0-1 thus spacing must be
a decimal. Default: 0.01</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_method">method</code></td>
<td>
<p>Character. Model to fit. Current options are &quot;loess&quot; for
locally-estimated scatterplot smoothing (see <code><a href="stats.html#topic+loess">loess</a></code>),
and &quot;gam&quot; for generalized additive model with support for large datasets
(see <code><a href="mgcv.html#topic+bam">bam</a></code>). Default: &quot;loess&quot;</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_span">span</code></td>
<td>
<p>Numeric. If <em>method = &quot;loess&quot;</em>, degree of smoothing for
LOESS fitting. Default: 0.6</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_k">k</code></td>
<td>
<p>Numeric. If <em>method = &quot;gam&quot;</em>, Number of knots for the
<em>cubic regression splines</em>. Default: 20</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_discrete">discrete</code></td>
<td>
<p>Boolean. If <em>method = &quot;gam&quot;</em>, discretize variables for
storage and efficiency reasons? Can reduce processing time significantly.
Default: TRUE</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_to.disk">to.disk</code></td>
<td>
<p>Boolean. Write the output raster layers of predicted
distribution function to disk? See details an example about parallel
processing. Default: FALSE</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_outdir">outdir</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, string specifying the path
for the output raster layers of predicted distribution function. Default:
&quot;.&quot;</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_prefix">prefix</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, string specifying a prefix
for the file names of the output raster layers of predicted distribution
function. Default: &quot;&quot;</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_extension">extension</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, string specifying the
extension for the output raster layers of predicted distribution function.
Default: &quot;.tif&quot;</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_overwrite">overwrite</code></td>
<td>
<p>Boolean. If <em>to.disk = TRUE</em>, should raster layers in
disk and with same name as the output raster layer(s) of predicted
distribution function be overwritten? Default: FALSE</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Show warning messages in the console? Default: FALSE</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_...">...</code></td>
<td>
<p>If <em>to.disk = TRUE</em>, additional arguments as for
<code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To calculate the PDF, this function uses the binned KDE for observations
drawn from the breaks of a regular/irregular histogram. The &quot;optimal&quot; number
of bins for the histogram is defined by calling the function
<code><a href="histogram.html#topic+histogram">histogram</a></code> (Mildenberger et al., 2019) with the
user-defined penalty <em>hist.pen</em>. Subsequently, the optimal number of
bins is treated as equivalent to the &quot;optimal&quot; grid size for the binned KDE.
The grid size can be adjusted by specifying the multiplying factor
<em>grid.mult</em>. Lastly, the &quot;optimal&quot; bandwidth for the binned KDE is
calculated by applying the <em>direct plugin</em> method of Sheather and Jones
(1991). For the calculation of optimal bandwidth and for the binned KDE, the
package <strong>KernSmooth</strong> is called. To calculate both the ECDF and the
iECDF, this function calls the <code><a href="stats.html#topic+ecdf">ecdf</a></code> function on
equally-spaced quantiles. The spacing between quantiles can be manually
adjusted via <em>quant.sep</em>. In the case of iECDF, the ECDF is inverted by
applying the formula: <em>iECDF = ((x - max(ECDF)) * -1) + min(ECDF)</em>;
where <em>x</em> corresponds to each value of the ECDF.
</p>
<p>The &quot;cu&quot;, &quot;vars&quot;, and &quot;dif&quot; parameters of this function are configured such
that the output table from <code><a href="#topic+select_functions">select_functions</a></code> can be used
directly as input. (see <strong>Examples</strong>).
</p>
<p>When writing output raster layer to disk, multiple distribution functions can
be predicted in parallel if a parallel backend is registered beforehand with
<code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code>. Keep in mind that the function
may require a large amount of memory when using a parallel backend with large
raster layers (i.e., high resolution and/or large spatial coverage).
</p>
<p>Some issues have been reported when manually creating cluster objects using
the <span class="pkg">parallel</span> package. To overcome this issue, a cluster object can be
registered directly through <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code>
without passing it first through <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. See
examples.
</p>


<h3>Value</h3>

<p>Single-layer or multi-layer SpatRaster with the predicted distribution
function for each variable and for each classification unit.
</p>


<h3>References</h3>

<p>T. Mildenberger, Y. Rozenholc, and D. Zasada. histogram: Construction of
Regular and Irregular Histograms with Different Options for Automatic Choice
of Bins, 2019. <a href="https://CRAN.R-project.org/package=histogram">https://CRAN.R-project.org/package=histogram</a>
</p>
<p>S. Sheather and M. Jones. A reliable data-based bandwidth selection method
for kernel density estimation. Journal of the Royal Statistical Society.
Series B. Methodological, 53:683–690, 1991.
</p>


<h3>See Also</h3>

<p>Other Landscape Correspondence Metrics: 
<code><a href="#topic+select_functions">select_functions</a>()</code>,
<code><a href="#topic+signature">signature</a></code>,
<code><a href="#topic+similarity">similarity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Multi-layer SpatRaster of topographic variables
## 3 continuous variables
ftva &lt;- list.files(path = p, pattern = "^height|^slope|^wetness",
                   full.names = TRUE
                  )
tva &lt;- terra::rast(ftva)
# Single-layer SpatRaster of topographic classification units
## Five classification units
ftcu &lt;- list.files(path = p, pattern = "topography.tif", full.names = TRUE)
tcu &lt;- terra::rast(ftcu)
# Add the classification units to the SpatRaster of topographic variables
tcuvars &lt;- c(tcu, tva)
# Data frame with source for "cu", "vars", and "dif"
ftdif &lt;- list.files(path = p, pattern = "topodif.csv", full.names = TRUE)
tdif &lt;- read.csv(ftdif)
# Check structure of source data frame
head(tdif)
# Predict distribution functions
## 1 distribution function per variable and classification unit = 1
tpdif &lt;- predict_functions(cuvar.rast = tcuvars,
                           cu.ind = 1,
                           cu = tdif$Class.Unit[1:3],
                           vars = tdif$Variable[1:3],
                           dif = tdif$Dist.Func[1:3],
                           grid.mult = 3,
                           span = 0.9
                         )
# Plot predicted distribution functions
if(interactive()){plot(tpdif, col = hcl.colors(100, "Oslo", rev = TRUE))}

#--------
# Writing results to disk and parallel processing

if(interactive()){
  # Directory for temporary files
  o &lt;- tempdir()
  # Register parallel backend
  require(doParallel)
  registerDoParallel(4)
  # Predict distribution functions
  tpdif &lt;- predict_functions(cuvar.rast = tcuvars,
                             cu.ind = 1,
                             cu = tdif$Class.Unit[1:3],
                             vars = tdif$Variable[1:3],
                             dif = tdif$Dist.Func[1:3],
                             grid.mult = 3, span = 0.9,
                             to.disk = TRUE,
                             outdir = o
                         )
   # Stop cluster
   stopImplicitCluster()
   # Clean temporary files
   file.remove(sources(tpdif))
 }

</code></pre>

<hr>
<h2 id='select_functions'>Select Constrained Univariate Distribution Functions</h2><span id='topic+select_functions'></span>

<h3>Description</h3>

<p>Selection of distribution functions for continuous raster layers that were
used to create a raster layer of classification units. The distribution
functions currently supported are the probability density function (PDF), the
empirical cumulative density function (ECDF), and the inverse of the
empirical cumulative density function (iECDF). Please note that
<code><a href="#topic+select_functions">select_functions</a></code> DOES NOT calculate the aforementioned
distribution functions. The sole purpose of <code><a href="#topic+select_functions">select_functions</a></code> is
to assist in the knowledge-driven selection of the most appropriate
distribution function for each continuous variable used to create a given
classification unit (see <strong>Details</strong>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_functions(
  cu.rast,
  var.rast,
  fun = mean,
  varscale = "uniminmax",
  mode = "auto",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_functions_+3A_cu.rast">cu.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Single-layer
SpatRaster representing the classification units occurring across
geographic space. The cell values (i.e., numeric IDs) for classification
units must be integer values.</p>
</td></tr>
<tr><td><code id="select_functions_+3A_var.rast">var.rast</code></td>
<td>
<p>SpatRaster. Multi-layer SpatRaster containing the <em>n</em>
continuous raster layers of the variables used to create the classification
units.</p>
</td></tr>
<tr><td><code id="select_functions_+3A_fun">fun</code></td>
<td>
<p>Character. Descriptive statistical measurement (e.g., mean, max).
See <code><a href="terra.html#topic+zonal">zonal</a></code>. Default: mean</p>
</td></tr>
<tr><td><code id="select_functions_+3A_varscale">varscale</code></td>
<td>
<p>Character. Variable scaling method. See <em>scale</em> argument
in <code><a href="GGally.html#topic+ggparcoord">ggparcoord</a></code>. Default: &quot;uniminmax&quot;</p>
</td></tr>
<tr><td><code id="select_functions_+3A_mode">mode</code></td>
<td>
<p>Character. String specifying the selection mode for univariate
distribution functions. Possible values are &quot;inter&quot; for interactive
selection, and &quot;auto&quot; for automatic selection (see Details). Default:
&quot;auto&quot;</p>
</td></tr>
<tr><td><code id="select_functions_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Show warning messages in the console? Default: FALSE</p>
</td></tr>
<tr><td><code id="select_functions_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="GGally.html#topic+ggparcoord">ggparcoord</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selection of distribution functions is univariate, that is, for each
variable, and it is constrained, meaning that the selection has to be made
for each classification unit. Overall, the distribution functions are used to
characterize typical values of a given continuous variable within a given
classification unit. When the PDF is selected, values closer to, or at the
peak of the PDF will be considered as the most typical. Contrarily, values at
the tails of the PDF will be considered as the less typical. When the ECDF or
the iECDF are selected, values toward (+)infinity and (-)infinity will be
considered as the most typical values, respectively.
</p>
<p>In order to assist the selection process, when <em>mode = &quot;inter&quot;</em>, this
function displays an interactive parallel coordinates plot (see
<code><a href="plotly.html#topic+ggplotly">ggplotly</a></code>) and a writable table (built in Shiny). For
each variable, the parallel coordinates plot shows a trend of a descriptive
statistical measurement (argument <em>fun</em>) across all of the
classification units. Using this trend, one can then select the most
appropriate distribution function for each variable based on the
occurrence/absence of <strong>&quot;peaks&quot;</strong> and <strong>&quot;pits&quot;</strong> in the observed
trend. For instance, a peak (highest point in the trend) would indicate that
the given classification unit contains on average, the highest values of that
variable. Conversely, a pit (lowest point in the trend) would indicate that
the given classification unit contains on average, the lowest values of that
variable. Thus, an ECDF and an iECDF can be selected for the peak and the
pit, respectively. The PDF can be selected for classification units whose
trend does not show either a peak or a pit. Please consider that peaks and
pits are only reference points and thus, one should validate the selection of
distribution functions based on domain knowledge.
</p>
<p>When <em>mode = &quot;auto&quot;</em>, the criteria for the selection of distribution
functions will be based on peaks and pits in the parallel coordinates plot.
</p>
<p>The output table (<strong>distfun</strong>) is intended to be used as input in the
<code><a href="#topic+predict_functions">predict_functions</a></code> function.
</p>
<p>The selection of distribution functions is similar to the selection of
membership functions in fuzzy logic. For example, if one wants to describe a
phenomenon through distribution functions of continuous variables, then the
functions can be considered to be membership curves. Accordingly, the PDF,
ECDF, and iECDF will be equivalent to the Gaussian, S, and Z membership
functions, respectively.
</p>


<h3>Value</h3>

<p>If <em>mode = &quot;inter&quot;</em>:
</p>
<p><strong>distfun</strong>: A DT table (DataTables library) with the following
attributes: (1) <em>Class.Unit</em> = numeric ID for classification units, (2)
<em>Variable</em> = each of the <em>n</em> continuous raster layers of a
classification unit, and (3) <em>Dist.Func</em> = Empty column whose cells can
be filled with the following strings: &quot;PDF, &quot;ECDF&quot;, and &quot;iECDF&quot; (unquoted).
This table can be saved on disk through the Shiny interface.
</p>
<p><strong>parcoord</strong>: A plotly-based parallel coordinate plot which can be saved
on disk using the R package htmlwidgets.
</p>
<p>If <em>mode = &quot;auto&quot;</em>:
</p>
<p><strong>distfun</strong>: Same as <strong>distfun</strong> when <em>mode = &quot;inter&quot;</em>, except
for column &quot;Dist.Func&quot; whose cells were automatically filled.
</p>
<p><strong>parcoord</strong>: Same as <strong>parcoord</strong> when <em>mode = &quot;inter&quot;</em>.
</p>


<h3>See Also</h3>

<p>Other Landscape Correspondence Metrics: 
<code><a href="#topic+predict_functions">predict_functions</a>()</code>,
<code><a href="#topic+signature">signature</a></code>,
<code><a href="#topic+similarity">similarity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Multi-layer SpatRaster of topographic variables
## 3 topographic variables
tf &lt;- list.files(path = p, pattern = "^height|^slope|^wetness",
                 full.names = TRUE
                )
tvars &lt;- terra::rast(tf)
# Single-layer SpatRaster of topographic classification units
## 5 classification units
tcf &lt;- list.files(path = p, pattern = "topography.tif", full.names = TRUE)
tcu &lt;- terra::rast(tcf)
# Automatic selection of distribution functions
tdif &lt;- select_functions(cu.rast = tcu, var.rast = tvars, fun = mean)
# Parallel coordinates plot
if(interactive()){tdif$parcoord}

</code></pre>

<hr>
<h2 id='signature'>Calculate the Spatial Signature of Classification Units</h2><span id='topic+signature'></span>

<h3>Description</h3>

<p>Using a mathematical function, a raster layer is created from the cell-wise
aggregation of a set of predicted distribution functions for a classification
unit (see <code><a href="#topic+predict_functions">predict_functions</a></code>). Each element in this set can be
thought of as a correspondence measurement between an <em>XY</em> location in
the geographic space and the landscape configuration represented by a given
classification unit in terms of a specific variable. Therefore, aggregating
the set of predicted distribution functions into a single layer produces an
overall (multivariate) measurement of correspondence. This multivariate
landscape correspondence metric is considered to be the <em>spatial
signature</em> of the classification unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signature(
  pdif.rast,
  inprex,
  outname,
  fun = mean,
  to.disk = FALSE,
  outdir = ".",
  extension = ".tif",
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signature_+3A_pdif.rast">pdif.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Multi-layer
SpatRaster whose raster layers represent predicted distribution functions
for continuous variables and for one or more classification units. All
predicted distribution functions for a particular classification unit are
considered as part of the same set. There must be a matching pattern in the
names of predicted distribution functions from the same set (see
<em>inprex</em>).</p>
</td></tr>
<tr><td><code id="signature_+3A_inprex">inprex</code></td>
<td>
<p>Character. Prefix in the name of raster layers representing
predicted distribution functions belonging to the same set (i.e.,same
classification unit). If spatial signatures for multiple sets are to be
calculated, a vector of strings must be provided. See <strong>Details</strong> and
<strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="signature_+3A_outname">outname</code></td>
<td>
<p>Character. Output layer/file name for the raster layer(s) of
spatial signature. If the spatial signatures for multiple classification
units are to be calculated, then a vector of strings must be provided.</p>
</td></tr>
<tr><td><code id="signature_+3A_fun">fun</code></td>
<td>
<p>Function. The mathematical function must take a vector of values
and return a single value (e.g., mean, max, sum, etc.). See
<code><a href="terra.html#topic+app">app</a></code>. Default: mean</p>
</td></tr>
<tr><td><code id="signature_+3A_to.disk">to.disk</code></td>
<td>
<p>Boolean. Write the output raster layer(s) of spatial signature
to disk? See details about parallel processing. Default: FALSE</p>
</td></tr>
<tr><td><code id="signature_+3A_outdir">outdir</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, string specifying the path
for the output  raster layer(s) of spatial signature. Default: &quot;.&quot;</p>
</td></tr>
<tr><td><code id="signature_+3A_extension">extension</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, String specifying the
extension for the output raster layer(s) of spatial signature. Default:
&quot;.tif&quot;</p>
</td></tr>
<tr><td><code id="signature_+3A_overwrite">overwrite</code></td>
<td>
<p>Boolean. If <em>to.disk = TRUE</em>, should raster layers in
disk and with same name as the output raster layer(s) of spatial signature
be overwritten? Default: FALSE</p>
</td></tr>
<tr><td><code id="signature_+3A_...">...</code></td>
<td>
<p>If <em>to.disk = TRUE</em>, additional arguments as for
<code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Raster layers of predicted distribution functions belonging to the same
classification unit must be identified by a unique prefix in their layer
names (argument <em>inprex</em>). This prefix is used as a string pattern to
find all the predicted distribution functions belonging to one classification
unit. Consequently, a unique prefix must be defined for each additional
classification unit to distinguish between predicted distribution functions
for different classification units. Similarly, an additional string (or
vector of strings) of file/layer name(s) must be provided to distinguish
between the resulting spatial signatures for different classification units
(argument <em>outname</em>). The length of <em>outname</em> must match that from
<em>inprex</em>.
</p>
<p>When writing the output raster layers of spatial signature to disk, a
parallel backend can be registered before running this function with
<code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> to speed-up computation. Note
that this is only helpful when calculating spatial signatures for many
classification units.
</p>
<p>From a spatial analysis standpoint, the aggregation of predicted distribution
functions into spatial signature is similar to the application of fuzzy
aggregation operators commonly used in GIS-based multi-criteria decision
analysis. Moreover, The use of descriptive statistics to calculate
<em>signatures</em> for landscape-related classification units can be traced
back to the works of Pike and Rozema (1975), and Pike (1988).
</p>


<h3>Value</h3>

<p>Single-layer or multi-layer SpatRaster with the spatial signature(s)
calculated from the set(s) of predicted distribution functions.
</p>


<h3>References</h3>

<p>R. Pike. The geometric signature: quantifying landslide-terrain types from
digital elevation models. Mathematical geology, 20(5):491–511, 1988.
<a href="https://doi.org/10.1007/BF00890333">doi:10.1007/BF00890333</a>
</p>
<p>R. Pike and W. Rozema. Spectral analysis of landforms. Annals of the
Association of American Geographers,65(4):499–516, 1975.
<a href="https://doi.org/10.1111/j.1467-8306.1975.tb01058.x">doi:10.1111/j.1467-8306.1975.tb01058.x</a>
</p>


<h3>See Also</h3>

<p>Other Landscape Correspondence Metrics: 
<code><a href="#topic+predict_functions">predict_functions</a>()</code>,
<code><a href="#topic+select_functions">select_functions</a>()</code>,
<code><a href="#topic+similarity">similarity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Multi-layer SpatRast with predicted distribution functions
## 3 continuous variables and 5 classification units, = 15 functions
ft &lt;- list.files(path = p, pattern = "topo_", full.names = TRUE)
t &lt;- terra::rast(ft)
# Vector with the prefix for each set of predicted distribution functions
## 5 classification units = 5 sets
it &lt;- paste("topo_", seq(1, 5), "_", sep = "")
# Vector of names for output raster layers of spatial signature
## 5 spatial signatures, one per classification unit
ot &lt;- paste("topography_", seq(1, 5), sep = "")
# Calculate spatial signatures
tsig &lt;- signature(pdif.rast = t, inprex = it, outname = ot)
# Plot spatial signatures
if(interactive()){plot(tsig, col = hcl.colors(100, "Oslo", rev = TRUE))}

</code></pre>

<hr>
<h2 id='similarity'>Calculate the Landscape Similarity to Stratification Units</h2><span id='topic+similarity'></span>

<h3>Description</h3>

<p>For each stratification unit present in a single-layer SpatRaster, a raster
layer of landscape similarity is created by aggregating the stratification
unit's corresponding set of spatial signatures (see <code><a href="#topic+signature">signature</a></code>).
For a stratification unit <em>x</em>, the corresponding set of spatial
signatures consists of one spatial signature for each of the <em>n</em>
classification units that are present in the numeric code of <em>x</em> (one
classification unit per landscape factor/factor scale). The aggregation
process is performed cell-wise, and by using a mathematical function which
takes multiple values but return a single value (e.g., mean, sum, min, max).
The resulting raster layer represents the correspondence between an <em>XY</em>
location in geographic space and the landscape configuration represented by a
given stratification unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity(
  su.rast,
  su.code,
  sig.rast,
  fun = mean,
  to.disk = FALSE,
  outdir = ".",
  prefix = "su_",
  extension = ".tif",
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="similarity_+3A_su.rast">su.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Single-layer
SpatRaster representing the stratification units occurring across
geographic space. Integer values are expected as cell values (i.e., numeric
codes) of stratification units.</p>
</td></tr>
<tr><td><code id="similarity_+3A_su.code">su.code</code></td>
<td>
<p>List. The structure of the stratification units' numeric code.
This (nested) list should indicate the names of the landscape
factors/factor scales used to create the stratification units, and the
position (start, end) of their corresponding classification units' ID in
the numeric code. See <strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="similarity_+3A_sig.rast">sig.rast</code></td>
<td>
<p>SpatRaster. Multi-layer SpatRaster with the spatial
signatures of all the classification units that were used to create the
stratification units. The spatial signatures should follow this name
convention: <em>x_n</em>; where <em>x</em> is the landscape factor/factor scale,
and <em>n</em> is the numeric ID of the classification unit to which
the spatial signature belongs.</p>
</td></tr>
<tr><td><code id="similarity_+3A_fun">fun</code></td>
<td>
<p>Function. The mathematical function must accept a vector of values
and return a single value (e.g., mean, max, sum, etc.). See
<code><a href="terra.html#topic+app">app</a></code>. Default: mean</p>
</td></tr>
<tr><td><code id="similarity_+3A_to.disk">to.disk</code></td>
<td>
<p>Boolean. Write the output raster layers of landscape
similarity to disk? See note about parallel processing. Default: FALSE</p>
</td></tr>
<tr><td><code id="similarity_+3A_outdir">outdir</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, string specifying the path
for the output raster layers of landscape similarity. Default: &quot;.&quot;</p>
</td></tr>
<tr><td><code id="similarity_+3A_prefix">prefix</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, prefix for the file name
of the output raster layers of landscape similarity. Default: &quot;su_&quot;</p>
</td></tr>
<tr><td><code id="similarity_+3A_extension">extension</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, string specifying the
extension for the output raster layers of landscape signature. Default:
&quot;.tif&quot;</p>
</td></tr>
<tr><td><code id="similarity_+3A_overwrite">overwrite</code></td>
<td>
<p>Boolean. When <em>to.disk = TRUE</em>, should raster layers in
disk and with same name as the output landscape similarities be
overwritten? Default: FALSE</p>
</td></tr>
<tr><td><code id="similarity_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="terra.html#topic+writeRaster">writeRaster</a></code> (if
<em>to.disk = TRUE</em>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The landscape similarity is a landscape correspondence metric. The
aggregation of multiple spatial signatures into a single landscape similarity
layer is somewhat similar to the application of fuzzy logic and aggregation
operators in GIS-based multi-criteria decision analysis. Furthermore, the
aggregation of raster layers indicating relative optimality for
spatially-varying phenomena, like spatial signatures, can be guided by
physical/ecological principles like Sprengel-Liebig's law of the minimum. In
such case, one could select the <em>min</em> function when aggregating the
spatial signatures into landscape similarities.
</p>
<p>When writing the output raster layers of landscape similarity to disk, a
parallel backend can be registered before running this function with
<code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> to speed-up computation.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<p><strong>landsim</strong>: Multi-layer SpatRaster with the landscape similarity to
each stratification unit present in <em>su.rast</em>.
</p>
<p><strong>codes</strong>: A data frame with the numeric code for each stratification
unit and the corresponding classification units' numeric ID for each
landscape factor/factor scale.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strata">strata</a></code>
</p>
<p>Other Landscape Correspondence Metrics: 
<code><a href="#topic+predict_functions">predict_functions</a>()</code>,
<code><a href="#topic+select_functions">select_functions</a>()</code>,
<code><a href="#topic+signature">signature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Single-layer SpatRaster of stratification units
fsu &lt;- list.files(path = p, pattern = "strata2.tif", full.names = TRUE)
su &lt;- terra::rast(fsu)
# Define the structure of the stratification units' numeric code
code &lt;- list(geology = c(1,1), climate = c(2,2), topography = c(3,3))
# Multi-layer SpatRaster of spatial signatures of classification units
fsig &lt;- list.files(path = p, pattern = "geology_|climate_|topography_",
                   full.names = TRUE
                  )
sig &lt;- terra::rast(fsig)
# Calculate landscape similarity to stratification units
landsim &lt;- similarity(su.rast = su, su.code = code, sig.rast = sig)

# Plot some landscape similarities
# if(interactive()){plot(landsim$landsim[[c(1,10,12,14)]],
#                        col = hcl.colors(100, "Oslo", rev = TRUE)
#                       )}

#-------
# A note on the numeric code of stratification units

# For a given stratification unit, the structure of its corresponding numeric
# code indicates: (1) the landscape factors and/or factor scales that were
# accounted for when creating the stratification unit, and (2) the numeric id
# of the classification unit from each landscape factor/factor scale.
# Consider the following numeric code structure:

su.code &lt;- list(geology = c(1,1), climate = c(2,2), topography = c(3,4))

# The stratification units are composed of classification units from...
# ...three landscape factors: geology, climate, and topography
names(su.code)

# For geology, the classification units are represented by the first...
# ...digit in the numeric code
su.code$geology

# For climate, the classification units are represented by the second...
# ...digit in the numeric code
su.code$climate
# For topography, the classification units are represented by the third...
# ...and fourth digit in the numeric code
su.code$topography

# Thus, the numeric code of the stratification units 1101 and 2410 means:
su &lt;- c(1101, 2410)
su[1]   # 'geology' = 1, 'climate' = 1, and 'topography' = 1
su[2]   # 'geology' = 2, 'climate' = 4, and 'topography' = 10

</code></pre>

<hr>
<h2 id='som_gap'>Self-Organizing Map and Selection of k</h2><span id='topic+som_gap'></span>

<h3>Description</h3>

<p>Produces a low-dimensional representation of the input feature space for
subsequent estimation of the &quot;optimal&quot; number of clusters (<em>k</em>) in a
multivariate dataset. The dimension reduction is based on the
self-organizing map technique (SOM) of Kohonen (1982; 1990), and implemented
in R by the function <code><a href="kohonen.html#topic+supersom">supersom</a></code> of Wehrens and
Kruisselbrink (2018). To estimate the optimal <em>k</em>, the partitioning
around medoids (PAM) of Kaufman and Rousseeuw (1990), coupled with the gap
statistic of Tibshirani et al. (2001), is performed on the SOM's codebook
vectors. This is achieved by internally calling <code><a href="cluster.html#topic+pam">pam</a></code>
and <code><a href="cluster.html#topic+clusGap">clusGap</a></code> (Maechler et al., 2021). See
<em>Details</em> for a brief theoretical background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>som_gap(
  var.rast,
  xdim = 12,
  ydim = 12,
  topo = "hexagonal",
  neighbourhood.fct = "gaussian",
  rlen = 600,
  dist.fcts = c("sumofsquares", "manhattan"),
  mode = "pbatch",
  K.max,
  stand = FALSE,
  B = 500,
  d.power = 2,
  spaceH0 = "original",
  method = "globalSEmax",
  SE.factor = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="som_gap_+3A_var.rast">var.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. This Multi-layer
SpatRaster must contain <em>n</em> continuous variables from which the SOM
will be created.</p>
</td></tr>
<tr><td><code id="som_gap_+3A_xdim">xdim</code></td>
<td>
<p>Integer. Horizontal dimension of the SOM's grid. Default: 12</p>
</td></tr>
<tr><td><code id="som_gap_+3A_ydim">ydim</code></td>
<td>
<p>Integer. Vertical dimension of the SOM's grid. Default: 12</p>
</td></tr>
<tr><td><code id="som_gap_+3A_topo">topo</code></td>
<td>
<p>Character. Topology of the SOM's grid. Options = &quot;rectangular&quot;,
&quot;hexagonal&quot;. Default: &quot;hexagonal&quot;</p>
</td></tr>
<tr><td><code id="som_gap_+3A_neighbourhood.fct">neighbourhood.fct</code></td>
<td>
<p>Character. Neighborhood of the SOM's grid. Options =
&quot;bubble&quot;, &quot;gaussian&quot;. Default: &quot;gaussian&quot;</p>
</td></tr>
<tr><td><code id="som_gap_+3A_rlen">rlen</code></td>
<td>
<p>Integer. Number of times the complete dataset will be presented
to the SOM's network. Default: 600</p>
</td></tr>
<tr><td><code id="som_gap_+3A_dist.fcts">dist.fcts</code></td>
<td>
<p>Character. Vector of length 2 containing the distance
functions to use for SOM (First element, options = &quot;sumofsquares&quot;,
&quot;euclidean&quot;, &quot;manhattan&quot;) and for PAM (second element, options =
&quot;euclidean&quot;, &quot;manhattan&quot;). Default: c(&quot;sumofsquares&quot;, &quot;manhattan&quot;)</p>
</td></tr>
<tr><td><code id="som_gap_+3A_mode">mode</code></td>
<td>
<p>Character. Type of learning algorithm. Options are “online&quot;,
&quot;batch&quot;, and &quot;pbatch&quot;. Default: &quot;pbatch&quot;</p>
</td></tr>
<tr><td><code id="som_gap_+3A_k.max">K.max</code></td>
<td>
<p>Integer. Maximum number of clusters to consider, must be at
least two (2).</p>
</td></tr>
<tr><td><code id="som_gap_+3A_stand">stand</code></td>
<td>
<p>Boolean. For PAM function, does SOM's codebook vectors need to
be standardized? Default: FALSE</p>
</td></tr>
<tr><td><code id="som_gap_+3A_b">B</code></td>
<td>
<p>Integer. Number of bootstrap samples for the gap statistic. Default:
500</p>
</td></tr>
<tr><td><code id="som_gap_+3A_d.power">d.power</code></td>
<td>
<p>Integer. Positive Power applied to euclidean distances for the
gap statistic. Default: 2</p>
</td></tr>
<tr><td><code id="som_gap_+3A_spaceh0">spaceH0</code></td>
<td>
<p>Character. Space of the reference distribution for the gap
statistic. Options = &quot;scaledPCA&quot;, &quot;original&quot; (See <strong>Details</strong>).
Default: &quot;original&quot;</p>
</td></tr>
<tr><td><code id="som_gap_+3A_method">method</code></td>
<td>
<p>Character. Optimal k selection criterion for the gap statistic.
Options = &quot;globalmax&quot;, &quot;firstmax&quot;, &quot;Tibs2001SEmax&quot;, &quot;firstSEmax&quot;,
&quot;globalSEmax&quot;. See  <code><a href="cluster.html#topic+clusGap">clusGap</a></code> for more details.
Default: &quot;globalSEmax&quot;</p>
</td></tr>
<tr><td><code id="som_gap_+3A_se.factor">SE.factor</code></td>
<td>
<p>Numeric. Factor to feed into the standard error rule for the
gap statistic. Only applicable for methods based on standard error (SE).
See <code><a href="cluster.html#topic+clusGap">clusGap</a></code> for more details. Default: 1</p>
</td></tr>
<tr><td><code id="som_gap_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="kohonen.html#topic+supersom">supersom</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clustering of SOM's codebook vectors has been proposed in several works,
notably in that from Vesanto and Alhoniemi (2000). These authors proposed a
two-stage clustering routine as an efficient method to reduce computational
load, while obtaining satisfactory correspondence between the clustered
codebook vectors and the clustered original feature space.
</p>
<p>The main purpose of this function is to allow the use of clustering and
k-selection algorithms that may result prohibitive for large datasets, such
as matrices derived from raster layers commonly used during geocomputational
routines. Thus, the SOM's codebook vectors can be subsequently used for the
calculation of distance matrices, which given the large size of their input
feature space, may otherwise be impossible to create due to insufficient
memory allocation capacity. Similarly, robust clustering algorithms that
require full pairwise distance matrices (e.g., hierarchical clustering, PAM)
and/or eigenvalues (e.g., spectral clustering) may also be performed on SOM's
codebook vectors.
</p>
<p>Note that <code><a href="kohonen.html#topic+supersom">supersom</a></code> will internally equalize the
importance (i.e., weights) of variables such that differences in scale will
not affect distance calculations. This behavior can be prevented by setting
<em>normalizeDataLayers = FALSE</em> in additional arguments passed to
<code><a href="kohonen.html#topic+supersom">supersom</a></code>. Moreover, custom weights can also be passed
through the additional argument <em>user.weights</em>. In such case, user
weights are applied on top of the internal weights.
</p>
<p>When working with large matrices, the additional SOM argument
<em>keep.data</em> may be set to FALSE. However, note that by doing so, the
suggested follow-up function for raster products <code><a href="#topic+som_pam">som_pam</a></code> will
not work since it requires both original data and winning units.
</p>
<p>For the gap statistic, <em>method = &quot;scaledPCA&quot;</em> has resulted in errors for
R sessions with BLAS/LAPACK supported by the Intel Math Kernel Library (MKL).
</p>


<h3>Value</h3>

<p><strong>SOM</strong>: An object of class <strong>kohonen</strong> (see
<code><a href="kohonen.html#topic+supersom">supersom</a></code>). The components of class kohonen returned by
this function are: (1) <em>data</em> = original input matrix, (2)
<em>unit.classif</em> = winning units for all observations, (3)
<em>distances</em> = distance between each observation and its corresponding
winning unit, (4) <em>grid</em> = object of class <strong>somgrid</strong> (see
<code><a href="kohonen.html#topic+somgrid">somgrid</a></code>), (5) <em>codes</em> = matrix of codebook
vectors, (6) <em>changes</em> = matrix of mean average deviations from codebook
vectors, (7) <em>dist.fcts</em> = selected distance function, and other
arguments passed to <code><a href="kohonen.html#topic+supersom">supersom</a></code> (e.g., <em>radius</em>,
<em>distance.weights</em>, etc.). Note that components 1, 2, and 3 will only be
returned if <em>keep.data = TRUE</em>, which is the default.
</p>
<p><strong>SOMdist</strong>: Object of class <strong>dist</strong>. Matrix of pairwise distances
calculated from the SOM's codebook vectors.
</p>
<p><strong>SOMgap</strong>: Object of class <strong>clusGap</strong>. The main component of
class clusGap returned by this function is <em>Tab</em>, which is a matrix of
the gap statistic results (see <code><a href="cluster.html#topic+clusGap">clusGap</a></code>). Additional
components are the arguments passed to the function (i.e., <em>spaceH0</em>,
<em>B</em>), the PAM function, <em>n</em> (number of observations) and
<em>call</em> (the clusGap call-type object).
</p>
<p><strong>Kopt</strong>: Optimal <em>k</em>, as selected by arguments <em>method</em> and
(possibly) <em>SE.factor</em>.
</p>


<h3>References</h3>

<p>L. Kaufman and P. Rousseeuw. Finding groups in data: an introduction to
cluster analysis. John Wiley &amp; Sons, 1990.
<a href="https://doi.org/10.1002/9780470316801">doi:10.1002/9780470316801</a>
</p>
<p>T. Kohonen. Self-organized formation of topologically correct feature maps.
Biological cybernetics, 43 (1):59–69, 1982.
<a href="https://doi.org/10.1007/bf00337288">doi:10.1007/bf00337288</a>
</p>
<p>T. Kohonen. The self-organizing map. Proceedings of the IEEE,
78(9):1464–1480, 1990. <a href="https://doi.org/10.1016/s0925-2312%2898%2900030-7">doi:10.1016/s0925-2312(98)00030-7</a>
</p>
<p>M. Maechler, P. Rousseeuw, A. Struyf, M. Hubert, and K. Hornik. cluster:
Cluster Analysis Basics and Extensions, 2021.
<a href="https://CRAN.R-project.org/package=cluster">https://CRAN.R-project.org/package=cluster</a>
</p>
<p>R. Tibshirani, G. Walther, and T. Hastie. Estimating the number of clusters
in a data set via the gap statistic. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 63(2):411–423, 2001.
<a href="https://doi.org/10.1111/1467-9868.00293">doi:10.1111/1467-9868.00293</a>
</p>
<p>J. Vesanto and E. Alhoniemi. Clustering of the self-organizing map. IEEE
Transactions on Neural Networks, 11(3):586–600, 2000.
<a href="https://doi.org/10.1109/72.846731">doi:10.1109/72.846731</a>
</p>
<p>R. Wehrens and J. Kruisselbrink. Flexible self-organizing maps in kohonen
3.0. Journal of Statistical Software, 87(1):1–18, 2018.
<a href="https://doi.org/10.18637/jss.v087.i07">doi:10.18637/jss.v087.i07</a>
</p>


<h3>See Also</h3>

<p>Other Functions for Landscape Stratification: 
<code><a href="#topic+som_pam">som_pam</a>()</code>,
<code><a href="#topic+strata">strata</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
# Multi-layer SpatRaster with topographic variables
p &lt;- system.file("exdat", package = "rassta")
tf &lt;- list.files(path = p, pattern = "^height|^slope|^wetness",
                 full.names = TRUE
                )
t &lt;- rast(tf)
# Scale topographic variables (mean = 0, StDev = 1)
ts &lt;- scale(t)
# Self-organizing map and gap statistic for optimum k
set.seed(963)
tsom &lt;- som_gap(var.rast = ts, xdim = 8, ydim = 8, rlen = 150,
               mode = "online", K.max = 6, B = 300, spaceH0 = "original",
               method = "globalSEmax"
              )
# Optimum k
tsom$Kopt

</code></pre>

<hr>
<h2 id='som_pam'>Rasterization of Self-Organizing Map and Partitioning Around Medoids</h2><span id='topic+som_pam'></span>

<h3>Description</h3>

<p>Creation of a rasterized representation of the outputs from the
self-organizing map (SOM) and partitioning around medoids (PAM). Given a
reference raster layer, each winning unit of the SOM and clustering value
from the PAM will be mapped on the corresponding cell in the reference layer
and across the geographic space supported by such layer. Note that this
function is a follow-up of the <code><a href="#topic+som_gap">som_gap</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>som_pam(ref.rast, kohsom, k, metric = "manhattan", stand = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="som_pam_+3A_ref.rast">ref.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. This raster
layer will serve as a reference of the index of valid cells and the
geographic support for the rasterized representation of SOM's winning units
and PAM's clustering. See <em>Details</em> for some notes about efficiency.</p>
</td></tr>
<tr><td><code id="som_pam_+3A_kohsom">kohsom</code></td>
<td>
<p>SOM Object of class <strong>kohonen</strong>, see
<code><a href="kohonen.html#topic+supersom">supersom</a></code>. The following components must be present
in the SOM object (1) <em>unit.classif</em> = winning units for all
observations, and (2) <em>codes</em> = matrix of codebook vectors.</p>
</td></tr>
<tr><td><code id="som_pam_+3A_k">k</code></td>
<td>
<p>Integer (positive value). Number of clusters to form from the
codebook vectors of the SOM, where <em>k &lt; SOM's codebook vectors</em>.</p>
</td></tr>
<tr><td><code id="som_pam_+3A_metric">metric</code></td>
<td>
<p>Character. Distance function for PAM. Options are &quot;euclidean&quot;,
and &quot;manhattan&quot;. Default: &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="som_pam_+3A_stand">stand</code></td>
<td>
<p>Boolean. For the PAM function, do SOM's codebook vectors need to
be standardized? Default: FALSE</p>
</td></tr>
<tr><td><code id="som_pam_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="cluster.html#topic+pam">pam</a></code>. See
<strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As in <code><a href="#topic+som_gap">som_gap</a></code>, this function calls <code><a href="cluster.html#topic+pam">pam</a></code>
to perform the clustering of SOM's codebook vectors. The SOM object must
belong to the class <strong>kohonen</strong>, as in <code><a href="kohonen.html#topic+supersom">supersom</a></code>.
</p>
<p>Note that in order for <code><a href="#topic+som_pam">som_pam</a></code> to perform efficiently, the
reference SpatRaster <em>ref.rast</em> must be a single-layer SpatRaster with
the same cell size, number of rows, number of columns, and index of valid
cells as those in the multi-layer SpatRaster object used in
<code><a href="#topic+som_gap">som_gap</a></code>. If a multi-layer SpatRaster (with each layer possibly
having a different index of valid cells) is used as the <em>ref.rast</em>, the
efficiency of <code><a href="#topic+som_pam">som_pam</a></code> (i.e., running time and/or memory
allocation) may be degraded when handling large SpatRaster objects.
</p>
<p>For this function to work as intended, the additional argument
<em>cluster.only</em> in <code><a href="cluster.html#topic+pam">pam</a></code> must remain as FALSE, which
is the default.
</p>


<h3>Value</h3>

<p><strong>sompam</strong>: Object of class <strong>pam</strong>. See ?pam.object for details.
</p>
<p><strong>sompam.rast</strong>: Multi-layer SpatRaster, as in
<code><a href="terra.html#topic+rast">rast</a></code>. The first raster layer corresponds to the SOM's
winning units. The second raster layer corresponds to the clustered SOM's
codebook vectors by PAM.
</p>


<h3>See Also</h3>

<p>Other Functions for Landscape Stratification: 
<code><a href="#topic+som_gap">som_gap</a>()</code>,
<code><a href="#topic+strata">strata</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
# Multi-layer SpatRaster with topographic variables
p &lt;- system.file("exdat", package = "rassta")
ft &lt;- list.files(path = p, pattern = "^height|^slope|^wetness",
                 full.names = TRUE
                )
t &lt;- rast(ft)
# Scale topographic variables (mean = 0, StDev = 1)
ts &lt;- scale(t)
# Self-organizing map and gap statistic for optimum k
set.seed(963)
tsom &lt;- som_gap(var.rast = ts, xdim = 8, ydim = 8, rlen = 150,
               mode = "online", K.max = 6, B = 300, spaceH0 = "original",
               method = "globalSEmax"
              )
# Optimum k
tsom$Kopt
# PAM clustering of topographic SOM's codebook vectors
tpam &lt;- som_pam(ref.rast = t[[1]], kohsom = tsom$SOM, k = tsom$Kopt)
# Plot topographic variables, SOM grid and PAM clustering
if(interactive()){plot(c(t, tpam$sompam.rast))}

</code></pre>

<hr>
<h2 id='strata'>Create Stratification Units</h2><span id='topic+strata'></span>

<h3>Description</h3>

<p>Stratification units are created from the spatial intersection of raster
layers representing different sets of classification units. Each set of
classification units is related to a particular landscape factor (e.g.,
topography, climate) or to a particular spatial scale for a single landscape
factor (e.g., micro-climate, macro-topography). Each resulting stratification
unit is considered to represent a distinct landscape configuration in terms
of multiple landscape factors/factor scales (represented by the
classification units). This function automatically assigns a unique numeric
code to each stratification unit. For <em>x</em> stratification unit, the
numeric code represents the unique combination of classification units whose
spatial intersection resulted in <em>x</em>. See <strong>Examples</strong> to get a
better idea of the logic behind the code assignment process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata(cu.rast, to.disk = FALSE, outdir = ".", su.name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strata_+3A_cu.rast">cu.rast</code></td>
<td>
<p>SpatRaster, as in <code><a href="terra.html#topic+rast">rast</a></code>. Multi-layer
SpatRaster for which each layer represents a set of classification units
for a particular landscape factor or factor scale. Integer cell values
(i.e., numeric identifiers) are expected.</p>
</td></tr>
<tr><td><code id="strata_+3A_to.disk">to.disk</code></td>
<td>
<p>Boolean. Write the resulting raster layer of stratification
units to disk? Default: FALSE</p>
</td></tr>
<tr><td><code id="strata_+3A_outdir">outdir</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, string specifying the path
for the output raster layer of stratification units. Default: &quot;.&quot;</p>
</td></tr>
<tr><td><code id="strata_+3A_su.name">su.name</code></td>
<td>
<p>Character. If <em>to.disk = TRUE</em>, file name (including
extension) for the output raster layer of stratification units.</p>
</td></tr>
<tr><td><code id="strata_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When printing <em>su.rast$code.mult</em>, the output shows the multiplier
used for each landscape factor/factor scale. From this output, one can manually
replicate the creation of stratification units through simple raster algebra.
To do so, a weighted sum of the SpatRasters containing the classification
units for each landscape factor/factor scale should be performed using the
multipliers as weights. Note that the weights do not imply relative
importance. The weights are required only to preserve a logical structure of
the landscape factors/factor scales in the resulting numeric code.
</p>


<h3>Value</h3>

<p><strong>su.rast</strong>: Single-layer SpatRaster representing the stratification
units occurring across geographic space. The cell values in this raster layer
represents the numeric codes of stratification units.
</p>
<p><strong>code.mult</strong>: Multipliers used for the creation of the numeric codes.
See <strong>Details</strong>.
</p>


<h3>See Also</h3>

<p>Other Functions for Landscape Stratification: 
<code><a href="#topic+som_gap">som_gap</a>()</code>,
<code><a href="#topic+som_pam">som_pam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(terra)
p &lt;- system.file("exdat", package = "rassta")
# Multi-layer SpatRast with classification units (Cus)
## Three sets (i.e., landscape factors): geology, climate and topography
fcu &lt;- list.files(path = p,
                  pattern = "geology.tif|climate.tif|topography.tif",
                  full.names = TRUE
                 )
cu &lt;- terra::rast(fcu)
# Stratification units (SUs)
su &lt;- strata(cu.rast = cu)
# Plot the stratification units
if(interactive()){plot(su$su.rast, type = "classes")}
#
# Note code structure from SUs and corresponding values from CUs
z &lt;- c(su$su.rast, cu)[46,61]   # Example of one cell (row = 45, column = 45)
su$code.mult                    # Multipliers
z[c("SU", names(su$code.mult))] # Code structure

# Note what happens when some landscape factors have cell values greater...
#... than 1 digit (i.e., more than 9 distinct classification units)
cu &lt;- c(cu[[1]], cu[[2]]^4, cu[[3]]^2)
su &lt;- strata(cu.rast = cu)
su$code.mult
c(su$su.rast, cu[[names(su$code.mult)]])[46,61]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
