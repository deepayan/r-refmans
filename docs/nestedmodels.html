<!DOCTYPE html><html><head><title>Help for package nestedmodels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nestedmodels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#augment.nested_model_fit'><p>Augment data with predictions</p></a></li>
<li><a href='#autoplot.nested_model_fit'><p>Create a set of ggplots for a nested model object</p></a></li>
<li><a href='#example_nested_data'><p>Example nested data</p></a></li>
<li><a href='#extract_inner_model'><p>Get the inner model of a nested model object</p></a></li>
<li><a href='#fit_xy.nested_model'><p>Fit a nested model to a dataset using an xy interface.</p></a></li>
<li><a href='#fit.nested_model'><p>Fit a nested model to a dataset</p></a></li>
<li><a href='#multi_predict.nested_model_fit'><p>Nested model predictions across many sub-models</p></a></li>
<li><a href='#nested'><p>Create a Nested Model</p></a></li>
<li><a href='#nested_resamples'><p>Create splits with nested data</p></a></li>
<li><a href='#nestedmodels-package'><p>nestedmodels: Tidy Modelling for Nested Data</p></a></li>
<li><a href='#predict.nested_model_fit'><p>Nested Model Predictions</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#step_nest'><p>Nest transformation</p></a></li>
<li><a href='#tidy.nested_model_fit'><p>Turn a nested model into a tidy tibble</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tidy Modelling for Nested Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A modelling framework for nested data using the 'tidymodels' 
    ecosystem. Specify how to nest data using the 'recipes' package, create 
    testing and training splits using 'rsample', and fit models to this data
    using the 'parsnip' and 'workflows' packages. Allows any model to be fit
    to nested data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ashbythorpe/nestedmodels">https://github.com/ashbythorpe/nestedmodels</a>,
<a href="https://ashbythorpe.github.io/nestedmodels/">https://ashbythorpe.github.io/nestedmodels/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ashbythorpe/nestedmodels/issues">https://github.com/ashbythorpe/nestedmodels/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, foreach, generics, ggplot2, lifecycle, magrittr,
parsnip, purrr, recipes, rlang (&ge; 0.4.11), rsample, stats,
stringr, tibble, tidyr (&gt; 0.8.99), vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom, covr, doParallel, ggrepel, glmnet, glue, hardhat,
knitr, parallel, patchwork, rmarkdown, roxygen2, testthat (&ge;
3.0.0), tidyselect, tune, utils, vdiffr, withr, workflows</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-30 10:40:39 UTC; ashbythorpe</td>
</tr>
<tr>
<td>Author:</td>
<td>Ashby Thorpe <a href="https://orcid.org/0000-0003-3106-099X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ashby Thorpe &lt;ashbythorpe@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-30 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='augment.nested_model_fit'>Augment data with predictions</h2><span id='topic+augment.nested_model_fit'></span>

<h3>Description</h3>

<p><code><a href="generics.html#topic+augment">generics::augment()</a></code> method for nested models. <code>augment.nested_model_fit()</code>
will add column(s) for predictions to the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested_model_fit'
augment(x, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.nested_model_fit_+3A_x">x</code></td>
<td>
<p>A <code>nested_model_fit</code> object produced by
<code><a href="#topic+fit.nested_model">fit.nested_model()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.nested_model_fit_+3A_new_data">new_data</code></td>
<td>
<p>A data frame - can be nested or non-nested.</p>
</td></tr>
<tr><td><code id="augment.nested_model_fit_+3A_...">...</code></td>
<td>
<p>Passed onto <code><a href="parsnip.html#topic+augment">parsnip::augment.model_fit()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one or more added columns for predictions.
</p>


<h3>See Also</h3>

<p><code><a href="parsnip.html#topic+augment">parsnip::augment.model_fit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(tidyr)
library(parsnip)

data &lt;- filter(example_nested_data, id %in% 1:5)

nested_data &lt;- nest(data, data = -c(id, id2))

model &lt;- linear_reg() %&gt;%
  set_engine("lm") %&gt;%
  nested()

fitted &lt;- fit(model, z ~ x + y + a + b, nested_data)

augment(fitted, example_nested_data)

</code></pre>

<hr>
<h2 id='autoplot.nested_model_fit'>Create a set of ggplots for a nested model object</h2><span id='topic+autoplot.nested_model_fit'></span>

<h3>Description</h3>

<p>This method calls <code><a href="parsnip.html#topic+autoplot.model_fit">parsnip::autoplot.model_fit()</a></code> on each model fitted on
each nested data frame, returning a list of plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested_model_fit'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.nested_model_fit_+3A_object">object</code></td>
<td>
<p>A <code>nested_model_fit</code> object produced by
<code><a href="#topic+fit.nested_model">fit.nested_model()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.nested_model_fit_+3A_...">...</code></td>
<td>
<p>Passed into <code><a href="parsnip.html#topic+autoplot.model_fit">parsnip::autoplot.model_fit()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Printing the list of plots will print every plot in turn, so remember to
store the result of this function in a variable to look at each plot
individually.
</p>


<h3>Value</h3>

<p>A list of <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(dplyr)
library(tidyr)
library(purrr)
library(parsnip)
library(glmnet)
library(ggplot2)

data &lt;- filter(example_nested_data, id %in% 16:20)

nested_data &lt;- nest(data, data = -id2)

model &lt;- linear_reg(penalty = 1) %&gt;%
  set_engine("glmnet") %&gt;%
  nested()

fit &lt;- fit(model, z ~ x + y + a + b, nested_data)

plots &lt;- autoplot(fit)

# View the first plot
plots[[1]]

# Use the patchwork package (or others) to combine the plots
library(patchwork)

reduce(plots, `+`)

</code></pre>

<hr>
<h2 id='example_nested_data'>Example nested data</h2><span id='topic+example_nested_data'></span>

<h3>Description</h3>

<p>A dataset containing example data that can be nested. Mainly used for
examples and testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_nested_data
</code></pre>


<h3>Format</h3>

<p>A tibble with 1000 rows and 7 variables
</p>

<dl>
<dt>id</dt><dd><p>A column that can be nested, ranging from 1 to 20.</p>
</dd>
<dt>id2</dt><dd><p>Another column that can be nested, ranging from 1 to 10.</p>
</dd>
<dt>x</dt><dd><p>A numeric column that depends on 'id'.</p>
</dd>
<dt>y</dt><dd><p>A sequential numeric column (with some added randomness),
independent of the other columns.</p>
</dd>
<dt>z</dt><dd><p>A column dependent on id, id2, x and y.</p>
</dd>
<dt>a</dt><dd><p>A randomly generated numeric column, ranging from 1 to 100.</p>
</dd>
<dt>b</dt><dd><p>A randomly generated numeric column, centred around 50.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>example_nested_data
</code></pre>

<hr>
<h2 id='extract_inner_model'>Get the inner model of a nested model object</h2><span id='topic+extract_inner_model'></span><span id='topic+extract_inner_model.default'></span><span id='topic+extract_inner_model.nested_model'></span><span id='topic+extract_inner_model.workflow'></span><span id='topic+extract_inner_model.model_spec'></span>

<h3>Description</h3>

<p>Extract the inner model of a <code>nested_model</code> object, or a workflow
containing a nested model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_inner_model(x, ...)

## Default S3 method:
extract_inner_model(x, ...)

## S3 method for class 'nested_model'
extract_inner_model(x, ...)

## S3 method for class 'workflow'
extract_inner_model(x, ...)

## S3 method for class 'model_spec'
extract_inner_model(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_inner_model_+3A_x">x</code></td>
<td>
<p>A model spec or workflow.</p>
</td></tr>
<tr><td><code id="extract_inner_model_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>model_spec</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(parsnip)

model &lt;- linear_reg() %&gt;%
  set_engine("lm") %&gt;%
  nested()

extract_inner_model(model)

</code></pre>

<hr>
<h2 id='fit_xy.nested_model'>Fit a nested model to a dataset using an xy interface.</h2><span id='topic+fit_xy.nested_model'></span>

<h3>Description</h3>

<p><code><a href="generics.html#topic+fit_xy">generics::fit_xy()</a></code> method for nested models. This should not be
called directly and instead should be called by
<code><a href="workflows.html#topic+fit-workflow">workflows::fit.workflow()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested_model'
fit_xy(
  object,
  x,
  y,
  case_weights = NULL,
  control = parsnip::control_parsnip(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_xy.nested_model_+3A_object">object</code></td>
<td>
<p>An <code>nested_model</code> object (see <code><a href="#topic+nested">nested()</a></code>).</p>
</td></tr>
<tr><td><code id="fit_xy.nested_model_+3A_x">x</code></td>
<td>
<p>A data frame of predictors.</p>
</td></tr>
<tr><td><code id="fit_xy.nested_model_+3A_y">y</code></td>
<td>
<p>A data frame of outcome data.</p>
</td></tr>
<tr><td><code id="fit_xy.nested_model_+3A_case_weights">case_weights</code></td>
<td>
<p>An optional vector of case weights. Passed into
<code><a href="parsnip.html#topic+fit">parsnip::fit.model_spec()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_xy.nested_model_+3A_control">control</code></td>
<td>
<p>A <code><a href="parsnip.html#topic+control_parsnip">parsnip::control_parsnip()</a></code> object. Passed into
<code><a href="parsnip.html#topic+fit">parsnip::fit.model_spec()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_xy.nested_model_+3A_...">...</code></td>
<td>
<p>Passed into <code><a href="parsnip.html#topic+fit">parsnip::fit.model_spec()</a></code>. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>nested_model_fit</code> object with several elements:
</p>

<ul>
<li> <p><code>spec</code>: The model specification object (the inner model of the
nested model object)
</p>
</li>
<li> <p><code>fit</code>: A tibble containing the model fits and the nests that they
correspond to.
</p>
</li>
<li> <p><code>inner_names</code>: A character vector of names, used to help with
nesting the data during predictions.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="parsnip.html#topic+fit">parsnip::fit.model_spec()</a></code> <a href="parsnip.html#topic+model_fit">parsnip::model_fit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(dplyr)
library(parsnip)
library(recipes)
library(workflows)

data &lt;- filter(example_nested_data, id %in% 11:20)

model &lt;- linear_reg() %&gt;%
  set_engine("lm") %&gt;%
  nested()

recipe &lt;- recipe(data, z ~ x + y + id) %&gt;%
  step_nest(id)

wf &lt;- workflow() %&gt;%
  add_recipe(recipe) %&gt;%
  add_model(model)

fit(wf, data)

</code></pre>

<hr>
<h2 id='fit.nested_model'>Fit a nested model to a dataset</h2><span id='topic+fit.nested_model'></span>

<h3>Description</h3>

<p><code>fit.model_spec()</code> takes a nested model specification and fits the inner
model specification to each nested data frame in the given dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested_model'
fit(
  object,
  formula,
  data,
  case_weights = NULL,
  control = parsnip::control_parsnip(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.nested_model_+3A_object">object</code></td>
<td>
<p>An <code>nested_model</code> object (see <code><a href="#topic+nested">nested()</a></code>).</p>
</td></tr>
<tr><td><code id="fit.nested_model_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code>. Passed into
<code><a href="parsnip.html#topic+fit">parsnip::fit.model_spec()</a></code>. This should <em>not contain</em> the variable to
nest by.</p>
</td></tr>
<tr><td><code id="fit.nested_model_+3A_data">data</code></td>
<td>
<p>A data frame. If used with a 'nested_model' object, the data
frame must already be nested.</p>
</td></tr>
<tr><td><code id="fit.nested_model_+3A_case_weights">case_weights</code></td>
<td>
<p>An optional vector of case weights. Passed into
<code><a href="parsnip.html#topic+fit">parsnip::fit.model_spec()</a></code>.</p>
</td></tr>
<tr><td><code id="fit.nested_model_+3A_control">control</code></td>
<td>
<p>A <code><a href="parsnip.html#topic+control_parsnip">parsnip::control_parsnip()</a></code> object. Passed into
<code><a href="parsnip.html#topic+fit">parsnip::fit.model_spec()</a></code>.</p>
</td></tr>
<tr><td><code id="fit.nested_model_+3A_...">...</code></td>
<td>
<p>Passed into <code><a href="parsnip.html#topic+fit">parsnip::fit.model_spec()</a></code>. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>nested_model_fit</code> object with several elements:
</p>

<ul>
<li> <p><code>spec</code>: The model specification object (the inner model of the
nested model object)
</p>
</li>
<li> <p><code>fit</code>: A tibble containing the model fits and the nests that they
correspond to.
</p>
</li>
<li> <p><code>inner_names</code>: A character vector of names, used to help with
nesting the data during predictions.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="parsnip.html#topic+fit">parsnip::fit.model_spec()</a></code> <a href="parsnip.html#topic+model_fit">parsnip::model_fit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(parsnip)
library(tidyr)

model &lt;- linear_reg() %&gt;%
  set_engine("lm") %&gt;%
  nested()

nested_data &lt;- nest(example_nested_data, data = -id)

fit(model, z ~ x + y + a + b, nested_data)

</code></pre>

<hr>
<h2 id='multi_predict.nested_model_fit'>Nested model predictions across many sub-models</h2><span id='topic+multi_predict.nested_model_fit'></span>

<h3>Description</h3>

<p><code><a href="parsnip.html#topic+multi_predict">parsnip::multi_predict()</a></code> method for nested models. Allows predictions
to be made on sub-models in a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested_model_fit'
multi_predict(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_predict.nested_model_fit_+3A_object">object</code></td>
<td>
<p>A <code>nested_model_fit</code> object produced by
<code><a href="#topic+fit.nested_model">fit.nested_model()</a></code>.</p>
</td></tr>
<tr><td><code id="multi_predict.nested_model_fit_+3A_new_data">new_data</code></td>
<td>
<p>A data frame - can be nested or non-nested.</p>
</td></tr>
<tr><td><code id="multi_predict.nested_model_fit_+3A_...">...</code></td>
<td>
<p>Passed onto <code><a href="parsnip.html#topic+multi_predict">parsnip::multi_predict()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the same number of rows as <code>new_data</code>, after it
has been unnested.
</p>


<h3>See Also</h3>

<p><code><a href="parsnip.html#topic+multi_predict">parsnip::multi_predict()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(dplyr)
library(tidyr)
library(parsnip)
library(glmnet)

data &lt;- filter(example_nested_data, id %in% 16:20)

nested_data &lt;- nest(data, data = -id2)

model &lt;- linear_reg(penalty = 1) %&gt;%
  set_engine("glmnet") %&gt;%
  nested()

fitted &lt;- fit(model, z ~ x + y + a + b, nested_data)

multi_predict(fitted, example_nested_data,
  penalty = c(0.1, 0.2, 0.3)
)

</code></pre>

<hr>
<h2 id='nested'>Create a Nested Model</h2><span id='topic+nested'></span><span id='topic+is_nested'></span><span id='topic+nested.default'></span><span id='topic+nested.model_spec'></span><span id='topic+nested.nested_model'></span><span id='topic+nested.workflow'></span><span id='topic+is_nested.default'></span><span id='topic+is_nested.model_spec'></span><span id='topic+is_nested.workflow'></span>

<h3>Description</h3>

<p><code>nested()</code> turns a model or workflow into a nested model/workflow.
<code>is_nested()</code> checks if a model or workflow is nested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested(x, ...)

is_nested(x, ...)

## Default S3 method:
nested(x, ...)

## S3 method for class 'model_spec'
nested(x, allow_par = FALSE, pkgs = NULL, ...)

## S3 method for class 'nested_model'
nested(x, allow_par = FALSE, pkgs = NULL, ...)

## S3 method for class 'workflow'
nested(x, allow_par = FALSE, pkgs = NULL, ...)

## Default S3 method:
is_nested(x, ...)

## S3 method for class 'model_spec'
is_nested(x, ...)

## S3 method for class 'workflow'
is_nested(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_+3A_x">x</code></td>
<td>
<p>A model specification or workflow.</p>
</td></tr>
<tr><td><code id="nested_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="nested_+3A_allow_par">allow_par</code></td>
<td>
<p>A logical to allow parallel processing over nests during
the fitting process (if a parallel backend is registered).</p>
</td></tr>
<tr><td><code id="nested_+3A_pkgs">pkgs</code></td>
<td>
<p>An optional character string of R package names that should be
loaded (by namespace) during parallel processing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested model object, or a workflow containing a nested model.
For <code>is_nested()</code>, a logical vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(parsnip)
library(workflows)

model &lt;- linear_reg() %&gt;%
  set_engine("lm") %&gt;%
  nested()

model

is_nested(model)

wf &lt;- workflow() %&gt;%
  add_model(model)

is_nested(wf)

</code></pre>

<hr>
<h2 id='nested_resamples'>Create splits with nested data</h2><span id='topic+nested_resamples'></span>

<h3>Description</h3>

<p>Use any rsample split function on nested data, where nests act as
strata. This almost guarantees that every split will contain data from
every nested data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_resamples(
  data,
  resamples,
  nesting_method = NULL,
  size_action = c("truncate", "recycle", "recycle-random", "combine", "combine-random",
    "combine-end", "error"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_resamples_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="nested_resamples_+3A_resamples">resamples</code></td>
<td>
<p>An expression, function, formula or string that can
be evaluated to produce an <code>rset</code> or <code>rsplit</code> object.</p>
</td></tr>
<tr><td><code id="nested_resamples_+3A_nesting_method">nesting_method</code></td>
<td>
<p>A recipe, workflow or <code>NULL</code>, used to nest <code>data</code>
if <code>data</code> is not already nested (see Details).</p>
</td></tr>
<tr><td><code id="nested_resamples_+3A_size_action">size_action</code></td>
<td>
<p>If different numbers of splits are produced in each
nest, how should sizes be matched? (see Details)</p>
</td></tr>
<tr><td><code id="nested_resamples_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass into <code>resamples</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function breaks down a data frame into smaller, nested data frames.
Resampling is then performed within these nests, and the results are
combined together at the end. This ensures that each split contains
data from every nest. However, this function does not perform any
pooling (unlike <code><a href="rsample.html#topic+make_strata">rsample::make_strata()</a></code>), so you may run into issues
if a nest is too small.
</p>


<h3>Value</h3>

<p>Either an <code>rsplit</code> object or an <code>rset</code> object, depending on
<code>resamples</code>.
</p>


<h3>Nesting Data</h3>

<p><code>data</code> can be nested in several ways:
If <code>nesting_method</code> is <code>NULL</code> and <code>data</code> is grouped (using
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>), the data will be nested (see <code><a href="tidyr.html#topic+nest">tidyr::nest()</a></code>
for how this works).
If <code>data</code> is not grouped, it is assumed to already be nested, and
<code>nested_resamples</code> will try to find a column that contains nested data
frames.
If <code>nesting_method</code> is a workflow or recipe, and the recipe has a step
created using  <code><a href="#topic+step_nest">step_nest()</a></code>, <code>data</code> will be nested using the step in
the recipe. This is convenient if you've already created a recipe or
workflow, as it saves a line of code.
</p>


<h3>Resample Evaluation</h3>

<p>The <code>resamples</code> argument can take many forms:
</p>

<ul>
<li><p> A function call, such as <code>vfold_cv(v = 5)</code>. This is similar to the
format of <code><a href="rsample.html#topic+nested_cv">rsample::nested_cv()</a></code>.
</p>
</li>
<li><p> A function, such as <code>rsample::vfold_cv</code>.
</p>
</li>
<li><p> A purrr-style anonymous function, which will be converted to a
function using <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>.
</p>
</li>
<li><p> A string, which will be evaluated using <code><a href="rlang.html#topic+exec">rlang::exec()</a></code>.
</p>
</li></ul>

<p>Every method will be evaluated with <code>data</code> passed in as the first
argument (with name 'data').
</p>


<h3>Size Matching</h3>

<p>Before the set of resamples created in each nest can be combined, they
must contain the same number of splits. For most resampling methods,
this will not be an issue. <code><a href="rsample.html#topic+vfold_cv">rsample::vfold_cv()</a></code>, for example, reliably
creates the number of splits defined in its 'v' argument. However,
other resampling methods, like <code><a href="rsample.html#topic+rolling_origin">rsample::rolling_origin()</a></code>, depend on
the size of their 'data' argument, and therefore may produce different
numbers of resamples when presented with differently sized nests.
</p>
<p>The <code>size_action</code> argument defines many ways of matching the sizes of
resample sets with different numbers of splits. These methods will either try
to reduce the number of splits in each set until each rset is the same
length as the set with the lowest number of splits; or the opposite,
where each rset will have the same number of splits as the largest set.
</p>
<p>&quot;truncate&quot;, the default, means that all splits beyond the required
length will be removed.
</p>
<p>&quot;recycle&quot; means that sets of splits will be extended by repeating
elements until the required length has been reached, mimicking the
process of vector recycling. The advantage of this method is that all
created splits will be preserved.
</p>
<p>&quot;recycle-random&quot; is a similar process to recycling, but splits will be
copied at random to spaces in the output, which may be important if
the order of resamples matters. This process is not completely random,
and the program makes sure that every split is copied roughly the same
number of times.
</p>
<p>&quot;combine&quot; gets rid of excess splits by combining them with previous ones.
This means the training and testing rows are merged into one split.
Combining is done systematically: if a set of splits needs to be
compacted down to a set of 5, the first split is combined with the
sixth split, then the eleventh, then the sixteenth, etc. This approach
is not recommended, since it is not clear what the benefit of a
combined split is.
</p>
<p>&quot;combine-random&quot; combines each split with a random set of other splits,
instead of the systematic process described in the previous method.
Once again, this process is not actually random, and each split will
be combined with roughly the same number of other splits.
</p>
<p>&quot;combine-end&quot; combines every excess split with the last non-excess
split.
</p>
<p>&quot;error&quot; throws an error if each nest does not produce the same number
of splits.
</p>


<h3>See Also</h3>

<p><code><a href="rsample.html#topic+initial_split">rsample::initial_split()</a></code> for an example of the strata
argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(tidyr)
library(recipes)
library(workflows)
library(rsample)
library(dplyr)

nested_data &lt;- example_nested_data %&gt;%
  nest(data = -id)

grouped_data &lt;- example_nested_data %&gt;%
  group_by(id)

recipe &lt;- recipe(example_nested_data, z ~ .) %&gt;%
  step_nest(id)

wf &lt;- workflow() %&gt;%
  add_recipe(recipe)

nested_resamples(nested_data, vfold_cv())

nested_resamples(
  group_by(example_nested_data, id),
  ~ initial_split(.)
)

nested_resamples(example_nested_data, bootstraps,
  times = 25, nesting_method = wf
)

# nested nested resamples

nested_resamples(nested_data, nested_cv(
  vfold_cv(),
  bootstraps()
))

</code></pre>

<hr>
<h2 id='nestedmodels-package'>nestedmodels: Tidy Modelling for Nested Data</h2><span id='topic+nestedmodels'></span><span id='topic+nestedmodels-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A modelling framework for nested data using the 'tidymodels' ecosystem. Specify how to nest data using the 'recipes' package, create testing and training splits using 'rsample', and fit models to this data using the 'parsnip' and 'workflows' packages. Allows any model to be fit to nested data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ashby Thorpe <a href="mailto:ashbythorpe@gmail.com">ashbythorpe@gmail.com</a> (<a href="https://orcid.org/0000-0003-3106-099X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Hadley Wickham <a href="mailto:hadley@rstudio.com">hadley@rstudio.com</a> (<a href="https://orcid.org/0000-0003-4757-117X">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ashbythorpe/nestedmodels">https://github.com/ashbythorpe/nestedmodels</a>
</p>
</li>
<li> <p><a href="https://ashbythorpe.github.io/nestedmodels/">https://ashbythorpe.github.io/nestedmodels/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ashbythorpe/nestedmodels/issues">https://github.com/ashbythorpe/nestedmodels/issues</a>
</p>
</li></ul>


<hr>
<h2 id='predict.nested_model_fit'>Nested Model Predictions</h2><span id='topic+predict.nested_model_fit'></span><span id='topic+predict_raw.nested_model_fit'></span>

<h3>Description</h3>

<p>Apply a fitted nested model to generate different types of predictions.
<code><a href="stats.html#topic+predict">stats::predict()</a></code> / <code><a href="parsnip.html#topic+predict.model_fit">parsnip::predict_raw()</a></code> methods for nested model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested_model_fit'
predict(object, new_data, type = NULL, opts = list(), ...)

## S3 method for class 'nested_model_fit'
predict_raw(object, new_data, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.nested_model_fit_+3A_object">object</code></td>
<td>
<p>A <code>nested_model_fit</code> object produced by
<code><a href="#topic+fit.nested_model">fit.nested_model()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.nested_model_fit_+3A_new_data">new_data</code></td>
<td>
<p>A data frame to make predictions on. Can be nested or
non-nested.</p>
</td></tr>
<tr><td><code id="predict.nested_model_fit_+3A_type">type</code></td>
<td>
<p>A singular character vector or <code>NULL</code>. Passed on to
<code><a href="parsnip.html#topic+predict.model_fit">parsnip::predict.model_fit()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.nested_model_fit_+3A_opts">opts</code></td>
<td>
<p>A list of optional arguments. Passed on to
<code><a href="parsnip.html#topic+predict.model_fit">parsnip::predict.model_fit()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.nested_model_fit_+3A_...">...</code></td>
<td>
<p>Arguments for the underlying model's predict function. Passed on
to <code><a href="parsnip.html#topic+predict.model_fit">parsnip::predict.model_fit()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of model predictions. For <code>predict_raw()</code>, a
matrix, data frame, vector or list.
</p>


<h3>See Also</h3>

<p><code><a href="parsnip.html#topic+predict.model_fit">parsnip::predict.model_fit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(tidyr)
library(parsnip)

data &lt;- filter(example_nested_data, id %in% 5:15)

nested_data &lt;- nest(data, data = -id)

model &lt;- linear_reg() %&gt;%
  set_engine("lm") %&gt;%
  nested()

fitted &lt;- fit(model, z ~ x + y + a + b, nested_data)

predict(fitted, example_nested_data)

predict_raw(fitted, example_nested_data)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+fit'></span><span id='topic+fit_xy'></span><span id='topic+augment'></span><span id='topic+tidy'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+fit">fit</a></code>, <code><a href="generics.html#topic+fit_xy">fit_xy</a></code>, <code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='step_nest'>Nest transformation</h2><span id='topic+step_nest'></span>

<h3>Description</h3>

<p><code>step_nest()</code> creates a <em>specification</em> of a recipe step that will
convert specified data into a single model term, specifying the 'nest'
that each row of the dataset corresponds to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_nest(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  names = NULL,
  lookup_table = NULL,
  skip = FALSE,
  id = recipes::rand_id("nest")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_nest_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_nest_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables.
For <code>step_nest</code>, this indicates the variables which will <em>not</em> be
nested. See <code><a href="recipes.html#topic+selections">recipes::selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_nest_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_nest_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_nest_+3A_names">names</code></td>
<td>
<p>The names of the variables selected by <code>...</code> are stored here
once this preprocessing step has been trained by <code><a href="recipes.html#topic+prep">recipes::prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_nest_+3A_lookup_table">lookup_table</code></td>
<td>
<p>The table describing which values of your selected
columns correspond to which unique nest id are stored here once this
preprocessing step has been trained by <code><a href="recipes.html#topic+prep">recipes::prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_nest_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">recipes::prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_nest_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_nest()</code> will create a single nominal variable (named '.nest_id')
from a set of variables (of any type). Every unique combination
of the specified columns will receive a single nest id.
</p>
<p>This recipe step is designed for use with nested models, since a model
will be fitted on the data corresponding to each nest id. Using a recipe
is often easier and more reliable than nesting the data manually.
</p>
<p>The nest id corresponding to each unique combination of column values is
decided when the recipe is prepped (if this recipe is contained in a
workflow, this happens when the workflow is fitted). This means that
when using a prepped recipe on new data (using <code><a href="recipes.html#topic+prep">recipes::prep()</a></code> or
<code><a href="workflows.html#topic+predict-workflow">workflows::predict.workflow()</a></code>), all unique combinations of nesting
columns must also exist in the training data. You will be warned if
this is not the case. If you are using the 'rsample' package to create
splits and this presents an issue, you may want to consider using
<code><a href="#topic+nested_resamples">nested_resamples()</a></code>.
</p>
<p><code>step_nest()</code> is designed so that nesting the transformed data by its
'.nest_id' column is equivalent to the following action on the
non-transformed data:
</p>
<div class="sourceCode"><pre>data %&gt;%
  dplyr::group_by(...) %&gt;% # '...' represents your specified terms
  tidyr::nest()
</pre></div>


<h3>Value</h3>

<p>An updated version of recipe with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned showing
how each unique value of the terms you have specified correspond to each
nest id.
</p>


<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)

recipe &lt;- recipe(example_nested_data, z ~ x + id) %&gt;%
  step_nest(id)

recipe %&gt;%
  prep() %&gt;%
  bake(NULL)

recipe2 &lt;- recipe(example_nested_data, z ~ x + id) %&gt;%
  step_nest(-c(x, z))

recipe2 %&gt;%
  prep() %&gt;%
  bake(NULL)

</code></pre>

<hr>
<h2 id='tidy.nested_model_fit'>Turn a nested model into a tidy tibble</h2><span id='topic+tidy.nested_model_fit'></span><span id='topic+glance.nested_model_fit'></span><span id='topic+glance_nested'></span>

<h3>Description</h3>

<p>Use broom functions on fitted nested models.
</p>
<p><code>tidy.nested_model_fit()</code> summarises components of each model within a
nested model fit, indicating which nested data frame each row corresponds
to.
</p>
<p><code>glance.nested_model_fit()</code> summarises a nested model, returning a
<code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with 1 row.
</p>
<p><code>glance_nested()</code> summarises each model within a nested model fit,
returning a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with the same number of rows as the number
of inner models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested_model_fit'
tidy(x, ...)

## S3 method for class 'nested_model_fit'
glance(x, ...)

glance_nested(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.nested_model_fit_+3A_x">x</code></td>
<td>
<p>A <code>nested_model_fit</code> object produced by <code><a href="#topic+fit.nested_model">fit.nested_model()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.nested_model_fit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed into their respective functions.
(e.g. for <code>tidy.nested_model_fit()</code>, <code><a href="parsnip.html#topic+tidy.model_fit">parsnip::tidy.model_fit()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="generics.html#topic+glance">generics::glance()</a></code> states that <code>glance()</code> methods should always return 1
row outputs for non-empty inputs. The 'nestedmodels' package is no
exception: <code>glance()</code> methods will combine rows to produce a result with a
single row. Specifically:
</p>

<ul>
<li><p> If a column contains 1 unique value, that value is used.
</p>
</li>
<li><p> If a column is numeric, the mean will be calculated.
</p>
</li>
<li><p> Otherwise, the results will be combined into a list.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>. With <code>glance.nested_model_fit()</code>, the
tibble will have 1 row.
</p>


<h3>See Also</h3>

<p><code><a href="generics.html#topic+tidy">generics::tidy()</a></code> <code><a href="generics.html#topic+glance">generics::glance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(dplyr)
library(parsnip)
library(broom)

data &lt;- filter(example_nested_data, id %in% 1:5)

model &lt;- linear_reg() %&gt;%
  set_engine("lm") %&gt;%
  nested()

fit &lt;- fit(
  model, z ~ x + y + a + b,
  group_by(data, id)
)

tidy(fit)
glance(fit)
glance_nested(fit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
