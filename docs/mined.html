<!DOCTYPE html><html><head><title>Help for package mined</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mined}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mined-package'>
<p>mined package</p></a></li>
<li><a href='#Lattice'>
<p>Good lattice points</p></a></li>
<li><a href='#mined'>
<p>Minimum Energy Design</p></a></li>
<li><a href='#SelectMinED'>
<p>Select Minimum Energy Design samples from a candidate set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Minimum Energy Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Dianpeng Wang and V. Roshan Joseph</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dianpeng Wang &lt;wdp@bit.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a method (MinED) for mining probability distributions using deterministic sampling which is proposed by Joseph, Wang, Gu, Lv, and Tuo (2019) &lt;<a href="https://doi.org/10.1080%2F00401706.2018.1552203">doi:10.1080/00401706.2018.1552203</a>&gt;. The MinED samples can be used for approximating the target distribution. They can be generated from a density function that is known only up to a proportionality constant and thus, it might find applications in Bayesian computation. Moreover, the MinED samples are generated with much fewer evaluations of the density function compared to random sampling-based methods such as MCMC and therefore, this method will be especially useful when the unnormalized posterior is expensive or time consuming to evaluate. This research is supported by a U.S. National Science Foundation grant DMS-1712642.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.17)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-19 06:37:01 UTC; dpwang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-26 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mined-package'>
mined package
</h2><span id='topic+mined-package'></span>

<h3>Description</h3>

<p>Generate minimum energy design (MinED) samples from an unnormalized probability density function. The asymptotic distribution of MinED samples converges to the target distribution and therefore, MinED can be viewed as a deterministic sample from the target distribution. The details of MinED and the algorithm used for generating it can be found in Joseph, Dasgupta, Tuo, and Wu (2015) and Joseph, Wang, Gu, Lv, and Tuo (2019). This research is supported by a U.S. National Science Foundation grant DMS-1712642.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mined</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-06-19</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Important functions in this package are: <code><a href="#topic+mined">mined</a></code> generates Minimum Energy Design samples from an unnormalized density function, <code><a href="#topic+SelectMinED">SelectMinED</a></code> selects Minimum Energy Design samples from candidate points, and <code><a href="#topic+Lattice">Lattice</a></code> generates good rank-1 lattice rules. 
</p>


<h3>Author(s)</h3>

<p>Dianpeng Wang and V. Roshan Joseph
</p>
<p>Maintainer: Dianpeng Wang &lt;wdp@bit.edu.cn&gt;
</p>


<h3>References</h3>

<p>Joseph, V. R., Dasgupta, T., Tuo, R., and Wu, C. F. J. (2015). &quot;Sequential Exploration of Complex Surfaces Using Minimum Energy Designs&quot;. <em>Technometrics</em>, 57, 64-74.
</p>
<p>Joseph, V. R., Wang, D., Gu, L., Lv, S., and Tuo, R. (2019). &quot;Deterministic Sampling of Expensive Posteriors Using Minimum Energy Designs&quot;, <em>Technometrics</em>, 61, 297-308, arXiv:1712.08929, DOI:10.1080/00401706.2018.1552203.
</p>

<hr>
<h2 id='Lattice'>
Good lattice points
</h2><span id='topic+Lattice'></span>

<h3>Description</h3>

<p>Generate good rank-1 lattice points with prime number of points by using the fast component-by-component construction algorithm of Nuyens and Cools (2006). Refer Nuyens (2007) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lattice(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lattice_+3A_n">n</code></td>
<td>

<p>The number of points, which should be a prime.
</p>
</td></tr>
<tr><td><code id="Lattice_+3A_p">p</code></td>
<td>

<p>The number of dimensions.
</p>
</td></tr>
</table>


<h3>Value</h3>


<p>An n-by-p matrix containing the good lattice points.
</p>


<h3>Author(s)</h3>

<p>Dianpeng Wang &lt;wdp@bit.edu.cn&gt; and V. Roshan Joseph &lt;roshan@gatech.edu&gt;
</p>


<h3>References</h3>

<p>Nuyens, D. and Cools, R. (2006). &quot;Fast algorithms for component-by-component construction of rank-1 lattice rules in shift-invariant reproducing kernel Hilbert spaces.&quot;, <em>Mathematics of Computation</em>, 75, 903-920.
</p>
<p>Nuyens, D. (2007). &quot;Fast Construction of Good Lattice Rules.&quot;, <em>Ph.D Thesis</em>, Katholieke Universiteit Leuven, Leuven, Belgium.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mined)
res &lt;- Lattice(101, 2)
plot(res[, 1], res[, 2], col='red',xlab='First dimension', ylab='Second dimension', pch=15)
</code></pre>

<hr>
<h2 id='mined'>
Minimum Energy Design
</h2><span id='topic+mined'></span>

<h3>Description</h3>

<p>Generate MinED samples from an unnormalized density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mined(initial, logf, K_iter = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mined_+3A_initial">initial</code></td>
<td>

<p>An n-by-p matrix containing the initial uniform samples from <code>[0,1]^p</code>. 
</p>
</td></tr>
<tr><td><code id="mined_+3A_logf">logf</code></td>
<td>

<p>An R function to compute the logarithm of unnormalized density function. The input region should be scaled in <code>[0,1]^p</code>.
</p>
</td></tr>
<tr><td><code id="mined_+3A_k_iter">K_iter</code></td>
<td>

<p>The number of iteration steps for annealed version of the unnormalized posterior density. Optional, default is <code>0</code>. If <code>0</code>, <code>K_iter = ceiling(4 * sqrt(p))</code> is used.

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function of the package, which is used for generating the MinED samples. The MinED sample can be viewed as a deterministic sample from the probability density specified in the mined function. Since only the unnormalized density is needed to generate the MinED samples, this method could be used in Bayesian computation to approximate the posterior. The method uses few evaluations of the unnormalized posterior compared to random sampling-based methods and therefore, it will be useful when the evaluations are expensive or time consuming.
</p>
<p>There are many parameters that control the performance of the algorithm, which are fixed at some reasonable values as specified in Joseph et al. (2019). The only thing user need to choose is the region for scaling the variables in [0,1]^p. Ideally it should be the highercube containing the highest posterior density region with good coverage. However, the algorithm is robust to this choice to some extend as it can shrink or expand from the intial region. Therefore, it can be chosen based on user's guessed range of each variable.
</p>


<h3>Value</h3>

<p>The value returned from the function is a list containing the following components:
</p>
<table>
<tr><td><code>points</code></td>
<td>
<p>A matrix containing <code>n</code> MinED samples.</p>
</td></tr>
<tr><td><code>logf</code></td>
<td>
<p>Log-unnormalized density function values of MinED samples.</p>
</td></tr>
<tr><td><code>cand</code></td>
<td>
<p>Full set of samples used in the algorithm.</p>
</td></tr>
<tr><td><code>candlf</code></td>
<td>
<p>Log-unormalized density function values of the samples in <code>cand</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dianpeng Wang &lt;wdp@bit.edu.cn&gt; and V. Roshan Joseph &lt;roshan@gatech.edu&gt;
</p>


<h3>References</h3>

<p>Joseph, V. R., Wang, D., Gu, L., Lv, S., and Tuo, R. (2019). &quot;Deterministic Sampling of Expensive Posteriors Using Minimum Energy Designs&quot;, <em>Technometrics</em>, 61, 297-308, arXiv:1712.08929, DOI:10.1080/00401706.2018.1552203.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(mined)
p &lt;- 2
n &lt;- 109 # largest prime number less than 100+5p
initial &lt;- Lattice(n, p)

# suppose x1 is in [-40,40] and x2 in [-25,10]
logf &lt;- function(para)
{
  l1 &lt;- -40
  u1 &lt;- 40
  l2 &lt;- -25
  u2 &lt;- 10
  x1 &lt;- l1 + (u1 - l1) * para[1]
  x2 &lt;- l2 + (u2 - l2) * para[2]
  val &lt;- -.5 * (x1 ^2 / 100 + (x2+ .03 * x1^2 -3)^2)
  return(val)
}

res &lt;- mined::mined(initial, logf, K_iter = 8)
dim(res$points)
dim(res$cand)

x1 &lt;- seq(0, 1, length.out = 200)
x2 &lt;- seq(0, 1, length.out = 200)
y &lt;- matrix(0.0, 200, 200)
for(i in 1:200)
{
  for(j in 1:200)
  {
    y[i, j] = logf(c(x1[i], x2[j]))
  }
}
image(x1, x2, exp(y), col = cm.colors(5), xlab = expression(x[1]), ylab = expression(x[2]))
points(res$cand[, 1], res$cand[, 2], pch = 11, col = rgb(red = 0, green = 0, blue = 1, 
       alpha = 0.35), cex = .25)
points(res$points[, 1], res$points[, 2], pch = 17, col = 'black', cex = .75)
legend("bottom", c('Candidates points', 'MinED samples'), pch = c(11, 17), 
        col = c(rgb(red = 0, green = 0, blue = 1, alpha = 0.35), 'black'), 
        inset = .02, bg = 'transparent', bty = 'n')
</code></pre>

<hr>
<h2 id='SelectMinED'>
Select Minimum Energy Design samples from a candidate set
</h2><span id='topic+SelectMinED'></span>

<h3>Description</h3>

<p>Select MinED samples from <code>candidates</code> by optimizing the generalized MinED criterion in Joseph et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectMinED(candidates, candlf, n, gamma=1, s=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectMinED_+3A_candidates">candidates</code></td>
<td>

<p>Candidate samples from the target distribution, which can be MC, QMC, or MCMC samples.
</p>
</td></tr>
<tr><td><code id="SelectMinED_+3A_candlf">candlf</code></td>
<td>

<p>The log-unnormalized density function values corresponding to the <code>candidates</code>.
</p>
</td></tr>
<tr><td><code id="SelectMinED_+3A_n">n</code></td>
<td>

<p>The required number of MinED samples.
</p>
</td></tr>
<tr><td><code id="SelectMinED_+3A_gamma">gamma</code></td>
<td>

<p>The parameter in the anealled version of density function. Optional, default is &ldquo;1&rdquo;. 
</p>
</td></tr>
<tr><td><code id="SelectMinED_+3A_s">s</code></td>
<td>

<p>The parameter in generalized distance. Optional, default is &ldquo;2&rdquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function select MinED samples from a given set of candidate samples. The function is used internally in the <code>mined</code> function repeatedly for K times, where K is the number of annealing steps in the algorithm. Refer to Joseph et al., (2018) for more details.
</p>


<h3>Value</h3>

<p>The value returned from the function is a list containing the following components:
</p>
<table>
<tr><td><code>points</code></td>
<td>
<p>The MinED samples selected from the <code>candidates</code>.</p>
</td></tr>
<tr><td><code>logf</code></td>
<td>
<p>The log-unnormalized density function values of the <code>points</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dianpeng Wang &lt;wdp@bit.edu.cn&gt; and V. Roshan Joseph &lt;roshan@gatech.edu&gt;
</p>


<h3>References</h3>

<p>Joseph, V. R., Wang, D., Gu, L., Lv, S., and Tuo, R. (2019). &quot;Deterministic Sampling of Expensive Posteriors Using Minimum Energy Designs&quot;, <em>Technometrics</em>, 61, 297-308, arXiv:1712.08929, DOI:10.1080/00401706.2018.1552203.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mined">mined</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cand &lt;- matrix(runif(10000, min = -4, max = 4), ncol = 1)
candlf &lt;- log(dnorm(cand))
res &lt;- mined::SelectMinED(cand, as.vector(candlf), 150, 1.0, 2.0)
print(res)
par(mfrow=c(1,2))
hist(cand)
hist(res$points)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
