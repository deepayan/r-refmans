<!DOCTYPE html><html><head><title>Help for package gips</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gips}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC.gips'><p>Akaike's An Information Criterion for <code>gips</code> class</p></a></li>
<li><a href='#as.character.gips'><p>Transform the <code>gips</code> object to a character vector</p></a></li>
<li><a href='#as.character.gips_perm'><p>Transform the <code>gips_perm</code> object to a character vector</p></a></li>
<li><a href='#calculate_gamma_function'><p>Calculate Gamma function</p></a></li>
<li><a href='#compare_posteriories_of_perms'><p>Compare the posteriori probabilities of 2 permutations</p></a></li>
<li><a href='#find_MAP'><p>Find the Maximum A Posteriori Estimation</p></a></li>
<li><a href='#forget_perms'><p>Forget the permutations for <code>gips</code> object optimized with <code>save_all_perms = TRUE</code></p></a></li>
<li><a href='#get_probabilities_from_gips'><p>Extract probabilities for <code>gips</code> object optimized with <code>return_probabilities = TRUE</code></p></a></li>
<li><a href='#get_structure_constants'><p>Get Structure Constants</p></a></li>
<li><a href='#gips'><p>The constructor of a <code>gips</code> class.</p></a></li>
<li><a href='#gips_perm'><p>Permutation object</p></a></li>
<li><a href='#log_posteriori_of_gips'><p>A log of a posteriori that the covariance matrix is invariant under permutation</p></a></li>
<li><a href='#logLik.gips'><p>Extract the Log-Likelihood for <code>gips</code> class</p></a></li>
<li><a href='#plot.gips'><p>Plot optimized matrix or optimization <code>gips</code> object</p></a></li>
<li><a href='#prepare_orthogonal_matrix'><p>Prepare orthogonal matrix</p></a></li>
<li><a href='#print.gips'><p>Printing <code>gips</code> object</p></a></li>
<li><a href='#print.gips_perm'><p>Printing <code>gips_perm</code> object</p></a></li>
<li><a href='#project_matrix'><p>Project matrix after optimization</p></a></li>
<li><a href='#summary.gips'><p>Summarizing the gips object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Model Invariant by Permutation Symmetry</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Find the permutation symmetry group such that the covariance
    matrix of the given data is approximately invariant under it.
    Discovering such a permutation decreases the number of observations
    needed to fit a Gaussian model, which is of great use when it is
    smaller than the number of variables. Even if that is not the case,
    the covariance matrix found with 'gips' approximates the actual
    covariance with less statistical error. The methods implemented in
    this package are described in Graczyk et al. (2022)
    &lt;<a href="https://doi.org/10.1214%2F22-AOS2174">doi:10.1214/22-AOS2174</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/PrzeChoj/gips">https://github.com/PrzeChoj/gips</a>, <a href="https://przechoj.github.io/gips/">https://przechoj.github.io/gips/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PrzeChoj/gips/issues">https://github.com/PrzeChoj/gips/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>numbers, permutations, rlang (&ge; 0.4.10), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DAAG, dplyr, ggplot2, graphics, hash, HSAUR2, knitr, MASS (&ge;
7.3-39), mvtnorm, rmarkdown, spelling, stringi, testthat (&ge;
3.0.0), tibble, tidyr, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-11 22:50:55 UTC; adam</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Przemysław Chojecki [aut, cre],
  Paweł Morgen [aut],
  Bartosz Kołodziejek
    <a href="https://orcid.org/0000-0002-5220-9012"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Przemysław Chojecki &lt;adam.prze.choj@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-12 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC.gips'>Akaike's An Information Criterion for <code>gips</code> class</h2><span id='topic+AIC.gips'></span><span id='topic+BIC.gips'></span>

<h3>Description</h3>

<p>Akaike's An Information Criterion for <code>gips</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gips'
AIC(object, ..., k = 2)

## S3 method for class 'gips'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.gips_+3A_object">object</code></td>
<td>
<p>An object of class <code>gips</code>. Usually, a result of a <code><a href="#topic+find_MAP">find_MAP()</a></code>.</p>
</td></tr>
<tr><td><code id="AIC.gips_+3A_...">...</code></td>
<td>
<p>Further arguments will be ignored.</p>
</td></tr>
<tr><td><code id="AIC.gips_+3A_k">k</code></td>
<td>
<p>Numeric, the <em>penalty</em> per parameter to be used.
The default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>AIC.gips()</code> returns calculated Akaike's An Information Criterion
</p>
<p>When the multivariate normal model does not exist
(<code>number_of_observations &lt; n0</code>), it returns <code>NULL</code>.
When the multivariate normal model cannot be reasonably approximated
(output of <code><a href="#topic+project_matrix">project_matrix()</a></code> is singular), it returns <code>Inf</code>.
</p>
<p>In both failure situations, shows a warning.
More information can be found in the <strong>Existence of likelihood</strong>
section of <code><a href="#topic+logLik.gips">logLik.gips()</a></code>.
</p>
<p><code>BIC.gips()</code> returns calculated
Schwarz's Bayesian Information Criterion.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>BIC(gips)</code>: Schwarz's Bayesian Information Criterion
</p>
</li></ul>


<h3>Calculation details</h3>

<p>For more details and used formulas, see
the <strong>Information Criterion - AIC and BIC</strong> section in
<code>vignette("Theory", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+AIC">AIC()</a></code>, <code><a href="stats.html#topic+BIC">BIC()</a></code> - Generic functions
this <code>AIC.gips()</code> and <code>BIC.gips()</code> extend.
</p>
</li>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - Usually, the <code>AIC.gips()</code> and <code>BIC.gips()</code>
are called on the output of <code>find_MAP()</code>.
</p>
</li>
<li> <p><code><a href="#topic+logLik.gips">logLik.gips()</a></code> - Calculates the log-likelihood for
the <code>gips</code> object. An important part of the Information Criteria.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- matrix(c(
  5.15, 2.05, 3.10, 1.99,
  2.05, 5.09, 2.03, 3.07,
  3.10, 2.03, 5.21, 1.97,
  1.99, 3.07, 1.97, 5.13
), nrow = 4)
g &lt;- gips(S, 14)
g_map &lt;- find_MAP(g, optimizer = "brute_force")

AIC(g) # 238
AIC(g_map) # 224 &lt; 238, so g_map is better than g in AIC
# ================================================================================
BIC(g) # 244
BIC(g_map) # 226 &lt; 244, so g_map is better than g in BIC
</code></pre>

<hr>
<h2 id='as.character.gips'>Transform the <code>gips</code> object to a character vector</h2><span id='topic+as.character.gips'></span>

<h3>Description</h3>

<p>Implementation of the S3 method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gips'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.gips_+3A_x">x</code></td>
<td>
<p>An object of a <code>gips</code> class.</p>
</td></tr>
<tr><td><code id="as.character.gips_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of a <code>character</code> type.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+as.character.gips_perm">as.character.gips_perm()</a></code> - The underlying <code>gips_perm</code> of
the <code>gips</code> object is passed to <code><a href="#topic+as.character.gips_perm">as.character.gips_perm()</a></code>.
</p>
</li>
<li> <p><code><a href="permutations.html#topic+print">permutations::as.character.cycle()</a></code> - The underlying permutation of
the <code>gips</code> object is passed to <code><a href="permutations.html#topic+print">permutations::as.character.cycle()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rnorm(4 * 4), nrow = 4)
S &lt;- t(A) %*% A
g &lt;- gips(S, 14, perm = "(123)")
as.character(g)
</code></pre>

<hr>
<h2 id='as.character.gips_perm'>Transform the <code>gips_perm</code> object to a character vector</h2><span id='topic+as.character.gips_perm'></span>

<h3>Description</h3>

<p>Implementation of the S3 method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gips_perm'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.gips_perm_+3A_x">x</code></td>
<td>
<p>An object of a <code>gips_perm</code> class.</p>
</td></tr>
<tr><td><code id="as.character.gips_perm_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of a <code>character</code> type.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+as.character.gips">as.character.gips()</a></code> - The underlying <code>gips_perm</code> of
the <code>gips</code> object is passed to <code><a href="#topic+as.character.gips_perm">as.character.gips_perm()</a></code>.
</p>
</li>
<li> <p><code><a href="permutations.html#topic+print">permutations::as.character.cycle()</a></code> - The underlying permutation of
the <code>gips</code> object is passed to <code><a href="permutations.html#topic+print">permutations::as.character.cycle()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>g_perm &lt;- gips_perm("(5,4)", 5)
as.character(g_perm)
</code></pre>

<hr>
<h2 id='calculate_gamma_function'>Calculate Gamma function</h2><span id='topic+calculate_gamma_function'></span>

<h3>Description</h3>

<p>It calculates the value of the integral defined in
<a href="https://arxiv.org/abs/2004.03503">Definition 11 from references</a>.
It implements
<a href="https://arxiv.org/abs/2004.03503">Theorem 8 from references</a>
and uses the
<a href="https://arxiv.org/abs/2004.03503">formula (19) from references</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_gamma_function(perm, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_gamma_function_+3A_perm">perm</code></td>
<td>
<p>An object of a <code>gips_perm</code> class.
It can also be of a <code>gips</code> class, but
it will be interpreted as the underlying <code>gips_perm</code>.</p>
</td></tr>
<tr><td><code id="calculate_gamma_function_+3A_lambda">lambda</code></td>
<td>
<p>A positive real number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the Gamma function of the colored cone
(for definition of colored cone, see the <strong>Basic definitions</strong> section
in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>).
</p>


<h3>References</h3>

<p>Piotr Graczyk, Hideyuki Ishi, Bartosz Kołodziejek, Hélène Massam.
&quot;Model selection in the space of Gaussian models invariant by symmetry.&quot;
The Annals of Statistics, 50(3) 1747-1774 June 2022.
<a href="https://arxiv.org/abs/2004.03503">arXiv link</a>;
<a href="https://doi.org/10.1214/22-AOS2174">doi:10.1214/22-AOS2174</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_structure_constants">get_structure_constants()</a></code> - The function useful inside
the <code>calculate_gamma_function()</code>.
</p>
</li>
<li> <p><code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code> - The function that uses
the values of the gamma function.
</p>
</li>
<li> <p><code>vignette("Theory", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a> -
A place to learn more about
the math behind the <code>gips</code> package.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>id_perm &lt;- gips_perm("()", 2)
calculate_gamma_function(id_perm, 0.5001) # 10.7...
calculate_gamma_function(id_perm, 0.50000001) # 19.9...
calculate_gamma_function(id_perm, 0.500000000001) # 29.1...

oldw &lt;- getOption("warn")
options(warn = -1)
calculate_gamma_function(id_perm, 0.5) # Inf
# Integral diverges; returns Inf and warning
options(warn = oldw)

</code></pre>

<hr>
<h2 id='compare_posteriories_of_perms'>Compare the posteriori probabilities of 2 permutations</h2><span id='topic+compare_posteriories_of_perms'></span><span id='topic+compare_log_posteriories_of_perms'></span>

<h3>Description</h3>

<p>Check which permutation is more likely and how much more likely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_posteriories_of_perms(
  perm1,
  perm2 = "()",
  S = NULL,
  number_of_observations = NULL,
  delta = 3,
  D_matrix = NULL,
  was_mean_estimated = TRUE,
  print_output = TRUE,
  digits = 3
)

compare_log_posteriories_of_perms(
  perm1,
  perm2 = "()",
  S = NULL,
  number_of_observations = NULL,
  delta = 3,
  D_matrix = NULL,
  was_mean_estimated = TRUE,
  print_output = TRUE,
  digits = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_posteriories_of_perms_+3A_perm1">perm1</code>, <code id="compare_posteriories_of_perms_+3A_perm2">perm2</code></td>
<td>
<p>Permutations to compare.
How many times <code>perm1</code> is more likely than <code>perm2</code>?
Those can be provided as the <code>gips</code> objects,
the <code>gips_perm</code> objects, or anything that can be used as
the <code>x</code> parameter in the <code><a href="#topic+gips_perm">gips_perm()</a></code> function.
They do not have to be of the same class.</p>
</td></tr>
<tr><td><code id="compare_posteriories_of_perms_+3A_s">S</code>, <code id="compare_posteriories_of_perms_+3A_number_of_observations">number_of_observations</code>, <code id="compare_posteriories_of_perms_+3A_delta">delta</code>, <code id="compare_posteriories_of_perms_+3A_d_matrix">D_matrix</code>, <code id="compare_posteriories_of_perms_+3A_was_mean_estimated">was_mean_estimated</code></td>
<td>
<p>The same parameters as in the <code><a href="#topic+gips">gips()</a></code> function.
If at least one of <code>perm1</code> or <code>perm2</code> is a <code>gips</code> object,
they are overwritten with those from the <code>gips</code> object.</p>
</td></tr>
<tr><td><code id="compare_posteriories_of_perms_+3A_print_output">print_output</code></td>
<td>
<p>A boolean.
When <code>TRUE</code> (default), the computed value will be printed with
additional text and returned invisibly. When <code>FALSE</code>,
the computed value will be returned visibly.</p>
</td></tr>
<tr><td><code id="compare_posteriories_of_perms_+3A_digits">digits</code></td>
<td>
<p>Integer. Only used when <code>print_output = TRUE</code>.
The number of digits after the comma to print.
It can be negative, can be <code>+Inf</code>. It is passed to <code>base::round()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>compare_posteriories_of_perms()</code> returns
the value of how many times the <code>perm1</code> is more likely than <code>perm2</code>.
</p>
<p>The function <code>compare_log_posteriories_of_perms()</code> returns
the logarithm of how many times the <code>perm1</code> is more likely than <code>perm2</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>compare_log_posteriories_of_perms()</code>: More stable,
logarithmic version of <code>compare_posteriories_of_perms()</code>.
The natural logarithm is used.
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+print.gips">print.gips()</a></code> - The function that prints the posterior of
the optimized <code>gips</code> object compared to the starting permutation.
</p>
</li>
<li> <p><code><a href="#topic+summary.gips">summary.gips()</a></code> - The function that calculates the posterior of
the optimized <code>gips</code> object compared to the starting permutation.
</p>
</li>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - The function that finds the permutation that
maximizes <code>log_posteriori_of_gips()</code>.
</p>
</li>
<li> <p><code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code> - The function this
<code>compare_posteriories_of_perms()</code> calls underneath.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>require("MASS") # for mvrnorm()

perm_size &lt;- 6
mu &lt;- runif(6, -10, 10) # Assume we don't know the mean
sigma_matrix &lt;- matrix(
  data = c(
    1.05, 0.8, 0.6, 0.4, 0.6, 0.8,
    0.8, 1.05, 0.8, 0.6, 0.4, 0.6,
    0.6, 0.8, 1.05, 0.8, 0.6, 0.4,
    0.4, 0.6, 0.8, 1.05, 0.8, 0.6,
    0.6, 0.4, 0.6, 0.8, 1.05, 0.8,
    0.8, 0.6, 0.4, 0.6, 0.8, 1.05
  ),
  nrow = perm_size, byrow = TRUE
) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6)
number_of_observations &lt;- 13
Z &lt;- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S &lt;- cov(Z) # Assume we have to estimate the mean

g &lt;- gips(S, number_of_observations)
g_map &lt;- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = "Metropolis_Hastings")

compare_posteriories_of_perms(g_map, g, print_output = TRUE)
exp(compare_log_posteriories_of_perms(g_map, g, print_output = FALSE))
</code></pre>

<hr>
<h2 id='find_MAP'>Find the Maximum A Posteriori Estimation</h2><span id='topic+find_MAP'></span>

<h3>Description</h3>

<p>Use one of the optimization algorithms to find the permutation that
maximizes a posteriori probability based on observed data.
Not all optimization algorithms will always find the MAP, but they try
to find a significant value. More information can be found in
the &quot;<strong>Possible algorithms to use as optimizers</strong>&quot; section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_MAP(
  g,
  max_iter = NA,
  optimizer = NA,
  show_progress_bar = TRUE,
  save_all_perms = FALSE,
  return_probabilities = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_MAP_+3A_g">g</code></td>
<td>
<p>Object of a <code>gips</code> class.</p>
</td></tr>
<tr><td><code id="find_MAP_+3A_max_iter">max_iter</code></td>
<td>
<p>The number of iterations for an algorithm to perform.
At least 2. For <code>optimizer = "BF"</code>, it is not used;
for <code>optimizer = "MH"</code>, it has to be finite;
for <code>optimizer = "HC"</code>, it can be infinite.</p>
</td></tr>
<tr><td><code id="find_MAP_+3A_optimizer">optimizer</code></td>
<td>
<p>The optimizer for the search of the maximum posteriori:
</p>

<ul>
<li> <p><code>"BF"</code> (the default for unoptimized <code>g</code> with <code style="white-space: pre;">&#8288;perm size &lt;= 9&#8288;</code>) - Brute Force;
</p>
</li>
<li> <p><code>"MH"</code> (the default for unoptimized <code>g</code> with <code style="white-space: pre;">&#8288;perm size &gt; 10&#8288;</code>) - Metropolis-Hastings;
</p>
</li>
<li> <p><code>"HC"</code> - Hill Climbing;
</p>
</li>
<li> <p><code>"continue"</code> (the default for optimized <code>g</code>) - The same as
the <code>g</code> was optimized by (see Examples).
</p>
</li></ul>

<p>See the <strong>Possible algorithms to use as optimizers</strong>
section below for more details.</p>
</td></tr>
<tr><td><code id="find_MAP_+3A_show_progress_bar">show_progress_bar</code></td>
<td>
<p>A boolean.
Indicate whether or not to show the progress bar:
</p>

<ul>
<li><p> When <code>max_iter</code> is infinite, <code>show_progress_bar</code> has to be <code>FALSE</code>;
</p>
</li>
<li><p> When <code>return_probabilities = TRUE</code>, then
shows an additional progress bar for the time
when the probabilities are calculated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="find_MAP_+3A_save_all_perms">save_all_perms</code></td>
<td>
<p>A boolean. <code>TRUE</code> indicates saving
a list of all permutations visited during optimization.
This can be useful sometimes but need a lot more RAM.</p>
</td></tr>
<tr><td><code id="find_MAP_+3A_return_probabilities">return_probabilities</code></td>
<td>
<p>A boolean. <code>TRUE</code> can only be provided
only when <code>save_all_perms = TRUE</code>. For:
</p>

<ul>
<li> <p><code>optimizer = "MH"</code> - use Metropolis-Hastings results to
estimate posterior probabilities;
</p>
</li>
<li> <p><code>optimizer = "BF"</code> - use brute force results to
calculate exact posterior probabilities.
</p>
</li></ul>

<p>These additional calculations are costly, so a second and third
progress bar is shown (when <code>show_progress_bar = TRUE</code>).
</p>
<p>To examine probabilities after optimization,
call <code><a href="#topic+get_probabilities_from_gips">get_probabilities_from_gips()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>find_MAP</code> can produce a warning when:
</p>

<ul>
<li><p> the optimizer &quot;hill_climbing&quot; gets to the end of
its <code>max_iter</code> without converging.
</p>
</li>
<li><p> the optimizer will find the permutation with smaller <code>n0</code> than
<code>number_of_observations</code> (for more information on what it means,
see <strong><code class="reqn">C_\sigma</code> and <code>n0</code></strong> section
in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>).
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an optimized object of a <code>gips</code> class.
</p>


<h3>Possible algorithms to use as optimizers</h3>

<p>For a in-depth explanation, see in
<code>vignette("Optimizers", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Optimizers.html">pkgdown page</a>.
</p>
<p>For every algorithm, there are some aliases available.
</p>

<ul>
<li> <p><code>"brute_force"</code>, <code>"BF"</code>, <code>"full"</code> - use
the <strong>Brute Force</strong> algorithm that checks the whole permutation
space of a given size. This algorithm will find
the actual Maximum A Posteriori Estimation, but it is
very computationally expensive for bigger spaces.
We recommend Brute Force only for <code>p &lt;= 9</code>.
For the time the Brute Force takes on our machines, see in
<code>vignette("Optimizers", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Optimizers.html">pkgdown page</a>.
</p>
</li>
<li> <p><code>"Metropolis_Hastings"</code>, <code>"MH"</code> - use
the <strong>Metropolis-Hastings</strong> algorithm;
<a href="https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm">see Wikipedia</a>.
The algorithm will draw a random transposition in every iteration
and consider changing the current state (permutation).
When the <code>max_iter</code> is reached, the algorithm will return the best
permutation calculated as the MAP Estimator. This implements
the <a href="https://arxiv.org/abs/2004.03503"><em>Second approach</em> from references, section 4.1.2</a>.
This algorithm used in this context is a special case of the
<strong>Simulated Annealing</strong> the user may be more familiar with;
<a href="https://en.wikipedia.org/wiki/Simulated_annealing">see Wikipedia</a>.
</p>
</li>
<li> <p><code>"hill_climbing"</code>, <code>"HC"</code> - use
the <strong>hill climbing</strong> algorithm;
<a href="https://en.wikipedia.org/wiki/Hill_climbing">see Wikipedia</a>.
The algorithm will check all transpositions in every iteration and
go to the one with the biggest a posteriori value.
The optimization ends when all <em>neighbors</em> will have a smaller
a posteriori value. If the <code>max_iter</code> is reached before the end,
then the warning is shown, and it is recommended to continue
the optimization on the output of the <code>find_MAP()</code> with
<code>optimizer = "continue"</code>; see examples.
Remember that <code>p*(p-1)/2</code> transpositions will be checked
in every iteration. For bigger <code>p</code>, this may be costly.
</p>
</li></ul>



<h3>References</h3>

<p>Piotr Graczyk, Hideyuki Ishi, Bartosz Kołodziejek, Hélène Massam.
&quot;Model selection in the space of Gaussian models invariant by symmetry.&quot;
The Annals of Statistics, 50(3) 1747-1774 June 2022.
<a href="https://arxiv.org/abs/2004.03503">arXiv link</a>;
<a href="https://doi.org/10.1214/22-AOS2174">doi:10.1214/22-AOS2174</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+gips">gips()</a></code> - The constructor of a <code>gips</code> class.
The <code>gips</code> object is used as the <code>g</code> parameter of <code>find_MAP()</code>.
</p>
</li>
<li> <p><code><a href="#topic+plot.gips">plot.gips()</a></code> - Practical plotting function for
visualizing the optimization process.
</p>
</li>
<li> <p><code><a href="#topic+summary.gips">summary.gips()</a></code> - Summarize the output of optimization.
</p>
</li>
<li> <p><code><a href="#topic+AIC.gips">AIC.gips()</a></code>, <code><a href="#topic+BIC.gips">BIC.gips()</a></code> - Get the Information Criterion
of the found model.
</p>
</li>
<li> <p><code><a href="#topic+get_probabilities_from_gips">get_probabilities_from_gips()</a></code> - When
<code>find_MAP(return_probabilities = TRUE)</code> was called,
probabilities can be extracted with this function.
</p>
</li>
<li> <p><code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code> - The function that the optimizers
of <code>find_MAP()</code> tries to find the argmax of.
</p>
</li>
<li> <p><code><a href="#topic+forget_perms">forget_perms()</a></code> - When the <code>gips</code> object was optimized
with <code>find_MAP(save_all_perms = TRUE)</code>, it will be of
considerable size in RAM. <code>forget_perms()</code> can make such an object
lighter in memory by forgetting the permutations it considered.
</p>
</li>
<li> <p><code>vignette("Optimizers", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Optimizers.html">pkgdown page</a> -
A place to learn more about
the available optimizers.
</p>
</li>
<li> <p><code>vignette("Theory", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a> -
A place to learn more about
the math behind the <code>gips</code> package.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>require("MASS") # for mvrnorm()

perm_size &lt;- 5
mu &lt;- runif(perm_size, -10, 10) # Assume we don't know the mean
sigma_matrix &lt;- matrix(
  data = c(
    1.0, 0.8, 0.6, 0.6, 0.8,
    0.8, 1.0, 0.8, 0.6, 0.6,
    0.6, 0.8, 1.0, 0.8, 0.6,
    0.6, 0.6, 0.8, 1.0, 0.8,
    0.8, 0.6, 0.6, 0.8, 1.0
  ),
  nrow = perm_size, byrow = TRUE
) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5)
number_of_observations &lt;- 13
Z &lt;- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S &lt;- cov(Z) # Assume we have to estimate the mean

g &lt;- gips(S, number_of_observations)

g_map &lt;- find_MAP(g, max_iter = 5, show_progress_bar = FALSE, optimizer = "Metropolis_Hastings")
g_map

g_map2 &lt;- find_MAP(g_map, max_iter = 5, show_progress_bar = FALSE, optimizer = "continue")

if (require("graphics")) {
  plot(g_map2, type = "both", logarithmic_x = TRUE)
}

g_map_BF &lt;- find_MAP(g, show_progress_bar = FALSE, optimizer = "brute_force")
summary(g_map_BF)
</code></pre>

<hr>
<h2 id='forget_perms'>Forget the permutations for <code>gips</code> object optimized with <code>save_all_perms = TRUE</code></h2><span id='topic+forget_perms'></span>

<h3>Description</h3>

<p>Slim the <code>gips</code> object by forgetting the visited permutations from <code>find_MAP(save_all_perms = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forget_perms(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forget_perms_+3A_g">g</code></td>
<td>
<p>An object of class <code>gips</code>.
A result of a <code>find_MAP(save_all_perms = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, <code>perm_size = 150</code> and <code>max_iter = 150000</code> we checked <code>forget_perms()</code> saves ~350 MB of RAM.
</p>


<h3>Value</h3>

<p>Returns the same object <code>g</code> as given,
but without the visited permutation list.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - The <code>forget_perms()</code> is called on
the output of <code>find_MAP(save_all_perms = TRUE)</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rnorm(10 * 10), nrow = 10)
S &lt;- t(A) %*% A
g &lt;- gips(S, 13, was_mean_estimated = FALSE)
g_map &lt;- find_MAP(g,
  max_iter = 10, optimizer = "Metropolis_Hastings",
  show_progress_bar = FALSE, save_all_perms = TRUE
)

object.size(g_map) # ~18 KB
g_map_slim &lt;- forget_perms(g_map)
object.size(g_map_slim) # ~8 KB
</code></pre>

<hr>
<h2 id='get_probabilities_from_gips'>Extract probabilities for <code>gips</code> object optimized with <code>return_probabilities = TRUE</code></h2><span id='topic+get_probabilities_from_gips'></span>

<h3>Description</h3>

<p>After the <code>gips</code> object was optimized with
the <code>find_MAP(return_probabilities = TRUE)</code> function, then
those calculated probabilities can be extracted with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_probabilities_from_gips(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_probabilities_from_gips_+3A_g">g</code></td>
<td>
<p>An object of class <code>gips</code>.
A result of a <code>find_MAP(return_probabilities = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector, calculated values of probabilities.
Names contain permutations this probabilities represent.
For <code>gips</code> object optimized with <code>find_MAP(return_probabilities = FALSE)</code>,
it returns a <code>NULL</code> object.
It is sorted according to the probability.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - The <code>get_probabilities_from_gips()</code>
is called on the output of
<code>find_MAP(return_probabilities = TRUE, save_all_perms = TRUE)</code>.
</p>
</li>
<li> <p><code>vignette("Optimizers", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Optimizers.html">pkgdown page</a>) -
A place to learn more about the available optimizers.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- gips(matrix(c(1, 0.5, 0.5, 1.3), nrow = 2), 13, was_mean_estimated = FALSE)
g_map &lt;- find_MAP(g,
  optimizer = "BF", show_progress_bar = FALSE,
  return_probabilities = TRUE, save_all_perms = TRUE
)

get_probabilities_from_gips(g_map)
</code></pre>

<hr>
<h2 id='get_structure_constants'>Get Structure Constants</h2><span id='topic+get_structure_constants'></span>

<h3>Description</h3>

<p>Finds constants necessary for internal calculations of integrals and
eventually the posteriori probability in <code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_structure_constants(perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_structure_constants_+3A_perm">perm</code></td>
<td>
<p>An object of a <code>gips_perm</code> class.
It can also be of a <code>gips</code> class, but
it will be interpreted as the underlying <code>gips_perm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <a href="https://arxiv.org/abs/2004.03503">Theorem 5 from references</a>
to calculate the constants.
</p>


<h3>Value</h3>

<p>Returns a list of 5 items:
<code>r</code>, <code>d</code>, <code>k</code>, <code>L</code>, <code>dim_omega</code> - vectors of constants from
<a href="https://arxiv.org/abs/2004.03503">Theorem 1 from references</a>
and the beginning of
<a href="https://arxiv.org/abs/2004.03503">section 3.1. from references</a>.
</p>


<h3>References</h3>

<p>Piotr Graczyk, Hideyuki Ishi, Bartosz Kołodziejek, Hélène Massam.
&quot;Model selection in the space of Gaussian models invariant by symmetry.&quot;
The Annals of Statistics, 50(3) 1747-1774 June 2022.
<a href="https://arxiv.org/abs/2004.03503">arXiv link</a>;
<a href="https://doi.org/10.1214/22-AOS2174">doi:10.1214/22-AOS2174</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+calculate_gamma_function">calculate_gamma_function()</a></code>, <code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code> - The functions
that rely heavily on <code>get_structure_constants()</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>perm &lt;- gips_perm("(1)(2)(3)(4,5)", 5)
get_structure_constants(perm)
</code></pre>

<hr>
<h2 id='gips'>The constructor of a <code>gips</code> class.</h2><span id='topic+gips'></span><span id='topic+new_gips'></span><span id='topic+validate_gips'></span>

<h3>Description</h3>

<p>Create a <code>gips</code> object.
This object will contain initial data and all other information
needed to find the most likely invariant permutation.
It will not perform optimization. One must call
the <code><a href="#topic+find_MAP">find_MAP()</a></code> function to do it. See the examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gips(
  S,
  number_of_observations,
  delta = 3,
  D_matrix = NULL,
  was_mean_estimated = TRUE,
  perm = ""
)

new_gips(
  list_of_gips_perm,
  S,
  number_of_observations,
  delta,
  D_matrix,
  was_mean_estimated,
  optimization_info
)

validate_gips(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gips_+3A_s">S</code></td>
<td>
<p>A matrix; empirical covariance matrix.
When <code>Z</code> is the observed data:
</p>

<ul>
<li><p> if one does not know the theoretical mean and has to
estimate it with the observed mean, use <code>S = cov(Z)</code>,
and leave parameter <code>was_mean_estimated = TRUE</code> as default;
</p>
</li>
<li><p> if one know the theoretical mean is 0, use
<code>S = (t(Z) %*% Z) / number_of_observations</code>, and set
parameter <code>was_mean_estimated = FALSE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gips_+3A_number_of_observations">number_of_observations</code></td>
<td>
<p>A number of data points
that <code>S</code> is based on.</p>
</td></tr>
<tr><td><code id="gips_+3A_delta">delta</code></td>
<td>
<p>A number, hyper-parameter of a Bayesian model.
It has to be strictly bigger than 1.
See the <strong>Hyperparameters</strong> section below.</p>
</td></tr>
<tr><td><code id="gips_+3A_d_matrix">D_matrix</code></td>
<td>
<p>Symmetric, positive-definite matrix of the same size as <code>S</code>.
Hyper-parameter of a Bayesian model.
When <code>NULL</code>, the (hopefully) reasonable one is derived from the data.
For more details, see the <strong>Hyperparameters</strong> section below.</p>
</td></tr>
<tr><td><code id="gips_+3A_was_mean_estimated">was_mean_estimated</code></td>
<td>
<p>A boolean.
</p>

<ul>
<li><p> Set <code>TRUE</code> (default) when your <code>S</code> parameter is a result of
a <code><a href="stats.html#topic+cor">stats::cov()</a></code> function.
</p>
</li>
<li><p> Set FALSE when your <code>S</code> parameter is a result of
a <code>(t(Z) %*% Z) / number_of_observations</code> calculation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gips_+3A_perm">perm</code></td>
<td>
<p>An optional permutation to be the base for the <code>gips</code> object.
It can be of a <code>gips_perm</code> or a <code>permutation</code> class, or anything
the function <code><a href="permutations.html#topic+permutation">permutations::permutation()</a></code> can handle.
It can also be of a <code>gips</code> class, but
it will be interpreted as the underlying <code>gips_perm</code>.</p>
</td></tr>
<tr><td><code id="gips_+3A_list_of_gips_perm">list_of_gips_perm</code></td>
<td>
<p>A list with a single element of
a <code>gips_perm</code> class. The base object for the <code>gips</code> object.</p>
</td></tr>
<tr><td><code id="gips_+3A_optimization_info">optimization_info</code></td>
<td>
<p>For internal use only. <code>NULL</code> or the list with
information about the optimization process.</p>
</td></tr>
<tr><td><code id="gips_+3A_g">g</code></td>
<td>
<p>Object to be checked whether it is a proper object of a <code>gips</code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gips()</code> returns an object of
a <code>gips</code> class after the safety checks.
</p>
<p><code>new_gips()</code> returns an object of
a <code>gips</code> class without the safety checks.
</p>
<p><code>validate_gips()</code> returns its argument unchanged.
If the argument is not a proper element of a <code>gips</code> class,
it produces an error.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>new_gips()</code>: Constructor. It is only intended for low-level use.
</p>
</li>
<li> <p><code>validate_gips()</code>: Validator. It is only intended for low-level use.
</p>
</li></ul>


<h3>Methods for a <code>gips</code> class</h3>


<ul>
<li> <p><code><a href="#topic+summary.gips">summary.gips()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.gips">plot.gips()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.gips">print.gips()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+logLik.gips">logLik.gips()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+AIC.gips">AIC.gips()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+BIC.gips">BIC.gips()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+as.character.gips">as.character.gips()</a></code>
</p>
</li></ul>



<h3>Hyperparameters</h3>

<p>We encourage the user to try <code>D_matrix = d * I</code>, where <code>I</code> is an identity matrix of a size
<code style="white-space: pre;">&#8288;p x p&#8288;</code> and <code>d &gt; 0</code> for some different <code>d</code>.
When <code>d</code> is small compared to the data (e.g., <code>d=0.1 * mean(diag(S))</code>),
bigger structures will be found.
When <code>d</code> is big compared to the data (e.g., <code>d=100 * mean(diag(S))</code>),
the posterior distribution does not depend on the data.
</p>
<p>Taking <code>D_matrix = d * I</code> is equivalent to setting <code>S &lt;- S / d</code>.
</p>
<p>The default for <code>D_matrix</code> is <code>D_matrix = d * I</code>, where
<code>d = mean(diag(S))</code>, which is equivalent to modifying <code>S</code>
so that the mean value on the diagonal is 1.
</p>
<p>In the Bayesian model, the prior distribution for
the covariance matrix is a generalized case of
<a href="https://en.wikipedia.org/wiki/Wishart_distribution">Wishart distribution</a>.
</p>
<p>For a brief introduction, see the <strong>Bayesian model selection</strong>
section in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>).
</p>
<p>For analysis of the Hyperparameters influence, see <strong>Section 3.2.</strong>
of &quot;Learning permutation symmetries with gips in R&quot;
by <code>gips</code> developers Adam Chojecki, Paweł Morgen, and Bartosz Kołodziejek,
available on <a href="https://arxiv.org/abs/2307.00790">arXiv:2307.00790</a>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+cor">stats::cov()</a></code> - The <code>S</code> parameter, as an empirical covariance matrix,
is most of the time a result of the <code>cov()</code> function.
For more information, see
<a href="https://en.wikipedia.org/wiki/Estimation_of_covariance_matrices">Wikipedia - Estimation of covariance matrices</a>.
</p>
</li>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - The function that finds
the Maximum A Posteriori (MAP) Estimator
for a given <code>gips</code> object.
</p>
</li>
<li> <p><code><a href="#topic+gips_perm">gips_perm()</a></code> - The constructor of a <code>gips_perm</code> class.
The <code>gips_perm</code> object is used as the base object for
the <code>gips</code> object. To be more precise, the base object
for <code>gips</code> is a one-element list of a <code>gips_perm</code> object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>require("MASS") # for mvrnorm()

perm_size &lt;- 5
mu &lt;- runif(5, -10, 10) # Assume we don't know the mean
sigma_matrix &lt;- matrix(
  data = c(
    1.0, 0.8, 0.6, 0.6, 0.8,
    0.8, 1.0, 0.8, 0.6, 0.6,
    0.6, 0.8, 1.0, 0.8, 0.6,
    0.6, 0.6, 0.8, 1.0, 0.8,
    0.8, 0.6, 0.6, 0.8, 1.0
  ),
  nrow = perm_size, byrow = TRUE
) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5)
number_of_observations &lt;- 13
Z &lt;- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S &lt;- cov(Z) # Assume we have to estimate the mean

g &lt;- gips(S, number_of_observations)

g_map &lt;- find_MAP(g, show_progress_bar = FALSE, optimizer = "brute_force")
g_map

summary(g_map)

if (require("graphics")) {
  plot(g_map, type = "both", logarithmic_x = TRUE)
}
</code></pre>

<hr>
<h2 id='gips_perm'>Permutation object</h2><span id='topic+gips_perm'></span><span id='topic+new_gips_perm'></span><span id='topic+validate_gips_perm'></span>

<h3>Description</h3>

<p>Create permutation objects to be passed to
other functions of the <code>gips</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gips_perm(x, size)

new_gips_perm(rearranged_cycles, size)

validate_gips_perm(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gips_perm_+3A_x">x</code></td>
<td>
<p>A single object that can be interpreted by
the <code><a href="permutations.html#topic+permutation">permutations::permutation()</a></code> function.
For example, the character of a form <code>"(1,2)(4,5)"</code>. See examples.
It can also be of a <code>gips</code> class but
it will be interpreted as the underlying <code>gips_perm</code>.</p>
</td></tr>
<tr><td><code id="gips_perm_+3A_size">size</code></td>
<td>
<p>An integer. Size of a permutation
(AKA cardinality of a set, on which permutation is defined. See examples).</p>
</td></tr>
<tr><td><code id="gips_perm_+3A_rearranged_cycles">rearranged_cycles</code></td>
<td>
<p>A list of rearranged integer vectors.
Each vector corresponds to a single cycle of a permutation.</p>
</td></tr>
<tr><td><code id="gips_perm_+3A_g">g</code></td>
<td>
<p>Object to be checked whether it is
a proper object of a <code>gips_perm</code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gips_perm()</code> returns an object of
a <code>gips_perm</code> class after the safety checks.
</p>
<p><code>new_gips_perm()</code> returns an object of
a <code>gips_perm</code> class without the safety checks.
</p>
<p><code>validate_gips_perm()</code> returns its argument unchanged.
If the argument is not a proper element of a <code>gips_perm</code> class,
it produces an error.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>new_gips_perm()</code>: Constructor. Only intended for low-level use.
</p>
</li>
<li> <p><code>validate_gips_perm()</code>: Validator. Only intended for low-level use.
</p>
</li></ul>


<h3>Methods for a <code>gips</code> class</h3>


<ul>
<li> <p><code><a href="#topic+as.character.gips_perm">as.character.gips_perm()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.gips_perm">print.gips_perm()</a></code>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+project_matrix">project_matrix()</a></code> - <code>gips_perm</code> is the <code>perm</code> parameter of <code>project_matrix()</code>.
</p>
</li>
<li> <p><code><a href="permutations.html#topic+permutation">permutations::permutation()</a></code> - The constructor for the <code>x</code> parameter.
</p>
</li>
<li> <p><code><a href="#topic+gips">gips()</a></code> - The constructor for the <code>gips</code> class uses
the <code>gips_perm</code> object as the base object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># All 7 following lines give the same output:
gperm &lt;- gips_perm("(12)(45)", 5)
gperm &lt;- gips_perm("(1,2)(4,5)", 5)
gperm &lt;- gips_perm(as.matrix(c(2, 1, 3, 5, 4)), 5)
gperm &lt;- gips_perm(t(as.matrix(c(2, 1, 3, 5, 4))), 5) # both way for a matrix works
gperm &lt;- gips_perm(list(list(c(2, 1), c(4, 5))), 5)
gperm &lt;- gips_perm(permutations::as.word(c(2, 1, 3, 5, 4)), 5)
gperm &lt;- gips_perm(permutations::as.cycle("(1,2)(4,5)"), 5)
gperm

# note the necessity of the `size` parameter:
gperm &lt;- gips_perm("(12)(45)", 5)
gperm &lt;- gips_perm("(12)(45)", 7) # this one is a different permutation

try(gperm &lt;- gips_perm("(12)(45)", 4))
# Error, `size` was set to 4, while the permutation has the element 5.

</code></pre>

<hr>
<h2 id='log_posteriori_of_gips'>A log of a posteriori that the covariance matrix is invariant under permutation</h2><span id='topic+log_posteriori_of_gips'></span>

<h3>Description</h3>

<p>More precisely, it is the logarithm of an unnormalized
posterior probability. It is the goal function for
optimization algorithms in the <code>find_MAP()</code> function.
The <code>perm_proposal</code> that maximizes this function is
the Maximum A Posteriori (MAP) Estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_posteriori_of_gips(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_posteriori_of_gips_+3A_g">g</code></td>
<td>
<p>An object of a <code>gips</code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is calculated using
<a href="https://arxiv.org/abs/2004.03503">formulas (33) and (27) from references</a>.
</p>
<p>If <code>Inf</code> or <code>NaN</code> is reached, it produces a warning.
</p>


<h3>Value</h3>

<p>Returns a value of
the logarithm of an unnormalized A Posteriori.
</p>


<h3>References</h3>

<p>Piotr Graczyk, Hideyuki Ishi, Bartosz Kołodziejek, Hélène Massam.
&quot;Model selection in the space of Gaussian models invariant by symmetry.&quot;
The Annals of Statistics, 50(3) 1747-1774 June 2022.
<a href="https://arxiv.org/abs/2004.03503">arXiv link</a>;
<a href="https://doi.org/10.1214/22-AOS2174">doi:10.1214/22-AOS2174</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+calculate_gamma_function">calculate_gamma_function()</a></code> - The function that calculates
the value needed for <code>log_posteriori_of_gips()</code>.
</p>
</li>
<li> <p><code><a href="#topic+get_structure_constants">get_structure_constants()</a></code> - The function that calculates
the structure constants needed for <code>log_posteriori_of_gips()</code>.
</p>
</li>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - The function that optimizes
the <code>log_posteriori_of_gips</code> function.
</p>
</li>
<li> <p><code><a href="#topic+compare_posteriories_of_perms">compare_posteriories_of_perms()</a></code> - Uses <code>log_posteriori_of_gips()</code>
to compare a posteriori of two permutations.
</p>
</li>
<li> <p><code>vignette("Theory", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a> -
A place to learn more about the math behind the <code>gips</code> package.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># In the space with p = 2, there is only 2 permutations:
perm1 &lt;- permutations::as.cycle("(1)(2)")
perm2 &lt;- permutations::as.cycle("(1,2)")
S1 &lt;- matrix(c(1, 0.5, 0.5, 2), nrow = 2, byrow = TRUE)
g1 &lt;- gips(S1, 100, perm = perm1)
g2 &lt;- gips(S1, 100, perm = perm2)
log_posteriori_of_gips(g1) # -134.1615, this is the MAP Estimator
log_posteriori_of_gips(g2) # -138.1695

exp(log_posteriori_of_gips(g1) - log_posteriori_of_gips(g2)) # 55.0
# g1 is 55 times more likely than g2.
# This is the expected outcome because S[1,1] significantly differs from S[2,2].

compare_posteriories_of_perms(g1, g2)
# The same result, but presented in a more pleasant way

# ========================================================================

S2 &lt;- matrix(c(1, 0.5, 0.5, 1.1), nrow = 2, byrow = TRUE)
g1 &lt;- gips(S2, 100, perm = perm1)
g2 &lt;- gips(S2, 100, perm = perm2)
log_posteriori_of_gips(g1) # -98.40984
log_posteriori_of_gips(g2) # -95.92039, this is the MAP Estimator

exp(log_posteriori_of_gips(g2) - log_posteriori_of_gips(g1)) # 12.05
# g2 is 12 times more likely than g1.
# This is the expected outcome because S[1,1] is very close to S[2,2].

compare_posteriories_of_perms(g2, g1)
# The same result, but presented in a more pleasant way
</code></pre>

<hr>
<h2 id='logLik.gips'>Extract the Log-Likelihood for <code>gips</code> class</h2><span id='topic+logLik.gips'></span>

<h3>Description</h3>

<p>Calculates Log-Likelihood of the sample based on the <code>gips</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gips'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.gips_+3A_object">object</code></td>
<td>
<p>An object of class <code>gips</code>. Usually, a result of a <code><a href="#topic+find_MAP">find_MAP()</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.gips_+3A_...">...</code></td>
<td>
<p>Further arguments will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will always be the biggest for <code>perm = "()"</code> (provided that <code>p &lt;= n</code>).
</p>
<p>If the found permutation still requires more parameters than <code>n</code>,
the likelihood does not exist; thus the function returns <code>NULL</code>.
</p>
<p>If the <code>projected_cov</code> (output of <code><a href="#topic+project_matrix">project_matrix()</a></code>)
is close to singular, the <code>NA</code> is returned.
</p>


<h3>Value</h3>

<p>Log-Likelihood of the sample.
</p>
<p>When the multivariate normal model does not exist
(<code>number_of_observations &lt; n0</code>), it returns <code>NULL</code>.
When the multivariate normal model cannot be reasonably approximated
(output of <code><a href="#topic+project_matrix">project_matrix()</a></code> is singular), it returns <code>-Inf</code>.
</p>
<p>In both failure situations, it shows a warning.
More information can be found in the <strong>Existence of likelihood</strong> section below.
</p>


<h3>Existence of likelihood</h3>

<p>We only consider the non-degenerate multivariate normal model.
In the <code>gips</code> context, such a model exists only when
the number of observations is bigger or equal to <code>n0</code>. To get <code>n0</code>
for the <code>gips</code> object <code>g</code>, call <code>summary(g)$n0</code>.
</p>
<p>For more information, refer to <strong><code class="reqn">C_\sigma</code> and <code>n0</code></strong> section in
<code>vignette("Theory", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>.
</p>


<h3>Calculation details</h3>

<p>For more details and used formulas, see
the <strong>Information Criterion - AIC and BIC</strong> section in
<code>vignette("Theory", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+logLik">logLik()</a></code> - Generic function this <code><a href="#topic+logLik.gips">logLik.gips()</a></code> extends.
</p>
</li>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - Usually, the <code>logLik.gips()</code>
is called on the output of <code>find_MAP()</code>.
</p>
</li>
<li> <p><code><a href="#topic+AIC.gips">AIC.gips()</a></code>, <code><a href="#topic+BIC.gips">BIC.gips()</a></code> - Often, one is more
interested in an Information Criterion AIC or BIC.
</p>
</li>
<li> <p><code><a href="#topic+summary.gips">summary.gips()</a></code> - One can get <code>n0</code> by calling <code>summary(g)$n0</code>.
To see why one may be interested in <code>n0</code>,
see the <strong>Existence of likelihood</strong> section above.
</p>
</li>
<li> <p><code><a href="#topic+project_matrix">project_matrix()</a></code> - Project the known matrix
onto the found permutations space.
It is mentioned in the <strong>Calculation details</strong> section above.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- matrix(c(
  5.15, 2.05, 3.60, 1.99,
  2.05, 5.09, 2.03, 3.57,
  3.60, 2.03, 5.21, 1.97,
  1.99, 3.57, 1.97, 5.13
), nrow = 4)
g &lt;- gips(S, 5)
logLik(g) # -32.67048
# For perm = "()", which is default, there is p + choose(p, 2) degrees of freedom

g_map &lt;- find_MAP(g, optimizer = "brute_force")
logLik(g_map) # -32.6722 # this will always be smaller than `logLik(gips(S, n, perm = ""))`

g_n_too_small &lt;- gips(S, 4)
logLik(g_n_too_small) # NULL # the likelihood does not exists
</code></pre>

<hr>
<h2 id='plot.gips'>Plot optimized matrix or optimization <code>gips</code> object</h2><span id='topic+plot.gips'></span>

<h3>Description</h3>

<p>Plot the heatmap of the MAP covariance matrix estimator
or the convergence of the optimization method.
The plot depends on the <code>type</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gips'
plot(
  x,
  type = NA,
  logarithmic_y = TRUE,
  logarithmic_x = FALSE,
  color = NULL,
  title_text = "Convergence plot",
  xlabel = NULL,
  ylabel = NULL,
  show_legend = TRUE,
  ylim = NULL,
  xlim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gips_+3A_x">x</code></td>
<td>
<p>Object of a <code>gips</code> class.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_type">type</code></td>
<td>
<p>A character vector of length 1. One of
<code>c("heatmap", "MLE", "best", "all", "both", "block_heatmap")</code>:
</p>

<ul>
<li> <p><code>"heatmap"</code>, <code>"MLE"</code> - Plots a heatmap of the Maximum Likelihood
Estimator of the covariance matrix given the permutation.
That is, the <code>S</code> matrix inside the <code>gips</code> object
projected on the permutation in the <code>gips</code> object.
</p>
</li>
<li> <p><code>"best"</code> - Plots the line of the biggest a posteriori found over time.
</p>
</li>
<li> <p><code>"all"</code> - Plots the line of a posteriori for all visited states.
</p>
</li>
<li> <p><code>"both"</code> - Plots both lines from &quot;all&quot; and &quot;best&quot;.
</p>
</li>
<li> <p><code>"block_heatmap"</code> - Plots a heatmap of diagonally block representation of <code>S</code>.
Non-block entries (equal to 0) are white for better clarity.
For more information, see <strong>Block Decomposition - [1], Theorem 1</strong>
section in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>.
</p>
</li></ul>

<p>The default value is <code>NA</code>, which will be changed to &quot;heatmap&quot; for
non-optimized <code>gips</code> objects and to &quot;both&quot; for optimized ones.
Using the default produces a warning.
All other arguments are ignored for
the <code>type = "heatmap"</code>, <code>type = "MLE"</code>, or <code>type = "block_heatmap"</code>.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_logarithmic_y">logarithmic_y</code>, <code id="plot.gips_+3A_logarithmic_x">logarithmic_x</code></td>
<td>
<p>A boolean.
Sets the axis of the plot in logarithmic scale.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_color">color</code></td>
<td>
<p>Vector of colors to be used to plot lines.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_title_text">title_text</code></td>
<td>
<p>Text to be in the title of the plot.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_xlabel">xlabel</code></td>
<td>
<p>Text to be on the bottom of the plot.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_ylabel">ylabel</code></td>
<td>
<p>Text to be on the left of the plot.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_show_legend">show_legend</code></td>
<td>
<p>A boolean. Whether or not to show a legend.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_ylim">ylim</code></td>
<td>
<p>Limits of the y axis. When <code>NULL</code>,
the minimum, and maximum of the <code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code> are taken.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_xlim">xlim</code></td>
<td>
<p>Limits of the x axis. When <code>NULL</code>,
the whole optimization process is shown.</p>
</td></tr>
<tr><td><code id="plot.gips_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
other various elements of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>type</code> is one of <code>"best"</code>, <code>"all"</code> or <code>"both"</code>,
returns an invisible <code>NULL</code>.
When <code>type</code> is one of <code>"heatmap"</code>, <code>"MLE"</code> or <code>"block_heatmap"</code>,
returns an object of class <code>ggplot</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - Usually, the <code>plot.gips()</code>
is called on the output of <code>find_MAP()</code>.
</p>
</li>
<li> <p><code><a href="#topic+project_matrix">project_matrix()</a></code> - The function used with <code>type = "MLE"</code>.
</p>
</li>
<li> <p><code><a href="#topic+gips">gips()</a></code> - The constructor of a <code>gips</code> class.
The <code>gips</code> object is used as the <code>x</code> parameter.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>require("MASS") # for mvrnorm()

perm_size &lt;- 6
mu &lt;- runif(6, -10, 10) # Assume we don't know the mean
sigma_matrix &lt;- matrix(
  data = c(
    1.0, 0.8, 0.6, 0.4, 0.6, 0.8,
    0.8, 1.0, 0.8, 0.6, 0.4, 0.6,
    0.6, 0.8, 1.0, 0.8, 0.6, 0.4,
    0.4, 0.6, 0.8, 1.0, 0.8, 0.6,
    0.6, 0.4, 0.6, 0.8, 1.0, 0.8,
    0.8, 0.6, 0.4, 0.6, 0.8, 1.0
  ),
  nrow = perm_size, byrow = TRUE
) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6)
number_of_observations &lt;- 13
Z &lt;- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S &lt;- cov(Z) # Assume we have to estimate the mean

g &lt;- gips(S, number_of_observations)
if (require("graphics")) {
  plot(g, type = "MLE")
}

g_map &lt;- find_MAP(g, max_iter = 30, show_progress_bar = FALSE, optimizer = "hill_climbing")
if (require("graphics")) {
  plot(g_map, type = "both", logarithmic_x = TRUE)
}

if (require("graphics")) {
  plot(g_map, type = "MLE")
}
# Now, the output is (most likely) different because the permutation
  # `g_map[[1]]` is (most likely) not an identity permutation.
</code></pre>

<hr>
<h2 id='prepare_orthogonal_matrix'>Prepare orthogonal matrix</h2><span id='topic+prepare_orthogonal_matrix'></span>

<h3>Description</h3>

<p>Calculate the orthogonal matrix <code>U_Gamma</code> for decomposition in
<a href="https://arxiv.org/abs/2004.03503">Theorem 1 from references</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_orthogonal_matrix(perm, perm_size = NULL, basis = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_orthogonal_matrix_+3A_perm">perm</code></td>
<td>
<p>An object of a <code>gips_perm</code> or anything
a <code>gips_perm()</code> can handle. It can also be of a <code>gips</code> class,
but it will be interpreted as the underlying <code>gips_perm</code>.</p>
</td></tr>
<tr><td><code id="prepare_orthogonal_matrix_+3A_perm_size">perm_size</code></td>
<td>
<p>Size of a permutation.
Required if <code>perm</code> is neither <code>gips_perm</code> nor <code>gips</code>.</p>
</td></tr>
<tr><td><code id="prepare_orthogonal_matrix_+3A_basis">basis</code></td>
<td>
<p>A matrix with basis vectors in COLUMNS. Identity by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given X - a matrix invariant under the permutation <code>perm</code>. Call Gamma
the permutations cyclic group: <code class="reqn">\Gamma = &lt;perm&gt; = \{perm, perm^2, ...\}</code>.
</p>
<p>Then, <code class="reqn">U_\Gamma</code> is such an orthogonal matrix, which block-diagonalizes X.
</p>
<p>To be more precise, the matrix <code>t(U_Gamma) %*% X %*% U_Gamma</code> has a
block-diagonal structure, which is ensured by
<a href="https://arxiv.org/abs/2004.03503">Theorem 1 from references</a>.
</p>
<p>The formula for <code>U_Gamma</code> can be found in
<a href="https://arxiv.org/abs/2004.03503">Theorem 6 from references</a>.
</p>
<p>A nice example is demonstrated in the <strong>Block Decomposition - [1], Theorem 1</strong>
section of <code>vignette("Theory", package="gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>.
</p>


<h3>Value</h3>

<p>A square matrix of size <code>perm_size</code> by <code>perm_size</code> with
columns from vector elements <code class="reqn">v_k^{(c)}</code> according to
<a href="https://arxiv.org/abs/2004.03503">Theorem 6 from references</a>.
</p>


<h3>References</h3>

<p>Piotr Graczyk, Hideyuki Ishi, Bartosz Kołodziejek, Hélène Massam.
&quot;Model selection in the space of Gaussian models invariant by symmetry.&quot;
The Annals of Statistics, 50(3) 1747-1774 June 2022.
<a href="https://arxiv.org/abs/2004.03503">arXiv link</a>;
<a href="https://doi.org/10.1214/22-AOS2174">doi:10.1214/22-AOS2174</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+project_matrix">project_matrix()</a></code> - A function used in examples
to show the properties of <code>prepare_orthogonal_matrix()</code>.
</p>
</li>
<li> <p><strong>Block Decomposition - [1], Theorem 1</strong> section of
<code>vignette("Theory", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a> -
A place to learn more about the math behind the <code>gips</code> package
and see more examples of <code>prepare_orthogonal_matrix()</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>gperm &lt;- gips_perm("(1,2,3)(4,5)", 5)
U_Gamma &lt;- prepare_orthogonal_matrix(gperm)

number_of_observations &lt;- 10
X &lt;- matrix(rnorm(5 * number_of_observations), number_of_observations, 5)
S &lt;- cov(X)
X &lt;- project_matrix(S, perm = gperm) # this matrix in invariant under gperm

block_decomposition &lt;- t(U_Gamma) %*% X %*% U_Gamma
round(block_decomposition, 5) # the non-zeros only on diagonal and [1,2] and [2,1]
</code></pre>

<hr>
<h2 id='print.gips'>Printing <code>gips</code> object</h2><span id='topic+print.gips'></span>

<h3>Description</h3>

<p>Printing function for a <code>gips</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gips'
print(
  x,
  digits = 3,
  compare_to_original = TRUE,
  log_value = FALSE,
  oneline = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gips_+3A_x">x</code></td>
<td>
<p>An object of a <code>gips</code> class.</p>
</td></tr>
<tr><td><code id="print.gips_+3A_digits">digits</code></td>
<td>
<p>The number of digits after the comma
for a posteriori to be presented. It can be negative.
By default, <code>Inf</code>. It is passed to <code><a href="base.html#topic+Round">base::round()</a></code>.</p>
</td></tr>
<tr><td><code id="print.gips_+3A_compare_to_original">compare_to_original</code></td>
<td>
<p>A logical. Whether to print how many
times more likely is the current permutation compared to:
</p>

<ul>
<li><p> the identity permutation <code style="white-space: pre;">&#8288;()&#8288;</code> (for unoptimized <code>gips</code> object);
</p>
</li>
<li><p> the starting permutation (for optimized <code>gips</code> object).
</p>
</li></ul>
</td></tr>
<tr><td><code id="print.gips_+3A_log_value">log_value</code></td>
<td>
<p>A logical. Whether to print the logarithmic value.
Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="print.gips_+3A_oneline">oneline</code></td>
<td>
<p>A logical. Whether to print in
one or multiple lines. Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="print.gips_+3A_...">...</code></td>
<td>
<p>The additional arguments passed to <code><a href="base.html#topic+cat">base::cat()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an invisible <code>NULL</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - The function that makes
an optimized <code>gips</code> object out of the unoptimized one.
</p>
</li>
<li> <p><code><a href="#topic+compare_posteriories_of_perms">compare_posteriories_of_perms()</a></code> - The function that prints
the compared posteriories between any two permutations,
not only compared to the starting one or id.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- matrix(c(1, 0.5, 0.5, 2), nrow = 2, byrow = TRUE)
g &lt;- gips(S, 10, perm = "(12)")
print(g, digits = 4, oneline = TRUE)
</code></pre>

<hr>
<h2 id='print.gips_perm'>Printing <code>gips_perm</code> object</h2><span id='topic+print.gips_perm'></span>

<h3>Description</h3>

<p>Printing function for a <code>gips_perm</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gips_perm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gips_perm_+3A_x">x</code></td>
<td>
<p>An object of a <code>gips_perm</code> class.</p>
</td></tr>
<tr><td><code id="print.gips_perm_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an invisible <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gperm &lt;- gips_perm("(5,4)", 5)
print(gperm)
</code></pre>

<hr>
<h2 id='project_matrix'>Project matrix after optimization</h2><span id='topic+project_matrix'></span>

<h3>Description</h3>

<p>After the MAP permutation was found with <code><a href="#topic+find_MAP">find_MAP()</a></code>,
use this permutation to approximate the covariance matrix
with bigger statistical confidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_matrix(S, perm, precomputed_equal_indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_matrix_+3A_s">S</code></td>
<td>
<p>A square matrix to be projected.
The empirical covariance matrix.
(See the <code>S</code> parameter in the <code>gips()</code> function).
When it is not positive semi-definite,
it shows a warning of a class <code>not_positive_semi_definite_matrix</code>.</p>
</td></tr>
<tr><td><code id="project_matrix_+3A_perm">perm</code></td>
<td>
<p>A permutation to be projected on.
An object of a <code>gips</code> class,
a <code>gips_perm</code> class, or anything that can be used
as the <code>x</code> argument in the <code>gips_perm()</code> function.</p>
</td></tr>
<tr><td><code id="project_matrix_+3A_precomputed_equal_indices">precomputed_equal_indices</code></td>
<td>
<p>This parameter is for internal use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Project matrix on the space of symmetrical matrices invariant
by a cyclic group generated by <code>perm</code>.
This implements the formal
<a href="https://arxiv.org/abs/2004.03503">Definition 3 from references</a>.
</p>
<p>When <code>S</code> is the sample covariance matrix (output of <code>cov()</code> function, see
examples), then <code>S</code> is the <strong>unbiased estimator</strong> of the covariance matrix.
However, the <strong>maximum likelihood estimator</strong> of the covariance matrix is
<code>S*(n-1)/(n)</code>, unless n &lt; p, when the
<strong>maximum likelihood estimator does not exist</strong>. For more information, see
<a href="https://en.wikipedia.org/wiki/Estimation_of_covariance_matrices">Wikipedia - Estimation of covariance matrices</a>.
</p>
<p>The maximum likelihood estimator differs when one knows the covariance
matrix is <strong>invariant under some permutation</strong>. This estimator will
be symmetric AND have some values repeated (see examples and
<a href="https://arxiv.org/abs/2004.03503">Corollary 12 from references</a>).
</p>
<p>The estimator will be invariant under the given permutation. Also, it
will <strong>need fewer observations</strong> for the maximum likelihood estimator to
exist (see <strong>Project Matrix - Equation (6)</strong> section in
<code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>).
For some permutations, even <code class="reqn">n = 2</code> could be enough.
The minimal number of observations needed are named <code>n0</code> and
can be calculated by <code>summary.gips()</code>.
</p>
<p>For more details, see the <strong>Project Matrix - Equation (6)</strong>
section in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>.
</p>


<h3>Value</h3>

<p>Returns the matrix <code>S</code> projected on the space of symmetrical matrices invariant
by a cyclic group generated by <code>perm</code>. See Details for more.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="https://en.wikipedia.org/wiki/Estimation_of_covariance_matrices">Wikipedia - Estimation of covariance matrices</a>
</p>
</li>
<li> <p><strong>Project Matrix - Equation (6)</strong> section of
<code>vignette("Theory", package = "gips")</code> or its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a> -
A place to learn more about the math
behind the <code>gips</code> package and see
more examples of <code>project_matrix()</code>.
</p>
</li>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - The function that finds
the Maximum A Posteriori (MAP) Estimator
for a given <code>gips</code> object.
After the MAP Estimator is found, the matrix
<code>S</code> can be projected on this permutation,
creating the MAP Estimator of the covariance matrix
(see examples).
</p>
</li>
<li> <p><code><a href="#topic+gips_perm">gips_perm()</a></code> - Constructor for the <code>perm</code> parameter.
</p>
</li>
<li> <p><code><a href="#topic+plot.gips">plot.gips()</a></code> - For <code>plot(g, type = "MLE")</code>,
the <code>project_matrix()</code> is called (see examples).
</p>
</li>
<li> <p><code><a href="#topic+summary.gips">summary.gips()</a></code> - Can calculate the <code>n0</code>, the minimal
number of observations, so that the projected matrix
will be the MLE estimator of the covariance matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 6
my_perm &lt;- "(14)(23)" # permutation (1,4)(2,3)(5)(6)
number_of_observations &lt;- 10
X &lt;- matrix(rnorm(p * number_of_observations), number_of_observations, p)
S &lt;- cov(X)
projected_S &lt;- project_matrix(S, perm = my_perm)
projected_S
# The value in [1,1] is the same as in [4,4]; also, [2,2] and [3,3];
  # also [1,2] and [3,4]; also, [1,5] and [4,5]; and so on

# Plot the projected matrix:
g &lt;- gips(S, number_of_observations, perm = my_perm)
plot(g, type = "MLE")

# Find the MAP Estimator of covariance
g_MAP &lt;- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = "Metropolis_Hastings")
S_MAP &lt;- project_matrix(attr(g, "S"), perm = g_MAP)
S_MAP
plot(g_MAP, type = "heatmap")
</code></pre>

<hr>
<h2 id='summary.gips'>Summarizing the gips object</h2><span id='topic+summary.gips'></span><span id='topic+print.summary.gips'></span>

<h3>Description</h3>

<p><code>summary</code> method for <code>gips</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gips'
summary(object, ...)

## S3 method for class 'summary.gips'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gips_+3A_object">object</code></td>
<td>
<p>An object of class <code>gips</code>. Usually, a result of a <code><a href="#topic+find_MAP">find_MAP()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.gips_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.gips_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.gips</code> to be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.gips()</code> computes and returns a list of summary
statistics of the given <code>gips</code> object. Those are:
</p>

<ul>
<li><p> For unoptimized <code>gips</code> object:
</p>

<ol>
<li> <p><code>optimized</code> - <code>FALSE</code>.
</p>
</li>
<li> <p><code>start_permutation</code> - the permutation this <code>gips</code> represents.
</p>
</li>
<li> <p><code>start_permutation_log_posteriori</code> - the log of the a posteriori
value the start permutation has.
</p>
</li>
<li> <p><code>times_more_likely_than_id</code> - how many more likely
the <code>start_permutation</code> is over the identity permutation, <code style="white-space: pre;">&#8288;()&#8288;</code>.
It can be less than 1, meaning the identity permutation
is more likely. Remember that this number can big and
overflow to <code>Inf</code> or small and underflow to 0.
</p>
</li>
<li> <p><code>n0</code> - the minimum number of observations needed for
the covariance matrix's maximum likelihood estimator
(corresponding to a MAP) to exist. See <strong><code class="reqn">C\sigma</code> and <code>n0</code></strong>
section in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>.
</p>
</li>
<li> <p><code>S_matrix</code> - the underlying matrix.
This matrix will be used in calculations of
the posteriori value in <code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code>.
</p>
</li>
<li> <p><code>number_of_observations</code> - the number of observations that
were observed for the <code>S_matrix</code> to be calculated.
This value will be used in calculations of
the posteriori value in <code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code>.
</p>
</li>
<li> <p><code>was_mean_estimated</code> - given by the user while creating the <code>gips</code> object:
</p>

<ul>
<li> <p><code>TRUE</code> means the <code>S</code> parameter was the output of <code><a href="stats.html#topic+cor">stats::cov()</a></code> function;
</p>
</li>
<li> <p><code>FALSE</code> means the <code>S</code> parameter was calculated with
<code>S = t(X) %*% X / number_of_observations</code>.
</p>
</li></ul>

</li>
<li> <p><code>delta</code>, <code>D_matrix</code> - the hyperparameters of the Bayesian method.
See the <strong>Hyperparameters</strong> section of <code><a href="#topic+gips">gips()</a></code> documentation.
</p>
</li>
<li> <p><code>AIC</code>, <code>BIC</code> - output of <code><a href="#topic+AIC.gips">AIC.gips()</a></code> and <code><a href="#topic+BIC.gips">BIC.gips()</a></code> functions.
</p>
</li>
<li> <p><code>n_parameters</code> - number of free parameters in the covariance matrix.
</p>
</li></ol>

</li>
<li><p> For optimized <code>gips</code> object:
</p>

<ol>
<li> <p><code>optimized</code> - <code>TRUE</code>.
</p>
</li>
<li> <p><code>found_permutation</code> - the permutation this <code>gips</code> represents.
The visited permutation with the biggest a posteriori value.
</p>
</li>
<li> <p><code>found_permutation_log_posteriori</code> - the log of the a posteriori
value the found permutation has.
</p>
</li>
<li> <p><code>start_permutation</code> - the original permutation this <code>gips</code>
represented before optimization. It is the first visited permutation.
</p>
</li>
<li> <p><code>start_permutation_log_posteriori</code> - the log of the a posteriori
value the start permutation has.
</p>
</li>
<li> <p><code>times_more_likely_than_start</code> - how many more likely
the <code>found_permutation</code> is over the <code>start_permutation</code>.
It cannot be a number less than 1.
Remember that this number can big and overflow to <code>Inf</code>.
</p>
</li>
<li> <p><code>n0</code> - the minimal number of observations needed for the existence of
the maximum likelihood estimator (corresponding to a MAP) of
the covariance matrix (see <strong><code class="reqn">C\sigma</code> and <code>n0</code></strong>
section in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>).
</p>
</li>
<li> <p><code>S_matrix</code> - the underlying matrix.
This matrix will be used in calculations of
the posteriori value in <code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code>.
</p>
</li>
<li> <p><code>number_of_observations</code> - the number of observations that
were observed for the <code>S_matrix</code> to be calculated.
This value will be used in calculations of
the posteriori value in <code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code>.
</p>
</li>
<li> <p><code>was_mean_estimated</code> - given by the user while creating the <code>gips</code> object:
</p>

<ul>
<li> <p><code>TRUE</code> means the <code>S</code> parameter was output of the <code><a href="stats.html#topic+cor">stats::cov()</a></code> function;
</p>
</li>
<li> <p><code>FALSE</code> means the <code>S</code> parameter was calculated with
<code>S = t(X) %*% X / number_of_observations</code>.
</p>
</li></ul>

</li>
<li> <p><code>delta</code>, <code>D_matrix</code> - the hyperparameters of the Bayesian method.
See the <strong>Hyperparameters</strong> section of <code><a href="#topic+gips">gips()</a></code> documentation.
</p>
</li>
<li> <p><code>AIC</code>, <code>BIC</code> - output of <code><a href="#topic+AIC.gips">AIC.gips()</a></code> and <code><a href="#topic+BIC.gips">BIC.gips()</a></code> functions.
</p>
</li>
<li> <p><code>n_parameters</code> - number of free parameters in the covariance matrix.
</p>
</li>
<li> <p><code>optimization_algorithm_used</code> - all used optimization algorithms
in order (one could start optimization with &quot;MH&quot;, and then
do an &quot;HC&quot;).
</p>
</li>
<li> <p><code>did_converge</code> - a boolean, did the last used algorithm converge.
</p>
</li>
<li> <p><code>number_of_log_posteriori_calls</code> - how many times was
the <code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code> function called during
the optimization.
</p>
</li>
<li> <p><code>whole_optimization_time</code> - how long was the optimization process;
the sum of all optimization times (when there were multiple).
</p>
</li>
<li> <p><code>log_posteriori_calls_after_best</code> - how many times was
the <code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code> function called after
the <code>found_permutation</code>; in other words, how long ago
could the optimization be stopped and have the same result.
If this value is small, consider running <code><a href="#topic+find_MAP">find_MAP()</a></code>
again with <code>optimizer = "continue"</code>.
For <code>optimizer = "BF"</code>, it is <code>NULL</code>.
</p>
</li>
<li> <p><code>acceptance_rate</code> - only interesting for <code>optimizer = "MH"</code>.
How often was the algorithm accepting the change of permutation
in an iteration.
</p>
</li></ol>

</li></ul>

<p>The function <code>print.summary.gips()</code> returns an invisible <code>NULL</code>.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(summary.gips)</code>: Printing method for class <code>summary.gips</code>.
Prints every interesting information in a form pleasant for humans.
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+find_MAP">find_MAP()</a></code> - Usually, the <code>summary.gips()</code>
is called on the output of <code>find_MAP()</code>.
</p>
</li>
<li> <p><code><a href="#topic+log_posteriori_of_gips">log_posteriori_of_gips()</a></code> - Calculate
the likelihood of a permutation.
</p>
</li>
<li> <p><code><a href="#topic+AIC.gips">AIC.gips()</a></code>, <code><a href="#topic+BIC.gips">BIC.gips()</a></code> - Calculate
Akaike's or Bayesian Information Criterion
</p>
</li>
<li> <p><code><a href="#topic+project_matrix">project_matrix()</a></code> - Project the known
matrix on the found permutations space.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>require("MASS") # for mvrnorm()

perm_size &lt;- 6
mu &lt;- runif(6, -10, 10) # Assume we don't know the mean
sigma_matrix &lt;- matrix(
  data = c(
    1.0, 0.8, 0.6, 0.4, 0.6, 0.8,
    0.8, 1.0, 0.8, 0.6, 0.4, 0.6,
    0.6, 0.8, 1.0, 0.8, 0.6, 0.4,
    0.4, 0.6, 0.8, 1.0, 0.8, 0.6,
    0.6, 0.4, 0.6, 0.8, 1.0, 0.8,
    0.8, 0.6, 0.4, 0.6, 0.8, 1.0
  ),
  nrow = perm_size, byrow = TRUE
) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6)
number_of_observations &lt;- 13
Z &lt;- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S &lt;- cov(Z) # Assume we have to estimate the mean

g &lt;- gips(S, number_of_observations)

g_map &lt;- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = "Metropolis_Hastings")
unclass(summary(g_map))

g_map2 &lt;- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = "hill_climbing")
summary(g_map2)
# ================================================================================
S &lt;- matrix(c(1, 0.5, 0.5, 2), nrow = 2, byrow = TRUE)
g &lt;- gips(S, 10)
print(summary(g))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
