<!DOCTYPE html><html lang="en"><head><title>Help for package EpiEstim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EpiEstim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_cdt_samples_convergence'><p>Checking convergence of an MCMC chain by using the Gelman-Rubin algorithm</p></a></li>
<li><a href='#coarse2estim'><p>Link coarseDataTools and EpiEstim</p></a></li>
<li><a href='#discr_si'><p>Discretized Generation Time Distribution Assuming A Shifted Gamma</p>
Distribution</a></li>
<li><a href='#DiscrSI'><p>Function to ensure compatibility with EpiEstim versions &lt;2.0</p></a></li>
<li><a href='#estimate_R'><p>Estimated Instantaneous Reproduction Number</p>
</p>
<p><code>estimate_R</code> estimates the reproduction number of an epidemic, given the</p>
incidence time series and the serial interval distribution.</a></li>
<li><a href='#estimate_R_plots'><p>Wrapper for plot.estimate_R</p></a></li>
<li><a href='#EstimateR'><p>Function to ensure compatibility with EpiEstim versions &lt;2.0</p></a></li>
<li><a href='#flu_2009_NYC_school'><p>Data on the 2009 H1N1 influenza pandemic in a school in New York city</p></a></li>
<li><a href='#Flu1918'><p>Data on the 1918 H1N1 influenza pandemic in Baltimore.</p></a></li>
<li><a href='#Flu2009'><p>Data on the 2009 H1N1 influenza pandemic in a school in Pennsylvania.</p></a></li>
<li><a href='#init_mcmc_params'><p>init_mcmc_params Finds clever starting points for the MCMC to be used to</p>
estimate the serial interval, e.g. when using option <code>si_from_data</code> in
<code>estimate_R</code></a></li>
<li><a href='#make_config'><p>Set and check parameter settings of estimate_R</p></a></li>
<li><a href='#make_mcmc_control'><p>make_mcmc_control Creates a list of mcmc control parameters to be used in</p>
<code>config$mcmc_control</code>, where <code>config</code> is an argument of the
<code>estimate_R</code> function. This is used to configure the MCMC chain used to
estimate the serial interval within <code>estimate_R</code> (with method
&quot;si_from_data&quot;).</a></li>
<li><a href='#Measles1861'><p>Data on the 1861 measles epidemic in Hagelloch, Germany.</p></a></li>
<li><a href='#mers_2014_15'><p>Data on Middle East Respiratory Syndrome (MERS) in Saudi Arabia.</p></a></li>
<li><a href='#MockRotavirus'><p>Mock data on a rotavirus epidemic.</p></a></li>
<li><a href='#overall_infectivity'><p>Overall Infectivity Due To Previously Infected Individuals</p></a></li>
<li><a href='#OverallInfectivity'><p>Function to ensure compatibility with EpiEstim versions &lt;2.0</p></a></li>
<li><a href='#plot.estimate_R'><p>Plot outputs of estimate_r</p></a></li>
<li><a href='#sample_posterior_R'><p>sample from the posterior R distribution</p></a></li>
<li><a href='#SARS2003'><p>Data on the 2003 SARS epidemic in Hong Kong.</p></a></li>
<li><a href='#Smallpox1972'><p>Data on the 1972 smallpox epidemic in Kosovo</p></a></li>
<li><a href='#wallinga_teunis'><p>Estimation of the case reproduction number using the Wallinga and Teunis</p>
method</a></li>
<li><a href='#WT'><p>Function to ensure compatibility with EpiEstim versions &lt;2.0</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.2-4</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate Time Varying Reproduction Numbers from Epidemic Curves</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anne Cori &lt;a.cori@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to quantify transmissibility throughout
    an epidemic from the analysis of time series of incidence as described in
    Cori et al. (2013) &lt;<a href="https://doi.org/10.1093%2Faje%2Fkwt133">doi:10.1093/aje/kwt133</a>&gt; and Wallinga and Teunis (2004) 
    &lt;<a href="https://doi.org/10.1093%2Faje%2Fkwh255">doi:10.1093/aje/kwh255</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mrc-ide/EpiEstim">https://github.com/mrc-ide/EpiEstim</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mrc-ide/EpiEstim/issues">https://github.com/mrc-ide/EpiEstim/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coarseDataTools (&ge; 0.6-4), stats, graphics, reshape2,
ggplot2, gridExtra, fitdistrplus, coda, incidence (&ge; 1.7.0),
scales, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, utils, vdiffr, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-04 13:08:11 UTC; acori</td>
</tr>
<tr>
<td>Author:</td>
<td>Anne Cori <a href="https://orcid.org/0000-0002-8443-9162"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Simon Cauchemez [ctb],
  Neil M. Ferguson <a href="https://orcid.org/0000-0002-1154-8093"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Christophe Fraser <a href="https://orcid.org/0000-0003-2399-9657"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Elisabeth Dahlqwist
    <a href="https://orcid.org/0000-0001-5797-6803"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  P. Alex Demarsh [ctb],
  Thibaut Jombart <a href="https://orcid.org/0000-0003-2226-8692"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Justin Lessler <a href="https://orcid.org/0000-0002-9741-8109"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Shikun Li [ctb],
  Jonathan A. Polonsky
    <a href="https://orcid.org/0000-0002-8634-4255"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Jake Stockwin [ctb],
  Robin Thompson <a href="https://orcid.org/0000-0001-8545-5212"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Rolina van Gaalen [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-07 16:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_cdt_samples_convergence'>Checking convergence of an MCMC chain by using the Gelman-Rubin algorithm</h2><span id='topic+check_cdt_samples_convergence'></span>

<h3>Description</h3>

<p><code>check_cdt_samples_convergence</code> Checking convergence of an MCMC chain by
using the Gelman-Rubin algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cdt_samples_convergence(cdt_samples)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_cdt_samples_convergence_+3A_cdt_samples">cdt_samples</code></td>
<td>
<p>the <code>@sample</code> slot of a <code>cd.fit.mcmc</code> S4 object 
(see package <code>coarseDataTools</code>)</p>
</td></tr>
</table>


<h3>Details</h3>


<p>This function splits an MCMC chain in two halves and uses the Gelman-Rubin 
algorithm to assess convergence of the chain by comparing its two halves.

</p>


<h3>Value</h3>

<p>TRUE if the Gelman Rubin test for convergence was successful, FALSE 
otherwise
</p>


<h3>Author(s)</h3>

<p>Anne Cori
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_R">estimate_R</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Note the following examples use an MCMC routine
## to estimate the serial interval distribution from data,
## so they may take a few minutes to run

## load data on rotavirus
data("MockRotavirus")

## estimate the serial interval from data
SI_fit &lt;- coarseDataTools::dic.fit.mcmc(dat = MockRotavirus$si_data,
                     dist="G",
                     init_pars=init_mcmc_params(MockRotavirus$si_data, "G"),
                     burnin = 1000,
                     n.samples = 5000)

## use check_cdt_samples_convergence to check convergence
converg_diag &lt;- check_cdt_samples_convergence(SI_fit@samples)
converg_diag


## End(Not run)

</code></pre>

<hr>
<h2 id='coarse2estim'>Link coarseDataTools and EpiEstim</h2><span id='topic+coarse2estim'></span>

<h3>Description</h3>

<p><code>coarse2estim</code> Transforms outputs of
<code>coarseDataTools::dic.fit.mcmc</code> to right format for input into
<code>estimate_R</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coarse2estim(x = NULL, dist = x@dist, samples = x@samples, thin = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coarse2estim_+3A_x">x</code></td>
<td>
<p>An object generated by function
<code>coarseDataTools::dic.fit.mcmc</code>, containing posterior estimates of the
serial interval distribution.</p>
</td></tr>
<tr><td><code id="coarse2estim_+3A_dist">dist</code></td>
<td>
<p>The parametric distribution used when estimating the serial
interval.
#' Should be one of &quot;G&quot; (Gamma), &quot;W&quot; (Weibull), &quot;L&quot; (Lognormal), &quot;off1G&quot;
(Gamma shifted by 1), &quot;off1W&quot; (Weibull shifted by 1), or &quot;off1L&quot; (Lognormal
shifted by 1).  If not present, computed automatically from <code>x</code>.</p>
</td></tr>
<tr><td><code id="coarse2estim_+3A_samples">samples</code></td>
<td>
<p>A dataframe containing the posterior samples of serial
interval parameters corresponding to the parametric choice specified in
<code>dist</code>. If not present, computed automatically from <code>x</code>.</p>
</td></tr>
<tr><td><code id="coarse2estim_+3A_thin">thin</code></td>
<td>
<p>A positive integer corresponding to thinning parameter; of the
posterior sample of serial interval distributions in x, only 1 in <code>thin</code>
will be kept, the rest will be discarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li><p>si_sample: a matrix where each column gives one distribution of the
serial interval to be explored, obtained from x by thinning the MCMC chain.
</p>
</li>
<li><p>si_parametric_distr: the parametric distribution used when estimating
the serial interval stored in x. 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>The Hackout3 Parameter Estimation team.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_R">estimate_R</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Note the following examples use an MCMC routine
## to estimate the serial interval distribution from data,
## so they may take a few minutes to run

## load data on rotavirus
data("MockRotavirus")

## estimate the serial interval from data
SI.fit &lt;- coarseDataTools::dic.fit.mcmc(dat = MockRotavirus$si_data,
                     dist = "G",
                     init.pars = init_mcmc_params(MockRotavirus$si_data, "G"),
                     burnin = 1000,
                     n.samples = 5000)

## use coarse2estim to turn this in the right format for estimate_R
si_sample &lt;- coarse2estim(SI.fit, thin = 10)$si_sample

## use estimate_R to estimate the reproduction number
## based on these estimates of the serial interval
R_si_from_sample &lt;- estimate_R(MockRotavirus$incidence,
                            method="si_from_sample",
                            si_sample=si_sample,
                            config = make_config(list(n2 = 50)))
plot(R_si_from_sample)

## End(Not run)

</code></pre>

<hr>
<h2 id='discr_si'>Discretized Generation Time Distribution Assuming A Shifted Gamma 
Distribution</h2><span id='topic+discr_si'></span>

<h3>Description</h3>

<p><code>discr_si</code> computes the discrete distribution of the serial interval, 
assuming that the serial interval is shifted Gamma distributed, with shift 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr_si(k, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr_si_+3A_k">k</code></td>
<td>
<p>Positive integer, or vector of positive integers for which the 
discrete distribution is desired.</p>
</td></tr>
<tr><td><code id="discr_si_+3A_mu">mu</code></td>
<td>
<p>A positive real giving the mean of the Gamma distribution.</p>
</td></tr>
<tr><td><code id="discr_si_+3A_sigma">sigma</code></td>
<td>
<p>A non-negative real giving the standard deviation of the Gamma 
distribution.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Assuming that the serial interval is shifted Gamma distributed with mean 
<code class="reqn">\mu</code>, standard deviation <code class="reqn">\sigma</code> and shift <code class="reqn">1</code>,
the discrete probability <code class="reqn">w_k</code> that the serial interval is equal to 
<code class="reqn">k</code> is:
</p>
<p style="text-align: center;"><code class="reqn">w_k = kF_{\{\mu-1,\sigma\}}(k)+(k-2)F_{\{\mu-1,\sigma\}}
(k-2)-2(k-1)F_{\{\mu-1,\sigma\}}(k-1)\\
+(\mu-1)(2F_{\{\mu-1+\frac{\sigma^2}{\mu-1},
\sigma\sqrt{1+\frac{\sigma^2}{\mu-1}}\}}(k-1)-
F_{\{\mu-1+\frac{\sigma^2}{\mu-1},
\sigma\sqrt{1+\frac{\sigma^2}{\mu-1}}\}}(k-2)-
F_{\{\mu-1+\frac{\sigma^2}{\mu-1},
\sigma\sqrt{1+\frac{\sigma^2}{\mu-1}}\}}(k))</code>
</p>

<p>where <code class="reqn">F_{\{\mu,\sigma\}}</code> is the cumulative density function of a Gamma 
distribution with mean <code class="reqn">\mu</code> and standard deviation <code class="reqn">\sigma</code>.

</p>


<h3>Value</h3>

<p>Gives the discrete probability <code class="reqn">w_k</code> that the serial interval is 
equal to <code class="reqn">k</code>.
</p>


<h3>Author(s)</h3>

<p>Anne Cori <a href="mailto:a.cori@imperial.ac.uk">a.cori@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Cori, A. et al. A new framework and software to estimate 
time-varying reproduction numbers during epidemics (AJE 2013).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overall_infectivity">overall_infectivity</a></code>, <code><a href="#topic+estimate_R">estimate_R</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Computing the discrete serial interval of influenza
mean_flu_si &lt;- 2.6
sd_flu_si &lt;- 1.5
dicrete_si_distr &lt;- discr_si(seq(0, 20), mean_flu_si, sd_flu_si)
plot(seq(0, 20), dicrete_si_distr, type = "h",
          lwd = 10, lend = 1, xlab = "time (days)", ylab = "frequency")
title(main = "Discrete distribution of the serial interval of influenza")
</code></pre>

<hr>
<h2 id='DiscrSI'>Function to ensure compatibility with EpiEstim versions &lt;2.0</h2><span id='topic+DiscrSI'></span>

<h3>Description</h3>

<p>Please only use for compatibility;
Prefer the new discr_si function instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiscrSI(k, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DiscrSI_+3A_k">k</code></td>
<td>
<p>see <code>k</code> in <code>discr_si</code></p>
</td></tr>
<tr><td><code id="DiscrSI_+3A_mu">mu</code></td>
<td>
<p>see <code>mu</code> in <code>discr_si</code></p>
</td></tr>
<tr><td><code id="DiscrSI_+3A_sigma">sigma</code></td>
<td>
<p>see <code>sigma</code> in <code>discr_si</code></p>
</td></tr>
</table>

<hr>
<h2 id='estimate_R'>Estimated Instantaneous Reproduction Number
<code>estimate_R</code> estimates the reproduction number of an epidemic, given the
incidence time series and the serial interval distribution.</h2><span id='topic+estimate_R'></span>

<h3>Description</h3>

<p>Estimated Instantaneous Reproduction Number
</p>
<p><code>estimate_R</code> estimates the reproduction number of an epidemic, given the
incidence time series and the serial interval distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_R(
  incid,
  method = c("non_parametric_si", "parametric_si", "uncertain_si", "si_from_data",
    "si_from_sample"),
  si_data = NULL,
  si_sample = NULL,
  config = make_config(incid = incid, method = method)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_R_+3A_incid">incid</code></td>
<td>
<p>One of the following
</p>

<ul>
<li><p>A vector (or a dataframe with a single column) of non-negative integers
containing the incidence time series
</p>
</li>
<li><p>A dataframe of non-negative integers with either i) <code>incid$I</code>
containing the total incidence, or ii) two columns, so that
<code>incid$local</code> contains the incidence of cases due to local transmission
and <code>incid$imported</code> contains the incidence of imported cases (with
<code>incid$local + incid$imported</code> the total incidence). If the dataframe
contains a column <code>incid$dates</code>, this is used for plotting.
<code>incid$dates</code> must contains only dates in a row.
</p>
</li>
<li><p>An object of class <code><a href="incidence.html#topic+incidence">incidence</a></code>
</p>
</li></ul>

<p>Note that the cases from the first time step are always all assumed to be
imported cases.</p>
</td></tr>
<tr><td><code id="estimate_R_+3A_method">method</code></td>
<td>
<p>One of &quot;non_parametric_si&quot;, &quot;parametric_si&quot;, &quot;uncertain_si&quot;,
&quot;si_from_data&quot; or &quot;si_from_sample&quot; (see details).</p>
</td></tr>
<tr><td><code id="estimate_R_+3A_si_data">si_data</code></td>
<td>
<p>For method &quot;si_from_data&quot; ; the data on dates of symptoms of
pairs of infector/infected individuals to be used to estimate the serial
interval distribution (see details).</p>
</td></tr>
<tr><td><code id="estimate_R_+3A_si_sample">si_sample</code></td>
<td>
<p>For method &quot;si_from_sample&quot; ; a matrix where each column
gives one distribution of the serial interval to be explored (see details).</p>
</td></tr>
<tr><td><code id="estimate_R_+3A_config">config</code></td>
<td>
<p>An object of class <code>estimate_R_config</code>, as returned by 
function <code>make_config</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Analytical estimates of the reproduction number for an epidemic over
predefined time windows can be obtained within a Bayesian framework,
for a given discrete distribution of the serial interval (see references).
</p>
<p>Several methods are available to specify the serial interval distribution.
</p>
<p>In short there are five methods to specify the serial interval distribution
(see help for function <code>make_config</code> for more detail on each method).
In the first two methods, a unique serial interval distribution is
considered, whereas in the last three, a range of serial interval
distributions are integrated over:
</p>

<ul>
<li><p>In method &quot;non_parametric_si&quot; the user specifies the discrete
distribution of the serial interval
</p>
</li>
<li><p>In method &quot;parametric_si&quot; the user specifies the mean and sd of the
serial interval
</p>
</li>
<li><p>In method &quot;uncertain_si&quot; the mean and sd of the serial interval are
each drawn from truncated normal distributions, with parameters specified by
the user
</p>
</li>
<li><p>In method &quot;si_from_data&quot;, the serial interval distribution is directly
estimated, using MCMC, from interval censored exposure data, with data
provided by the user together with a choice of parametric distribution for
the serial interval
</p>
</li>
<li><p>In method &quot;si_from_sample&quot;, the user directly provides the sample of
serial interval distribution to use for estimation of R. This can be a useful
alternative to the previous method, where the MCMC estimation of the serial
interval distribution could be run once, and the same estimated SI
distribution then used in estimate_R in different contexts, e.g. with
different time windows, hence avoiding to rerun the MCMC every time
estimate_R is called.
</p>
</li></ul>



<h3>Value</h3>


<p>an object of class <code>estimate_R</code>, with components:
</p>

<ul>
<li><p>R: a dataframe containing:
the times of start and end of each time window considered ;
the posterior mean, std, and 0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975
quantiles of the reproduction number for each time window.
</p>
</li>
<li><p>method: the method used to estimate R, one of &quot;non_parametric_si&quot;,
&quot;parametric_si&quot;, &quot;uncertain_si&quot;, &quot;si_from_data&quot; or &quot;si_from_sample&quot;
</p>
</li>
<li><p>si_distr: a vector or dataframe (depending on the method) containing
the discrete serial interval distribution(s) used for estimation
</p>
</li>
<li><p>SI.Moments: a vector or dataframe (depending on the method)
containing the mean and std of the discrete serial interval distribution(s)
used for estimation
</p>
</li>
<li><p>I: the time series of total incidence
</p>
</li>
<li><p>I_local: the time series of incidence of local cases (so that
<code>I_local + I_imported = I</code>)
</p>
</li>
<li><p>I_imported: the time series of incidence of imported cases (so that
<code>I_local + I_imported = I</code>)
</p>
</li>
<li><p>dates: a vector of dates corresponding to the incidence time series
</p>
</li>
<li><p>MCMC_converged (only for method <code>si_from_data</code>): a boolean
showing whether the Gelman-Rubin MCMC convergence diagnostic was successful
(<code>TRUE</code>) or not (<code>FALSE</code>)
</p>
</li></ul>




<h3>Author(s)</h3>

<p>Anne Cori <a href="mailto:a.cori@imperial.ac.uk">a.cori@imperial.ac.uk</a>
</p>


<h3>References</h3>


<p>Cori, A. et al. A new framework and software to estimate time-varying
reproduction numbers during epidemics (AJE 2013).
Wallinga, J. and P. Teunis. Different epidemic curves for severe acute
respiratory syndrome reveal similar impacts of control measures (AJE 2004).
Reich, N.G. et al. Estimating incubation period distributions with coarse
data (Statis. Med. 2009)

</p>


<h3>See Also</h3>

<p><code><a href="#topic+discr_si">discr_si</a></code> <code><a href="#topic+make_config">make_config</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on pandemic flu in a school in 2009
data("Flu2009")

## estimate the reproduction number (method "non_parametric_si")
## when not specifying t_start and t_end in config, they are set to estimate
## the reproduction number on sliding weekly windows                          
res &lt;- estimate_R(incid = Flu2009$incidence, 
                  method = "non_parametric_si",
                  config = make_config(list(si_distr = Flu2009$si_distr)))
plot(res)

## the second plot produced shows, at each each day,
## the estimate of the reproduction number over the 7-day window 
## finishing on that day.

## to specify t_start and t_end in config, e.g. to have biweekly sliding
## windows      
t_start &lt;- seq(2, nrow(Flu2009$incidence)-13)   
t_end &lt;- t_start + 13                 
res &lt;- estimate_R(incid = Flu2009$incidence, 
                  method = "non_parametric_si",
                  config = make_config(list(
                      si_distr = Flu2009$si_distr, 
                      t_start = t_start, 
                      t_end = t_end)))
plot(res)

## the second plot produced shows, at each each day,
## the estimate of the reproduction number over the 14-day window 
## finishing on that day.

## example with an incidence object

## create fake data
library(incidence)
data &lt;- c(0,1,1,2,1,3,4,5,5,5,5,4,4,26,6,7,9)
location &lt;- sample(c("local","imported"), length(data), replace=TRUE)
location[1] &lt;- "imported" # forcing the first case to be imported

## get incidence per group (location)
incid &lt;- incidence(data, groups = location)

## Estimate R with assumptions on serial interval
res &lt;- estimate_R(incid, method = "parametric_si",
                  config = make_config(list(
                  mean_si = 2.6, std_si = 1.5)))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number over the 7-day window
## finishing on that day.

## estimate the reproduction number (method "parametric_si")
res &lt;- estimate_R(Flu2009$incidence, method = "parametric_si",
                  config = make_config(list(mean_si = 2.6, std_si = 1.5)))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number over the 7-day window
## finishing on that day.

## estimate the reproduction number (method "uncertain_si")
res &lt;- estimate_R(Flu2009$incidence, method = "uncertain_si",
                  config = make_config(list(
                  mean_si = 2.6, std_mean_si = 1,
                  min_mean_si = 1, max_mean_si = 4.2,
                  std_si = 1.5, std_std_si = 0.5,
                  min_std_si = 0.5, max_std_si = 2.5,
                  n1 = 100, n2 = 100)))
plot(res)
## the bottom left plot produced shows, at each each day,
## the estimate of the reproduction number over the 7-day window
## finishing on that day.

## Not run: 
## Note the following examples use an MCMC routine
## to estimate the serial interval distribution from data,
## so they may take a few minutes to run

## load data on rotavirus
data("MockRotavirus")

## estimate the reproduction number (method "si_from_data")
MCMC_seed &lt;- 1
overall_seed &lt;- 2
R_si_from_data &lt;- estimate_R(MockRotavirus$incidence,
                            method = "si_from_data",
                            si_data = MockRotavirus$si_data,
                            config = make_config(list(si_parametric_distr = "G",
                                        mcmc_control = make_mcmc_control(list(burnin = 1000,
                                        thin = 10, seed = MCMC_seed),
                                        n1 = 500, n2 = 50,
                                        seed = overall_seed))))

## compare with version with no uncertainty
R_Parametric &lt;- estimate_R(MockRotavirus$incidence,
                          method = "parametric_si",
                          config = make_config(list(
                          mean_si = mean(R_si_from_data$SI.Moments$Mean),
                             std_si = mean(R_si_from_data$SI.Moments$Std))))
## generate plots
p_uncertainty &lt;- plot(R_si_from_data, "R", options_R=list(ylim=c(0, 1.5)))
p_no_uncertainty &lt;- plot(R_Parametric, "R", options_R=list(ylim=c(0, 1.5)))
gridExtra::grid.arrange(p_uncertainty, p_no_uncertainty,ncol=2)

## the left hand side graph is with uncertainty in the SI distribution, the
## right hand side without.
## The credible intervals are wider when accounting for uncertainty in the SI
## distribution.

## estimate the reproduction number (method "si_from_sample")
MCMC_seed &lt;- 1
overall_seed &lt;- 2
SI.fit &lt;- coarseDataTools::dic.fit.mcmc(dat = MockRotavirus$si_data,
                 dist = "G",
                 init.pars = init_mcmc_params(MockRotavirus$si_data, "G"),
                 burnin = 1000,
                 n.samples = 5000,
                 seed = MCMC_seed)
si_sample &lt;- coarse2estim(SI.fit, thin = 10)$si_sample
R_si_from_sample &lt;- estimate_R(MockRotavirus$incidence,
                               method = "si_from_sample",
                               si_sample = si_sample,
                               config = make_config(list(n2 = 50, 
                               seed = overall_seed)))
plot(R_si_from_sample)

## check that R_si_from_sample is the same as R_si_from_data
## since they were generated using the same MCMC algorithm to generate the SI
## sample (either internally to EpiEstim or externally)
all(R_si_from_sample$R$`Mean(R)` == R_si_from_data$R$`Mean(R)`)

## End(Not run)

</code></pre>

<hr>
<h2 id='estimate_R_plots'>Wrapper for plot.estimate_R</h2><span id='topic+estimate_R_plots'></span>

<h3>Description</h3>

<p>This wrapper has been created so that several <code>estimate_R</code> objects can 
be plotted at the same time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_R_plots(..., legend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_R_plots_+3A_...">...</code></td>
<td>
<p>Arguments of 
<code><a href="#topic+plot.estimate_R">plot.estimate_R</a></code>, but in addition,
parameter <code>x</code> can be a objects of class <code>estimate_R</code> (obtained as 
outputs of functions <code><a href="#topic+estimate_R">estimate_R</a></code> or 
<code><a href="#topic+wallinga_teunis">wallinga_teunis</a></code>.  
If <code>x</code> is a list, and <code>what='R'</code> or <code>what='all'</code>, 
all estimates of R are plotted on a
single graph. This will only work if all the <code>estimate_R</code> objects in 
the list were computed using the same <code>config$t_start</code> and 
<code>config$t_end</code></p>
</td></tr>
<tr><td><code id="estimate_R_plots_+3A_legend">legend</code></td>
<td>
<p>A boolean (TRUE by default) governing the presence / absence of
legends on the plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot (if <code>what = "incid"</code>, <code>"R"</code>, or <code>"SI"</code>) or a
<code><a href="grid.html#topic+grob">grob</a></code> object (if <code>what = "all"</code>).
</p>


<h3>Author(s)</h3>

<p>Anne Cori, Zhian Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.estimate_R">plot.estimate_R</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on pandemic flu in a school in 2009
data("Flu2009")

#### COMPARE THE INSTANTANEOUS AND CASE REPRODUCTION NUMBERS ####

## estimate the instantaneous reproduction number
## (method "non_parametric_si")
R_instantaneous &lt;- estimate_R(Flu2009$incidence,
                  method = "non_parametric_si",
                  config = list(t_start = seq(2, 26), 
                                t_end = seq(8, 32), 
                                si_distr = Flu2009$si_distr
                               )
                 )

## estimate the case reproduction number
R_case &lt;- wallinga_teunis(Flu2009$incidence,
                  method = "non_parametric_si",
                  config = list(t_start = seq(2, 26), 
                                t_end = seq(8, 32), 
                                si_distr = Flu2009$si_distr
                  )
                 )

## visualise R estimates on the same plot
estimate_R_plots(list(R_instantaneous, R_case), what = "R",
                 options_R = list(col = c("blue", "red")), legend = TRUE)
                 
#### COMPARE THE INSTANTANEOUS R ON SLIDING WEEKLY OR BIWEEKLY WINDOWS ####

R_weekly &lt;- estimate_R(Flu2009$incidence,
                  method = "non_parametric_si",
                  config = list(t_start = seq(9, 26), 
                                t_end = seq(15, 32), 
                                si_distr = Flu2009$si_distr
                               )
                 )

R_biweekly &lt;- estimate_R(Flu2009$incidence,
                  method = "non_parametric_si",
                  config = list(t_start = seq(2, 19), 
                                t_end = seq(15, 32),  
                                si_distr = Flu2009$si_distr
                  )
                 )

## visualise R estimates on the same plot
estimate_R_plots(list(R_weekly, R_biweekly), what = "R",
                 options_R = list(col = c("blue", "red")), legend = TRUE)
</code></pre>

<hr>
<h2 id='EstimateR'>Function to ensure compatibility with EpiEstim versions &lt;2.0</h2><span id='topic+EstimateR'></span>

<h3>Description</h3>

<p>Please only use for compatibility;
Prefer the new estimate_R function instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateR(
  I,
  T.Start,
  T.End,
  method = c("NonParametricSI", "ParametricSI", "UncertainSI"),
  n1 = NULL,
  n2 = NULL,
  Mean.SI = NULL,
  Std.SI = NULL,
  Std.Mean.SI = NULL,
  Min.Mean.SI = NULL,
  Max.Mean.SI = NULL,
  Std.Std.SI = NULL,
  Min.Std.SI = NULL,
  Max.Std.SI = NULL,
  SI.Distr = NULL,
  Mean.Prior = 5,
  Std.Prior = 5,
  CV.Posterior = 0.3,
  plot = FALSE,
  leg.pos = "topright"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EstimateR_+3A_i">I</code></td>
<td>
<p>see <code>incid</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_t.start">T.Start</code></td>
<td>
<p>see <code>config$t_start</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_t.end">T.End</code></td>
<td>
<p>see <code>config$t_end</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_method">method</code></td>
<td>
<p>see method in <code>estimate_R</code> (but EstimateR uses CamelCase 
where estimate_R uses snake_case for the method names)</p>
</td></tr>
<tr><td><code id="EstimateR_+3A_n1">n1</code></td>
<td>
<p>see <code>n1</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_n2">n2</code></td>
<td>
<p>see <code>n2</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_mean.si">Mean.SI</code></td>
<td>
<p>see <code>config$mean_si</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_std.si">Std.SI</code></td>
<td>
<p>see <code>config$std_si</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_std.mean.si">Std.Mean.SI</code></td>
<td>
<p>see <code>config$std_mean_si</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_min.mean.si">Min.Mean.SI</code></td>
<td>
<p>see <code>config$min_mean_si</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_max.mean.si">Max.Mean.SI</code></td>
<td>
<p>see <code>config$max_mean_si</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_std.std.si">Std.Std.SI</code></td>
<td>
<p>see <code>config$std_std_si</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_min.std.si">Min.Std.SI</code></td>
<td>
<p>see <code>config$min_std_si</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_max.std.si">Max.Std.SI</code></td>
<td>
<p>see <code>config$max_std_si</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_si.distr">SI.Distr</code></td>
<td>
<p>see <code>config$si_distr</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_mean.prior">Mean.Prior</code></td>
<td>
<p>see <code>config$mean_prior</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_std.prior">Std.Prior</code></td>
<td>
<p>see <code>config$std_prior</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_cv.posterior">CV.Posterior</code></td>
<td>
<p>see <code>config$cv_posterior</code> in <code>estimate_R</code></p>
</td></tr>
<tr><td><code id="EstimateR_+3A_plot">plot</code></td>
<td>
<p>Not used anymore, only there for compatibility</p>
</td></tr>
<tr><td><code id="EstimateR_+3A_leg.pos">leg.pos</code></td>
<td>
<p>Not used anymore, only there for compatibility</p>
</td></tr>
</table>

<hr>
<h2 id='flu_2009_NYC_school'>Data on the 2009 H1N1 influenza pandemic in a school in New York city</h2><span id='topic+flu_2009_NYC_school'></span>

<h3>Description</h3>

<p>This data set gives:
</p>

<ol>
<li><p> the daily incidence of self-reported and laboratory-confirmed cases of
influenza among children in a school in New York city during the 2009
H1N1 influenza pandemic (see source and references),
</p>
</li>
<li><p> interval-censored serial interval data from the 2009 outbreak of H1N1
influenza in a New York city school (see references).
</p>
</li></ol>



<h3>Format</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><strong>incidence</strong>: a dataframe with 14 lines containing dates in first column,
and daily incidence in second column ,
</p>
</li>
<li> <p><strong>si_data</strong>: a dataframe containing data on the generation time for 16
pairs of infector/infected individuals (see references and see argument
<code>si_data</code> of function <code><a href="#topic+estimate_R">estimate_R()</a></code> for details on columns)
</p>
</li></ul>


<h3>Source</h3>

<p>Lessler J. et al. (2009) Outbreak of 2009 pandemic influenza A (H1N1)
at a New York City school. New Eng J Med 361: 2628-2636.
</p>


<h3>References</h3>

<p>Lessler J. et al. (2009) Outbreak of 2009 pandemic influenza A (H1N1) at a
New York City school. New Eng J Med 361: 2628-2636.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Note the following examples use an MCMC routine
## to estimate the serial interval distribution from data,
## so they may take a few minutes to run

## load data on pandemic flu in a New York school in 2009
data("flu_2009_NYC_school")

## estimate the reproduction number (method "si_from_data")
res &lt;- estimate_R(flu_2009_NYC_school$incidence, method="si_from_data",
         si_data = flu_2009_NYC_school$si_data,
          config = make_config(list(
                      t_start = seq(2, 8), 
                      t_end = seq(8, 14),
                      si_parametric_distr = "G",
                      mcmc_control = make_mcmc_control(list(burnin = 1000,
                                 thin = 10, seed = 1)),
                      n1 = 1000, n2 = 50))
          )
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number
## over the 7-day window finishing on that day.

## End(Not run)
</code></pre>

<hr>
<h2 id='Flu1918'>Data on the 1918 H1N1 influenza pandemic in Baltimore.</h2><span id='topic+Flu1918'></span>

<h3>Description</h3>

<p>This data set gives:
</p>

<ol>
<li><p> the daily incidence of onset of disease in Baltimore during the 1918 H1N1
influenza pandemic (see source and references),
</p>
</li>
<li><p> the discrete daily distribution of the serial interval for influenza,
assuming a shifted Gamma distribution with mean 2.6 days, standard
deviation 1.5 days and shift 1 day (see references).
</p>
</li></ol>



<h3>Format</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><strong>incidence</strong>: a vector containing 92 days of observation,
</p>
</li>
<li> <p><strong>si_distr</strong>: a vector containing a set of 12 probabilities.
</p>
</li></ul>


<h3>Source</h3>

<p>Frost W. and E. Sydenstricker (1919) Influenza in Maryland:
preliminary statistics of certain localities.
Public Health Rep.(34): 491-504.
</p>


<h3>References</h3>

<p>Cauchemez S. et al. (2011) Role of social networks in shaping disease
transmission during a community outbreak of 2009 H1N1 pandemic influenza.
Proc Natl Acad Sci U S A 108(7), 2825-2830.
</p>
<p>Ferguson N.M. et al. (2005) Strategies for containing an emerging influenza
pandemic in Southeast Asia. Nature 437(7056), 209-214.
</p>
<p>Fraser C. et al. (2011) Influenza Transmission in Households During the 1918
Pandemic. Am J Epidemiol 174(5): 505-514.
</p>
<p>Frost W. and E. Sydenstricker (1919) Influenza in Maryland: preliminary
statistics of certain localities. Public Health Rep.(34): 491-504.
</p>
<p>Vynnycky E. et al. (2007) Estimates of the reproduction numbers of Spanish
influenza using morbidity data. Int J Epidemiol 36(4): 881-889.
</p>
<p>White L.F. and M. Pagano (2008) Transmissibility of the influenza virus in
the 1918 pandemic. PLoS One 3(1): e1498.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on pandemic flu in Baltimore in 1918
data("Flu1918")

## estimate the reproduction number (method "non_parametric_si")
res &lt;- estimate_R(Flu1918$incidence,
          method = "non_parametric_si",
          config = make_config(list(si_distr = Flu1918$si_distr)))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number
## over the 7-day window finishing on that day.
</code></pre>

<hr>
<h2 id='Flu2009'>Data on the 2009 H1N1 influenza pandemic in a school in Pennsylvania.</h2><span id='topic+Flu2009'></span>

<h3>Description</h3>

<p>This data set gives:
</p>

<ol>
<li><p> the daily incidence of onset of acute respiratory illness
(ARI, defined as at least two symptoms among fever, cough, sore throat,
and runny nose) among children in a school in Pennsylvania during the
2009 H1N1 influenza pandemic (see source and references),
</p>
</li>
<li><p> the discrete daily distribution of the serial interval for influenza,
assuming a shifted Gamma distribution with mean 2.6 days, standard
deviation 1.5 days and shift 1 day (see references).
</p>
</li>
<li><p> interval-censored serial interval data from the 2009 outbreak of H1N1
influenza in San Antonio, Texas, USA (see references).
</p>
</li></ol>



<h3>Format</h3>

<p>A list of three elements:
</p>

<ul>
<li> <p><strong>incidence:</strong> a dataframe with 32 lines containing dates in first column,
and daily incidence in second column (Cauchemez et al., 2011),
</p>
</li>
<li> <p><strong>si_distr:</strong> a vector containing a set of 12 probabilities (Ferguson et
al, 2005),
</p>
</li>
<li> <p><strong>si_data:</strong> a dataframe with 16 lines giving serial interval patient
data collected in a household study in San Antonio, Texas throughout the
2009 H1N1 outbreak (Morgan et al., 2010).
</p>
</li></ul>


<h3>Source</h3>

<p>Cauchemez S. et al. (2011) Role of social networks in shaping
disease transmission during a community outbreak of 2009 H1N1 pandemic
influenza. Proc Natl Acad Sci U S A 108(7), 2825-2830.
</p>
<p>Morgan O.W. et al. (2010) Household transmission of pandemic (H1N1) 2009, San
Antonio, Texas, USA, April-May 2009. Emerg Infect Dis 16: 631-637.
</p>


<h3>References</h3>

<p>Cauchemez S. et al. (2011) Role of social networks in shaping
disease transmission during a community outbreak of 2009 H1N1 pandemic
influenza. Proc Natl Acad Sci U S A 108(7), 2825-2830.
</p>
<p>Ferguson N.M. et al. (2005) Strategies for containing an emerging influenza
pandemic in Southeast Asia. Nature 437(7056), 209-214.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on pandemic flu in a school in 2009
data("Flu2009")

## estimate the reproduction number (method "non_parametric_si")
res &lt;- estimate_R(Flu2009$incidence, method="non_parametric_si",
          config = make_config(list(si_distr = Flu2009$si_distr)))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number
## over the 7-day window finishing on that day.

## Not run: 
## Note the following examples use an MCMC routine
## to estimate the serial interval distribution from data,
## so they may take a few minutes to run

## estimate the reproduction number (method "si_from_data")
res &lt;- estimate_R(Flu2009$incidence, method="si_from_data",
          si_data = Flu2009$si_data,
          config = make_config(list(mcmc_control = make_mcmc_control(list(
                                 burnin = 1000,
                                 thin = 10, seed = 1)),
                      n1 = 1000, n2 = 50,
                      si_parametric_distr = "G")))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number
## over the 7-day window finishing on that day.

## End(Not run)


</code></pre>

<hr>
<h2 id='init_mcmc_params'>init_mcmc_params Finds clever starting points for the MCMC to be used to 
estimate the serial interval, e.g. when using option <code>si_from_data</code> in 
<code>estimate_R</code></h2><span id='topic+init_mcmc_params'></span>

<h3>Description</h3>

<p><code>init_mcmc_params</code> Finds values of the serial interval distribution 
parameters, used to initialise the MCMC estimation of the serial interval 
distribution. Initial values are computed based on the observed mean and 
standard deviation of the sample from which the parameters are to be 
estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_mcmc_params(si_data, dist = c("G", "W", "L", "off1G", "off1W", "off1L"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_mcmc_params_+3A_si_data">si_data</code></td>
<td>
<p>the data on dates of symptoms of pairs of infector/infected
individuals to be used to estimate the serial interval distribution. This
should be a dataframe with 5 columns: </p>
 <ul>
<li><p>EL: the lower bound
of the symptom onset date of the infector (given as an integer) </p>
</li>
<li><p>ER:
the upper bound of the symptom onset date of the infector (given as an
integer). Should be such that ER&gt;=EL </p>
</li>
<li><p>SL: the lower bound of the
symptom onset date of the infected individual (given as an integer) 
</p>
</li>
<li><p>SR: the upper bound of the symptom onset date of the infected
individual (given as an integer). Should be such that SR&gt;=SL </p>
</li>
<li><p>type
(optional): can have entries 0, 1, or 2, corresponding to doubly
interval-censored, single interval-censored or exact observations, 
respectively, see Reich et al. Statist. Med. 2009. If not specified, this
will be automatically computed from the dates </p>
</li></ul>
</td></tr>
<tr><td><code id="init_mcmc_params_+3A_dist">dist</code></td>
<td>
<p>the parametric distribution to use for the serial interval. 
Should be one of &quot;G&quot; (Gamma), &quot;W&quot; (Weibull), &quot;L&quot; (Lognormal), &quot;off1G&quot;
(Gamma shifted by 1), &quot;off1W&quot; (Weibull shifted by 1), or &quot;off1L&quot; (Lognormal
shifted by 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the initial values for the two parameters of the
distribution of the serial interval. These are the shape and scale for all
but the lognormal distribution, for which it is the meanlog and sdlog.
</p>


<h3>Author(s)</h3>

<p>Anne Cori
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_R">estimate_R</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Note the following examples use an MCMC routine
## to estimate the serial interval distribution from data,
## so they may take a few minutes to run

## load data on rotavirus
data("MockRotavirus")

## get clever initial values for shape and scale of a Gamma distribution
## fitted to the the data MockRotavirus$si_data
clever_init_param &lt;- init_mcmc_params(MockRotavirus$si_data, "G")

## estimate the serial interval from data using a clever starting point for 
## the MCMC chain
SI_fit_clever &lt;- coarseDataTools::dic.fit.mcmc(dat = MockRotavirus$si_data,
                             dist = "G",
                             init.pars = clever_init_param,
                             burnin = 1000,
                             n.samples = 5000)

## estimate the serial interval from data using a random starting point for 
## the MCMC chain
SI_fit_naive &lt;- coarseDataTools::dic.fit.mcmc(dat = MockRotavirus$si_data,
                             dist = "G",
                             burnin = 1000,
                             n.samples = 5000)


## use check_cdt_samples_convergence to check convergence in both situations
converg_diag_clever &lt;- check_cdt_samples_convergence(SI_fit_clever@samples)
converg_diag_naive &lt;- check_cdt_samples_convergence(SI_fit_naive@samples)
converg_diag_clever
converg_diag_naive


## End(Not run)

</code></pre>

<hr>
<h2 id='make_config'>Set and check parameter settings of estimate_R</h2><span id='topic+make_config'></span>

<h3>Description</h3>

<p>This function defines settings for estimate_R  It takes a list of named
items as input, set defaults where arguments are
missing, and return a list of settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_config(
  ...,
  incid = NULL,
  method = c("non_parametric_si", "parametric_si", "uncertain_si", "si_from_data",
    "si_from_sample")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_config_+3A_...">...</code></td>
<td>
<p>Acceptable arguments for ... are:
</p>

<dl>
<dt>t_start</dt><dd><p>Vector of positive integers giving the starting times of each
window over which the reproduction number will be estimated. These must be in
ascending order, and so that for all <code>i</code>, <code>t_start[i]&lt;=t_end[i]</code>.
t_start[1] should be strictly after the first day with non null incidence.</p>
</dd>
<dt>t_end</dt><dd><p>Vector of positive integers giving the ending times of each
window over which the reproduction number will be estimated. These must be
in ascending order, and so that for all <code>i</code>,
<code>t_start[i]&lt;=t_end[i]</code>.</p>
</dd>
<dt>n1</dt><dd><p>For method &quot;uncertain_si&quot; and &quot;si_from_data&quot;; positive integer
giving the size of the sample of SI distributions to be drawn (see details).</p>
</dd>
<dt>n2</dt><dd><p>For methods &quot;uncertain_si&quot;, &quot;si_from_data&quot; and &quot;si_from_sample&quot;;
positive integer giving the size of the sample drawn from the posterior
distribution of R for each serial interval distribution considered (see
details).</p>
</dd>
<dt>mean_si</dt><dd><p>For method &quot;parametric_si&quot; and &quot;uncertain_si&quot; ; positive real
giving the mean serial interval (method &quot;parametric_si&quot;) or the average mean
serial interval (method &quot;uncertain_si&quot;, see details).</p>
</dd>
<dt>std_si</dt><dd><p>For method &quot;parametric_si&quot; and &quot;uncertain_si&quot; ; non negative
real giving the standard deviation of the serial interval
(method &quot;parametric_si&quot;) or the average standard deviation of the serial
interval (method &quot;uncertain_si&quot;, see details).</p>
</dd>
<dt>std_mean_si</dt><dd><p>For method &quot;uncertain_si&quot; ; standard deviation of the
distribution from which mean serial intervals are drawn (see details).</p>
</dd>
<dt>min_mean_si</dt><dd><p>For method &quot;uncertain_si&quot; ; lower bound of the
distribution from which mean serial intervals are drawn (see details).</p>
</dd>
<dt>max_mean_si</dt><dd><p>For method &quot;uncertain_si&quot; ; upper bound of the
distribution from which mean serial intervals are drawn (see details).</p>
</dd>
<dt>std_std_si</dt><dd><p>For method &quot;uncertain_si&quot; ; standard deviation of the
distribution from which standard deviations of the serial interval are drawn
(see details).</p>
</dd>
<dt>min_std_si</dt><dd><p>For method &quot;uncertain_si&quot; ; lower bound of the distribution
from which standard deviations of the serial interval are drawn (see
details).</p>
</dd>
<dt>max_std_si</dt><dd><p>For method &quot;uncertain_si&quot; ; upper bound of the distribution
from which standard deviations of the serial interval are drawn (see
details).</p>
</dd>
<dt>si_distr</dt><dd><p>For method &quot;non_parametric_si&quot; ; vector of probabilities
giving the discrete distribution of the serial interval, starting with
<code>si_distr[1]</code> (probability that the serial interval is zero), which
should be zero.</p>
</dd>
<dt>si_parametric_distr</dt><dd><p>For method &quot;si_from_data&quot; ; the parametric
distribution to use when estimating the serial interval from data on dates of
symptoms of pairs of infector/infected individuals (see details).
Should be one of &quot;G&quot; (Gamma), &quot;W&quot; (Weibull), &quot;L&quot; (Lognormal), &quot;off1G&quot; (Gamma
shifted by 1), &quot;off1W&quot; (Weibull shifted by 1), or &quot;off1L&quot; (Lognormal shifted
by 1).</p>
</dd>
<dt>mcmc_control</dt><dd><p>An object of class <code>estimate_R_mcmc_control</code>, as 
returned by function <code>make_mcmc_control</code>. </p>
</dd>
<dt>seed</dt><dd><p>An optional integer used as the seed for the random number
generator at the start of the function (then potentially reset within the
MCMC for method <code>si_from_data</code>); useful to get reproducible results.</p>
</dd>
<dt>mean_prior</dt><dd><p>A positive number giving the mean of the common prior
distribution for all reproduction numbers (see details).</p>
</dd>
<dt>std_prior</dt><dd><p>A positive number giving the standard deviation of the
common prior distribution for all reproduction numbers (see details).</p>
</dd>
<dt>cv_posterior</dt><dd><p>A positive number giving the aimed posterior coefficient
of variation (see details).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="make_config_+3A_incid">incid</code></td>
<td>
<p>As in function<code>estimate_R</code>.</p>
</td></tr>
<tr><td><code id="make_config_+3A_method">method</code></td>
<td>
<p>As in function<code>estimate_R</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Analytical estimates of the reproduction number for an epidemic over
predefined time windows can be obtained using function <code>estimate_R</code>,  
for a given discrete distribution of the serial interval. <code>make_config</code>
allows to generate a configuration specifying the way the estimation will
be performed. 
</p>
<p>The more incident cases are observed over a time window, the smallest the
posterior coefficient of variation (CV, ratio of standard deviation over
mean) of the reproduction number.
An aimed CV can be specified in the argument <code>cv_posterior</code> 
(default is <code>0.3</code>), and a warning will be produced if the incidence 
within one of the time windows considered is too low to get this CV.
</p>
<p>The methods vary in the way the serial interval distribution is specified.
</p>
<p>In short there are five methods to specify the serial interval distribution
(see below for details on each method).
In the first two methods, a unique serial interval distribution is
considered, whereas in the last three, a range of serial interval
distributions are integrated over:
</p>

<ul>
<li><p>In method &quot;non_parametric_si&quot; the user specifies the discrete
distribution of the serial interval
</p>
</li>
<li><p>In method &quot;parametric_si&quot; the user specifies the mean and sd of the
serial interval
</p>
</li>
<li><p>In method &quot;uncertain_si&quot; the mean and sd of the serial interval are
each drawn from truncated normal distributions, with parameters specified by
the user
</p>
</li>
<li><p>In method &quot;si_from_data&quot;, the serial interval distribution is directly
estimated, using MCMC, from interval censored exposure data, with data
provided by the user together with a choice of parametric distribution for
the serial interval
</p>
</li>
<li><p>In method &quot;si_from_sample&quot;, the user directly provides the sample of
serial interval distribution to use for estimation of R. This can be a useful
alternative to the previous method, where the MCMC estimation of the serial
interval distribution could be run once, and the same estimated SI
distribution then used in estimate_R in different contexts, e.g. with
different time windows, hence avoiding to rerun the MCMC everytime
estimate_R is called.
</p>
</li></ul>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; <code>method "non_parametric_si"</code> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
</p>
<p>The discrete distribution of the serial interval is directly specified in the
argument <code>si_distr</code>.
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; <code>method "parametric_si"</code> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p>The mean and standard deviation of the continuous distribution of the serial
interval are given in the arguments <code>mean_si</code> and <code>std_si</code>.
The discrete distribution of the serial interval is derived automatically
using <code><a href="#topic+discr_si">discr_si</a></code>.
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; <code>method "uncertain_si"</code> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p><code>Method "uncertain_si"</code> allows accounting for uncertainty on the serial
interval distribution as described in Cori et al. AJE 2013.
We allow the mean <code class="reqn">\mu</code> and standard deviation <code class="reqn">\sigma</code> of the serial
interval to vary according to truncated normal distributions.
We sample <code>n1</code> pairs of mean and standard deviations,
<code class="reqn">(\mu^{(1)},\sigma^{(1)}),...,(\mu^{(n_2)},\sigma^{(n_2)})</code>, by first
sampling the mean <code class="reqn">\mu^{(k)}</code>
from its truncated normal distribution (with mean <code>mean_si</code>, standard
deviation <code>std_mean_si</code>, minimum <code>min_mean_si</code> and maximum
<code>max_mean_si</code>),
and then sampling the standard deviation <code class="reqn">\sigma^{(k)}</code> from its
truncated normal distribution
(with mean <code>std_si</code>, standard deviation <code>std_std_si</code>, minimum
<code>min_std_si</code> and maximum <code>max_std_si</code>), but imposing that
<code class="reqn">\sigma^{(k)}&lt;\mu^{(k)}</code>.
This constraint ensures that the Gamma probability density function of the
serial interval is null at <code class="reqn">t=0</code>.
Warnings are produced when the truncated normal distributions are not
symmetric around the mean.
For each pair <code class="reqn">(\mu^{(k)},\sigma^{(k)})</code>, we then draw a sample of size
<code>n2</code> in the posterior distribution of the reproduction number over each
time window, conditionally on this serial interval distribution.
After pooling, a sample of size <code class="reqn">\code{n1}\times\code{n2}</code> of the joint
posterior distribution of the reproduction number over each time window is
obtained.
The posterior mean, standard deviation, and 0.025, 0.05, 0.25, 0.5, 0.75,
0.95, 0.975 quantiles of the reproduction number for each time window are
obtained from this sample.
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; <code>method "si_from_data"</code> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p><code>Method "si_from_data"</code> allows accounting for uncertainty on the serial
interval distribution.
Unlike method &quot;uncertain_si&quot;, where we arbitrarily vary the mean and std of
the SI in truncated normal distributions,
here, the scope of serial interval distributions considered is directly
informed by data
on the (potentially censored) dates of symptoms of pairs of infector/infected
individuals.
This data, specified in argument <code>si_data</code>, should be a dataframe with 5
columns:
</p>

<ul>
<li><p>EL: the lower bound of the symptom onset date of the infector (given as
an integer)
</p>
</li>
<li><p>ER: the upper bound of the symptom onset date of the infector (given as
an integer). Should be such that ER&gt;=EL
</p>
</li>
<li><p>SL: the lower bound of the symptom onset date of the infected
individual (given as an integer)
</p>
</li>
<li><p>SR: the upper bound of the symptom onset date of the infected
individual (given as an integer). Should be such that SR&gt;=SL
</p>
</li>
<li><p>type (optional): can have entries 0, 1, or 2, corresponding to doubly
interval-censored, single interval-censored or exact observations,
respectively, see Reich et al. Statist. Med. 2009. If not specified, this
will be automatically computed from the dates
</p>
</li></ul>

<p>Assuming a given parametric distribution for the serial interval distribution
(specified in si_parametric_distr),
the posterior distribution of the serial interval is estimated directly from
these data using MCMC methods implemented in the package
<code>coarsedatatools</code>.
The argument <code>mcmc_control</code> is a list of characteristics which control
the MCMC.
The MCMC is run for a total number of iterations of
<code>mcmc_control$burnin + n1*mcmc_control$thin</code>;
but the output is only recorded after the burnin, and only 1 in every
<code>mcmc_control$thin</code> iterations,
so that the posterior sample size is <code>n1</code>.
For each element in the posterior sample of serial interval distribution,
we then draw a sample of size <code>n2</code> in the posterior distribution of the
reproduction number over each time window,
conditionally on this serial interval distribution.
After pooling, a sample of size <code class="reqn">\code{n1}\times\code{n2}</code> of the joint
posterior distribution of
the reproduction number over each time window is obtained.
The posterior mean, standard deviation, and 0.025, 0.05, 0.25, 0.5, 0.75,
0.95, 0.975 quantiles of the reproduction number for each time window are
obtained from this sample.
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; <code>method "si_from_sample"</code> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
</p>
<p><code>Method "si_from_sample"</code> also allows accounting for uncertainty on the
serial interval distribution.
Unlike methods &quot;uncertain_si&quot; and &quot;si_from_data&quot;, the user directly provides
(in argument <code>si_sample</code>) a sample of serial interval distribution to be
explored.
</p>


<h3>Value</h3>

<p>An object of class <code>estimate_R_config</code> with components 
t_start, t_end, n1, n2, mean_si, std_si, 
std_mean_si, min_mean_si, max_mean_si, std_std_si, min_std_si, max_std_si,
si_distr, si_parametric_distr, mcmc_control, seed, mean_prior, std_prior, 
cv_posterior, which can be used as an argument of function <code>estimate_R</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Note the following examples use an MCMC routine
## to estimate the serial interval distribution from data,
## so they may take a few minutes to run

## load data on rotavirus
data("MockRotavirus")

## estimate the reproduction number (method "si_from_data")
## we are not specifying the time windows, so by defaults this will estimate
## R on sliding weekly windows
incid &lt;- MockRotavirus$incidence
method &lt;- "si_from_data"
config &lt;- make_config(incid = incid, 
                     method = method, 
                     list(si_parametric_distr = "G",
                     mcmc_control = make_mcmc_control(burnin = 1000, 
                     thin = 10, seed = 1),
                     n1 = 500, 
                     n2 = 50,
                     seed = 2))

R_si_from_data &lt;- estimate_R(incid,
                            method = method,
                            si_data = MockRotavirus$si_data,
                            config = config)
plot(R_si_from_data)                          

## you can also create the config straight within the estimate_R call, 
## in that case incid and method are automatically used from the estimate_R
## arguments:
R_si_from_data &lt;- estimate_R(incid,
                            method = method,
                            si_data = MockRotavirus$si_data,
                            config = make_config(
                     list(si_parametric_distr = "G",
                     mcmc_control = make_mcmc_control(burnin = 1000, 
                     thin = 10, seed = 1),
                     n1 = 500, 
                     n2 = 50,
                     seed = 2)))
plot(R_si_from_data)    

## End(Not run)
</code></pre>

<hr>
<h2 id='make_mcmc_control'>make_mcmc_control Creates a list of mcmc control parameters to be used in 
<code>config$mcmc_control</code>, where <code>config</code> is an argument of the 
<code>estimate_R</code> function. This is used to configure the MCMC chain used to 
estimate the serial interval within <code>estimate_R</code> (with method 
&quot;si_from_data&quot;).</h2><span id='topic+make_mcmc_control'></span>

<h3>Description</h3>

<p>make_mcmc_control Creates a list of mcmc control parameters to be used in 
<code>config$mcmc_control</code>, where <code>config</code> is an argument of the 
<code>estimate_R</code> function. This is used to configure the MCMC chain used to 
estimate the serial interval within <code>estimate_R</code> (with method 
&quot;si_from_data&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mcmc_control(
  burnin = 3000,
  thin = 10,
  seed = as.integer(Sys.time()),
  init_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_mcmc_control_+3A_burnin">burnin</code></td>
<td>
<p>A positive integer giving the burnin used in the MCMC when
estimating the serial interval distribution.</p>
</td></tr>
<tr><td><code id="make_mcmc_control_+3A_thin">thin</code></td>
<td>
<p>A positive integer corresponding to thinning parameter; the MCMC
will be run for <code>burnin+n1*thin iterations</code>; 1 in <code>thin</code>
iterations will be recorded, after the burnin phase, so the posterior
sample size is n1.</p>
</td></tr>
<tr><td><code id="make_mcmc_control_+3A_seed">seed</code></td>
<td>
<p>An integer used as the seed for the random number generator at
the start of the MCMC estimation; useful to get reproducible results.</p>
</td></tr>
<tr><td><code id="make_mcmc_control_+3A_init_pars">init_pars</code></td>
<td>
<p>vector of size 2 corresponding to the initial values of
parameters to use for the SI distribution. This is the shape and scale for
all but the lognormal distribution, for which it is the meanlog and
sdlog.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>si_data</code>, should be a dataframe with 5
columns:
</p>

<ul>
<li><p>EL: the lower bound of the symptom onset date of the infector (given as
an integer)
</p>
</li>
<li><p>ER: the upper bound of the symptom onset date of the infector (given as
an integer). Should be such that ER&gt;=EL
</p>
</li>
<li><p>SL: the lower bound of the symptom onset date of the infected
individual (given as an integer)
</p>
</li>
<li><p>SR: the upper bound of the symptom onset date of the infected
individual (given as an integer). Should be such that SR&gt;=SL
</p>
</li>
<li><p>type (optional): can have entries 0, 1, or 2, corresponding to doubly
interval-censored, single interval-censored or exact observations,
respectively, see Reich et al. Statist. Med. 2009. If not specified, this
will be automatically computed from the dates
</p>
</li></ul>

<p>Assuming a given parametric distribution for the serial interval distribution
(specified in <code>si_parametric_distr</code>),
the posterior distribution of the serial interval is estimated directly fom
these data using MCMC methods implemented in the package
</p>


<h3>Value</h3>

<p>An object of class <code>estimate_R_mcmc_control</code> with components 
burnin, thin, seed, init_pars. This can be 
used as an argument of function <code>make_config</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Note the following examples use an MCMC routine
## to estimate the serial interval distribution from data,
## so they may take a few minutes to run

## load data on rotavirus
data("MockRotavirus")

## estimate the reproduction number (method "si_from_data")
mcmc_seed &lt;- 1
burnin &lt;- 1000
thin &lt;- 10
mcmc_control &lt;- make_mcmc_control(burnin = burnin, thin = thin, 
                     seed = mcmc_seed)

incid &lt;- MockRotavirus$incidence
method &lt;- "si_from_data"
overall_seed &lt;- 2
config &lt;- make_config(incid = incid, 
                     method = method, 
                     si_parametric_distr = "G",
                     mcmc_control = mcmc_control,
                     n1 = 500
                     n2 = 50,
                     seed = overall_seed)

R_si_from_data &lt;- estimate_R(incid,
                            method = method,
                            si_data = MockRotavirus$si_data,
                            config = config)

## End(Not run)
</code></pre>

<hr>
<h2 id='Measles1861'>Data on the 1861 measles epidemic in Hagelloch, Germany.</h2><span id='topic+Measles1861'></span>

<h3>Description</h3>

<p>This data set gives:
</p>

<ol>
<li><p> the daily incidence of onset of symptoms in Hallegoch (Germany) during
the 1861 measles epidemic (see source and references),
</p>
</li>
<li><p> the discrete daily distribution of the serial interval for measles,
assuming a shifted Gamma distribution with mean 14.9 days, standard
deviation 3.9 days and shift 1 day (see references).
</p>
</li></ol>



<h3>Format</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><strong>incidence:</strong> a vector containing 48 days of observation,
</p>
</li>
<li> <p><strong>si_distr:</strong> a vector containing a set of 38 probabilities.
</p>
</li></ul>


<h3>Source</h3>

<p>Groendyke C. et al. (2011) Bayesian Inference for Contact Networks
Given Epidemic Data. Scandinavian Journal of Statistics 38(3): 600-616.
</p>


<h3>References</h3>

<p>Groendyke C. et al. (2011) Bayesian Inference for Contact
Networks Given Epidemic Data. Scandinavian Journal of Statistics 38(3):
600-616.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on measles in Hallegoch in 1861
data("Measles1861")

## estimate the reproduction number (method "non_parametric_si")
res &lt;- estimate_R(Measles1861$incidence, method="non_parametric_si",
          config = make_config(list(
                t_start = seq(17, 42), 
                t_end = seq(23, 48),
                si_distr = Measles1861$si_distr)))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number
## over the 7-day window finishing on that day.
</code></pre>

<hr>
<h2 id='mers_2014_15'>Data on Middle East Respiratory Syndrome (MERS) in Saudi Arabia.</h2><span id='topic+mers_2014_15'></span>

<h3>Description</h3>

<p>This data set gives:
</p>

<ol>
<li><p> the daily incidence of onset of symptoms of laboratory confirmed human
infections with MERS-CoV in Saudi Arabia between the beginning of July
2014 and the end of December 2015, and
</p>
</li>
<li><p> estimates of the mean and standard deviation of the serial interval for
MERS.
</p>
</li></ol>



<h3>Format</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><strong>incidence:</strong> a dataframe containing 495 days of observations with dates
in the first column, and number of local (2nd column) and imported (3rd
column) cases of MERS,
</p>
</li>
<li> <p><strong>si:</strong> a list of estimates of the mean (mean_si) and standard deviation
(std_si) of the serial interval for MERS.
</p>
</li></ul>


<h3>Source</h3>

<p>The incidence data was extracted from the EMPRES I system from FAO
(Global Animal Disease Information System - Food and Agriculture Organization
of the United Nations, 2017). Note incidence on the first day was originally
made of one local case and zero imported cases; this has been modified to
zero local cases and one imported case in the dataset shown here so the
reproduction number can be estimated from the start using the function
<code><a href="#topic+estimate_R">estimate_R()</a></code>. The serial interval parameters were those
estimated by Cauchemez et al. (2016).
</p>


<h3>References</h3>

<p>Global Animal Disease Information System - Food and Agriculture Organization
of the United Nations, 2017
</p>
<p>Cauchemez S, Nouvellet P, Cori A, Jombart T, Garske T, Clapham H, Moore S,
Linden Mills H, Salje H, Collins C, et al. 2016.
Unraveling the drivers of MERS-CoV transmission.
Proc Natl Acad Sci 113: 9081-9086.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data
data("mers_2014_15")

## estimate the reproduction number (method "parametric_si")
bimonthly_R &lt;- estimate_R(mers_2014_15$incidence[,c("local", "imported")],
                          method = "parametric_si",
                          config = make_config(
                          mean_si = mers_2014_15$si$mean_si,
                          std_si = mers_2014_15$si$std_si,
                          t_start = 2:(nrow(mers_2014_15$incidence)-8*7),
                          t_end = (2:(nrow(mers_2014_15$incidence)-8*7)) + 8*7))

plot(bimonthly_R, legend = FALSE, add_imported_cases = TRUE,
                          options_I = list(col = c("local" = "black", 
                             "imported" = "red"),
                             interval = 7, # show weekly incidence
                             ylab = "Weekly incidence"),
                          options_R = list(ylab = "Bimonthly R")) 
# The first plot shows the weekly incidence, 
# with imported cases shown in red and local cases in black

</code></pre>

<hr>
<h2 id='MockRotavirus'>Mock data on a rotavirus epidemic.</h2><span id='topic+MockRotavirus'></span>

<h3>Description</h3>

<p>This data set gives:
</p>

<ol>
<li><p> the daily incidence of onset of symptoms in a mock outbreak of rotavirus,
</p>
</li>
<li><p> mock observations of symptom onset dates for 19 pairs of
infector/infected individuals.
</p>
</li></ol>



<h3>Format</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><strong>incidence:</strong> a vector containing 53 days of observation,
</p>
</li>
<li> <p><strong>si_distr:</strong> a dataframe containing a set of 19 observations; each
observation corresponds to a pair of infector/infected individuals. EL
and ER columns contain the lower an upper bounds of the dates of
symptoms onset in the infectors. SL and SR columns contain the lower an
upper bounds of the dates of symptoms onset in the infected individuals.
The type column has entries 0, 1, or 2, corresponding to doubly
interval-censored, single interval-censored or exact observations,
respectively, see Reich et al.  Statist. Med. 2009
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Note the following example uses an MCMC routine
## to estimate the serial interval distribution from data,
## so may take a few minutes to run

## load data
data("MockRotavirus")

## estimate the reproduction number (method "si_from_data")
res &lt;- estimate_R(MockRotavirus$incidence,
          method = "si_from_data",
          si_data = MockRotavirus$si_data,
          config = make_config(list(
            si_parametric_distr = "G",
            mcmc_control = make_mcmc_control(list(burnin = 3000, thin = 10)),
            n1 = 500, n2 = 50)))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number
## over the 7-day window finishing on that day.

## End(Not run)
</code></pre>

<hr>
<h2 id='overall_infectivity'>Overall Infectivity Due To Previously Infected Individuals</h2><span id='topic+overall_infectivity'></span>

<h3>Description</h3>

<p><code>overall_infectivity</code> computes the overall infectivity due to previously
infected individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall_infectivity(incid, si_distr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overall_infectivity_+3A_incid">incid</code></td>
<td>
<p>One of the following </p>
 <ul>
<li><p>A vector (or a dataframe
with a single column) of non-negative integers containing an incidence time
series </p>
</li>
<li><p>A dataframe of non-negative integers with two columns, so
that <code>incid$local</code> contains the incidence of cases due to local
transmission and <code>incid$imported</code> contains the incidence of imported
cases (with <code>incid$local + incid$imported</code> the total incidence). </p>
</li></ul>
 
<p>Note that the cases from the first time step are always all assumed to be
imported cases.</p>
</td></tr>
<tr><td><code id="overall_infectivity_+3A_si_distr">si_distr</code></td>
<td>
<p>Vector of probabilities giving the discrete distribution of
the serial interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The overall infectivity <code class="reqn">\lambda_t</code> at time step <code class="reqn">t</code> is
equal to the sum of the previously infected individuals (given by the
incidence vector <code class="reqn">I</code>, with <code>I = incid$local + incid$imported</code> if
<code class="reqn">I</code> is a matrix), weigthed by their infectivity at time <code class="reqn">t</code> (given by
the discrete serial interval distribution <code class="reqn">w_k</code>). In mathematical terms: 
<br /> <code class="reqn">\lambda_t = \sum_{k=1}^{t-1}I_{t-k}w_k</code> <br /> 
</p>


<h3>Value</h3>

<p>A vector which contains the overall infectivity <code class="reqn">\lambda_t</code> at
each time step
</p>


<h3>Author(s)</h3>

<p>Anne Cori <a href="mailto:a.cori@imperial.ac.uk">a.cori@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Cori, A. et al. A new framework and software to estimate
time-varying reproduction numbers during epidemics (AJE 2013).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discr_si">discr_si</a></code>, <code><a href="#topic+estimate_R">estimate_R</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on pandemic flu in a school in 2009
data("Flu2009")

## compute overall infectivity
lambda &lt;- overall_infectivity(Flu2009$incidence, Flu2009$si_distr)
par(mfrow=c(2,1))
plot(Flu2009$incidence, type = "s", xlab = "time (days)", ylab = "incidence")
title(main = "Epidemic curve")
plot(lambda, type = "s", xlab = "time (days)", ylab = "Infectivity")
title(main = "Overall infectivity")
</code></pre>

<hr>
<h2 id='OverallInfectivity'>Function to ensure compatibility with EpiEstim versions &lt;2.0</h2><span id='topic+OverallInfectivity'></span>

<h3>Description</h3>

<p>Please only use for compatibility;
Prefer the new overall_infectivity function instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OverallInfectivity(I, SI.Distr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OverallInfectivity_+3A_i">I</code></td>
<td>
<p>see <code>incid</code> in <code>overall_infectivity</code></p>
</td></tr>
<tr><td><code id="OverallInfectivity_+3A_si.distr">SI.Distr</code></td>
<td>
<p>see <code>si_distr</code> in <code>overall_infectivity</code></p>
</td></tr>
</table>

<hr>
<h2 id='plot.estimate_R'>Plot outputs of estimate_r</h2><span id='topic+plot.estimate_R'></span>

<h3>Description</h3>

<p>The plot method of <code>estimate_r</code> objects can be used to visualise three
types of information. The first one shows the epidemic curve. The second one
shows the posterior mean and 95% credible interval of the reproduction
number. The estimate for a time window is plotted at the end of the time
window. The third plot shows the discrete distribution(s) of the serial
interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimate_R'
plot(
  x,
  what = c("all", "incid", "R", "SI"),
  add_imported_cases = FALSE,
  options_I = list(col = palette(), transp = 0.7, xlim = NULL, ylim = NULL, interval =
    1L, xlab = "Time", ylab = "Incidence"),
  options_R = list(col = palette(), transp = 0.2, xlim = NULL, ylim = NULL, xlab =
    "Time", ylab = "R"),
  options_SI = list(prob_min = 0.001, col = "black", transp = 0.25, xlim = NULL, ylim =
    NULL, xlab = "Time", ylab = "Frequency"),
  legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.estimate_R_+3A_x">x</code></td>
<td>
<p>The output of function <code><a href="#topic+estimate_R">estimate_R</a></code> or function
<code><a href="#topic+wallinga_teunis">wallinga_teunis</a></code>. To plot simultaneous outputs on the same 
plot use <code><a href="#topic+estimate_R_plots">estimate_R_plots</a></code> function</p>
</td></tr>
<tr><td><code id="plot.estimate_R_+3A_what">what</code></td>
<td>
<p>A string specifying what to plot, namely the incidence time
series (<code>what='incid'</code>), the estimated reproduction number
(<code>what='R'</code>), the serial interval distribution (<code>what='SI'</code>, or
all three (<code>what='all'</code>)).</p>
</td></tr>
<tr><td><code id="plot.estimate_R_+3A_add_imported_cases">add_imported_cases</code></td>
<td>
<p>A boolean to specify whether, on the incidence time
series plot, to add the incidence of imported cases.</p>
</td></tr>
<tr><td><code id="plot.estimate_R_+3A_options_i">options_I</code></td>
<td>
<p>For what = &quot;incid&quot; or &quot;all&quot;. A list of graphical options:
</p>
 <dl>
<dt>col</dt><dd><p>A color or vector of colors used for plotting
incid. By default uses the default R colors.</p>
</dd>  <dt>transp</dt><dd><p>A numeric
value between 0 and 1 used to monitor transparency of the bars
plotted. Defaults to 0.7.</p>
</dd>  <dt>xlim</dt><dd><p>A parameter similar to that in
<code>par</code>, to monitor the limits of the horizontal axis</p>
</dd> <dt>ylim</dt><dd><p>A
parameter similar to that in <code>par</code>, to monitor the limits of the
vertical axis</p>
</dd> <dt>interval</dt><dd><p>An integer or character indicating the 
(fixed) size of the time interval used for plotting the incidence; 
defaults to 1 day.</p>
</dd> <dt>xlab, ylab</dt><dd><p>Labels for the axes of the 
incidence plot</p>
</dd></dl>
</td></tr>
<tr><td><code id="plot.estimate_R_+3A_options_r">options_R</code></td>
<td>
<p>For what = &quot;R&quot; or &quot;all&quot;. A list of graphical options:
</p>
 <dl>
<dt>col</dt><dd><p>A color or vector of colors used for plotting R. By
default uses the default R colors.</p>
</dd>  <dt>transp</dt><dd><p>A numeric value between
0 and 1 used to monitor transparency of the 95%CrI. Defaults to 0.2.</p>
</dd>
<dt>xlim</dt><dd><p>A parameter similar to that in <code>par</code>, to monitor the
limits of the horizontal axis</p>
</dd> <dt>ylim</dt><dd><p>A parameter similar to that in
<code>par</code>, to monitor the limits of the vertical axis</p>
</dd> 
<dt>xlab, ylab</dt><dd><p>Labels for the axes of the R plot</p>
</dd></dl>
</td></tr>
<tr><td><code id="plot.estimate_R_+3A_options_si">options_SI</code></td>
<td>
<p>For what = &quot;SI&quot; or &quot;all&quot;. A list of graphical options:
</p>
 <dl>
<dt>prob_min</dt><dd><p>A numeric value between 0 and 1. The SI
distributions explored are only shown from time 0 up to the time t so that
each distribution explored has probability &lt; <code>prob_min</code> to be on any
time step after t. Defaults to 0.001.</p>
</dd>  <dt>col</dt><dd><p>A color or vector of
colors used for plotting the SI. Defaults to black.</p>
</dd>  <dt>transp</dt><dd><p>A
numeric value between 0 and 1 used to monitor transparency of the
lines. Defaults to 0.25</p>
</dd> <dt>xlim</dt><dd><p>A parameter similar to that in
<code>par</code>, to monitor the limits of the horizontal axis</p>
</dd> <dt>ylim</dt><dd><p>A
parameter similar to that in <code>par</code>, to monitor the limits of the
vertical axis</p>
</dd> <dt>xlab, ylab</dt><dd><p>Labels for the axes of the serial interval
distribution plot</p>
</dd></dl>
</td></tr>
<tr><td><code id="plot.estimate_R_+3A_legend">legend</code></td>
<td>
<p>A boolean (TRUE by default) governing the presence / absence of
legends on the plots</p>
</td></tr>
<tr><td><code id="plot.estimate_R_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods (currently unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot (if <code>what = "incid"</code>, <code>"R"</code>, or <code>"SI"</code>) or a
<code><a href="grid.html#topic+grob">grob</a></code> object (if <code>what = "all"</code>).
</p>


<h3>Author(s)</h3>

<p>Rolina van Gaalen <a href="mailto:rolina.van.gaalen@rivm.nl">rolina.van.gaalen@rivm.nl</a> and Anne Cori
<a href="mailto:a.cori@imperial.ac.uk">a.cori@imperial.ac.uk</a>; S3 method by Thibaut Jombart
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_R">estimate_R</a></code>, 
<code><a href="#topic+wallinga_teunis">wallinga_teunis</a></code> and 
<code><a href="#topic+estimate_R_plots">estimate_R_plots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on pandemic flu in a school in 2009
data("Flu2009")

## estimate the instantaneous reproduction number
## (method "non_parametric_si")
R_i &lt;- estimate_R(Flu2009$incidence,
                  method = "non_parametric_si",
                  config = list(t_start = seq(2, 26), 
                                t_end = seq(8, 32), 
                                si_distr = Flu2009$si_distr
                               )
                 )

## visualise results
plot(R_i, legend = FALSE)

## estimate the instantaneous reproduction number
## (method "non_parametric_si")
R_c &lt;- wallinga_teunis(Flu2009$incidence, 
                       method = "non_parametric_si",
                       config = list(t_start = seq(2, 26), 
                                     t_end = seq(8, 32), 
                                     si_distr = Flu2009$si_distr
                                    )
                      )

## produce plot of the incidence
## (with, on top of total incidence, the incidence of imported cases),
## estimated instantaneous and case reproduction numbers
## and serial interval distribution used
p_I &lt;- plot(R_i, "incid", add_imported_cases=TRUE) # plots the incidence
p_SI &lt;- plot(R_i, "SI") # plots the serial interval distribution
p_Ri &lt;- plot(R_i, "R",
             options_R = list(ylim = c(0, 4)))
        # plots the estimated instantaneous reproduction number
p_Rc &lt;- plot(R_c, "R",
             options_R = list(ylim = c(0, 4)))
        # plots the estimated case reproduction number
gridExtra::grid.arrange(p_I, p_SI, p_Ri, p_Rc, ncol = 2)

</code></pre>

<hr>
<h2 id='sample_posterior_R'>sample from the posterior R distribution</h2><span id='topic+sample_posterior_R'></span>

<h3>Description</h3>

<p>sample from the posterior R distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_posterior_R(R, n = 1000, window = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_posterior_R_+3A_r">R</code></td>
<td>
<p>an <code>estimate_R</code> object from the estimate_r function
function.</p>
</td></tr>
<tr><td><code id="sample_posterior_R_+3A_n">n</code></td>
<td>
<p>an integer specifying the number of samples to be taken from the
gamma distribution.</p>
</td></tr>
<tr><td><code id="sample_posterior_R_+3A_window">window</code></td>
<td>
<p>an integer (or sequence of integers) specifying the window(s) 
from which to estimate R. Defaults to the first window. If multiple windows
are specified, the resulting samples will be drawn from several 
distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n values of R from the posterior R distribution
</p>


<h3>Author(s)</h3>

<p>Anne Cori
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## load data on pandemic flu in a school in 2009
data("Flu2009")

## estimate the reproduction number (method "non_parametric_si")
## when not specifying t_start and t_end in config, they are set to estimate
## the reproduction number on sliding weekly windows                          
res &lt;- estimate_R(incid = Flu2009$incidence, 
                  method = "non_parametric_si",
                  config = make_config(list(si_distr = Flu2009$si_distr)))

## Sample R from the first weekly window
win &lt;- 1L
R_median &lt;- res$R$`Median(R)`[win]
R_CrI &lt;- c(res$R$`Quantile.0.025(R)`[win], res$R$`Quantile.0.975(R)`[win])

set.seed(2019-06-06) # fixing the random seed for reproducibility
R_sample &lt;- sample_posterior_R(res, n = 1000, window = win)
hist(R_sample, col = "grey", main = "R sampled from the first weekly window")
abline(v = R_median, col = "red")       # show the median estimated R
abline(v = R_CrI, col = "red", lty = 2) # show the 95%CrI of R
</code></pre>

<hr>
<h2 id='SARS2003'>Data on the 2003 SARS epidemic in Hong Kong.</h2><span id='topic+SARS2003'></span>

<h3>Description</h3>

<p>This data set gives:
</p>

<ol>
<li><p> the daily incidence of onset of symptoms in Hong Kong during the 2003
severe acute respiratory syndrome (SARS) epidemic (see source and
references),
</p>
</li>
<li><p> the discrete daily distribution of the serial interval for SARS, assuming
a shifted Gamma distribution with mean 8.4 days, standard deviation 3.8
days and shift 1 day (see references).
</p>
</li></ol>



<h3>Format</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><strong>incidence:</strong> a vector containing 107 days of observation,
</p>
</li>
<li> <p><strong>si_distr:</strong> a vector containing a set of 25 probabilities.
</p>
</li></ul>


<h3>Source</h3>

<p>Cori A. et al. (2009) Temporal variability and social heterogeneity
in disease transmission: the case of SARS in Hong Kong. PLoS Comput Biol 5(8)
: e1000471.
</p>


<h3>References</h3>

<p>Cori A. et al. (2009) Temporal variability and social heterogeneity in
disease transmission: the case of SARS in Hong Kong. PLoS Comput Biol 5(8):
e1000471.
</p>
<p>Lipsitch M. et al. (2003) Transmission dynamics and control of severe acute
respiratory syndrome. Science 300(5627): 1966-1970.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on SARS in Hong Kong in 2003
data("SARS2003")

## estimate the reproduction number (method "non_parametric_si")
res &lt;- estimate_R(SARS2003$incidence, method="non_parametric_si",
          config = make_config(list(
                      t_start = seq(14, 101), 
                      t_end = seq(20, 107),
                      si_distr = SARS2003$si_distr)))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number
## over the 7-day window finishing on that day.
</code></pre>

<hr>
<h2 id='Smallpox1972'>Data on the 1972 smallpox epidemic in Kosovo</h2><span id='topic+Smallpox1972'></span>

<h3>Description</h3>

<p>This data set gives:
</p>

<ol>
<li><p> the daily incidence of onset of symptoms in Kosovo during the 1972
smallpox epidemic (see source and references),
</p>
</li>
<li><p> the discrete daily distribution of the serial interval for smallpox,
assuming a shifted Gamma distribution with mean 22.4 days, standard
deviation 6.1 days and shift 1 day (see references).
</p>
</li></ol>



<h3>Format</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><strong>incidence:</strong> a vector containing 57 days of observation,
</p>
</li>
<li> <p><strong>si_distr:</strong> a vector containing a set of 46 probabilities.
</p>
</li></ul>


<h3>Source</h3>

<p>Fenner F. et al. (1988) Smallpox and its Eradication. Geneva, World
Health Organization.
</p>


<h3>References</h3>

<p>Fenner F. et al. (1988) Smallpox and its Eradication. Geneva, World Health
Organization.
</p>
<p>Gani R. and S. Leach (2001) Transmission potential of smallpox in
contemporary populations. Nature 414(6865): 748-751.
</p>
<p>Riley S. and N. M. Ferguson (2006) Smallpox transmission and control: spatial
dynamics in Great Britain. Proc Natl Acad Sci U S A 103(33): 12637-12642.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on smallpox in Kosovo in 1972
data("Smallpox1972")

## estimate the reproduction number (method "non_parametric_si")
res &lt;- estimate_R(Smallpox1972$incidence, method="non_parametric_si",
          config = make_config(list(
                      t_start = seq(27, 51), 
                      t_end = seq(33, 57),
                      si_distr = Smallpox1972$si_distr)))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the reproduction number
## over the 7-day window finishing on that day.
</code></pre>

<hr>
<h2 id='wallinga_teunis'>Estimation of the case reproduction number using the Wallinga and Teunis
method</h2><span id='topic+wallinga_teunis'></span>

<h3>Description</h3>

<p><code>wallinga_teunis</code> estimates the case reproduction number of an epidemic,
given the incidence time series and the serial interval distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wallinga_teunis(
  incid,
  method = c("non_parametric_si", "parametric_si"),
  config
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wallinga_teunis_+3A_incid">incid</code></td>
<td>
<p>One of the following
</p>

<ul>
<li><p> Vector (or a dataframe with
a column named 'incid') of non-negative integers containing an incidence
time series. If the dataframe contains a column <code>incid$dates</code>, this is
used for plotting. <code>incid$dates</code> must contains only dates in a row.
</p>
</li>
<li><p> An object of class <code><a href="incidence.html#topic+incidence">incidence</a></code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="wallinga_teunis_+3A_method">method</code></td>
<td>
<p>the method used to estimate R, one of &quot;non_parametric_si&quot;,
&quot;parametric_si&quot;, &quot;uncertain_si&quot;, &quot;si_from_data&quot; or &quot;si_from_sample&quot;</p>
</td></tr>
<tr><td><code id="wallinga_teunis_+3A_config">config</code></td>
<td>
<p>a list with the following elements: </p>
 <ul>
<li><p>t_start:
Vector of positive integers giving the starting times of each window over
which the reproduction number will be estimated. These must be in ascending
order, and so that for all <code>i</code>, <code>t_start[i]&lt;=t_end[i]</code>.
t_start[1] should be strictly after the first day with non null incidence.
</p>
</li>
<li><p>t_end: Vector of positive integers giving the ending times of each
window over which the reproduction number will be estimated. These must be
in ascending order, and so that for all <code>i</code>,
<code>t_start[i]&lt;=t_end[i]</code>. </p>
</li>
<li><p>method: One of &quot;non_parametric_si&quot; or
&quot;parametric_si&quot; (see details). </p>
</li>
<li><p>mean_si: For method &quot;parametric_si&quot; ;
positive real giving the mean serial interval. </p>
</li>
<li><p>std_si: For method
&quot;parametric_si&quot; ; non negative real giving the standard deviation of the
serial interval. </p>
</li>
<li><p>si_distr: For method &quot;non_parametric_si&quot; ; vector
of probabilities giving the discrete distribution of the serial interval,
starting with <code>si_distr[1]</code> (probability that the serial interval is
zero), which should be zero. </p>
</li>
<li><p>n_sim: A positive integer giving the
number of simulated epidemic trees used for computation of the confidence
intervals of the case reproduction number (see details). </p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates of the case reproduction number for an epidemic over
predefined time windows can be obtained, for a given discrete distribution of
the serial interval, as proposed by Wallinga and Teunis (AJE, 2004).
Confidence intervals are obtained by simulating a number (config$n_sim) of
possible transmission trees (only done if config$n_sim &gt; 0).
</p>
<p>The methods vary in the way the serial interval distribution is specified.
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; <code>method "non_parametric_si"</code>
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p>The discrete distribution of the serial interval is directly specified in the
argument <code>config$si_distr</code>.
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; <code>method "parametric_si"</code> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p>The mean and standard deviation of the continuous distribution of the serial
interval are given in the arguments <code>config$mean_si</code> and
<code>config$std_si</code>. The discrete distribution of the serial interval is
derived automatically using <code><a href="#topic+discr_si">discr_si</a></code>.
</p>


<h3>Value</h3>

<p> a list with components: </p>
 <ul>
<li><p>R: a dataframe
containing: the times of start and end of each time window considered ; the
estimated mean, std, and 0.025 and 0.975 quantiles of the reproduction
number for each time window. </p>
</li>
<li><p>si_distr: a vector containing the
discrete serial interval distribution used for estimation
</p>
</li>
<li><p>SI.Moments: a vector containing the mean and std of the discrete
serial interval distribution(s) used for estimation </p>
</li>
<li><p>I: the time
series of total incidence </p>
</li>
<li><p>I_local: the time series of incidence of
local cases (so that <code>I_local + I_imported = I</code>) </p>
</li>
<li><p>I_imported:
the time series of incidence of imported cases (so that <code>I_local +
  I_imported = I</code>) </p>
</li>
<li><p>dates: a vector of dates corresponding to the
incidence time series </p>
</li></ul>
 


<h3>Author(s)</h3>

<p>Anne Cori <a href="mailto:a.cori@imperial.ac.uk">a.cori@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p> Cori, A. et al. A new framework and software to estimate
time-varying reproduction numbers during epidemics (AJE 2013). Wallinga, J.
and P. Teunis. Different epidemic curves for severe acute respiratory
syndrome reveal similar impacts of control measures (AJE 2004). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discr_si">discr_si</a></code>, <code><a href="#topic+estimate_R">estimate_R</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data on pandemic flu in a school in 2009
data("Flu2009")

## estimate the case reproduction number (method "non_parametric_si")
res &lt;- wallinga_teunis(Flu2009$incidence,
   method="non_parametric_si",
   config = list(t_start = seq(2, 26), t_end = seq(8, 32),
                 si_distr = Flu2009$si_distr,
                 n_sim = 100))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the case reproduction number over the 7-day window
## finishing on that day.

## estimate the case reproduction number (method "parametric_si")
res &lt;- wallinga_teunis(Flu2009$incidence, method="parametric_si",
   config = list(t_start = seq(2, 26), t_end = seq(8, 32),
                 mean_si = 2.6, std_si = 1.5,
                 n_sim = 100))
plot(res)
## the second plot produced shows, at each each day,
## the estimate of the case reproduction number over the 7-day window
## finishing on that day.
</code></pre>

<hr>
<h2 id='WT'>Function to ensure compatibility with EpiEstim versions &lt;2.0</h2><span id='topic+WT'></span>

<h3>Description</h3>

<p>Please only use for compatibility;
Prefer the new wallinga_teunis function instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WT(
  I,
  T.Start,
  T.End,
  method = c("NonParametricSI", "ParametricSI"),
  Mean.SI = NULL,
  Std.SI = NULL,
  SI.Distr = NULL,
  nSim = 10,
  plot = FALSE,
  leg.pos = "topright"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WT_+3A_i">I</code></td>
<td>
<p>see <code>incid</code> in <code>wallinga_teunis</code></p>
</td></tr>
<tr><td><code id="WT_+3A_t.start">T.Start</code></td>
<td>
<p>see <code>config$t_start</code> in <code>wallinga_teunis</code></p>
</td></tr>
<tr><td><code id="WT_+3A_t.end">T.End</code></td>
<td>
<p>see <code>config$t_end</code> in <code>wallinga_teunis</code></p>
</td></tr>
<tr><td><code id="WT_+3A_method">method</code></td>
<td>
<p>see method in <code>wallinga_teunis</code> (but WT uses CamelCase 
where wallinga_teunis uses snake_case for the method names)</p>
</td></tr>
<tr><td><code id="WT_+3A_mean.si">Mean.SI</code></td>
<td>
<p>see <code>config$mean_si</code> in <code>wallinga_teunis</code></p>
</td></tr>
<tr><td><code id="WT_+3A_std.si">Std.SI</code></td>
<td>
<p>see <code>config$std_si</code> in <code>wallinga_teunis</code></p>
</td></tr>
<tr><td><code id="WT_+3A_si.distr">SI.Distr</code></td>
<td>
<p>see <code>config$si_distr</code> in <code>wallinga_teunis</code></p>
</td></tr>
<tr><td><code id="WT_+3A_nsim">nSim</code></td>
<td>
<p>see <code>config$n_sim</code> in <code>wallinga_teunis</code></p>
</td></tr>
<tr><td><code id="WT_+3A_plot">plot</code></td>
<td>
<p>Not used anymore, only there for compatibility</p>
</td></tr>
<tr><td><code id="WT_+3A_leg.pos">leg.pos</code></td>
<td>
<p>Not used anymore, only there for compatibility</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
