<!DOCTYPE html><html lang="en"><head><title>Help for package stors</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stors}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#build_proposal'><p>Build Proposal</p></a></li>
<li><a href='#build_sampler'><p>Sampling Function for User Defined Density</p></a></li>
<li><a href='#delete_built_in_proposal'><p>Delete Built-in Proposal</p></a></li>
<li><a href='#delete_proposal'><p>Delete Proposal</p></a></li>
<li><a href='#load_proposal'><p>Load Stored Proposal</p></a></li>
<li><a href='#plot.proposal'><p>Plot Method for Proposal Objects</p></a></li>
<li><a href='#print_proposals'><p>Print proposals</p></a></li>
<li><a href='#print.proposal'><p>Print Method for proposal Objects</p></a></li>
<li><a href='#save_proposal'><p>Save User Proposal</p></a></li>
<li><a href='#srbeta_custom'><p>Sampling from Beta Distribution</p></a></li>
<li><a href='#srbeta_optimize'><p>Optimizing Beta Distribution proposal</p></a></li>
<li><a href='#srchisq_custom'><p>Sampling from Chi-squared Distribution</p></a></li>
<li><a href='#srchisq_optimize'><p>Optimizing Chi-squared Distribution proposal</p></a></li>
<li><a href='#srexp'><p>Sampling from Exponential Distribution</p></a></li>
<li><a href='#srexp_optimize'><p>Optimizing Exponential Distribution proposal</p></a></li>
<li><a href='#srgamma_custom'><p>Sampling from Gamma Distribution</p></a></li>
<li><a href='#srgamma_optimize'><p>Optimizing Gamma Distribution proposal</p></a></li>
<li><a href='#srlaplace'><p>Sampling from Laplace Distribution</p></a></li>
<li><a href='#srlaplace_optimize'><p>Optimizing Laplace Distribution proposal</p></a></li>
<li><a href='#srnorm'><p>Sampling from Normal Distribution</p></a></li>
<li><a href='#srnorm_optimize'><p>Optimizing Normal Distribution proposal</p></a></li>
<li><a href='#srpareto_custom'><p>Sampling from Pareto Distribution</p></a></li>
<li><a href='#srpareto_optimize'><p>Optimizing Pareto Distribution proposal</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Step Optimised Rejection Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ahmad ALQabandi &lt;ahmad.alqabandi@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast and efficient sampling from general univariate probability
    density functions. Implements a rejection sampling approach designed to take
    advantage of modern CPU caches and minimise evaluation of the target
    density for most samples. Many standard densities are internally implemented
    in 'C' for high performance, with general user defined densities also
    supported. A paper describing the methodology will be released soon.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, microbenchmark, cli, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), ggplot2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ahmad-alqabandi.github.io/stors/">https://ahmad-alqabandi.github.io/stors/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-10 14:23:28 UTC; ahmad</td>
</tr>
<tr>
<td>Author:</td>
<td>Ahmad ALQabandi <a href="https://orcid.org/0009-0006-0055-3846"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, cph],
  Louis Aslett <a href="https://orcid.org/0000-0003-2211-233X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-11 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='build_proposal'>Build Proposal</h2><span id='topic+build_proposal'></span>

<h3>Description</h3>

<p>Constructs the step optimized proposal density, squeezing function, and log-linear tail proposal for a user defined probability density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_proposal(
  f,
  modes,
  lower = -Inf,
  upper = Inf,
  h = NULL,
  h_prime = NULL,
  steps = NULL,
  proposal_range = NULL,
  theta = 0.1,
  target_sample_size = 1000,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_proposal_+3A_f">f</code></td>
<td>
<p>A function which returns the (unnormalised) probability density function of the target distribution.
The first argument must be the value at which the pdf is to be evaluated.
Additional arguments may be parameters of the distribution, which should be specified by name in the <code>...</code> arguments.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_modes">modes</code></td>
<td>
<p>Numeric vector of modes of the density function.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_lower">lower</code></td>
<td>
<p>Numeric scalar representing the lower bound of the target density.
Default is <code>-Inf</code> for unbounded lower support.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_upper">upper</code></td>
<td>
<p>Numeric scalar representing the upper bound of the target density.
Default is <code>Inf</code> for unbounded upper support.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_h">h</code></td>
<td>
<p>An optional function which returns the (unnormalised) log-probability density function of the target distribution.
As for <code>f</code> the first argument must be the value at which the log-pdf is to be evaluated and additional parameters may be named arguments passed to <code>...</code>.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_h_prime">h_prime</code></td>
<td>
<p>An optional function which returns the first derivative of the (unnormalised) log-probability density function of the target distribution.
As for <code>f</code> the first argument must be the value at which the log-pdf is to be evaluated and additional parameters may be named arguments passed to <code>...</code>.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_steps">steps</code></td>
<td>
<p>Optional integer scalar specifying the number of steps in the step optimised part of the proposal density and squeezing function.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_proposal_range">proposal_range</code></td>
<td>
<p>Optional numeric vector of length 2 specifying the lower and upper range of the steps in the step optimised part of the proposal density and squeezing function.
This range should be contained within the interval defined by <code>lower</code> and <code>upper</code>.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_theta">theta</code></td>
<td>
<p>Optional numeric scalar (between 0.1 and 1) defining the pre-acceptance threshold.
This dictates when no further steps should be added in the step optimised part of the proposal density and squeezing function, based on the probability of pre-acceptance.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_target_sample_size">target_sample_size</code></td>
<td>
<p>Integer scalar indicating the typical sample size that will be requested when sampling from this density using build_sampler.
The proposal optimization process bases benchmark timings on this target size in order to select a proposal best suited to the desired sample size.
Note this does <em>not</em> limit sampling to this number, it is merely a guide should the user be aware that a certain sample size will be most commonly sampled.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar.
If <code>TRUE</code>, a table detailing the optimization areas and steps will be displayed during proposal optimization.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="build_proposal_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>f</code>, <code>h</code>, and <code>h_prime</code>, if they depend on additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the starting point when a user wishes to build a custom sampler using StORS.
It is responsible for generating the step optimized proposal density, squeezing function, and log-linear tail proposal that can be utilized for this purpose.
The minimum information that must be supplied by the user is:
</p>

<ul>
<li><p> The (closed) interval of support for the distribution, [<code>lower</code>, <code>upper</code>] <code class="reqn">\in \mathbb{R}</code>, which may also be half-closed on either side, or all of <code class="reqn">\mathbb{R}</code>.
</p>
</li>
<li><p> The probability density function (pdf), which need not be normalised, <code>f</code>.
</p>
</li>
<li><p> Any modes of the pdf, as vector <code>modes</code>.
</p>
</li></ul>

<p>Optionally, the log-pdf and derivative of the log-pdf may be supplied.
</p>
<p><strong>Arguments for pdf</strong>
</p>
<p>The pdf (and log-pdf and first derivative of the log-pdf) may depend on certain parameters.
If so, these can be from the second argument onward in <code>f</code>.
For instance, consider the Kumaraswamy distribution, which has pdf:
</p>
<p style="text-align: center;"><code class="reqn">f(x; a,b) = a b x^{a-1}{ (1-x^a)}^{b-1},  \ \ \mbox{where} \ \ x \in (0,1)</code>
</p>

<p>This pdf has known modes.
</p>
<p>Then, to implement as a custom StORS sampler, we would first define the pdf in R:
</p>
<p><code>dkumaraswamy &lt;- function(x, a, b) a*b*(x^(a-1))*(1-x^a)^(b-1)</code>
</p>
<p>Then, to construct a StORS proposal for <code class="reqn">a=2</code> and <code class="reqn">b=2</code>, we would call
</p>
<p><code>Proposal &lt;- build_Proposal(lower = 0, upper = 1, modes = sqrt(1/3), f = dkumaraswamy, a = 2, b = 2)</code>
</p>
<p><strong>StORS proposal construction</strong>
</p>
<p>StORS defines an unnormalised piecewise constant proposal density and squeezing function, with a Proposal defining the change points.
To optimise the execution speed on modern CPUs, the unnormalised piecewise constant proposal has fixed area for each segment with one end of the segment coinciding with the user's pdf.
That is, each step of the function has width defined by <code class="reqn">w_i = (x_i - x_{i-1})</code> and a height determined by <code class="reqn">h_i = \max(f(x_{i-1}), f(x_i))</code>, such that <code class="reqn">w_i h_i = \alpha \ \forall\,i</code> where <code class="reqn">\alpha</code> is constant.
</p>
<p>Once the user has constructed the proposal, the sampling function can be built using <code><a href="#topic+build_sampler">build_sampler()</a></code>.
</p>
<p><strong>Internal details</strong>
</p>
<p>The function <code>build_final_Proposal()</code> manages the construction of these steps and calculates values critical for the sampling process.
When the resultant Proposal is used with the <code>build_sampler()</code> function, these values are cached,
significantly enhancing the computational efficiency and hence improving sampling speed.
During the optimization process, we aim for a certain Proposal
size based on L1-3 memory cache size. Therefore, we test the speed of Proposals of sizes <code class="reqn">2^m</code> Kb.
To achieve this, we estimate the uniform step area
based on a certain steps number that leads to the target cache size,
<code class="reqn"> \alpha = \frac{1}{\text{number of steps}} </code>.
</p>
<p>The speed testing for each possible Proposal is initially based on a sample size of 1000.
However, if the user wishes to optimize the Proposal for a different sample size, they can do so
by specifying the desired sample size using the <code>target_sample_size</code> argument.
</p>
<p>In case the user wants to select a specific number of steps for the proposal
and bypass the optimization process, this can be done by specifying a steps number greater than the number of modes by 2 using the <code>steps</code> argument.
If the target density is heavy-tailed,
and the user wishes to stop the Proposal building process at a certain pre-acceptance threshold, this can be achieved by setting
the acceptance probability threshold <code>theta</code> <code class="reqn">\theta</code>.
Once the steps reach this level of pre-acceptance probability,
the step construction will end <code class="reqn"> \frac{\min(f(x_i), f(x_{i+1}))}{\max(f(x_i), f(x_{i+1}))} &lt; \theta </code>.
Alternatively, if the user wishes to create the steps within certain limits on the
x-axis, they can do so by specifying the proposal limits using the <code>proposal_range</code> argument.
</p>


<h3>Value</h3>

<p>This returns a list which is used to construct the sampler by passing to <code><a href="#topic+build_sampler">build_sampler</a></code> function.
</p>
<p>A list containing the optimized proposal and related parameters for the specified built-in distribution:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame with detailed information about the proposal steps, including:
</p>

<dl>
<dt><code>x</code></dt><dd><p>The start point of each step on the x-axis.</p>
</dd>
<dt><code>s_upper</code></dt><dd><p>The height of each step on the y-axis.</p>
</dd>
<dt><code>p_a</code></dt><dd><p>Pre-acceptance probability for each step.</p>
</dd>
<dt><code>s_upper_lower</code></dt><dd><p>A vector used to scale the uniform random number when the sample is accepted.</p>
</dd>
</dl>
</dd>
<dt><code>areas</code></dt><dd><p>A numeric vector containing the areas under:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The left tail bound.</p>
</dd>
<dt><code>steps</code></dt><dd><p>The middle steps.</p>
</dd>
<dt><code>right_tail</code></dt><dd><p>The right tail bound.</p>
</dd>
</dl>
</dd>
<dt><code>steps_number</code></dt><dd><p>An integer specifying the number of steps in the proposal.</p>
</dd>
<dt><code>sampling_probabilities</code></dt><dd><p>A numeric vector with:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The probability of sampling from the left tail.</p>
</dd>
<dt><code>left_and_middle</code></dt><dd><p>The combined probability of sampling from the left tail and middle steps.</p>
</dd>
</dl>
</dd>
<dt><code>unif_scaler</code></dt><dd><p>A numeric scalar, the inverse probability of sampling from the steps part of the proposal (<code class="reqn">\frac{1}{p(lower &lt; x &lt; upper)}</code>). Used for scaling uniform random values.</p>
</dd>
<dt><code>lt_properties</code></dt><dd><p>A numeric vector of 5 values required for Adaptive Rejection Sampling (ARS) in the left tail.</p>
</dd>
<dt><code>rt_properties</code></dt><dd><p>A numeric vector of 6 values required for ARS in the right tail.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric scalar representing the uniform step area.</p>
</dd>
<dt><code>tails_method</code></dt><dd><p>A string, either <code>"ARS"</code> (Adaptive Rejection Sampling) or <code>"IT"</code> (Inverse Transform), indicating the sampling method for the tails.</p>
</dd>
<dt><code>proposal_bounds</code></dt><dd><p>A numeric vector specifying the left and right bounds of the target density.</p>
</dd>
<dt><code>cnum</code></dt><dd><p>An integer representing the cache number of the created proposal in memory.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>A numeric scalar indicating the symmetry point of the proposal, or <code>NULL</code> if not symmetric.</p>
</dd>
<dt><code>f_params</code></dt><dd><p>A list of parameters for the target density that the proposal is designed for.</p>
</dd>
<dt><code>is_symmetric</code></dt><dd><p>A logical value indicating whether the proposal is symmetric.</p>
</dd>
<dt><code>proposal_type</code></dt><dd><p>A string indicating the type of the generated proposal:
</p>

<dl>
<dt><code>"scaled"</code></dt><dd><p>The proposal is &quot;scalable&quot; and standardized with <code>rate = 1</code>. This is used when parameter <code>rate</code> is either <code>NULL</code> or not provided. Scalable proposals are compatible with <code><a href="#topic+srexp">srexp</a></code>.</p>
</dd>
<dt><code>"custom"</code></dt><dd><p>The proposal is &quot;custom&quot; when <code>rate</code> is provided. Custom proposals are compatible with <code><a href="#topic+srexp_custom">srexp_custom</a></code>.</p>
</dd>
</dl>
</dd>
<dt><code>target_function_area</code></dt><dd><p>A numeric scalar estimating the area of the target distribution.</p>
</dd>
<dt><code>dens_func</code></dt><dd><p>A string containing the hardcoded density function.</p>
</dd>
<dt><code>density_name</code></dt><dd><p>A string specifying the name of the target density distribution.</p>
</dd>
<dt><code>lock</code></dt><dd><p>An identifier used for saving and loading the proposal from disk.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+build_sampler">build_sampler</a></code>: Function to build and return a sampling function based on the provided proposal properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: Building a proposal for Standard Normal Distribution
# This example demonstrates constructing a proposal for a standard normal distribution
# \( f(x) \sim \mathcal{N}(0,1) \),
# and shows the optimization table by setting \code{verbose} to \code{TRUE}.

# Define the density function, its logarithm,
# and its derivative for the standard normal distribution
modes_norm = 0
f_norm &lt;- function(x) { 1 / sqrt(2 * pi) * exp(-0.5 * x^2) }
h_norm &lt;- function(x) { log(f_norm(x)) }
h_prime_norm &lt;- function(x) { -x }

# Following example takes slightly too long to run on CRAN.

# Build the proposal for the standard normal distribution
norm_proposal = build_proposal(lower = -Inf, upper = Inf, mode = modes_norm,
 f = f_norm, h = h_norm, h_prime = h_prime_norm, verbose = TRUE)

# Plot the generated proposal
plot(norm_proposal)


# Example 2: proposal for a Bimodal Distribution
# This example shows how to build a proposal for sampling from a bimodal distribution,
#combining two normal distributions
# \( f(x) = 0.5 \cdot w_1(x) + 0.5 \cdot w_2(x) \),
# where \( w_1(x) \sim \mathcal{N}(0, 1) \) and \( w_2(x) \sim \mathcal{N}(4, 1) \).

# Define the bimodal density function
f_bimodal &lt;- function(x) {
  0.5 * (1 / sqrt(2 * pi)) * exp(-(x^2) / 2) + 0.5 * (1 / sqrt(2 * pi)) * exp(-((x - 4)^2) / 2)
}
modes_bimodal = c(0.00134865, 3.99865)

# Build the proposal for the bimodal distribution
bimodal_proposal = build_proposal( f = f_bimodal, lower = -Inf, upper = Inf, mode = modes_bimodal)

# Print and plot the bimodal proposal
print(bimodal_proposal)
plot(bimodal_proposal)

# Example 3: Proposal with 500 Steps for Bimodal Distribution
# This example demonstrates constructing a proposal with 500 steps,
# for the bimodal distribution used in Example 2.

bimodal_proposal_500 = build_proposal(f = f_bimodal, lower = -Inf, upper = Inf,
 mode = modes_bimodal, steps = 500)

# Print and plot the proposal with 500 steps
print(bimodal_proposal_500)

</code></pre>

<hr>
<h2 id='build_sampler'>Sampling Function for User Defined Density</h2><span id='topic+build_sampler'></span>

<h3>Description</h3>

<p>This function generates a sampling function based on a proposal created by the user using the <code>build_proposal()</code> function.
The resulting sampling function can then be used to produce samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_sampler(proposal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_sampler_+3A_proposal">proposal</code></td>
<td>
<p>The sampling proposal created using the <code>build_proposal()</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After a user creates a proposal for their desired sampling function using <code><a href="#topic+build_proposal">build_proposal</a></code>,
this proposal must be passed to <code>build_sampler()</code> to create a sampling function for the target distribution.
<code>build_sampler()</code> first checks whether the proposal was indeed created using <code>build_proposal()</code>. If the user has altered
or modified the proposal returned from <code>build_proposal()</code>, <code>build_sampler()</code> will reject the altered proposal; therefore,
no changes should be made to the proposal after its creation. Once the proposal is accepted by <code>build_sampler()</code>, it is
cached in memory, allowing fast access to proposal data for the compiled C code and reducing memory access latency.
Subsequently, <code>build_sampler()</code> returns a function that can be utilized to generate samples from the target distribution,
</p>


<h3>Value</h3>

<p>Returns a function that can be used to generate samples from the specified <code>proposal</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# To sample from a standard normal distribution \( f(x) \sim \mathcal{N}(0,1) \),
# first build the proposal using \code{build_proposal()}

modes_norm = 0
f_norm &lt;- function(x) { 1 / sqrt(2 * pi) * exp(-0.5 * x^2) }
h_norm &lt;- function(x) { log(f_norm(x)) }
h_prime_norm &lt;- function(x) { -x }
normal_proposal = build_proposal(lower = -Inf, upper = Inf, mode = modes_norm,
 f = f_norm, h = h_norm, h_prime = h_prime_norm, steps = 1000)

# Generate samples from the standard normal distribution
sample_normal &lt;- build_sampler(normal_proposal)
hist(sample_normal(100), main = "Normal Distribution Samples")


# Example 2
# Let's consider a bimodal distribution composed of two normal distributions:
# The first normal distribution N(0,1) with weight p = 0.3,
# and the second normal distribution N(4,1) with weight q = 0.7.

f_bimodal &lt;- function(x) {
 0.3 * (1 / sqrt(2 * pi) * exp(-0.5 * (x - 0)^2)) +
 0.7 * (1 / sqrt(2 * pi) * exp(-0.5 * (x - 4)^2))
}

# Define the modes of the bimodal distribution
   modes_bimodal &lt;- c(0.00316841, 3.99942)

# Build the proposal for the bimodal distribution
bimodal_proposal = build_proposal(f = f_bimodal, modes = modes_bimodal,
 lower = -Inf, upper = Inf, steps = 1000)

# Create the sampling function using \code{build_sampler()}
sample_bimodal &lt;- build_sampler(bimodal_proposal)

# Generate and plot samples from the bimodal distribution
bimodal_samples &lt;- sample_bimodal(1000)
hist(bimodal_samples, breaks = 30, main = "Bimodal Distribution Samples")

# Create the truncated sampling function using
# \code{build_sampler()} with truncation bounds [-0.5, 6]
truncated_bimodal_proposal &lt;- build_proposal(f = f_bimodal,
 modes = modes_bimodal, lower = -0.5, upper = 6, steps = 1000)

# Create the sampling function using \code{build_sampler()}
sample_truncated_bimodal &lt;- build_sampler(truncated_bimodal_proposal)

# Generate and plot samples from the truncated bimodal distribution
truncated_sample &lt;- sample_truncated_bimodal(1000)
hist(truncated_sample, breaks = 30, main = "Truncated Bimodal Distribution Samples")


</code></pre>

<hr>
<h2 id='delete_built_in_proposal'>Delete Built-in Proposal</h2><span id='topic+delete_built_in_proposal'></span>

<h3>Description</h3>

<p>This function deletes built-in proposals from disk by specifying the sampling function and proposal type.
It is useful for managing cached proposals and freeing up storage space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_built_in_proposal(sampling_function, proposal_type = "custom")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete_built_in_proposal_+3A_sampling_function">sampling_function</code></td>
<td>
<p>String. The name of the sampling distribution's function in STORS.
For example, <code>"srgamma"</code> or <code>"srchisq"</code>.</p>
</td></tr>
<tr><td><code id="delete_built_in_proposal_+3A_proposal_type">proposal_type</code></td>
<td>
<p>String. Either <code>"custom"</code> to delete the custom proposal or <code>"scaled"</code> to delete the scaled proposal.
Defaults to <code>"custom"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function looks for the specified proposal type associated with the sampling function in the built-in proposals directory.
If the proposal exists, it deletes the corresponding proposal file from disk and frees its cached resources.
If the specified sampling function or proposal type does not exist, an error is thrown.
</p>


<h3>Value</h3>

<p>A message indicating the status of the deletion process, or an error if the operation fails.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following examples are not run, since if they are run the srgamma and
# srnorm samplers will no longer work until a new grid is built for them.
# This causes problems if the examples are run by CRAN checks or the website
# build system.
## Not run: 
# Delete a custom proposal for the srgamma function (uncomment to run)
delete_built_in_proposal(sampling_function = "srgamma", proposal_type = "custom")

# Delete a scaled proposal for the srnorm function (uncomment to run)
delete_built_in_proposal(sampling_function = "srnorm", proposal_type = "scaled")

## End(Not run)

</code></pre>

<hr>
<h2 id='delete_proposal'>Delete Proposal</h2><span id='topic+delete_proposal'></span>

<h3>Description</h3>

<p>This function deletes a proposal that was previously stored by the user using the <code>save_proposal()</code> function. It is useful for managing stored proposals and freeing up space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_proposal(proposal_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete_proposal_+3A_proposal_name">proposal_name</code></td>
<td>
<p>A string specifying the name of the proposal to be deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>proposal_name</code> does not exist, the function returns an error message. If the proposal exists and is successfully deleted, a message confirming its successful removal will be displayed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, let's create a proposal to sample from a standard normal distribution
f_normal &lt;- function(x) { 0.3989423 * exp(-0.5 * x^2) }
normal_proposal = build_proposal(f = f_normal, modes = 0, lower = -Inf, upper = Inf, steps = 1000)
print(normal_proposal)

# Then, save this proposal in R's internal data directory using
# `save_proposal()` with the name "normal"
save_proposal(normal_proposal, "normal")

# Now, we can print all proposals stored on this machine using `print_proposals()`
print_proposals()

# The list will include the `normal_proposal` stored under the name "normal"

# To delete the "normal" proposal from the machine, pass its name to `delete_proposal`
delete_proposal("normal")

# Now, when we print all stored proposals, the "normal" proposal will no longer be listed
print_proposals()

</code></pre>

<hr>
<h2 id='load_proposal'>Load Stored Proposal</h2><span id='topic+load_proposal'></span>

<h3>Description</h3>

<p>This function loads a proposal into memory that was previously saved using the <code>save_proposal()</code> function. It is useful for retrieving saved proposals for further analysis or processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_proposal(proposal_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_proposal_+3A_proposal_name">proposal_name</code></td>
<td>
<p>A string specifying the name of the proposal to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list representing the proposal stored under <code>proposal_name</code> in R's internal data directory. If the proposal corresponding to the specified name does not exist, an error message is displayed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, let's create a proposal to sample from a standard normal distribution
f_normal &lt;- function(x) { 0.3989423 * exp(-0.5 * x^2) }
normal_proposal = build_proposal(f = f_normal, modes = 0, lower = -Inf, upper = Inf, steps = 1000)
print(normal_proposal)

# Then, save this proposal in R's internal data directory using
# `save_proposal()` with the name "normal"
save_proposal(normal_proposal, "normal")

# Now, in case the R session is restarted and the proposal is no longer in memory,
# it can be loaded from the machine as follows:
loaded_normal_proposal &lt;- load_proposal("normal")
print(loaded_normal_proposal)
</code></pre>

<hr>
<h2 id='plot.proposal'>Plot Method for Proposal Objects</h2><span id='topic+plot.proposal'></span>

<h3>Description</h3>

<p>This function evaluates the properties of the included target and proposal functions to create a plot for both functions. In cases where the
proposal function's steps part is too dense, <code>x_min</code> and <code>x_max</code> can be set to crop and scale the chart for better visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'proposal'
plot(x, x_min = NA, x_max = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.proposal_+3A_x">x</code></td>
<td>
<p>A list generated using STORS' <code>build_proposal()</code> or <code>proposal_optimizer()</code> functions.</p>
</td></tr>
<tr><td><code id="plot.proposal_+3A_x_min">x_min</code></td>
<td>
<p>A scalar that represents the left cropping of the chart on the x-axis.</p>
</td></tr>
<tr><td><code id="plot.proposal_+3A_x_max">x_max</code></td>
<td>
<p>A scalar that represents the right cropping of the chart on the x-axis.</p>
</td></tr>
<tr><td><code id="plot.proposal_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method extends the generic <code>plot()</code> function for objects of class <code>proposal</code>.
It offers custom plotting functionality specifically designed for visualizing proposal objects.
</p>


<h3>Value</h3>

<p>A plot of the target density and proposal. If <code>ggplot2</code> is available, it returns a <code>ggplot</code> object representing the plot. otherwise, it uses the base <code>plot()</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.proposal">print.proposal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define the density function, its logarithm,
# and its derivative for the standard normal distribution
modes_norm = 0
f_norm &lt;- function(x) { 1 / sqrt(2 * pi) * exp(-0.5 * x^2) }
h_norm &lt;- function(x) { log(f_norm(x)) }
h_prime_norm &lt;- function(x) { -x }

# Build a dense proposal for the standard normal distribution
norm_proposal = build_proposal(lower = -Inf, upper = Inf, mode = modes_norm,
 f = f_norm, h = h_norm, h_prime = h_prime_norm, steps = 4000)

# Plot the generated proposal
plot(norm_proposal)

# To visualize the proposal in a cropped area between -0.1 and 0
plot(norm_proposal, x_min = -0.1, x_max = 0)

</code></pre>

<hr>
<h2 id='print_proposals'>Print proposals</h2><span id='topic+print_proposals'></span>

<h3>Description</h3>

<p>This function prints details of all proposals stored by the user. It provides information on each proposal, including the proposal name, size, efficiency, and other relevant details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_proposals()
</code></pre>


<h3>Value</h3>

<p>Prints a summary of all proposals, but does not return any value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, let's create a proposal to sample from a standard normal distribution
f_normal &lt;- function(x) { 0.3989423 * exp(-0.5 * x^2) }
normal_proposal = build_proposal(f = f_normal, modes = 0, lower = -Inf, upper = Inf, steps = 1000)
print(normal_proposal)

# `print_proposals()` prints all proposals stored in R's internal data directory.
# To see this, we first save `normal_proposal` using `save_proposal()`
save_proposal(normal_proposal, "normal")

# Since `normal_proposal` is now stored on this machine,
# we can confirm this by printing all saved proposals
print_proposals()

# Example 2: Create and Save a proposal for a Bimodal Distribution
f_bimodal &lt;- function(x) {
  0.5 * (1 / sqrt(2 * pi)) * exp(-(x^2) / 2) +
  0.5 * (1 / sqrt(2 * pi)) * exp(-((x - 4)^2) / 2)
}
modes_bimodal = c(0, 4)
bimodal_proposal = build_proposal(f = f_bimodal, modes = modes_bimodal,
lower = -Inf, upper = Inf, steps = 1000)

save_proposal(bimodal_proposal, "bimodal")
print(bimodal_proposal)

# To print all stored proposals after saving bimodal_proposal
print_proposals()

</code></pre>

<hr>
<h2 id='print.proposal'>Print Method for proposal Objects</h2><span id='topic+print.proposal'></span>

<h3>Description</h3>

<p>The function displays detailed information about the proposal object created by STORS' <code>build_proposal()</code> or <code>proposal_optimizer()</code> functions.
This includes the number of steps within the proposal, the range of values covered by the proposal, and the proposal's sampling efficiency.
This information is crucial for understanding the structure and performance of the proposal in sampling processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'proposal'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.proposal_+3A_x">x</code></td>
<td>
<p>A list generated using STORS' <code>build_proposal()</code> or <code>proposal_optimizer()</code> functions.</p>
</td></tr>
<tr><td><code id="print.proposal_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>print</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method extends the generic <code>print</code> function for objects of class <code>proposal</code>.
It prints the provided proposal's features such as the number of steps, steps limit, and efficiency.
</p>


<h3>Value</h3>

<p>Prints a summary of the proposal's properties, but does not return any value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define the density function, its logarithm,
#and its derivative for the standard normal distribution
modes_norm = 0
f_norm &lt;- function(x) { 1 / sqrt(2 * pi) * exp(-0.5 * x^2) }
h_norm &lt;- function(x) { log(f_norm(x)) }
h_prime_norm &lt;- function(x) { -x }

# Build a dense proposal for the standard normal distribution
norm_proposal = build_proposal(lower = -Inf, upper = Inf, mode = modes_norm,
 f = f_norm, h = h_norm, h_prime = h_prime_norm, steps = 1000)

# Print the properties of the generated proposal

print(norm_proposal)
</code></pre>

<hr>
<h2 id='save_proposal'>Save User Proposal</h2><span id='topic+save_proposal'></span>

<h3>Description</h3>

<p>This function stores proposals generated by the <code>build_proposal()</code> function in R's internal data directory. It is useful when users want to reuse a proposal across multiple R sessions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_proposal(proposal, proposal_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_proposal_+3A_proposal">proposal</code></td>
<td>
<p>list representing an optimized proposal generated using the <code>build_proposal()</code> function.</p>
</td></tr>
<tr><td><code id="save_proposal_+3A_proposal_name">proposal_name</code></td>
<td>
<p>string specifying the name under which the proposal will be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will produce an error if the proposal is not generated by the <code>build_proposal()</code> function. Otherwise, it successfully saves the proposal without returning any value upon completion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, let's create a proposal to sample from a standard normal distribution
f_normal &lt;- function(x) { 0.3989423 * exp( -0.5 * x^2) }
normal_proposal = build_proposal(f = f_normal, modes = 0, lower = -Inf, upper = Inf, steps = 1000)
print(normal_proposal)

# Then, we can save this proposal in R's internal data directory using `save_proposal()`
# with the name "normal"
save_proposal(normal_proposal, "normal")

# To make sure the `normal_proposal` has been stored in R's internal data directory,
# we can print all saved proposals using `print_proposals()`
print_proposals()


</code></pre>

<hr>
<h2 id='srbeta_custom'>Sampling from Beta Distribution</h2><span id='topic+srbeta_custom'></span>

<h3>Description</h3>

<p>The <code>srbeta_custom()</code> function generates random samples from a Beta distribution using the STORS algorithm.
It employs an optimized proposal distribution around the mode and Adaptive Rejection Sampling (ARS) for the tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srbeta_custom(n = 1, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srbeta_custom_+3A_n">n</code></td>
<td>
<p>Integer, length 1. Number of samples to draw.</p>
</td></tr>
<tr><td><code id="srbeta_custom_+3A_x">x</code></td>
<td>
<p>(optional) Numeric vector of length <code class="reqn">n</code>. If provided, this vector is overwritten in place to avoid any memory allocation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Beta Distribution
</p>
<p>The Beta distribution has the probability density function (PDF):
</p>
<p style="text-align: center;"><code class="reqn">f(x | \alpha, \beta) = \frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)} x^{\alpha - 1} (1 - x)^{\beta - 1}, \quad 0 \leq x \leq 1,</code>
</p>

<p>where:
</p>

<dl>
<dt><code class="reqn">\alpha</code></dt><dd><p>is the first shape parameter (<code class="reqn">\alpha &gt; 0</code>).</p>
</dd>
<dt><code class="reqn">\beta</code></dt><dd><p>is the second shape parameter (<code class="reqn">\beta &gt; 0</code>).</p>
</dd>
</dl>

<p>The Beta distribution is widely used in Bayesian statistics and in modelling probabilities and proportions.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code> containing random samples from the Beta distribution.
The <code>shape1</code> and <code>shape2</code> parameters are specified during the optimization process using <code>srbeta_optimize()</code>.
</p>
<p><b>NOTE:</b> When the <code>x</code> parameter is specified, it is updated in-place with the simulation for performance reasons.
</p>


<h3>TODO : This density instead of this function.</h3>

<p>This function samples from a proposal constructed using <code><a href="#topic+srbeta_optimize">srbeta_optimize</a></code>, employing the STORS algorithm.
</p>
<p>By default, <code>srbeta_custom()</code> samples from the standard Beta distribution with <code>shape1 = 1</code> and <code>shape2 = 1</code>.
The proposal distribution is pre-optimized at package load time using <code>srbeta_optimize()</code> with
<code>steps = 4091</code>, creating a scalable proposal centred around the mode.
</p>


<h3>Note</h3>

<p>This function is not scalable. Therefore, only the <code>srbeta_custom()</code> version is available, which requires the proposal to be pre-optimized using <code>srbeta_optimize()</code> before calling this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srbeta_optimize">srbeta_optimize</a></code> to optimize the custom proposal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 10 samples from Beta Distribution
samples &lt;- srbeta_custom(10)
print(samples)

# Generate 10 samples using a pre-allocated vector
x &lt;- numeric(10)
srbeta_custom(10, x = x)
print(x)

</code></pre>

<hr>
<h2 id='srbeta_optimize'>Optimizing Beta Distribution proposal</h2><span id='topic+srbeta_optimize'></span>

<h3>Description</h3>

<p>The <code>srbeta_optimize()</code> function generates an optimized proposal for a targeted Beta distribution.
The proposal can be customized and adjusted based on various options provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srbeta_optimize(
  shape1 = 2,
  shape2 = 2,
  xl = 0,
  xr = 1,
  steps = NULL,
  proposal_range = NULL,
  theta = 0.1,
  target_sample_size = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srbeta_optimize_+3A_shape1">shape1</code></td>
<td>
<p>(optional) Numeric. The first shape parameter (<code class="reqn">\alpha</code>) of the Beta distribution. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="srbeta_optimize_+3A_shape2">shape2</code></td>
<td>
<p>(optional) Numeric. The second shape parameter (<code class="reqn">\beta</code>) of the Beta distribution. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="srbeta_optimize_+3A_xl">xl</code></td>
<td>
<p>Numeric. Left truncation bound for the target distribution. Defaults to <code>0</code>, as the Beta distribution is defined only on the interval <code>[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="srbeta_optimize_+3A_xr">xr</code></td>
<td>
<p>Numeric. Right truncation bound for the target distribution. Defaults to <code>1</code>, as the Beta distribution is defined only on the interval <code>[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="srbeta_optimize_+3A_steps">steps</code></td>
<td>
<p>(optional) Integer. Desired number of steps in the proposal. Defaults to <code>4091</code>.</p>
</td></tr>
<tr><td><code id="srbeta_optimize_+3A_proposal_range">proposal_range</code></td>
<td>
<p>(optional) Numeric vector. Specifies the range for optimizing the steps part of the proposal. Defaults to <code>NULL</code>, indicating automatic range selection.</p>
</td></tr>
<tr><td><code id="srbeta_optimize_+3A_theta">theta</code></td>
<td>
<p>Numeric. A parameter for proposal optimization. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="srbeta_optimize_+3A_target_sample_size">target_sample_size</code></td>
<td>
<p>(optional) Integer. Target sample size for proposal optimization. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="srbeta_optimize_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, detailed optimization information, including areas and steps, will be displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>srbeta_optimize()</code> is explicitly called:
</p>

<ul>
<li><p> A proposal is created and cached. If no parameters are provided, a standard proposal is created with <code>shape1 = 1</code> and <code>shape2 = 1</code>.
</p>
</li>
<li><p> Providing <code>shape1</code> and <code>shape2</code> creates a custom proposal, which is cached for use with <code>srbeta_custom()</code>.
</p>
</li>
<li><p> The optimization process can be controlled via parameters such as <code>steps</code>, <code>proposal_range</code>, or
<code>theta</code>. If no parameters are provided, the proposal is optimized via brute force based on the
<code>target_sample_size</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the optimized proposal and related parameters for the specified Beta distribution. The proposal is also cached for internal use.
</p>

<dl>
<dt><code>data</code></dt><dd><p>Detailed information about the proposal steps, including <code>x</code>, <code>s_upper</code>, <code>p_a</code>, and <code>s_upper_lower</code>.</p>
</dd>
<dt><code>areas</code></dt><dd><p>The areas under the left tail, steps, and right tail of the proposal distribution.</p>
</dd>
<dt><code>steps_number</code></dt><dd><p>The number of steps in the proposal.</p>
</dd>
<dt><code>f_params</code></dt><dd><p>The parameters (<code>shape1</code> and <code>shape2</code>) of the Beta distribution.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+srbeta_custom">srbeta_custom</a></code>: Function to sample from a custom proposal generated by <code>srbeta_optimize()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a standard proposal with shape1 = 1 and shape2 = 1
standard_proposal &lt;- srbeta_optimize()

# Generate a custom proposal with shape1 = 2 and shape2 = 3
custom_proposal &lt;- srbeta_optimize(shape1 = 2, shape2 = 3)

</code></pre>

<hr>
<h2 id='srchisq_custom'>Sampling from Chi-squared Distribution</h2><span id='topic+srchisq_custom'></span>

<h3>Description</h3>

<p>The <code>srchisq_custom()</code> function generates random samples from a Chi-squared Distribution using the STORS algorithm.
It employs an optimized proposal distribution around the mode and Adaptive Rejection Sampling (ARS) for the tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srchisq_custom(n = 1, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srchisq_custom_+3A_n">n</code></td>
<td>
<p>Integer, length 1. Number of samples to draw.</p>
</td></tr>
<tr><td><code id="srchisq_custom_+3A_x">x</code></td>
<td>
<p>(optional) Numeric vector of length <code class="reqn">n</code>. If provided, this vector is over
written in place to avoid any memory allocation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Chi-squared Distribution
</p>
<p>The Chi-squared distribution has the probability density function (PDF):
</p>
<p style="text-align: center;"><code class="reqn">f(x | k) = \frac{1}{2^{k/2} \Gamma(k/2)} x^{(k/2) - 1} \exp(-x/2), \quad x \geq 0,</code>
</p>

<p>where:
</p>

<dl>
<dt><code class="reqn">k</code></dt><dd><p> is the degrees of freedom (<code class="reqn">k &gt; 0</code>), which determines the shape of the distribution.</p>
</dd>
</dl>

<p>The Chi-squared distribution is widely used in hypothesis testing and constructing confidence intervals, particularly in the context of variance estimation.
</p>
<p>this function is sampling from proposal that has been constructed using <code><a href="#topic+srchisq_optimize">srchisq_optimize</a></code>, using the STORS algorithm.
</p>
<p>By default, <code>srchisq_custom()</code> samples from Chi-squared Distribution <code>df = 2</code>.
The proposal distribution is pre-optimized at package load time using <code>srchisq_optimize()</code> with
<code>steps = 4091</code>, creating a scalable proposal centred around the mode.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code> containing random samples from the Chi-squared distribution.
The degrees of freedom (<code>df</code>) for the distribution are specified during the optimization process using <code>srchisq_optimize()</code>.
<b>NOTE:</b> When the <code>x</code> parameter is specified, it is updated in-place with the simulation for performance reasons.
</p>


<h3>Note</h3>

<p>This function is not scalable. Therefore, only the <code>srchisq_custom()</code> version is available, which requires the proposal to be pre-optimized using <code>srchisq_optimize()</code> before calling this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srchisq_optimize">srchisq_optimize</a></code> to optimize the custom proposal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Genedf 10 samples from Chi-squared Distribution
samples &lt;- srchisq_custom(10)
print(samples)

# Genedf 10 samples using a pre-allocated vector
x &lt;- numeric(10)
srchisq_custom(10, x = x)
print(x)


</code></pre>

<hr>
<h2 id='srchisq_optimize'>Optimizing Chi-squared Distribution proposal</h2><span id='topic+srchisq_optimize'></span>

<h3>Description</h3>

<p>The <code>srchisq_optimize()</code> function generates an optimized proposal for a targeted Chi-squared Distribution.
The proposal can be customized and adjusted based on various options provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srchisq_optimize(
  df = 2,
  xl = NULL,
  xr = NULL,
  steps = 4091,
  proposal_range = NULL,
  theta = 0.1,
  target_sample_size = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srchisq_optimize_+3A_df">df</code></td>
<td>
<p>(optional) Numeric. degrees of freedom parameter of the Chi-squared Distribution. Defaults to <code>NULL</code>, which implies proposal with <code>df = 2</code>.</p>
</td></tr>
<tr><td><code id="srchisq_optimize_+3A_xl">xl</code></td>
<td>
<p>Numeric. Left truncation bound for the target distribution. Defaults to <code>-Inf</code>, representing no left truncation.</p>
</td></tr>
<tr><td><code id="srchisq_optimize_+3A_xr">xr</code></td>
<td>
<p>Numeric. Right truncation bound for the target distribution. Defaults to <code>Inf</code>, representing no right truncation.</p>
</td></tr>
<tr><td><code id="srchisq_optimize_+3A_steps">steps</code></td>
<td>
<p>(optional) Integer. Desired number of steps in the proposal. Defaults to <code>NULL</code>, which means the number of steps is determined automatically during optimization.</p>
</td></tr>
<tr><td><code id="srchisq_optimize_+3A_proposal_range">proposal_range</code></td>
<td>
<p>(optional) Numeric vector. Specifies the range for optimizing the steps part of the proposal. Defaults to <code>NULL</code>, indicating automatic range selection.</p>
</td></tr>
<tr><td><code id="srchisq_optimize_+3A_theta">theta</code></td>
<td>
<p>Numeric. A parameter for proposal optimization. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="srchisq_optimize_+3A_target_sample_size">target_sample_size</code></td>
<td>
<p>(optional) Integer. Target sample size for proposal optimization. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="srchisq_optimize_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, detailed optimization information, including areas and steps, will be displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>srchisq_optimize()</code> is explicitly called:
</p>

<ul>
<li><p> A proposal is created and cached. If no parameters are provided, a standard proposal is created with <code>df = 2</code>.
</p>
</li>
<li><p> Providing <code>df</code> creates a custom proposal, which is cached for use with <code>srchisq_custom()</code>.
</p>
</li>
<li><p> The optimization process can be controlled via parameters such as <code>steps</code>, <code>proposal_range</code>, or
<code>theta</code>. If no parameters are provided, the proposal is optimized via brute force based on the.
<code>target_sample_size</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The user does not need to store the returned value, because the package internally cashes the proposal. However, we explain here the full returned proposal for advanced users.
</p>
<p>A list containing the optimized proposal and related parameters for the specified built-in distribution:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame with detailed information about the proposal steps, including:
</p>

<dl>
<dt><code>x</code></dt><dd><p>The start point of each step on the x-axis.</p>
</dd>
<dt><code>s_upper</code></dt><dd><p>The height of each step on the y-axis.</p>
</dd>
<dt><code>p_a</code></dt><dd><p>Pre-acceptance probability for each step.</p>
</dd>
<dt><code>s_upper_lower</code></dt><dd><p>A vector used to scale the uniform random number when the sample is accepted.</p>
</dd>
</dl>
</dd>
<dt><code>areas</code></dt><dd><p>A numeric vector containing the areas under:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The left tail bound.</p>
</dd>
<dt><code>steps</code></dt><dd><p>The middle steps.</p>
</dd>
<dt><code>right_tail</code></dt><dd><p>The right tail bound.</p>
</dd>
</dl>
</dd>
<dt><code>steps_number</code></dt><dd><p>An integer specifying the number of steps in the proposal.</p>
</dd>
<dt><code>sampling_probabilities</code></dt><dd><p>A numeric vector with:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The probability of sampling from the left tail.</p>
</dd>
<dt><code>left_and_middle</code></dt><dd><p>The combined probability of sampling from the left tail and middle steps.</p>
</dd>
</dl>
</dd>
<dt><code>unif_scaler</code></dt><dd><p>A numeric scalar, the inverse probability of sampling from the steps part of the proposal (<code class="reqn">\frac{1}{p(lower &lt; x &lt; upper)}</code>). Used for scaling uniform random values.</p>
</dd>
<dt><code>lt_properties</code></dt><dd><p>A numeric vector of 5 values required for Adaptive Rejection Sampling (ARS) in the left tail.</p>
</dd>
<dt><code>rt_properties</code></dt><dd><p>A numeric vector of 6 values required for ARS in the right tail.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric scalar representing the uniform step area.</p>
</dd>
<dt><code>tails_method</code></dt><dd><p>A string, either <code>"ARS"</code> (Adaptive Rejection Sampling) or <code>"IT"</code> (Inverse Transform), indicating the sampling method for the tails.</p>
</dd>
<dt><code>proposal_bounds</code></dt><dd><p>A numeric vector specifying the left and right bounds of the target density.</p>
</dd>
<dt><code>cnum</code></dt><dd><p>An integer representing the cache number of the created proposal in memory.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>A numeric scalar indicating the symmetry point of the proposal, or <code>NULL</code> if not symmetric.</p>
</dd>
<dt><code>f_params</code></dt><dd><p>A list of parameters for the target density that the proposal is designed for.</p>
</dd>
</dl>

<dl>
<dt><code>df</code></dt><dd><p> the df of the target distribution.</p>
</dd>
</dl>

<dl>
<dt><code>is_symmetric</code></dt><dd><p>A logical value indicating whether the proposal is symmetric.</p>
</dd>
<dt><code>proposal_type</code></dt><dd><p>A string indicating the type of the genedfd proposal:
</p>

<dl>
<dt><code>"custom"</code></dt><dd><p>The proposal is &quot;custom&quot; when <code>df</code> is provided. Custom proposals are compatible with <code><a href="#topic+srchisq_custom">srchisq_custom</a></code>.</p>
</dd>
</dl>
</dd>
<dt><code>target_function_area</code></dt><dd><p>A numeric scalar estimating the area of the target distribution.</p>
</dd>
<dt><code>dens_func</code></dt><dd><p>A string containing the hardcoded density function.</p>
</dd>
<dt><code>density_name</code></dt><dd><p>A string specifying the name of the target density distribution.</p>
</dd>
<dt><code>lock</code></dt><dd><p>An identifier used for saving and loading the proposal from disk.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+srchisq_custom">srchisq_custom</a></code>: Function to sample from a custom proposal genedfd by <code>srchisq_optimize()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Genedf custom proposal that with df = 2, that has 4096 steps
scalable_proposal &lt;- srchisq_optimize(steps = 4096)

# Genedf custom proposal that with df = 4
scalable_proposal &lt;- srchisq_optimize(df = 4)

</code></pre>

<hr>
<h2 id='srexp'>Sampling from Exponential Distribution</h2><span id='topic+srexp'></span><span id='topic+srexp_custom'></span>

<h3>Description</h3>

<p>The <code>srexp()</code> function generates random samples from a Exponential Distribution using the STORS algorithm.
It employs an optimized proposal distribution around the mode and Inverse Transform (IT) method for the tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srexp(n = 1, rate = 1, x = NULL)

srexp_custom(n = 1, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srexp_+3A_n">n</code></td>
<td>
<p>Integer, length 1. Number of samples to draw.</p>
</td></tr>
<tr><td><code id="srexp_+3A_rate">rate</code></td>
<td>
<p>Numeric. is the rate parameter of the Exponential Distribution.</p>
</td></tr>
<tr><td><code id="srexp_+3A_x">x</code></td>
<td>
<p>(optional) Numeric vector of length <code class="reqn">n</code>. If provided, this vector is over
written in place to avoid any memory allocation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Exponential distribution has the probability density function (PDF):
<code class="reqn">f(x | \lambda) = \lambda \exp(-\lambda x), \quad x \geq 0,</code>
where:
</p>

<dl>
<dt><code class="reqn">\lambda</code></dt><dd><p>is the rate parameter (<code class="reqn">\lambda &gt; 0</code>), which determines the rate of decay of the distribution.</p>
</dd>
</dl>

<p>The Exponential distribution is commonly used to model the time between independent events that occur at a constant average rate.
</p>
<p>These two functions are for sampling using the STORS algorithm based on the proposal that has been constructed using <code><a href="#topic+srexp_optimize">srexp_optimize</a></code>.
</p>
<p>By default, <code>srexp()</code> samples from a standard Exponential Distribution <code>rate = 1</code>.
The proposal distribution is pre-optimized at package load time using <code>srexp_optimize()</code> with
<code>steps = 4091</code>, creating a scalable proposal centred around the mode.
</p>
<p>If <code>srexp()</code> is called with custom <code>rate</code> parameter, the samples are generated
from the standard Exponential Distribution, then scaled accordingly.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code> containing samples from the Exponential Distribution with the specified
<code>rate</code>.
</p>
<p><b>NOTE:</b> When the <code>x</code> parameter is specified, it is updated in-place with the simulation for performance reasons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srexp_optimize">srexp_optimize</a></code> to optimize the custom or the scaled proposal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 10 samples from the standard Exponential Distribution
samples &lt;- srexp(10)
print(samples)

# Generate 10 samples using a pre-allocated vector
x &lt;- numeric(10)
srexp(10, x = x)
print(x)

# Generate 10 samples from a Exponential Distribution with rate = 4
samples &lt;- srexp(10, rate = 4)
print(samples)

</code></pre>

<hr>
<h2 id='srexp_optimize'>Optimizing Exponential Distribution proposal</h2><span id='topic+srexp_optimize'></span>

<h3>Description</h3>

<p>The <code>srexp_optimize()</code> function generates an optimized proposal for a targeted Exponential Distribution.
The proposal can be customized and adjusted based on various options provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srexp_optimize(
  rate = NULL,
  xl = NULL,
  xr = NULL,
  steps = 4091,
  proposal_range = NULL,
  theta = 0.1,
  target_sample_size = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srexp_optimize_+3A_rate">rate</code></td>
<td>
<p>(optional) Numeric. rate parameter of the Exponential Distribution. Defaults to <code>NULL</code>, which implies a scalable proposal with <code>rate = 1</code>.</p>
</td></tr>
<tr><td><code id="srexp_optimize_+3A_xl">xl</code></td>
<td>
<p>Numeric. Left truncation bound for the target distribution. Defaults to <code>-Inf</code>, representing no left truncation.</p>
</td></tr>
<tr><td><code id="srexp_optimize_+3A_xr">xr</code></td>
<td>
<p>Numeric. Right truncation bound for the target distribution. Defaults to <code>Inf</code>, representing no right truncation.</p>
</td></tr>
<tr><td><code id="srexp_optimize_+3A_steps">steps</code></td>
<td>
<p>(optional) Integer. Desired number of steps in the proposal. Defaults to <code>NULL</code>, which means the number of steps is determined automatically during optimization.</p>
</td></tr>
<tr><td><code id="srexp_optimize_+3A_proposal_range">proposal_range</code></td>
<td>
<p>(optional) Numeric vector. Specifies the range for optimizing the steps part of the proposal. Defaults to <code>NULL</code>, indicating automatic range selection.</p>
</td></tr>
<tr><td><code id="srexp_optimize_+3A_theta">theta</code></td>
<td>
<p>Numeric. A parameter for proposal optimization. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="srexp_optimize_+3A_target_sample_size">target_sample_size</code></td>
<td>
<p>(optional) Integer. Target sample size for proposal optimization. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="srexp_optimize_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, detailed optimization information, including areas and steps, will be displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>srexp_optimize()</code> is explicitly called:
</p>

<ul>
<li><p> A proposal is created and cached. If no parameters are provided, a standard proposal is created with <code>rate = 1</code>.
</p>
</li>
<li><p> Providing <code>rate</code> creates a custom proposal, which is cached for use with <code>srexp_custom()</code>.
</p>
</li>
<li><p> The optimization process can be controlled via parameters such as <code>steps</code>, <code>proposal_range</code>, or
<code>theta</code>. If no parameters are provided, the proposal is optimized via brute force based on the.
<code>target_sample_size</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The user does not need to store the returned value, because the package internally cashes the proposal. However, we explain here the full returned proposal for advanced users.
</p>
<p>A list containing the optimized proposal and related parameters for the specified built-in distribution:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame with detailed information about the proposal steps, including:
</p>

<dl>
<dt><code>x</code></dt><dd><p>The start point of each step on the x-axis.</p>
</dd>
<dt><code>s_upper</code></dt><dd><p>The height of each step on the y-axis.</p>
</dd>
<dt><code>p_a</code></dt><dd><p>Pre-acceptance probability for each step.</p>
</dd>
<dt><code>s_upper_lower</code></dt><dd><p>A vector used to scale the uniform random number when the sample is accepted.</p>
</dd>
</dl>
</dd>
<dt><code>areas</code></dt><dd><p>A numeric vector containing the areas under:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The left tail bound.</p>
</dd>
<dt><code>steps</code></dt><dd><p>The middle steps.</p>
</dd>
<dt><code>right_tail</code></dt><dd><p>The right tail bound.</p>
</dd>
</dl>
</dd>
<dt><code>steps_number</code></dt><dd><p>An integer specifying the number of steps in the proposal.</p>
</dd>
<dt><code>sampling_probabilities</code></dt><dd><p>A numeric vector with:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The probability of sampling from the left tail.</p>
</dd>
<dt><code>left_and_middle</code></dt><dd><p>The combined probability of sampling from the left tail and middle steps.</p>
</dd>
</dl>
</dd>
<dt><code>unif_scaler</code></dt><dd><p>A numeric scalar, the inverse probability of sampling from the steps part of the proposal (<code class="reqn">\frac{1}{p(lower &lt; x &lt; upper)}</code>). Used for scaling uniform random values.</p>
</dd>
<dt><code>lt_properties</code></dt><dd><p>A numeric vector of 5 values required for Adaptive Rejection Sampling (ARS) in the left tail.</p>
</dd>
<dt><code>rt_properties</code></dt><dd><p>A numeric vector of 6 values required for ARS in the right tail.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric scalar representing the uniform step area.</p>
</dd>
<dt><code>tails_method</code></dt><dd><p>A string, either <code>"ARS"</code> (Adaptive Rejection Sampling) or <code>"IT"</code> (Inverse Transform), indicating the sampling method for the tails.</p>
</dd>
<dt><code>proposal_bounds</code></dt><dd><p>A numeric vector specifying the left and right bounds of the target density.</p>
</dd>
<dt><code>cnum</code></dt><dd><p>An integer representing the cache number of the created proposal in memory.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>A numeric scalar indicating the symmetry point of the proposal, or <code>NULL</code> if not symmetric.</p>
</dd>
<dt><code>f_params</code></dt><dd><p>A list of parameters for the target density that the proposal is designed for.</p>
</dd>
</dl>

<dl>
<dt><code>rate</code></dt><dd><p> the rate of the target distribution.</p>
</dd>
</dl>

<dl>
<dt><code>is_symmetric</code></dt><dd><p>A logical value indicating whether the proposal is symmetric.</p>
</dd>
<dt><code>proposal_type</code></dt><dd><p>A string indicating the type of the generated proposal:
</p>

<dl>
<dt><code>"scaled"</code></dt><dd><p>The proposal is &quot;scalable&quot; and standardized with <code>rate = 1</code>. This is used when parameter <code>rate</code> is either <code>NULL</code> or not provided. Scalable proposals are compatible with <code><a href="#topic+srexp">srexp</a></code>.</p>
</dd>
<dt><code>"custom"</code></dt><dd><p>The proposal is &quot;custom&quot; when <code>rate</code> is provided. Custom proposals are compatible with <code><a href="#topic+srexp_custom">srexp_custom</a></code>.</p>
</dd>
</dl>
</dd>
<dt><code>target_function_area</code></dt><dd><p>A numeric scalar estimating the area of the target distribution.</p>
</dd>
<dt><code>dens_func</code></dt><dd><p>A string containing the hardcoded density function.</p>
</dd>
<dt><code>density_name</code></dt><dd><p>A string specifying the name of the target density distribution.</p>
</dd>
<dt><code>lock</code></dt><dd><p>An identifier used for saving and loading the proposal from disk.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+srexp">srexp</a></code>: Function to sample from a scalable proposal generated by <code>srexp_optimize()</code>.
<code><a href="#topic+srexp_custom">srexp_custom</a></code>: Function to sample from a custom proposal tailored to user specifications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate scalable proposal that with rate = 1, that has 4096 steps
scalable_proposal &lt;- srexp_optimize(steps = 4096)

# Generate custom proposal that with rate = 4
scalable_proposal &lt;- srexp_optimize(rate = 4)

</code></pre>

<hr>
<h2 id='srgamma_custom'>Sampling from Gamma Distribution</h2><span id='topic+srgamma_custom'></span>

<h3>Description</h3>

<p>The <code>srgamma_custom()</code> function generates random samples from a Gamma distribution using the STORS algorithm.
It employs an optimized proposal distribution around the mode and Adaptive Rejection Sampling (ARS) for the tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srgamma_custom(n = 1, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srgamma_custom_+3A_n">n</code></td>
<td>
<p>Integer, length 1. Number of samples to draw.</p>
</td></tr>
<tr><td><code id="srgamma_custom_+3A_x">x</code></td>
<td>
<p>(optional) Numeric vector of length <code class="reqn">n</code>. If provided, this vector is overwritten in place to avoid any memory allocation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gamma Distribution
</p>
<p>The Gamma distribution has the probability density function (PDF):
</p>
<p style="text-align: center;"><code class="reqn">f(x | \alpha, \beta) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{\alpha - 1} \exp(-\beta x), \quad x \geq 0,</code>
</p>

<p>where:
</p>

<dl>
<dt><code class="reqn">\alpha</code></dt><dd><p>is the shape parameter (<code class="reqn">\alpha &gt; 0</code>), which determines the shape of the distribution.</p>
</dd>
<dt><code class="reqn">\beta</code></dt><dd><p>is the rate parameter (<code class="reqn">\beta &gt; 0</code>), which determines the rate of decay.</p>
</dd>
</dl>

<p>The Gamma distribution is widely used in statistics, particularly in Bayesian inference and modelling waiting times.
</p>
<p>This function samples from a proposal constructed using <code><a href="#topic+srgamma_optimize">srgamma_optimize</a></code>, employing the STORS algorithm.
</p>
<p>By default, <code>srgamma_custom()</code> samples from the standard Gamma distribution with <code>shape = 1</code> and <code>rate = 1</code>.
The proposal distribution is pre-optimized at package load time using <code>srgamma_optimize()</code> with
<code>steps = 4091</code>, creating a scalable proposal centred around the mode.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code> containing random samples from the Gamma distribution.
The <code>shape</code> and <code>rate</code> parameters are specified during the optimization process using <code>srgamma_optimize()</code>.
</p>
<p><b>NOTE:</b> When the <code>x</code> parameter is specified, it is updated in-place with the simulation for performance reasons.
</p>


<h3>Note</h3>

<p>This function is not scalable. Therefore, only the <code>srgamma_custom()</code> version is available, which requires the proposal to be pre-optimized using <code>srgamma_optimize()</code> before calling this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srgamma_optimize">srgamma_optimize</a></code> to optimize the custom proposal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 10 samples from Gamma Distribution
samples &lt;- srgamma_custom(10)
print(samples)

# Generate 10 samples using a pre-allocated vector
x &lt;- numeric(10)
srgamma_custom(10, x = x)
print(x)

</code></pre>

<hr>
<h2 id='srgamma_optimize'>Optimizing Gamma Distribution proposal</h2><span id='topic+srgamma_optimize'></span>

<h3>Description</h3>

<p>The <code>srgamma_optimize()</code> function generates an optimized proposal for a targeted Gamma distribution.
The proposal can be customized and adjusted based on various options provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srgamma_optimize(
  shape = NULL,
  rate = NULL,
  scale = NULL,
  xl = NULL,
  xr = NULL,
  steps = 4091,
  proposal_range = NULL,
  theta = 0.1,
  target_sample_size = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srgamma_optimize_+3A_shape">shape</code></td>
<td>
<p>(optional) Numeric. The shape parameter (<code class="reqn">\alpha</code>) of the Gamma distribution. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="srgamma_optimize_+3A_rate">rate</code></td>
<td>
<p>(optional) Numeric. The rate parameter (<code class="reqn">\beta</code>) of the Gamma distribution. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="srgamma_optimize_+3A_scale">scale</code></td>
<td>
<p>(optional) Numeric. The scale parameter of the Gamma distribution. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="srgamma_optimize_+3A_xl">xl</code></td>
<td>
<p>Numeric. Left truncation bound for the target distribution. Defaults to <code>0</code>, representing no left truncation.</p>
</td></tr>
<tr><td><code id="srgamma_optimize_+3A_xr">xr</code></td>
<td>
<p>Numeric. Right truncation bound for the target distribution. Defaults to <code>Inf</code>, representing no right truncation.</p>
</td></tr>
<tr><td><code id="srgamma_optimize_+3A_steps">steps</code></td>
<td>
<p>(optional) Integer. Desired number of steps in the proposal. Defaults to <code>4091</code>.</p>
</td></tr>
<tr><td><code id="srgamma_optimize_+3A_proposal_range">proposal_range</code></td>
<td>
<p>(optional) Numeric vector. Specifies the range for optimizing the steps part of the proposal. Defaults to <code>NULL</code>, indicating automatic range selection.</p>
</td></tr>
<tr><td><code id="srgamma_optimize_+3A_theta">theta</code></td>
<td>
<p>Numeric. A parameter for proposal optimization. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="srgamma_optimize_+3A_target_sample_size">target_sample_size</code></td>
<td>
<p>(optional) Integer. Target sample size for proposal optimization. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="srgamma_optimize_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, detailed optimization information, including areas and steps, will be displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>srgamma_optimize()</code> is explicitly called:
</p>

<ul>
<li><p> A proposal is created and cached. If no parameters are provided, a standard proposal is created with <code>shape = 1</code> and <code>rate = 1</code>.
</p>
</li>
<li><p> Providing <code>shape</code> and <code>rate</code> creates a custom proposal, which is cached for use with <code>srgamma_custom()</code>.
</p>
</li>
<li><p> The optimization process can be controlled via parameters such as <code>steps</code>, <code>proposal_range</code>, or
<code>theta</code>. If no parameters are provided, the proposal is optimized via brute force based on the
<code>target_sample_size</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the optimized proposal and related parameters for the specified Gamma distribution. The proposal is also cached for internal use.
</p>

<dl>
<dt><code>data</code></dt><dd><p>Detailed information about the proposal steps, including <code>x</code>, <code>s_upper</code>, <code>p_a</code>, and <code>s_upper_lower</code>.</p>
</dd>
<dt><code>areas</code></dt><dd><p>The areas under the left tail, steps, and right tail of the proposal distribution.</p>
</dd>
<dt><code>steps_number</code></dt><dd><p>The number of steps in the proposal.</p>
</dd>
<dt><code>f_params</code></dt><dd><p>The parameters (<code>shape</code> and <code>rate</code>) of the Gamma distribution.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+srgamma_custom">srgamma_custom</a></code>: Function to sample from a custom proposal generated by <code>srgamma_optimize()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a standard proposal with shape = 1 and rate = 1
standard_proposal &lt;- srgamma_optimize()

# Generate a custom proposal with shape = 2 and rate = 3
custom_proposal &lt;- srgamma_optimize(shape = 2, rate = 3)

</code></pre>

<hr>
<h2 id='srlaplace'>Sampling from Laplace Distribution</h2><span id='topic+srlaplace'></span><span id='topic+srlaplace_custom'></span>

<h3>Description</h3>

<p>The <code>srlaplace()</code> function generates random samples from a Laplace Distribution using the STORS algorithm.
It employs an optimized proposal distribution around the mode and Inverse Transform (IT) method for the tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srlaplace(n = 1, mu = 0, b = 1, x = NULL)

srlaplace_custom(n = 1, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srlaplace_+3A_n">n</code></td>
<td>
<p>Integer, length 1. Number of samples to draw.</p>
</td></tr>
<tr><td><code id="srlaplace_+3A_mu">mu</code></td>
<td>
<p>Numeric, location parameter.</p>
</td></tr>
<tr><td><code id="srlaplace_+3A_b">b</code></td>
<td>
<p>Numeric, scale parameter.</p>
</td></tr>
<tr><td><code id="srlaplace_+3A_x">x</code></td>
<td>
<p>(optional) Numeric vector of length <code class="reqn">n</code>. If provided, this vector is over
written in place to avoid any memory allocation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Laplace distribution has the probability density function (PDF):
<code class="reqn">f(x | \mu, b) = \frac{1}{2b} \exp\left(-\frac{|x - \mu|}{b}\right),</code>
where:
</p>

<dl>
<dt><code class="reqn">\mu</code></dt><dd><p>is the location parameter (mean of the distribution).</p>
</dd>
<dt><code>b</code></dt><dd><p>is the scale parameter, which controls the spread of the distribution (<code>b &gt; 0</code>).</p>
</dd>
</dl>

<p>These two functions are for sampling using the STORS algorithm based on the proposal that has been constructed using <code><a href="#topic+srlaplace_optimize">srlaplace_optimize</a></code>.
</p>
<p>By default, <code>srlaplace()</code> samples from a standard Laplace Distribution (<code>mu = 0</code>, <code>b = 1</code>).
The proposal distribution is pre-optimized at package load time using <code>srlaplace_optimize()</code> with
<code>steps = 4091</code>, creating a scalable proposal centred around the mode.
</p>
<p>If <code>srlaplace()</code> is called with custom <code>mu</code> or <code>b</code> parameters, the samples are generated
from the standard Laplace Distribution, then scaled and location shifted accordingly.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code> containing samples from the Laplace Distribution with the specified
<code>mu</code> and <code>b</code>.
</p>
<p><b>NOTE:</b> When the <code>x</code> parameter is specified, it is updated in-place with the simulation for performance reasons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srlaplace_optimize">srlaplace_optimize</a></code> to optimize the custom or the scaled proposal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 10 samples from the standard Laplace Distribution
samples &lt;- srlaplace(10)
print(samples)

# Generate 10 samples using a pre-allocated vector
x &lt;- numeric(10)
srlaplace(10, x = x)
print(x)

# Generate 10 samples from a Laplace Distribution with mu = 2 and b = 3
samples &lt;- srlaplace(10, mu = 2, b = 3)
print(samples)

</code></pre>

<hr>
<h2 id='srlaplace_optimize'>Optimizing Laplace Distribution proposal</h2><span id='topic+srlaplace_optimize'></span>

<h3>Description</h3>

<p>The <code>srlaplace_optimize()</code> function generates an optimized proposal for a targeted Laplace Distribution.
The proposal can be customized and adjusted based on various options provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srlaplace_optimize(
  mu = NULL,
  b = NULL,
  xl = NULL,
  xr = NULL,
  steps = 4091,
  proposal_range = NULL,
  theta = 0.1,
  target_sample_size = 1000,
  verbose = FALSE,
  symmetric = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srlaplace_optimize_+3A_mu">mu</code></td>
<td>
<p>(optional) Numeric, location parameter.</p>
</td></tr>
<tr><td><code id="srlaplace_optimize_+3A_b">b</code></td>
<td>
<p>(optional) Numeric, scale parameter.</p>
</td></tr>
<tr><td><code id="srlaplace_optimize_+3A_xl">xl</code></td>
<td>
<p>Numeric. Left truncation bound for the target distribution. Defaults to <code>-Inf</code>, representing no left truncation.</p>
</td></tr>
<tr><td><code id="srlaplace_optimize_+3A_xr">xr</code></td>
<td>
<p>Numeric. Right truncation bound for the target distribution. Defaults to <code>Inf</code>, representing no right truncation.</p>
</td></tr>
<tr><td><code id="srlaplace_optimize_+3A_steps">steps</code></td>
<td>
<p>(optional) Integer. Desired number of steps in the proposal. Defaults to <code>NULL</code>, which means the number of steps is determined automatically during optimization.</p>
</td></tr>
<tr><td><code id="srlaplace_optimize_+3A_proposal_range">proposal_range</code></td>
<td>
<p>(optional) Numeric vector. Specifies the range for optimizing the steps part of the proposal. Defaults to <code>NULL</code>, indicating automatic range selection.</p>
</td></tr>
<tr><td><code id="srlaplace_optimize_+3A_theta">theta</code></td>
<td>
<p>Numeric. A parameter for proposal optimization. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="srlaplace_optimize_+3A_target_sample_size">target_sample_size</code></td>
<td>
<p>(optional) Integer. Target sample size for proposal optimization. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="srlaplace_optimize_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, detailed optimization information, including areas and steps, will be displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="srlaplace_optimize_+3A_symmetric">symmetric</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the proposal will target only the right tail of the distribution, reducing the size of the cached proposal and making sampling more memory-efficient.
An additional uniform random number will be sampled to determine the sample's position relative to the mode of the distribution.
While this improves memory efficiency, the extra sampling may slightly impact performance, especially when the proposal efficiency is close to 1. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>srlaplace_optimize()</code> is explicitly called:
</p>

<ul>
<li><p> A proposal is created and cached. If no parameters are provided, a standard proposal is created (<code>mu = 0</code>, <code>b = 1</code>).
</p>
</li>
<li><p> Providing <code>mu</code> or <code>b</code> creates a custom proposal, which is cached for use with <code>srlaplace_custom()</code>.
</p>
</li>
<li><p> The optimization process can be controlled via parameters such as <code>steps</code>, <code>proposal_range</code>, or
<code>theta</code>. If no parameters are provided, the proposal is optimized via brute force based on the.
<code>target_sample_size</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The user does not need to store the returned value, because the package internally cashes the proposal. However, we explain here the full returned proposal for advanced users.
</p>
<p>A list containing the optimized proposal and related parameters for the specified built-in distribution:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame with detailed information about the proposal steps, including:
</p>

<dl>
<dt><code>x</code></dt><dd><p>The start point of each step on the x-axis.</p>
</dd>
<dt><code>s_upper</code></dt><dd><p>The height of each step on the y-axis.</p>
</dd>
<dt><code>p_a</code></dt><dd><p>Pre-acceptance probability for each step.</p>
</dd>
<dt><code>s_upper_lower</code></dt><dd><p>A vector used to scale the uniform random number when the sample is accepted.</p>
</dd>
</dl>
</dd>
<dt><code>areas</code></dt><dd><p>A numeric vector containing the areas under:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The left tail bound.</p>
</dd>
<dt><code>steps</code></dt><dd><p>The middle steps.</p>
</dd>
<dt><code>right_tail</code></dt><dd><p>The right tail bound.</p>
</dd>
</dl>
</dd>
<dt><code>steps_number</code></dt><dd><p>An integer specifying the number of steps in the proposal.</p>
</dd>
<dt><code>sampling_probabilities</code></dt><dd><p>A numeric vector with:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The probability of sampling from the left tail.</p>
</dd>
<dt><code>left_and_middle</code></dt><dd><p>The combined probability of sampling from the left tail and middle steps.</p>
</dd>
</dl>
</dd>
<dt><code>unif_scaler</code></dt><dd><p>A numeric scalar, the inverse probability of sampling from the steps part of the proposal (<code class="reqn">\frac{1}{p(lower &lt; x &lt; upper)}</code>). Used for scaling uniform random values.</p>
</dd>
<dt><code>lt_properties</code></dt><dd><p>A numeric vector of 5 values required for Adaptive Rejection Sampling (ARS) in the left tail.</p>
</dd>
<dt><code>rt_properties</code></dt><dd><p>A numeric vector of 6 values required for ARS in the right tail.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric scalar representing the uniform step area.</p>
</dd>
<dt><code>tails_method</code></dt><dd><p>A string, either <code>"ARS"</code> (Adaptive Rejection Sampling) or <code>"IT"</code> (Inverse Transform), indicating the sampling method for the tails.</p>
</dd>
<dt><code>proposal_bounds</code></dt><dd><p>A numeric vector specifying the left and right bounds of the target density.</p>
</dd>
<dt><code>cnum</code></dt><dd><p>An integer representing the cache number of the created proposal in memory.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>A numeric scalar indicating the symmetry point of the proposal, or <code>NULL</code> if not symmetric.</p>
</dd>
<dt><code>f_params</code></dt><dd><p>A list of parameters for the target density that the proposal is designed for.</p>
</dd>
</dl>

<dl>
<dt><code>mu</code></dt><dd><p>is the location parameter (location of the distribution).</p>
</dd>
<dt><code>b</code></dt><dd><p>is the scale parameter, which controls the spread of the distribution (<code>b &gt; 0</code>).</p>
</dd>
</dl>

<dl>
<dt><code>is_symmetric</code></dt><dd><p>A logical value indicating whether the proposal is symmetric.</p>
</dd>
<dt><code>proposal_type</code></dt><dd><p>A string indicating the type of the generated proposal:
</p>

<dl>
<dt><code>"scaled"</code></dt><dd><p>The proposal is &quot;scalable&quot; and standardized with <code>mu = 0</code> and <code>b = 1</code>. This is used when parameters <code>mu</code> and <code>b</code> are either <code>NULL</code> or not provided. Scalable proposals are compatible with <code><a href="#topic+srlaplace">srlaplace</a></code>.</p>
</dd>
<dt><code>"custom"</code></dt><dd><p>The proposal is &quot;custom&quot; when either <code>mu</code> or <code>b</code> is provided. Custom proposals are compatible with <code><a href="#topic+srlaplace_custom">srlaplace_custom</a></code>.</p>
</dd>
</dl>
</dd>
<dt><code>target_function_area</code></dt><dd><p>A numeric scalar estimating the area of the target distribution.</p>
</dd>
<dt><code>dens_func</code></dt><dd><p>A string containing the hardcoded density function.</p>
</dd>
<dt><code>density_name</code></dt><dd><p>A string specifying the name of the target density distribution.</p>
</dd>
<dt><code>lock</code></dt><dd><p>An identifier used for saving and loading the proposal from disk.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+srlaplace">srlaplace</a></code>: Function to sample from a scalable proposal generated by <code>srlaplace_optimize()</code>.
<code><a href="#topic+srlaplace_custom">srlaplace_custom</a></code>: Function to sample from a custom proposal tailored to user specifications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate scalable proposal that with mu = 0 and b = 1, that has 4096 steps
scalable_proposal &lt;- srlaplace_optimize(steps = 4096)

# Generate custom proposal that with mu = 2 and b = 1
scalable_proposal &lt;- srlaplace_optimize(mu = 2, b = 1)

</code></pre>

<hr>
<h2 id='srnorm'>Sampling from Normal Distribution</h2><span id='topic+srnorm'></span><span id='topic+srnorm_custom'></span>

<h3>Description</h3>

<p>The <code>srnorm()</code> function generates random samples from a Normal distribution using the STORS algorithm.
It employs an optimized proposal distribution around the mode and Adaptive Rejection Sampling (ARS) for the tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srnorm(n = 1, mean = 0, sd = 1, x = NULL)

srnorm_custom(n = 1, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srnorm_+3A_n">n</code></td>
<td>
<p>Integer, length 1. Number of samples to draw.</p>
</td></tr>
<tr><td><code id="srnorm_+3A_mean">mean</code></td>
<td>
<p>Numeric. Mean parameter of the Normal distribution.</p>
</td></tr>
<tr><td><code id="srnorm_+3A_sd">sd</code></td>
<td>
<p>Numeric. Standard deviation of the target Normal distribution.</p>
</td></tr>
<tr><td><code id="srnorm_+3A_x">x</code></td>
<td>
<p>(optional) Numeric vector of length <code class="reqn">n</code>. If provided, this vector is over
written in place to avoid any memory allocation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Normal distribution has the probability density function (PDF):
<code class="reqn">f(x | \mu, \sigma) = \frac{1}{\sigma\sqrt{2\pi}} \exp\left(-\frac{(x - \mu)^2}{2\sigma^2}\right),</code>
where:
</p>

<dl>
<dt><code class="reqn">\mu</code></dt><dd><p> is the mean of the distribution, which determines the centre of the bell curve.</p>
</dd>
<dt><code class="reqn">\sigma</code></dt><dd><p> is the standard deviation, which controls the spread of the distribution (<code class="reqn">\sigma &gt; 0</code>).</p>
</dd>
</dl>

<p>These two functions are for sampling using the STORS algorithm based on the proposal that has been constructed using <code><a href="#topic+srnorm_optimize">srnorm_optimize</a></code>.
</p>
<p>By default, <code>srnorm()</code> samples from a standard Normal distribution (<code>mean = 0</code>, <code>sd = 1</code>).
The proposal distribution is pre-optimized at package load time using <code>srnorm_optimize()</code> with
<code>steps = 4091</code>, creating a scalable proposal centred around the mode.
</p>
<p>If <code>srnorm()</code> is called with custom <code>mean</code> or <code>sd</code> parameters, the samples are generated
from the standard Normal distribution, then scaled and location shifted accordingly.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code> containing samples from the Normal distribution with the specified
<code>mean</code> and <code>sd</code>.
</p>
<p><b>NOTE:</b> When the <code>x</code> parameter is specified, it is updated in-place with the simulation for performance reasons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srnorm_optimize">srnorm_optimize</a></code> to optimize the custom or the scaled proposal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 10 samples from the standard Normal distribution
samples &lt;- srnorm(10)
print(samples)

# Generate 10 samples using a pre-allocated vector
x &lt;- numeric(10)
srnorm(10, x = x)
print(x)

# Generate 10 samples from a Normal distribution with mean = 2 and sd = 3
samples &lt;- srnorm(10, mean = 2, sd = 3)
print(samples)

</code></pre>

<hr>
<h2 id='srnorm_optimize'>Optimizing Normal Distribution proposal</h2><span id='topic+srnorm_optimize'></span>

<h3>Description</h3>

<p>The <code>srnorm_optimize()</code> function generates an optimized proposal for a targeted Normal distribution.
The proposal can be customized and adjusted based on various options provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srnorm_optimize(
  mean = NULL,
  sd = NULL,
  xl = -Inf,
  xr = Inf,
  steps = NULL,
  proposal_range = NULL,
  theta = 0.1,
  target_sample_size = 1000,
  verbose = FALSE,
  symmetric = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srnorm_optimize_+3A_mean">mean</code></td>
<td>
<p>(optional) Numeric. Mean parameter of the Normal distribution. Defaults to <code>NULL</code>, which implies a scalable proposal with <code>mean = 0</code>.</p>
</td></tr>
<tr><td><code id="srnorm_optimize_+3A_sd">sd</code></td>
<td>
<p>(optional) Numeric. Standard deviation of the target Normal distribution. Defaults to <code>NULL</code>, which implies a scalable proposal with <code>sd = 1</code>.</p>
</td></tr>
<tr><td><code id="srnorm_optimize_+3A_xl">xl</code></td>
<td>
<p>Numeric. Left truncation bound for the target distribution. Defaults to <code>-Inf</code>, representing no left truncation.</p>
</td></tr>
<tr><td><code id="srnorm_optimize_+3A_xr">xr</code></td>
<td>
<p>Numeric. Right truncation bound for the target distribution. Defaults to <code>Inf</code>, representing no right truncation.</p>
</td></tr>
<tr><td><code id="srnorm_optimize_+3A_steps">steps</code></td>
<td>
<p>(optional) Integer. Desired number of steps in the proposal. Defaults to <code>NULL</code>, which means the number of steps is determined automatically during optimization.</p>
</td></tr>
<tr><td><code id="srnorm_optimize_+3A_proposal_range">proposal_range</code></td>
<td>
<p>(optional) Numeric vector. Specifies the range for optimizing the steps part of the proposal. Defaults to <code>NULL</code>, indicating automatic range selection.</p>
</td></tr>
<tr><td><code id="srnorm_optimize_+3A_theta">theta</code></td>
<td>
<p>Numeric. A parameter for proposal optimization. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="srnorm_optimize_+3A_target_sample_size">target_sample_size</code></td>
<td>
<p>(optional) Integer. Target sample size for proposal optimization. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="srnorm_optimize_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, detailed optimization information, including areas and steps, will be displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="srnorm_optimize_+3A_symmetric">symmetric</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the proposal will target only the right tail of the distribution, reducing the size of the cached proposal and making sampling more memory-efficient.
An additional uniform random number will be sampled to determine the sample's position relative to the mode of the distribution.
While this improves memory efficiency, the extra sampling may slightly impact performance, especially when the proposal efficiency is close to 1. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>srnorm_optimize()</code> is explicitly called:
</p>

<ul>
<li><p> A proposal is created and cached. If no parameters are provided, a standard proposal is created (<code>mean = 0</code>, <code>sd = 1</code>).
</p>
</li>
<li><p> Providing <code>mean</code> or <code>sd</code> creates a custom proposal, which is cached for use with <code>srnorm_custom()</code>.
</p>
</li>
<li><p> The optimization process can be controlled via parameters such as <code>steps</code>, <code>proposal_range</code>, or
<code>theta</code>. If no parameters are provided, the proposal is optimized via brute force based on the.
<code>target_sample_size</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The user does not need to store the returned value, because the package internally cashes the proposal. However, we explain here the full returned proposal for advanced users.
</p>
<p>A list containing the optimized proposal and related parameters for the specified built-in distribution:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A data frame with detailed information about the proposal steps, including:
</p>

<dl>
<dt><code>x</code></dt><dd><p>The start point of each step on the x-axis.</p>
</dd>
<dt><code>s_upper</code></dt><dd><p>The height of each step on the y-axis.</p>
</dd>
<dt><code>p_a</code></dt><dd><p>Pre-acceptance probability for each step.</p>
</dd>
<dt><code>s_upper_lower</code></dt><dd><p>A vector used to scale the uniform random number when the sample is accepted.</p>
</dd>
</dl>
</dd>
<dt><code>areas</code></dt><dd><p>A numeric vector containing the areas under:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The left tail bound.</p>
</dd>
<dt><code>steps</code></dt><dd><p>The middle steps.</p>
</dd>
<dt><code>right_tail</code></dt><dd><p>The right tail bound.</p>
</dd>
</dl>
</dd>
<dt><code>steps_number</code></dt><dd><p>An integer specifying the number of steps in the proposal.</p>
</dd>
<dt><code>sampling_probabilities</code></dt><dd><p>A numeric vector with:
</p>

<dl>
<dt><code>left_tail</code></dt><dd><p>The probability of sampling from the left tail.</p>
</dd>
<dt><code>left_and_middle</code></dt><dd><p>The combined probability of sampling from the left tail and middle steps.</p>
</dd>
</dl>
</dd>
<dt><code>unif_scaler</code></dt><dd><p>A numeric scalar, the inverse probability of sampling from the steps part of the proposal (<code class="reqn">\frac{1}{p(lower &lt; x &lt; upper)}</code>). Used for scaling uniform random values.</p>
</dd>
<dt><code>lt_properties</code></dt><dd><p>A numeric vector of 5 values required for Adaptive Rejection Sampling (ARS) in the left tail.</p>
</dd>
<dt><code>rt_properties</code></dt><dd><p>A numeric vector of 6 values required for ARS in the right tail.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric scalar representing the uniform step area.</p>
</dd>
<dt><code>tails_method</code></dt><dd><p>A string, either <code>"ARS"</code> (Adaptive Rejection Sampling) or <code>"IT"</code> (Inverse Transform), indicating the sampling method for the tails.</p>
</dd>
<dt><code>proposal_bounds</code></dt><dd><p>A numeric vector specifying the left and right bounds of the target density.</p>
</dd>
<dt><code>cnum</code></dt><dd><p>An integer representing the cache number of the created proposal in memory.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>A numeric scalar indicating the symmetry point of the proposal, or <code>NULL</code> if not symmetric.</p>
</dd>
<dt><code>f_params</code></dt><dd><p>A list of parameters for the target density that the proposal is designed for.</p>
</dd>
</dl>

<dl>
<dt><code>mean</code></dt><dd><p>The mean of the target distribution.</p>
</dd>
<dt><code>sd</code></dt><dd><p>The standard deviation of the target distribution.</p>
</dd>
</dl>

<dl>
<dt><code>is_symmetric</code></dt><dd><p>A logical value indicating whether the proposal is symmetric.</p>
</dd>
<dt><code>proposal_type</code></dt><dd><p>A string indicating the type of the generated proposal:
</p>

<dl>
<dt><code>"scaled"</code></dt><dd><p>The proposal is &quot;scalable&quot; and standardized with <code>mean = 0</code> and <code>sd = 1</code>. This is used when parameters <code>mean</code> and <code>sd</code> are either <code>NULL</code> or not provided. Scalable proposals are compatible with <code><a href="#topic+srnorm">srnorm</a></code>.</p>
</dd>
<dt><code>"custom"</code></dt><dd><p>The proposal is &quot;custom&quot; when either <code>mean</code> or <code>sd</code> is provided. Custom proposals are compatible with <code><a href="#topic+srnorm_custom">srnorm_custom</a></code>.</p>
</dd>
</dl>
</dd>
<dt><code>target_function_area</code></dt><dd><p>A numeric scalar estimating the area of the target distribution.</p>
</dd>
<dt><code>dens_func</code></dt><dd><p>A string containing the hardcoded density function.</p>
</dd>
<dt><code>density_name</code></dt><dd><p>A string specifying the name of the target density distribution.</p>
</dd>
<dt><code>lock</code></dt><dd><p>An identifier used for saving and loading the proposal from disk.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+srnorm">srnorm</a></code>: Function to sample from a scalable proposal generated by <code>srnorm_optimize()</code>.
<code><a href="#topic+srnorm_custom">srnorm_custom</a></code>: Function to sample from a custom proposal tailored to user specifications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate scalable proposal that with mean = 0 and sd = 1, that has 4096 steps
scalable_proposal &lt;- srnorm_optimize(steps = 4096)


# Generate custom proposal that with mean = 2 and sd = 1
scalable_proposal &lt;- srnorm_optimize(mean = 2, sd = 1)


</code></pre>

<hr>
<h2 id='srpareto_custom'>Sampling from Pareto Distribution</h2><span id='topic+srpareto_custom'></span>

<h3>Description</h3>

<p>The <code>srpareto_custom()</code> function generates random samples from a Pareto distribution using the STORS algorithm.
It employs an optimized proposal distribution around the mode and Inverse Transform (IT) method for the tails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srpareto_custom(n = 1, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srpareto_custom_+3A_n">n</code></td>
<td>
<p>Integer, length 1. Number of samples to draw.</p>
</td></tr>
<tr><td><code id="srpareto_custom_+3A_x">x</code></td>
<td>
<p>(optional) Numeric vector of length <code class="reqn">n</code>. If provided, this vector is overwritten in place to avoid any memory allocation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pareto Distribution
</p>
<p>The Pareto distribution has the probability density function (PDF):
</p>
<p style="text-align: center;"><code class="reqn">f(x | \alpha, \sigma) = \frac{\alpha \sigma^\alpha}{x^{\alpha + 1}}, \quad x \geq \sigma,</code>
</p>

<p>where:
</p>

<dl>
<dt><code class="reqn">\alpha</code></dt><dd><p>is the shape parameter (<code class="reqn">\alpha &gt; 0</code>), which determines the tail heaviness of the distribution.</p>
</dd>
<dt><code class="reqn">\sigma</code></dt><dd><p>is the scale parameter (<code class="reqn">\sigma &gt; 0</code>), which determines the minimum possible value of <code class="reqn">x</code>.</p>
</dd>
</dl>

<p>The Pareto distribution is widely used in modelling phenomena with heavy tails, such as wealth distribution, insurance losses, and natural events.
</p>
<p>This function samples from a proposal constructed using <code><a href="#topic+srpareto_optimize">srpareto_optimize</a></code>, employing the STORS algorithm.
</p>
<p>By default, <code>srpareto_custom()</code> samples from the standard Pareto distribution with <code>shape = 1</code> and <code>rate = 1</code>.
The proposal distribution is pre-optimized at package load time using <code>srpareto_optimize()</code> with
<code>steps = 4091</code>, creating a scalable proposal centred around the mode.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code> containing random samples from the Pareto distribution.
The <code>shape</code> and <code>scale</code> parameters are specified during the optimization process using <code>srpareto_optimize()</code>.
</p>
<p><b>NOTE:</b> When the <code>x</code> parameter is specified, it is updated in-place with the simulation for performance reasons.
</p>


<h3>Note</h3>

<p>This function is not scalable. Therefore, only the <code>srpareto_custom()</code> version is available, which requires the proposal to be pre-optimized using <code>srpareto_optimize()</code> before calling this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srpareto_optimize">srpareto_optimize</a></code> to optimize the custom proposal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 10 samples from Pareto Distribution
samples &lt;- srpareto_custom(10)
print(samples)

# Generate 10 samples using a pre-allocated vector
x &lt;- numeric(10)
srpareto_custom(10, x = x)
print(x)

</code></pre>

<hr>
<h2 id='srpareto_optimize'>Optimizing Pareto Distribution proposal</h2><span id='topic+srpareto_optimize'></span>

<h3>Description</h3>

<p>The <code>srpareto_optimize()</code> function generates an optimized proposal for a targeted Pareto Distribution.
The proposal can be customized and adjusted based on various options provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srpareto_optimize(
  scale = NULL,
  shape = NULL,
  xl = NULL,
  xr = NULL,
  steps = 4091,
  proposal_range = NULL,
  theta = 0.1,
  target_sample_size = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srpareto_optimize_+3A_scale">scale</code></td>
<td>
<p>(optional) Numeric. scale parameter of the Pareto Distribution. Defaults to <code>NULL</code>, which implies a scalable proposal with <code>scale = 1</code>.</p>
</td></tr>
<tr><td><code id="srpareto_optimize_+3A_shape">shape</code></td>
<td>
<p>(optional) Numeric. shape parameter of the Pareto Distribution. Defaults to <code>NULL</code>, which implies a scalable proposal with <code>shape = 1</code>.</p>
</td></tr>
<tr><td><code id="srpareto_optimize_+3A_xl">xl</code></td>
<td>
<p>Numeric. Left truncation bound for the target distribution. Defaults to <code>-Inf</code>, representing no left truncation.</p>
</td></tr>
<tr><td><code id="srpareto_optimize_+3A_xr">xr</code></td>
<td>
<p>Numeric. Right truncation bound for the target distribution. Defaults to <code>Inf</code>, representing no right truncation.</p>
</td></tr>
<tr><td><code id="srpareto_optimize_+3A_steps">steps</code></td>
<td>
<p>(optional) Integer. Desired number of steps in the proposal. Defaults to <code>NULL</code>, which means the number of steps is determined automatically during optimization.</p>
</td></tr>
<tr><td><code id="srpareto_optimize_+3A_proposal_range">proposal_range</code></td>
<td>
<p>(optional) Numeric vector. Specifies the range for optimizing the steps part of the proposal. Defaults to <code>NULL</code>, indicating automatic range selection.</p>
</td></tr>
<tr><td><code id="srpareto_optimize_+3A_theta">theta</code></td>
<td>
<p>Numeric. A parameter for proposal optimization. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="srpareto_optimize_+3A_target_sample_size">target_sample_size</code></td>
<td>
<p>(optional) Integer. Target sample size for proposal optimization. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="srpareto_optimize_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, detailed optimization information, including areas and steps, will be displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>srpareto_optimize()</code> is explicitly called:
</p>

<ul>
<li><p> A proposal is created and cached. If no parameters are provided, a standard proposal is created with <code>rate = 1</code>.
</p>
</li>
<li><p> Providing <code>rate</code> creates a custom proposal, which is cached for use with <code>srpareto_custom()</code>.
</p>
</li>
<li><p> The optimization process can be controlled via parameters such as <code>steps</code>, <code>proposal_range</code>, or
<code>theta</code>. If no parameters are provided, the proposal is optimized via brute force based on the.
<code>target_sample_size</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The user does not need to store the returned value, because the package internally cashes the proposal. However, we explain here the full returned proposal for advanced users.
</p>
<p>A list containing the optimized proposal and related parameters for the specified built-in distribution:
#' </p>

<dl>
<dt><code>data</code></dt><dd><p>Detailed information about the proposal steps, including <code>x</code>, <code>s_upper</code>, <code>p_a</code>, and <code>s_upper_lower</code>.</p>
</dd>
<dt><code>areas</code></dt><dd><p>The areas under the left tail, steps, and right tail of the proposal distribution.</p>
</dd>
<dt><code>steps_number</code></dt><dd><p>The number of steps in the proposal.</p>
</dd>
<dt><code>f_params</code></dt><dd><p>The parameters (<code>scale</code> and <code>shape</code>) of the Beta distribution.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+srpareto_custom">srpareto_custom</a></code>: Function to sample from a custom proposal tailored to user specifications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate scalable proposal that with rate = 1, that has 4096 steps
scalable_proposal &lt;- srpareto_optimize(steps = 4096)

# Generate custom proposal that with scale = 4
scalable_proposal &lt;- srpareto_optimize(scale = 4)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
