<!DOCTYPE html><html><head><title>Help for package ASV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ASV}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asv_apf'><p>Auxiliary particle filter for stochastic volatility models with leverage</p>
</a></li>
<li><a href='#asv_logML'>
<p>Compute the logarithm of the marginal likelihood for the stochastic volatility models with leverage</p></a></li>
<li><a href='#asv_mcmc'>
<p>MCMC estimation for stochastic volatility models with leverage</p>
</a></li>
<li><a href='#asv_pf'><p>Particle filter for stochastic volatility models with leverage</p>
</a></li>
<li><a href='#asv_posterior'>
<p>Compute the logarithm of the posterior density for the stochastic volatility models with leverage</p></a></li>
<li><a href='#asv_prior'>
<p>Compute the logarithm of the prior density for the stochastic volatility models with leverage</p></a></li>
<li><a href='#ASV-package'>
<p>Stochastic Volatility Models with or without Leverage</p></a></li>
<li><a href='#ReportMCMC'><p>Summary statistics, diagnostic statistics and plots.</p>
</a></li>
<li><a href='#sv_apf'><p>Auxiliary particle filter for stochastic volatility models without leverage</p>
</a></li>
<li><a href='#sv_logML'>
<p>Compute the logarithm of the marginal likelihood for the stochastic volatility models without leverage</p></a></li>
<li><a href='#sv_mcmc'>
<p>MCMC estimation for stochastic volatility models without leverage</p>
</a></li>
<li><a href='#sv_pf'><p>Particle filter for stochastic volatility models without leverage</p>
</a></li>
<li><a href='#sv_posterior'>
<p>Compute the logarithm of the posterior density for the stochastic volatility models without leverage</p></a></li>
<li><a href='#sv_prior'>
<p>Compute the logarithm of the prior density for the stochastic volatility models without leverage</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stochastic Volatility Models with or without Leverage</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yasuhiro Omori &lt;omori.yasuhiro@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The efficient Markov chain Monte Carlo estimation of stochastic volatility models with and without leverage (asymmetric and symmetric stochastic volatility models). Further, it computes the logarithm of the likelihood given parameters using particle filters.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sites.google.com/view/omori-stat/english/software/asv-r">https://sites.google.com/view/omori-stat/english/software/asv-r</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.7), freqdom, stats, graphics</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 08:51:39 UTC; omori</td>
</tr>
<tr>
<td>Author:</td>
<td>Yasuhiro Omori [aut, cre],
  Ryuji Hashimoto [ctr]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='asv_apf'>Auxiliary particle filter for stochastic volatility models with leverage

</h2><span id='topic+asv_apf'></span>

<h3>Description</h3>

<p>The function computes the log likelihood given (mu, phi, sigma_eta, rho)  for stochastic volatility models with leverage (asymmetric stochastic volatility models).

</p>


<h3>Usage</h3>

<pre><code class='language-R'>asv_apf(mu, phi, sigma_eta, rho, Y, I)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asv_apf_+3A_mu">mu</code></td>
<td>
<p>parameter value such as the posterior mean of mu
</p>
</td></tr>
<tr><td><code id="asv_apf_+3A_phi">phi</code></td>
<td>
<p>parameter value such as the posterior mean of phi
</p>
</td></tr>
<tr><td><code id="asv_apf_+3A_sigma_eta">sigma_eta</code></td>
<td>
<p>parameter value such as the posterior mean of sigma_eta
</p>
</td></tr>
<tr><td><code id="asv_apf_+3A_rho">rho</code></td>
<td>
<p>parameter value such as the posterior mean of rho
</p>
</td></tr>
<tr><td><code id="asv_apf_+3A_y">Y</code></td>
<td>
<p>T x 1 vector (y(1),...,y(T))' of returns where T is a sample size.
</p>
</td></tr>
<tr><td><code id="asv_apf_+3A_i">I</code></td>
<td>
<p>Number of particles to approximate the filtering density.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logarithm of the likelihood of Y given parameters (mu, phi, sigma_eta, rho)
using the auxiliary particle filter by Pitt and Shephard (1999).





</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori, Ryuji Hashimoto</p>


<h3>References</h3>


<p>Pitt, M. K., and N. Shephard (1999), &quot;Filtering via simulation: Auxiliary particle filters.&quot; Journal of the American statistical association 94, 590-599.
</p>
<p>Omori, Y., Chib, S., Shephard, N., and J. Nakajima (2007), &quot;Stochastic volatility model with leverage: fast and efficient likelihood inference,&quot; Journal of Econometrics, 140-2, 425-449.
</p>
<p>Takahashi, M., Omori, Y. and T. Watanabe (2022+), Stochastic volatility and  realized stochastic volatility models. JSS Research Series in Statistics, in press. Springer, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3; rho = -0.3;
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = rho*sigma_eta*eps + sigma_eta*sqrt(1-rho^2)*rnorm(1, 0, 1)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}
npart = 1000 
asv_apf(mu, phi, sigma_eta, rho, Y, npart)
</code></pre>

<hr>
<h2 id='asv_logML'>
Compute the logarithm of the marginal likelihood for the stochastic volatility models with leverage </h2><span id='topic+asv_logML'></span>

<h3>Description</h3>

<p>This function computes the logarithm of the marginal likelihood for 
stochastic volatility models with leverage (asymmetric stochastic volatility models): </p>


<h3>Usage</h3>

<pre><code class='language-R'>asv_logML(H, Theta, Theta_star, Y, iI = NULL, iM = NULL, vHyper = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asv_logML_+3A_h">H</code></td>
<td>

<p>T x 1 vector of latent log volatilities to start the reduced MCMC run to compute the log posterior density.</p>
</td></tr>
<tr><td><code id="asv_logML_+3A_theta">Theta</code></td>
<td>

<p>a vector of parameters to start the reduced MCMC run to compute the log posterior density. Theta = c(mu, phi, sigma_eta, rho)
</p>
</td></tr>
<tr><td><code id="asv_logML_+3A_theta_star">Theta_star</code></td>
<td>

<p>a vector of parameters to evaluate the log posterior density. Theta_star = c(mu, phi, sigma_eta, rho)
</p>
</td></tr>
<tr><td><code id="asv_logML_+3A_y">Y</code></td>
<td>

<p>T x 1 vector of returns
</p>
</td></tr>
<tr><td><code id="asv_logML_+3A_ii">iI</code></td>
<td>
<p>the number of particles to approximate the filtering density. Default is 5000.
</p>
</td></tr>
<tr><td><code id="asv_logML_+3A_im">iM</code></td>
<td>

<p>the number of iterations for the reduced MCMC run. Default is 5000.
</p>
</td></tr>
<tr><td><code id="asv_logML_+3A_vhyper">vHyper</code></td>
<td>

<p>a vector of hyper-parameters to evaluate the log posterior density. vHyper     = c(mu_0, sigma_0, a_0, b_0, a_1, b_1, n_0, S_0). Defaults is (0,1000, 1, 1, 1, 1, 0.01, 0.01)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4 x 2 matrix. 
</p>
<table>
<tr><td><code>Column 1</code></td>
<td>
<p>The logarithms of the marginal likelihood, the likelihood, the prior density and the posterior density.</p>
</td></tr>
<tr><td><code>Column 2</code></td>
<td>
<p>The standard errors of the logarithms of the marginal likelihood, the likelihood, the prior density and the posterior density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yasuhiro Omori
</p>


<h3>References</h3>

<p>Chib, S., and Jeliazkov, I. (2001). Marginal likelihood from the Metropolis-Hastings output. Journal of the American statistical association, 96(453), 270-281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3; rho = -0.3;
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = rho*sigma_eta*eps + sigma_eta*sqrt(1-rho^2)*rnorm(1, 0, 1)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}

# This is a toy example. Increase nsim and nburn
# until the convergence of MCMC in practice.
nsim = 300; nburn = 100;
vhyper = c(0.0,1000,1.0,1.0,1.0,1.0,0.01,0.01)
out  = asv_mcmc(Y, nsim, nburn, vhyper)
vmu = out[[1]]; vphi = out[[2]]; vsigma_eta = out[[3]]; vrho = out[[4]];mh  = out[[5]];
mu  = mean(vmu); phi = mean(vphi); sigma_eta = mean(vsigma_eta);
rho = mean(vrho);
#
h          = mh[nsim,]
theta      = c(vmu[nsim],vphi[nsim],vsigma_eta[nsim],vrho[nsim])
theta_star = c(mu, phi, sigma_eta, rho)

# Increase iM in practice (such as iI = 5000, iM =5000).
result = asv_logML(h, theta, theta_star, Y, 100, 100, vHyper = vhyper)
result1     = matrix(0, 4, 2)
result1[,1] =result[[1]]
result1[,2] =result[[2]]
  
colnames(result1) = c("Estimate", "Std Err")
rownames(result1) = c("Log marginal lik", "Log likelihood", "Log prior", "Log posterior")
print(result1, digit=4)
</code></pre>

<hr>
<h2 id='asv_mcmc'>
MCMC estimation for stochastic volatility models with leverage

</h2><span id='topic+asv_mcmc'></span>

<h3>Description</h3>

<p>This function estimates model parameters and latent log volatilities for 
stochastic volatility models with leverage (asymmetric stochastic volatility models):  
</p>
<p>y(t) = eps(t)*exp(h(t)/2), h(t+1) = mu + phi*(h(t)-mu) + eta(t)
</p>
<p>eps(t)~i.i.d. N(0,1), eta(t)~i.i.d. N(0,sigma_eta^2)
</p>
<p>where we assume the correlation between eps(t) and eta(t) equals to rho. Prior distributions are 
</p>
<p>mu~N(mu_0,sigma_0^2), (phi+1)/2~Beta(a_0,b_0), sigma_eta^2~IG(n_0/2,S_0/2),
</p>
<p>(rho+1)/2~Beta(a_1,b_1),
</p>
<p>where N, Beta and IG denote normal, beta and inverse gaussian distributions respectively. Note that the probability density function of x ~ IG(a,b) is proportional to (1/x)^(a+1)*exp(-b/x). 
</p>
<p>The highly efficient Markov chain Monte Carlo algorithm is based on the mixture 
sampler by Omori, Chib, Shephard and Nakajima (2007), but it further corrects 
the approximation error within the sampling algorithm.
See Takahashi, Omori and Watanabe (2022+) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asv_mcmc(return_vector, nSim = NULL, nBurn = NULL, vHyper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asv_mcmc_+3A_return_vector">return_vector</code></td>
<td>


<p>T x 1 vector (y(1),...,y(T))' of returns where T is a sample size.
</p>
</td></tr>
<tr><td><code id="asv_mcmc_+3A_nsim">nSim</code></td>
<td>


<p>Number of iterations for the MCMC estimation. Default value is 5000.
</p>
</td></tr>
<tr><td><code id="asv_mcmc_+3A_nburn">nBurn</code></td>
<td>


<p>Number of iterations for the burn-in period. Default value is the maximum integer less than or equal to 2*sqrt(nSim)+1.
</p>
</td></tr>
<tr><td><code id="asv_mcmc_+3A_vhyper">vHyper</code></td>
<td>

<p>8 x 1 vector of hyperparameters. (mu_0,sigma_0^2,a_0,b_0,a_1,b_1,n_0,S_0). Default values are (0,1000, 1,1,1,1,0.01,0.01).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A list with components:


</p>
<table>
<tr><td><code>vmu</code></td>
<td>
<p>nSim x 1 vector of MCMC samples of mu</p>
</td></tr>
<tr><td><code>vphi</code></td>
<td>
<p>nSim x 1 vector of MCMC samples of phi</p>
</td></tr>
<tr><td><code>vsigma_eta</code></td>
<td>
<p>nSim x 1 vector of MCMC samples of sigma_eta</p>
</td></tr>
<tr><td><code>vrho</code></td>
<td>
<p>nSim x 1 vector of MCMC samples of rho</p>
</td></tr>
<tr><td><code>mh</code></td>
<td>
<p>nSim x T matrix of latent log volatilities (h(1),...,h(T)). For example, the first column is a vector of MCMC samples for h(1).</p>
</td></tr>
</table>
<p>Further, the acceptance rates of MH algorithms will be shown for h and (mu,phi,sigma_eta, rho). 

</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori, Ryuji Hashimoto</p>


<h3>References</h3>


<p>Omori, Y., Chib, S., Shephard, N., and J. Nakajima (2007), &quot;Stochastic volatility model with leverage: fast and efficient likelihood inference,&quot; Journal of Econometrics, 140-2, 425-449.
</p>
<p>Takahashi, M., Omori, Y. and T. Watanabe (2022+), Stochastic volatility and  realized stochastic volatility models. JSS Research Series in Statistics, in press. Springer, Singapore.
</p>


<h3>See Also</h3>


<p>See also <code><a href="#topic+ReportMCMC">ReportMCMC</a></code>, <code><a href="#topic+asv_pf">asv_pf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3; rho = -0.3;
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = rho*sigma_eta*eps + sigma_eta*sqrt(1-rho^2)*rnorm(1, 0, 1)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}

# This is a toy example. Increase nsim and nburn
# until the convergence of MCMC in practice.

nsim = 500; nburn = 100;
vhyper = c(0.0,1000,1.0,1.0,1.0,1.0,0.01,0.01)
out  = asv_mcmc(Y, nsim, nburn, vhyper)
vmu = out[[1]]; vphi = out[[2]]; vsigma_eta = out[[3]]; vrho = out[[4]];
mh  = out[[5]];
</code></pre>

<hr>
<h2 id='asv_pf'>Particle filter for stochastic volatility models with leverage

</h2><span id='topic+asv_pf'></span>

<h3>Description</h3>


<p>The function computes the log likelihood given (mu, phi, sigma_eta, rho) for stochastic volatility models with leverage  (asymmetric stochastic volatility models).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asv_pf(mu, phi, sigma_eta, rho, Y, I)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asv_pf_+3A_mu">mu</code></td>
<td>
<p>parameter value such as the posterior mean of mu
</p>
</td></tr>
<tr><td><code id="asv_pf_+3A_phi">phi</code></td>
<td>
<p>parameter value such as the posterior mean of phi
</p>
</td></tr>
<tr><td><code id="asv_pf_+3A_sigma_eta">sigma_eta</code></td>
<td>
<p>parameter value such as the posterior mean of sigma_eta
</p>
</td></tr>
<tr><td><code id="asv_pf_+3A_rho">rho</code></td>
<td>
<p>parameter value such as the posterior mean of rho
</p>
</td></tr>
<tr><td><code id="asv_pf_+3A_y">Y</code></td>
<td>
<p>T x 1 vector (y(1),...,y(T))' of returns where T is a sample size.
</p>
</td></tr>
<tr><td><code id="asv_pf_+3A_i">I</code></td>
<td>
<p>Number of particles to approximate the filtering density.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logarithm of the likelihood of Y given parameters (mu, phi, sigma_eta, rho)





</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori, Ryuji Hashimoto</p>


<h3>References</h3>


<p>Omori, Y., Chib, S., Shephard, N., and J. Nakajima (2007), &quot;Stochastic volatility model with leverage: fast and efficient likelihood inference,&quot; Journal of Econometrics, 140-2, 425-449.
</p>
<p>Takahashi, M., Omori, Y. and T. Watanabe (2022+), Stochastic volatility and  realized stochastic volatility models. JSS Research Series in Statistics, in press. Springer, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3; rho = -0.3;
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = rho*sigma_eta*eps + sigma_eta*sqrt(1-rho^2)*rnorm(1, 0, 1)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}
npart = 5000 
asv_pf(mu, phi, sigma_eta, rho, Y, npart)
</code></pre>

<hr>
<h2 id='asv_posterior'>
Compute the logarithm of the posterior density for the stochastic volatility models with leverage</h2><span id='topic+asv_posterior'></span>

<h3>Description</h3>

<p>This function computes the logarithm of the posterior density for 
stochastic volatility models with leverage (asymmetric stochastic volatility models):  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asv_posterior(H, Theta, Theta_star, Y, iM = NULL, vHyper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asv_posterior_+3A_h">H</code></td>
<td>

<p>T x 1 vector of latent log volatilities to start the reduced MCMC run to compute the log posterior density.
</p>
</td></tr>
<tr><td><code id="asv_posterior_+3A_theta">Theta</code></td>
<td>

<p>a vector of parameters to start the reduced MCMC run to compute the log posterior density. Theta = c(mu, phi, sigma_eta, rho)
</p>
</td></tr>
<tr><td><code id="asv_posterior_+3A_theta_star">Theta_star</code></td>
<td>

<p>a vector of parameters to evaluate the log posterior density. Theta_star = c(mu, phi, sigma_eta, rho)
</p>
</td></tr>
<tr><td><code id="asv_posterior_+3A_y">Y</code></td>
<td>

<p>T x 1 vector of returns
</p>
</td></tr>
<tr><td><code id="asv_posterior_+3A_im">iM</code></td>
<td>

<p>the number of iterations for the reduced MCMC run. Default is 5000.
</p>
</td></tr>
<tr><td><code id="asv_posterior_+3A_vhyper">vHyper</code></td>
<td>

<p>a vector of hyper-parameters to evaluate the log posterior density. vHyper     = c(mu_0, sigma_0, a_0, b_0, a_1, b_1, n_0, S_0).  Defaults is (0,1000, 1, 1, 1, 1, 0.01, 0.01)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2 x 1 vector. The first element is the logarithm of the posterior density, and the second element is its standard error. 
</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori
</p>


<h3>References</h3>

<p>Chib, S., and Jeliazkov, I. (2001). Marginal likelihood from the Metropolis-Hastings output. Journal of the American statistical association, 96(453), 270-281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 100; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3; rho = -0.3;
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = rho*sigma_eta*eps + sigma_eta*sqrt(1-rho^2)*rnorm(1, 0, 1)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}

# This is a toy example. Increase nsim and nburn
# until the convergence of MCMC in practice.
nsim = 300; nburn = 100;
vhyper = c(0.0,1000,1.0,1.0,1.0,1.0,0.01,0.01)
out  = asv_mcmc(Y, nsim, nburn, vhyper)
vmu = out[[1]]; vphi = out[[2]]; vsigma_eta = out[[3]]; vrho = out[[4]];mh  = out[[5]];
mu  = mean(vmu); phi = mean(vphi); sigma_eta = mean(vsigma_eta);
rho = mean(vrho);
#
h          = mh[nsim,]
theta      = c(vmu[nsim],vphi[nsim],vsigma_eta[nsim],vrho[nsim])
theta_star = c(mu, phi, sigma_eta, rho)

# Increase iM in practice (such as iM =5000).
asv_posterior(h, theta, theta_star, Y, 100, vhyper)
</code></pre>

<hr>
<h2 id='asv_prior'>
Compute the logarithm of the prior density for the stochastic volatility models with leverage
</h2><span id='topic+asv_prior'></span>

<h3>Description</h3>

<p>This function computes the logarithm of the prior density for 
stochastic volatility models with leverage (asymmetric stochastic volatility models):  
</p>
<p>mu~N(mu_0,sigma_0^2), (phi+1)/2~Beta(a_0,b_0), sigma_eta^2~IG(n_0/2,S_0/2), (rho+1)/2~Beta(a_1,b_1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asv_prior(Theta_star, vHyper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asv_prior_+3A_theta_star">Theta_star</code></td>
<td>

<p>a vector of parameters to evaluate the prior density: Theta_star = c(mu, phi, sigma_eta, rho)
</p>
</td></tr>
<tr><td><code id="asv_prior_+3A_vhyper">vHyper</code></td>
<td>

<p>a vector of hyper-parameters to evaluate the prior density: vHyper     = c(mu_0, sigma_0, a_0, b_0, a_1, b_1, n_0, S_0)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The logarithm of the prior density.





</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori</p>


<h3>Examples</h3>

<pre><code class='language-R'>vhyper     = c(0, 1, 20, 1.5, 1, 1, 5, 0.05)
theta_star = c(0, 0.97, 0.3, -0.5) 
asv_prior(theta_star, vhyper)
</code></pre>

<hr>
<h2 id='ASV-package'>
Stochastic Volatility Models with or without Leverage
</h2><span id='topic+ASV-package'></span><span id='topic+ASV'></span>

<h3>Description</h3>

<p>This function estimates model parameters and latent log volatilities for 
stochastic volatility models:  
</p>
<p>y(t) = eps(t)*exp(h(t)/2), h(t+1) = mu + phi*(h(t)-mu) + eta(t)
</p>
<p>eps(t)~i.i.d. N(0,1), eta(t)~i.i.d. N(0,sigma_eta^2)
</p>
<p>where we assume the correlation between eps(t) and eta(t) equals to rho.
</p>


<h3>Details</h3>




<p>The highly efficient Markov chain Monte Carlo algorithm is based on the mixture 
sampler by Omori, Chib, Shephard and Nakajima (2007), but it further corrects the approximation error within the sampling algorithm.
See Takahashi, Omori and Watanabe (2022+) for more details.</p>


<h3>References</h3>


<p>Omori, Y., Chib, S., Shephard, N., and J. Nakajima (2007), &quot;Stochastic volatility model with leverage: fast and efficient likelihood inference,&quot; Journal of Econometrics, 140-2, 425-449.
</p>
<p>Takahashi, M., Omori, Y. and T. Watanabe (2022+), Stochastic volatility and  realized stochastic volatility models. JSS Research Series in Statistics, in press. Springer, Singapore.
</p>


<h3>See Also</h3>



<p><code><a href="#topic+sv_mcmc">sv_mcmc</a>, <a href="#topic+asv_mcmc">asv_mcmc</a>, <a href="#topic+sv_pf">sv_pf</a>, <a href="#topic+asv_pf">asv_pf</a>, <a href="#topic+sv_apf">sv_apf</a>, <a href="#topic+asv_apf">asv_apf</a></code>
</p>

<hr>
<h2 id='ReportMCMC'>Summary statistics, diagnostic statistics and plots.

</h2><span id='topic+ReportMCMC'></span>

<h3>Description</h3>

<p>This function reports summary statistics of the MCMC samples such as the posterior 
mean, the posterior standard deviation, the 95% credible interval, the expected sample size, the inefficiency factor, the posterior probability that the parameter is positive. Further it plots the sample path, the sample autocorrelation function
and the estimated posterior density.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ReportMCMC(mx, dBm = NULL, vname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReportMCMC_+3A_mx">mx</code></td>
<td>
<p>nSim x m matrix where nSim is the MCMC sample size and m is the 
number of parameters.

</p>
</td></tr>
<tr><td><code id="ReportMCMC_+3A_dbm">dBm</code></td>
<td>
<p>The bandwidth to compute the inefficient factor. Default value is the 
maximum integer less than or equal to 2*sqrt(nSim)+1.

</p>
</td></tr>
<tr><td><code id="ReportMCMC_+3A_vname">vname</code></td>
<td>
<p>The vector of variable names. Default names are Param1, Param2 and so forth.

</p>
</td></tr>



</table>


<h3>Value</h3>

<table>
<tr><td><code>Mean</code></td>
<td>
<p>The posterior mean of the parameter</p>
</td></tr>
<tr><td><code>Std Dev</code></td>
<td>
<p>The posterior standard deviation of the parameter</p>
</td></tr>
<tr><td><code>95%L</code></td>
<td>
<p>The lower limit of the 95% credible interval of the parameter</p>
</td></tr>
<tr><td><code>Median</code></td>
<td>
<p>The posterior median of the parameter</p>
</td></tr>
<tr><td><code>95%U</code></td>
<td>
<p>The upper limit of the 95% credible interval of the parameter</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>Expected sample size defined as the MCMC sample size divided by IF </p>
</td></tr>
<tr><td><code>IF</code></td>
<td>
<p>Inefficiency factor. See, for example, Kim, Shephard and Chib (1998).</p>
</td></tr>
<tr><td><code>CD</code></td>
<td>
<p>p-value of convergence diagnostics test by Geweke (1992). H_0:mean of the first 10% of MCMC samples is equal to mean of the last 50% of MCMC samples vs. H_1:not H_0.</p>
</td></tr>
<tr><td><code>Pr(+)</code></td>
<td>
<p>The posterior probability that the parameter is positive.</p>
</td></tr>
</table>
<p>Further, it plots the sample path, the sample autocorrelation function 
and the posterior density for each parameter.





</p>


<h3>Note</h3>

<p>&lsquo;freqdom&rsquo; package needs to be pre-installed.

</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori
</p>


<h3>References</h3>


<p>Kim, S., Shephard, N. and S. Chib (1998) &quot;Stochastic volatility: likelihood inference and comparison with ARCH models&quot;, The Review of Economic Studies, 65(3), 361-393.
</p>
<p>Geweke, J. (1992), &quot;Evaluating the accuracy of sampling-based approaches to calculating posterior moments,&quot;&quot; in Bayesian Statistics 4 (ed J.M. Bernardo, J.O. Berger, A.P. Dawid and A.F.M. Smith), Oxford, UK.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3; rho = 0.0;
h  = 0;   Y = c();

for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = rho*sigma_eta*eps + sigma_eta*sqrt(1-rho^2)*rnorm(1, 0, 1)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}

# This is a toy example. Increase nsim and nburn
# until the convergence of MCMC in practice.

nsim = 500; nburn = 100;
vhyper = c(0.0,1000,1.0,1.0,0.01,0.01)
out  = sv_mcmc(Y, nsim, nburn, vhyper)
vmu = out[[1]]; vphi = out[[2]]; vsigma_eta = out[[3]]; mh  = out[[4]];
myname = c(expression(mu), expression(phi),expression(sigma[eta]))
ReportMCMC(cbind(vmu,vphi,vsigma_eta), vname=myname)

</code></pre>

<hr>
<h2 id='sv_apf'>Auxiliary particle filter for stochastic volatility models without leverage

</h2><span id='topic+sv_apf'></span>

<h3>Description</h3>

<p>The function computes the log likelihood given (mu, phi, sigma_eta) for stochastic volatility models without leverage   (symmetric stochastic volatility models).
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sv_apf(mu, phi, sigma_eta, Y, I)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_apf_+3A_mu">mu</code></td>
<td>
<p>parameter value such as the posterior mean of mu

</p>
</td></tr>
<tr><td><code id="sv_apf_+3A_phi">phi</code></td>
<td>
<p>parameter value such as the posterior mean of phi

</p>
</td></tr>
<tr><td><code id="sv_apf_+3A_sigma_eta">sigma_eta</code></td>
<td>
<p>parameter value such as the posterior mean of sigma_eta

</p>
</td></tr>
<tr><td><code id="sv_apf_+3A_y">Y</code></td>
<td>
<p>T x 1 vector (y(1),...,y(T))' of returns where T is a sample size.

</p>
</td></tr>
<tr><td><code id="sv_apf_+3A_i">I</code></td>
<td>
<p>Number of particles to approximate the filtering density.

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logarithm of the likelihood of Y given parameters (mu, phi, sigma_eta) 
using the auxiliary particle filter by Pitt and Shephard (1999).





</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori, Ryuji Hashimoto</p>


<h3>References</h3>


<p>Pitt, M. K., and N. Shephard (1999), &quot;Filtering via simulation: Auxiliary particle filters.&quot; Journal of the American statistical association 94, 590-599.
</p>
<p>Omori, Y., Chib, S., Shephard, N., and J. Nakajima (2007), &quot;Stochastic volatility model with leverage: fast and efficient likelihood inference,&quot; Journal of Econometrics, 140-2, 425-449.
</p>
<p>Takahashi, M., Omori, Y. and T. Watanabe (2022+), Stochastic volatility and  realized stochastic volatility models. JSS Research Series in Statistics, in press. Springer, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3; 
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = rnorm(1, 0, sigma_eta)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}
npart = 5000 
sv_pf(mu, phi, sigma_eta, Y, npart)
</code></pre>

<hr>
<h2 id='sv_logML'>
Compute the logarithm of the marginal likelihood for the stochastic volatility models without leverage 
</h2><span id='topic+sv_logML'></span>

<h3>Description</h3>

<p>This function computes the logarithm of the marginal likelihood for stochastic volatility models without leverage (symmetric stochastic volatility models): </p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_logML(H, Theta, Theta_star, Y, iI = NULL, iM = NULL, vHyper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_logML_+3A_h">H</code></td>
<td>

<p>T x 1 vector of latent log volatilities to start the reduced MCMC run to compute the log posterior density.</p>
</td></tr>
<tr><td><code id="sv_logML_+3A_theta">Theta</code></td>
<td>

<p>a vector of parameters to start the reduced MCMC run to compute the log posterior density. Theta = c(mu, phi, sigma_eta)</p>
</td></tr>
<tr><td><code id="sv_logML_+3A_theta_star">Theta_star</code></td>
<td>

<p>a vector of parameters to evaluate the log posterior density. Theta_star = c(mu, phi, sigma_eta)</p>
</td></tr>
<tr><td><code id="sv_logML_+3A_y">Y</code></td>
<td>

<p>T x 1 vector of returns</p>
</td></tr>
<tr><td><code id="sv_logML_+3A_ii">iI</code></td>
<td>
<p>the number of particles to approximate the filtering density. Default is 5000.</p>
</td></tr>
<tr><td><code id="sv_logML_+3A_im">iM</code></td>
<td>

<p>the number of iterations for the reduced MCMC run. Default is 5000.
</p>
</td></tr>
<tr><td><code id="sv_logML_+3A_vhyper">vHyper</code></td>
<td>

<p>a vector of hyper-parameters to evaluate the log posterior density. vHyper     = c(mu_0, sigma_0, a_0, b_0, n_0, S_0). Defaults is (0,1000, 1, 1, 0.01, 0.01)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4 x 2 matrix. 
</p>
<table>
<tr><td><code>Column 1</code></td>
<td>
<p>The logarithms of the marginal likelihood, the likelihood, the prior density and the posterior density.</p>
</td></tr>
<tr><td><code>Column 2</code></td>
<td>
<p>The standard errors of the logarithms of the marginal likelihood, the likelihood, the prior density and the posterior density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yasuhiro Omori
</p>


<h3>References</h3>

<p>Chib, S., and Jeliazkov, I. (2001). Marginal likelihood from the Metropolis-Hastings output. Journal of the American statistical association, 96(453), 270-281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3;
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = sigma_eta*rnorm(1, 0, 1)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}

# This is a toy example. Increase nsim and nburn
# until the convergence of MCMC in practice.
nsim = 300; nburn = 100;
vhyper = c(0.0,1000,1.0,1.0,1.0,1.0,0.01,0.01)
out  = sv_mcmc(Y, nsim, nburn, vhyper)
vmu = out[[1]]; vphi = out[[2]]; vsigma_eta = out[[3]]; mh  = out[[4]];
mu  = mean(vmu); phi = mean(vphi); sigma_eta = mean(vsigma_eta);
#
h          = mh[nsim,]
theta      = c(vmu[nsim],vphi[nsim],vsigma_eta[nsim])
theta_star = c(mu, phi, sigma_eta)

# Increase iM in practice (such as iI = 5000, iM =5000).
result = sv_logML(h, theta, theta_star, Y, 100, 100, vHyper = vhyper)
result1     = matrix(0, 4, 2)
result1[,1] =result[[1]]
result1[,2] =result[[2]]
  
colnames(result1) = c("Estimate", "Std Err")
rownames(result1) = c("Log marginal lik", "Log likelihood", "Log prior", "Log posterior")
print(result1, digit=4)
</code></pre>

<hr>
<h2 id='sv_mcmc'>
MCMC estimation for stochastic volatility models without leverage

</h2><span id='topic+sv_mcmc'></span>

<h3>Description</h3>

<p>This function estimates model parameters and latent log volatilities for stochastic volatility models without leverage  (symmetric stochastic volatility models):  
</p>
<p>y(t) = eps(t)*exp(h(t)/2), h(t+1) = mu + phi*(h(t)-mu) + eta(t)
</p>
<p>eps(t)~i.i.d. N(0,1), eta(t)~i.i.d. N(0,sigma_eta^2)
</p>
<p>where we assume the correlation between eps(t) and eta(t) equals to zero.
Prior distributions are 
</p>
<p>mu~N(mu_0,sigma_0^2), (phi+1)/2~Beta(a_0,b_0), sigma_eta^2~IG(n_0/2,S_0/2)
</p>
<p>where N, Beta and IG denote normal, beta and inverse gaussian distributions respectively. Note that the probability density function of x ~ IG(a,b) is proportional to (1/x)^(a+1)*exp(-b/x). 
</p>
<p>The highly efficient Markov chain Monte Carlo algorithm is based on the mixture sampler by Omori, Chib, Shephard and Nakajima (2007), but it further corrects the approximation error within the sampling algorithm.
See Takahashi, Omori and Watanabe (2022+) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_mcmc(return_vector, nSim = NULL, nBurn = NULL, vHyper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_mcmc_+3A_return_vector">return_vector</code></td>
<td>


<p>T x 1 vector (y(1),...,y(T))' of returns where T is a sample size.
</p>
</td></tr>
<tr><td><code id="sv_mcmc_+3A_nsim">nSim</code></td>
<td>


<p>Number of iterations for the MCMC estimation. Default value is 5000.
</p>
</td></tr>
<tr><td><code id="sv_mcmc_+3A_nburn">nBurn</code></td>
<td>


<p>Number of iterations for the burn-in period. Default value is the maximum integer less than or equal to 2*sqrt(nSim)+1.
</p>
</td></tr>
<tr><td><code id="sv_mcmc_+3A_vhyper">vHyper</code></td>
<td>

<p>6 x 1 vector of hyperparameters. (mu_0,sigma_0^2,a_0,b_0,n_0,S_0). Default values are (0,1000, 1,1,0.01,0.01).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A list with components:


</p>
<table>
<tr><td><code>vmu</code></td>
<td>
<p>nSim x 1 vector of MCMC samples of mu</p>
</td></tr>
<tr><td><code>vphi</code></td>
<td>
<p>nSim x 1 vector of MCMC samples of phi</p>
</td></tr>
<tr><td><code>vsigma_eta</code></td>
<td>
<p>nSim x 1 vector of MCMC samples of sigma_eta</p>
</td></tr>
<tr><td><code>vmh</code></td>
<td>
<p>nSim x T matrix of latent log volatilities (h(1),...,h(T)). For example, the first column is a vector of MCMC samples for h(1).</p>
</td></tr>
</table>
<p>Further, the acceptance rates of MH algorithms will be shown for h and (mu,phi,sigma_eta). 

</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori, Ryuji Hashimoto</p>


<h3>References</h3>


<p>Omori, Y., Chib, S., Shephard, N., and J. Nakajima (2007), &quot;Stochastic volatility model with leverage: fast and efficient likelihood inference,&quot; Journal of Econometrics, 140-2, 425-449.
</p>
<p>Takahashi, M., Omori, Y. and T. Watanabe (2022+), Stochastic volatility and  realized stochastic volatility models. JSS Research Series in Statistics, in press. Springer, Singapore.
</p>


<h3>See Also</h3>


<p>See also <code><a href="#topic+ReportMCMC">ReportMCMC</a></code>, <code><a href="#topic+sv_pf">sv_pf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3;
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = rnorm(1, 0, sigma_eta)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}

# This is a toy example. Increase nsim and nburn
# until the convergence of MCMC in practice.

nsim = 500; nburn = 100;
vhyper = c(0.0,1000,1.0,1.0,0.01,0.01)
out  = sv_mcmc(Y, nsim, nburn, vhyper)
vmu = out[[1]]; vphi = out[[2]]; vsigma_eta = out[[3]]; mh  = out[[4]];
</code></pre>

<hr>
<h2 id='sv_pf'>Particle filter for stochastic volatility models without leverage

</h2><span id='topic+sv_pf'></span>

<h3>Description</h3>

<p>This function computes the log likelihood given (mu, phi, sigma_eta) for stochastic volatility models without leverage  (symmetric stochastic volatility models).
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sv_pf(mu, phi, sigma_eta, Y, I)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_pf_+3A_mu">mu</code></td>
<td>
<p>parameter value such as the posterior mean of mu

</p>
</td></tr>
<tr><td><code id="sv_pf_+3A_phi">phi</code></td>
<td>
<p>parameter value such as the posterior mean of phi

</p>
</td></tr>
<tr><td><code id="sv_pf_+3A_sigma_eta">sigma_eta</code></td>
<td>
<p>parameter value such as the posterior mean of sigma_eta

</p>
</td></tr>
<tr><td><code id="sv_pf_+3A_y">Y</code></td>
<td>
<p>T x 1 vector (y(1),...,y(T))' of returns where T is a sample size.

</p>
</td></tr>
<tr><td><code id="sv_pf_+3A_i">I</code></td>
<td>
<p>Number of particles to approximate the filtering density.

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logarithm of the likelihood of Y given parameters (mu, phi, sigma_eta)





</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori, Ryuji Hashimoto</p>


<h3>References</h3>


<p>Omori, Y., Chib, S., Shephard, N., and J. Nakajima (2007), &quot;Stochastic volatility model with leverage: fast and efficient likelihood inference,&quot; Journal of Econometrics, 140-2, 425-449.
</p>
<p>Takahashi, M., Omori, Y. and T. Watanabe (2022+), Stochastic volatility and  realized stochastic volatility models. JSS Research Series in Statistics, in press. Springer, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3;
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = rnorm(1, 0, sigma_eta)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}
npart = 5000 
sv_pf(mu, phi, sigma_eta, Y, npart)
</code></pre>

<hr>
<h2 id='sv_posterior'>
Compute the logarithm of the posterior density for the stochastic volatility models without leverage</h2><span id='topic+sv_posterior'></span>

<h3>Description</h3>

<p>This function computes the logarithm of the posterior density for stochastic volatility models without leverage (symmetric stochastic volatility models):</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_posterior(H, Theta, Theta_star, Y, iM = NULL, vHyper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_posterior_+3A_h">H</code></td>
<td>

<p>T x 1 vector of latent log volatilities to start the reduced MCMC run to compute the log posterior density.
</p>
</td></tr>
<tr><td><code id="sv_posterior_+3A_theta">Theta</code></td>
<td>

<p>a vector of parameters to start the reduced MCMC run to compute the log posterior density. Theta = c(mu, phi, sigma_eta)
</p>
</td></tr>
<tr><td><code id="sv_posterior_+3A_theta_star">Theta_star</code></td>
<td>

<p>a vector of parameters to evaluate the log posterior density. Theta_star = c(mu, phi, sigma_eta)
</p>
</td></tr>
<tr><td><code id="sv_posterior_+3A_y">Y</code></td>
<td>

<p>T x 1 vector of returns
</p>
</td></tr>
<tr><td><code id="sv_posterior_+3A_im">iM</code></td>
<td>

<p>the number of iterations for the reduced MCMC run. Default is 5000.
</p>
</td></tr>
<tr><td><code id="sv_posterior_+3A_vhyper">vHyper</code></td>
<td>

<p>a vector of hyper-parameters to evaluate the log posterior density. vHyper     = c(mu_0, sigma_0, a_0, b_0, n_0, S_0). Defaults is (0,1000, 1, 1, 0.01, 0.01)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2 x 1 vector. The first element is the logarithm of the posterior density, and the second element is its standard error. 





</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori

</p>


<h3>References</h3>

<p>Chib, S., and Jeliazkov, I. (2001). Marginal likelihood from the Metropolis-Hastings output. Journal of the American statistical association, 96(453), 270-281.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
nobs = 80; # n is often larger than 1000 in practice.
mu = 0; phi = 0.97; sigma_eta = 0.3;
h  = 0;   Y = c();
for(i in 1:nobs){
  eps = rnorm(1, 0, 1)
  eta = sigma_eta*rnorm(1, 0, 1)
  y   = eps * exp(0.5*h)
  h   = mu + phi * (h-mu) + eta
  Y   = append(Y, y)
}

# This is a toy example. Increase nsim and nburn
# until the convergence of MCMC in practice.
nsim = 500; nburn = 100;
vhyper = c(0.0,1000,1.0,1.0,0.01,0.01)
out  = sv_mcmc(Y, nsim, nburn, vhyper)
vmu = out[[1]]; vphi = out[[2]]; vsigma_eta = out[[3]]; mh  = out[[4]];
mu  = mean(vmu); phi = mean(vphi); sigma_eta = mean(vsigma_eta);
#
h          = mh[nsim,]
theta      = c(vmu[nsim],vphi[nsim],vsigma_eta[nsim])
theta_star = c(mu, phi, sigma_eta)

# Increase iM in practice (such as iM =5000).
sv_posterior(h, theta, theta_star, Y, 100, vhyper)
</code></pre>

<hr>
<h2 id='sv_prior'>
Compute the logarithm of the prior density for the stochastic volatility models without leverage
</h2><span id='topic+sv_prior'></span>

<h3>Description</h3>

<p>This function computes the logarithm of the prior density for 
stochastic volatility models without leverage (symmetric stochastic volatility models):  
</p>
<p>mu~N(mu_0,sigma_0^2), (phi+1)/2~Beta(a_0,b_0), sigma_eta^2~IG(n_0/2,S_0/2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_prior(Theta_star, vHyper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_prior_+3A_theta_star">Theta_star</code></td>
<td>

<p>a vector of parameters to evaluate the prior density: Theta_star = c(mu, phi, sigma_eta)
</p>
</td></tr>
<tr><td><code id="sv_prior_+3A_vhyper">vHyper</code></td>
<td>

<p>a vector of hyper-parameters to evaluate the prior density: vHyper     = c(mu_0, sigma_0, a_0, b_0, n_0, S_0)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The logarithm of the prior density.





</p>


<h3>Author(s)</h3>

<p>Yasuhiro Omori</p>


<h3>Examples</h3>

<pre><code class='language-R'>vhyper     = c(0, 1, 20, 1.5, 5, 0.05)
theta_star = c(0, 0.97, 0.3) 
sv_prior(theta_star, vhyper)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
