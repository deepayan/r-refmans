<!DOCTYPE html><html><head><title>Help for package TreeTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TreeTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.RandomParent'><p>Random parent vector</p></a></li>
<li><a href='#AddTip'><p>Add a tip to a phylogenetic tree</p></a></li>
<li><a href='#AncestorEdge'><p>Ancestral edge</p></a></li>
<li><a href='#ApeTime'><p>Read modification time from &quot;ape&quot; Nexus file</p></a></li>
<li><a href='#ArtificialExtinction'><p>Artificial Extinction</p></a></li>
<li><a href='#as.multiPhylo'><p>Convert object to <code>multiPhylo</code> class</p></a></li>
<li><a href='#as.Newick'><p>Write a phylogenetic tree in Newick format</p></a></li>
<li><a href='#brewer'><p>Brewer palettes</p></a></li>
<li><a href='#CharacterInformation'><p>Character information content</p></a></li>
<li><a href='#CladeSizes'><p>Clade sizes</p></a></li>
<li><a href='#CladisticInfo'><p>Cladistic information content of a tree</p></a></li>
<li><a href='#ClusterTable'><p>Convert phylogenetic tree to <code>ClusterTable</code></p></a></li>
<li><a href='#ClusterTable-methods'><p>S3 methods for <code>ClusterTable</code> objects</p></a></li>
<li><a href='#CollapseNode'><p>Collapse nodes on a phylogenetic tree</p></a></li>
<li><a href='#CompatibleSplits'><p>Which splits are compatible?</p></a></li>
<li><a href='#Consensus'><p>Construct consensus trees</p></a></li>
<li><a href='#ConsensusWithout'><p>Reduced consensus, omitting specified taxa</p></a></li>
<li><a href='#ConstrainedNJ'><p>Constrained neighbour-joining tree</p></a></li>
<li><a href='#DescendantEdges'><p>Identify descendant edges</p></a></li>
<li><a href='#DoubleFactorial'><p>Double factorial</p></a></li>
<li><a href='#doubleFactorials'><p>Double factorials</p></a></li>
<li><a href='#DropTip'><p>Drop leaves from tree</p></a></li>
<li><a href='#edge_to_splits'><p>Efficiently convert edge matrix to splits</p></a></li>
<li><a href='#EdgeAncestry'><p>Ancestors of an edge</p></a></li>
<li><a href='#EdgeDistances'><p>Distance between edges</p></a></li>
<li><a href='#EndSentence'><p>Add full stop to end of a sentence</p></a></li>
<li><a href='#EnforceOutgroup'><p>Generate a tree with a specified outgroup</p></a></li>
<li><a href='#ExtractTaxa'><p>Extract taxa from a matrix block</p></a></li>
<li><a href='#GenerateTree'><p>Generate pectinate, balanced or random trees</p></a></li>
<li><a href='#Hamming'><p>Hamming distance between taxa in a phylogenetic dataset</p></a></li>
<li><a href='#ImposeConstraint'><p>Force a tree to match a constraint</p></a></li>
<li><a href='#is.TreeNumber'><p>Is an object a <code>TreeNumber</code> object?</p></a></li>
<li><a href='#KeptPaths'><p>Paths present in reduced tree</p></a></li>
<li><a href='#KeptVerts'><p>Identify vertices retained when leaves are dropped</p></a></li>
<li><a href='#LabelSplits'><p>Label splits</p></a></li>
<li><a href='#LeafLabelInterchange'><p>Leaf label interchange</p></a></li>
<li><a href='#ListAncestors'><p>List ancestors</p></a></li>
<li><a href='#Lobo.data'><p>Data from Zhang et al. 2016</p></a></li>
<li><a href='#logDoubleFactorials'><p>Natural logarithms of double factorials</p></a></li>
<li><a href='#MakeTreeBinary'><p>Generate binary tree by collapsing polytomies</p></a></li>
<li><a href='#match.Splits'><p>Split matching</p></a></li>
<li><a href='#MatrixToPhyDat'><p>Convert between matrices and <code>phyDat</code> objects</p></a></li>
<li><a href='#MorphoBankDecode'><p>Decode MorphoBank text</p></a></li>
<li><a href='#MRCA'><p>Most recent common ancestor</p></a></li>
<li><a href='#MSTEdges'><p>Minimum spanning tree</p></a></li>
<li><a href='#N1Spr'><p>Number of trees one SPR step away</p></a></li>
<li><a href='#NDescendants'><p>Count descendants for each node in a tree</p></a></li>
<li><a href='#NewickTree'><p>Write Newick Tree</p></a></li>
<li><a href='#Neworder'><p>Reorder edges of a phylogenetic tree</p></a></li>
<li><a href='#NJTree'><p>Generate a neighbour joining tree</p></a></li>
<li><a href='#NodeDepth'><p>Distance of each node from tree exterior</p></a></li>
<li><a href='#NodeOrder'><p>Number of edges incident to each node in a tree</p></a></li>
<li><a href='#NPartitionPairs'><p>Distributions of tips consistent with a partition pair</p></a></li>
<li><a href='#NRooted'><p>Number of trees</p></a></li>
<li><a href='#nRootedShapes'><p>Number of rooted / unrooted tree shapes</p></a></li>
<li><a href='#NSplits'><p>Number of distinct splits</p></a></li>
<li><a href='#NTip'><p>Number of leaves in a phylogenetic tree</p></a></li>
<li><a href='#PairwiseDistances'><p>Distances between each pair of trees</p></a></li>
<li><a href='#PathLengths'><p>Calculate length of paths between each pair of vertices within tree</p></a></li>
<li><a href='#PolarizeSplits'><p>Polarize splits on a single taxon</p></a></li>
<li><a href='#print.TreeNumber'><p>Print <code>TreeNumber</code> object</p></a></li>
<li><a href='#ReadCharacters'><p>Read phylogenetic characters from file</p></a></li>
<li><a href='#ReadMrBayesTrees'><p>Read posterior tree sample produced by MrBayes</p></a></li>
<li><a href='#ReadTntTree'><p>Parse TNT Tree</p></a></li>
<li><a href='#Renumber'><p>Renumber a tree's nodes and tips</p></a></li>
<li><a href='#RenumberTips'><p>Renumber a tree's tips</p></a></li>
<li><a href='#RenumberTree'><p>Reorder tree edges and nodes</p></a></li>
<li><a href='#RightmostCharacter'><p>Rightmost character of string</p></a></li>
<li><a href='#RoguePlot'><p>Visualize position of rogue taxa</p></a></li>
<li><a href='#RootNode'><p>Which node is a tree's root?</p></a></li>
<li><a href='#RootTree'><p>Root or unroot a phylogenetic tree</p></a></li>
<li><a href='#SampleOne'><p>Quickly sample</p></a></li>
<li><a href='#sapply64'><p>Apply a function that returns 64-bit integers over a list or vector</p></a></li>
<li><a href='#sort.multiPhylo'><p>Sort a list of phylogenetic trees</p></a></li>
<li><a href='#SortTree'><p>Sort tree</p></a></li>
<li><a href='#SpectrumLegend'><p>Produce a legend for continuous gradient scales</p></a></li>
<li><a href='#SplitFrequency'><p>Frequency of splits</p></a></li>
<li><a href='#SplitInformation'><p>Phylogenetic information content of splitting leaves into two partitions</p></a></li>
<li><a href='#SplitMatchProbability'><p>Probability of matching this well</p></a></li>
<li><a href='#Splits'><p>Convert object to <code>Splits</code></p></a></li>
<li><a href='#SplitsInBinaryTree'><p>Maximum splits in an <em>n</em>-leaf tree</p></a></li>
<li><a href='#Stemwardness'><p>&quot;Stemwardness&quot; of a leaf</p></a></li>
<li><a href='#StringToPhyDat'><p>Convert between strings and <code>phyDat</code> objects</p></a></li>
<li><a href='#Subsplit'><p>Subset of a split on fewer leaves</p></a></li>
<li><a href='#Subtree'><p>Extract a subtree</p></a></li>
<li><a href='#SupportColour'><p>Colour for node support value</p></a></li>
<li><a href='#TipLabels'><p>Extract tip labels</p></a></li>
<li><a href='#TipsInSplits'><p>Tips contained within splits</p></a></li>
<li><a href='#TipTimedTree'><p>Display time-calibrated tree using tip information only</p></a></li>
<li><a href='#TotalCopheneticIndex'><p>Total Cophenetic Index</p></a></li>
<li><a href='#TreeIsRooted'><p>Is tree rooted?</p></a></li>
<li><a href='#TreeNumber'><p>Unique integer indices for bifurcating tree topologies</p></a></li>
<li><a href='#TreesMatchingSplit'><p>Number of trees matching a bipartition split</p></a></li>
<li><a href='#TreesMatchingTree'><p>Number of trees containing a tree</p></a></li>
<li><a href='#TreeTools-package'><p>TreeTools</p></a></li>
<li><a href='#TrivialSplits'><p>Identify and remove trivial splits</p></a></li>
<li><a href='#TrivialTree'><p>Generate trivial trees</p></a></li>
<li><a href='#Unquote'><p>Remove quotation marks from a string</p></a></li>
<li><a href='#unrootedKeys'><p>Integer representing shape of a tree</p></a></li>
<li><a href='#UnrootedTreesMatchingSplit'><p>Number of trees consistent with split</p></a></li>
<li><a href='#UnshiftTree'><p>Add tree to start of list</p></a></li>
<li><a href='#WriteTntCharacters'><p>Write morphological character matrix to TNT file</p></a></li>
<li><a href='#xor'><p>Exclusive OR operation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create, Modify and Analyse Phylogenetic Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>1.10.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>Incorporates C/C++ code from 'ape' by Emmanuel Paradis
&lt;doi:10.1093/bioinformatics/bty633&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient implementations of functions for the creation, 
  modification and analysis of phylogenetic trees.
  Applications include:
  generation of trees with specified shapes;
  tree rearrangement;
  analysis of tree shape;
  rooting of trees and extraction of subtrees;
  calculation and depiction of split support;
  plotting the position of rogue taxa (Klopfstein &amp; Spasojevic 2019)
  &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0212942">doi:10.1371/journal.pone.0212942</a>&gt;;
  calculation of ancestor-descendant relationships,
  of 'stemwardness' (Asher &amp; Smith, 2022) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyab072">doi:10.1093/sysbio/syab072</a>&gt;,
  and of tree balance (Mir et al. 2013) &lt;<a href="https://doi.org/10.1016%2Fj.mbs.2012.10.005">doi:10.1016/j.mbs.2012.10.005</a>&gt;;
  artificial extinction (Asher &amp; Smith, 2022) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyab072">doi:10.1093/sysbio/syab072</a>&gt;;
  import and export of trees from Newick, Nexus (Maddison et al. 1997)
  &lt;<a href="https://doi.org/10.1093%2Fsysbio%2F46.4.590">doi:10.1093/sysbio/46.4.590</a>&gt;,
  and TNT <a href="https://www.lillo.org.ar/phylogeny/tnt/">https://www.lillo.org.ar/phylogeny/tnt/</a> formats;
  and analysis of splits and cladistic information.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ms609.github.io/TreeTools/">https://ms609.github.io/TreeTools/</a>,
<a href="https://github.com/ms609/TreeTools/">https://github.com/ms609/TreeTools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ms609/TreeTools/issues/">https://github.com/ms609/TreeTools/issues/</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), ape (&ge; 5.6),</td>
</tr>
<tr>
<td>Imports:</td>
<td>bit64, lifecycle, colorspace, fastmatch (&ge; 1.1.3), methods,
PlotTools, RCurl, R.cache, Rdpack (&ge; 2.3),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, knitr, phangorn (&ge; 2.2.1), purrr, Rcpp (&ge; 1.0.8),
rlang, rmarkdown, testthat (&ge; 3.0), vdiffr (&ge; 1.0.0),</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>rcmdcheck</td>
</tr>
<tr>
<td>Config/Needs/coverage:</td>
<td>covr</td>
</tr>
<tr>
<td>Config/Needs/memcheck:</td>
<td>devtools</td>
</tr>
<tr>
<td>Config/Needs/metadata:</td>
<td>codemeta</td>
</tr>
<tr>
<td>Config/Needs/revdeps:</td>
<td>revdepcheck</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>pkgdown</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-18 07:30:14 UTC; pjjg18</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin R. Smith <a href="https://orcid.org/0000-0001-5660-1727"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Emmanuel Paradis <a href="https://orcid.org/0000-0003-3092-2199"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin R. Smith &lt;martin.smith@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 00:22:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='.RandomParent'>Random parent vector</h2><span id='topic+.RandomParent'></span>

<h3>Description</h3>

<p>Random parent vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.RandomParent(n, seed = sample.int(2147483647L, 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".RandomParent_+3A_n">n</code></td>
<td>
<p>Integer specifying number of leaves.</p>
</td></tr>
<tr><td><code id=".RandomParent_+3A_seed">seed</code></td>
<td>
<p>(Optional) Integer with which to seed Mersenne Twister random
number generator in C++.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector corresponding to the &quot;parent&quot; entry of
<code>tree[["edge"]]</code>, where the &quot;child&quot; entry, i.e. column 2, is numbered
sequentially from <code>1:n</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='AddTip'>Add a tip to a phylogenetic tree</h2><span id='topic+AddTip'></span><span id='topic+AddTipEverywhere'></span>

<h3>Description</h3>

<p><code>AddTip()</code> adds a tip to a phylogenetic tree at a specified location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddTip(
  tree,
  where = sample.int(tree[["Nnode"]] * 2 + 2L, size = 1) - 1L,
  label = "New tip",
  edgeLength = 0,
  lengthBelow = NULL,
  nTip = NTip(tree),
  nNode = tree[["Nnode"]],
  rootNode = RootNode(tree)
)

AddTipEverywhere(tree, label = "New tip", includeRoot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddTip_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="AddTip_+3A_where">where</code></td>
<td>
<p>The node or tip that should form the sister taxon to the new
node.  To add a new tip at the root, use <code>where = 0</code>.  By default, the
new tip is added to a random edge.</p>
</td></tr>
<tr><td><code id="AddTip_+3A_label">label</code></td>
<td>
<p>Character string providing the label to apply to the new tip.</p>
</td></tr>
<tr><td><code id="AddTip_+3A_edgelength">edgeLength</code></td>
<td>
<p>Numeric specifying length of new edge</p>
</td></tr>
<tr><td><code id="AddTip_+3A_lengthbelow">lengthBelow</code></td>
<td>
<p>Numeric specifying length below neighbour at which to
graft new edge. Values greater than the length of the edge will result
in negative edge lengths. If <code>NULL</code>, the default, the new tip will be added
at the midpoint of the broken edge. If inserting at the root (<code>where = 0</code>),
a new edge of length <code>lengthBelow</code> will be inserted.</p>
</td></tr>
<tr><td><code id="AddTip_+3A_ntip">nTip</code>, <code id="AddTip_+3A_nnode">nNode</code>, <code id="AddTip_+3A_rootnode">rootNode</code></td>
<td>
<p>Optional integer vectors specifying number of tips and
nodes in <code>tree</code>, and index of root node.
Not checked for correctness: specifying values here trades code safety for a
nominal speed increase.</p>
</td></tr>
<tr><td><code id="AddTip_+3A_includeroot">includeRoot</code></td>
<td>
<p>Logical; if <code>TRUE</code>, each position adjacent
to the root edge is considered to represent distinct edges; if <code>FALSE</code>,
they are treated as a single edge.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AddTip()</code> extends <code><a href="ape.html#topic+bind.tree">bind.tree</a></code>, which cannot handle
single-taxon trees.
</p>
<p><code>AddTipEverywhere()</code> adds a tip to each edge in turn.
</p>


<h3>Value</h3>

<p><code>AddTip()</code> returns a tree of class <code>phylo</code> with an additional tip
at the desired location.
</p>
<p><code>AddTipEverywhere()</code> returns a list of class <code>multiPhylo</code> containing
the trees produced by adding <code>label</code> to each edge of <code>tree</code> in turn.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Add one tree to another: <code><a href="ape.html#topic+bind.tree">bind.tree</a>()</code>
</p>
<p>Other tree manipulation: 
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(tree &lt;- BalancedTree(10))
ape::nodelabels()
ape::nodelabels(15, 15, bg="green")

plot(AddTip(tree, 15, "NEW_TIP"))

oldPar &lt;- par(mfrow = c(2, 4), mar = rep(0.3, 4), cex = 0.9)

backbone &lt;- BalancedTree(4)
# Treating the position of the root as instructive:
additions &lt;- AddTipEverywhere(backbone, includeRoot = TRUE)
xx &lt;- lapply(additions, plot)

par(mfrow=c(2, 3))
# Don't treat root edges as distinct:
additions &lt;- AddTipEverywhere(backbone, includeRoot = FALSE)
xx &lt;- lapply(additions, plot)

par(oldPar)

</code></pre>

<hr>
<h2 id='AncestorEdge'>Ancestral edge</h2><span id='topic+AncestorEdge'></span>

<h3>Description</h3>

<p>Ancestral edge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AncestorEdge(edge, parent, child)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AncestorEdge_+3A_edge">edge</code></td>
<td>
<p>Number of an edge</p>
</td></tr>
<tr><td><code id="AncestorEdge_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 1]</code></p>
</td></tr>
<tr><td><code id="AncestorEdge_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 2]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>AncestorEdge</code> returns a logical vector identifying whether each edge
is the immediate ancestor of the given edge.
</p>


<h3>See Also</h3>

<p>Other tree navigation: 
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- BalancedTree(6)
parent &lt;- tree$edge[, 1]
child &lt;- tree$edge[, 2]
plot(tree)
ape::edgelabels()
AncestorEdge(5, parent, child)
which(AncestorEdge(5, parent, child))

</code></pre>

<hr>
<h2 id='ApeTime'>Read modification time from &quot;ape&quot; Nexus file</h2><span id='topic+ApeTime'></span>

<h3>Description</h3>

<p><code>ApeTime()</code> reads the time that a tree written with &quot;ape&quot; was modified,
based on the comment in the Nexus file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ApeTime(filepath, format = "double")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ApeTime_+3A_filepath">filepath</code></td>
<td>
<p>Character string specifying path to the file.</p>
</td></tr>
<tr><td><code id="ApeTime_+3A_format">format</code></td>
<td>
<p>Format in which to return the time: &quot;double&quot; as a sortable numeric;
any other value to return a string in the format
<code style="white-space: pre;">&#8288;YYYY-MM-DD hh:mm:ss&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ApeTime()</code> returns the time that the specified file was created by
ape, in the format specified by <code>format</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='ArtificialExtinction'>Artificial Extinction</h2><span id='topic+ArtificialExtinction'></span><span id='topic+ArtificialExtinction.matrix'></span><span id='topic+ArtificialExtinction.phyDat'></span><span id='topic+ArtEx'></span>

<h3>Description</h3>

<p>Remove tokens that do not occur in a fossil &quot;template&quot; taxon from a living
taxon, to simulate the process of fossilization in removing data from
a phylogenetic dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ArtificialExtinction(
  dataset,
  subject,
  template,
  replaceAmbiguous = "ambig",
  replaceCoded = "original",
  replaceAll = TRUE,
  sampleFrom = NULL
)

## S3 method for class 'matrix'
ArtificialExtinction(
  dataset,
  subject,
  template,
  replaceAmbiguous = "ambig",
  replaceCoded = "original",
  replaceAll = TRUE,
  sampleFrom = NULL
)

## S3 method for class 'phyDat'
ArtificialExtinction(
  dataset,
  subject,
  template,
  replaceAmbiguous = "ambig",
  replaceCoded = "original",
  replaceAll = TRUE,
  sampleFrom = NULL
)

ArtEx(
  dataset,
  subject,
  template,
  replaceAmbiguous = "ambig",
  replaceCoded = "original",
  replaceAll = TRUE,
  sampleFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ArtificialExtinction_+3A_dataset">dataset</code></td>
<td>
<p>Phylogenetic dataset of class <code>phyDat</code> or <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="ArtificialExtinction_+3A_subject">subject</code></td>
<td>
<p>Vector identifying subject taxa, by name or index.</p>
</td></tr>
<tr><td><code id="ArtificialExtinction_+3A_template">template</code></td>
<td>
<p>Character or integer identifying taxon to use as a template.</p>
</td></tr>
<tr><td><code id="ArtificialExtinction_+3A_replaceambiguous">replaceAmbiguous</code>, <code id="ArtificialExtinction_+3A_replacecoded">replaceCoded</code></td>
<td>
<p>Character specifying whether tokens
that are ambiguous (<code style="white-space: pre;">&#8288;?&#8288;</code>) or coded (not <code style="white-space: pre;">&#8288;?&#8288;</code>) in the fossil template should
be replaced with:
</p>

<ul>
<li> <p><code>original</code>: Their original value; i.e. no change;
</p>
</li>
<li> <p><code>ambiguous</code>: The ambiguous token, <code style="white-space: pre;">&#8288;?&#8288;</code>;
</p>
</li>
<li> <p><code>binary</code>: The tokens <code>0</code> or <code>1</code>, with equal probability;
</p>
</li>
<li> <p><code>uniform</code>: One of the tokens present in <code>sampleFrom</code>, with equal
probability;
</p>
</li>
<li> <p><code>sample</code>: One of the tokens present in <code>sampleFrom</code>, sampled according
to their frequency.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ArtificialExtinction_+3A_replaceall">replaceAll</code></td>
<td>
<p>Logical: if <code>TRUE</code>, replace all tokens in a subject; if
<code>FALSE</code>, leave any ambiguous tokens (<code style="white-space: pre;">&#8288;?&#8288;</code>) ambiguous.</p>
</td></tr>
<tr><td><code id="ArtificialExtinction_+3A_samplefrom">sampleFrom</code></td>
<td>
<p>Vector identifying a subset of characters from which to
sample replacement tokens.
If <code>NULL</code>, replacement tokens will be sampled from the initial states of
all taxa not used as a template (including the subjects).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further details are provided in Asher and Smith (2022).
</p>
<p>Note: this simple implementation does not account for character contingency,
e.g. characters whose absence imposes inapplicable or absent tokens on
dependent characters.
</p>


<h3>Value</h3>

<p>A dataset with the same class as <code>dataset</code> in which entries that
are ambiguous in <code>template</code> are made ambiguous in <code>subject</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Asher R, Smith MR (2022).
&ldquo;Phylogenetic signal and bias in paleontology.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(4), 986&ndash;1008.
<a href="https://doi.org/10.1093/sysbio/syab072">doi:10.1093/sysbio/syab072</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
dataset &lt;- matrix(c(sample(0:2, 4 * 8, TRUE),
                    "0", "0", rep("?", 6)), nrow = 5,
                    dimnames = list(c(LETTERS[1:4], "FOSSIL"),
                                    paste("char", 1:8)), byrow = TRUE)
artex &lt;- ArtificialExtinction(dataset, c("A", "C"), "FOSSIL")
</code></pre>

<hr>
<h2 id='as.multiPhylo'>Convert object to <code>multiPhylo</code> class</h2><span id='topic+as.multiPhylo'></span><span id='topic+as.multiPhylo.phylo'></span><span id='topic+as.multiPhylo.list'></span><span id='topic+as.multiPhylo.phyDat'></span><span id='topic+as.multiPhylo.Splits'></span>

<h3>Description</h3>

<p>Converts representations of phylogenetic trees to an object of the &quot;ape&quot;
class <code>multiPhylo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.multiPhylo(x)

## S3 method for class 'phylo'
as.multiPhylo(x)

## S3 method for class 'list'
as.multiPhylo(x)

## S3 method for class 'phyDat'
as.multiPhylo(x)

## S3 method for class 'Splits'
as.multiPhylo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.multiPhylo_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.multiPhylo</code> returns an object of class <code>multiPhylo</code>
</p>
<p><code>as.multiPhylo.phyDat()</code> returns a list of trees, each corresponding
to the partitions implied by each non-ambiguous character in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.multiPhylo(BalancedTree(8))
as.multiPhylo(list(BalancedTree(8), PectinateTree(8)))
data("Lobo")
as.multiPhylo(Lobo.phy)
</code></pre>

<hr>
<h2 id='as.Newick'>Write a phylogenetic tree in Newick format</h2><span id='topic+as.Newick'></span><span id='topic+as.Newick.phylo'></span><span id='topic+as.Newick.list'></span><span id='topic+as.Newick.multiPhylo'></span>

<h3>Description</h3>

<p><code>as.Newick()</code> creates a character string representation of a phylogenetic
tree, in the Newick format, using R's internal tip numbering.
Use <code><a href="#topic+RenumberTips">RenumberTips()</a></code> to ensure that the internal numbering follows the
order you expect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Newick(x)

## S3 method for class 'phylo'
as.Newick(x)

## S3 method for class 'list'
as.Newick(x)

## S3 method for class 'multiPhylo'
as.Newick(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Newick_+3A_x">x</code></td>
<td>
<p>Object to convert to Newick format.
See Usage section for supported classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.Newick()</code> returns a character string representing <code>tree</code> in Newick
format.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>


<ul>
<li><p> Retain leaf labels: <code><a href="#topic+NewickTree">NewickTree()</a></code>
</p>
</li>
<li><p> Change R's internal numbering of leaves: <code><a href="#topic+RenumberTips">RenumberTips()</a></code>
</p>
</li>
<li><p> Write tree to text or file: <code><a href="ape.html#topic+write.tree">ape::write.tree()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>trees &lt;- list(BalancedTree(1:8), PectinateTree(8:1))
trees &lt;- lapply(trees, RenumberTips, 1:8)
as.Newick(trees)

</code></pre>

<hr>
<h2 id='brewer'>Brewer palettes</h2><span id='topic+brewer'></span>

<h3>Description</h3>

<p>A list of eleven Brewer palettes containing one to eleven colours that
are readily distinguished by colourblind viewers, followed by a twelfth
12-colour palette adapted for colour blindness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brewer
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 12.
</p>


<h3>Source</h3>



<ul>
<li> <p><a href="https://colorbrewer2.org/#type=diverging&amp;scheme=RdYlBu&amp;n=3">ColourBrewer2.org</a>
</p>
</li>
<li> <p><a href="http://mkweb.bcgsc.ca/colorblind/">Martin Krzywinski</a>
</p>
</li></ul>




<h3>Examples</h3>

<pre><code class='language-R'>data("brewer", package="TreeTools")
plot(0, type="n", xlim=c(1, 12), ylim=c(12, 1),
     xlab = "Colour", ylab="Palette")
for (i in seq_along(brewer)) text(seq_len(i), i, col=brewer[[i]])

</code></pre>

<hr>
<h2 id='CharacterInformation'>Character information content</h2><span id='topic+CharacterInformation'></span>

<h3>Description</h3>

<p><code>CharacterInformation()</code> calculates the cladistic information content
(Steel and Penny 2006) of a given character, in bits.
The total information in all characters gives a measure of the potential
utility of a dataset (Cotton and Wilkinson 2008), which can be
compared with a profile parsimony score (Faith and Trueman 2001) to
evaluate the degree of homoplasy within a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CharacterInformation(tokens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CharacterInformation_+3A_tokens">tokens</code></td>
<td>
<p>Character vector specifying the tokens assigned to each taxon for
a character.  Example: <code>c(0, 0, 0, 1, 1, 1, "?", "-")</code>.
</p>
<p>Note that ambiguous tokens such as <code>(01)</code> are not supported, and should be
replaced with <code style="white-space: pre;">&#8288;?&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CharacterInformation()</code> returns a numeric specifying the
phylogenetic information content of the character (<em>sensu</em>
Steel and Penny 2006), in bits.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>


<ul>
<li> <p>Cotton JA, Wilkinson M (2008).
&ldquo;Quantifying the potential utility of phylogenetic characters.&rdquo;
<em>Taxon</em>, <b>57</b>(1), 131&ndash;136.<br /><br /> Faith DP, Trueman JWH (2001).
&ldquo;Towards an inclusive philosophy for phylogenetic inference.&rdquo;
<em>Systematic Biology</em>, <b>50</b>(3), 331&ndash;350.
<a href="https://doi.org/10.1080/10635150118627">doi:10.1080/10635150118627</a>.<br /><br /> Steel MA, Penny D (2006).
&ldquo;Maximum parsimony and the phylogenetic information in multistate characters.&rdquo;
In Albert VA (ed.), <em>Parsimony, Phylogeny, and Genomics</em>, 163&ndash;178.
Oxford University Press, Oxford.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other split information functions: 
<code><a href="#topic+SplitInformation">SplitInformation</a>()</code>,
<code><a href="#topic+SplitMatchProbability">SplitMatchProbability</a>()</code>,
<code><a href="#topic+TreesMatchingSplit">TreesMatchingSplit</a>()</code>,
<code><a href="#topic+UnrootedTreesMatchingSplit">UnrootedTreesMatchingSplit</a>()</code>
</p>

<hr>
<h2 id='CladeSizes'>Clade sizes</h2><span id='topic+CladeSizes'></span>

<h3>Description</h3>

<p><code>CladeSizes()</code> reports the number of nodes in each clade in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CladeSizes(tree, internal = FALSE, nodes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CladeSizes_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="CladeSizes_+3A_internal">internal</code></td>
<td>
<p>Logical specifying whether internal nodes should be counted
towards the size of each clade.</p>
</td></tr>
<tr><td><code id="CladeSizes_+3A_nodes">nodes</code></td>
<td>
<p>Integer specifying indices of nodes at the base of clades
whose sizes should be returned.
If unspecified, counts will be provided for all nodes (including leaves).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CladeSizes()</code> returns the number of nodes (including leaves) that
are descended from each node, not including the node itself.
</p>


<h3>See Also</h3>

<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- BalancedTree(6)
plot(tree)
ape::nodelabels()
CladeSizes(tree, nodes = c(1, 8, 9))

</code></pre>

<hr>
<h2 id='CladisticInfo'>Cladistic information content of a tree</h2><span id='topic+CladisticInfo'></span><span id='topic+PhylogeneticInfo'></span><span id='topic+CladisticInfo.phylo'></span><span id='topic+CladisticInfo.Splits'></span><span id='topic+CladisticInfo.list'></span><span id='topic+CladisticInfo.multiPhylo'></span><span id='topic+PhylogeneticInformation'></span><span id='topic+CladisticInformation'></span>

<h3>Description</h3>

<p><code>CladisticInfo()</code> calculates the cladistic (phylogenetic) information
content of a phylogenetic object, <em>sensu</em> Thorley <em>et al.</em> (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CladisticInfo(x)

PhylogeneticInfo(x)

## S3 method for class 'phylo'
CladisticInfo(x)

## S3 method for class 'Splits'
CladisticInfo(x)

## S3 method for class 'list'
CladisticInfo(x)

## S3 method for class 'multiPhylo'
CladisticInfo(x)

PhylogeneticInformation(x)

CladisticInformation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CladisticInfo_+3A_x">x</code></td>
<td>
<p>Tree of class <code>phylo</code>, or a list thereof.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <abbr><span class="acronym">CIC</span></abbr> is the logarithm of the number of binary trees that
include the specified topology.
A base two logarithm gives an information content in bits.
</p>
<p>The <abbr><span class="acronym">CIC</span></abbr> was originally proposed by
Rohlf (1982), and formalised,
with an information-theoretic justification, by
Thorley et al. (1998).
Steel and Penny (2006) term the equivalent quantity
&quot;phylogenetic information content&quot; in the context of individual characters.
</p>
<p>The number of binary trees consistent with a cladogram provides a more
satisfactory measure of the resolution of a tree than simply
counting the number of edges resolved (Page 1992).
</p>


<h3>Value</h3>

<p><code>CladisticInfo()</code> returns a numeric giving the cladistic information
content of the input tree(s), in bits.
If passed a <code>Splits</code> object, it returns the information content of each
split in turn.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Page RD (1992).
&ldquo;Comments on the information content of classifications.&rdquo;
<em>Cladistics</em>, <b>8</b>(1), 87&ndash;95.
<a href="https://doi.org/10.1111/j.1096-0031.1992.tb00054.x">doi:10.1111/j.1096-0031.1992.tb00054.x</a>.<br /><br /> Rohlf FJ (1982).
&ldquo;Consensus indices for comparing classifications.&rdquo;
<em>Mathematical Biosciences</em>, <b>59</b>(1), 131&ndash;144.
<a href="https://doi.org/10.1016/0025-5564%2882%2990112-2">doi:10.1016/0025-5564(82)90112-2</a>.<br /><br /> Steel MA, Penny D (2006).
&ldquo;Maximum parsimony and the phylogenetic information in multistate characters.&rdquo;
In Albert VA (ed.), <em>Parsimony, Phylogeny, and Genomics</em>, 163&ndash;178.
Oxford University Press, Oxford.<br /><br /> Thorley JL, Wilkinson M, Charleston M (1998).
&ldquo;The information content of consensus trees.&rdquo;
In Rizzi A, Vichi M, Bock H (eds.), <em>Advances in Data Science and Classification</em>, 91&ndash;98.
Springer, Berlin.
ISBN 978-3-540-64641-9, <a href="https://doi.org/10.1007/978-3-642-72253-0">doi:10.1007/978-3-642-72253-0</a>.
</p>


<h3>See Also</h3>

<p>Other tree information functions: 
<code><a href="#topic+NRooted">NRooted</a>()</code>,
<code><a href="#topic+TreesMatchingTree">TreesMatchingTree</a>()</code>
</p>
<p>Other tree characterization functions: 
<code><a href="#topic+Consensus">Consensus</a>()</code>,
<code><a href="#topic+Stemwardness">Stemwardness</a></code>,
<code><a href="#topic+TotalCopheneticIndex">TotalCopheneticIndex</a>()</code>
</p>

<hr>
<h2 id='ClusterTable'>Convert phylogenetic tree to <code>ClusterTable</code></h2><span id='topic+ClusterTable'></span><span id='topic+as.ClusterTable'></span><span id='topic+as.ClusterTable.phylo'></span><span id='topic+as.ClusterTable.list'></span><span id='topic+as.ClusterTable.multiPhylo'></span>

<h3>Description</h3>

<p><code>as.ClusterTable()</code> converts a phylogenetic tree to a <code>ClusterTable</code> object,
which is an internal representation of its splits suitable for rapid tree
distance calculation (per Day, 1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ClusterTable(x, tipLabels = NULL, ...)

## S3 method for class 'phylo'
as.ClusterTable(x, tipLabels = NULL, ...)

## S3 method for class 'list'
as.ClusterTable(x, tipLabels = NULL, ...)

## S3 method for class 'multiPhylo'
as.ClusterTable(x, tipLabels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClusterTable_+3A_x">x</code></td>
<td>
<p>Object to convert into <code>ClusterTable</code>: perhaps a tree of class
<code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="ClusterTable_+3A_tiplabels">tipLabels</code></td>
<td>
<p>Character vector specifying sequence in which to order
tip labels.</p>
</td></tr>
<tr><td><code id="ClusterTable_+3A_...">...</code></td>
<td>
<p>Presently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row of a cluster table relates to a clade on a tree rooted on tip 1.
Tips are numbered according to the order in which they are visited in
preorder: i.e., if plotted using <code>plot(x)</code>, from the top of the page
downwards.  A clade containing the tips 2 .. 5 would be denoted by the
entry <code style="white-space: pre;">&#8288;2, 5&#8288;</code>, in either row 2 or row 5 of the cluster table.
</p>


<h3>Value</h3>

<p><code>as.ClusterTable()</code> returns an object of class <code>ClusterTable</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Day WHE (1985).
&ldquo;Optimal algorithms for comparing trees with labeled leaves.&rdquo;
<em>Journal of Classification</em>, <b>2</b>(1), 7&ndash;28.
<a href="https://doi.org/10.1007/BF01908061">doi:10.1007/BF01908061</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+ClusterTable-methods">S3 methods</a> for <code>ClusterTable</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree1 &lt;- ape::read.tree(text = "(A, (B, (C, (D, E))));");
tree2 &lt;- ape::read.tree(text = "(A, (B, (D, (C, E))));");
ct1 &lt;- as.ClusterTable(tree1)
summary(ct1)
as.matrix(ct1)

# Tip label order must match ct1 to allow comparison
ct2 &lt;- as.ClusterTable(tree2, tipLabels = LETTERS[1:5])
</code></pre>

<hr>
<h2 id='ClusterTable-methods'>S3 methods for <code>ClusterTable</code> objects</h2><span id='topic+ClusterTable-methods'></span><span id='topic+as.matrix.ClusterTable'></span><span id='topic+print.ClusterTable'></span><span id='topic+summary.ClusterTable'></span>

<h3>Description</h3>

<p>S3 methods for <code><a href="#topic+ClusterTable">ClusterTable</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ClusterTable'
as.matrix(x, ...)

## S3 method for class 'ClusterTable'
print(x, ...)

## S3 method for class 'ClusterTable'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClusterTable-methods_+3A_x">x</code>, <code id="ClusterTable-methods_+3A_object">object</code></td>
<td>
<p>Object of class <code>ClusterTable</code>.</p>
</td></tr>
<tr><td><code id="ClusterTable-methods_+3A_...">...</code></td>
<td>
<p>Additional arguments for consistency with S3 methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clustab &lt;- as.ClusterTable(TreeTools::BalancedTree(6))
as.matrix(clustab)
print(clustab)
summary(clustab)
</code></pre>

<hr>
<h2 id='CollapseNode'>Collapse nodes on a phylogenetic tree</h2><span id='topic+CollapseNode'></span><span id='topic+CollapseNode.phylo'></span><span id='topic+CollapseEdge'></span>

<h3>Description</h3>

<p>Collapses specified nodes or edges on a phylogenetic tree, resulting in
polytomies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CollapseNode(tree, nodes)

## S3 method for class 'phylo'
CollapseNode(tree, nodes)

CollapseEdge(tree, edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CollapseNode_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="CollapseNode_+3A_nodes">nodes</code>, <code id="CollapseNode_+3A_edges">edges</code></td>
<td>
<p>Integer vector specifying the nodes or edges in the tree
to be dropped.
(Use <code><a href="ape.html#topic+nodelabels">nodelabels</a>()</code> or
<code><a href="ape.html#topic+nodelabels">edgelabels</a>()</code>
to view numbers on a plotted tree.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CollapseNode()</code> and <code>CollapseEdge()</code> return a tree of class <code>phylo</code>,
corresponding to <code>tree</code> with the specified nodes or edges collapsed.
The length of each dropped edge will (naively) be added to each descendant
edge.
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(mfrow = c(3, 1), mar = rep(0.5, 4))

tree &lt;- as.phylo(898, 7)
tree$edge.length &lt;- 11:22
plot(tree)
nodelabels()
edgelabels()
edgelabels(round(tree$edge.length, 2),
           cex = 0.6, frame = "n", adj = c(1, -1))

# Collapse by node number
newTree &lt;- CollapseNode(tree, c(12, 13))
plot(newTree)
nodelabels()
edgelabels(round(newTree$edge.length, 2),
           cex = 0.6, frame = "n", adj = c(1, -1))

# Collapse by edge number
newTree &lt;- CollapseEdge(tree, c(2, 4))
plot(newTree)

par(oldPar)

</code></pre>

<hr>
<h2 id='CompatibleSplits'>Which splits are compatible?</h2><span id='topic+CompatibleSplits'></span><span id='topic+.CompatibleSplit'></span><span id='topic+.CompatibleRaws'></span>

<h3>Description</h3>

<p>Which splits are compatible?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompatibleSplits(splits, splits2)

.CompatibleSplit(a, b, nTip)

.CompatibleRaws(rawA, rawB, bitmask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompatibleSplits_+3A_splits">splits</code></td>
<td>
<p>An object of class <code><a href="#topic+as.Splits">Splits</a></code>.</p>
</td></tr>
<tr><td><code id="CompatibleSplits_+3A_splits2">splits2</code></td>
<td>
<p>A second <code>Splits</code> object.</p>
</td></tr>
<tr><td><code id="CompatibleSplits_+3A_a">a</code>, <code id="CompatibleSplits_+3A_b">b</code></td>
<td>
<p><a href="base.html#topic+raw">Raw</a> representations of splits, from a row of a <code>Splits</code>
object.</p>
</td></tr>
<tr><td><code id="CompatibleSplits_+3A_rawa">rawA</code>, <code id="CompatibleSplits_+3A_rawb">rawB</code></td>
<td>
<p>Raw representations of splits.</p>
</td></tr>
<tr><td><code id="CompatibleSplits_+3A_bitmask">bitmask</code></td>
<td>
<p>Raw masking bits that do not correspond to tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CompatibleSplits</code> returns a logical matrix specifying whether each
split in <code>splits</code> is compatible with each split in <code>splits2</code>.
</p>
<p><code>.CompatibleSplit</code> returns a logical vector stating whether splits
are compatible.
</p>
<p><code>.CompatibleRaws</code> returns a logical vector specifying whether input
raws are compatible.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splits &lt;- as.Splits(BalancedTree(8))
splits2 &lt;- as.Splits(PectinateTree(8))

summary(splits)
summary(splits2)

CompatibleSplits(splits, splits2)

</code></pre>

<hr>
<h2 id='Consensus'>Construct consensus trees</h2><span id='topic+Consensus'></span>

<h3>Description</h3>

<p><code>Consensus()</code> calculates the consensus of a set of trees, using the
algorithm of (Day 1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Consensus(trees, p = 1, check.labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Consensus_+3A_trees">trees</code></td>
<td>
<p>List of trees, optionally of class <code>multiPhylo</code>.</p>
</td></tr>
<tr><td><code id="Consensus_+3A_p">p</code></td>
<td>
<p>Proportion of trees that must contain a split for it to be reported
in the consensus.  <code>p = 0.5</code> gives the majority-rule consensus; <code>p = 1</code> (the
default) gives the strict consensus.</p>
</td></tr>
<tr><td><code id="Consensus_+3A_check.labels">check.labels</code></td>
<td>
<p>Logical specifying whether to check that all trees have
identical labels.  Defaults to <code>TRUE</code>, which is slower.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Consensus()</code> returns an object of class <code>phylo</code>, rooted as in the
first entry of <code>trees</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Day WHE (1985).
&ldquo;Optimal algorithms for comparing trees with labeled leaves.&rdquo;
<em>Journal of Classification</em>, <b>2</b>(1), 7&ndash;28.
<a href="https://doi.org/10.1007/BF01908061">doi:10.1007/BF01908061</a>.
</p>


<h3>See Also</h3>

<p><code>TreeDist::ConsensusInfo()</code> calculates the information content of a consensus
tree.
</p>
<p>Other consensus tree functions: 
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+RoguePlot">RoguePlot</a>()</code>
</p>
<p>Other tree characterization functions: 
<code><a href="#topic+CladisticInfo">CladisticInfo</a>()</code>,
<code><a href="#topic+Stemwardness">Stemwardness</a></code>,
<code><a href="#topic+TotalCopheneticIndex">TotalCopheneticIndex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Consensus(as.phylo(0:2, 8))
</code></pre>

<hr>
<h2 id='ConsensusWithout'>Reduced consensus, omitting specified taxa</h2><span id='topic+ConsensusWithout'></span><span id='topic+ConsensusWithout.phylo'></span><span id='topic+ConsensusWithout.multiPhylo'></span><span id='topic+ConsensusWithout.list'></span><span id='topic+MarkMissing'></span>

<h3>Description</h3>

<p><code>ConsensusWithout()</code> displays a consensus plot with specified taxa excluded,
which can be a useful way to increase the resolution of a consensus tree
when a few wildcard taxa obscure a consistent set of relationships.
<code>MarkMissing()</code> adds missing taxa as loose leaves on the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConsensusWithout(trees, tip = character(0), ...)

## S3 method for class 'phylo'
ConsensusWithout(trees, tip = character(0), ...)

## S3 method for class 'multiPhylo'
ConsensusWithout(trees, tip = character(0), ...)

## S3 method for class 'list'
ConsensusWithout(trees, tip = character(0), ...)

MarkMissing(tip, position = "bottomleft", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConsensusWithout_+3A_trees">trees</code></td>
<td>
<p>A list of phylogenetic trees, of class <code>multiPhylo</code> or <code>list</code>.</p>
</td></tr>
<tr><td><code id="ConsensusWithout_+3A_tip">tip</code></td>
<td>
<p>A character vector specifying the names (or numbers) of tips to
drop (using <code>ape::drop.tip()</code>).</p>
</td></tr>
<tr><td><code id="ConsensusWithout_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass on to <code><a href="ape.html#topic+consensus">ape::consensus()</a></code> or
<code><a href="graphics.html#topic+legend">legend()</a></code>.</p>
</td></tr>
<tr><td><code id="ConsensusWithout_+3A_position">position</code></td>
<td>
<p>Where to plot the missing taxa.
See <code><a href="graphics.html#topic+legend">legend()</a></code> for options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ConsensusWithout()</code> returns a consensus tree (of class <code>phylo</code>)
without the excluded taxa.
</p>
<p><code>MarkMissing()</code> provides a null return, after plotting the specified
<code>tip</code>s as a legend.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>
<p>Other tree properties: 
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PathLengths">PathLengths</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TreeIsRooted">TreeIsRooted</a>()</code>
</p>
<p>Other consensus tree functions: 
<code><a href="#topic+Consensus">Consensus</a>()</code>,
<code><a href="#topic+RoguePlot">RoguePlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(mfrow = c(1, 2), mar = rep(0.5, 4))

# Two trees differing only in placement of tip 2:
trees &lt;- as.phylo(c(0, 53), 6)
plot(trees[[1]])
plot(trees[[2]])

# Strict consensus (left panel) lacks resolution:
plot(ape::consensus(trees))

# But omitting tip two (right panel) reveals shared structure in common:
plot(ConsensusWithout(trees, "t2"))
MarkMissing("t2")

par(oldPar)
</code></pre>

<hr>
<h2 id='ConstrainedNJ'>Constrained neighbour-joining tree</h2><span id='topic+ConstrainedNJ'></span>

<h3>Description</h3>

<p>Constructs an approximation to a neighbour-joining tree, modified in order
to be consistent with a constraint.  Zero-length branches are collapsed
at random.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstrainedNJ(dataset, constraint, weight = 1L, ratio = TRUE, ambig = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstrainedNJ_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class <code>phyDat</code>,
whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="ConstrainedNJ_+3A_constraint">constraint</code></td>
<td>
<p>Either an object of class <code>phyDat</code>, in which case returned
trees will be perfectly compatible with each character in <code>constraint</code>;
or a tree of class <code>phylo</code>, in which each node in <code>constraint</code> will occur in
the returned tree.
See <a href="https://ms609.github.io/TreeSearch/articles/tree-search.html">vignette</a>
for further examples.</p>
</td></tr>
<tr><td><code id="ConstrainedNJ_+3A_weight">weight</code></td>
<td>
<p>Numeric specifying degree to up-weight characters in
<code>constraint</code>.</p>
</td></tr>
<tr><td><code id="ConstrainedNJ_+3A_ambig">ambig</code>, <code id="ConstrainedNJ_+3A_ratio">ratio</code></td>
<td>
<p>Settings of <code>ambig</code> and <code>ratio</code> to be used when
computing <code><a href="#topic+Hamming">Hamming()</a></code> distances between sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ConstrainedNJ()</code> returns a tree of class <code>phylo</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree generation functions: 
<code><a href="#topic+GenerateTree">GenerateTree</a></code>,
<code><a href="#topic+NJTree">NJTree</a>()</code>,
<code><a href="#topic+TreeNumber">TreeNumber</a></code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- MatrixToPhyDat(matrix(
  c(0, 1, 1, 1, 0, 1,
    0, 1, 1, 0, 0, 1), ncol = 2,
  dimnames = list(letters[1:6], NULL)))
constraint &lt;- MatrixToPhyDat(
  c(a = 0, b = 0, c = 0, d = 0, e = 1, f = 1))
plot(ConstrainedNJ(dataset, constraint))
</code></pre>

<hr>
<h2 id='DescendantEdges'>Identify descendant edges</h2><span id='topic+DescendantEdges'></span><span id='topic+AllDescendantEdges'></span>

<h3>Description</h3>

<p>Quickly identify edges that are &quot;descended&quot; from edges in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DescendantEdges(parent, child, edge = NULL, nEdge = length(parent))

AllDescendantEdges(parent, child, nEdge = length(parent))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DescendantEdges_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 1]</code></p>
</td></tr>
<tr><td><code id="DescendantEdges_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 2]</code>.</p>
</td></tr>
<tr><td><code id="DescendantEdges_+3A_edge">edge</code></td>
<td>
<p>Integer specifying the number of the edge whose child edges are
required (see <code><a href="ape.html#topic+nodelabels">edgelabels</a>()</code>).</p>
</td></tr>
<tr><td><code id="DescendantEdges_+3A_nedge">nEdge</code></td>
<td>
<p>number of edges (calculated from <code>length(parent)</code> if not
supplied).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DescendantEdges()</code> returns a logical vector stating whether each
edge in turn is a descendant of the specified edge (or the edge itself).
</p>
<p><code>AllDescendantEdges()</code> is deprecated; use <code>DescendantEdges()</code>
instead.
It returns a matrix of class logical, with row <em>N</em> specifying whether each
edge is a descendant of edge <em>N</em> (or the edge itself).
</p>


<h3>See Also</h3>

<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>

<hr>
<h2 id='DoubleFactorial'>Double factorial</h2><span id='topic+DoubleFactorial'></span><span id='topic+DoubleFactorial64'></span><span id='topic+LnDoubleFactorial'></span><span id='topic+Log2DoubleFactorial'></span><span id='topic+LogDoubleFactorial'></span><span id='topic+LnDoubleFactorial.int'></span><span id='topic+LogDoubleFactorial.int'></span>

<h3>Description</h3>

<p>Calculate the double factorial of a number, or its logarithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoubleFactorial(n)

DoubleFactorial64(n)

LnDoubleFactorial(n)

Log2DoubleFactorial(n)

LogDoubleFactorial(n)

LnDoubleFactorial.int(n)

LogDoubleFactorial.int(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DoubleFactorial_+3A_n">n</code></td>
<td>
<p>Vector of integers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the double factorial, <em>n</em> * (<em>n</em> - 2) * (<em>n</em> - 4) *
(<em>n</em> - 6) * ...
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>DoubleFactorial64()</code>: Returns the exact double factorial as a 64-bit
<code>integer64</code>, for <code>n</code> &lt; 34.
</p>
</li>
<li> <p><code>LnDoubleFactorial()</code>: Returns the logarithm of the double factorial.
</p>
</li>
<li> <p><code>Log2DoubleFactorial()</code>: Returns the logarithm of the double factorial.
</p>
</li>
<li> <p><code>LnDoubleFactorial.int()</code>: Slightly faster, when x is known to be length one
and below 50001
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other double factorials: 
<code><a href="#topic+doubleFactorials">doubleFactorials</a></code>,
<code><a href="#topic+logDoubleFactorials">logDoubleFactorials</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DoubleFactorial (-4:0) # Return 1 if n &lt; 2
DoubleFactorial (2) # 2
DoubleFactorial (5) # 1 * 3 * 5
exp(LnDoubleFactorial.int (8)) # log(2 * 4 * 6 * 8)
DoubleFactorial64(31)
</code></pre>

<hr>
<h2 id='doubleFactorials'>Double factorials</h2><span id='topic+doubleFactorials'></span>

<h3>Description</h3>

<p>A vector with pre-calculated values of double factorials up to 300!!,
and the logarithms of double factorials up to 50 000!!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleFactorials
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 300.
</p>


<h3>Details</h3>

<p>301!! is too large to store as an integer; use <code>logDoubleFactorials</code> instead.
</p>


<h3>See Also</h3>

<p>Other double factorials: 
<code><a href="#topic+DoubleFactorial">DoubleFactorial</a>()</code>,
<code><a href="#topic+logDoubleFactorials">logDoubleFactorials</a></code>
</p>

<hr>
<h2 id='DropTip'>Drop leaves from tree</h2><span id='topic+DropTip'></span><span id='topic+DropTip.phylo'></span><span id='topic+DropTip.Splits'></span><span id='topic+DropTipPhylo'></span><span id='topic+DropTip.multiPhylo'></span><span id='topic+DropTip.list'></span><span id='topic+DropTip.NULL'></span><span id='topic+KeepTipPreorder'></span><span id='topic+KeepTipPostorder'></span><span id='topic+KeepTip'></span>

<h3>Description</h3>

<p><code>DropTip()</code> removes specified leaves from a phylogenetic tree, collapsing
incident branches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DropTip(tree, tip, preorder = TRUE, check = TRUE)

## S3 method for class 'phylo'
DropTip(tree, tip, preorder = TRUE, check = TRUE)

## S3 method for class 'Splits'
DropTip(tree, tip, preorder, check = TRUE)

DropTipPhylo(tree, tip, preorder = TRUE, check = TRUE)

## S3 method for class 'multiPhylo'
DropTip(tree, tip, preorder = TRUE, check = TRUE)

## S3 method for class 'list'
DropTip(tree, tip, preorder = TRUE, check = TRUE)

## S3 method for class ''NULL''
DropTip(tree, tip, preorder = TRUE, check = TRUE)

KeepTipPreorder(tree, tip)

KeepTipPostorder(tree, tip)

KeepTip(tree, tip, preorder = TRUE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DropTip_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="DropTip_+3A_tip">tip</code></td>
<td>
<p>Character vector specifying labels of leaves in tree to be
dropped, or integer vector specifying the indices of leaves to be dropped.
Specifying the index of an internal node will drop all descendants of that
node.</p>
</td></tr>
<tr><td><code id="DropTip_+3A_preorder">preorder</code></td>
<td>
<p>Logical specifying whether to <a href="#topic+Preorder">Preorder</a> <code>tree</code> before
dropping tips.  Specifying <code>FALSE</code> saves a little time, but will result in
undefined behaviour if <code>tree</code> is not in preorder.</p>
</td></tr>
<tr><td><code id="DropTip_+3A_check">check</code></td>
<td>
<p>Logical specifying whether to check validity of <code>tip</code>. If
<code>FALSE</code> and <code>tip</code> contains entries that do not correspond to leaves of the
tree, undefined behaviour may occur.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from <code><a href="ape.html#topic+drop.tip">ape::drop.tip()</a></code>, which roots unrooted trees,
and which can crash when trees' internal numbering follows unexpected schema.
</p>


<h3>Value</h3>

<p><code>DropTip()</code> returns a tree of class <code>phylo</code>, with the requested
leaves removed. The edges of the tree will be numbered in preorder,
but their sequence may not conform to the conventions of <code><a href="#topic+Preorder">Preorder()</a></code>.
</p>
<p><code>KeepTip()</code> returns <code>tree</code> with all leaves not in <code>tip</code> removed,
in preorder.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>DropTipPhylo()</code>: Direct call to <code>DropTip.phylo()</code>, to avoid overhead of
querying object's class.
</p>
</li>
<li> <p><code>KeepTipPreorder()</code>: Faster version with no checks.
Does not retain tip labels or edge weights.
edges must be listed in preorder.
May crash if improper input is specified.
</p>
</li>
<li> <p><code>KeepTipPostorder()</code>: Faster version with no checks.
Does not retain tip labels or edge weights.
edges must be listed in postorder.
May crash if improper input is specified.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>
<p>Other split manipulation functions: 
<code><a href="#topic+Subsplit">Subsplit</a>()</code>,
<code><a href="#topic+TrivialSplits">TrivialSplits</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- BalancedTree(9)
plot(tree)
plot(DropTip(tree, c("t5", "t6")))

unrooted &lt;- UnrootTree(tree)
plot(unrooted)
plot(DropTip(unrooted, 4:5))

summary(DropTip(as.Splits(tree), 4:5))
</code></pre>

<hr>
<h2 id='edge_to_splits'>Efficiently convert edge matrix to splits</h2><span id='topic+edge_to_splits'></span>

<h3>Description</h3>

<p>Wrapper for internal C++ function for maximum efficiency.
Improper input may crash R.  Behaviour not guaranteed.
It is advisable to contact the package maintainers before
relying on this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_to_splits(
  edge,
  edgeOrder,
  tipLabels = NULL,
  asSplits = TRUE,
  nTip = NTip(edge),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_to_splits_+3A_edge">edge</code></td>
<td>
<p>A matrix with two columns, with each row listing the parent and
child node of an edge in a phylogenetic tree.  Property <code>edge</code> of objects
of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="edge_to_splits_+3A_edgeorder">edgeOrder</code></td>
<td>
<p>Integer vector such that <code>edge[edgeOrder, ]</code> returns a
postorder ordering of edges.</p>
</td></tr>
<tr><td><code id="edge_to_splits_+3A_tiplabels">tipLabels</code></td>
<td>
<p>Character vector specifying sequence in which to order
tip labels.  Label order must (currently) match to combine or compare separate
<code>Splits</code> objects.</p>
</td></tr>
<tr><td><code id="edge_to_splits_+3A_assplits">asSplits</code></td>
<td>
<p>Logical specifying whether to return a <code>Splits</code> object,
or an unannotated two-dimensional array (useful where performance is
paramount).</p>
</td></tr>
<tr><td><code id="edge_to_splits_+3A_ntip">nTip</code></td>
<td>
<p>Integer specifying number of leaves in tree.</p>
</td></tr>
<tr><td><code id="edge_to_splits_+3A_...">...</code></td>
<td>
<p>Presently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>edge_to_splits()</code> uses the same return format as <code>as.Splits()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Splits">as.Splits()</a></code> offers a safe access point to this
function that should be suitable for most users.
</p>

<hr>
<h2 id='EdgeAncestry'>Ancestors of an edge</h2><span id='topic+EdgeAncestry'></span>

<h3>Description</h3>

<p>Quickly identify edges that are &quot;ancestral&quot; to a particular edge in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EdgeAncestry(edge, parent, child, stopAt = (parent == min(parent)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EdgeAncestry_+3A_edge">edge</code></td>
<td>
<p>Integer specifying the number of the edge whose child edges
should be returned.</p>
</td></tr>
<tr><td><code id="EdgeAncestry_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 1]</code></p>
</td></tr>
<tr><td><code id="EdgeAncestry_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 2]</code>.</p>
</td></tr>
<tr><td><code id="EdgeAncestry_+3A_stopat">stopAt</code></td>
<td>
<p>Integer or logical vector specifying the edge(s) at which to
terminate the search; defaults to the edges with the smallest parent,
which will be the root edges if nodes are numbered <a href="#topic+Cladewise">Cladewise</a> or in
<a href="#topic+Preorder">Preorder</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>EdgeAncestry()</code> returns a logical vector stating whether each edge
in turn is a descendant of the specified edge.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- PectinateTree(6)
plot(tree)
ape::edgelabels()
parent &lt;- tree$edge[, 1]
child &lt;- tree$edge[, 2]
EdgeAncestry(7, parent, child)
which(EdgeAncestry(7, parent, child, stopAt = 4))

</code></pre>

<hr>
<h2 id='EdgeDistances'>Distance between edges</h2><span id='topic+EdgeDistances'></span>

<h3>Description</h3>

<p>Number of nodes that must be traversed to navigate from each edge to
each other edge within a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EdgeDistances(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EdgeDistances_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>EdgeDistances()</code> returns a symmetrical matrix listing the number
of edges that must be traversed to travel from each numbered edge to each
other.
The two edges straddling the root of a rooted tree
are treated as a single edge.  Add a &quot;root&quot; tip using <code><a href="#topic+AddTip">AddTip()</a></code> if the
position of the root is significant.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tree &lt;- BalancedTree(5)
plot(tree)
ape::edgelabels()

EdgeDistances(tree)

</code></pre>

<hr>
<h2 id='EndSentence'>Add full stop to end of a sentence</h2><span id='topic+EndSentence'></span>

<h3>Description</h3>

<p>Add full stop to end of a sentence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EndSentence(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EndSentence_+3A_string">string</code></td>
<td>
<p>Input string</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>EndSentence()</code> returns <code>string</code>, punctuated with a final full stop
(period).'
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>


<h3>See Also</h3>

<p>Other string parsing functions: 
<code><a href="#topic+MorphoBankDecode">MorphoBankDecode</a>()</code>,
<code><a href="#topic+RightmostCharacter">RightmostCharacter</a>()</code>,
<code><a href="#topic+Unquote">Unquote</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EndSentence("Hello World") # "Hello World."
</code></pre>

<hr>
<h2 id='EnforceOutgroup'>Generate a tree with a specified outgroup</h2><span id='topic+EnforceOutgroup'></span><span id='topic+EnforceOutgroup.phylo'></span><span id='topic+EnforceOutgroup.character'></span>

<h3>Description</h3>

<p>Deprecated. Use <code>RootTree()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EnforceOutgroup(tree, outgroup)

## S3 method for class 'phylo'
EnforceOutgroup(tree, outgroup)

## S3 method for class 'character'
EnforceOutgroup(tree, outgroup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EnforceOutgroup_+3A_tree">tree</code></td>
<td>
<p>Either a tree of class <code>phylo</code>; or (for <code>EnforceOutgroup()</code>)
a character vector listing the names of all the taxa in the tree, from which
a random tree will be generated.</p>
</td></tr>
<tr><td><code id="EnforceOutgroup_+3A_outgroup">outgroup</code></td>
<td>
<p>Character vector containing the names of taxa to include in
the outgroup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a tree or a list of taxa, <code>EnforceOutgroup()</code> rearranges the ingroup
and outgroup taxa such that the two are sister taxa across the root, without
changing the relationships within the ingroup or within the outgroup.
</p>


<h3>Value</h3>

<p><code>EnforceOutgroup()</code> returns a tree of class <code>phylo</code> where all
outgroup taxa are sister to all remaining taxa, without modifying the
ingroup topology.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>For a more robust implementation, see <code><a href="#topic+RootTree">RootTree()</a></code>, which will
eventually replace this function
(<a href="https://github.com/ms609/TreeTools/issues/30">#30</a>).
</p>
<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>

<hr>
<h2 id='ExtractTaxa'>Extract taxa from a matrix block</h2><span id='topic+ExtractTaxa'></span><span id='topic+NexusTokens'></span>

<h3>Description</h3>

<p>Extract leaf labels and character states from a Nexus-formatted matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractTaxa(matrixLines, character_num = NULL, continuous = FALSE)

NexusTokens(tokens, character_num = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractTaxa_+3A_matrixlines">matrixLines</code></td>
<td>
<p>Character vector containing lines of a file that include
a phylogenetic matrix. See <code><a href="#topic+ReadCharacters">ReadCharacters()</a></code> for expected format.</p>
</td></tr>
<tr><td><code id="ExtractTaxa_+3A_character_num">character_num</code></td>
<td>
<p>Index of character(s) to return.
<code>NULL</code>, the default, returns all characters.</p>
</td></tr>
<tr><td><code id="ExtractTaxa_+3A_continuous">continuous</code></td>
<td>
<p>Logical specifying whether characters are continuous.
Treated as discrete if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ExtractTaxa_+3A_tokens">tokens</code></td>
<td>
<p>Vector of character strings corresponding to phylogenetic
tokens.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ExtractTaxa()</code> returns a matrix with <em>n</em> rows, each named for the
relevant taxon, and <em>c</em> columns,
each corresponding to the respective character specified in <code>character_num</code>.
</p>
<p><code>NexusTokens()</code> returns a character vector in which each entry
corresponds to the states of a phylogenetic character, or a list containing
an error message if input is invalid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileName &lt;- paste0(system.file(package = "TreeTools"),
                   "/extdata/input/dataset.nex")
matrixLines &lt;- readLines(fileName)[6:11]
ExtractTaxa(matrixLines)

NexusTokens("01[01]-?")
</code></pre>

<hr>
<h2 id='GenerateTree'>Generate pectinate, balanced or random trees</h2><span id='topic+GenerateTree'></span><span id='topic+RandomTree'></span><span id='topic+PectinateTree'></span><span id='topic+BalancedTree'></span><span id='topic+StarTree'></span>

<h3>Description</h3>

<p><code>RandomTree()</code>, <code>PectinateTree()</code>, <code>BalancedTree()</code> and <code>StarTree()</code>
generate trees with the specified shapes and leaf labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomTree(tips, root = FALSE, nodes)

PectinateTree(tips)

BalancedTree(tips)

StarTree(tips)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateTree_+3A_tips">tips</code></td>
<td>
<p>An integer specifying the number of tips, or a character vector
naming the tips, or any other object from which <code><a href="#topic+TipLabels">TipLabels()</a></code> can
extract leaf labels.</p>
</td></tr>
<tr><td><code id="GenerateTree_+3A_root">root</code></td>
<td>
<p>Character or integer specifying tip to use as root, if desired;
or <code>FALSE</code> for an unrooted tree.</p>
</td></tr>
<tr><td><code id="GenerateTree_+3A_nodes">nodes</code></td>
<td>
<p>Number of nodes to generate.  The default and maximum,
<code>tips - 1</code>, generates a binary tree; setting a lower value will induce
polytomies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each function returns an unweighted binary tree of class <code>phylo</code> with
the specified leaf labels. Trees are rooted unless <code>root = FALSE</code>.
</p>
<p><code>RandomTree()</code> returns a topology drawn at random from the uniform
distribution (i.e. each binary tree is drawn with equal probability).
Trees are generated by inserting
each tip in term at a randomly selected edge in the tree.
Random numbers are generated using a Mersenne Twister.
If <code>root = FALSE</code>, the tree will be unrooted, with the first tip in a
basal position.  Otherwise, the tree will be rooted on <code>root</code>.
</p>
<p><code>PectinateTree()</code> returns a pectinate (caterpillar) tree.
</p>
<p><code>BalancedTree()</code> returns a balanced (symmetrical) tree, in preorder.
</p>
<p><code>StarTree()</code> returns a completely unresolved (star) tree.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree generation functions: 
<code><a href="#topic+ConstrainedNJ">ConstrainedNJ</a>()</code>,
<code><a href="#topic+NJTree">NJTree</a>()</code>,
<code><a href="#topic+TreeNumber">TreeNumber</a></code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RandomTree(LETTERS[1:10])

data("Lobo")
RandomTree(Lobo.phy)

plot(PectinateTree(LETTERS[1:10]))

plot(BalancedTree(LETTERS[1:10]))
plot(StarTree(LETTERS[1:10]))

</code></pre>

<hr>
<h2 id='Hamming'>Hamming distance between taxa in a phylogenetic dataset</h2><span id='topic+Hamming'></span>

<h3>Description</h3>

<p>The Hamming distance between a pair of taxa is the number of characters
with a different coding, i.e. the smallest number of evolutionary steps
that must have occurred since their common ancestor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hamming(
  dataset,
  ratio = TRUE,
  ambig = c("median", "mean", "zero", "one", "na", "nan")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hamming_+3A_dataset">dataset</code></td>
<td>
<p>Object of class <code>phyDat</code>.</p>
</td></tr>
<tr><td><code id="Hamming_+3A_ratio">ratio</code></td>
<td>
<p>Logical specifying whether to weight distance against
maximum possible, given that a token that is ambiguous in either of two taxa
cannot contribute to the total distance between the pair.</p>
</td></tr>
<tr><td><code id="Hamming_+3A_ambig">ambig</code></td>
<td>
<p>Character specifying value to return when a pair of taxa
have a zero maximum distance (perhaps due to a preponderance of ambiguous
tokens).
&quot;median&quot;, the default, take the median of all other distance values;
&quot;mean&quot;, the mean;
&quot;zero&quot; sets to zero; &quot;one&quot; to one;
&quot;NA&quot; to <code>NA_integer_</code>; and &quot;NaN&quot; to <code>NaN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tokens that contain the inapplicable state are treated as requiring no steps
to transform into any applicable token.
</p>


<h3>Value</h3>

<p><code>Hamming()</code> returns an object of class <code>dist</code> listing the Hamming
distance between each pair of taxa.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Used to construct neighbour joining trees in <code><a href="#topic+NJTree">NJTree()</a></code>.
</p>
<p><code>dist.hamming()</code> in the <span class="pkg">phangorn</span> package provides an alternative
implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens &lt;- matrix(c(0, 0, "0", 0, "?",
                   0, 0, "1", 0, 1,
                   0, 0, "1", 0, 1,
                   0, 0, "2", 0, 1,
                   1, 1, "-", "?", 0,
                   1, 1, "2", 1, "{01}"),
                   nrow = 6, ncol = 5, byrow = TRUE,
                   dimnames = list(
                     paste0("Taxon_", LETTERS[1:6]),
                     paste0("Char_", 1:5)))

dataset &lt;- MatrixToPhyDat(tokens)
Hamming(dataset)
</code></pre>

<hr>
<h2 id='ImposeConstraint'>Force a tree to match a constraint</h2><span id='topic+ImposeConstraint'></span><span id='topic+AddUnconstrained'></span>

<h3>Description</h3>

<p>Modify a tree such that it matches a specified constraint.
This is at present a somewhat crude implementation that attempts to retain
much of the structure of <code>tree</code> whilst guaranteeing compatibility with
each entry in <code>constraint</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImposeConstraint(tree, constraint)

AddUnconstrained(constraint, toAdd, asPhyDat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ImposeConstraint_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="ImposeConstraint_+3A_constraint">constraint</code></td>
<td>
<p>Either an object of class <code>phyDat</code>, in which case returned
trees will be perfectly compatible with each character in <code>constraint</code>;
or a tree of class <code>phylo</code>, in which each node in <code>constraint</code> will occur in
the returned tree.
See <a href="https://ms609.github.io/TreeSearch/articles/tree-search.html">vignette</a>
for further examples.</p>
</td></tr>
<tr><td><code id="ImposeConstraint_+3A_toadd">toAdd</code></td>
<td>
<p>Character vector specifying taxa to add to constraint.</p>
</td></tr>
<tr><td><code id="ImposeConstraint_+3A_asphydat">asPhyDat</code></td>
<td>
<p>Logical: if <code>TRUE</code>, return a <code>phyDat</code> object; if <code>FALSE</code>,
return a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ImposeConstraint()</code> returns a tree of class <code>phylo</code>, consistent
with <code>constraint</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>AddUnconstrained()</code>: Expand a constraint to include unconstrained
taxa.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tips &lt;- letters[1:9]
tree &lt;- as.phylo(1, 9, tips)
plot(tree)

constraint &lt;- StringToPhyDat("0000?1111 000111111 0000??110", tips, FALSE)
plot(ImposeConstraint(tree, constraint))
</code></pre>

<hr>
<h2 id='is.TreeNumber'>Is an object a <code>TreeNumber</code> object?</h2><span id='topic+is.TreeNumber'></span>

<h3>Description</h3>

<p>Is an object a <code>TreeNumber</code> object?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.TreeNumber(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.TreeNumber_+3A_x">x</code></td>
<td>
<p>R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.TreeNumber()</code> returns a logical vector of length one specifying
whether <code>x</code> inherits the class <code>"TreeNumber"</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other 'TreeNumber' utilities: 
<code><a href="#topic+TreeNumber">TreeNumber</a></code>,
<code><a href="#topic+print.TreeNumber">print.TreeNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.TreeNumber(FALSE) # FALSE 
is.TreeNumber(as.TreeNumber(BalancedTree(5))) # TRUE
</code></pre>

<hr>
<h2 id='KeptPaths'>Paths present in reduced tree</h2><span id='topic+KeptPaths'></span><span id='topic+KeptPaths.data.frame'></span><span id='topic+KeptPaths.matrix'></span>

<h3>Description</h3>

<p>Lists which paths present in a master tree are present when leaves are
dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KeptPaths(paths, keptVerts, all = TRUE)

## S3 method for class 'data.frame'
KeptPaths(paths, keptVerts, all = TRUE)

## S3 method for class 'matrix'
KeptPaths(paths, keptVerts, all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KeptPaths_+3A_paths">paths</code></td>
<td>
<p><code>data.frame</code> of paths in master tree, perhaps generated using
<code><a href="#topic+PathLengths">PathLengths()</a></code>.</p>
</td></tr>
<tr><td><code id="KeptPaths_+3A_keptverts">keptVerts</code></td>
<td>
<p>Logical specifying whether each entry is retained in the
reduced tree, perhaps generated using <code><a href="#topic+KeptVerts">KeptVerts()</a></code>.</p>
</td></tr>
<tr><td><code id="KeptPaths_+3A_all">all</code></td>
<td>
<p>Logical: if <code>TRUE</code>, return all paths that occur in the reduced
tree; if <code>FALSE</code>, return only those paths that correspond to a single edge.
that correspond to edges in the reduced tree.
Ignored if <code>paths</code> is a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>KeptPaths()</code> returns a logical vector specifying whether each path
in <code>paths</code> occurs when <code>keptVerts</code> vertices are retained.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>master &lt;- BalancedTree(9)
paths &lt;- PathLengths(master)
keptTips &lt;- c(1, 5, 7, 9)
keptVerts &lt;- KeptVerts(master, keptTips)
KeptPaths(paths, keptVerts)
paths[KeptPaths(paths, keptVerts, all = FALSE), ]
</code></pre>

<hr>
<h2 id='KeptVerts'>Identify vertices retained when leaves are dropped</h2><span id='topic+KeptVerts'></span><span id='topic+KeptVerts.phylo'></span><span id='topic+KeptVerts.numeric'></span>

<h3>Description</h3>

<p>Identify vertices retained when leaves are dropped
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KeptVerts(tree, keptTips, tipLabels = TipLabels(tree))

## S3 method for class 'phylo'
KeptVerts(tree, keptTips, tipLabels = TipLabels(tree))

## S3 method for class 'numeric'
KeptVerts(tree, keptTips, tipLabels = TipLabels(tree))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KeptVerts_+3A_tree">tree</code></td>
<td>
<p>Original tree of class <code>phylo</code>, in <code><a href="#topic+Preorder">Preorder</a></code>.</p>
</td></tr>
<tr><td><code id="KeptVerts_+3A_kepttips">keptTips</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> a logical vector stating whether each leaf should be retained, in a
sequence corresponding to <code>tree[["tip.label"]]</code>; or
</p>
</li>
<li><p> a character vector listing the leaf labels to retain; or
</p>
</li>
<li><p> a numeric vector listing the indices of leaves to retain.
</p>
</li></ul>
</td></tr>
<tr><td><code id="KeptVerts_+3A_tiplabels">tipLabels</code></td>
<td>
<p>Optional character vector naming the leaves of <code>tree</code>,
if <code>keptTips</code> is not logical.  Inferred from <code>tree</code> if unspecified.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>master &lt;- BalancedTree(12)
master &lt;- Preorder(master) # Nodes must be listed in Preorder sequence
plot(master)
nodelabels()

allTips &lt;- master[["tip.label"]]
keptTips &lt;- sample(allTips, 8)
plot(KeepTip(master, keptTips))
kept &lt;- KeptVerts(master, allTips %in% keptTips)

map &lt;- which(kept)
# Node `i` in the reduced tree corresponds to node `map[i]` in the original.
</code></pre>

<hr>
<h2 id='LabelSplits'>Label splits</h2><span id='topic+LabelSplits'></span>

<h3>Description</h3>

<p>Labels the edges associated with each split on a plotted tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LabelSplits(tree, labels = NULL, unit = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LabelSplits_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="LabelSplits_+3A_labels">labels</code></td>
<td>
<p>Named vector listing annotations for each split. Names
should correspond to the node associated with each split; see
<code><a href="#topic+as.Splits">as.Splits()</a></code> for details.
If <code>NULL</code>, each splits will be labelled with its associated node.</p>
</td></tr>
<tr><td><code id="LabelSplits_+3A_unit">unit</code></td>
<td>
<p>Character specifying units of <code>labels</code>, if desired. Include a
leading space if necessary.</p>
</td></tr>
<tr><td><code id="LabelSplits_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code><a href="ape.html#topic+nodelabels">ape::edgelabels()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the two root edges of a rooted tree denote the same split, only the
rightmost (plotted at the bottom, by default) edge will be labelled.
If the position of the root is significant, add a tip at the root using
<code><a href="#topic+AddTip">AddTip()</a></code>.
</p>


<h3>Value</h3>

<p><code>LabelSplits()</code> returns <code>invisible()</code>, after plotting <code>labels</code> on
each relevant edge of a plot (which should already have been produced using
<code>plot(tree)</code>).
</p>


<h3>See Also</h3>

<p>Calculate split support: <code><a href="#topic+SplitFrequency">SplitFrequency()</a></code>
</p>
<p>Colour labels according to value: <code><a href="#topic+SupportColour">SupportColour()</a></code>
</p>
<p>Other Splits operations: 
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- BalancedTree(LETTERS[1:5])
splits &lt;- as.Splits(tree)
plot(tree)
LabelSplits(tree, as.character(splits), frame = "none", pos = 3L)
LabelSplits(tree, TipsInSplits(splits), unit = " tips", frame = "none",
            pos = 1L)

# An example forest of 100 trees, some identical
forest &lt;- as.phylo(c(1, rep(10, 79), rep(100, 15), rep(1000, 5)), nTip = 9)

# Generate an 80% consensus tree
cons &lt;- ape::consensus(forest, p = 0.8)
plot(cons)

# Calculate split frequencies
splitFreqs &lt;- SplitFrequency(cons, forest)

# Optionally, colour edges by corresponding frequency.
# Note that not all edges are associated with a unique split
# (and two root edges may be associated with one split - not handled here)
edgeSupport &lt;- rep(1, nrow(cons$edge)) # Initialize trivial splits to 1
childNode &lt;- cons$edge[, 2]
edgeSupport[match(names(splitFreqs), childNode)] &lt;- splitFreqs / 100

plot(cons, edge.col = SupportColour(edgeSupport), edge.width = 3)

# Annotate nodes by frequency 
LabelSplits(cons, splitFreqs, unit = "%",
            col = SupportColor(splitFreqs / 100),
            frame = "none", pos = 3L)

</code></pre>

<hr>
<h2 id='LeafLabelInterchange'>Leaf label interchange</h2><span id='topic+LeafLabelInterchange'></span>

<h3>Description</h3>

<p><code>LeafLabelInterchange()</code> exchanges the position of leaves within a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LeafLabelInterchange(tree, n = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LeafLabelInterchange_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="LeafLabelInterchange_+3A_n">n</code></td>
<td>
<p>Integer specifying number of leaves whose positions should be
exchanged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modifies a tree by switching the positions of <em>n</em> leaves.  To avoid
later swaps undoing earlier exchanges, all <em>n</em> leaves are guaranteed
to change position.  Note, however, that no attempt is made to avoid
swapping equivalent leaves, for example, a pair that are each others'
closest relatives.  As such, the relationships within a tree are not
guaranteed to be changed.
</p>


<h3>Value</h3>

<p><code>LeafLabelInterchange()</code> returns a tree of class <code>phylo</code> on which
the position of <code>n</code> leaves have been exchanged.
The tree's internal topology will not change.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- PectinateTree(8)
plot(LeafLabelInterchange(tree, 3L))

</code></pre>

<hr>
<h2 id='ListAncestors'>List ancestors</h2><span id='topic+ListAncestors'></span><span id='topic+AllAncestors'></span>

<h3>Description</h3>

<p><code>ListAncestors()</code> reports all ancestors of a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ListAncestors(parent, child, node = NULL)

AllAncestors(parent, child)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ListAncestors_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 1]</code></p>
</td></tr>
<tr><td><code id="ListAncestors_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 2]</code>.</p>
</td></tr>
<tr><td><code id="ListAncestors_+3A_node">node</code></td>
<td>
<p>Integer giving the index of the node or tip whose ancestors are
required, or <code>NULL</code> to return ancestors of all nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if <code>node = NULL</code>, the tree's edges must be listed such that each
internal node (except the root) is listed as a child before it is listed
as a parent, i.e. its index in <code>child</code> is less than its index in <code>parent</code>.
This will be true of trees listed in <a href="#topic+Preorder">Preorder</a>.
</p>


<h3>Value</h3>

<p>If <code>node = NULL</code>, <code>ListAncestors()</code> returns a list. Each entry <em>i</em> contains
a vector containing, in order, the nodes encountered when traversing the tree
from node <em>i</em> to the root node.
The last entry of each member of the list is therefore the root node,
with the exception of the entry for the root node itself, which is a
zero-length integer.
</p>
<p>If <code>node</code> is an integer, <code>ListAncestors()</code> returns a vector of the numbers of
the nodes ancestral to the given <code>node</code>, including the root node.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>AllAncestors()</code>: Alias for <code>ListAncestors(node = NULL)</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Implemented less efficiently in <code>phangorn:::Ancestors</code>, on which this
code is based.
</p>
<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>
<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- PectinateTree(5)
edge &lt;- tree[["edge"]]

# Identify desired node with:
plot(tree)
nodelabels()
tiplabels()

# Ancestors of specific nodes:
ListAncestors(edge[, 1], edge[, 2], 4L)
ListAncestors(edge[, 1], edge[, 2], 8L)

# Ancestors of each node, if tree numbering system is uncertain:
lapply(seq_len(max(edge)), ListAncestors,
       parent = edge[, 1], child = edge[, 2])

# Ancestors of each node, if tree is in preorder:
ListAncestors(edge[, 1], edge[, 2])

# Alias:
AllAncestors(edge[, 1], edge[, 2])

</code></pre>

<hr>
<h2 id='Lobo.data'>Data from Zhang et al. 2016</h2><span id='topic+Lobo.data'></span><span id='topic+Lobo.phy'></span>

<h3>Description</h3>

<p>Phylogenetic data from Zhang et al. (2016) in raw
(<code>Lobo.data</code>) and <code>phyDat</code> (<code>Lobo.phy</code>) formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lobo.data

Lobo.phy
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 48.
</p>
<p>An object of class <code>phyDat</code> of length 48.
</p>


<h3>Source</h3>

<p>Zhang et al. (2016)
</p>


<h3>References</h3>

<p>Zhang X, Smith MR, Yang J, Hou J (2016).
&ldquo;Onychophoran-like musculature in a phosphatized Cambrian lobopodian.&rdquo;
<em>Biology Letters</em>, <b>12</b>(9), 20160492.
<a href="https://doi.org/10.1098/rsbl.2016.0492">doi:10.1098/rsbl.2016.0492</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lobo", package = "TreeTools")
Lobo.data
Lobo.phy
</code></pre>

<hr>
<h2 id='logDoubleFactorials'>Natural logarithms of double factorials</h2><span id='topic+logDoubleFactorials'></span>

<h3>Description</h3>

<p><code>logDoubleFactorials</code> is a numeric vector with pre-calculated values of
double factorials up to 50 000!!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logDoubleFactorials
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 50000.
</p>


<h3>See Also</h3>

<p>Other double factorials: 
<code><a href="#topic+DoubleFactorial">DoubleFactorial</a>()</code>,
<code><a href="#topic+doubleFactorials">doubleFactorials</a></code>
</p>

<hr>
<h2 id='MakeTreeBinary'>Generate binary tree by collapsing polytomies</h2><span id='topic+MakeTreeBinary'></span>

<h3>Description</h3>

<p><code>MakeTreeBinary()</code> resolves, at random, all polytomies in a tree or set of
trees, such that all trees compatible with the input topology are drawn
with equal probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeTreeBinary(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeTreeBinary_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MakeTreeBinary()</code> returns a rooted binary tree of class <code>phylo</code>,
corresponding to tree uniformly selected from all those compatible with
the input tree topologies.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Since ape v5.5, this functionality is available through
<code><a href="ape.html#topic+multi2di">ape::multi2di()</a></code>; previous versions of &quot;ape&quot; did not return topologies
in equal frequencies.
</p>
<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MakeTreeBinary(CollapseNode(PectinateTree(7), c(9, 11, 13)))
UnrootTree(MakeTreeBinary(StarTree(5)))
</code></pre>

<hr>
<h2 id='match.Splits'>Split matching</h2><span id='topic+match.Splits'></span><span id='topic+match+2CSplits+2CSplits-method'></span><span id='topic+in.Splits'></span><span id='topic+match'></span><span id='topic++25in+25+2CSplits+2CSplits-method'></span>

<h3>Description</h3>

<p><code>match()</code> returns a vector of the positions of (first) matches of splits in
its first argument in its second.
<code>%in%</code> is a more intuitive interface as a binary operator, which returns
a logical vector indicating whether there is a match or not for each
split in its left operand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Splits,Splits'
match(x, table, nomatch = NA_integer_, incomparables = NULL)

in.Splits(x, table)

match(x, table, nomatch = NA_integer_, incomparables = NULL)

## S4 method for signature 'Splits,Splits'
x %in% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.Splits_+3A_x">x</code>, <code id="match.Splits_+3A_table">table</code></td>
<td>
<p>Object of class <code>Splits</code>.</p>
</td></tr>
<tr><td><code id="match.Splits_+3A_nomatch">nomatch</code></td>
<td>
<p>Integer value that will be used in place of <code>NA</code> in the case
where no match is found.</p>
</td></tr>
<tr><td><code id="match.Splits_+3A_incomparables">incomparables</code></td>
<td>
<p>Ignored. (Included for consistency with generic.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>in.Splits()</code> is an alias for <code>%in%</code>, included for backwards compatibility.
It is deprecated and will be removed in a future release.
</p>


<h3>Value</h3>

<p><code>match()</code> returns an integer vector specifying the position in
<code>table</code> that matches each element in <code>x</code>, or <code>nomatch</code> if no match is found.
</p>


<h3>See Also</h3>

<p>Corresponding base functions are documented in
<code><a href="base.html#topic+match">match()</a></code>.
</p>
<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splits1 &lt;- as.Splits(BalancedTree(7))
splits2 &lt;- as.Splits(PectinateTree(7))

match(splits1, splits2)
</code></pre>

<hr>
<h2 id='MatrixToPhyDat'>Convert between matrices and <code>phyDat</code> objects</h2><span id='topic+MatrixToPhyDat'></span><span id='topic+PhyDatToMatrix'></span>

<h3>Description</h3>

<p><code>MatrixToPhyDat()</code> converts a matrix of tokens to a <code>phyDat</code> object;
<code>PhyDatToMatrix()</code> converts a <code>phyDat</code> object to a matrix of tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixToPhyDat(tokens)

PhyDatToMatrix(
  dataset,
  ambigNA = FALSE,
  inappNA = ambigNA,
  parentheses = c("{", "}"),
  sep = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatrixToPhyDat_+3A_tokens">tokens</code></td>
<td>
<p>Matrix of tokens, possibly created with <code><a href="#topic+ReadCharacters">ReadCharacters()</a></code>
or <code><a href="#topic+ReadTntCharacters">ReadTntCharacters()</a></code>.
Row names should correspond to leaf labels; column names may optionally
correspond to character labels.</p>
</td></tr>
<tr><td><code id="MatrixToPhyDat_+3A_dataset">dataset</code></td>
<td>
<p>A dataset of class <code>phyDat</code>.</p>
</td></tr>
<tr><td><code id="MatrixToPhyDat_+3A_ambigna">ambigNA</code>, <code id="MatrixToPhyDat_+3A_inappna">inappNA</code></td>
<td>
<p>Logical specifying whether to denote ambiguous /
inapplicable characters as <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="MatrixToPhyDat_+3A_parentheses">parentheses</code></td>
<td>
<p>Character vector specifying style of parentheses
with which to enclose ambiguous characters. <code>c("[", "]")</code> or <code>"[]"</code> will
render <code style="white-space: pre;">&#8288;[01]&#8288;</code>.
<code>NULL</code> will use the token specified in the <code>phyDat</code> object; but beware that
this will be treated as a distinct (non-ambiguous) token if re-encoding with
<code>PhyDatToMatrix()</code>.</p>
</td></tr>
<tr><td><code id="MatrixToPhyDat_+3A_sep">sep</code></td>
<td>
<p>Character with which to separate ambiguous tokens, e.g. <code>','</code>
will render <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MatrixToPhyDat()</code> returns an object of class <code>phyDat</code>.
</p>
<p><code>PhyDatToMatrix()</code> returns a matrix corresponding to the
uncompressed character states within a <code>phyDat</code> object.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other phylogenetic matrix conversion functions: 
<code><a href="#topic+StringToPhyDat">StringToPhyDat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens &lt;- matrix(c(0, 0, "0", 0, 0,
                   0, 0, "1", 0, 1,
                   0, 0, "1", 0, 1,
                   0, 0, "2", 0, 1,
                   1, 1, "-", 1, 0,
                   1, 1, "2", 1, "{01}"),
                   nrow = 6, ncol = 5, byrow = TRUE,
                   dimnames = list(
                     paste0("Taxon_", LETTERS[1:6]),
                     paste0("Char_", 1:5)))
                   
MatrixToPhyDat(tokens)
data("Lobo", package = "TreeTools")
head(PhyDatToMatrix(Lobo.phy)[, 91:93])
</code></pre>

<hr>
<h2 id='MorphoBankDecode'>Decode MorphoBank text</h2><span id='topic+MorphoBankDecode'></span>

<h3>Description</h3>

<p>Converts strings from MorphoBank notes into a Latex-compatible format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MorphoBankDecode(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MorphoBankDecode_+3A_string">string</code></td>
<td>
<p>String to process</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MorphoBankDecode()</code> returns a string with new lines and punctuation
reformatted.
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>


<h3>See Also</h3>

<p>Other string parsing functions: 
<code><a href="#topic+EndSentence">EndSentence</a>()</code>,
<code><a href="#topic+RightmostCharacter">RightmostCharacter</a>()</code>,
<code><a href="#topic+Unquote">Unquote</a>()</code>
</p>

<hr>
<h2 id='MRCA'>Most recent common ancestor</h2><span id='topic+MRCA'></span>

<h3>Description</h3>

<p><code>MRCA()</code> calculates the last common ancestor of specified nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRCA(x1, x2, ancestors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRCA_+3A_x1">x1</code>, <code id="MRCA_+3A_x2">x2</code></td>
<td>
<p>Integer specifying index of leaves or nodes whose most
recent common ancestor should be found.</p>
</td></tr>
<tr><td><code id="MRCA_+3A_ancestors">ancestors</code></td>
<td>
<p>List of ancestors for each node in a tree. Perhaps
produced by <code><a href="#topic+ListAncestors">ListAncestors()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MRCA()</code> requires that node values within a tree increase away from the root,
which will be true of trees listed in <code>Preorder</code>.
No warnings will be given if trees do not fulfil this requirement.
</p>


<h3>Value</h3>

<p><code>MRCA()</code> returns an integer specifying the node number of the last
common ancestor of <code>x1</code> and <code>x2</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- BalancedTree(7)

# Verify that node numbering increases away from root
plot(tree)
nodelabels()

# ListAncestors expects a tree in Preorder
tree &lt;- Preorder(tree)
edge &lt;- tree$edge
ancestors &lt;- ListAncestors(edge[, 1], edge[, 2])
MRCA(1, 4, ancestors)

# If a tree must be in postorder, use:
tree &lt;- Postorder(tree)
edge &lt;- tree$edge
ancestors &lt;- lapply(seq_len(max(edge)), ListAncestors,
                    parent = edge[, 1], child = edge[, 2])

</code></pre>

<hr>
<h2 id='MSTEdges'>Minimum spanning tree</h2><span id='topic+MSTEdges'></span><span id='topic+MSTLength'></span>

<h3>Description</h3>

<p>Calculate or plot the minimum spanning tree (Gower and Ross 1969)
of a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSTEdges(distances, plot = FALSE, x = NULL, y = NULL, ...)

MSTLength(distances, mst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSTEdges_+3A_distances">distances</code></td>
<td>
<p>Either a matrix that can be interpreted as a distance
matrix, or an object of class <code>dist</code>.</p>
</td></tr>
<tr><td><code id="MSTEdges_+3A_plot">plot</code></td>
<td>
<p>Logical specifying whether to add the minimum spanning tree
to an existing plot.</p>
</td></tr>
<tr><td><code id="MSTEdges_+3A_x">x</code>, <code id="MSTEdges_+3A_y">y</code></td>
<td>
<p>Numeric vectors specifying the X and Y coordinates of each
element in <code>distances</code>.  Necessary only if <code>plot = TRUE</code>.</p>
</td></tr>
<tr><td><code id="MSTEdges_+3A_...">...</code></td>
<td>
<p>Additional parameters to send to <code style="white-space: pre;">&#8288;[lines()]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="MSTEdges_+3A_mst">mst</code></td>
<td>
<p>Optional parameter specifying the minimum spanning tree in the
format returned by <code>MSTEdges()</code>; if <code>NULL</code>, calculated from <code>distances</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MSTEdges()</code> returns a matrix in which each row corresponds to an
edge of the minimum spanning tree, listed in non-decreasing order of length.
The two columns contain the indices of the entries in <code>distances</code> that
each edge connects, with the lower value listed first.
</p>
<p><code>MSTLength()</code> returns the length of the minimum spanning tree.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Gower JC, Ross GJS (1969).
&ldquo;Minimum spanning trees and single linkage cluster analysis.&rdquo;
<em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em>, <b>18</b>(1), 54&ndash;64.
<a href="https://doi.org/10.2307/2346439">doi:10.2307/2346439</a>.
</p>


<h3>See Also</h3>

<p>Slow implementation returning the association matrix of the minimum spanning
tree: <code><a href="ape.html#topic+mst">ape::mst()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Corners of an almost-regular octahedron
points &lt;- matrix(c(0, 0, 2, 2, 1.1, 1,
                   0, 2, 0, 2, 1, 1.1,
                   0, 0, 0, 0, 1, -1), 6)
distances &lt;- dist(points)
mst &lt;- MSTEdges(distances)
MSTLength(distances, mst)
plot(points[, 1:2], ann = FALSE, asp = 1)
MSTEdges(distances, TRUE, x = points[, 1], y = points[, 2], lwd = 2)
</code></pre>

<hr>
<h2 id='N1Spr'>Number of trees one SPR step away</h2><span id='topic+N1Spr'></span><span id='topic+IC1Spr'></span>

<h3>Description</h3>

<p><code>N1Spr()</code> calculates the number of trees one subtree prune-and-regraft
operation away from a binary input tree using the formula given by
Allen and Steel (2001);
<code>IC1Spr()</code> calculates the information content of trees at this
distance: i.e. the entropy corresponding to the proportion of all possible
<em>n</em>-tip trees whose SPR distance is at most one from a specified tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N1Spr(n)

IC1Spr(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="N1Spr_+3A_n">n</code></td>
<td>
<p>Integer vector specifying the number of tips in a tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>N1Spr()</code> returns an integer vector denoting the number of trees one
SPR rearrangement away from the input tree..
</p>
<p><code>IC1Spr()</code> returns an numeric vector giving the phylogenetic
information content of trees 0 or 1 SPR rearrangement from an <em>n</em>-leaf tree,
in bits.
</p>


<h3>References</h3>

<p>Allen BL, Steel MA (2001).
&ldquo;Subtree transfer operations and their induced metrics on evolutionary trees.&rdquo;
<em>Annals of Combinatorics</em>, <b>5</b>(1), 1&ndash;15.
<a href="https://doi.org/10.1007/s00026-001-8006-8">doi:10.1007/s00026-001-8006-8</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N1Spr(4:6)
IC1Spr(5)

</code></pre>

<hr>
<h2 id='NDescendants'>Count descendants for each node in a tree</h2><span id='topic+NDescendants'></span>

<h3>Description</h3>

<p><code>NDescendants()</code> counts the number of nodes (including leaves) directly
descended from each node in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NDescendants(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NDescendants_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NDescendants()</code> returns an integer listing the number of direct
descendants (leaves or internal nodes) for each node in a tree.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- CollapseNode(BalancedTree(8), 12:15)
NDescendants(tree)
plot(tree)
nodelabels(NDescendants(tree))

</code></pre>

<hr>
<h2 id='NewickTree'>Write Newick Tree</h2><span id='topic+NewickTree'></span>

<h3>Description</h3>

<p><code>NewickTree()</code> encodes a tree as a Newick-format string.
This differs from <code><a href="ape.html#topic+write.tree">write.tree()</a></code> in the encoding of
spaces as spaces, rather than underscores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewickTree(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NewickTree_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NewickTree()</code> returns a character string denoting <code>tree</code> in Newick
format.
</p>


<h3>See Also</h3>

<p>Use tip numbers, rather than leaf labels: <code><a href="#topic+as.Newick">as.Newick</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NewickTree(BalancedTree(LETTERS[4:9]))

</code></pre>

<hr>
<h2 id='Neworder'>Reorder edges of a phylogenetic tree</h2><span id='topic+Neworder'></span><span id='topic+NeworderPruningwise'></span><span id='topic+NeworderPhylo'></span>

<h3>Description</h3>

<p>Wrappers for the C functions called by
<code>ape::<a href="ape.html#topic+reorder.phylo">reorder.phylo</a></code>.
These call the C functions directly, so are faster &ndash; but don't perform
as many checks on user input.  Bad input could crash R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NeworderPruningwise(nTip, nNode, parent, child, nEdge)

NeworderPhylo(nTip, parent, child, nEdge, whichwise)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Neworder_+3A_ntip">nTip</code>, <code id="Neworder_+3A_nnode">nNode</code>, <code id="Neworder_+3A_nedge">nEdge</code></td>
<td>
<p>Integer specifying the number of tips, nodes
and edges in the input tree.</p>
</td></tr>
<tr><td><code id="Neworder_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 1]</code></p>
</td></tr>
<tr><td><code id="Neworder_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 2]</code>.</p>
</td></tr>
<tr><td><code id="Neworder_+3A_whichwise">whichwise</code></td>
<td>
<p>Integer specifying whether to order edges (1)
cladewise; or (2) in postorder.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NeworderPruningwise</code> returns an integer vector specifying the
pruningwise order of edges within a tree.
</p>
<p><code>NeworderPhylo</code> returns an integer vector specifying the order
of edges under the ordering sequence specified by <code>whichwise</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> C algorithm: Emmanuel Paradis
</p>
</li>
<li><p> R wrapper: Martin R. Smith
</p>
</li></ul>



<h3>See Also</h3>

<p>Other C wrappers: 
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nTip &lt;- 8L
tree &lt;- BalancedTree(nTip)
edge &lt;- tree[["edge"]]
pruningwise &lt;- NeworderPruningwise(nTip, tree$Nnode, edge[, 1], edge[, 2],
                                   dim(edge)[1])
cladewise &lt;- NeworderPhylo(nTip, edge[, 1], edge[, 2], dim(edge)[1], 1L)
postorder &lt;- NeworderPhylo(nTip, edge[, 1], edge[, 2], dim(edge)[1], 2L)

tree[["edge"]] &lt;- tree[["edge"]][pruningwise, ]

</code></pre>

<hr>
<h2 id='NJTree'>Generate a neighbour joining tree</h2><span id='topic+NJTree'></span>

<h3>Description</h3>

<p><code>NJTree()</code> generates a rooted neighbour joining tree from a phylogenetic
dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NJTree(dataset, edgeLengths = FALSE, ratio = TRUE, ambig = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NJTree_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class <code>phyDat</code>,
whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="NJTree_+3A_edgelengths">edgeLengths</code></td>
<td>
<p>Logical specifying whether to include edge lengths.</p>
</td></tr>
<tr><td><code id="NJTree_+3A_ambig">ambig</code>, <code id="NJTree_+3A_ratio">ratio</code></td>
<td>
<p>Settings of <code>ambig</code> and <code>ratio</code> to be used when
computing <code><a href="#topic+Hamming">Hamming()</a></code> distances between sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NJTree</code> returns an object of class <code>phylo</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree generation functions: 
<code><a href="#topic+ConstrainedNJ">ConstrainedNJ</a>()</code>,
<code><a href="#topic+GenerateTree">GenerateTree</a></code>,
<code><a href="#topic+TreeNumber">TreeNumber</a></code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lobo")
NJTree(Lobo.phy)

</code></pre>

<hr>
<h2 id='NodeDepth'>Distance of each node from tree exterior</h2><span id='topic+NodeDepth'></span>

<h3>Description</h3>

<p><code>NodeDepth()</code> evaluates how &quot;deep&quot; each node is within a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NodeDepth(x, shortest = FALSE, includeTips = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NodeDepth_+3A_x">x</code></td>
<td>
<p>A tree of class <code>phylo</code>, its <code style="white-space: pre;">&#8288;$edge&#8288;</code> property, or a list thereof.</p>
</td></tr>
<tr><td><code id="NodeDepth_+3A_shortest">shortest</code></td>
<td>
<p>Logical specifying whether to calculate the length of the
shortest away-from-root path to a leaf.  If <code>FALSE</code>, the length of the
longest such route will be returned.</p>
</td></tr>
<tr><td><code id="NodeDepth_+3A_includetips">includeTips</code></td>
<td>
<p>Logical specifying whether to include leaves
(each of depth zero) in return value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a rooted tree, the depth of a node is the minimum (if <code>shortest = TRUE</code>)
or maximum  (<code>shortest = FALSE</code>) number of edges that must be traversed,
moving away from the root, to reach a leaf.
</p>
<p>Unrooted trees are treated as if a root node occurs in the &quot;middle&quot; of the
tree, meaning the position that will minimise the maximum node depth.
</p>


<h3>Value</h3>

<p><code>NodeDepth()</code> returns an integer vector specifying the depth of
each external and internal node in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+node.depth">ape::node.depth</a></code> returns the number of tips descended from a
node.
</p>
<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- CollapseNode(BalancedTree(10), c(12:13, 19))
plot(tree)
nodelabels(NodeDepth(tree, includeTips = FALSE))


</code></pre>

<hr>
<h2 id='NodeOrder'>Number of edges incident to each node in a tree</h2><span id='topic+NodeOrder'></span>

<h3>Description</h3>

<p><code>NodeOrder()</code> calculates the order of each node: the number of edges
incident to it in a tree.
This value includes the root edge in rooted trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NodeOrder(x, includeAncestor = TRUE, internalOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NodeOrder_+3A_x">x</code></td>
<td>
<p>A tree of class <code>phylo</code>, its <code style="white-space: pre;">&#8288;$edge&#8288;</code> property, or a list thereof.</p>
</td></tr>
<tr><td><code id="NodeOrder_+3A_includeancestor">includeAncestor</code></td>
<td>
<p>Logical specifying whether to count edge leading to
ancestral node in calculation of order.</p>
</td></tr>
<tr><td><code id="NodeOrder_+3A_internalonly">internalOnly</code></td>
<td>
<p>Logical specifying whether to restrict to results
to internal nodes, i.e. to omit leaves. Irrelevant if
<code>includeAncestor = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NodeOrder()</code> returns an integer listing the order of each node;
entries are named with the number of each node.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+RootNode">RootNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- CollapseNode(BalancedTree(8), 12:15)
NodeOrder(tree)
plot(tree)
nodelabels(NodeOrder(tree, internalOnly = TRUE))

</code></pre>

<hr>
<h2 id='NPartitionPairs'>Distributions of tips consistent with a partition pair</h2><span id='topic+NPartitionPairs'></span>

<h3>Description</h3>

<p><code>NPartitionPairs()</code> calculates the number of terminal arrangements matching
a specified configuration of two splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPartitionPairs(configuration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NPartitionPairs_+3A_configuration">configuration</code></td>
<td>
<p>Integer vector of length four specifying the number of
terminals that occur in both
(1) splits A1 and A2;
(2) splits A1 and B2;
(3) splits B1 and A2;
(4) splits B1 and B2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider splits that divide eight terminals, labelled A to H.
</p>

<table>
<tr>
 <td style="text-align: right;">
Bipartition 1:</td><td style="text-align: center;"> ABCD:EFGH</td><td style="text-align: left;"> A1 = ABCD</td><td style="text-align: left;"> B1 = EFGH </td>
</tr>
<tr>
 <td style="text-align: right;">
Bipartition 2:</td><td style="text-align: center;"> ABE:CDFGH</td><td style="text-align: left;"> A2 = ABE</td><td style="text-align: left;"> B2 = CDFGH
</td>
</tr>

</table>

<p>This can be represented by an association matrix:
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <em>A2</em> </td><td style="text-align: left;"> <em>B2</em> </td>
</tr>
<tr>
 <td style="text-align: right;">
<em>A1</em> </td><td style="text-align: left;"> AB  </td><td style="text-align: left;"> C   </td>
</tr>
<tr>
 <td style="text-align: right;">
<em>B1</em> </td><td style="text-align: left;"> E   </td><td style="text-align: left;"> FGH
</td>
</tr>

</table>

<p>The cells in this matrix contain 2, 1, 1 and 3 terminals respectively; this
four-element vector (<code>c(2, 1, 1, 3)</code>) is the <code>configuration</code> implied by
this pair of bipartition splits.
</p>


<h3>Value</h3>

<p>The number of ways to distribute <code>sum(configuration)</code> taxa according
to the specified pattern.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NPartitionPairs(c(2, 1, 1, 3))
</code></pre>

<hr>
<h2 id='NRooted'>Number of trees</h2><span id='topic+NRooted'></span><span id='topic+NUnrooted'></span><span id='topic+NRooted64'></span><span id='topic+NUnrooted64'></span><span id='topic+LnUnrooted'></span><span id='topic+LnUnrooted.int'></span><span id='topic+Log2Unrooted'></span><span id='topic+Log2Unrooted.int'></span><span id='topic+LnRooted'></span><span id='topic+LnRooted.int'></span><span id='topic+Log2Rooted'></span><span id='topic+Log2Rooted.int'></span><span id='topic+LnUnrootedSplits'></span><span id='topic+Log2UnrootedSplits'></span><span id='topic+NUnrootedSplits'></span><span id='topic+LnUnrootedMult'></span><span id='topic+Log2UnrootedMult'></span><span id='topic+NUnrootedMult'></span>

<h3>Description</h3>

<p>These functions return the number of rooted or unrooted binary trees
consistent with a given pattern of splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NRooted(tips)

NUnrooted(tips)

NRooted64(tips)

NUnrooted64(tips)

LnUnrooted(tips)

LnUnrooted.int(tips)

Log2Unrooted(tips)

Log2Unrooted.int(tips)

LnRooted(tips)

LnRooted.int(tips)

Log2Rooted(tips)

Log2Rooted.int(tips)

LnUnrootedSplits(...)

Log2UnrootedSplits(...)

NUnrootedSplits(...)

LnUnrootedMult(...)

Log2UnrootedMult(...)

NUnrootedMult(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NRooted_+3A_tips">tips</code></td>
<td>
<p>Integer specifying the number of leaves.</p>
</td></tr>
<tr><td><code id="NRooted_+3A_...">...</code></td>
<td>
<p>Integer vector, or series of integers, listing the number of
leaves in each split.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions starting <code>N</code> return the number of rooted or unrooted trees.
Replace this initial <code>N</code> with <code>Ln</code> for the natural logarithm of this number;
or <code>Log2</code> for its base 2 logarithm.
</p>
<p>Calculations follow Cavalli-Sforza and Edwards (1967) and
Carter et al. (1990), Theorem 2.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>NUnrooted()</code>: Number of unrooted trees
</p>
</li>
<li> <p><code>NRooted64()</code>: Exact number of rooted trees as 64-bit integer
(13 &lt; <code>nTip</code> &lt; 19)
</p>
</li>
<li> <p><code>NUnrooted64()</code>: Exact number of unrooted trees as 64-bit integer
(14 &lt; <code>nTip</code> &lt; 20)
</p>
</li>
<li> <p><code>LnUnrooted()</code>: Log Number of unrooted trees
</p>
</li>
<li> <p><code>LnUnrooted.int()</code>: Log Number of unrooted trees (as integer)
</p>
</li>
<li> <p><code>LnRooted()</code>: Log Number of rooted trees
</p>
</li>
<li> <p><code>LnRooted.int()</code>: Log Number of rooted trees (as integer)
</p>
</li>
<li> <p><code>NUnrootedSplits()</code>: Number of unrooted trees consistent with a bipartition
split.
</p>
</li>
<li> <p><code>NUnrootedMult()</code>: Number of unrooted trees consistent with a multi-partition
split.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Carter M, Hendy M, Penny D, Szkely LA, Wormald NC (1990).
&ldquo;On the distribution of lengths of evolutionary trees.&rdquo;
<em>SIAM Journal on Discrete Mathematics</em>, <b>3</b>(1), 38&ndash;47.
<a href="https://doi.org/10.1137/0403005">doi:10.1137/0403005</a>.<br /><br /> Cavalli-Sforza LL, Edwards AWF (1967).
&ldquo;Phylogenetic analysis: models and estimation procedures.&rdquo;
<em>Evolution</em>, <b>21</b>(3), 550&ndash;570.
ISSN 00143820, <a href="https://doi.org/10.1111/j.1558-5646.1967.tb03411.x">doi:10.1111/j.1558-5646.1967.tb03411.x</a>.
</p>


<h3>See Also</h3>

<p>Other tree information functions: 
<code><a href="#topic+CladisticInfo">CladisticInfo</a>()</code>,
<code><a href="#topic+TreesMatchingTree">TreesMatchingTree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NRooted(10)
NUnrooted(10)
LnRooted(10)
LnUnrooted(10)
Log2Unrooted(10)
# Number of trees consistent with a character whose states are
# 00000 11111 222
NUnrootedMult(c(5,5,3))

NUnrooted64(18)
LnUnrootedSplits(c(2,4))
LnUnrootedSplits(3, 3)
Log2UnrootedSplits(c(2,4))
Log2UnrootedSplits(3, 3)
NUnrootedSplits(c(2,4))
NUnrootedSplits(3, 3)
</code></pre>

<hr>
<h2 id='nRootedShapes'>Number of rooted / unrooted tree shapes</h2><span id='topic+nRootedShapes'></span><span id='topic+nUnrootedShapes'></span>

<h3>Description</h3>

<p><code>nRootedShapes</code> and <code>nUnrootedShapes</code> give the number of (un)rooted binary
trees on <em>n</em> unlabelled leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nRootedShapes

nUnrootedShapes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>integer64</code> of length 55.
</p>
<p>An object of class <code>integer64</code> of length 60.
</p>


<h3>Source</h3>

<p><code>nRootedShapes</code> corresponds to the Wedderburn-Etherington numbers,
<a href="https://oeis.org/A001190"><abbr><span class="acronym">OEIS</span></abbr> A001190</a>
</p>
<p><code>nUnrootedShapes</code> is <a href="https://oeis.org/A000672"><abbr><span class="acronym">OEIS</span></abbr> A000672</a>
</p>

<hr>
<h2 id='NSplits'>Number of distinct splits</h2><span id='topic+NSplits'></span><span id='topic+NPartitions'></span><span id='topic+NSplits.phylo'></span><span id='topic+NSplits.list'></span><span id='topic+NSplits.multiPhylo'></span><span id='topic+NSplits.Splits'></span><span id='topic+NSplits.numeric'></span><span id='topic+NSplits.NULL'></span><span id='topic+NSplits.ClusterTable'></span><span id='topic+NSplits.character'></span>

<h3>Description</h3>

<p><code>NSplits()</code> counts the unique bipartition splits in a tree or object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSplits(x)

NPartitions(x)

## S3 method for class 'phylo'
NSplits(x)

## S3 method for class 'list'
NSplits(x)

## S3 method for class 'multiPhylo'
NSplits(x)

## S3 method for class 'Splits'
NSplits(x)

## S3 method for class 'numeric'
NSplits(x)

## S3 method for class ''NULL''
NSplits(x)

## S3 method for class 'ClusterTable'
NSplits(x)

## S3 method for class 'character'
NSplits(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NSplits_+3A_x">x</code></td>
<td>
<p>A phylogenetic tree of class <code>phylo</code>; a list of such trees
(of class <code>list</code> or <code>multiPhylo</code>); a <code>Splits</code> object;
a vector of integers; or a character vector listing tips of a tree,
or a character of length one specifying a tree in Newick format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NSplits()</code> returns an integer specifying the number of bipartitions in
the specified objects, or in a binary tree with <code>x</code> tips.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree properties: 
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PathLengths">PathLengths</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TreeIsRooted">TreeIsRooted</a>()</code>
</p>
<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NSplits(8L)
NSplits(PectinateTree(8))
NSplits(as.Splits(BalancedTree(8)))
</code></pre>

<hr>
<h2 id='NTip'>Number of leaves in a phylogenetic tree</h2><span id='topic+NTip'></span><span id='topic+NTip.default'></span><span id='topic+NTip.Splits'></span><span id='topic+NTip.list'></span><span id='topic+NTip.phylo'></span><span id='topic+NTip.multiPhylo'></span><span id='topic+NTip.phyDat'></span><span id='topic+NTip.matrix'></span>

<h3>Description</h3>

<p><code>NTip()</code> extends <code><a href="ape.html#topic+summary.phylo">ape::Ntip()</a></code> to handle
objects of class <code>Splits</code> and <code>list</code>, and edge matrices
(equivalent to <code>tree$edge</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NTip(phy)

## Default S3 method:
NTip(phy)

## S3 method for class 'Splits'
NTip(phy)

## S3 method for class 'list'
NTip(phy)

## S3 method for class 'phylo'
NTip(phy)

## S3 method for class 'multiPhylo'
NTip(phy)

## S3 method for class 'phyDat'
NTip(phy)

## S3 method for class 'matrix'
NTip(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NTip_+3A_phy">phy</code></td>
<td>
<p>Object representing one or more phylogenetic trees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NTip()</code> returns an integer specifying the number of tips in each
object in <code>phy</code>.
</p>


<h3>See Also</h3>

<p>Other tree properties: 
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+PathLengths">PathLengths</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TreeIsRooted">TreeIsRooted</a>()</code>
</p>
<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>

<hr>
<h2 id='PairwiseDistances'>Distances between each pair of trees</h2><span id='topic+PairwiseDistances'></span>

<h3>Description</h3>

<p>Distances between each pair of trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PairwiseDistances(trees, Func, valueLength = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PairwiseDistances_+3A_trees">trees</code></td>
<td>
<p>List of trees of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="PairwiseDistances_+3A_func">Func</code></td>
<td>
<p>Function returning a distance between two trees.</p>
</td></tr>
<tr><td><code id="PairwiseDistances_+3A_valuelength">valueLength</code></td>
<td>
<p>Integer specifying expected length of the value returned
by <code>Func</code>.</p>
</td></tr>
<tr><td><code id="PairwiseDistances_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>Func</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix detailing distance between each pair of trees.
Identical trees are assumed to have zero distance.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trees &lt;- list(BalancedTree(8), PectinateTree(8), StarTree(8))
TCIDiff &lt;- function(tree1, tree2) {
  TotalCopheneticIndex(tree1) - TotalCopheneticIndex(tree2)
}
PairwiseDistances(trees, TCIDiff, 1)
TCIRange &lt;- function(tree1, tree2) {
  range(TotalCopheneticIndex(tree1), TotalCopheneticIndex(tree2))
}
PairwiseDistances(trees, TCIRange, 2)
</code></pre>

<hr>
<h2 id='PathLengths'>Calculate length of paths between each pair of vertices within tree</h2><span id='topic+PathLengths'></span>

<h3>Description</h3>

<p>Given a weighted rooted tree <code>tree</code>, <code>PathLengths()</code> returns the distance
from each vertex to each of its descendant vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PathLengths(tree, fullMatrix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PathLengths_+3A_tree">tree</code></td>
<td>
<p>Original tree of class <code>phylo</code>, in <code><a href="#topic+Preorder">Preorder</a></code>.</p>
</td></tr>
<tr><td><code id="PathLengths_+3A_fullmatrix">fullMatrix</code></td>
<td>
<p>Logical specifying return format; see &quot;value&quot; section'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fullMatrix = TRUE</code>, <code>PathLengths()</code> returns a square matrix in
which entry <code style="white-space: pre;">&#8288;[i, j]&#8288;</code> denotes the distance from internal node <code>i</code> to the
descendant vertex <code>j</code>.
Vertex pairs without a continuous directed path are denoted <code>NA</code>.
If <code>fullMatrix = FALSE</code>, <code>PathLengths()</code> returns a <code>data.frame</code> with three
columns: <code>start</code> lists the deepest node in each path (i.e. that closest
to the root); <code>end</code> lists the shallowest node (i.e. that closest to a leaf);
<code>length</code> lists the total length of that path.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree properties: 
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TreeIsRooted">TreeIsRooted</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- rtree(6)
plot(tree)
add.scale.bar()
nodelabels()
tiplabels()
PathLengths(tree)
</code></pre>

<hr>
<h2 id='PolarizeSplits'>Polarize splits on a single taxon</h2><span id='topic+PolarizeSplits'></span>

<h3>Description</h3>

<p>Polarize splits on a single taxon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolarizeSplits(x, pole = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PolarizeSplits_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+Splits">Splits</a></code>.</p>
</td></tr>
<tr><td><code id="PolarizeSplits_+3A_pole">pole</code></td>
<td>
<p>Numeric or character identifying tip that should polarize each
split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PolarizeSplits()</code> returns a <code>Splits</code> object in which <code>pole</code> is
represented by a zero bit
</p>


<h3>See Also</h3>

<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>

<hr>
<h2 id='print.TreeNumber'>Print <code>TreeNumber</code> object</h2><span id='topic+print.TreeNumber'></span>

<h3>Description</h3>

<p>S3 method for objects of class <code>TreeNumber</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TreeNumber'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TreeNumber_+3A_x">x</code></td>
<td>
<p>Object of class <code>TreeNumber</code>.</p>
</td></tr>
<tr><td><code id="print.TreeNumber_+3A_...">...</code></td>
<td>
<p>Additional arguments for consistency with S3 method (unused).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other 'TreeNumber' utilities: 
<code><a href="#topic+TreeNumber">TreeNumber</a></code>,
<code><a href="#topic+is.TreeNumber">is.TreeNumber</a>()</code>
</p>

<hr>
<h2 id='ReadCharacters'>Read phylogenetic characters from file</h2><span id='topic+ReadCharacters'></span><span id='topic+ReadTntCharacters'></span><span id='topic+ReadNotes'></span><span id='topic+ReadAsPhyDat'></span><span id='topic+ReadTntAsPhyDat'></span><span id='topic+PhyDat'></span>

<h3>Description</h3>

<p>Parse a Nexus (Maddison et al. 1997) or
TNT (Goloboff et al. 2008) file, reading character states and
names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadCharacters(filepath, character_num = NULL, encoding = "UTF8")

ReadTntCharacters(
  filepath,
  character_num = NULL,
  type = NULL,
  encoding = "UTF8"
)

ReadNotes(filepath, encoding = "UTF8")

ReadAsPhyDat(...)

ReadTntAsPhyDat(...)

PhyDat(dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadCharacters_+3A_filepath">filepath</code></td>
<td>
<p>character string specifying location of file, or a
<a href="base.html#topic+connections">connection</a> to the file.</p>
</td></tr>
<tr><td><code id="ReadCharacters_+3A_character_num">character_num</code></td>
<td>
<p>Index of character(s) to return.
<code>NULL</code>, the default, returns all characters.</p>
</td></tr>
<tr><td><code id="ReadCharacters_+3A_encoding">encoding</code></td>
<td>
<p>Character encoding of input file.</p>
</td></tr>
<tr><td><code id="ReadCharacters_+3A_type">type</code></td>
<td>
<p>Character vector specifying categories of data to extract from
file. Setting <code>type = c("num", "dna")</code> will return only characters
following a <code style="white-space: pre;">&#8288;&amp;[num]&#8288;</code> or <code style="white-space: pre;">&#8288;&amp;[dna]&#8288;</code> tag in a TNT input file, listing <code>num</code>
character blocks before <code>dna</code> characters.
Leave as <code>NULL</code> (the default) to return all characters in their original
sequence.</p>
</td></tr>
<tr><td><code id="ReadCharacters_+3A_...">...</code></td>
<td>
<p>Parameters to pass to <code style="white-space: pre;">&#8288;Read[Tnt]Characters()&#8288;</code>.</p>
</td></tr>
<tr><td><code id="ReadCharacters_+3A_dataset">dataset</code></td>
<td>
<p>list of taxa and characters, in the format produced by <a href="ape.html#topic+read.nexus.data">read.nexus.data</a>:
a list of sequences each made of a single character vector,
and named with the taxon name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tested with matrices downloaded from <a href="https://morphobank.org">MorphoBank</a>
(OLeary and Kaufman 2011), but should also work more widely; please
<a href="https://github.com/ms609/TreeTools/issues/new?title=Error+parsing+Nexus+file&amp;body=%3C!--Tell+me+more+and+attach+your+file...--%3E">report</a>
incompletely or incorrectly parsed files.
</p>
<p>Matrices must contain only continuous or only discrete characters;
maximum one matrix per file.  Continuous characters will be read as strings
(i.e. base type &quot;character&quot;).
</p>
<p>The encoding of an input file will be automatically determined by R.
Errors pertaining to an <code style="white-space: pre;">&#8288;invalid multibyte string&#8288;</code> or
<code style="white-space: pre;">&#8288;string invalid at that locale&#8288;</code> indicate that R has failed to detect
the appropriate encoding.  Either
<a href="https://support.posit.co/hc/en-us/articles/200532197">re-save the file</a>
in a supported encoding (<code>UTF-8</code> is a good choice) or
specify the file encoding (which you can find by, for example, opening in
<a href="https://notepad-plus-plus.org/downloads/">Notepad++</a> and identifying
the highlighted option in the &quot;Encoding&quot; menu) following the example below.
</p>


<h3>Value</h3>

<p><code>ReadCharacters()</code> and <code>ReadTNTCharacters()</code> return a matrix whose
row names correspond to tip labels, and
column names correspond to character labels, with the
attribute <code>state.labels</code> listing the state labels for each character; or
a list of length one containing a character string explaining why the
function call was unsuccessful.
</p>
<p><code>ReadAsPhyDat()</code> and <code>ReadTntAsPhyDat()</code> return a <code>phyDat</code> object.
</p>
<p><code>ReadNotes()</code> returns a list in which each entry corresponds to a
single character, and itself contains a list of with two elements:
</p>

<ol>
<li><p> A single character object listing any notes associated with the character
</p>
</li>
<li><p> A named character vector listing the notes associated with each taxon
for that character, named with the names of each note-bearing taxon.
</p>
</li></ol>



<h3>Functions</h3>


<ul>
<li> <p><code>PhyDat()</code>: A convenient wrapper for <span class="pkg">phangorn</span>'s
<code>phyDat()</code>, which converts a <strong>list</strong> of morphological characters into a
<code>phyDat</code> object.
If your morphological characters are in the form of a <strong>matrix</strong>, perhaps
because they have been read using <code><a href="utils.html#topic+read.table">read.table()</a></code>, try <code><a href="#topic+MatrixToPhyDat">MatrixToPhyDat()</a></code>
instead.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Goloboff PA, Farris JS, Nixon KC (2008).
&ldquo;TNT, a free program for phylogenetic analysis.&rdquo;
<em>Cladistics</em>, <b>24</b>(5), 774&ndash;786.<br /><br /> Maddison DR, Swofford DL, Maddison WP (1997).
&ldquo;Nexus: an extensible file format for systematic information.&rdquo;
<em>Systematic Biology</em>, <b>46</b>, 590&ndash;621.
<a href="https://doi.org/10.1093/sysbio/46.4.590">doi:10.1093/sysbio/46.4.590</a>.<br /><br /> OLeary MA, Kaufman S (2011).
&ldquo;MorphoBank: phylophenomics in the &quot;cloud&quot;.&rdquo;
<em>Cladistics</em>, <b>27</b>(5), 529&ndash;537.
</p>


<h3>See Also</h3>


<ul>
<li><p> Convert between matrices and <code>phyDat</code> objects: <code><a href="#topic+MatrixToPhyDat">MatrixToPhyDat()</a></code>
</p>
</li>
<li><p> Write characters to TNT-format file: <code><a href="#topic+WriteTntCharacters">WriteTntCharacters()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fileName &lt;- paste0(system.file(package = "TreeTools"),
                   "/extdata/input/dataset.nex")
ReadCharacters(fileName)

fileName &lt;- paste0(system.file(package = "TreeTools"),
                   "/extdata/tests/continuous.nex")

continuous &lt;- ReadCharacters(fileName, encoding = "UTF8")

# To convert from strings to numbers:
at &lt;- attributes(continuous)
continuous &lt;- suppressWarnings(as.numeric(continuous))
attributes(continuous) &lt;- at
continuous
</code></pre>

<hr>
<h2 id='ReadMrBayesTrees'>Read posterior tree sample produced by MrBayes</h2><span id='topic+ReadMrBayesTrees'></span><span id='topic+ReadMrBayes'></span><span id='topic+MrBayesTrees'></span>

<h3>Description</h3>

<p>Read posterior trees from <a href="https://nbisweden.github.io/MrBayes/">'MrBayes'</a> output files, discarding burn-in
generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadMrBayesTrees(filepath, n = NULL, burninFrac = NULL)

ReadMrBayes(filepath, n = NULL, burninFrac = NULL)

MrBayesTrees(filepath, n = NULL, burninFrac = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadMrBayesTrees_+3A_filepath">filepath</code></td>
<td>
<p>character string specifying path to <code>.nex</code> input file used
to initialize the MrBayes analysis,
relative to the R working directory (visible with <code>getwd()</code>).</p>
</td></tr>
<tr><td><code id="ReadMrBayesTrees_+3A_n">n</code></td>
<td>
<p>Integer specifying number of trees to sample from posterior.</p>
</td></tr>
<tr><td><code id="ReadMrBayesTrees_+3A_burninfrac">burninFrac</code></td>
<td>
<p>Fraction of trees to discard from each run as burn-in.
If <code>NULL</code> (the default), this will be read from the last <code>mcmc</code> or <code>mcmcp</code>
command in <code>filepath</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ReadMrBayesTrees()</code> samples trees from the posterior distributions
computed using the Bayesian inference software <a href="https://nbisweden.github.io/MrBayes/">'MrBayes'</a>
</p>


<h3>Value</h3>

<p><code>ReadMrBayesTrees()</code> returns a 'multiPhylo' object containing
<code>n</code> trees sampled evenly from all runs generated by analysis of <code>filepath</code>,
or <code>NULL</code> if no trees are found.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree import functions: 
<code><a href="#topic+ReadTntTree">ReadTntTree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # Download will take a few seconds
  url &lt;- 
  "https://raw.githubusercontent.com/ms609/hyoliths/master/MrBayes/hyo.nex"
  trees &lt;- ReadMrBayesTrees(url, n = 40)
  plot(Consensus(trees, p = 0.5))

## End(Not run)
</code></pre>

<hr>
<h2 id='ReadTntTree'>Parse TNT Tree</h2><span id='topic+ReadTntTree'></span><span id='topic+TntText2Tree'></span><span id='topic+TNTText2Tree'></span>

<h3>Description</h3>

<p>Read a tree from <a href="https://www.lillo.org.ar/phylogeny/tnt/">TNT</a>'s
parenthetical output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadTntTree(filepath, relativePath = NULL, keepEnd = 1L, tipLabels = NULL)

TntText2Tree(treeText)

TNTText2Tree(treeText)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadTntTree_+3A_filepath">filepath</code></td>
<td>
<p>character string specifying path to TNT <code>.tre</code> file,
relative to the R working directory (visible with <code>getwd()</code>).</p>
</td></tr>
<tr><td><code id="ReadTntTree_+3A_relativepath">relativePath</code></td>
<td>
<p>(discouraged) character string specifying location of the
matrix file used to generate the TNT results, relative to the current working
directory.  Taxon names will be read from this file if they are not specified
by <code>tipLabels</code>.</p>
</td></tr>
<tr><td><code id="ReadTntTree_+3A_keepend">keepEnd</code></td>
<td>
<p>(optional, default 1) integer specifying how many elements of
the file path to conserve when creating relative path (see examples).</p>
</td></tr>
<tr><td><code id="ReadTntTree_+3A_tiplabels">tipLabels</code></td>
<td>
<p>(optional) character vector specifying the names of the
taxa, in the sequence that they appear in the TNT file.  If not specified,
taxon names will be loaded from the data file linked in the first line of the
<code>.tre</code> file specified in <code>filepath</code>.</p>
</td></tr>
<tr><td><code id="ReadTntTree_+3A_treetext">treeText</code></td>
<td>
<p>Character string describing one or more trees,
in the parenthetical format output by TNT.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ReadTntTree()</code> imports trees generated by the parsimony analysis program
<a href="https://www.lillo.org.ar/phylogeny/tnt/">TNT</a> into R, including node labels
written with the <code>ttags</code> command.
Tree files must have been saved by TNT in parenthetical notation, using the
TNT command <code style="white-space: pre;">&#8288;tsave *&#8288;</code>.
Trees are easiest to load into R if taxa have been saved using their names
(TNT command <code style="white-space: pre;">&#8288;taxname =&#8288;</code>).  In this case, the TNT <code>.tre</code> file
contains tip labels and can be parsed directly.  The downside is that the
uncompressed <code>.tre</code> files will have a larger file size.
</p>
<p><code>ReadTntTree()</code> can also read <code>.tre</code> files in which taxa have been saved
using their numbers (<code style="white-space: pre;">&#8288;taxname -&#8288;</code>).  Such files contain a hard-coded link to
the matrix file that was used to generate the trees, in the first line of the
<code>.tre</code> file.  This poses problems for portability: if the matrix file is
moved, or the <code>.tre</code> file is accessed on another computer, the taxon names
may be lost.  As such, it is important to check that the matrix file
exists in the expected location &ndash; if it does not,
either use the <code>relativePath</code> argument to point to its new location, or
specify <code>tipLabels</code> to manually specify the tip labels.
</p>
<p><code>TntText2Tree()</code> converts text representation of a tree in TNT to an
object of class <code>phylo</code>.
</p>


<h3>Value</h3>

<p><code>ReadTntTree()</code> returns a tree of class <code>phylo</code> in
<a href="#topic+TNTOrder">TNTOrder</a><code>tnt</code> order,
corresponding to the tree in <code>filepath</code>, or NULL if no trees are found.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree import functions: 
<code><a href="#topic+ReadMrBayesTrees">ReadMrBayesTrees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In the examples below, TNT has read a matrix from
# "c:/TreeTools/input/dataset.nex"
# The results of an analysis were written to
# "c:/TreeTools/output/results1.tnt"
#
# results1.tnt will contain a hard-coded reference to
# "c:/TreeTools/input/dataset.nex".

# On the original machine (but not elsewhere), it would be possible to read
# this hard-coded reference from results.tnt:
# ReadTntTree("output/results1.tnt")

# These datasets are provided with the "TreeTools" package, which will
# probably not be located at c:/TreeTools on your machine:

oldWD &lt;- getwd() # Remember the current working directory
setwd(system.file(package = "TreeTools"))

# If taxon names were saved within the file (using `taxname=` in TNT),
# then our job is easy:
ReadTntTree("extdata/output/named.tre")

# But if taxa were compressed to numbers (using `taxname-`), we need to
# look up the original matrix in order to dereference the tip names.
#
# We need to extract the relevant file path from the end of the
# hard-coded path in the original file.
#
# We are interested in the last two elements of
# c:/TreeTools/input/dataset.nex
#                2      1
#
# "." means "relative to the current directory"
ReadTntTree("extdata/output/numbered.tre", "./extdata", 2)

# If working in a lower subdirectory
setwd("./extdata/otherfolder")

# then it will be necessary to navigate up the directory path with "..":
ReadTntTree("../output/numbered.tre", "..", 2)


setwd(oldWD) # Restore original working directory

TNTText2Tree("(A (B (C (D E ))));")

</code></pre>

<hr>
<h2 id='Renumber'>Renumber a tree's nodes and tips</h2><span id='topic+Renumber'></span>

<h3>Description</h3>

<p><code>Renumber()</code> numbers the nodes and tips in a tree to conform with the
<code>phylo</code> standards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Renumber(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Renumber_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <span class="pkg">ape</span> class <code>phylo</code> is not formally defined, but expects trees' internal
representation to conform to certain principles: for example, nodes should
be numbered sequentially, with values increasing away from the root.
</p>
<p><code>Renumber()</code> attempts to reformat any tree into a representation that will
not cause <span class="pkg">ape</span> functions to produce unwanted results or to crash R.
</p>


<h3>Value</h3>

<p><code>Renumber()</code> returns a tree of class <code>phylo</code>, numbered in a
<a href="#topic+Cladewise">Cladewise</a> fashion consistent with the expectations of <span class="pkg">ape</span> functions.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code>Preorder()</code> provides a faster and simpler alternative, but also
rotates nodes.
</p>
<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- RandomTree(letters[1:10])
Renumber(tree)

</code></pre>

<hr>
<h2 id='RenumberTips'>Renumber a tree's tips</h2><span id='topic+RenumberTips'></span><span id='topic+RenumberTips.phylo'></span><span id='topic+RenumberTips.multiPhylo'></span><span id='topic+RenumberTips.list'></span><span id='topic+RenumberTips.NULL'></span>

<h3>Description</h3>

<p><code>RenumberTips(tree, tipOrder)</code> sorts the tips of a phylogenetic tree <code>tree</code>
such that the indices in <code>tree[["edge"]][, 2]</code> correspond to the order of
leaves given in <code>tipOrder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RenumberTips(tree, tipOrder)

## S3 method for class 'phylo'
RenumberTips(tree, tipOrder)

## S3 method for class 'multiPhylo'
RenumberTips(tree, tipOrder)

## S3 method for class 'list'
RenumberTips(tree, tipOrder)

## S3 method for class ''NULL''
RenumberTips(tree, tipOrder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RenumberTips_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="RenumberTips_+3A_tiporder">tipOrder</code></td>
<td>
<p>A character vector containing the values of
<code>tree[["tip.label"]]</code> in the desired sort order, or an object
(perhaps of class <code>phylo</code> or <code>Splits</code>) with tip labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RenumberTips()</code> returns <code>tree</code>, with the tips' internal
representation numbered to match <code>tipOrder</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lobo") # Loads the phyDat object Lobo.phy
tree &lt;- RandomTree(Lobo.phy)
tree &lt;- RenumberTips(tree, names(Lobo.phy))

</code></pre>

<hr>
<h2 id='RenumberTree'>Reorder tree edges and nodes</h2><span id='topic+RenumberTree'></span><span id='topic+RenumberEdges'></span><span id='topic+Reorder'></span><span id='topic+Cladewise'></span><span id='topic+Cladewise.phylo'></span><span id='topic+Cladewise.list'></span><span id='topic+Cladewise.multiPhylo'></span><span id='topic+Cladewise.matrix'></span><span id='topic+Cladewise.NULL'></span><span id='topic+ApePostorder'></span><span id='topic+ApePostorder.phylo'></span><span id='topic+ApePostorder.list'></span><span id='topic+ApePostorder.NULL'></span><span id='topic+ApePostorder.multiPhylo'></span><span id='topic+Postorder'></span><span id='topic+Postorder.phylo'></span><span id='topic+Postorder.NULL'></span><span id='topic+Postorder.list'></span><span id='topic+Postorder.multiPhylo'></span><span id='topic+Postorder.numeric'></span><span id='topic+PostorderOrder'></span><span id='topic+PostorderOrder.phylo'></span><span id='topic+PostorderOrder.numeric'></span><span id='topic+Pruningwise'></span><span id='topic+Pruningwise.phylo'></span><span id='topic+Pruningwise.list'></span><span id='topic+Pruningwise.multiPhylo'></span><span id='topic+Pruningwise.NULL'></span><span id='topic+Preorder'></span><span id='topic+Preorder.phylo'></span><span id='topic+Preorder.numeric'></span><span id='topic+Preorder.multiPhylo'></span><span id='topic+Preorder.list'></span><span id='topic+Preorder.NULL'></span><span id='topic+TntOrder'></span><span id='topic+TNTOrder'></span><span id='topic+TntOrder.phylo'></span><span id='topic+TntOrder.numeric'></span><span id='topic+TntOrder.multiPhylo'></span><span id='topic+TntOrder.list'></span><span id='topic+TntOrder.NULL'></span>

<h3>Description</h3>

<p>Functions for systematically ordering the internal edges of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RenumberTree(parent, child, weight)

RenumberEdges(parent, child, ...)

Cladewise(tree, nTip, edge)

## S3 method for class 'phylo'
Cladewise(tree, nTip = NTip(tree), edge = tree[["edge"]])

## S3 method for class 'list'
Cladewise(tree, nTip, edge)

## S3 method for class 'multiPhylo'
Cladewise(tree, nTip, edge)

## S3 method for class 'matrix'
Cladewise(tree, nTip = min(tree[, 1]) - 1L, edge)

## S3 method for class ''NULL''
Cladewise(tree, nTip = min(tree[, 1]) - 1L, edge)

ApePostorder(tree, nTip, edge)

## S3 method for class 'phylo'
ApePostorder(tree, nTip = NTip(tree), edge = tree[["edge"]])

## S3 method for class 'list'
ApePostorder(tree, nTip, edge)

## S3 method for class ''NULL''
ApePostorder(tree, nTip, edge)

## S3 method for class 'multiPhylo'
ApePostorder(tree, nTip, edge)

Postorder(tree, force = FALSE)

## S3 method for class 'phylo'
Postorder(tree, force = FALSE)

## S3 method for class ''NULL''
Postorder(tree, force = FALSE)

## S3 method for class 'list'
Postorder(tree, force = FALSE)

## S3 method for class 'multiPhylo'
Postorder(tree, force = FALSE)

## S3 method for class 'numeric'
Postorder(tree, force = FALSE)

PostorderOrder(tree)

## S3 method for class 'phylo'
PostorderOrder(tree)

## S3 method for class 'numeric'
PostorderOrder(tree)

Pruningwise(tree, nTip, edge)

## S3 method for class 'phylo'
Pruningwise(tree, nTip = NTip(tree), edge = tree[["edge"]])

## S3 method for class 'list'
Pruningwise(tree, nTip, edge)

## S3 method for class 'multiPhylo'
Pruningwise(tree, nTip, edge)

## S3 method for class ''NULL''
Pruningwise(tree, nTip, edge)

Preorder(tree)

## S3 method for class 'phylo'
Preorder(tree)

## S3 method for class 'numeric'
Preorder(tree)

## S3 method for class 'multiPhylo'
Preorder(tree)

## S3 method for class 'list'
Preorder(tree)

## S3 method for class ''NULL''
Preorder(tree)

TntOrder(tree)

TNTOrder(tree)

## S3 method for class 'phylo'
TntOrder(tree)

## S3 method for class 'numeric'
TntOrder(tree)

## S3 method for class 'multiPhylo'
TntOrder(tree)

## S3 method for class 'list'
TntOrder(tree)

## S3 method for class ''NULL''
TntOrder(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RenumberTree_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 1]</code></p>
</td></tr>
<tr><td><code id="RenumberTree_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree[["edge"]][, 2]</code>.</p>
</td></tr>
<tr><td><code id="RenumberTree_+3A_weight">weight</code></td>
<td>
<p>Optional vector specifying the weight of each edge,
corresponding to the <code>edge.length</code> property of a <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="RenumberTree_+3A_...">...</code></td>
<td>
<p>Deprecated; included for compatibility with previous versions.</p>
</td></tr>
<tr><td><code id="RenumberTree_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="RenumberTree_+3A_ntip">nTip</code></td>
<td>
<p>Integer specifying number of tips (leaves).</p>
</td></tr>
<tr><td><code id="RenumberTree_+3A_edge">edge</code></td>
<td>
<p>Two-column matrix listing the parent and child of each edge in a
tree, corresponding to <code>tree[["edge"]]</code>. Optional in <code>Cladewise()</code>.</p>
</td></tr>
<tr><td><code id="RenumberTree_+3A_force">force</code></td>
<td>
<p>Logical specifying whether to rearrange trees already in
postorder, in order to ensure edges are ordered in the &quot;TreeTools&quot; fashion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Reorder()</code> is a wrapper for <code>ape:::.reorder_ape</code>.
Calling this C function directly is approximately twice as fast as using
<code>ape::<a href="ape.html#topic+reorder.phylo">cladewise</a></code> or
<code>ape::<a href="ape.html#topic+reorder.phylo">postorder</a></code>
</p>
<p><code>Cladewise()</code>, <code>ApePostorder()</code> and <code>Pruningwise()</code> are convenience
functions to the corresponding functions in &quot;ape&quot;.
Single nodes may need to be collapsed using <a href="ape.html#topic+collapse.singles">ape::collapse.singles</a> first.
&quot;ape&quot; functions can cause crashes if nodes are numbered unconventionally &ndash;
sometimes arising after using tree rearrangement functions,
e.g. <code>phangorn::SPR()</code>.
</p>
<p><code>Preorder()</code> is more robust: it supports polytomies, nodes may be numbered
in any sequence, and edges may be listed in any order in the input tree.
Its output is guaranteed to be identical for any tree of an equivalent
leaf labelling (see <code>RenumberTips()</code>) and topology,
allowing unique trees to be detected by comparing sorted edge matrices alone.
</p>
<p>Nodes and edges in a preorder tree are numbered starting from the deepest
node.
Each node is numbered in the sequence in which it is encountered, and
each edge is listed in the sequence in which it is visited.
</p>
<p>At each node, child edges are sorted from left to right in order of the
lowest-numbered leaf in the subtree subtended by each edge; i.e. an edge
that leads eventually to tip 1 will be to the left of an edge leading to a
subtree containing tip 2.
</p>
<p>Numbering begins by following the leftmost edge of the root node,
and sorting its descendant subtree into preorder.
Then, the next edge at the root node is followed, and its descendants
sorted into preorder, until each edge has been visited.
</p>
<p><code>RenumberTree()</code> and <code>RenumberEdges()</code> are wrappers for the C function
<code>preorder_edges_and_nodes()</code>; they do not perform the same checks on input
as <code>Preorder()</code> and are intended for use where performance is at a premium.
</p>
<p><code>Postorder()</code> numbers nodes as in <code>Preorder()</code>, and lists edges in
descending order of parent node number, breaking ties by listing child
nodes in increasing order.  If a tree is already in postorder, it will not
be rearranged unless <code>force = TRUE</code>.
</p>
<p>Methods applied to numeric inputs do not check input for sanity, so should
be used with caution: malformed input may cause undefined results, including
crashing R.
</p>
<p>Trees with &gt;8191 leaves require additional memory and are not handled
by <code>Postorder()</code> at present.
If you need to process such large trees, please contact the maintainer for
advice.
</p>


<h3>Value</h3>

<p><code>RenumberTree()</code> returns an edge matrix for a tree of class <code>phylo</code>
following the preorder convention for edge and node numbering.
</p>
<p><code>RenumberEdges()</code> formats the output of <code>RenumberTree()</code> into a list
whose two entries correspond to the new parent and child vectors.
</p>
<p><code>ApePostorder()</code>, <code>Cladewise()</code>, <code>Postorder()</code>, <code>Preorder()</code> and
<code>Pruningwise()</code> each return a tree of class <code>phylo</code> with nodes following the
specified numbering scheme.
</p>
<p><code>Postorder.numeric</code> accepts a numeric matrix corresponding to the
<code>edge</code> entry of a tree of class <code>phylo</code>, and returns a two-column array
corresponding to <code>tree</code>, with edges listed in postorder
</p>
<p><code>PostorderOrder()</code> returns an integer vector. Visiting edges in this
order will traverse the tree in postorder.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Cladewise()</code>: Reorder tree cladewise.
</p>
</li>
<li> <p><code>ApePostorder()</code>: Reorder tree in Postorder using ape's <code>postorder</code>
function, which is robust to unconventional node numbering.
</p>
</li>
<li> <p><code>Pruningwise()</code>: Reorder tree Pruningwise.
</p>
</li>
<li> <p><code>Preorder()</code>: Reorder tree in Preorder (special case of cladewise).
</p>
</li>
<li> <p><code>TntOrder()</code>: Reorder tree in postorder, numbering internal nodes
according to <a href="https://stackoverflow.com/a/54296100/3438001">TNT's rules</a>,
which number the root node as <code>nTip + 1</code>, then the remaining nodes in
the sequence encountered when traversing the tree in postorder, starting from
each tip in sequence.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><code>Preorder()</code> and <code>Postorder()</code>: Martin R. Smith.
</p>
<p><code>Cladewise()</code>, <code>ApePostorder()</code> and <code>Pruningwise()</code>: modified by Martin R.
Smith from <code>.reorder_ape()</code> in <span class="pkg">ape</span> (Emmanuel Paradis).
</p>


<h3>See Also</h3>

<p>Rotate each node into a consistent orientation with <code><a href="#topic+SortTree">SortTree()</a></code>.
</p>
<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>
<p>Other C wrappers: 
<code><a href="#topic+Neworder">Neworder</a></code>
</p>
<p>Other C wrappers: 
<code><a href="#topic+Neworder">Neworder</a></code>
</p>

<hr>
<h2 id='RightmostCharacter'>Rightmost character of string</h2><span id='topic+RightmostCharacter'></span>

<h3>Description</h3>

<p><code>RightmostCharacter()</code> is a convenience function that returns the final
character of a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RightmostCharacter(string, len = nchar(string))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RightmostCharacter_+3A_string">string</code></td>
<td>
<p>Character string.</p>
</td></tr>
<tr><td><code id="RightmostCharacter_+3A_len">len</code></td>
<td>
<p>(Optional) Integer specifying number of characters in <code>string</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RightmostCharacter()</code> returns the rightmost character of a string.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other string parsing functions: 
<code><a href="#topic+EndSentence">EndSentence</a>()</code>,
<code><a href="#topic+MorphoBankDecode">MorphoBankDecode</a>()</code>,
<code><a href="#topic+Unquote">Unquote</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RightmostCharacter("Hello, World!")

</code></pre>

<hr>
<h2 id='RoguePlot'>Visualize position of rogue taxa</h2><span id='topic+RoguePlot'></span>

<h3>Description</h3>

<p>Plots a consensus of trees with a rogue taxon omitted, with edges coloured
according to the proportion of trees in which the taxon attaches to that
edge, after Klopfstein and Spasojevic (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RoguePlot(
  trees,
  tip,
  p = 1,
  plot = TRUE,
  Palette = colorRampPalette(c(par("fg"), "#009E73"), space = "Lab"),
  nullCol = rgb(colorRamp(unlist(par(c("fg", "bg"))), space = "Lab")(0.8)/255),
  edgeLength = NULL,
  thin = par("lwd"),
  fat = thin + 1L,
  outgroupTips,
  sort = FALSE,
  legend = "none",
  legend.inset = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RoguePlot_+3A_trees">trees</code></td>
<td>
<p>List or <code>multiPhylo</code> object containing phylogenetic trees
of class <code>phylo</code> to be summarized.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_tip">tip</code></td>
<td>
<p>Numeric or character identifying rogue leaf, in format accepted
by <code><a href="#topic+DropTip">DropTip()</a></code>.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_p">p</code></td>
<td>
<p>A numeric value between 0.5 and 1 giving the proportion for a clade
to be represented in the consensus tree (see <code><a href="#topic+Consensus">Consensus()</a></code>).</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_plot">plot</code></td>
<td>
<p>Logical specifying whether to plot the tree.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_palette">Palette</code></td>
<td>
<p>Function that takes a parameter <code>n</code> and generates a colour
palette with <code>n</code> entries.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_nullcol">nullCol</code></td>
<td>
<p>Colour to paint regions of the tree on which the rogue is
never found.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_edgelength">edgeLength</code></td>
<td>
<p>Numeric specifying edge lengths of consensus tree;
<code>NULL</code> aligns tips by scaling edges proportional to clade size; <code>1</code> sets
all edges to unit length.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_thin">thin</code>, <code id="RoguePlot_+3A_fat">fat</code></td>
<td>
<p>Numeric specifying width to plot edges if the rogue tip
never / sometimes does attach to them.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_outgrouptips">outgroupTips</code></td>
<td>
<p>Vector of type character, integer or logical, specifying
the names or indices of the tips to include in the outgroup.  If
<code>outgroupTips</code> is a of type character, and a tree contains multiple tips
with a matching label, the first will be used.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_sort">sort</code></td>
<td>
<p>Logical specifying whether to sort consensus tree using
<code><a href="#topic+SortTree">SortTree()</a></code>.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_legend">legend</code></td>
<td>
<p>Character vector specifying position of legend (e.g.
<code>"bottomleft"</code>), or <code>"none"</code> to suppress legend.
For fine-grained control of legend, use <code><a href="PlotTools.html#topic+SpectrumLegend">PlotTools::SpectrumLegend()</a></code>.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_legend.inset">legend.inset</code></td>
<td>
<p>Numeric specifying fraction of plot width / height
by which the legend's position should be inset.</p>
</td></tr>
<tr><td><code id="RoguePlot_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code>plot.phylo()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rogue taxa can be identified using the package <span class="pkg">Rogue</span>
(Smith 2022).
</p>


<h3>Value</h3>

<p><code>RoguePlot()</code> invisibly returns a list whose elements are:
</p>

<ul>
<li> <p><code>cons</code>: The reduced consensus tree, in preorder;
</p>
</li>
<li> <p><code>onEdge</code>: a vector of integers specifying the number of
trees in <code>trees</code> in which the rogue leaf is attached to each edge in turn
of the consensus tree;
</p>
</li>
<li> <p><code>atNode</code>: a vector of integers specifying the number of trees in <code>trees</code>
in which the rogue leaf is attached to an edge collapsed into each node
of the consensus tree.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Klopfstein S, Spasojevic T (2019).
&ldquo;Illustrating phylogenetic placement of fossils using RoguePlots: An example from ichneumonid parasitoid wasps (Hymenoptera, Ichneumonidae) and an extensive morphological matrix.&rdquo;
<em>PLOS ONE</em>, <b>14</b>(4), e0212942.
<a href="https://doi.org/10.1371/journal.pone.0212942">doi:10.1371/journal.pone.0212942</a>.<br /><br /> Smith MR (2022).
&ldquo;Using information theory to detect rogue taxa and improve consensus trees.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(5), 986&ndash;1008.
<a href="https://doi.org/10.1093/sysbio/syab099">doi:10.1093/sysbio/syab099</a>.
</p>


<h3>See Also</h3>

<p>Other consensus tree functions: 
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+Consensus">Consensus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trees &lt;- list(read.tree(text = "(a, (b, (c, (rogue, (d, (e, f))))));"),
              read.tree(text = "(a, (b, (c, (rogue, (d, (e, f))))));"),
              read.tree(text = "(a, (b, (c, (rogue, (d, (e, f))))));"),
              read.tree(text = "(a, (b, (c, (rogue, (d, (e, f))))));"),
              read.tree(text = "(rogue, (a, (b, (c, (d, (e, f))))));"),
              read.tree(text = "((rogue, a), (b, (c, (d, (e, f)))));"),
              read.tree(text = "(a, (b, ((c, d), (rogue, (e, f)))));"),
              read.tree(text = "(a, (b, ((c, (rogue, d)), (e, f))));"),
              read.tree(text = "(a, (b, (c, (d, (rogue, (e, f))))));"))
RoguePlot(trees, "rogue", legend = "topleft", legend.inset = 0.02)
</code></pre>

<hr>
<h2 id='RootNode'>Which node is a tree's root?</h2><span id='topic+RootNode'></span>

<h3>Description</h3>

<p><code>RootNode()</code> identifies the root node of a (rooted or unrooted) phylogenetic
tree.
Unrooted trees are represented internally by a rooted tree with a polytomy
at the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RootNode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RootNode_+3A_x">x</code></td>
<td>
<p>A tree of class <code>phylo</code>, or its edge matrix; or a list or
<code>multiPhylo</code> object containing multiple trees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RootNode()</code> returns an integer denoting the root node for each tree.
Badly conformed trees trigger an error.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Test whether a tree is rooted: <code><a href="#topic+TreeIsRooted">TreeIsRooted()</a></code>
</p>
<p><code>phangorn::getRoot()</code>
</p>
<p>Other tree navigation: 
<code><a href="#topic+AncestorEdge">AncestorEdge</a>()</code>,
<code><a href="#topic+CladeSizes">CladeSizes</a>()</code>,
<code><a href="#topic+DescendantEdges">DescendantEdges</a>()</code>,
<code><a href="#topic+EdgeAncestry">EdgeAncestry</a>()</code>,
<code><a href="#topic+EdgeDistances">EdgeDistances</a>()</code>,
<code><a href="#topic+ListAncestors">ListAncestors</a>()</code>,
<code><a href="#topic+MRCA">MRCA</a>()</code>,
<code><a href="#topic+NDescendants">NDescendants</a>()</code>,
<code><a href="#topic+NodeDepth">NodeDepth</a>()</code>,
<code><a href="#topic+NodeOrder">NodeOrder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RootNode(BalancedTree(8))
RootNode(UnrootTree(BalancedTree(8)))


</code></pre>

<hr>
<h2 id='RootTree'>Root or unroot a phylogenetic tree</h2><span id='topic+RootTree'></span><span id='topic+RootOnNode'></span><span id='topic+UnrootTree'></span>

<h3>Description</h3>

<p><code>RootTree()</code> roots a tree on the smallest clade containing the specified
tips;
<code>RootOnNode()</code> roots a tree on a specified internal node;
<code>UnrootTree()</code> collapses a root node, without the undefined behaviour
encountered when using <code><a href="ape.html#topic+root">ape::unroot</a>()</code> on trees in
preorder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RootTree(tree, outgroupTips)

RootOnNode(tree, node, resolveRoot = FALSE)

UnrootTree(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RootTree_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>, or a list of trees
of class <code>list</code> or <code>multiPhylo</code>.</p>
</td></tr>
<tr><td><code id="RootTree_+3A_outgrouptips">outgroupTips</code></td>
<td>
<p>Vector of type character, integer or logical, specifying
the names or indices of the tips to include in the outgroup.  If
<code>outgroupTips</code> is a of type character, and a tree contains multiple tips
with a matching label, the first will be used.</p>
</td></tr>
<tr><td><code id="RootTree_+3A_node">node</code></td>
<td>
<p>integer specifying node (internal or tip) to set as the root.</p>
</td></tr>
<tr><td><code id="RootTree_+3A_resolveroot">resolveRoot</code></td>
<td>
<p>logical specifying whether to resolve the root node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RootTree()</code> returns a tree of class <code>phylo</code>, rooted on the smallest
clade that contains the specified tips, with edges and nodes numbered in
preorder.
</p>
<p><code>RootOnNode()</code> returns a tree of class <code>phylo</code>, rooted on the
requested <code>node</code> and ordered in <code><a href="#topic+Preorder">Preorder</a></code>.
</p>
<p><code>UnrootTree()</code> returns <code>tree</code>, in preorder,
having collapsed the first child of the root node in each tree.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="ape.html#topic+root">ape::root()</a></code>
</p>
</li></ul>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- PectinateTree(8)
plot(tree)
ape::nodelabels()

plot(RootTree(tree, c("t6", "t7")))

plot(RootOnNode(tree, 12))
plot(RootOnNode(tree, 2))

</code></pre>

<hr>
<h2 id='SampleOne'>Quickly sample</h2><span id='topic+SampleOne'></span>

<h3>Description</h3>

<p><code>SampleOne()</code> is a fast alternative to  <code><a href="base.html#topic+sample">sample()</a></code> that avoids some checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SampleOne(x, len = length(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SampleOne_+3A_x">x</code></td>
<td>
<p>A vector to sample.</p>
</td></tr>
<tr><td><code id="SampleOne_+3A_len">len</code></td>
<td>
<p>(Optional) Integer specifying length of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SampleOne()</code> returns a length one vector, randomly sampled from <code>x</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SampleOne(9:10)
SampleOne(letters[1:4])

</code></pre>

<hr>
<h2 id='sapply64'>Apply a function that returns 64-bit integers over a list or vector</h2><span id='topic+sapply64'></span><span id='topic+vapply64'></span><span id='topic+replicate64'></span>

<h3>Description</h3>

<p>Wrappers for members of the <code><a href="base.html#topic+lapply">lapply()</a></code> family intended for use when a
function <code>FUN</code> returns a vector of <code>integer64</code> objects.
<code>vapply()</code>, <code>sapply()</code> or <code>replicate()</code> drop the <code>integer64</code> class,
resulting in a vector of numerics that require conversion back to
64-bit integers.  These functions restore the missing <code>class</code> attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sapply64(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)

vapply64(X, FUN, FUN.LEN = 1, ...)

replicate64(n, expr, simplify = "array")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sapply64_+3A_x">X</code></td>
<td>
<p>a vector (atomic or list) or an <code><a href="base.html#topic+expression">expression</a></code>
object.  Other objects (including classed objects) will be coerced
by <code>base::<a href="base.html#topic+as.list">as.list</a></code>.</p>
</td></tr>
<tr><td><code id="sapply64_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to each element of <code>X</code>:
see &lsquo;Details&rsquo;.  In the case of functions like
<code>+</code>, <code>%*%</code>, the function name must be backquoted or quoted.</p>
</td></tr>
<tr><td><code id="sapply64_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="sapply64_+3A_simplify">simplify</code></td>
<td>
<p>logical or character string; should the result be
simplified to a vector, matrix or higher dimensional array if
possible?  For <code>sapply</code> it must be named and not abbreviated.
The default value, <code>TRUE</code>, returns a vector or matrix if appropriate,
whereas if <code>simplify = "array"</code> the result may be an
<code><a href="base.html#topic+array">array</a></code> of &ldquo;rank&rdquo;
(<code class="reqn">=</code><code>length(dim(.))</code>) one higher than the result
of <code>FUN(X[[i]])</code>.</p>
</td></tr>
<tr><td><code id="sapply64_+3A_use.names">USE.NAMES</code></td>
<td>
<p>logical; if <code>TRUE</code> and if <code>X</code> is character,
use <code>X</code> as <code><a href="base.html#topic+names">names</a></code> for the result unless it had names
already.  Since this argument follows <code>...</code> its name cannot
be abbreviated.</p>
</td></tr>
<tr><td><code id="sapply64_+3A_fun.len">FUN.LEN</code></td>
<td>
<p>Integer specifying the length of the output of <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="sapply64_+3A_n">n</code></td>
<td>
<p>integer: the number of replications.</p>
</td></tr>
<tr><td><code id="sapply64_+3A_expr">expr</code></td>
<td>
<p>the expression (a <a href="base.html#topic+language+20object">language object</a>, usually a call)
to evaluate repeatedly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the underlying functions, see <code><a href="base.html#topic+lapply">base::lapply()</a></code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code><a href="bit64.html#topic+bit64-package">bit64::integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapply64(as.phylo(1:6, 6), as.TreeNumber)
vapply64(as.phylo(1:6, 6), as.TreeNumber, 1)
set.seed(0)
replicate64(6, as.TreeNumber(RandomTree(6)))
</code></pre>

<hr>
<h2 id='sort.multiPhylo'>Sort a list of phylogenetic trees</h2><span id='topic+sort.multiPhylo'></span><span id='topic++3D+3D.phylo'></span><span id='topic++3C.phylo'></span><span id='topic++3E.phylo'></span><span id='topic++3D+3D.MixedBase'></span><span id='topic++3C.MixedBase'></span><span id='topic++3E.MixedBase'></span>

<h3>Description</h3>

<p>Trees are sorted by their <a href="#topic+TreeNumber">mixed base representation</a>,
treating their leaves in the order of their labels (i.e. alphabetically,
if leaves are labelled with text).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiPhylo'
sort(x, decreasing = FALSE, na.last = NA, ...)

## S3 method for class 'phylo'
e1 == e2

## S3 method for class 'phylo'
e1 &lt; e2

## S3 method for class 'phylo'
e1 &gt; e2

## S3 method for class 'MixedBase'
e1 == e2

## S3 method for class 'MixedBase'
e1 &lt; e2

## S3 method for class 'MixedBase'
e1 &gt; e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.multiPhylo_+3A_x">x</code>, <code id="sort.multiPhylo_+3A_decreasing">decreasing</code>, <code id="sort.multiPhylo_+3A_na.last">na.last</code>, <code id="sort.multiPhylo_+3A_...">...</code></td>
<td>
<p>As in <code><a href="base.html#topic+sort">sort()</a></code>.</p>
</td></tr>
<tr><td><code id="sort.multiPhylo_+3A_e1">e1</code>, <code id="sort.multiPhylo_+3A_e2">e2</code></td>
<td>
<p>Objects to be compared.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sort(as.phylo(5:0, 7))
</code></pre>

<hr>
<h2 id='SortTree'>Sort tree</h2><span id='topic+SortTree'></span><span id='topic+SortTree.phylo'></span><span id='topic+SortTree.list'></span><span id='topic+SortTree.multiPhylo'></span>

<h3>Description</h3>

<p><code>SortTree()</code> sorts each node into a consistent order, so that node rotation
does not obscure similarities between similar trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SortTree(tree, how = "cladesize", order = TipLabels(tree))

## S3 method for class 'phylo'
SortTree(tree, how = "cladesize", order = TipLabels(tree))

## S3 method for class 'list'
SortTree(tree, how = "cladesize", order = TipLabels(tree[[1]]))

## S3 method for class 'multiPhylo'
SortTree(tree, how = "cladesize", order = TipLabels(tree[[1]]))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SortTree_+3A_tree">tree</code></td>
<td>
<p>One or more trees of class <code>phylo</code>, optionally as a list
or a <code>multiPhylo</code> object.</p>
</td></tr>
<tr><td><code id="SortTree_+3A_how">how</code></td>
<td>
<p>Character vector specifying sort method:
<code>"Cladesize"</code> rotates each node such that the larger clade is first,
thus appearing lower when plotted;
<code>"TipLabels"</code> rotates nodes such that labels listed sooner in <code>order</code>
are listed first, and thus plot lower.</p>
</td></tr>
<tr><td><code id="SortTree_+3A_order">order</code></td>
<td>
<p>Character vector listing tip labels in sequence they should
appear on tree. Clades containing a taxon earlier in this list will be listed
sooner and thus plot lower on a tree.  Taxa not listed in <code>order</code> will be
treated as if they were last in the list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each node, clades will be listed in <code>tree[["edge"]]</code> in decreasing size
order.
</p>
<p>Clades that contain the same number of leaves are sorted in decreasing order
of minimum leaf number, so (2, 3) will occur before (1, 4).
</p>
<p>As trees are plotted from &quot;bottom up&quot;, the largest clades will &quot;sink&quot; to the
bottom of a plotted tree.
</p>


<h3>Value</h3>

<p><code>SortTree()</code> returns tree in the format of <code>tree</code>, with each node
in each tree sorted
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code>Preorder()</code> also rearranges trees into a consistent shape,
based on the index of leaves.
</p>
<p><code><a href="#topic+sort.multiPhylo">sort.multiPhylo()</a></code> sorts a list of trees stored as a <code>multiPhylo</code>
object.
</p>
<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>messyTree &lt;- as.phylo(10, 6)
plot(messyTree)

sorted &lt;- SortTree(messyTree)
plot(sorted)
ape::nodelabels()
ape::edgelabels()
ape::tiplabels(adj = c(2, 1/3))

plot(SortTree(messyTree, how = "tip"))
</code></pre>

<hr>
<h2 id='SpectrumLegend'>Produce a legend for continuous gradient scales</h2><span id='topic+SpectrumLegend'></span>

<h3>Description</h3>

<p>Prints an annotated vertical bar coloured according to a continuous palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpectrumLegend(
  x0 = 0.05,
  y0 = 0.05,
  x1 = x0,
  y1 = y0 + 0.2,
  absolute = FALSE,
  legend = character(0),
  palette,
  lwd = 4,
  lty = 1,
  lend = "square",
  cex = 1,
  text.col = par("col"),
  font = NULL,
  text.font = font,
  title = NULL,
  title.col = text.col[1],
  title.cex = cex[1],
  title.adj = 0.5,
  title.font = 2,
  pos = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpectrumLegend_+3A_x0">x0</code>, <code id="SpectrumLegend_+3A_y0">y0</code>, <code id="SpectrumLegend_+3A_x1">x1</code>, <code id="SpectrumLegend_+3A_y1">y1</code></td>
<td>
<p>Coordinates of the bottom-left and top-right end of the
bar.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_absolute">absolute</code></td>
<td>
<p>Logical specifying whether <code>x</code> and <code>y</code> values denote
coordinates (<code>TRUE</code>) or relative position, where (0, 0) denotes the
bottom-left of the plot area and (1, 1) the top right.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_legend">legend</code></td>
<td>
<p>Character vector with which to label points on <code>palette</code>.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_palette">palette</code></td>
<td>
<p>Colour palette to depict.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_lwd">lwd</code>, <code id="SpectrumLegend_+3A_lty">lty</code>, <code id="SpectrumLegend_+3A_lend">lend</code></td>
<td>
<p>Additional parameters to <code><a href="graphics.html#topic+segments">segments()</a></code>,
controlling line style.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_cex">cex</code></td>
<td>
<p>Character expansion factor relative to current <code>par("cex")</code>.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_text.col">text.col</code></td>
<td>
<p>Colour used for the legend text.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_font">font</code>, <code id="SpectrumLegend_+3A_text.font">text.font</code></td>
<td>
<p>Font used for the legend text; see <code><a href="graphics.html#topic+text">text()</a></code>.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_title">title</code></td>
<td>
<p>Text to display</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_title.col">title.col</code></td>
<td>
<p>Colour for title; defaults to <code>text.col[1]</code>.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_title.cex">title.cex</code></td>
<td>
<p>Expansion factor(s) for the title, defaults to <code>cex[1]</code>.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_title.adj">title.adj</code></td>
<td>
<p>Horizontal adjustment for title: see the help for
<code>par("adj")</code>.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_title.font">title.font</code></td>
<td>
<p>Font used for the legend title.</p>
</td></tr>
<tr><td><code id="SpectrumLegend_+3A_pos">pos</code>, <code id="SpectrumLegend_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code><a href="graphics.html#topic+text">text()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is now deprecated; it has been superseded by the more capable
<code><a href="PlotTools.html#topic+SpectrumLegend">PlotTools::SpectrumLegend()</a></code> and will be removed in a future release.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='SplitFrequency'>Frequency of splits</h2><span id='topic+SplitFrequency'></span><span id='topic+SplitNumber'></span><span id='topic+ForestSplits'></span><span id='topic+TreeSplits'></span>

<h3>Description</h3>

<p><code>SplitFrequency()</code> provides a simple way to count the number of times that
bipartition splits, as defined by a reference tree, occur in a forest of
trees. May be used to calculate edge (&quot;node&quot;) support for majority consensus
or bootstrap trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitFrequency(reference, forest)

SplitNumber(tips, tree, tipIndex, powersOf2)

ForestSplits(forest, powersOf2)

TreeSplits(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitFrequency_+3A_reference">reference</code></td>
<td>
<p>A tree of class <code>phylo</code>, a <code>Splits</code> object.</p>
</td></tr>
<tr><td><code id="SplitFrequency_+3A_forest">forest</code></td>
<td>
<p>a list of trees of class <code>phylo</code>, or a <code>multiPhylo</code> object; or a
<code>Splits</code> object. See
<a href="https://ms609.github.io/TreeTools/articles/load-trees.html">vignette</a> for
possible methods of loading trees into R.</p>
</td></tr>
<tr><td><code id="SplitFrequency_+3A_tips">tips</code></td>
<td>
<p>Integer vector specifying the tips of the tree within the chosen
split.</p>
</td></tr>
<tr><td><code id="SplitFrequency_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="SplitFrequency_+3A_tipindex">tipIndex</code></td>
<td>
<p>Character vector of tip names, in a fixed order.</p>
</td></tr>
<tr><td><code id="SplitFrequency_+3A_powersof2">powersOf2</code></td>
<td>
<p>Integer vector of same length as <code>tipIndex</code>, specifying a
power of 2 to be associated with each tip in turn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If multiple calculations are required, some time can be saved by using the
constituent functions (see examples)
</p>


<h3>Value</h3>

<p><code>SplitFrequency()</code> returns the number of trees in <code>forest</code> that
contain each split in <code>reference</code>.
If <code>reference</code> is a tree of class <code>phylo</code>, then the sequence will correspond
to the order of nodes (use <code>ape::nodelabels()</code> to view).
Note that the three nodes at the root of the tree correspond to a single
split; see the example for how these might be plotted on a tree.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>SplitNumber()</code>: Assign a unique integer to each split
</p>
</li>
<li> <p><code>ForestSplits()</code>: Frequency of splits in a given forest of trees
</p>
</li>
<li> <p><code>TreeSplits()</code>: Deprecated. Listed the splits in a given tree.
Use as.Splits instead.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An example forest of 100 trees, some identical
forest &lt;- as.phylo(c(1, rep(10, 79), rep(100, 15), rep(1000, 5)), nTip = 9)

# Generate an 80% consensus tree
cons &lt;- ape::consensus(forest, p = 0.8)
plot(cons)

# Calculate split frequencies
splitFreqs &lt;- SplitFrequency(cons, forest)

# Optionally, colour edges by corresponding frequency.
# Note that not all edges are associated with a unique split
# (and two root edges may be associated with one split - not handled here)
edgeSupport &lt;- rep(1, nrow(cons$edge)) # Initialize trivial splits to 1
childNode &lt;- cons$edge[, 2]
edgeSupport[match(names(splitFreqs), childNode)] &lt;- splitFreqs / 100

plot(cons, edge.col = SupportColour(edgeSupport), edge.width = 3)

# Annotate nodes by frequency 
LabelSplits(cons, splitFreqs, unit = "%",
            col = SupportColor(splitFreqs / 100),
            frame = "none", pos = 3L)

</code></pre>

<hr>
<h2 id='SplitInformation'>Phylogenetic information content of splitting leaves into two partitions</h2><span id='topic+SplitInformation'></span><span id='topic+MultiSplitInformation'></span>

<h3>Description</h3>

<p>Calculate the phylogenetic information content (<em>sensu</em>
Steel and Penny 2006) of a split, which
reflects the probability that a uniformly selected random tree will contain#
the split: a split that is consistent with a smaller number of trees will
have a higher information content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitInformation(A, B = A[1])

MultiSplitInformation(partitionSizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitInformation_+3A_a">A</code>, <code id="SplitInformation_+3A_b">B</code></td>
<td>
<p>Integer specifying the number of taxa in each partition.</p>
</td></tr>
<tr><td><code id="SplitInformation_+3A_partitionsizes">partitionSizes</code></td>
<td>
<p>Integer vector specifying the number of taxa in each
partition of a multi-partition split.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SplitInformation()</code> addresses bipartition splits, which correspond to
edges in an unrooted phylogeny; <code>MultiSplitInformation()</code> supports splits
that subdivide taxa into multiple partitions, which may correspond to
multi-state characters in a phylogenetic matrix.
</p>
<p>A simple way to characterise trees is to count the number of edges.
(Edges are almost, but not quite, equivalent to nodes.)
Counting edges (or nodes) provides a quick measure of a tree's resolution,
and underpins the Robinson-Foulds tree distance measure.
Not all edges, however, are created equal.
</p>
<p>An edge splits the leaves of a tree into two subdivisions.  The more equal
these subdivisions are in size, the more instructive this edge is.
Intuitively, the division of mammals from reptiles is a profound revelation
that underpins much of zoology; recognizing that two species of bat are more
closely related to each other than to any other mammal or reptile is still
instructive, but somewhat less fundamental.
</p>
<p>Formally, the phylogenetic (Shannon) information content of a split <em>S</em>,
<em>h(S)</em>, corresponds to the probability that a uniformly selected random tree
will contain the split, <em>P(S)</em>: <em>h(S)</em> = -log <em>P(S)</em>.
Base 2 logarithms are typically employed to yield an information content in
bits.
</p>
<p>As an example, the split <code>AB|CDEF</code> occurs in 15 of the 105 six-leaf trees;
<em>h</em>(<code>AB|CDEF</code>) = -log <em>P</em>(<code>AB|CDEF</code>) = -log(15/105) ~ 2.81 bits.  The split
<code>ABC|DEF</code> subdivides the leaves more evenly, and is thus more instructive:
it occurs in just nine of the 105 six-leaf trees, and
<em>h</em>(<code>ABC|DEF</code>) = -log(9/105) ~ 3.54 bits.
</p>
<p>As the number of leaves increases, a single even split may contain more
information than multiple uneven splits &ndash; see the examples section below.
</p>
<p>Summing the information content of all splits within a tree, perhaps using
the '<a href="https://ms609.github.io/TreeDist/">TreeDist</a>' function
<a href="https://ms609.github.io/TreeDist/reference/TreeInfo.html"><code>SplitwiseInfo()</code></a>,
arguably gives a more instructive picture of its resolution than simply
counting the number of splits that are present &ndash; though with the caveat
that splits within a tree are not independent of one another, so some
information may be double counted.  (This same charge applies to simply
counting nodes, too.)
</p>
<p>Alternatives would be to count the number of quartets that are resolved,
perhaps using the '<a href="https://ms609.github.io/Quartet/">Quartet</a>' function
<a href="https://ms609.github.io/Quartet/reference/QuartetState.html"><code>QuartetStates()</code></a>,
or to use a different take on the information contained within a split, the
clustering information: see the 'TreeDist' function
<a href="https://ms609.github.io/TreeDist/reference/TreeInfo.html"><code>ClusteringInfo()</code></a>
for details.
</p>


<h3>Value</h3>

<p><code>SplitInformation()</code> and <code>MultiSplitInformation()</code> return the
phylogenetic information content, in bits, of a split that subdivides leaves
into partitions of the specified sizes.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Steel MA, Penny D (2006).
&ldquo;Maximum parsimony and the phylogenetic information in multistate characters.&rdquo;
In Albert VA (ed.), <em>Parsimony, Phylogeny, and Genomics</em>, 163&ndash;178.
Oxford University Press, Oxford.
</p>


<h3>See Also</h3>

<p>Sum the phylogenetic information content of splits within a tree:
<a href="https://ms609.github.io/TreeDist/reference/TreeInfo.html"><code>TreeDist::SplitwiseInfo()</code></a>
</p>
<p>Sum the clustering information content of splits within a tree:
<a href="https://ms609.github.io/TreeDist/reference/TreeInfo.html"><code>TreeDist::ClusteringInfo()</code></a>
</p>
<p>Other split information functions: 
<code><a href="#topic+CharacterInformation">CharacterInformation</a>()</code>,
<code><a href="#topic+SplitMatchProbability">SplitMatchProbability</a>()</code>,
<code><a href="#topic+TreesMatchingSplit">TreesMatchingSplit</a>()</code>,
<code><a href="#topic+UnrootedTreesMatchingSplit">UnrootedTreesMatchingSplit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Eight leaves can be split evenly:
SplitInformation(4, 4)

# or unevenly, which is less informative:
SplitInformation(2, 6)

# A single split that evenly subdivides 50 leaves contains more information
# that seven maximally uneven splits on the same leaves:
SplitInformation(25, 25)
7 * SplitInformation(2, 48)
# Three ways to split eight leaves into multiple partitions:
MultiSplitInformation(c(2, 2, 4))
MultiSplitInformation(c(2, 3, 3))
MultiSplitInformation(rep(2, 4))


</code></pre>

<hr>
<h2 id='SplitMatchProbability'>Probability of matching this well</h2><span id='topic+SplitMatchProbability'></span><span id='topic+LnSplitMatchProbability'></span>

<h3>Description</h3>

<p>(<code>Ln</code>)<code>SplitMatchProbability()</code>calculates the probability that two random
splits of the sizes provided will be at least as similar as the two
specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitMatchProbability(split1, split2)

LnSplitMatchProbability(split1, split2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitMatchProbability_+3A_split1">split1</code>, <code id="SplitMatchProbability_+3A_split2">split2</code></td>
<td>
<p>Logical vectors listing terminals in same order, such that
each terminal is identified as a member of the ingroup (<code>TRUE</code>) or outgroup
(<code>FALSE</code>) of the respective bipartition split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SplitMatchProbability()</code> returns a numeric giving the proportion
of permissible non-trivial splits that divide the terminals into bipartitions
of the sizes given, that match as well as <code>split1</code> and <code>split2</code> do.
</p>
<p><code>LnSplitMatchProbability()</code> returns the natural logarithm of the
probability.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other split information functions: 
<code><a href="#topic+CharacterInformation">CharacterInformation</a>()</code>,
<code><a href="#topic+SplitInformation">SplitInformation</a>()</code>,
<code><a href="#topic+TreesMatchingSplit">TreesMatchingSplit</a>()</code>,
<code><a href="#topic+UnrootedTreesMatchingSplit">UnrootedTreesMatchingSplit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>split1 &lt;- as.Splits(c(rep(TRUE, 4), rep(FALSE, 4)))
split2 &lt;- as.Splits(c(rep(TRUE, 3), rep(FALSE, 5)))
SplitMatchProbability(split1, split2)
LnSplitMatchProbability(split1, split2)
</code></pre>

<hr>
<h2 id='Splits'>Convert object to <code>Splits</code></h2><span id='topic+Splits'></span><span id='topic+as.Splits'></span><span id='topic+as.Splits.phylo'></span><span id='topic+as.Splits.multiPhylo'></span><span id='topic+as.Splits.Splits'></span><span id='topic+as.Splits.list'></span><span id='topic+as.Splits.matrix'></span><span id='topic+as.Splits.logical'></span><span id='topic+as.Splits.character'></span><span id='topic+as.logical.Splits'></span>

<h3>Description</h3>

<p><code>as.Splits()</code> converts a phylogenetic tree to a <code>Splits</code> object representing
its constituent bipartition splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Splits(x, tipLabels = NULL, ...)

## S3 method for class 'phylo'
as.Splits(x, tipLabels = NULL, asSplits = TRUE, ...)

## S3 method for class 'multiPhylo'
as.Splits(x, tipLabels = unique(unlist(TipLabels(x))), asSplits = TRUE, ...)

## S3 method for class 'Splits'
as.Splits(x, tipLabels = NULL, ...)

## S3 method for class 'list'
as.Splits(x, tipLabels = NULL, asSplits = TRUE, ...)

## S3 method for class 'matrix'
as.Splits(x, tipLabels = NULL, ...)

## S3 method for class 'logical'
as.Splits(x, tipLabels = NULL, ...)

## S3 method for class 'character'
as.Splits(x, tipLabels = NULL, ...)

## S3 method for class 'Splits'
as.logical(x, tipLabels = attr(x, "tip.label"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Splits_+3A_x">x</code></td>
<td>
<p>Object to convert into splits: perhaps a tree of class
<code><a href="ape.html#topic+read.tree">phylo</a></code>.
If a logical matrix is provided, each row will be considered as a
separate split.</p>
</td></tr>
<tr><td><code id="Splits_+3A_tiplabels">tipLabels</code></td>
<td>
<p>Character vector specifying sequence in which to order
tip labels.  Label order must (currently) match to combine or compare separate
<code>Splits</code> objects.</p>
</td></tr>
<tr><td><code id="Splits_+3A_...">...</code></td>
<td>
<p>Presently unused.</p>
</td></tr>
<tr><td><code id="Splits_+3A_assplits">asSplits</code></td>
<td>
<p>Logical specifying whether to return a <code>Splits</code> object,
or an unannotated two-dimensional array (useful where performance is
paramount).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.Splits()</code> returns an object of class <code>Splits</code>, or
(if <code>asSplits = FALSE</code>) a two-dimensional array of <code>raw</code> objects, with
each bit specifying whether or not the leaf corresponding to the respective
bit position is a member of the split.
Splits are named according to the node at the non-root end of the edge that
defines them. In rooted trees, the child of the rightmost root edge names
the split.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splits &lt;- as.Splits(BalancedTree(letters[1:6]))
summary(splits)
TipsInSplits(splits)
summary(!splits)
TipsInSplits(!splits)

length(splits + !splits)
length(unique(splits + !splits))

summary(c(splits[[2:3]], !splits[[1:2]]))

moreSplits &lt;- as.Splits(PectinateTree(letters[6:1]), tipLabel = splits)
print(moreSplits, details = TRUE)
match(splits, moreSplits)
moreSplits %in% splits

as.Splits("....**", letters[1:6])

</code></pre>

<hr>
<h2 id='SplitsInBinaryTree'>Maximum splits in an <em>n</em>-leaf tree</h2><span id='topic+SplitsInBinaryTree'></span><span id='topic+SplitsInBinaryTree.list'></span><span id='topic+SplitsInBinaryTree.multiPhylo'></span><span id='topic+SplitsInBinaryTree.numeric'></span><span id='topic+SplitsInBinaryTree.NULL'></span><span id='topic+SplitsInBinaryTree.default'></span><span id='topic+SplitsInBinaryTree.Splits'></span><span id='topic+SplitsInBinaryTree.phylo'></span>

<h3>Description</h3>

<p><code>SplitsInBinaryTree()</code> is a convenience function to calculate the number of
splits in a fully-resolved (binary) tree with <em>n</em> leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitsInBinaryTree(tree)

## S3 method for class 'list'
SplitsInBinaryTree(tree)

## S3 method for class 'multiPhylo'
SplitsInBinaryTree(tree)

## S3 method for class 'numeric'
SplitsInBinaryTree(tree)

## S3 method for class ''NULL''
SplitsInBinaryTree(tree)

## Default S3 method:
SplitsInBinaryTree(tree)

## S3 method for class 'Splits'
SplitsInBinaryTree(tree)

## S3 method for class 'phylo'
SplitsInBinaryTree(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitsInBinaryTree_+3A_tree">tree</code></td>
<td>
<p>An object of a supported format that represents a tree or
set of trees, from which the number of leaves will be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SplitsInBinaryTree()</code> returns an integer vector detailing the number
of unique non-trivial splits in a binary tree with <em>n</em> leaves.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree properties: 
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PathLengths">PathLengths</a>()</code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TreeIsRooted">TreeIsRooted</a>()</code>
</p>
<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- BalancedTree(8)
SplitsInBinaryTree(tree)
SplitsInBinaryTree(as.Splits(tree))
SplitsInBinaryTree(8)
SplitsInBinaryTree(list(tree, tree))
</code></pre>

<hr>
<h2 id='Stemwardness'>&quot;Stemwardness&quot; of a leaf</h2><span id='topic+Stemwardness'></span><span id='topic+SisterSize'></span><span id='topic+SisterSize.numeric'></span><span id='topic+SisterSize.character'></span><span id='topic+RootNodeDistance'></span><span id='topic+RootNodeDistance.numeric'></span><span id='topic+RootNodeDistance.character'></span><span id='topic+RootNodeDist'></span>

<h3>Description</h3>

<p>Functions to describe the position of a leaf relative to the root.
&quot;Stemmier&quot; leaves ought to exhibit a smaller root-node distance and a
larger sister size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SisterSize(tree, tip)

## S3 method for class 'numeric'
SisterSize(tree, tip)

## S3 method for class 'character'
SisterSize(tree, tip)

RootNodeDistance(tree, tip)

## S3 method for class 'numeric'
RootNodeDistance(tree, tip)

## S3 method for class 'character'
RootNodeDistance(tree, tip)

RootNodeDist(tree, tip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Stemwardness_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="Stemwardness_+3A_tip">tip</code></td>
<td>
<p>Either a numeric specifying the index of a single tip, or a
character specifying its label.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RootNodeDistance()</code> calculates the number of nodes between the chosen leaf
and the root of <code>tree</code>.
This is an unsatisfactory measure, as the range of possible
distances is a function of the shape of the tree
(Asher and Smith 2022).
As an example, leaf <em>X1</em> in the tree <code style="white-space: pre;">&#8288;(.,(.,(.,(.,(X1,(a,b))))))&#8288;</code>
falls outside the clade <em>(a, b)</em> and has a root-node distance of 4,
whereas leaf <em>X2</em> in the tree <code style="white-space: pre;">&#8288;(.,((.,(.,.)),(b,(X2,a))))&#8288;</code>
falls within the clade <em>(a, b)</em>, so should be considered more &quot;crownwards&quot;,
yet has a smaller root-node distance (3).
</p>
<p><img src="../help/figures/Stemwardness.png" alt="Stemwardness.png" />
</p>
<p><code>SisterSize()</code> measures the number of leaves in the clade that is sister to
the chosen leaf, as proposed by Asher and Smith (2022).
In the examples above, <em>X1</em> has a sister size of 2 leaves, whereas <em>X2</em>,
which is &quot;more crownwards&quot;, has a smaller sister size (1 leaf), as desired.
</p>


<h3>Value</h3>

<p><code>SisterSize()</code> returns an integer specifying the number of leaves
in the clade that is sister to <code>tip</code>.
<code>RootNodeDist()</code> returns an integer specifying the number of nodes between
<code>tip</code> and the root node of <code>tree</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Asher R, Smith MR (2022).
&ldquo;Phylogenetic signal and bias in paleontology.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(4), 986&ndash;1008.
<a href="https://doi.org/10.1093/sysbio/syab072">doi:10.1093/sysbio/syab072</a>.
</p>


<h3>See Also</h3>

<p>Other tree characterization functions: 
<code><a href="#topic+CladisticInfo">CladisticInfo</a>()</code>,
<code><a href="#topic+Consensus">Consensus</a>()</code>,
<code><a href="#topic+TotalCopheneticIndex">TotalCopheneticIndex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bal8 &lt;- BalancedTree(8)
pec8 &lt;- PectinateTree(8)

SisterSize(bal8, 3)
SisterSize(pec8, "t3")
SisterSize(RootTree(pec8, "t3"), "t3")

RootNodeDist(bal8, 3)
RootNodeDist(pec8, "t3")
RootNodeDist(RootTree(pec8, "t3"), "t3")
</code></pre>

<hr>
<h2 id='StringToPhyDat'>Convert between strings and <code>phyDat</code> objects</h2><span id='topic+StringToPhyDat'></span><span id='topic+StringToPhydat'></span><span id='topic+PhyToString'></span><span id='topic+PhyDatToString'></span><span id='topic+PhydatToString'></span>

<h3>Description</h3>

<p><code>PhyDatToString()</code> converts a <code>phyDat</code> object as a string;
<code>StringToPhyDat()</code> converts a string of character data to a <code>phyDat</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StringToPhyDat(string, tips, byTaxon = TRUE)

StringToPhydat(string, tips, byTaxon = TRUE)

PhyToString(
  phy,
  parentheses = "{",
  collapse = "",
  ps = "",
  useIndex = TRUE,
  byTaxon = TRUE,
  concatenate = TRUE
)

PhyDatToString(
  phy,
  parentheses = "{",
  collapse = "",
  ps = "",
  useIndex = TRUE,
  byTaxon = TRUE,
  concatenate = TRUE
)

PhydatToString(
  phy,
  parentheses = "{",
  collapse = "",
  ps = "",
  useIndex = TRUE,
  byTaxon = TRUE,
  concatenate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StringToPhyDat_+3A_string">string</code></td>
<td>
<p>String of tokens, optionally containing whitespace, with no
terminating semi-colon.</p>
</td></tr>
<tr><td><code id="StringToPhyDat_+3A_tips">tips</code></td>
<td>
<p>(Optional) Character vector corresponding to the names (in order)
of each taxon in the matrix, or an object such as a tree from which
tip labels can be extracted.</p>
</td></tr>
<tr><td><code id="StringToPhyDat_+3A_bytaxon">byTaxon</code></td>
<td>
<p>Logical. If <code>TRUE</code>, write one taxon followed by the next.
If <code>FALSE</code>, write one character followed by the next.</p>
</td></tr>
<tr><td><code id="StringToPhyDat_+3A_phy">phy</code></td>
<td>
<p>An object of class <code>phyDat</code>.</p>
</td></tr>
<tr><td><code id="StringToPhyDat_+3A_parentheses">parentheses</code></td>
<td>
<p>Character specifying format of parentheses with which to
surround ambiguous tokens.  Choose from: <code>{</code> (default), <code>[</code>, <code>(</code>, <code>&lt;</code>.</p>
</td></tr>
<tr><td><code id="StringToPhyDat_+3A_collapse">collapse</code></td>
<td>
<p>Character specifying text, perhaps <code style="white-space: pre;">&#8288;,&#8288;</code>, with which to
separate multiple tokens within parentheses.</p>
</td></tr>
<tr><td><code id="StringToPhyDat_+3A_ps">ps</code></td>
<td>
<p>Character specifying text, perhaps <code style="white-space: pre;">&#8288;;&#8288;</code>, to append to the end of
the string.</p>
</td></tr>
<tr><td><code id="StringToPhyDat_+3A_useindex">useIndex</code></td>
<td>
<p>Logical (default: <code>TRUE</code>) specifying whether to print
duplicate characters multiple times, as they appeared in the original matrix.</p>
</td></tr>
<tr><td><code id="StringToPhyDat_+3A_concatenate">concatenate</code></td>
<td>
<p>Logical specifying whether to concatenate all
characters/taxa into a single string, or to return a separate string for
each entry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>StringToPhyDat()</code> returns an object of class <code>phyDat</code>.
</p>
<p><code>PhyToString()</code> returns a character vector listing a text
representation of the phylogenetic character state for each taxon in turn.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other phylogenetic matrix conversion functions: 
<code><a href="#topic+MatrixToPhyDat">MatrixToPhyDat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>StringToPhyDat("-?01231230?-", c("Lion", "Gazelle"), byTaxon = TRUE)
# encodes the following matrix:
# Lion     -?0123
# Gazelle  1230?-

fileName &lt;- paste0(system.file(package = "TreeTools"),
                   "/extdata/input/dataset.nex")
phyDat &lt;- ReadAsPhyDat(fileName)
PhyToString(phyDat, concatenate = FALSE)

</code></pre>

<hr>
<h2 id='Subsplit'>Subset of a split on fewer leaves</h2><span id='topic+Subsplit'></span>

<h3>Description</h3>

<p><code>Subsplit()</code> removes leaves from a <code>Splits</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Subsplit(splits, tips, keepAll = FALSE, unique = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Subsplit_+3A_splits">splits</code></td>
<td>
<p>An object of class <code><a href="#topic+as.Splits">Splits</a></code>.</p>
</td></tr>
<tr><td><code id="Subsplit_+3A_tips">tips</code></td>
<td>
<p>A vector specifying a subset of the leaf labels applied to <code>split</code>.</p>
</td></tr>
<tr><td><code id="Subsplit_+3A_keepall">keepAll</code></td>
<td>
<p>logical specifying whether to keep entries that define trivial
splits (i.e. splits of zero or one leaf) on the subset of leaves.</p>
</td></tr>
<tr><td><code id="Subsplit_+3A_unique">unique</code></td>
<td>
<p>logical specifying whether to remove duplicate splits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Subsplit()</code> returns an object of class <code>Splits</code>, defined on the
leaves <code>tips</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KeepTip">KeepTip()</a></code> is a less flexible but faster equivalent.
</p>
<p>Other split manipulation functions: 
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+TrivialSplits">TrivialSplits</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splits &lt;- as.Splits(PectinateTree(letters[1:9]))
splits
efgh &lt;- Subsplit(splits, tips = letters[5:8], keepAll = TRUE)
summary(efgh)

TrivialSplits(efgh)

summary(Subsplit(splits, tips = letters[5:8], keepAll = FALSE))
</code></pre>

<hr>
<h2 id='Subtree'>Extract a subtree</h2><span id='topic+Subtree'></span>

<h3>Description</h3>

<p><code>Subtree()</code> safely extracts a clade from a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Subtree(tree, node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Subtree_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, with internal numbering
in cladewise order (use <code><a href="#topic+Preorder">Preorder</a>(tree)</code> or (slower)
<code><a href="#topic+Cladewise">Cladewise</a>(tree)</code>) .</p>
</td></tr>
<tr><td><code id="Subtree_+3A_node">node</code></td>
<td>
<p>The number of the node at the base of the clade to be extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modified from the <span class="pkg">ape</span> function <code><a href="ape.html#topic+extract.clade">extract.clade</a></code>, which
sometimes behaves erratically.
Unlike extract.clade, this function supports the extraction of &quot;clades&quot;
that constitute a single tip.
</p>


<h3>Value</h3>

<p><code>Subtree()</code> returns a tree of class <code>phylo</code> that represents a
clade extracted from the original tree.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- Preorder(BalancedTree(8))
plot(tree)
ape::nodelabels()
ape::nodelabels(13, 13, bg="yellow")

plot(Subtree(tree, 13))

</code></pre>

<hr>
<h2 id='SupportColour'>Colour for node support value</h2><span id='topic+SupportColour'></span><span id='topic+SupportColor'></span>

<h3>Description</h3>

<p>Colour value with which to display node support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SupportColour(
  support,
  show1 = TRUE,
  scale = rev(diverge_hcl(101, h = c(260, 0), c = 100, l = c(50, 90), power = 1)),
  outOfRange = "red"
)

SupportColor(
  support,
  show1 = TRUE,
  scale = rev(diverge_hcl(101, h = c(260, 0), c = 100, l = c(50, 90), power = 1)),
  outOfRange = "red"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SupportColour_+3A_support">support</code></td>
<td>
<p>A numeric vector of values in the range 0&ndash;1.</p>
</td></tr>
<tr><td><code id="SupportColour_+3A_show1">show1</code></td>
<td>
<p>Logical specifying whether to display values of 1.
A transparent white will be returned if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="SupportColour_+3A_scale">scale</code></td>
<td>
<p>101-element vector listing colours in sequence. Defaults to
a diverging <abbr><span class="acronym">HCL</span></abbr> scale.</p>
</td></tr>
<tr><td><code id="SupportColour_+3A_outofrange">outOfRange</code></td>
<td>
<p>Colour to use if results are outside the range 0&ndash;1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SupportColour()</code> returns the appropriate value from <code>scale</code>,
or <code>outOfRange</code> if a value is outwith the valid range.
</p>


<h3>See Also</h3>

<p>Use in conjunction with <code><a href="#topic+LabelSplits">LabelSplits()</a></code> to colour split labels,
possibly calculated using <code><a href="#topic+SplitFrequency">SplitFrequency()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SupportColour((-1):4 / 4, show1 = FALSE)

# An example forest of 100 trees, some identical
forest &lt;- as.phylo(c(1, rep(10, 79), rep(100, 15), rep(1000, 5)), nTip = 9)

# Generate an 80% consensus tree
cons &lt;- ape::consensus(forest, p = 0.8)
plot(cons)

# Calculate split frequencies
splitFreqs &lt;- SplitFrequency(cons, forest)

# Optionally, colour edges by corresponding frequency.
# Note that not all edges are associated with a unique split
# (and two root edges may be associated with one split - not handled here)
edgeSupport &lt;- rep(1, nrow(cons$edge)) # Initialize trivial splits to 1
childNode &lt;- cons$edge[, 2]
edgeSupport[match(names(splitFreqs), childNode)] &lt;- splitFreqs / 100

plot(cons, edge.col = SupportColour(edgeSupport), edge.width = 3)

# Annotate nodes by frequency 
LabelSplits(cons, splitFreqs, unit = "%",
            col = SupportColor(splitFreqs / 100),
            frame = "none", pos = 3L)

</code></pre>

<hr>
<h2 id='TipLabels'>Extract tip labels</h2><span id='topic+TipLabels'></span><span id='topic+TipLabels.matrix'></span><span id='topic+TipLabels.phylo'></span><span id='topic+TipLabels.default'></span><span id='topic+TipLabels.phyDat'></span><span id='topic+TipLabels.MixedBase'></span><span id='topic+TipLabels.TreeNumber'></span><span id='topic+TipLabels.Splits'></span><span id='topic+TipLabels.list'></span><span id='topic+AllTipLabels'></span><span id='topic+AllTipLabels.list'></span><span id='topic+AllTipLabels.multiPhylo'></span><span id='topic+AllTipLabels.phylo'></span><span id='topic+AllTipLabels.Splits'></span><span id='topic+AllTipLabels.TreeNumber'></span><span id='topic+AllTipLabels.matrix'></span><span id='topic+TipLabels.multiPhylo'></span><span id='topic+TipLabels.character'></span><span id='topic+TipLabels.numeric'></span>

<h3>Description</h3>

<p><code>TipLabels()</code> extracts labels from an object: for example, names of taxa in
a phylogenetic tree or data matrix.  <code>AllTipLabels()</code> extracts all labels,
where entries of a list of trees may pertain to different taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TipLabels(x, single = TRUE)

## S3 method for class 'matrix'
TipLabels(x, single = TRUE)

## S3 method for class 'phylo'
TipLabels(x, single = TRUE)

## Default S3 method:
TipLabels(x, single = TRUE)

## S3 method for class 'phyDat'
TipLabels(x, single = TRUE)

## S3 method for class 'MixedBase'
TipLabels(x, single = TRUE)

## S3 method for class 'TreeNumber'
TipLabels(x, single = TRUE)

## S3 method for class 'Splits'
TipLabels(x, single = TRUE)

## S3 method for class 'list'
TipLabels(x, single = FALSE)

AllTipLabels(x)

## S3 method for class 'list'
AllTipLabels(x)

## S3 method for class 'multiPhylo'
AllTipLabels(x)

## S3 method for class 'phylo'
AllTipLabels(x)

## S3 method for class 'Splits'
AllTipLabels(x)

## S3 method for class 'TreeNumber'
AllTipLabels(x)

## S3 method for class 'matrix'
AllTipLabels(x)

## S3 method for class 'multiPhylo'
TipLabels(x, single = FALSE)

## S3 method for class 'character'
TipLabels(x, single = TRUE)

## S3 method for class 'numeric'
TipLabels(x, single = TRUE)

## S3 method for class 'phyDat'
TipLabels(x, single = TRUE)

## Default S3 method:
TipLabels(x, single = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TipLabels_+3A_x">x</code></td>
<td>
<p>An object of a supported class (see Usage section above).</p>
</td></tr>
<tr><td><code id="TipLabels_+3A_single">single</code></td>
<td>
<p>Logical specifying whether to report the labels for the first
object only (<code>TRUE</code>), or for each object in a list (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TipLabels()</code> returns a character vector listing the tip labels
appropriate to <code>x</code>. If <code>x</code> is a single integer, this will be a vector
<code>t1</code>, <code>t2</code> ... <code>tx</code>, to match the default of <code>ape::<a href="ape.html#topic+rtree">rtree</a>()</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree properties: 
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PathLengths">PathLengths</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+TreeIsRooted">TreeIsRooted</a>()</code>
</p>
<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TipLabels(BalancedTree(letters[5:1]))
TipLabels(5)

data("Lobo")
head(TipLabels(Lobo.phy))

AllTipLabels(c(BalancedTree(4), PectinateTree(8)))

</code></pre>

<hr>
<h2 id='TipsInSplits'>Tips contained within splits</h2><span id='topic+TipsInSplits'></span><span id='topic+TipsInSplits.Splits'></span><span id='topic+TipsInSplits.phylo'></span><span id='topic+SplitImbalance'></span><span id='topic+SplitImbalance.Splits'></span><span id='topic+SplitImbalance.phylo'></span>

<h3>Description</h3>

<p><code>TipsInSplits()</code> specifies the number of tips that occur within each
bipartition split in a <code>Splits</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TipsInSplits(splits, keep.names = TRUE, smallest = FALSE, ...)

## S3 method for class 'Splits'
TipsInSplits(splits, keep.names = TRUE, smallest = FALSE, ...)

## S3 method for class 'phylo'
TipsInSplits(splits, keep.names = TRUE, smallest = FALSE, ...)

SplitImbalance(splits, keep.names = TRUE, ...)

## S3 method for class 'Splits'
SplitImbalance(splits, keep.names = TRUE, ...)

## S3 method for class 'phylo'
SplitImbalance(splits, keep.names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TipsInSplits_+3A_splits">splits</code></td>
<td>
<p>Object of class <code>Splits</code> or <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="TipsInSplits_+3A_keep.names">keep.names</code></td>
<td>
<p>Logical specifying whether to include the names of <code>splits</code>
in the output.</p>
</td></tr>
<tr><td><code id="TipsInSplits_+3A_smallest">smallest</code></td>
<td>
<p>Logical; if <code>TRUE</code>, return the number of leaves in the
smaller bipartition.</p>
</td></tr>
<tr><td><code id="TipsInSplits_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>as.Splits()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TipsInSplits()</code> returns a named vector of integers, specifying the
number of tips contained within each split in <code>splits</code>.
</p>
<p><code>SplitImbalance()</code> returns a named vector of integers, specifying the
number of leaves within a split that are not &quot;balanced&quot; by a leaf outside it;
i.e. a split that divides leaves evenly has an imbalance of zero; one that
splits two tips from ten has an imbalance of 10 - 2 = 8.
</p>


<h3>See Also</h3>

<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>,
<code><a href="#topic+xor">xor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- PectinateTree(8)
splits &lt;- as.Splits(tree)
TipsInSplits(splits)

plot(tree)
LabelSplits(tree, as.character(splits), frame = "none", pos = 3L, cex = 0.7)
LabelSplits(tree, TipsInSplits(splits), unit = " tips", frame = "none",
            pos = 1L)

</code></pre>

<hr>
<h2 id='TipTimedTree'>Display time-calibrated tree using tip information only</h2><span id='topic+TipTimedTree'></span>

<h3>Description</h3>

<p><code>TipTimedTree()</code> plots a phylogenetic tree against time using an
<em>ad hoc</em> approach based on dates associated with the leaves.
Nodes are dated to the youngest possible value, plus an additional &quot;buffer&quot;
(specified with <code>minEdge</code>) to ensure that branching order is readable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TipTimedTree(tree, tipAge, minEdge = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TipTimedTree_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="TipTimedTree_+3A_tipage">tipAge</code></td>
<td>
<p>Numeric vector specifying the age (in units-of-time ago)
associated with each tip in <code>tree$tip.label</code> in turn.
Older ages signify earlier tips.</p>
</td></tr>
<tr><td><code id="TipTimedTree_+3A_minedge">minEdge</code></td>
<td>
<p>Minimum length of edge to allow (in units-of-time)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This experimental function is liable to change its behaviour, or to
be deprecated, in coming releases.
Please contact the maintainer if you find it useful, so that a
production-ready version can be prioritized.
</p>


<h3>Value</h3>

<p><code>TipTimedTree()</code> returns a tree with edge lengths set based on the
ages of each tip.
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- BalancedTree(6)
plot(TipTimedTree(tree, tipAge = 1:6, minEdge = 2))
</code></pre>

<hr>
<h2 id='TotalCopheneticIndex'>Total Cophenetic Index</h2><span id='topic+TotalCopheneticIndex'></span><span id='topic+TCIContext'></span><span id='topic+TCIContext.numeric'></span>

<h3>Description</h3>

<p><code>TotalCopheneticIndex()</code> calculates the total cophenetic index
(Mir et al. 2013) for any tree, a measure of its balance;
<code>TCIContext()</code> lists its possible values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TotalCopheneticIndex(x)

TCIContext(x)

## S3 method for class 'numeric'
TCIContext(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TotalCopheneticIndex_+3A_x">x</code></td>
<td>
<p>A tree of class <code>phylo</code>, its <code style="white-space: pre;">&#8288;$edge&#8288;</code> property, or a list thereof.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Total Cophenetic Index is a measure of tree balance &ndash; i.e. whether
a (phylogenetic) tree comprises symmetric pairs of nodes, or has a pectinate
&quot;caterpillar&quot; shape.
The index has a greater resolution power than Sackin's and Colless' indices,
and can be applied to trees that are not perfectly resolved.
</p>
<p>For a tree with <em>n</em> leaves, the Total Cophenetic Index can take values of
0 to <code>choose(n, 3)</code>.
The minimum value is higher for a perfectly resolved (i.e. dichotomous) tree
(see Lemma 14 of Mir <em>et al.</em> 2013).
Formulae to calculate the expected values under the Yule and Uniform models
of evolution are given in Theorems 17 and 23.
</p>
<p>Full details are provided by Mir et al. (2013).
</p>


<h3>Value</h3>

<p><code>TotalCopheneticIndex()</code> returns an integer denoting the total cophenetic index.
</p>
<p><code>TCIContext()</code> returns a data frame detailing the maximum and minimum value
obtainable for the Total Cophenetic Index for rooted binary trees with the
number of leaves of the given tree, and the expected value under the Yule
and Uniform models.
The variance of the expected value is given under the Yule model, but cannot
be obtained by calculation for the Uniform model.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Mir A, Rossell F, Rotger LA (2013).
&ldquo;A new balance index for phylogenetic trees.&rdquo;
<em>Mathematical Biosciences</em>, <b>241</b>(1), 125&ndash;136.
<a href="https://doi.org/10.1016/j.mbs.2012.10.005">doi:10.1016/j.mbs.2012.10.005</a>.
</p>


<h3>See Also</h3>

<p><code>cophen.index()</code> in the package
<a href="https://github.com/LuciaRotger/CollessLike"><span class="pkg">CollessLike</span></a>
provides an alternative implementation of this index and its predecessors.
</p>
<p>Other tree characterization functions: 
<code><a href="#topic+CladisticInfo">CladisticInfo</a>()</code>,
<code><a href="#topic+Consensus">Consensus</a>()</code>,
<code><a href="#topic+Stemwardness">Stemwardness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Balanced trees have the minimum index for a binary tree;
# Pectinate trees the maximum:
TCIContext(8)
TotalCopheneticIndex(PectinateTree(8))
TotalCopheneticIndex(BalancedTree(8))
TotalCopheneticIndex(StarTree(8))


# Examples from Mir et al. (2013):
tree12 &lt;- ape::read.tree(text="(1, (2, (3, (4, 5))));")  #Fig. 4, tree 12
TotalCopheneticIndex(tree12) # 10
tree8  &lt;- ape::read.tree(text="((1, 2, 3, 4), 5);")      #Fig. 4, tree 8
TotalCopheneticIndex(tree8)  # 6
TCIContext(tree8)
TCIContext(5L) # Context for a tree with 5 leaves.

</code></pre>

<hr>
<h2 id='TreeIsRooted'>Is tree rooted?</h2><span id='topic+TreeIsRooted'></span>

<h3>Description</h3>

<p><code>TreeIsRooted()</code> is a fast alternative to <code>ape::is.rooted()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TreeIsRooted(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TreeIsRooted_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree of class <code>phylo</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TreeIsRooted()</code> returns a logical specifying whether a root node is
resolved.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree properties: 
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PathLengths">PathLengths</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TreeIsRooted(BalancedTree(6))
TreeIsRooted(UnrootTree(BalancedTree(6)))

</code></pre>

<hr>
<h2 id='TreeNumber'>Unique integer indices for bifurcating tree topologies</h2><span id='topic+TreeNumber'></span><span id='topic+as.TreeNumber'></span><span id='topic+as.TreeNumber.phylo'></span><span id='topic+as.TreeNumber.multiPhylo'></span><span id='topic+as.TreeNumber.character'></span><span id='topic+as.TreeNumber.TreeNumber'></span><span id='topic+as.TreeNumber.MixedBase'></span><span id='topic+as.MixedBase.TreeNumber'></span><span id='topic+as.MixedBase.integer64'></span><span id='topic+as.MixedBase.numeric'></span><span id='topic+as.phylo.numeric'></span><span id='topic+as.phylo.TreeNumber'></span><span id='topic+as.MixedBase'></span><span id='topic+as.MixedBase.MixedBase'></span><span id='topic+as.MixedBase.phylo'></span><span id='topic+as.MixedBase.multiPhylo'></span><span id='topic+as.phylo.MixedBase'></span>

<h3>Description</h3>

<p>Functions converting between phylogenetic trees and their unique decimal
representation, based on a concept by John Tromp, employed in
(Li et al. 1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.TreeNumber(x, ...)

## S3 method for class 'phylo'
as.TreeNumber(x, ...)

## S3 method for class 'multiPhylo'
as.TreeNumber(x, ...)

## S3 method for class 'character'
as.TreeNumber(x, nTip, tipLabels = TipLabels(nTip), ...)

## S3 method for class 'TreeNumber'
as.TreeNumber(x, ...)

## S3 method for class 'MixedBase'
as.TreeNumber(x, ...)

## S3 method for class 'TreeNumber'
as.MixedBase(x, ...)

## S3 method for class 'integer64'
as.MixedBase(x, tipLabels = NULL, ...)

## S3 method for class 'numeric'
as.MixedBase(x, tipLabels = NULL, ...)

## S3 method for class 'numeric'
as.phylo(x, nTip = attr(x, "nTip"), tipLabels = attr(x, "tip.label"), ...)

## S3 method for class 'TreeNumber'
as.phylo(x, nTip = attr(x, "nTip"), tipLabels = attr(x, "tip.label"), ...)

as.MixedBase(x, ...)

## S3 method for class 'MixedBase'
as.MixedBase(x, ...)

## S3 method for class 'phylo'
as.MixedBase(x, ...)

## S3 method for class 'multiPhylo'
as.MixedBase(x, ...)

## S3 method for class 'MixedBase'
as.phylo(x, nTip = attr(x, "nTip"), tipLabels = attr(x, "tip.label"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TreeNumber_+3A_x">x</code></td>
<td>
<p>Integer identifying the tree (see details).</p>
</td></tr>
<tr><td><code id="TreeNumber_+3A_...">...</code></td>
<td>
<p>Additional parameters for consistency with S3 methods (unused).</p>
</td></tr>
<tr><td><code id="TreeNumber_+3A_ntip">nTip</code></td>
<td>
<p>Integer specifying number of leaves in the tree.</p>
</td></tr>
<tr><td><code id="TreeNumber_+3A_tiplabels">tipLabels</code></td>
<td>
<p>Character vector listing the labels assigned to each tip
in a tree, perhaps obtained using <code><a href="#topic+TipLabels">TipLabels()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are <code>NUnrooted(n)</code> unrooted trees with <em>n</em> leaves.
As such, each <em>n</em>-leaf tree can be uniquely identified by a non-negative
integer <em>x</em> &lt; <code>NUnrooted(n)</code>.
</p>
<p>This integer can be converted by a tree by treating it as a mixed-base
number, with bases 1, 3, 5, 7,  (2<em>n</em> - 5).
</p>
<p>Each digit of this mixed base number corresponds to a leaf, and determines
the location on a growing tree to which that leaf should be added.
</p>
<p>We start with a two-leaf tree, and treat 0 as the origin of the tree.
</p>
<div class="sourceCode"><pre>
0 ---- 1

</pre></div>
<p>We add leaf 2 by breaking an edge and inserting a node (numbered
<code>2 + nTip - 1</code>).
In this example, we'll work up to a six-leaf tree; this node will be numbered
2 + 6 - 1 = 7.
There is only one edge on which leaf 2 can be added.  Let's add node 7 and
leaf 2:
</p>
<div class="sourceCode"><pre>
0 ---- 7 ---- 1
       |
       |
       2

</pre></div>
<p>There are now three edges on which leaf 3 can be added.  Our options are:
</p>
<p>Option 0: the edge leading to 1;
</p>
<p>Option 1: the edge leading to 2;
</p>
<p>Option 2: the edge leading to 7.
</p>
<p>If we select option 1, we produce:
</p>
<div class="sourceCode"><pre>
0 ---- 7 ---- 1
       |
       |
       8 ---- 2
       |
       |
       3

</pre></div>
<p><code>1</code> is now the final digit of our mixed-base number.
</p>
<p>There are five places to add leaf 4:
</p>
<p>Option 0: the edge leading to 1;
</p>
<p>Option 1: the edge leading to 2;
</p>
<p>Option 2: the edge leading to 3;
</p>
<p>Option 3: the edge leading to 7;
</p>
<p>Option 4: the edge leading to 8.
</p>
<p>If we chose option 3, then <code>3</code> would be the penultimate digit of our
mixed-base number.
</p>
<p>If we chose option 0 for the next two additions, we could specify this tree
with the mixed-base number 0021.  We can convert this into decimal:
</p>
<p>0  (1  3  5  9) +
</p>
<p>0  (1  3  5) +
</p>
<p>3  (1  3) +
</p>
<p>1  (1)
</p>
<p>= 10
</p>
<p>Note that the hyperexponential nature of tree space means that there are &gt;
2^64 unique 20-leaf trees.  As a <code>TreeNumber</code> is a 64-bit integer,
only trees with at most 19 leaves can be accommodated.
</p>


<h3>Value</h3>

<p><code>as.TreeNumber()</code> returns an object of class <code>TreeNumber</code>,
which comprises a numeric vector, whose elements represent successive
nine-digit chunks of the decimal integer corresponding to the tree topology
(in big endian order).  The <code>TreeNumber</code> object has attributes
<code>nTip</code> and <code>tip.label</code>.  If <code>x</code> is a list of trees or a <code>multiPhylo</code> object,
then <code>as.TreeNumber()</code> returns a corresponding list of <code>TreeNumber</code> objects.
</p>
<p><code>as.phylo.numeric()</code> returns a tree of class <code>phylo</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Li M, Tromp J, Zhang L (1996).
&ldquo;Some notes on the nearest neighbour interchange distance.&rdquo;
In Goos G, Hartmanis J, Leeuwen J, Cai J, Wong CK (eds.), <em>Computing and Combinatorics</em>, volume 1090, 343&ndash;351.
Springer, Berlin, Heidelberg.
ISBN 978-3-540-61332-9, <a href="https://doi.org/10.1007/3-540-61332-3_168">doi:10.1007/3-540-61332-3_168</a>.
</p>


<h3>See Also</h3>

<p>Describe the shape of a tree topology, independent of leaf labels:
<code><a href="#topic+TreeShape">TreeShape()</a></code>
</p>
<p>Other tree generation functions: 
<code><a href="#topic+ConstrainedNJ">ConstrainedNJ</a>()</code>,
<code><a href="#topic+GenerateTree">GenerateTree</a></code>,
<code><a href="#topic+NJTree">NJTree</a>()</code>,
<code><a href="#topic+TrivialTree">TrivialTree</a></code>
</p>
<p>Other 'TreeNumber' utilities: 
<code><a href="#topic+is.TreeNumber">is.TreeNumber</a>()</code>,
<code><a href="#topic+print.TreeNumber">print.TreeNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- as.phylo(10, nTip = 6)
plot(tree)
as.TreeNumber(tree)

# Larger trees:
as.TreeNumber(BalancedTree(19))

# If &gt; 9 digits, represent the tree number as a string.
treeNumber &lt;- as.TreeNumber("1234567890123", nTip = 14)
tree &lt;- as.phylo(treeNumber)
as.phylo(0:2, nTip = 6, tipLabels = letters[1:6])

</code></pre>

<hr>
<h2 id='TreesMatchingSplit'>Number of trees matching a bipartition split</h2><span id='topic+TreesMatchingSplit'></span><span id='topic+LnTreesMatchingSplit'></span><span id='topic+Log2TreesMatchingSplit'></span>

<h3>Description</h3>

<p>Calculates the number of unrooted bifurcated trees that are consistent with
a bipartition split that divides taxa into groups of size <code>A</code> and <code>B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TreesMatchingSplit(A, B = A[2])

LnTreesMatchingSplit(A, B = A[2])

Log2TreesMatchingSplit(A, B = A[2])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TreesMatchingSplit_+3A_a">A</code>, <code id="TreesMatchingSplit_+3A_b">B</code></td>
<td>
<p>Integer specifying the number of taxa in each partition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TreesMatchingSplit()</code> returns a numeric specifying the number of trees
that are compatible with the given split.
</p>
<p><code>LnTreesMatchingSplit()</code> and <code>Log2TreesMatchingSplit()</code> give the natural
and base-2 logarithms of this number.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other split information functions: 
<code><a href="#topic+CharacterInformation">CharacterInformation</a>()</code>,
<code><a href="#topic+SplitInformation">SplitInformation</a>()</code>,
<code><a href="#topic+SplitMatchProbability">SplitMatchProbability</a>()</code>,
<code><a href="#topic+UnrootedTreesMatchingSplit">UnrootedTreesMatchingSplit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TreesMatchingSplit(5, 6)
LnTreesMatchingSplit(5, 6)
Log2TreesMatchingSplit(5, 6)

</code></pre>

<hr>
<h2 id='TreesMatchingTree'>Number of trees containing a tree</h2><span id='topic+TreesMatchingTree'></span><span id='topic+LnTreesMatchingTree'></span><span id='topic+Log2TreesMatchingTree'></span>

<h3>Description</h3>

<p><code>TreesMatchingTree()</code> calculates the number of unrooted binary trees that
are consistent with a tree topology on the same leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TreesMatchingTree(tree)

LnTreesMatchingTree(tree)

Log2TreesMatchingTree(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TreesMatchingTree_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remember to unroot a tree first if the position of its root is arbitrary.
</p>


<h3>Value</h3>

<p><code>TreesMatchingTree()</code> returns a numeric specifying the number of
unrooted binary trees that contain all the edges present in the input tree.
</p>
<p><code>LnTreesMatchingTree()</code> gives the natural logarithm of this number.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree information functions: 
<code><a href="#topic+CladisticInfo">CladisticInfo</a>()</code>,
<code><a href="#topic+NRooted">NRooted</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>partiallyResolvedTree &lt;- CollapseNode(BalancedTree(8), 12:15)
TreesMatchingTree(partiallyResolvedTree)
LnTreesMatchingTree(partiallyResolvedTree)

# Number of rooted trees:
rootedTree &lt;- AddTip(partiallyResolvedTree, where = 0)
TreesMatchingTree(partiallyResolvedTree)
</code></pre>

<hr>
<h2 id='TreeTools-package'>TreeTools</h2><span id='topic+TreeTools'></span><span id='topic+TreeTools-package'></span>

<h3>Description</h3>

<p>&quot;TreeTools&quot; is an R package that provides functions for creating, modifying and
analysing phylogenetic trees.
It complements packages such as
<a href="https://cran.r-project.org/package=ape"><span class="pkg">ape</span></a>,
<a href="https://cran.r-project.org/package=phangorn"><span class="pkg">phangorn</span></a> and
<a href="https://cran.r-project.org/package=phytools"><span class="pkg">phytools</span></a>,
aiming for efficient and robust implementations of functions, typically
applied to unweighted trees (i.e. those without edge lengths).
</p>


<h3>Details</h3>

<p>Full documentation is available <a href="https://ms609.github.io/TreeTools/">online</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin R. Smith <a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a> (<a href="https://orcid.org/0000-0001-5660-1727">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Emmanuel Paradis (<a href="https://orcid.org/0000-0003-3092-2199">ORCID</a>) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ms609.github.io/TreeTools/">https://ms609.github.io/TreeTools/</a>
</p>
</li>
<li> <p><a href="https://github.com/ms609/TreeTools/">https://github.com/ms609/TreeTools/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ms609/TreeTools/issues/">https://github.com/ms609/TreeTools/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='TrivialSplits'>Identify and remove trivial splits</h2><span id='topic+TrivialSplits'></span><span id='topic+WithoutTrivialSplits'></span>

<h3>Description</h3>

<p><code>TrivialSplits()</code> identifies trivial splits (which separate one or zero
leaves from all others); <code>WithoutTrivialSplits()</code> removes them from a
<code>Splits</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrivialSplits(splits, nTip = attr(splits, "nTip"))

WithoutTrivialSplits(splits, nTip = attr(splits, "nTip"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrivialSplits_+3A_splits">splits</code></td>
<td>
<p>An object of class <code><a href="#topic+as.Splits">Splits</a></code>.</p>
</td></tr>
<tr><td><code id="TrivialSplits_+3A_ntip">nTip</code></td>
<td>
<p>Integer specifying number of tips (leaves).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TrivialSplits()</code> returns a logical vector specifying whether each
split in <code>splits</code> is trivial, i.e. includes or excludes only a single tip or
no tips at all.
</p>
<p><code>WithoutTrivialSplits()</code> returns a <code>Splits</code> object with trivial
splits removed.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other split manipulation functions: 
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+Subsplit">Subsplit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splits &lt;- as.Splits(PectinateTree(letters[1:9]))
efgh &lt;- Subsplit(splits, tips = letters[5:8], keepAll = TRUE)
summary(efgh)

TrivialSplits(efgh)
summary(WithoutTrivialSplits(efgh))
</code></pre>

<hr>
<h2 id='TrivialTree'>Generate trivial trees</h2><span id='topic+TrivialTree'></span><span id='topic+SingleTaxonTree'></span><span id='topic+ZeroTaxonTree'></span>

<h3>Description</h3>

<p><code>SingleTaxonTree()</code> creates a phylogenetic &quot;tree&quot; that contains a single
taxon.
<code>ZeroTaxonTree()</code> creates an empty <code>phylo</code> object with zero leaves or edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleTaxonTree(label = "t1")

ZeroTaxonTree()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrivialTree_+3A_label">label</code></td>
<td>
<p>a character vector specifying the label of the tip.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SingleTaxonTree()</code> returns a <code>phylo</code> object containing a single
tip with the specified label.
</p>
<p><code>ZeroTaxonTree()</code> returns an empty <code>phylo</code> object.
</p>


<h3>See Also</h3>

<p>Other tree manipulation: 
<code><a href="#topic+AddTip">AddTip</a>()</code>,
<code><a href="#topic+CollapseNode">CollapseNode</a>()</code>,
<code><a href="#topic+ConsensusWithout">ConsensusWithout</a>()</code>,
<code><a href="#topic+DropTip">DropTip</a>()</code>,
<code><a href="#topic+EnforceOutgroup">EnforceOutgroup</a>()</code>,
<code><a href="#topic+ImposeConstraint">ImposeConstraint</a>()</code>,
<code><a href="#topic+KeptPaths">KeptPaths</a>()</code>,
<code><a href="#topic+KeptVerts">KeptVerts</a>()</code>,
<code><a href="#topic+LeafLabelInterchange">LeafLabelInterchange</a>()</code>,
<code><a href="#topic+MakeTreeBinary">MakeTreeBinary</a>()</code>,
<code><a href="#topic+RenumberTips">RenumberTips</a>()</code>,
<code><a href="#topic+RenumberTree">RenumberTree</a>()</code>,
<code><a href="#topic+Renumber">Renumber</a>()</code>,
<code><a href="#topic+RootTree">RootTree</a>()</code>,
<code><a href="#topic+SortTree">SortTree</a>()</code>,
<code><a href="#topic+Subtree">Subtree</a>()</code>,
<code><a href="#topic+TipTimedTree">TipTimedTree</a>()</code>
</p>
<p>Other tree generation functions: 
<code><a href="#topic+ConstrainedNJ">ConstrainedNJ</a>()</code>,
<code><a href="#topic+GenerateTree">GenerateTree</a></code>,
<code><a href="#topic+NJTree">NJTree</a>()</code>,
<code><a href="#topic+TreeNumber">TreeNumber</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SingleTaxonTree("Homo_sapiens")
plot(SingleTaxonTree("root") + BalancedTree(4))

ZeroTaxonTree()
</code></pre>

<hr>
<h2 id='Unquote'>Remove quotation marks from a string</h2><span id='topic+Unquote'></span>

<h3>Description</h3>

<p>Remove quotation marks from a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Unquote(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Unquote_+3A_string">string</code></td>
<td>
<p>Input string</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Unquote()</code> returns <code>string</code>, with any matched punctuation marks
and trailing whitespace removed.
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>


<h3>See Also</h3>

<p>Other string parsing functions: 
<code><a href="#topic+EndSentence">EndSentence</a>()</code>,
<code><a href="#topic+MorphoBankDecode">MorphoBankDecode</a>()</code>,
<code><a href="#topic+RightmostCharacter">RightmostCharacter</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Unquote("'Hello World'")
</code></pre>

<hr>
<h2 id='unrootedKeys'>Integer representing shape of a tree</h2><span id='topic+unrootedKeys'></span><span id='topic+TreeShape'></span><span id='topic+RootedTreeShape'></span><span id='topic+RootedTreeWithShape'></span><span id='topic+UnrootedTreeWithShape'></span><span id='topic+UnrootedTreeWithKey'></span><span id='topic+UnrootedTreeShape'></span><span id='topic+UnrootedTreeKey'></span><span id='topic+.UnrootedKeys'></span><span id='topic+UnrootedKeys'></span><span id='topic+NUnrootedShapes'></span><span id='topic+NRootedShapes'></span>

<h3>Description</h3>

<p>Returns an integer that uniquely represents the shape of an <em>n</em>-tip
binary tree, ignoring tip labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unrootedKeys

RootedTreeShape(tree)

RootedTreeWithShape(shape, nTip, tipLabels)

UnrootedTreeWithShape(shape, nTip, tipLabels = character(nTip))

UnrootedTreeWithKey(key, nTip, tipLabels = character(nTip))

UnrootedTreeShape(tree)

UnrootedTreeKey(tree, asInteger = FALSE)

.UnrootedKeys(nTip)

UnrootedKeys(..., envir = parent.frame())

NUnrootedShapes(nTip)

NRootedShapes(nTip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unrootedKeys_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="unrootedKeys_+3A_shape">shape</code></td>
<td>
<p>Integer specifying shape of tree, perhaps generated by
<code>TreeShape()</code>.</p>
</td></tr>
<tr><td><code id="unrootedKeys_+3A_ntip">nTip</code></td>
<td>
<p>Integer specifying number of tips.</p>
</td></tr>
<tr><td><code id="unrootedKeys_+3A_tiplabels">tipLabels</code></td>
<td>
<p>Character vector listing the labels assigned to each tip
in a tree, perhaps obtained using <code><a href="#topic+TipLabels">TipLabels()</a></code>.</p>
</td></tr>
<tr><td><code id="unrootedKeys_+3A_key">key</code></td>
<td>
<p>Integer specifying the <em>key</em> (not number) of an unrooted tree.</p>
</td></tr>
<tr><td><code id="unrootedKeys_+3A_asinteger">asInteger</code></td>
<td>
<p>Logical specifying whether to coerce the return value to
mode <code>integer</code>: only possible for values &lt; 2^31.
If <code>FALSE</code>, values will have class <code>integer64</code>.</p>
</td></tr>
<tr><td><code id="unrootedKeys_+3A_...">...</code></td>
<td>
<p>Value of <code>nTip</code>, to pass to memoized <code>.UnrootedKeys</code>.</p>
</td></tr>
<tr><td><code id="unrootedKeys_+3A_envir">envir</code></td>
<td>
<p>Unused; passed to <code><a href="R.cache.html#topic+addMemoization">addMemoization</a></code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code>unrootedKeys</code> is a list of length 22; each
entry is a vector of integers corresponding to they keys (not shape numbers)
of the different unrooted tree shapes with <code>nTip</code> leaves.
</p>


<h3>Details</h3>

<p>Rooted trees are numbered working up from the root.
</p>
<p>The root node divides <em>n</em> tips into two subtrees.  The smaller subtree
may contain $a = 1, 2, ..., n/2$ tips, leaving $b = n - a$ tips in
These options are worked through in turn.
</p>
<p>For the first shape of the smaller subtree, work through each possible shape
for the larger subtree.  Then, move to the next shape of the smaller subtree,
and work through each possible shape of the larger subtree.
</p>
<p>Stop when the desired topology is encountered.
</p>
<p>Unrooted trees are numbered less elegantly.  Each cherry (i.e. node
subtending a pair of tips) is treated in turn.  The subtended tips are
removed, and the node treated as the root of a rooted tree.  The number of
this rooted tree is then calculated.  The tree is assigned a <em>key</em>
corresponding to the lowest such value.  The keys of all unrooted tree shapes
on <em>n</em> tips are ranked, and the unrooted tree shape is assigned a <em>number</em>
based on the rank order of its key among all possible keys, counting from
zero.
</p>
<p>If <code>UnrootedTreeShape()</code> or <code>UnrootedTreeKey()</code> is passed a rooted tree,
the position of the root will be ignored.
</p>
<p>The number of unlabelled binary rooted trees corresponds to the
<a href="https://oeis.org/A001190">Wedderburn-Etherington numbers</a>.
</p>


<h3>Value</h3>

<p><code>TreeShape()</code> returns an integer specifying the shape of a tree,
ignoring tip labels.
</p>
<p><code>RootedTreeWithShape()</code> returns a tree of class <code>phylo</code>
corresponding to the shape provided.  Tips are unlabelled.
</p>
<p><code>UnrootedTreeWithShape()</code> returns a tree of class <code>phylo</code>
corresponding to the shape provided.  Tips are unlabelled.
</p>
<p><code>UnrootedTreeWithKey()</code> returns a tree of class <code>phylo</code> corresponding
to the key provided.  Tips are unlabelled.
</p>
<p><code>UnrootedKeys()</code> returns a vector of integers corresponding to the
keys (not shape numbers) of unrooted tree shapes with <code>nTip</code> tips.
It is a wrapper to <code>.UnrootedKeys()</code>, with memoization, meaning that results
once calculated are cached and need not be calculated on future calls to
the function.
</p>
<p><code>NUnrootedShapes()</code> returns an object of class <code>integer64</code> specifying
the number of unique unrooted tree shapes with <code>nTip</code> (&lt; 61) tips.
</p>
<p><code>NRootedShapes()</code> returns an object of class <code>integer64</code> specifying
the number of unique rooted tree shapes with <code>nTip</code> (&lt; 56) leaves.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Unique number for a labelled tree: <code><a href="#topic+TreeNumber">TreeNumber()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RootedTreeShape(PectinateTree(8))
plot(RootedTreeWithShape(0, nTip = 8L))

NRootedShapes(8L)
# Shapes are numbered from 0 to NRootedShapes(n) - 1.  The maximum shape is:
RootedTreeShape(BalancedTree(8))

# Unique shapes of unrooted trees:
NUnrootedShapes(8L)

# Keys of these trees:
UnrootedKeys(8L)

# A tree may be represented by multiple keys.
# For a one-to-one correspondence, use a number instead:
unrootedShapes8 &lt;- as.integer(NUnrootedShapes(8L))
allShapes &lt;- lapply(seq_len(unrootedShapes8) - 1L,
                    UnrootedTreeWithShape, 8L)
plot(allShapes[[1]])
sapply(allShapes, UnrootedTreeShape)
sapply(allShapes, UnrootedTreeKey, asInteger = TRUE) # Key &gt;= number

# If numbers larger than 2&gt;31 are required, sapply needs a little help
# with 64-bit integers:
structure(sapply(allShapes, UnrootedTreeKey), class = "integer64")


</code></pre>

<hr>
<h2 id='UnrootedTreesMatchingSplit'>Number of trees consistent with split</h2><span id='topic+UnrootedTreesMatchingSplit'></span><span id='topic+LnUnrootedTreesMatchingSplit'></span><span id='topic+Log2UnrootedTreesMatchingSplit'></span>

<h3>Description</h3>

<p>Calculates the number of unrooted bifurcating trees consistent with the
specified multi-partition split, using theorem two of
Carter et al. (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnrootedTreesMatchingSplit(...)

LnUnrootedTreesMatchingSplit(...)

Log2UnrootedTreesMatchingSplit(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnrootedTreesMatchingSplit_+3A_...">...</code></td>
<td>
<p>A series or vector of integers listing the number of tips in
each of a number of tree splits (e.g. bipartitions).
For example, <code style="white-space: pre;">&#8288;3, 5&#8288;</code> states that a character divides a set of eight tips into
a group of three and a group of five.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>UnrootedTreesMatchingSplit()</code> returns an integer specifying the
number of unrooted bifurcating trees consistent with the specified split.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Carter M, Hendy M, Penny D, Szkely LA, Wormald NC (1990).
&ldquo;On the distribution of lengths of evolutionary trees.&rdquo;
<em>SIAM Journal on Discrete Mathematics</em>, <b>3</b>(1), 38&ndash;47.
<a href="https://doi.org/10.1137/0403005">doi:10.1137/0403005</a>.
</p>


<h3>See Also</h3>

<p>Other split information functions: 
<code><a href="#topic+CharacterInformation">CharacterInformation</a>()</code>,
<code><a href="#topic+SplitInformation">SplitInformation</a>()</code>,
<code><a href="#topic+SplitMatchProbability">SplitMatchProbability</a>()</code>,
<code><a href="#topic+TreesMatchingSplit">TreesMatchingSplit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>UnrootedTreesMatchingSplit(c(3, 5))
UnrootedTreesMatchingSplit(3, 2, 1, 2)
</code></pre>

<hr>
<h2 id='UnshiftTree'>Add tree to start of list</h2><span id='topic+UnshiftTree'></span>

<h3>Description</h3>

<p><code>UnshiftTree()</code> adds a phylogenetic tree to the start of a list of trees.
This is useful where the class of a list of trees is unknown, or where
names of trees should be retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnshiftTree(add, treeList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnshiftTree_+3A_add">add</code></td>
<td>
<p>Tree to add to the list, of class <code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="UnshiftTree_+3A_treelist">treeList</code></td>
<td>
<p>A list of trees, of class <code>list</code>,
<code><a href="ape.html#topic+multiphylo">multiPhylo</a></code>, or, if a single tree,
<code><a href="ape.html#topic+read.tree">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Caution: adding a tree to a <code>multiPhylo</code> object whose own attributes apply
to all trees, for example trees read from a Nexus file, causes data to be
lost.
</p>


<h3>Value</h3>

<p><code>UnshiftTree()</code> returns a list of class <code>list</code> or <code>multiPhylo</code>
(following the original class of <code>treeList</code>), whose first element is the
tree specified as 'add.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+c">c()</a></code> joins a tree or series of trees to a <code>multiPhylo</code> object, but loses
names and does not handle lists of trees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>forest &lt;- as.phylo(0:5, 6)
tree &lt;- BalancedTree(6)

UnshiftTree(tree, forest)
UnshiftTree(tree, tree)
</code></pre>

<hr>
<h2 id='WriteTntCharacters'>Write morphological character matrix to TNT file</h2><span id='topic+WriteTntCharacters'></span><span id='topic+WriteTntCharacters.phyDat'></span><span id='topic+WriteTntCharacters.matrix'></span>

<h3>Description</h3>

<p>Write morphological character matrix to TNT file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteTntCharacters(
  dataset,
  filepath = NULL,
  comment = "Dataset written by `TreeTools::WriteTntCharacters()`",
  types = NULL,
  pre = "",
  post = ""
)

## S3 method for class 'phyDat'
WriteTntCharacters(
  dataset,
  filepath = NULL,
  comment = "Dataset written by `TreeTools::WriteTntCharacters()`",
  types = NULL,
  pre = "",
  post = ""
)

## S3 method for class 'matrix'
WriteTntCharacters(
  dataset,
  filepath = NULL,
  comment = "Dataset written by `TreeTools::WriteTntCharacters()`",
  types = NULL,
  pre = "",
  post = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WriteTntCharacters_+3A_dataset">dataset</code></td>
<td>
<p>Morphological dataset of class <code>phyDat</code> or <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="WriteTntCharacters_+3A_filepath">filepath</code></td>
<td>
<p>Path to file; if <code>NULL</code>, returns a character vector.</p>
</td></tr>
<tr><td><code id="WriteTntCharacters_+3A_comment">comment</code></td>
<td>
<p>Optional comment with which to entitle matrix.</p>
</td></tr>
<tr><td><code id="WriteTntCharacters_+3A_types">types</code></td>
<td>
<p>Optional list specifying where different data types begin.
<code>c(num = 1, dna = 10)</code> sets characters 1..9 as numeric, 10..end as DNA.</p>
</td></tr>
<tr><td><code id="WriteTntCharacters_+3A_pre">pre</code>, <code id="WriteTntCharacters_+3A_post">post</code></td>
<td>
<p>Character vector listing text to print before and after the
character matrix.  Specify <code style="white-space: pre;">&#8288;pre = 'piwe=;&#8288;</code> if the matrix is to be analysed
using extended implied weighting (<code style="white-space: pre;">&#8288;xpiwe=&#8288;</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ReadTntCharacters">ReadTntCharacters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lobo", package = "TreeTools")

WriteTntCharacters(Lobo.phy)

# Read with extended implied weighting
WriteTntCharacters(Lobo.phy, pre = "piwe=10;", post = "xpiwe=;")

# Write to a file with:
# WriteTntCharacters(Lobo.phy, "example_file.tnt")
</code></pre>

<hr>
<h2 id='xor'>Exclusive OR operation</h2><span id='topic+xor'></span><span id='topic+xor+2CSplits+2CSplits-method'></span>

<h3>Description</h3>

<p>Exclusive OR operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xor(x, y)

## S4 method for signature 'Splits,Splits'
xor(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xor_+3A_x">x</code>, <code id="xor_+3A_y">y</code></td>
<td>
<p>Objects to be compared.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Splits operations: 
<code><a href="#topic+LabelSplits">LabelSplits</a>()</code>,
<code><a href="#topic+NSplits">NSplits</a>()</code>,
<code><a href="#topic+NTip">NTip</a>()</code>,
<code><a href="#topic+PolarizeSplits">PolarizeSplits</a>()</code>,
<code><a href="#topic+SplitFrequency">SplitFrequency</a>()</code>,
<code><a href="#topic+SplitsInBinaryTree">SplitsInBinaryTree</a>()</code>,
<code><a href="#topic+Splits">Splits</a></code>,
<code><a href="#topic+TipLabels">TipLabels</a>()</code>,
<code><a href="#topic+TipsInSplits">TipsInSplits</a>()</code>,
<code><a href="#topic+match.Splits">match.Splits</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
