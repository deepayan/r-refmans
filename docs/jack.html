<!DOCTYPE html><html><head><title>Help for package jack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ESF'><p>Evaluation of elementary symmetric functions</p></a></li>
<li><a href='#Jack'><p>Evaluation of Jack polynomial - C++ implementation</p></a></li>
<li><a href='#JackPol'><p>Jack polynomial - C++ implementation</p></a></li>
<li><a href='#JackPolR'><p>Jack polynomial</p></a></li>
<li><a href='#JackR'><p>Evaluation of Jack polynomials</p></a></li>
<li><a href='#JackSymPol'><p>Jack polynomial with symbolic Jack parameter</p></a></li>
<li><a href='#KostkaNumbers'><p>Kostka numbers</p></a></li>
<li><a href='#LRmult'><p>Littlewood-Richardson rule for multiplication</p></a></li>
<li><a href='#LRskew'><p>Littlewood-Richardson rule for skew Schur polynomial</p></a></li>
<li><a href='#MSF'><p>Evaluation of monomial symmetric functions</p></a></li>
<li><a href='#Schur'><p>Evaluation of Schur polynomial - C++ implementation</p></a></li>
<li><a href='#SchurPol'><p>Schur polynomial - C++ implementation</p></a></li>
<li><a href='#SchurPolR'><p>Schur polynomial</p></a></li>
<li><a href='#SchurR'><p>Evaluation of Schur polynomials</p></a></li>
<li><a href='#SkewSchurPol'><p>Skew Schur polynomial</p></a></li>
<li><a href='#Zonal'><p>Evaluation of zonal polynomial - C++ implementation</p></a></li>
<li><a href='#ZonalPol'><p>Zonal polynomial - C++ implementation</p></a></li>
<li><a href='#ZonalPolR'><p>Zonal polynomial</p></a></li>
<li><a href='#ZonalQ'><p>Evaluation of zonal quaternionic polynomial - C++ implementation</p></a></li>
<li><a href='#ZonalQPol'><p>Quaternionic zonal polynomial - C++ implementation</p></a></li>
<li><a href='#ZonalQPolR'><p>Quaternionic zonal polynomial</p></a></li>
<li><a href='#ZonalQR'><p>Evaluation of quaternionic zonal polynomials</p></a></li>
<li><a href='#ZonalR'><p>Evaluation of zonal polynomials</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Jack, Zonal, and Schur Polynomials</td>
</tr>
<tr>
<td>Version:</td>
<td>6.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Laurent</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Laurent &lt;laurent_step@outlook.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Symbolic calculation and evaluation of the Jack polynomials,
    zonal polynomials, and Schur polynomials. Mainly based on Demmel &amp;
    Koev's paper (2006) &lt;<a href="https://doi.org/10.1090%2FS0025-5718-05-01780-1">doi:10.1090/S0025-5718-05-01780-1</a>&gt;. Zonal
    polynomials and Schur polynomials are particular cases of Jack
    polynomials. Zonal polynomials appear in random matrix theory. Schur
    polynomials appear in the field of combinatorics. The package can also 
    compute the skew Schur polynomials.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stla/jackR">https://github.com/stla/jackR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stla/jackR/issues">https://github.com/stla/jackR/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17, gmp, mpfr</td>
</tr>
<tr>
<td>Depends:</td>
<td>qspray (&ge; 3.0.0), symbolicQspray</td>
</tr>
<tr>
<td>Imports:</td>
<td>DescTools, gmp, multicool, mvp, partitions, Rcpp, spray, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp, qspray, RcppArmadillo, ratioOfQsprays, RcppCGAL,
symbolicQspray</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, syt</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-03 00:52:28 UTC; SDL96354</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-03 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ESF'>Evaluation of elementary symmetric functions</h2><span id='topic+ESF'></span>

<h3>Description</h3>

<p>Evaluates an elementary symmetric function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESF(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESF_+3A_x">x</code></td>
<td>
<p>a numeric vector or a <code><a href="gmp.html#topic+bigq">bigq</a></code> vector</p>
</td></tr>
<tr><td><code id="ESF_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number if <code>x</code> is numeric, a <code>bigq</code> rational number
if <code>x</code> is a <code>bigq</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 5/2)
lambda &lt;- c(3, 1)
ESF(x, lambda)
library(gmp)
x &lt;- c(as.bigq(1), as.bigq(2), as.bigq(5,2))
ESF(x, lambda)
</code></pre>

<hr>
<h2 id='Jack'>Evaluation of Jack polynomial - C++ implementation</h2><span id='topic+Jack'></span>

<h3>Description</h3>

<p>Evaluates the Jack polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jack(x, lambda, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jack_+3A_x">x</code></td>
<td>
<p>values of the variables, a vector of <code>bigq</code> numbers, or a
vector that can be coerced as such (e.g. <code>c("2", "5/3")</code>)</p>
</td></tr>
<tr><td><code id="Jack_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="Jack_+3A_alpha">alpha</code></td>
<td>
<p>rational number, given as a string such as
<code>"2/3"</code> or as a <code>bigq</code> number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bigq</code> number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Jack(c("1", "3/2", "-2/3"), lambda = c(3, 1), alpha = "1/4")
</code></pre>

<hr>
<h2 id='JackPol'>Jack polynomial - C++ implementation</h2><span id='topic+JackPol'></span>

<h3>Description</h3>

<p>Returns the Jack polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackPol(n, lambda, alpha, which = "J")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JackPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="JackPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="JackPol_+3A_alpha">alpha</code></td>
<td>
<p>rational number, given as a string such as
<code>"2/3"</code> or as a <code>bigq</code> number</p>
</td></tr>
<tr><td><code id="JackPol_+3A_which">which</code></td>
<td>
<p>which Jack polynomial, <code>"J"</code>, <code>"P"</code>, <code>"Q"</code>,
or <code>"C"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JackPol(3, lambda = c(3, 1), alpha = "2/5")
</code></pre>

<hr>
<h2 id='JackPolR'>Jack polynomial</h2><span id='topic+JackPolR'></span>

<h3>Description</h3>

<p>Returns the Jack polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackPolR(n, lambda, alpha, algorithm = "DK", basis = "canonical", which = "J")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JackPolR_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="JackPolR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="JackPolR_+3A_alpha">alpha</code></td>
<td>
<p>parameter of the Jack polynomial, a number, possibly (and
preferably) a <code><a href="gmp.html#topic+bigq">bigq</a></code> rational number</p>
</td></tr>
<tr><td><code id="JackPolR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> or <code>"naive"</code></p>
</td></tr>
<tr><td><code id="JackPolR_+3A_basis">basis</code></td>
<td>
<p>the polynomial basis for <code>algorithm = "naive"</code>,
either <code>"canonical"</code> or <code>"MSF"</code> (monomial symmetric functions);
for <code>algorithm = "DK"</code> the canonical basis is always used and
this parameter is ignored</p>
</td></tr>
<tr><td><code id="JackPolR_+3A_which">which</code></td>
<td>
<p>which Jack polynomial, <code>"J"</code>, <code>"P"</code> or <code>"Q"</code>;
this argument is taken into account <strong>only</strong> if <code>alpha</code> is a
<code>bigq</code> number and <code>algorithm = "DK"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mvp</code> multivariate polynomial (see <a href="mvp.html#topic+mvp-package">mvp-package</a>),
or a <code>qspray</code> multivariate polynomial if <code>alpha</code>
is a <code>bigq</code> rational number and <code>algorithm = "DK"</code>, or a
character string if <code>basis = "MSF"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JackPolR(3, lambda = c(3,1), alpha = gmp::as.bigq(2,3),
                  algorithm = "naive")
JackPolR(3, lambda = c(3,1), alpha = 2/3, algorithm = "DK")
JackPolR(3, lambda = c(3,1), alpha = gmp::as.bigq(2,3), algorithm = "DK")
JackPolR(3, lambda = c(3,1), alpha= gmp::as.bigq(2,3),
        algorithm = "naive", basis = "MSF")
# when the Jack polynomial is a `qspray` object, you can
# evaluate it with `qspray::evalQspray`:
jack &lt;- JackPolR(3, lambda = c(3, 1), alpha = gmp::as.bigq(2))
evalQspray(jack, c("1", "1/2", "3"))
</code></pre>

<hr>
<h2 id='JackR'>Evaluation of Jack polynomials</h2><span id='topic+JackR'></span>

<h3>Description</h3>

<p>Evaluates a Jack polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackR(x, lambda, alpha, algorithm = "DK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JackR_+3A_x">x</code></td>
<td>
<p>numeric or complex vector or <code><a href="gmp.html#topic+bigq">bigq</a></code> vector</p>
</td></tr>
<tr><td><code id="JackR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="JackR_+3A_alpha">alpha</code></td>
<td>
<p>ordinary number or <code>bigq</code> rational number</p>
</td></tr>
<tr><td><code id="JackR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> (Demmel-Koev)
or <code>"naive"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex scalar or a <code>bigq</code> rational number.
</p>


<h3>References</h3>


<ul>
<li><p> I.G. Macdonald.
<em>Symmetric Functions and Hall Polynomials</em>.
Oxford Mathematical Monographs.
The Clarendon Press Oxford University Press,
New York, second edition, 1995.
</p>
</li>
<li><p> J. Demmel &amp; P. Koev.
<em>Accurate and efficient evaluation of Schur and Jack functions</em>.
Mathematics of computations, vol. 75, n. 253, 223-229, 2005.
</p>
</li>
<li> <p><em>Jack polynomials</em>.
<a href="https://www.symmetricfunctions.com/jack.htm">https://www.symmetricfunctions.com/jack.htm</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+JackPolR">JackPolR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- c(2,1,1)
JackR(c(1/2, 2/3, 1), lambda, alpha = 3)
# exact value:
JackR(c(gmp::as.bigq(1,2), gmp::as.bigq(2,3), gmp::as.bigq(1)), lambda,
     alpha = gmp::as.bigq(3))
</code></pre>

<hr>
<h2 id='JackSymPol'>Jack polynomial with symbolic Jack parameter</h2><span id='topic+JackSymPol'></span>

<h3>Description</h3>

<p>Returns the Jack polynomial with symbolic Jack parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackSymPol(n, lambda, which = "J")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JackSymPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="JackSymPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="JackSymPol_+3A_which">which</code></td>
<td>
<p>which Jack polynomial, <code>"J"</code>, <code>"P"</code>, <code>"Q"</code>,
or <code>"C"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>symbolicQspray</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JackSymPol(3, lambda = c(3, 1))
</code></pre>

<hr>
<h2 id='KostkaNumbers'>Kostka numbers</h2><span id='topic+KostkaNumbers'></span>

<h3>Description</h3>

<p>The Kostka numbers for partitions of a given weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KostkaNumbers(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KostkaNumbers_+3A_n">n</code></td>
<td>
<p>positive integer, the weight of the partitions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of integers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KostkaNumbers(4)
</code></pre>

<hr>
<h2 id='LRmult'>Littlewood-Richardson rule for multiplication</h2><span id='topic+LRmult'></span>

<h3>Description</h3>

<p>Expression of the product of two Schur polynomials as a linear
combination of Schur polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRmult(mu, nu, output = "dataframe")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LRmult_+3A_mu">mu</code>, <code id="LRmult_+3A_nu">nu</code></td>
<td>
<p>integer partitions, given as vectors of decreasing integers</p>
</td></tr>
<tr><td><code id="LRmult_+3A_output">output</code></td>
<td>
<p>the type of the output, <code>"dataframe"</code> or <code>"list"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This computes the expression of the two Schur polynomials
associated to <code>mu</code> and <code>nu</code> as a linear combination of Schur
polynomials. If <code>output="dataframe"</code>, the output is a dataframe with
two columns: the column <code>coeff</code> gives the coefficients of this
linear combination, and the column <code>lambda</code> gives the partitions
defining the Schur polynomials of this linear combination as character
strings, e.g. the partition <code>c(4, 3, 1)</code> is given by <code>"4, 3, 1"</code>.
If <code>output="list"</code>, the output is a list with two fields: the field
<code>coeff</code> is the vector made of the coefficients of the linear
combination, and the field <code>lambda</code> is the list of partitions
defining the Schur polynomials of the linear combination given as
integer vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(jack)
mu &lt;- c(2, 1)
nu &lt;- c(3, 2, 1)
LR &lt;- LRmult(mu, nu, output = "list")
LRcoeffs &lt;- LR$coeff
LRparts &lt;- LR$lambda
LRterms &lt;- lapply(1:length(LRcoeffs), function(i) {
  LRcoeffs[i] * SchurPol(3, LRparts[[i]])
})
smu_times_snu &lt;- Reduce(`+`, LRterms)
smu_times_snu == SchurPol(3, mu) * SchurPol(3, nu)
</code></pre>

<hr>
<h2 id='LRskew'>Littlewood-Richardson rule for skew Schur polynomial</h2><span id='topic+LRskew'></span>

<h3>Description</h3>

<p>Expression of a skew Schur polynomial as a linear
combination of Schur polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRskew(lambda, mu, output = "dataframe")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LRskew_+3A_lambda">lambda</code>, <code id="LRskew_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
<tr><td><code id="LRskew_+3A_output">output</code></td>
<td>
<p>the type of the output, <code>"dataframe"</code> or <code>"list"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This computes the expression of the skew Schur polynomial
associated to the skew partition defined by <code>lambda</code> and <code>mu</code>
as a linear combination of Schur polynomials. If <code>output="dataframe"</code>,
the output is a dataframe with two columns: the column <code>coeff</code> gives
the coefficients of this linear combination, and the column <code>nu</code>
gives the partitions defining the Schur polynomials of this linear
combination as character strings, e.g. the partition <code>c(4, 3, 1)</code> is
given by <code>"4, 3, 1"</code>. If <code>output="list"</code>, the output is a list
with two fields: the field <code>coeff</code> is the vector made of the
coefficients of the linear combination, and the field <code>nu</code> is the
list of partitions defining the Schur polynomials of the linear combination
given as integer vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(jack)
LRskew(lambda = c(4, 2, 1), mu = c(3, 1))
</code></pre>

<hr>
<h2 id='MSF'>Evaluation of monomial symmetric functions</h2><span id='topic+MSF'></span>

<h3>Description</h3>

<p>Evaluates a monomial symmetric function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSF(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSF_+3A_x">x</code></td>
<td>
<p>a numeric vector or a <code><a href="gmp.html#topic+bigq">bigq</a></code> vector</p>
</td></tr>
<tr><td><code id="MSF_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number if <code>x</code> is numeric, a <code>bigq</code> rational number
if <code>x</code> is a <code>bigq</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 5/2)
lambda &lt;- c(3, 1)
MSF(x, lambda)
library(gmp)
x &lt;- c(as.bigq(1), as.bigq(2), as.bigq(5,2))
MSF(x, lambda)
</code></pre>

<hr>
<h2 id='Schur'>Evaluation of Schur polynomial - C++ implementation</h2><span id='topic+Schur'></span>

<h3>Description</h3>

<p>Evaluates the Schur polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Schur(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Schur_+3A_x">x</code></td>
<td>
<p>values of the variables, a vector of <code>bigq</code> numbers, or a
vector that can be coerced as such (e.g. <code>c("2", "5/3")</code>)</p>
</td></tr>
<tr><td><code id="Schur_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bigq</code> number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Schur(c("1", "3/2", "-2/3"), lambda = c(3, 1))
</code></pre>

<hr>
<h2 id='SchurPol'>Schur polynomial - C++ implementation</h2><span id='topic+SchurPol'></span>

<h3>Description</h3>

<p>Returns the Schur polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SchurPol(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SchurPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="SchurPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( schur &lt;- SchurPol(3, lambda = c(3, 1)) )
schur == JackPol(3, lambda = c(3, 1), alpha = "1", which = "P")
</code></pre>

<hr>
<h2 id='SchurPolR'>Schur polynomial</h2><span id='topic+SchurPolR'></span>

<h3>Description</h3>

<p>Returns the Schur polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SchurPolR(n, lambda, algorithm = "DK", basis = "canonical", exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SchurPolR_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="SchurPolR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="SchurPolR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> or <code>"naive"</code></p>
</td></tr>
<tr><td><code id="SchurPolR_+3A_basis">basis</code></td>
<td>
<p>the polynomial basis for <code>algorithm = "naive"</code>,
either <code>"canonical"</code> or <code>"MSF"</code> (monomial symmetric functions);
for <code>algorithm = "DK"</code> the canonical basis is always used and
this parameter is ignored</p>
</td></tr>
<tr><td><code id="SchurPolR_+3A_exact">exact</code></td>
<td>
<p>logical, whether to use exact arithmetic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mvp</code> multivariate polynomial (see <a href="mvp.html#topic+mvp-package">mvp-package</a>),
or a <code>qspray</code> multivariate polynomial if
<code>exact = TRUE</code> and <code>algorithm = "DK"</code>, or a
character string if <code>basis = "MSF"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SchurPolR(3, lambda = c(3,1), algorithm = "naive")
SchurPolR(3, lambda = c(3,1), algorithm = "DK")
SchurPolR(3, lambda = c(3,1), algorithm = "DK", exact = FALSE)
SchurPolR(3, lambda = c(3,1), algorithm = "naive", basis = "MSF")
</code></pre>

<hr>
<h2 id='SchurR'>Evaluation of Schur polynomials</h2><span id='topic+SchurR'></span>

<h3>Description</h3>

<p>Evaluates a Schur polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SchurR(x, lambda, algorithm = "DK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SchurR_+3A_x">x</code></td>
<td>
<p>numeric or complex vector or <a href="gmp.html#topic+bigq">bigq</a> vector</p>
</td></tr>
<tr><td><code id="SchurR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="SchurR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> (Demmel-Koev)
or <code>"naive"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex scalar or a <code>bigq</code> rational number.
</p>


<h3>References</h3>

<p>J. Demmel &amp; P. Koev.
<em>Accurate and efficient evaluation of Schur and Jack functions</em>.
Mathematics of computations, vol. 75, n. 253, 223-229, 2005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SchurPolR">SchurPolR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2,3,4)
SchurR(x, c(2,1,1))
prod(x) * sum(x)
</code></pre>

<hr>
<h2 id='SkewSchurPol'>Skew Schur polynomial</h2><span id='topic+SkewSchurPol'></span>

<h3>Description</h3>

<p>Returns the skew Schur polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SkewSchurPol(n, lambda, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SkewSchurPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="SkewSchurPol_+3A_lambda">lambda</code>, <code id="SkewSchurPol_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation is performed with the help of the
Littlewood-Richardson rule (see <code><a href="#topic+LRskew">LRskew</a></code>).
</p>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial, the skew Schur polynomial
associated to the skew partition defined by <code>lambda</code> and <code>mu</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SkewSchurPol(3, lambda = c(3, 2, 1), mu = c(1, 1))
</code></pre>

<hr>
<h2 id='Zonal'>Evaluation of zonal polynomial - C++ implementation</h2><span id='topic+Zonal'></span>

<h3>Description</h3>

<p>Evaluates the zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zonal(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Zonal_+3A_x">x</code></td>
<td>
<p>values of the variables, a vector of <code>bigq</code> numbers, or a
vector that can be coerced as such (e.g. <code>c("2", "5/3")</code>)</p>
</td></tr>
<tr><td><code id="Zonal_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bigq</code> number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Zonal(c("1", "3/2", "-2/3"), lambda = c(3, 1))
</code></pre>

<hr>
<h2 id='ZonalPol'>Zonal polynomial - C++ implementation</h2><span id='topic+ZonalPol'></span>

<h3>Description</h3>

<p>Returns the zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalPol(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZonalPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="ZonalPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( zonal &lt;- ZonalPol(3, lambda = c(3, 1)) )
zonal == JackPol(3, lambda = c(3, 1), alpha = "2", which = "C")
</code></pre>

<hr>
<h2 id='ZonalPolR'>Zonal polynomial</h2><span id='topic+ZonalPolR'></span>

<h3>Description</h3>

<p>Returns the zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalPolR(n, lambda, algorithm = "DK", basis = "canonical", exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZonalPolR_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="ZonalPolR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="ZonalPolR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> or <code>"naive"</code></p>
</td></tr>
<tr><td><code id="ZonalPolR_+3A_basis">basis</code></td>
<td>
<p>the polynomial basis for <code>algorithm = "naive"</code>,
either <code>"canonical"</code> or <code>"MSF"</code> (monomial symmetric functions);
for <code>algorithm = "DK"</code> the canonical basis is always used and
this parameter is ignored</p>
</td></tr>
<tr><td><code id="ZonalPolR_+3A_exact">exact</code></td>
<td>
<p>logical, whether to get rational coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mvp</code> multivariate polynomial (see <a href="mvp.html#topic+mvp-package">mvp-package</a>),
or a <code>qspray</code> multivariate polynomial if
<code>exact = TRUE</code> and <code>algorithm = "DK"</code>, or a
character string if <code>basis = "MSF"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ZonalPolR(3, lambda = c(3,1), algorithm = "naive")
ZonalPolR(3, lambda = c(3,1), algorithm = "DK")
ZonalPolR(3, lambda = c(3,1), algorithm = "DK", exact = FALSE)
ZonalPolR(3, lambda = c(3,1), algorithm = "naive", basis = "MSF")
</code></pre>

<hr>
<h2 id='ZonalQ'>Evaluation of zonal quaternionic polynomial - C++ implementation</h2><span id='topic+ZonalQ'></span>

<h3>Description</h3>

<p>Evaluates the zonal quaternionic polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalQ(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZonalQ_+3A_x">x</code></td>
<td>
<p>values of the variables, a vector of <code>bigq</code> numbers, or a
vector that can be coerced as such (e.g. <code>c("2", "5/3")</code>)</p>
</td></tr>
<tr><td><code id="ZonalQ_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bigq</code> number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ZonalQ(c("1", "3/2", "-2/3"), lambda = c(3, 1))
</code></pre>

<hr>
<h2 id='ZonalQPol'>Quaternionic zonal polynomial - C++ implementation</h2><span id='topic+ZonalQPol'></span>

<h3>Description</h3>

<p>Returns the quaternionic zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalQPol(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZonalQPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="ZonalQPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( zonalQ &lt;- ZonalQPol(3, lambda = c(3, 1)) )
zonalQ == JackPol(3, lambda = c(3, 1), alpha = "1/2", which = "C")
</code></pre>

<hr>
<h2 id='ZonalQPolR'>Quaternionic zonal polynomial</h2><span id='topic+ZonalQPolR'></span>

<h3>Description</h3>

<p>Returns the quaternionic (or symplectic) zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalQPolR(n, lambda, algorithm = "DK", basis = "canonical", exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZonalQPolR_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="ZonalQPolR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="ZonalQPolR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> or <code>"naive"</code></p>
</td></tr>
<tr><td><code id="ZonalQPolR_+3A_basis">basis</code></td>
<td>
<p>the polynomial basis for <code>algorithm = "naive"</code>,
either <code>"canonical"</code> or <code>"MSF"</code> (monomial symmetric functions);
for <code>algorithm = "DK"</code> the canonical basis is always used and
this parameter is ignored</p>
</td></tr>
<tr><td><code id="ZonalQPolR_+3A_exact">exact</code></td>
<td>
<p>logical, whether to get rational coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mvp</code> multivariate polynomial (see <a href="mvp.html#topic+mvp-package">mvp-package</a>),
or a <code>qspray</code> multivariate polynomial if
<code>exact = TRUE</code> and <code>algorithm = "DK"</code>, or a
character string if <code>basis = "MSF"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ZonalQPolR(3, lambda = c(3,1), algorithm = "naive")
ZonalQPolR(3, lambda = c(3,1), algorithm = "DK")
ZonalQPolR(3, lambda = c(3,1), algorithm = "DK", exact = FALSE)
ZonalQPolR(3, lambda = c(3,1), algorithm = "naive", basis = "MSF")
</code></pre>

<hr>
<h2 id='ZonalQR'>Evaluation of quaternionic zonal polynomials</h2><span id='topic+ZonalQR'></span>

<h3>Description</h3>

<p>Evaluates a quaternionic (or symplectic) zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalQR(x, lambda, algorithm = "DK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZonalQR_+3A_x">x</code></td>
<td>
<p>numeric or complex vector or <a href="gmp.html#topic+bigq">bigq</a> vector</p>
</td></tr>
<tr><td><code id="ZonalQR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="ZonalQR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> (Demmel-Koev)
or <code>"naive"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex scalar or a <code>bigq</code> rational number.
</p>


<h3>References</h3>

<p>F. Li, Y. Xue. <em>Zonal polynomials and hypergeometric
functions of quaternion matrix argument</em>.
Comm. Statist. Theory Methods, 38 (8), 1184-1206, 2009
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ZonalQPolR">ZonalQPolR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- c(2,2)
ZonalQR(c(3,1), lambda)
ZonalQR(c(gmp::as.bigq(3),gmp::as.bigq(1)), lambda)
##
x &lt;- c(3,1)
ZonalQR(x, c(1,1)) + ZonalQR(x, 2) # sum(x)^2
ZonalQR(x, 3) + ZonalQR(x, c(2,1)) + ZonalQR(x, c(1,1,1)) # sum(x)^3
</code></pre>

<hr>
<h2 id='ZonalR'>Evaluation of zonal polynomials</h2><span id='topic+ZonalR'></span>

<h3>Description</h3>

<p>Evaluates a zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalR(x, lambda, algorithm = "DK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZonalR_+3A_x">x</code></td>
<td>
<p>numeric or complex vector or <a href="gmp.html#topic+bigq">bigq</a> vector</p>
</td></tr>
<tr><td><code id="ZonalR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="ZonalR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> (Demmel-Koev)
or <code>"naive"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex scalar or a <code>bigq</code> rational number.
</p>


<h3>References</h3>


<ul>
<li><p> Robb Muirhead. <em>Aspects of multivariate statistical theory</em>.
Wiley series in probability and mathematical statistics.
Probability and mathematical statistics.
John Wiley &amp; Sons, New York, 1982.
</p>
</li>
<li><p> Akimichi Takemura. <em>Zonal Polynomials</em>,
volume 4 of Institute of Mathematical Statistics Lecture Notes –
Monograph Series.
Institute of Mathematical Statistics, Hayward, CA, 1984.
</p>
</li>
<li><p> Lin Jiu &amp; Christoph Koutschan.
<em>Calculation and Properties of Zonal Polynomials</em>.
<a href="http://koutschan.de/data/zonal/">http://koutschan.de/data/zonal/</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ZonalPolR">ZonalPolR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- c(2,2)
ZonalR(c(1,1), lambda)
ZonalR(c(gmp::as.bigq(1),gmp::as.bigq(1)), lambda)
##
x &lt;- c(3,1)
ZonalR(x, c(1,1)) + ZonalR(x, 2) # sum(x)^2
ZonalR(x, 3) + ZonalR(x, c(2,1)) + ZonalR(x, c(1,1,1)) # sum(x)^3
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
