<!DOCTYPE html><html lang="en"><head><title>Help for package jack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ESF'><p>Evaluation of elementary symmetric functions</p></a></li>
<li><a href='#factorialSchurPol'><p>Factorial Schur polynomial</p></a></li>
<li><a href='#flaggedSchurPol'><p>Flagged Schur polynomial</p></a></li>
<li><a href='#flaggedSkewSchurPol'><p>Flagged skew Schur polynomial</p></a></li>
<li><a href='#HallLittlewoodPol'><p>Hall-Littlewood polynomial</p></a></li>
<li><a href='#HallPolynomials'><p>Hall polynomials</p></a></li>
<li><a href='#Jack'><p>Evaluation of Jack polynomial - C++ implementation</p></a></li>
<li><a href='#JackCombination'><p>Symmetric polynomial in terms of Jack polynomials</p></a></li>
<li><a href='#JackPol'><p>Jack polynomial - C++ implementation</p></a></li>
<li><a href='#JackPolR'><p>Jack polynomial</p></a></li>
<li><a href='#JackR'><p>Evaluation of Jack polynomials</p></a></li>
<li><a href='#JackSymPol'><p>Jack polynomial with symbolic Jack parameter</p></a></li>
<li><a href='#KostaFoulkesPolynomial'><p>Kostka-Foulkes polynomial</p></a></li>
<li><a href='#KostkaJackNumbers'><p>Kostka-Jack numbers with a given Jack parameter</p></a></li>
<li><a href='#KostkaJackNumbersWithGivenLambda'><p>Kostka-Jack numbers with a given partition <code class="reqn">\lambda</code></p></a></li>
<li><a href='#LRmult'><p>Littlewood-Richardson rule for multiplication</p></a></li>
<li><a href='#LRskew'><p>Littlewood-Richardson rule for skew Schur polynomial</p></a></li>
<li><a href='#MacdonaldPol'><p>Macdonald polynomial</p></a></li>
<li><a href='#modifiedMacdonaldPol'><p>Modified Macdonald polynomial</p></a></li>
<li><a href='#MSF'><p>Evaluation of monomial symmetric functions</p></a></li>
<li><a href='#qtKostkaPolynomials'><p>qt-Kostka polynomials</p></a></li>
<li><a href='#qtSkewKostkaPolynomials'><p>Skew qt-Kostka polynomials</p></a></li>
<li><a href='#Schur'><p>Evaluation of Schur polynomial - C++ implementation</p></a></li>
<li><a href='#SchurCombination'><p>Symmetric polynomial in terms of the Schur polynomials</p></a></li>
<li><a href='#SchurPol'><p>Schur polynomial - C++ implementation</p></a></li>
<li><a href='#SchurPolR'><p>Schur polynomial</p></a></li>
<li><a href='#SchurR'><p>Evaluation of Schur polynomials</p></a></li>
<li><a href='#SkewFactorialSchurPol'><p>Skew factorial Schur polynomial</p></a></li>
<li><a href='#SkewHallLittlewoodPol'><p>Skew Hall-Littlewood polynomial</p></a></li>
<li><a href='#SkewJackPol'><p>Skew Jack polynomial</p></a></li>
<li><a href='#SkewJackSymPol'><p>Skew Jack polynomial with symbolic Jack parameter</p></a></li>
<li><a href='#SkewKostkaFoulkesPolynomial'><p>Skew Kostka-Foulkes polynomial</p></a></li>
<li><a href='#skewKostkaJackNumbers'><p>Skew Kostka-Jack numbers with given Jack parameter</p></a></li>
<li><a href='#SkewMacdonaldPol'><p>Skew Macdonald polynomial</p></a></li>
<li><a href='#SkewSchurPol'><p>Skew Schur polynomial</p></a></li>
<li><a href='#symbolicJackCombination'><p>Symmetric polynomial in terms of symbolic Jack polynomials</p></a></li>
<li><a href='#symbolicKostkaJackNumbers'><p>Kostka-Jack numbers with symbolic Jack parameter</p></a></li>
<li><a href='#symbolicKostkaJackNumbersWithGivenLambda'><p>Kostka-Jack numbers with symbolic Jack parameter for a</p>
given <code class="reqn">\lambda</code></a></li>
<li><a href='#symbolicSkewKostkaJackNumbers'><p>Skew Kostka-Jack numbers with symbolic Jack parameter</p></a></li>
<li><a href='#tSchurPol'><p>t-Schur polynomial</p></a></li>
<li><a href='#tSkewSchurPol'><p>Skew t-Schur polynomial</p></a></li>
<li><a href='#Zonal'><p>Evaluation of zonal polynomial - C++ implementation</p></a></li>
<li><a href='#ZonalPol'><p>Zonal polynomial - C++ implementation</p></a></li>
<li><a href='#ZonalPolR'><p>Zonal polynomial</p></a></li>
<li><a href='#ZonalQ'><p>Evaluation of zonal quaternionic polynomial - C++ implementation</p></a></li>
<li><a href='#ZonalQPol'><p>Quaternionic zonal polynomial - C++ implementation</p></a></li>
<li><a href='#ZonalQPolR'><p>Quaternionic zonal polynomial</p></a></li>
<li><a href='#ZonalQR'><p>Evaluation of quaternionic zonal polynomials</p></a></li>
<li><a href='#ZonalR'><p>Evaluation of zonal polynomials</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Jack, Zonal, Schur, and Other Symmetric Polynomials</td>
</tr>
<tr>
<td>Version:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-29</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Laurent &lt;laurent_step@outlook.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Schur polynomials appear in combinatorics and zonal
    polynomials appear in random matrix theory. They are particular cases
    of Jack polynomials. This package allows to compute these polynomials
    and other symmetric multivariate polynomials: flagged Schur
    polynomials, factorial Schur polynomials, t-Schur polynomials,
    Hall-Littlewood polynomials, Macdonald polynomials, and modified
    Macdonald polynomials. In addition, it can compute the Kostka-Jack
    numbers, the Kostka-Foulkes polynomials, the Kostka-Macdonald
    polynomials, and the Hall polynomials.  Mainly based on Demmel &amp;
    Koev's paper (2006) &lt;<a href="https://doi.org/10.1090%2FS0025-5718-05-01780-1">doi:10.1090/S0025-5718-05-01780-1</a>&gt; and
    Macdonald's book (1995) &lt;<a href="https://doi.org/10.1093%2Foso%2F9780198534891.003.0001">doi:10.1093/oso/9780198534891.003.0001</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stla/jackR">https://github.com/stla/jackR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stla/jackR/issues">https://github.com/stla/jackR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>qspray (&ge; 3.1.0), ratioOfQsprays (&ge; 1.1.0), symbolicQspray
(&ge; 1.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DescTools, gmp, methods, multicool, mvp, partitions,
RationalMatrix, Rcpp, spray, syt (&ge; 0.5.0), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, qspray, ratioOfQsprays, Rcpp, RcppCGAL, symbolicQspray</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17, gmp, mpfr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-29 17:12:59 UTC; User</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Laurent [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-29 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ESF'>Evaluation of elementary symmetric functions</h2><span id='topic+ESF'></span>

<h3>Description</h3>

<p>Evaluates an elementary symmetric function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESF(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ESF_+3A_x">x</code></td>
<td>
<p>a numeric vector or a <code><a href="gmp.html#topic+bigq">bigq</a></code> vector</p>
</td></tr>
<tr><td><code id="ESF_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number if <code>x</code> is numeric, a <code>bigq</code> rational number
if <code>x</code> is a <code>bigq</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 5/2)
lambda &lt;- c(3, 1)
ESF(x, lambda)
library(gmp)
x &lt;- c(as.bigq(1), as.bigq(2), as.bigq(5,2))
ESF(x, lambda)
</code></pre>

<hr>
<h2 id='factorialSchurPol'>Factorial Schur polynomial</h2><span id='topic+factorialSchurPol'></span>

<h3>Description</h3>

<p>Computes a factorial Schur polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorialSchurPol(n, lambda, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="factorialSchurPol_+3A_n">n</code></td>
<td>
<p>number of variables</p>
</td></tr>
<tr><td><code id="factorialSchurPol_+3A_lambda">lambda</code></td>
<td>
<p>integer partition</p>
</td></tr>
<tr><td><code id="factorialSchurPol_+3A_a">a</code></td>
<td>
<p>vector of <code>bigq</code> numbers, or vector of elements coercible
to <code>bigq</code> numbers; this vector corresponds to the sequence denoted by
<code class="reqn">a</code> in the
<a href="https://www.kurims.kyoto-u.ac.jp/EMIS/journals/SLC/opapers/s28macdonald.pdf">reference paper</a>,
section <strong>6th Variation</strong> (in this paper <code class="reqn">a</code> is a doubly
infinite sequence, but in the case of a non-skew partition, the
non-positive indices of this sequence are not involved); the length of
this vector must be large enough (an error will be thrown if it is too
small) but it is not easy to know the minimal possible length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> polynomial.
</p>


<h3>References</h3>

<p>I.G. Macdonald.
<em>Schur functions: theme and variations</em>.
Publ. IRMA Strasbourg, 1992.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for a=c(0, 0, ...), the factorial Schur polynomial is the Schur polynomial
n &lt;- 3
lambda &lt;- c(2, 2, 2)
a &lt;- c(0, 0, 0, 0)
factorialSchurPoly &lt;- factorialSchurPol(n, lambda, a)
schurPoly &lt;- SchurPol(n, lambda)
factorialSchurPoly == schurPoly # should be TRUE
</code></pre>

<hr>
<h2 id='flaggedSchurPol'>Flagged Schur polynomial</h2><span id='topic+flaggedSchurPol'></span>

<h3>Description</h3>

<p>Computes a flagged Schur polynomial (which is not symmetric
in general). See
<a href="https://math.mit.edu/~apost/papers/degreeschub.pdf">Chains in the Bruhat order</a>
for the definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flaggedSchurPol(lambda, a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flaggedSchurPol_+3A_lambda">lambda</code></td>
<td>
<p>integer partition</p>
</td></tr>
<tr><td><code id="flaggedSchurPol_+3A_a">a</code>, <code id="flaggedSchurPol_+3A_b">b</code></td>
<td>
<p>lower bounds and upper bounds, weakly increasing vectors of
integers; <code>lambda</code>, <code>a</code> and <code>b</code> must have the same length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- c(3, 2, 2)
n &lt;- 3
a &lt;- c(1, 1, 1); b &lt;- c(n, n, n)
flaggedPoly &lt;- flaggedSchurPol(lambda, a, b)
poly &lt;- SchurPol(n, lambda)
flaggedPoly == poly # should be TRUE
</code></pre>

<hr>
<h2 id='flaggedSkewSchurPol'>Flagged skew Schur polynomial</h2><span id='topic+flaggedSkewSchurPol'></span>

<h3>Description</h3>

<p>Computes a flagged skew Schur polynomial (which is not symmetric
in general). See
<a href="https://www.symmetricfunctions.com/schurFlagged.htm#schurFlagged">Schur polynomials (flagged)</a>
for the definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flaggedSkewSchurPol(lambda, mu, a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flaggedSkewSchurPol_+3A_lambda">lambda</code>, <code id="flaggedSkewSchurPol_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
<tr><td><code id="flaggedSkewSchurPol_+3A_a">a</code>, <code id="flaggedSkewSchurPol_+3A_b">b</code></td>
<td>
<p>lower bounds and upper bounds, weakly increasing vectors of
integers; <code>lambda</code>, <code>a</code> and <code>b</code> must have the same length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- c(3, 2, 2); mu &lt;- c(2, 1)
n &lt;- 3
a &lt;- c(1, 1, 1); b &lt;- c(n, n, n)
flaggedPoly &lt;- flaggedSkewSchurPol(lambda, mu, a, b)
poly &lt;- SkewSchurPol(n, lambda, mu)
flaggedPoly == poly # should be TRUE
</code></pre>

<hr>
<h2 id='HallLittlewoodPol'>Hall-Littlewood polynomial</h2><span id='topic+HallLittlewoodPol'></span>

<h3>Description</h3>

<p>Hall-Littlewood polynomial of a given partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HallLittlewoodPol(n, lambda, which = "P")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HallLittlewoodPol_+3A_n">n</code></td>
<td>
<p>number of variables</p>
</td></tr>
<tr><td><code id="HallLittlewoodPol_+3A_lambda">lambda</code></td>
<td>
<p>integer partition</p>
</td></tr>
<tr><td><code id="HallLittlewoodPol_+3A_which">which</code></td>
<td>
<p>which Hall-Littlewood polynomial, <code>"P"</code> or <code>"Q"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Hall-Littlewood polynomial in <code>n</code> variables of the
integer partition <code>lambda</code>. This is a <code>symbolicQspray</code>
polynomial with a unique parameter usually denoted by <code class="reqn">t</code> and
its coefficients are polynomial in this parameter. When substituting
<code class="reqn">t</code> with <code class="reqn">0</code> in the Hall-Littlewood <code class="reqn">P</code>-polynomials, one
obtains the Schur polynomials.
</p>

<hr>
<h2 id='HallPolynomials'>Hall polynomials</h2><span id='topic+HallPolynomials'></span>

<h3>Description</h3>

<p>Hall polynomials <code class="reqn">g^{\lambda}_{\mu,\nu}(t)</code> for given
integer partitions <code class="reqn">\mu</code> and <code class="reqn">\nu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HallPolynomials(mu, nu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HallPolynomials_+3A_mu">mu</code>, <code id="HallPolynomials_+3A_nu">nu</code></td>
<td>
<p>integer partitions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists. Each of these lists has two elements: an integer
partition <code class="reqn">\lambda</code> in the field <code>lambda</code>, and a univariate
<code>qspray</code> polynomial in the field <code>polynomial</code>, the Hall
polynomial <code class="reqn">g^{\lambda}_{\mu,\nu}(t)</code>. Every coefficient of a
Hall polynomial is an integer.
</p>


<h3>Note</h3>

<p>This function is slow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HallPolynomials(c(2, 1), c(1, 1))
</code></pre>

<hr>
<h2 id='Jack'>Evaluation of Jack polynomial - C++ implementation</h2><span id='topic+Jack'></span>

<h3>Description</h3>

<p>Evaluates a Jack polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jack(x, lambda, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Jack_+3A_x">x</code></td>
<td>
<p>values of the variables, a vector of <code>bigq</code> numbers, or a
vector that can be coerced as such (e.g. <code>c("2", "5/3")</code>)</p>
</td></tr>
<tr><td><code id="Jack_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="Jack_+3A_alpha">alpha</code></td>
<td>
<p>rational number, given as a string such as
<code>"2/3"</code> or as a <code>bigq</code> number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bigq</code> number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Jack(c("1", "3/2", "-2/3"), lambda = c(3, 1), alpha = "1/4")
</code></pre>

<hr>
<h2 id='JackCombination'>Symmetric polynomial in terms of Jack polynomials</h2><span id='topic+JackCombination'></span>

<h3>Description</h3>

<p>Expression of a symmetric polynomial as a linear combination
of Jack polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackCombination(qspray, alpha, which = "J", check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JackCombination_+3A_qspray">qspray</code></td>
<td>
<p>a <code>qspray</code> object or a <code>symbolicQspray</code> object
defining a symmetric polynomial</p>
</td></tr>
<tr><td><code id="JackCombination_+3A_alpha">alpha</code></td>
<td>
<p>Jack parameter, must be coercible to a <code>bigq</code> number</p>
</td></tr>
<tr><td><code id="JackCombination_+3A_which">which</code></td>
<td>
<p>which Jack polynomials, <code>"J"</code>, <code>"P"</code>, <code>"Q"</code> or
<code>"C"</code></p>
</td></tr>
<tr><td><code id="JackCombination_+3A_check">check</code></td>
<td>
<p>Boolean, whether to check the symmetry of <code>qspray</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the combination. Each element of this list is a
list with two elements: <code>coeff</code>, which is a <code>bigq</code> number if
<code>qspray</code> is a <code>qspray</code> polynomial or a <code>ratioOfQsprays</code> if
<code>qspray</code> is a <code>symbolicQspray</code> polynomial, and the second
element of the list is <code>lambda</code>, an integer partition; then this list
corresponds to the term <code>coeff * JackPol(n, lambda, alpha, which)</code>,
where <code>n</code> is the number of variables in the symmetric polynomial
<code>qspray</code>.
</p>

<hr>
<h2 id='JackPol'>Jack polynomial - C++ implementation</h2><span id='topic+JackPol'></span>

<h3>Description</h3>

<p>Returns a Jack polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackPol(n, lambda, alpha, which = "J")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JackPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="JackPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="JackPol_+3A_alpha">alpha</code></td>
<td>
<p>rational number, given as a string such as
<code>"2/3"</code> or as a <code>bigq</code> number</p>
</td></tr>
<tr><td><code id="JackPol_+3A_which">which</code></td>
<td>
<p>which Jack polynomial, <code>"J"</code>, <code>"P"</code>, <code>"Q"</code>,
or <code>"C"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JackPol(3, lambda = c(3, 1), alpha = "2/5")
</code></pre>

<hr>
<h2 id='JackPolR'>Jack polynomial</h2><span id='topic+JackPolR'></span>

<h3>Description</h3>

<p>Returns the Jack polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackPolR(n, lambda, alpha, algorithm = "DK", basis = "canonical", which = "J")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JackPolR_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="JackPolR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="JackPolR_+3A_alpha">alpha</code></td>
<td>
<p>parameter of the Jack polynomial, a number, possibly (and
preferably) a <code><a href="gmp.html#topic+bigq">bigq</a></code> rational number</p>
</td></tr>
<tr><td><code id="JackPolR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> or <code>"naive"</code></p>
</td></tr>
<tr><td><code id="JackPolR_+3A_basis">basis</code></td>
<td>
<p>the polynomial basis for <code>algorithm = "naive"</code>,
either <code>"canonical"</code> or <code>"MSF"</code> (monomial symmetric functions);
for <code>algorithm = "DK"</code> the canonical basis is always used and
this parameter is ignored</p>
</td></tr>
<tr><td><code id="JackPolR_+3A_which">which</code></td>
<td>
<p>which Jack polynomial, <code>"J"</code>, <code>"P"</code> or <code>"Q"</code>;
this argument is taken into account <strong>only</strong> if <code>alpha</code> is a
<code>bigq</code> number and <code>algorithm = "DK"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mvp</code> multivariate polynomial (see <a href="mvp.html#topic+mvp-package">mvp-package</a>),
or a <code>qspray</code> multivariate polynomial if <code>alpha</code>
is a <code>bigq</code> rational number and <code>algorithm = "DK"</code>, or a
character string if <code>basis = "MSF"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JackPolR(3, lambda = c(3,1), alpha = gmp::as.bigq(2,3),
                  algorithm = "naive")
JackPolR(3, lambda = c(3,1), alpha = 2/3, algorithm = "DK")
JackPolR(3, lambda = c(3,1), alpha = gmp::as.bigq(2,3), algorithm = "DK")
JackPolR(3, lambda = c(3,1), alpha= gmp::as.bigq(2,3),
        algorithm = "naive", basis = "MSF")
# when the Jack polynomial is a `qspray` object, you can
# evaluate it with `qspray::evalQspray`:
jack &lt;- JackPolR(3, lambda = c(3, 1), alpha = gmp::as.bigq(2))
evalQspray(jack, c("1", "1/2", "3"))
</code></pre>

<hr>
<h2 id='JackR'>Evaluation of Jack polynomials</h2><span id='topic+JackR'></span>

<h3>Description</h3>

<p>Evaluates a Jack polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackR(x, lambda, alpha, algorithm = "DK")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JackR_+3A_x">x</code></td>
<td>
<p>numeric or complex vector or <code><a href="gmp.html#topic+bigq">bigq</a></code> vector</p>
</td></tr>
<tr><td><code id="JackR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="JackR_+3A_alpha">alpha</code></td>
<td>
<p>ordinary number or <code>bigq</code> rational number</p>
</td></tr>
<tr><td><code id="JackR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> (Demmel-Koev)
or <code>"naive"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex scalar or a <code>bigq</code> rational number.
</p>


<h3>References</h3>


<ul>
<li><p> I.G. Macdonald.
<em>Symmetric Functions and Hall Polynomials</em>.
Oxford Mathematical Monographs.
The Clarendon Press Oxford University Press,
New York, second edition, 1995.
</p>
</li>
<li><p> J. Demmel &amp; P. Koev.
<em>Accurate and efficient evaluation of Schur and Jack functions</em>.
Mathematics of computations, vol. 75, n. 253, 223-229, 2005.
</p>
</li>
<li> <p><em>Jack polynomials</em>.
<a href="https://www.symmetricfunctions.com/jack.htm">https://www.symmetricfunctions.com/jack.htm</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+JackPolR">JackPolR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- c(2,1,1)
JackR(c(1/2, 2/3, 1), lambda, alpha = 3)
# exact value:
JackR(c(gmp::as.bigq(1,2), gmp::as.bigq(2,3), gmp::as.bigq(1)), lambda,
     alpha = gmp::as.bigq(3))
</code></pre>

<hr>
<h2 id='JackSymPol'>Jack polynomial with symbolic Jack parameter</h2><span id='topic+JackSymPol'></span>

<h3>Description</h3>

<p>Returns the Jack polynomial with a symbolic Jack parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackSymPol(n, lambda, which = "J")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JackSymPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="JackSymPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="JackSymPol_+3A_which">which</code></td>
<td>
<p>which Jack polynomial, <code>"J"</code>, <code>"P"</code>, <code>"Q"</code>,
or <code>"C"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>symbolicQspray</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JackSymPol(3, lambda = c(3, 1))
</code></pre>

<hr>
<h2 id='KostaFoulkesPolynomial'>Kostka-Foulkes polynomial</h2><span id='topic+KostaFoulkesPolynomial'></span>

<h3>Description</h3>

<p>Kostka-Foulkes polynomial for two given partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KostaFoulkesPolynomial(lambda, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KostaFoulkesPolynomial_+3A_lambda">lambda</code>, <code id="KostaFoulkesPolynomial_+3A_mu">mu</code></td>
<td>
<p>integer partitions; in order for the Kostka-Foulkes
polynomial to be non-zero, a necessary condition is that <code>lambda</code>
and <code>mu</code> have the same weight; more precisely, <code>mu</code> must
be dominated by <code>lambda</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Kostka-Foulkes polynomial associated to <code>lambda</code> and
<code>mu</code>. This is a univariate <code>qspray</code> polynomial whose value
at <code>1</code> is the Kostka number associated to <code>lambda</code> and
<code>mu</code>.
</p>

<hr>
<h2 id='KostkaJackNumbers'>Kostka-Jack numbers with a given Jack parameter</h2><span id='topic+KostkaJackNumbers'></span>

<h3>Description</h3>

<p>Kostka numbers with Jack parameter, or Kostka-Jack numbers,
for partitions of a given weight and a given Jack parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KostkaJackNumbers(n, alpha = "1")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KostkaJackNumbers_+3A_n">n</code></td>
<td>
<p>positive integer, the weight of the partitions</p>
</td></tr>
<tr><td><code id="KostkaJackNumbers_+3A_alpha">alpha</code></td>
<td>
<p>the Jack parameter, a <code>bigq</code> number or an object coercible
to a <code>bigq</code> number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kostka-Jack number <code class="reqn">K_{\lambda,\mu}(\alpha)</code> is the
coefficient of the monomial symmetric polynomial <code class="reqn">m_\mu</code> in the
expression of the <code class="reqn">P</code>-Jack polynomial <code class="reqn">P_\lambda(\alpha)</code> as a
linear combination of monomial symmetric polynomials. For <code class="reqn">\alpha=1</code>
it is the ordinary Kostka number.
</p>


<h3>Value</h3>

<p>The matrix of the Kostka-Jack numbers <code class="reqn">K_{\lambda,\mu}(\alpha)</code>
given as character strings representing integers or fractions.
The row names of this matrix encode the partitions <code class="reqn">\lambda</code> and
the column names encode the partitions <code class="reqn">\mu</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KostkaJackNumbersWithGivenLambda">KostkaJackNumbersWithGivenLambda</a></code>,
<code><a href="#topic+symbolicKostkaJackNumbers">symbolicKostkaJackNumbers</a></code>,
<code><a href="#topic+skewKostkaJackNumbers">skewKostkaJackNumbers</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KostkaJackNumbers(4)
</code></pre>

<hr>
<h2 id='KostkaJackNumbersWithGivenLambda'>Kostka-Jack numbers with a given partition <code class="reqn">\lambda</code></h2><span id='topic+KostkaJackNumbersWithGivenLambda'></span>

<h3>Description</h3>

<p>Kostka numbers with Jack parameter, or Kostka-Jack numbers
<code class="reqn">K_{\lambda,\mu}(\alpha)</code> for a given Jack parameter <code class="reqn">\alpha</code>
and a given integer partition <code class="reqn">\lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KostkaJackNumbersWithGivenLambda(lambda, alpha, output = "vector")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KostkaJackNumbersWithGivenLambda_+3A_lambda">lambda</code></td>
<td>
<p>integer partition</p>
</td></tr>
<tr><td><code id="KostkaJackNumbersWithGivenLambda_+3A_alpha">alpha</code></td>
<td>
<p>the Jack parameter, a <code>bigq</code> number or anything coercible
to a <code>bigq</code> number</p>
</td></tr>
<tr><td><code id="KostkaJackNumbersWithGivenLambda_+3A_output">output</code></td>
<td>
<p>the format of the output, either <code>"vector"</code> or
<code>"list"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kostka-Jack number <code class="reqn">K_{\lambda,\mu}(\alpha)</code> is the
coefficient of the monomial symmetric polynomial <code class="reqn">m_\mu</code> in the
expression of the <code class="reqn">P</code>-Jack polynomial <code class="reqn">P_\lambda(\alpha)</code> as a
linear combination of monomial symmetric polynomials. For <code class="reqn">\alpha=1</code>
it is the ordinary Kostka number.
</p>


<h3>Value</h3>

<p>If <code>output="vector"</code>, this function returns a named vector.
This vector is made of the non-zero (i.e. positive) Kostka-Jack numbers
<code class="reqn">K_{\lambda,\mu}(\alpha)</code> given as character strings and its names
encode the partitions <code class="reqn">\mu</code>.
If <code>ouput="list"</code>, this function returns a list of lists.
Each of these lists has two
elements. The first one is named <code>mu</code> and is an integer
partition, and the second one is named <code>value</code> and is a <code>bigq</code>
rational number, the Kostka-Jack number <code class="reqn">K_{\lambda,\mu}(\alpha)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KostkaJackNumbers">KostkaJackNumbers</a></code>,
<code><a href="#topic+symbolicKostkaJackNumbersWithGivenLambda">symbolicKostkaJackNumbersWithGivenLambda</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KostkaJackNumbersWithGivenLambda(c(3, 2), alpha = "2")
</code></pre>

<hr>
<h2 id='LRmult'>Littlewood-Richardson rule for multiplication</h2><span id='topic+LRmult'></span>

<h3>Description</h3>

<p>Expression of the product of two Schur polynomials as a linear
combination of Schur polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRmult(mu, nu, output = "dataframe")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LRmult_+3A_mu">mu</code>, <code id="LRmult_+3A_nu">nu</code></td>
<td>
<p>integer partitions, given as vectors of decreasing integers</p>
</td></tr>
<tr><td><code id="LRmult_+3A_output">output</code></td>
<td>
<p>the type of the output, <code>"dataframe"</code> or <code>"list"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This computes the expression of the product of the two Schur
polynomials associated to <code>mu</code> and <code>nu</code> as a linear combination
of Schur polynomials. If <code>output="dataframe"</code>, the output is a
dataframe with two columns: the column <code>coeff</code> gives the coefficients
of this linear combination, these are positive integers, and the column
<code>lambda</code> gives the partitions defining the Schur polynomials of this
linear combination as character strings, e.g. the partition
<code>c(4, 3, 1)</code> is encoded by the character string <code>"[4, 3, 1]"</code>.
If <code>output="list"</code>, the output is a list
of lists with two elements. Each of these lists with two elements
corresponds to a term of the linear combination: the first element,
named <code>coeff</code>, is the coefficient, namely the Littlewood-Richardson
coefficient <code class="reqn">c^{\lambda}_{\mu,\nu}</code>, where <code class="reqn">\lambda</code> is the
integer partition given in the second element of the list, named
<code>lambda</code>, which defines the Schur polynomial of the
linear combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(jack)
mu &lt;- c(2, 1)
nu &lt;- c(3, 2, 1)
LR &lt;- LRmult(mu, nu, output = "list")
LRterms &lt;- lapply(LR, function(lr) {
  lr[["coeff"]] * SchurPol(3, lr[["lambda"]])
})
smu_times_snu &lt;- Reduce(`+`, LRterms)
smu_times_snu == SchurPol(3, mu) * SchurPol(3, nu) # should be TRUE
</code></pre>

<hr>
<h2 id='LRskew'>Littlewood-Richardson rule for skew Schur polynomial</h2><span id='topic+LRskew'></span>

<h3>Description</h3>

<p>Expression of a skew Schur polynomial as a linear
combination of Schur polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRskew(lambda, mu, output = "dataframe")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LRskew_+3A_lambda">lambda</code>, <code id="LRskew_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
<tr><td><code id="LRskew_+3A_output">output</code></td>
<td>
<p>the type of the output, <code>"dataframe"</code> or <code>"list"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This computes the expression of the skew Schur polynomial
associated to the skew partition defined by <code>lambda</code> and <code>mu</code>
as a linear combination of Schur polynomials. Every coefficient of this
linear combination is a positive integer, a so-called
Littlewood-Richardson coefficient.
If <code>output="dataframe"</code>,
the output is a dataframe with two columns: the column <code>coeff</code> gives
the coefficients of this linear combination, and the column <code>nu</code>
gives the partitions defining the Schur polynomials of this linear
combination as character strings, e.g. the partition <code>c(4, 3, 1)</code> is
given by <code>"[4, 3, 1]"</code>. If <code>output="list"</code>, the output is a list
of lists with two elements. Each of these lists with two elements
corresponds to a term of the linear combination: the first element, named
<code>coeff</code>, is the coefficient, namely the Littlewood-Richardson
coefficient <code class="reqn">c^{\lambda}_{\mu,\nu}</code>, where <code class="reqn">\nu</code> is the integer
partition given in the second element of the list, named
<code>nu</code>, which defines the Schur polynomial of the linear
combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(jack)
LRskew(lambda = c(4, 2, 1), mu = c(3, 1))
</code></pre>

<hr>
<h2 id='MacdonaldPol'>Macdonald polynomial</h2><span id='topic+MacdonaldPol'></span>

<h3>Description</h3>

<p>Returns the Macdonald polynomial associated to
the given integer partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MacdonaldPol(n, lambda, which = "P")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MacdonaldPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="MacdonaldPol_+3A_lambda">lambda</code></td>
<td>
<p>integer partition</p>
</td></tr>
<tr><td><code id="MacdonaldPol_+3A_which">which</code></td>
<td>
<p>which Macdonald polynomial, <code>"P"</code>, <code>"Q"</code>,
or <code>"J"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>symbolicQspray</code> multivariate polynomial, the
Macdonald polynomial associated to the integer partition
<code>lambda</code>. It has two parameters usually denoted by <code class="reqn">q</code>
and <code class="reqn">t</code>. Substituting <code class="reqn">q</code> with <code class="reqn">0</code> yields the
Hall-Littlewood polynomials.
</p>

<hr>
<h2 id='modifiedMacdonaldPol'>Modified Macdonald polynomial</h2><span id='topic+modifiedMacdonaldPol'></span>

<h3>Description</h3>

<p>Returns the modified Macdonald polynomial associated to a
given integer partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifiedMacdonaldPol(n, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifiedMacdonaldPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="modifiedMacdonaldPol_+3A_mu">mu</code></td>
<td>
<p>integer partition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>symbolicQspray</code> multivariate polynomial, the modified
Macdonald polynomial associated to the integer partition <code>mu</code>.
It has two parameters and its coefficients are polynomials in these
parameters.
</p>

<hr>
<h2 id='MSF'>Evaluation of monomial symmetric functions</h2><span id='topic+MSF'></span>

<h3>Description</h3>

<p>Evaluates a monomial symmetric function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSF(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSF_+3A_x">x</code></td>
<td>
<p>a numeric vector or a <code><a href="gmp.html#topic+bigq">bigq</a></code> vector</p>
</td></tr>
<tr><td><code id="MSF_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number if <code>x</code> is numeric, a <code>bigq</code> rational number
if <code>x</code> is a <code>bigq</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 5/2)
lambda &lt;- c(3, 1)
MSF(x, lambda)
library(gmp)
x &lt;- c(as.bigq(1), as.bigq(2), as.bigq(5,2))
MSF(x, lambda)
</code></pre>

<hr>
<h2 id='qtKostkaPolynomials'>qt-Kostka polynomials</h2><span id='topic+qtKostkaPolynomials'></span>

<h3>Description</h3>

<p>qt-Kostka polynomials, aka Kostka-Macdonald polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtKostkaPolynomials(mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtKostkaPolynomials_+3A_mu">mu</code></td>
<td>
<p>integer partition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The qt-Kostka polynomials are usually denoted by
<code class="reqn">K_{\lambda, \mu}(q, t)</code> where <code class="reqn">q</code> and <code class="reqn">t</code> denote the two
variables and <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> are two integer partitions.
One obtains the Kostka-Foulkes polynomials by substituting <code class="reqn">q</code>
with <code class="reqn">0</code>.
For a given partition <code class="reqn">\mu</code>, the function returns the
polynomials <code class="reqn">K_{\lambda, \mu}(q, t)</code> as <code>qspray</code> objects
for all partitions <code class="reqn">\lambda</code> of the same weight as <code class="reqn">\mu</code>. The
generated list is a list of lists with two elements: the integer
partition <code class="reqn">\lambda</code> and the polynomial.
</p>

<hr>
<h2 id='qtSkewKostkaPolynomials'>Skew qt-Kostka polynomials</h2><span id='topic+qtSkewKostkaPolynomials'></span>

<h3>Description</h3>

<p>Skew qt-Kostka polynomials associated to a given skew
partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtSkewKostkaPolynomials(lambda, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtSkewKostkaPolynomials_+3A_lambda">lambda</code>, <code id="qtSkewKostkaPolynomials_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The skew qt-Kostka polynomials are usually denoted by
<code class="reqn">K_{\lambda/\mu, \nu}(q, t)</code> where <code class="reqn">q</code> and <code class="reqn">t</code> denote the two
variables, <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> are the two integer partitions
defining the skew partition, and <code class="reqn">\nu</code> is an integer partition.
One obtains the skew Kostka-Foulkes polynomials by substituting <code class="reqn">q</code>
with <code class="reqn">0</code>.
For given partitions <code class="reqn">\lambda</code> and <code class="reqn">\mu</code>, the function returns the
polynomials <code class="reqn">K_{\lambda/\mu, \nu}(q, t)</code> as <code>qspray</code> objects
for all partitions <code class="reqn">\nu</code> of the same weight as the skew partition. The
generated list is a list of lists with two elements: the integer
partition <code class="reqn">\nu</code> and the polynomial.
</p>

<hr>
<h2 id='Schur'>Evaluation of Schur polynomial - C++ implementation</h2><span id='topic+Schur'></span>

<h3>Description</h3>

<p>Evaluates a Schur polynomial. The Schur polynomials are the
Jack <code class="reqn">P</code>-polynomials with Jack parameter <code class="reqn">\alpha=1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Schur(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Schur_+3A_x">x</code></td>
<td>
<p>values of the variables, a vector of <code>bigq</code> numbers, or a
vector that can be coerced as such (e.g. <code>c("2", "5/3")</code>)</p>
</td></tr>
<tr><td><code id="Schur_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bigq</code> number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Schur(c("1", "3/2", "-2/3"), lambda = c(3, 1))
</code></pre>

<hr>
<h2 id='SchurCombination'>Symmetric polynomial in terms of the Schur polynomials</h2><span id='topic+SchurCombination'></span>

<h3>Description</h3>

<p>Expression of a symmetric polynomial as a linear combination
of some Schur polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SchurCombination(qspray, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SchurCombination_+3A_qspray">qspray</code></td>
<td>
<p>a <code>qspray</code> object defining a symmetric polynomial</p>
</td></tr>
<tr><td><code id="SchurCombination_+3A_check">check</code></td>
<td>
<p>Boolean, whether to check the symmetry of <code>qspray</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the combination. Each element of this list is a
list with two elements: <code>coeff</code>, a <code>bigq</code> number, and
<code>lambda</code>, an integer partition; then this list corresponds to the
term <code>coeff * SchurPol(n, lambda)</code>, where <code>n</code> is the number of
variables in the symmetric polynomial.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JackCombination">JackCombination</a></code>.
</p>

<hr>
<h2 id='SchurPol'>Schur polynomial - C++ implementation</h2><span id='topic+SchurPol'></span>

<h3>Description</h3>

<p>Returns a Schur polynomial. The Schur polynomials are the
Jack <code class="reqn">P</code>-polynomials with Jack parameter <code class="reqn">\alpha=1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SchurPol(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SchurPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="SchurPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( schur &lt;- SchurPol(3, lambda = c(3, 1)) )
schur == JackPol(3, lambda = c(3, 1), alpha = "1", which = "P")
</code></pre>

<hr>
<h2 id='SchurPolR'>Schur polynomial</h2><span id='topic+SchurPolR'></span>

<h3>Description</h3>

<p>Returns the Schur polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SchurPolR(n, lambda, algorithm = "DK", basis = "canonical", exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SchurPolR_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="SchurPolR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="SchurPolR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> or <code>"naive"</code></p>
</td></tr>
<tr><td><code id="SchurPolR_+3A_basis">basis</code></td>
<td>
<p>the polynomial basis for <code>algorithm = "naive"</code>,
either <code>"canonical"</code> or <code>"MSF"</code> (monomial symmetric functions);
for <code>algorithm = "DK"</code> the canonical basis is always used and
this parameter is ignored</p>
</td></tr>
<tr><td><code id="SchurPolR_+3A_exact">exact</code></td>
<td>
<p>logical, whether to use exact arithmetic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mvp</code> multivariate polynomial (see <a href="mvp.html#topic+mvp-package">mvp-package</a>),
or a <code>qspray</code> multivariate polynomial if
<code>exact = TRUE</code> and <code>algorithm = "DK"</code>, or a
character string if <code>basis = "MSF"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SchurPolR(3, lambda = c(3,1), algorithm = "naive")
SchurPolR(3, lambda = c(3,1), algorithm = "DK")
SchurPolR(3, lambda = c(3,1), algorithm = "DK", exact = FALSE)
SchurPolR(3, lambda = c(3,1), algorithm = "naive", basis = "MSF")
</code></pre>

<hr>
<h2 id='SchurR'>Evaluation of Schur polynomials</h2><span id='topic+SchurR'></span>

<h3>Description</h3>

<p>Evaluates a Schur polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SchurR(x, lambda, algorithm = "DK")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SchurR_+3A_x">x</code></td>
<td>
<p>numeric or complex vector or <a href="gmp.html#topic+bigq">bigq</a> vector</p>
</td></tr>
<tr><td><code id="SchurR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="SchurR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> (Demmel-Koev)
or <code>"naive"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex scalar or a <code>bigq</code> rational number.
</p>


<h3>References</h3>

<p>J. Demmel &amp; P. Koev.
<em>Accurate and efficient evaluation of Schur and Jack functions</em>.
Mathematics of computations, vol. 75, n. 253, 223-229, 2005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SchurPolR">SchurPolR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2,3,4)
SchurR(x, c(2,1,1))
prod(x) * sum(x)
</code></pre>

<hr>
<h2 id='SkewFactorialSchurPol'>Skew factorial Schur polynomial</h2><span id='topic+SkewFactorialSchurPol'></span>

<h3>Description</h3>

<p>Computes the skew factorial Schur polynomial associated to a
given skew partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SkewFactorialSchurPol(n, lambda, mu, a, i0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewFactorialSchurPol_+3A_n">n</code></td>
<td>
<p>number of variables</p>
</td></tr>
<tr><td><code id="SkewFactorialSchurPol_+3A_lambda">lambda</code>, <code id="SkewFactorialSchurPol_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
<tr><td><code id="SkewFactorialSchurPol_+3A_a">a</code></td>
<td>
<p>vector of <code>bigq</code> numbers, or vector of elements coercible
to <code>bigq</code> numbers; this vector corresponds to the sequence denoted by
<code class="reqn">a</code> in the
<a href="https://www.kurims.kyoto-u.ac.jp/EMIS/journals/SLC/opapers/s28macdonald.pdf">reference paper</a>,
section <strong>6th Variation</strong> (in this paper <code class="reqn">a</code> is a doubly
infinite sequence, but only a finite number of indices are not involved);
the length of this vector must be large enough (an error will be thrown
if it is too small) but it is not easy to know the minimal possible length</p>
</td></tr>
<tr><td><code id="SkewFactorialSchurPol_+3A_i0">i0</code></td>
<td>
<p>positive integer, the index of <code>a</code> that must be considered
as the zero index of the sequence denoted by <code class="reqn">a</code> in the reference
paper</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> polynomial.
</p>


<h3>References</h3>

<p>I.G. Macdonald.
<em>Schur functions: theme and variations</em>.
Publ. IRMA Strasbourg, 1992.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for a=c(0, 0, ...), the skew factorial Schur polynomial is the
# skew Schur polynomial; let's check
n &lt;- 4
lambda &lt;- c(3, 3, 2, 2); mu &lt;- c(2, 2)
a &lt;- rep(0, 9)
i0 &lt;- 3
skewFactorialSchurPoly &lt;- SkewFactorialSchurPol(n, lambda, mu, a, i0)
skewSchurPoly &lt;- SkewSchurPol(n, lambda, mu)
skewFactorialSchurPoly == skewSchurPoly # should be TRUE
</code></pre>

<hr>
<h2 id='SkewHallLittlewoodPol'>Skew Hall-Littlewood polynomial</h2><span id='topic+SkewHallLittlewoodPol'></span>

<h3>Description</h3>

<p>Returns the skew Hall-Littlewood polynomial associated to
the given skew partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SkewHallLittlewoodPol(n, lambda, mu, which = "P")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewHallLittlewoodPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="SkewHallLittlewoodPol_+3A_lambda">lambda</code>, <code id="SkewHallLittlewoodPol_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
<tr><td><code id="SkewHallLittlewoodPol_+3A_which">which</code></td>
<td>
<p>which skew Hall-Littlewood polynomial, <code>"P"</code> or <code>"Q"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>symbolicQspray</code> multivariate polynomial, the skew
Hall-Littlewood polynomial associated to the skew partition defined by
<code>lambda</code> and <code>mu</code>. It has a single parameter usually denoted
by <code class="reqn">t</code> and its coefficients are polynomial in this parameter.
When substituting <code class="reqn">t</code> with <code class="reqn">0</code> in the skew Hall-Littlewood
<code class="reqn">P</code>-polynomials, one obtains the skew Schur polynomials.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 3; lambda &lt;- c(3, 2, 1); mu &lt;- c(1, 1)
skewHLpoly &lt;- SkewHallLittlewoodPol(n, lambda, mu)
skewSchurPoly &lt;- SkewSchurPol(n, lambda, mu)
substituteParameters(skewHLpoly, 0) == skewSchurPoly # should be TRUE
</code></pre>

<hr>
<h2 id='SkewJackPol'>Skew Jack polynomial</h2><span id='topic+SkewJackPol'></span>

<h3>Description</h3>

<p>Computes a skew Jack polynomial with a given Jack parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SkewJackPol(n, lambda, mu, alpha, which = "J")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewJackPol_+3A_n">n</code></td>
<td>
<p>positive integer, the number of variables</p>
</td></tr>
<tr><td><code id="SkewJackPol_+3A_lambda">lambda</code></td>
<td>
<p>outer integer partition of the skew partition</p>
</td></tr>
<tr><td><code id="SkewJackPol_+3A_mu">mu</code></td>
<td>
<p>inner integer partition of the skew partition; it must be a
subpartition of <code>lambda</code></p>
</td></tr>
<tr><td><code id="SkewJackPol_+3A_alpha">alpha</code></td>
<td>
<p>the Jack parameter, any object coercible to a <code>bigq</code>
number</p>
</td></tr>
<tr><td><code id="SkewJackPol_+3A_which">which</code></td>
<td>
<p>which skew Jack polynomial, <code>"J"</code>, <code>"P"</code>, <code>"Q"</code>
or <code>"C"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> polynomial.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SkewJackSymPol">SkewJackSymPol</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SkewJackPol(3, c(3,1), c(2), "2")
</code></pre>

<hr>
<h2 id='SkewJackSymPol'>Skew Jack polynomial with symbolic Jack parameter</h2><span id='topic+SkewJackSymPol'></span>

<h3>Description</h3>

<p>Computes a skew Jack polynomial with a symbolic Jack parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SkewJackSymPol(n, lambda, mu, which = "J")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewJackSymPol_+3A_n">n</code></td>
<td>
<p>positive integer, the number of variables</p>
</td></tr>
<tr><td><code id="SkewJackSymPol_+3A_lambda">lambda</code></td>
<td>
<p>outer integer partition of the skew partition</p>
</td></tr>
<tr><td><code id="SkewJackSymPol_+3A_mu">mu</code></td>
<td>
<p>inner integer partition of the skew partition; it must be a
subpartition of <code>lambda</code></p>
</td></tr>
<tr><td><code id="SkewJackSymPol_+3A_which">which</code></td>
<td>
<p>which skew Jack polynomial, <code>"J"</code>, <code>"P"</code>, <code>"Q"</code>
or <code>"C"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>symbolicQspray</code> polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SkewJackSymPol(3, c(3,1), c(2))
</code></pre>

<hr>
<h2 id='SkewKostkaFoulkesPolynomial'>Skew Kostka-Foulkes polynomial</h2><span id='topic+SkewKostkaFoulkesPolynomial'></span>

<h3>Description</h3>

<p>Computes a skew Kostka-Foulkes polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SkewKostkaFoulkesPolynomial(lambda, mu, nu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewKostkaFoulkesPolynomial_+3A_lambda">lambda</code>, <code id="SkewKostkaFoulkesPolynomial_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
<tr><td><code id="SkewKostkaFoulkesPolynomial_+3A_nu">nu</code></td>
<td>
<p>integer partition; the condition
<code>sum(nu)==sum(lambda)-sum(mu)</code> is necessary in order to get a
non-zero polynomial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The skew Kostka-Foulkes polynomial associated to the skew
partitiion defined by <code>lambda</code> and <code>mu</code> and to the partition
<code>nu</code>. This is a univariate <code>qspray</code> polynomial whose value
at <code>1</code> is the skew Kostka number associated to the skew partition
defined by <code>lambda</code> and <code>mu</code> and to the partition <code>nu</code>.
</p>

<hr>
<h2 id='skewKostkaJackNumbers'>Skew Kostka-Jack numbers with given Jack parameter</h2><span id='topic+skewKostkaJackNumbers'></span>

<h3>Description</h3>

<p>Skew Kostka-Jack numbers associated to a given skew partition
and a given Jack parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewKostkaJackNumbers(lambda, mu, alpha = NULL, output = "vector")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skewKostkaJackNumbers_+3A_lambda">lambda</code>, <code id="skewKostkaJackNumbers_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
<tr><td><code id="skewKostkaJackNumbers_+3A_alpha">alpha</code></td>
<td>
<p>the Jack parameter, a <code>bigq</code> number or an object coercible
to a <code>bigq</code> number; setting <code>alpha=NULL</code> is equivalent to set
<code>alpha=1</code></p>
</td></tr>
<tr><td><code id="skewKostkaJackNumbers_+3A_output">output</code></td>
<td>
<p>the format of the output, either <code>"vector"</code> or
<code>"list"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The skew Kostka-Jack number <code class="reqn">K_{\lambda/\mu,\nu}(\alpha)</code> is
the coefficient of the monomial symmetric polynomial <code class="reqn">m_\nu</code> in the
expression of the skew <code class="reqn">P</code>-Jack polynomial
<code class="reqn">P_{\lambda/\mu}(\alpha)</code> as a linear combination of monomial
symmetric polynomials. For <code class="reqn">\alpha=1</code> it is the ordinary skew Kostka
number.
</p>


<h3>Value</h3>

<p>If <code>output="vector"</code>, the function returns a named vector.
This vector is made of the non-zero skew Kostka-Jack numbers
<code class="reqn">K_{\lambda/\mu,\nu}(\alpha)</code> given as character strings and its names
encode the partitions <code class="reqn">\nu</code>.
If <code>ouput="list"</code>, the function returns a list. Each element of this
list is a named list with two elements: an integer partition <code class="reqn">\nu</code>
in the field named <code>"nu"</code>, and the corresponding skew Kostka-Jack
number <code class="reqn">K_{\lambda/\mu,\nu}(\alpha)</code> in the field named <code>"value"</code>.
Only the non-null skew Kostka-Jack numbers are provided by this list.
</p>


<h3>Note</h3>

<p>The skew Kostka-Jack numbers <code class="reqn">K_{\lambda/\mu,\nu}(\alpha)</code> are
well defined when the Jack parameter <code class="reqn">\alpha</code> is zero, however this
function does not work with <code>alpha=0</code>. A possible way to get the
skew Kostka-Jack numbers <code class="reqn">K_{\lambda/\mu,\nu}(0)</code> is to use the
function <code><a href="#topic+symbolicSkewKostkaJackNumbers">symbolicSkewKostkaJackNumbers</a></code> to get the skew
Kostka-Jack numbers with a symbolic Jack parameter <code class="reqn">\alpha</code>, and then
to substitute <code class="reqn">\alpha</code> with <code class="reqn">0</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+symbolicSkewKostkaJackNumbers">symbolicSkewKostkaJackNumbers</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skewKostkaJackNumbers(c(4,2,2), c(2,2))
</code></pre>

<hr>
<h2 id='SkewMacdonaldPol'>Skew Macdonald polynomial</h2><span id='topic+SkewMacdonaldPol'></span>

<h3>Description</h3>

<p>Returns the skew Macdonald polynomial associated to
the given skew partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SkewMacdonaldPol(n, lambda, mu, which = "P")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewMacdonaldPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="SkewMacdonaldPol_+3A_lambda">lambda</code>, <code id="SkewMacdonaldPol_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
<tr><td><code id="SkewMacdonaldPol_+3A_which">which</code></td>
<td>
<p>which skew Macdonald polynomial, <code>"P"</code>, <code>"Q"</code>
or <code>"J"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>symbolicQspray</code> multivariate polynomial, the skew
Macdonald polynomial associated to the skew partition defined by
<code>lambda</code> and <code>mu</code>. It has two parameters usually
denoted by <code class="reqn">q</code> and <code class="reqn">t</code>. Substituting <code class="reqn">q</code> with <code class="reqn">0</code>
yields the skew Hall-Littlewood polynomials.
</p>

<hr>
<h2 id='SkewSchurPol'>Skew Schur polynomial</h2><span id='topic+SkewSchurPol'></span>

<h3>Description</h3>

<p>Returns the skew Schur polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SkewSchurPol(n, lambda, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewSchurPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="SkewSchurPol_+3A_lambda">lambda</code>, <code id="SkewSchurPol_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation is performed with the help of the
Littlewood-Richardson rule (see <code><a href="#topic+LRskew">LRskew</a></code>).
</p>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial, the skew Schur polynomial
associated to the skew partition defined by <code>lambda</code> and <code>mu</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SkewSchurPol(3, lambda = c(3, 2, 1), mu = c(1, 1))
</code></pre>

<hr>
<h2 id='symbolicJackCombination'>Symmetric polynomial in terms of symbolic Jack polynomials</h2><span id='topic+symbolicJackCombination'></span>

<h3>Description</h3>

<p>Expression of a symmetric polynomial as a linear combination
of Jack polynomials with a symbolic Jack parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolicJackCombination(qspray, which = "J", check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symbolicJackCombination_+3A_qspray">qspray</code></td>
<td>
<p>a <code>qspray</code> object or a <code>symbolicQspray</code> object
defining a symmetric polynomial</p>
</td></tr>
<tr><td><code id="symbolicJackCombination_+3A_which">which</code></td>
<td>
<p>which Jack polynomials, <code>"J"</code>, <code>"P"</code>, <code>"Q"</code> or
<code>"C"</code></p>
</td></tr>
<tr><td><code id="symbolicJackCombination_+3A_check">check</code></td>
<td>
<p>Boolean, whether to check the symmetry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the combination. Each element of this list is a
list with two elements: <code>coeff</code>, a <code>bigq</code> number, and
<code>lambda</code>, an integer partition; then this list corresponds to the
term <code>coeff * JackSymPol(n, lambda, which)</code>, where <code>n</code> is
the number of variables in the symmetric polynomial.
</p>

<hr>
<h2 id='symbolicKostkaJackNumbers'>Kostka-Jack numbers with symbolic Jack parameter</h2><span id='topic+symbolicKostkaJackNumbers'></span>

<h3>Description</h3>

<p>Kostka-Jack numbers with a symbolic Jack parameter for
integer partitions of a given weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolicKostkaJackNumbers(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symbolicKostkaJackNumbers_+3A_n">n</code></td>
<td>
<p>positive integer, the weight of the partitions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of named lists of <code>ratioOfQsprays</code> objects.
Denoting the Kostka-Jack numbers by <code class="reqn">K_{\lambda,\mu}(\alpha)</code>, the
names of the outer list correspond to the partitions <code class="reqn">\lambda</code>, and
the names of the inner lists correspond to the partitions <code class="reqn">\mu</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KostkaJackNumbers">KostkaJackNumbers</a></code>,
<code><a href="#topic+symbolicKostkaJackNumbersWithGivenLambda">symbolicKostkaJackNumbersWithGivenLambda</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symbolicKostkaJackNumbers(3)
</code></pre>

<hr>
<h2 id='symbolicKostkaJackNumbersWithGivenLambda'>Kostka-Jack numbers with symbolic Jack parameter for a
given <code class="reqn">\lambda</code></h2><span id='topic+symbolicKostkaJackNumbersWithGivenLambda'></span>

<h3>Description</h3>

<p>Kostka-Jack numbers <code class="reqn">K_{\lambda,\mu}(\alpha)</code> with a
symbolic Jack parameter <code class="reqn">\alpha</code> for a given
integer partition <code class="reqn">\lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolicKostkaJackNumbersWithGivenLambda(lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symbolicKostkaJackNumbersWithGivenLambda_+3A_lambda">lambda</code></td>
<td>
<p>integer partition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of <code>ratioOfQsprays</code> objects. The elements of this
list are the Kostka-Jack numbers <code class="reqn">K_{\lambda,\mu}(\alpha)</code> and
its names correspond to the partitions <code class="reqn">\mu</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KostkaJackNumbersWithGivenLambda">KostkaJackNumbersWithGivenLambda</a></code>,
<code><a href="#topic+symbolicKostkaJackNumbers">symbolicKostkaJackNumbers</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symbolicKostkaJackNumbersWithGivenLambda(c(3, 1))
</code></pre>

<hr>
<h2 id='symbolicSkewKostkaJackNumbers'>Skew Kostka-Jack numbers with symbolic Jack parameter</h2><span id='topic+symbolicSkewKostkaJackNumbers'></span>

<h3>Description</h3>

<p>Skew Kostka-Jack numbers associated to a given skew partition
with a symbolic Jack parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolicSkewKostkaJackNumbers(lambda, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symbolicSkewKostkaJackNumbers_+3A_lambda">lambda</code>, <code id="symbolicSkewKostkaJackNumbers_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list. Each element of this
list is a named list with two elements: an integer partition <code class="reqn">\nu</code>
in the field named <code>"nu"</code>, and the corresponding skew Kostka number
<code class="reqn">K_{\lambda/\mu,\nu}(\alpha)</code> in the field named <code>"value"</code>, a
<code>ratioOfQsprays</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symbolicSkewKostkaJackNumbers(c(4,2,2), c(2,2))
</code></pre>

<hr>
<h2 id='tSchurPol'>t-Schur polynomial</h2><span id='topic+tSchurPol'></span>

<h3>Description</h3>

<p>Returns the t-Schur polynomial associated to
the given partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSchurPol(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSchurPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="tSchurPol_+3A_lambda">lambda</code></td>
<td>
<p>integer partition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>symbolicQspray</code> multivariate polynomial, the
t-Schur polynomial associated to <code>lambda</code>.
It has a single parameter usually denoted by <code class="reqn">t</code> and its
coefficients are polynomials in this parameter. Substituting
<code class="reqn">t</code> with <code class="reqn">0</code> yields the Schur polynomials.
</p>


<h3>Note</h3>

<p>The name &quot;t-Schur polynomial&quot; is taken from
<a href="https://www.sciencedirect.com/science/article/pii/S0097316518300724">Wheeler and Zinn-Justin's paper</a>
<em>Hall polynomials, inverse Kostka polynomials and puzzles</em>.
</p>

<hr>
<h2 id='tSkewSchurPol'>Skew t-Schur polynomial</h2><span id='topic+tSkewSchurPol'></span>

<h3>Description</h3>

<p>Returns the skew t-Schur polynomial associated to
the given skew partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSkewSchurPol(n, lambda, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSkewSchurPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="tSkewSchurPol_+3A_lambda">lambda</code>, <code id="tSkewSchurPol_+3A_mu">mu</code></td>
<td>
<p>integer partitions defining the skew partition:
<code>lambda</code> is the outer partition and <code>mu</code> is the inner partition
(so <code>mu</code> must be a subpartition of <code>lambda</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>symbolicQspray</code> multivariate polynomial, the skew
t-Schur polynomial associated to the skew partition defined by
<code>lambda</code> and <code>mu</code>.
It has a single parameter usually denoted by <code class="reqn">t</code> and its
coefficients are polynomials in this parameter. Substituting
<code class="reqn">t</code> with <code class="reqn">0</code> yields the skew Schur polynomials.
</p>

<hr>
<h2 id='Zonal'>Evaluation of zonal polynomial - C++ implementation</h2><span id='topic+Zonal'></span>

<h3>Description</h3>

<p>Evaluates a zonal polynomial. The zonal polynomials are the
Jack <code class="reqn">C</code>-polynomials with Jack parameter <code class="reqn">\alpha=Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zonal(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Zonal_+3A_x">x</code></td>
<td>
<p>values of the variables, a vector of <code>bigq</code> numbers, or a
vector that can be coerced as such (e.g. <code>c("2", "5/3")</code>)</p>
</td></tr>
<tr><td><code id="Zonal_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bigq</code> number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Zonal(c("1", "3/2", "-2/3"), lambda = c(3, 1))
</code></pre>

<hr>
<h2 id='ZonalPol'>Zonal polynomial - C++ implementation</h2><span id='topic+ZonalPol'></span>

<h3>Description</h3>

<p>Returns a zonal polynomial. The zonal polynomials are the
Jack <code class="reqn">C</code>-polynomials with Jack parameter <code class="reqn">\alpha=Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalPol(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZonalPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="ZonalPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( zonal &lt;- ZonalPol(3, lambda = c(3, 1)) )
zonal == JackPol(3, lambda = c(3, 1), alpha = "2", which = "C")
</code></pre>

<hr>
<h2 id='ZonalPolR'>Zonal polynomial</h2><span id='topic+ZonalPolR'></span>

<h3>Description</h3>

<p>Returns the zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalPolR(n, lambda, algorithm = "DK", basis = "canonical", exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZonalPolR_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="ZonalPolR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="ZonalPolR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> or <code>"naive"</code></p>
</td></tr>
<tr><td><code id="ZonalPolR_+3A_basis">basis</code></td>
<td>
<p>the polynomial basis for <code>algorithm = "naive"</code>,
either <code>"canonical"</code> or <code>"MSF"</code> (monomial symmetric functions);
for <code>algorithm = "DK"</code> the canonical basis is always used and
this parameter is ignored</p>
</td></tr>
<tr><td><code id="ZonalPolR_+3A_exact">exact</code></td>
<td>
<p>logical, whether to get rational coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mvp</code> multivariate polynomial (see <a href="mvp.html#topic+mvp-package">mvp-package</a>),
or a <code>qspray</code> multivariate polynomial if
<code>exact = TRUE</code> and <code>algorithm = "DK"</code>, or a
character string if <code>basis = "MSF"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ZonalPolR(3, lambda = c(3,1), algorithm = "naive")
ZonalPolR(3, lambda = c(3,1), algorithm = "DK")
ZonalPolR(3, lambda = c(3,1), algorithm = "DK", exact = FALSE)
ZonalPolR(3, lambda = c(3,1), algorithm = "naive", basis = "MSF")
</code></pre>

<hr>
<h2 id='ZonalQ'>Evaluation of zonal quaternionic polynomial - C++ implementation</h2><span id='topic+ZonalQ'></span>

<h3>Description</h3>

<p>Evaluates a zonal quaternionic polynomial. The quaternionic
zonal polynomials are the Jack <code class="reqn">C</code>-polynomials with Jack
parameter <code class="reqn">\alpha=1/Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalQ(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZonalQ_+3A_x">x</code></td>
<td>
<p>values of the variables, a vector of <code>bigq</code> numbers, or a
vector that can be coerced as such (e.g. <code>c("2", "5/3")</code>)</p>
</td></tr>
<tr><td><code id="ZonalQ_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bigq</code> number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ZonalQ(c("1", "3/2", "-2/3"), lambda = c(3, 1))
</code></pre>

<hr>
<h2 id='ZonalQPol'>Quaternionic zonal polynomial - C++ implementation</h2><span id='topic+ZonalQPol'></span>

<h3>Description</h3>

<p>Returns a quaternionic zonal polynomial. The quaternionic
zonal polynomials are the Jack <code class="reqn">C</code>-polynomials with Jack
parameter <code class="reqn">\alpha=1/Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalQPol(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZonalQPol_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="ZonalQPol_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>qspray</code> multivariate polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( zonalQ &lt;- ZonalQPol(3, lambda = c(3, 1)) )
zonalQ == JackPol(3, lambda = c(3, 1), alpha = "1/2", which = "C")
</code></pre>

<hr>
<h2 id='ZonalQPolR'>Quaternionic zonal polynomial</h2><span id='topic+ZonalQPolR'></span>

<h3>Description</h3>

<p>Returns the quaternionic (or symplectic) zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalQPolR(n, lambda, algorithm = "DK", basis = "canonical", exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZonalQPolR_+3A_n">n</code></td>
<td>
<p>number of variables, a positive integer</p>
</td></tr>
<tr><td><code id="ZonalQPolR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="ZonalQPolR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> or <code>"naive"</code></p>
</td></tr>
<tr><td><code id="ZonalQPolR_+3A_basis">basis</code></td>
<td>
<p>the polynomial basis for <code>algorithm = "naive"</code>,
either <code>"canonical"</code> or <code>"MSF"</code> (monomial symmetric functions);
for <code>algorithm = "DK"</code> the canonical basis is always used and
this parameter is ignored</p>
</td></tr>
<tr><td><code id="ZonalQPolR_+3A_exact">exact</code></td>
<td>
<p>logical, whether to get rational coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mvp</code> multivariate polynomial (see <a href="mvp.html#topic+mvp-package">mvp-package</a>),
or a <code>qspray</code> multivariate polynomial if
<code>exact = TRUE</code> and <code>algorithm = "DK"</code>, or a
character string if <code>basis = "MSF"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ZonalQPolR(3, lambda = c(3,1), algorithm = "naive")
ZonalQPolR(3, lambda = c(3,1), algorithm = "DK")
ZonalQPolR(3, lambda = c(3,1), algorithm = "DK", exact = FALSE)
ZonalQPolR(3, lambda = c(3,1), algorithm = "naive", basis = "MSF")
</code></pre>

<hr>
<h2 id='ZonalQR'>Evaluation of quaternionic zonal polynomials</h2><span id='topic+ZonalQR'></span>

<h3>Description</h3>

<p>Evaluates a quaternionic (or symplectic) zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalQR(x, lambda, algorithm = "DK")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZonalQR_+3A_x">x</code></td>
<td>
<p>numeric or complex vector or <a href="gmp.html#topic+bigq">bigq</a> vector</p>
</td></tr>
<tr><td><code id="ZonalQR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="ZonalQR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> (Demmel-Koev)
or <code>"naive"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex scalar or a <code>bigq</code> rational number.
</p>


<h3>References</h3>

<p>F. Li, Y. Xue. <em>Zonal polynomials and hypergeometric
functions of quaternion matrix argument</em>.
Comm. Statist. Theory Methods, 38 (8), 1184-1206, 2009
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ZonalQPolR">ZonalQPolR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- c(2,2)
ZonalQR(c(3,1), lambda)
ZonalQR(c(gmp::as.bigq(3),gmp::as.bigq(1)), lambda)
##
x &lt;- c(3,1)
ZonalQR(x, c(1,1)) + ZonalQR(x, 2) # sum(x)^2
ZonalQR(x, 3) + ZonalQR(x, c(2,1)) + ZonalQR(x, c(1,1,1)) # sum(x)^3
</code></pre>

<hr>
<h2 id='ZonalR'>Evaluation of zonal polynomials</h2><span id='topic+ZonalR'></span>

<h3>Description</h3>

<p>Evaluates a zonal polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZonalR(x, lambda, algorithm = "DK")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZonalR_+3A_x">x</code></td>
<td>
<p>numeric or complex vector or <a href="gmp.html#topic+bigq">bigq</a> vector</p>
</td></tr>
<tr><td><code id="ZonalR_+3A_lambda">lambda</code></td>
<td>
<p>an integer partition, given as a vector of decreasing
integers</p>
</td></tr>
<tr><td><code id="ZonalR_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used, either <code>"DK"</code> (Demmel-Koev)
or <code>"naive"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex scalar or a <code>bigq</code> rational number.
</p>


<h3>References</h3>


<ul>
<li><p> Robb Muirhead. <em>Aspects of multivariate statistical theory</em>.
Wiley series in probability and mathematical statistics.
Probability and mathematical statistics.
John Wiley &amp; Sons, New York, 1982.
</p>
</li>
<li><p> Akimichi Takemura. <em>Zonal Polynomials</em>,
volume 4 of Institute of Mathematical Statistics Lecture Notes –
Monograph Series.
Institute of Mathematical Statistics, Hayward, CA, 1984.
</p>
</li>
<li><p> Lin Jiu &amp; Christoph Koutschan.
<em>Calculation and Properties of Zonal Polynomials</em>.
<a href="http://koutschan.de/data/zonal/">http://koutschan.de/data/zonal/</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ZonalPolR">ZonalPolR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- c(2,2)
ZonalR(c(1,1), lambda)
ZonalR(c(gmp::as.bigq(1),gmp::as.bigq(1)), lambda)
##
x &lt;- c(3,1)
ZonalR(x, c(1,1)) + ZonalR(x, 2) # sum(x)^2
ZonalR(x, 3) + ZonalR(x, c(2,1)) + ZonalR(x, c(1,1,1)) # sum(x)^3
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
