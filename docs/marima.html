<!DOCTYPE html><html lang="en"><head><title>Help for package marima</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {marima}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arma.filter'><p>arma.filter</p></a></li>
<li><a href='#arma.forecast'><p>arma.forecast</p></a></li>
<li><a href='#austr'><p>Data set for testing marima package (australian killings)</p></a></li>
<li><a href='#C20'><p>Data set for testing marima package (Copenhagen Stocks)</p></a></li>
<li><a href='#check.one'><p>check.one</p></a></li>
<li><a href='#define.dif'><p>define.dif</p></a></li>
<li><a href='#define.model'><p>define.model</p></a></li>
<li><a href='#define.sum'><p>define.sum</p></a></li>
<li><a href='#forec.var'><p>forec.var</p></a></li>
<li><a href='#inverse.form'><p>inverse.form</p></a></li>
<li><a href='#lead.one'><p>lead.one</p></a></li>
<li><a href='#marima'><p>marima</p></a></li>
<li><a href='#marima.sim'><p>marima.sim</p></a></li>
<li><a href='#pol.inv'><p>pol.inv</p></a></li>
<li><a href='#pol.mul'><p>pol.mul</p></a></li>
<li><a href='#pol.order'><p>pol.order</p></a></li>
<li><a href='#print.marima'><p>print.marima</p></a></li>
<li><a href='#rand.shock'><p>rand.shock</p></a></li>
<li><a href='#Results'><p>Results</p></a></li>
<li><a href='#season.lagging'><p>season.lagging</p></a></li>
<li><a href='#short.form'><p>short.form</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate ARIMA and ARIMA-X Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-01-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Henrik Spliid</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Spliid &lt;hspl@dtu.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multivariate ARIMA and ARIMA-X estimation using Spliid's 
    algorithm (marima()) and simulation (marima.sim()).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-13 20:34:32 UTC; hspl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-14 00:59:20</td>
</tr>
</table>
<hr>
<h2 id='arma.filter'>arma.filter</h2><span id='topic+arma.filter'></span>

<h3>Description</h3>

<p>Filtering of (kvar-variate) time series with marima
type model.
</p>
<p>Calculation of residuals and filtered values of timeseries using
a marima model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma.filter(series = NULL, ar.poly = array(diag(kvar), dim = c(kvar, kvar,
  1)), ma.poly = array(diag(kvar), dim = c(kvar, kvar, 1)), means = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma.filter_+3A_series">series</code></td>
<td>
<p>matrix holding the kvar by n multivariate timeseries
(if (kvar &gt; n) the series is transposed and a warning is given).</p>
</td></tr>
<tr><td><code id="arma.filter_+3A_ar.poly">ar.poly</code></td>
<td>
<p>(kvar, kvar, p+1) array containing autoregressive matrix
polynomial model part. If the filtering is to be performed for
undifferenced data when the analysis (in marima) was done for differenced
data, the input array ar.poly should incorporate the ar-representation
of the differensing operation (using, for example:
ar.poly &lt;- pol.mul(ar.estimate, dif.poly,
L = ( dim(ar.estimates)[3]+dim(dif.poly)[3])), where 'dif.poly'
was obtained when differencing the time series (using define.dif)
before analysing it with marima (giving the ar.estimate) .</p>
</td></tr>
<tr><td><code id="arma.filter_+3A_ma.poly">ma.poly</code></td>
<td>
<p>(kvar, kvar, q+1) array containing moving average matrix
polynomial model part.
</p>
<p>If a leading unity matrix is not included in the ar- and/or the ma-part
of the model this is automatically taken care of in the function
(in that case the dimensions of the model arrays used in arma.filter()
are, respectively, (kvar, kvar, p+1) and (kvar, kvar, q+1)).</p>
</td></tr>
<tr><td><code id="arma.filter_+3A_means">means</code></td>
<td>
<p>vector (length = kvar) indicating whether means are
subtracted or not (0/1). Default : means = 1 saying that all means
are subtracted (equivalent to means = c(1, 1, ..., 1)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates = estimated values for input series
</p>
<p>residuals = corresponding residuals. It is noted that the
residuals computed by arma.filter may deviate slightly from the
marima-residuals (which are taken from the last repeated regression
step performed). The residuals computed by arma.filter are constructed
by filtering (successive use of the arma model) and using a heuristic
method for the first residuals.
</p>
<p>averages = averages of variables in input series
</p>
<p>mean.pattern = pattern of means as used in filtering
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(marima)
data(austr)
series&lt;-t(austr)[,1:90]
# Define marima model
Model5 &lt;- define.model(kvar=7,ar=1,ma=1,rem.var=1,reg.var=6:7)

# Estimate marima model
Marima5 &lt;- marima(series,Model5$ar.pattern,Model5$ma.pattern,penalty=1)

# Calculate residuals by filtering
Resid &lt;- arma.filter(series, Marima5$ar.estimates,
     Marima5$ma.estimates)

# Compare residuals

plot(Marima5$residuals[2, 5:90], Resid$residuals[2, 5:90],
xlab='marima residuals', ylab='arma.filter residuals')

</code></pre>

<hr>
<h2 id='arma.forecast'>arma.forecast</h2><span id='topic+arma.forecast'></span>

<h3>Description</h3>

<p>Forecasting of (multivariate) time series of
using marima type model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma.forecast(series = NULL, marima = NULL, nstart = NULL, nstep = 1,
  dif.poly = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma.forecast_+3A_series">series</code></td>
<td>
<p>matrix holding the kvar-variate timeseries.
The series is assumed to have the same format
as the timeseries analysed by marima BEFORE differencing (if
differencing was used via define.dif)
(the length, though, does not need to be the same but can be shorter
or longer). Results
from estimating the model (for the differenced data, if used) are assumed
to be saved in the input-object 'marima' (see 'usage') by marima.
</p>
<p>The series is assumed to have the total length=(nstart+nstep) (but it
may be longer. In any case the forecasting is starting from nstart
continuing to nstart+nstep. Future values already present or initialised,
for example, as NAs are overwritten with the forecasted values.)
</p>
<p>An example of a series prepared for forcasting is in the marima library:
'data(austr)': (see below, the example).
</p>
<p>If future (independent) x-values for the forecasting are to be used
these values must be supplied in 'series' at the proper places before
calling 'arma.forecast(...)' (that is except the x-value(s)
corresponding to the last prediction).</p>
</td></tr>
<tr><td><code id="arma.forecast_+3A_marima">marima</code></td>
<td>
<p>the object holding the marima results to be used for
the forecasting, that is an output object created by marima.
</p>
<p>If the ar- and/or the ma-model do not include a leading unity matrix
this is automatically taken care of in the function (in that case the
dimensions of the model arrays used will be, respectively,
(kvar, kvar, p+1) and (kvar, kvar, q+1)) after inserting the leading
unity matrix (if the object 'marima' was produced by marima, this
will automatically be OK.</p>
</td></tr>
<tr><td><code id="arma.forecast_+3A_nstart">nstart</code></td>
<td>
<p>starting point for forecasting (1st forecast values
will be for time point t = nstart+1).</p>
</td></tr>
<tr><td><code id="arma.forecast_+3A_nstep">nstep</code></td>
<td>
<p>length of forecast (forecasts will be for time points
nstart+1,...,nstart+nstep).</p>
</td></tr>
<tr><td><code id="arma.forecast_+3A_dif.poly">dif.poly</code></td>
<td>
<p>(most often) output from the function define.dif holding
the ar-representation of the differencing polynomial
(define.dif$dif.poly).
If a differenced timeseries was analysed by marima
the forecast-variance/covariance matrices are calculated for the
aggregated (original) timeseries if 'dif.poly' is specified. If not,
the forecast-variance/covariance matrices are calculated for the
differenced time series. If forecasting is wanted for the original
(not differenced) time series the 'dif.poly' created by define.dif
must be specified.</p>
</td></tr>
<tr><td><code id="arma.forecast_+3A_check">check</code></td>
<td>
<p>If check=TRUE (default) various checks and
printouts are carried out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>forecasts = forecasted values following the nstart first values
of the input series (at time points 'nstart+1,...,nstart+nstep').
The forecasted values will be (over-) written in the input series at
the proper future positions (if relevant).
</p>
<p>residuals = corresponding residuals for input series followed by
nstep future residuals (all=0).
</p>
<p>prediction.variances = (kvar, kvar, nstep) array containing
prediction covariance matrices corresponding to the nstep forecasts.
</p>
<p>nstart = starting point for prediction (1st prediction at point
nstart+1).
</p>
<p>nstep = length of forecast
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(marima)
data(austr)
series&lt;-austr
Model5 &lt;- define.model(kvar=7, ar=1, ma=1, rem.var=1, reg.var=6:7)
Marima5 &lt;- marima(ts(series[1:90, ]), Model5$ar.pattern, Model5$ma.pattern, 
penalty=1)

nstart  &lt;- 90
nstep   &lt;- 10
cat("Calling arma.forecast.\n")
cat("In the example the input series is dim(length,kvar).\n")
cat("and of type ts() (timeseries) for illustration. \n")
Forecasts &lt;- arma.forecast(series=ts(series), marima=Marima5, 
               nstart=nstart, nstep=nstep )
Year&lt;-series[91:100,1]
One.step &lt;- Forecasts$forecasts[, (nstart+1)]
One.step
Predict  &lt;- Forecasts$forecasts[ 2, 91:100]
Predict
stdv&lt;-sqrt(Forecasts$pred.var[2, 2, ])
upper.lim=Predict+stdv*1.645
lower.lim=Predict-stdv*1.645
Out&lt;-rbind(Year, Predict, upper.lim, lower.lim)
print(Out)
# plot results:
plot(series[1:100, 1], Forecasts$forecasts[2, ], type='l', xlab='Year', 
ylab='Rate of armed suicides', main='Prediction of suicides by firearms', 
ylim=c(0.0, 4.1))
lines(series[1:90, 1], series[1:90, 2], type='p')
grid(lty=2, lwd=1, col='black')
Years&lt;-2005:2014
lines(Years, Predict, type='l')
lines(Years, upper.lim, type='l')
lines(Years, lower.lim, type='l')
lines(c(2004.5, 2004.5), c(0.0, 2.0), lty = 2)

</code></pre>

<hr>
<h2 id='austr'>Data set for testing marima package (australian killings)</h2><span id='topic+austr'></span>

<h3>Description</h3>

<p>Data for marima examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(austr)
</code></pre>


<h3>Format</h3>

<p>A data frame (austr) with 7 columns and 100 rows.
</p>

<dl>
<dt>Year</dt><dd><p>Year for data</p>
</dd>
<dt>suic.fire</dt><dd><p>Rate of suicides by firearms</p>
</dd>
<dt>homi.fire</dt><dd><p>Rate of homicides by firearms</p>
</dd>
<dt>suic.other</dt><dd><p>Rate of suicides by non firearms</p>
</dd>
<dt>homi.other</dt><dd><p>Rate of homicides by non firearms</p>
</dd>
<dt>leg</dt><dd><p>Legislation against firearms in effect</p>
</dd>
<dt>acc.elg</dt><dd><p>Accumulated effect of legislation in years</p>
</dd> 
</dl>

<hr>
<h2 id='C20'>Data set for testing marima package (Copenhagen Stocks)</h2><span id='topic+C20'></span>

<h3>Description</h3>

<p>Two years of prices for 18 shares from the Copenhagen
Stock Exchange C20 index, covering the most valuable companies.
Two shares have been removed (Maersk A = almost identical to Maersk B)
and ISS which is incomplete for the period considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C20)
</code></pre>


<h3>Format</h3>

<p>A data frame (C20) with 1+18+18 columns and 517 rows (about
two full years).
</p>

<dl>
<dt>Dates</dt><dd><p>Format for date is 2016-04-01</p>
</dd> 
<dt>CARL.fin</dt><dd><p>Closing price for stock 'Carlsberg' .</p>
</dd>
<dt>CHR..fin</dt><dd><p>Closing price for stock 'Christian Hansen' .</p>
</dd>
<dt>COLO.fin</dt><dd><p>Closing price for stock 'Coloplast' .</p>
</dd>
<dt>DANS.fin</dt><dd><p>Closing price for stock 'Danske Bank' .</p>
</dd>
<dt>DSV..fin</dt><dd><p>Closing price for stock 'DSV' .</p>
</dd>
<dt>GEN..fin</dt><dd><p>Closing price for stock 'Genmap' .</p>
</dd>
<dt>GN.2.fin</dt><dd><p>Closing price for stock 'GN St. Nord' .</p>
</dd>
<dt>FLS..fin</dt><dd><p>Closing price for stock 'FL Smidth' .</p>
</dd>
<dt>JYSK.fin</dt><dd><p>Closing price for stock 'Jyske Bank' .</p>
</dd>
<dt>MAER.fin</dt><dd><p>Closing price for stock 'Maersk B' .</p>
</dd>
<dt>NDA..fin</dt><dd><p>Closing price for stock 'Nordea Bank' .</p>
</dd>
<dt>NOVO.fin</dt><dd><p>Closing price for stock 'Novo' .</p>
</dd>
<dt>NZYM.fin</dt><dd><p>Closing price for stock 'Novozymes' .</p>
</dd>
<dt>PNDO.fin</dt><dd><p>Closing price for stock 'Pandora' .</p>
</dd>
<dt>TDC..fin</dt><dd><p>Closing price for stock 'TDC' .</p>
</dd> 
<dt>TRYG.fin</dt><dd><p>Closing price for stock Pandora' .</p>
</dd>
<dt>VWS..fin</dt><dd><p>Closing price for stock 'Vestas Wind' .</p>
</dd>
<dt>WDH..fin</dt><dd><p>Closing price for stock 'Wiliam Demant' .</p>
</dd>
<dt>CARL.ave</dt><dd><p>Average price for stock 'Carlsberg' .</p>
</dd>
<dt>CHR..ave</dt><dd><p>Average price for stock 'Christian Hansen' .</p>
</dd>
<dt>COLO.ave</dt><dd><p>Average price for stock 'Coloplast' .</p>
</dd>
<dt>DANS.ave</dt><dd><p>Average price for stock 'Danske Bank' .</p>
</dd>
<dt>DSV..ave</dt><dd><p>Average price for stock 'DSV' .</p>
</dd>
<dt>GEN..ave</dt><dd><p>Average price for stock 'Genmap' .</p>
</dd>
<dt>GN.2.ave</dt><dd><p>Average price for stock 'GN St. Nord' .</p>
</dd>
<dt>FLS..ave</dt><dd><p>Average price for stock 'FL Smidth' .</p>
</dd>
<dt>JYSK.ave</dt><dd><p>Average price for stock 'Jyske Bank' .</p>
</dd>
<dt>MAER.ave</dt><dd><p>Average price for stock 'Maersk B' .</p>
</dd>
<dt>NDA..ave</dt><dd><p>Average price for stock 'Nordea Bank' .</p>
</dd>
<dt>NOVO.ave</dt><dd><p>Average price for stock 'Novo' .</p>
</dd>
<dt>NZYM.ave</dt><dd><p>Average price for stock 'Novozymes' .</p>
</dd>
<dt>PNDO.ave</dt><dd><p>Average price for stock Pandora' .</p>
</dd>
<dt>TDC..ave</dt><dd><p>Average price for stock 'TDC' .</p>
</dd>
<dt>TRYG.ave</dt><dd><p>Average price for stock 'Pandora' .</p>
</dd>
<dt>VWS..ave</dt><dd><p>Average price for stock 'Vestas Wind' .</p>
</dd>
<dt>WDH..ave</dt><dd><p>Average price for stock 'William Demant' .</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1:

library(marima)
data(C20)

selects &lt;- c(2,7,11)

cat("Multivariate model for ",colnames(C20)[selects]," \n")

Data &lt;- data.frame(C20[,selects])
colnames(Data) &lt;- colnames(C20)[selects]

log.Data &lt;- log(Data)
kvar &lt;- length(selects)
k    &lt;- c(1:kvar)
difs &lt;- rep(1,length(selects))

difference &lt;- rbind(k , difs)

dlog.Data &lt;- 100*t(define.dif(log.Data,difference)$y.dif)

cat("dlog.Data represents the percentage change from day
to day. \n")

mod &lt;- define.model(kvar = kvar, ar=c(1:2),ma=c(1))

Model &lt;- marima(dlog.Data,
   ar.pattern=mod$ar.pattern, ma.pattern=mod$ma.pattern,penalty=2)

short.form(Model$ar.estimates,leading=FALSE)
short.form(Model$ma.estimates,leading=FALSE)

# Example 2:
library(marima)
data(C20)

selects &lt;- c(13)

cat("Univariate model for ",colnames(C20)[selects]," \n")

Data &lt;- data.frame(C20[,selects])
colnames(Data) &lt;- colnames(C20)[selects]

log.Data &lt;- log(Data)
kvar &lt;- length(selects)
k    &lt;- c(1:kvar)
difs &lt;- rep(1,length(selects))

difference &lt;- rbind(k , difs)

dlog.Data &lt;- 100*t(define.dif(log.Data,difference)$y.dif)

mod &lt;- define.model(kvar = kvar, ar=c(1:2),ma=c(1))

Model &lt;- marima(dlog.Data,
   ar.pattern=mod$ar.pattern, ma.pattern=mod$ma.pattern,penalty=2)

short.form(Model$ar.estimates,leading=FALSE)
short.form(Model$ma.estimates,leading=FALSE)

</code></pre>

<hr>
<h2 id='check.one'>check.one</h2><span id='topic+check.one'></span>

<h3>Description</h3>

<p>Function to check and insert leading unity matrix
if NOT present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.one(polyn = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.one_+3A_polyn">polyn</code></td>
<td>
<p>(k, k, ...) matrix polynomium with or without leading
unity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>polyn (array) with a leading unity matrix being
inserted if not present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4711)
X &lt;- array(rnorm(32),dim=c(4, 4, 2))
X &lt;- check.one(X)
short.form(X)

</code></pre>

<hr>
<h2 id='define.dif'>define.dif</h2><span id='topic+define.dif'></span>

<h3>Description</h3>

<p>Function to generate and apply a differencing matrix polynomial
(autoregressive form) defined by a pattern.
</p>
<p>To be used before calling marima in order to difference the
timeseries before the marima analysis. The averages of the variables
in the time series are subtracted from the input series before
differencing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define.dif(series = series, difference = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="define.dif_+3A_series">series</code></td>
<td>
<p>= kvar-variate timeseries (kvar by n matrix).</p>
</td></tr>
<tr><td><code id="define.dif_+3A_difference">difference</code></td>
<td>
<p>= 2 by L matrix defining L differencing operations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y.dif = the differenced timeseries (the complete part)
</p>
<p>y.lost = the first observations lost because of differencing
</p>
<p>dif.poly = differencing polynomial
array = c(kvar, kvar, ...) holding the autoregressive representation
of the specified differencing
</p>
<p>averages = the averages of the original series as they
were subtracted before differencing
</p>
<p>dif.series = the differenced series (y.lost followed by y.dif)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate Y=series with 4 variables for illustration:
set.seed(4711)
Y&lt;-matrix(round(100*rnorm(40)+10), nrow=4)

# Example 1: use of difference parameter: If
difference=c(2, 1, 2, 1, 3, 12)
difference
# the variable 2 is differenced
# twice, and variable 3 is differenced once with lag=12.

# Example 2:
poly &lt;- define.dif(series=Y, difference=c(2, 1, 3, 1, 3, 1))
poly
# Generates a (4-variate) polynomial differencing array (with a leading
# unity matrix corresponding to lag=0, and (in the example) differencing
# of variable 2 for lag 1 and variable 3 for lag 1 but twice. Afterwards
# the series Y is differenced accordingly. Results in poly$series and
# poly$dif.poly .

# Example 3: Generation and application of multivariate differencing
# polynomial. Re-use the 4-variate time series and use the
# differencing polynomial (ar-form):
# var=1, dif=1, var=2, dif=6, and var=3 and 4, no differencing.
dif.y &lt;-define.dif(Y, c(1, 1,  2, 6,  3, 0,  4, 0))
# Now dif.y contains the differenced series and the differencing
# polynomial. Print the generated polynomial in short form:
short.form(dif.y$dif.poly)
# Specifying no differencing (3, 0 and 4, 0) may be omitted:
dif.y &lt;-define.dif(Y, c(1, 1,  2, 6))
dif.y

# Example 4:
y&lt;-matrix(round(rnorm(1200)*100+50), nrow=6)
library(marima)
difference&lt;-c(3, 2, 4, 0, 5, 0, 6, 7)
matrix(difference, nrow=2)
Y&lt;-define.dif(y, difference=difference)
round(rowMeans(Y$dif.series), 2)
round(Y$averages, 2)

</code></pre>

<hr>
<h2 id='define.model'>define.model</h2><span id='topic+define.model'></span>

<h3>Description</h3>

<p>Function to define multivariate arma model
(indicator form) for marima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define.model(kvar = 1, ar = 0, ma = 0, rem.var = 0, reg.var = 0,
  no.dep = NULL, print = 0, ar.fill = NULL, ar.rem = NULL,
  ma.fill = NULL, ma.rem = NULL, indep = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="define.model_+3A_kvar">kvar</code></td>
<td>
<p>dimension of time series</p>
</td></tr>
<tr><td><code id="define.model_+3A_ar">ar</code></td>
<td>
<p>autoregresssion definition. For example ar=c(1, 2, 12) will
generate autoregression at lags 1, 2 and 12.</p>
</td></tr>
<tr><td><code id="define.model_+3A_ma">ma</code></td>
<td>
<p>moving average definition. Works like ar. If ma=c(1, 2) moving
average terms at lags 1 and 2 are defined.</p>
</td></tr>
<tr><td><code id="define.model_+3A_rem.var">rem.var</code></td>
<td>
<p>no. of variable(s) not to be considered in marima.</p>
</td></tr>
<tr><td><code id="define.model_+3A_reg.var">reg.var</code></td>
<td>
<p>no. of variable(s) that can only act as regression
variable(s) such as (typically) a socalled leading indicator.</p>
</td></tr>
<tr><td><code id="define.model_+3A_no.dep">no.dep</code></td>
<td>
<p>sequence of pairs of variables. For example
no.dep=c(1, 2, 2, 3) means that variable 2 is not allowed in model
for variable 1, and variable 3 is not allowed in model for variable 2.</p>
</td></tr>
<tr><td><code id="define.model_+3A_print">print</code></td>
<td>
<p>(!0/0) If !0 is used, the generated patterns of the
arma model and other informations are printed on the console.
If 0 is used, no printout of the arma patterns are given.</p>
</td></tr>
<tr><td><code id="define.model_+3A_ar.fill">ar.fill</code></td>
<td>
<p>sequence of triplets: c(dependent variable, independent
variable, lag). ar.fill=c(2, 3, 12): Insert ar-indicator for model for
dependent variable 2 and independent variable 3 at lag 12.</p>
</td></tr>
<tr><td><code id="define.model_+3A_ar.rem">ar.rem</code></td>
<td>
<p>sequence of triplets c(dependent variable, independent
variable, lag). ar.rem=c(2, 3, 12): remove (if present) ar-indicator for model
for dependent variable 2 and independent variable 3 at lag 12.</p>
</td></tr>
<tr><td><code id="define.model_+3A_ma.fill">ma.fill</code></td>
<td>
<p>sequence of triplets: c(dependent variable, independent
variable, lag). ma.fill=c(2, 3, 12): Insert ma-indicator for model for
dependent variable 2 and independent variable 3 at lag 12.</p>
</td></tr>
<tr><td><code id="define.model_+3A_ma.rem">ma.rem</code></td>
<td>
<p>sequence of triplets c(dependent variable, independent
variable, lag). ma.rem=c(2, 3, 12): remove (if present) ma-indicator for model
for dependent variable 2 and independent variable 3 at lag 12.
</p>
<p>The various parameters may (in some cases) accomplish the same model
requirements. The routine define.model apply these input parameters
successively in the following order: 1) rem.var, 2) reg.var, 3) indep,
4) no.dep, 5) ar.fill, 6) ar.rem, 7) ma.fil, 8) ma.rem
</p>
<p>The parameters ar.fill, ar.rem, ma.fill and ma.rem are applied last, and
in that order. They overwrite what previously has been defined.</p>
</td></tr>
<tr><td><code id="define.model_+3A_indep">indep</code></td>
<td>
<p>no. of variable(s) that are independent of the other
variables. indepc(2, 4) makes variables 2 and 4 independent of all
other variables. Variables 2 and 4 may influence other variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ar.pattern  a matrix polynomium (an array) with 1's and 0's
defining
the autoregressive matrix polynomium to be fitted by marima (an array
with dim=c(kvar, kvar, 1+ar_order) (with leading unity matrix)).
</p>
<p>ma.pattern  a matrix polynomium (an array) with 1's and 0's
defining
the moving average matrix polynomium to be fitted by marima (an array
with dim=c(kvar, kvar, 1+ma_order) (including the leading unity
matrix)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Example 1: 3-variate arma model with ar-lags at 1 and 2, and an
# ma-term at lag 1. And var=3 is a regression variable (X-variable).
#
 Model1 &lt;- define.model(kvar=3, ar=c(1, 2), ma=c(1), reg.var=3)
 short.form(Model1$ar.pattern)
 short.form(Model1$ma.pattern, leading=FALSE)
#
# The object Model1 contains the ar- and ma-pattern arrays as defined.
#
# Model1$ar.pattern and Model1$ma.pattern are used as input to
# marima in order to define the model to be estimated.
#
# Example 2: arma model with ar-lags at 1, 2 and 6, and var=3
#  regression variable (X-variable).
#
 Model2 &lt;- define.model(kvar=3, ar=c(1, 2, 6), ma=c(1), reg.var=3)
# Print the ar- and ma-polynomial patterns using
 short.form(Model2$ar.pattern, leading=FALSE)
 short.form(Model2$ma.pattern, leading=TRUE)
#
# Example 3: arma model with ar-lags at 1, 2 and 6, and reg.var=3
# (X-variable). ma-order=1. Finally (ar.fill=c(2, 3, 4) puts  a '1'
# for (dep-var=2, indep-var=3, ar-lag=4).
#
# If further modifications of the ar- or ma-patterns are needed, it
# can be accomplished before calling marima (Model3$ar.pattern and
# Model3$ma.pattern are arrays).
#
 Model3 &lt;- define.model(kvar=3, ar=c(1, 2, 6), ma=c(1), reg.var=3,
    ar.fill=c(2, 3, 4))
 short.form(Model3$ar.pattern)
 short.form(Model3$ma.pattern)
#
 Model4 &lt;- define.model(kvar=3, ar=c(1, 2, 6), ma=c(1), reg.var=3, 
 ar.fill=c(2, 3, 4), indep=c(1))
 short.form(Model4$ar.pattern)
 short.form(Model4$ma.pattern, leading=FALSE)

</code></pre>

<hr>
<h2 id='define.sum'>define.sum</h2><span id='topic+define.sum'></span>

<h3>Description</h3>

<p>Function to aggregate multivariate time series.
Reverse of function 'define.dif'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define.sum(series = NULL, difference = NULL, averages = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="define.sum_+3A_series">series</code></td>
<td>
<p>series to be summed up.</p>
</td></tr>
<tr><td><code id="define.sum_+3A_difference">difference</code></td>
<td>
<p>differencing pattern (see define.dif).</p>
</td></tr>
<tr><td><code id="define.sum_+3A_averages">averages</code></td>
<td>
<p>of the individual series that (usually) have
been subtracted when differencing the time series (if so,
the averages are supplied in the output from define.dif(...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sum.series  the summed series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4711)
y &lt;- round(matrix(100*rnorm(48), nrow=4))
difference=matrix(c(1, 1,  1, 1,  2, 1,  3, 6), nrow=2)
dy &lt;- define.dif(y, difference)$dif.series
averages &lt;- define.dif(y, difference)$averages
sum.y &lt;- define.sum(dy, difference, averages)$series.sum
y
dy
averages
sum.y

</code></pre>

<hr>
<h2 id='forec.var'>forec.var</h2><span id='topic+forec.var'></span>

<h3>Description</h3>

<p>Function for calculation of variances of nstep forecasts
using a marima type model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forec.var(marima, nstep = 1, dif.poly = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forec.var_+3A_marima">marima</code></td>
<td>
<p>marima object (cov.u and ar.estimates and
ma.estimates are used)</p>
</td></tr>
<tr><td><code id="forec.var_+3A_nstep">nstep</code></td>
<td>
<p>length of forecast</p>
</td></tr>
<tr><td><code id="forec.var_+3A_dif.poly">dif.poly</code></td>
<td>
<p>autoregressive representation of differencing
polynomial as constructed by the function
define.dif(...) when the time series is differenced
(if so) before being analysed by marima.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pred.var    = variance-covariances for nstep forecasts
(an array with dimension (kvar, kvar, nstep).
</p>
<p>rand.shock   = corresponding random shock representation
of the model used.
</p>

<hr>
<h2 id='inverse.form'>inverse.form</h2><span id='topic+inverse.form'></span>

<h3>Description</h3>

<p>Calculation of inverse form for arma model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse.form(ar.poly, ma.poly, L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse.form_+3A_ar.poly">ar.poly</code></td>
<td>
<p>=autoregressive matrix part of model (array(k, k, ar-order)).</p>
</td></tr>
<tr><td><code id="inverse.form_+3A_ma.poly">ma.poly</code></td>
<td>
<p>=moving average matrix part of model (array(k, k, ma-order)).</p>
</td></tr>
<tr><td><code id="inverse.form_+3A_l">L</code></td>
<td>
<p>=order of return polynomial (length=L+1 including leading
unity matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>inverse form for arma model up to order L (array(k, k, L+1)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4711)
p1  &lt;- check.one(matrix(rnorm(16), nrow=4))
p2  &lt;- check.one(array(rnorm(32),dim=c(4, 4, 2)))
inverse &lt;- inverse.form(ar.poly=p1, ma.poly=p2, L=6)
short.form(inverse)

</code></pre>

<hr>
<h2 id='lead.one'>lead.one</h2><span id='topic+lead.one'></span>

<h3>Description</h3>

<p>Function to add (or remove) a leading unity matrix to (from)
an  array
(being an array representation of ar- or ma-polynomial).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lead.one(polyn = NULL, add = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lead.one_+3A_polyn">polyn</code></td>
<td>
<p>an input polynomium (an array).</p>
</td></tr>
<tr><td><code id="lead.one_+3A_add">add</code></td>
<td>
<p>indicator for adding or removing unity matrix:
+1 = add leading unity matrix,
-1 = remove leading matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>changed array (with leading unity matrix inserted or
removed).
</p>

<hr>
<h2 id='marima'>marima</h2><span id='topic+marima'></span>

<h3>Description</h3>

<p>Estimate multivariate arima and arima-x models.
Setting up the proper model for (especially) arima-x estimation
can be accomplished using the routine 'define.model' that can
assist in setting up the necessary autoregressive and moving average
patterns used as input to 'marima'.
</p>
<p>A more elaborate description of 'marima' and how it is used
can be downloaded from:
</p>
<p>http://www.imm.dtu.dk/~hspl/marima.use.pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marima(DATA = NULL, ar.pattern = NULL, ma.pattern = NULL, means = 1,
  max.iter = 50, penalty = 0, weight = 0.33, Plot = "none",
  Check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marima_+3A_data">DATA</code></td>
<td>
<p>time series matrix, dim(DATA) = c(kvar, n), 
where 'kvar' is the dimension of the time series and 'n' is the
length of the series. If DATA is organized (n, kvar) (as a data.frame
e.g.) it is automatically transposed in marima, and the user need
not care about it. Also, and consequently, the output residuals and
fitted values matrices are both organised c(kvar, n) at return from marima.
The DATA is checked for completeness. Cases which include 'NA's or 'NaN's
are initially left out. A message is given (on the console) and the active
cases are given in the output object (...$used.cases). If DATA is a time
series object it is transformed to a matrix and a warning is given
( if(is.ts(DATA))  DATA &lt;- as.matrix(data.frame(DATA))  and a message
is given (on the console).</p>
</td></tr>
<tr><td><code id="marima_+3A_ar.pattern">ar.pattern</code></td>
<td>
<p>autoregressive pattern for model (see define.model).
If ar.pattern is not specified a pure ma-model is estimated.</p>
</td></tr>
<tr><td><code id="marima_+3A_ma.pattern">ma.pattern</code></td>
<td>
<p>moving average pattern for model (see define.model).
If ma.pattern is not specified a pure ar-model is estimated. In this case
the estimation is carried out by regression analysis in a few steps.</p>
</td></tr>
<tr><td><code id="marima_+3A_means">means</code></td>
<td>
<p>0/1 indicator vector of length kvar, indicating
which variables in the analysis should be means adjusted or not.
Default: means=1 and all variables are means adjusted.
If means=0 is used, no variables are means adjusted.</p>
</td></tr>
<tr><td><code id="marima_+3A_max.iter">max.iter</code></td>
<td>
<p>max. number of iterations in estimation (max.iter=50
is default which, generally, is more than enough).</p>
</td></tr>
<tr><td><code id="marima_+3A_penalty">penalty</code></td>
<td>
<p>parameter used in the R function 'step' for
stepwise model reduction. If penalty=2, the conventional
AIC criterion is used. If penalty=0, no stepwise reduction of model is
performed. Generally 0&lt;=penalty&lt;=2 works well (especially penalty=1).
The level of
significance of the individual parameter estimates in the final
model can be checked by considering the (approximate) 'ar.pvalues'
and the 'ma.pvalues' calculated by marima.</p>
</td></tr>
<tr><td><code id="marima_+3A_weight">weight</code></td>
<td>
<p>weighting factor for smoothing the repeated
estimation procedure. Default is weight=0.33 which often works
well. If weight&gt;0.33 (e.g. weight=0.66) is specified more damping
will result. If a large damping factor is used, the successive
estimations are more cautious, and a slower (but safer)
convergence (if possible) may result (max.iter may have to be
increased to, say, max.iter=75.</p>
</td></tr>
<tr><td><code id="marima_+3A_plot">Plot</code></td>
<td>
<p>'none' or 'trace' or 'log.det' indicates a plot that shows
how the residual covariance matrix (resid.cov) develops with the
iterations.
If Plot= 'none' no plot is generated.
If Plot= 'trace' a plot of the trace of the residual
covariance matrix versus iterations is generated.
If Plot='log.det' the log(determinant) of the residual
covariance matrix (resid.cov) is generated. Default is Plot= 'none'.</p>
</td></tr>
<tr><td><code id="marima_+3A_check">Check</code></td>
<td>
<p>(TRUE/FALSE) results (if TRUE) in a printout of some
controls of the call to arima. Useful in the first attemp(s) to use
marima. Default=FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class marima containing:
</p>
<p>N            = N length of analysed series
</p>
<p>kvar         = dimension of time series (all random and
non-random variables).
</p>
<p>ar.estimates = ar-estimates
</p>
<p>ma.estimates = ma-estimates
</p>
<p>ar.fvalues   = ar-fvalues (approximate)
</p>
<p>ma.fvalues   = ma-fvalues (approximate)
</p>
<p>ar.stdv      = standard devaitions of ar-estimates (approximate)
</p>
<p>ma.stdv      = standard deviations of ma-estimates (approximate)
</p>
<p>ar.pvalues   = ar.estimate p-values (approximate). If in the input data two
series are identical or one (or more) series is (are)
linearly dependent of the
the other series the routine lm(...) generates &quot;NA&quot; for estimates
t-values, p-values and and parameter standard deviations. In
marima the corresponding estimates, F-values and
parameter standard deviations
are set to 0 (zero) while the p-value(s) are set to &quot;NaN&quot;. Can happen
only for ar-parameters.
</p>
<p>ma.pvalues   = ma.estimate p-values (approximate)
</p>
<p>residuals = estimated residuals (for used.cases), leading values
(not estimated values) are put equal to NA
</p>
<p>fitted    = estimated/fitted values for all data
(including non random variables) (for used.cases), leading values
(not estimated values) are put equal to NA
</p>
<p>resid.cov = covariance matrix of residuals
(including non random variables) (computed for used.cases)
</p>
<p>data.cov  = covariance matrix of (all)
input data (for used.cases)
</p>
<p>averages  = averages of input variables
</p>
<p>Constant  = estimated model constant =
(sum_i(ar[, , i])) x averages
</p>
<p>call.ar.pattern = calling ar.pattern
</p>
<p>call.ma.pattern = calling ma.pattern
</p>
<p>out.ar.pattern = resulting ar.pattern
(after possible model reduction)
</p>
<p>out.ma.pattern = resulting ar.pattern
(after possible model reduction)
</p>
<p>max.iter = max no. of iterations in call
</p>
<p>penalty = factor used in AIC model reduction, if penalty=0, no AIC
model redukction is performed (default).
</p>
<p>weight  = weighting of successive residuals
updating (default=0.33)
</p>
<p>used.cases = cases in input which are analysed
</p>
<p>trace   = trace(random part of resid.cov)
</p>
<p>log.det = log(det(random part of resid.cov))
</p>
<p>randoms = which are random variables in problem?
</p>
<p>one.step = one step ahead prediction (for time = N+1)
based on whole series from obs. 1 to N. The computation
is based on the marima residuals (as taken from the last
regression step in the repeated pseudo-regression algorithm).
</p>


<h3>Source</h3>

<p>The code is an R code which is based on the
article (below) by Spliid (1983). A repeated (socalled) pseudo
regression procedure is used in order to estimate the multivariate
arma model.
</p>


<h3>References</h3>

<p>Jenkins, G.M. &amp; Alavi, A. (1981): Some aspects of modelling and forecasting
multivariate time series, Journal of Time Series Analysis, 
Vol. 2, issue 1, Jan. 1981, pp. 1-47.
</p>
<p>Madsen, H. (2008) Time Series Analysis, Chapmann \&amp; Hall (in particular
chapter 9: Multivariate time series).
</p>
<p>Reinsel, G.C. (2003) Elements of Multivariate Time Series Analysis, 
Springer Verlag, 2$^nd$ ed. pp. 106-114.
</p>
<p>Shumway, R.H. &amp; Stoffer, D.S. (2000). Time Series Analysis and
Its Applications, Springer Verlag, (4$^th$ ed. 2016).
</p>
<p>Spliid, H.: A Fast Estimation Method for the Vector
Autoregressive Moving Average Model With Exogenous Variables, Journal
of the American Statistical Association, Vol. 78, No. 384, Dec. 1983, 
pp. 843-849.
</p>
<p>Spliid, H.: Estimation of Multivariate Time Series
with Regression Variables:
</p>
<p>http://www.imm.dtu.dk/~hspl/marima.use.pdf
</p>
<p>www.itl.nist.gov/div898/handbook/pmc/section4/pmc45.htm
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1:
library(marima)
# Generate a 4-variate time series (in this example):
#
kvar&lt;-4 ; set.seed(4711)
y4&lt;-matrix(round(100*rnorm(4*1000, mean=2.0)), nrow=kvar)
# If wanted define differencing of variable 4 (lag=1)
# and variable 3 (lag=6), for example:
y4.dif&lt;-define.dif(y4, difference=c(4, 1, 3, 6))
# The differenced series will be in y4.dif$y.dif, the observations
# lost by differencing being excluded.
#
y4.dif.analysis&lt;-y4.dif$y.dif
# Give lags the be included in ar- and ma-parts of model:
#
ar&lt;-c(1, 2, 4)
ma&lt;-c(1)
# Define the multivariate arma model using 'define.model' procedure.
# Output from 'define.model' will be the patterns of the ar- and ma-
# parts of the model specified.
#
Mod &lt;- define.model(kvar=4, ar=ar, ma=ma, reg.var=3)
arp&lt;-Mod$ar.pattern
map&lt;-Mod$ma.pattern
# Print out model in 'short form':
#
short.form(arp)
short.form(map)
# Now call marima:
Model &lt;- marima(y4.dif.analysis, ar.pattern=arp, ma.pattern=map, 
                penalty=0.0)
# The estimated model is in the object 'Model':
#
ar.model&lt;-Model$ar.estimates
ma.model&lt;-Model$ma.estimates
dif.poly&lt;-y4.dif$dif.poly  # = difference polynomial in ar-form.
# Multiply the estimated ar-polynomial with difference polynomial
# to compute the aggregated ar-part of the arma model:
#
ar.aggregated &lt;- pol.mul(ar.model, dif.poly, L=12)
# and print everything out in 'short form':
#
short.form(ar.aggregated, leading=FALSE)
short.form(ma.model, leading=FALSE)

</code></pre>

<hr>
<h2 id='marima.sim'>marima.sim</h2><span id='topic+marima.sim'></span>

<h3>Description</h3>

<p>Simulation of multivariate arma model of
type 'marima'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marima.sim(kvar = 1, ar.model = NULL, ar.dif = NULL, ma.model = NULL,
  averages = rep(0, kvar), resid.cov = diag(kvar), seed = NULL,
  nstart = 0, nsim = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marima.sim_+3A_kvar">kvar</code></td>
<td>
<p>dimension of one observation (from
kvar-variate time series).</p>
</td></tr>
<tr><td><code id="marima.sim_+3A_ar.model">ar.model</code></td>
<td>
<p>array holding the autoregressive part of model, 
organised as in the marima$ar.estimates. May be
empty (default = NULL) when there is no autoregressive part.</p>
</td></tr>
<tr><td><code id="marima.sim_+3A_ar.dif">ar.dif</code></td>
<td>
<p>array holding differencing polynomium of model, 
typically generated by applying the function define.dif. May be
empty (default = NULL) when differencing is not included.</p>
</td></tr>
<tr><td><code id="marima.sim_+3A_ma.model">ma.model</code></td>
<td>
<p>array holding the moving average part of model, 
organised as in the marima$ma.estimates. May be
empty (default = NULL) when there is no moving average part.</p>
</td></tr>
<tr><td><code id="marima.sim_+3A_averages">averages</code></td>
<td>
<p>vector holding the kvar averages of the
variables in the simulated series.</p>
</td></tr>
<tr><td><code id="marima.sim_+3A_resid.cov">resid.cov</code></td>
<td>
<p>(kvar x kvar) innovation covariance matrix.</p>
</td></tr>
<tr><td><code id="marima.sim_+3A_seed">seed</code></td>
<td>
<p>seed for random number generator (set.seed(seed)).
If the seed is set by the user, the random number generator is 
initialised. If seed is not set no initialisation is done.</p>
</td></tr>
<tr><td><code id="marima.sim_+3A_nstart">nstart</code></td>
<td>
<p>number of extra observations in the start of the
simulated series to be left out before returning. If nstart=0
in calling marima.sim a suitable value is computed (see code).</p>
</td></tr>
<tr><td><code id="marima.sim_+3A_nsim">nsim</code></td>
<td>
<p>length of (final) simulated series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated kvar variate time series of length = nsim.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(marima)
data(austr)
old.data &lt;- t(austr)[, 1:83]
Model2   &lt;- define.model(kvar=7, ar=c(1), ma=c(1),
                    rem.var=c(1, 6, 7), indep=NULL)
Marima2  &lt;- marima(old.data, means=1, ar.pattern=Model2$ar.pattern, 
 ma.pattern=Model2$ma.pattern, Check=FALSE, Plot="none", penalty=4)

resid.cov  &lt;- Marima2$resid.cov
averages   &lt;- Marima2$averages
        ar &lt;- Marima2$ar.estimates
        ma &lt;- Marima2$ma.estimates

N    &lt;- 1000
kvar &lt;- 7

y.sim &lt;- marima.sim(kvar = kvar, ar.model = ar, ma.model = ma, 
  seed = 4711, averages = averages, resid.cov = resid.cov, nsim = N)

# Now simulate from model identified by marima (model=Marima2).
# The relevant ar and ma patterns are saved in 
# Marima2$out.ar.pattern and Marima2$out.ma.pattern, respectively: 

Marima.sim &lt;- marima( t(y.sim), means=1, 
     ar.pattern=Marima2$out.ar.pattern, 
     ma.pattern=Marima2$out.ma.pattern, 
     Check=FALSE, Plot="none", penalty=0) 

cat("Comparison of simulation model and estimates", 
" from simulated data. \n")
   round(Marima2$ar.estimates[, , 2], 4)
round(Marima.sim$ar.estimates[, , 2], 4)

   round(Marima2$ma.estimates[, , 2], 4)
round(Marima.sim$ma.estimates[, , 2], 4)

</code></pre>

<hr>
<h2 id='pol.inv'>pol.inv</h2><span id='topic+pol.inv'></span>

<h3>Description</h3>

<p>Calculation of left inverse of matrix polynomial. The
leading term
is expected to be the (k by k) identity matrix. This is checked
and the proper leading unity term is taken into account when the
inverse is calculated.
</p>
<p>phi = matrix polynomial coefficients = I, phi1, phi2, ..., phi(p).
</p>
<p>dim(phi) = c(k, k, p+1) where k = dimension of coefficient
matrices (k by k), and L  = order of polynomial (length = 1+L ,
including the leading unity matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pol.inv(phi, L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pol.inv_+3A_phi">phi</code></td>
<td>
<p>polynomium (an array) to invert</p>
</td></tr>
<tr><td><code id="pol.inv_+3A_l">L</code></td>
<td>
<p>order of inverse polynomium</p>
</td></tr>
</table>


<h3>Value</h3>

<p>left inverse of phi of order L (L+1 terms including leading
unity matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4711)
p2&lt;-check.one(array(rnorm(32),dim=c(4,4,2)))
pi2&lt;-pol.inv(p2,L=12)
short.form(pi2)

</code></pre>

<hr>
<h2 id='pol.mul'>pol.mul</h2><span id='topic+pol.mul'></span>

<h3>Description</h3>

<p>Calculation of product of two matrix
polynomials (arrays).
</p>
<p>If one or both leading unity matrices (of eta and theta) are
missing, they are (it is)
generated (and taken into account).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pol.mul(eta, theta, L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pol.mul_+3A_eta">eta</code></td>
<td>
<p>first matrix polynomial</p>
</td></tr>
<tr><td><code id="pol.mul_+3A_theta">theta</code></td>
<td>
<p>second matrix olynomial</p>
</td></tr>
<tr><td><code id="pol.mul_+3A_l">L</code></td>
<td>
<p>order of output polynomial (length = L+1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix polynomial product af eta and theta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4711)
p1 &lt;- check.one(matrix(rnorm(16), nrow=4))
p2 &lt;- check.one(array(rnorm(32),dim=c(4, 4, 2)))
p12 &lt;- pol.mul(p1, p2, L=(2+3))
short.form(p12)

</code></pre>

<hr>
<h2 id='pol.order'>pol.order</h2><span id='topic+pol.order'></span>

<h3>Description</h3>

<p>Function to evaluate (significant)
order of matrix polynomium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pol.order(polyn = NULL, digits = 12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pol.order_+3A_polyn">polyn</code></td>
<td>
<p>the polynomium the order of which is determined.</p>
</td></tr>
<tr><td><code id="pol.order_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to be considered (values
smaller than 10^(-digits) are taken to be 0 (zero)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pol.order order of polynomium polyn.
(exclusive the leading unity matrix if present.
pol.order=0 corresponds to the k by k unity matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pol          &lt;- array(1e-8*rnorm(96),dim=c(4,4,6))
pol[, , 1:3] &lt;- array(rnorm(48), dim=c(4,4,3))
pol.order(polyn=pol, digits=12)
pol.order(polyn=pol, digits=4)

</code></pre>

<hr>
<h2 id='print.marima'>print.marima</h2><span id='topic+print.marima'></span>

<h3>Description</h3>

<p>Print some (most relevant) content of a marima object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marima'
print(x, estimates = TRUE, pvalues = FALSE,
  pattern = TRUE, fvalues = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.marima_+3A_x">x</code></td>
<td>
<p>= a marima object with results of marima analysis.</p>
</td></tr>
<tr><td><code id="print.marima_+3A_estimates">estimates</code></td>
<td>
<p>= TRUE/FALSE: printout of parameter estimates.</p>
</td></tr>
<tr><td><code id="print.marima_+3A_pvalues">pvalues</code></td>
<td>
<p>= TRUE/FALSE: printout of (approximate) p-values for
parameter estimates.</p>
</td></tr>
<tr><td><code id="print.marima_+3A_pattern">pattern</code></td>
<td>
<p>= TRUE/FALSE: printout of model definition pattern(s).</p>
</td></tr>
<tr><td><code id="print.marima_+3A_fvalues">fvalues</code></td>
<td>
<p>= TRUE/FALSE: printout of parameter (approximate)
F-values.</p>
</td></tr>
<tr><td><code id="print.marima_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='rand.shock'>rand.shock</h2><span id='topic+rand.shock'></span>

<h3>Description</h3>

<p>Calculation of random shock form for arma model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand.shock(ar.poly, ma.poly, L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rand.shock_+3A_ar.poly">ar.poly</code></td>
<td>
<p>autoregressive matrix part of model</p>
</td></tr>
<tr><td><code id="rand.shock_+3A_ma.poly">ma.poly</code></td>
<td>
<p>moving average matrix part of model</p>
</td></tr>
<tr><td><code id="rand.shock_+3A_l">L</code></td>
<td>
<p>order of return polynomial  (length=L+1 including
leading unity matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>random shock form of arma model up to order L (array(k,k,L+1))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4711)
p1 &lt;- check.one(matrix(rnorm(16),nrow=4))
p2 &lt;- check.one(array(rnorm(32),dim=c(4, 4, 2)))
randshock &lt;- rand.shock(ar.poly=p1, ma.poly=p2, L=6)
short.form(randshock)

</code></pre>

<hr>
<h2 id='Results'>Results</h2><span id='topic+Results'></span>

<h3>Description</h3>

<p>function which generates a matrix from summary(Model),
where 'Model' is an 'lm' object. Is used by marima, in case there can
be one or more non-identifiable (ar-)parameters when estimating
the lm-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Results(Model = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Results_+3A_model">Model</code></td>
<td>
<p>= an 'lm' object (with NA's for non-identifiable
ar.parameters in the 'lm' specification, if so).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results = matrix with 4 columns containing the same information
as summary(Model),
but with &quot;NA&quot; rows replaced by rows = c(0, 0, 0, NaN).
</p>

<hr>
<h2 id='season.lagging'>season.lagging</h2><span id='topic+season.lagging'></span>

<h3>Description</h3>

<p>Generate new time series with (seasonally) lagged variables
from lagging pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>season.lagging(y, lagging = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="season.lagging_+3A_y">y</code></td>
<td>
<p>= data series</p>
</td></tr>
<tr><td><code id="season.lagging_+3A_lagging">lagging</code></td>
<td>
<p>= lagging array array describing what to be added
to y: c(1, 3, 6) adds a new y3,  using y1 lagged 6 time steps.
lagging&lt;-matrix(c(1, 3, 6-1, 2, 4, 12-1), nrow=3) adds two new variables
(y3 and y4) using y1 lagged 6-1 time steps and y2 lagged 12-1 time
steps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y.lagged = the part of the new series (including new
lagged variables) that can be entered into marima
</p>
<p>y.future = the part of the new series (including new
lagged variables) that does not include future observation
</p>
<p>y.lost = previous values of the time series that is
incomplete with respect to the new variables generated by lagging
</p>
<p>cbind(y.lost, y.lagged.y, y.future) is the complete series after
creation and addition of the lagged variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4711)
# generate bivariate time series
y&lt;-round(matrix(10*rnorm(36), nrow=2))
y
# define new lagged variables (y3 and y4) with seasonalities 6 and 12
lagging &lt;- c(1, 3, (6-1),  2, 4, (12-1)) 
season.lagging(y, lagging)

</code></pre>

<hr>
<h2 id='short.form'>short.form</h2><span id='topic+short.form'></span>

<h3>Description</h3>

<p>Function to condensate (and/or) print out matrix
polynomium leaving out empty lag matrices and, if specified,
the leading (unity) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>short.form(poly = NULL, name = "Lag=", leading = TRUE, tail = FALSE,
  digits = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="short.form_+3A_poly">poly</code></td>
<td>
<p>matrix polynomium (0-1 array as construced by define.model,
for example, or array of reals as estimated by marima).</p>
</td></tr>
<tr><td><code id="short.form_+3A_name">name</code></td>
<td>
<p>character string used as header in output (default='lag').</p>
</td></tr>
<tr><td><code id="short.form_+3A_leading">leading</code></td>
<td>
<p>TRUE/FALSE. If leading=FALSE the leading (unity matrix)
is to be left out/suppressed.</p>
</td></tr>
<tr><td><code id="short.form_+3A_tail">tail</code></td>
<td>
<p>TRUE/FALSE. If TRUE and the ar/ma-model only consists
of coefficient matrice(s) where all coefficients (except the
leading unity matrix) are all zero a first order coefficient matrix
(being zero) is retained (in order to avoid a model containing only
the leading unity matrix).
</p>
<p>If tail=TRUE and the coefficients in the first coefficient matrix
(after the leading unity matrix) are all zero, the leading unity
matrix is always retained.</p>
</td></tr>
<tr><td><code id="short.form_+3A_digits">digits</code></td>
<td>
<p>the number of digits retained by short.form (default=6).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Model&lt;-define.model(kvar=4, ar=c(1, 2, 4), ma=c(1), reg.var=4)
short.form(Model$ar.pattern)
short.form(Model$ma.pattern)
short.form(Model$ar.pattern, leading=FALSE)
short.form(Model$ar.pattern, leading=FALSE)
#
M&lt;-define.model(kvar=4, ma=c(1))
short.form(M$ar.pattern)
short.form(M$ar.pattern, tail=TRUE)
short.form(M$ar.pattern, leading=FALSE, tail=TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
