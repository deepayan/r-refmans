<!DOCTYPE html><html><head><title>Help for package confreq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {confreq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#confreq-package'><p>Configural Frequencies Analysis Using Log-linear Modeling</p></a></li>
<li><a href='#binomial_test_cfa'><p>Binomial Test</p></a></li>
<li><a href='#CFA'><p>Configural Frequencies Analysis Main Function</p></a></li>
<li><a href='#chi_local_test_cfa'><p>Local Chi-Square Test</p></a></li>
<li><a href='#coef.CFA'><p>S3 coefficients for CFA</p></a></li>
<li><a href='#dat2cov'><p>conversion of a covariate dataset into summary covariate values</p></a></li>
<li><a href='#dat2fre'><p>dataset to pattern frequency conversion</p></a></li>
<li><a href='#design_cfg_cfa'><p>Designmatrix for log linear CFA models</p></a></li>
<li><a href='#df_des_cfa'><p>Degrees of freedom</p></a></li>
<li><a href='#expected_cfa'><p>Expected frequencies with glm</p></a></li>
<li><a href='#expected_margin_cfa'><p>Expected frequencies using margins</p></a></li>
<li><a href='#fre2dat'><p>pattern frequency to dataset conversion</p></a></li>
<li><a href='#fre2tab'><p>pattern frequency to table conversion</p></a></li>
<li><a href='#ftab'><p>Tabulating Answer Categories in Data</p></a></li>
<li><a href='#lazar'><p>The Data Example from Lazarsfeld and Henry</p></a></li>
<li><a href='#Lienert1978'><p>The Lienert (1978) Data</p></a></li>
<li><a href='#LienertLSD'><p>The Lienert LSD Data</p></a></li>
<li><a href='#lr'><p>Likelihood Ratio Chi-square (LR)</p></a></li>
<li><a href='#newborns'><p>The Data Example from Stemmler 2020</p></a></li>
<li><a href='#plot.CFA'><p>S3 plot for CFA</p></a></li>
<li><a href='#plot.S2CFA'><p>S3 plot for S2CFA</p></a></li>
<li><a href='#pos_cfg_cfa'><p>Possible configurations</p></a></li>
<li><a href='#print.Pfreq'><p>S3 print for Pfreq</p></a></li>
<li><a href='#S2CFA'><p>Configural Frequencies Analysis for two Samples.</p></a></li>
<li><a href='#stirling_cfa'><p>Approximation to the binomial using Stirling's Formula</p></a></li>
<li><a href='#suicide'><p>The Krauth &amp; Lienert suicide Data</p></a></li>
<li><a href='#summary.CFA'><p>S3 Summary for CFA</p></a></li>
<li><a href='#summary.S2CFA'><p>S3 Summary for S2CFA</p></a></li>
<li><a href='#z_tests_cfa'><p>Two z-Approximation Tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Configural Frequencies Analysis Using Log-Linear Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.1-1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats, gmp, methods, grid, vcd</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Joerg-Henrik Heine, R.W. Alexandrowicz (function stirling_cfa() )
    and some package testing by Mark Stemmler</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joerg-Henrik Heine &lt;jhheine@googlemail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Offers several functions for Configural Frequencies
    Analysis (CFA), which is a useful statistical tool for the analysis of
    multiway contingency tables. CFA was introduced by G. A. Lienert as
    'Konfigurations Frequenz Analyse - KFA'. Lienert, G. A. (1971). 
    Die Konfigurationsfrequenzanalyse: I. Ein neuer Weg zu Typen und Syndromen. 
    Zeitschrift für Klinische Psychologie und Psychotherapie, 19(2), 99–115.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-12 01:10:33 UTC; jhh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-13 05:40:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='confreq-package'>Configural Frequencies Analysis Using Log-linear Modeling</h2><span id='topic+confreq-package'></span>

<h3>Description</h3>

<p>The package <code>confreq</code> offers some functions for Configural Frequencies Analysis (CFA) proposed by G.A. Lienert as an analysis of types and antitypes of persons or objects grouped according to their characteristic (response) pattern. The core principle in the package <code>confreq</code> is to use the function <code><a href="stats.html#topic+glm">glm</a></code> to compute the expected counts based on a model (design) matrix. The main functions are <code><a href="#topic+CFA">CFA</a></code> and <code><a href="#topic+S2CFA">S2CFA</a></code> (see details).
</p>


<h3>Details</h3>

<p>The simplest entry to the package <code>confreq</code> is to use the main function <code><a href="#topic+CFA">CFA</a></code>, which will compute several coefficients of Configural Frequencies Analysis at once.
</p>
<p>More sophisticated control can be achieved by using the several single functions like <code><a href="#topic+expected_cfa">expected_cfa</a></code>, <code><a href="#topic+design_cfg_cfa">design_cfg_cfa</a></code>, <code><a href="#topic+chi_local_test_cfa">chi_local_test_cfa</a></code> , <code><a href="#topic+stirling_cfa">stirling_cfa</a></code> , etc. ...
</p>
<p>Two-Sample-CFA, to detect discriminating pattern between two (sub-) samples, can be performed with the function <code><a href="#topic+S2CFA">S2CFA</a></code>  
</p>
<p>For further description see description of the respective functions.
</p>
<p>A good introduction into the theory and applications of Configural Frequencies Analysis is given in the Textbook 'Person-Centered Methods' by Mark Stemmler (see references).
</p>
<p><em>Additional Information</em>:
Some users running R on 'Linux like' OS distributions (like e.g. Ubuntu &ndash; and in rare cases MAC OS) might report trouble during installation of <code>confreq</code> due to the package dependency <code>gmp</code>, which is used in <code>confreq</code> to perform the exact binomial test. 
This (miss-)behavior can usually traced back to a missing of 'the GNU Multiple Precision Arithmetic Library' in the respective OS installation. To fix this, users might consider to run the following Ubuntu Linux command in a terminal to install the latest GMP Library: 
</p>
<p>'<code>sudo apt-get install libgmp3-dev</code>'.
</p>
<p>For additional information see also <a href="http://www.mathemagix.org/www/mmdoc/doc/html/external/gmp.en.html">http://www.mathemagix.org/www/mmdoc/doc/html/external/gmp.en.html</a> and <a href="https://gmplib.org/">https://gmplib.org/</a>.
</p>
<p>Annotation:
The foundations for this R-Package were established and discussed in Rothenberge (2011) and (finally) in Klagenfurt at FGME 2013 with Rainer Alexandrowicz and Mark Stemmler ...
</p>


<h3>Author(s)</h3>

<ul>
<li><p>Joerg-Henrik Heine &lt;jhheine@googlemail.com&gt;</p>
</li>
<li><p>R.W. Alexandrowicz (function <code>stirling_cfa()</code>)</p>
</li></ul>



<h3>References</h3>

<p>von Eye, A. (2002). <em>Configural Frequency Analysis. Methods, Models, and Applications.</em> Mahwah, NJ, LEA.
</p>
<p>Krauth, J., &amp; Lienert, G. A. (1973). <em>Die Konfigurationsfrequenzanalyse (KFA) und ihre Anwendung in Psychologie und Medizin: ein multivariates nichtparametrisches Verfahren zur Aufdeckung von Typen und Syndromen; mit 70 Tabellen</em>. Freiburg; München: Alber Karl.
</p>
<p>Lazarsfeld, P. F., &amp; Henry, N. W. (1968). <em>Latent structure analysis</em>. Boston: Houghton Mifflin.
</p>
<p>Lienert, G. A. (1978). <em>Verteilungsfreie Methoden in der Biostatistik (Band II)</em> [Non-parametrical methods in the field of biometrics (Vol. II)]. Meisenheim am Glan, Germany: Hain.
</p>
<p>Lienert, G. A. (1971). Die Konfigurationsfrequenzanalyse: I. Ein neuer Weg zu Typen und Syndromen. <em>Zeitschrift für Klinische Psychologie und Psychotherapie, 19</em>(2), 99-115.
</p>
<p>Stemmler, M. (2020). <em>Person-Centered Methods &ndash; Configural Frequency Analysis (CFA) and Other Methods for the Analysis of Contingency Tables</em>. Cham Heidelberg New York Dordrecht London: Springer.
</p>
<p>Stemmler, M., &amp; Hammond, S. (1997). Configural frequency analysis of dependent samples for intra-patient treatment comparisons. <em>Studia Psychologica, 39</em>, 167–175.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
######### some examples ########
data(LienertLSD)
LienertLSD
CFA(LienertLSD)
## testing with (full) interactions
CFA(LienertLSD,form="~ C + T + A + C:T + C:A + T:A + C:T:A")
## testing the null model
CFA(LienertLSD,form="null")
#######################
data(suicide)
suicide
# suicide data is in non tabulated data representation 
# so it must be tabulated !
CFA(dat2fre(suicide))
</code></pre>

<hr>
<h2 id='binomial_test_cfa'>Binomial Test</h2><span id='topic+binomial_test_cfa'></span>

<h3>Description</h3>

<p>Calculates the (exact) binomial test based on obseved, expected frequencies an the total number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial_test_cfa(observed, expected, ntotal = sum(observed))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomial_test_cfa_+3A_observed">observed</code></td>
<td>
<p>a vector giving the observed frequencies.</p>
</td></tr>
<tr><td><code id="binomial_test_cfa_+3A_expected">expected</code></td>
<td>
<p>a vector giving the expected frequencies.</p>
</td></tr>
<tr><td><code id="binomial_test_cfa_+3A_ntotal">ntotal</code></td>
<td>
<p>optional a numeric giving the total number of observations. By default ntotal is calculated as <code>ntotal=sum(observed)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details
</p>


<h3>Value</h3>

<p>a numeric giving the p-value.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
# first calculate expected counts for LienertLSD data example.
designmatrix&lt;-design_cfg_cfa(kat=c(2,2,2)) # generate an designmatrix (only main effects)
data(LienertLSD) # load example data
observed&lt;-LienertLSD[,4] # extract observed counts
expected&lt;-expected_cfa(des=designmatrix, observed=observed) # calculation of expected counts
 binomial_test_cfa(observed,expected)
####################################### 
</code></pre>

<hr>
<h2 id='CFA'>Configural Frequencies Analysis Main Function</h2><span id='topic+CFA'></span>

<h3>Description</h3>

<p>Calculates various coefficients for the Configural Frequencies Analysis (CFA) defining main- and (optional) interaction effects. The core principle is to use <code><a href="stats.html#topic+glm">glm</a></code> in package <code>stats</code> to calculate the expected counts considering a designmatrix, which is constructed based on an formula definition given in argument <code>form</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFA(
  patternfreq,
  alpha = 0.05,
  form = NULL,
  ccor = FALSE,
  family = poisson(),
  intercept = FALSE,
  method = "log",
  blank = NULL,
  cova = NULL,
  bintest = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFA_+3A_patternfreq">patternfreq</code></td>
<td>
<p>an object of class <code>"Pfreq"</code>, which is data in pattern frequencies representation - see function <code><a href="#topic+dat2fre">dat2fre</a></code>.</p>
</td></tr>
<tr><td><code id="CFA_+3A_alpha">alpha</code></td>
<td>
<p>a numeric giving the alpha level for testing (default set to <code>alpha=.05</code>)</p>
</td></tr>
<tr><td><code id="CFA_+3A_form">form</code></td>
<td>
<p>either a character expression which can be coerced into a model formula with the function <code>as.formula</code> in the package <code>stats</code>. If this argument is left empty (at default <code>form=NULL</code>) the (internal) function <code>design_cfg_cfa()</code> will return a designmatrix coding only main effects and no interactions &ndash; for a designmatrix referring to  three variables (V1, V2, V3) for example, leaving the argument <code>form</code> empty will be equivalent to assigning the character <code>"~ V1 + V2 + V3"</code> to the argument (<code>form="~ V1 + V2 + V3"</code>).
A special case is to define a null-model or rather a cfa model of order zero. In such a model no (main) effects are considered. This can be achieved bei passing the character expression <code>"null"</code> to the argument <code>form</code> &ndash; so: <code>form = "null"</code> &ndash; not to be confound with the default setting of this argument <code>form=NULL</code>. Another option is to define your own designmatrix and assign it to this argument (<code>form</code>) in this case the object assigned to <code>form</code> must be of class <code>"matrix"</code> and must logical match to the argument <code>patternfreq</code>, which is currently not checked! - but simply assumed.</p>
</td></tr>
<tr><td><code id="CFA_+3A_ccor">ccor</code></td>
<td>
<p>either a logical (TRUE / FALSE) determining whether to apply a continuity correction or not for the Binomial Approximation to the z-Test. When set to <code>ccor=TRUE</code> continuity correction is applied for expected values 5 =&lt; expected =&lt; 10. For <code>ccor=FALSE</code> no continuity correction is applied. Another option is to set <code>ccor=c(x,y)</code> where x is the lower and y the upper bound for expected values where continuity correction is applied. So <code>ccor=c(5,10)</code> is equivalent to <code>ccor=TRUE</code>.</p>
</td></tr>
<tr><td><code id="CFA_+3A_family">family</code></td>
<td>
<p>argument passed to <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> with default set to <code>poisson()</code></p>
</td></tr>
<tr><td><code id="CFA_+3A_intercept">intercept</code></td>
<td>
<p>argument passed to <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> with default set to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="CFA_+3A_method">method</code></td>
<td>
<p>character defining the estimation method for expected frequencies with default set to <code>method="log"</code> to estimate the expected frequencies using <code><a href="stats.html#topic+glm">glm</a></code>. An other option is to set this argument to <code>method="margins"</code> which will result in expected frequencies calculated based on the margins of the multidimensional contingency table. Only main effects models are possible in this case and thus the arguments <code>form</code>, <code>family</code> <code>cova</code> and <code>intercept</code> are ignored.</p>
</td></tr>
<tr><td><code id="CFA_+3A_blank">blank</code></td>
<td>
<p>can be used to indicate which pattern (configurations) are declared as structural cells (configurations) for functional CFA. Should be either (1) a character vector defining the pattern (with spaces between variable categories), which will be ignored for calculation of expected frequencies; or (2) a numeric vector defining the (row) positions of the pattern in an object of class <code>"Pfreq"</code> (see. argument <code>patternfreq</code>), which will be ignored for calculation of expected frequencies. At default (<code>blank=NULL</code>) all possible pattern, as listed in object of class <code>"Pfreq"</code>, are included for calculation of expected frequencies.</p>
</td></tr>
<tr><td><code id="CFA_+3A_cova">cova</code></td>
<td>
<p>a matrix (possibly with one or more columns) holding the covariate (mean) values for each pattern (configurations) see function <code><a href="#topic+dat2cov">dat2cov</a></code>.</p>
</td></tr>
<tr><td><code id="CFA_+3A_bintest">bintest</code></td>
<td>
<p>a logical with default set to <code>bintest=TRUE</code>; if set to <code>bintest=FALSE</code> no calculations for the exact binomial test are performed, which can reduce processing time in some cases dramatically.</p>
</td></tr>
<tr><td><code id="CFA_+3A_...">...</code></td>
<td>
<p>additional parameters passed through to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function of the package. It internal calls several functions of the package <code><a href="#topic+confreq-package">confreq-package</a></code> which are also available as single functions. For classification of the observed patterns into 'Types' and 'Antitypes' according to Lienert  (1971), a S3 summary method for the resulting object of class <code>"CFA"</code> can be applied - see <code><a href="#topic+summary.CFA">summary.CFA</a></code>. An S3 plot method is useful for visualization of the contingency table and the 'Types' and 'Antitypes' &ndash; see <code><a href="#topic+plot.CFA">plot.CFA</a></code>. Since version  1.6.0-1 of <code>confreq</code> survey weights are supported when tabluating a data set with function <code><a href="#topic+dat2fre">dat2fre</a></code>. In case that for the resulting tabulated data in the object of class <code>c("data.frame","Pfreq")</code> survey weights were used the function <code>CFA</code> will take into account those weigts for estimation of the expected counts &ndash; currently only when <code>method="log"</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>CFA</code> with results.
</p>


<h3>References</h3>

<p>Lienert, G. A. (1971). Die Konfigurationsfrequenzanalyse: I. Ein neuer Weg zu Typen und Syndromen. <em>Zeitschrift für Klinische Psychologie und Psychotherapie, 19</em>(2), 99-115.
</p>
<p>Glück, J., &amp; Von Eye, A. (2000). Including covariates in Configural Frequency Analysis. <em>Psychologische Beitrage, 42</em>, 405–417.
</p>
<p>Victor, N. (1989). An Alternativ Approach to Configural Frequency Analysis. <em>Methodika, 3</em>, 61–73.
</p>
<p>Stemmler, M. (2020). <em>Person-Centered Methods</em>. Cham: Springer International Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
######### some examples ########
data(LienertLSD)
LienertLSD
res1 &lt;- CFA(LienertLSD)
summary(res1)
## testing with (full) interactions
res2 &lt;- CFA(LienertLSD,form="~ C + T + A + C:T + C:A + T:A + C:T:A")
summary(res2)
#' ## testing the null model
res3 &lt;- CFA(LienertLSD,form="null")
summary(res3)
#######################
data(suicide)
suicide
# suicide data is in non tabulated data representation - so it must be tabulated !
res4 &lt;- CFA(dat2fre(suicide))  
summary(res4)
</code></pre>

<hr>
<h2 id='chi_local_test_cfa'>Local Chi-Square Test</h2><span id='topic+chi_local_test_cfa'></span>

<h3>Description</h3>

<p>Calculates the local chi-square test based on obseved and expected frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi_local_test_cfa(observed, expected)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi_local_test_cfa_+3A_observed">observed</code></td>
<td>
<p>a vector giving the observed frequencies.</p>
</td></tr>
<tr><td><code id="chi_local_test_cfa_+3A_expected">expected</code></td>
<td>
<p>a vector giving the expected frequencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details in the moment.
</p>


<h3>Value</h3>

<p>a list with chi-square statistic and corresponding degrees of freedom an p-value.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
# first calculate expected counts for LienertLSD data example.
designmatrix&lt;-design_cfg_cfa(kat=c(2,2,2)) # generate an designmatrix (only main effects)
data(LienertLSD) # load example data
observed&lt;-LienertLSD[,4] # extract observed counts
expected&lt;-expected_cfa(des=designmatrix, observed=observed) # calculation of expected counts
 chi_local_test_cfa(observed,expected)
####################################### 
</code></pre>

<hr>
<h2 id='coef.CFA'>S3 coefficients for CFA</h2><span id='topic+coef.CFA'></span><span id='topic+coefficients'></span>

<h3>Description</h3>

<p>S3 coefficients method for object of class<code>"CFA"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CFA'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.CFA_+3A_object">object</code></td>
<td>
<p>object of class <code>"CFA"</code>.</p>
</td></tr>
<tr><td><code id="coef.CFA_+3A_...">...</code></td>
<td>
<p>other parameters passed trough.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients extracted from the model object of class<code>"CFA"</code>.
</p>

<hr>
<h2 id='dat2cov'>conversion of a covariate dataset into summary covariate values</h2><span id='topic+dat2cov'></span>

<h3>Description</h3>

<p>Given a dataset <code>x</code>, this function returns summary values for some (<code>numeric</code>) covariate variables in <code>x</code> for each pattern (configuration) defined by a set of factor variables in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat2cov(
  x,
  FUN = "mean",
  ...,
  notobs = 0,
  katorder = FALSE,
  caseorder = TRUE,
  wgt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dat2cov_+3A_x">x</code></td>
<td>
<p>an object of class &quot;data.frame&quot; with at least 2 <code>factor</code> variables representing the pattern (configurations) and at least 1 <code>numeric</code> variable representing the covariate(s).</p>
</td></tr>
<tr><td><code id="dat2cov_+3A_fun">FUN</code></td>
<td>
<p>a function to compute the summary statistics which can be applied to all covariate variables in <code>x</code>. See function <code><a href="stats.html#topic+aggregate">aggregate</a></code>.</p>
</td></tr>
<tr><td><code id="dat2cov_+3A_...">...</code></td>
<td>
<p>further arguments passed to or used by methods in <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="dat2cov_+3A_notobs">notobs</code></td>
<td>
<p>a numeric vector possibly with length equal to the number of <code>numeric</code> variables in <code>x</code>, defining the summary value for the respective covariate variable to use for unobserved pattern (configurations) defined by the <code>factor</code> variables in <code>x</code>. By default it is assumed that this value is 0. <code>notobs</code> is recycled if only one value is given.</p>
</td></tr>
<tr><td><code id="dat2cov_+3A_katorder">katorder</code></td>
<td>
<p>see <code><a href="#topic+dat2fre">dat2fre</a></code></p>
</td></tr>
<tr><td><code id="dat2cov_+3A_caseorder">caseorder</code></td>
<td>
<p>see <code><a href="#topic+dat2fre">dat2fre</a></code></p>
</td></tr>
<tr><td><code id="dat2cov_+3A_wgt">wgt</code></td>
<td>
<p>a numerical vector of survey weights to weight the cases (rows) in <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>No further details
</p>


<h3>Value</h3>

<p>An object of class <code>c("data.frame", "Pcov")</code> holding the summary statistics for the covariate variables corresponding to the pattern (configurations) of the given dataset in the argument <code>x</code>.
</p>

<hr>
<h2 id='dat2fre'>dataset to pattern frequency conversion</h2><span id='topic+dat2fre'></span>

<h3>Description</h3>

<p>Given a dataset this function returns a (response) pattern frequencies table representation of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat2fre(
  x,
  katorder = FALSE,
  caseorder = TRUE,
  kat = NULL,
  codes = NULL,
  wgt = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dat2fre_+3A_x">x</code></td>
<td>
<p>an object of class &quot;matrix&quot; or &quot;data.frame&quot;. If <code>x</code> is a &quot;data.frame&quot; each variable (column) must be an <code>integer</code> or a <code>factor</code>. If <code>x</code> is a &quot;matrix&quot; it is assumed that the categories for each variable in <code>x</code> start with <code>1</code> &ndash; there is no check for that !!!</p>
</td></tr>
<tr><td><code id="dat2fre_+3A_katorder">katorder</code></td>
<td>
<p>logical with default set to <code>katorder==FALSE</code>. When set to <code>katorder==TRUE</code> variables are ordered according to their number of categories (variable with most categories is the rightmost variable) in the resulting object.</p>
</td></tr>
<tr><td><code id="dat2fre_+3A_caseorder">caseorder</code></td>
<td>
<p>logical with default set to <code>caseorder==TRUE</code>. When set to <code>caseorder==FALSE</code> configurations are only ordered according to the categories of the rightmost variable in the resulting object.</p>
</td></tr>
<tr><td><code id="dat2fre_+3A_kat">kat</code></td>
<td>
<p>ignored when <code>x</code> is a <code>data.frame</code>! If <code>x</code> is a <code>"matrix"</code> the optional argument <code>kat</code> must be an integer vector defining the number of categories for every variable in <code>x</code> (in the respective order). If left empty the (max) number of categories is estimated from the data given in <code>x</code>.</p>
</td></tr>
<tr><td><code id="dat2fre_+3A_codes">codes</code></td>
<td>
<p>a list with character vectors containing coding for integers in matrix (if <code>x</code> is a numeric <code>matrix</code>). If <code>codes</code> is not empty (and the argument <code>x</code> is an object of class &quot;matrix&quot;) the return object will be pattern frequencies table as <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="dat2fre_+3A_wgt">wgt</code></td>
<td>
<p>a numerical vector of survey weights to weight the cases (rows) in <code>x</code></p>
</td></tr>
<tr><td><code id="dat2fre_+3A_...">...</code></td>
<td>
<p>other parameters passed through to <code><a href="base.html#topic+table">table</a></code> (in case of x  being a <code>data.frame</code>) or to <code><a href="base.html#topic+tabulate">tabulate</a></code> (in case of x being a matrix).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use survey weights a vector of positive numeric values with length matching the number of rows in <code>x</code> must be assigned to the argument <code>wgt</code>. The individual case weights are then aggregated (respective sum of weights) for each pattern observed in the data (assigned to argument <code>x</code>).
</p>


<h3>Value</h3>

<p>An object of class c(&quot;data.frame&quot;,&quot;Pfreq&quot;) containing the (response) pattern frequencies table representation of the given dataset in the argument <code>x</code>.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
data(suicide)# loading data in data frame (702 cases) representation 
dat2fre(suicide) # converting it into a pattern frequencies table

########### 
#######################################
data(LienertLSD)# loading example pattern frequencies table ..
test&lt;-fre2dat(LienertLSD)# and coverting it into a simple (data) matrix
test&lt;-test[sample(c(1:65),65),] # making a messy order 
############
dat2fre(test) # making a proper ordered pattern frequencies table again
##### try it with a data.frame too!
#######################################
</code></pre>

<hr>
<h2 id='design_cfg_cfa'>Designmatrix for log linear CFA models</h2><span id='topic+design_cfg_cfa'></span>

<h3>Description</h3>

<p>Calculates the designmatrix corresponding to a dataset with <code>length(kat)</code> columns (variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_cfg_cfa(
  kat,
  form = paste("~", paste(paste("V", 1:length(kat), sep = ""), collapse = " + ")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_cfg_cfa_+3A_kat">kat</code></td>
<td>
<p>a numerical vector containing kardinal numbers, giving the number of categories for each variable of a dataset (in the respective order of the variables in such a dataset) which corresponds to the requested designmatrix. So the length of this numerical vector represents the number of variables.</p>
</td></tr>
<tr><td><code id="design_cfg_cfa_+3A_form">form</code></td>
<td>
<p>a character string which can be coerced into a model formulae with the function <code>as.formula</code> in the package <code>stats</code>. If this argument is left empty the function <code>design_cfg_cfa()</code> will return a designmatrix coding only main effects and no interactions &ndash; for a designmatrix refering to  three variables for example, leaving the argument <code>form</code> empty will be equivalent to assigning the character <code>"~ V1 + V2 + V3"</code> to the argument (<code>form="~ V1 + V2 + V3"</code>).
</p>
<p>A special Case is to define a null-model or rather a cfa model of order zero. In such a model no (main) effects are considered. This can be achieved bei passing the character expression <code>"null"</code> to the argument <code>form</code> &ndash; so: <code>form = "null"</code></p>
</td></tr>
<tr><td><code id="design_cfg_cfa_+3A_...">...</code></td>
<td>
<p>additional parameters passed through to function <code>model.matrix</code> in package <code>stats</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function internaly calls the function <code><a href="#topic+pos_cfg_cfa">pos_cfg_cfa</a></code>.
</p>
<p>For further information on designmatrices see decription on function <code>model.matrix</code> in the package <code>stats</code>.
</p>


<h3>Value</h3>

<p>A designmatrix - an object of class <code>c("matrix","design_cfg_cfa")</code> - for the formula therm given in argument<code>form</code>.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
# designmatrix with three main effects.
# three variables with two categories each.
design_cfg_cfa(kat=c(2,2,2))
# two variables with two categories each and one variable
# with 7 categories (Lienert LSD example).
design_cfg_cfa(kat=c(2,2,7))
###########
# designmatrix with three main effects an three interactions.
# three variables with two categories each.
design_cfg_cfa(kat=c(2,2,2),form="~ V1 + V2 + V3 + V1:V2 + V1:V3 + V2:V3")
# two variables with two categories each and one variable
# with 7 categories (e.g. The Krauth &amp; Lienert suicide Data).
design_cfg_cfa(kat=c(2,2,7),form="~ V1 + V2 + V3 + V1:V2 + V1:V3 + V2:V3")
#######################################
</code></pre>

<hr>
<h2 id='df_des_cfa'>Degrees of freedom</h2><span id='topic+df_des_cfa'></span>

<h3>Description</h3>

<p>Calculates the degrees of freedom based on an designmatrix for a (log liniear) CFA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_des_cfa(des)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_des_cfa_+3A_des">des</code></td>
<td>
<p>a designmatrix (object of class &quot;matrix&quot;) as returned by function <code>design_cfg_cfa</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details
</p>


<h3>Value</h3>

<p>An object of class &quot;integer&quot; giving the degrees of freedom for the designmatrix defined in argument <code>des</code>.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
# degrees of freedom for designmatrix with three main effects.
# three variables with two categories each.
df_des_cfa(design_cfg_cfa(kat=c(2,2,2)))
# two variables with two categories each and one variable
# with 7 categories (e.g. The Krauth &amp; Lienert suicide Data).
df_des_cfa(design_cfg_cfa(kat=c(2,2,7)))
###########
# degrees of freedom for designmatrix with three main effects
# and three 'two by two'interactions.
# and tripple interaction --&gt; saturated model --&gt; df=0
# three variables with two categories each.
df_des_cfa(design_cfg_cfa(kat=c(2,2,2),form="~ V1 + V2 + V3 + V1:V2 + V1:V3 + V2:V3 + V1:V2:V3"))
####################################### 
</code></pre>

<hr>
<h2 id='expected_cfa'>Expected frequencies with glm</h2><span id='topic+expected_cfa'></span>

<h3>Description</h3>

<p>Calculates the expected frequencies of counts using log liniear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_cfa(des, observed, family = poisson(), intercept = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_cfa_+3A_des">des</code></td>
<td>
<p>a designmatrix (object of class <code>"matrix"</code>) as returned by function <code>design_cfg_cfa</code>.</p>
</td></tr>
<tr><td><code id="expected_cfa_+3A_observed">observed</code></td>
<td>
<p>a integer vector with <code>lenght(observed) == dim(des)[1]</code>. WARNING: The observed frequencies counts must be in an order corresponding to the coding sheme in designmatix (see argument <code>des</code>).</p>
</td></tr>
<tr><td><code id="expected_cfa_+3A_family">family</code></td>
<td>
<p>argument passed to <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> with default set to <code>poisson()</code></p>
</td></tr>
<tr><td><code id="expected_cfa_+3A_intercept">intercept</code></td>
<td>
<p>argument passed to <code>glm.fit</code> with default set to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="expected_cfa_+3A_...">...</code></td>
<td>
<p>aditional arguments optional passed to <code><a href="stats.html#topic+glm.fit">glm.fit</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details
</p>


<h3>Value</h3>

<p>An vector object giving the expected counts.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
# expected counts for LienertLSD data example.
designmatrix&lt;-design_cfg_cfa(kat=c(2,2,2)) # generate an designmatrix (only main effects)
data(LienertLSD) # load example data
observed&lt;-LienertLSD[,4] # extract observed counts
expected_cfa(des=designmatrix, observed=observed) # calculation of expected counts
####################################### 
</code></pre>

<hr>
<h2 id='expected_margin_cfa'>Expected frequencies using margins</h2><span id='topic+expected_margin_cfa'></span>

<h3>Description</h3>

<p>Calculates the expected frequencies of counts based on the margins of the k-dimensional contingency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_margin_cfa(Pfreq, blank = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_margin_cfa_+3A_pfreq">Pfreq</code></td>
<td>
<p>Object of class &quot;Pfreq&quot; (see. function <code><a href="#topic+dat2fre">dat2fre</a></code>).</p>
</td></tr>
<tr><td><code id="expected_margin_cfa_+3A_blank">blank</code></td>
<td>
<p>Either (1) character vector defining the pattern (with spaces between variable categories), which will be ignored for calculation of expected frequencies; or (2) a numeric vector defining the position(s) of the pattern in object of class <code>"Pfreq"</code>, which will be ignored for calculation of expected frequencies. At default (<code>blank=NULL</code>) all possible pattern, as listed in object of class <code>"Pfreq"</code>, are included for calculation of expected frequencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>only main effects are considered.
</p>


<h3>Value</h3>

<p>An vector object giving the expected counts.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
# expected counts for LienertLSD data example.
data(LienertLSD) # load example data
expected_margin_cfa(Pfreq = LienertLSD) # calculation of expected counts (only main effects).
####################################### 
</code></pre>

<hr>
<h2 id='fre2dat'>pattern frequency to dataset conversion</h2><span id='topic+fre2dat'></span>

<h3>Description</h3>

<p>Given a (response) pattern frequencies table this function returns a dataset representation of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fre2dat(x, fact = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fre2dat_+3A_x">x</code></td>
<td>
<p>an object of class &quot;matrix&quot; which is a (response) pattern frequencies table. It is assumed, that the last column of the object <code>x</code> represents the frequencies of the (respose) patern represented by the other columns in <code>x</code>.</p>
</td></tr>
<tr><td><code id="fre2dat_+3A_fact">fact</code></td>
<td>
<p>logical, default is <code>(fact=FALSE)</code>. If this argument is set to <code>(fact=TRUE)</code> the result is coerced to a data.frame with factor variables.</p>
</td></tr>
<tr><td><code id="fre2dat_+3A_...">...</code></td>
<td>
<p>additional parameters passed trough. This is an option to assign factor labels to the resulting <code>data.frame</code> (when setting argument <code>fact=TRUE</code>) &ndash;&gt; see <code>factor</code> in the <code>base</code> package and examples.
</p>
<p>WARNING using this option will only work correct when all 'pattern' columns (variables) in the frequencies table share the same number of categories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details
</p>


<h3>Value</h3>

<p>An object of class &quot;matrix&quot; or &quot;data.frame&quot; (depending on the argument <code>fact</code>) containing the dataset representation of the (response) pattern frequencies table give in the argument <code>x</code>.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
data(LienertLSD)# loading example pattern frequencies table
fre2dat(LienertLSD)# coverting it into a (data) matrix
# for a matrix without colnames
colnames(LienertLSD)&lt;-NULL # first removing the colnames
fre2dat(LienertLSD) # conversion with automatic new colnames
# requesting a data.frame using factor levels 
fre2dat(LienertLSD,fact=TRUE,labels=c("yes","no"))
</code></pre>

<hr>
<h2 id='fre2tab'>pattern frequency to table conversion</h2><span id='topic+fre2tab'></span>

<h3>Description</h3>

<p>Given data as pattern frequencies (object of class class c(&quot;data.frame&quot;,&quot;Pfreq&quot;, see function <code><a href="#topic+dat2fre">dat2fre</a></code>) this function returns a typical array representation (class &quot;table&quot; , see <code><a href="base.html#topic+table">table</a></code>) of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fre2tab(patternfreq, form = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fre2tab_+3A_patternfreq">patternfreq</code></td>
<td>
<p>an object of class c(&quot;data.frame&quot;,&quot;Pfreq&quot;)</p>
</td></tr>
<tr><td><code id="fre2tab_+3A_form">form</code></td>
<td>
<p>a formula object with possibly both left and right hand sides specifying the order of the variables in the resulting table. At default (<code>(formula=NULL)</code>) all variables in <code>(x)</code> are used in their respective order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was introduced in order to connect the typical confreq data representation in the objects of the class <code>c("data.frame","Pfreq")</code>, see function <code><a href="#topic+dat2fre">dat2fre</a></code>, to the R-typical array representation as it exists in objects of the <code>"table"</code> class, see <code><a href="base.html#topic+table">table</a></code>. This array representation of multi-dimensional contingency tables is used more universally in R &ndash; e.g. also in the R package <code>vcd</code>, see the examples section below.
</p>
<p>It is assumed, that the last column of the object <code>patternfreq</code> represents the frequencies of the (response) pattern represented by the other columns in <code>patternfreq</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;table&quot; see <code><a href="base.html#topic+table">table</a></code>.
</p>


<h3>References</h3>

<p>No references at the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
data(LienertLSD)# loading example pattern frequencies table
fre2tab(LienertLSD)# coverting it into a table

### examples using functions from package vcd
data(Lienert1978)# loading example pattern frequencies table
fre2tab(Lienert1978)# coverting it into a table
strucplot(fre2tab(Lienert1978))# plotting data with 'vcd'
structable(fre2tab(Lienert1978),direction = "v")# flatten table (vertical) with 'vcd'

# changing the vertical grouping when flattening the table by unsing a 'formula':
structable(fre2tab(Lienert1978, form=~Group + Student + Teacher),direction = "v")# flatten table
</code></pre>

<hr>
<h2 id='ftab'>Tabulating Answer Categories in Data</h2><span id='topic+ftab'></span>

<h3>Description</h3>

<p>Function tabulating (answer) categories in <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ftab(X, catgories = NULL, na.omit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ftab_+3A_x">X</code></td>
<td>
<p>Data as a <code>"matrix"</code>, a <code>"data.frame"</code> or even a <code>"vector"</code> or <code>"factor"</code>. <code>"vector"</code> or <code>"factor"</code> are coerced to a <code>"data.frame"</code> with one column.</p>
</td></tr>
<tr><td><code id="ftab_+3A_catgories">catgories</code></td>
<td>
<p>optional a vector (<code>"numeric"</code> or <code>"character"</code>) containig the categories to tabulate. At default (<code>catgories=NULL</code>) the fuction looks for unique categories in <code>X</code>.</p>
</td></tr>
<tr><td><code id="ftab_+3A_na.omit">na.omit</code></td>
<td>
<p>logical (default: <code>na.omit=FALSE</code> ) wether to return frequencies for missing values, <code>NA</code>s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> can either be a (<code>"numeric"</code> or <code>"character"</code>) <code>"matrix"</code> containing response vectors of persons (rows) or a <code>"data.frame"</code> containing <code>"numeric"</code>, <code>"character"</code> or <code>"factor"</code> variables (columns).
</p>


<h3>Value</h3>

<p>a <code>"matrix"</code> with category frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########
data(suicide)
ftab(suicide)
</code></pre>

<hr>
<h2 id='lazar'>The Data Example from Lazarsfeld and Henry</h2><span id='topic+lazar'></span>

<h3>Description</h3>

<p>data example by Lazarsfeld and Henry (1968) where <em>n</em> = 1000 subjects need to solve questions or problems (i.e., A,B, and C). They either ‘1’ = solved or ‘2’ = did not solve the problems. The data is in pattern frequencies table representation (object of class c(&quot;data.frame&quot;, &quot;Pfreq&quot; )). This data example is used in the textbook by Mark Stemmler (2020, Table 6.6, p. 81).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(lazar)
</code></pre>


<h3>Format</h3>

<p>A matrix with 4 columns and 8 rows. The last column gives the frequencies for the (response) pattern in column 1:3. 
</p>


<h3>Details</h3>

<p>No detail in the moment
</p>


<h3>References</h3>

<p>Lazarsfeld, P. F., &amp; Henry, N. W. (1968). <em>Latent structure analysis</em>. Boston: Houghton Mifflin.
</p>
<p>Stemmler, M. (2020). <em>Person-Centered Methods &ndash; Configural Frequency Analysis (CFA) and Other Methods for the Analysis of Contingency Tables</em>. Cham Heidelberg New York Dordrecht London: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################################################
data(lazar)
dim(lazar)
##############################################################
</code></pre>

<hr>
<h2 id='Lienert1978'>The Lienert (1978) Data</h2><span id='topic+Lienert1978'></span>

<h3>Description</h3>

<p>Data used as an example for two-sample CFA in the textbook by Mark Stemmler (2020, Table 7.7, p.97) taken from Lienert (1978, p. 978). The data is in pattern frequencies table representation (object of class c(&quot;data.frame&quot;, &quot;Pfreq&quot; )). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(Lienert1978)
</code></pre>


<h3>Format</h3>

<p>A data frame (object of class <code>c("data.frame", "Pfreq")</code> ) with 4 columns and 12 rows. The last column gives the frequencies for the (response) pattern in column 1:2 of the respective 'Group' given in column 3. 
</p>


<h3>Details</h3>

<p>no details at the moment ...
</p>


<h3>References</h3>

<p>Lienert, G. A. (1978). <em>Verteilungsfreie Methoden in der Biostatistik (Band II)</em> [Non-parametrical 168 methods in the field of biometrics (Vol. II)]. Meisenheim am Glan, Germany: Hain.
</p>
<p>Stemmler, M. (2020). <em>Person-Centered Methods &ndash; Configural Frequency Analysis (CFA) and Other Methods for the Analysis of Contingency Tables</em>. Cham Heidelberg New York Dordrecht London: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Lienert1978)
dim(Lienert1978)
##############################################################
colnames(Lienert1978) # show all variable names of Lienert1978
</code></pre>

<hr>
<h2 id='LienertLSD'>The Lienert LSD Data</h2><span id='topic+LienertLSD'></span>

<h3>Description</h3>

<p>Data from the classical Lienert LSD trial as an example for CFA (see Lienert, 1971, p. 103, ’Tabelle 1’). The data is in pattern frequencies table representation (object of class c(&quot;data.frame&quot;, &quot;Pfreq&quot; )). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(LienertLSD)
</code></pre>


<h3>Format</h3>

<p>A data frame (object of class <code>c("data.frame", "Pfreq")</code> ) with 4 columns and 8 rows. The last column gives the frequencies for the observed pattern of the psychotoxic basic syndrome (in column 1:3) due to the intake of lysergic acid diethylamide (LSD).
</p>


<h3>Details</h3>

<p>The first three columns are named C, T and A which are abbreviations for 
the observed symptoms after taking LSD:
</p>
<p>C = narrowed consciousness
</p>
<p>T = thought disturbance
</p>
<p>A = affective disturbance
</p>
<p>The coding of the observations is for all symptoms: present='+' and absent='-'
</p>


<h3>References</h3>

<p>Lienert, G. A. (1971). Die Konfigurationsfrequenzanalyse: I. Ein neuer Weg zu Typen und Syndromen. <em>Zeitschrift für Klinische Psychologie und Psychotherapie, 19</em>(2), 99-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LienertLSD)
dim(LienertLSD)
##############################################################
colnames(LienertLSD) # show all variable names of matrix LienertLSD
</code></pre>

<hr>
<h2 id='lr'>Likelihood Ratio Chi-square (LR)</h2><span id='topic+lr'></span>

<h3>Description</h3>

<p>Calculates the likelihod ratio chi-square statistic based on observed and expected counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr(observed, expected)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lr_+3A_observed">observed</code></td>
<td>
<p>a vector giving the observed frequencies.</p>
</td></tr>
<tr><td><code id="lr_+3A_expected">expected</code></td>
<td>
<p>a vector giving the expected frequencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details in the moment.
</p>


<h3>Value</h3>

<p>numeric giving the likelihood ratio chi-square statistic.
</p>


<h3>References</h3>

<p>Stemmler, M. (2014). <em>Person-Centered Methods &ndash; Configural Frequency Analysis (CFA) and Other Methods for the Analysis of Contingency Tables</em>. Cham Heidelberg New York Dordrecht London: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
######### some examples ########
data(newborns)
newborns
designmatrix &lt;- design_cfg_cfa(kat=c(2,2)) # generate an designmatrix (only main effects)
observed &lt;- newborns[,3] # extract observed counts
expected &lt;- expected_cfa(des=designmatrix, observed=observed) # calculation of expected counts
lr(observed,expected) # calculation of the likelihood ratio chi-square statistic

</code></pre>

<hr>
<h2 id='newborns'>The Data Example from Stemmler 2020</h2><span id='topic+newborns'></span>

<h3>Description</h3>

<p>data example by Stemmler (2020, table 4.1, p. 33) where <em>n</em> = 56 newborns 'with seizures' = 1 or 'without seizures' = 2 (coded in the in first column named 'A') were tested with an intelligence test while they attended kindergarten. Children’s intelligence was divided into 'average or above' = 1 and 'below average' = 2 (coded in the in second column named 'B'). The third column gives the frequencies of the respective pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(newborns)
</code></pre>


<h3>Format</h3>

<p>A data.frame with 3 columns and 4 rows. The last column gives the frequencies for the observed pattern in column 1:2. The data is in pattern frequencies table representation (object of class c(&quot;data.frame&quot;, &quot;Pfreq&quot;)) 
</p>


<h3>Details</h3>

<p>No detail in the moment
</p>


<h3>References</h3>

<p>Stemmler, M. (2020). <em>Person-Centered Methods &ndash; Configural Frequency Analysis (CFA) and Other Methods for the Analysis of Contingency Tables</em>. Cham Heidelberg New York Dordrecht London: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################################################
data(newborns)
dim(newborns)
newborns
##############################################################
</code></pre>

<hr>
<h2 id='plot.CFA'>S3 plot for CFA</h2><span id='topic+plot.CFA'></span>

<h3>Description</h3>

<p>S3 plot method for object of class<code>"CFA"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CFA'
plot(
  x,
  type = "z.pChi",
  fill = c("red", "blue", "grey"),
  adjalpha = "bonferroni",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CFA_+3A_x">x</code></td>
<td>
<p>object of class <code>"CFA"</code></p>
</td></tr>
<tr><td><code id="plot.CFA_+3A_type">type</code></td>
<td>
<p>character indicating which test to use for visualizing whether the observed pattern are 'Types', 'Antitypes' or not significant at all. Possible options for <code>type</code> are <code>"pChi"</code>, <code>"ex.bin.test"</code>, <code>"z.pChi"</code>, <code>"z.pBin"</code> and <code>"p.stir"</code>.</p>
</td></tr>
<tr><td><code id="plot.CFA_+3A_fill">fill</code></td>
<td>
<p>a vector of (three) colors defining the coloring of significant 'Types' (default &quot;red&quot;), 'Antitypes' (default &quot;blue&quot;) or not significant cells (default &quot;grey&quot;) in the plot.</p>
</td></tr>
<tr><td><code id="plot.CFA_+3A_adjalpha">adjalpha</code></td>
<td>
<p>character with default <code>adjalpha = "bonferroni"</code>. Selector for the type of alpha adjustment for multiple testing. Possible options are: <code>adjalpha = "none"</code>, for no adjustment; <code>adjalpha = "bonferroni"</code>, for bonferroni adjustment (default); <code>adjalpha = "holm"</code>, for alpha adjustment according to Holm (1979); other options to come ... .</p>
</td></tr>
<tr><td><code id="plot.CFA_+3A_...">...</code></td>
<td>
<p>other parameters passed trough</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot visualizing the results.
</p>


<h3>References</h3>

<p>Holm, S. (1979). A simple sequentially rejective multiple test procedure. <em>Scandinavian Journal of Statistics, 6</em>(2), 65–70.
</p>
<p>Bonferroni, C. E. (1935). Il calcolo delle assicurazioni su gruppi di teste. In S.O. Carboni (Ed.), <em>Studi in Onore del Professore Salvatore Ortu Carboni</em> (S. 13–60). Roma, Tipografia del Senato: Bardi.
</p>

<hr>
<h2 id='plot.S2CFA'>S3 plot for S2CFA</h2><span id='topic+plot.S2CFA'></span>

<h3>Description</h3>

<p>S3 plot method for object of class<code>"S2CFA"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'S2CFA'
plot(
  x,
  type = "ex.fisher.test",
  fill = c("red", "grey"),
  adjalpha = "bonferroni",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.S2CFA_+3A_x">x</code></td>
<td>
<p>object of class<code>"S2CFA"</code></p>
</td></tr>
<tr><td><code id="plot.S2CFA_+3A_type">type</code></td>
<td>
<p>character with default <code>type="ex.fisher.test"</code>, to return wether the observed pattern are 'discriminating Types' or not significant at all based on the respective p-value. Another option for <code>type</code> is <code>type="pChi"</code>.</p>
</td></tr>
<tr><td><code id="plot.S2CFA_+3A_fill">fill</code></td>
<td>
<p>a vector of (two) colors defining the coloring of discriminating 'Types' (default &quot;red&quot;), or not discriminating cells (default &quot;grey&quot;) in the plot.</p>
</td></tr>
<tr><td><code id="plot.S2CFA_+3A_adjalpha">adjalpha</code></td>
<td>
<p>character with default <code>adjalpha = "bonferroni"</code>. Selector for the type of alpha adjustment for multiple testing. Possible options are: <code>adjalpha = "none"</code>, for no adjustment; <code>adjalpha = "bonferroni"</code>, for bonferroni adjustment (default); <code>adjalpha = "holm"</code>, for alpha adjustment according to Holm (1979); other options to come ... .</p>
</td></tr>
<tr><td><code id="plot.S2CFA_+3A_...">...</code></td>
<td>
<p>other parameters passed trough.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot visualizing the results.
</p>


<h3>References</h3>

<p>Holm, S. (1979). A simple sequentially rejective multiple test procedure. <em>Scandinavian Journal of Statistics, 6</em>(2), 65–70.
</p>
<p>Bonferroni, C. E. (1935). Il calcolo delle assicurazioni su gruppi di teste. In S.O. Carboni (Ed.), <em>Studi in Onore del Professore Salvatore Ortu Carboni</em> (S. 13–60). Roma, Tipografia del Senato: Bardi.
</p>

<hr>
<h2 id='pos_cfg_cfa'>Possible configurations</h2><span id='topic+pos_cfg_cfa'></span>

<h3>Description</h3>

<p>Calculates all possible configuartions for some variables with different numbers of categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pos_cfg_cfa(kat, fact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pos_cfg_cfa_+3A_kat">kat</code></td>
<td>
<p>a numerical vector containing kardinal numbers, giving the number of categories for each variable. 
So the length of this numerical vector represents the number of variables.</p>
</td></tr>
<tr><td><code id="pos_cfg_cfa_+3A_fact">fact</code></td>
<td>
<p>logical, default is <code>(fact=FALSE)</code>. If this argument is set to <code>(fact=TRUE)</code> the result is coerced to a data.frame with factor variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details
</p>


<h3>Value</h3>

<p>An object of class &quot;matrix&quot; or &quot;data.frame&quot; (depending on the argument <code>fact</code>) containing all possible configurations for <code>lenght(kat)</code> variables with the respective number of categories given as kardinal numbers in the vector <code>kat</code>.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
# possible configurations for ...
# three variables with two categories each (Lienert LSD example).
pos_cfg_cfa(kat=c(2,2,2))
#######################################
</code></pre>

<hr>
<h2 id='print.Pfreq'>S3 print for Pfreq</h2><span id='topic+print.Pfreq'></span>

<h3>Description</h3>

<p>S3 print method for object of class<code>"Pfreq"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Pfreq'
print(
  x,
  ...,
  digits = NULL,
  quote = FALSE,
  right = TRUE,
  row.names = TRUE,
  max = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Pfreq_+3A_x">x</code></td>
<td>
<p>object of class <code>"Pfreq"</code></p>
</td></tr>
<tr><td><code id="print.Pfreq_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.Pfreq_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.Pfreq_+3A_quote">quote</code></td>
<td>
<p>logical, indicating whether or not strings should be printed with surrounding quotes.</p>
</td></tr>
<tr><td><code id="print.Pfreq_+3A_right">right</code></td>
<td>
<p>logical, indicating whether or not strings should be right aligned.</p>
</td></tr>
<tr><td><code id="print.Pfreq_+3A_row.names">row.names</code></td>
<td>
<p>logical (or character vector), indicating whether (or what) row names should be printed.</p>
</td></tr>
<tr><td><code id="print.Pfreq_+3A_max">max</code></td>
<td>
<p>numeric or <code>NULL</code>, specifying the maximal number of entries to be printed. By default, when <code>NULL</code>, <code><a href="base.html#topic+getOption">getOption</a>("max.print")</code> used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output printed to the console
</p>

<hr>
<h2 id='S2CFA'>Configural Frequencies Analysis for two Samples.</h2><span id='topic+S2CFA'></span>

<h3>Description</h3>

<p>Calculates coefficients for the two-sample CFA. Instead of differentiating between 'Types' and 'Antitypes', two-sample CFA looks for discrimination types, that is configurations with significant differences in frequencies between two sub samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S2CFA(patternfreq, alpha = 0.05, ccor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S2CFA_+3A_patternfreq">patternfreq</code></td>
<td>
<p>an object of class <code>"Pfreq"</code>, which is data in pattern frequencies representation - see function <code><a href="#topic+dat2fre">dat2fre</a></code>. The variable defining the two sub samples (a variable with max. two categories) must be located in the last but one column of the object of class <code>"Pfreq"</code></p>
</td></tr>
<tr><td><code id="S2CFA_+3A_alpha">alpha</code></td>
<td>
<p>a numeric giving the alpha level for testing (default set to <code>alpha=.05</code>)</p>
</td></tr>
<tr><td><code id="S2CFA_+3A_ccor">ccor</code></td>
<td>
<p>a logical (TRUE / FALSE) determining whether to apply a continuity correction or not. When set to <code>ccor=TRUE</code> continuity correction is applied. For <code>ccor=FALSE</code> no continuity correction is applied.</p>
</td></tr>
<tr><td><code id="S2CFA_+3A_...">...</code></td>
<td>
<p>additional parameters passed through to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>no details at the moment ...
</p>


<h3>Value</h3>

<p>an object of class <code>S2CFA</code> with results.
</p>


<h3>References</h3>

<p>Stemmler, M. (2020). <em>Person-Centered Methods – Configural Frequency Analysis (CFA) and Other Methods for the Analysis of Contingency Tables.</em> Cham Heidelberg New York Dordrecht London: Springer.
</p>
<p>Stemmler, M., &amp; Hammond, S. (1997). Configural frequency analysis of dependent samples for intra-patient treatment comparisons. <em>Studia Psychologica, 39</em>, 167–175.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
############### some examples #########
######### example from Marks Textbook
data(Lienert1978)
res1 &lt;- S2CFA(Lienert1978)
summary(res1)
res2 &lt;- S2CFA(Lienert1978, ccor=TRUE) # with continuity correction
summary(res2)
######### example with biger numbers
data(suicide)
ftab(suicide) # 'Epoche' may divide the sample into 2 subsamples  
suicide_2s &lt;- suicide[, c(1,3,2) ] # reorder data that 'Epoche' is the last column
ftab(suicide_2s) # check reordering
suicide_2s_fre &lt;- dat2fre(suicide_2s)
res3 &lt;- S2CFA(suicide_2s_fre)
summary(res3)
res4 &lt;- S2CFA(suicide_2s_fre, ccor=TRUE) # with continuity correction
summary(res4)
</code></pre>

<hr>
<h2 id='stirling_cfa'>Approximation to the binomial using Stirling's Formula</h2><span id='topic+stirling_cfa'></span>

<h3>Description</h3>

<p>Calculates the binomial aproximation using stirling's formula (Version of function: V 1.0 - November 2013)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stirling_cfa(
  observed,
  expected = NULL,
  n = sum(observed),
  p = NULL,
  cum = T,
  verb = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stirling_cfa_+3A_observed">observed</code></td>
<td>
<p>a integer vector with observed freqencies</p>
</td></tr>
<tr><td><code id="stirling_cfa_+3A_expected">expected</code></td>
<td>
<p>a vector giving the expected frequencies. expected can be set to <code>expected=NULL</code> if an vector of cell probabilities is given in argument <code>p</code>.</p>
</td></tr>
<tr><td><code id="stirling_cfa_+3A_n">n</code></td>
<td>
<p>number of trials (scalar) default is <code>n = sum(observed) </code>.</p>
</td></tr>
<tr><td><code id="stirling_cfa_+3A_p">p</code></td>
<td>
<p>a vector of cell probabilities. If p is not NULL the argument <code>expected</code> is ignored and this vector p of cell probabilities is used for calculatio instead of expected counts</p>
</td></tr>
<tr><td><code id="stirling_cfa_+3A_cum">cum</code></td>
<td>
<p>a logical - computation of cumulative density. If <code>cum=TRUE</code> (default) computes tail probability. If <code>cum=FALSE</code> computes prob. only for one cell (i.e. execute stircore only).</p>
</td></tr>
<tr><td><code id="stirling_cfa_+3A_verb">verb</code></td>
<td>
<p>logical - verbose results: If <code>verb=TRUE</code> (default) builds a results table. If <code>verb=FALSE</code> returns vector of cell p-values only.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li><p>Vector p must be of same length as observed _or_ p may be a scalar (e.g. in case of the zero-order CFA).
</p>
</li>
<li> <p>The routine autoselects the upper or lower tail: 
</p>
 <ul>
<li><p>if obs &gt; exp then sum obs:n </p>
</li>
<li><p> else              sum 0:obs</p>
</li></ul>

</li>
<li> <p>The stirling approximation cannot be evaluated if the observed frequency is 0 or n. Therefore, the proposal of A. von Eye (20xx) is adopted, taking the sum up to 1 or n-1, respectively.</p>
</li></ul>



<h3>Author(s)</h3>

<p>R.W. Alexandrowicz
</p>


<h3>References</h3>

<p>von Eye, A. (2002). <em>Configural Frequency Analysis. Methods, Models, and Applications.</em> Mahwah, NJ, LEA.
</p>

<hr>
<h2 id='suicide'>The Krauth &amp; Lienert suicide Data</h2><span id='topic+suicide'></span>

<h3>Description</h3>

<p>Data from the Krauth &amp; Lienert suicide example for CFA (see Tables 39a and 39b; Krauth &amp; Lienert, 1973). The data describe suicide patterns in pre- and post-WWII Germany &ndash; see von Eye, A., (2002); p. 385.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(suicide)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 3 columns (as factors).  The data is in data list representation &ndash; each row represents one case.
</p>


<h3>Details</h3>

<p>The three columns are named 'Geschlecht', 'Epoche' and 'Suizidart' which is 'gender', 'epoch' and 'type od suicide'. each of the variables are factors with the following levels:
</p>
<p>Geschlecht: 'm' = 1 (male); 'w' = 2 (female) 
</p>
<p>Epoche: '44' = 1 (the epoch 1944); '52' = 2 (the epoch 1952)
</p>
<p>Suizidart: 'Eh' = 1(hang); 'Es' = 2 (shoot); 'Et' = 3(drown);  
'G' = 4(gas);  'H' = 5(crashing down);  'P' = 6(open vein);  'S' = 7(barbiturate);
</p>


<h3>References</h3>

<p>Krauth, J., &amp; Lienert, G. A. (1973). <em>Die Konfigurationsfrequenzanalyse (KFA) und ihre Anwendung in Psychologie und Medizin: ein multivariates nichtparametrisches Verfahren zur Aufdeckung von Typen und Syndromen; mit 70 Tabellen</em>. Freiburg; München: Alber Karl.
</p>
<p>von Eye, A. (2002). Configural Frequency Analysis: Methods, models, and applications. Mahwah, N.J.: Lawrence Erlbaum Associates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################################################
data(suicide) # to load the data.frame included in the package
class(suicide)
dim(suicide)
str(suicide)
</code></pre>

<hr>
<h2 id='summary.CFA'>S3 Summary for CFA</h2><span id='topic+summary.CFA'></span>

<h3>Description</h3>

<p>S3 summary method for object of class<code>"CFA"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CFA'
summary(
  object,
  digits = 3,
  type = "z.pChi",
  sorton = NULL,
  decreasing = FALSE,
  showall = TRUE,
  holm = FALSE,
  wide = FALSE,
  adjalpha = "bonferroni",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.CFA_+3A_object">object</code></td>
<td>
<p>object of class<code>"CFA"</code></p>
</td></tr>
<tr><td><code id="summary.CFA_+3A_digits">digits</code></td>
<td>
<p>integer rounds the values to the specified number of decimal places, default is <code>digits=3</code>.</p>
</td></tr>
<tr><td><code id="summary.CFA_+3A_type">type</code></td>
<td>
<p>character indicating which test to use for inference whether the observed pattern are 'Types', 'Antitypes' or not significant at all. Possible options for <code>type</code> are <code>"pChi"</code>, <code>"ex.bin.test"</code>, <code>"z.pChi"</code>, <code>"z.pBin"</code> and <code>"p.stir"</code>.</p>
</td></tr>
<tr><td><code id="summary.CFA_+3A_sorton">sorton</code></td>
<td>
<p>sort results of local test by any column. By default the output is not sorted. Other options may be <code>"pat."</code>, <code>"obs."</code>, <code>"exp."</code>, <code>"Type"</code>, <code>"Chi"</code>, etc. ... So all column names that can potentially appear in the result.</p>
</td></tr>
<tr><td><code id="summary.CFA_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort be increasing or decreasing? see <code><a href="base.html#topic+order">order</a></code></p>
</td></tr>
<tr><td><code id="summary.CFA_+3A_showall">showall</code></td>
<td>
<p>logical with default <code>showall = TRUE</code>. To return only significant pattern ('Types' / 'Antitypes') set it to <code>showall = FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.CFA_+3A_holm">holm</code></td>
<td>
<p>logical with default <code>holm = FALSE</code>. If set to <code>holm = TRUE</code>, significance testing is based on the holm procedure &ndash; see references. This argument is deprecated (since version 1.5.6) and kept only for downward compatibility. Use argument <code>adjalpha</code> for any type of alpha adjustment.</p>
</td></tr>
<tr><td><code id="summary.CFA_+3A_wide">wide</code></td>
<td>
<p>logical with default <code>wide = FALSE</code>. If set to <code>wide = TRUE</code>, results for all significance tests are returned.</p>
</td></tr>
<tr><td><code id="summary.CFA_+3A_adjalpha">adjalpha</code></td>
<td>
<p>character with default <code>adjalpha = "bonferroni"</code>. Selector for the type of alpha adjustment for multiple testing. Possible options are: <code>adjalpha = "none"</code>, for no adjustment; <code>adjalpha = "bonferroni"</code>, for bonferroni adjustment (default); <code>adjalpha = "holm"</code>, for alpha adjustment according to Holm (1979); other options to come ... .</p>
</td></tr>
<tr><td><code id="summary.CFA_+3A_...">...</code></td>
<td>
<p>other parameters passed trough.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary of the results printed on the console.
</p>


<h3>References</h3>

<p>Holm, S. (1979). A simple sequentially rejective multiple test procedure. <em>Scandinavian Journal of Statistics, 6</em>(2), 65–70.
</p>
<p>Bonferroni, C. E. (1935). Il calcolo delle assicurazioni su gruppi di teste. In S.O. Carboni (Ed.), <em>Studi in Onore del Professore Salvatore Ortu Carboni</em> (S. 13–60). Roma, Tipografia del Senato: Bardi.
</p>

<hr>
<h2 id='summary.S2CFA'>S3 Summary for S2CFA</h2><span id='topic+summary.S2CFA'></span>

<h3>Description</h3>

<p>S3 summary method for object of class<code>"S2CFA"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'S2CFA'
summary(
  object,
  digits = 3,
  type = "ex.fisher.test",
  sorton = NULL,
  decreasing = FALSE,
  showall = TRUE,
  adjalpha = "bonferroni",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.S2CFA_+3A_object">object</code></td>
<td>
<p>object of class<code>"S2CFA"</code></p>
</td></tr>
<tr><td><code id="summary.S2CFA_+3A_digits">digits</code></td>
<td>
<p>integer rounds the values to the specified number of decimal places, default is <code>digits=3</code>.</p>
</td></tr>
<tr><td><code id="summary.S2CFA_+3A_type">type</code></td>
<td>
<p>character with default <code>type="ex.fisher.test"</code>, to return wether the observed pattern are 'discriminating Types' or not significant at all based on the respective p-value. Another option for <code>type</code> is <code>type="pChi"</code>.</p>
</td></tr>
<tr><td><code id="summary.S2CFA_+3A_sorton">sorton</code></td>
<td>
<p>sort results of local test by any column. By default the output is not sorted. Other options may be <code>"pat."</code>, <code>"disc.Type"</code>, etc. ... So all column names that can potentially appear in the result.</p>
</td></tr>
<tr><td><code id="summary.S2CFA_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort be increasing or decreasing? see <code><a href="base.html#topic+order">order</a></code></p>
</td></tr>
<tr><td><code id="summary.S2CFA_+3A_showall">showall</code></td>
<td>
<p>logical with default <code>showall = TRUE</code>. To return only significant pattern (discriminating types) set it to <code>showall = FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.S2CFA_+3A_adjalpha">adjalpha</code></td>
<td>
<p>character with default <code>adjalpha = "bonferroni"</code>. Selector for the type of alpha adjustment for multiple testing. Possible options are: <code>adjalpha = "none"</code>, for no adjustment; <code>adjalpha = "bonferroni"</code>, for bonferroni adjustment (default); <code>adjalpha = "holm"</code>, for alpha adjustment according to Holm (1979); other options to come ... .</p>
</td></tr>
<tr><td><code id="summary.S2CFA_+3A_...">...</code></td>
<td>
<p>other parameters passed trough.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary of the results printed on the console.
</p>


<h3>References</h3>

<p>Holm, S. (1979). A simple sequentially rejective multiple test procedure. <em>Scandinavian Journal of Statistics, 6</em>(2), 65–70.
</p>
<p>Bonferroni, C. E. (1935). Il calcolo delle assicurazioni su gruppi di teste. In S.O. Carboni (Ed.), <em>Studi in Onore del Professore Salvatore Ortu Carboni</em> (S. 13–60). Roma, Tipografia del Senato: Bardi.
</p>

<hr>
<h2 id='z_tests_cfa'>Two z-Approximation Tests</h2><span id='topic+z_tests_cfa'></span>

<h3>Description</h3>

<p>Calculates the Chi-square approximation to the z-test and the binomial approximation to the z-test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_tests_cfa(observed, expected, ccor = FALSE, ntotal = sum(observed))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z_tests_cfa_+3A_observed">observed</code></td>
<td>
<p>a vector giving the observed frequencies.</p>
</td></tr>
<tr><td><code id="z_tests_cfa_+3A_expected">expected</code></td>
<td>
<p>a vector giving the expected frequencies.</p>
</td></tr>
<tr><td><code id="z_tests_cfa_+3A_ccor">ccor</code></td>
<td>
<p>either a logical (TRUE / FALSE) determining wether to apply a continuity correction or not to the Binomial Approximation of the z-Test. When set to <code>ccor=TRUE</code> continuity correction is applied for expected values 5 =&lt; expected =&lt; 10. For <code>ccor=FALSE</code> no continuity correction is applied. Another option is to set <code>ccor=c(x,y)</code> where x is the lower and y the upper bound for expected values where continuity correction is applied. So <code>ccor=c(5,10)</code> is equivalent to <code>ccor=TRUE</code>.</p>
</td></tr>
<tr><td><code id="z_tests_cfa_+3A_ntotal">ntotal</code></td>
<td>
<p>optional a numeric giving the total number of observations. By default ntotal is calculated as <code>ntotal=sum(observed)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An continuity correction can be applied to the binomial approximation &ndash; see argument <code>ccor</code>.
</p>


<h3>Value</h3>

<p>a list with z and p-values.
</p>


<h3>References</h3>

<p>No references in the moment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
# expected counts for LienertLSD data example.
designmatrix&lt;-design_cfg_cfa(kat=c(2,2,2)) # generate an designmatrix (only main effects)
data(LienertLSD) # load example data
observed&lt;-LienertLSD[,4] # extract observed counts
expected&lt;-expected_cfa(des=designmatrix, observed=observed) # calculation of expected counts
z_tests_cfa(observed,expected)
####################################### 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
