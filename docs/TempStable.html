<!DOCTYPE html><html><head><title>Help for package TempStable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TempStable}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#charCTS'><p>Characteristic function of the classical tempered stable (CTS) distribution</p></a></li>
<li><a href='#charGTS'><p>Characteristic function of the generalized classical tempered stable (GTS)</p>
distribution.</a></li>
<li><a href='#charKRTS'><p>Characteristic function of the Kim-Rachev tempered stable distribution</p></a></li>
<li><a href='#charMTS'><p>Characteristic function of the modified tempered stable distribution</p></a></li>
<li><a href='#charNTS'><p>Characteristic function of the normal tempered stable (NTS) distribution</p></a></li>
<li><a href='#charRDTS'><p>Characteristic function of the rapidly decreasing tempered stable (RDTS)</p>
distribution</a></li>
<li><a href='#charTSS'><p>Characteristic function of the tempered stable subordinator</p></a></li>
<li><a href='#dCTS'><p>Density function of the classical tempered stable (CTS) distribution</p></a></li>
<li><a href='#dGTS'><p>Density function of generalized classical tempered stable distribution</p></a></li>
<li><a href='#dKRTS'><p>Density Function of the Kim-Rachev tempered stable distribution</p></a></li>
<li><a href='#dMTS'><p>Density function of the modified tempered stable (MTS) distribution</p></a></li>
<li><a href='#dNTS'><p>Density function of the normal tempered stable (NTS) distribution</p></a></li>
<li><a href='#dRDTS'><p>Density function of the rapidly decreasing tempered stable (CTS) distribution</p></a></li>
<li><a href='#dTSS'><p>Density function of the tempered stable subordinator (TSS) distribution</p></a></li>
<li><a href='#parallelizeMCsimulation'><p>Function to parallelize the Monte Carlo Simulation</p></a></li>
<li><a href='#pCTS'><p>Cumulative probability function of the classical tempered stable (CTS)</p>
distribution</a></li>
<li><a href='#pGTS'><p>Cumulative probability function of the generalized classical tempered stable</p>
(GTS) distribution</a></li>
<li><a href='#pKRTS'><p>Cumulative probability distribution function of the Kim-Rachev tempered</p>
stable (KRTS) distribution</a></li>
<li><a href='#pMTS'><p>Cumulative probability function of the  modified tempered stable (MTS)</p>
distribution</a></li>
<li><a href='#pNTS'><p>Cumulative probability function of the normal tempered stable (NTS)</p>
distribution</a></li>
<li><a href='#pRDTS'><p>Cumulative probability function of the rapidly decreasing tempered stable</p>
(RDTS) distribution</a></li>
<li><a href='#pTSS'><p>Cumulative probability distribution function of the tempered stable subordinator</p>
distribution</a></li>
<li><a href='#qCTS'><p>Quantile function of the classical tempered stable (CTS)</p></a></li>
<li><a href='#qNTS'><p>Quantile function of the normal tempered stable (NTS)</p></a></li>
<li><a href='#qTSS'><p>Quantile function of the tempered stable subordinator distribution</p></a></li>
<li><a href='#rCTS'><p>Function to generate random variates of CTS distribution.</p></a></li>
<li><a href='#rGTS'><p>Function to generate random variates of GTS distribution.</p></a></li>
<li><a href='#rKRTS'><p>Function to generate random variates of KRTS distribution.</p></a></li>
<li><a href='#rMTS'><p>Function to generate random variates of MTS distribution</p></a></li>
<li><a href='#rNTS'><p>Function to generate random variates of NTS distribution.</p></a></li>
<li><a href='#rRDTS'><p>Function to generate random variates of RDTS distribution.</p></a></li>
<li><a href='#rTSS'><p>Function to generate random variates of the TSS distribution.</p></a></li>
<li><a href='#TemperedEstim'><p>Estimation function</p></a></li>
<li><a href='#TemperedEstim_Simulation'><p>Monte Carlo Simulation</p></a></li>
<li><a href='#TempStable'><p>TempStable: A collection of methods to estimate parameters of different</p>
tempered stable distributions.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Collection of Methods to Estimate Parameters of Different
Tempered Stable Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>
  A collection of methods to estimate parameters of different tempered stable 
  distributions (TSD). Currently, there are seven different tempered stable 
  distributions to choose from: Tempered stable subordinator distribution, 
  classical TSD, generalized classical TSD, normal TSD, modified TSD, rapid 
  decreasing TSD, and Kim-Rachev TSD.
  The package also provides functions to compute density and probability 
  functions and tools to run Monte Carlo simulations.
  This package has already been used for the estimation of tempered stable 
  distributions (Massing (2023) &lt;<a href="https://arxiv.org/abs/2303.07060">arXiv:2303.07060</a>&gt;).
  The following references form the theoretical background for various functions
  in this package. References for each function are explicitly listed in its 
  documentation:
  Bianchi et al. (2010) &lt;<a href="https://doi.org/10.1007%2F978-88-470-1481-7_4">doi:10.1007/978-88-470-1481-7_4</a>&gt;
  Bianchi et al. (2011) &lt;<a href="https://doi.org/10.1137%2FS0040585X97984632">doi:10.1137/S0040585X97984632</a>&gt;
  Carrasco (2017) &lt;<a href="https://doi.org/10.1017%2FS0266466616000025">doi:10.1017/S0266466616000025</a>&gt;
  Feuerverger (1981) &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1981.tb01143.x">doi:10.1111/j.2517-6161.1981.tb01143.x</a>&gt;
  Hansen et al. (1996) &lt;<a href="https://doi.org/10.1080%2F07350015.1996.10524656">doi:10.1080/07350015.1996.10524656</a>&gt;
  Hansen (1982) &lt;<a href="https://doi.org/10.2307%2F1912775">doi:10.2307/1912775</a>&gt;
  Hofert (2011) &lt;<a href="https://doi.org/10.1145%2F2043635.2043638">doi:10.1145/2043635.2043638</a>&gt;
  Kawai &amp; Masuda (2011) &lt;<a href="https://doi.org/10.1016%2Fj.cam.2010.12.014">doi:10.1016/j.cam.2010.12.014</a>&gt;
  Kim et al. (2008) &lt;<a href="https://doi.org/10.1016%2Fj.jbankfin.2007.11.004">doi:10.1016/j.jbankfin.2007.11.004</a>&gt;
  Kim et al. (2009) &lt;<a href="https://doi.org/10.1007%2F978-3-7908-2050-8_5">doi:10.1007/978-3-7908-2050-8_5</a>&gt;
  Kim et al. (2010) &lt;<a href="https://doi.org/10.1016%2Fj.jbankfin.2010.01.015">doi:10.1016/j.jbankfin.2010.01.015</a>&gt;
  Kuechler &amp; Tappe (2013) &lt;<a href="https://doi.org/10.1016%2Fj.spa.2013.06.012">doi:10.1016/j.spa.2013.06.012</a>&gt;
  Rachev et al. (2011) &lt;<a href="https://doi.org/10.1002%2F9781118268070">doi:10.1002/9781118268070</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TMoek/TempStable">https://github.com/TMoek/TempStable</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>copula (&ge; 1.1-2), doParallel (&ge; 1.0.12), foreach (&ge; 1.5.0),
gsl (&ge; 2.1-8), hypergeo (&ge; 1.2-13), moments (&ge; 0.14),
numDeriv (&ge; 2016.8-1), stabledist (&ge; 0.7-1), StableEstim (&ge;
2.1), rootSolve (&ge; 1.8), VGAM (&ge; 1.1-7)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.4), rmarkdown (&ge; 2.17), testthat (&ge; 3.1), V8
(&ge; 4.2)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TMoek/TempStable/issues">https://github.com/TMoek/TempStable/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-24 11:14:12 UTC; till.massing</td>
</tr>
<tr>
<td>Author:</td>
<td>Till Massing [cre, aut],
  Cedric Maximilian Juessen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Till Massing &lt;till.massing@uni-due.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-24 13:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='charCTS'>Characteristic function of the classical tempered stable (CTS) distribution</h2><span id='topic+charCTS'></span>

<h3>Description</h3>

<p>Theoretical characteristic function (CF) of the classical tempered
stable distribution. See Kuechler &amp; Tappe (2013) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charCTS(
  t,
  alpha = NULL,
  deltap = NULL,
  deltam = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  functionOrigin = "massing"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charCTS_+3A_t">t</code></td>
<td>
<p>A vector of real numbers where the CF is evaluated.</p>
</td></tr>
<tr><td><code id="charCTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="charCTS_+3A_deltap">deltap</code></td>
<td>
<p>Scale parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charCTS_+3A_deltam">deltam</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charCTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charCTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charCTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="charCTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="charCTS_+3A_functionorigin">functionOrigin</code></td>
<td>
<p>A string. Either &quot;massing&quot;, or &quot;kim10&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, deltap, deltam,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>. Characteristic function shown here is from Massing
(2023).
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{CTS}(t;\theta):=
E_{\theta}\left[
\mathrm{e}^{\mathrm{i}tX}\right]=
\exp\left(\mathrm{i}t\mu+\delta_+\Gamma(-\alpha)
\left((\lambda_+-\mathrm{i}t)^{\alpha}-\lambda_+^{\alpha}+
\mathrm{i}t\alpha\lambda_+^{\alpha-1}\right)\right.\\</code>
</p>

<p style="text-align: center;"><code class="reqn">\left. +\delta_-\Gamma(-\alpha)
\left((\lambda_-+\mathrm{i}t)^{\alpha}-\lambda_-^{\alpha}-\mathrm{i}t\alpha
\lambda_-^{\alpha-1}\right)
\right)</code>
</p>

<p><strong>Origin of functions</strong>
Since the parameterisation can be different for this
characteristic function in different approaches, the respective approach can
be selected with <code>functionOrigin</code>. For the estimation function
<code>TemperedEstim</code> and therefore also the Monte Carlo function
<code>TemperedEstim_Simulation</code> and the calculation of the density function
<code>dMTS</code> only the approach of Massing (2023) can be selected. If you want
to use the approach of Kim et al. (2010) for these functions, you have to
clone the package from GitHub and adapt the functions accordingly.
</p>

<dl>
<dt>massing</dt><dd><p>From Massing, T. (2023), 'Parametric Estimation of
Tempered Stable Laws'.</p>
</dd>
<dt>kim10</dt><dd><p>From Kim et al. (2010) 'Tempered stable
and tempered infinitely divisible GARCH models'.</p>
</dd>
</dl>



<h3>Value</h3>

<p>The CF of the classical tempered stable distribution.
</p>


<h3>References</h3>

<p>Kim, Y. S.; Rachev, S. T.; Bianchi, M. L. &amp; Fabozzi, F. J.(2010), 'Tempered
stable and tempered infinitely divisible GARCH models',
<a href="https://doi.org/10.1016/j.jbankfin.2010.01.015">doi:10.1016/j.jbankfin.2010.01.015</a>
</p>
<p>Kuechler, U. &amp; Tappe, S. (2013), 'Tempered stable distributions and
processes' <a href="https://doi.org/10.1016/j.spa.2013.06.012">doi:10.1016/j.spa.2013.06.012</a>
</p>
<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-10,10,0.25)
y &lt;- charCTS(x,1.5,1,1,1,1,0)

</code></pre>

<hr>
<h2 id='charGTS'>Characteristic function of the generalized classical tempered stable (GTS)
distribution.</h2><span id='topic+charGTS'></span>

<h3>Description</h3>

<p>Theoretical characteristic function (CF) of the generalized classical
tempered stable distribution. See Rachev et al. (2011) for details. The GTS
is a more generalized version of the CTS <a href="#topic+charCTS">charCTS</a>, as
alpha = alphap = alpham for CTS. The characteristic function is given -
with a small adjustment - by Rachev et al. (2011):
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charGTS(
  t,
  alphap = NULL,
  alpham = NULL,
  deltap = NULL,
  deltam = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charGTS_+3A_t">t</code></td>
<td>
<p>A vector of real numbers where the CF is evaluated.</p>
</td></tr>
<tr><td><code id="charGTS_+3A_alphap">alphap</code>, <code id="charGTS_+3A_alpham">alpham</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="charGTS_+3A_deltap">deltap</code>, <code id="charGTS_+3A_deltam">deltam</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charGTS_+3A_lambdap">lambdap</code>, <code id="charGTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charGTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="charGTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alphap, alpham, deltap,
deltam, lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>. Characteristic function shown here is from Rachev et al.
(2011).
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{GTS}(t;\theta):=
E_{\theta}\left[\mathrm{e}^{\mathrm{i}tX}\right]=
\exp\left(\mathrm{i}t\mu-\mathrm{i}t\Gamma(1-\alpha_+)
\left(\delta_+\lambda_+^{\alpha_+-1}\right)\right.\\</code>
</p>

<p style="text-align: center;"><code class="reqn">\left. +\mathrm{i}t\Gamma(1-\alpha_-)
\left(\delta_-\lambda_-^{\alpha_--1}\right)\right.\\</code>
</p>

<p style="text-align: center;"><code class="reqn">\left.+\delta_+\Gamma(-\alpha_+)
\left(\left(\lambda_+-\mathrm{i}t\right)^{\alpha_+}
-\lambda_+^{\alpha_+}\right) \right.\\</code>
</p>

<p style="text-align: center;"><code class="reqn">\left.+\delta_-\Gamma(-\alpha_-)
\left(\left(\lambda_-+\mathrm{i}t\right)^{\alpha_-}
-\lambda_-^{\alpha_-}\right)\right)</code>
</p>



<h3>Value</h3>

<p>The CF of the the generalized classical tempered stable distribution.
</p>


<h3>References</h3>

<p>Rachev, S. T.; Kim, Y. S.; Bianchi, M. L. &amp; Fabozzi, F. J. (2011),
'Financial models with Lévy processes and volatility clustering'
<a href="https://doi.org/10.1002/9781118268070">doi:10.1002/9781118268070</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-5,5,0.25)
y &lt;- charGTS(x,0.3,0.2,1,1,1,1,0)

</code></pre>

<hr>
<h2 id='charKRTS'>Characteristic function of the Kim-Rachev tempered stable distribution</h2><span id='topic+charKRTS'></span>

<h3>Description</h3>

<p>Theoretical characteristic function (CF) of the Kim-Rachev tempered
stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charKRTS(
  t,
  alpha = NULL,
  kp = NULL,
  km = NULL,
  rp = NULL,
  rm = NULL,
  pp = NULL,
  pm = NULL,
  mu = NULL,
  theta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charKRTS_+3A_t">t</code></td>
<td>
<p>A vector of real numbers where the CF is evaluated.</p>
</td></tr>
<tr><td><code id="charKRTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="charKRTS_+3A_kp">kp</code>, <code id="charKRTS_+3A_km">km</code>, <code id="charKRTS_+3A_rp">rp</code>, <code id="charKRTS_+3A_rm">rm</code></td>
<td>
<p>Parameter of KR-distribution. A real number <code>&gt;0</code>.</p>
</td></tr>
<tr><td><code id="charKRTS_+3A_pp">pp</code>, <code id="charKRTS_+3A_pm">pm</code></td>
<td>
<p>Parameter of KR-distribution. A real number <code>&gt;-alpha</code>.</p>
</td></tr>
<tr><td><code id="charKRTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="charKRTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CF of the RDTS distribution is given by (Rachev et
al. (2011))
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{KRTS}(t;\theta):=
E_{\theta}\left[\mathrm{e}^{\mathrm{i}tX}\right]=
\exp\left(\mathrm{i}t\mu-\mathrm{i}t\Gamma(1-\alpha)
\left(\frac{k_+r_+}{p_++1}-\frac{k_-r_-}{p_-+1}\right) \right.\\</code>
</p>

<p style="text-align: center;"><code class="reqn">\left. +k_+H(\mathrm{i}t;\alpha,r_+,p_+)+k_
-H(-\mathrm{i}t;\alpha,r_-,p_-)\right),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\left. H\left(x;\alpha,r,p\right)=
\frac{\Gamma(-\alpha)}{p}\left(F\left(p,-\alpha;1+p;rx\right)-1\right)\right.
</code>
</p>

<p><code>F</code> denotes the hypergeometric Function.
</p>


<h3>Value</h3>

<p>The CF of the the Kim-Rachev tempered stable distribution.
</p>


<h3>References</h3>

<p>Rachev, Svetlozar T. &amp; Kim, Young Shin &amp; Bianchi, Michele L. &amp; Fabozzi,
Frank J. (2011) 'Financial models with Lévy processes and volatility
clustering' <a href="https://doi.org/10.1002/9781118268070">doi:10.1002/9781118268070</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-5,5,0.25)
y &lt;- charKRTS(x,0.5,1,1,1,1,1,1,0)

</code></pre>

<hr>
<h2 id='charMTS'>Characteristic function of the modified tempered stable distribution</h2><span id='topic+charMTS'></span>

<h3>Description</h3>

<p>Theoretical characteristic function (CF) of the modified tempered stable
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charMTS(
  t,
  alpha = NULL,
  delta = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  functionOrigin = "kim08"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charMTS_+3A_t">t</code></td>
<td>
<p>A vector of real numbers where the CF is evaluated.</p>
</td></tr>
<tr><td><code id="charMTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="charMTS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charMTS_+3A_lambdap">lambdap</code>, <code id="charMTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charMTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="charMTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="charMTS_+3A_functionorigin">functionOrigin</code></td>
<td>
<p>A string. Either &quot;kim09&quot;, &quot;rachev11&quot; or &quot;kim08&quot;.
Default is &quot;kim08&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>. Characteristic function shown here is from Kim et al.
(2008).
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{MTS}(t;\theta):=
E_{\theta}\left[\mathrm{e}^{\mathrm{i}tX}\right]=
\exp\left(\mathrm{i}t\mu+G_R\left(t;\alpha,\delta,\lambda_+,\lambda_-\right)
+G_R\left(t;\alpha,\delta,\lambda_+,\lambda_-\right)\right),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\left. G_R\left(t;\alpha,\delta,\lambda_+,\lambda_-\right)=
\frac{\sqrt{\pi}\delta\Gamma(-\frac{\alpha}{2})}
{2^{\frac{\alpha+3}{2}}}\left((\lambda_+^{2}+t^{2})^{\frac{\alpha}{2}}
-\lambda_+^{\alpha}+(\lambda_-^{2}+t^{2})^{\frac{\alpha}{2}}
-\lambda_-^{\alpha} \right)\right.\\</code>
</p>

<p style="text-align: center;"><code class="reqn">\left. G_I\left(t;\alpha,\delta,\lambda_+,\lambda_-\right)=
\frac{\mathrm{i}t\delta\Gamma(\frac{1-\alpha}{2})}
{2^{\frac{\alpha+1}{2}}}
\left(\lambda_+^{\alpha-1}
F\left(1,\frac{1-\alpha}{2};\frac{3}{2};-\frac{t^2}{\lambda_+^2}\right)
\right. \right. \\</code>
</p>

<p style="text-align: center;"><code class="reqn">\left. \left. -\lambda_-^{\alpha-1}
F\left(1,\frac{1-\alpha}{2};\frac{3}{2};-\frac{t^2}{\lambda_-^2}\right)
 \right)\right.</code>
</p>

<p><code>F</code> is the hypergeometric function.
</p>
<p><strong>Origin of functions</strong>
Since the parameterisation can be different for this
characteristic function in different approaches, the respective approach can
be selected with <code>functionOrigin</code>. For the estimation function
<code>TemperedEstim</code> and therefore also the Monte Carlo function
<code>TemperedEstim_Simulation</code> and the calculation of the density function
<code>dMTS</code> only the approach of Kim et al. (2008) or Rachev et al.
(2011) can be selected. If you want to use the approach of Kim et al. (2009)
for these functions, you have to clone the package from GitHub and adapt the
functions accordingly.
</p>

<dl>
<dt>kim09</dt><dd><p>From  Kim et al. (2009) 'The modified tempered stable
distribution, GARCH-models and option pricing'. Here <code>alpha</code> is in
(-Inf,1) except <code>0.5</code>.</p>
</dd>
<dt>kim08</dt><dd><p>From Kim et al. (2008) 'Financial market models with
Levy processes and time-varying volatility'. Without further coding, this
is the selected function for estimation function from this package.</p>
</dd>
<dt>rachev11</dt><dd><p>From Rachev et al. (2011) 'Financial Models with Levy
Processes and time-varying volatility'. Similar to <code>kim08</code>
</p>
</dd>
</dl>



<h3>Value</h3>

<p>The CF of the the modified tempered stable distribution.
</p>


<h3>References</h3>

<p>Kim, Y. S.; Rachev, S. T.; Bianchi, M. L. &amp; Fabozzi, F. J. (2008), 'Financial
market models with lévy processes and time-varying volatility'
<a href="https://doi.org/10.1016/j.jbankfin.2007.11.004">doi:10.1016/j.jbankfin.2007.11.004</a>
</p>
<p>Kim, Y. S.; Rachev, S. T.; Bianchi, M. L. &amp; Fabozzi, F. J. (2009), 'A New
Tempered Stable Distribution and Its Application to Finance'
<a href="https://doi.org/10.1007/978-3-7908-2050-8_5">doi:10.1007/978-3-7908-2050-8_5</a>
</p>
<p>Rachev, S. T.; Kim, Y. S.; Bianchi, M. L. &amp; Fabozzi, F. J. (2011),
'Financial models with Lévy processes and volatility clustering'
<a href="https://doi.org/10.1002/9781118268070">doi:10.1002/9781118268070</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-5,5,0.1)
y &lt;- charMTS(x, 0.5,1,1,1,0)

</code></pre>

<hr>
<h2 id='charNTS'>Characteristic function of the normal tempered stable (NTS) distribution</h2><span id='topic+charNTS'></span>

<h3>Description</h3>

<p>Theoretical characteristic function (CF) of the normal tempered
stable distribution.
See Rachev et al. (2011) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charNTS(
  t,
  alpha = NULL,
  beta = NULL,
  delta = NULL,
  lambda = NULL,
  mu = NULL,
  theta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charNTS_+3A_t">t</code></td>
<td>
<p>A vector of real numbers where the CF is evaluated.</p>
</td></tr>
<tr><td><code id="charNTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="charNTS_+3A_beta">beta</code></td>
<td>
<p>Skewness parameter. Any real number.</p>
</td></tr>
<tr><td><code id="charNTS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charNTS_+3A_lambda">lambda</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charNTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="charNTS_+3A_theta">theta</code></td>
<td>
<p>A vector of all other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, beta, delta, lambda,
mu)</code>. Either provide the parameters individually OR provide <code>theta</code>.
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{NTS}(t;\theta)=E\left[\mathrm{e}^{\mathrm{i}tZ}\right]= \exp
\left(\mathrm{i}t\mu+\delta\Gamma(-\alpha)\left((\lambda-\mathrm{i}t
\beta+t^2/2)^{\alpha}-\lambda^{\alpha}\right)\right)
</code>
</p>



<h3>Value</h3>

<p>The CF of the normal tempered stable distribution.
</p>


<h3>References</h3>

<p>Massing, T. (2022), 'Parametric Estimation of Tempered Stable Laws'
</p>
<p>Rachev, Svetlozar T. &amp; Kim, Young Shin &amp; Bianchi, Michele L. &amp; Fabozzi,
Frank J. (2011) 'Financial models with Lévy processes and volatility
clustering' <a href="https://doi.org/10.1002/9781118268070">doi:10.1002/9781118268070</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-10,10,0.25)
y &lt;- charNTS(x,0.5,1,1,1,0)

</code></pre>

<hr>
<h2 id='charRDTS'>Characteristic function of the rapidly decreasing tempered stable (RDTS)
distribution</h2><span id='topic+charRDTS'></span>

<h3>Description</h3>

<p>Theoretical characteristic function (CF) of the rapidly decreasing tempered
stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charRDTS(
  t,
  alpha = NULL,
  delta = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charRDTS_+3A_t">t</code></td>
<td>
<p>A vector of real numbers where the CF is evaluated.</p>
</td></tr>
<tr><td><code id="charRDTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="charRDTS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charRDTS_+3A_lambdap">lambdap</code>, <code id="charRDTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charRDTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="charRDTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CF of the RDTS distribution is given by (Rachev et
al. (2011)):
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{RDTS}(t;\theta):=
E_{\theta}\left[\mathrm{e}^{\mathrm{i}tX}\right]=
\exp\left(\mathrm{i}t\mu+\delta(G(\mathrm{i}t;\alpha,\lambda_+)
+G(-\mathrm{i}t;\alpha,\lambda_-))\right),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">G\left(x;\alpha,r,\lambda\right)=
2^{-\frac{\alpha}{2}-1}\lambda^\alpha\Gamma\left(-\frac{\alpha}{2}\right)
\left(M\left(-\frac{\alpha}{2},\frac{1}{2};\frac{x^2}{2\lambda^2}\right)
-1\right)\\</code>
</p>

<p style="text-align: center;"><code class="reqn">+2^{-\frac{\alpha}{2}-\frac{1}{2}}\lambda^{\alpha-1}x
\Gamma\left(\frac{1-\alpha}{2}\right)
\left(M\left(\frac{1-\alpha}{2},\frac{3}{2};\frac{x^2}{2\lambda^2}\right)
-1\right).</code>
</p>

<p><code>M</code> stands for the confluent hypergeometric function.
</p>


<h3>Value</h3>

<p>The CF of the the rapidly decreasing tempered stable distribution.
</p>


<h3>References</h3>

<p>Rachev, Svetlozar T. &amp; Kim, Young Shin &amp; Bianchi, Michele L. &amp; Fabozzi,
Frank J. (2011) 'Financial models with Lévy processes and volatility
clustering' <a href="https://doi.org/10.1002/9781118268070">doi:10.1002/9781118268070</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-5,5,0.25)
y &lt;- charRDTS(x,0.5,1,1,1,0)

</code></pre>

<hr>
<h2 id='charTSS'>Characteristic function of the tempered stable subordinator</h2><span id='topic+charTSS'></span>

<h3>Description</h3>

<p>Theoretical characteristic function (CF) of the distribution of the tempered
stable subordinator. See Kawai &amp; Masuda (2011) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charTSS(t, alpha = NULL, delta = NULL, lambda = NULL, theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charTSS_+3A_t">t</code></td>
<td>
<p>A vector of real numbers where the CF is evaluated.</p>
</td></tr>
<tr><td><code id="charTSS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="charTSS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charTSS_+3A_lambda">lambda</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="charTSS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta, lambda)</code>.
Either provide the parameters <code>alpha</code>, <code>delta</code>, <code>lambda</code>
individually OR provide <code>theta</code>.
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{TSS}(t;\theta):=E_{\theta}\left[
\mathrm{e}^{\mathrm{i}tY}\right]= \exp\left(\delta\Gamma(-\alpha)
\left((\lambda-\mathrm{i}t)^{\alpha}-\lambda^{\alpha}\right)\right)</code>
</p>



<h3>Value</h3>

<p>The CF of the tempered stable subordinator distribution.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>
<p>Kawai, R. &amp; Masuda, H. (2011), 'On simulation of tempered stable random
variates' <a href="https://doi.org/10.1016/j.cam.2010.12.014">doi:10.1016/j.cam.2010.12.014</a>
</p>
<p>Kuechler, U. &amp; Tappe, S. (2013), 'Tempered stable distributions and
processes' <a href="https://doi.org/10.1016/j.spa.2013.06.012">doi:10.1016/j.spa.2013.06.012</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-10,10,0.25)
y &lt;- charTSS(x,0.5,1,1)

</code></pre>

<hr>
<h2 id='dCTS'>Density function of the classical tempered stable (CTS) distribution</h2><span id='topic+dCTS'></span>

<h3>Description</h3>

<p>The probability density function (PDF) of the classical tempered stable
distributions is not available in closed form.
Relies on fast Fourier transform (FFT) applied to the characteristic
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCTS(
  x,
  alpha = NULL,
  deltap = NULL,
  deltam = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -20,
  b = 20,
  nf = 2048,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCTS_+3A_x">x</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_deltap">deltap</code></td>
<td>
<p>Scale parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_deltam">deltam</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_dens_method">dens_method</code></td>
<td>
<p>Algorithm for numerical evaluation. Choose between <code>
"FFT"</code> (default) and <code>"Conv"</code>.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size. 2048 by default.</p>
</td></tr>
<tr><td><code id="dCTS_+3A_...">...</code></td>
<td>
<p>Possibility to modify <code><a href="#topic+charCTS">charCTS()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, deltap, deltam,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>. Methods include the FFT or alternatively by convolving
two totally positively skewed tempered stable distributions, see Massing
(2022).
</p>
<p>The &quot;FFT&quot; method is automatically selected for Mac users, as the &quot;Conv&quot;
method causes problems.
</p>


<h3>Value</h3>

<p>As <code>x</code> is a numeric vector, the return value is also a numeric
vector of densities.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0,15,0.25)
y &lt;- dCTS(x,0.6,1,1,1,1,1,NULL,"FFT",-20,20,2048)
plot(x,y)

</code></pre>

<hr>
<h2 id='dGTS'>Density function of generalized classical tempered stable distribution</h2><span id='topic+dGTS'></span>

<h3>Description</h3>

<p>The probability density function (PDF) of the generalized classical tempered
stable (GTS) distributions is not available in closed form.
Relies on fast Fourier transform (FFT) applied to the characteristic
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dGTS(
  x,
  alphap = NULL,
  alpham = NULL,
  deltap = NULL,
  deltam = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -20,
  b = 20,
  nf = 2048
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dGTS_+3A_x">x</code></td>
<td>
<p>A numeric vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="dGTS_+3A_alphap">alphap</code>, <code id="dGTS_+3A_alpham">alpham</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="dGTS_+3A_deltap">deltap</code>, <code id="dGTS_+3A_deltam">deltam</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dGTS_+3A_lambdap">lambdap</code>, <code id="dGTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dGTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="dGTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="dGTS_+3A_dens_method">dens_method</code></td>
<td>
<p>A method to get the density function. Here, only &quot;FFT&quot; is
available.</p>
</td></tr>
<tr><td><code id="dGTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="dGTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="dGTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size. Default is 2048.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As <code>q</code> is a numeric vector, the return value is also a numeric
vector of probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-5,5,0.25)
y &lt;- dGTS(x,0.3,0.2,1,1,1,1,0)

</code></pre>

<hr>
<h2 id='dKRTS'>Density Function of the Kim-Rachev tempered stable distribution</h2><span id='topic+dKRTS'></span>

<h3>Description</h3>

<p>The probability density function (PDF) of the Kim-Rachev tempered stable
distributions is not available in closed form.
Relies on fast Fourier transform (FFT) applied to the characteristic
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dKRTS(
  x,
  alpha = NULL,
  kp = NULL,
  km = NULL,
  rp = NULL,
  rm = NULL,
  pp = NULL,
  pm = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -20,
  b = 20,
  nf = 256
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dKRTS_+3A_x">x</code></td>
<td>
<p>A numeric vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="dKRTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="dKRTS_+3A_kp">kp</code>, <code id="dKRTS_+3A_km">km</code>, <code id="dKRTS_+3A_rp">rp</code>, <code id="dKRTS_+3A_rm">rm</code></td>
<td>
<p>Parameter of KR-distribution. A real number <code>&gt;0</code>.</p>
</td></tr>
<tr><td><code id="dKRTS_+3A_pp">pp</code>, <code id="dKRTS_+3A_pm">pm</code></td>
<td>
<p>Parameter of KR-distribution. A real number <code>&gt;-alpha</code>.</p>
</td></tr>
<tr><td><code id="dKRTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="dKRTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="dKRTS_+3A_dens_method">dens_method</code></td>
<td>
<p>Algorithm for numerical evaluation. Here you can only
choose <code>"FFT"</code>.</p>
</td></tr>
<tr><td><code id="dKRTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="dKRTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="dKRTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size. 256 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, kp, km,
rp, rm, pp. pm, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
</p>
<p>For examples, compare with <code><a href="#topic+dCTS">dCTS()</a></code>.
</p>


<h3>Value</h3>

<p>The CF of the the Kim-Rachev tempered stable distribution.
</p>

<hr>
<h2 id='dMTS'>Density function of the modified tempered stable (MTS) distribution</h2><span id='topic+dMTS'></span>

<h3>Description</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta, lambdap,
lambdam, mu)</code>. The probability density function (PDF) of the modified
tempered stable distributions is not available in closed form.
Relies on fast Fourier transform (FFT) applied to the characteristic
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dMTS(
  x,
  alpha = NULL,
  delta = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -20,
  b = 20,
  nf = 256
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dMTS_+3A_x">x</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dMTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="dMTS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dMTS_+3A_lambdap">lambdap</code>, <code id="dMTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dMTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="dMTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="dMTS_+3A_dens_method">dens_method</code></td>
<td>
<p>A method to get the density function. Here, only &quot;FFT&quot; is
available.</p>
</td></tr>
<tr><td><code id="dMTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="dMTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="dMTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size. 256 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples, compare with <code><a href="#topic+dCTS">dCTS()</a></code>.
</p>


<h3>Value</h3>

<p>As <code>x</code> is a numeric vector, the return value is also a numeric
vector of densities.
</p>

<hr>
<h2 id='dNTS'>Density function of the normal tempered stable (NTS) distribution</h2><span id='topic+dNTS'></span>

<h3>Description</h3>

<p>The probability density function (PDF) of the normal tempered stable
distributions is not available in closed form.
Relies on fast Fourier transform (FFT) applied to the characteristic
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dNTS(
  x,
  alpha = NULL,
  beta = NULL,
  delta = NULL,
  lambda = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -20,
  b = 20,
  nf = 2048
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dNTS_+3A_x">x</code></td>
<td>
<p>A numeric vector of quantile.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_alpha">alpha</code></td>
<td>
<p>A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_beta">beta</code></td>
<td>
<p>Any real number.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_delta">delta</code></td>
<td>
<p>A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_lambda">lambda</code></td>
<td>
<p>A  real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_theta">theta</code></td>
<td>
<p>A vector of all other arguments.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_dens_method">dens_method</code></td>
<td>
<p>Currently, useless param, as it does nothing and FFT is
always used.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="dNTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, beta, delta, lambda,
mu)</code>. Either provide the parameters individually OR provide <code>theta</code>.
Currently, the only method is FFT.
</p>


<h3>Value</h3>

<p>As <code>x</code> is a numeric vector, the return value is also a numeric
vector of densities.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0,15,0.25)
y &lt;- dNTS(x,0.8,1,1,1,1)
plot(x,y)

</code></pre>

<hr>
<h2 id='dRDTS'>Density function of the rapidly decreasing tempered stable (CTS) distribution</h2><span id='topic+dRDTS'></span>

<h3>Description</h3>

<p>The probability density function (PDF) of the rapidly decreasing tempered
stable distributions is not available in closed form.
Relies on fast Fourier transform (FFT) applied to the characteristic
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dRDTS(
  x,
  alpha = NULL,
  delta = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -20,
  b = 20,
  nf = 256
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dRDTS_+3A_x">x</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_dens_method">dens_method</code></td>
<td>
<p>Algorithm for numerical evaluation. Choose <code>
"FFT"</code>.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="dRDTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size. 256 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>. Methods include only the the Fast Fourier Transform
(FFT).
</p>
<p>For examples, compare with <code><a href="#topic+dCTS">dCTS()</a></code>.
</p>


<h3>Value</h3>

<p>As <code>x</code> is a numeric vector, the return value is also a numeric
vector of densities.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>

<hr>
<h2 id='dTSS'>Density function of the tempered stable subordinator (TSS) distribution</h2><span id='topic+dTSS'></span>

<h3>Description</h3>

<p>The probability density function (PDF) of tempered stable subordinator distribution.
It can be computed via the stable distribution (see details)
using the <code>stabledist</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dTSS(x, alpha = NULL, delta = NULL, lambda = NULL, theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dTSS_+3A_x">x</code></td>
<td>
<p>A numeric vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="dTSS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="dTSS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dTSS_+3A_lambda">lambda</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="dTSS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta, lambda)</code>. Either provide the parameters
<code>alpha</code>, <code>delta</code>, <code>lambda</code> individually OR provide <code>theta</code>.
</p>
<p style="text-align: center;"><code class="reqn">f_{TSS}(y;\theta)=\mathrm{e}^{-\lambda y-\lambda^{\alpha}\delta\Gamma(-\alpha)}f_{S(\alpha,\delta)}(y),</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">f_{S(\alpha,\delta)}</code>
</p>
<p> is the density of the stable subordinator.
</p>


<h3>Value</h3>

<p>As <code>x</code> is a numeric vector, the return value is also a numeric
vector of probability densities.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>
<p>Kawai, R. &amp; Masuda, H. (2011), 'On simulation of tempered stable random
variates' <a href="https://doi.org/10.1016/j.cam.2010.12.014">doi:10.1016/j.cam.2010.12.014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0,15,0.25)
y &lt;- dTSS(x,0.5,1,0.3)
plot(x,y)

</code></pre>

<hr>
<h2 id='parallelizeMCsimulation'>Function to parallelize the Monte Carlo Simulation</h2><span id='topic+parallelizeMCsimulation'></span>

<h3>Description</h3>

<p>Since the Monte Carlo Simulation is very computationally intensive, it may
be worthwhile to split it across all available processor cores. To do this,
simply pass all the parameters from the <code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code>
function to this function in the same way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallelizeMCsimulation(
  ParameterMatrix,
  MCparam = 10000,
  SampleSizes = c(200),
  saveOutput = FALSE,
  cores = 2,
  SeedOptions = NULL,
  iterationDisplayToFileSystem = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallelizeMCsimulation_+3A_parametermatrix">ParameterMatrix</code></td>
<td>
<p>The matrix is to be composed of vectors, row by row.
Each vector must fit the pattern of theta of the <code>TemperedType</code>.
Compared to the function <code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code>, the matrix here may
contain only one parameter vector.</p>
</td></tr>
<tr><td><code id="parallelizeMCsimulation_+3A_mcparam">MCparam</code></td>
<td>
<p>Number of Monte Carlo simulation for each couple of parameter,
default=100; integer</p>
</td></tr>
<tr><td><code id="parallelizeMCsimulation_+3A_samplesizes">SampleSizes</code></td>
<td>
<p>Sample sizes to be used to simulate the data. By default,
we use 200 (small sample size). Vector of integer. Compared to the function
<code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code>, the vector here may contain only one integer.</p>
</td></tr>
<tr><td><code id="parallelizeMCsimulation_+3A_saveoutput">saveOutput</code></td>
<td>
<p>Logical flag: In the function <code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code>
the argument can be true. Then an external csv file is created. Here the
argument must be false. The output of the values works in this function
exclusively via the return of the function.</p>
</td></tr>
<tr><td><code id="parallelizeMCsimulation_+3A_cores">cores</code></td>
<td>
<p>size of cluster for parallelization. Positive Integer.</p>
</td></tr>
<tr><td><code id="parallelizeMCsimulation_+3A_seedoptions">SeedOptions</code></td>
<td>
<p>is an argument what can be used in
<code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code> but must be NULL here.</p>
</td></tr>
<tr><td><code id="parallelizeMCsimulation_+3A_iterationdisplaytofilesystem">iterationDisplayToFileSystem</code></td>
<td>
<p>creates a text file in your file system
that displays the current iteration of the simulation.</p>
</td></tr>
<tr><td><code id="parallelizeMCsimulation_+3A_...">...</code></td>
<td>
<p>The function works only if all necessary arguments from the
function <code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code> are passed. See description and
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function exactly the arguments must be passed, which are also needed
for the function <code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code>. However, a few functions of
<code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code> are not possible here. The restrictions are
described in more detail for the individual arguments.
</p>
<p>In addition to the arguments of function <code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code>, the
argument &quot;cores&quot; can be assigned an integer value. This value determines how
many different processes are to be parallelized. If value is <code>NULL</code>, R
tries to read out how many cores the processor has and passes this
value to &quot;cores&quot;.
</p>
<p>During the simulation, the progress of the simulation can be viewed in a
file in the workspace named &quot;IterationControlForParallelization.txt&quot;.
</p>


<h3>Value</h3>

<p>The return object is a list of 2. Results of the simulation are
listed in <code>$outputMat</code>.
</p>

<hr>
<h2 id='pCTS'>Cumulative probability function of the classical tempered stable (CTS)
distribution</h2><span id='topic+pCTS'></span>

<h3>Description</h3>

<p>The cumulative probability distribution function (CDF) of the classical
tempered stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pCTS(
  q,
  alpha = NULL,
  deltap = NULL,
  deltam = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  a = -40,
  b = 40,
  nf = 2^13,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pCTS_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_deltap">deltap</code></td>
<td>
<p>Scale parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_deltam">deltam</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size.</p>
</td></tr>
<tr><td><code id="pCTS_+3A_...">...</code></td>
<td>
<p>Possibility to modify <code>stats::integrate()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, deltap, deltam,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
The function integrates the PDF numerically with <code>integrate()</code>.
</p>


<h3>Value</h3>

<p>As <code>q</code> is a numeric vector, the return value is also a numeric
vector of probabilities.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+dCTS">dCTS()</a></code> density-function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(-5,5,0.25)
y &lt;- pCTS(x,0.5,1,1,1,1,1)
plot(x,y)


</code></pre>

<hr>
<h2 id='pGTS'>Cumulative probability function of the generalized classical tempered stable
(GTS) distribution</h2><span id='topic+pGTS'></span>

<h3>Description</h3>

<p>The cumulative probability distribution function (CDF) of the generalized
classical tempered stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pGTS(
  q,
  alphap = NULL,
  alpham = NULL,
  deltap = NULL,
  deltam = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -40,
  b = 40,
  nf = 2048,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pGTS_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_alphap">alphap</code>, <code id="pGTS_+3A_alpham">alpham</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_deltap">deltap</code></td>
<td>
<p>Scale parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_deltam">deltam</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_dens_method">dens_method</code></td>
<td>
<p>A method to get the density function. Here, only &quot;FFT&quot; is
available.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size.</p>
</td></tr>
<tr><td><code id="pGTS_+3A_...">...</code></td>
<td>
<p>Possibility to modify <code>stats::integrate()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alphap, alpham, deltap,
deltam, lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
The function integrates the PDF numerically with <code>integrate()</code>.
</p>


<h3>Value</h3>

<p>As <code>q</code> is a numeric vector, the return value is also a numeric
vector of probabilities.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+dGTS">dGTS()</a></code> density-function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(-1,1,1)
y &lt;- pGTS(x,0.5,1.5,1,1,1,1,1)


</code></pre>

<hr>
<h2 id='pKRTS'>Cumulative probability distribution function of the Kim-Rachev tempered
stable (KRTS) distribution</h2><span id='topic+pKRTS'></span>

<h3>Description</h3>

<p>The cumulative probability distribution function (CDF) of the Kim-Rachev
tempered stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pKRTS(
  q,
  alpha = NULL,
  kp = NULL,
  km = NULL,
  rp = NULL,
  rm = NULL,
  pp = NULL,
  pm = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -40,
  b = 40,
  nf = 2048,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pKRTS_+3A_q">q</code></td>
<td>
<p>A vector of real numbers where the CF is evaluated.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_kp">kp</code>, <code id="pKRTS_+3A_km">km</code>, <code id="pKRTS_+3A_rp">rp</code>, <code id="pKRTS_+3A_rm">rm</code></td>
<td>
<p>Parameter of KR-distribution. A real number <code>&gt;0</code>.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_pp">pp</code>, <code id="pKRTS_+3A_pm">pm</code></td>
<td>
<p>Parameter of KR-distribution. A real number <code>&gt;-alpha</code>.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_dens_method">dens_method</code></td>
<td>
<p>Algorithm for numerical evaluation. Currently, only <code>
"FFT"</code> available.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -40
by default.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 40
by default.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size.</p>
</td></tr>
<tr><td><code id="pKRTS_+3A_...">...</code></td>
<td>
<p>Possibility to modify <code>stats::integrate()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, kp, km,
rp, rm, pp. pm, mu))</code>. Either provide the parameters individually OR
provide <code>theta</code>.
The function integrates the PDF numerically with <code>integrate()</code>.
</p>


<h3>Value</h3>

<p>As <code>q</code> is a numeric vector, the return value is also a numeric
vector of probabilities.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+dKRTS">dKRTS()</a></code> density-function.
</p>

<hr>
<h2 id='pMTS'>Cumulative probability function of the  modified tempered stable (MTS)
distribution</h2><span id='topic+pMTS'></span>

<h3>Description</h3>

<p>The cumulative probability distribution function (CDF) of the  modified
tempered stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pMTS(
  q,
  alpha = NULL,
  delta = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -40,
  b = 40,
  nf = 2048,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pMTS_+3A_q">q</code></td>
<td>
<p>A vector of real numbers where the CF is evaluated.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_lambdap">lambdap</code>, <code id="pMTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_dens_method">dens_method</code></td>
<td>
<p>A method to get the density function. Here, only &quot;FFT&quot; is
available.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size.</p>
</td></tr>
<tr><td><code id="pMTS_+3A_...">...</code></td>
<td>
<p>Possibility to modify <code>stats::integrate()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
The function integrates the PDF numerically with <code>integrate()</code>.
</p>


<h3>Value</h3>

<p>As <code>q</code> is a numeric vector, the return value is also a numeric
vector of probabilities.
</p>

<hr>
<h2 id='pNTS'>Cumulative probability function of the normal tempered stable (NTS)
distribution</h2><span id='topic+pNTS'></span>

<h3>Description</h3>

<p>The cumulative probability distribution function (CDF) of the normal
tempered stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pNTS(
  q,
  alpha = NULL,
  beta = NULL,
  delta = NULL,
  lambda = NULL,
  mu = NULL,
  theta = NULL,
  a = -40,
  b = 40,
  nf = 2^11,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pNTS_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantile.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_alpha">alpha</code></td>
<td>
<p>A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_beta">beta</code></td>
<td>
<p>Any real number.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_delta">delta</code></td>
<td>
<p>A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_lambda">lambda</code></td>
<td>
<p>A  real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_theta">theta</code></td>
<td>
<p>A vector of all other arguments.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_a">a</code></td>
<td>
<p>Starting point integrate density function. -40 by default.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_b">b</code></td>
<td>
<p>Ending point of integrate density function. 40 by default.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the fast Fourier transformation is divided in. Limited to
power-of-two size. 2^11 by default.</p>
</td></tr>
<tr><td><code id="pNTS_+3A_...">...</code></td>
<td>
<p>Change parameters in <code><a href="#topic+dNTS">dNTS()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, beta, delta, lambda,
mu)</code>. Either provide the parameters individually OR provide <code>theta</code>.
The function integrates the PDF numerically with <code>integrate()</code>.
</p>


<h3>Value</h3>

<p>As <code>q</code> is a numeric vector, the return value is also a numeric
vector of probabilities.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+dNTS">dNTS()</a></code> density-function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(-5,5,0.25)
y &lt;- pNTS(x,0.5,1,1,1,1)
plot(x,y)


</code></pre>

<hr>
<h2 id='pRDTS'>Cumulative probability function of the rapidly decreasing tempered stable
(RDTS) distribution</h2><span id='topic+pRDTS'></span>

<h3>Description</h3>

<p>The cumulative probability distribution function (CDF) of the rapidly
decreasing tempered stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pRDTS(
  q,
  alpha = NULL,
  delta = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  dens_method = "FFT",
  a = -130,
  b = 130,
  nf = 2048,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pRDTS_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_dens_method">dens_method</code></td>
<td>
<p>Algorithm for numerical evaluation. Currently, only <code>
"FFT"</code> available.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_a">a</code></td>
<td>
<p>Starting point of FFT, if <code>dens_method == "FFT"</code>. -20
by default.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_b">b</code></td>
<td>
<p>Ending point of FFT, if <code>dens_method == "FFT"</code>. 20
by default.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_nf">nf</code></td>
<td>
<p>Pieces the transformation is divided in. Limited to power-of-two
size.</p>
</td></tr>
<tr><td><code id="pRDTS_+3A_...">...</code></td>
<td>
<p>Possibility to modify <code>stats::integrate()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
The function integrates the PDF numerically with <code>integrate()</code>.
</p>


<h3>Value</h3>

<p>As <code>q</code> is a numeric vector, the return value is also a numeric
vector of probabilities.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+dRDTS">dRDTS()</a></code> density-function.
</p>

<hr>
<h2 id='pTSS'>Cumulative probability distribution function of the tempered stable subordinator
distribution</h2><span id='topic+pTSS'></span>

<h3>Description</h3>

<p>The cumulative probability distribution function (CDF) of the tempered
stable subordinator distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pTSS(
  q,
  alpha = NULL,
  delta = NULL,
  lambda = NULL,
  theta = NULL,
  pmethod = "integrate",
  N = 8192,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pTSS_+3A_q">q</code></td>
<td>
<p>A numeric vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="pTSS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="pTSS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pTSS_+3A_lambda">lambda</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="pTSS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="pTSS_+3A_pmethod">pmethod</code></td>
<td>
<p>A string. If not &quot;integrate&quot;, the function <code>chartocdf()</code>
will be triggered.</p>
</td></tr>
<tr><td><code id="pTSS_+3A_n">N</code></td>
<td>
<p>is a power of two &amp; N &gt;= 1024. if
<code>pmethod != "integrate"</code>. 8192 by default. Relevant for</p>
</td></tr>
<tr><td><code id="pTSS_+3A_...">...</code></td>
<td>
<p>Possibility to modify <code>stats::integrate()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta, lambda)</code>. Either provide the parameters
<code>alpha</code>, <code>delta</code>, <code>lambda</code> individually OR provide <code>theta</code>.
The function integrates the PDF numerically with <code>integrate()</code>.
</p>


<h3>Value</h3>

<p>As <code>q</code> is a numeric vector, the return value is also a numeric
vector of probabilities.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+dTSS">dTSS()</a></code> density-function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0,15,0.5)
y &lt;- pTSS(x,0.7,1.354,0.3)
plot(x,y)


</code></pre>

<hr>
<h2 id='qCTS'>Quantile function of the classical tempered stable (CTS)</h2><span id='topic+qCTS'></span>

<h3>Description</h3>

<p>The quantile function of the classical tempered stable (CTS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qCTS(
  p,
  alpha = NULL,
  deltap = NULL,
  deltam = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  qmin = NULL,
  qmax = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qCTS_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities. Each probability must be a real
number &gt;0 and &lt;1.</p>
</td></tr>
<tr><td><code id="qCTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="qCTS_+3A_deltap">deltap</code></td>
<td>
<p>Scale parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="qCTS_+3A_deltam">deltam</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="qCTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="qCTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="qCTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="qCTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="qCTS_+3A_qmin">qmin</code>, <code id="qCTS_+3A_qmax">qmax</code></td>
<td>
<p>Limits of the interval. Will be computed if
<code>==NULL</code>.</p>
</td></tr>
<tr><td><code id="qCTS_+3A_...">...</code></td>
<td>
<p>Modify <code><a href="#topic+pTSS">pTSS()</a></code> and <code><a href="stats.html#topic+uniroot">stats::uniroot()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, deltap, deltam,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
The function searches for a root between <code>qmin</code> and <code>qmax</code> with
<code>uniroot</code>. Boundaries can either be supplied by the user or a built-in
approach using the stable distribution is used.
</p>


<h3>Value</h3>

<p>As <code>p</code> is a numeric vector, the return value is also a numeric
vector of quantiles.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+pCTS">pCTS()</a></code> probability function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  qCTS(0.5,1.5,1,1,1,1,1)


</code></pre>

<hr>
<h2 id='qNTS'>Quantile function of the normal tempered stable (NTS)</h2><span id='topic+qNTS'></span>

<h3>Description</h3>

<p>The quantile function of the normal tempered stable (NTS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qNTS(
  p,
  alpha = NULL,
  beta = NULL,
  delta = NULL,
  lambda = NULL,
  mu = NULL,
  theta = NULL,
  qmin = NULL,
  qmax = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qNTS_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities. Each probability must be a real
number &gt;0 and &lt;1.</p>
</td></tr>
<tr><td><code id="qNTS_+3A_alpha">alpha</code></td>
<td>
<p>A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="qNTS_+3A_beta">beta</code></td>
<td>
<p>A gap holder.</p>
</td></tr>
<tr><td><code id="qNTS_+3A_delta">delta</code></td>
<td>
<p>A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="qNTS_+3A_lambda">lambda</code></td>
<td>
<p>A  real number &gt;= 0.</p>
</td></tr>
<tr><td><code id="qNTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="qNTS_+3A_theta">theta</code></td>
<td>
<p>A vector of all other arguments.</p>
</td></tr>
<tr><td><code id="qNTS_+3A_qmin">qmin</code>, <code id="qNTS_+3A_qmax">qmax</code></td>
<td>
<p>Limits of the interval. Will be computed if
<code>==NULL</code>.</p>
</td></tr>
<tr><td><code id="qNTS_+3A_...">...</code></td>
<td>
<p>Modify <code><a href="#topic+pNTS">pNTS()</a></code> and <code><a href="stats.html#topic+uniroot">stats::uniroot()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, beta, delta, lambda,
mu)</code>. Either provide the parameters individually OR provide <code>theta</code>.
The function searches for a root between <code>qmin</code> and <code>qmax</code> with
<code>uniroot</code>.
Boundaries can either be supplied by the user or a built-in approach using
the stable distribution is used.
</p>


<h3>Value</h3>

<p>As <code>p</code> is a numeric vector, the return value is also a numeric
vector of quantiles.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+pNTS">pNTS()</a></code> probability function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
qNTS(0.1,0.5,1,1,1,1)
qNTS(0.3,0.6,1,1,1,1,NULL)


</code></pre>

<hr>
<h2 id='qTSS'>Quantile function of the tempered stable subordinator distribution</h2><span id='topic+qTSS'></span>

<h3>Description</h3>

<p>The quantile function of the tempered stable
subordinator distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qTSS(
  p,
  alpha = NULL,
  delta = NULL,
  lambda = NULL,
  theta = NULL,
  qmin = NULL,
  qmax = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qTSS_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities. Each probability must be a real
number &gt;0 and &lt;1.</p>
</td></tr>
<tr><td><code id="qTSS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="qTSS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="qTSS_+3A_lambda">lambda</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="qTSS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="qTSS_+3A_qmin">qmin</code>, <code id="qTSS_+3A_qmax">qmax</code></td>
<td>
<p>Limits of the interval. Will be computed if
<code>==NULL</code>.</p>
</td></tr>
<tr><td><code id="qTSS_+3A_...">...</code></td>
<td>
<p>Modify <code><a href="#topic+pTSS">pTSS()</a></code> and <code><a href="stats.html#topic+uniroot">stats::uniroot()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta, lambda)</code>.
Either provide the parameters <code>alpha</code>, <code>delta</code>, <code>lambda</code>
individually OR provide <code>theta</code>. The function searches for a root
between <code>qmin</code> and <code>qmax</code> with <code>uniroot</code>. Boundaries can
either be supplied by the user or a built-in approach using the stable
distribution is used.
</p>


<h3>Value</h3>

<p>As <code>p</code> is a numeric vector, the return value is also a numeric
vector of quantiles.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+pTSS">pTSS()</a></code> probability function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
qTSS(0.5,0.5,5,0.01)
qTSS(0.5,0.9,1,10,NULL)


</code></pre>

<hr>
<h2 id='rCTS'>Function to generate random variates of CTS distribution.</h2><span id='topic+rCTS'></span>

<h3>Description</h3>

<p>Generates <code>n</code> random numbers distributed according to the classical
tempered stable (CTS) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rCTS(
  n,
  alpha = NULL,
  deltap = NULL,
  deltam = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  methodR = "TM",
  k = 10000,
  c = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rCTS_+3A_n">n</code></td>
<td>
<p>sample size (integer).</p>
</td></tr>
<tr><td><code id="rCTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="rCTS_+3A_deltap">deltap</code></td>
<td>
<p>Scale parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rCTS_+3A_deltam">deltam</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rCTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rCTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rCTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="rCTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="rCTS_+3A_methodr">methodR</code></td>
<td>
<p>A String. Either &quot;TM&quot;,&quot;AR&quot; or &quot;SR&quot;.</p>
</td></tr>
<tr><td><code id="rCTS_+3A_k">k</code></td>
<td>
<p>integer: the level of truncation, if <code>methodR == "SR"</code>. 10000
by default.</p>
</td></tr>
<tr><td><code id="rCTS_+3A_c">c</code></td>
<td>
<p>A real number. Only relevant for <code>methodR == "AR"</code>.
1 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, deltap, deltam,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
&quot;AR&quot; stands for the approximate Acceptance-Rejection Method and &quot;SR&quot; for a
truncated infinite shot noise series representation. &quot;TM&quot; stands for Two
Methods as two different methods are used depending on which will be faster.
&quot;TM&quot; works only for <code>alpha &lt; 1</code>.
In this method the function <code><a href="copula.html#topic+retstable">copula::retstable()</a></code> is called. For
<code>alpha &lt; 1</code>, &quot;TM&quot; is the default method, while &quot;AR&quot; for <code>alpha &gt; 1</code>
is the default method.
</p>
<p>It is recommended to check the generated random numbers once for each
distribution using the density function. If the random numbers are shifted,
e.g. for the method &quot;SR&quot;, it may be worthwhile to increase k.
</p>
<p>For more details, see references.
</p>


<h3>Value</h3>

<p>Generates <code>n</code> random numbers of the CTS distribution.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>
<p>Kawai, R &amp; Masuda, H (2011), 'On simulation of tempered stable random
variates' <a href="https://doi.org/10.1016/j.cam.2010.12.014">doi:10.1016/j.cam.2010.12.014</a>
</p>
<p>Hofert, M (2011), 'Sampling Exponentially Tilted Stable Distributions'
<a href="https://doi.org/10.1145/2043635.2043638">doi:10.1145/2043635.2043638</a>
</p>


<h3>See Also</h3>

<p><code><a href="copula.html#topic+retstable">copula::retstable()</a></code> as &quot;TM&quot; uses this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rCTS(10,0.5,1,1,1,1,1,NULL,"SR",10)
rCTS(10,0.5,1,1,1,1,1,NULL,"aAR")

</code></pre>

<hr>
<h2 id='rGTS'>Function to generate random variates of GTS distribution.</h2><span id='topic+rGTS'></span>

<h3>Description</h3>

<p>Generates <code>n</code> random numbers distributed according to the generalized
classical tempered stable (GTS) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rGTS(
  n,
  alphap = NULL,
  alpham = NULL,
  deltap = NULL,
  deltam = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  methodR = "AR",
  k = 10000,
  c = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rGTS_+3A_n">n</code></td>
<td>
<p>sample size (integer).</p>
</td></tr>
<tr><td><code id="rGTS_+3A_alphap">alphap</code>, <code id="rGTS_+3A_alpham">alpham</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="rGTS_+3A_deltap">deltap</code></td>
<td>
<p>Scale parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rGTS_+3A_deltam">deltam</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rGTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rGTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rGTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="rGTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="rGTS_+3A_methodr">methodR</code></td>
<td>
<p>A String. Either &quot;TM&quot;,&quot;AR&quot; or &quot;SR&quot;.</p>
</td></tr>
<tr><td><code id="rGTS_+3A_k">k</code></td>
<td>
<p>integer: the level of truncation, if <code>methodR == "SR"</code>. 10000
by default.</p>
</td></tr>
<tr><td><code id="rGTS_+3A_c">c</code></td>
<td>
<p>A real number. Only relevant for <code>methodR == "AR"</code>.
1 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alphap, alpham, deltap,
deltam, lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
&quot;AR&quot; stands for the approximate Acceptance-Rejection Method and &quot;SR&quot; for a
truncated infinite shot noise series representation.
</p>
<p>It is recommended to check the generated random numbers once for each
distribution using the density function. If the random numbers are shifted,
e.g. for the method &quot;SR&quot;, it may be worthwhile to increase k.
</p>
<p>For more details, see references.
</p>


<h3>Value</h3>

<p>Generates <code>n</code> random numbers of the CTS distribution.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>
<p>Kawai, R &amp; Masuda, H (2011), 'On simulation of tempered stable random
variates' <a href="https://doi.org/10.1016/j.cam.2010.12.014">doi:10.1016/j.cam.2010.12.014</a>
</p>
<p>Hofert, M (2011), 'Sampling Exponentially Tilted Stable Distributions'
<a href="https://doi.org/10.1145/2043635.2043638">doi:10.1145/2043635.2043638</a>
</p>


<h3>See Also</h3>

<p><code><a href="copula.html#topic+retstable">copula::retstable()</a></code> as &quot;TM&quot; uses this function and <code><a href="#topic+rCTS">rCTS()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rGTS(2,1.5,0.5,1,1,1,1,0,NULL,"SR")
rGTS(2,1.5,0.5,1,1,1,1,1,NULL,"aAR")

</code></pre>

<hr>
<h2 id='rKRTS'>Function to generate random variates of KRTS distribution.</h2><span id='topic+rKRTS'></span>

<h3>Description</h3>

<p>Generates <code>n</code> random numbers distributed according to the Kim-Rachev
tempered stable (KRTS) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rKRTS(
  n,
  alpha = NULL,
  kp = NULL,
  km = NULL,
  rp = NULL,
  rm = NULL,
  pp = NULL,
  pm = NULL,
  mu = NULL,
  theta = NULL,
  methodR = "SR",
  k = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rKRTS_+3A_n">n</code></td>
<td>
<p>sample size (integer).</p>
</td></tr>
<tr><td><code id="rKRTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="rKRTS_+3A_kp">kp</code>, <code id="rKRTS_+3A_km">km</code>, <code id="rKRTS_+3A_rp">rp</code>, <code id="rKRTS_+3A_rm">rm</code></td>
<td>
<p>Parameter of KR-distribution. A real number <code>&gt;0</code>.</p>
</td></tr>
<tr><td><code id="rKRTS_+3A_pp">pp</code>, <code id="rKRTS_+3A_pm">pm</code></td>
<td>
<p>Parameter of KR-distribution. A real number <code>&gt;-alpha</code>.</p>
</td></tr>
<tr><td><code id="rKRTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="rKRTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="rKRTS_+3A_methodr">methodR</code></td>
<td>
<p>A String. Only &quot;SR&quot; is available here.</p>
</td></tr>
<tr><td><code id="rKRTS_+3A_k">k</code></td>
<td>
<p>integer: the level of truncation, if <code>methodR == "SR"</code>. 10000
by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, kp, km,
rp, rm, pp. pm, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
&quot;SR&quot; stands for a truncated infinite shot noise series representation.
Currently, this method is the only implemented to generate random variates.
The series representation is given by Bianchi et a. (2010).
</p>
<p>It is recommended to check the generated random numbers once for each
distribution using the density function. If the random numbers are shifted,
e.g. for the method &quot;SR&quot;, it may be worthwhile to increase k.
</p>
<p>For more details, see references.
</p>


<h3>Value</h3>

<p>Generates <code>n</code> random numbers of the KRTS distribution.
</p>


<h3>References</h3>

<p>Bianchi, M. L.; Rachev, S. T.; Kim, Y. S. &amp; Fabozzi, F. J. (2010), 'Tempered
stable distributions and processes in finance: Numerical analysis'
<a href="https://doi.org/10.1007/978-88-470-1481-7">doi:10.1007/978-88-470-1481-7</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rKRTS(1,0.5,1,1,1,1,1,1,0,NULL,"SR")

</code></pre>

<hr>
<h2 id='rMTS'>Function to generate random variates of MTS distribution</h2><span id='topic+rMTS'></span>

<h3>Description</h3>

<p>Generates <code>n</code> random numbers distributed according to the modified
tempered stable (MTS) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMTS(
  n,
  alpha = NULL,
  delta = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  methodR = "SR",
  k = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMTS_+3A_n">n</code></td>
<td>
<p>sample size (integer).</p>
</td></tr>
<tr><td><code id="rMTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="rMTS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rMTS_+3A_lambdap">lambdap</code>, <code id="rMTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rMTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="rMTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="rMTS_+3A_methodr">methodR</code></td>
<td>
<p>A String. Either &quot;TM&quot;, &quot;AR&quot; or &quot;SR&quot;.</p>
</td></tr>
<tr><td><code id="rMTS_+3A_k">k</code></td>
<td>
<p>integer: the level of truncation, if <code>methodR == "SR"</code>.
10000 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, random variants can only be generated using the series
representation given by Bianchi et al. (2011).
</p>
<p>It is recommended to check the generated random numbers once for each
distribution using the density function. If the random numbers are shifted,
e.g. for the method &quot;SR&quot;, it may be worthwhile to increase k.
</p>


<h3>Value</h3>

<p>Generates <code>n</code> random numbers of the CTS distribution.
</p>


<h3>References</h3>

<p>Bianchi, M. L.; Rachev, S. T.; Kim, Y. S. &amp; Fabozzi, F. J. (2011), 'Tempered
infinitely divisible distributions and processes'
<a href="https://doi.org/10.1137/S0040585X97984632">doi:10.1137/S0040585X97984632</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rMTS(2,0.5,1,1,1,0,NULL,"SR")

</code></pre>

<hr>
<h2 id='rNTS'>Function to generate random variates of NTS distribution.</h2><span id='topic+rNTS'></span>

<h3>Description</h3>

<p>Generates <code>n</code> random numbers distributed according
of the normal tempered stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rNTS(
  n,
  alpha = NULL,
  beta = NULL,
  delta = NULL,
  lambda = NULL,
  mu = NULL,
  theta = NULL,
  methodR = "TM",
  k = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rNTS_+3A_n">n</code></td>
<td>
<p>sample size (integer).</p>
</td></tr>
<tr><td><code id="rNTS_+3A_alpha">alpha</code></td>
<td>
<p>A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="rNTS_+3A_beta">beta</code></td>
<td>
<p>A gap holder.</p>
</td></tr>
<tr><td><code id="rNTS_+3A_delta">delta</code></td>
<td>
<p>A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rNTS_+3A_lambda">lambda</code></td>
<td>
<p>A  real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rNTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="rNTS_+3A_theta">theta</code></td>
<td>
<p>A vector of all other arguments.</p>
</td></tr>
<tr><td><code id="rNTS_+3A_methodr">methodR</code></td>
<td>
<p>A String. Either &quot;TM&quot;,&quot;AR&quot; or &quot;SR&quot;. &quot;TM&quot; by default.</p>
</td></tr>
<tr><td><code id="rNTS_+3A_k">k</code></td>
<td>
<p>integer: the number of replications, if <code>methodR == "SR"</code>. 10000
by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, beta, delta, lambda,
mu)</code>. Either provide the parameters individually OR provide <code>theta</code>.
Works by a normal variance-mean mixture with a TSS distribution. Method
parameter is for the method of simulating the TSS random variable, see the
<code><a href="#topic+rTSS">rTSS()</a></code> function.
&quot;AR&quot; stands for the Acceptance-Rejection Method and &quot;SR&quot; for a truncated
infinite shot noise series representation. &quot;TM&quot; stands for Two Methods as
two different methods are used depending on which will be faster. In this
method the function <code><a href="copula.html#topic+retstable">copula::retstable()</a></code> is called. &quot;TM&quot; is the standard
method used. For more details, see references.
</p>
<p>It is recommended to check the generated random numbers once for each
distribution using the density function. If the random numbers are shifted,
e.g. for the method &quot;SR&quot;, it may be worthwhile to increase k.
</p>
<p>For more details, see references.
</p>


<h3>Value</h3>

<p>Generates <code>n</code> random numbers.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>
<p>Kawai, R &amp; Masuda, H (2011), 'On simulation of tempered stable random
variates' <a href="https://doi.org/10.1016/j.cam.2010.12.014">doi:10.1016/j.cam.2010.12.014</a>
</p>
<p>Hofert, M (2011), 'Sampling Exponentially Tilted Stable Distributions'
<a href="https://doi.org/10.1145/2043635.2043638">doi:10.1145/2043635.2043638</a>
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+rTSS">rTSS()</a></code> function.
<code><a href="copula.html#topic+retstable">copula::retstable()</a></code> as &quot;TM&quot; uses this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rNTS(100, 0.5, 1,1,1,1)
rNTS(10, 0.6, 0,1,1,0)
rNTS(10, 0.5, 1,1,1,1, NULL, "SR", 100)

</code></pre>

<hr>
<h2 id='rRDTS'>Function to generate random variates of RDTS distribution.</h2><span id='topic+rRDTS'></span>

<h3>Description</h3>

<p>Generates <code>n</code> random numbers distributed according to the rapidly
decreasing tempered stable (CTS) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rRDTS(
  n,
  alpha = NULL,
  delta = NULL,
  lambdap = NULL,
  lambdam = NULL,
  mu = NULL,
  theta = NULL,
  methodR = "SR",
  k = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rRDTS_+3A_n">n</code></td>
<td>
<p>sample size (integer).</p>
</td></tr>
<tr><td><code id="rRDTS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 2.</p>
</td></tr>
<tr><td><code id="rRDTS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rRDTS_+3A_lambdap">lambdap</code></td>
<td>
<p>Tempering parameter for the right tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rRDTS_+3A_lambdam">lambdam</code></td>
<td>
<p>Tempering parameter for the left tail. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rRDTS_+3A_mu">mu</code></td>
<td>
<p>A location parameter, any real number.</p>
</td></tr>
<tr><td><code id="rRDTS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="rRDTS_+3A_methodr">methodR</code></td>
<td>
<p>A String. Only &quot;SR&quot; works currently.</p>
</td></tr>
<tr><td><code id="rRDTS_+3A_k">k</code></td>
<td>
<p>integer: the level of truncation, if <code>methodR == "SR"</code>. 10000
by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta,
lambdap, lambdam, mu)</code>. Either provide the parameters individually OR
provide <code>theta</code>.
&quot;SR&quot; stands for a truncated infinite shot noise series representation. Kim et
al. (2010) showed how to simulate random variates with SR-method for the RDTS
distribution. For more details, see references.
</p>
<p>It is recommended to check the generated random numbers once for each
distribution using the density function. If the random numbers are shifted,
e.g. for the method &quot;SR&quot;, it may be worthwhile to increase k.
</p>


<h3>Value</h3>

<p>Generates <code>n</code> random numbers of the RDTS distribution.
</p>


<h3>References</h3>

<p>Kim, Young Shi &amp; Rachev, Svetlozar T. &amp; Leonardo Bianchi, Michele &amp; Fabozzi,
Frank J. (2010), 'Tempered stable and tempered infinitely divisible GARCH
models' <a href="https://doi.org/10.1016/j.jbankfin.2010.01.015">doi:10.1016/j.jbankfin.2010.01.015</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rCTS(10,0.5,1,1,1,1,1,NULL,"SR",10)
rCTS(10,0.5,1,1,1,1,1,NULL,"aAR")

</code></pre>

<hr>
<h2 id='rTSS'>Function to generate random variates of the TSS distribution.</h2><span id='topic+rTSS'></span>

<h3>Description</h3>

<p>Generates <code>n</code> random numbers distributed according
of the tempered stable subordinator distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTSS(
  n,
  alpha = NULL,
  delta = NULL,
  lambda = NULL,
  theta = NULL,
  methodR = "TM",
  k = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rTSS_+3A_n">n</code></td>
<td>
<p>sample size (integer).</p>
</td></tr>
<tr><td><code id="rTSS_+3A_alpha">alpha</code></td>
<td>
<p>Stability parameter. A real number between 0 and 1.</p>
</td></tr>
<tr><td><code id="rTSS_+3A_delta">delta</code></td>
<td>
<p>Scale parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rTSS_+3A_lambda">lambda</code></td>
<td>
<p>Tempering parameter. A real number &gt; 0.</p>
</td></tr>
<tr><td><code id="rTSS_+3A_theta">theta</code></td>
<td>
<p>Parameters stacked as a vector.</p>
</td></tr>
<tr><td><code id="rTSS_+3A_methodr">methodR</code></td>
<td>
<p>A String. Either &quot;TM&quot;, &quot;AR&quot; or &quot;SR&quot;.</p>
</td></tr>
<tr><td><code id="rTSS_+3A_k">k</code></td>
<td>
<p>integer: the level of truncation, if <code>methodR == "SR"</code>. 10000
by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> denotes the parameter vector <code>(alpha, delta, lambda)</code>.
Either provide the parameters <code>alpha</code>, <code>delta</code>, <code>lambda</code>
individually OR provide <code>theta</code>.
&quot;AR&quot; stands for the Acceptance-Rejection Method and &quot;SR&quot; for a truncated
infinite shot noise series representation. &quot;TM&quot; stands for Two Methods as
two different methods are used depending on which will be faster. In this
method the function <code><a href="copula.html#topic+retstable">copula::retstable()</a></code> is called. &quot;TM&quot; is the standard
method used.
</p>
<p>It is recommended to check the generated random numbers once for each
distribution using the density function. If the random numbers are shifted,
e.g. for the method &quot;SR&quot;, it may be worthwhile to increase k.
</p>
<p>For more details, see references.
</p>


<h3>Value</h3>

<p>Generates <code>n</code> random numbers.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>
<p>Kawai, R &amp; Masuda, H (2011), 'On simulation of tempered stable random
variates' <a href="https://doi.org/10.1016/j.cam.2010.12.014">doi:10.1016/j.cam.2010.12.014</a>
</p>
<p>Hofert, M (2011), 'Sampling Exponentially Tilted Stable Distributions'
<a href="https://doi.org/10.1145/2043635.2043638">doi:10.1145/2043635.2043638</a>
</p>


<h3>See Also</h3>

<p><code><a href="copula.html#topic+retstable">copula::retstable()</a></code> as &quot;TM&quot; uses this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rTSS(100,0.5,1,1)
rTSS(100,0.5,1,1,NULL,"SR",50)

</code></pre>

<hr>
<h2 id='TemperedEstim'>Estimation function</h2><span id='topic+TemperedEstim'></span>

<h3>Description</h3>

<p>Main estimation function for the tempered stabled distributions
offered within this package. It allows the user to select the
preferred estimation method and several related options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TemperedEstim(
  TemperedType = c("CTS", "TSS", "NTS", "MTS", "GTS", "KRTS", "RDTS"),
  EstimMethod = c("ML", "GMM", "Cgmm", "GMC"),
  data,
  theta0 = NULL,
  ComputeCov = FALSE,
  HandleError = TRUE,
  eps = 1e-06,
  algo = NULL,
  regularization = NULL,
  WeightingMatrix = NULL,
  t_scheme = NULL,
  alphaReg = NULL,
  t_free = NULL,
  nb_t = NULL,
  subdivisions = NULL,
  IntegrationMethod = NULL,
  randomIntegrationLaw = NULL,
  s_min = NULL,
  s_max = NULL,
  ncond = NULL,
  IterationControl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TemperedEstim_+3A_temperedtype">TemperedType</code></td>
<td>
<p>A String. Either &quot;CTS&quot;, &quot;TSS&quot;, &quot;NTS&quot;, &quot;MTS&quot;, &quot;GTS&quot;,
&quot;KRTS&quot;, &quot;RDTS&quot;.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_estimmethod">EstimMethod</code></td>
<td>
<p>A String. Either &quot;ML&quot;, &quot;GMM&quot;, &quot;Cgmm&quot;, or &quot;GMC&quot;.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_data">data</code></td>
<td>
<p>Data used to perform the estimation: numeric vector of length n.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_theta0">theta0</code></td>
<td>
<p>A vector of numeric values corresponding to the pattern of the
<code>TemperedType</code>.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_computecov">ComputeCov</code></td>
<td>
<p>Logical flag: If set to TRUE, the asymptotic covariance
matrix is computed. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_handleerror">HandleError</code></td>
<td>
<p>Logical flag: If set to <code>TRUE</code> and if an error occurs
during the estimation procedure, the computation will carry on and NA will be
returned. Useful for Monte Carlo simulations.<code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_eps">eps</code></td>
<td>
<p>Numerical error tolerance. <code>1e-06</code> by default.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_algo">algo</code></td>
<td>
<p>algorithm: For GMM: <code>"2SGMM"</code> is the two step GMM proposed
by Hansen (1982). <code>"CueGMM"</code> and <code>"ITGMM"</code> are respectively the
continuous updated and the iterative GMM proposed by Hansen, Eaton et Yaron
(1996) and adapted to the continuum case. For GMC: <code>"2SGMC", "CueGMC"</code>.
For Cgmm: <code>"2SCgmm", "CueCgmm", ...</code>.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_regularization">regularization</code></td>
<td>
<p>regularization scheme to be used for moment methods,
one of <code>"Tikhonov"</code> (Tikhonov), <code>"LF"</code> (Landweber-Fridmann) and
<code>"cut-off"</code> (spectral cut-off).</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_weightingmatrix">WeightingMatrix</code></td>
<td>
<p>type of weighting matrix used to compute the
objective function for the GMM and GMC methods, one of <code>"OptAsym"</code> (the
optimal asymptotic), <code>"DataVar"</code> (the data driven, only for GMM) and
<code>"Id"</code> (the identity matrix).</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_t_scheme">t_scheme</code></td>
<td>
<p>scheme used to select the points for the GMM method where the
moment conditions are evaluated, one of <code>"equally"</code> (equally placed),
<code>"NonOptAr"</code> (non optimal arithmetic placement), <code>"uniformOpt"</code>
(uniform optimal placement), <code>"ArithOpt"</code> (arithmetic optimal
placement), <code>"Var Opt"</code> (optimal variance placement) and <code>"free"</code>
(users need to pass their own set of points in ...).</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_alphareg">alphaReg</code></td>
<td>
<p>value of the regularisation parameter; numeric. Example Value
could be ==0.01.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_t_free">t_free</code></td>
<td>
<p>sequence, if <code>t_scheme=="free"</code>.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_nb_t">nb_t</code></td>
<td>
<p>integer, if you set <code>t_scheme &lt;- "equally"</code>. nb_t could be
== 20 for example.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_subdivisions">subdivisions</code></td>
<td>
<p>Number of subdivisions used to compute the different
integrals involved in the computation of the objective function for the Cgmm
method (to minimise); numeric.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_integrationmethod">IntegrationMethod</code></td>
<td>
<p>Numerical integration method to be used to
approximate the (vectorial) integrals for the Cgmm method. Users can choose
between &quot;Uniform&quot; discretization or the &quot;Simpson&quot;'s rule (the 3-point
Newton-Cotes quadrature rule).</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_randomintegrationlaw">randomIntegrationLaw</code></td>
<td>
<p>Probability measure associated to the Hilbert
space spanned by the moment conditions for the Cgmm method.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_s_min">s_min</code>, <code id="TemperedEstim_+3A_s_max">s_max</code></td>
<td>
<p>Lower and Upper bounds of the interval where the moment
conditions are considered for the Cgmm method; numeric.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_ncond">ncond</code></td>
<td>
<p>Integer. Number of moment conditions (until order <code>ncond</code>)
for the GMC method. Must not be less than 3 for TSS, 6 for CTS, 5 for NTS.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_iterationcontrol">IterationControl</code></td>
<td>
<p>only used if algo = &quot;IT...&quot; or algo = &quot;Cue...&quot;
to control the iterations. See Details.</p>
</td></tr>
<tr><td><code id="TemperedEstim_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the estimation function or the
asymptotic confidence level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>TemperedType</strong> Detailed documentation of the individual tempered
stable distributions can be viewed in the respective characteristic function.
With the parameter 'TemperedTyp' you can choose the tempered stable
distribution you want to use. Here is a list of distribution you can choose
from:
</p>

<dl>
<dt>TSS</dt><dd><p>Tempered stabel subordinator: See <code><a href="#topic+charTSS">charTSS()</a></code> for details.</p>
</dd>
<dt>CTS</dt><dd><p>Classical tempered stable distribution: See <code><a href="#topic+charCTS">charCTS()</a></code> for
details.</p>
</dd>
<dt>GTS</dt><dd><p>Generalized classical tempered stable distribution: See
<code><a href="#topic+charGTS">charGTS()</a></code> for details.</p>
</dd>
<dt>NTS</dt><dd><p>Normal tempered stable distribution: See <code><a href="#topic+charNTS">charNTS()</a></code> for
details.</p>
</dd>
<dt>MTS</dt><dd><p>Modified tempered stable distribution: See <code><a href="#topic+charMTS">charMTS()</a></code> for
details.</p>
</dd>
<dt>RDTS</dt><dd><p>Rapid decreasing tempered stable distribution: See <code><a href="#topic+charRDTS">charRDTS()</a></code>
for details.</p>
</dd>
<dt>KRTS</dt><dd><p>Kim-Rachev tempered stable distribution: See <code><a href="#topic+charKRTS">charKRTS()</a></code> for
details.</p>
</dd>
</dl>

<p><strong>Estimfct</strong> Additional parameters are needed for different estimation
functions. These are listed below for each function. The list of additional
parameters starts after the parameter <code>eps</code> in the parameter list.
</p>

<dl>
<dt>For ML:</dt><dd><p>See usage of Maximum likelihood estimation in Kim et al.
(2008). No additional parameters are needed.</p>
</dd>
<dt>For GMM:</dt><dd><p>Generalized Method of Moments by Feuerverger (1981).
The parameters <code>algo, alphaReg, regularization, WeightingMatrix, and
  t_scheme</code> must be specified.
</p>
<p>Parameter <code>t_scheme</code>: One of the most important features of this
method is that it allows the user to choose how to place the points where
the moment conditions are evaluated. One can choose among 6 different
options. Depending on the option, further parameters have to be passed.
</p>

<dl>
<dt>&quot;equally&quot;:</dt><dd><p>equally placed points in <code>min_t,max_t</code>. When
provided, user's <code>min_t</code> and <code>max_t</code> will be used (when
<code>Coinstrained == FALSE</code>).
</p>
</dd>
<dt>&quot;NonOptAr&quot;:</dt><dd><p>non optimal arithmetic placement.
</p>
</dd>
<dt>&quot;uniformOpt&quot;:</dt><dd><p>uniform optimal placement.
</p>
</dd>
<dt>&quot;ArithOpt&quot;:</dt><dd><p>arithmetic optimal placement.
</p>
</dd>
<dt>&quot;Var Opt&quot;:</dt><dd><p>optimal variance placement as explained above.
</p>
</dd>
<dt>&quot;free&quot;:</dt><dd><p>user needs to pass own set of points in <code>t_free</code>.
</p>
</dd>
</dl>

<p>Parameter <code>WeightingMatrix</code>: One can choose among 3 different options:
</p>

<dl>
<dt>&quot;OptAsym&quot;:</dt><dd><p>the optimal asymptotic choice.
</p>
</dd>
<dt>&quot;DataVar&quot;:</dt><dd><p>the covariance matrix of the data provided.
</p>
</dd>
<dt>&quot;Id&quot;:</dt><dd><p>the identity matrix.
</p>
</dd>
</dl>

</dd>
<dt>For Cgmm:</dt><dd><p>Continuum Generalized Methods of Moments by Carrasco &amp;
Kotchoni (2017). The parameters <code>algo, alphaReg, subdivisions,
  IntegrationMethod, randomIntegrationLaw, s_min, and s_max</code> must be
specified.
</p>
</dd>
<dt>For GMC:</dt><dd><p>Generalized Method of Cumulants (GMC) by Massing, T.
(2022). The parameters <code>algo, alphaReg, regularization,
   WeightingMatrix, and ncond</code> must be specified.
</p>
</dd>
</dl>

<p><strong>Estim-Class</strong> Class storing all the information about the estimation
method; output of this function.
</p>
<p><strong>Slots of the return class</strong>
</p>

<dl>
<dt>par:</dt><dd><p>Object of class &quot;<code>numeric</code>&quot;; Value of the estimated
parameters.</p>
</dd>
<dt>par0:</dt><dd><p>Object of class &quot;<code>numeric</code>&quot;; Initial guess for the
parameters.</p>
</dd>
<dt>vcov:</dt><dd><p>Object of class &quot;<code>matrix</code>&quot; representing the covariance
matrix.</p>
</dd>
<dt>confint:</dt><dd><p>Object of class &quot;<code>matrix</code>&quot; representing the confidence
interval computed at a specific level (attribute of the object).</p>
</dd>
<dt>data:</dt><dd><p>Object of class &quot;<code>numeric</code>&quot; used to compute the
estimation.</p>
</dd>
<dt>sampleSize:</dt><dd><p>Object of class &quot;<code>numeric</code>&quot; ; length of the data.</p>
</dd>
<dt>others:</dt><dd><p>Object of class &quot;<code>list</code>&quot; ; more information about the
estimation method.</p>
</dd>
<dt>duration:</dt><dd><p>Object of class &quot;<code>numeric</code>&quot; ; duration in seconds.</p>
</dd>
<dt>failure:</dt><dd><p>Object of class &quot;<code>numeric</code>&quot; representing the status of
the procedure: 0 failure or 1 success.</p>
</dd>
<dt>method:</dt><dd><p>Object of class &quot;<code>character</code>&quot; description of the
parameter used in the estimation.</p>
</dd>
</dl>

<p><strong>IterationControl</strong> If <code>algo = "IT..."</code> or <code>algo =
"Cue..."</code> the user can control each iteration by setting up the list
IterationControl which contains the following elements:
</p>

<dl>
<dt>NbIter</dt><dd><p>maximum number of iteration. The loop stops when NBIter is
reached; default = 10.</p>
</dd>
<dt>PrintIterlogical</dt><dd><p>if set to TRUE, the value of the current parameter
estimation is printed to the screen at each iteration; default = TRUE.</p>
</dd>
<dt>RelativeErrMax</dt><dd><p>the loop stops if the relative error between two
consecutive estimation steps is smaller than RelativeErrMax;
default = 1e-3.</p>
</dd>
</dl>

<p>Since this package is structurally based on the <strong>&quot;StableEstim&quot;
package by Tarak Kharrat and Georgi N. Boshnakov</strong>, more detailed
documentation can be found in their documentation.
</p>


<h3>Value</h3>

<p>Object of a estim-class. See details for more information.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>
<p>Kim, Y. s., Rachev, S. T., Bianchi, M. L. &amp; Fabozzi, F. J. (2008), 'Financial
market models with levy processes and time-varying volatility'
<a href="https://doi.org/10.1016/j.jbankfin.2007.11.004">doi:10.1016/j.jbankfin.2007.11.004</a>
</p>
<p>Hansen, L. P. (1982), 'Large sample properties of generalized method of
moments estimators' <a href="https://doi.org/10.2307/1912775">doi:10.2307/1912775</a>
</p>
<p>Hansen, L. P.; Heaton, J. &amp; Yaron, A. (1996), 'Finite-Sample Properties of
Some Alternative GMM Estimators' <a href="https://doi.org/10.1080/07350015.1996.10524656">doi:10.1080/07350015.1996.10524656</a>
</p>
<p>Carrasco, M. &amp; Kotchoni, R. (2017), 'Efficient estimation using the
characteristic function' <a href="https://doi.org/10.1017/S0266466616000025">doi:10.1017/S0266466616000025</a>
</p>
<p>Kuechler, U. &amp; Tappe, S. (2013), 'Tempered stable distribution and processes'
<a href="https://doi.org/10.1016/j.spa.2013.06.012">doi:10.1016/j.spa.2013.06.012</a>
</p>
<p>Feuerverger, A. &amp; McDunnough, P. (1981), 'On the efficiency of empirical
characteristic function procedures'
<a href="https://doi.org/10.1111/j.2517-6161.1981.tb01143.x">doi:10.1111/j.2517-6161.1981.tb01143.x</a>
</p>


<h3>See Also</h3>

<p><a href="https://github.com/GeoBosh/StableEstim/blob/master/R/Simulation.R">https://github.com/GeoBosh/StableEstim/blob/master/R/Simulation.R</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
TemperedEstim(TemperedType = "CTS", EstimMethod = "ML",
               data = rCTS(2,1.5,1,1,1,1,0),
               theta0 = c(1.5,1,1,1,1,0) - 0.1);
TemperedEstim("TSS", "GMM", rTSS(20,0.5,1,1), algo = "2SGMM",
              alphaReg = 0.01, regularization = "cut-off",
              WeightingMatrix = "OptAsym", t_scheme = "free",
              t_free = seq(0.1,2,length.out = 12));
TemperedEstim("NTS", "Cgmm", rNTS(20,0.5,1,1,1,0), algo = "2SCgmm",
              alphaReg = 0.01, subdivisions = 50,
              IntegrationMethod = "Uniform", randomIntegrationLaw = "unif",
              s_min = 0, s_max= 1);
TemperedEstim("TSS", "GMC", rTSS(20, 0.5, 1, 1), algo = "2SGMC",
              alphaReg = 0.01, WeightingMatrix = "OptAsym",
              regularization = "cut-off", ncond = 8, theta0 = c(0.5,1,1));

</code></pre>

<hr>
<h2 id='TemperedEstim_Simulation'>Monte Carlo Simulation</h2><span id='topic+TemperedEstim_Simulation'></span>

<h3>Description</h3>

<p>Runs Monte Carlo simulation for a selected estimation method. The function
can save results in a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TemperedEstim_Simulation(
  ParameterMatrix,
  SampleSizes = c(200, 1600),
  MCparam = 100,
  TemperedType = c("CTS", "TSS", "NTS", "MTS", "GTS", "KRTS", "RDTS"),
  Estimfct = c("ML", "GMM", "Cgmm", "GMC"),
  HandleError = TRUE,
  saveOutput = FALSE,
  SeedOptions = NULL,
  eps = 1e-06,
  algo = NULL,
  regularization = NULL,
  WeightingMatrix = NULL,
  t_scheme = NULL,
  alphaReg = NULL,
  t_free = NULL,
  nb_t = NULL,
  subdivisions = NULL,
  IntegrationMethod = NULL,
  randomIntegrationLaw = NULL,
  s_min = NULL,
  s_max = NULL,
  ncond = NULL,
  IterationControl = NULL,
  methodR = "TM",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TemperedEstim_Simulation_+3A_parametermatrix">ParameterMatrix</code></td>
<td>
<p>The matrix is to be composed of vectors, row by row.
Each vector must fit the pattern of theta of the <code>TemperedType</code>.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_samplesizes">SampleSizes</code></td>
<td>
<p>Sample sizes to be used to simulate the data. By default,
we use 200 (small sample size) and 1600 (large sample size);
vector of integer.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_mcparam">MCparam</code></td>
<td>
<p>Number of Monte Carlo simulation for each couple of parameter,
default=100; integer</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_temperedtype">TemperedType</code></td>
<td>
<p>A String. Either &quot;CTS&quot;, &quot;TSS&quot;, &quot;NTS&quot;, &quot;MTS&quot;, &quot;GTS&quot;,
&quot;KRTS&quot;, &quot;RDTS&quot;.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_estimfct">Estimfct</code></td>
<td>
<p>The estimation function to be used. A String.
Either &quot;ML&quot;, &quot;GMM&quot;, &quot;Cgmm&quot;, or &quot;GMC&quot;.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_handleerror">HandleError</code></td>
<td>
<p>Logical flag: if set to TRUE, the simulation doesn't stop
when an error in the estimation function is encountered. A vector of
(size 4) NA is saved and the the simulation carries on. See details.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_saveoutput">saveOutput</code></td>
<td>
<p>Logical flag: if set to TRUE, a csv file (for each couple
of parameter) with the the estimation
information is saved in the current directory. See details.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_seedoptions">SeedOptions</code></td>
<td>
<p>List to control the seed generation. See details.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_eps">eps</code></td>
<td>
<p>Numerical error tolerance. <code>1e-06</code> by default.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_algo">algo</code></td>
<td>
<p>algorithm: For GMM: <code>"2SGMM"</code> is the two step GMM proposed
by Hansen (1982). <code>"CueGMM"</code> and <code>"ITGMM"</code> are respectively the
continuous updated and the iterative GMM proposed by Hansen, Eaton et Yaron
(1996) and adapted to the continuum case. For GMC: <code>"2SGMC", "CueGMC"</code>.
For Cgmm: <code>"2SCgmm", "CueCgmm", ...</code>.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_regularization">regularization</code></td>
<td>
<p>regularization scheme to be used for moment methods,
one of <code>"Tikhonov"</code> (Tikhonov), <code>"LF"</code> (Landweber-Fridmann) and
<code>"cut-off"</code> (spectral cut-off).</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_weightingmatrix">WeightingMatrix</code></td>
<td>
<p>type of weighting matrix used to compute the
objective function for the GMM and GMC methods, one of <code>"OptAsym"</code> (the
optimal asymptotic), <code>"DataVar"</code> (the data driven, only for GMM) and
<code>"Id"</code> (the identity matrix).</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_t_scheme">t_scheme</code></td>
<td>
<p>scheme used to select the points for the GMM method where the
moment conditions are evaluated, one of <code>"equally"</code> (equally placed),
<code>"NonOptAr"</code> (non optimal arithmetic placement), <code>"uniformOpt"</code>
(uniform optimal placement), <code>"ArithOpt"</code> (arithmetic optimal placement)
, <code>"Var Opt"</code> (optimal variance placement) and <code>"free"</code> (users need
to pass their own set of points in ...).</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_alphareg">alphaReg</code></td>
<td>
<p>value of the regularisation parameter; numeric. Example Value
could be ==0.01.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_t_free">t_free</code></td>
<td>
<p>sequence, if <code>t_scheme=="free"</code>.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_nb_t">nb_t</code></td>
<td>
<p>integer, if you set <code>t_scheme &lt;- "equally"</code>. nb_t could be
== 20 for example.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_subdivisions">subdivisions</code></td>
<td>
<p>Number of subdivisions used to compute the different
integrals involved in the computation of the objective function for the Cgmm
method (to minimise); numeric.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_integrationmethod">IntegrationMethod</code></td>
<td>
<p>Numerical integration method to be used to
approximate the (vectorial) integrals for the Cgmm method. Users can choose
between &quot;Uniform&quot; discretization or the &quot;Simpson&quot;'s rule (the 3-point
Newton-Cotes quadrature rule).</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_randomintegrationlaw">randomIntegrationLaw</code></td>
<td>
<p>Probability measure associated to the Hilbert
space spanned by the moment conditions for the Cgmm method.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_s_min">s_min</code>, <code id="TemperedEstim_Simulation_+3A_s_max">s_max</code></td>
<td>
<p>Lower and Upper bounds of the interval where the moment
conditions are considered for the Cgmm method; numeric.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_ncond">ncond</code></td>
<td>
<p>Integer. Number of moment conditions (until order <code>ncond</code>)
for the GMC method. Must not be less than 3 for TSS, 6 for CTS, 5 for NTS.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_iterationcontrol">IterationControl</code></td>
<td>
<p>only used if algo = &quot;IT...&quot; or algo = &quot;Cue...&quot;
to control the iterations. See Details.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_methodr">methodR</code></td>
<td>
<p>A string. Method generates random variates of TS distribution.
&quot;TM&quot; by default. Switches automatically if the method is not applicable in
this way.</p>
</td></tr>
<tr><td><code id="TemperedEstim_Simulation_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the estimation function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>TemperedTyp</strong> With the parameter 'TemperedTyp' you can choose the
tempered stable distribution you want to use. Here is a list of distribution
you can choose from:
</p>

<dl>
<dt>TSS</dt><dd><p>Tempered stabel subordinator: See <code><a href="#topic+charTSS">charTSS()</a></code> for details.</p>
</dd>
<dt>CTS</dt><dd><p>Classical tempered stable distribution: See <code><a href="#topic+charCTS">charCTS()</a></code> for
details.</p>
</dd>
<dt>GTS</dt><dd><p>Generalized classical tempered stable distribution: See
<code><a href="#topic+charGTS">charGTS()</a></code> for details.</p>
</dd>
<dt>NTS</dt><dd><p>Normal tempered stable distribution: See <code><a href="#topic+charNTS">charNTS()</a></code> for
details.</p>
</dd>
<dt>MTS</dt><dd><p>Modified tempered stable distribution: See <code><a href="#topic+charMTS">charMTS()</a></code> for
details.</p>
</dd>
<dt>RDTS</dt><dd><p>Rapid decreasing tempered stable distribution: See <code><a href="#topic+charRDTS">charRDTS()</a></code>
for details.</p>
</dd>
<dt>KRTS</dt><dd><p>Kim-Rachev tempered stable distribution: See <code><a href="#topic+charKRTS">charKRTS()</a></code> for
details.</p>
</dd>
</dl>

<p><strong>Error Handling</strong> It is advisable to set it to TRUE when user is
planning to launch long simulations as it will prevent the procedure to stop
if an error occurs for one sample data. The estimation function will produce
a vector of NA as estimated parameters related to this (error generating)
sample data and move on to the next Monte Carlo step.
</p>
<p><strong>Output file</strong> Setting <code>saveOutput</code> to <code>TRUE</code> will have the
side effect of saving a csv file in the working directory. This file will
have <code>MCparam*length(SampleSizes)</code> lines and its columns will be:
</p>

<dl>
<dt>alphaT, ...:</dt><dd><p>the true value of the parameters.</p>
</dd>
<dt>data size:</dt><dd><p>the sample size used to generate the simulated data.</p>
</dd>
<dt>seed:</dt><dd><p>the seed value used to generate the simulated data.</p>
</dd>
<dt>alphaE, ...:</dt><dd><p>the estimate of the parameters.</p>
</dd>
<dt>failure:</dt><dd><p>binary: 0 for success, 1 for failure.</p>
</dd>
<dt>time:</dt><dd><p>estimation running time in seconds.</p>
</dd>
</dl>

<p>The file name is informative to let the user identify the value of the true
parameters, the MC parameters as well as the options selected for the
estimation method. The csv file is updated after each MC estimation which is
useful when the simulation stops before it finishes.
</p>
<p><strong>SeedOptions</strong> If users does not want to control the seed generation,
they could ignore this argument (default value NULL). This argument can be
more useful when they wants to cut the simulation (even for one parameter
value) into pieces. In that case, they can control which part of the seed
vector they want to use.
</p>

<dl>
<dt>MCtot:</dt><dd><p>total values of MC simulations in the entire process.</p>
</dd>
<dt>seedStart:</dt><dd><p>starting index in the seed vector. The vector extracted
will be of size MCparam.</p>
</dd>
</dl>

<p><strong>Estimfct</strong> Additional parameters are needed for different estimation
functions. These are listed below for each function. The list of additional
parameters starts after the parameter <code>eps</code> in the parameter list.
</p>

<dl>
<dt>For ML:</dt><dd><p> See usage of Maximum likelihood estimation in Kim et al.
(2008).No additional parameters are needed.</p>
</dd>
<dt>For GMM:</dt><dd><p>Generalized Method of Moments by Feuerverger (1981).
The parameters <code>algo, alphaReg, regularization, WeightingMatrix, and
  t_scheme</code> must be specified.
</p>
<p>Parameter <code>t_scheme</code>: One of the most important features of this
method is that it allows the user to choose how to place the points where
the moment conditions are evaluated. One can choose among 6 different
options. Depending on the option, further parameters have to be passed.
</p>

<dl>
<dt>&quot;equally&quot;:</dt><dd><p>equally placed points in <code>min_t,max_t</code>. When
provided, user's <code>min_t</code> and <code>max_t</code> will be used (when
<code>Coinstrained == FALSE</code>).
</p>
</dd>
<dt>&quot;NonOptAr&quot;:</dt><dd><p>non optimal arithmetic placement.
</p>
</dd>
<dt>&quot;uniformOpt&quot;:</dt><dd><p>uniform optimal placement.
</p>
</dd>
<dt>&quot;ArithOpt&quot;:</dt><dd><p>arithmetic optimal placement.
</p>
</dd>
<dt>&quot;Var Opt&quot;:</dt><dd><p>optimal variance placement as explained above.
</p>
</dd>
<dt>&quot;free&quot;:</dt><dd><p>user needs to pass own set of points in <code>t_free</code>.
</p>
</dd>
</dl>

<p>Parameter <code>WeightingMatrix</code>: One can choose among 3 different options:
</p>

<dl>
<dt>&quot;OptAsym&quot;:</dt><dd><p>the optimal asymptotic choice.
</p>
</dd>
<dt>&quot;DataVar&quot;:</dt><dd><p>the covariance matrix of the data provided.
</p>
</dd>
<dt>&quot;Id&quot;:</dt><dd><p>the identity matrix.
</p>
</dd>
</dl>

</dd>
<dt>For Cgmm:</dt><dd><p>Continuum Generalized Methods of Moments by Carrasco &amp;
Kotchoni (2017). The parameters <code>algo, alphaReg, subdivisions,
  IntegrationMethod, randomIntegrationLaw, s_min, and s_max</code> must be
specified.
</p>
</dd>
<dt>For GMC:</dt><dd><p>Generalized Method of Cumulants (GMC) by Massing, T.
(2022). The parameters <code>algo, alphaReg, regularization,
   WeightingMatrix, and ncond</code> must be specified.
</p>
</dd>
</dl>

<p><strong>IterationControl</strong> If <code>algo = "IT..."</code> or <code>algo =
"Cue..."</code> the user can control each iteration by setting up the list
IterationControl which contains the following elements:
</p>

<dl>
<dt>NbIter</dt><dd><p>maximum number of iteration. The loop stops when NBIter is
reached; default = 10.</p>
</dd>
<dt>PrintIterlogical</dt><dd><p>if set to TRUE, the value of the current parameter
estimation is printed to the screen at each iteration; default = TRUE.</p>
</dd>
<dt>RelativeErrMax</dt><dd><p>the loop stops if the relative error between two
consecutive estimation steps is smaller than RelativeErrMax;
default = 1e-3.</p>
</dd>
</dl>

<p><strong>methodR</strong> Random numbers must be generated for each MC study. For
each distribution, different methods are available for this (partly also
depending on alpha). For more information, the documentation of the
respective <code>r...()</code> distribution can be called up. By default, the fastest
method is selected. Since the deviation error can amplify to the edges of
alpha depending on the method, it is recommended to check the generated
random numbers once for each distribution using the density function before
starting the simulation.
</p>
<p><strong>Parallelization</strong>  Parallelization of the function is possible with
using <code><a href="#topic+parallelizeMCsimulation">parallelizeMCsimulation()</a></code>. If someone wants to parallelize the
function manually, the parameter <code>MCparam</code> must be set to <code>1</code> and
the parameter <code>SeedOption</code> must be changed for each iteration.
</p>
<p>Since this package is structurally based on the <strong>&quot;StableEstim&quot;
package by Tarak Kharrat and Georgi N. Boshnakov</strong>, more detailed
documentation can be found in their documentation.
</p>


<h3>Value</h3>

<p>If <code>saveOutput == FALSE</code>, the return object is a list of 2.
Results of the simulation are listed in <code>$outputMat</code>. If <code>
saveOutput == TRUE</code>, only a csv file is saved and nothing is returned.
</p>


<h3>References</h3>

<p>Massing, T. (2023), 'Parametric Estimation of Tempered Stable Laws'
</p>
<p>Kim, Y. s.; Rachev, S. T.; Bianchi, M. L. &amp; Fabozzi, F. J. (2008), 'Financial
market models with lévy processes and time-varying volatility'
<a href="https://doi.org/10.1016/j.jbankfin.2007.11.004">doi:10.1016/j.jbankfin.2007.11.004</a>
</p>
<p>Hansen, L. P. (1982), 'Large sample properties of generalized method of
moments estimators' <a href="https://doi.org/10.2307/1912775">doi:10.2307/1912775</a>
</p>
<p>Hansen, L. P.; Heaton, J. &amp; Yaron, A. (1996), 'Finite-Sample Properties of
Some Alternative GMM Estimators' <a href="https://doi.org/10.1080/07350015.1996.10524656">doi:10.1080/07350015.1996.10524656</a>
</p>
<p>Feuerverger, A. &amp; McDunnough, P. (1981), 'On the efficiency of empirical
characteristic function procedures'
<a href="https://doi.org/10.1111/j.2517-6161.1981.tb01143.x">doi:10.1111/j.2517-6161.1981.tb01143.x</a>
</p>
<p>Carrasco, M. &amp; Kotchoni, R. (2017), 'Efficient estimation using the
characteristic function' <a href="https://doi.org/10.1017/S0266466616000025">doi:10.1017/S0266466616000025</a>;
</p>
<p>Kuechler, U. &amp; Tappe, S. (2013), 'Tempered stable distribution and processes'
<a href="https://doi.org/10.1016/j.spa.2013.06.012">doi:10.1016/j.spa.2013.06.012</a>
</p>


<h3>See Also</h3>

<p><a href="https://github.com/GeoBosh/StableEstim/blob/master/R/Simulation.R">https://github.com/GeoBosh/StableEstim/blob/master/R/Simulation.R</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
TemperedEstim_Simulation(ParameterMatrix = rbind(c(1.5,1,1,1,1,0),
                                                 c(0.5,1,1,1,1,0)),
                         SampleSizes = c(4), MCparam = 4,
                         TemperedType = "CTS", Estimfct = "ML",
                         saveOutput = FALSE)

TemperedEstim_Simulation(ParameterMatrix = rbind(c(1.5,1,1,1,1,0)),
                         SampleSizes = c(4), MCparam = 4,
                         TemperedType = "CTS", Estimfct = "GMM",
                         saveOutput = FALSE, algo = "2SGMM",
                         regularization = "cut-off",
                         WeightingMatrix = "OptAsym", t_scheme = "free",
                         alphaReg = 0.01,
                         t_free = seq(0.1,2,length.out=12))

TemperedEstim_Simulation(ParameterMatrix = rbind(c(1.45,0.55,1,1,1,0)),
                         SampleSizes = c(4), MCparam = 4,
                         TemperedType = "CTS", Estimfct = "Cgmm",
                         saveOutput = FALSE, algo = "2SCgmm",
                         alphaReg = 0.01, subdivisions = 50,
                         IntegrationMethod = "Uniform",
                         randomIntegrationLaw = "unif",
                         s_min = 0, s_max= 1)

TemperedEstim_Simulation(ParameterMatrix = rbind(c(1.45,0.55,1,1,1,0)),
                         SampleSizes = c(4), MCparam = 4,
                         TemperedType = "CTS", Estimfct = "GMC",
                         saveOutput = FALSE, algo = "2SGMC",
                         alphaReg = 0.01, WeightingMatrix = "OptAsym",
                         regularization = "cut-off", ncond = 8)


</code></pre>

<hr>
<h2 id='TempStable'>TempStable: A collection of methods to estimate parameters of different
tempered stable distributions.</h2><span id='topic+TempStable'></span><span id='topic+TempStable-package'></span>

<h3>Description</h3>

<p>A collection of methods to estimate parameters of different tempered stable
distributions. Currently, there are three different tempered stable
distributions to choose from: Tempered stable subordinator distribution,
classical tempered stable distribution, normal tempered stable distribution.
The package also provides functions to compute characteristic functions and
tools to run Monte Carlo simulations.
</p>


<h3>Details</h3>

<p>The package was developed by Till Massing and Cedric Juessen and is
structurally based on the &quot;StableEstim&quot; package by Tarak Kharrat and Georgi
N. Boshnakov.
</p>


<h3>Brief description of functions</h3>

<p><strong>TemperedEstim()</strong> <code><a href="#topic+TemperedEstim">TemperedEstim()</a></code>computes all the information about the
estimator. It allows the user to choose the preferred method and several
related options.
</p>
<p>Characteristic function, density function, probability function and other
functions for every tempered stable distribution mentioned above.
E.g. <code><a href="#topic+charTSS">charTSS()</a></code>, <code><a href="#topic+dCTS">dCTS()</a></code>, ...
</p>
<p><strong>Monte Carlo simulation:</strong> a tool to run a Monte Carlo simulation
<code><a href="#topic+TemperedEstim_Simulation">TemperedEstim_Simulation()</a></code> is provided and can save output files or
produce statistical summary.To parallelize this function, you can use
<code><a href="#topic+parallelizeMCsimulation">parallelizeMCsimulation()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## basic example code
# Such a simulation can take a very long time. Therefore, it can make sense
# to parallelize after Monte Carlo runs. Parallelization of the simulation is
# now possible with [parallelizeMCsimulation()].

# For testing purposes, the amount of runs and parameters is greatly reduced.
# Therefore, the result is not meaningful. To start a meaningful simulation,
# the SampleSize could be, for example, 1000 and MCParam also 1000.

thetaT &lt;- c(1.5,1,1,1,1,0)
res_CTS_ML_size4 &lt;- TemperedEstim_Simulation(ParameterMatrix =
                                                rbind(thetaT),
                                              SampleSizes = c(4),
                                              MCparam = 4,
                                              TemperedType = "CTS",
                                              Estimfct = "ML",
                                              saveOutput = FALSE)

colMeans(sweep(res_CTS_ML_size4$outputMat[,9:14],2,thetaT), na.rm = TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
