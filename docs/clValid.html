<!DOCTYPE html><html><head><title>Help for package clValid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clValid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annotationListToMatrix'><p> Change annotation list to matrix</p></a></li>
<li><a href='#BHI'><p>Biological Homogeneity Index</p></a></li>
<li><a href='#BSI'><p>Biological Stability Index</p></a></li>
<li><a href='#clValid'><p>Validate Cluster Results</p></a></li>
<li><a href='#clValid-class'><p>Class &quot;clValid&quot;</p></a></li>
<li><a href='#clValid-internal'><p>Internal clValid functions</p></a></li>
<li><a href='#connectivity'><p>Connectivity Measure</p></a></li>
<li><a href='#dunn'><p>Dunn Index</p></a></li>
<li><a href='#getRanksWeights'><p>Extract ranks and weights from clValid object</p></a></li>
<li><a href='#mouse'><p>Mouse Mesenchymal Cells</p></a></li>
<li><a href='#plot.sota'><p>Plot Function for a SOTA Object</p></a></li>
<li><a href='#print.sota'><p>Print Function for a SOTA Object</p></a></li>
<li><a href='#readAnnotationFile'>
<p>Read in biological annotation files from external file</p></a></li>
<li><a href='#sota'><p>Self-organizing Tree Algorithm (SOTA)</p></a></li>
<li><a href='#stability'><p>Stability Measures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Validation of Clustering Results</td>
</tr>
<tr>
<td>Author:</td>
<td>Guy Brock &lt;guy.brock@louisville.edu&gt;, Vasyl Pihur &lt;vpihur@gmail.com&gt;, 
	Susmita Datta &lt;susmita.datta@louisville.edu&gt;, and
  	Somnath Datta &lt;somnath.datta@louisville.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vasyl Pihur &lt;vpihur@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), cluster</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, class</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Biobase, annotate, GO.db, moe430a.db, RankAggreg, kohonen,
mclust</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical and biological validation of clustering results. This package implements Dunn Index, Silhouette, Connectivity, Stability, BHI and BSI. Further information can be found in Brock, G et al. (2008) &lt;<a href="https://doi.org/10.18637%2Fjss.v025.i04">doi:10.18637/jss.v025.i04</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>clValid-Classes.R clValid-Methods.R clValid-internal.R
clValid-functions.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-14 19:49:26 UTC; vpihur</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-14 20:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='annotationListToMatrix'> Change annotation list to matrix</h2><span id='topic+annotationListToMatrix'></span>

<h3>Description</h3>

<p>Change biological functional annotation from list to TRUE / FALSE matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotationListToMatrix(annotation, genenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotationListToMatrix_+3A_annotation">annotation</code></td>
<td>
<p> functional annotation of genes, as a list</p>
</td></tr>
<tr><td><code id="annotationListToMatrix_+3A_genenames">genenames</code></td>
<td>
<p> vector of genenames</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts biological annotation from &ldquo;list&rdquo; to &ldquo;matrix&rdquo; format.  In
&ldquo;list&rdquo; format, each item in the list is a vector giving genes
belonging to a particular biological class.  In &ldquo;matrix&rdquo; format,
each column is a logical vector indicating which genes belong to the
biological class.  Both <code><a href="#topic+BHI">BHI</a></code> and
<code><a href="#topic+BSI">BSI</a></code> use the TRUE / FALSE matrix format for inputting
predetermined biological functional classes.
</p>


<h3>Value</h3>

<p>A logical matrix, where each element indicates whether the gene in row
i belongs to the biological functional class of column j
</p>


<h3>Note</h3>

<p>Special thanks to Rainer Machne, who initially suggested this change.</p>


<h3>Author(s)</h3>

<p>Guy Brock</p>


<h3>See Also</h3>

<p><code><a href="#topic+BHI">BHI</a></code>, <code><a href="#topic+BSI">BSI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mouse)
express &lt;- mouse[1:25,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID[1:25]
fc &lt;- tapply(rownames(express),mouse$FC[1:25], c)
fc &lt;- fc[-match( c("EST","Unknown"), names(fc))]
fc &lt;- annotationListToMatrix(fc, rownames(express))

## see package vignette for example use when reading from Excel file

</code></pre>

<hr>
<h2 id='BHI'>Biological Homogeneity Index</h2><span id='topic+BHI'></span>

<h3>Description</h3>

<p>Calculates the biological homogeneity index (BHI) for a given
statistical clustering partition and biological annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BHI(statClust, annotation, names = NULL, category = "all", dropEvidence=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BHI_+3A_statclust">statClust</code></td>
<td>
<p>An integer vector indicating the statistical cluster partitioning</p>
</td></tr>
<tr><td><code id="BHI_+3A_annotation">annotation</code></td>
<td>
<p>Either a character string naming the Bioconductor
annotation package for mapping genes to GO categories, or a
matrix where each column is a logical vector indicating which genes
belong to the biological functional class.  See details below.</p>
</td></tr>
<tr><td><code id="BHI_+3A_names">names</code></td>
<td>
<p>A vector of labels to associate with the 'genes', to be
used in conjunction with the Bioconductor annotation package.  Not
needed if <code>annotation</code> is a list providing the functional classes. </p>
</td></tr>
<tr><td><code id="BHI_+3A_category">category</code></td>
<td>
<p>Indicates the GO 
categories to use for biological validation.  Can be one of &quot;BP&quot;,
&quot;MF&quot;, &quot;CC&quot;, or &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="BHI_+3A_dropevidence">dropEvidence</code></td>
<td>
<p>Which GO evidence codes to omit.  Either NULL or a
character vector, see 'Details' below.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The BHI measures how homogeneous the clusters are biologically.  The
measure checks whether genes placed
in the same statistical cluster also belong to the same functional
classes.  The BHI is in the range [0,1], with
larger values corresponding to more biologically homogeneous clusters.
For details see the package vignette.
</p>
<p>When inputting the biological annotation and functional classes
directly, the <code>BSI</code> function expects the input in &ldquo;matrix&rdquo; format,
where each column is a logical vector indicating which genes belong to the
biological class.  For details on how to input the biological
annotation from an Excel file see <code><a href="#topic+readAnnotationFile">readAnnotationFile</a></code> and
for converting from list to matrix format see
<code><a href="#topic+annotationListToMatrix">annotationListToMatrix</a></code>.
</p>
<p>The <code>dropEvidence</code> argument indicates which GO evidence codes to
omit.  For example, &quot;IEA&quot; is a relatively weak association based only
on electronic information, and users may wish to omit this evidence
when determining the functional annotation classes.  
</p>


<h3>Value</h3>

<p>Returns the BHI measure as a numeric value.
</p>


<h3>Note</h3>

<p>The main function for cluster validation is <code><a href="#topic+clValid">clValid</a></code>, and
users should call this function directly if possible.
</p>


<h3>Author(s)</h3>

<p>Guy Brock, Vasyl Pihur, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Datta, S. and Datta, S. (2006).
Methods for evaluating clustering algorithms for gene expression data
using a reference set of functional classes.
BMC Bioinformatics 7:397.
</p>


<h3>See Also</h3>

<p>For a description of the function 'clValid' see <code><a href="#topic+clValid">clValid</a></code>.
</p>
<p>For a description of the class 'clValid' and all available methods see
<code><a href="#topic+clValidObj">clValidObj</a></code> or <code><a href="#topic+clValid-class">clValid-class</a></code>.
</p>
<p>For additional help on the other validation measures see
<code><a href="#topic+connectivity">connectivity</a></code>,   <code><a href="#topic+dunn">dunn</a></code>,
<code><a href="#topic+stability">stability</a></code>, and
<code><a href="#topic+BSI">BSI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouse)
express &lt;- mouse[1:25,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID[1:25]
## hierarchical clustering
Dist &lt;- dist(express,method="euclidean")
clusterObj &lt;- hclust(Dist, method="average")
nc &lt;- 4 ## number of clusters      
cluster &lt;- cutree(clusterObj,nc)

## first way - functional classes predetermined
fc &lt;- tapply(rownames(express),mouse$FC[1:25], c)
fc &lt;- fc[-match( c("EST","Unknown"), names(fc))]
fc &lt;- annotationListToMatrix(fc, rownames(express))
BHI(cluster, fc)

## second way - using Bioconductor
if(require("Biobase") &amp;&amp; require("annotate") &amp;&amp; require("GO.db") &amp;&amp;
require("moe430a.db")) {
  BHI(cluster, annotation="moe430a.db", names=rownames(express), category="all")
}

</code></pre>

<hr>
<h2 id='BSI'>Biological Stability Index</h2><span id='topic+BSI'></span>

<h3>Description</h3>

<p>Calculates the biological stability index (BSI) for a given
statistical clustering partition and biological annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BSI(statClust, statClustDel, annotation, names = NULL, category = "all",
goTermFreq = 0.05, dropEvidence=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BSI_+3A_statclust">statClust</code></td>
<td>
<p>An integer vector indicating the statistical cluster partitioning</p>
</td></tr>  
<tr><td><code id="BSI_+3A_statclustdel">statClustDel</code></td>
<td>
<p>An integer vector indicating the statistical cluster
partitioning based on one column removed</p>
</td></tr>
<tr><td><code id="BSI_+3A_annotation">annotation</code></td>
<td>
<p>Either a character string naming the Bioconductor
annotation package for mapping genes to GO categories, or a
matrix where each column is a logical vector indicating which genes
belong to the biological functional class.  See details below.</p>
</td></tr>
<tr><td><code id="BSI_+3A_names">names</code></td>
<td>
<p>An optional vector of names for the observations</p>
</td></tr>
<tr><td><code id="BSI_+3A_category">category</code></td>
<td>
<p>Indicates the GO 
categories to use for biological validation.  Can be one of &quot;BP&quot;,
&quot;MF&quot;, &quot;CC&quot;, or &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="BSI_+3A_gotermfreq">goTermFreq</code></td>
<td>
<p>What threshold frequency of GO terms to use for
functional annotation.</p>
</td></tr>
<tr><td><code id="BSI_+3A_dropevidence">dropEvidence</code></td>
<td>
<p>Which GO evidence codes to omit.  Either NULL or a
character vector, see 'Details' below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BSI  inspects the consistency of clustering for genes with
similar biological functionality.  Each sample is removed, 
and the cluster membership for genes with similar functional annotation
is compared with the cluster membership using all available samples.
The BSI is in the range [0,1], with larger values corresponding to more stable
clusters of the functionally annotated genes.
For details see the package vignette.
</p>
<p>The <code>dropEvidence</code> argument indicates which GO evidence codes to
omit.  For example, &quot;IEA&quot; is a relatively weak association based only
on electronic information, and users may wish to omit this evidence
when determining the functional annotation classes.
</p>
<p>When inputting the biological annotation and functional classes
directly, the <code>BSI</code> function expects the input in &ldquo;matrix&rdquo; format,
where each column is a logical vector indicating which genes belong to the
biological class.  For details on how to input the biological
annotation from an Excel file see <code><a href="#topic+readAnnotationFile">readAnnotationFile</a></code> and
for converting from list to matrix format see
<code><a href="#topic+annotationListToMatrix">annotationListToMatrix</a></code>.
</p>
<p>NOTE: The <code>BSI</code> function only calculates these measures for
one particular column removed.  To get the
overall scores, the user must average the measures
corresponding to each removed column.
</p>


<h3>Value</h3>

<p>Returns the BSI value corresponding to the particular column that was
removed.  
</p>


<h3>Note</h3>

<p>The main function for cluster validation is <code><a href="#topic+clValid">clValid</a></code>, and
users should call this function directly if possible.
</p>
<p>To get the overall BSI value, the BSI values
corresponding to each removed column should be averaged (see the
examples below).
</p>


<h3>Author(s)</h3>

<p>Guy Brock, Vasyl Pihur, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Datta, S. and Datta, S. (2006).
Methods for evaluating clustering algorithms for gene expression data
using a reference set of functional classes.
BMC Bioinformatics 7:397.
</p>


<h3>See Also</h3>

<p>For a description of the function 'clValid' see <code><a href="#topic+clValid">clValid</a></code>.
</p>
<p>For a description of the class 'clValid' and all available methods see
<code><a href="#topic+clValidObj">clValidObj</a></code> or <code><a href="#topic+clValid-class">clValid-class</a></code>.
</p>
<p>For additional help on the other validation measures see
<code><a href="#topic+connectivity">connectivity</a></code>,   <code><a href="#topic+dunn">dunn</a></code>,
<code><a href="#topic+stability">stability</a></code>, and
<code><a href="#topic+BHI">BHI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(mouse)
express &lt;- mouse[1:25,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID[1:25]
## hierarchical clustering
Dist &lt;- dist(express,method="euclidean")
clusterObj &lt;- hclust(Dist, method="average")
nc &lt;- 4 ## number of clusters      
cluster &lt;- cutree(clusterObj,nc)

## first way - functional classes predetermined
fc &lt;- tapply(rownames(express),mouse$FC[1:25], c)
fc &lt;- fc[-match( c("EST","Unknown"), names(fc))]
fc &lt;- annotationListToMatrix(fc, rownames(express))
bsi &lt;- numeric(ncol(express))
## Need loop over all removed samples
for (del in 1:ncol(express)) {
  matDel &lt;- express[,-del]               
  DistDel &lt;- dist(matDel,method="euclidean")
  clusterObjDel &lt;- hclust(DistDel, method="average")
  clusterDel &lt;- cutree(clusterObjDel,nc)
  bsi[del] &lt;- BSI(cluster, clusterDel, fc)
}
mean(bsi)

## second way - using Bioconductor
if(require("Biobase") &amp;&amp; require("annotate") &amp;&amp; require("GO.db") &amp;&amp;
   require("moe430a.db")) {
  bsi &lt;- numeric(ncol(express))
  for (del in 1:ncol(express)) {
    matDel &lt;- express[,-del]               
    DistDel &lt;- dist(matDel,method="euclidean")
    clusterObjDel &lt;- hclust(DistDel, method="average")
    clusterDel &lt;- cutree(clusterObjDel,nc)
    bsi[del] &lt;- BSI(cluster, clusterDel, annotation="moe430a.db",
                    names=rownames(express), category="all")
  }
  mean(bsi)
}
</code></pre>

<hr>
<h2 id='clValid'>Validate Cluster Results</h2><span id='topic+clValid'></span>

<h3>Description</h3>

<p><code>clValid</code> reports validation measures for clustering
results.  The function returns an object of class
<code>"<a href="#topic+clValid-class">clValid</a>"</code>, which
contains the clustering results in addition to the validation
measures.  The validation measures fall into three general categories:
&quot;internal&quot;, &quot;stability&quot;, and &quot;biological&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clValid(obj, nClust, clMethods = "hierarchical", validation =
"stability", maxitems = 600, metric = "euclidean", method = "average",
neighbSize = 10, annotation = NULL, GOcategory = "all",
goTermFreq=0.05, dropEvidence=NULL, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clValid_+3A_obj">obj</code></td>
<td>
<p>Either a numeric matrix, a data frame, or an ExpressionSet
object.  Data frames must contain all numeric columns.  In all
cases, the rows are the items to be clustered (e.g., genes),
and the columns are the samples.</p>
</td></tr>
<tr><td><code id="clValid_+3A_nclust">nClust</code></td>
<td>
<p>A numeric vector giving the numbers of clusters
to be evaluated.  e.g., 4:6 would evaluate the number of clusters
ranging from 4 to 6.</p>
</td></tr>
<tr><td><code id="clValid_+3A_clmethods">clMethods</code></td>
<td>
<p>A character vector giving the clustering methods.
Available options are &quot;hierarchical&quot;, &quot;kmeans&quot;, &quot;diana&quot;, &quot;fanny&quot;,
&quot;som&quot;, &quot;model&quot;, &quot;sota&quot;, &quot;pam&quot;, &quot;clara&quot;, and &quot;agnes&quot;, with multiple
choices allowed.</p>
</td></tr>
<tr><td><code id="clValid_+3A_validation">validation</code></td>
<td>
<p>A character vector giving the type of
validation measures to use.  Available options are &quot;internal&quot;,
&quot;stability&quot;, and &quot;biological&quot;, with multiple choices allowed.  </p>
</td></tr>
<tr><td><code id="clValid_+3A_maxitems">maxitems</code></td>
<td>
<p>The maximum number of items (rows in matrix) which can be clustered.</p>
</td></tr>
<tr><td><code id="clValid_+3A_metric">metric</code></td>
<td>
<p>The metric used to determine the distance
matrix.  Possible choices are &quot;euclidean&quot;, &quot;correlation&quot;, and &quot;manhattan&quot;.</p>
</td></tr>
<tr><td><code id="clValid_+3A_method">method</code></td>
<td>
<p>For hierarchical clustering (<code>hclust</code> and <code>agnes</code>), the
agglomeration method used.  Available choices are &quot;ward&quot;, &quot;single&quot;,
&quot;complete&quot;, and &quot;average&quot;.</p>
</td></tr>
<tr><td><code id="clValid_+3A_neighbsize">neighbSize</code></td>
<td>
<p>For internal validation, an integer giving the neighborhood size used for the
connectivity measure.</p>
</td></tr>
<tr><td><code id="clValid_+3A_annotation">annotation</code></td>
<td>
<p>For biological validation,
either a character string naming the Bioconductor annotation
package for mapping genes to GO categories, or a list with the names of the functional classes
and the observations belonging to each class.</p>
</td></tr>
<tr><td><code id="clValid_+3A_gocategory">GOcategory</code></td>
<td>
<p>For biological validation, gives which GO
categories to use for biological validation.  Can be one of &quot;BP&quot;,
&quot;MF&quot;, &quot;CC&quot;, or &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="clValid_+3A_gotermfreq">goTermFreq</code></td>
<td>
<p>For the
BSI, what threshold frequency of GO terms to use for functional
annotation.</p>
</td></tr>
<tr><td><code id="clValid_+3A_dropevidence">dropEvidence</code></td>
<td>
<p>Which GO evidence codes to omit.  Either NULL or a
character vector, see 'Details' below.</p>
</td></tr>
<tr><td><code id="clValid_+3A_verbose">verbose</code></td>
<td>
<p>Logical - if TRUE will produce detailed output on the
progress of cluster validation.</p>
</td></tr>
<tr><td><code id="clValid_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the clustering functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates validation measures for a given set of
clustering algorithms and number of clusters.  A variety of clustering
algorithms are available, including hierarchical, self-organizing maps
(SOM), K-means, self-organizing tree algorithm (SOTA), and model-based.
The available validation measures fall into the three general
categories of &quot;internal&quot;, &quot;stability&quot;, and &quot;biological&quot;.  A brief
description of each measure is given below, for further details refer
to the package vignette and the references.
</p>

<dl>
<dt><b>Internal measures:</b></dt><dd><p>The internal
measures include the connectivity, and Silhouette Width, and Dunn
Index.  The connectivity indicates the degree of connectedness of the
clusters, as determined by the k-nearest neighbors.  The
<code>neighbSize</code> argument specifies the number of neighbors to use.
The connectivity has a value between 0 and infinity and should be minimized.
Both the Silhouette Width and the Dunn Index combine measures of
compactness and separation of the clusters.  The Silhouette Width is
the average of each observation's Silhouette value.  The Silhouette
value measures the degree of confidence in a particular clustering
assignment and lies
in the interval [-1,1], with well-clustered observations having values
near 1 and poorly clustered observations having values near -1.  See
the <code><a href="cluster.html#topic+silhouette">silhouette</a></code> function in package <span class="pkg">cluster</span> for
more details.  The
Dunn Index is the ratio between the smallest distance between
observations not in the same cluster to the largest intra-cluster
distance.  It has a value between 0 and infinity and should be maximized.</p>
</dd>
<dt><b>Stability measures:</b></dt><dd><p>The stability measures are a special version of internal measures
which evaluate the stability of a clustering result by comparing it
with the clusters obtained by removing one column at a time.
These measures include the average proportion of non-overlap (APN),
the average distance (AD), the average distance between means (ADM),
and the figure of merit (FOM).  The APN, AD, and ADM are all based on the
cross-classification table of the original clustering with the
clustering based on the removal of one column.  The APN measures the
average proportion of observations not placed in the same cluster under both
cases, while the AD measures the average distance between observations placed
in the same cluster under both cases and the ADM measures the average
distance between cluster centers for observations placed in the same cluster
under both cases.  The FOM measures the average intra-cluster variance
of the deleted column, where the clustering is based on the remaining
(undeleted) columns.  In all cases the average is taken over all the
deleted columns, and all measures should be minimized.  </p>
</dd>
<dt><b>Biological measures:</b></dt><dd><p>There are two biological validation measures, the biological homogeneity index (BHI) and
biological stability index (BSI).  The observations are typically taken to
represent a &lsquo;gene&rsquo; (e.g., ORF, SAGE
tag, affy ID).  The BHI measures the average
proportion of gene pairs that are clustered together which have
matching biological functional classes.
The BSI is similar to the other stability
measures, but 
inspects the consistency of
clustering for genes with similar biological functionality. Each sample is removed one
at a time, and the cluster membership for genes with similar functional annotation is
compared with the cluster membership using all available samples.
</p>
<p>For biological validation, the user has two options.
The first option is to explicity specify the
functional clustering of the genes via either a named list or logical
matrix. In &ldquo;list&rdquo; format, each item in the list is a vector giving genes
belonging to a particular biological class.  In &ldquo;matrix&rdquo; format,
each column is a logical vector indicating which genes belong to the
biological class. <code>clValid</code> will convert the biological
annotation to matrix format internally if initially given in list format.
</p>
<p>The second option is to specify the appropriate
annotation package from Bioconductor (<a href="https://www.bioconductor.org/">https://www.bioconductor.org/</a>)
and GO terms to determine the functional classes of
the genes.  To use the second option requires the <span class="pkg">Biobase</span>,
<span class="pkg">annotate</span>, and <span class="pkg">GO</span> packages from Bioconductor, in addition
to the annotation package for the particular data type.
If the annotation package cannot be loaded, <code>clValid</code> will
attempt to automatically download the package from
<a href="https://www.bioconductor.org/">https://www.bioconductor.org/</a> (using the
&lsquo;<span class="file">biocLite.R</span>&rsquo; installation script).
</p>
<p>The <code>GOcategory</code> options are &quot;MF&quot;, &quot;BP&quot;, &quot;CC&quot;, or &quot;all&quot;,
corresponding to molecular function, biological process, cellular
component, and all of the ontologies.
</p>
<p>The <code>dropEvidence</code> argument indicates which GO evidence codes to
omit.  For example, &quot;IEA&quot; is a relatively weak association based only
on electronic information, and users may wish to omit this evidence
when determining the functional annotation classes.
</p>
</dd></dl>



<h3>Value</h3>

<p><code>clValid</code> returns an object of class
<code>"<a href="#topic+clValid-class">clValid</a>"</code>.  See the help file for the class description.
</p>


<h3>Note</h3>

<p>The only package which is automatically attached is <span class="pkg">cluster</span>.  To
use the clustering methods <code>som</code> and <code>Mclust</code> you will need
to load the packages <span class="pkg">kohonen</span> and <span class="pkg">mclust</span>, respectively.
</p>
<p>Unless the the list of genes corresponding to functional classes is prespecified,
to perform biological clustering validation
will require the <span class="pkg">Biobase</span>, <span class="pkg">annotate</span> and <span class="pkg">GO</span> packages from
Bioconductor, and in addition the annotation package for your
particular data type.  Please see <a href="https://www.bioconductor.org/">https://www.bioconductor.org/</a> for installation instructions.
</p>
<p>Further details of the validation measures and instructions in use can
be found in the package vignette.
</p>


<h3>Author(s)</h3>

<p>Guy Brock, Vasyl Pihur, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Brock, G., Pihur, V., Datta, S. and Datta, S. (2008)
clValid: An R Package for Cluster Validation
Journal of Statistical Software 25(4)
<a href="https://www.jstatsoft.org/v25/i04/">https://www.jstatsoft.org/v25/i04/</a>
</p>
<p>Datta, S. and Datta, S. (2003)
Comparisons and validation of statistical clustering techniques for microarray gene expression data.
Bioinformatics 19(4): 459-466
</p>
<p>Datta, S. and Datta, S. (2006)
Methods for evaluating clustering algorithms for gene expression data
using a reference set of functional classes.
BMC Bioinformatics 7:397
<a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-7-397/">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-7-397/</a>
</p>
<p>Handl, J., Knowles, K., and Kell, D. (2005)
Computational cluster validation in post-genomic data analysis.
Bioinformatics 21(15): 3201-3212
</p>


<h3>See Also</h3>

<p>For a description of the class 'clValid' and all available methods see <code><a href="#topic+clValidObj">clValidObj</a></code>
or <code><a href="#topic+clValid-class">clValid-class</a></code>.
</p>
<p>For help on the clustering methods see <code><a href="stats.html#topic+hclust">hclust</a></code> and
<code><a href="stats.html#topic+kmeans">kmeans</a></code>  in package <span class="pkg">stats</span>, 
<code><a href="cluster.html#topic+agnes">agnes</a></code>, <code><a href="cluster.html#topic+clara">clara</a></code>,  <code><a href="cluster.html#topic+diana">diana</a></code>,
<code><a href="cluster.html#topic+fanny">fanny</a></code>, and <code><a href="cluster.html#topic+pam">pam</a></code> in package <span class="pkg">cluster</span>,
<code><a href="kohonen.html#topic+supersom">supersom</a></code> in package <span class="pkg">kohonen</span>, <code><a href="mclust.html#topic+Mclust">Mclust</a></code>
in package <span class="pkg">mclust</span>, and <code><a href="#topic+sota">sota</a></code> (in this package).
</p>
<p>For additional help on the validation measures see
<code><a href="#topic+connectivity">connectivity</a></code>,   <code><a href="#topic+dunn">dunn</a></code>,
<code><a href="#topic+stability">stability</a></code>, 
<code><a href="#topic+BHI">BHI</a></code>, and 
<code><a href="#topic+BSI">BSI</a></code>. 
</p>



<h3>Examples</h3>

<pre><code class='language-R'>

data(mouse)

## internal validation
express &lt;- mouse[1:25,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID[1:25]
intern &lt;- clValid(express, 2:4, clMethods=c("hierarchical","kmeans","pam"),
                  validation="internal")

## view results
summary(intern)
optimalScores(intern)
plot(intern)

## stability measures
stab &lt;- clValid(express, 2:4, clMethods=c("hierarchical","kmeans","pam"),
                validation="stability")
optimalScores(stab)
plot(stab)

## biological measures
## first way - functional classes predetermined
fc &lt;- tapply(rownames(express),mouse$FC[1:25], c)
fc &lt;- fc[-match( c("EST","Unknown"), names(fc))]
bio &lt;- clValid(express, 2:4, clMethods=c("hierarchical","kmeans","pam"),
               validation="biological", annotation=fc)
optimalScores(bio)
plot(bio)

## second way - using Bioconductor
if(require("Biobase") &amp;&amp; require("annotate") &amp;&amp; require("GO.db") &amp;&amp; require("moe430a.db")) {
  bio2 &lt;- clValid(express, 2:4, clMethods=c("hierarchical","kmeans","pam"),
                  validation="biological",annotation="moe430a.db",GOcategory="all")
  optimalScores(bio2)
  plot(bio2)
}

</code></pre>

<hr>
<h2 id='clValid-class'>Class &quot;clValid&quot;</h2><span id='topic+clValidObj'></span><span id='topic+clValid-class'></span><span id='topic+clusterMethods+2CclValid-method'></span><span id='topic+clusters+2CclValid-method'></span><span id='topic+measNames+2CclValid-method'></span><span id='topic+measures+2CclValid-method'></span><span id='topic+nClusters+2CclValid-method'></span><span id='topic+optimalScores+2CclValid-method'></span><span id='topic+clusterMethods'></span><span id='topic+clusters'></span><span id='topic+measNames'></span><span id='topic+measures'></span><span id='topic+nClusters'></span><span id='topic+optimalScores'></span><span id='topic+plot+2CclValid+2Cmissing-method'></span><span id='topic+print+2CclValid-method'></span><span id='topic+show+2CclValid-method'></span><span id='topic+summary+2CclValid-method'></span>

<h3>Description</h3>

<p>The class <code>"clValid"</code> contains the clustering results
and validation measures from the accompanying call to the function
<code><a href="#topic+clValid">clValid</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created using the function <code><a href="#topic+clValid">clValid</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>clusterObjs</code>:</dt><dd><p>Object of class <code>"list"</code>. A list
containing the results from the clustering methods.</p>
</dd>
<dt><code>measures</code>:</dt><dd><p>Object of class <code>"array"</code>. A
3-dimensional array which contains the
validation measures for the clustering results.  The first
dimension indicates the validation measures, the second the number of
clusters, and the third the clustering methods.</p>
</dd>
<dt><code>measNames</code>:</dt><dd><p>Object of class <code>"character"</code>. The
names of the validation measures.</p>
</dd>
<dt><code>clMethods</code>:</dt><dd><p>Object of class <code>"character"</code>. A
character vector giving the clustering methods.</p>
</dd>
<dt><code>labels</code>:</dt><dd><p>Object of class <code>"character"</code>. A
character vector giving the item (gene) labels.</p>
</dd>    
<dt><code>nClust</code>:</dt><dd><p>Object of class <code>"numeric"</code>. A numeric
vector giving the numbers of clusters
which were evaluated.</p>
</dd>
<dt><code>validation</code>:</dt><dd><p>Object of class <code>"character"</code>. A character vector giving the type of
validation measures used, consisting of some combination of
&quot;internal&quot;, &quot;stability&quot;, or &quot;biological&quot;.</p>
</dd>
<dt><code>metric</code>:</dt><dd><p>Object of class <code>"character"</code>. The metric used to determine the distance
matrix.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>. For
hierarchical clustering, the agglomeration method used.</p>
</dd>
<dt><code>neighbSize</code>:</dt><dd><p>Object of class <code>"numeric"</code>. For internal validation, the neighborhood size used for the
connectivity measure.</p>
</dd>
<dt><code>annotation</code>:</dt><dd><p>Object of class <code>"character or array
	or list"</code>.
Either a character string naming the Bioconductor annotation
package for mapping genes to GO categories, or a list with the names of the functional classes
and the observations belonging to each class.</p>
</dd>
<dt><code>GOcategory</code>:</dt><dd><p>Object of class <code>"character"</code>. For biological validation, gives which GO
categories to use for biological validation.  Can be one of &quot;BP&quot;,
&quot;MF&quot;, &quot;CC&quot;, or &quot;all&quot;</p>
</dd>
<dt><code>goTermFreq</code>:</dt><dd><p>Object of class <code>"numeric"</code>. For the
BSI, what threshold frequency of GO terms to use for functional annotation.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code>.  Gives the call
to <code><a href="#topic+clValid">clValid</a></code> used to create the <code>clValid</code> object.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>clusterMethods</dt><dd><p><code>signature(object = "clValid")</code>: Returns the
names of the clustering methods. </p>
</dd>
<dt>clusters</dt><dd><p><code>signature(object = "clValid")</code>: Returns the
results from the clustering methods.
</p>
<p>Additional arguments:
</p>

<dl>
<dt><code>method = clMethods(object)</code></dt><dd><p>The clustering method(s)
to extract.</p>
</dd>
</dl>

</dd>
<dt>measNames</dt><dd><p><code>signature(object = "clValid")</code>: Returns the
names of the validation measures.</p>
</dd>
<dt>measures</dt><dd><p><code>signature(object = "clValid")</code>: Returns
the validation measures.
</p>
<p>Additional arguments:
</p>

<dl>
<dt><code>measures = measNames(object)</code></dt><dd><p> The validation measure(s)
to extract.</p>
</dd>
</dl>

</dd>
<dt>nClusters</dt><dd><p><code>signature(object = "clValid")</code>: Returns the
numbers of clusters evaluated.</p>
</dd>
<dt>optimalScores</dt><dd><p><code>signature(object = "clValid")</code>:
Returns the optimal value for each validation measure, along with
the corresponding clustering method and number of clusters.
</p>
<p>Additional arguments:
</p>

<dl>
<dt><code>measures = measNames(object)</code></dt><dd><p> The validation measure(s)
to extract.</p>
</dd>
</dl>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "clValid", y = "missing")</code>: Plots
the validation measures.
</p>
<p>Additional arguments:
</p>

<dl>
<dt><code>measures=measNames(x)</code></dt><dd><p> The validation measures to
plot.</p>
</dd>
<dt><code>legend=TRUE</code></dt><dd><p> If TRUE provides a legend.</p>
</dd>
<dt><code>legendLoc="topright"</code></dt><dd><p> The location of the legend.</p>
</dd>
<dt><code>main=NULL</code></dt><dd><p> Title of graph.</p>
</dd>
<dt><code>pch=NULL</code></dt><dd><p> Plotting characters to use.</p>
</dd>
<dt><code>type="b"</code></dt><dd><p> Type of plot.</p>
</dd>
<dt><code>ask=prod(par("mfcol")) &lt; length(measures) &amp;&amp;
	    dev.interactive()</code></dt><dd><p> Logical.  If <code>TRUE</code> the user is
prompted before each plot.</p>
</dd>
</dl>

</dd>
<dt>print</dt><dd><p><code>signature(x = "clValid")</code>: Print method for class
<code>clValid</code>.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "clValid")</code>: Same as print.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "clValid")</code>: Summary method
for class <code>clValid</code>.
</p>
<p>Additional arguments:
</p>

<dl>
<dt><code>digits = max(3,getOption("digits")-3)</code></dt><dd><p> The number
of significant digits to use.</p>
</dd>
</dl>

</dd>
</dl>


<h3>Note</h3>

<p>See the vignette for an illustration of the class.</p>


<h3>Author(s)</h3>

<p>Guy Brock, Vasyl Pihur, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Brock, G., Pihur, V., Datta, S. and Datta, S. (2008)
clValid: An R Package for Cluster Validation
Journal of Statistical Software 25(4)
<a href="https://www.jstatsoft.org/v25/i04/">https://www.jstatsoft.org/v25/i04/</a>
</p>
<p>Datta, S. and Datta, S. (2003)
Comparisons and validation of statistical clustering techniques for microarray gene expression data.
Bioinformatics 19(4): 459-466.
</p>
<p>Datta, S. and Datta, S. (2006)
Methods for evaluating clustering algorithms for gene expression data
using a reference set of functional classes.
BMC Bioinformatics 7:397.
<a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-7-397/">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-7-397/</a>
</p>
<p>Handl, J., Knowles, K., and Kell, D. (2005)
Computational cluster validation in post-genomic data analysis.
Bioinformatics 21(15): 3201-3212.
</p>


<h3>See Also</h3>

<p>For a description of the function 'clValid' see <code><a href="#topic+clValid">clValid</a></code>.
</p>
<p>For help on the clustering methods see <code><a href="stats.html#topic+hclust">hclust</a></code> and
<code><a href="stats.html#topic+kmeans">kmeans</a></code> in package <span class="pkg">stats</span>,
<code><a href="stats.html#topic+kmeans">kmeans</a></code>  in package <span class="pkg">stats</span>, 
<code><a href="cluster.html#topic+agnes">agnes</a></code>, <code><a href="cluster.html#topic+clara">clara</a></code>,  <code><a href="cluster.html#topic+diana">diana</a></code>,
<code><a href="cluster.html#topic+fanny">fanny</a></code>, and <code><a href="cluster.html#topic+pam">pam</a></code> in package <span class="pkg">cluster</span>,
<code><a href="kohonen.html#topic+supersom">supersom</a></code> in package <span class="pkg">kohonen</span>, <code><a href="mclust.html#topic+Mclust">Mclust</a></code>  
in package <span class="pkg">mclust</span>, and <code><a href="#topic+sota">sota</a></code>.
</p>
<p>For additional help on the validation measures see
<code><a href="#topic+connectivity">connectivity</a></code>,   <code><a href="#topic+dunn">dunn</a></code>,
<code><a href="#topic+stability">stability</a></code>, 
<code><a href="#topic+BHI">BHI</a></code>, and 
<code><a href="#topic+BSI">BSI</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## to delete
library(clValid)


data(mouse)

## internal validation
express &lt;- mouse[1:25,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID[1:25]
intern &lt;- clValid(express, 2:6, clMethods=c("hierarchical","kmeans","pam"),
                  validation="internal")
slotNames(intern)

## view results
intern
summary(intern)
optimalScores(intern)
plot(intern)

## Extract objects from slots
measures(intern)
hierClust &lt;- clusters(intern,"hierarchical")
plot(hierClust)
measNames(intern)
nClusters(intern)

</code></pre>

<hr>
<h2 id='clValid-internal'>Internal clValid functions</h2><span id='topic+vClusters'></span><span id='topic+matchGO'></span>

<h3>Description</h3>

<p>Internal clValid functions
</p>


<h3>Details</h3>

<p>These functions are not to be called directly by the user
</p>

<hr>
<h2 id='connectivity'>Connectivity Measure</h2><span id='topic+connectivity'></span>

<h3>Description</h3>

<p>Calculates the connectivity validation measure for a given cluster partitioning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectivity(distance = NULL, clusters, Data = NULL, neighbSize = 10,
             method = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connectivity_+3A_distance">distance</code></td>
<td>
<p>The distance matrix (as a matrix object) of the
clustered observations.  Required if <code>Data</code> is NULL.</p>
</td></tr>
<tr><td><code id="connectivity_+3A_clusters">clusters</code></td>
<td>
<p>An integer vector indicating the cluster partitioning</p>
</td></tr>
<tr><td><code id="connectivity_+3A_data">Data</code></td>
<td>
<p>The data matrix of the clustered observations. Required if
<code>distance</code> is NULL.</p>
</td></tr>  
<tr><td><code id="connectivity_+3A_neighbsize">neighbSize</code></td>
<td>
<p>The size of the neighborhood</p>
</td></tr>
<tr><td><code id="connectivity_+3A_method">method</code></td>
<td>
<p>The metric used to determine the distance
matrix.  Not used if <code>distance</code> is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The connectivity indicates the degree of connectedness of the
clusters, as determined by the k-nearest neighbors.  The
<code>neighbSize</code> argument specifies the number of neighbors to use.
The connectivity has a value between 0 and infinity and should be minimized.
For details see the package vignette.
</p>


<h3>Value</h3>

<p>Returns the connectivity measure as a numeric value.
</p>


<h3>Note</h3>

<p>The main function for cluster validation is <code><a href="#topic+clValid">clValid</a></code>, and
users should call this function directly if possible.
</p>


<h3>Author(s)</h3>

<p>Guy Brock, Vasyl Pihur, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Handl, J., Knowles, K., and Kell, D. (2005).
Computational cluster validation in post-genomic data analysis.
Bioinformatics 21(15): 3201-3212.
</p>


<h3>See Also</h3>

<p>For a description of the function 'clValid' see <code><a href="#topic+clValid">clValid</a></code>.
</p>
<p>For a description of the class 'clValid' and all available methods see
<code><a href="#topic+clValidObj">clValidObj</a></code> or <code><a href="#topic+clValid-class">clValid-class</a></code>.
</p>
<p>For additional help on the other validation measures see
<code><a href="#topic+dunn">dunn</a></code>,
<code><a href="#topic+stability">stability</a></code>, 
<code><a href="#topic+BHI">BHI</a></code>, and
<code><a href="#topic+BSI">BSI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouse)
express &lt;- mouse[1:25,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID[1:25]
## hierarchical clustering
Dist &lt;- dist(express,method="euclidean")
clusterObj &lt;- hclust(Dist, method="average")
nc &lt;- 2 ## number of clusters      
cluster &lt;- cutree(clusterObj,nc)
connectivity(Dist, cluster)
</code></pre>

<hr>
<h2 id='dunn'>Dunn Index</h2><span id='topic+dunn'></span>

<h3>Description</h3>

<p>Calculates the Dunn Index for a given clustering partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dunn(distance = NULL, clusters, Data = NULL, method = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dunn_+3A_distance">distance</code></td>
<td>
<p>The distance matrix (as a matrix object) of the
clustered observations.  Required if <code>Data</code> is NULL.</p>
</td></tr>
<tr><td><code id="dunn_+3A_clusters">clusters</code></td>
<td>
<p>An integer vector indicating the cluster partitioning</p>
</td></tr>
<tr><td><code id="dunn_+3A_data">Data</code></td>
<td>
<p>The data matrix of the clustered observations. Required if
<code>distance</code> is NULL.</p>
</td></tr>  
<tr><td><code id="dunn_+3A_method">method</code></td>
<td>
<p>The metric used to determine the distance
matrix.  Not used if <code>distance</code> is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dunn Index is the ratio of the smallest distance between
observations not in the same cluster to the largest intra-cluster
distance.  The Dunn Index has a value between zero and infinity, and
should be maximized.
For details see the package vignette.
</p>


<h3>Value</h3>

<p>Returns the Dunn Index as a numeric value.
</p>


<h3>Note</h3>

<p>The main function for cluster validation is <code><a href="#topic+clValid">clValid</a></code>, and
users should call this function directly if possible.
</p>


<h3>Author(s)</h3>

<p>Guy Brock, Vasyl Pihur, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Dunn, J.C. (1974). Well separated clusters and fuzzy partitions.
Journal on Cybernetics, 4:95-104.
</p>
<p>Handl, J., Knowles, K., and Kell, D. (2005).
Computational cluster validation in post-genomic data analysis.
Bioinformatics 21(15): 3201-3212.
</p>


<h3>See Also</h3>

<p>For a description of the function 'clValid' see <code><a href="#topic+clValid">clValid</a></code>.
</p>
<p>For a description of the class 'clValid' and all available methods see
<code><a href="#topic+clValidObj">clValidObj</a></code> or <code><a href="#topic+clValid-class">clValid-class</a></code>.
</p>
<p>For additional help on the other validation measures see
<code><a href="#topic+dunn">dunn</a></code>,
<code><a href="#topic+stability">stability</a></code>, 
<code><a href="#topic+BHI">BHI</a></code>, and
<code><a href="#topic+BSI">BSI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouse)
express &lt;- mouse[1:25,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID[1:25]
## hierarchical clustering
Dist &lt;- dist(express,method="euclidean")
clusterObj &lt;- hclust(Dist, method="average")
nc &lt;- 2 ## number of clusters      
cluster &lt;- cutree(clusterObj,nc)
dunn(Dist, cluster)
</code></pre>

<hr>
<h2 id='getRanksWeights'>Extract ranks and weights from clValid object</h2><span id='topic+getRanksWeights'></span>

<h3>Description</h3>

<p>Creates matrix of ranks and weights from <code><a href="#topic+clValid-class">clValid</a></code>
object, to use as input for rank aggregation using
<code><a href="RankAggreg.html#topic+RankAggreg">RankAggreg</a></code> in package <span class="pkg">RankAggreg</span></p>


<h3>Usage</h3>

<pre><code class='language-R'>getRanksWeights(clVObj, measures = measNames(clVObj), nClust =
                nClusters(clVObj), clAlgs = clusterMethods(clVObj))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRanksWeights_+3A_clvobj">clVObj</code></td>
<td>
<p>a clValid object</p>
</td></tr>
<tr><td><code id="getRanksWeights_+3A_measures">measures</code></td>
<td>
<p>the cluster validation measures to use for rank aggregation</p>
</td></tr>
<tr><td><code id="getRanksWeights_+3A_nclust">nClust</code></td>
<td>
<p>the number of clusters to evaluate</p>
</td></tr>
<tr><td><code id="getRanksWeights_+3A_clalgs">clAlgs</code></td>
<td>
<p>the clustering algorithms to evaluate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts cluster validation measures from a
<code><a href="#topic+clValid-class">clValid</a></code> object, and creates a matrix of rankings
where each row contains a list of clustering algorithms which are
ranked according to the validation measure for that row.  The function
also returns the cluster validation measures as a matrix of weights,
for use with weighted rank aggregation in the function
<code><a href="RankAggreg.html#topic+RankAggreg">RankAggreg</a></code>.  Any combination of validation
measures, numbers of clusters, and clustering algorithms can be
selected by the user.  Number of clusters and clustering algorithms
are appended into a single name.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>ranks</code></td>
<td>
<p>Matrix with rankings for each validation measure in each row</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Matrix of weights, corresponding to the cluster
validation measures, which are used for weighted rank aggregation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Brock</p>


<h3>References</h3>

<p>Brock, G., Pihur, V., Datta, S. and Datta, S. (2008)
clValid: An R Package for Cluster Validation
Journal of Statistical Software 25(4)
<a href="https://www.jstatsoft.org/v25/i04/">https://www.jstatsoft.org/v25/i04/</a>
</p>
<p>Pihur, V., Datta, S. and Datta, S. (2009)
RankAggreg, an R package for weighted rank aggregation
BMC Bioinformatics 10:62  
<a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-10-62/">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-10-62/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clValid-class">clValid</a></code>, <code><a href="RankAggreg.html#topic+RankAggreg">RankAggreg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouse)
express &lt;- mouse[1:25,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID[1:25]
clv &lt;- clValid(express, 4:6, clMethods=c("hierarchical","kmeans","pam"), 
                  validation=c("internal","stability"))
res &lt;- getRanksWeights(clv)
if(require("RankAggreg")) {
  CEWS &lt;- RankAggreg(x=res$ranks, k=5, weights=res$weights, seed=123, verbose=FALSE)
  CEWS
}
</code></pre>

<hr>
<h2 id='mouse'>Mouse Mesenchymal Cells</h2><span id='topic+mouse'></span>

<h3>Description</h3>

<p>Data from an Affymetrix microarray experiment (moe430a) comparing comparing gene expression of mesenchymal
cells from two distinct lineages, neural crest and mesoderm derived. The
dataset consists of 147 genes and ESTs which were determined to be significantly
differentially expressed between the two cell lineages, with at least a 1.5 fold increase
or decrease in expression. There are three samples for each of the neural crest
and mesoderm derived cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mouse)</code></pre>


<h3>Format</h3>

<p>A data frame with 147 observations on the following 8 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>The Affymetric GeneChip ID, from the moe430a chip</p>
</dd>
<dt><code>M1</code></dt><dd><p>Mesoderm derived cell sample</p>
</dd> 
<dt><code>M2</code></dt><dd><p>Mesoderm derived cell sample</p>
</dd> 
<dt><code>M3</code></dt><dd><p>Mesoderm derived cell sample</p>
</dd> 
<dt><code>NC1</code></dt><dd><p>Nueral crest derived cell sample</p>
</dd>
<dt><code>NC2</code></dt><dd><p>Nueral crest derived cell sample</p>
</dd>
<dt><code>NC3</code></dt><dd><p>Nueral crest derived cell sample</p>
</dd>
<dt><code>FC</code></dt><dd><p>The functional class of each gene/EST</p>
</dd>
</dl>



<h3>Source</h3>

<p>V. Bhattacherjee, P. Mukhopadhyay, S. Singh, C. Johnson, J. T. Philipose, C. P.
Warner, R. M. Greene, and M. M. Pisano. Neural crest and mesoderm lineagedependent
gene expression in orofacial development. Differentiation, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouse)

## table of fuctional classifications
table(mouse$FC)

## hierarchical clustering of expression values
express &lt;- mouse[,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID
hc &lt;- hclust(dist(express))
plot(hc)

</code></pre>

<hr>
<h2 id='plot.sota'>Plot Function for a SOTA Object</h2><span id='topic+plot.sota'></span>

<h3>Description</h3>

<p>'plot.sota' is used to obtain a visual representation of profiles within each individual cluster.
Corresponding cluster average profiles are also available. By default, plots for all clusters
are displayed side by side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sota'
plot(x, cl = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sota_+3A_x">x</code></td>
<td>
<p>SOTA object, an object returned by function <code><a href="#topic+sota">sota</a></code>.</p>
</td></tr>
<tr><td><code id="plot.sota_+3A_cl">cl</code></td>
<td>
<p><code>cl</code> specifies which cluster is to be plotted by setting it to the cluster ID. By default,
<code>cl</code> is equal to 0 and the function plots all clusters side by
side.</p>
</td></tr>
<tr><td><code id="plot.sota_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vasyl Pihur, Guy Brock, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Herrero, J., Valencia,
A, and Dopazo, J. (2005). A hierarchical unsupervised growing neural
network for clustering gene expression patterns. Bioinformatics, 17, 126-136.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sota">sota</a></code>, <code><a href="#topic+print.sota">print.sota</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouse)
express &lt;- mouse[,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID

sotaCl &lt;- sota(as.matrix(express), 4)
names(sotaCl)
sotaCl
plot(sotaCl)
plot(sotaCl, cl=2)

</code></pre>

<hr>
<h2 id='print.sota'>Print Function for a SOTA Object</h2><span id='topic+print.sota'></span>

<h3>Description</h3>

<p>A default print method for a SOTA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sota'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sota_+3A_x">x</code></td>
<td>
<p>a SOTA object as returned by the <code><a href="#topic+sota">sota</a></code> function</p>
</td></tr>
<tr><td><code id="print.sota_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="base.html#topic+print">print</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>print</code> function does not return anything. It simply displays in the console
window general information about the paritioning (cluster ID, Size, and Diversity Score),
as well as cluster centroids (average profiles within each cluster) and the distance that has
been used.
</p>


<h3>Author(s)</h3>

<p>Vasyl Pihur, Guy Brock, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Herrero, J., Valencia,
A, and Dopazo, J. (2005). A hierarchical unsupervised growing neural
network for clustering gene expression patterns. Bioinformatics, 17, 126-136.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sota">sota</a></code>, <code><a href="#topic+print.sota">print.sota</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouse)
express &lt;- mouse[,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID

sotaCl &lt;- sota(as.matrix(express), 4)
names(sotaCl)
sotaCl
plot(sotaCl)
plot(sotaCl, cl=2)

</code></pre>

<hr>
<h2 id='readAnnotationFile'>
Read in biological annotation files from external file
</h2><span id='topic+readAnnotationFile'></span>

<h3>Description</h3>

<p>This function reads in a biological annotation file detailing the
functional classes for a given set of genes from a comma separated file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAnnotationFile(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readAnnotationFile_+3A_filename">filename</code></td>
<td>
<p>The name of the external file.  The values must be
comma separated.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The required format is comma separated, with
the first column indicating the biological functional category, and
the remaining columns containing the gene identifiers for those genes
belonging to that category. 
</p>


<h3>Value</h3>

<p>Returns a list where each item in the list is the set of genes
belonging to a particular functional class. This can be converted to a
TRUE/FALSE matrix using the <code><a href="#topic+annotationListToMatrix">annotationListToMatrix</a></code>
function, though it is not necessary to do this prior to using
<code><a href="#topic+clValid">clValid</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Guy Brock, Vasyl Pihur
</p>


<h3>See Also</h3>

<p><code><a href="#topic+annotationListToMatrix">annotationListToMatrix</a></code>, <code><a href="#topic+clValid">clValid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For example use, see the package vignette
</code></pre>

<hr>
<h2 id='sota'>Self-organizing Tree Algorithm (SOTA)</h2><span id='topic+sota'></span>

<h3>Description</h3>

<p>Computes a Self-organizing Tree Algorithm (SOTA) clustering of a dataset returning a SOTA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sota(data, maxCycles, maxEpochs = 1000, distance = "euclidean", wcell = 0.01, 
     pcell = 0.005, scell = 0.001, delta = 1e-04, neighb.level = 0, 
     maxDiversity = 0.9, unrest.growth = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sota_+3A_data">data</code></td>
<td>
<p>data matrix or data frame. Cannot have a profile ID as the first column.</p>
</td></tr>
<tr><td><code id="sota_+3A_maxcycles">maxCycles</code></td>
<td>
<p>integer value representing the maximum number of iterations allowed. The resulting number
of clusters returned by <code>sota</code> is maxCycles+1 unless <code>unrest.growth</code> is set to FALSE and the
<code>maxDiversity</code> criteria is satisfied prior to reaching the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="sota_+3A_maxepochs">maxEpochs</code></td>
<td>
<p>integer value indicating the maximum number of training epochs allowed per cycle. By default,
<code>maxEpochs</code> is set to 1000.</p>
</td></tr>
<tr><td><code id="sota_+3A_distance">distance</code></td>
<td>
<p>character string used to represent the metric to be used for calculating
dissimilarities between profiles. 'euclidean' is the default, with 'correlation' being another option.</p>
</td></tr>
<tr><td><code id="sota_+3A_wcell">wcell</code></td>
<td>
<p>value specifying the winning cell migration weight. The default is 0.01.</p>
</td></tr>
<tr><td><code id="sota_+3A_pcell">pcell</code></td>
<td>
<p>value specifying the parent cell migration weight. The default is 0.005.</p>
</td></tr>
<tr><td><code id="sota_+3A_scell">scell</code></td>
<td>
<p>value specifying the sister cell migration weight. The default is 0.001.</p>
</td></tr>
<tr><td><code id="sota_+3A_delta">delta</code></td>
<td>
<p>value specifying the minimum epoch error improvement. This value is used as a threshold for signaling
the start of a new cycle. It is set to 1e-04 by default.</p>
</td></tr>
<tr><td><code id="sota_+3A_neighb.level">neighb.level</code></td>
<td>
<p>integer value used to indicate which cells are candidates to accept new profiles. This number
specifies the number of levels up the tree the algorithm moves in the search of candidate cells for the redistribution
of profiles. The default is 0.</p>
</td></tr>
<tr><td><code id="sota_+3A_maxdiversity">maxDiversity</code></td>
<td>
<p>value representing a maximum variability allowed within a cluster. 0.9 is the default value.</p>
</td></tr>
<tr><td><code id="sota_+3A_unrest.growth">unrest.growth</code></td>
<td>
<p>logical flag: if TRUE then the algorithm will run <code>maxCycles</code> iterations regardless of
whether the <code>maxDiversity</code> criteria is satisfied or not and <code>maxCycles</code>+1 clusters will be produced; if FALSE
then the algorithm can potentially stop before reaching the <code>maxCycles</code> based on the current state of cluster
diversities. A smaller than usual number of clusters will be obtained. The default value is TRUE.</p>
</td></tr>
<tr><td><code id="sota_+3A_...">...</code></td>
<td>
<p>Any other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Self-Organizing Tree Algorithm (SOTA) is an unsupervised neural network with a binary tree topology. It combines
the advantages of both hierarchical clustering and Self-Organizing Maps (SOM). The algorithm picks a node with
the largest Diversity and splits it into two nodes, called Cells. This process can be stopped at any level, assuring a fixed number of
hard clusters. This behavior is achieved with setting the <code>unrest.growth</code> parameter to TRUE. Growth of the
tree can be stopped based on other criteria, like the allowed maximum Diversity within the cluster and so on.
</p>
<p>Further details regarding the inner workings of the algorithm can be found in the paper listed in the Reference
section.
</p>


<h3>Value</h3>

<table>
<tr><td><code>data</code></td>
<td>
<p>data matrix used for clustering</p>
</td></tr>
<tr><td><code>c.tree</code></td>
<td>
<p>complete tree in a matrix format. Node ID, its Ancestor, and whether it's a terminal node (cell)
are listed in the first three columns. Node profiles are shown in the remaining columns.</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>incomplete tree in a matrix format listing only the terminal nodes (cells).
Node ID, its Ancestor, and 1's for a cell indicator
are listed in the first three columns. Node profiles are shown in the remaining columns.</p>
</td></tr>
<tr><td><code>clust</code></td>
<td>
<p>integer vector whose length is equal to the number of profiles in a data matrix indicating
the cluster assingments for each profile in the original order.</p>
</td></tr>
<tr><td><code>totals</code></td>
<td>
<p>integer vector specifying the cluster sizes.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>character string indicating a distance function used in the clustering process.</p>
</td></tr>
<tr><td><code>diversity</code></td>
<td>
<p>vector specifying final cluster diverisities.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vasyl Pihur, Guy Brock, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Herrero, J., Valencia,
A, and Dopazo, J. (2005). A hierarchical unsupervised growing neural
network for clustering gene expression patterns. Bioinformatics, 17, 126-136.</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.sota">plot.sota</a></code>, <code><a href="#topic+print.sota">print.sota</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mouse)
express &lt;- mouse[,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID

sotaCl &lt;- sota(as.matrix(express), 4)
names(sotaCl)
sotaCl
plot(sotaCl)
plot(sotaCl, cl=2)
</code></pre>

<hr>
<h2 id='stability'>Stability Measures</h2><span id='topic+stability'></span><span id='topic+APN'></span><span id='topic+AD'></span><span id='topic+ADM'></span><span id='topic+FOM'></span>

<h3>Description</h3>

<p>Calculates the stability measures the average proportion of non-overlap (APN),
the average distance (AD), the average distance between means (ADM),
and the figure of merit (FOM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stability(mat, Dist=NULL, del, cluster, clusterDel, method="euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stability_+3A_mat">mat</code></td>
<td>
<p>The data matrix of the clustered observations</p>
</td></tr>  
<tr><td><code id="stability_+3A_dist">Dist</code></td>
<td>
<p>The distance matrix (as a matrix or dist object) of the
clustered observations.  If NULL then <code>method</code> is used with
<code>mat</code> to determine the distance matrix.</p>
</td></tr>
<tr><td><code id="stability_+3A_del">del</code></td>
<td>
<p>An integer indicating which column was removed</p>
</td></tr>
<tr><td><code id="stability_+3A_cluster">cluster</code></td>
<td>
<p>An integer vector indicating the cluster partitioning
based on all the data</p>
</td></tr>  
<tr><td><code id="stability_+3A_clusterdel">clusterDel</code></td>
<td>
<p>An integer vector indicating the cluster
partitioning based on the data with column <code>del</code> removed.</p>
</td></tr>
<tr><td><code id="stability_+3A_method">method</code></td>
<td>
<p>The metric used to determine the distance
matrix.  Not used if <code>distance</code> is provided.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The stability measures evaluate the stability of a clustering result by comparing it
with the clusters obtained by removing one column at a time.
These measures include the average proportion of non-overlap (APN),
the average distance (AD), the average distance between means (ADM),
and the figure of merit (FOM).  The APN, AD, and ADM are all based on the
cross-classification table of the original clustering with the
clustering based on the removal of one column.  The APN measures the
average proportion of observations not placed in the same cluster under both
cases, while the AD measures the average distance between observations placed
in the same cluster under both cases and the ADM measures the average
distance between cluster centers for observations placed in the same cluster
under both cases.  The FOM measures the average intra-cluster variance
of the deleted column, where the clustering is based on the remaining
(undeleted) columns.  In all cases the average is taken over all the
deleted columns, and all measures should be minimized.
For details see the package vignette.
</p>
<p>NOTE: The <code>stability</code> function only calculates these measures for
the particular column specified by <code>del</code> removed.  To get the
overall scores, the user must average the measures
corresponding to each removed column.
</p>


<h3>Value</h3>

<p>Returns a numeric vector with the APN, AD, ADM, and FOM measures
corresponding to the particular column that was
removed.  
</p>


<h3>Note</h3>

<p>The main function for cluster validation is <code><a href="#topic+clValid">clValid</a></code>, and
users should call this function directly if possible.
</p>
<p>To get the overall values, the stability measures
corresponding to each removed column should be averaged (see the
examples below).  
</p>


<h3>Author(s)</h3>

<p>Guy Brock, Vasyl Pihur, Susmita Datta, Somnath Datta</p>


<h3>References</h3>

<p>Datta, S. and Datta, S. (2003).
Comparisons and validation of statistical clustering techniques for microarray gene expression data.
Bioinformatics 19(4): 459-466.  
</p>


<h3>See Also</h3>

<p>For a description of the function 'clValid' see <code><a href="#topic+clValid">clValid</a></code>.
</p>
<p>For a description of the class 'clValid' and all available methods see
<code><a href="#topic+clValidObj">clValidObj</a></code> or <code><a href="#topic+clValid-class">clValid-class</a></code>.
</p>
<p>For additional help on the other validation measures see
<code><a href="#topic+connectivity">connectivity</a></code>,   <code><a href="#topic+dunn">dunn</a></code>,
<code><a href="#topic+BSI">BSI</a></code>, and 
<code><a href="#topic+BHI">BHI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mouse)
express &lt;- mouse[1:25,c("M1","M2","M3","NC1","NC2","NC3")]
rownames(express) &lt;- mouse$ID[1:25]
## hierarchical clustering
Dist &lt;- dist(express,method="euclidean")
clusterObj &lt;- hclust(Dist, method="average")
nc &lt;- 4 ## number of clusters      
cluster &lt;- cutree(clusterObj,nc)

stab &lt;- matrix(0,nrow=ncol(express),ncol=4)
colnames(stab) &lt;- c("APN","AD","ADM","FOM")

## Need loop over all removed samples
for (del in 1:ncol(express)) {
  matDel &lt;- express[,-del]               
  DistDel &lt;- dist(matDel,method="euclidean")
  clusterObjDel &lt;- hclust(DistDel, method="average")
  clusterDel &lt;- cutree(clusterObjDel,nc)
  stab[del,] &lt;- stability(express, Dist, del, cluster, clusterDel)
}
colMeans(stab)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
