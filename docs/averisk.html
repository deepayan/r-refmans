<!DOCTYPE html><html><head><title>Help for package averisk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {averisk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#averisk'><p>averisk: Calculation of Average Population Attributable Fractions and Confidence Intervals.</p></a></li>
<li><a href='#getAF'><p>Calculate average attributable fractions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculation of Average Population Attributable Fractions and
Confidence Intervals</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS (&ge; 7.3.0)</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-10-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Ferguson &lt;john.ferguson@nuigalway.ie&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Average population attributable fractions are calculated for a set
    of risk factors (either binary or ordinal valued) for both prospective and case-
    control designs. Confidence intervals are found by Monte Carlo simulation. The
    method can be applied to either prospective or case control designs, provided an
    estimate of disease prevalence is provided. In addition to an exact calculation
    of AF, an approximate calculation, based on randomly sampling permutations has
    been implemented to ensure the calculation is computationally tractable when the
    number of risk factors is large.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-03-20 19:20:00 UTC; 0118158S</td>
</tr>
<tr>
<td>Author:</td>
<td>John Ferguson [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-03-21 06:50:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='averisk'>averisk: Calculation of Average Population Attributable Fractions and Confidence Intervals.</h2><span id='topic+averisk'></span><span id='topic+averisk-package'></span>

<h3>Description</h3>

<p>Average population attributable fractions are calculated for a set of risk factors (either binary or ordinal valued) for both prospective and case-control designs.  Confidence intervals are found by Monte Carlo simulation. The method can be applied to either prospective or case control designs, provided an estimate of disease prevalence is provided.  In addition to an exact calculation of AF, an approximate calculation, based on randomly sampling permutations has been implemented to ensure the calculation is computationally tractable when the number of risk factors is large.
</p>


<h3>averisk functions</h3>

<p>getAF
</p>

<hr>
<h2 id='getAF'>Calculate average attributable fractions</h2><span id='topic+getAF'></span>

<h3>Description</h3>

<p>This function calculates average attributable fractions and confidence intervals for discrete riskfactors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAF(f, the.data, ref_cat = NULL, refy = 0, cat_confounders = NULL,
  cont_confounders = NULL, prev = NA, allperm = TRUE,
  nsample_perm = 1000, approx_error = NA, ci = FALSE, conf_level = 0.99,
  nsample_var = 100, correction_factor = TRUE, quantile_int = FALSE,
  sep_est = TRUE, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAF_+3A_f">f</code></td>
<td>
<p>A formula object specifying a logistic regression model for the risk factors.  See Details for more information.</p>
</td></tr>
<tr><td><code id="getAF_+3A_the.data">the.data</code></td>
<td>
<p>A dataframe containing the disease indicator, riskfactors and possible confounders.</p>
</td></tr>
<tr><td><code id="getAF_+3A_ref_cat">ref_cat</code></td>
<td>
<p>A character vector indicating the reference values for each risk factor. Defaults to <code>NULL</code>. In the case that this argument is not specified, the default R assignment for the reference level is used for risk factors coded as <code>character</code> and <code>factor</code> variables (see <code>?factor</code>) whereas the minimum value is assigned as the reference level for risk factors coded as <code>numeric</code> vectors. Attributable fractions calculate the proportional change in disease prevalence that might be expected if the entire population had the reference value for each risk factor.</p>
</td></tr>
<tr><td><code id="getAF_+3A_refy">refy</code></td>
<td>
<p>Response value that specifies controls.  Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="getAF_+3A_cat_confounders">cat_confounders</code></td>
<td>
<p>A character vector indicating categorical variables that need to be adjusted for (excluding risk factors).  Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getAF_+3A_cont_confounders">cont_confounders</code></td>
<td>
<p>A character vector indicating categorical variables that need to be adjusted for (excluding risk factors).  Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getAF_+3A_prev">prev</code></td>
<td>
<p>A proportion specifying the percentage of the population that have the disease.  Defaults to <code>NA</code>.  <code>NA</code> is appropriate for prospective and survey designs. Prevalence should be specified for case control designs.</p>
</td></tr>
<tr><td><code id="getAF_+3A_allperm">allperm</code></td>
<td>
<p><code>TRUE</code> gives an exact calculation of the sample average fraction.  <code>FALSE</code> gives an approximate calculation.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getAF_+3A_nsample_perm">nsample_perm</code></td>
<td>
<p>How many permutations are used when calculating approximate average attributable fractions? (only necessary to specify when <code>allperm=FALSE</code>).  If <code>approx_error</code> is specified, then <code>nsample_perm</code> is the number of sampled permutations for the construction of the standard error (if <code>ci=TRUE</code>), but is overrided in the construction of the point estimate.</p>
</td></tr>
<tr><td><code id="getAF_+3A_approx_error">approx_error</code></td>
<td>
<p>Specifying this option will calculate average fractions using the number of permutations necessary to approximate the true sample average fraction point estimate to within approx_error.  Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="getAF_+3A_ci">ci</code></td>
<td>
<p>Is a confidence interval required? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getAF_+3A_conf_level">conf_level</code></td>
<td>
<p>The confidence level specified as a proportion.  i.e. <code>conf_level=0.95</code> would imply 95 percent confidence. Only necessary to specify when <code>ci=TRUE</code></p>
</td></tr>
<tr><td><code id="getAF_+3A_nsample_var">nsample_var</code></td>
<td>
<p>The number of monte carlo iterates of the average fraction that are used when calculating the confidence interval.  Only necessary to specify when <code>ci=TRUE</code></p>
</td></tr>
<tr><td><code id="getAF_+3A_correction_factor">correction_factor</code></td>
<td>
<p>Whether an extra correction term is subtracted from the estimated standard error due to the monte carlo simulated AFs and the point estimate for the AF being based on different numbers of permutations.  Defaults to <code>TRUE</code>. (Only necessary to specify when <code>ci=TRUE</code> and <code>allperm=FALSE</code>)</p>
</td></tr>
<tr><td><code id="getAF_+3A_quantile_int">quantile_int</code></td>
<td>
<p>confidence interval is calculated from empirical quantiles of the monte carlo simulated AFs.  Defaults to <code>FALSE</code>.   Only necessary to specify when <code>ci=TRUE</code>.  See Details for more information.</p>
</td></tr>
<tr><td><code id="getAF_+3A_sep_est">sep_est</code></td>
<td>
<p>The point estimate of the AF in a separate calculation to the confidence interval.  Defaults to <code>TRUE</code>   (Only necessary to specify when <code>ci=TRUE</code>)</p>
</td></tr>
<tr><td><code id="getAF_+3A_w">w</code></td>
<td>
<p>Optional weighting vector for survey data  Defaults to <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model formula <code>f</code> is specified using traditional R notation.  For instance, in the situation where the binary response is 'y' and there are 3 risk factors: x1, x2 and x3, <code>f</code> would be specified as <code>y~x1+x2+x3</code>.  Interactions are not permitted in the model.  Confounders (either categorical or continuous) are added as separate arguments in character vectors.  When a confidence interval is requested, a symmetric interval around the point estimate AF is given by default.  In the case that <code>nsample_var</code> is large, a possibly assymetric interval may instead be requested using <code>quantile_int=TRUE</code>.  In this case, the interval is generated from percentiles of the Monte Carlo simulates of the AF.  Since estimating percentiles of a distribution is more difficult than estimating the overall variance, <code>nsample_var</code> should be increased if quantile based confidence intervals are desired, and doing so will significantly increase run-time.  Quantile based confidence intervals maybe superior to symmetric intervals when the distribution of the simulated AFs is skewed.  However, in our experience, the distribution of Monte Carlo simulates is usually relatively symmetric.
</p>


<h3>Value</h3>

<p>If <code>ci=TRUE</code>, a 3 x (K+1) matrix, where K is the number of risk factors.  The first row represents the point estimate for the AF, and the second and third rows lower and upper confidnece bounds.  If <code>ci=FALSE</code>, a (K+1)-dimensional vector with the calculated point estimates for the AF is returned.
</p>


<h3>Author(s)</h3>

<p>John Ferguson (john.ferguson@nuigalway.ie)
</p>


<h3>References</h3>

<p>Eide, Geir Egil and Olaf Gefeller.  Sequential and Average Attributable Fractions as Aids in the Selection of Preventative Strategies.  J. Clinical Epidemiology, Vol. 48, No. 5, pp. 645-655, 1995.
</p>
<p>Ferguson John, Alvarez Alberto, Newell John, Hinde John and O'Donnell Martin.  Estimating average attributable fractions with confidence intervals for cohort and case control studies.  Statistical Methods in Medical Research, 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the following example is from Eide and Gefeller, 1995
# simulate data

ex_probs &lt;- c(.06732,.02976,.01570,.01787,.01445,.01008,.06986,.06553,.03,.05766,
             .09680,.04194,.02741,.02194,.02474,.01031,.12410,.09537,.08408,.09509) # P(E|D)
disease_probs &lt;- c(.036,.0621,.0236,.0411,.0507,.0864,.1066,.1745,.1867,.2891,.0514,
             .0875,.0339,.0584,.0718,.1206,.1474,.2345,.2497,.3708) # P(D|E)
pe &lt;- ex_probs/disease_probs ## marginal P(E)
pe &lt;- pe/sum(pe)
nond_exposure_probs &lt;- (1-disease_probs)*pe  # P(E|not D)
nond_exposure_probs &lt;- nond_exposure_probs/sum(nond_exposure_probs)
ex_probs &lt;- ex_probs/sum(ex_probs)
the.mat &lt;- cbind(c(rep(0,10),rep(1,10)),rep(rep(1:5,each=2),2),rep(c(0,1),10))
ncase &lt;- 500
ncontrol &lt;- 500
casemat &lt;- the.mat[sample(1:20,size=ncase,replace=TRUE,prob=ex_probs),]
case_rows &lt;- cbind(rep(1,ncase),casemat)
controlmat &lt;- the.mat[sample(1:20,size=ncase,replace=TRUE,prob=nond_exposure_probs),]
control_rows &lt;- cbind(rep(0,ncontrol),controlmat)
the.d &lt;- rbind(case_rows,control_rows)
colnames(the.d) &lt;- c("y","urban.rural","smoking.category","occupational.exposure")

# Just get the estimate (no confidence interval)
getAF(y~urban.rural+smoking.category+occupational.exposure,the.d,prev=0.09)

## find the average fraction and associated monte-carlo calculated 99% confidence 
##  No need for approximation here.  Assume population prevalence is 9 percent.


getAF(y~urban.rural+smoking.category+occupational.exposure,the.d,prev=0.09,ci=TRUE,conf_level=0.99)


## genetic simulation using more risk factors (disease prevalence = 0.01)  might be slow.

## Not run: 
thevec &lt;- dbinom(0:40, size= 40, prob=0.2, log = FALSE)
bin_fun &lt;- function(beta_0){
 sum(thevec*exp(beta_0+.1*(0:40))/(1+exp(beta_0+.1*(0:40))))-0.01
}
beta_0 &lt;- uniroot(bin_fun,lower=-8,upper=5)$root
total_risk &lt;- (0.01-exp(beta_0)/(1+exp(beta_0)))/0.01
risk_per_snp &lt;- total_risk/20
case_probabilities &lt;- (thevec*exp(beta_0 + (0:40)*0.1)/(1+exp(beta_0 + (0:40)*0.1)))/0.01
control_probabilities &lt;- thevec*1/(1+exp(beta_0 + (0:40)*0.1))/0.99
simdata_genetic &lt;- function(ncase,ncontrol){ 
numbersnps_case &lt;- sample(0:40,ncase,prob=case_probabilities,replace=TRUE)
 numbersnps_control &lt;- sample(0:40,ncase,prob=control_probabilities,replace=TRUE)
 case_rows &lt;- cbind(rep(1,ncase),matrix(0,nrow=ncase,ncol=20))
 control_rows &lt;- cbind(rep(0,ncase),matrix(0,nrow=ncontrol,ncol=20))
 for(i in 1:ncase){
   if(numbersnps_case[i]&gt;0){   
     positions &lt;- sample(1:40,numbersnps_case[i])  
     positions &lt;- ceiling(positions/2)
    for(j in 1:length(positions)) case_rows[i,positions[j]+1] &lt;- case_rows[i,positions[j]+1]+1
   }
 }
 for(i in 1:ncontrol){
   if(numbersnps_control[i]&gt;0){   
     positions &lt;- sample(1:40,numbersnps_control[i])
     positions &lt;- ceiling(positions/2)
     for(j in 1:length(positions)){
         control_rows[i,positions[j]+1]&lt;- control_rows[i,positions[j]+1]+1 
     }                                                       
   }
}
 return(rbind(case_rows,control_rows))
}
the.d &lt;- simdata_genetic(ncase=250, ncontrol=250)
colnames(the.d) &lt;- c("y",paste("SNP",1:20,sep=""))

## Here we just calculate the approximate average fraction
## from 50 permutations and no confidence interval.
## If CI desired add the argument ci=TRUE and nsample_var to the function. 
## 50 permuations is chosen for speed. In reality, 1000 maybe needed

thesnp &lt;- paste0("SNP", 1:20,sep="")
(fmla &lt;- as.formula(paste("y ~ ", paste(thesnp, collapse= "+"))))
getAF(fmla, the.d,prev=0.01, allperm=FALSE,nsample_perm=50,ci=FALSE)

## Instead of specifying the number of permutations, 
## you can specify an estimated approximation error. 
## The approximation error will be within this bound with 95% confidence 
## approximation error of 0.01 specified for reasons of speed.
## In reality, you may want to use a smaller value for approx_error.

getAF(fmla, the.d,prev=0.01, allperm=FALSE,approx_error=0.01,ci=FALSE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
