<!DOCTYPE html><html><head><title>Help for package SpatialKWD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialKWD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SpatialKWD-package'>
<p>Kantorovich-Wasserstein Distances for Large Spatial Maps</p></a></li>
<li><a href='#CompareAll-function'>
<p>Compare a given set of spatial histograms</p></a></li>
<li><a href='#CompareOneToMany-function'>
<p>Compare a reference spatial histogram to other histograms</p></a></li>
<li><a href='#CompareOneToOne-function'>
<p>Compare a pair of spatial histograms</p></a></li>
<li><a href='#FocusArea-function'>
<p>Compute the KWD tranport distance within a given focus area</p></a></li>
<li><a href='#Histogram2D-class'>
<p>Two Dimensional Histogram for Spatial Data</p></a></li>
<li><a href='#Solver-class'>
<p>Spatial-KWD Solver</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial KWD for Large Spatial Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefano Gualandi [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefano Gualandi &lt;stefano.gualandi@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains efficient implementations of Discrete Optimal Transport algorithms for the computation of Kantorovich-Wasserstein distances between pairs of large spatial maps (Bassetti, Gualandi, Veneroni (2020), &lt;<a href="https://doi.org/10.1137%2F19M1261195">doi:10.1137/19M1261195</a>&gt;). All the algorithms are based on an ad-hoc implementation of the Network Simplex algorithm. The package has four main helper functions: compareOneToOne() (to compare two spatial maps), compareOneToMany() (to compare a reference map with a list of other maps), compareAll() (to compute a matrix of distances between a list of maps), and focusArea() (to compute the KWD distance within a focus area). In non-convex maps, the helper functions first build the convex-hull of the input bins and pad the weights with zeros.</td>
</tr>
<tr>
<td>License:</td>
<td></td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-09 16:21:03 UTC; stegua</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-09 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SpatialKWD-package'>
Kantorovich-Wasserstein Distances for Large Spatial Maps
</h2><span id='topic+SpatialKWD-package'></span><span id='topic+SpatialKWD'></span>

<h3>Description</h3>

<p>The Spatial-KWD package contains efficient implementations of Discrete Optimal Transport algorithms for the computation of Kantorovich-Wasserstein distances [1], customized for large spatial maps.
All the algorithms are based on an ad-hoc implementation of the Network Simplex algorithm [2].
Each implemented algorithm builds a different network, exploiting the particular structure of spatial maps.
</p>


<h3>Details</h3>

<p>This library contains four helper functions and two classes [4].
</p>
<p>The four helper functions are <code><a href="#topic+compareOneToOne">compareOneToOne</a></code>, <code><a href="#topic+compareOneToMany">compareOneToMany</a></code>, <code><a href="#topic+compareAll">compareAll</a></code>, and <code><a href="#topic+focusArea">focusArea</a></code>. All the functions take in input the data and an options list. Using the options is possible to configure the Kantorivich-Wasserstein solver, so that it uses different algorithms with different parameters.
</p>
<p>The helper functions are built on top of two main classes: <code><a href="#topic+Histogram2D">Histogram2D</a></code> and <code><a href="#topic+Solver">Solver</a></code>.
</p>
<p>Note that in non-convex maps, the algorithm builds the convex-hull of the input bins and pads the weights with zeros.
</p>
<p>In the case of spatial histograms with weights that do not sum up to 1, all the weights can optionally be rescaled in such a way the overall sum of the weights of every single histogram is equal to 1.0: <code class="reqn">w_i \gets \frac{w_i}{\sum_{i=1,\dots,n} w_i}</code>.
This way, the spatial histograms have a natural interpretation as discrete probability measures.
</p>
<p>For a detailed introduction on Computational Optimal Transport, we refer the reader to [3].
</p>


<h3>Author(s)</h3>

<p>Stefano Gualandi, stefano.gualandi@gmail.com.
</p>
<p>Maintainer: Stefano Gualandi &lt;stefano.gualandi@gmail.com&gt;
</p>


<h3>References</h3>

<p>[1] Bassetti, F., Gualandi, S. and Veneroni, M., 2020. &quot;On the Computation of Kantorovich&ndash;Wasserstein Distances Between Two-Dimensional Histograms by Uncapacitated Minimum Cost Flows&quot;. SIAM Journal on Optimization, 30(3), pp.2441-2469.
</p>
<p>[2] Cunningham, W.H., 1976. &quot;A Network Simplex method&quot;. Mathematical Programming, 11(1), pp.105-116.
</p>
<p>[3] Peyre, G., and Cuturi, M., 2019. &quot;Computational optimal transport: With applications to data science&quot;. Foundations and Trends in Machine Learning, 11(5-6), pp.355-607.
</p>
<p>[4] <a href="https://github.com/eurostat/Spatial-KWD">https://github.com/eurostat/Spatial-KWD</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+compareOneToOne">compareOneToOne</a></code>, <code><a href="#topic+compareOneToMany">compareOneToMany</a></code>, <code><a href="#topic+compareAll">compareAll</a></code>, <code>focusArea</code>, <code><a href="#topic+Histogram2D">Histogram2D</a></code>, and <code><a href="#topic+Solver">Solver</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SpatialKWD)

# Random coordinates
N = 90
Xs &lt;- as.integer(runif(N, 0, 31))
Ys &lt;- as.integer(runif(N, 0, 31))
coordinates &lt;- matrix(c(Xs, Ys), ncol=2)

# Random weights
weights &lt;- matrix(runif(2*N, 0, 1), ncol=2)

# Compute distance
print("Compare one-to-one with exact algorithm:")
d &lt;- compareOneToOne(coordinates, weights, L=3)
cat("runtime:", d$runtime, " distance:", d$distance, "\n")
</code></pre>

<hr>
<h2 id='CompareAll-function'>
Compare a given set of spatial histograms
</h2><span id='topic+compareAll'></span>

<h3>Description</h3>

<p>This function computes the Kantorovich-Wasserstein among a given set of <code>M</code> spatial histograms. All the histograms are defined over the same grid map.
</p>
<p>The grid map is described by the two lists of <code>N</code> coordinates <code>Xs</code> and <code>Ys</code>, which specify the coordinates of the centroid of each tile of the map.
For each tile <code>i</code> with coordinates <code>Xs[i], Ys[i]</code>, we have a positive weight for each histogram.
</p>
<p>The two lists of coordinates are passed to <code>compareOneToMany</code> as a matrix with <code>N</code> rows and two columns.
The weights of the histograms are passed as a single matrix with <code>N</code> rows and <code>M</code> columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareAll(Coordinates, Weights, L = 3, recode = TRUE,
           method = "approx",    algorithm = "colgen",
           model="mincostflow",  verbosity = "silent",
           timelimit = 14400,    opt_tolerance = 1e-06,
           unbalanced = FALSE, unbal_cost = 1e+09, convex = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareAll-function_+3A_coordinates">Coordinates</code></td>
<td>
<p>A <code>Matrix</code> with <code>N</code> rows and two columns:
</p>

<ul>
<li><p><code>Coordinates[,1]</code>: <em>(First Column)</em> Vector of horizontal coordinates of the centroids of each tile of the map. Data type: vector of positive integers.
</p>
</li>
<li><p><code>Coordinates[,2]</code>: <em>(Second Column)</em> Vector of vertical coordinates of the centroids of each tile of the map. Data type: vector of positive integers.
</p>
</li></ul>

</td></tr>
<tr><td><code id="CompareAll-function_+3A_weights">Weights</code></td>
<td>
<p>A <code>Matrix</code> of positive weights of the tiles specified by the <code>Coordinates</code> matrix, one column for each input histogram.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_l">L</code></td>
<td>
<p>Approximation parameter.
Higher values of <em>L</em> give a more accurate solution, but they require longer running time. Data type: positive integer.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_recode">recode</code></td>
<td>
<p>If equal to <code>True</code>, recode the input coordinates as consecutive integers.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_method">method</code></td>
<td>
<p>Method for computing the KW distances: <code>exact</code> or <code>approx</code>.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm for computing the KW distances: <code>fullmodel</code> or <code>colgen</code>.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_model">model</code></td>
<td>
<p>Model for building the underlying network: <code>bipartite</code> or <code>mincostflow</code>.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_verbosity">verbosity</code></td>
<td>
<p>Level of verbosity of the log: <code>silent</code>, <code>info</code> or <code>debug</code>.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_timelimit">timelimit</code></td>
<td>
<p>Time limit in second for running the solver.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_opt_tolerance">opt_tolerance</code></td>
<td>
<p>Numerical tolerance on the negative reduce cost for the optimal solution.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_unbalanced">unbalanced</code></td>
<td>
<p>If equal to <code>True</code>, solve the problem with unbalanced masses.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_unbal_cost">unbal_cost</code></td>
<td>
<p>Cost for the arcs going from each point to the extra artificial bin.</p>
</td></tr>
<tr><td><code id="CompareAll-function_+3A_convex">convex</code></td>
<td>
<p>If equal to <code>True</code>, compute the convex hull of the input points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>compareAll(Coordinates, Weights, ...)</code> computes the distances among a given set of spatial histograms.
All the histograms are specified by the <code>M</code> columns of matrix <code>Weights</code>, and where the support points (i.e., centroids of each tile of the map)
are defined by the coordinates given in <code>Xs</code> and <code>Ys</code> in the two columns of matrix <code>Coordinates</code>.
The algorithm used to compute such distance depends on the parameters specified as optional arguments of the function.
</p>
<p>The most important is the parameter <code>L</code>, which by default is equal to 3 (see <code><a href="#topic+compareOneToOne">compareOneToOne</a></code>).
</p>


<h3>Value</h3>

<p>Return an R List with the following named attributes:
</p>

<ul>
<li><p><code>distances</code>: A symmetric matrix of dimension <code>M</code>x<code>M</code> of KW-distances among the input histograms.
</p>
</li>
<li><p><code>status</code>: Status of the solver used to compute the distances.
</p>
</li>
<li><p><code>runtime</code>: Overall runtime in seconds to compute all the distances.
</p>
</li>
<li><p><code>iterations</code>: Overall number of iterations of the Network Simplex algorithm.
</p>
</li>
<li><p><code>nodes</code>: Number of nodes in the network model used to compute the distances.
</p>
</li>
<li><p><code>arcs</code>: Number of arcs in the network model used to compute the distances.
</p>
</li></ul>



<h3>See Also</h3>

<p>See also <code><a href="#topic+compareOneToOne">compareOneToOne</a></code>, <code><a href="#topic+compareOneToMany">compareOneToMany</a></code>, <code><a href="#topic+focusArea">focusArea</a></code>, <code><a href="#topic+Histogram2D">Histogram2D</a></code>, and <code><a href="#topic+Solver">Solver</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple example
library(SpatialKWD)

# Random coordinates
N = 90
Xs &lt;- as.integer(runif(N, 0, 31))
Ys &lt;- as.integer(runif(N, 0, 31))
coordinates &lt;- matrix(c(Xs, Ys), ncol=2, nrow=N)

# Random weights
m &lt;- 3
test3 &lt;- matrix(runif(m*N, 0, 1), ncol=m)

# Compute distance
print("Compare all pairwise distances with an approximate algorithm:")
d &lt;- compareAll(coordinates, Weights=test3, L=3)
cat("L: 3, runtime:", d$runtime, " distances:", "\n")
m &lt;- matrix(d$distance, ncol=3, nrow=3)
print(m)
</code></pre>

<hr>
<h2 id='CompareOneToMany-function'>
Compare a reference spatial histogram to other histograms
</h2><span id='topic+compareOneToMany'></span>

<h3>Description</h3>

<p>This function computes the Kantorovich-Wasserstein among a single reference histogram and a given list of other spatial histograms. All the histograms are defined over the same grid map.
</p>
<p>The grid map is described by the two lists of <code>N</code> coordinates <code>Xs</code> and <code>Ys</code>, which specify the coordinates of the centroid of each tile of the map.
For each tile <code>i</code> with coordinates <code>Xs[i], Ys[i]</code>, we have a positive weight for each histogram.
</p>
<p>The two lists of coordinates are passed to <code>compareOneToMany</code> as a matrix with <code>N</code> rows and two columns.
The weights of the histograms are passed as a single matrix with <code>N</code> rows and <code>M</code> columns, where the first column is the reference histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareOneToMany(Coordinates, Weights, L = 3, recode = TRUE,
           method = "approx",    algorithm = "colgen",
           model="mincostflow",  verbosity = "silent",
           timelimit = 14400,    opt_tolerance = 1e-06,
           unbalanced = FALSE, unbal_cost = 1e+09, convex = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareOneToMany-function_+3A_coordinates">Coordinates</code></td>
<td>
<p>A <code>Matrix</code> with <code>N</code> rows and two columns:
</p>

<ul>
<li><p><code>Coordinates[,1]</code>: <em>(First Column)</em> Vector of horizontal coordinates of the centroids of each tile of the map (<code>Xs</code>). Data type: vector of positive integers.
</p>
</li>
<li><p><code>Coordinates[,2]</code>: <em>(Second Column)</em> Vector of vertical coordinates of the centroids of each tile of the map (<code>Ys</code>). Data type: vector of positive integers.
</p>
</li></ul>

</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_weights">Weights</code></td>
<td>
<p>A <code>Matrix</code> of positive weights of the tiles specified by <code>Coordinates</code>.
</p>

<ul>
<li><p><code>Weights[,1]</code>: <em>(First Column)</em> Weights of the reference spatial histogram, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. Data type: vector of positive doubles.
</p>
</li>
<li><p><code>Weights[,2:M]</code>: <em>(Remaining Columns)</em> Weights of the spatial histograms to be compared with the reference histogram. Data type: vector of positive doubles.
</p>
</li></ul>

</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_l">L</code></td>
<td>
<p>Approximation parameter.
Higher values of <em>L</em> give a more accurate solution, but they require a longer running time. Data type: positive integer.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_recode">recode</code></td>
<td>
<p>If equal to <code>True</code>, recode the input coordinates as consecutive integers.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_method">method</code></td>
<td>
<p>Method for computing the KW distances: <code>exact</code> or <code>approx</code>.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm for computing the KW distances: <code>fullmodel</code> or <code>colgen</code>.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_model">model</code></td>
<td>
<p>Model for building the underlying network: <code>bipartite</code> or <code>mincostflow</code>.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_verbosity">verbosity</code></td>
<td>
<p>Level of verbosity of the log: <code>silent</code>, <code>info</code>, or <code>debug</code>.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_timelimit">timelimit</code></td>
<td>
<p>Time limit in second for running the solver.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_opt_tolerance">opt_tolerance</code></td>
<td>
<p>Numerical tolerance on the negative reduced cost for the optimal solution.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_unbalanced">unbalanced</code></td>
<td>
<p>If equal to <code>True</code>, solve the problem with unbalanced masses.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_unbal_cost">unbal_cost</code></td>
<td>
<p>Cost for the arcs going from each point to the extra artificial bin.</p>
</td></tr>
<tr><td><code id="CompareOneToMany-function_+3A_convex">convex</code></td>
<td>
<p>If equal to <code>True</code>, compute the convex hull of the input points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>compareOneToMany(Coordinates, Weights, ...)</code> computes the distances among a reference spatial histogram and a given set of other histograms.
All the histograms are specified by the <code>M</code> columns of matrix <code>Weights</code>, and where the support points (i.e., centroids of each tile of the map)
are defined by the coordinates given in <code>Xs</code> and <code>Ys</code> in the two columns of matrix <code>Coordinates</code>.
The algorithm used to compute such distance depends on the parameters specified as optional arguments of the function.
</p>
<p>The most important is the parameter <code>L</code>, which by default is equal to 3 (see <code><a href="#topic+compareOneToOne">compareOneToOne</a></code>).
</p>


<h3>Value</h3>

<p>Return an R List with the following named attributes:
</p>

<ul>
<li><p><code>distances</code>: An array of <code>M-1</code> KW-distances among the input histograms.
</p>
</li>
<li><p><code>status</code>: Status of the solver used to compute the distances.
</p>
</li>
<li><p><code>runtime</code>: Overall runtime in seconds to compute all the distances.
</p>
</li>
<li><p><code>iterations</code>: Overall number of iterations of the Network Simplex algorithm.
</p>
</li>
<li><p><code>nodes</code>: Number of nodes in the network model used to compute the distances.
</p>
</li>
<li><p><code>arcs</code>: Number of arcs in the network model used to compute the distances.
</p>
</li></ul>



<h3>See Also</h3>

<p>See also <code><a href="#topic+compareOneToOne">compareOneToOne</a></code>, <code><a href="#topic+compareAll">compareAll</a></code>, <code><a href="#topic+focusArea">focusArea</a></code>, <code><a href="#topic+Histogram2D">Histogram2D</a></code>, and <code><a href="#topic+Solver">Solver</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple example
library(SpatialKWD)

# Random coordinates
N = 90
Xs &lt;- as.integer(runif(N, 0, 31))
Ys &lt;- as.integer(runif(N, 0, 31))
coordinates &lt;- matrix(c(Xs, Ys), ncol=2, nrow=N)

# Random weights
m &lt;- 3
test2 &lt;- matrix(runif((m+1)*N, 0, 1), ncol=(m+1))

# Compute distance
print("Compare one-to-many with approximate algorithm:")
d &lt;- compareOneToMany(coordinates, Weights=test2, L=3, method="approx")
cat("L: 3, runtime:", d$runtime, " distances:", d$distance, "\n")
</code></pre>

<hr>
<h2 id='CompareOneToOne-function'>
Compare a pair of spatial histograms
</h2><span id='topic+compareOneToOne'></span>

<h3>Description</h3>

<p>This function computes the Kantorovich-Wasserstein between a pair of spatial histograms defined over the same grid map.
</p>
<p>The grid map is described by the two lists of <code>N</code> coordinates <code>Xs</code> and <code>Ys</code>, which specify the coordinates of the centroid of each tile of the map.
For each tile <code>i</code> with coordinates <code>Xs[i], Ys[i]</code>, we have the two lists of weights, one for the first histograms and the other for the second histogram.
</p>
<p>The two lists of coordinates are passed to <code>compareOneToOne</code> as a matrix with <code>N</code> rows and two columns.
The two lists of weights are passed as a matrix with <code>N</code> rows and two columns, a column for each histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareOneToOne(Coordinates, Weights, L = 3, recode = TRUE,
           method = "approx",    algorithm = "colgen",
           model="mincostflow",  verbosity = "silent",
           timelimit = 14400,    opt_tolerance = 1e-06,
           unbalanced = FALSE, unbal_cost = 1e+09, convex = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareOneToOne-function_+3A_coordinates">Coordinates</code></td>
<td>
<p>A <code>Matrix</code> with <code>N</code> rows and two columns:
</p>

<ul>
<li><p><code>Coordinates[,1]</code>: <em>(First Column)</em> Vector of horizontal coordinates of the centroids of each tile of the map (<code>Xs</code>). Data type: vector of positive integers.
</p>
</li>
<li><p><code>Coordinates[,2]</code>: <em>(Second Column)</em> Vector of vertical coordinates of the centroids of each tile of the map (<code>Ys</code>). Data type: vector of positive integers.
</p>
</li></ul>

</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_weights">Weights</code></td>
<td>
<p>A <code>Matrix</code> of positive weights of the tiles specified by <code>Coordinates</code>.
</p>

<ul>
<li><p><code>Weights[,1]</code>: <em>(First Column)</em> Weights of the first spatial histogram, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. Data type: vector of positive doubles.
</p>
</li>
<li><p><code>Weights[,2]</code>: <em>(Second Column)</em> Weights of the second spatial histogram, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. Data type: vector of positive doubles.
</p>
</li></ul>

</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_l">L</code></td>
<td>
<p>Approximation parameter.
Higher values of <em>L</em> give a more accurate solution, but they require a longer running time. Data type: positive integer.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_recode">recode</code></td>
<td>
<p>If equal to <code>True</code>, recode the input coordinates as consecutive integers.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_method">method</code></td>
<td>
<p>Method for computing the KW distances: <code>exact</code> or <code>approx</code>.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm for computing the KW distances: <code>fullmodel</code> or <code>colgen</code>.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_model">model</code></td>
<td>
<p>Model for building the underlying network: <code>bipartite</code> or <code>mincostflow</code>.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_verbosity">verbosity</code></td>
<td>
<p>Level of verbosity of the log: <code>silent</code>, <code>info</code>, or <code>debug</code>.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_timelimit">timelimit</code></td>
<td>
<p>Time limit in second for running the solver.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_opt_tolerance">opt_tolerance</code></td>
<td>
<p>Numerical tolerance on the negative reduced cost for the optimal solution.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_unbalanced">unbalanced</code></td>
<td>
<p>If equal to <code>True</code>, solve the problem with unbalanced masses.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_unbal_cost">unbal_cost</code></td>
<td>
<p>Cost for the arcs going from each point to the extra artificial bin.</p>
</td></tr>
<tr><td><code id="CompareOneToOne-function_+3A_convex">convex</code></td>
<td>
<p>If equal to <code>True</code>, compute the convex hull of the input points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>compareOneToOne(Coordinates, Weights, ...)</code> computes the distance between the two histograms specified by the weights given in the two columns of matrix <code>Weights</code>. 
The support points (i.e., centroids of each tile of the map) are defined by the coordinates given in <code>Xs</code> and <code>Ys</code> in the two columns of matrix <code>Coordinates</code>. 
The algorithm used to compute such distance depends on the parameters specified as optional arguments of the function.
</p>
<p>The most important is the parameter <code>L</code>, which by default is equal to 3. The following table shows the worst-case approximation ratio as a function of the value assigned to <code>L</code>.
The table also reports the number of arcs in the network flow model as a function of the number of bins <em>n</em> contained in the convex hull of the support points of the histograms given in input with matrix <code>Coordinates</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>L</b> </td><td style="text-align: left;"> <b>1</b> </td><td style="text-align: left;"> <b>2</b> </td><td style="text-align: left;"> <b>3</b> </td><td style="text-align: left;"> <b>5</b> </td><td style="text-align: left;"> <b>10</b></td><td style="text-align: left;"> <b>15</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Worst-case error</code>  </td><td style="text-align: left;"> 7.61% </td><td style="text-align: left;">  2.68% </td><td style="text-align: left;">  1.29% </td><td style="text-align: left;"> 0.49%  </td><td style="text-align: left;"> 0.12%  </td><td style="text-align: left;">   0.06%  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Number of arcs</code> </td><td style="text-align: left;"> <em>O(8n)</em> </td><td style="text-align: left;"> <em>O(16n)</em> </td><td style="text-align: left;"> <em>O(32n)</em>  </td><td style="text-align: left;"> <em>O(80n)</em> </td><td style="text-align: left;"> <em>O(256n)</em> </td><td style="text-align: left;"> <em>O(576n)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>The following two figures show the network build on a grid with 8x8 nodes and using <em>L=2</em> and <em>L=3</em>.
</p>
<p><img src="../help/figures/figL2.png" width="35%" alt="L=2" />
</p>
<p><img src="../help/figures/figL3.png" width="35%" alt="L=3" />
</p>




<h3>Value</h3>

<p>Return an R List with the following named attributes:
</p>

<ul>
<li><p><code>distance</code>: The value of the KW-distance between the two input histograms.
</p>
</li>
<li><p><code>status</code>: Status of the solver used to compute the distances.
</p>
</li>
<li><p><code>runtime</code>: Overall runtime in seconds to compute all the distances.
</p>
</li>
<li><p><code>iterations</code>: Overall number of iterations of the Network Simplex algorithm.
</p>
</li>
<li><p><code>nodes</code>: Number of nodes in the network model used to compute the distances.
</p>
</li>
<li><p><code>arcs</code>: Number of arcs in the network model used to compute the distances.
</p>
</li></ul>



<h3>See Also</h3>

<p>See also <code><a href="#topic+compareOneToMany">compareOneToMany</a></code>, <code><a href="#topic+compareAll">compareAll</a></code>, <code><a href="#topic+focusArea">focusArea</a></code>, <code><a href="#topic+Histogram2D">Histogram2D</a></code>, and <code><a href="#topic+Solver">Solver</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple example
library(SpatialKWD)

# Random coordinates
N = 90
Xs &lt;- as.integer(runif(N, 0, 31))
Ys &lt;- as.integer(runif(N, 0, 31))
coordinates &lt;- matrix(c(Xs, Ys), ncol=2, nrow=N)

# Random weights
test1 &lt;- matrix(runif(2*N, 0, 1), ncol=2, nrow=N)

# Compute distance
print("Compare one-to-one with exact algorithm:")
d &lt;- compareOneToOne(coordinates, Weights=test1, method="exact",
                     recode=TRUE, verbosity = "info")
cat("runtime:", d$runtime, " distance:", d$distance,
    " nodes:", d$nodes, " arcs:", d$arcs, "\n")

print("Compare one-to-one with approximate algorithm:")
d &lt;- compareOneToOne(coordinates, Weights=test1, L=2, recode=TRUE)
cat("L: 2, runtime:", d$runtime, " distance:", d$distance,
    " nodes:", d$nodes, " arcs:", d$arcs, "\n")

d &lt;- compareOneToOne(coordinates, Weights=test1, L=3)
cat("L: 3 runtime:", d$runtime, " distance:", d$distance, "\n")

d &lt;- compareOneToOne(coordinates, Weights=test1, L=10)
cat("L: 10, runtime:", d$runtime, " distance:", d$distance, "\n")
</code></pre>

<hr>
<h2 id='FocusArea-function'>
Compute the KWD tranport distance within a given focus area
</h2><span id='topic+focusArea'></span>

<h3>Description</h3>

<p>This function computes the Kantorovich-Wasserstein distance within a given focus area embedded into a large region described as a grid map.
Both the focus and the embedding areas are are described by spatial histograms, similarly to the input data of the other functions of this package.
</p>
<p>The grid map is described by the two lists <code>Xs</code> and <code>Ys</code> of <code>N</code> coordinates, which specify the coordinates of the centroid of every single tile.
For each tile <code>i</code> with coordinates <code>Xs[i], Ys[i]</code>, we have an entry in the two lists of weights <code>W1</code> and <code>W2</code>, one for the first histograms, and the other for the second histogram.
</p>
<p>The two lists of coordinates <code>Xs</code> and <code>Ys</code> are passed to the <code>focusArea</code> function as a matrix with <code>N</code> rows and two columns.
The two lists of weights <code>W1</code> and <code>W2</code> are passed as a matrix with <code>N</code> rows and two columns, a column for each histogram.
</p>
<p>The focus area is specified by three parameters: the coordinates <code>x</code> and <code>y</code> of the center of the focus area, and the (circular) <code>radius</code> of the focus area.
The pair of coordinates (<code>x,y</code>) must correspond to a pair of coordinates contained in the vectors <code>Xs,Ys</code>.
Every tile whose distance is less or equal to the <code>radius</code> will be included in the focus area.
</p>
<p>The focus area by default is circular, that is, the area is based on a <em>L_2</em> norm. By setting the parameter <code>area</code> to the value <code>linf</code> it is possible to obtain
a squared focus area, induced by the norm <em>L_infinity</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focusArea(Coordinates, Weights, x, y, radius,
           L = 3, recode = TRUE,
           method = "approx",    algorithm = "colgen",
           model="mincostflow",  verbosity = "silent",
           timelimit = 14400,    opt_tolerance = 1e-06,
           area = "l2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FocusArea-function_+3A_coordinates">Coordinates</code></td>
<td>
<p>A <code>Matrix</code> with <code>N</code> rows and two columns:
</p>

<ul>
<li><p><code>Coordinates[,1]</code>: <em>(First Column)</em> Vector of horizontal coordinates of the centroids of each tile of the map (<code>Xs</code>). Data type: vector of positive integers.
</p>
</li>
<li><p><code>Coordinates[,2]</code>: <em>(Second Column)</em> Vector of vertical coordinates of the centroids of each tile of the map (<code>Ys</code>). Data type: vector of positive integers.
</p>
</li></ul>

</td></tr>
<tr><td><code id="FocusArea-function_+3A_weights">Weights</code></td>
<td>
<p>A <code>Matrix</code> of positive weights of the tiles specified by <code>Coordinates</code>.
</p>

<ul>
<li><p><code>Weights[,1]</code>: <em>(First Column)</em> Weights of the embedding spatial histogram, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. Data type: vector of positive doubles.
</p>
</li>
<li><p><code>Weights[,2]</code>: <em>(Second Column)</em> Weights of the spatial histogram of the focus area, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. All the weights outside the focus area should be equal to zero. Data type: vector of positive doubles.
</p>
</li></ul>

</td></tr>
<tr><td><code id="FocusArea-function_+3A_x">x</code></td>
<td>
<p>Horizontal coordinate of the centroid of the focus area.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_y">y</code></td>
<td>
<p>Vertical coordinate of the centroid of the focus area.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_radius">radius</code></td>
<td>
<p>The radius of the focus area.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_l">L</code></td>
<td>
<p>Approximation parameter.
Higher values of <em>L</em> give a more accurate solution, but they require a longer running time. Data type: positive integer.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_recode">recode</code></td>
<td>
<p>If equal to <code>True</code>, recode the input coordinates as consecutive integers.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_method">method</code></td>
<td>
<p>Method for computing the KW distances: <code>exact</code> or <code>approx</code>.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm for computing the KW distances: <code>fullmodel</code> or <code>colgen</code>.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_model">model</code></td>
<td>
<p>Model for building the underlying network: <code>bipartite</code> or <code>mincostflow</code>.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_verbosity">verbosity</code></td>
<td>
<p>Level of verbosity of the log: <code>silent</code>, <code>info</code>, or <code>debug</code>.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_timelimit">timelimit</code></td>
<td>
<p>Time limit in second for running the solver.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_opt_tolerance">opt_tolerance</code></td>
<td>
<p>Numerical tolerance on the negative reduced cost for the optimal solution.</p>
</td></tr>
<tr><td><code id="FocusArea-function_+3A_area">area</code></td>
<td>
<p>Type of norm for delimiting the focus area: <code>l2</code> denotes a circular area of radius, <code>linf</code> denotes a squared area.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>focusArea(Coordinates, Weights, x, y, radius, ...)</code> computes the KW distance within a focus area by implicitly considering the surrounding larger area.
The mass contained within the focus area is transported to a destination either within or outside the focus area.
All the mass contained outside the focus area could be used to balance the mass within the focus area.
</p>


<h3>Value</h3>

<p>Return an R List with the following named attributes:
</p>

<ul>
<li><p><code>distance</code>: The value of the KW-distance between the two input areas.
</p>
</li>
<li><p><code>status</code>: Status of the solver used to compute the distances.
</p>
</li>
<li><p><code>runtime</code>: Overall runtime in seconds to compute all the distances.
</p>
</li>
<li><p><code>iterations</code>: Overall number of iterations of the Capacitated Network Simplex algorithm.
</p>
</li>
<li><p><code>nodes</code>: Number of nodes in the network model used to compute the distances.
</p>
</li>
<li><p><code>arcs</code>: Number of arcs in the network model used to compute the distances.
</p>
</li></ul>



<h3>See Also</h3>

<p>See also <code><a href="#topic+compareOneToOne">compareOneToOne</a></code>, <code><a href="#topic+compareOneToMany">compareOneToMany</a></code>, <code><a href="#topic+compareAll">compareAll</a></code>, <code><a href="#topic+Histogram2D">Histogram2D</a></code>, and <code><a href="#topic+Solver">Solver</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple example
library(SpatialKWD)

# Random coordinates
N = 90
Xs &lt;- as.integer(runif(N, 0, 31))
Ys &lt;- as.integer(runif(N, 0, 31))
coordinates &lt;- matrix(c(Xs, Ys), ncol=2, nrow=N)

# Random weights
test1 &lt;- matrix(runif(2*N, 0, 1), ncol=2, nrow=N)

# Compute distance
print("Compare one-to-one with exact algorithm:")
d &lt;- focusArea(coordinates, Weights=test1,
                x=15, y=15, radius=5,
                method="exact", recode=TRUE, verbosity = "info")
cat("runtime:", d$runtime, " distance:", d$distance,
    " nodes:", d$nodes, " arcs:", d$arcs, "\n")
</code></pre>

<hr>
<h2 id='Histogram2D-class'>
Two Dimensional Histogram for Spatial Data
</h2><span id='topic+Rcpp_Histogram2D-class'></span><span id='topic+Histogram2D'></span><span id='topic+Rcpp_Histogram2D'></span>

<h3>Description</h3>

<p>The <code>Histogram2D</code> class represents a single spatial 2-dimensional histograms. The class is mainly composed of three vectors of the same length <code>n</code>. The first two vectors of integers, called <code>Xs</code> and <code>Ys</code>, give the coordinates of each bin of the histogram, while the third
vector of doubles, called <code>Ws</code>, gives the weight <code>Ws[i]</code> of the <em>i</em>-th bin located at position <code>Xs[i]</code> and <code>Ys[i]</code>.
</p>
<p>A 2D histogram can be also defined by adding (or updating) a single element a the time (see the second constructor).
</p>
<p>Note that the positions of the bins are not required to lay on rectangular (or squared) grid, but they can lay everywhere in the plane. 
Before computing the distance between a pair of algorithms, the solver will compute a convex hull of all non-empty bins.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Histogram2D-class_+3A_n">n</code></td>
<td>
<p>Number of non-empty bins. Type: positive integer.</p>
</td></tr>
<tr><td><code id="Histogram2D-class_+3A_xs">Xs</code></td>
<td>
<p>Vector of horizontal coordinates the bins. Type: vector of integers.</p>
</td></tr>
<tr><td><code id="Histogram2D-class_+3A_ys">Ys</code></td>
<td>
<p>Vector of vertical coordinates the bins. Type: vector of integers.</p>
</td></tr>
<tr><td><code id="Histogram2D-class_+3A_ws">Ws</code></td>
<td>
<p>Vector of positive weights of the bin at position <em>(x,y)</em>. Type: vector of positive doubles.</p>
</td></tr>
<tr><td><code id="Histogram2D-class_+3A_x">x</code></td>
<td>
<p>Horizontal coordinate of a bin. Type: integer.</p>
</td></tr>
<tr><td><code id="Histogram2D-class_+3A_y">y</code></td>
<td>
<p>Vertical coordinate of a bin. Type: integer.</p>
</td></tr>
<tr><td><code id="Histogram2D-class_+3A_w">w</code></td>
<td>
<p>Weight of the bin at position <em>(x,y)</em>. Type: positive double.</p>
</td></tr>
<tr><td><code id="Histogram2D-class_+3A_u">u</code></td>
<td>
<p>Weight of the bin to be added to the weight at position <em>(x,y)</em>. If a bin in position <em>(x,y)</em> is absent, then it is added with weight equal to <code>u</code>. Type: positive double.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The public methods of the <code>Histogram2D</code> class are described below.
</p>


<h3>Value</h3>

<p>The <code>add</code>, <code>update</code>, and <code>normalize</code> does not return any value.
</p>
<p>The <code>size</code> method returns the number of non-empty bins in <code>h</code>.
</p>
<p>The <code>balance</code> method returns the sum of the weights in <code>h</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>Histogram2D(n, Xs, Ys, Ws)</code>:</dt><dd><p> c'tor. </p>
</dd>
<dt><code>add(x, y, w)</code>:</dt><dd><p>it adds a bin located at position <em>(x,y)</em> with weight <em>w</em>. </p>
</dd>
<dt><code>update(x, y, u)</code>:</dt><dd><p> return the total mass balance of this histogram, that is, return the quantity <code class="reqn">\sum_{i=1,\dots,n} w_i</code>. </p>
</dd>
<dt><code>size()</code>:</dt><dd><p>return the number of non-empty bins <em>n</em> of this histogram. </p>
</dd>
<dt><code>normalize()</code>:</dt><dd><p> normalize the weights of all non-empty bins, such that they all sum up to 1. Indeed, this method implements the operation: <code class="reqn">w_i \gets \frac{w_i}{\sum_{i=1,\dots,n} w_i}</code>. </p>
</dd>
<dt><code>balance()</code>:</dt><dd><p> return the total mass balance of this histogram, that is, return the quantity <code class="reqn">\sum_{i=1,\dots,n} w_i</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See also <code><a href="#topic+compareOneToOne">compareOneToOne</a></code>, <code><a href="#topic+compareOneToMany">compareOneToMany</a></code>, <code><a href="#topic+compareAll">compareAll</a></code>,  <code><a href="#topic+focusArea">focusArea</a></code>, and <code><a href="#topic+Solver">Solver</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SpatialKWD)

# Define a simple histogram
h &lt;- new(Histogram2D)

# Add half unit of mass at positions (1,0) and (0,1)
h$add(1, 0, 0.5)
h$add(0, 1, 0.5)

# Add at position (5,5) a unit of mass
h$add(5, 5, 1)

# Normalize the histogram
h$normalize()

# Print the total weight (mass) of the histogram
print(sprintf("Histogram total weight = %f", h$balance()))
</code></pre>

<hr>
<h2 id='Solver-class'>
Spatial-KWD Solver
</h2><span id='topic+Solver'></span><span id='topic+Rcpp_Solver-class'></span>

<h3>Description</h3>

<p>The <code>Solver</code> class is the main wrapper to the core algorithms implemented in the Spatial KWD package.
It has several methods that permit to compare two, or more, objects of type <code>Histogram2D</code>.
If you use the helper functions described at the begging of this document, you can avoid using this class directly
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Solver-class_+3A_n">n</code></td>
<td>
<p>Number of bins in the histograms <code>Xs, Yw, W1, W2, Ws</code>.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_h1">H1</code></td>
<td>
<p>First object of type <code>Histogram2D</code>.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_h2">H2</code></td>
<td>
<p>Second object of type <code>Histogram2D</code>.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_l">L</code></td>
<td>
<p>Approximation parameter. Higher values of <em>L</em> give a more accurate solution, but they require a longer running time.
Table X gives the guarantee approximation bound as a function of <em>L</em>. Type: positive integer.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_xs">Xs</code></td>
<td>
<p>Vector of horizontal coordinates the bins. Type: vector of integers.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_ys">Ys</code></td>
<td>
<p>Vector of vertical coordinates the bins. Type: vector of integers.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_w1">W1</code></td>
<td>
<p>Vector of weights of the bin at the positions specified by <code>Xs</code> and <code>Ys</code>. Type: vector of doubles.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_w2">W2</code></td>
<td>
<p>Vector of weights of the bin at the positions specified by <code>Xs</code> and <code>Ys</code>. Type: vector of doubles.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_ws">Ws</code></td>
<td>
<p>Matrix of weights of the bin at the positions specified by <code>Xs</code> and <code>Ys</code>. Type: matrix of doubles.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_name">name</code></td>
<td>
<p>Name of the parameter to set and/or get. Type: string.</p>
</td></tr>
<tr><td><code id="Solver-class_+3A_value">value</code></td>
<td>
<p>Value to set the corresponding parameter specified by <code>name</code>. Type: double.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The public methods of this class are:
</p>
<p>The <code>Solver</code> class can be controlled by the list of parameters given in the following table, which can be set with the <code>setParam(name, value)</code> method. A detailed description of each parameter is given below.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>Parameter Name</b> </td><td style="text-align: left;"> <b>Possible Values</b> </td><td style="text-align: left;"> <b>Default Value</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Method</code>  </td><td style="text-align: left;"> <code>exact, approx</code> </td><td style="text-align: left;"> <code>approx</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Model</code>  </td><td style="text-align: left;"> <code>bipartite, mincostflow</code> </td><td style="text-align: left;"> <code>mincostflow</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Algorithm</code> </td><td style="text-align: left;"> <code>fullmodel, colgen</code> </td><td style="text-align: left;"> <code>colgen</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Verbosity</code>    </td><td style="text-align: left;"> <code>silent, info, debug</code> </td><td style="text-align: left;"> <code>info</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>TimeLimit</code>    </td><td style="text-align: left;"> Any positive integer smaller than <code>INTMAX</code> </td><td style="text-align: left;"> <code>INTMAX</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>OptTolerance</code> </td><td style="text-align: left;"> Any value in <code class="reqn">[10^{-9}, 10^{-1}]</code> </td><td style="text-align: left;"> <code class="reqn">10^{-6}</code>
    </td>
</tr>

</table>


<ul>
<li> <p><code>Method</code>: set which method to use for computing the exact distance between a pair of histograms. The options for this parameter are:
</p>

<ul>
<li> <p><code>exact</code>: Compute the exact KW distance. This method is only helpful for small and sparse spatial maps.
</p>
</li>
<li> <p><code>approx</code>: Compute an approximation KW distance which depends on the parameter <em>L</em>. This is the default value.
</p>
</li></ul>

</li>
<li> <p><code>Model</code>: set which network model to use for computing the exact distance between a pair of histograms. The options for this parameter are:
</p>

<ul>
<li> <p><code>bipartite</code>: Build a complete bipartite graph. This method is only helpful for small and sparse spatial maps.
</p>
</li>
<li> <p><code>mincostflow</code>: Build an uncapacitated network flow. This is, in general, smaller than the <code>bipartite</code> model, except for very sparse histograms.
</p>
</li></ul>

</li>
<li> <p><code>Algorithm</code>: set which algorithm to use to compute an approximate distance between a pair of histograms, which depends on the parameter <em>L</em>. The options for this parameter are:
</p>

<ul>
<li> <p><code>fullmodel</code>: Build a complete network model and solve the corresponding problem.
</p>
</li>
<li> <p><code>colgen</code>: Build the network model incrementally while computing the KW distance. It is the recommended method for very large dense spatial maps. On medium and small spatial maps, the fullmodel could be faster.
</p>
</li></ul>

<p>The default value is set to <code>colgen</code>.
</p>
</li>
<li> <p><code>Verbosity</code>: set the level of verbosity of the logs. Possible values are <code>silent</code>, <code>info</code>, <code>debug</code>. The last is more verbose than the other two.
The default value is set to <code>info</code>.
</p>
</li>
<li> <p><code>TimeLimit</code>: set the time limit for computing the distance between a pair of spatial maps. Min values: <code>INTMAX</code>.
The default value is set to <code>INTMAX</code>.
</p>
</li>
<li> <p><code>OptTolerance</code>: Optimality tolerance on negative reduced cost variables to enter the basis.
Min value: <code class="reqn">10^{-9}</code>, max value: <code class="reqn">10^{-1}</code>.
The default value is set to <code class="reqn">10^{-6}</code>.
</p>
</li></ul>



<h3>Methods</h3>


<dl>
<dt><code>compareExact(Xs, Ys, W1, W2)</code>:</dt><dd><p>compute the exact distance between the two vector of weights <code>W1</code> and <code>W2</code>, on the convex hull of the points defined by the two vectors <code>Xs</code> and <code>Ys</code>.
The algorithm used by the solver is controlled by the parameter <code>ExactMethod</code> (see below).
This method returns a single value (double), which is the KW-distance between <code>W1</code> and <code>W2</code>.</p>
</dd>
<dt><code>compareExact(Xs, Ys, W1, Ws)</code>:</dt><dd><p>compute the exact distances between the vector of weights <code>W1</code> and each of the vector of weights in <code>Ws</code>, on the convex hull of the points defined by the two vectors <code>Xs</code> and <code>Ys</code>.
The algorithm used by the solver is controlled by the parameter <code>ExactMethod</code> (see below).
This method returns a vector of double of the same size of <code>Ws</code>, representing the distance of <code>W1</code> to every element of <code>Ws</code>.</p>
</dd>
<dt><code>compareExact(Xs, Ys, Ws)</code>:</dt><dd><p>compute a symmetric matrix of pairwise exact distances between all the possible pairs of the vector listed in <code>Ws</code>.
The algorithm used by the solver is controlled by the parameter <code>ExactMethod</code> (see below).</p>
</dd>
<dt><code>compareApprox(Xs, Ys, W1, W2, L)</code>:</dt><dd><p>compute the approximate distance between the two vector of weights <code>W1</code> and <code>W2</code>, on the convex hull of the points defined by the two vectors <code>Xs</code> and <code>Ys</code>.
The parameter <code>ApproxMethod</code> (see below) controls the algorithm used by the solver.
This method returns a single value (double), which is the KW-distance between <code>W1</code> and <code>W2</code>.</p>
</dd>
<dt><code>compareApprox(Xs, Ys, W1, Ws, L)</code>:</dt><dd><p>compute the approximate distances between the vector of weights <code>W1</code> and each of the vector of weights in <code>Ws</code>, on the convex hull of the points defined by the two vectors <code>Xs</code> and <code>Ys</code>.
The parameter <code>ApproxMethod</code> (see below) controls the algorithm used by the solver.
This method returns a vector of double of the same size of <code>Ws</code>, representing the distance of <code>W1</code> to every element of <code>Ws</code>.</p>
</dd>
<dt><code>compareApprox(Xs, Ys, Ws, L)</code>:</dt><dd><p>compute a symmetric matrix of pairwise approximate distances (which depends on the value of <em>L</em>) between all the possible pairs of the vector listed in <code>Ws</code>.
The parameter <code>ApproxMethod</code> (see below) controls the algorithm used by the solver.
</p>
</dd>
<dt><code>runtime()</code>:</dt><dd><p>return the runtime in seconds to the last call to one of the <em>compare</em> methods. It reports the runtime of the execution of the Network Simplex algorithm.</p>
</dd>
<dt><code>preprocesstime()</code>:</dt><dd><p>return the preprocessing time in seconds to the last call to one of the <em>compare</em> methods. It reports the execution time to set up the main data structures and to compute the convex hull of all the input histograms.</p>
</dd>
<dt><code>setParam(name, value)</code>:</dt><dd><p>set the parameter <code>name</code> to the new <code>value</code>. Every parameter has a default value. See below for the existing parameters.</p>
</dd>
<dt><code>getParam(name)</code>:</dt><dd><p>return the current value of the parameter <code>name</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See also <code><a href="#topic+compareOneToOne">compareOneToOne</a></code>, <code><a href="#topic+compareOneToMany">compareOneToMany</a></code>, <code><a href="#topic+compareAll">compareAll</a></code>, <code><a href="#topic+focusArea">focusArea</a></code>, and <code><a href="#topic+Histogram2D">Histogram2D</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
