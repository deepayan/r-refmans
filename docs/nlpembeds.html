<!DOCTYPE html><html lang="en"><head><title>Help for package nlpembeds</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nlpembeds}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe</p></a></li>
<li><a href='#+25+26lt+3B+26gt+3B+25'><p>Assignment pipe</p></a></li>
<li><a href='#+25+24+25'><p>Exposition pipe</p></a></li>
<li><a href='#build_df_cooc'><p>Compute monthly co-occurrence matrix</p></a></li>
<li><a href='#build_spm_cooc_sym'><p>Build symmetric sparse matrix from data frame</p></a></li>
<li><a href='#get_pmi'><p>Compute pointwise mutual information (PMI)</p></a></li>
<li><a href='#get_svd'><p>Compute random singular value decomposition (rSVD)</p></a></li>
<li><a href='#spm_to_df'><p>Write sparse matrix to dataframe</p></a></li>
<li><a href='#sql_cooc'><p>Compute co-occurrence matrix on SQL file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Natural Language Processing Embeddings</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides efficient methods to compute co-occurrence matrices, pointwise mutual information (PMI) and singular value decomposition (SVD). In the biomedical and clinical settings, one challenge is the huge size of databases, e.g. when analyzing data of millions of patients over tens of years. To address this, this package provides functions to efficiently compute monthly co-occurrence matrices, which is the computational bottleneck of the analysis, by using the 'RcppAlgos' package and sparse matrices. Furthermore, the functions can be called on 'SQL' databases, enabling the computation of co-occurrence matrices of tens of gigabytes of data, representing millions of patients over tens of years. Partly based on Hong C. (2021) &lt;<a href="https://doi.org/10.1038%2Fs41746-021-00519-z">doi:10.1038/s41746-021-00519-z</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, magrittr, Matrix, methods, parallel, RcppAlgos,
reshape2, RSQLite, rsvd</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/thomaschln/nlpembeds">https://gitlab.com/thomaschln/nlpembeds</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/thomaschln/nlpembeds/-/issues">https://gitlab.com/thomaschln/nlpembeds/-/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-03 20:02:33 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Charlon <a href="https://orcid.org/0000-0001-7497-0470"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Doudou Zhou <a href="https://orcid.org/0000-0002-0830-2287"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  CELEHS [aut] (&lt;https://celehs.hms.harvard.edu&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Charlon &lt;charlon@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-04 08:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe an object forward into a function or call expression.
Magrittr imported function, see details and examples in the magrittr package.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of rhs applied to lhs, see details in magrittr package.
</p>

<hr>
<h2 id='+25+26lt+3B+26gt+3B+25'>Assignment pipe</h2><span id='topic++25+3C+3E+25'></span>

<h3>Description</h3>

<p>Pipe an object forward into a function or call expression and update the
'lhs' object with the resulting value.
Magrittr imported function, see details and examples in the magrittr package.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26lt+2B3B+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>An object which serves both as the initial value and as target.</p>
</td></tr>
<tr><td><code id="+2B25+2B26lt+2B3B+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>a function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, used to update the value of lhs.
</p>

<hr>
<h2 id='+25+24+25'>Exposition pipe</h2><span id='topic++25+24+25'></span>

<h3>Description</h3>

<p>Expose the names in 'lhs' to the 'rhs' expression.
Magrittr imported function, see details and examples in the magrittr package.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B24+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A list, environment, or a data.frame.</p>
</td></tr>
<tr><td><code id="+2B25+2B24+2B25_+3A_rhs">rhs</code></td>
<td>
<p>An expression where the names in lhs is available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of rhs applied to one or several names of lhs.
</p>

<hr>
<h2 id='build_df_cooc'>Compute monthly co-occurrence matrix</h2><span id='topic+build_df_cooc'></span>

<h3>Description</h3>

<p>Compute monthly co-occurrence matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_df_cooc(
  df_ehr,
  uniq_codes = NULL,
  n_cores = 1,
  min_code_freq = 5,
  gc_before_parallel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_df_cooc_+3A_df_ehr">df_ehr</code></td>
<td>
<p>Input data frame, monthly counts with columns Patient, Month,
Parent_Code, Count</p>
</td></tr>
<tr><td><code id="build_df_cooc_+3A_uniq_codes">uniq_codes</code></td>
<td>
<p>Not required, useful for sql_cooc function</p>
</td></tr>
<tr><td><code id="build_df_cooc_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores</p>
</td></tr>
<tr><td><code id="build_df_cooc_+3A_min_code_freq">min_code_freq</code></td>
<td>
<p>Filter matrix based on feature frequency</p>
</td></tr>
<tr><td><code id="build_df_cooc_+3A_gc_before_parallel">gc_before_parallel</code></td>
<td>
<p>Call garbage collector before computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Co-occurrence sparse matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df_ehr = data.frame(Month = c(1, 1, 1, 2, 2, 3, 3, 4, 4),
                    Patient = c(1, 1, 2, 1, 2, 1, 1, 3, 4),
                    Parent_Code = c('C1', 'C2', 'C2', 'C1', 'C1', 'C1', 'C2',
                                    'C3', 'C4'),
                    Count = 1:9)

spm_cooc = build_df_cooc(df_ehr)

</code></pre>

<hr>
<h2 id='build_spm_cooc_sym'>Build symmetric sparse matrix from data frame</h2><span id='topic+build_spm_cooc_sym'></span>

<h3>Description</h3>

<p>Build symmetric sparse matrix from data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_spm_cooc_sym(df_cooc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_spm_cooc_sym_+3A_df_cooc">df_cooc</code></td>
<td>
<p>Symmetric sparse matrix in data frame format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix::sparseMatrix object, symmetric sparse matrix
</p>

<hr>
<h2 id='get_pmi'>Compute pointwise mutual information (PMI)</h2><span id='topic+get_pmi'></span>

<h3>Description</h3>

<p>Compute pointwise mutual information (PMI)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pmi(spm_cooc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_pmi_+3A_spm_cooc">spm_cooc</code></td>
<td>
<p>Co-occurrence sparse matrix, either a triangular sparse
matrix or a dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PMI symmetric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_ehr = data.frame(Patient = c(1, 1, 2, 1, 2, 1, 1, 3, 4),
                    Month = c(1, 1, 1, 2, 2, 3, 3, 4, 4),
                    Parent_Code = c('C1', 'C2', 'C2', 'C1', 'C1', 'C1',
                                    'C2', 'C3', 'C4'),
                    Count = 1:9)

spm_cooc = build_df_cooc(df_ehr)

m_pmi = get_pmi(spm_cooc)

</code></pre>

<hr>
<h2 id='get_svd'>Compute random singular value decomposition (rSVD)</h2><span id='topic+get_svd'></span>

<h3>Description</h3>

<p>Random SVD is an efficient approximation of truncated SVD, in which only the
first principal components are returned. It is computed with the rsvd
package, and the author suggests that the number of dimensions requested k
should be: k &lt; n / 4, where n is the number of features, for it to be
efficient, and that otherwise one should rather use either SVD or truncated
SVD.
When computing SVD on PMI, we only want to use the singular values
corresponding to the positive eigen values. We do not know beforehand how
many we will have to filter out, so there is two parameters: 'embedding_dim'
for the requested output dimension, and 'svd_rank' for the actual SVD
computation, by default twice the requested dimension, and a warning may be
thrown if 'svd_rank' needs to be manually increased.
Computation may be expensive and manually optimizing the 'svd_rank'
parameter might save significant time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_svd(m_pmi, embedding_dim = 100, svd_rank = embedding_dim * 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_svd_+3A_m_pmi">m_pmi</code></td>
<td>
<p>Pointwise mutual information matrix.</p>
</td></tr>
<tr><td><code id="get_svd_+3A_embedding_dim">embedding_dim</code></td>
<td>
<p>Number of output embedding dimensions requested.</p>
</td></tr>
<tr><td><code id="get_svd_+3A_svd_rank">svd_rank</code></td>
<td>
<p>Number of SVD dimensions to compute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SVD rectangular matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_ehr = data.frame(Patient = c(1, 1, 2, 1, 2, 1, 1, 3, 4),
                    Month = c(1, 1, 1, 2, 2, 3, 3, 4, 4),
                    Parent_Code = c('C1', 'C2', 'C2', 'C1', 'C1', 'C1',
                                    'C2', 'C3', 'C4'),
                    Count = 1:9)

spm_cooc = build_df_cooc(df_ehr)

m_pmi = get_pmi(spm_cooc)
m_svd = get_svd(m_pmi, embedding_dim = 2)

</code></pre>

<hr>
<h2 id='spm_to_df'>Write sparse matrix to dataframe</h2><span id='topic+spm_to_df'></span>

<h3>Description</h3>

<p>Write sparse matrix to dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_to_df(spm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spm_to_df_+3A_spm">spm</code></td>
<td>
<p>Sparse matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame
</p>

<hr>
<h2 id='sql_cooc'>Compute co-occurrence matrix on SQL file</h2><span id='topic+sql_cooc'></span>

<h3>Description</h3>

<p>Performs out-of-memory co-occurrence for large databases that would not fit
in RAM memory with the classic call to build_df_cooc.
Patients are batched using the n_batch parameter.
Co-occurrence sparse matrix output is written to a new SQL file.
Depending on number of codes considered, need to adjust n_batch and n_cores.
See vignette &quot;Co-occurrence and PMI-SVD&quot; for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_cooc(
  input_path,
  output_path,
  min_code_freq = 5,
  exclude_code_pattern = NULL,
  exclude_dict_pattern = NULL,
  codes_dict_fpaths = NULL,
  n_batch = 300,
  n_cores = 1,
  autoindex = FALSE,
  overwrite_output = FALSE,
  verbose = TRUE,
  verbose_max = verbose,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sql_cooc_+3A_input_path">input_path</code></td>
<td>
<p>Input SQL file path.
Must contain monthly counts table 'df_monthly',
with columns 'Patient', 'Month', 'Parent_Code', 'Count'.
Also requires an index on column 'Patient' and a table of
the unique codes 'df_uniq_codes', but will perform it
automatically if parameter autoindex is TRUE
(can increase input file size by 40%).</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_output_path">output_path</code></td>
<td>
<p>Output SQL file path for co-occurrence sparse matrix.
Can overwrite with overwrite_output parameter.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_min_code_freq">min_code_freq</code></td>
<td>
<p>Filter output matrix based on code frequency.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_exclude_code_pattern">exclude_code_pattern</code></td>
<td>
<p>Pattern of codes prefixes to exclude.
Will be used in SQL appended by '
prefixed by '^'.
For example, 'AB'.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_exclude_dict_pattern">exclude_dict_pattern</code></td>
<td>
<p>Used in combination with codes_dict.
Pattern of codes prefixes to exclude, except if
they are found in codes_dict.
Will be used in SQL appended by '
grep prefixed by '^'.
For example, 'C[0-9]'.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_codes_dict_fpaths">codes_dict_fpaths</code></td>
<td>
<p>Used in combination with exclude_dict_pattern.
Filepaths to define codes to avoid excluding using
exclude_dict_pattern.
First column of each file must define the code
identifiers.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_n_batch">n_batch</code></td>
<td>
<p>Number of patients per batch.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_autoindex">autoindex</code></td>
<td>
<p>If table 'df_uniq_codes' not found in input_path,
index table 'df_monthly' on column 'Patient', and write
unique values of 'Parent_Code' to table 'df_uniq_codes'.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_overwrite_output">overwrite_output</code></td>
<td>
<p>Should output_path be overwritten ?</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_verbose">verbose</code></td>
<td>
<p>Prints batch progress.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_verbose_max">verbose_max</code></td>
<td>
<p>Prints memory usage at each batch.</p>
</td></tr>
<tr><td><code id="sql_cooc_+3A_...">...</code></td>
<td>
<p>Passed to build_df_cooc</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, side-effect is output SQL file creation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df_ehr = data.frame(Patient = c(1, 1, 2, 1, 2, 1, 1, 3, 4),
                    Month = c(1, 1, 1, 2, 2, 3, 3, 4, 4),
                    Parent_Code = c('C1', 'C2', 'C2', 'C1', 'C1', 'C1',
                                    'C2', 'C3', 'C4'),
                    Count = 1:9)

library(RSQLite)

test_db_path = tempfile()
test_db = dbConnect(SQLite(), test_db_path)
dbWriteTable(test_db, 'df_monthly', df_ehr, overwrite = TRUE)

dbDisconnect(test_db)

output_db_path = tempfile()
sql_cooc(test_db_path, output_db_path, autoindex = TRUE)

test_db = dbConnect(SQLite(), output_db_path)
spm_cooc = dbGetQuery(test_db, 'select * from df_monthly;')
dbDisconnect(test_db)

spm_cooc

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
