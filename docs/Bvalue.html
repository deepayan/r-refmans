<!DOCTYPE html><html><head><title>Help for package Bvalue</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Bvalue}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bvalue-package'><p> B-Value and Empirical Equivalence Bound</p></a></li>
<li><a href='#EEB'><p> The Empirical Equivalence Bound</p></a></li>
<li><a href='#pB'><p> The B-Value Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>B-Value and Empirical Equivalence Bound</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Yi Zhao &lt;zhaoyi1026@gmail.com&gt;
		Brian Caffo &lt;bcaffo@gmail.com&gt;
		Joshua Ewen &lt;ewen@kennedykrieger.org&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yi Zhao &lt;zhaoyi1026@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates B-value and empirical equivalence bound. B-value is defined as the maximum magnitude of a confidence interval; and the empirical equivalence bound is the minimum B-value at a certain level. A new two-stage procedure for hypothesis testing is proposed, where the first stage is conventional hypothesis testing and the second is an equivalence testing procedure using the introduced empirical equivalence bound. See Zhao et al. (2019) "B-Value and Empirical Equivalence Bound: A New Procedure of Hypothesis Testing" &lt;<a href="https://doi.org/10.48550/arXiv.1912.13084">doi:10.48550/arXiv.1912.13084</a>&gt; for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-12 19:46:51 UTC; yizhao</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-23 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bvalue-package'> B-Value and Empirical Equivalence Bound
</h2><span id='topic+Bvalue-package'></span><span id='topic+Bvalue'></span>

<h3>Description</h3>

<p>Bvalue package calculates B-value and empirical equivalence bound. B-value is defined as the maximum magnitude of a confidence interval; and the empirical equivalence bound is the minimum B-value at a certain level. A new two-stage procedure for hypothesis testing is proposed, where the first stage is conventional hypothesis testing and the second is an equivalence testing procedure using the introduced empirical equivalence bound.
</p>


<h3>Author(s)</h3>

<p>Yi Zhao, Indiana University, &lt;zhaoyi1026@gmail.com&gt;
</p>
<p>Brian Caffo, Johns Hopkins University, &lt;bcaffo@gmail.com&gt;
</p>
<p>Joshua Ewen, Kennedy Krieger Institute and Johns Hopkins University, &lt;ewen@kennedykrieger.org&gt;
</p>
<p>Maintainer: Yi Zhao &lt;zhaoyi1026@gmail.com&gt;
</p>


<h3>References</h3>

<p>Zhao et al. (2019) <em>&quot;B-Value and Empirical Equivalence Bound: A New Procedure of Hypothesis Testing&quot;</em> &lt;arXiv:1912.13084&gt;
</p>

<hr>
<h2 id='EEB'> The Empirical Equivalence Bound
</h2><span id='topic+EEB'></span>

<h3>Description</h3>

<p> This function calculates the Empirical Equivalence Bound (EEB) at given level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EEB(beta, nu, delta = 0, S = 1, alpha = 0.05, 
  type = c("marginal", "cond_NRej", "cond_Rej"), 
  tol = 1e-04, max.itr = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EEB_+3A_beta">beta</code></td>
<td>
<p> a numeric between 0 and 1. This is the beta value in the EEB definition, see details.
</p>
</td></tr>
<tr><td><code id="EEB_+3A_nu">nu</code></td>
<td>
<p> an integer, the degrees of freedom in the conventional t-test.
</p>
</td></tr>
<tr><td><code id="EEB_+3A_delta">delta</code></td>
<td>
<p> a numeric value. Considering testing for difference of two population means, delta is the null value of the difference. Default is 0.
</p>
</td></tr>
<tr><td><code id="EEB_+3A_s">S</code></td>
<td>
<p> a numeric value. The standard error in the conventional t-test.
</p>
</td></tr>
<tr><td><code id="EEB_+3A_alpha">alpha</code></td>
<td>
<p> a numeric between 0 and 1. The Type I error rate aiming to control in the conventional t-test.
</p>
</td></tr>
<tr><td><code id="EEB_+3A_type">type</code></td>
<td>
<p> a character to specify the type of EEB to be calculated. <code>type = "marginal"</code> gives the marginal EEB; <code>type = "cond_NRej"</code> gives the EEB under the condition that one cannot reject the first-stage conventional t-test; <code>type = "cond_Rej"</code> gives the EEB under the condition that the first-stage conventional t-test is rejected.
</p>
</td></tr>
<tr><td><code id="EEB_+3A_tol">tol</code></td>
<td>
<p> a numeric value of convergence tolerance.
</p>
</td></tr>
<tr><td><code id="EEB_+3A_max.itr">max.itr</code></td>
<td>
<p> an integer, the maximum number of iterations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Consider a two-sample t-test setting with hypotheses
</p>
<p style="text-align: center;"><code class="reqn">H_{0}:\delta=0 \quad \leftrightarrow \quad H_{1}:\delta\neq 0,</code>
</p>

<p>where <code class="reqn">\delta=\mu_{1}-\mu_{2}</code> is the difference of two population means. If the testing result is failure to reject the null, one cannot directly conclude equivalence of the two groups. In this case, an equivalence test is suggested by testing the hypotheses
</p>
<p style="text-align: center;"><code class="reqn">H_{3}:|\delta|\geq\Delta \quad \leftrightarrow \quad H_{4}:|\delta|&lt;\Delta,</code>
</p>

<p>where <code class="reqn">\Delta</code> is a pre-specified equivalence bound. A <code class="reqn">100(1-2\alpha)\%</code> confidence interval is formulated, denoted as <code class="reqn">[L,U]</code>, to test for equivalence, where
</p>
<p style="text-align: center;"><code class="reqn">L=\hat{\delta}-t_{\nu,1-\alpha}S, \quad U=\hat{\delta}+t_{\nu,1-\alpha}S,</code>
</p>

<p><code class="reqn">\hat{\delta}</code> is the estimate of <code class="reqn">\delta</code>, <code class="reqn">t_{\nu,1-\alpha}</code> is the <code class="reqn">100(1-\alpha)\%</code> quantile of a t-distribution with degrees of freedom <code class="reqn">\nu</code>, and <code class="reqn">S</code> is the standard error. We define the B-value as
</p>
<p style="text-align: center;"><code class="reqn">B=\max\{|L|,|U|\},</code>
</p>

<p>and the Empirical Equivalence Bound (EEB) is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{EEB}_{\alpha}(\beta|C)=\inf_{b\in[0,\infty]}\{b:F_{B}(b|C,H_{0})\geq\beta\},</code>
</p>

<p>where <code class="reqn">\beta\in(0,1)</code> is a pre-specified level; <code class="reqn">C</code> denotes the status of the hypothesis test, which takes value of empty set (<code>type = "marginal"</code>), cannot reject <code class="reqn">H_{0}</code> (<code>type = "cond_NRej"</code>), and reject <code class="reqn">H_{0}</code> (<code>type = "cond_Rej"</code>); and <code class="reqn">F_{B}(\cdot|C,H_{0})</code> is the conditional cumulative distribution function of B-value.
</p>


<h3>Value</h3>

<p> Gives the Empirical Equivalence Bound value.
</p>


<h3>Author(s)</h3>

<p>Yi Zhao, Indiana University, &lt;zhaoyi1026@gmail.com&gt;
</p>
<p>Brian Caffo, Johns Hopkins University, &lt;bcaffo@gmail.com&gt;
</p>
<p>Joshua Ewen, Kennedy Krieger Institute and Johns Hopkins University, &lt;ewen@kennedykrieger.org&gt;
</p>


<h3>References</h3>

<p>Zhao et al. (2019) <em>&quot;B-Value and Empirical Equivalence Bound: A New Procedure of Hypothesis Testing&quot;</em> &lt;arXiv:1912.13084&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pB">pB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################################
# R Plant Growth Data

data("PlantGrowth")

PlantGrowth$group
comb.mat&lt;-cbind(c(1,2),c(1,3))
comb.name&lt;-paste0(levels(PlantGrowth$group)[2:3],"-",levels(PlantGrowth$group)[1])
colnames(comb.mat)&lt;-comb.name

alpha&lt;-0.05
# consider a series of beta values
beta.vec&lt;-c(0.5,0.75,0.8,0.9,0.95,0.99)

# two-stage hypothesis testing
# Stage I: conventional two-sample t-test
# Stage II: based on Stage I result to calculate EEB
stat&lt;-matrix(NA,ncol(comb.mat),10+length(beta.vec)*3)
colnames(stat)&lt;-c("delta","LB0","UB0","LB","UB","S","nu","tv","statistic","pvalue",
                  paste0(rep(c("EEB","EEB_NRej","EEB_Rej"),
                    each=length(beta.vec)),"_beta",rep(beta.vec,3)))
rownames(stat)&lt;-comb.name
for(kk in 1:ncol(comb.mat))
{
  x2&lt;-PlantGrowth$weight[which(as.numeric(PlantGrowth$group)==comb.mat[1,kk])]
  x1&lt;-PlantGrowth$weight[which(as.numeric(PlantGrowth$group)==comb.mat[2,kk])]
  
  n1&lt;-length(x1)
  n2&lt;-length(x2)
  
  S&lt;-sqrt((sum((x1-mean(x1))^2)+sum((x2-mean(x2))^2))/(n1+n2-2))*sqrt(1/n1+1/n2)
  
  nu&lt;-n1+n2-2
  
  tv&lt;-qt(1-alpha,df=nu)
  tv2&lt;-qt(1-alpha/2,df=nu)
  
  stat[kk,1]&lt;-mean(x1)-mean(x2)         # delta estimate
  stat[kk,2]&lt;-stat[kk,1]-tv2*S          # (1-alpha)% CI lower bound
  stat[kk,3]&lt;-stat[kk,1]+tv2*S          # (1-alpha)% CI upper bound
  stat[kk,4]&lt;-stat[kk,1]-tv*S           # (1-2alpha)% CI lower bound
  stat[kk,5]&lt;-stat[kk,1]+tv*S           # (1-2alpha)% CI upper bound
  stat[kk,6]&lt;-S                         # standard error
  stat[kk,7]&lt;-nu                        # degrees of freedom in the first-stage t-test
  stat[kk,8]&lt;-tv                        
  stat[kk,9]&lt;-stat[kk,1]/S              # test-statistic in the first-stage t-test
  stat[kk,10]&lt;-(1-pt(abs(stat[kk,9]),df=nu))*2    # p-value in the first-stage t-test
  
  # marginal EEB
  stat[kk,11:(11+length(beta.vec)-1)]&lt;-
    apply(as.matrix(beta.vec),1,
      function(x){return(EEB(beta=x,nu=nu,delta=0,S=S,alpha=alpha,type="marginal"))})
  
  # conditional on not rejection
  if(stat[kk,2]*stat[kk,3]&lt;0)
  {
    stat[kk,(11+length(beta.vec)):(11+length(beta.vec)*2-1)]&lt;-
      apply(as.matrix(beta.vec),1,
        function(x){return(EEB(beta=x,nu=nu,delta=0,S=S,alpha=alpha,type="cond_NRej"))})
  }
  
  # conditional on rejection
  if(stat[kk,2]*stat[kk,3]&gt;0)
  {
    stat[kk,(11+length(beta.vec)*2):(11+length(beta.vec)*3-1)]&lt;-
      apply(as.matrix(beta.vec),1,
        function(x){return(EEB(beta=x,nu=nu,delta=0,S=S,alpha=alpha,type="cond_Rej"))})
  }
}
print(data.frame(t(stat)))

cc&lt;-colors()[c(24,136,564,500,469,50,200,460,17,2,652,90,8,146,464,52,2)]
beta.lgd&lt;-sapply(1:length(beta.vec),
                 function(i){as.expression(substitute(beta==x,
                  list(x=format(beta.vec[i],digit=2,nsmall=2))))})

# Boxplot of data
oldpar&lt;-par(no.readonly=TRUE)
par(mar=c(5,5,1,1))
boxplot(weight~group,data=PlantGrowth,ylab="Dried weight of plants",col=cc[c(3,2,2)],
        pch=19,notch=TRUE,varwidth=TRUE,cex.lab=1.25,cex.axis=1.25)
par(oldpar)

# Comparing t-test CI and equivalence CI using the EEB
# trt1-ctrl
kk&lt;-1
oldpar&lt;-par(no.readonly=TRUE)
par(mar=c(4,5,3,3))
par(oma=c(2.5,0,0,0))
plot(range(c(stat[kk,c(1,2,3,4,5,11:ncol(stat))],-stat[kk,c(11:ncol(stat))]),na.rm=TRUE),
  c(0.5,length(beta.vec)+0.5),type="n",
  xlab="",ylab=expression(beta),yaxt="n",main=comb.name[kk],
  cex.lab=1.25,cex.axis=1.25,cex.main=1.25)
axis(2,at=1:length(beta.vec),labels=FALSE)
text(rep(par("usr")[1]-(par("usr")[2]-par("usr")[1])/100*2,length(beta.vec)),1:length(beta.vec),
  labels=format(beta.vec,nsmall=2,digits=2),srt=0,adj=c(1,0.5),xpd=TRUE,cex=1.25)
for(ll in 1:length(beta.vec))
{
  if(stat[kk,2]*stat[kk,3]&lt;0)
  {
    lines(c(-stat[kk,(10+length(beta.vec))+ll],stat[kk,(10+length(beta.vec))+ll]),rep(ll,2),
      lty=1,lwd=3,col=cc[1])
    points(0,ll,pch=15,cex=1.5,col=cc[1])
    text(-stat[kk,(10+length(beta.vec))+ll],ll,labels="[",cex=1.5,col=cc[1])
    text(stat[kk,(10+length(beta.vec))+ll],ll,labels="]",cex=1.5,col=cc[1])
  }
  if(stat[kk,2]*stat[kk,3]&gt;0)
  {
    lines(c(-stat[kk,(10+length(beta.vec)*2)+ll],stat[kk,(10+length(beta.vec)*2)+ll]),rep(ll,2),
      lty=1,lwd=3,col=cc[1])
    points(0,ll,pch=15,cex=1.5,col=cc[1])
    text(-stat[kk,(10+length(beta.vec)*2)+ll],ll,labels="[",cex=1.5,col=cc[1])
    text(stat[kk,(10+length(beta.vec)*2)+ll],ll,labels="]",cex=1.5,col=cc[1])
  }
  
  lines(stat[kk,c(4,5)],rep(ll,2),lty=1,lwd=3,col=cc[2])
  points(stat[kk,1],ll,pch=19,cex=1.5,col=cc[2])
  text(stat[kk,4],ll,labels="[",cex=1.5,col=cc[2])
  text(stat[kk,5],ll,labels="]",cex=1.5,col=cc[2])
}
par(fig=c(0,1,0,1),oma=c(0,0,0,0),mar=c(0,2,0,2),new=TRUE)
plot(0,0,type="n",bty="n",xaxt="n",yaxt="n")
legend("bottom",legend=c("confidence interval","equivalence interval"),xpd=TRUE,horiz=TRUE,
       inset=c(0,0),pch=c(19,15),col=cc[c(2,1)],lty=1,lwd=2,cex=1.5,bty="n")
par(oldpar)

# trt2-ctrl
kk&lt;-2
oldpar&lt;-par(no.readonly=TRUE)
par(mar=c(4,5,3,3))
par(oma=c(2.5,0,0,0))
plot(range(c(stat[kk,c(1,2,3,4,5,11:ncol(stat))],-stat[kk,c(11:ncol(stat))]),na.rm=TRUE),
  c(0.5,length(beta.vec)+0.5),type="n",
  xlab="",ylab=expression(beta),yaxt="n",main=comb.name[kk],
  cex.lab=1.25,cex.axis=1.25,cex.main=1.25)
axis(2,at=1:length(beta.vec),labels=FALSE)
text(rep(par("usr")[1]-(par("usr")[2]-par("usr")[1])/100*2,length(beta.vec)),1:length(beta.vec),
     labels=format(beta.vec,nsmall=2,digits=2),srt=0,adj=c(1,0.5),xpd=TRUE,cex=1.25)
for(ll in 1:length(beta.vec))
{
  if(stat[kk,2]*stat[kk,3]&lt;0)
  {
    lines(c(-stat[kk,(10+length(beta.vec))+ll],stat[kk,(10+length(beta.vec))+ll]),rep(ll,2),
      lty=1,lwd=3,col=cc[1])
    points(0,ll,pch=15,cex=1.5,col=cc[1])
    text(-stat[kk,(10+length(beta.vec))+ll],ll,labels="[",cex=1.5,col=cc[1])
    text(stat[kk,(10+length(beta.vec))+ll],ll,labels="]",cex=1.5,col=cc[1])
  }
  if(stat[kk,2]*stat[kk,3]&gt;0)
  {
    lines(c(-stat[kk,(10+length(beta.vec)*2)+ll],stat[kk,(10+length(beta.vec)*2)+ll]),rep(ll,2),
      lty=1,lwd=3,col=cc[1])
    points(0,ll,pch=15,cex=1.5,col=cc[1])
    text(-stat[kk,(10+length(beta.vec)*2)+ll],ll,labels="[",cex=1.5,col=cc[1])
    text(stat[kk,(10+length(beta.vec)*2)+ll],ll,labels="]",cex=1.5,col=cc[1])
  }
  
  lines(stat[kk,c(4,5)],rep(ll,2),lty=1,lwd=3,col=cc[2])
  points(stat[kk,1],ll,pch=19,cex=1.5,col=cc[2])
  text(stat[kk,4],ll,labels="[",cex=1.5,col=cc[2])
  text(stat[kk,5],ll,labels="]",cex=1.5,col=cc[2])
}
par(fig=c(0,1,0,1),oma=c(0,0,0,0),mar=c(0,2,0,2),new=TRUE)
plot(0,0,type="n",bty="n",xaxt="n",yaxt="n")
legend("bottom",legend=c("confidence interval","equivalence interval"),xpd=TRUE,horiz=TRUE,
       inset=c(0,0),pch=c(19,15),col=cc[c(2,1)],lty=1,lwd=2,cex=1.5,bty="n")
par(oldpar)
#########################################
</code></pre>

<hr>
<h2 id='pB'> The B-Value Distribution
</h2><span id='topic+pB'></span>

<h3>Description</h3>

<p> This function gives the cumulative distribution function of the B-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pB(b, nu, delta = 0, S = 1, alpha = 0.05, type = c("marginal", "cond_NRej", "cond_Rej"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pB_+3A_b">b</code></td>
<td>
<p> vector of quantiles
</p>
</td></tr>
<tr><td><code id="pB_+3A_nu">nu</code></td>
<td>
<p> an integer, the degrees of freedom in the conventional t-test.
</p>
</td></tr>
<tr><td><code id="pB_+3A_delta">delta</code></td>
<td>
<p> a numeric value. Considering testing for difference of two population means, delta is the null value of the difference. Default is 0.
</p>
</td></tr>
<tr><td><code id="pB_+3A_s">S</code></td>
<td>
<p> a numeric value. The standard error in the conventional t-test.
</p>
</td></tr>
<tr><td><code id="pB_+3A_alpha">alpha</code></td>
<td>
<p> a numeric between 0 and 1. The Type I error rate aiming to control in the conventional t-test.
</p>
</td></tr>
<tr><td><code id="pB_+3A_type">type</code></td>
<td>
<p> a character to specify the type of EEB to be calculated. <code>type = "marginal"</code> gives the marginal EEB; <code>type = "cond_NRej"</code> gives the EEB under the condition that one cannot reject the first-stage conventional t-test; <code>type = "cond_Rej"</code> gives the EEB under the condition that the first-stage conventional t-test is rejected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Consider a two-sample t-test setting with hypotheses
</p>
<p style="text-align: center;"><code class="reqn">H_{0}:\delta=0 \quad \leftrightarrow \quad H_{1}:\delta\neq 0,</code>
</p>

<p>where <code class="reqn">\delta=\mu_{1}-\mu_{2}</code> is the difference of two population means. If the testing result is failure to reject the null, one cannot directly conclude equivalence of the two groups. In this case, an equivalence test is suggested by testing the hypotheses
</p>
<p style="text-align: center;"><code class="reqn">H_{3}:|\delta|\geq\Delta \quad \leftrightarrow \quad H_{4}:|\delta|&lt;\Delta,</code>
</p>

<p>where <code class="reqn">\Delta</code> is a pre-specified equivalence bound. A <code class="reqn">100(1-2\alpha)\%</code> confidence interval is formulated, denoted as <code class="reqn">[L,U]</code>, to test for equivalence, where
</p>
<p style="text-align: center;"><code class="reqn">L=\hat{\delta}-t_{\nu,1-\alpha}S, \quad U=\hat{\delta}+t_{\nu,1-\alpha}S,</code>
</p>

<p><code class="reqn">\hat{\delta}</code> is the estimate of <code class="reqn">\delta</code>, <code class="reqn">t_{\nu,1-\alpha}</code> is the <code class="reqn">100(1-\alpha)\%</code> quantile of a t-distribution with degrees of freedom <code class="reqn">\nu</code>, and <code class="reqn">S</code> is the standard error. We define the B-value as
</p>
<p style="text-align: center;"><code class="reqn">B=\max\{|L|,|U|\}.</code>
</p>

<p>The cumulative distribution function of the B-value is defined under three conditions: (1) the marginal distribution (<code>type = "marginal"</code>); (2) the conditional distribution given that one cannot reject <code class="reqn">H_{0}</code> in the conventional t-test (<code>type = "cond_NRej"</code>); and (3) the conditional distribution given that <code class="reqn">H_{0}</code> is rejected in the conventional t-test (<code>type = "cond_Rej"</code>).
</p>


<h3>Value</h3>

<p> Gives the cumulative distribution function of the B-value.
</p>


<h3>Author(s)</h3>

<p>Yi Zhao, Indiana University, &lt;zhaoyi1026@gmail.com&gt;
</p>
<p>Brian Caffo, Johns Hopkins University, &lt;bcaffo@gmail.com&gt;
</p>
<p>Joshua Ewen, Kennedy Krieger Institute and Johns Hopkins University, &lt;ewen@kennedykrieger.org&gt;
</p>


<h3>References</h3>

<p>Zhao et al. (2019) <em>&quot;B-Value and Empirical Equivalence Bound: A New Procedure of Hypothesis Testing&quot;</em> &lt;arXiv:1912.13084&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EEB">EEB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############################################
# An Example: demonstration of marginal/conditional distribution of the B-value
alpha&lt;-0.05

delta&lt;-0
n1=n2=n&lt;-10
S&lt;-0.325
nu&lt;-n1+n2-2

# compare three types of B-value distributions
oldpar&lt;-par(no.readonly=TRUE)
par(mar=c(6,5,2,2))
plot(c(0,2),c(0,1),type="n",xlab=expression(b),ylab=expression(F[B](b*~"|"*~C,H[0])),
     cex.lab=1.25,cex.axis=1.25,cex.main=1.25)
abline(h=1,lty=1,lwd=2,col=8)
abline(h=0,lty=1,lwd=2,col=8)
curve(pB(x,nu=nu,delta=delta,S=S,alpha=alpha,type="marginal"),
      lty=1,lwd=3,col=1,n=1000,from=0,to=20,add=TRUE)
curve(pB(x,nu=nu,delta=delta,S=S,alpha=alpha,type="cond_NRej"),
      lty=2,lwd=3,col=2,n=1000,from=0,to=20,add=TRUE)
curve(pB(x,nu=nu,delta=delta,S=S,alpha=alpha,type="cond_Rej"),
      lty=3,lwd=3,col=4,n=1000,from=0,to=20,add=TRUE)
par(fig=c(0,1,0,1),oma=c(0,0,0,0),mar=c(0,2,0,2),new=TRUE)
plot(0,0,type="n",bty="n",xaxt="n",yaxt="n")
legend("bottom",legend=c("marginal","conditional (not reject)","conditional (reject)"),
       xpd=TRUE,horiz=TRUE,inset=c(0,0),col=c(1,2,4),lty=c(1,2,3),lwd=2,bty="n",cex=1.25)
par(oldpar)
############################################
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
