<!DOCTYPE html><html lang="en"><head><title>Help for package mfx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mfx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#betamfx'><p>Marginal effects for a beta regression.</p></a></li>
<li><a href='#betaor'><p>Odds ratios for a beta regression.</p></a></li>
<li><a href='#logitmfx'><p>Marginal effects for a logit regression.</p></a></li>
<li><a href='#logitor'><p>Odds ratios for a logit regression.</p></a></li>
<li><a href='#negbinirr'><p>Incidence rate ratios for a negative binomial regression.</p></a></li>
<li><a href='#negbinmfx'><p>Marginal effects for a negative binomial regression.</p></a></li>
<li><a href='#poissonirr'><p>Incidence rate ratios for a Poisson regression.</p></a></li>
<li><a href='#poissonmfx'><p>Marginal effects for a Poisson regression.</p></a></li>
<li><a href='#probitmfx'><p>Marginal effects for a probit regression.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Marginal Effects, Odds Ratios and Incidence Rate Ratios for GLMs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-02-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates probit, logit, Poisson, negative binomial, 
  and beta regression models, returning their marginal effects, odds ratios, 
  or incidence rate ratios as an output.
  Greene (2008, pp. 780-7) provides a textbook introduction to this topic.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, sandwich, lmtest, MASS, betareg</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-06 07:08:01 UTC; gsl324</td>
</tr>
<tr>
<td>Author:</td>
<td>Alan Fernihough [aut, cre],
  Arne Henningsen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alan Fernihough &lt;alan.fernihough@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-06 11:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='betamfx'>Marginal effects for a beta regression.</h2><span id='topic+betamfx'></span><span id='topic+print.betamfx'></span>

<h3>Description</h3>

<p>This function estimates a beta regression model and calculates
the corresponding marginal effects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betamfx(formula, data, atmean = TRUE, robust = FALSE, 
        clustervar1 = NULL, clustervar2 = NULL, 
        control = betareg.control(), link.phi = NULL, type = "ML")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betamfx_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class).</p>
</td></tr>
<tr><td><code id="betamfx_+3A_data">data</code></td>
<td>
<p>the data frame containing these data. This argument must be used.</p>
</td></tr>
<tr><td><code id="betamfx_+3A_atmean">atmean</code></td>
<td>
<p>default marginal effects represent the partial effects for the average observation. 
If <code>atmean = FALSE</code> the function calculates average partial effects.</p>
</td></tr>
<tr><td><code id="betamfx_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> the function reports White/robust standard errors.</p>
</td></tr>
<tr><td><code id="betamfx_+3A_clustervar1">clustervar1</code></td>
<td>
<p>a character value naming the first cluster on which to adjust the standard errors.</p>
</td></tr>
<tr><td><code id="betamfx_+3A_clustervar2">clustervar2</code></td>
<td>
<p>a character value naming the second cluster on which to 
adjust the standard errors for two-way clustering.</p>
</td></tr>
<tr><td><code id="betamfx_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via <code><a href="betareg.html#topic+betareg.control">betareg.control</a></code>.</p>
</td></tr>
<tr><td><code id="betamfx_+3A_link.phi">link.phi</code></td>
<td>
<p>as in the <code><a href="betareg.html#topic+betareg">betareg</a></code> function.</p>
</td></tr>
<tr><td><code id="betamfx_+3A_type">type</code></td>
<td>
<p>as in the <code><a href="betareg.html#topic+betareg">betareg</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying link function in the mean model (mu) is &ldquo;logit&rdquo;. If both <code>robust=TRUE</code> and 
<code>!is.null(clustervar1)</code> the function overrides the <code>robust</code> command and computes clustered 
standard errors.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mfxest</code></td>
<td>
<p>a coefficient matrix with columns containing the estimates, 
associated standard errors, test statistics and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted <code><a href="betareg.html#topic+betareg">betareg</a></code> object.</p>
</td></tr>
<tr><td><code>dcvar</code></td>
<td>
<p>a character vector containing the variable names where the marginal effect 
refers to the impact of a discrete change on the outcome. For example, a factor variable.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Francisco Cribari-Neto, Achim Zeileis (2010). Beta Regression in R. Journal of Statistical Software 34(2), 1-24.
</p>
<p>Bettina Gruen, Ioannis Kosmidis, Achim Zeileis (2012). Extended Beta Regression in R: Shaken, Stirred, Mixed, 
and Partitioned. Journal of Statistical Software, 48(11), 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betaor">betaor</a></code>, <code><a href="betareg.html#topic+betareg">betareg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(12345)
n = 1000
x = rnorm(n)

# beta outcome
y = rbeta(n, shape1 = plogis(1 + 0.5 * x), shape2 = (abs(0.2*x)))
# use Smithson and Verkuilen correction
y = (y*(n-1)+0.5)/n

data = data.frame(y,x)
betamfx(y~x|x, data=data)
</code></pre>

<hr>
<h2 id='betaor'>Odds ratios for a beta regression.</h2><span id='topic+betaor'></span><span id='topic+print.betaor'></span>

<h3>Description</h3>

<p>This function estimates a beta regression model and calculates the corresponding odds ratios. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaor(formula, data, robust = FALSE, clustervar1 = NULL, clustervar2 = NULL, 
       control = betareg.control(), link.phi = NULL, type = "ML")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betaor_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class).</p>
</td></tr>
<tr><td><code id="betaor_+3A_data">data</code></td>
<td>
<p>the data frame containing these data. This argument must be used.</p>
</td></tr>
<tr><td><code id="betaor_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> the function reports White/robust standard errors.</p>
</td></tr>
<tr><td><code id="betaor_+3A_clustervar1">clustervar1</code></td>
<td>
<p>a character value naming the first cluster on which to adjust the standard errors.</p>
</td></tr>
<tr><td><code id="betaor_+3A_clustervar2">clustervar2</code></td>
<td>
<p>a character value naming the second cluster on which to 
adjust the standard errors for two-way clustering.</p>
</td></tr>
<tr><td><code id="betaor_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via <code><a href="betareg.html#topic+betareg.control">betareg.control</a></code>.</p>
</td></tr>
<tr><td><code id="betaor_+3A_link.phi">link.phi</code></td>
<td>
<p>as in the <code><a href="betareg.html#topic+betareg">betareg</a></code> function.</p>
</td></tr>
<tr><td><code id="betaor_+3A_type">type</code></td>
<td>
<p>as in the <code><a href="betareg.html#topic+betareg">betareg</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying link function in the mean model (mu) is &quot;logit&quot;. If both <code>robust=TRUE</code> and 
<code>!is.null(clustervar1)</code> the function overrides the <code>robust</code> command and computes clustered 
standard errors.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>oddsratio</code></td>
<td>
<p>a coefficient matrix with columns containing the estimates, 
associated standard errors, test statistics and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted <code><a href="betareg.html#topic+betareg">betareg</a></code> object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Francisco Cribari-Neto, Achim Zeileis (2010). Beta Regression in R. Journal of Statistical Software 34(2), 1-24. 
</p>
<p>Bettina Gruen, Ioannis Kosmidis, Achim Zeileis (2012). Extended Beta Regression in R: Shaken, Stirred, Mixed, 
and Partitioned. Journal of Statistical Software, 48(11), 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betamfx">betamfx</a></code>, <code><a href="betareg.html#topic+betareg">betareg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(12345)
n = 1000
x = rnorm(n)

# beta outcome
y = rbeta(n, shape1 = plogis(1 + 0.5 * x), shape2 = (abs(0.2*x)))
# use Smithson and Verkuilen correction
y = (y*(n-1)+0.5)/n

data = data.frame(y,x)
betaor(y~x|x, data=data)
</code></pre>

<hr>
<h2 id='logitmfx'>Marginal effects for a logit regression.</h2><span id='topic+logitmfx'></span><span id='topic+print.logitmfx'></span>

<h3>Description</h3>

<p>This function estimates a binary logistic regression model and calculates 
the corresponding marginal effects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logitmfx(formula, data, atmean = TRUE, robust = FALSE, clustervar1 = NULL, 
         clustervar2 = NULL, start = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logitmfx_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class).</p>
</td></tr>
<tr><td><code id="logitmfx_+3A_data">data</code></td>
<td>
<p>the data frame containing these data. This argument must be used.</p>
</td></tr>
<tr><td><code id="logitmfx_+3A_atmean">atmean</code></td>
<td>
<p>default marginal effects represent the partial effects for the average observation. 
If <code>atmean = FALSE</code> the function calculates average partial effects.</p>
</td></tr>
<tr><td><code id="logitmfx_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> the function reports White/robust standard errors.</p>
</td></tr>
<tr><td><code id="logitmfx_+3A_clustervar1">clustervar1</code></td>
<td>
<p>a character value naming the first cluster on which to adjust the standard errors.</p>
</td></tr>
<tr><td><code id="logitmfx_+3A_clustervar2">clustervar2</code></td>
<td>
<p>a character value naming the second cluster on which to 
adjust the standard errors for two-way clustering.</p>
</td></tr>
<tr><td><code id="logitmfx_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the <code><a href="stats.html#topic+glm">glm</a></code> model.</p>
</td></tr>
<tr><td><code id="logitmfx_+3A_control">control</code></td>
<td>
<p>see <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>robust=TRUE</code> and <code>!is.null(clustervar1)</code> the function overrides the <code>robust</code> 
command and computes clustered standard errors.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mfxest</code></td>
<td>
<p>a coefficient matrix with columns containing the estimates, 
associated standard errors, test statistics and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted <code><a href="stats.html#topic+glm">glm</a></code> object.</p>
</td></tr>
<tr><td><code>dcvar</code></td>
<td>
<p>a character vector containing the variable names where the marginal effect 
refers to the impact of a discrete change on the outcome. For example, a factor variable.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>William H. Greene (2008). Econometric Analysis (6th ed.). Prentice Hall, N.Y. pp 770-787.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logitor">logitor</a></code>, <code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(12345)
n = 1000
x = rnorm(n)

# binary outcome
y = ifelse(pnorm(1 + 0.5*x + rnorm(n))&gt;0.5, 1, 0)

data = data.frame(y,x)
logitmfx(formula=y~x, data=data)
</code></pre>

<hr>
<h2 id='logitor'>Odds ratios for a logit regression.</h2><span id='topic+logitor'></span><span id='topic+print.logitor'></span>

<h3>Description</h3>

<p>This function estimates a binary logistic regression model and calculates 
the corresponding odds ratios. </p>


<h3>Usage</h3>

<pre><code class='language-R'>logitor(formula, data, robust = FALSE, clustervar1 = NULL, clustervar2 = NULL, 
        start = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logitor_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class).</p>
</td></tr>
<tr><td><code id="logitor_+3A_data">data</code></td>
<td>
<p>the data frame containing these data. This argument must be used.</p>
</td></tr>
<tr><td><code id="logitor_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> the function reports White/robust standard errors.</p>
</td></tr>
<tr><td><code id="logitor_+3A_clustervar1">clustervar1</code></td>
<td>
<p>a character value naming the first cluster on which to adjust the standard errors.</p>
</td></tr>
<tr><td><code id="logitor_+3A_clustervar2">clustervar2</code></td>
<td>
<p>a character value naming the second cluster on which to 
adjust the standard errors for two-way clustering.</p>
</td></tr>
<tr><td><code id="logitor_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the <code><a href="stats.html#topic+glm">glm</a></code> model.</p>
</td></tr>
<tr><td><code id="logitor_+3A_control">control</code></td>
<td>
<p>see <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>robust=TRUE</code> and <code>!is.null(clustervar1)</code> the function overrides the <code>robust</code> 
command and computes clustered standard errors.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>oddsratio</code></td>
<td>
<p>a coefficient matrix with columns containing the estimates, 
associated standard errors, test statistics and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted <code><a href="stats.html#topic+glm">glm</a></code> object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+logitmfx">logitmfx</a></code>, <code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(12345)
n = 1000
x = rnorm(n)

# binary outcome
y = ifelse(pnorm(1 + 0.5*x + rnorm(n))&gt;0.5, 1, 0)

data = data.frame(y,x)
logitor(formula=y~x, data=data)
</code></pre>

<hr>
<h2 id='negbinirr'>Incidence rate ratios for a negative binomial regression.</h2><span id='topic+negbinirr'></span><span id='topic+print.negbinirr'></span>

<h3>Description</h3>

<p>This function estimates a negative binomial regression model and calculates 
the corresponding incidence rate ratios.</p>


<h3>Usage</h3>

<pre><code class='language-R'>negbinirr(formula, data, robust = FALSE, clustervar1 = NULL, 
          clustervar2 = NULL, start = NULL, control = glm.control())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="negbinirr_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class).</p>
</td></tr>
<tr><td><code id="negbinirr_+3A_data">data</code></td>
<td>
<p>the data frame containing these data. This argument must be used.</p>
</td></tr>
<tr><td><code id="negbinirr_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> the function reports White/robust standard errors.</p>
</td></tr>
<tr><td><code id="negbinirr_+3A_clustervar1">clustervar1</code></td>
<td>
<p>a character value naming the first cluster on which to adjust the standard errors.</p>
</td></tr>
<tr><td><code id="negbinirr_+3A_clustervar2">clustervar2</code></td>
<td>
<p>a character value naming the second cluster on which to 
adjust the standard errors for two-way clustering.</p>
</td></tr>
<tr><td><code id="negbinirr_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> model.</p>
</td></tr>
<tr><td><code id="negbinirr_+3A_control">control</code></td>
<td>
<p>see <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>robust=TRUE</code> and <code>!is.null(clustervar1)</code> the function overrides the <code>robust</code> 
command and computes clustered standard errors.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>irr</code></td>
<td>
<p>a coefficient matrix with columns containing the estimates, 
associated standard errors, test statistics and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+negbinmfx">negbinmfx</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(12345)
n = 1000
x = rnorm(n)
y = rnegbin(n, mu = exp(1 + 0.5 * x), theta = 0.5)

data = data.frame(y,x)

negbinirr(formula=y~x,data=data)
</code></pre>

<hr>
<h2 id='negbinmfx'>Marginal effects for a negative binomial regression.</h2><span id='topic+negbinmfx'></span><span id='topic+print.negbinmfx'></span>

<h3>Description</h3>

<p>This function estimates a negative binomial regression model and calculates 
the corresponding marginal effects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>negbinmfx(formula, data, atmean = TRUE, robust = FALSE, clustervar1 = NULL, 
          clustervar2 = NULL, start = NULL, control = glm.control())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="negbinmfx_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class).</p>
</td></tr>
<tr><td><code id="negbinmfx_+3A_data">data</code></td>
<td>
<p>the data frame containing these data. This argument must be used.</p>
</td></tr>
<tr><td><code id="negbinmfx_+3A_atmean">atmean</code></td>
<td>
<p>default marginal effects represent the partial effects for the average observation. 
If <code>atmean = FALSE</code> the function calculates average partial effects.</p>
</td></tr>
<tr><td><code id="negbinmfx_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> the function reports White/robust standard errors.</p>
</td></tr>
<tr><td><code id="negbinmfx_+3A_clustervar1">clustervar1</code></td>
<td>
<p>a character value naming the first cluster on which to adjust the standard errors.</p>
</td></tr>
<tr><td><code id="negbinmfx_+3A_clustervar2">clustervar2</code></td>
<td>
<p>a character value naming the second cluster on which to 
adjust the standard errors for two-way clustering.</p>
</td></tr>
<tr><td><code id="negbinmfx_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> model.</p>
</td></tr>
<tr><td><code id="negbinmfx_+3A_control">control</code></td>
<td>
<p>see <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>robust=TRUE</code> and <code>!is.null(clustervar1)</code> the function overrides the <code>robust</code> 
command and computes clustered standard errors.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mfxest</code></td>
<td>
<p>a coefficient matrix with columns containing the estimates, 
associated standard errors, test statistics and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> object.</p>
</td></tr>
<tr><td><code>dcvar</code></td>
<td>
<p>a character vector containing the variable names where the marginal effect 
refers to the impact of a discrete change on the outcome. For example, a factor variable.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+negbinirr">negbinirr</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(12345)
n = 1000
x = rnorm(n)
y = rnegbin(n, mu = exp(1 + 0.5 * x), theta = 0.5)

data = data.frame(y,x)

negbinmfx(formula=y~x,data=data)
</code></pre>

<hr>
<h2 id='poissonirr'>Incidence rate ratios for a Poisson regression.</h2><span id='topic+poissonirr'></span><span id='topic+print.poissonirr'></span>

<h3>Description</h3>

<p>This function estimates a negative binomial regression model and calculates 
the corresponding incidence rate ratios.</p>


<h3>Usage</h3>

<pre><code class='language-R'>poissonirr(formula, data, robust = FALSE, clustervar1 = NULL, 
           clustervar2 = NULL, start = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poissonirr_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class).</p>
</td></tr>
<tr><td><code id="poissonirr_+3A_data">data</code></td>
<td>
<p>the data frame containing these data. This argument must be used.</p>
</td></tr>
<tr><td><code id="poissonirr_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> the function reports White/robust standard errors.</p>
</td></tr>
<tr><td><code id="poissonirr_+3A_clustervar1">clustervar1</code></td>
<td>
<p>a character value naming the first cluster on which to adjust the standard errors.</p>
</td></tr>
<tr><td><code id="poissonirr_+3A_clustervar2">clustervar2</code></td>
<td>
<p>a character value naming the second cluster on which to 
adjust the standard errors for two-way clustering.</p>
</td></tr>
<tr><td><code id="poissonirr_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the <code><a href="stats.html#topic+glm">glm</a></code> model.</p>
</td></tr>
<tr><td><code id="poissonirr_+3A_control">control</code></td>
<td>
<p>see <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>robust=TRUE</code> and <code>!is.null(clustervar1)</code> the function overrides the <code>robust</code> 
command and computes clustered standard errors.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>irr</code></td>
<td>
<p>a coefficient matrix with columns containing the estimates, 
associated standard errors, test statistics and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted <code><a href="stats.html#topic+glm">glm</a></code> object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+poissonmfx">poissonmfx</a></code>, <code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(12345)
n = 1000
x = rnorm(n)
y = rnegbin(n, mu = exp(1 + 0.5 * x), theta = 0.5)

data = data.frame(y,x)

poissonirr(formula=y~x,data=data)
</code></pre>

<hr>
<h2 id='poissonmfx'>Marginal effects for a Poisson regression.</h2><span id='topic+poissonmfx'></span><span id='topic+print.poissonmfx'></span>

<h3>Description</h3>

<p>This function estimates a Poisson regression model and calculates 
the corresponding marginal effects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>poissonmfx(formula, data, atmean = TRUE, robust = FALSE, clustervar1 = NULL, 
           clustervar2 = NULL, start = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poissonmfx_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class).</p>
</td></tr>
<tr><td><code id="poissonmfx_+3A_data">data</code></td>
<td>
<p>the data frame containing these data. This argument must be used.</p>
</td></tr>
<tr><td><code id="poissonmfx_+3A_atmean">atmean</code></td>
<td>
<p>default marginal effects represent the partial effects for the average observation. 
If <code>atmean = FALSE</code> the function calculates average partial effects.</p>
</td></tr>
<tr><td><code id="poissonmfx_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> the function reports White/robust standard errors.</p>
</td></tr>
<tr><td><code id="poissonmfx_+3A_clustervar1">clustervar1</code></td>
<td>
<p>a character value naming the first cluster on which to adjust the standard errors.</p>
</td></tr>
<tr><td><code id="poissonmfx_+3A_clustervar2">clustervar2</code></td>
<td>
<p>a character value naming the second cluster on which to 
adjust the standard errors for two-way clustering.</p>
</td></tr>
<tr><td><code id="poissonmfx_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the <code><a href="stats.html#topic+glm">glm</a></code> model.</p>
</td></tr>
<tr><td><code id="poissonmfx_+3A_control">control</code></td>
<td>
<p>see <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>robust=TRUE</code> and <code>!is.null(clustervar1)</code> the function overrides the <code>robust</code> 
command and computes clustered standard errors.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mfxest</code></td>
<td>
<p>a coefficient matrix with columns containing the estimates, 
associated standard errors, test statistics and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted <code><a href="stats.html#topic+glm">glm</a></code> object.</p>
</td></tr>
<tr><td><code>dcvar</code></td>
<td>
<p>a character vector containing the variable names where the marginal effect 
refers to the impact of a discrete change on the outcome. For example, a factor variable.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+poissonirr">poissonirr</a></code>, <code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(12345)
n = 1000
x = rnorm(n)
y = rnegbin(n, mu = exp(1 + 0.5 * x), theta = 0.5)

data = data.frame(y,x)

poissonmfx(formula=y~x,data=data)
</code></pre>

<hr>
<h2 id='probitmfx'>Marginal effects for a probit regression.</h2><span id='topic+probitmfx'></span><span id='topic+print.probitmfx'></span>

<h3>Description</h3>

<p>This function estimates a probit regression model and calculates 
the corresponding marginal effects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>probitmfx(formula, data, atmean = TRUE, robust = FALSE, clustervar1 = NULL, 
          clustervar2 = NULL, start = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probitmfx_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo; (or one that can be coerced to that class).</p>
</td></tr>
<tr><td><code id="probitmfx_+3A_data">data</code></td>
<td>
<p>the data frame containing these data. This argument must be used.</p>
</td></tr>
<tr><td><code id="probitmfx_+3A_atmean">atmean</code></td>
<td>
<p>default marginal effects represent the partial effects for the average observation. 
If <code>atmean = FALSE</code> the function calculates average partial effects.</p>
</td></tr>
<tr><td><code id="probitmfx_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> the function reports White/robust standard errors.</p>
</td></tr>
<tr><td><code id="probitmfx_+3A_clustervar1">clustervar1</code></td>
<td>
<p>a character value naming the first cluster on which to adjust the standard errors.</p>
</td></tr>
<tr><td><code id="probitmfx_+3A_clustervar2">clustervar2</code></td>
<td>
<p>a character value naming the second cluster on which to 
adjust the standard errors for two-way clustering.</p>
</td></tr>
<tr><td><code id="probitmfx_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the <code><a href="stats.html#topic+glm">glm</a></code> model.</p>
</td></tr>
<tr><td><code id="probitmfx_+3A_control">control</code></td>
<td>
<p>see <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>robust=TRUE</code> and <code>!is.null(clustervar1)</code> the function overrides the <code>robust</code> 
command and computes clustered standard errors.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mfxest</code></td>
<td>
<p>a coefficient matrix with columns containing the estimates, 
associated standard errors, test statistics and p-values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted <code><a href="stats.html#topic+glm">glm</a></code> object.</p>
</td></tr>
<tr><td><code>dcvar</code></td>
<td>
<p>a character vector containing the variable names where the marginal effect 
refers to the impact of a discrete change on the outcome. For example, a factor variable.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>William H. Greene (2008). Econometric Analysis (6th ed.). Prentice Hall, N.Y. pp 770-787.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(12345)
n = 1000
x = rnorm(n)

# binary outcome
y = ifelse(pnorm(1 + 0.5*x + rnorm(n))&gt;0.5, 1, 0)

data = data.frame(y,x)
probitmfx(formula=y~x, data=data)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
