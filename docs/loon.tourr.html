<!DOCTYPE html><html><head><title>Help for package loon.tourr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {loon.tourr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#l_getPlots.l_tour'><p>Query a loon widget</p></a></li>
<li><a href='#l_getProjection'><p>Query the matrix of projection vectors</p></a></li>
<li><a href='#l_layer_callback'><p>Tour Layer Configuration</p></a></li>
<li><a href='#l_layer_density2d'><p>2D density layer</p></a></li>
<li><a href='#l_layer_hull'><p>Layer a hull for <code>loon</code></p></a></li>
<li><a href='#l_layer_trails'><p>Display tour path with trails</p></a></li>
<li><a href='#l_tour'><p>Tour in loon</p></a></li>
<li><a href='#tour_pairs'><p>Tour Pairs Plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tour in 'Loon'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implement tour algorithms in interactive graphical system 'loon'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), tcltk, loon (&gt; 1.3.1), tourr, methods,</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, grDevices, MASS, loon.ggplot, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>class, magrittr, tidyverse, testthat, knitr, rmarkdown,
markdown, covr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/z267xu/loon.tourr/issues">https://github.com/z267xu/loon.tourr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-27 02:33:57 UTC; Zehao</td>
</tr>
<tr>
<td>Author:</td>
<td>Zehao Xu [aut, cre],
  R. Wayne Oldford [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zehao Xu &lt;z267xu@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-27 14:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='l_getPlots.l_tour'>Query a loon widget</h2><span id='topic+l_getPlots.l_tour'></span>

<h3>Description</h3>

<p>A generic function to query the <code>loon</code> (tcl) widget from the given target
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'l_tour'
l_getPlots(target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_getPlots.l_tour_+3A_target">target</code></td>
<td>
<p>a <code>loon</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>loon</code> widget
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
  p &lt;- l_tour(iris[, -5])
  l_isLoonWidget(p) # FALSE
  q &lt;- l_getPlots(p)
  l_isLoonWidget(q) # TRUE

  # `l_compound` widget
  p &lt;- l_tour_pairs(tourr::flea[, -7])
  l_isLoonWidget(p) # FALSE
  q &lt;- l_getPlots(p)
  l_isLoonWidget(q) # FALSE
  is(q, "l_compound") # TRUE
}
</code></pre>

<hr>
<h2 id='l_getProjection'>Query the matrix of projection vectors</h2><span id='topic+l_getProjection'></span>

<h3>Description</h3>

<p>Query the matrix of projection vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_getProjection(target, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_getProjection_+3A_target">target</code></td>
<td>
<p>A object returned by <code>l_tour</code></p>
</td></tr>
<tr><td><code id="l_getProjection_+3A_data">data</code></td>
<td>
<p>Original data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of projection vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
  dat &lt;- iris[,-5]
  p &lt;- l_tour(dat, color = iris$Species,
              as.l_tour = FALSE)
  # scroll the bar
  proj &lt;- l_getProjection(p, dat)
  projected_object &lt;- as.matrix(dat) %*% proj
  # it will not be exactly the same
  plot(projected_object[,1], projected_object[,2],
       col = hex12tohex6(p['color']))
}
</code></pre>

<hr>
<h2 id='l_layer_callback'>Tour Layer Configuration</h2><span id='topic+l_layer_callback'></span>

<h3>Description</h3>

<p>Mainly used in the 2D (or 1D) tour interactive layer configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_layer_callback(target, layer, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_layer_callback_+3A_target">target</code></td>
<td>
<p>either a 'l_tour' object or a loon widget</p>
</td></tr>
<tr><td><code id="l_layer_callback_+3A_layer">layer</code></td>
<td>
<p>the layer need to be modified</p>
</td></tr>
<tr><td><code id="l_layer_callback_+3A_...">...</code></td>
<td>
<p>some useful info for the layer configuration (i.e. tours, projections, etc)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a <code>S3</code> method. The object class is determined by the layer **label**
</p>


<h3>Value</h3>

<p>this callback function does not return any object. As the
slider bar is scrolled, for the specified layer, the callback function
will be fired and the layer will be configured.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive() &amp;&amp; requireNamespace("tourr")) {
  # 1D tour
  p &lt;- l_tour(iris[, -5], tour = tourr::grand_tour(1L))
  # add layer density
  l &lt;- l_layer(l_getPlots(p),
               stats::density(p['x']),
               label = "density")

  # as we scroll the bar, the density curve does not change
  # unless the following function is executed
  l_layer_callback.density &lt;- function(target, layer, ...) {

      layer &lt;- loon::l_create_handle(c(l_getPlots(target), layer))
      den &lt;- stats::density(target['x'])

      loon::l_configure(layer,
                        x = den$x,
                        y = den$y)

      invisible()
  }
}

</code></pre>

<hr>
<h2 id='l_layer_density2d'>2D density layer</h2><span id='topic+l_layer_density2d'></span>

<h3>Description</h3>

<p>Two-dimensional kernel density estimation with an axis-aligned bivariate normal kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_layer_density2d(
  widget,
  x,
  y,
  h,
  n = 25L,
  lims = NULL,
  color = "black",
  linewidth = 1,
  nlevels = 10,
  levels = NULL,
  label = "density2d",
  parent = "root",
  index = 0,
  group = NULL,
  active = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_layer_density2d_+3A_widget">widget</code></td>
<td>
<p>'loon' widget path name as a string</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_x">x</code></td>
<td>
<p>The coordinates of <code>x</code>. See details</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_y">y</code></td>
<td>
<p>The coordinates of <code>y</code>. See details</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_h">h</code></td>
<td>

<p>vector of bandwidths for x and y directions.  Defaults to
normal reference bandwidth (see <code><a href="MASS.html#topic+bandwidth.nrd">bandwidth.nrd</a></code>). A scalar
value will be taken to apply to both directions.
</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_n">n</code></td>
<td>

<p>Number of grid points in each direction.  Can be scalar or a length-2
integer vector.
</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_lims">lims</code></td>
<td>

<p>The limits of the rectangle covered by the grid as <code>c(xl, xu, yl, yu)</code>.
</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_color">color</code></td>
<td>
<p>color of each contour</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_linewidth">linewidth</code></td>
<td>
<p>the line width</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_nlevels">nlevels</code></td>
<td>
<p>number of contour levels desired <b>iff</b>
<code>levels</code> is not supplied.</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_levels">levels</code></td>
<td>
<p>numeric vector of levels at which to draw contour
lines.</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_label">label</code></td>
<td>
<p>label used in the layers inspector</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_parent">parent</code></td>
<td>
<p>parent group layer</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_index">index</code></td>
<td>
<p>of the newly added layer in its parent group</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_group">group</code></td>
<td>
<p>separate x vector or y vector into a list by group</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_active">active</code></td>
<td>
<p>a logical determining whether points appear or not (default is <code>TRUE</code> for all points).
If a logical vector is given of length equal to the number of points,
then it identifies which points appear (<code>TRUE</code>) and which do not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="l_layer_density2d_+3A_...">...</code></td>
<td>
<p>other arguments to modify <code>l_layer_line</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>l_layer</code> widget
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
p &lt;- l_plot(iris, color = iris$Species)
l &lt;- l_layer_density2d(p)
}
</code></pre>

<hr>
<h2 id='l_layer_hull'>Layer a hull for <code>loon</code></h2><span id='topic+l_layer_hull'></span>

<h3>Description</h3>

<p>Creates a layer which is the subset of points lying on the hull (convex or alpha) of the set of points specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_layer_hull(
  widget,
  x,
  y,
  color = "black",
  linewidth = 1,
  label = "hull",
  parent = "root",
  index = 0,
  group = NULL,
  active = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_layer_hull_+3A_widget">widget</code></td>
<td>
<p>'loon' widget path name as a string</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_x">x</code></td>
<td>
<p>The coordinates of <code>x</code>. See details</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_y">y</code></td>
<td>
<p>The coordinates of <code>y</code>. See details</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_color">color</code></td>
<td>
<p>the line color of each hull</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_linewidth">linewidth</code></td>
<td>
<p>the line width</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_label">label</code></td>
<td>
<p>label used in the layers inspector</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_parent">parent</code></td>
<td>
<p>parent group layer</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_index">index</code></td>
<td>
<p>of the newly added layer in its parent group</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_group">group</code></td>
<td>
<p>separate x vector or y vector into a list by group</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_active">active</code></td>
<td>
<p>a logical determining whether points appear or not (default is <code>TRUE</code> for all points).
If a logical vector is given of length equal to the number of points,
then it identifies which points appear (<code>TRUE</code>) and which do not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="l_layer_hull_+3A_...">...</code></td>
<td>
<p>other arguments to modify <code>l_layer_line</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coordinates: the <code>x</code> or <code>y</code> can be a list or a vector.
</p>

<ul>
<li> <p>If they are vectors, the argument <code>group</code> will be used to set the groups.
</p>
</li>
<li> <p>If they are not provided, the <code>x</code> will be inherited from the widget
</p>
</li></ul>



<h3>Value</h3>

<p>an <code>l_layer</code> widget
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
p &lt;- l_plot(iris, color = iris$Species)
l &lt;- l_layer_hull(p, group = iris$Species)
}

</code></pre>

<hr>
<h2 id='l_layer_trails'>Display tour path with trails</h2><span id='topic+l_layer_trails'></span>

<h3>Description</h3>

<p>A 2D tour path with trails
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_layer_trails(
  widget,
  x,
  y,
  xpre,
  ypre,
  color = "black",
  linewidth = 1,
  label = "trails",
  parent = "root",
  index = 0,
  active = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_layer_trails_+3A_widget">widget</code></td>
<td>
<p>'loon' widget path name as a string</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_x">x</code></td>
<td>
<p>The coordinates of x representing the current state</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_y">y</code></td>
<td>
<p>The coordinates of y representing the current state</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_xpre">xpre</code></td>
<td>
<p>the same length of <code>x</code> representing the last state</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_ypre">ypre</code></td>
<td>
<p>the same length of <code>y</code> representing the last state</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_color">color</code></td>
<td>
<p>the color of the trail</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_linewidth">linewidth</code></td>
<td>
<p>the line width</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_label">label</code></td>
<td>
<p>label used in the layers inspector</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_parent">parent</code></td>
<td>
<p>parent group layer</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_index">index</code></td>
<td>
<p>of the newly added layer in its parent group</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_active">active</code></td>
<td>
<p>a logical determining whether points appear or not (default is <code>TRUE</code> for all points).
If a logical vector is given of length equal to the number of points,
then it identifies which points appear (<code>TRUE</code>) and which do not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="l_layer_trails_+3A_...">...</code></td>
<td>
<p>other arguments to modify <code>l_layer_line</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>l_layer</code> widget
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
p &lt;- l_tour(iris[, -5], color = iris$Species)
l &lt;- l_layer_trails(p, color = "grey50")
}
</code></pre>

<hr>
<h2 id='l_tour'>Tour in loon</h2><span id='topic+l_tour'></span>

<h3>Description</h3>

<p>An interactive tour in loon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_tour(
  data,
  scaling = c("data", "variable", "observation", "sphere"),
  by = NULL,
  on,
  as.l_tour = TRUE,
  color = loon::l_getOption("color"),
  tour_path = tourr::grand_tour(),
  group = "color",
  start = NULL,
  slicing = FALSE,
  slicingDistance = NULL,
  numOfTours = 30L,
  interpolation = 40L,
  parent = NULL,
  envir = parent.frame(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_tour_+3A_data">data</code></td>
<td>
<p>a data frame with numerical data only</p>
</td></tr>
<tr><td><code id="l_tour_+3A_scaling">scaling</code></td>
<td>
<p>one of 'variable', 'data', 'observation', 'sphere', or 'none' to specify how the data is scaled.
See Details</p>
</td></tr>
<tr><td><code id="l_tour_+3A_by">by</code></td>
<td>
<p>loon plot can be separated by some variables into multiple panels.
This argument can take a <code><a href="stats.html#topic+formula">formula</a></code>,
<code>n</code> dimensional state names (see <code><a href="loon.html#topic+l_nDimStateNames">l_nDimStateNames</a></code>)
an <code>n</code>-dimensional <code>vector</code> and <code>data.frame</code> or
a <code>list</code> of same lengths <code>n</code> as input.</p>
</td></tr>
<tr><td><code id="l_tour_+3A_on">on</code></td>
<td>
<p>if the <code>x</code> or <code>by</code> is a formula,
an optional data frame containing the variables in the <code>x</code> or <code>by</code>.
If the variables are not found in data, they are taken from environment,
typically the environment from which the function is called.</p>
</td></tr>
<tr><td><code id="l_tour_+3A_as.l_tour">as.l_tour</code></td>
<td>
<p>return a <code>l_tour</code> object; see details</p>
</td></tr>
<tr><td><code id="l_tour_+3A_color">color</code></td>
<td>
<p>vector with line colors. Default is given by <code><a href="loon.html#topic+l_getOption">l_getOption</a>("color")</code>.</p>
</td></tr>
<tr><td><code id="l_tour_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
<tr><td><code id="l_tour_+3A_group">group</code></td>
<td>
<p>only used for layers. As we scroll the bar, the layers are re-calculated.
This argument is used to specify which state is used to set groups (i.e. &quot;color&quot;, &quot;linewidth&quot;, etc).</p>
</td></tr>
<tr><td><code id="l_tour_+3A_start">start</code></td>
<td>
<p>projection to start at, if not specified, uses default
associated with tour path</p>
</td></tr>
<tr><td><code id="l_tour_+3A_slicing">slicing</code></td>
<td>
<p>whether to show a sliced scatter plot</p>
</td></tr>
<tr><td><code id="l_tour_+3A_slicingdistance">slicingDistance</code></td>
<td>
<p>the slicing distance that if the distance between
points and the projected plane is less than this distance, points will be
preserved; else points will be invisible. The default is <code>NULL</code> and a suggested
value will be given. See details</p>
</td></tr>
<tr><td><code id="l_tour_+3A_numoftours">numOfTours</code></td>
<td>
<p>the number of tours</p>
</td></tr>
<tr><td><code id="l_tour_+3A_interpolation">interpolation</code></td>
<td>
<p>the steps between two serial projections. The larger the value is,
the smoother the transitions would be.</p>
</td></tr>
<tr><td><code id="l_tour_+3A_parent">parent</code></td>
<td>
<p>a valid Tk parent widget path. When the parent widget is
specified (i.e. not <code>NULL</code>) then the plot widget needs to be placed using
some geometry manager like <code><a href="tcltk.html#topic+tkpack">tkpack</a></code> or <code><a href="tcltk.html#topic+tkplace">tkplace</a></code> in
order to be displayed. See the examples below.</p>
</td></tr>
<tr><td><code id="l_tour_+3A_envir">envir</code></td>
<td>
<p>the <code><a href="base.html#topic+environment">environment</a></code> to use.</p>
</td></tr>
<tr><td><code id="l_tour_+3A_...">...</code></td>
<td>
<p>named arguments to modify the serialaxes states or layouts, see details.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p>tour_path is a tour generator; available tours are <code><a href="tourr.html#topic+grand_tour">grand_tour</a></code>,
<code><a href="tourr.html#topic+dependence_tour">dependence_tour</a></code>, <code><a href="tourr.html#topic+frozen_tour">frozen_tour</a></code>, <code><a href="tourr.html#topic+guided_tour">guided_tour</a></code>,
<code><a href="tourr.html#topic+planned_tour">planned_tour</a></code>, and etc
</p>
</li>
<li> <p>Argument <code>as.l_tour</code>
</p>

<ul>
<li><p>If <code>TRUE</code>, a <code>l_tour</code> (or a <code>l_tour_compound</code>) object is returned. It is a list essentially with the
first object <code>loon</code> (tcl) widget and the second object matrix of projection vectors.
The benefit is that the matrix of projection vectors can be accessed via function <code>`[`</code> (or <code>l_cget</code>).
However, the drawback is that, since it is not a valid <code>loon</code> (tcl) widget
(call <code>l_isLoonWidget</code> would return **<code>FALSE</code>**)
</p>
</li>
<li><p>If <code>FALSE</code>: a valid <code>loon</code> (tcl) widget (call <code>l_isLoonWidget</code> would return &quot;TRUE&quot;) or a <code>l_compound</code>
object will be returned so that the matrix of projection vectors cannot be accessed directly from it.
However, function <code><a href="#topic+l_getProjection">l_getProjection</a></code> could return an estimated one.
</p>
</li></ul>


</li>
<li> <p>The <code>scaling</code> state defines how the data is scaled. The axes
display 0 at one end and 1 at the other. For the following explanation
assume that the data is in a n x p dimensional matrix. The scaling options
are then
</p>

<table>
<tr>
 <td style="text-align: left;">
variable </td><td style="text-align: left;"> per column scaling</td>
</tr>
<tr>
 <td style="text-align: left;">
observation </td><td style="text-align: left;"> per row scaling</td>
</tr>
<tr>
 <td style="text-align: left;">
data </td><td style="text-align: left;"> whole matrix scaling</td>
</tr>
<tr>
 <td style="text-align: left;">
sphere </td><td style="text-align: left;"> transforming variables to principal components</td>
</tr>

</table>

</li>
<li> <p>The default <code>slidingDistance</code> is suggested by Laa, U., Cook, D., &amp; Valencia, G. (2020).
First, find the maximum Euclidean distance of each observation (centralized), say <code>maxD</code>.
Then, compute the &quot;relative volume&quot; that <code>vRel</code> = (<code>maxD</code>^(d - 2))/10, where <code>d</code>
is the dimension of this data set. In the end, the suggested <code>slidingDistance</code>
is given by <code>vRel</code>^(1/(d - 2))

</p>
</li></ul>



<h3>Value</h3>

<p>an <code>l_tour</code> or an <code>l_tour_compound</code> object that
one can query the <code>loon</code> states and a matrix projection vectors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+l_getProjection">l_getProjection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive() &amp;&amp; requireNamespace('tourr')) {
  # 2D projection
  fl &lt;- tourr::flea[, 1:6]
  # different scaling will give very different projections
  # in this dataset, scaling 'variable' will give the best separation
  p &lt;- l_tour(fl, scaling = 'variable',
              color = tourr::flea$species)
  l0 &lt;- l_layer_hull(p, group = p["color"],
                     color = "red", linewidth = 4)
  l1 &lt;- l_layer_density2d(p)
  # a `l_tour` object
  class(p)

  # query the matrix of projection vectors
  proj &lt;- p['projection'] # or `l_getProjection(p)`
  # suppose the scaling is still 'observation'
  new_xy &lt;- as.matrix(
    loon::l_getScaledData(data = fl,
                          scaling = 'observation')) %*%
    proj
  plot(new_xy, xlab = "V1", ylab = "V2",
       col = loon::hex12tohex6(p['color']))

  # A higher dimension projection
  # turn the `tour` to 4 dimensional space
  s &lt;- l_tour(fl, color = tourr::flea$species,
              scaling = "observation",
              tour_path = tourr::grand_tour(4L))

  # set `as.l_tour` FALSE
  p &lt;- l_tour(fl, scaling = 'observation',
              color = tourr::flea$species)
  class(p)
  ## ERROR
  ## p["projection"]

  # query the estimated matrix of projection vectors
  l_getProjection(p)

  ##### facet by region
  olive &lt;- tourr::olive
  p &lt;- with(olive, l_tour(olive[, -c(1, 2)],
                          by = region,
                          color = area))
}
</code></pre>

<hr>
<h2 id='tour_pairs'>Tour Pairs Plot</h2><span id='topic+tour_pairs'></span><span id='topic+l_tour_pairs'></span>

<h3>Description</h3>

<p>A nD tour path with a scatterplot matrix (the default tour is a 4D tour;
by setting 'tour_path' to modify the dimension)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_tour_pairs(
  data,
  scaling = c("data", "variable", "observation", "sphere"),
  tour_path = tourr::grand_tour(4L),
  numOfTours = 30L,
  interpolation = 40L,
  as.l_tour = TRUE,
  connectedScales = c("none", "cross"),
  linkingGroup,
  linkingKey,
  showItemLabels = TRUE,
  itemLabel,
  showHistograms = FALSE,
  histLocation = c("edge", "diag"),
  histHeightProp = 1,
  histArgs = list(),
  showSerialAxes = FALSE,
  serialAxesArgs = list(),
  color = "grey60",
  group = "color",
  start = NULL,
  parent = NULL,
  span = 10L,
  envir = parent.frame(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tour_pairs_+3A_data">data</code></td>
<td>
<p>a data frame with numerical data only</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_scaling">scaling</code></td>
<td>
<p>one of 'variable', 'data', 'observation', 'sphere', or 'none' to specify how the data is scaled.
See Details</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_numoftours">numOfTours</code></td>
<td>
<p>the number of tours</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_interpolation">interpolation</code></td>
<td>
<p>the steps between two serial projections. The larger the value is,
the smoother the transitions would be.</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_as.l_tour">as.l_tour</code></td>
<td>
<p>return a <code>l_tour</code> object; see details</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_connectedscales">connectedScales</code></td>
<td>
<p>Determines how the scales of the panels are to be connected.
</p>

<ul>
<li><p><code>"cross"</code>: only the scales in the same row and the same column are connected;
</p>
</li>
<li><p><code>"none"</code>: neither &quot;x&quot; nor &quot;y&quot; scales are connected in any panels.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tour_pairs_+3A_linkinggroup">linkingGroup</code></td>
<td>
<p>string giving the linkingGroup for all plots. If missing,
a default <code>linkingGroup</code> will be determined from deparsing the <code>data</code>.</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_linkingkey">linkingKey</code></td>
<td>
<p>a vector of strings to provide a linking identity for each row of the
<code>data</code> data.frame.  If missing, a default <code>linkingKey</code> will be <code>0:(nrows(data)-1)</code>.</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_showitemlabels">showItemLabels</code></td>
<td>
<p>TRUE, logical indicating whether its itemLabel pops up over a point when
the mouse hovers over it.</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_itemlabel">itemLabel</code></td>
<td>
<p>a vector of strings to be used as pop up information when the mouse hovers
over a point.  If missing, the default <code>itemLabel</code> will be the <code>row.names(data)</code>.</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_showhistograms">showHistograms</code></td>
<td>
<p>logical (default FALSE) to show histograms of each variable
or not</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_histlocation">histLocation</code></td>
<td>
<p>one &quot;edge&quot; or &quot;diag&quot;, when showHistograms = TRUE</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_histheightprop">histHeightProp</code></td>
<td>
<p>a positive number giving the height of the histograms as a
proportion of the height of the scatterplots</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_histargs">histArgs</code></td>
<td>
<p>additional arguments to modify the 'l_hist' states</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_showserialaxes">showSerialAxes</code></td>
<td>
<p>logical (default FALSE) indication of whether to show a serial axes plot
in the bottom left of the pairs plot (or not)</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_serialaxesargs">serialAxesArgs</code></td>
<td>
<p>additional arguments to modify the 'l_serialaxes' states</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_color">color</code></td>
<td>
<p>vector with line colors. Default is given by <code><a href="loon.html#topic+l_getOption">l_getOption</a>("color")</code>.</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_group">group</code></td>
<td>
<p>only used for layers. As we scroll the bar, the layers are re-calculated.
This argument is used to specify which state is used to set groups (i.e. &quot;color&quot;, &quot;linewidth&quot;, etc).</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_start">start</code></td>
<td>
<p>projection to start at, if not specified, uses default
associated with tour path</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_parent">parent</code></td>
<td>
<p>a valid Tk parent widget path. When the parent widget is
specified (i.e. not <code>NULL</code>) then the plot widget needs to be placed using
some geometry manager like <code><a href="tcltk.html#topic+tkpack">tkpack</a></code> or <code><a href="tcltk.html#topic+tkplace">tkplace</a></code> in
order to be displayed. See the examples below.</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_span">span</code></td>
<td>
<p>How many column/row occupies for each widget</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_envir">envir</code></td>
<td>
<p>the <code><a href="base.html#topic+environment">environment</a></code> to use.</p>
</td></tr>
<tr><td><code id="tour_pairs_+3A_...">...</code></td>
<td>
<p>named arguments to modify the serialaxes states or layouts, see details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>l_tour_compound</code> object that one can query the <code>loon</code> states
and a matrix projection vectors
</p>


<h3>See Also</h3>

<p><code>l_pairs</code>, <code><a href="#topic+l_tour">l_tour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive() &amp;&amp; requireNamespace('tourr')) {
  # q is a `l_pairs` object
  q &lt;- l_tour_pairs(olive[, -c(1:2)],
                    color = olive$region)
  # query the matrix of projection vectors
  proj &lt;- q["projection"]

  # query the `l_compound` widget
  lc &lt;- l_getPlots(q)
  # pack the `density2d` layers
  layer_pack &lt;- lapply(lc, function(w) l_layer_density2d(w))

  #### set `as.l_tour = FALSE`
  # q is a `l_pairs` object
  q &lt;- l_tour_pairs(tourr::flea[, 1:6],
                    as.l_tour = FALSE,
                    color = tourr::flea$species,
                    showHistogram = TRUE,
                    showSerialAxes = TRUE)

  # proj &lt;- q["projection"] # Return a list of `NA`
  # query estimated matrix of projection vectors
  proj &lt;- l_getProjection(q, tourr::flea[, 1:6])
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
