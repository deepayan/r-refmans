<!DOCTYPE html><html><head><title>Help for package NORMA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NORMA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#f'><p>Predictor Function</p></a></li>
<li><a href='#ILF_cost_der'><p>Cost Functions Derivatives</p></a></li>
<li><a href='#linear_kernel'><p>Kernels</p></a></li>
<li><a href='#mle_parameters'><p>MLE Parameters</p></a></li>
<li><a href='#NORMA'><p>NORMA Optimization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Builds General Noise SVRs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-01-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Jesus Prada [aut,cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jesus Prada &lt;jesus.prada@estudiante.uam.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Builds general noise SVR models using Naive Online R Minimization Algorithm, NORMA, an optimization method based on classical stochastic gradient descent suitable for computing SVR models in an online setting.</td>
</tr>
<tr>
<td>Depends:</td>
<td>rootSolve</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://link.springer.com/chapter/10.1007/978-3-319-19222-2_47">http://link.springer.com/chapter/10.1007/978-3-319-19222-2_47</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-23 18:29:25 UTC; jesus</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-24 01:03:12</td>
</tr>
</table>
<hr>
<h2 id='f'>Predictor Function</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>Computes the predictor function of a general noise SVR based on NORMA optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(point, t, x, alpha, beta, f_0, kernel = function(x, y, gamma) {    
  exp(-gamma * (norm(x - y, type = "2")^2)) }, gamma, no_beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_+3A_point">point</code></td>
<td>
<p><code>numeric</code> with the value of the point where we want to evaluate the predictor function.</p>
</td></tr>
<tr><td><code id="f_+3A_t">t</code></td>
<td>
<p>time parameter value indicating the iteration we want to consider.</p>
</td></tr>
<tr><td><code id="f_+3A_x">x</code></td>
<td>
<p><code>matrix</code> containing training points. Each row must be
a point.</p>
</td></tr>
<tr><td><code id="f_+3A_alpha">alpha</code></td>
<td>
<p><code>matrix</code> representing <code class="reqn">\alpha</code> parameters of NORMA optimization in each iteration, one per row.</p>
</td></tr>
<tr><td><code id="f_+3A_beta">beta</code></td>
<td>
<p><code>numeric</code> representing <code class="reqn">\beta</code> parameter of NORMA optimization in each iteration.</p>
</td></tr>
<tr><td><code id="f_+3A_f_0">f_0</code></td>
<td>
<p>initial hypothesis.</p>
</td></tr>
<tr><td><code id="f_+3A_kernel">kernel</code></td>
<td>
<p>kernel function to use.</p>
</td></tr>
<tr><td><code id="f_+3A_gamma">gamma</code></td>
<td>
<p>gaussian kernel parameter <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="f_+3A_no_beta">no_beta</code></td>
<td>
<p><code>boolean</code> indicating if an offset <code class="reqn">b</code> is used (FALSE) or not (TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>numeric</code> representing the prediction value.
</p>


<h3>Author(s)</h3>

<p>Jesus Prada, <a href="mailto:jesus.prada@estudiante.uam.es">jesus.prada@estudiante.uam.es</a>
</p>


<h3>References</h3>

<p>Link to the scientific paper
</p>
<p>Kivinen J., Smola A. J., Williamson R.C.: Online learning with kernels. In: IEEE
transactions on signal processing, vol. 52, pp. 2165-2176, IEEE (2004).
</p>
<p>with theoretical background for NORMA optimization is provided below.
</p>
<p><a href="http://realm.sics.se/papers/KivSmoWil04(1).pdf">http://realm.sics.se/papers/KivSmoWil04(1).pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f(c(1,2,3),2,matrix(c(1,2,3,4,5,6),nrow=2,ncol=3,byrow=TRUE),
matrix(c(1,2,3,4,5,6),nrow=2,ncol=3,byrow=TRUE),
c(1,2),0,function(x,y,gamma=0){x%*%y},0.1,FALSE)
</code></pre>

<hr>
<h2 id='ILF_cost_der'>Cost Functions Derivatives</h2><span id='topic+ILF_cost_der'></span><span id='topic+beta_cost_der'></span><span id='topic+general_gaussian_cost_der'></span><span id='topic+general_laplace_cost_der'></span><span id='topic+moge_cost_der'></span><span id='topic+weibull_cost_der'></span><span id='topic+zero_gaussian_cost_der'></span><span id='topic+zero_laplace_cost_der'></span>

<h3>Description</h3>

<p><code>ILF_cost_der</code> computes the ILF derivative value at a given point.
</p>
<p><code>zero_laplace_cost_der</code> computes the value at a given point of the loss function derivative
corresponding to a zero-mean Laplace distribution.
</p>
<p><code>general_laplace_cost_der</code> computes the value at a given point of the loss function derivative
corresponding to a general Laplace distribution.
</p>
<p><code>zero_gaussian_cost_der</code> computes the value at a given point of the loss function derivative
corresponding to a zero-mean Gaussian distribution.
</p>
<p><code>general_gaussian_cost_der</code> computes the value at a given point of the loss function derivative
corresponding to a general Gaussian distribution.
</p>
<p><code>beta_cost_der</code> computes the value at a given point of the loss function derivative
corresponding to a Beta distribution.
</p>
<p><code>weibull_cost_der</code> computes the value at a given point of the loss function derivative
corresponding to a Weibull distribution.
</p>
<p><code>moge_cost_der</code> computes the value at a given point of the loss function derivative
corresponding to a MOGE distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ILF_cost_der(phi, epsilon = 0.1, nu = 0)

zero_laplace_cost_der(phi, sigma)

general_laplace_cost_der(phi, sigma, mu)

zero_gaussian_cost_der(phi, sigma_cuad)

general_gaussian_cost_der(phi, sigma_cuad, mu)

beta_cost_der(phi, alpha, beta)

weibull_cost_der(phi, lambda, kappa)

moge_cost_der(phi, lambda, alpha, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ILF_cost_der_+3A_phi">phi</code></td>
<td>
<p>point to use as argument of the loss function derivative.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_epsilon">epsilon</code></td>
<td>
<p>width of the insensitive band.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_nu">nu</code></td>
<td>
<p>parameter to control value of <code>epsilon</code>.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_sigma">sigma</code></td>
<td>
<p>scale parameter of the Laplace distribution.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_mu">mu</code></td>
<td>
<p>location or mean parameter of the Laplace or Gaussian distribution, respectively.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_sigma_cuad">sigma_cuad</code></td>
<td>
<p>variance parameter of the Gaussian distribution.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_alpha">alpha</code></td>
<td>
<p>shape1 parameter of the Beta distribution or second parameter of the MOGE distribution.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_beta">beta</code></td>
<td>
<p>shape2 parameter of the Beta distribution.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_lambda">lambda</code></td>
<td>
<p>lambda scale parameter of the Weibull distribution or first parameter of the MOGE distribution.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_kappa">kappa</code></td>
<td>
<p>shape parameter of the Weibull distribution.</p>
</td></tr>
<tr><td><code id="ILF_cost_der_+3A_theta">theta</code></td>
<td>
<p>third parameter of the MOGE distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also 'References'.
</p>


<h3>Value</h3>

<p>Returns a <code>numeric</code> representing the derivative value at a given point.
</p>


<h3>Author(s)</h3>

<p>Jesus Prada, <a href="mailto:jesus.prada@estudiante.uam.es">jesus.prada@estudiante.uam.es</a>
</p>


<h3>References</h3>

<p>Link to the scientific paper
</p>
<p>Prada, Jesus, and Jose Ramon Dorronsoro. &quot;SVRs and Uncertainty Estimates in Wind 
Energy Prediction.&quot; Advances in Computational Intelligence. Springer International 
Publishing, 2015. 564-577,
</p>
<p>with theoretical background for this package is provided below.
</p>
<p><a href="http://link.springer.com/chapter/10.1007/978-3-319-19222-2_47">http://link.springer.com/chapter/10.1007/978-3-319-19222-2_47</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ILF derivative value at point phi=1 with default epsilon.
ILF_cost_der(1)

# ILF derivative value at point phi=1 with epsilon=2.
ILF_cost_der(1,2)

# Zero-mean Laplace loss function derivative value at point phi=1 with sigma=1.
zero_laplace_cost_der(1,1)

# General Laplace loss function derivative value at point phi=1 with mu=0 and sigma=1.
general_laplace_cost_der(1,1,0)

# Zero-mean Gaussian loss function derivative value at point phi=1 with sigma_cuad=1.
zero_gaussian_cost_der(1,1)

# General Gaussian loss function derivative value at point phi=1 with mu=0 and sigma_cuad=1.
general_gaussian_cost_der(1,1,0)

# Beta loss function derivative value at point phi=1 with alpha=2 and beta=3.
beta_cost_der(1,2,3)

# Weibull loss function derivative value at point phi=1 with lambda=2 and kappa=3.
weibull_cost_der(1,2,3)

# MOGE loss function derivative value at point phi=1 with lambda=2 ,alpha=3 and theta=4.
moge_cost_der(1,2,3,4)
</code></pre>

<hr>
<h2 id='linear_kernel'>Kernels</h2><span id='topic+gaussian_kernel'></span><span id='topic+linear_kernel'></span>

<h3>Description</h3>

<p><code>linear_kernel</code> computes the linear kernel between two given vector, <code class="reqn">x</code> and <code class="reqn">y</code>.
</p>
<p><code>gaussian_kernel</code> computes the gaussian kernel between two given vectors, <code class="reqn">x</code> and <code class="reqn">y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_kernel(x, y, gamma = 0)

gaussian_kernel(x, y, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_kernel_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector indicating value of <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="linear_kernel_+3A_y">y</code></td>
<td>
<p><code>numeric</code> vector indicating value of <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="linear_kernel_+3A_gamma">gamma</code></td>
<td>
<p>gaussian kernel parameter <code class="reqn">\gamma</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linear kernel: </p>
<p style="text-align: center;"><code class="reqn">k(x,y) = x*y</code>
</p>

<p>Gaussian kernel: </p>
<p style="text-align: center;"><code class="reqn">k(x,y) = exp(-\gamma||x-y||^2)</code>
</p>



<h3>Value</h3>

<p>Returns a <code>numeric</code> representing the kernel value.
</p>


<h3>Author(s)</h3>

<p>Jesus Prada, <a href="mailto:jesus.prada@estudiante.uam.es">jesus.prada@estudiante.uam.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Linear kernel value between point x=c(1,2,3) and point y=c(2,3,4).
linear_kernel(c(1,2,3),c(2,3,4))

# Gaussian kernel value between point x=c(1,2,3) and point y=c(2,3,4) with gamma=0.1.
gaussian_kernel(c(1,2,3),c(2,3,4),0.1)
</code></pre>

<hr>
<h2 id='mle_parameters'>MLE Parameters</h2><span id='topic+beta_mle'></span><span id='topic+general_gaussian_mle'></span><span id='topic+general_laplace_mle'></span><span id='topic+mle_parameters'></span><span id='topic+moge_mle'></span><span id='topic+weibull_mle'></span><span id='topic+zero_gaussian_mle'></span><span id='topic+zero_laplace_mle'></span>

<h3>Description</h3>

<p><code>mle_parameters</code> computes the optimal parameters via MLE of
a given distribution.
</p>
<p><code>zero_laplace_mle</code> computes the optimal parameters via MLE
assuming a zero-mean Laplace as noise distribution.
</p>
<p><code>general_laplace_mle</code> computes the optimal parameters via MLE 
assuming a general Laplace as noise distribution.
</p>
<p><code>zero_gaussian_mle</code> computes the optimal parameters via MLE 
assuming a zero-mean Gaussian as noise distribution.
</p>
<p><code>general_gaussian_mle</code> computes the optimal parameters via MLE 
assuming a general Gaussian as noise distribution.
</p>
<p><code>beta_mle</code> computes the optimal parameters via MLE 
assuming a Beta as noise distribution.
</p>
<p><code>weibull_mle</code> computes the optimal parameters via MLE 
assuming a Weibull as noise distribution.
</p>
<p><code>moge_mle</code> computes the optimal parameters via MLE 
assuming a MOGE as noise distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle_parameters(phi, dist = "nm", ...)

zero_laplace_mle(phi)

general_laplace_mle(phi)

zero_gaussian_mle(phi)

general_gaussian_mle(phi)

beta_mle(phi, m1 = mean(phi, na.rm = T), m2 = mean(phi^2, na.rm = T),
  alpha_0 = (m1 * (m1 - m2))/(m2 - m1^2), beta_0 = (alpha_0 * (1 - m1)/m1))

weibull_mle(phi, k_0 = 1)

moge_mle(phi, lambda_0 = 1, alpha_0 = 1, theta_0 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle_parameters_+3A_phi">phi</code></td>
<td>
<p>a vector with residual values used to estimate the parameters.</p>
</td></tr>
<tr><td><code id="mle_parameters_+3A_dist">dist</code></td>
<td>
<p>assumed distribution for the noise in the data. Possible values to take:
</p>

<ul>
<li><p>l: Zero-mean Laplace distribution.
</p>
</li>
<li><p>lm: General Laplace distribution.
</p>
</li>
<li><p>n: Zero-mean Gaussian distribution.
</p>
</li>
<li><p>nm: General Gaussian distribution.
</p>
</li>
<li><p>b: Beta distribution.
</p>
</li>
<li><p>w: Weibull distribution.
</p>
</li>
<li><p>moge: MOGE distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mle_parameters_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level
functions (see below).</p>
</td></tr>
<tr><td><code id="mle_parameters_+3A_m1">m1</code></td>
<td>
<p>first moment of the residuals. Used to compute <code>alpha_0</code>.</p>
</td></tr>
<tr><td><code id="mle_parameters_+3A_m2">m2</code></td>
<td>
<p>second moment of the residuals. Used to compute <code>beta_0</code>.</p>
</td></tr>
<tr><td><code id="mle_parameters_+3A_alpha_0">alpha_0</code></td>
<td>
<p>initial value for Newton-Raphson method for the parameter <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="mle_parameters_+3A_beta_0">beta_0</code></td>
<td>
<p>initial value for Newton-Raphson method for the parameter <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="mle_parameters_+3A_k_0">k_0</code></td>
<td>
<p>initial value for Newton-Raphson method for the parameter <code class="reqn">\kappa</code>.</p>
</td></tr>
<tr><td><code id="mle_parameters_+3A_lambda_0">lambda_0</code></td>
<td>
<p>initial value for Newton-Raphson method for the parameter <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="mle_parameters_+3A_theta_0">theta_0</code></td>
<td>
<p>initial value for Newton-Raphson method for the parameter <code class="reqn">\theta</code>.
</p>
<p>See also 'Details' and multiroot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the zero-<code class="reqn">\mu</code> Laplace distribution the optimal MLE parameters are
</p>
<p style="text-align: center;"><code class="reqn">\sigma=mean(|\phi_i|)</code>
</p>
<p>, where <code class="reqn">{\phi_i}</code> are the residuals passed as argument.
</p>
<p>For the general Laplace distribution the optimal MLE parameters are
</p>
<p style="text-align: center;"><code class="reqn">\mu=median(\phi_i)</code>
</p>
<p style="text-align: center;"><code class="reqn">\sigma=mean(|\phi_i - \mu|)</code>
</p>
<p>, where <code class="reqn">{\phi_i}</code> are the residuals passed as argument.
</p>
<p>For the zero-<code class="reqn">\mu</code> Gaussian distribution the optimal MLE parameters are
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2=mean(\phi_i^2)</code>
</p>
<p>, where <code class="reqn">{\phi_i}</code> are the residuals passed as argument.
</p>
<p>For the general Gaussian distribution the optimal MLE parameters are
</p>
<p style="text-align: center;"><code class="reqn">\mu=mean(\phi_i)</code>
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2=mean((\phi_i-\mu)^2)</code>
</p>
<p>, where <code class="reqn">{\phi_i}</code> are the residuals passed as argument.
</p>
<p>For the Beta distribution values of parameters <code class="reqn">\alpha</code> and
<code class="reqn">\beta</code> are estimated using Newton-Raphson method.
</p>
<p>For the Weibull distribution value of parameter <code class="reqn">\kappa</code> is estimated using Newton-Raphson method
and then estimated value of <code class="reqn">\lambda</code> is computed using the following closed form that depends on <code class="reqn">\kappa</code>:
</p>
<p style="text-align: center;"><code class="reqn">\lambda=mean(\phi_i^kappa)^(1/\kappa)</code>
</p>

<p>For the MOGE distribution values of parameters <code class="reqn">\lambda</code>, <code class="reqn">\alpha</code> and
<code class="reqn">\theta</code> are estimated using Newton-Raphson method.
</p>
<p>See also 'References'.
</p>


<h3>Value</h3>

<p><code>mle_parameters</code> returns a list with the estimated parameters. Depending on the distribution
these parameters will be one or more of the following ones:
</p>

<dl>
<dt>sigma</dt><dd><p>scale parameter of the Laplace distribution.</p>
</dd>
<dt>mu</dt><dd><p>location or mean parameter of the Laplace or Gaussian distribution,
respectively.</p>
</dd>
<dt>sigma_cuad</dt><dd><p>variance parameter of the Gaussian distribution.</p>
</dd>
<dt>alpha</dt><dd><p>shape1 parameter of the Beta distribution or second parameter of the MOGE distribution.</p>
</dd>
<dt>beta</dt><dd><p>shape2 parameter of the Beta distribution.</p>
</dd>
<dt>k</dt><dd><p>shape parameter of the Weibull distribution.</p>
</dd>
<dt>lambda</dt><dd><p>lambda scale parameter of the Weibull distribution or first parameter of the MOGE distribution.</p>
</dd>
<dt>theta</dt><dd><p>third parameter of the MOGE distribution.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jesus Prada, <a href="mailto:jesus.prada@estudiante.uam.es">jesus.prada@estudiante.uam.es</a>
</p>


<h3>References</h3>

<p>Link to the scientific paper
</p>
<p>Prada, Jesus, and Jose Ramon Dorronsoro. &quot;SVRs and Uncertainty Estimates in Wind 
Energy Prediction.&quot; Advances in Computational Intelligence. Springer International 
Publishing, 2015. 564-577,
</p>
<p>with theoretical background for this package is provided below.
</p>
<p><a href="http://link.springer.com/chapter/10.1007/978-3-319-19222-2_47">http://link.springer.com/chapter/10.1007/978-3-319-19222-2_47</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate optimal parameters using default distribution ("nm").
mle_parameters(rnorm(100))

# Estimate optimal parameters using "lm" distribution.
mle_parameters(rnorm(100),dist="lm")

# Equivalent to mle_parameters(rnorm(100),dist="l")
zero_laplace_mle(rnorm(100))

# Equivalent to mle_parameters(rnorm(100),dist="lm")
general_laplace_mle(rnorm(100))

# Equivalent to mle_parameters(rnorm(100),dist="n")
zero_gaussian_mle(rnorm(100))

# Equivalent to mle_parameters(rnorm(100),dist="nm")
general_gaussian_mle(rnorm(100))

# Equivalent to mle_parameters(rnorm(100),dist="b")
beta_mle(rnorm(100))

# Equivalent to mle_parameters(rnorm(100),dist="w")
weibull_mle(rnorm(100))

# Equivalent to mle_parameters(rnorm(100),dist="moge")
moge_mle(rnorm(100))
</code></pre>

<hr>
<h2 id='NORMA'>NORMA Optimization</h2><span id='topic+NORMA'></span>

<h3>Description</h3>

<p>Computes general noise SVR based on NORMA optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NORMA(x, y, f_0 = 0, beta_0 = 0, lambda = 0, rate = function(t) {     1
  }, kernel = linear_kernel, cost_der = ILF_cost_der,
  cost_name = "ILF_cost_der", gamma = 1, max_iterations = nrow(x),
  stopping_threshold = 0, trace = TRUE, no_beta = TRUE,
  fixed_epsilon = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NORMA_+3A_x">x</code></td>
<td>
<p><code>matrix</code> containing training points. Each row must be a point.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_y">y</code></td>
<td>
<p><code>numeric</code> containing target for training points <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_f_0">f_0</code></td>
<td>
<p>initial hypothesis.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_beta_0">beta_0</code></td>
<td>
<p>initial value for offset <code class="reqn">b</code>.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_lambda">lambda</code></td>
<td>
<p>NORMA optimization parameter <code class="reqn">lambda</code></p>
</td></tr>
<tr><td><code id="NORMA_+3A_rate">rate</code></td>
<td>
<p>learning rate for NORMA optimization. Must be a function with one argument.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_kernel">kernel</code></td>
<td>
<p>kernel function to use. Must be a function with three arguments such as <code>gaussian_kernel</code>.
See also <a href="#topic+linear_kernel">linear_kernel</a></p>
</td></tr>
<tr><td><code id="NORMA_+3A_cost_der">cost_der</code></td>
<td>
<p>Loss function derivative to use. See also <a href="#topic+ILF_cost_der">ILF_cost_der</a>. Must be &quot;ILF_cost_der&quot; when
ILF derivative is used.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_cost_name">cost_name</code></td>
<td>
<p><code>character</code> indicating the symbolic name of <code>cost_der</code>.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_gamma">gamma</code></td>
<td>
<p>gaussian kernel parameter <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_max_iterations">max_iterations</code></td>
<td>
<p>maximum number of NORMA iterations computed.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_stopping_threshold">stopping_threshold</code></td>
<td>
<p>value indicating when to stop NORMA optimization. See also 'Details'.</p>
</td></tr>
<tr><td><code id="NORMA_+3A_trace">trace</code></td>
<td>
<p><code>boolean</code> indicating if information messages should be printed (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="NORMA_+3A_no_beta">no_beta</code></td>
<td>
<p><code>boolean</code> indicating if an offset <code class="reqn">b</code> is used (FALSE) or not (TRUE).</p>
</td></tr>
<tr><td><code id="NORMA_+3A_fixed_epsilon">fixed_epsilon</code></td>
<td>
<p><code>boolean</code> indicating if <code>epsilon</code> should be updated (FALSE) or not (TRUE).</p>
</td></tr>
<tr><td><code id="NORMA_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optimization will stop when the sum of the differences between all training predicted values of present
iteration versus values from previous iteration does not exceeds <code>stopping_threshold</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>list</code> containing:
</p>

<dl>
<dt>alpha</dt><dd><p><code>matrix</code> representing <code class="reqn">\alpha</code> parameters of NORMA optimization in each iteration, one per row.</p>
</dd>
<dt>beta</dt><dd><p><code>numeric</code> representing <code class="reqn">\beta</code> parameter of NORMA optimization in each iteration.</p>
</dd>
<dt>n_iterations</dt><dd><p>Number of NORMA iterations performed.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jesus Prada, <a href="mailto:jesus.prada@estudiante.uam.es">jesus.prada@estudiante.uam.es</a>
</p>


<h3>References</h3>

<p>Link to the scientific paper
</p>
<p>Kivinen J., Smola A. J., Williamson R.C.: Online learning with kernels. In: IEEE
transactions on signal processing, vol. 52, pp. 2165-2176, IEEE (2004).
</p>
<p>with theoretical background for NORMA optimization is provided below.
</p>
<p><a href="http://realm.sics.se/papers/KivSmoWil04(1).pdf">http://realm.sics.se/papers/KivSmoWil04(1).pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NORMA(x=matrix(rnorm(10),nrow=10,ncol=1,byrow=TRUE),y=rnorm(10),kernel=function(x,y,gamma=0){x%*%y},
cost_der=function(phi,sigma_cuad,mu){return((phi-mu)/sigma_cuad)},cost_name="example",
sigma_cuad=1,mu=0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
