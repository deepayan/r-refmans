<!DOCTYPE html><html><head><title>Help for package GSSE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GSSE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EM_PAVA_Func'>
<p>EM-PAVA function</p></a></li>
<li><a href='#GSSE-package'>
<p>Genotype-Specific Survival Estimation</p></a></li>
<li><a href='#p0G_data'>
<p>Data Set for Illustration of the &lsquo;p0G&rsquo; Calculation</p></a></li>
<li><a href='#p0G_Func'>
<p>Probability Calculation of Relative's Mutation Status</p></a></li>
<li><a href='#Permutation_Test'>
<p>Permutation Test</p></a></li>
<li><a href='#Sieve_NPMLE_Bootstrap'>
<p>Sieve_NPMLE_Bootstrap function</p></a></li>
<li><a href='#Sieve_NPMLE_Switch'>
<p>Sieve_NPMLE_Switch function</p></a></li>
<li><a href='#Simulated_data'>
<p>Simulated Parkinson's disease data</p></a></li>
<li><a href='#test_stat'>
<p>Kolmogorov-Smirnov Test Statistic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genotype-Specific Survival Estimation</td>
</tr>
<tr>
<td>Description:</td>
<td>We propose a fully efficient sieve maximum likelihood method to estimate genotype-specific distribution of time-to-event outcomes under a nonparametric model. We can handle missing genotypes in pedigrees.  We estimate the time-dependent hazard ratio between two genetic mutation groups using B-splines, while applying nonparametric maximum likelihood estimation to the reference baseline hazard function.  The estimators are calculated via an expectation-maximization algorithm.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-10-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Baosheng Liang, Yuanjia Wang and Donglin Zeng</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Baosheng Liang &lt;liangbsunc@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>Iso (&ge; 0.0-17), splines, stats, zoo (&ge; 1.7-12)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-10-20 01:00:51 UTC; BLiang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-10-20 08:06:35</td>
</tr>
</table>
<hr>
<h2 id='EM_PAVA_Func'>
EM-PAVA function
</h2><span id='topic+EM_PAVA_Func'></span>

<h3>Description</h3>

<p>This function is used to estimate the genotype-specific distribution of time-to-event outcomes using EM-PAVA algorithm (Qin et al. 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM_PAVA_Func (q, x, delta, timeval, p, ep = 1e-05, maxiter = 400)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM_PAVA_Func_+3A_q">q</code></td>
<td>
<p>matrix of 2 columns, where the first and second columns are the probabilities of belonging to the carrier <code>p0G</code> and non-carrier groups <code>1 - p0G</code>, respectively.</p>
</td></tr>
<tr><td><code id="EM_PAVA_Func_+3A_x">x</code></td>
<td>
<p>observed event time or censoring time.</p>
</td></tr>
<tr><td><code id="EM_PAVA_Func_+3A_delta">delta</code></td>
<td>
<p>indicator of event.</p>
</td></tr>
<tr><td><code id="EM_PAVA_Func_+3A_timeval">timeval</code></td>
<td>
<p>grid points at which the distribution function values are estimated.</p>
</td></tr>
<tr><td><code id="EM_PAVA_Func_+3A_p">p</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code id="EM_PAVA_Func_+3A_ep">ep</code></td>
<td>
<p>convergence criterion. Here, <code>ep = 1e-5</code> is used as the default value.</p>
</td></tr>
<tr><td><code id="EM_PAVA_Func_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of EM iterations. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technical details can be found in Qin et al. (2014).
</p>


<h3>Value</h3>

<p>Returns a list of prediction values for classes
</p>
<table>
<tr><td><code>Fest</code></td>
<td>
<p>estimated values at the points of <code>timeval</code>.</p>
</td></tr>
<tr><td><code>Fest.all</code></td>
<td>
<p>estimated values of cumulative distribution function on both carrier and non-carrier groups.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Qin, J., Garcia, T., Ma, Y., Tang, M., Marder, K. &amp; Wang, Y. (2014). Combining isotonic regression and EM algorithm to predict genetic risk under monotonicity constraint. <em>The Annals of Applied Statistics</em> <b>8</b>(2), 1182-1208.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+p0G_Func">p0G_Func</a>()</code>, <code><a href="#topic+Sieve_NPMLE_Switch">Sieve_NPMLE_Switch</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Simulated_data");

OY = Simulated_data[,2];
ind = order(OY);
ODelta = Simulated_data[,3];
Op0G = Simulated_data[,4];

Y = OY[ind];
Delta = ODelta[ind];
p0G = Op0G[ind];

Grid = seq(0.01, 3.65, 0.01);
fix_t1 = c(0.288, 0.693, 1.390);
fix_t2 = c(0.779, 1.860, 3.650);

EMpava_result = EM_PAVA_Func ( q = rbind(p0G,1-p0G), x = Y, delta = Delta, 
                               timeval = Grid, p = 2, ep = 1e-4 );

all = sort(c(Grid, Y));

F_carr_func = function(x){  EMpava_result$Fest.all[1, which.max(all[all &lt;= x]) ]  };
F_non_func  = function(x){  EMpava_result$Fest.all[2, which.max(all[all &lt;= x]) ]  };

PAVA_F1.hat_fix_t = apply( matrix(fix_t1, ncol=1), 1, F_carr_func );
PAVA_F2.hat_fix_t = apply( matrix(fix_t2, ncol=1), 1, F_non_func );

PAVA_F.hat_fix_t = data.frame( fix_t1 = fix_t1, PAVA_F1.hat = PAVA_F1.hat_fix_t,
                               fix_t2 = fix_t2, PAVA_F2.hat = PAVA_F2.hat_fix_t  );

print(PAVA_F.hat_fix_t);

# plot estimated curves

F_carr = apply( matrix(Grid, ncol=1), 1, F_carr_func );
F_non = apply( matrix(Grid, ncol=1), 1, F_non_func );

plot( Grid, F_carr, type = 's', lty = 1, 
      xlab = "Y", ylab = "Estimated Cumulative Distribution Function",
      ylim = c(0,1), col = 'blue' );
lines(Grid, F_non, type='s', lty=2, col='red');
legend("topleft", legend=c("Carrier group", "Non-Carrier group"),
       lty=c(1,2), col=c("blue", "red") );

</code></pre>

<hr>
<h2 id='GSSE-package'>
Genotype-Specific Survival Estimation
</h2><span id='topic+GSSE-package'></span><span id='topic+GSSE'></span>

<h3>Description</h3>

<p>The package &lsquo;GSSE&rsquo; (Genotype-Specific Survival Estimation) is made to implement a fully efficient sieve maximum likelihood method to estimate genotype-specific distribution of time-to-event outcomes under a nonparametric model. The package can handle missing genotypes in pedigrees.  We estimate time-dependent hazard ratio between two genetic mutation groups using B-splines and apply nonparametric maximum likelihood estimation to the reference baseline hazard function. The estimators are calculated via an expectation-maximization algorithm.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GSSE</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-10-17</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main function is <code><a href="#topic+Sieve_NPMLE_Switch">Sieve_NPMLE_Switch</a>()</code>. See the documentation file with examples.
</p>


<h3>Author(s)</h3>

<p>Baosheng Liang &lt;liangbsunc@gmail.com&gt;, Yuanjia Wang &lt;yw2016@cumc.columbia.edu&gt; and Donglin Zeng &lt;dzeng@email.unc.edu&gt;
</p>
<p>Maintainer: Baosheng Liang &lt;liangbsunc@gmail.com&gt;
</p>


<h3>References</h3>

<p>Wang, Y., Clark, L. N., Louis, E. D., Mejia-Santana, H., Harris, J., Cote, L. J., ... &amp; Marder, K. (2008). Risk of Parkinson disease in carriers of parkin mutations: estimation using the kin-cohort method. <em>Archives of neurology</em>, <b>65</b>(4), 467-474.
</p>
<p>Qin, J., Garcia, T., Ma, Y., Tang, M., Marder, K. &amp; Wang, Y. (2014). Combining isotonic regression and EM algorithm to predict genetic risk under monotonicity constraint. <em>The Annals of Applied Statistics</em> <b>8</b>(2), 1182-1208.
</p>
<p>Wang, Y., Liang, B., Tong, X., Marder, K., Bressman, S., Orr-Urtreger, A., Giladi, N. &amp; Zeng, D. (2015). Efficient estimation of nonparametric genetic risk function with censored data. <em>Biometrika</em>, <b>102</b>(3), 515-532.
</p>

<hr>
<h2 id='p0G_data'>
Data Set for Illustration of the &lsquo;p0G&rsquo; Calculation
</h2><span id='topic+p0G_data'></span>

<h3>Description</h3>

<p>This is a small data set used for illustration of the &lsquo;p0G&rsquo; calculation. There are 2 columns, 20 rows in this data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("p0G_data")</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 2 columns with
</p>

<dl>
<dt><code>relative</code></dt><dd><p>a factor with levels <code>Child</code>, <code>Parent</code> and <code>Sibling</code>,</p>
</dd>
<dt><code>proband_pd</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>This data set is a tiny subset of the data set of a Parkinson disease research project supported by Michael J. Fox Foundation.
</p>


<h3>References</h3>

<p>Wang, Y., Clark, L. N., Louis, E. D., Mejia-Santana, H., Harris, J., Cote, L. J., ... &amp; Marder, K. (2008). Risk of Parkinson disease in carriers of parkin mutations: estimation using the kin-cohort method. <em>Archives of neurology</em>, <b>65</b>(4), 467-474.
</p>
<p>Wang, Y., Liang, B., Tong, X., Marder, K., Bressman, S., Orr-Urtreger, A., Giladi, N. &amp; Zeng, D. (2015). Efficient estimation of nonparametric genetic risk function with censored data. <em>Biometrika</em>, <b>102</b>(3), 515-532.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+p0G_Func">p0G_Func</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data("p0G_data")
</code></pre>

<hr>
<h2 id='p0G_Func'>
Probability Calculation of Relative's Mutation Status
</h2><span id='topic+p0G_Func'></span>

<h3>Description</h3>

<p>This function is used to calculate the probability of a relative being a carrier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p0G_Func (p, status, relative, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p0G_Func_+3A_p">p</code></td>
<td>
<p>population frequency of mutation.</p>
</td></tr>
<tr><td><code id="p0G_Func_+3A_status">status</code></td>
<td>
<p>proband's carrier status (<code>status</code> = 0, non-carrier; = 1, homozygous; = 2, heterozygous).</p>
</td></tr>
<tr><td><code id="p0G_Func_+3A_relative">relative</code></td>
<td>
<p>relative's relationship to the proband (<code>relative</code> = 1, parents; = 2, sibling; = 3, offspring). </p>
</td></tr>
<tr><td><code id="p0G_Func_+3A_model">model</code></td>
<td>
<p>assumed genetic model (&quot;dominant&quot; or &quot;recessive&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technical details can be found in Wang et al. (2008).
</p>


<h3>Value</h3>

<p>The function <code>p0G_Func</code> returns the probability of a relative being a carrier under the given genetic model.
</p>


<h3>References</h3>

<p>Wang, Y., Clark, L. N., Louis, E. D., Mejia-Santana, H., Harris, J., Cote, L. J., ... &amp; Marder, K. (2008). Risk of Parkinson disease in carriers of parkin mutations: estimation using the kin-cohort method. <em>Archives of neurology</em>, <b>65</b>(4), 467-474.
</p>
<p>Wang, Y., Liang, B., Tong, X., Marder, K., Bressman, S., Orr-Urtreger, A., Giladi, N. &amp; Zeng, D. (2015). Efficient estimation of nonparametric genetic risk function with censored data. <em>Biometrika</em>, <b>102</b>(3), 515-532.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+p0G_data">p0G_data</a></code>, <code><a href="#topic+Sieve_NPMLE_Switch">Sieve_NPMLE_Switch</a>()</code>, <code><a href="#topic+Sieve_NPMLE_Bootstrap">Sieve_NPMLE_Bootstrap</a>()</code>, <code><a href="#topic+EM_PAVA_Func">EM_PAVA_Func</a>()</code> and
</p>
<p><code><a href="#topic+Permutation_Test">Permutation_Test</a>()</code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  Example 1  #

 data("p0G_data");
 attach(p0G_data);

 n = dim(p0G_data)[1];
 Status = as.numeric( proband_pd == "Yes" );
 Relative = rep(1, n) + 1*(relative == "Sibling") + 2*(relative == "Child");

 detach(p0G_data);

 p0G = rep(0, n);

 for(i in 1:n)
 {
  p0G[i] = p0G_Func(p = 0.02, status = Status[i], relative = Relative[i], model="dominant");
 }

 data.frame(pd_status = Status, relatives = Relative, prob = p0G);

#  Example 2  #

 n = 50;
 status = sample(x=c(0,1), size = n, replace = TRUE, prob = c(0.6, 0.4) );
 relative = sample(x=1:3, size = n, replace = TRUE, prob = c(1/3, 1/3, 1/3) );

 p0G = rep(0, n);

 for(i in 1:n)
 {
  p0G[i] = p0G_Func(p = 0.2, status = status[i], relative = relative[i], model="dominant");
 }

 data.frame(status = status, relative = relative, p0G = p0G);

</code></pre>

<hr>
<h2 id='Permutation_Test'>
Permutation Test
</h2><span id='topic+Permutation_Test'></span>

<h3>Description</h3>

<p>Permutation test for the Sieve-NPMLE switch method with null hypothesis <code class="reqn">H_0</code>: F_carr = F_non and alternative hypothesis <code class="reqn">H_1</code>: F_carr is not equal to F_non.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Permutation_Test (Grid, F_carr, F_non, OY, ODelta, Op0G, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Permutation_Test_+3A_grid">Grid</code></td>
<td>
<p>time points at which the distribution function values are estimated.</p>
</td></tr>
<tr><td><code id="Permutation_Test_+3A_f_carr">F_carr</code></td>
<td>
<p>a vector of distribution function values at given grid points of the carrier group.</p>
</td></tr>
<tr><td><code id="Permutation_Test_+3A_f_non">F_non</code></td>
<td>
<p>a vector of distribution function values at given grid points of the non-carrier group.</p>
</td></tr>
<tr><td><code id="Permutation_Test_+3A_oy">OY</code></td>
<td>
<p>observed event times.</p>
</td></tr>
<tr><td><code id="Permutation_Test_+3A_odelta">ODelta</code></td>
<td>
<p>observed indicators of right censoring. </p>
</td></tr>
<tr><td><code id="Permutation_Test_+3A_op0g">Op0G</code></td>
<td>
<p>observed probability values of carrier and non-carrier groups.</p>
</td></tr>
<tr><td><code id="Permutation_Test_+3A_nperm">nperm</code></td>
<td>
<p>replication number used in permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technical details can be found in Wang et al. (2015).
</p>


<h3>Value</h3>

<p>This function returns a list of prediction values for classes,
</p>
<table>
<tr><td><code>Test_Stat</code></td>
<td>
<p>value of the Kolmogorov-Smirnov statistic with observed data.</p>
</td></tr>
<tr><td><code>Pvalues</code></td>
<td>
<p>p-value of the permutation test.</p>
</td></tr>
<tr><td><code>Permutation.value</code></td>
<td>
<p>values of Kolmogorov-Smirnov statistics under all permutations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wang, Y., Liang, B., Tong, X., Marder, K., Bressman, S., Orr-Urtreger, A., Giladi, N. &amp; Zeng, D. (2015). Efficient estimation of nonparametric genetic risk function with censored data. <em>Biometrika</em>, <b>102</b>(3), 515-532.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+test_stat">test_stat</a>()</code> and <code><a href="#topic+Sieve_NPMLE_Switch">Sieve_NPMLE_Switch</a>()</code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Simulated_data");

OY = Simulated_data[,2];
ind = order(OY);
ODelta = Simulated_data[,3];
Op0G = Simulated_data[,4];

Y = OY[ind];
Delta = ODelta[ind];
p0G = Op0G[ind];

Grid = seq(0.2, 3.65, 0.05);
fix_t1 = c(0.288, 0.693, 1.390);
fix_t2 = c(0.779, 1.860, 3.650);
px = seq(0.1, 3, 0.1);

SieveNPMLE_result = Sieve_NPMLE_Switch( Y=Y, Delta=Delta, p0G=p0G,
                                        px=px, Grid=Grid, Knot=7,
                                        degree=3 );

Lambda_1.hat = cumsum( SieveNPMLE_result$lamb1.hat );
Lambda_2.hat = cumsum( SieveNPMLE_result$lamb2.hat );

F_carr_func = function(x){ 1 - exp( max( Lambda_1.hat[Y &lt;= x] ) ) }
F_non_func  = function(x){ 1 - exp( max( Lambda_2.hat[Y &lt;= x] ) ) }

F_carr = apply( matrix(px, ncol=1), 1, F_carr_func );
F_non = apply( matrix(px, ncol=1), 1, F_non_func );

# Permutation test #

Permutation_Test( Grid=Grid, F_carr=F_carr, F_non=F_non,
                  OY=OY, ODelta=ODelta, Op0G=Op0G,
                  nperm=10 );

</code></pre>

<hr>
<h2 id='Sieve_NPMLE_Bootstrap'>
Sieve_NPMLE_Bootstrap function
</h2><span id='topic+Sieve_NPMLE_Bootstrap'></span>

<h3>Description</h3>

<p>This function is used for calculating standard error estimates and 95% confidence bands in quantile using the bootstrap method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sieve_NPMLE_Bootstrap ( fam_ID, Y0, Delta0, p0G0, fix_t1, fix_t2,
                        Grid, Knot, degree=3, Bn, maxiter=400, ep=1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_fam_id">fam_ID</code></td>
<td>
<p>family ID numbers.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_y0">Y0</code></td>
<td>
<p>observed event times or censoring times.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_delta0">Delta0</code></td>
<td>
<p>indicators of event.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_p0g0">p0G0</code></td>
<td>
<p>probabilities of being a carrier.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_fix_t1">fix_t1</code></td>
<td>
<p>a vector of fixed points at which the carrier's cumulative distribution function values are estimated. </p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_fix_t2">fix_t2</code></td>
<td>
<p>a vector of fixed points at which the non-carrier's cumulative distribution function values are estimated. </p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_grid">Grid</code></td>
<td>
<p>a vector of grid points used for plotting the estimated distribution functions of carrier and non-carrier groups. </p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_knot">Knot</code></td>
<td>
<p>number of knots of the B-spline base functions. </p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_degree">degree</code></td>
<td>
<p>degree of the B-spline base functions. </p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_bn">Bn</code></td>
<td>
<p>number of bootstrap samples. </p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Bootstrap_+3A_ep">ep</code></td>
<td>
<p>convergence criterion, default is ep= 1e-05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using bootstrap for standard error estimation and 95% confidence bands calculation. We do the Bootstrap resample according to <code>fam_ID</code>. 
</p>


<h3>Value</h3>

<p>This function returns a list
</p>
<table>
<tr><td><code>Boot.L1</code></td>
<td>
<p>estimated cumulative hazard function for the carrier group.</p>
</td></tr>
<tr><td><code>Boot.L2</code></td>
<td>
<p>estimated cumulative hazard function for the non-carrier group.</p>
</td></tr>
<tr><td><code>SE_F1_fix_t</code></td>
<td>
<p>estimated standard errors for the carrier group at given points <code>fix_t1</code>.</p>
</td></tr>
<tr><td><code>SE_F2_fix_t</code></td>
<td>
<p>estimated standard errors for the non-carrier group at given points <code>fix_t2</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wang, Y., Liang, B., Tong, X., Marder, K., Bressman, S., Orr-Urtreger, A., Giladi, N. &amp; Zeng, D. (2015). Efficient estimation of nonparametric genetic risk function with censored data. <em>Biometrika</em>, <b>102</b>(3), 515-532.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+p0G_Func">p0G_Func</a>()</code>, <code><a href="#topic+Sieve_NPMLE_Switch">Sieve_NPMLE_Switch</a>()</code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Simulated_data");

OID = Simulated_data[,1];
OY = Simulated_data[,2];
ind = order(OY);
ODelta = Simulated_data[,3];
Op0G = Simulated_data[,4];

Y = OY[ind];
Delta = ODelta[ind];
p0G = Op0G[ind];

Grid = seq(0.2, 3.65, 0.05);
fix_t1 = c(0.288, 0.693, 1.390);
fix_t2 = c(0.779, 1.860, 3.650);
px = seq(0.1, 3, 0.1);

SieveNPMLE_result = Sieve_NPMLE_Switch( Y=Y, Delta=Delta, p0G=p0G, px=px,
                                        Grid=Grid, Knot=7, degree=3  );

Lambda_1.hat = cumsum( SieveNPMLE_result$lamb1.hat );
Lambda_2.hat = cumsum( SieveNPMLE_result$lamb2.hat );

F_carr_func = function(x){ 1 - exp( - max( Lambda_1.hat[Y &lt;= x] ) ) }
F_non_func  = function(x){ 1 - exp( - max( Lambda_2.hat[Y &lt;= x] ) ) }

est.f1 = apply(matrix(fix_t1, ncol=1), 1, F_carr_func );
est.f2 = apply(matrix(fix_t2, ncol=1), 1, F_non_func  );

# ---------------- #
#    Bootstrap     #
# ---------------- #

 Boot = Sieve_NPMLE_Bootstrap( fam_ID=OID, Y0=OY, Delta0=ODelta, p0G0=Op0G,
                               fix_t1=fix_t1, fix_t2=fix_t2, Grid = Grid,
                               Knot=6, degree =3, Bn=10  );

 SE1 = Boot$SE_F1_fix_t;
 SE2 = Boot$SE_F2_fix_t;

 estp = data.frame( fix_t1 = fix_t1, F1.hat = est.f1, SE_F1 = SE1,
                    fix_t2 = fix_t2, F2.hat = est.f2, SE_F2 = SE2  );

 print(estp)

</code></pre>

<hr>
<h2 id='Sieve_NPMLE_Switch'>
Sieve_NPMLE_Switch function
</h2><span id='topic+Sieve_NPMLE_Switch'></span>

<h3>Description</h3>

<p>This function is used to estimate the genotype-specific distribution of time-to-event outcomes with the Sieve-NPMLE switch algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sieve_NPMLE_Switch (Y, p0G, Delta, px, Grid, Knot, degree, maxiter=400, ep=1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sieve_NPMLE_Switch_+3A_y">Y</code></td>
<td>
<p>observed event times or censoring times.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Switch_+3A_p0g">p0G</code></td>
<td>
<p>probabilities of being a carrier.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Switch_+3A_delta">Delta</code></td>
<td>
<p>indicators of event.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Switch_+3A_px">px</code></td>
<td>
<p>grid points at which the distribution function values are estimated.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Switch_+3A_grid">Grid</code></td>
<td>
<p>grid points used for plots. <code>Grid</code> could be either exactly the same as <code>px</code> or different from <code>px</code>. </p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Switch_+3A_knot">Knot</code></td>
<td>
<p>number of knots.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Switch_+3A_degree">degree</code></td>
<td>
<p>degree of the B-spline base functions.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Switch_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="Sieve_NPMLE_Switch_+3A_ep">ep</code></td>
<td>
<p>convergence criterion, default is <code>ep= 1e-05</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to estimate the distribution of the age-at-onset of Parkinsons disease for carriers' and non-carriers' mutations in the leucine-rich repeat kinase 2, LRRK2, gene. Please refer to Wang et al. (2015) for more details.
</p>


<h3>Value</h3>

<p>This function returns a list of prediction values for classes
</p>
<table>
<tr><td><code>lamb1.hat</code></td>
<td>
<p>estimated values of hazard function for the carrier group.</p>
</td></tr>
<tr><td><code>lamb2.hat</code></td>
<td>
<p>estimated values of hazard function for the non-carrier group.</p>
</td></tr>
<tr><td><code>Lamb1</code></td>
<td>
<p>estimated values of cumulative hazard function for the carrier group.</p>
</td></tr>
<tr><td><code>Lamb2</code></td>
<td>
<p>estimated values of cumulative hazard function for the non-carrier group.</p>
</td></tr>
<tr><td><code>Converge</code></td>
<td>
<p>convergence status.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wang, Y., Liang, B., Tong, X., Marder, K., Bressman, S., Orr-Urtreger, A., Giladi, N. &amp; Zeng, D. (2015). Efficient estimation of nonparametric genetic risk function with censored data. <em>Biometrika</em>, <b>102</b>(3), 515-532.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+p0G_Func">p0G_Func</a>()</code>, <code><a href="#topic+Sieve_NPMLE_Bootstrap">Sieve_NPMLE_Bootstrap</a>()</code> and <code><a href="#topic+Permutation_Test">Permutation_Test</a>()</code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Simulated_data");

OY = Simulated_data[,2];
ind = order(OY);
ODelta = Simulated_data[,3];
Op0G = Simulated_data[,4];

Y = OY[ind];
Delta = ODelta[ind];
p0G = Op0G[ind];

Grid = seq(0.2, 3.65, 0.05);
fix_t1 = c(0.288, 0.693, 1.390);
fix_t2 = c(0.779, 1.860, 3.650);
px = seq(0.01, 3.65, 0.01);

SieveNPMLE_result = Sieve_NPMLE_Switch( Y=Y, Delta=Delta, p0G=p0G,
                                        px=px, Grid=Grid,
                                        Knot=6, degree=3  );

# 'Sieve_NPMLE_Switch' only returns values of hazard function 
# or cumulative hazard function of mutation groups, in practice, we only 
# need to do a little bit more as follows for calculating the 
# cumulative distribution values of mutation groups. 

Lambda_1.hat = cumsum( SieveNPMLE_result$lamb1.hat );
Lambda_2.hat = cumsum( SieveNPMLE_result$lamb2.hat );

F_carr_func = function(x){ 1 - exp(- max( Lambda_1.hat[Y &lt;= x] ) ) }
F_non_func  = function(x){ 1 - exp(- max( Lambda_2.hat[Y &lt;= x] ) ) }

est.f1 = apply(matrix(fix_t1, ncol=1), 1, F_carr_func );
est.f2 = apply(matrix(fix_t2, ncol=1), 1, F_non_func  );

estp = data.frame( fix_t1 = fix_t1, F_carr_t1 = est.f1,
                   fix_t2 = fix_t2, F_non_t2 = est.f2  );

print(estp);

# plot estimated curves

F_carr = apply( matrix(px, ncol=1), 1, F_carr_func );
F_non = apply( matrix(px, ncol=1), 1, F_non_func );

plot( px, F_carr, type='s', lty=1, ylim=c(0, 1), xlab="Y",
      ylab="Estimated Cumulative Distribution Function", col='blue' );
lines(px, F_non, type='s', lty=2, col='red');
legend("topleft", legend=c("Carrier group", "Non-Carrier group"),
       lty=c(1,2), col=c("blue","red") );

</code></pre>

<hr>
<h2 id='Simulated_data'>
Simulated Parkinson's disease data
</h2><span id='topic+Simulated_data'></span>

<h3>Description</h3>

<p>This is an artificial data set used for the illustration of the current R-package. There are 4 columns, 268 rows in this data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Simulated_data")</code></pre>


<h3>Format</h3>

<p>A data frame with 268 observations on the following 4 columns with.
</p>

<dl>
<dt><code>FamID</code></dt><dd><p>a factor with levels <code>Child</code>, <code>Parent</code> and <code>Sibling</code></p>
</dd>
<dt><code>Y</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code></p>
</dd>
<dt><code>delta</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>p0G</code></dt><dd><p>a numeric vector, probability distribution value.</p>
</dd>
</dl>



<h3>Source</h3>

<p>This is a simulated data set based on  the real data analysis results in Wang et al. (2015).
</p>


<h3>References</h3>

<p>Wang, Y., Liang, B., Tong, X., Marder, K., Bressman, S., Orr-Urtreger, A., Giladi, N. &amp; Zeng, D. (2015). Efficient estimation of nonparametric genetic risk function with censored data. <em>Biometrika</em>, <b>102</b>(3), 515-532.
</p>
<p>Marder, K., Wang, Y., Alcalay, R. N., Mejia-Santana, H., Tang, M. X., Lee, A., ... &amp; Miravite, J. (2015). Age-specific penetrance of LRRK2 G2019S in the Michael J. Fox Ashkenazi Jewish LRRK2 Consortium. <em>Neurology</em>, <b>85</b>(1), 89&ndash;95.
</p>
<p>Qin, J., Garcia, T., Ma, Y., Tang, M., Marder, K. &amp; Wang, Y. (2014). Combining isotonic regression and EM algorithm to predict genetic risk under monotonicity constraint. <em>The Annals of Applied Statistics</em> <b>8</b>(2), 1182-1208.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Sieve_NPMLE_Switch">Sieve_NPMLE_Switch</a>()</code>, <code><a href="#topic+Sieve_NPMLE_Bootstrap">Sieve_NPMLE_Bootstrap</a>()</code>, <code><a href="#topic+EM_PAVA_Func">EM_PAVA_Func</a>()</code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Simulated_data")
</code></pre>

<hr>
<h2 id='test_stat'>
Kolmogorov-Smirnov Test Statistic
</h2><span id='topic+test_stat'></span>

<h3>Description</h3>

<p>This function is used to calculate the Kolmogorov-Smirnov statistic: <code class="reqn"> D(F_1, F_2) = \sup_{x}|F_1(x) - F_2(x)| </code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_stat (F1, F2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_stat_+3A_f1">F1</code></td>
<td>
<p>vector of one distribution function value.</p>
</td></tr>
<tr><td><code id="test_stat_+3A_f2">F2</code></td>
<td>
<p>vector of the other distribution function value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is necessary to point out that <code>F1</code> and <code>F2</code> are based on common grids. Other technical details can be found in Wang et al. (2015). 
</p>


<h3>Value</h3>

<p>This function returns a list of prediction values for classes, 
</p>
<table>
<tr><td><code>out</code></td>
<td>
<p>value of Kolmogorov-Smirnov statistics.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wang, Y., Liang, B., Tong, X., Marder, K., Bressman, S., Orr-Urtreger, A., Giladi, N. &amp; Zeng, D. (2015). Efficient estimation of nonparametric genetic risk function with censored data. <em>Biometrika</em>, <b>102</b>(3), 515-532.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Permutation_Test">Permutation_Test</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
 X = seq(0.01, 1, 0.05);
 Func_1 = function(x){ x + runif(length(x), min=0, max=1) };
 Func_2 = function(x){ x + 2*runif(length(x), min=0, max=1) };
 
 U1 = Func_1(X);
 U2 = Func_2(X);
 
 test_stat (F1 = U1, F2 = U2);

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
