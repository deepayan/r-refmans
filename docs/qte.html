<!DOCTYPE html><html><head><title>Help for package qte</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qte}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootiter'><p>bootiter</p></a></li>
<li><a href='#bootstrap'><p>bootstrap</p></a></li>
<li><a href='#bounds'><p>bounds</p></a></li>
<li><a href='#BoundsObj'><p>BoundsObj</p></a></li>
<li><a href='#ci.qte'><p>ci.qte</p></a></li>
<li><a href='#ci.qtet'><p>ci.qtet</p></a></li>
<li><a href='#CiC'><p>Change in Changes</p></a></li>
<li><a href='#compute.ci.qte'><p>compute.ci.qte</p></a></li>
<li><a href='#compute.ci.qtet'><p>compute.ci.qtet</p></a></li>
<li><a href='#compute.CiC'><p>athey.imbens</p></a></li>
<li><a href='#compute.ddid2'><p>compute.ddid2</p></a></li>
<li><a href='#compute.MDiD'><p>compute.MDiD</p></a></li>
<li><a href='#compute.panel.qtet'><p>compute.panel.qtet</p></a></li>
<li><a href='#compute.QDiD'><p>Quantile Difference in Differences</p></a></li>
<li><a href='#compute.spatt'><p>compute.spatt</p></a></li>
<li><a href='#computeDiffSE'><p>computeDiffSE</p></a></li>
<li><a href='#computeSE'><p>computeSE</p></a></li>
<li><a href='#ddid2'><p>ddid2</p></a></li>
<li><a href='#diffQ'><p>diffQ</p></a></li>
<li><a href='#DR'><p>DR</p></a></li>
<li><a href='#getlb'><p>getlb</p></a></li>
<li><a href='#getub'><p>getub</p></a></li>
<li><a href='#ggqte'><p>ggqte</p></a></li>
<li><a href='#lalonde'><p>Lalonde (1986)'s NSW Dataset</p></a></li>
<li><a href='#lalonde.exp'><p>Lalonde's Experimental Dataset</p></a></li>
<li><a href='#lalonde.exp.panel'><p>Lalonde's Panel Experimental Dataset</p></a></li>
<li><a href='#lalonde.psid'><p>Lalonde's Observational Dataset</p></a></li>
<li><a href='#lalonde.psid.panel'><p>Lalonde's Experimental Dataset</p></a></li>
<li><a href='#MDiD'><p>Mean Difference in Differences</p></a></li>
<li><a href='#panel.checks'><p>panel.checks</p></a></li>
<li><a href='#panel.qtet'><p>panel.qtet</p></a></li>
<li><a href='#panelize.data'><p>panelize.data</p></a></li>
<li><a href='#plot.BoundsObj'><p>Plot Bounds</p></a></li>
<li><a href='#plot.QTE'><p>plot.QTE</p></a></li>
<li><a href='#print.matrix1'><p>print.matrix1</p></a></li>
<li><a href='#print.matrix2'><p>print.matrix2</p></a></li>
<li><a href='#print.summary.BoundsObj'><p>Print a summary.BoundsObj</p></a></li>
<li><a href='#print.summary.QTE'><p>Print</p></a></li>
<li><a href='#QDiD'><p>Quantile Difference in Differences</p></a></li>
<li><a href='#QTE'><p>qte: A package for computating quantile treatment effects</p></a></li>
<li><a href='#QTEparams'><p>QTEparams</p></a></li>
<li><a href='#qtes2mat'><p>qtes2mat</p></a></li>
<li><a href='#qteToTexreg'><p>diffQ</p></a></li>
<li><a href='#SE'><p>SE</p></a></li>
<li><a href='#setupData'><p>setupData</p></a></li>
<li><a href='#spatt'><p>spatt</p></a></li>
<li><a href='#summary.BoundsObj'><p>Summary of BoundsObj</p></a></li>
<li><a href='#summary.QTE'><p>Summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Quantile Treatment Effects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides several methods for computing the Quantile Treatment Effect (QTE) and Quantile Treatment Effect on the Treated (QTT). The main cases covered are (i) Treatment is randomly assigned, (ii) Treatment is as good as randomly assigned after conditioning on some covariates (also called conditional independence or selection on observables) using the methods developed in Firpo (2007) &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2007.00738.x">doi:10.1111/j.1468-0262.2007.00738.x</a>&gt;, (iii) Identification is based on a Difference in Differences assumption (several varieties are available in the package e.g. Athey and Imbens (2006) &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2006.00668.x">doi:10.1111/j.1468-0262.2006.00668.x</a>&gt; Callaway and Li (2019) &lt;<a href="https://doi.org/10.3982%2FQE935">doi:10.3982/QE935</a>&gt;, Callaway, Li, and Oka (2018) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2018.06.008">doi:10.1016/j.jeconom.2018.06.008</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Hmisc, parallel, quantreg, BMisc, formula.tools, ggplot2,
texreg, pbapply, data.table</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, msm</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-31 20:44:39 UTC; bmc43193</td>
</tr>
<tr>
<td>Author:</td>
<td>Brantly Callaway [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brantly Callaway &lt;brantly.callaway@uga.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-01 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootiter'>bootiter</h2><span id='topic+bootiter'></span>

<h3>Description</h3>

<p><code>bootiter</code> that computes a single bootstrap iteration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootiter(i, qteparams, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootiter_+3A_i">i</code></td>
<td>
<p>the bootstrap iteration, this is not used except for calling
by apply-type methods</p>
</td></tr>
<tr><td><code id="bootiter_+3A_qteparams">qteparams</code></td>
<td>
<p>QTEparams object containing the parameters passed to ciqte</p>
</td></tr>
<tr><td><code id="bootiter_+3A_func">func</code></td>
<td>
<p>the internal function that computes estimates of the qte,
should be the same as what was used to produce qteest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SE object
</p>

<hr>
<h2 id='bootstrap'>bootstrap</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p><code>bootstrap</code> is a method that bootstraps standard
errors for methods in the qte package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(qteparams, qteest, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_qteparams">qteparams</code></td>
<td>
<p>QTEparams object containing the parameters passed to ciqte</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_qteest">qteest</code></td>
<td>
<p>an initial estimate of the qte</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_func">func</code></td>
<td>
<p>the internal function that computes estimates of the qte,
should be the same as what was used to produce qteest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SE object
</p>

<hr>
<h2 id='bounds'>bounds</h2><span id='topic+bounds'></span>

<h3>Description</h3>

<p><code>bounds</code> estimates bounds for the Quantile Treatment
Effect on the
Treated (QTET) using the method of Fan and Yu (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds(
  formla,
  xformla = NULL,
  t,
  tmin1,
  tname,
  data,
  idname,
  probs = seq(0.05, 0.95, 0.05)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounds_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary), d should be equal to one
in all time periods for individuals that are eventually treated</p>
</td></tr>
<tr><td><code id="bounds_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="bounds_+3A_t">t</code></td>
<td>
<p>The 3rd time period in the sample.  Treated individuals should
be treated in this time period and untreated individuals should not be
treated.  The code attempts to enforce this condition, but it is good
try to handle this outside the panel.qtet method.</p>
</td></tr>
<tr><td><code id="bounds_+3A_tmin1">tmin1</code></td>
<td>
<p>The 2nd time period in the sample.  This should be a
pre-treatment period for all individuals in the sample.</p>
</td></tr>
<tr><td><code id="bounds_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing the time periods</p>
</td></tr>
<tr><td><code id="bounds_+3A_data">data</code></td>
<td>
<p>A data.frame containing all the variables used</p>
</td></tr>
<tr><td><code id="bounds_+3A_idname">idname</code></td>
<td>
<p>The individual (cross-sectional unit) id name</p>
</td></tr>
<tr><td><code id="bounds_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>BoundsObj</code> object
</p>


<h3>References</h3>

<p>Fan, Yanqin and Zhengfei Yu.  &ldquo;Partial Identification of Distributional
and Quantile Treatment Effects in Difference-in-Differences Models.&rdquo;
Economics Letters 115.3, pp.511-515, 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data(lalonde)

## Run the bounds method with no covariates
b1 &lt;- bounds(re ~ treat, t=1978, tmin1=1975, data=lalonde.psid.panel,
  idname="id", tname="year")
summary(b1)

</code></pre>

<hr>
<h2 id='BoundsObj'>BoundsObj</h2><span id='topic+BoundsObj'></span>

<h3>Description</h3>

<p>An object of results from computing bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoundsObj(
  lbs,
  ubs,
  ub.quantiles,
  lb.quantiles,
  ub.qte,
  lb.qte,
  att = NULL,
  probs
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoundsObj_+3A_lbs">lbs</code></td>
<td>
<p>A vector of the lower bounds for each value in the support
of the outcome</p>
</td></tr>
<tr><td><code id="BoundsObj_+3A_ubs">ubs</code></td>
<td>
<p>A vector of the upper bounds for each value in the support
of the outcome</p>
</td></tr>
<tr><td><code id="BoundsObj_+3A_ub.quantiles">ub.quantiles</code></td>
<td>
<p>A vector of the same length as probs that contains
the upper bound of the quantiles of the counterfactual distribution
of untreated potential outcomes for the treated group</p>
</td></tr>
<tr><td><code id="BoundsObj_+3A_lb.quantiles">lb.quantiles</code></td>
<td>
<p>A vector of the same length as probs that contains
the lower bound of the quantiles of the counterfactual distribution
of untreated potential outcomes for the treated group</p>
</td></tr>
<tr><td><code id="BoundsObj_+3A_ub.qte">ub.qte</code></td>
<td>
<p>The point estimate of the upper bound for the QTE</p>
</td></tr>
<tr><td><code id="BoundsObj_+3A_lb.qte">lb.qte</code></td>
<td>
<p>The point estimate of the lower bound for the QTE</p>
</td></tr>
<tr><td><code id="BoundsObj_+3A_att">att</code></td>
<td>
<p>The ATT is point identified under the assumptions required
by the bounds method</p>
</td></tr>
<tr><td><code id="BoundsObj_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
</table>

<hr>
<h2 id='ci.qte'>ci.qte</h2><span id='topic+ci.qte'></span>

<h3>Description</h3>

<p>The <code>ci.qtet</code> method implements estimates the Quantile
Treatment Effect (QTE) under a Conditional Independence
Assumption (sometimes this is called Selection on Observables) developed
in Firpo (2007).  This method using propensity score re-weighting
and minimizes a check function to compute the QTET.  Standard errors
(if requested) are computed using the bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.qte(
  formla,
  xformla = NULL,
  x = NULL,
  data,
  w = NULL,
  probs = seq(0.05, 0.95, 0.05),
  se = TRUE,
  iters = 100,
  alp = 0.05,
  method = "logit",
  retEachIter = FALSE,
  printIter = FALSE,
  pl = FALSE,
  cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.qte_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary), d should be equal to one
in all time periods for individuals that are eventually treated</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_x">x</code></td>
<td>
<p>Vector of covariates.  Default is no covariates</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_data">data</code></td>
<td>
<p>A data.frame containing all the variables used</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_w">w</code></td>
<td>
<p>an additional vector of sampling weights</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_se">se</code></td>
<td>
<p>Boolean whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to compute bootstrap standard errors.
This is only used if se=TRUE</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_method">method</code></td>
<td>
<p>Method to compute propensity score.  Default is logit; other
option is probit.</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_reteachiter">retEachIter</code></td>
<td>
<p>Boolean whether or not to return list of results
from each iteration of the bootstrap procedure (default is FALSE).
This is potentially useful for debugging but can cause errors due
to running out of memory.</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_printiter">printIter</code></td>
<td>
<p>For debugging only; should leave at default FALSE unless
you want to see a lot of output</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_pl">pl</code></td>
<td>
<p>boolean for whether or not to compute bootstrap error in parallel.
Note that computing standard errors in parallel is a new feature and may
not work at all on Windows.</p>
</td></tr>
<tr><td><code id="ci.qte_+3A_cores">cores</code></td>
<td>
<p>the number of cores to use if bootstrap standard errors are
computed in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE object
</p>


<h3>References</h3>

<p>Firpo, Sergio.   &ldquo;Efficient Semiparametric Estimation of Quantile Treatment
Effects.&rdquo; Econometrica 75.1, pp. 259-276, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the data
data(lalonde)

##Estimate the QTET of participating in the job training program;
##This is the no covariate case.  Note: Because individuals that participate
## in the job training program are likely to be much different than
## individuals that do not (e.g. less experience and less education), this
## method is likely to perform poorly at estimating the true QTET
q1 &lt;- ci.qte(re78 ~ treat, x=NULL, data=lalonde.psid, se=FALSE,
 probs=seq(0.05,0.95,0.05))
summary(q1)

##This estimation controls for all the available background characteristics.
q2 &lt;- ci.qte(re78 ~ treat,
 xformla=~age + I(age^2) + education + black + hispanic + married + nodegree,
 data=lalonde.psid, se=FALSE, probs=seq(0.05, 0.95, 0.05))
summary(q2)

</code></pre>

<hr>
<h2 id='ci.qtet'>ci.qtet</h2><span id='topic+ci.qtet'></span>

<h3>Description</h3>

<p>The <code>ci.qtet</code> method implements estimates the Quantile
Treatment Effect on the Treated (QTET) under a Conditional Independence
Assumption (sometimes this is called Selection on Observables) developed
in Firpo (2007).  This method using propensity score re-weighting
and minimizes a check function to compute the QTET.  Standard errors
(if requested) are computed using the bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.qtet(
  formla,
  xformla = NULL,
  w = NULL,
  data,
  probs = seq(0.05, 0.95, 0.05),
  se = TRUE,
  iters = 100,
  alp = 0.05,
  method = "logit",
  retEachIter = FALSE,
  indsample = TRUE,
  printIter = FALSE,
  pl = FALSE,
  cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.qtet_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary), d should be equal to one
in all time periods for individuals that are eventually treated</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_w">w</code></td>
<td>
<p>an additional vector of sampling weights</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_data">data</code></td>
<td>
<p>A data.frame containing all the variables used</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_se">se</code></td>
<td>
<p>Boolean whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to compute bootstrap standard errors.
This is only used if se=TRUE</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_method">method</code></td>
<td>
<p>Method to compute propensity score.  Default is logit; other
option is probit.</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_reteachiter">retEachIter</code></td>
<td>
<p>Boolean whether or not to return list of results
from each iteration of the bootstrap procedure (default is FALSE).
This is potentially useful for debugging but can cause errors due
to running out of memory.</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_indsample">indsample</code></td>
<td>
<p>Binary variable for whether to treat the samples as
independent or dependent.  This affects bootstrap standard errors.  In
the job training example, the samples are independent because they
are two samples collected independently and then merged.  If the data is
from the same source, usually should set this option to be FALSE.</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_printiter">printIter</code></td>
<td>
<p>For debugging only; should leave at default FALSE unless
you want to see a lot of output</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_pl">pl</code></td>
<td>
<p>Whether or not to compute standard errors in parallel</p>
</td></tr>
<tr><td><code id="ci.qtet_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use if computing in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE object
</p>


<h3>References</h3>

<p>Firpo, Sergio.   &ldquo;Efficient Semiparametric Estimation of Quantile Treatment
Effects.&rdquo; Econometrica 75.1, pp. 259-276, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the data
data(lalonde)

##Estimate the QTET of participating in the job training program;
##This is the no covariate case.  Note: Because individuals that participate
## in the job training program are likely to be much different than
## individuals that do not (e.g. less experience and less education), this
## method is likely to perform poorly at estimating the true QTET
q1 &lt;- ci.qtet(re78 ~ treat, x=NULL, data=lalonde.psid, se=FALSE,
 probs=seq(0.05,0.95,0.05))
summary(q1)

##This estimation controls for all the available background characteristics.
q2 &lt;- ci.qtet(re78 ~ treat, 
 xformla=~age + I(age^2) + education + black + hispanic + married + nodegree,
 data=lalonde.psid, se=FALSE, probs=seq(0.05, 0.95, 0.05))
summary(q2)

</code></pre>

<hr>
<h2 id='CiC'>Change in Changes</h2><span id='topic+CiC'></span>

<h3>Description</h3>

<p><code>CiC</code> computes the Quantile Treatment Effect on the
Treated (QTET) using the method of Athey and Imbens (2006).  <code>CiC</code>
is a Difference in Differences type method.  It requires
having two periods of data that can be either  repeated cross sections
or panel data.
</p>
<p>The method can accommodate conditioning on covariates though it does so
in a restrictive way:  It specifies a linear model for outcomes conditional
on group-time dummies and covariates.  Then, after residualizing (see details
in Athey and Imbens (2006)), it computes the Change in Changes model
based on these quasi-residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CiC(
  formla,
  xformla = NULL,
  t,
  tmin1,
  tname,
  data,
  panel = FALSE,
  se = TRUE,
  idname = NULL,
  alp = 0.05,
  probs = seq(0.05, 0.95, 0.05),
  iters = 100,
  pl = FALSE,
  cores = 2,
  retEachIter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CiC_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary), d should be equal to one
in all time periods for individuals that are eventually treated</p>
</td></tr>
<tr><td><code id="CiC_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="CiC_+3A_t">t</code></td>
<td>
<p>The 3rd time period in the sample.  Treated individuals should
be treated in this time period and untreated individuals should not be
treated.  The code attempts to enforce this condition, but it is good
try to handle this outside the panel.qtet method.</p>
</td></tr>
<tr><td><code id="CiC_+3A_tmin1">tmin1</code></td>
<td>
<p>The 2nd time period in the sample.  This should be a
pre-treatment period for all individuals in the sample.</p>
</td></tr>
<tr><td><code id="CiC_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing the time periods</p>
</td></tr>
<tr><td><code id="CiC_+3A_data">data</code></td>
<td>
<p>A data.frame containing all the variables used</p>
</td></tr>
<tr><td><code id="CiC_+3A_panel">panel</code></td>
<td>
<p>Binary variable indicating whether or not the dataset is
panel.  This is used for computing bootstrap standard errors correctly.</p>
</td></tr>
<tr><td><code id="CiC_+3A_se">se</code></td>
<td>
<p>Boolean whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="CiC_+3A_idname">idname</code></td>
<td>
<p>The individual (cross-sectional unit) id name</p>
</td></tr>
<tr><td><code id="CiC_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
<tr><td><code id="CiC_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
<tr><td><code id="CiC_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to compute bootstrap standard errors.
This is only used if se=TRUE</p>
</td></tr>
<tr><td><code id="CiC_+3A_pl">pl</code></td>
<td>
<p>Whether or not to compute standard errors in parallel</p>
</td></tr>
<tr><td><code id="CiC_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use if computing in parallel</p>
</td></tr>
<tr><td><code id="CiC_+3A_reteachiter">retEachIter</code></td>
<td>
<p>Boolean whether or not to return list of results
from each iteration of the bootstrap procedure (default is FALSE).
This is potentially useful for debugging but can cause errors due
to running out of memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE Object
</p>


<h3>References</h3>

<p>Athey, Susan and Guido Imbens.  &ldquo;Identification and Inference in Nonlinear
Difference-in-Differences Models.&rdquo; Econometrica 74.2, pp. 431-497,
2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data(lalonde)
## Run the Change in Changes model conditioning on age, education,
## black, hispanic, married, and nodegree
c1 &lt;- CiC(re ~ treat, t=1978, tmin1=1975, tname="year",
 xformla=~age + I(age^2) + education + black + hispanic + married + nodegree,
 data=lalonde.psid.panel, idname="id", se=FALSE,
 probs=seq(0.05, 0.95, 0.05))
summary(c1)


</code></pre>

<hr>
<h2 id='compute.ci.qte'>compute.ci.qte</h2><span id='topic+compute.ci.qte'></span>

<h3>Description</h3>

<p><code>compute.ci.qte</code> computes the QTE under selection
on observables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.ci.qte(qp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.ci.qte_+3A_qp">qp</code></td>
<td>
<p>QTEparams object containing the parameters passed to ciqte</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE object
</p>

<hr>
<h2 id='compute.ci.qtet'>compute.ci.qtet</h2><span id='topic+compute.ci.qtet'></span>

<h3>Description</h3>

<p><code>compute.ci.qtet</code> computes the QTT under
selection on observables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.ci.qtet(qp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.ci.qtet_+3A_qp">qp</code></td>
<td>
<p>QTEparams object containing the parameters passed to ciqte</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE object
</p>

<hr>
<h2 id='compute.CiC'>athey.imbens</h2><span id='topic+compute.CiC'></span>

<h3>Description</h3>

<p><code>compute.CiC</code> does the computational
work for the Change in Changes model
of Athey and Imbens, 2006.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.CiC(qp)
</code></pre>

<hr>
<h2 id='compute.ddid2'>compute.ddid2</h2><span id='topic+compute.ddid2'></span>

<h3>Description</h3>

<p><code>compute.ddid2</code> uses two periods of data (repeated cross sections
or panel) to estimate the Quantile Treatment Effect on the Treated (QTET)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.ddid2(qp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.ddid2_+3A_qp">qp</code></td>
<td>
<p>QTEparams object containing the parameters passed to ddid2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE object
</p>

<hr>
<h2 id='compute.MDiD'>compute.MDiD</h2><span id='topic+compute.MDiD'></span>

<h3>Description</h3>

<p>Internal function for computing the actual value for MDiD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.MDiD(
  formla,
  xformla = NULL,
  t,
  tmin1,
  tname,
  data,
  panel = FALSE,
  idname = NULL,
  uniqueid = NULL,
  probs = seq(0.05, 0.95, 0.05)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.MDiD_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary), d should be equal to one
in all time periods for individuals that are eventually treated</p>
</td></tr>
<tr><td><code id="compute.MDiD_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="compute.MDiD_+3A_t">t</code></td>
<td>
<p>The 3rd time period in the sample.  Treated individuals should
be treated in this time period and untreated individuals should not be
treated.  The code attempts to enforce this condition, but it is good
try to handle this outside the panel.qtet method.</p>
</td></tr>
<tr><td><code id="compute.MDiD_+3A_tmin1">tmin1</code></td>
<td>
<p>The 2nd time period in the sample.  This should be a
pre-treatment period for all individuals in the sample.</p>
</td></tr>
<tr><td><code id="compute.MDiD_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing the time periods</p>
</td></tr>
<tr><td><code id="compute.MDiD_+3A_data">data</code></td>
<td>
<p>A data.frame containing all the variables used</p>
</td></tr>
<tr><td><code id="compute.MDiD_+3A_idname">idname</code></td>
<td>
<p>The individual (cross-sectional unit) id name</p>
</td></tr>
<tr><td><code id="compute.MDiD_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
</table>

<hr>
<h2 id='compute.panel.qtet'>compute.panel.qtet</h2><span id='topic+compute.panel.qtet'></span>

<h3>Description</h3>

<p><code>compute.panel.qtet</code> uses third period of data,
combined with Distributional
Difference in Differences assumption (Fan and Yu, 2012)
to point identify QTET.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.panel.qtet(qp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.panel.qtet_+3A_qp">qp</code></td>
<td>
<p>QTEparams object containing the parameters passed to ciqte</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE object
</p>

<hr>
<h2 id='compute.QDiD'>Quantile Difference in Differences</h2><span id='topic+compute.QDiD'></span>

<h3>Description</h3>

<p><code>compute.QDiD</code> computes the Quantile Difference in
Differences estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.QDiD(qp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.QDiD_+3A_qp">qp</code></td>
<td>
<p>QTEparams object containing the parameters passed to QDiD</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE object
</p>

<hr>
<h2 id='compute.spatt'>compute.spatt</h2><span id='topic+compute.spatt'></span>

<h3>Description</h3>

<p><code>compute.spatt</code> implements the method of Abadie (2005); this is
computed automatically in several other methods in the qte package
but this function provides a standalone result when quantiles are not
wanted/needed.
</p>
<p><code>compute.ddid2</code> uses two periods of data (repeated cross sections
or panel) to estimate the Quantile Treatment Effect on the Treated (QTET)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.spatt(qp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.spatt_+3A_qp">qp</code></td>
<td>
<p>QTEparams object containing the parameters passed to ciqte</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE object
</p>

<hr>
<h2 id='computeDiffSE'>computeDiffSE</h2><span id='topic+computeDiffSE'></span>

<h3>Description</h3>

<p>Takes two sets of initial estimates and bootstrap
estimations
(they need to have the same number of iterations) and determines
whether or not the estimates are statistically different from each
other.  It can be used to compare any sets of estimates, but it is
particularly used here to compare estimates from observational methods
with observations from the experimental data (which also have standard
errors because, even though the estimates are cleanly identified, they
are still estimated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeDiffSE(est1, bootIters1, est2, bootIters2, alp = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeDiffSE_+3A_est1">est1</code></td>
<td>
<p>A QTE object containing the first set of estimates</p>
</td></tr>
<tr><td><code id="computeDiffSE_+3A_bootiters1">bootIters1</code></td>
<td>
<p>A List of QTE objects that have been bootstrapped</p>
</td></tr>
<tr><td><code id="computeDiffSE_+3A_est2">est2</code></td>
<td>
<p>A QTE object containing a second set of estimates</p>
</td></tr>
<tr><td><code id="computeDiffSE_+3A_bootiters2">bootIters2</code></td>
<td>
<p>A List of QTE objects that have been bootstrapped
using the second method</p>
</td></tr>
<tr><td><code id="computeDiffSE_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
</table>

<hr>
<h2 id='computeSE'>computeSE</h2><span id='topic+computeSE'></span>

<h3>Description</h3>

<p>Computes standard errors from bootstrap results.  This function
is called by several functions in the qte package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSE(bootIters, qteobj, alp = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSE_+3A_bootiters">bootIters</code></td>
<td>
<p>List of bootstrap iterations</p>
</td></tr>
<tr><td><code id="computeSE_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SEObj
</p>

<hr>
<h2 id='ddid2'>ddid2</h2><span id='topic+ddid2'></span>

<h3>Description</h3>

<p><code>ddid2</code> computes the Quantile Treatment Effect
on the Treated (QTET) using the method of Callaway, Li, and Oka (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddid2(
  formla,
  xformla = NULL,
  t,
  tmin1,
  tname,
  data,
  panel = TRUE,
  dropalwaystreated = TRUE,
  idname = NULL,
  probs = seq(0.05, 0.95, 0.05),
  iters = 100,
  alp = 0.05,
  method = "logit",
  se = TRUE,
  retEachIter = FALSE,
  seedvec = NULL,
  pl = FALSE,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddid2_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary)</p>
</td></tr>
<tr><td><code id="ddid2_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="ddid2_+3A_t">t</code></td>
<td>
<p>The 3rd time period in the sample (this is the name of the column)</p>
</td></tr>
<tr><td><code id="ddid2_+3A_tmin1">tmin1</code></td>
<td>
<p>The 2nd time period in the sample (this is the name of the
column)</p>
</td></tr>
<tr><td><code id="ddid2_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing the time periods</p>
</td></tr>
<tr><td><code id="ddid2_+3A_data">data</code></td>
<td>
<p>The name of the data.frame that contains the data</p>
</td></tr>
<tr><td><code id="ddid2_+3A_panel">panel</code></td>
<td>
<p>Boolean indicating whether the data is panel or repeated cross
sections</p>
</td></tr>
<tr><td><code id="ddid2_+3A_dropalwaystreated">dropalwaystreated</code></td>
<td>
<p>How to handle always treated observations
in panel data case (not currently used)</p>
</td></tr>
<tr><td><code id="ddid2_+3A_idname">idname</code></td>
<td>
<p>The individual (cross-sectional unit) id name</p>
</td></tr>
<tr><td><code id="ddid2_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
<tr><td><code id="ddid2_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to compute bootstrap standard errors.
This is only used if se=TRUE</p>
</td></tr>
<tr><td><code id="ddid2_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
<tr><td><code id="ddid2_+3A_method">method</code></td>
<td>
<p>The method for estimating the propensity score when covariates
are included</p>
</td></tr>
<tr><td><code id="ddid2_+3A_se">se</code></td>
<td>
<p>Boolean whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="ddid2_+3A_reteachiter">retEachIter</code></td>
<td>
<p>Boolean whether or not to return list of results
from each iteration of the bootstrap procedure</p>
</td></tr>
<tr><td><code id="ddid2_+3A_seedvec">seedvec</code></td>
<td>
<p>Optional value to set random seed; can possibly be used
in conjunction with bootstrapping standard errors.</p>
</td></tr>
<tr><td><code id="ddid2_+3A_pl">pl</code></td>
<td>
<p>boolean for whether or not to compute bootstrap error in parallel.
Note that computing standard errors in parallel is a new feature and may
not work at all on Windows.</p>
</td></tr>
<tr><td><code id="ddid2_+3A_cores">cores</code></td>
<td>
<p>the number of cores to use if bootstrap standard errors are
computed in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>QTE</code> object
</p>


<h3>References</h3>

<p>Callaway, Brantly, Tong Li, and Tatsushi Oka.  &ldquo;Quantile Treatment Effects
in Difference in Differences Models under Dependence Restrictions and with
Only Two Time Periods.&rdquo; Working Paper, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##load the data
data(lalonde)

## Run the ddid2 method on the observational data with no covariates
d1 &lt;- ddid2(re ~ treat, t=1978, tmin1=1975, tname="year",
 data=lalonde.psid.panel, idname="id", se=FALSE,
 probs=seq(0.05, 0.95, 0.05))
summary(d1)

## Run the ddid2 method on the observational data with covariates
d2 &lt;- ddid2(re ~ treat, t=1978, tmin1=1975, tname="year",
 data=lalonde.psid.panel, idname="id", se=FALSE,
 xformla=~age + I(age^2) + education + black + hispanic + married + nodegree,
 probs=seq(0.05, 0.95, 0.05))
summary(d2)


</code></pre>

<hr>
<h2 id='diffQ'>diffQ</h2><span id='topic+diffQ'></span>

<h3>Description</h3>



<h4>takes a single set of quantiles</h4>

<p>(not qtes as in diffquantiles)
and returns the difference between particular ones
</p>



<h3>Usage</h3>

<pre><code class='language-R'>diffQ(qvec, tauvec, hightau, lowtau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffQ_+3A_qvec">qvec</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="diffQ_+3A_tauvec">tauvec</code></td>
<td>
<p>vector of tau (should be same length as qvec)</p>
</td></tr>
<tr><td><code id="diffQ_+3A_hightau">hightau</code></td>
<td>
<p>upper quantile</p>
</td></tr>
<tr><td><code id="diffQ_+3A_lowtau">lowtau</code></td>
<td>
<p>lower quantile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar difference between quantiles
</p>

<hr>
<h2 id='DR'>DR</h2><span id='topic+DR'></span>

<h3>Description</h3>

<p>A distribution regression object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DR(yvals, drlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DR_+3A_yvals">yvals</code></td>
<td>
<p>A vector of values that y can take</p>
</td></tr>
<tr><td><code id="DR_+3A_drlist">drlist</code></td>
<td>
<p>A list where for each value of y, a distribution regression</p>
</td></tr>
</table>

<hr>
<h2 id='getlb'>getlb</h2><span id='topic+getlb'></span>

<h3>Description</h3>

<p>Helper function to compute the lower bound in bounds method.
Usually called by vapply function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getlb(s, F.change.treated, F.treated.tmin1, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getlb_+3A_s">s</code></td>
<td>
<p>A particular value of distribution for which to calculate the bound</p>
</td></tr>
<tr><td><code id="getlb_+3A_f.change.treated">F.change.treated</code></td>
<td>
<p>ecdf object of distribution of change in outcomes
for the treated group</p>
</td></tr>
<tr><td><code id="getlb_+3A_f.treated.tmin1">F.treated.tmin1</code></td>
<td>
<p>ecdf object of distribution of outcomes in period
t-1 for the treated group</p>
</td></tr>
<tr><td><code id="getlb_+3A_y">y</code></td>
<td>
<p>a vector of values that observations could take in the previous
period ?</p>
</td></tr>
</table>

<hr>
<h2 id='getub'>getub</h2><span id='topic+getub'></span>

<h3>Description</h3>

<p>Helper function to compute the upper bound in bounds method.
It is usually called by vapply function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getub(s, F.change.treated, F.treated.tmin1, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getub_+3A_s">s</code></td>
<td>
<p>A particular value of distribution for which to calculate the bound</p>
</td></tr>
<tr><td><code id="getub_+3A_f.change.treated">F.change.treated</code></td>
<td>
<p>ecdf object of distribution of change in outcomes
for the treated group</p>
</td></tr>
<tr><td><code id="getub_+3A_f.treated.tmin1">F.treated.tmin1</code></td>
<td>
<p>ecdf object of distribution of outcomes in period
t-1 for the treated group</p>
</td></tr>
<tr><td><code id="getub_+3A_y">y</code></td>
<td>
<p>a vector of values that observations could take in the previous
period ?</p>
</td></tr>
</table>

<hr>
<h2 id='ggqte'>ggqte</h2><span id='topic+ggqte'></span>

<h3>Description</h3>

<p>Makes somewhat nicer plots of quantile treatment effects
by using ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggqte(
  qteobj,
  main = "",
  ylab = "QTE",
  ylim = NULL,
  ybreaks = NULL,
  xbreaks = c(0.1, 0.3, 0.5, 0.7, 0.9),
  setype = "pointwise"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggqte_+3A_qteobj">qteobj</code></td>
<td>
<p>a QTE object</p>
</td></tr>
<tr><td><code id="ggqte_+3A_main">main</code></td>
<td>
<p>optional title</p>
</td></tr>
<tr><td><code id="ggqte_+3A_ylab">ylab</code></td>
<td>
<p>optional y axis label</p>
</td></tr>
<tr><td><code id="ggqte_+3A_ylim">ylim</code></td>
<td>
<p>optional limits of y axis</p>
</td></tr>
<tr><td><code id="ggqte_+3A_ybreaks">ybreaks</code></td>
<td>
<p>optional breaks in y axis</p>
</td></tr>
<tr><td><code id="ggqte_+3A_xbreaks">xbreaks</code></td>
<td>
<p>optional breaks in x axis</p>
</td></tr>
<tr><td><code id="ggqte_+3A_setype">setype</code></td>
<td>
<p>options are &quot;pointwise&quot;, &quot;uniform&quot; or both; pointwise confidence
intervals cover the QTE at each particular point with a fixed probability,
uniform confidence bands cover the entire curve with a fixed
probability.  Uniform confidence bands will tend to be wider.  The option
&quot;both&quot; will plot both types of confidence intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>

<hr>
<h2 id='lalonde'>Lalonde (1986)'s NSW Dataset</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p><code>lalonde</code> contains data from the National Supported Work
Demonstration.  This program randomly assigned applicants to the job
training program (or out of the job training program).  The dataset is
discussed in Lalonde (1986).  The experimental part of the dataset is
combined with an observational dataset from the Panel Study of Income
Dynamics (PSID).  Lalonde (1986) and many subsequent papers (e.g.
Heckman and Hotz (1989), Dehejia and Wahba (1999), Smith and Todd (2005),
and Firpo (2007) have used this combination to study the effectiveness
of various &lsquo;observational&rsquo; methods (e.g. regression, Heckman selection,
Difference in Differences, and propensity score matching) of estimating
the Average Treatment Effect (ATE) of participating in the job training
program.  The idea is that the results from the observational method
can be compared to results that can be easily obtained from the
experimental portion of the dataset.
</p>
<p>To be clear, the observational data combines the observations that are
treated from the experimental portion of the data with untreated observations
from the PSID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalonde)
</code></pre>


<h3>Format</h3>

<p>Four data.frames: (i) lalonde.exp contains a cross sectional version
of the experimental data, (ii) lalonde.psid contains a cross sectional
version of the observational data, (iii) lalonde.exp.panel contains a
panel version of the experimental data, and (iv) lalonde.psid.panel contains
a panel version of the observational data.  Note: the cross sectional
and panel versions of each dataset are identical up to their shape; in
demonstrating each of the methods, it is sometimes convenient to have
one form of the data or the other.
</p>


<h3>References</h3>

<p>LaLonde, Robert.  &ldquo;Evaluating the Econometric Evaluations of
Training Programs with Experimental Data.&rdquo; The American Economics Review,
pp. 604-620, 1986.
@source The dataset comes from Lalonde (1986) and has been studied in much
subsequent work.  The <code>qte</code> package uses a version from the
<code>causalsens</code> package
(<a href="https://CRAN.R-project.org/package=causalsens">https://CRAN.R-project.org/package=causalsens</a>)
</p>

<hr>
<h2 id='lalonde.exp'>Lalonde's Experimental Dataset</h2><span id='topic+lalonde.exp'></span>

<h3>Description</h3>

<p>The cross sectional verion of the experimental part of the
<code>lalonde</code> dataset.  It
is loaded with all the datasets with the command <code>data(lalonde)</code>
</p>

<hr>
<h2 id='lalonde.exp.panel'>Lalonde's Panel Experimental Dataset</h2><span id='topic+lalonde.exp.panel'></span>

<h3>Description</h3>

<p>The panel verion of the experimental part of the
<code>lalonde</code> dataset.  It
is loaded with all the datasets with the command <code>data(lalonde)</code>
</p>

<hr>
<h2 id='lalonde.psid'>Lalonde's Observational Dataset</h2><span id='topic+lalonde.psid'></span>

<h3>Description</h3>

<p>The cross sectional verion of the observational part of the
<code>lalonde</code> dataset.  It
is loaded with all the datasets with the command <code>data(lalonde)</code>
</p>

<hr>
<h2 id='lalonde.psid.panel'>Lalonde's Experimental Dataset</h2><span id='topic+lalonde.psid.panel'></span>

<h3>Description</h3>

<p>The panel verion of the observational part of the
<code>lalonde</code> dataset.  It
is loaded with all the datasets with the command <code>data(lalonde)</code>
</p>

<hr>
<h2 id='MDiD'>Mean Difference in Differences</h2><span id='topic+MDiD'></span>

<h3>Description</h3>

<p><code>MDiD</code> is a Difference in Differences type method for
computing the QTET.
</p>
<p>The method can accommodate conditioning on covariates though it does so
in a restrictive way:  It specifies a linear model for outcomes conditional
on group-time dummies and covariates.  Then, after residualizing (see details
in Athey and Imbens (2006)), it computes the Change in Changes model
based on these quasi-residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDiD(
  formla,
  xformla = NULL,
  t,
  tmin1,
  tname,
  data,
  panel = FALSE,
  se = TRUE,
  idname = NULL,
  alp = 0.05,
  probs = seq(0.05, 0.95, 0.05),
  iters = 100,
  retEachIter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MDiD_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary), d should be equal to one
in all time periods for individuals that are eventually treated</p>
</td></tr>
<tr><td><code id="MDiD_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="MDiD_+3A_t">t</code></td>
<td>
<p>The 3rd time period in the sample.  Treated individuals should
be treated in this time period and untreated individuals should not be
treated.  The code attempts to enforce this condition, but it is good
try to handle this outside the panel.qtet method.</p>
</td></tr>
<tr><td><code id="MDiD_+3A_tmin1">tmin1</code></td>
<td>
<p>The 2nd time period in the sample.  This should be a
pre-treatment period for all individuals in the sample.</p>
</td></tr>
<tr><td><code id="MDiD_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing the time periods</p>
</td></tr>
<tr><td><code id="MDiD_+3A_data">data</code></td>
<td>
<p>A data.frame containing all the variables used</p>
</td></tr>
<tr><td><code id="MDiD_+3A_panel">panel</code></td>
<td>
<p>Binary variable indicating whether or not the dataset is
panel.  This is used for computing bootstrap standard errors correctly.</p>
</td></tr>
<tr><td><code id="MDiD_+3A_se">se</code></td>
<td>
<p>Boolean whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="MDiD_+3A_idname">idname</code></td>
<td>
<p>The individual (cross-sectional unit) id name</p>
</td></tr>
<tr><td><code id="MDiD_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
<tr><td><code id="MDiD_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
<tr><td><code id="MDiD_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to compute bootstrap standard errors.
This is only used if se=TRUE</p>
</td></tr>
<tr><td><code id="MDiD_+3A_reteachiter">retEachIter</code></td>
<td>
<p>Boolean whether or not to return list of results
from each iteration of the bootstrap procedure (default is FALSE).
This is potentially useful for debugging but can cause errors due
to running out of memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>QTE</code> object
</p>


<h3>References</h3>

<p>Athey, Susan and Guido Imbens.  &ldquo;Identification and Inference in Nonlinear
Difference-in-Differences Models.&rdquo; Econometrica 74.2, pp. 431-497,
2006.
</p>
<p>Thuysbaert, Bram.  &ldquo;Distributional Comparisons in Difference in Differences
Models.&rdquo; Working Paper, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data(lalonde)

## Run the Mean Difference in Differences method conditioning on
## age, education, black, hispanic, married, and nodegree
md1 &lt;- MDiD(re ~ treat, t=1978, tmin1=1975, tname="year",
 xformla=~age + I(age^2) + education + black + hispanic + married + nodegree,
 data=lalonde.psid.panel, idname="id", se=FALSE,
 probs=seq(0.05, 0.95, 0.05))
summary(md1)

</code></pre>

<hr>
<h2 id='panel.checks'>panel.checks</h2><span id='topic+panel.checks'></span>

<h3>Description</h3>

<p>Does some checking that data setup is valid for using methods
in qte package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.checks(qp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.checks_+3A_qp">qp</code></td>
<td>
<p>QTEparams object containing the parameters passed to ciqte</p>
</td></tr>
</table>

<hr>
<h2 id='panel.qtet'>panel.qtet</h2><span id='topic+panel.qtet'></span>

<h3>Description</h3>

<p><code>panel.qtet</code> computes the Quantile Treatment Effect
on the Treated (QTET) using the method of Callaway and Li (2015).  This
method should be used when the researcher wants to invoke a Difference
in Differences assumption to identify the QTET.  Relative to the other
Difference in Differences methods available in the <code>qte</code> package,
this method's assumptions are more intuitively similar to the identifying
assumptions used in identifying the Average Treatment Effect on the Treated
(ATT).
</p>
<p>Additionally, this method can accommodate covariates in a more
flexible way than the other Difference in Differences methods available.
In order to accommodate covariates, the user should specify a vector <code>x</code>
of covariate names.  The user also may specify a method for estimating
the propensity score.  The default is logit.
</p>
<p><code>panel.qtet</code> can only be used in some situations, however.  The
method requires three periods of panel data where individuals
are not treated until the last period.  The data should be formatted
as a panel; the names of columns containing time periods and ids
for each cross sectional unit need to be passed to the method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.qtet(
  formla,
  xformla = NULL,
  t,
  tmin1,
  tmin2,
  tname,
  data,
  idname,
  probs = seq(0.05, 0.95, 0.05),
  iters = 100,
  alp = 0.05,
  method = c("qr", "pscore"),
  se = TRUE,
  retEachIter = FALSE,
  pl = FALSE,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.qtet_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary), d should be equal to one
in all time periods for individuals that are eventually treated</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_t">t</code></td>
<td>
<p>The 3rd time period in the sample.  Treated individuals should
be treated in this time period and untreated individuals should not be
treated.  The code attempts to enforce this condition, but it is good
try to handle this outside the panel.qtet method.</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_tmin1">tmin1</code></td>
<td>
<p>The 2nd time period in the sample.  This should be a
pre-treatment period for all individuals in the sample.</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_tmin2">tmin2</code></td>
<td>
<p>The 1st time period in the sample.  This should be a
pre-treatment period for all individuals in the sample.</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing the time periods</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_data">data</code></td>
<td>
<p>A data.frame containing all the variables used</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_idname">idname</code></td>
<td>
<p>The individual (cross-sectional unit) id name</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to compute bootstrap standard errors.
This is only used if se=TRUE</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_method">method</code></td>
<td>
<p>The method for including covariates, should either be &quot;QR&quot;
for quantile regression or &quot;pscore&quot; for propensity score</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_se">se</code></td>
<td>
<p>Boolean whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_reteachiter">retEachIter</code></td>
<td>
<p>Boolean whether or not to return list of results
from each iteration of the bootstrap procedure (default is FALSE).
This is potentially useful for debugging but can cause errors due
to running out of memory.</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_pl">pl</code></td>
<td>
<p>Whether or not to compute standard errors in parallel</p>
</td></tr>
<tr><td><code id="panel.qtet_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use if computing in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>QTE</code> object
</p>


<h3>References</h3>

<p>Callaway, Brantly and Tong Li.  &ldquo;Quantile Treatment Effects in Difference
in Differences Models with Panel Data.&rdquo; Working Paper, 2019.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##load the data
data(lalonde)

## Run the panel.qtet method on the experimental data with no covariates
pq1 &lt;- panel.qtet(re ~ treat, t=1978, tmin1=1975, tmin2=1974, tname="year",
 data=lalonde.exp.panel, idname="id", se=FALSE,
 probs=seq(0.05, 0.95, 0.05))
summary(pq1)

## Run the panel.qtet method on the observational data with no covariates
pq2 &lt;- panel.qtet(re ~ treat, t=1978, tmin1=1975, tmin2=1974, tname="year",
 data=lalonde.psid.panel, idname="id", se=FALSE,
 probs=seq(0.05, 0.95, 0.05))
summary(pq2)

## Run the panel.qtet method on the observational data conditioning on
## age, education, black, hispanic, married, and nodegree.
## The propensity score will be estimated using the default logit method.
pq3 &lt;- panel.qtet(re ~ treat, t=1978, tmin1=1975, tmin2=1974, tname="year",
 xformla=~age + I(age^2) + education + black + hispanic + married + nodegree,
 data=lalonde.psid.panel, idname="id", se=FALSE, method="pscore",
 probs=seq(0.05, 0.95, 0.05))
summary(pq3)

pq4 &lt;- panel.qtet(re ~ treat, t=1978, tmin1=1975, tmin2=1974, tname="year",
 xformla=~age + I(age^2) + education + black + hispanic + married + nodegree,
 data=lalonde.psid.panel, idname="id", se=FALSE, method="qr",
 probs=seq(0.05, 0.95, 0.05))
summary(pq4)

</code></pre>

<hr>
<h2 id='panelize.data'>panelize.data</h2><span id='topic+panelize.data'></span>

<h3>Description</h3>

<p>get data in correct format for using panel methods in qte package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panelize.data(data, idname, tname, t, tmin1, tmin2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panelize.data_+3A_data">data</code></td>
<td>
<p>A data.frame containing all the variables used</p>
</td></tr>
<tr><td><code id="panelize.data_+3A_idname">idname</code></td>
<td>
<p>The individual (cross-sectional unit) id name</p>
</td></tr>
<tr><td><code id="panelize.data_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing the time periods</p>
</td></tr>
<tr><td><code id="panelize.data_+3A_t">t</code></td>
<td>
<p>The 3rd time period in the sample.  Treated individuals should
be treated in this time period and untreated individuals should not be
treated.  The code attempts to enforce this condition, but it is good
try to handle this outside the panel.qtet method.</p>
</td></tr>
<tr><td><code id="panelize.data_+3A_tmin1">tmin1</code></td>
<td>
<p>The 2nd time period in the sample.  This should be a
pre-treatment period for all individuals in the sample.</p>
</td></tr>
<tr><td><code id="panelize.data_+3A_tmin2">tmin2</code></td>
<td>
<p>The 1st time period in the sample.  This should be a
pre-treatment period for all individuals in the sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='plot.BoundsObj'>Plot Bounds</h2><span id='topic+plot.BoundsObj'></span>

<h3>Description</h3>

<p>Plots a BoundObj Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BoundsObj'
plot(
  x,
  plotate = FALSE,
  plot0 = FALSE,
  qtecol = "black",
  atecol = "black",
  col0 = "black",
  ylim = NULL,
  uselegend = FALSE,
  legloc = "topright",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BoundsObj_+3A_x">x</code></td>
<td>
<p>A BoundsObj Object</p>
</td></tr>
<tr><td><code id="plot.BoundsObj_+3A_plotate">plotate</code></td>
<td>
<p>Boolean whether or not to plot the ATE</p>
</td></tr>
<tr><td><code id="plot.BoundsObj_+3A_plot0">plot0</code></td>
<td>
<p>Boolean whether to plot a line at 0</p>
</td></tr>
<tr><td><code id="plot.BoundsObj_+3A_qtecol">qtecol</code></td>
<td>
<p>Color for qte plot.  Default &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plot.BoundsObj_+3A_atecol">atecol</code></td>
<td>
<p>Color for ate plot.  Default &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plot.BoundsObj_+3A_col0">col0</code></td>
<td>
<p>Color for 0 plot.  Default &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plot.BoundsObj_+3A_ylim">ylim</code></td>
<td>
<p>The ylim for the plot; if not passed, it will be automatically
set based on the values that the QTE takes</p>
</td></tr>
<tr><td><code id="plot.BoundsObj_+3A_uselegend">uselegend</code></td>
<td>
<p>Boolean whether or not to print a legend</p>
</td></tr>
<tr><td><code id="plot.BoundsObj_+3A_legloc">legloc</code></td>
<td>
<p>String location for the legend.  Default &quot;topright&quot;</p>
</td></tr>
<tr><td><code id="plot.BoundsObj_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to plot (e.g lwd)</p>
</td></tr>
</table>

<hr>
<h2 id='plot.QTE'>plot.QTE</h2><span id='topic+plot.QTE'></span>

<h3>Description</h3>

<p>Plots a QTE Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'QTE'
plot(
  x,
  plotate = FALSE,
  plot0 = FALSE,
  qtecol = "black",
  atecol = "black",
  col0 = "black",
  xlab = "tau",
  ylab = "QTE",
  legend = NULL,
  ontreated = FALSE,
  ylim = NULL,
  uselegend = FALSE,
  legendcol = NULL,
  legloc = "topright",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.QTE_+3A_x">x</code></td>
<td>
<p>a QTE Object</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_plotate">plotate</code></td>
<td>
<p>Boolean whether or not to plot the ATE</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_plot0">plot0</code></td>
<td>
<p>Boolean whether to plot a line at 0</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_qtecol">qtecol</code></td>
<td>
<p>Color for qte plot.  Default &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_atecol">atecol</code></td>
<td>
<p>Color for ate plot.  Default &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_col0">col0</code></td>
<td>
<p>Color for 0 plot.  Default &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_xlab">xlab</code></td>
<td>
<p>Custom label for x-axis.  Default &quot;tau&quot;</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_ylab">ylab</code></td>
<td>
<p>Custom label for y-axis.  Default &quot;QTE&quot;</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_legend">legend</code></td>
<td>
<p>Vector of strings to add to legend</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_ontreated">ontreated</code></td>
<td>
<p>Boolean whether parameters are &quot;on the treated group&quot;</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_ylim">ylim</code></td>
<td>
<p>The ylim for the plot; if not passed, it will be automatically
set based on the values that the QTE takes</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_uselegend">uselegend</code></td>
<td>
<p>Boolean whether or not to print a legend</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_legendcol">legendcol</code></td>
<td>
<p>Legend Colors for plotting</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_legloc">legloc</code></td>
<td>
<p>String location for the legend.  Default &quot;topright&quot;</p>
</td></tr>
<tr><td><code id="plot.QTE_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to plot (e.g lwd)</p>
</td></tr>
</table>

<hr>
<h2 id='print.matrix1'>print.matrix1</h2><span id='topic+print.matrix1'></span>

<h3>Description</h3>

<p>Helper function to print a matrix; used by the print methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix1'
print(m, probs = NULL, header = NULL, digits = 2, nsmall = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.matrix1_+3A_m">m</code></td>
<td>
<p>Some matrix</p>
</td></tr>
</table>

<hr>
<h2 id='print.matrix2'>print.matrix2</h2><span id='topic+print.matrix2'></span>

<h3>Description</h3>

<p>Helper function to print a matrix; used by the print methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix2'
print(m, header = NULL, digits = 2, nsmall = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.matrix2_+3A_m">m</code></td>
<td>
<p>Some matrix</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.BoundsObj'>Print a summary.BoundsObj</h2><span id='topic+print.summary.BoundsObj'></span>

<h3>Description</h3>

<p>Prints a Summary QTE Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.BoundsObj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.BoundsObj_+3A_x">x</code></td>
<td>
<p>A summary.BoundsObj</p>
</td></tr>
<tr><td><code id="print.summary.BoundsObj_+3A_...">...</code></td>
<td>
<p>Other objects to pass (not used)</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.QTE'>Print</h2><span id='topic+print.summary.QTE'></span>

<h3>Description</h3>

<p>Prints a Summary QTE Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.QTE'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.QTE_+3A_x">x</code></td>
<td>
<p>A summary.QTE object</p>
</td></tr>
<tr><td><code id="print.summary.QTE_+3A_...">...</code></td>
<td>
<p>Other params (required as generic function, but not used)</p>
</td></tr>
</table>

<hr>
<h2 id='QDiD'>Quantile Difference in Differences</h2><span id='topic+QDiD'></span>

<h3>Description</h3>

<p><code>QDiD</code> is a Difference in Differences type method for
computing the QTET.
</p>
<p>The method can accommodate conditioning on covariates though it does so
in a restrictive way:  It specifies a linear model for outcomes conditional
on group-time dummies and covariates.  Then, after residualizing (see details
in Athey and Imbens (2006)), it computes the Change in Changes model
based on these quasi-residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QDiD(
  formla,
  xformla = NULL,
  t,
  tmin1,
  tname,
  data,
  panel = FALSE,
  se = TRUE,
  idname = NULL,
  alp = 0.05,
  probs = seq(0.05, 0.95, 0.05),
  iters = 100,
  retEachIter = FALSE,
  pl = FALSE,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QDiD_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary), d should be equal to one
in all time periods for individuals that are eventually treated</p>
</td></tr>
<tr><td><code id="QDiD_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="QDiD_+3A_t">t</code></td>
<td>
<p>The 3rd time period in the sample.  Treated individuals should
be treated in this time period and untreated individuals should not be
treated.  The code attempts to enforce this condition, but it is good
try to handle this outside the panel.qtet method.</p>
</td></tr>
<tr><td><code id="QDiD_+3A_tmin1">tmin1</code></td>
<td>
<p>The 2nd time period in the sample.  This should be a
pre-treatment period for all individuals in the sample.</p>
</td></tr>
<tr><td><code id="QDiD_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing the time periods</p>
</td></tr>
<tr><td><code id="QDiD_+3A_data">data</code></td>
<td>
<p>A data.frame containing all the variables used</p>
</td></tr>
<tr><td><code id="QDiD_+3A_panel">panel</code></td>
<td>
<p>Binary variable indicating whether or not the dataset is
panel.  This is used for computing bootstrap standard errors correctly.</p>
</td></tr>
<tr><td><code id="QDiD_+3A_se">se</code></td>
<td>
<p>Boolean whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="QDiD_+3A_idname">idname</code></td>
<td>
<p>The individual (cross-sectional unit) id name</p>
</td></tr>
<tr><td><code id="QDiD_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
<tr><td><code id="QDiD_+3A_probs">probs</code></td>
<td>
<p>A vector of values between 0 and 1 to compute the QTET at</p>
</td></tr>
<tr><td><code id="QDiD_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to compute bootstrap standard errors.
This is only used if se=TRUE</p>
</td></tr>
<tr><td><code id="QDiD_+3A_reteachiter">retEachIter</code></td>
<td>
<p>Boolean whether or not to return list of results
from each iteration of the bootstrap procedure (default is FALSE).
This is potentially useful for debugging but can cause errors due
to running out of memory.</p>
</td></tr>
<tr><td><code id="QDiD_+3A_pl">pl</code></td>
<td>
<p>Whether or not to compute standard errors in parallel</p>
</td></tr>
<tr><td><code id="QDiD_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use if computing in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTE Object
</p>


<h3>References</h3>

<p>Athey, Susan and Guido Imbens.  &ldquo;Identification and Inference in Nonlinear
Difference-in-Differences Models.&rdquo; Econometrica 74.2, pp. 431-497,
2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data(lalonde)

## Run the Quantile Difference in Differences method conditioning on
## age, education, black, hispanic, married, and nodegree
qd1 &lt;- QDiD(re ~ treat, t=1978, tmin1=1975, tname="year",
 xformla=~age + I(age^2) + education + black + hispanic + married + nodegree,
 data=lalonde.psid.panel, idname="id", se=FALSE,
 probs=seq(0.05, 0.95, 0.05))
summary(qd1)

</code></pre>

<hr>
<h2 id='QTE'>qte: A package for computating quantile treatment effects</h2><span id='topic+QTE'></span>

<h3>Description</h3>

<p>Main class of objects.  A <code>QTE</code> object is returned by
all of the methods that compute the QTE or QTET.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTE(
  qte,
  ate = NULL,
  qte.se = NULL,
  qte.lower = NULL,
  qte.upper = NULL,
  ate.se = NULL,
  ate.lower = NULL,
  ate.upper = NULL,
  c = NULL,
  pscore.reg = NULL,
  probs,
  type = "On the Treated",
  F.treated.t = NULL,
  F.untreated.t = NULL,
  F.treated.t.cf = NULL,
  F.treated.tmin1 = NULL,
  F.treated.tmin2 = NULL,
  F.treated.change.tmin1 = NULL,
  F.untreated.change.t = NULL,
  F.untreated.change.tmin1 = NULL,
  F.untreated.tmin1 = NULL,
  F.untreated.tmin2 = NULL,
  condQ.treated.t = NULL,
  condQ.treated.t.cf = NULL,
  eachIterList = NULL,
  inffunct = NULL,
  inffuncu = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTE_+3A_qte">qte</code></td>
<td>
<p>The Quantile Treatment Effect at each value of probs</p>
</td></tr>
<tr><td><code id="QTE_+3A_ate">ate</code></td>
<td>
<p>The Average Treatment Effect (or Average Treatment Effect on
the Treated)</p>
</td></tr>
<tr><td><code id="QTE_+3A_qte.se">qte.se</code></td>
<td>
<p>A vector of standard errors for each qte</p>
</td></tr>
<tr><td><code id="QTE_+3A_qte.lower">qte.lower</code></td>
<td>
<p>A vector of lower confidence intervals for each qte (it is
based on the bootstrap confidence interval &ndash; not the se &ndash; so it may not
be symmyetric about the qte</p>
</td></tr>
<tr><td><code id="QTE_+3A_qte.upper">qte.upper</code></td>
<td>
<p>A vector of upper confidence intervals for each qte (it is
based on the bootstrap confidence interval &ndash; not the se &ndash; so it may not
be symmetric about the qte</p>
</td></tr>
<tr><td><code id="QTE_+3A_ate.se">ate.se</code></td>
<td>
<p>The standard error for the ATE</p>
</td></tr>
<tr><td><code id="QTE_+3A_ate.lower">ate.lower</code></td>
<td>
<p>Lower confidence interval for the ATE (it is based on the
bootstrap confidence intervall &ndash; not the se &ndash; so it may not be symmetric
about the ATE</p>
</td></tr>
<tr><td><code id="QTE_+3A_ate.upper">ate.upper</code></td>
<td>
<p>Upper confidence interval for the ATE (it is based on the
bootstrap confidence interval &ndash; not the se &ndash; so it may not be symmetric
about the ATE</p>
</td></tr>
<tr><td><code id="QTE_+3A_c">c</code></td>
<td>
<p>The critical value from a KS-type statistic used for creating
uniform confidence bands</p>
</td></tr>
<tr><td><code id="QTE_+3A_pscore.reg">pscore.reg</code></td>
<td>
<p>The results of propensity score regression, if specified</p>
</td></tr>
<tr><td><code id="QTE_+3A_probs">probs</code></td>
<td>
<p>The values for which the qte is computed</p>
</td></tr>
<tr><td><code id="QTE_+3A_type">type</code></td>
<td>
<p>Takes the values &quot;On the Treated&quot; or &quot;Population&quot; to indicate
whether the estimated QTE is for the treated group or for the entire
population</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.treated.t">F.treated.t</code></td>
<td>
<p>Distribution of treated outcomes for the treated group at
period t</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.untreated.t">F.untreated.t</code></td>
<td>
<p>Distribution of untreated potential outcomes for the
untreated group at period t</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.treated.t.cf">F.treated.t.cf</code></td>
<td>
<p>Counterfactual distribution of untreated potential
outcomes for the treated group at period t</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.treated.tmin1">F.treated.tmin1</code></td>
<td>
<p>Distribution of treated outcomes for the
treated group at period tmin1</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.treated.tmin2">F.treated.tmin2</code></td>
<td>
<p>Distribution of treated outcomes for the
treated group at period tmin2</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.treated.change.tmin1">F.treated.change.tmin1</code></td>
<td>
<p>Distribution of the change in outcomes for
the treated group between periods tmin1 and tmin2</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.untreated.change.t">F.untreated.change.t</code></td>
<td>
<p>Distribution of the change in outcomes for the
untreated group between periods t and tmin1</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.untreated.change.tmin1">F.untreated.change.tmin1</code></td>
<td>
<p>Distribution of the change in outcomes for
the untreated group between periods tmin1 and tmin2</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.untreated.tmin1">F.untreated.tmin1</code></td>
<td>
<p>Distribution of outcomes for the untreated group
in period tmin1</p>
</td></tr>
<tr><td><code id="QTE_+3A_f.untreated.tmin2">F.untreated.tmin2</code></td>
<td>
<p>Distribution of outcomes for the untreated group
in period tmin2</p>
</td></tr>
<tr><td><code id="QTE_+3A_condq.treated.t">condQ.treated.t</code></td>
<td>
<p>Conditional quantiles for the treated group in
period t</p>
</td></tr>
<tr><td><code id="QTE_+3A_condq.treated.t.cf">condQ.treated.t.cf</code></td>
<td>
<p>Counterfactual conditional quantiles for the treated
group in period t</p>
</td></tr>
<tr><td><code id="QTE_+3A_eachiterlist">eachIterList</code></td>
<td>
<p>An optional list of the outcome of each bootstrap
iteration</p>
</td></tr>
<tr><td><code id="QTE_+3A_inffunct">inffunct</code></td>
<td>
<p>The influence function for the treated group;
used for inference when there are multiple
periods and in the case with panel data.  It is needed for computing covariance
terms in the variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="QTE_+3A_inffuncu">inffuncu</code></td>
<td>
<p>The influence function for the untreated group</p>
</td></tr>
</table>

<hr>
<h2 id='QTEparams'>QTEparams</h2><span id='topic+QTEparams'></span>

<h3>Description</h3>

<p><code>QTEparams</code> is an object that contains all the
parameters passed to QTE methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTEparams(
  formla,
  xformla = NULL,
  t = NULL,
  tmin1 = NULL,
  tmin2 = NULL,
  tname = NULL,
  data,
  panel = FALSE,
  w = NULL,
  idname = NULL,
  probs,
  alp = NULL,
  method = NULL,
  plot = NULL,
  se = NULL,
  iters = NULL,
  retEachIter = NULL,
  bootstrapiter = NULL,
  seedvec = NULL,
  pl = NULL,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTEparams_+3A_formla">formla</code></td>
<td>
<p>Should be some y on treatment variable</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_xformla">xformla</code></td>
<td>
<p>a formula for the other covariates such as ~ x1 + x2</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_t">t</code></td>
<td>
<p>The last period (not always used)</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_tmin1">tmin1</code></td>
<td>
<p>The last pre-treatment period (not always used)</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_tmin2">tmin2</code></td>
<td>
<p>The 2nd to last pre-treatment period (not always used)</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing time periods (not always used)</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_data">data</code></td>
<td>
<p>The name of the data frame</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_panel">panel</code></td>
<td>
<p>Whether or not the data is panel</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_w">w</code></td>
<td>
<p>Additional (usually sampling) weights</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_idname">idname</code></td>
<td>
<p>The name of the id column used with panel data (not always used)</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_probs">probs</code></td>
<td>
<p>Which quantiles to produce quantile treatment effects for</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_alp">alp</code></td>
<td>
<p>The significance level</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_method">method</code></td>
<td>
<p>The method to compute the propensity score</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_plot">plot</code></td>
<td>
<p>boolean for whether or not to plot qtes</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_se">se</code></td>
<td>
<p>boolean whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_iters">iters</code></td>
<td>
<p>The number of bootstrap iterations to use to compute standard errors</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_reteachiter">retEachIter</code></td>
<td>
<p>boolean whether or not to return the full results from
each bootstrap iteration</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_bootstrapiter">bootstrapiter</code></td>
<td>
<p>Used internally for determining whether or not
a call is part of computing standard errors via the bootstrap</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_seedvec">seedvec</code></td>
<td>
<p>A seed to compute the same bootstrap standard errors each
time the method is called (not always used)</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_pl">pl</code></td>
<td>
<p>Boolean for whether or not computing bootstrap standard errrors
in parallel</p>
</td></tr>
<tr><td><code id="QTEparams_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use if computing standard errors in
in parallel</p>
</td></tr>
</table>

<hr>
<h2 id='qtes2mat'>qtes2mat</h2><span id='topic+qtes2mat'></span>

<h3>Description</h3>

<p>Turn multiple qtes into a matrix for printing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtes2mat(qteList, sset = NULL, se = TRUE, rnd = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtes2mat_+3A_qtelist">qteList</code></td>
<td>
<p>a list of qte objects</p>
</td></tr>
<tr><td><code id="qtes2mat_+3A_sset">sset</code></td>
<td>
<p>subset of qtes to keep</p>
</td></tr>
<tr><td><code id="qtes2mat_+3A_se">se</code></td>
<td>
<p>whether or not to include standard errors in the resulting matrix</p>
</td></tr>
<tr><td><code id="qtes2mat_+3A_rnd">rnd</code></td>
<td>
<p>how many disgits to round to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='qteToTexreg'>diffQ</h2><span id='topic+qteToTexreg'></span>

<h3>Description</h3>



<h4>takes a single set of quantiles</h4>

<p>(not qtes as in diffquantiles)
and returns the difference between particular ones
</p>



<h3>Usage</h3>

<pre><code class='language-R'>qteToTexreg(qteobj, tau = NULL, reportAte = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qteToTexreg_+3A_qteobj">qteobj</code></td>
<td>
<p>A QTE object</p>
</td></tr>
<tr><td><code id="qteToTexreg_+3A_tau">tau</code></td>
<td>
<p>Optional vector of taus to texreg results for</p>
</td></tr>
<tr><td><code id="qteToTexreg_+3A_reportate">reportAte</code></td>
<td>
<p>Whether or not texreg the ATE (or ATT) as well</p>
</td></tr>
</table>

<hr>
<h2 id='SE'>SE</h2><span id='topic+SE'></span>

<h3>Description</h3>

<p>Class for Standard Error Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SE(
  qte.se = NULL,
  ate.se = NULL,
  qte.upper = NULL,
  qte.lower = NULL,
  ate.upper = NULL,
  ate.lower = NULL,
  c = NULL,
  probs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SE_+3A_qte.se">qte.se</code></td>
<td>
<p>The QTE Standard Error</p>
</td></tr>
<tr><td><code id="SE_+3A_ate.se">ate.se</code></td>
<td>
<p>The ATE Standard Error</p>
</td></tr>
<tr><td><code id="SE_+3A_qte.upper">qte.upper</code></td>
<td>
<p>The QTE upper CI</p>
</td></tr>
<tr><td><code id="SE_+3A_qte.lower">qte.lower</code></td>
<td>
<p>The QTE lower CI</p>
</td></tr>
<tr><td><code id="SE_+3A_ate.upper">ate.upper</code></td>
<td>
<p>The ATE upper CI</p>
</td></tr>
<tr><td><code id="SE_+3A_ate.lower">ate.lower</code></td>
<td>
<p>The ATE lower CI</p>
</td></tr>
<tr><td><code id="SE_+3A_c">c</code></td>
<td>
<p>The critical value from a KS-type statistic used for creating
uniform confidence bands</p>
</td></tr>
<tr><td><code id="SE_+3A_probs">probs</code></td>
<td>
<p>The values at which the QTE is computed</p>
</td></tr>
</table>

<hr>
<h2 id='setupData'>setupData</h2><span id='topic+setupData'></span>

<h3>Description</h3>

<p><code>setupData</code> sets up the data to use in each
compute method in the QTE package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupData(qteParams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupData_+3A_qteparams">qteParams</code></td>
<td>
<p>object holding the function parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>qteData object holding data to be used in QTE functions
</p>

<hr>
<h2 id='spatt'>spatt</h2><span id='topic+spatt'></span>

<h3>Description</h3>

<p><code>spatt</code> computes the Average Treatment Effect on the
Treated (ATT) using the method of Abadie (2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatt(
  formla,
  xformla = NULL,
  t,
  tmin1,
  tname,
  data,
  w = NULL,
  panel = FALSE,
  idname = NULL,
  iters = 100,
  alp = 0.05,
  method = "logit",
  plot = FALSE,
  se = TRUE,
  retEachIter = FALSE,
  seedvec = NULL,
  pl = FALSE,
  cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatt_+3A_formla">formla</code></td>
<td>
<p>The formula y ~ d where y is the outcome and d is the
treatment indicator (d should be binary)</p>
</td></tr>
<tr><td><code id="spatt_+3A_xformla">xformla</code></td>
<td>
<p>A optional one sided formula for additional covariates that
will be adjusted for.  E.g ~ age + education.  Additional covariates can
also be passed by name using the x paramater.</p>
</td></tr>
<tr><td><code id="spatt_+3A_t">t</code></td>
<td>
<p>The 3rd time period in the sample (this is the name of the column)</p>
</td></tr>
<tr><td><code id="spatt_+3A_tmin1">tmin1</code></td>
<td>
<p>The 2nd time period in the sample (this is the name of the
column)</p>
</td></tr>
<tr><td><code id="spatt_+3A_tname">tname</code></td>
<td>
<p>The name of the column containing the time periods</p>
</td></tr>
<tr><td><code id="spatt_+3A_data">data</code></td>
<td>
<p>The name of the data.frame that contains the data</p>
</td></tr>
<tr><td><code id="spatt_+3A_w">w</code></td>
<td>
<p>an additional vector of sampling weights</p>
</td></tr>
<tr><td><code id="spatt_+3A_panel">panel</code></td>
<td>
<p>Boolean indicating whether the data is panel or repeated cross
sections</p>
</td></tr>
<tr><td><code id="spatt_+3A_idname">idname</code></td>
<td>
<p>The individual (cross-sectional unit) id name</p>
</td></tr>
<tr><td><code id="spatt_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to compute bootstrap standard errors.
This is only used if se=TRUE</p>
</td></tr>
<tr><td><code id="spatt_+3A_alp">alp</code></td>
<td>
<p>The significance level used for constructing bootstrap
confidence intervals</p>
</td></tr>
<tr><td><code id="spatt_+3A_method">method</code></td>
<td>
<p>The method for estimating the propensity score when covariates
are included</p>
</td></tr>
<tr><td><code id="spatt_+3A_plot">plot</code></td>
<td>
<p>Boolean whether or not the estimated QTET should be plotted</p>
</td></tr>
<tr><td><code id="spatt_+3A_se">se</code></td>
<td>
<p>Boolean whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="spatt_+3A_reteachiter">retEachIter</code></td>
<td>
<p>Boolean whether or not to return list of results
from each iteration of the bootstrap procedure</p>
</td></tr>
<tr><td><code id="spatt_+3A_seedvec">seedvec</code></td>
<td>
<p>Optional value to set random seed; can possibly be used
in conjunction with bootstrapping standard errors.</p>
</td></tr>
<tr><td><code id="spatt_+3A_pl">pl</code></td>
<td>
<p>boolean for whether or not to compute bootstrap error in parallel.
Note that computing standard errors in parallel is a new feature and may
not work at all on Windows.</p>
</td></tr>
<tr><td><code id="spatt_+3A_cores">cores</code></td>
<td>
<p>the number of cores to use if bootstrap standard errors are
computed in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>QTE</code> object
</p>


<h3>References</h3>

<p>Abadie (2005)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##load the data
data(lalonde)

## Run the panel.qtet method on the experimental data with no covariates
att1 &lt;- spatt(re ~ treat, t=1978, tmin1=1975, tname="year",
 x=NULL, data=lalonde.psid.panel, idname="id", se=FALSE)
summary(att1)

## Run the panel.qtet method on the observational data with no covariates


</code></pre>

<hr>
<h2 id='summary.BoundsObj'>Summary of BoundsObj</h2><span id='topic+summary.BoundsObj'></span>

<h3>Description</h3>

<p><code>summary.BoundsObj</code> is an object for holding
<code>bounds</code> results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BoundsObj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BoundsObj_+3A_object">object</code></td>
<td>
<p>A BoundsObj Object</p>
</td></tr>
<tr><td><code id="summary.BoundsObj_+3A_...">...</code></td>
<td>
<p>Other params (for consistency as generic S3 method, but not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary.BoundsObj Object
</p>

<hr>
<h2 id='summary.QTE'>Summary</h2><span id='topic+summary.QTE'></span>

<h3>Description</h3>

<p><code>summary.QTE</code> summarizes QTE objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'QTE'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.QTE_+3A_object">object</code></td>
<td>
<p>A QTE Object</p>
</td></tr>
<tr><td><code id="summary.QTE_+3A_...">...</code></td>
<td>
<p>Other params (to work as generic method, but not used)</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
