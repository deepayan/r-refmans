<!DOCTYPE html><html lang="en"><head><title>Help for package FLightR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FLightR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BAStag2TAGS'><p>Function to write down twilights annotated in BAStag package data in so-called TAGS format</p></a></li>
<li><a href='#find.stationary.location'><p>find unknown calibration location</p></a></li>
<li><a href='#find.times.distribution'><p>extracts times of arrival and departure to/from spatial extent</p></a></li>
<li><a href='#FLightR2Movebank'><p>Summary of estimated locations for Movebank</p></a></li>
<li><a href='#GeoLight2TAGS'><p>Function to write down twilights annotated in GeoLight package data in so-called TAGS format</p></a></li>
<li><a href='#get_ZI_distances'><p>Estimate distances moved between twilights</p></a></li>
<li><a href='#get.tags.data'><p>read TAGS formatted data</p></a></li>
<li><a href='#make.calibration'><p>Creates a calibration object, further used for calculation of coordinates in the <code>run.particle.filter</code>.</p></a></li>
<li><a href='#make.grid'><p>makes spatial grid</p></a></li>
<li><a href='#make.prerun.object'><p>combines data, calibration and sets up priors</p></a></li>
<li><a href='#map.FLightR.ggmap'><p>plots result over map</p></a></li>
<li><a href='#plot_likelihood'><p>plot likelihood surface over map</p></a></li>
<li><a href='#plot_lon_lat'><p>plots result by longitude and latitude</p></a></li>
<li><a href='#plot_slopes_by_location'><p>plots log of observed versus expected slope by time for a known location</p></a></li>
<li><a href='#plot_util_distr'><p>plots resulting track over map with uncertainty shown by space utilisation distribution</p></a></li>
<li><a href='#run.particle.filter'><p>Run Particle Filter</p></a></li>
<li><a href='#stationary.migration.summary'><p>find potential stationary periods and estimates their location and movement schedule</p></a></li>
<li><a href='#twGeos2TAGS'><p>Function to write down twilights annotated in twGeos package data in so-called TAGS format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Reconstruct Animal Paths from Solar Geolocation Loggers Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatio-temporal locations of an animal are computed 
    from annotated data with a hidden Markov  model via particle
    filter algorithm. The package is relatively robust to varying
    degrees of shading.
    The hidden Markov model is described in Movement Ecology - Rakhimberdiev et al. (2015) &lt;<a href="https://doi.org/10.1186%2Fs40462-015-0062-5">doi:10.1186/s40462-015-0062-5</a>&gt;,
    general package description is in the Methods in Ecology and Evolution - Rakhimberdiev et al. (2017) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12765">doi:10.1111/2041-210X.12765</a>&gt;
    and package accuracy assessed in the Journal of Avian Biology - Rakhimberdiev et al. (2016) &lt;<a href="https://doi.org/10.1111%2Fjav.00891">doi:10.1111/jav.00891</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=FLightR">https://CRAN.R-project.org/package=FLightR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eldarrak/FLightR/issues">https://github.com/eldarrak/FLightR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bit, geosphere, ggmap, ggplot2, CircStats, circular, fields,
maps, mgcv, nlme, parallel, RcppArmadillo, sf, suntools,
truncnorm</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-04 11:15:15 UTC; eldar</td>
</tr>
<tr>
<td>Author:</td>
<td>Eldar Rakhimberdiev [aut, cre],
  Anatoly Saveliev [aut],
  Julia Karagicheva [aut],
  Simeon Lisovski [ctb],
  Johannes de Groeve [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eldar Rakhimberdiev &lt;eldar.rakhimberdiev@uva.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-04 17:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='BAStag2TAGS'>Function to write down twilights annotated in BAStag package data in so-called TAGS format</h2><span id='topic+BAStag2TAGS'></span>

<h3>Description</h3>

<p>this function converts combines twilights detected in BAStag with raw data and writes them down in TAGS format that can be easily read by <code><a href="#topic+get.tags.data">get.tags.data</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BAStag2TAGS(raw, twl, threshold, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BAStag2TAGS_+3A_raw">raw</code></td>
<td>
<p>original data - dataframe with two columns first column must contain time and second measured light levels</p>
</td></tr>
<tr><td><code id="BAStag2TAGS_+3A_twl">twl</code></td>
<td>
<p>twilights object from <code>preprocess.light</code> function</p>
</td></tr>
<tr><td><code id="BAStag2TAGS_+3A_threshold">threshold</code></td>
<td>
<p>threshold value used for twilight definition in <code>preprocess.light</code></p>
</td></tr>
<tr><td><code id="BAStag2TAGS_+3A_filename">filename</code></td>
<td>
<p>if NULL data.frame in TAGS format will be returned otherwise .csv file in TAGS format will be written</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TAGS format returned or written as .csv by this function is a dataframe with columns
</p>

<dl>
<dt><code>datetime</code></dt><dd><p> date and time in ISO 8601 format e.g. 2013-06-16T00:00:11.000Z</p>
</dd>
<dt><code>light</code></dt><dd><p> light value measured by tag</p>
</dd>
<dt><code>twilight</code></dt><dd><p> assigned by the software numeric indication of whether the record belongs to sunrise (1), sunset (2) or none of those (0)</p>
</dd>
<dt><code>excluded</code></dt><dd><p> indication of whether a twilight was excluded during manual inspection (logical, <code>TRUE | FALSE</code>)</p>
</dd>
<dt><code>interp</code></dt><dd><p> indication of whether the light value at twilight was interpolated (logical, <code>TRUE | FALSE</code>)</p>
</dd>
</dl>

<p>The fields <code>excluded</code> and <code>interp</code> may have values of <code>TRUE</code> only for <code>twilight &gt; 0</code>.
</p>


<h3>Value</h3>

<p><code>NULL</code> if <code>filename</code> is provided or TAGS formatted dataframe.
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev &amp; Simeon Lisovski
</p>


<h3>See Also</h3>

<p><code><a href="#topic+twGeos2TAGS">twGeos2TAGS</a></code> and <code><a href="#topic+GeoLight2TAGS">GeoLight2TAGS</a></code>
</p>

<hr>
<h2 id='find.stationary.location'>find unknown calibration location</h2><span id='topic+find.stationary.location'></span>

<h3>Description</h3>

<p>Functions attempts to find a location where 
The function attempts to find a location for a time period assuming animal was not moving. Does not work well will shaded data!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.stationary.location(
  Proc.data,
  calibration.start,
  calibration.stop,
  plot = TRUE,
  initial.coords = NULL,
  print.optimization = TRUE,
  reltol = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.stationary.location_+3A_proc.data">Proc.data</code></td>
<td>
<p>processed data object generated by <code><a href="#topic+get.tags.data">get.tags.data</a></code></p>
</td></tr>
<tr><td><code id="find.stationary.location_+3A_calibration.start">calibration.start</code></td>
<td>
<p>POSIXct time when stationary period started</p>
</td></tr>
<tr><td><code id="find.stationary.location_+3A_calibration.stop">calibration.stop</code></td>
<td>
<p>POSIXct time when stationary period ended</p>
</td></tr>
<tr><td><code id="find.stationary.location_+3A_plot">plot</code></td>
<td>
<p>plots every iteration</p>
</td></tr>
<tr><td><code id="find.stationary.location_+3A_initial.coords">initial.coords</code></td>
<td>
<p>location vector with initial values for location (longitude and latitude). Should be close (+-2000 km from the real location)</p>
</td></tr>
<tr><td><code id="find.stationary.location_+3A_print.optimization">print.optimization</code></td>
<td>
<p>do you want every optimization iteration to be printed? If TRUE - Lon, Lat, calibration mean and calibration sd are being printed. Optimization tries to minimize the latter.</p>
</td></tr>
<tr><td><code id="find.stationary.location_+3A_reltol">reltol</code></td>
<td>
<p>tolerance for optimization, see <code><a href="stats.html#topic+optim">optim</a></code> for more details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea behind the function is that it tries to minimize variance between slopes for the whole period by optimizing location. It can be seen as an extension of Hill-Ekstrom calibration idea.
</p>


<h3>Value</h3>

<p>vector with coordinates - longitude and latitude.
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#this example takes about 15 minutes to run

File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
Proc.data&lt;-get.tags.data(File)
plot_slopes_by_location(Proc.data=Proc.data, location=c(5.43, 52.93))
abline(v=as.POSIXct("2013-08-20", tz='GMT')) # end of first calibration period
abline(v=as.POSIXct("2014-05-05", tz='GMT')) # start of the second calibration period
Location&lt;-find.stationary.location(Proc.data, '2013-07-20', '2013-08-20', initial.coords=c(10, 50))

</code></pre>

<hr>
<h2 id='find.times.distribution'>extracts times of arrival and departure to/from spatial extent</h2><span id='topic+find.times.distribution'></span>

<h3>Description</h3>

<p>Idea of this functions is to extract schedules for known location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.times.distribution(Result, Spatial.Index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.times.distribution_+3A_result">Result</code></td>
<td>
<p>FLightR result object obtained from <code><a href="#topic+run.particle.filter">run.particle.filter</a></code></p>
</td></tr>
<tr><td><code id="find.times.distribution_+3A_spatial.index">Spatial.Index</code></td>
<td>
<p>Row numbers for spatial grid (<code>Result$Spatial$Grid</code>) to estimate schedules for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with columns for 0.025, 0.25, 0.5, 0.75, 0.975 probability of line crossing and rows for every crossing.
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>

<hr>
<h2 id='FLightR2Movebank'>Summary of estimated locations for Movebank</h2><span id='topic+FLightR2Movebank'></span>

<h3>Description</h3>

<p>Summarize result object in the format required for upload to Movebank
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLightR2Movebank(Result, alpha = 0.5, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLightR2Movebank_+3A_result">Result</code></td>
<td>
<p>FLightR result object obtained from <code><a href="#topic+run.particle.filter">run.particle.filter</a></code></p>
</td></tr>
<tr><td><code id="FLightR2Movebank_+3A_alpha">alpha</code></td>
<td>
<p>coverage of the credible intervals for now only two options: 0.95 or 0.5.</p>
</td></tr>
<tr><td><code id="FLightR2Movebank_+3A_filename">filename</code></td>
<td>
<p>if NULL data.frame in TAGS format will be returned otherwise .csv file in TAGS format will be written</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts FLightR results object.
</p>


<h3>Value</h3>

<p><code>NULL</code> if <code>filename</code> is provided or Movebank formatted dataframe.
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>

<hr>
<h2 id='GeoLight2TAGS'>Function to write down twilights annotated in GeoLight package data in so-called TAGS format</h2><span id='topic+GeoLight2TAGS'></span>

<h3>Description</h3>

<p>this function converts combines twilights detected in BAStag to twGeos with raw data and writes them down in TAGS format that can be easily read by <code><a href="#topic+get.tags.data">get.tags.data</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoLight2TAGS(raw, gl_twl, threshold, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeoLight2TAGS_+3A_raw">raw</code></td>
<td>
<p>original data - dataframe with two columns first column must contain time and second measured light levels</p>
</td></tr>
<tr><td><code id="GeoLight2TAGS_+3A_gl_twl">gl_twl</code></td>
<td>
<p>twilights object from GeoLight</p>
</td></tr>
<tr><td><code id="GeoLight2TAGS_+3A_threshold">threshold</code></td>
<td>
<p>threshold value used for twilight definition in GeoLight</p>
</td></tr>
<tr><td><code id="GeoLight2TAGS_+3A_filename">filename</code></td>
<td>
<p>if NULL data.frame in TAGS format will be returned otherwise .csv file in TAGS format will be written</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TAGS format returned or written as .csv by this function is a dataframe with columns
</p>

<dl>
<dt><code>datetime</code></dt><dd><p> date and time in ISO 8601 format e.g. 2013-06-16T00:00:11.000Z</p>
</dd>
<dt><code>light</code></dt><dd><p> light value measured by tag</p>
</dd>
<dt><code>twilight</code></dt><dd><p> assigned by the software numeric indication of whether the record belongs to sunrise (1), sunset (2) or none of those (0)</p>
</dd>
<dt><code>excluded</code></dt><dd><p> indication of whether a twilight was excluded during manual inspection (logical, <code>TRUE | FALSE</code>)</p>
</dd>
<dt><code>interp</code></dt><dd><p> indication of whether the light value at twilight was interpolated (logical, <code>TRUE | FALSE</code>)</p>
</dd>
</dl>

<p>The fields <code>excluded</code> and <code>interp</code> may have values of <code>TRUE</code> only for <code>twilight &gt; 0</code>.
</p>


<h3>Value</h3>

<p><code>NULL</code> if <code>filename</code> is provided or TAGS formatted dataframe.
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev &amp; Simeon Lisovski
</p>


<h3>See Also</h3>

<p><code><a href="#topic+twGeos2TAGS">twGeos2TAGS</a></code> and <code><a href="#topic+BAStag2TAGS">BAStag2TAGS</a></code>
</p>

<hr>
<h2 id='get_ZI_distances'>Estimate distances moved between twilights</h2><span id='topic+get_ZI_distances'></span>

<h3>Description</h3>

<p>This function estimate distances with all zeros from stationary periods. This means many of the resulting movements will have 0 as the distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ZI_distances(Result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ZI_distances_+3A_result">Result</code></td>
<td>
<p>An object created by <code><a href="#topic+run.particle.filter">run.particle.filter</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing median and quartiles for the distances and also departure and arrival time
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>

<hr>
<h2 id='get.tags.data'>read TAGS formatted data</h2><span id='topic+get.tags.data'></span>

<h3>Description</h3>

<p>Reads the data frame with detected twilight events into the FLightR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tags.data(
  filename = NULL,
  start.date = NULL,
  end.date = NULL,
  log.light.borders = "auto",
  log.irrad.borders = "auto",
  saves = c("auto", "max", "mean"),
  measurement.period = NULL,
  impute.on.boundaries = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tags.data_+3A_filename">filename</code></td>
<td>
<p>the name of the file which the data are to be read from. File is supposed to be comma separated file of TAGS format. If it does not contain an absolute path, the file name is relative to the current working directory, getwd(). Tilde-expansion is performed where supported. This can be a compressed file (see <code><a href="base.html#topic+file">file</a></code>). Alternatively, file can be a readable text-mode connection (which will be opened for reading if necessary, and if so closed (and hence destroyed) at the end of the function call). File can also be a complete URL. For the supported URL schemes, see help for <code><a href="base.html#topic+url">url</a></code>.</p>
</td></tr>
<tr><td><code id="get.tags.data_+3A_start.date">start.date</code></td>
<td>
<p>date of beginning of relevant data collection in <code><a href="base.html#topic+POSIXct">POSIXct</a></code> format.</p>
</td></tr>
<tr><td><code id="get.tags.data_+3A_end.date">end.date</code></td>
<td>
<p>date of end of relevant data collection in <code><a href="base.html#topic+POSIXct">POSIXct</a></code> format.</p>
</td></tr>
<tr><td><code id="get.tags.data_+3A_log.light.borders">log.light.borders</code></td>
<td>
<p>Numeric vector with length of 2 for minimum and maximum log(light) levels to use. Alternatively character value 'auto', that will allow FLightR to assign these values according to detected tag type.</p>
</td></tr>
<tr><td><code id="get.tags.data_+3A_log.irrad.borders">log.irrad.borders</code></td>
<td>
<p>Numeric vector with length of 2 for minimum and maximum log(irradiance) values to use. Alternatively character value 'auto', that will allow FLightR to assign these values according to detected tag type.</p>
</td></tr>
<tr><td><code id="get.tags.data_+3A_saves">saves</code></td>
<td>
<p>character values informing FLightR if min or max values were used by logger.</p>
</td></tr>
<tr><td><code id="get.tags.data_+3A_measurement.period">measurement.period</code></td>
<td>
<p>Value in seconds defining how often tag was measuring light levels. If NULL value will be taken from known values for detected tag type.</p>
</td></tr>
<tr><td><code id="get.tags.data_+3A_impute.on.boundaries">impute.on.boundaries</code></td>
<td>
<p>logical, if FLightR should approximate values at boundaries. Set it to TRUE only if you have vary few active points at each twilight, e.g if tag was saving every 10 minutes or so.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned object has many parts, the important are: (1) the recorded light data, (2) the detected twilight events, (3) light level data at the moment of each determined sunrise and sunset and around them (24 fixes before and 24 after), and (4) technical parameters of the tag, i. e. its type, saving and measuring period (the periodicity, in seconds, at which a tag measures and saves data).
</p>


<h3>Value</h3>

<p>list, which is to be further processed with the FLightR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
Proc.data&lt;-get.tags.data(File)
</code></pre>

<hr>
<h2 id='make.calibration'>Creates a calibration object, further used for calculation of coordinates in the <code><a href="#topic+run.particle.filter">run.particle.filter</a></code>.</h2><span id='topic+make.calibration'></span>

<h3>Description</h3>

<p>Function estimates all necessary parameters from the calibration data logged in a known location or locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.calibration(
  Proc.data,
  Calibration.periods,
  model.ageing = FALSE,
  plot.each = FALSE,
  plot.final = FALSE,
  likelihood.correction = "auto",
  fixed.logSlope = c(NA, NA),
  suggest.irrad.borders = FALSE,
  return.slopes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.calibration_+3A_proc.data">Proc.data</code></td>
<td>
<p>processed data object generated by <code><a href="#topic+get.tags.data">get.tags.data</a></code></p>
</td></tr>
<tr><td><code id="make.calibration_+3A_calibration.periods">Calibration.periods</code></td>
<td>
<p>a data frame containing start and end dates of all the calibration periods (POSIXct) and geographic coordinates of the corresponding calibration locations.</p>
</td></tr>
<tr><td><code id="make.calibration_+3A_model.ageing">model.ageing</code></td>
<td>
<p>if set to TRUE, accounts for the tag ageing (with opacification of its transparent shell of a light sensor), resulting into decreasing sensitivity of the device. This option is useful only if there were several calibration periods or if calibration period was very long (~ longer than a month).</p>
</td></tr>
<tr><td><code id="make.calibration_+3A_plot.each">plot.each</code></td>
<td>
<p>Do you want every twilight to be plotted while processing</p>
</td></tr>
<tr><td><code id="make.calibration_+3A_plot.final">plot.final</code></td>
<td>
<p>Do you want final calibration graph to be plotted. On the graph you can see all the observed versus expected light levels. All slopes should be similar.</p>
</td></tr>
<tr><td><code id="make.calibration_+3A_likelihood.correction">likelihood.correction</code></td>
<td>
<p>will estimate correction of likelihood for the current calibration parameters. Highly recommended not to be change from 'auto'. In this case FLightR will switch it to FALSE in case tag saved data on 10 minutes or longer period.</p>
</td></tr>
<tr><td><code id="make.calibration_+3A_fixed.logslope">fixed.logSlope</code></td>
<td>
<p>these are mean (1) and SD (2) for distribution of slopes. Should normally be estimated from the data (and thus default is c(NA, NA)). Change any of these two finite values if you want them to be predetermined and not estimated from the calibration data.</p>
</td></tr>
<tr><td><code id="make.calibration_+3A_suggest.irrad.borders">suggest.irrad.borders</code></td>
<td>
<p>experimental parameter! If set to TRUE function will try to find the best values for the log.irrad.borders</p>
</td></tr>
<tr><td><code id="make.calibration_+3A_return.slopes">return.slopes</code></td>
<td>
<p>if true function will return estimated individual twilight slopes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>calibration object to be uses in the <code><a href="#topic+make.prerun.object">make.prerun.object</a></code>
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
Proc.data&lt;-get.tags.data(File, end.date=as.POSIXct('2013-08-20', tz='GMT'))
Calibration.periods&lt;-data.frame(
       calibration.start=NA,
       calibration.stop=as.POSIXct("2013-08-20", tz='GMT'),
       lon=5.43, lat=52.93) 
       #use c() also for the geographic coordinates, if you have more than one calibration location
       # (e. g.,  lon=c(5.43, 6.00), lat=c(52.93,52.94))
print(Calibration.periods)

# NB Below likelihood.correction is set to FALSE for fast run! 
# Leave it as default 'auto' for real examples
Calibration&lt;-make.calibration(Proc.data, Calibration.periods, likelihood.correction=FALSE)

</code></pre>

<hr>
<h2 id='make.grid'>makes spatial grid</h2><span id='topic+make.grid'></span>

<h3>Description</h3>

<p>This function makes a rectangular grid with use defined boundaries and probabilities of being stationary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.grid(
  left = -180,
  bottom = -90,
  right = 180,
  top = 90,
  distance.from.land.allowed.to.use = c(-Inf, Inf),
  distance.from.land.allowed.to.stay = c(-Inf, Inf),
  plot = TRUE,
  return.distances = FALSE,
  probability.of.staying = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.grid_+3A_left">left</code></td>
<td>
<p>- left boundary in degrees (-180 &lt;= left &lt;= 180)</p>
</td></tr>
<tr><td><code id="make.grid_+3A_bottom">bottom</code></td>
<td>
<p>- lower boundary in degrees (-90 &lt;= bottom &lt;= 90)</p>
</td></tr>
<tr><td><code id="make.grid_+3A_right">right</code></td>
<td>
<p>- right boundary in degrees (-180 &lt;= right &lt;= 180)</p>
</td></tr>
<tr><td><code id="make.grid_+3A_top">top</code></td>
<td>
<p>- top boundary in degrees (-90 &lt;= right &lt;= 90)</p>
</td></tr>
<tr><td><code id="make.grid_+3A_distance.from.land.allowed.to.use">distance.from.land.allowed.to.use</code></td>
<td>
<p>- define how far from the shore animal could occur. Unit - km, negative values are for inland and positive for offshore directions. <code>Inf</code> stays for infinity</p>
</td></tr>
<tr><td><code id="make.grid_+3A_distance.from.land.allowed.to.stay">distance.from.land.allowed.to.stay</code></td>
<td>
<p>- define how far from the shore animal could stay stationary between twilights. Unit - km, negative values are for inland and positive for offshore directions. <code>Inf</code> stays for infinity</p>
</td></tr>
<tr><td><code id="make.grid_+3A_plot">plot</code></td>
<td>
<p>show a plot of final grid.</p>
</td></tr>
<tr><td><code id="make.grid_+3A_return.distances">return.distances</code></td>
<td>
<p>- return distances to the shoreline</p>
</td></tr>
<tr><td><code id="make.grid_+3A_probability.of.staying">probability.of.staying</code></td>
<td>
<p>- assigned probability value for grid cells that do not satisfy <code>distance.from.water.allowed.to.stay</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with coordinates(lon and lat) and <code>probability.of.staying</code>
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Grid&lt;-make.grid(left=-14, bottom=30, right=13, top=57,
  distance.from.land.allowed.to.use=c(-Inf, Inf),
  distance.from.land.allowed.to.stay=c(-Inf, Inf))

</code></pre>

<hr>
<h2 id='make.prerun.object'>combines data, calibration and sets up priors</h2><span id='topic+make.prerun.object'></span>

<h3>Description</h3>

<p>This function is one step before <code><a href="#topic+run.particle.filter">run.particle.filter</a></code>. It combines data, calibration, spatial extent and movement priors and estimates spatial likelihoods that used later in the particle filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.prerun.object(
  Proc.data,
  Grid,
  start,
  end = start,
  Calibration,
  threads = -1,
  Decision = 0.05,
  Direction = 0,
  Kappa = 0,
  M.mean = 300,
  M.sd = 500,
  likelihood.correction = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.prerun.object_+3A_proc.data">Proc.data</code></td>
<td>
<p>Processed data object created by <code><a href="#topic+get.tags.data">get.tags.data</a></code>.</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_grid">Grid</code></td>
<td>
<p>Spatial grid created by <code><a href="#topic+make.grid">make.grid</a></code>.</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_start">start</code></td>
<td>
<p>release location (lat, lon).</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_end">end</code></td>
<td>
<p>end of the track location. Will use <code>start</code> by default. Use NA in case of unknown end point.</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_calibration">Calibration</code></td>
<td>
<p>Calibration object created by <code><a href="#topic+make.calibration">make.calibration</a></code>.</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_threads">threads</code></td>
<td>
<p>number of parallel threads to use. default is -1, which means FLightR will use all available threads except 1. Value 1 will force sequential evaluation</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_decision">Decision</code></td>
<td>
<p>prior for migration probability values from 0 to 1 are allowed</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_direction">Direction</code></td>
<td>
<p>Direction prior for direction of migration (in degrees) with 0 pointing to the North</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_kappa">Kappa</code></td>
<td>
<p>concentration parameter for vonMises distribution, 0 means uniform or even distribution. Will set some prior for direction for all the track, so is not recommended to be changed</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_m.mean">M.mean</code></td>
<td>
<p>Prior for mean distance travelled between consecutive twilights, km</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_m.sd">M.sd</code></td>
<td>
<p>Prior for sd of distance travelled between consecutive twilights, the higher the value is the wider is the the distribution</p>
</td></tr>
<tr><td><code id="make.prerun.object_+3A_likelihood.correction">likelihood.correction</code></td>
<td>
<p>Should likelihood correction estimated during <code><a href="#topic+make.calibration">make.calibration</a></code> run be used?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object to be uses in the <code><a href="#topic+run.particle.filter">run.particle.filter</a></code>
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
# to run example fast we will cut the real data file by 2013 Aug 20
Proc.data&lt;-get.tags.data(File, end.date=as.POSIXct('2013-07-02', tz='GMT'))
Calibration.periods&lt;-data.frame(
       calibration.start=NA,
       calibration.stop=as.POSIXct("2013-08-20", tz='GMT'),
       lon=5.43, lat=52.93) 
       #use c() also for the geographic coordinates, if you have more than one calibration location
       # (e. g.,  lon=c(5.43, 6.00), lat=c(52.93,52.94))
print(Calibration.periods)

# NB Below likelihood.correction is set to FALSE for fast run! 
# Leave it as default TRUE for real examples
Calibration&lt;-make.calibration(Proc.data, Calibration.periods, likelihood.correction=FALSE)

Grid&lt;-make.grid(left=0, bottom=50, right=10, top=56,
  distance.from.land.allowed.to.use=c(-Inf, Inf),
  distance.from.land.allowed.to.stay=c(-Inf, Inf))

all.in&lt;-make.prerun.object(Proc.data, Grid, start=c(5.43, 52.93),
                             Calibration=Calibration, threads=2)

</code></pre>

<hr>
<h2 id='map.FLightR.ggmap'>plots result over map</h2><span id='topic+map.FLightR.ggmap'></span>

<h3>Description</h3>

<p>plots track over map with probability cloud. Can plot only part of the track if dates are specified. Note that you can use it only after obtaining and registering in you current session Google Api Key. For details on the API key check [here](http://ornithologyexchange.org/forums/topic/38315-mapflightrggmap-error).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.FLightR.ggmap(
  Result,
  dates = NULL,
  plot.cloud = TRUE,
  map.options = NULL,
  plot.options = NULL,
  save.options = NULL,
  zoom = "auto",
  return.ggobj = FALSE,
  seasonal.colors = TRUE,
  seasonal.donut.location = "topleft",
  seasonal.donut.proportion = 0.5,
  save = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map.FLightR.ggmap_+3A_result">Result</code></td>
<td>
<p>FLightR result object obtained from <code><a href="#topic+run.particle.filter">run.particle.filter</a></code></p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_dates">dates</code></td>
<td>
<p>either NULL if all twilights should be included or data.frame with first column - start of the period and second end of the period. Each line represents a new period</p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_plot.cloud">plot.cloud</code></td>
<td>
<p>Should probability cloud be plotted? If TRUE cloud is estimated by <code><a href="ggplot2.html#topic+stat_density2d">stat_density2d</a></code></p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_map.options">map.options</code></td>
<td>
<p>options passed to <code><a href="ggmap.html#topic+get_map">get_map</a></code>, note that <code>zoom</code> option is defined separately</p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_plot.options">plot.options</code></td>
<td>
<p>plotting options. Not defined yet!</p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_save.options">save.options</code></td>
<td>
<p>options passed to <code><a href="ggplot2.html#topic+ggsave">ggsave</a></code>. Filename should be defined here.</p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_zoom">zoom</code></td>
<td>
<p>Zoom for map. If 'auto' FLightR will try to find optimal zoom level by downloading different size maps and checking whether all the points fit the map.</p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_return.ggobj">return.ggobj</code></td>
<td>
<p>Should ggobj be returned for subsequent checks and/or replotting</p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_seasonal.colors">seasonal.colors</code></td>
<td>
<p>if true points of the track will have seasonal colors</p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_seasonal.donut.location">seasonal.donut.location</code></td>
<td>
<p>if NULL - no color wheel placed, otherwise select one of 'bottomleft', 'bottomright', 'topleft'</p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_seasonal.donut.proportion">seasonal.donut.proportion</code></td>
<td>
<p>how much of X axis should color wheel occupy.
return either NULL or ggplot2 class object</p>
</td></tr>
<tr><td><code id="map.FLightR.ggmap_+3A_save">save</code></td>
<td>
<p>should function save results with <code><a href="ggplot2.html#topic+ggsave">ggsave</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if 'return.ggobj=TRUE' return ggplot object otherwise returns 'NULL'.
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
# to run example fast we will cut the real data file by 2013 Aug 20
Proc.data&lt;-get.tags.data(File, end.date=as.POSIXct('2013-06-25', tz='GMT'))
Calibration.periods&lt;-data.frame(
       calibration.start=as.POSIXct(c(NA, "2014-05-05"), tz='GMT'),
       calibration.stop=as.POSIXct(c("2013-08-20", NA), tz='GMT'),
       lon=5.43, lat=52.93) 
       #use c() also for the geographic coordinates, if you have more than one calibration location
       # (e. g.,  lon=c(5.43, 6.00), lat=c(52.93,52.94))

# NB Below likelihood.correction is set to FALSE for fast run! 
# Leave it as default TRUE for real examples
Calibration&lt;-make.calibration(Proc.data, Calibration.periods, likelihood.correction=FALSE)

Grid&lt;-make.grid(left=0, bottom=50, right=10, top=56,
  distance.from.land.allowed.to.use=c(-Inf, Inf),
  distance.from.land.allowed.to.stay=c(-Inf, Inf))

all.in&lt;-make.prerun.object(Proc.data, Grid, start=c(5.43, 52.93),
                             Calibration=Calibration, threads=2)
# here we will run only 1e4 partilces for a very short track.
# One should use 1e6 particles for the full run
Result&lt;-run.particle.filter(all.in, threads=1,
           nParticles=1e3, known.last=TRUE,
           precision.sd=25, check.outliers=FALSE)

## Not run: 
map.FLightR.ggmap(Result, seasonal.donut.location=NULL, zoom=6, save=FALSE)

## End(Not run) 
# for this short track without variance seasonal donut does not work,
# but for normall track it will.
</code></pre>

<hr>
<h2 id='plot_likelihood'>plot likelihood surface over map</h2><span id='topic+plot_likelihood'></span>

<h3>Description</h3>

<p>plots specific likelihood surface over map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_likelihood(object, date = NULL, twilight.index = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_likelihood_+3A_object">object</code></td>
<td>
<p>either output from <code><a href="#topic+make.prerun.object">make.prerun.object</a></code> or <code><a href="#topic+run.particle.filter">run.particle.filter</a></code></p>
</td></tr>
<tr><td><code id="plot_likelihood_+3A_date">date</code></td>
<td>
<p>either NULL or a date (possibly with time) closest to the twilight you wan to be plotted</p>
</td></tr>
<tr><td><code id="plot_likelihood_+3A_twilight.index">twilight.index</code></td>
<td>
<p>number of likelihood surface to be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function plots likelihoods before particle filter run, so these are pure results of calibrations without any movement model
</p>


<h3>Value</h3>

<p>'NULL'
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
# to run example fast we will cut the real data file by 2013 Aug 20
Proc.data&lt;-get.tags.data(File, end.date=as.POSIXct('2013-07-02', tz='GMT'))
Calibration.periods&lt;-data.frame(
       calibration.start=as.POSIXct(c(NA, "2014-05-05"), tz='GMT'),
       calibration.stop=as.POSIXct(c("2013-08-20", NA), tz='GMT'),
       lon=5.43, lat=52.93) 
       #use c() also for the geographic coordinates, if you have more than one calibration location
       # (e. g.,  lon=c(5.43, 6.00), lat=c(52.93,52.94))

# NB Below likelihood.correction is set to FALSE for fast run! 
# Leave it as default TRUE for real examples
Calibration&lt;-make.calibration(Proc.data, Calibration.periods, likelihood.correction=FALSE)

Grid&lt;-make.grid(left=0, bottom=50, right=10, top=56,
  distance.from.land.allowed.to.use=c(-Inf, Inf),
  distance.from.land.allowed.to.stay=c(-Inf, Inf))

all.in&lt;-make.prerun.object(Proc.data, Grid, start=c(5.43, 52.93),
                             Calibration=Calibration, threads=2)
plot_likelihood(all.in, twilight.index=10)

</code></pre>

<hr>
<h2 id='plot_lon_lat'>plots result by longitude and latitude</h2><span id='topic+plot_lon_lat'></span>

<h3>Description</h3>

<p>This function plots result by latitude and longitude in either vertical or horizontal layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lon_lat(Result, scheme = c("vertical", "horizontal"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_lon_lat_+3A_result">Result</code></td>
<td>
<p>FLightR result object obtained from <code><a href="#topic+run.particle.filter">run.particle.filter</a></code></p>
</td></tr>
<tr><td><code id="plot_lon_lat_+3A_scheme">scheme</code></td>
<td>
<p>either 'vertical' or 'horizontal' layouts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'NULL'
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
# to run example fast we will cut the real data file by 2013 Aug 20
Proc.data&lt;-get.tags.data(File, end.date=as.POSIXct('2013-07-02', tz='GMT'))
Calibration.periods&lt;-data.frame(
       calibration.start=as.POSIXct(c(NA, "2014-05-05"), tz='GMT'),
       calibration.stop=as.POSIXct(c("2013-08-20", NA), tz='GMT'),
       lon=5.43, lat=52.93) 
       #use c() also for the geographic coordinates, if you have more than one calibration location
       # (e. g.,  lon=c(5.43, 6.00), lat=c(52.93,52.94))

# NB Below likelihood.correction is set to FALSE for fast run! 
# Leave it as default TRUE for real examples
Calibration&lt;-make.calibration(Proc.data, Calibration.periods, likelihood.correction=FALSE)

Grid&lt;-make.grid(left=0, bottom=50, right=10, top=56,
  distance.from.land.allowed.to.use=c(-Inf, Inf),
  distance.from.land.allowed.to.stay=c(-Inf, Inf))

all.in&lt;-make.prerun.object(Proc.data, Grid, start=c(5.43, 52.93),
                             Calibration=Calibration, threads=2)
# here we will run only 1e4 partilces for a very short track.
# One should use 1e6 particles for the full run
Result&lt;-run.particle.filter(all.in, threads=1,
           nParticles=1e3, known.last=TRUE,
           precision.sd=25, check.outliers=FALSE)

plot_lon_lat(Result)

</code></pre>

<hr>
<h2 id='plot_slopes_by_location'>plots log of observed versus expected slope by time for a known location</h2><span id='topic+plot_slopes_by_location'></span>

<h3>Description</h3>

<p>The function calculates and plots calibration slopes for sunsets and sunrises for every day of the tracking period, based on the assumption that the tag remained in the same (calibration) location all the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_slopes_by_location(
  Proc.data,
  location,
  log.light.borders = "auto",
  log.irrad.borders = "auto",
  ylim = NULL,
  xlim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_slopes_by_location_+3A_proc.data">Proc.data</code></td>
<td>
<p>processed data object generated by <code><a href="#topic+get.tags.data">get.tags.data</a></code></p>
</td></tr>
<tr><td><code id="plot_slopes_by_location_+3A_location">location</code></td>
<td>
<p>vector with longitude and latitude of calibration location (degrees).</p>
</td></tr>
<tr><td><code id="plot_slopes_by_location_+3A_log.light.borders">log.light.borders</code></td>
<td>
<p>numeric vector with length of 2 for minimum and maximum log(light) levels to use. Default value 'auto', will take these values from the Proc.data object.</p>
</td></tr>
<tr><td><code id="plot_slopes_by_location_+3A_log.irrad.borders">log.irrad.borders</code></td>
<td>
<p>numeric vector with length of 2 for minimum and maximum log(irradiance) values to use. Default value 'auto', will take these values from the Proc.data object.</p>
</td></tr>
<tr><td><code id="plot_slopes_by_location_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. The default value, NULL, indicates that the range of the finite values to be plotted should be used.</p>
</td></tr>
<tr><td><code id="plot_slopes_by_location_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot. The default value, NULL, otherwise can be POSIXct or character in a form readable by <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot of calibration slopes is used for finding start and end dates of a calibration period (the time period, during which the tag remained in the calibration location with coordinates (x,y)). During the calibration period, the calibration slopes vary little both, between the twilight events (sunrises and sunsets) and in time. When the tag changes location, the slopes for sunrises and sunsets start to deviate. There may potentially be several calibration periods for the same location (if the bird returned to the same location several times). The boundaries (start and end dates) of each of these periods are captured visually. If there were more than one calibration location, the procedure is repeated, once for each location. 
All the obtained calibration periods can be entered in a data frame 'Calibration.periods', for further analysis. Each line of the data frame contains start and end dates (if applicable) of the calibration period and geographic coordinates of the location.
</p>


<h3>Value</h3>

<p>'NULL'
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
Proc.data&lt;-get.tags.data(File)
plot_slopes_by_location(Proc.data=Proc.data, location=c(5.43, 52.93))
abline(v=as.POSIXct("2013-08-20", tz='GMT')) # end of first calibration period
abline(v=as.POSIXct("2014-05-05", tz='GMT')) # start of the second calibration period

</code></pre>

<hr>
<h2 id='plot_util_distr'>plots resulting track over map with uncertainty shown by space utilisation distribution</h2><span id='topic+plot_util_distr'></span>

<h3>Description</h3>

<p>May be use not only for the whole track but for a set of specific dates, e.g. to show spatial uncertainty during migration. Note that you can use it only after obtaining and registering in you current session Google Api Key. For details on the API key check [here](http://ornithologyexchange.org/forums/topic/38315-mapflightrggmap-error).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_util_distr(
  Result,
  dates = NULL,
  map.options = NULL,
  percentiles = c(0.4, 0.6, 0.8),
  zoom = "auto",
  geom_polygon.options = NULL,
  save.options = NULL,
  color.palette = NULL,
  use.palette = TRUE,
  background = NULL,
  plot = TRUE,
  save = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_util_distr_+3A_result">Result</code></td>
<td>
<p>FLightR result object obtained from <code><a href="#topic+run.particle.filter">run.particle.filter</a></code></p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_dates">dates</code></td>
<td>
<p>Use NULL if all twilights will be used for plotting, one integer if specific twilight should be plotted (line number in Result$Results$Quantiles). Use data.frame with first column - start of the period and second - end of the period and each line represents a new period to plot specific periods, e.g. wintering or migration.</p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_map.options">map.options</code></td>
<td>
<p>options passed to <code><a href="ggmap.html#topic+get_map">get_map</a></code>, note that <code>zoom</code> option is defined separately</p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_percentiles">percentiles</code></td>
<td>
<p>Probability breaks for utilisation distribution</p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_zoom">zoom</code></td>
<td>
<p>Zoom for map. If 'auto' FLightR will try to find optimal zoom level by downloading different size maps and checking whether all the points fit the map.</p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_geom_polygon.options">geom_polygon.options</code></td>
<td>
<p>options passed to <code><a href="ggplot2.html#topic+geom_polygon">geom_polygon</a></code></p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_save.options">save.options</code></td>
<td>
<p>options passed to <code><a href="ggplot2.html#topic+ggsave">ggsave</a></code>. Filename should be defined here.</p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_color.palette">color.palette</code></td>
<td>
<p>colors for probability contours. Either NULL or <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code> object</p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_use.palette">use.palette</code></td>
<td>
<p>should the same colors be used for polygon boundaries as for polygon filling?</p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_background">background</code></td>
<td>
<p>if provided will be used as a background. Must be created by <code>link[ggmap]{get_map}</code></p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_plot">plot</code></td>
<td>
<p>should function produce a plot?</p>
</td></tr>
<tr><td><code id="plot_util_distr_+3A_save">save</code></td>
<td>
<p>should function save results with <code><a href="ggplot2.html#topic+ggsave">ggsave</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two parts 
</p>
<table role = "presentation">
<tr><td><code>res_buffers</code></td>
<td>
<p>spatial buffers for defined probability values</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
# to run example fast we will cut the real data file by 2013 Aug 20
Proc.data&lt;-get.tags.data(File, end.date=as.POSIXct('2013-06-25', tz='GMT'))
Calibration.periods&lt;-data.frame(
       calibration.start=as.POSIXct(c(NA, "2014-05-05"), tz='GMT'),
       calibration.stop=as.POSIXct(c("2013-08-20", NA), tz='GMT'),
       lon=5.43, lat=52.93) 
       #use c() also for the geographic coordinates, if you have more than one calibration location
       # (e. g.,  lon=c(5.43, 6.00), lat=c(52.93,52.94))

# NB Below likelihood.correction is set to FALSE for fast run! 
# Leave it as default TRUE for real examples
Calibration&lt;-make.calibration(Proc.data, Calibration.periods, likelihood.correction=FALSE)

Grid&lt;-make.grid(left=0, bottom=50, right=10, top=56,
  distance.from.land.allowed.to.use=c(-Inf, Inf),
  distance.from.land.allowed.to.stay=c(-Inf, Inf))

all.in&lt;-make.prerun.object(Proc.data, Grid, start=c(5.43, 52.93),
                             Calibration=Calibration, threads=1)
# here we will run only 1e4 partilces for a very short track.
# One should use 1e6 particles for the full run
Result&lt;-run.particle.filter(all.in, threads=1,
           nParticles=1e3, known.last=TRUE,
           precision.sd=25, check.outliers=FALSE)

## Not run: 
plot_util_distr(Result, zoom=6, save=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='run.particle.filter'>Run Particle Filter</h2><span id='topic+run.particle.filter'></span>

<h3>Description</h3>

<p>Main function of FLightR, it takes fully prepared object created by <code><a href="#topic+make.prerun.object">make.prerun.object</a></code> and produces a result object that can be used for plotting etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.particle.filter(
  all.out,
  cpus = NULL,
  threads = -1,
  nParticles = 1e+06,
  known.last = TRUE,
  precision.sd = 25,
  behav.mask.low.value = 0,
  k = NA,
  plot = TRUE,
  cluster.type = "PSOCK",
  a = 45,
  b = 1500,
  L = 90,
  adaptive.resampling = 0.99,
  check.outliers = FALSE,
  sink2file = FALSE,
  add.jitter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.particle.filter_+3A_all.out">all.out</code></td>
<td>
<p>An object created by <code><a href="#topic+make.prerun.object">make.prerun.object</a></code>.</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_cpus">cpus</code></td>
<td>
<p>another way to specify  <code>threads</code></p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_threads">threads</code></td>
<td>
<p>An amount of threads to use while running in parallel. default is -1. if value 1 submitted package will run sequentially</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_nparticles">nParticles</code></td>
<td>
<p>total amount of particles to be used with the run. 10 000 (1e4) is recommended for the preliminary run and 1 000 000 (1e6) for the final</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_known.last">known.last</code></td>
<td>
<p>Set to FALSE if your bird was not at a known place during last twilight in the data</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_precision.sd">precision.sd</code></td>
<td>
<p>if <code>known.last</code> then what is the precision of this information. Will be used to resample particles proportionally to their distance from the known last point with probability <code>P = dnorm(0, precision.sd)</code></p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_behav.mask.low.value">behav.mask.low.value</code></td>
<td>
<p>Probability value that will be used instead of 0 in the behavioural mask. If set to 1 behavioural mask will not be active anymore</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_k">k</code></td>
<td>
<p>Kappa parameter from vonMises distribution. Default is NA, otherwise will generate particles in a direction of a previous transitions with kappa = k</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_plot">plot</code></td>
<td>
<p>Should function plot preliminary map in the end of the run?</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_cluster.type">cluster.type</code></td>
<td>
<p>see help to package parallel for details</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_a">a</code></td>
<td>
<p>minimum distance that is used in the movement model - left boundary for truncated normal distribution of distances moved between twilights. Default is 45 for as default grid has a minimum distance of 50 km.</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_b">b</code></td>
<td>
<p>Maximum distance allowed to fly between two consecutive twilights</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_l">L</code></td>
<td>
<p>how many consecutive particles to resample</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_adaptive.resampling">adaptive.resampling</code></td>
<td>
<p>Above what level of ESS resampling should be skipped</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_check.outliers">check.outliers</code></td>
<td>
<p>switches ON the online outlier routine</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_sink2file">sink2file</code></td>
<td>
<p>will write run details in a file instead of showing on the screen</p>
</td></tr>
<tr><td><code id="run.particle.filter_+3A_add.jitter">add.jitter</code></td>
<td>
<p>will add spatial jitter inside a grid cell for the median estimates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FLightR object, containing output and extracted results. It is a list with the following elements 
</p>
<table role = "presentation">
<tr><td><code>Indices</code></td>
<td>
<p>List with prior information and indices</p>
</td></tr>
<tr><td><code>Spatial</code></td>
<td>
<p>Spatial data - Grid, Mask, spatial likelihood</p>
</td></tr>
<tr><td><code>Calibration</code></td>
<td>
<p>all calibration parameters</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>original data</p>
</td></tr>
<tr><td><code>Results</code></td>
<td>
<p>The main results object. Main components of it are
</p>

<dl>
<dt>Quantiles</dt><dd><p>dataframe containing results on locations. Each line corresponds to a twilight</p>
</dd>
<dt>Movement.results</dt><dd><p>dataframe containing all the movement results, Note - time at line n means time of the end of transition between n and n-1</p>
</dd>
<dt>outliers</dt><dd><p>id of twilights excluded by online outlier detection tool</p>
</dd>
<dt>LL</dt><dd><p>-Log likelihood</p>
</dd>
<dt>Points.rle</dt><dd><p>run length encoding object with posterior distribution for every twilight. Note that numbers of points correspond to line numbers in <code>$Spatial$Grid</code></p>
</dd>
<dt>Transitions.rle</dt><dd><p>run length encoding object with all the transitions</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
# to run example fast we will cut the real data file by 2013 Aug 20
Proc.data&lt;-get.tags.data(File, end.date=as.POSIXct('2013-07-02', tz='GMT'))
Calibration.periods&lt;-data.frame(
       calibration.start=NA,
       calibration.stop=as.POSIXct("2013-08-20", tz='GMT'),
       lon=5.43, lat=52.93) 
       #use c() also for the geographic coordinates, if you have more than one calibration location
       # (e. g.,  lon=c(5.43, 6.00), lat=c(52.93,52.94))
print(Calibration.periods)

# NB Below likelihood.correction is set to FALSE for fast run! 
# Leave it as default TRUE for real examples
Calibration&lt;-make.calibration(Proc.data, Calibration.periods, likelihood.correction=FALSE)

Grid&lt;-make.grid(left=0, bottom=50, right=10, top=56,
  distance.from.land.allowed.to.use=c(-Inf, Inf),
  distance.from.land.allowed.to.stay=c(-Inf, Inf))

all.in&lt;-make.prerun.object(Proc.data, Grid, start=c(5.43, 52.93),
                             Calibration=Calibration, threads=2)
# here we will run only 1e4 partilces for a very short track.
# One should use 1e6 particles for the full run.
Result&lt;-run.particle.filter(all.in, threads=1,
           nParticles=1e3, known.last=TRUE,
           precision.sd=25, check.outliers=FALSE)

</code></pre>

<hr>
<h2 id='stationary.migration.summary'>find potential stationary periods and estimates their location and movement schedule</h2><span id='topic+stationary.migration.summary'></span>

<h3>Description</h3>

<p>This function will find any sites where birds stayed longer than <code>min.stay</code>. Potential movement is detected by the minimum probability of movement <code>prob.cutoff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary.migration.summary(Result, prob.cutoff = 0.1, min.stay = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stationary.migration.summary_+3A_result">Result</code></td>
<td>
<p>FLightR result object obtained from <code><a href="#topic+run.particle.filter">run.particle.filter</a></code></p>
</td></tr>
<tr><td><code id="stationary.migration.summary_+3A_prob.cutoff">prob.cutoff</code></td>
<td>
<p>Minimum probability that defines movement</p>
</td></tr>
<tr><td><code id="stationary.migration.summary_+3A_min.stay">min.stay</code></td>
<td>
<p>Minimum duration of stationary period (in twilights)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with stationary and movement statistics
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>File&lt;-system.file("extdata", "Godwit_TAGS_format.csv", package = "FLightR")
# to run example fast we will cut the real data file by 2013 Aug 20
Proc.data&lt;-get.tags.data(File, end.date=as.POSIXct('2013-06-25', tz='GMT'))
Calibration.periods&lt;-data.frame(
       calibration.start=as.POSIXct(c(NA, "2014-05-05"), tz='GMT'),
       calibration.stop=as.POSIXct(c("2013-08-20", NA), tz='GMT'),
       lon=5.43, lat=52.93) 
       #use c() also for the geographic coordinates, if you have more than one calibration location
       # (e. g.,  lon=c(5.43, 6.00), lat=c(52.93,52.94))

# NB Below likelihood.correction is set to FALSE for fast run! 
# Leave it as default TRUE for real examples
Calibration&lt;-make.calibration(Proc.data, Calibration.periods, likelihood.correction=FALSE)

Grid&lt;-make.grid(left=0, bottom=50, right=10, top=56,
  distance.from.land.allowed.to.use=c(-Inf, Inf),
  distance.from.land.allowed.to.stay=c(-Inf, Inf))

all.in&lt;-make.prerun.object(Proc.data, Grid, start=c(5.43, 52.93),
                             Calibration=Calibration, threads=1)
# here we will run only 1e4 partilces for a very short track.
# One should use 1e6 particles for the full run.
Result&lt;-run.particle.filter(all.in, threads=1,
           nParticles=1e3, known.last=TRUE,
           precision.sd=25, check.outliers=FALSE)

Summary&lt;-stationary.migration.summary(Result, prob.cutoff=1)
# Use lower cut offs for real runs!
</code></pre>

<hr>
<h2 id='twGeos2TAGS'>Function to write down twilights annotated in twGeos package data in so-called TAGS format</h2><span id='topic+twGeos2TAGS'></span>

<h3>Description</h3>

<p>this function converts combines twilights detected in twGeos with raw data and writes them down in TAGS format that can be easily read by <code><a href="#topic+get.tags.data">get.tags.data</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twGeos2TAGS(raw, twl, threshold, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twGeos2TAGS_+3A_raw">raw</code></td>
<td>
<p>original data - dataframe with two columns first column must contain time and second measured light levels</p>
</td></tr>
<tr><td><code id="twGeos2TAGS_+3A_twl">twl</code></td>
<td>
<p>twilights object from <code>preprocess.light</code> function</p>
</td></tr>
<tr><td><code id="twGeos2TAGS_+3A_threshold">threshold</code></td>
<td>
<p>threshold value used for twilight definition in <code>preprocess.light</code></p>
</td></tr>
<tr><td><code id="twGeos2TAGS_+3A_filename">filename</code></td>
<td>
<p>if NULL data.frame in TAGS format will be returned otherwise .csv file in TAGS format will be written</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TAGS format returned or written as .csv by this function is a dataframe with columns
</p>

<dl>
<dt><code>datetime</code></dt><dd><p> date and time in ISO 8601 format e.g. 2013-06-16T00:00:11.000Z</p>
</dd>
<dt><code>light</code></dt><dd><p> light value measured by tag</p>
</dd>
<dt><code>twilight</code></dt><dd><p> assigned by the software numeric indication of whether the record belongs to sunrise (1), sunset (2) or none of those (0)</p>
</dd>
<dt><code>excluded</code></dt><dd><p> indication of whether a twilight was excluded during manual inspection (logical, <code>TRUE | FALSE</code>)</p>
</dd>
<dt><code>interp</code></dt><dd><p> indication of whether the light value at twilight was interpolated (logical, <code>TRUE | FALSE</code>)</p>
</dd>
</dl>

<p>The fields <code>excluded</code> and <code>interp</code> may have values of <code>TRUE</code> only for <code>twilight &gt; 0</code>.
</p>


<h3>Value</h3>

<p><code>NULL</code> if <code>filename</code> is provided or TAGS formatted dataframe.
</p>


<h3>Author(s)</h3>

<p>Eldar Rakhimberdiev &amp; Simeon Lisovski
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BAStag2TAGS">BAStag2TAGS</a></code> and <code><a href="#topic+GeoLight2TAGS">GeoLight2TAGS</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
