<!DOCTYPE html><html><head><title>Help for package prozor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prozor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annotateAHO'><p>annotate peptides using AhoCorasickTrie</p></a></li>
<li><a href='#annotatePeptides'><p>Annotate peptides with protein ids</p></a></li>
<li><a href='#Cdsw-class'><p>Compute dynamic swath windows</p></a></li>
<li><a href='#computeFDR'><p>Compute FDR given a score</p></a></li>
<li><a href='#computeFDRwithID'><p>Compute FDR given a score</p></a></li>
<li><a href='#create_fgcz_fasta_db'><p>create fasta db from one or more fasta files</p></a></li>
<li><a href='#createDecoyDB'><p>Create db with decoys and contaminants</p></a></li>
<li><a href='#fdrSample'><p>Data frame score and proteinID</p></a></li>
<li><a href='#greedy'><p>given matrix (columns protein rows peptides), compute minimal protein set using greedy algorithm</p></a></li>
<li><a href='#greedyRes2Matrix'><p>converts result of greedy function to a matrix with 3 columns - peptide - charge and protein</p></a></li>
<li><a href='#hardconstrain'><p>tests hard constraints</p></a></li>
<li><a href='#loadContaminantsFasta2019'><p>load list of contaminant sequences FGCZ 2019</p></a></li>
<li><a href='#loadContaminantsFasta2021'><p>load list of contaminant sequences FGCZ 2021</p></a></li>
<li><a href='#makeID'><p>make id for chain in format sp|P30443|1A01_HUMANs25</p></a></li>
<li><a href='#makeIDUnip'><p>make id for chain compatible with uniprot</p></a></li>
<li><a href='#masses'><p>MS masses</p>
A dataset containing approx 150000 MS1 precursor masses</a></li>
<li><a href='#objectiveMS1Function'><p>compute the deviation from optimum: equal number of MS1 per bin</p></a></li>
<li><a href='#pepprot'><p>Table containing peptide information</p></a></li>
<li><a href='#plotFDR'><p>plot FDR</p></a></li>
<li><a href='#predictScoreFDR'><p>Predict score given FDR</p></a></li>
<li><a href='#prepareMatrix'><p>given table of peptide protein assigments generate matrix</p></a></li>
<li><a href='#protpepmetashort'><p>Small version of pepprot dataset to speed up computation</p></a></li>
<li><a href='#prozor'><p>Minimal Protein Set Explaining Peptides</p></a></li>
<li><a href='#readjustWindows'><p>Readjust windows so that boundaries in regions of few peaks.</p></a></li>
<li><a href='#readPeptideFasta'><p>wrapper setting the correct parameters</p>
seqinr::read.fasta for reading peptide sequences</a></li>
<li><a href='#removeSignalPeptide'><p>remove signal peptides from main chain</p></a></li>
<li><a href='#reverseSeq'><p>create rev sequences to fasta list</p></a></li>
<li><a href='#writeFasta'><p>write fasta lists into file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Minimal Protein Set Explaining Peptide Spectrum Matches</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Determine minimal protein set explaining
    peptide spectrum matches. Utility functions for creating fasta amino acid databases with decoys and contaminants.
    Peptide false discovery rate estimation for target decoy search results on psm, precursor, peptide and protein
    level. Computing dynamic swath window sizes based on MS1 or MS2 signal distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>AhoCorasickTrie, docopt, Matrix, methods, purrr, readr, rlang,
seqinr, stringr, dplyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown,</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/protviz/prozor">https://github.com/protviz/prozor</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/protviz/prozor/issues">https://github.com/protviz/prozor/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'annotatePeptides.R' 'readjustWindow.R' 'cdsw.R'
'computeFDR.R' 'createDecoyDB.R' 'create_fgcz_fasta_db.R'
'greedy.R' 'hello.R' 'loadContaminantsFasta.R'
'prepareMatrix.R' 'readFasta.R' 'removeSignalPeptides.R'
'reverseSeq.R' 'writeFasta.R' 'zzz.R'</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Software, MassSpectrometry, Proteomics,
ExperimentHubSoftware,</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-07 11:48:58 UTC; wolski</td>
</tr>
<tr>
<td>Author:</td>
<td>Witold Wolski <a href="https://orcid.org/0000-0002-6468-120X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Witold Wolski &lt;wewolski@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-07 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='annotateAHO'>annotate peptides using AhoCorasickTrie</h2><span id='topic+annotateAHO'></span>

<h3>Description</h3>

<p>peptides which do not have protein assignment drop out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotateAHO(pepseq, fasta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotateAHO_+3A_pepseq">pepseq</code></td>
<td>
<p>- list of peptides - sequence, optional modified sequence, charge state.</p>
</td></tr>
<tr><td><code id="annotateAHO_+3A_fasta">fasta</code></td>
<td>
<p>- object as created by <code>readPeptideFasta</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with proteinID, peptideSeq, Offset and proteinSequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

file = system.file("extdata/IDResults.txt.gz" , package = "prozor")
specMeta &lt;- readr::read_tsv(file)
upeptide &lt;- unique(specMeta$peptideSeq)
resCan &lt;-
   prozor::readPeptideFasta(
       system.file("p1000_db1_example/Annotation_canSeq.fasta.gz" , package = "prozor"))
resCanU &lt;- resCan[!duplicated(unlist(resCan))]
annotAll = annotateAHO(upeptide[seq_len(20)], resCanU)
dim(annotAll)

</code></pre>

<hr>
<h2 id='annotatePeptides'>Annotate peptides with protein ids</h2><span id='topic+annotatePeptides'></span>

<h3>Description</h3>

<p>peptides which do not have protein assignment drop out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotatePeptides(
  pepinfo,
  fasta,
  peptide = "peptideSeq",
  prefix = "(([RK])|(^)|(^M))",
  suffix = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotatePeptides_+3A_pepinfo">pepinfo</code></td>
<td>
<p>- list of peptides - sequence, optional modified sequence, charge state.</p>
</td></tr>
<tr><td><code id="annotatePeptides_+3A_fasta">fasta</code></td>
<td>
<p>- object as created by readPeptideFasta</p>
</td></tr>
<tr><td><code id="annotatePeptides_+3A_peptide">peptide</code></td>
<td>
<p>- name of column containing peptide sequences default &quot;peptideSeq&quot;</p>
</td></tr>
<tr><td><code id="annotatePeptides_+3A_prefix">prefix</code></td>
<td>
<p>- default &quot;(([RK])|(^)|(^M))&quot;</p>
</td></tr>
<tr><td><code id="annotatePeptides_+3A_suffix">suffix</code></td>
<td>
<p>- default &quot;&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns &quot;peptideSeq&quot;, &quot;proteinID&quot;,&quot;Offset&quot;,&quot;proteinSequence&quot;,&quot;matched&quot;, &quot;lengthPeptide&quot;,&quot;proteinlength&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

file = system.file("extdata/IDResults.txt.gz" , package = "prozor")
specMeta &lt;- readr::read_tsv(file)
upeptide &lt;- unique(specMeta$peptideSeq)
resCan &lt;-
   prozor::readPeptideFasta(
       system.file("p1000_db1_example/Annotation_canSeq.fasta.gz" , package = "prozor"))

annotAll = prozor::annotatePeptides(upeptide[seq_len(20)], resCan)
dim(annotAll)

res &lt;-  mutate(annotAll, proteinlength = nchar(proteinSequence))
res &lt;-  select(res, proteinID, peptideSeq, proteinlength, Offset, lengthPeptide)
head(res)
</code></pre>

<hr>
<h2 id='Cdsw-class'>Compute dynamic swath windows</h2><span id='topic+Cdsw-class'></span><span id='topic+Cdsw'></span>

<h3>Description</h3>

<p>initialize
</p>
<p>create equidistant breaks
</p>
<p>quantile breaks
</p>
<p>sampling breaks
</p>
<p>barplot showing the number of precursors per window
</p>
<p>Table with window boundaries and statistics
</p>
<p>summary of the binning process (see objectiveMS1Function for more details)
</p>
<p>moves window start and end to region with as few as possible precursor masses
</p>
<p>shows the generated DIA cycle
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cdsw-class_+3A_list">list</code></td>
<td>
<p>of masses</p>
</td></tr>
<tr><td><code id="Cdsw-class_+3A_nbins">nbins</code></td>
<td>
<p>number of bins default 25</p>
</td></tr>
<tr><td><code id="Cdsw-class_+3A_maxwindow">maxwindow</code></td>
<td>
<p>largest window size</p>
</td></tr>
<tr><td><code id="Cdsw-class_+3A_minwindow">minwindow</code></td>
<td>
<p>smallest window size</p>
</td></tr>
<tr><td><code id="Cdsw-class_+3A_digits">digits</code></td>
<td>
<p>mass precision default 2</p>
</td></tr>
<tr><td><code id="Cdsw-class_+3A_digigits">digigits</code></td>
<td>
<p>mass precision</p>
</td></tr>
<tr><td><code id="Cdsw-class_+3A_max">max</code></td>
<td>
<p>number of bins</p>
</td></tr>
<tr><td><code id="Cdsw-class_+3A_plot">plot</code></td>
<td>
<p>default TRUE</p>
</td></tr>
<tr><td><code id="Cdsw-class_+3A_overlap">overlap</code></td>
<td>
<p>size of window overlap default 1 m/z</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of masses
</p>
<p>array with masses
</p>
<p>array with masses
</p>
<p>data.frame with columns:
- from (window start)
- to (window end)
- mid (window centre), width (window width)
- counts expected number of precursors
</p>
<p>list with optimization scores
</p>
<p>data.frame with optimized windows
</p>


<h3>Fields</h3>


<dl>
<dt><code>masses</code></dt><dd><p>MS1 masses</p>
</dd>
<dt><code>breaks</code></dt><dd><p>the breaks</p>
</dd>
<dt><code>nbins</code></dt><dd><p>number of bins</p>
</dd>
<dt><code>digits</code></dt><dd><p>mass accuracy in result</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>asTable(overlap = 1)</code></dt><dd><p>make windows</p>
</dd>
<dt><code>error()</code></dt><dd><p>show error</p>
</dd>
<dt><code>optimizeWindows(digits = 1, maxbin = 15, plot = FALSE, overlap = 0)</code></dt><dd><p>optimizes the windows</p>
</dd>
<dt><code>quantile_breaks(digits = 2)</code></dt><dd><p>same number of MS1 in each window but might violate hard constraints</p>
</dd>
<dt><code>sampling_breaks(maxwindow = 150, minwindow = 5, digits = 2, plot = FALSE)</code></dt><dd><p>starts with quantile breaks but mixes with uniform data to satisfy had constraints</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(masses)
cdsw &lt;- Cdsw(masses)
tmp &lt;- cdsw$sampling_breaks(maxwindow=100,plot=TRUE)
cdsw$plot()
cdsw$asTable()
cdsw$breaks
cdsw$optimizeWindows()
cdsw$showCycle()
</code></pre>

<hr>
<h2 id='computeFDR'>Compute FDR given a score</h2><span id='topic+computeFDR'></span>

<h3>Description</h3>

<p>Same as computeFDRwithID but works with decoy_hit boolean vector.
For more details and references see package vignette
<code>vignette("TargetDecoyFDR_Example", package = "prozor")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeFDR(score, decoy_hit, larger_better = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeFDR_+3A_score">score</code></td>
<td>
<p>score</p>
</td></tr>
<tr><td><code id="computeFDR_+3A_decoy_hit">decoy_hit</code></td>
<td>
<p>indicates if decoy hit</p>
</td></tr>
<tr><td><code id="computeFDR_+3A_larger_better">larger_better</code></td>
<td>
<p>is larger score the better one (default TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with decoy_hit (indicates if decoy), score the search engine score,
FDR1 false discovery rate estimated using the method of Gygi, SimpleFDR - estimated using the method of Kaell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fdrSample)

fdr1 &lt;- computeFDR(fdrSample$score, grepl("REV_",fdrSample$proteinID), larger_better = FALSE)
head(as.data.frame(fdr1))

</code></pre>

<hr>
<h2 id='computeFDRwithID'>Compute FDR given a score</h2><span id='topic+computeFDRwithID'></span>

<h3>Description</h3>

<p>For more details and references see package vignette
<code>vignette("TargetDecoyFDR_Example", package = "prozor")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeFDRwithID(score, ID, decoy = "REV_", larger_better = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeFDRwithID_+3A_score">score</code></td>
<td>
<p>a vector with scores</p>
</td></tr>
<tr><td><code id="computeFDRwithID_+3A_id">ID</code></td>
<td>
<p>- list with protein id's</p>
</td></tr>
<tr><td><code id="computeFDRwithID_+3A_decoy">decoy</code></td>
<td>
<p>decoy pattern, default &quot;REV_&quot;</p>
</td></tr>
<tr><td><code id="computeFDRwithID_+3A_larger_better">larger_better</code></td>
<td>
<p>if larger score better than small (default TRUE), If small score better set FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with ID, decoy_hit (indicates if decoy), score the search engine score,
FDR1 false discovery rate estimated using the method of Elias and Gygi; FDR2 - estimated using the method of Kell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fdrSample)
# call constructor
#nrow(fdrSample)
#fdrSample &lt;- dplyr::slice_sample(fdrSample, n = 40000)

#usethis::use_data(fdrSample, overwrite = TRUE)
fdr1 &lt;- computeFDRwithID(fdrSample$score, fdrSample$proteinID, larger_better = FALSE)
names(fdr1)
plot(fdr1$score, fdr1$FPR,type="l",xlim=c(0,0.001), ylim=c(0,0.0002))
lines(fdr1$score, fdr1$qValue_FPR, col=2)
lines(fdr1$score, fdr1$SimpleFDR,type="l",col=4)
lines(fdr1$score, fdr1$qValue_SimpleFDR, col=5)


fdr1 &lt;- computeFDRwithID(fdrSample$score2, fdrSample$proteinID, larger_better = TRUE)
names(fdr1)
plot(fdr1$score, fdr1$FPR,type="l", xlim=c(2.5,5),ylim=c(0,0.001))
lines(fdr1$score, fdr1$qValue_FPR, col=2)
lines(fdr1$score, fdr1$SimpleFDR,type="l",col=4)
lines(fdr1$score, fdr1$qValue_SimpleFDR, col=5)

</code></pre>

<hr>
<h2 id='create_fgcz_fasta_db'>create fasta db from one or more fasta files</h2><span id='topic+create_fgcz_fasta_db'></span>

<h3>Description</h3>

<p>create fasta db from one or more fasta files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_fgcz_fasta_db(
  databasedirectory,
  useContaminants = loadContaminantsFasta2021(),
  revLab = "REV_",
  outputdir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_fgcz_fasta_db_+3A_databasedirectory">databasedirectory</code></td>
<td>
<p>directory with fasta files</p>
</td></tr>
<tr><td><code id="create_fgcz_fasta_db_+3A_usecontaminants">useContaminants</code></td>
<td>
<p>contaminants to add</p>
</td></tr>
<tr><td><code id="create_fgcz_fasta_db_+3A_revlab">revLab</code></td>
<td>
<p>reverse label</p>
</td></tr>
<tr><td><code id="create_fgcz_fasta_db_+3A_outputdir">outputdir</code></td>
<td>
<p>output directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list list(resDB, filepath , summary, mcall, dbname)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("NO exmple since function also writes the fasta files")

</code></pre>

<hr>
<h2 id='createDecoyDB'>Create db with decoys and contaminants</h2><span id='topic+createDecoyDB'></span>

<h3>Description</h3>

<p>For more details and references see package vignette
<code>vignette("CreateDecoyDB", package = "prozor")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createDecoyDB(
  dbs,
  useContaminants = loadContaminantsFasta2021(),
  revLab = "REV_",
  annot = "zz|sourceOf|database"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createDecoyDB_+3A_dbs">dbs</code></td>
<td>
<p>a path to a fasta file or an array of files</p>
</td></tr>
<tr><td><code id="createDecoyDB_+3A_usecontaminants">useContaminants</code></td>
<td>
<p>list with contaminant sequences</p>
</td></tr>
<tr><td><code id="createDecoyDB_+3A_revlab">revLab</code></td>
<td>
<p>label for reversed peptides (if NULL do not generate decoys)</p>
</td></tr>
<tr><td><code id="createDecoyDB_+3A_annot">annot</code></td>
<td>
<p>source of database</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of SeqFastaAA entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file = system.file("extdata/fgcz_contaminants2021_20210929.fasta.gz",package="prozor")
cont &lt;- loadContaminantsFasta2021()
rabbit &lt;-readPeptideFasta(file)
tmp &lt;- 2*(2*length(rabbit)+length(cont)) + 1

res &lt;- createDecoyDB(c(file,file))
length(res)
stopifnot(length(res) == tmp)

res &lt;- createDecoyDB(c(file,file), revLab=NULL)
stopifnot(length(res) == (2*length(rabbit)+length(cont) + 1))
res &lt;- createDecoyDB(c(file,file), revLab=NULL, useContaminants = NULL)
stopifnot(length(res) == (2*length(rabbit) + 1) )

</code></pre>

<hr>
<h2 id='fdrSample'>Data frame score and proteinID</h2><span id='topic+fdrSample'></span>

<h3>Description</h3>

<p>Data frame score and proteinID
</p>

<hr>
<h2 id='greedy'>given matrix (columns protein rows peptides), compute minimal protein set using greedy algorithm</h2><span id='topic+greedy'></span>

<h3>Description</h3>

<p>given matrix (columns protein rows peptides), compute minimal protein set using greedy algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greedy(pepprot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greedy_+3A_pepprot">pepprot</code></td>
<td>
<p>matrix as returned by prepareMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of peptide protein assignment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(prozor)

data(protpepmetashort)
colnames(protpepmetashort)
dim(unique(protpepmetashort[,4]))
xx = prepareMatrix(protpepmetashort, peptideID = "peptideModSeq")
dim(xx)
stopifnot(dim(xx)[1] == dim(unique(protpepmetashort[,4]))[1])
es = greedy(xx)
stopifnot(length(unique(names(es))) == dim(unique(protpepmetashort[,4]))[1])

</code></pre>

<hr>
<h2 id='greedyRes2Matrix'>converts result of greedy function to a matrix with 3 columns - peptide - charge and protein</h2><span id='topic+greedyRes2Matrix'></span>

<h3>Description</h3>

<p>converts result of greedy function to a matrix with 3 columns - peptide - charge and protein
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greedyRes2Matrix(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greedyRes2Matrix_+3A_res">res</code></td>
<td>
<p>result of function prozor::greedy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of peptide protein assignments
</p>

<hr>
<h2 id='hardconstrain'>tests hard constraints</h2><span id='topic+hardconstrain'></span>

<h3>Description</h3>

<p>tests hard constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hardconstrain(splits, minwindow = 5, maxwindow = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hardconstrain_+3A_splits">splits</code></td>
<td>
<p>the proposed splits</p>
</td></tr>
<tr><td><code id="hardconstrain_+3A_minwindow">minwindow</code></td>
<td>
<p>min window size</p>
</td></tr>
<tr><td><code id="hardconstrain_+3A_maxwindow">maxwindow</code></td>
<td>
<p>max window size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='loadContaminantsFasta2019'>load list of contaminant sequences FGCZ 2019</h2><span id='topic+loadContaminantsFasta2019'></span>

<h3>Description</h3>

<p>load list of contaminant sequences FGCZ 2019
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadContaminantsFasta2019(noHuman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadContaminantsFasta2019_+3A_nohuman">noHuman</code></td>
<td>
<p>should human contaminants be excluded? default FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with contaminant sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(prozor)
cont &lt;- loadContaminantsFasta2019()
length(cont)
contNH &lt;- loadContaminantsFasta2019()
length(contNH)
#example how to create a protein db with decoy sequences
</code></pre>

<hr>
<h2 id='loadContaminantsFasta2021'>load list of contaminant sequences FGCZ 2021</h2><span id='topic+loadContaminantsFasta2021'></span>

<h3>Description</h3>

<p>load list of contaminant sequences FGCZ 2021
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadContaminantsFasta2021(noHuman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadContaminantsFasta2021_+3A_nohuman">noHuman</code></td>
<td>
<p>should human contaminants be excluded? default FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with contaminant sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(prozor)
cont &lt;- loadContaminantsFasta2021()
length(cont)
contNH &lt;- loadContaminantsFasta2021()
length(contNH)
#example how to create a protein db with decoy sequences
</code></pre>

<hr>
<h2 id='makeID'>make id for chain in format sp|P30443|1A01_HUMANs25</h2><span id='topic+makeID'></span>

<h3>Description</h3>

<p>make id for chain in format sp|P30443|1A01_HUMANs25
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeID(sequence, id, sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeID_+3A_sequence">sequence</code></td>
<td>
<p>- aa sequence as string</p>
</td></tr>
<tr><td><code id="makeID_+3A_id">id</code></td>
<td>
<p>uniprot id id: sp|P30443|1A01_HUMAN</p>
</td></tr>
<tr><td><code id="makeID_+3A_sp">sp</code></td>
<td>
<p>start position of chain numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string consisting of id,&quot;s&quot;,sp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq &lt;- "MAVMAPRTLLLLLSGALALTQTWAGSHSMRYFFTSVSRPGR\
GEPRFIAVGYVDDTQFVRFDSDAASQKMEPRAPWIEQEGPEYWDQETRN\
MKAHSQTDRANLGTLRGYYNQSEDGSHTIQIMYGCDVGPDGRFLRGYRQ\
DAYDGKDYIALNEDLRSWTAADMAAQITKRKWEAVHAAEQRRVYLEGRC\
VDGLRRYLENGKETLQRTDPPKTHMTHHPISDHEATLRCWALGFYPAEI\
TLTWQRDGEDQTQDTELVETRPAGDGTFQKWAAVVVPSGEEQRYTCHVQ\
HEGLPKPLTLRWELSSQPTIPIVGIIAGLVLLGAVITGAVVAAVMWRRK\
SSDRKGGSYTQAASSDSAQGSDVSLTACKV"
nam &lt;-"sp|P30443|1A01_HUMAN"
sp &lt;- 24
makeID(seq, nam, sp)
</code></pre>

<hr>
<h2 id='makeIDUnip'>make id for chain compatible with uniprot</h2><span id='topic+makeIDUnip'></span>

<h3>Description</h3>

<p>make id for chain compatible with uniprot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeIDUnip(sequence, id, sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeIDUnip_+3A_sequence">sequence</code></td>
<td>
<p>- aa sequence as string</p>
</td></tr>
<tr><td><code id="makeIDUnip_+3A_id">id</code></td>
<td>
<p>uniprot id id: sp|P30443|1A01_HUMAN</p>
</td></tr>
<tr><td><code id="makeIDUnip_+3A_sp">sp</code></td>
<td>
<p>start position of chain numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string consisting of sp,&quot;-&quot;, length of sequnce
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq &lt;- "MAVMAPRTLLLLLSGALALTQTWAGSHSMRYFFTSVSRPGR\
GEPRFIAVGYVDDTQFVRFDSDAASQKMEPRAPWIEQEGPEYWDQETRN\
MKAHSQTDRANLGTLRGYYNQSEDGSHTIQIMYGCDVGPDGRFLRGYRQ\
DAYDGKDYIALNEDLRSWTAADMAAQITKRKWEAVHAAEQRRVYLEGRC\
VDGLRRYLENGKETLQRTDPPKTHMTHHPISDHEATLRCWALGFYPAEI\
TLTWQRDGEDQTQDTELVETRPAGDGTFQKWAAVVVPSGEEQRYTCHVQ\
HEGLPKPLTLRWELSSQPTIPIVGIIAGLVLLGAVITGAVVAAVMWRRK\
SSDRKGGSYTQAASSDSAQGSDVSLTACKV"
nam &lt;-"sp|P30443|1A01_HUMAN"
sp &lt;- 24
makeIDUnip(seq, nam, sp)
</code></pre>

<hr>
<h2 id='masses'>MS masses
A dataset containing approx 150000 MS1 precursor masses</h2><span id='topic+masses'></span>

<h3>Description</h3>

<p>MS masses
A dataset containing approx 150000 MS1 precursor masses
</p>

<hr>
<h2 id='objectiveMS1Function'>compute the deviation from optimum: equal number of MS1 per bin</h2><span id='topic+objectiveMS1Function'></span>

<h3>Description</h3>

<p>compute the deviation from optimum: equal number of MS1 per bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectiveMS1Function(splits, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectiveMS1Function_+3A_splits">splits</code></td>
<td>
<p>the new window boundaries</p>
</td></tr>
<tr><td><code id="objectiveMS1Function_+3A_data">data</code></td>
<td>
<p>the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with score1 - manhattan distance, score2 - euclidean distance, counts - observed counts, optimumN - optimum counts
</p>

<hr>
<h2 id='pepprot'>Table containing peptide information</h2><span id='topic+pepprot'></span>

<h3>Description</h3>

<p>Table containing peptide information
</p>

<hr>
<h2 id='plotFDR'>plot FDR</h2><span id='topic+plotFDR'></span>

<h3>Description</h3>

<p>For more details and references see package vignette
<code>vignette("TargetDecoyFDR_Example", package = "prozor")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFDR(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFDR_+3A_data">data</code></td>
<td>
<p>data returned by computeFDR function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>creates a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(prozor)
data(fdrSample)
fdr1 &lt;- computeFDRwithID(fdrSample$score, fdrSample$proteinID, larger_better = FALSE)
fdr2 &lt;- computeFDRwithID(fdrSample$score2, fdrSample$proteinID, larger_better = TRUE)
plotFDR(fdr1)
plotFDR(fdr2)
data&lt;-fdr1

</code></pre>

<hr>
<h2 id='predictScoreFDR'>Predict score given FDR</h2><span id='topic+predictScoreFDR'></span>

<h3>Description</h3>

<p>For more details and references see package vignette
<code>vignette("TargetDecoyFDR_Example", package = "prozor")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictScoreFDR(fdrObj, qValue = 1, method = "SimpleFDR")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictScoreFDR_+3A_fdrobj">fdrObj</code></td>
<td>
<p>object generated by computeFDR</p>
</td></tr>
<tr><td><code id="predictScoreFDR_+3A_qvalue">qValue</code></td>
<td>
<p>false discovery rate in percent, default 1 percent</p>
</td></tr>
<tr><td><code id="predictScoreFDR_+3A_method">method</code></td>
<td>
<p>either FPR or SimpleFDR, default is SimpleFDR</p>
</td></tr>
</table>


<h3>Value</h3>

<p>score for a given FDR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fdrSample)
fdr1 &lt;- computeFDRwithID(fdrSample$score, fdrSample$proteinID, larger_better = FALSE)

predictScoreFDR(fdr1,qValue=5)
fdr2&lt;-computeFDRwithID(fdrSample$score2, fdrSample$proteinID, larger_better = TRUE)
predictScoreFDR(fdr2,qValue=5)

</code></pre>

<hr>
<h2 id='prepareMatrix'>given table of peptide protein assigments generate matrix</h2><span id='topic+prepareMatrix'></span>

<h3>Description</h3>

<p>given table of peptide protein assigments generate matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareMatrix(
  data,
  proteinID = "proteinID",
  peptideID = "strippedSequence",
  weighting = NULL,
  sep = "|"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareMatrix_+3A_data">data</code></td>
<td>
<p>generated by annotatePeptides</p>
</td></tr>
<tr><td><code id="prepareMatrix_+3A_proteinid">proteinID</code></td>
<td>
<p>protein ID column</p>
</td></tr>
<tr><td><code id="prepareMatrix_+3A_peptideid">peptideID</code></td>
<td>
<p>peptide / precursor ID column</p>
</td></tr>
<tr><td><code id="prepareMatrix_+3A_weighting">weighting</code></td>
<td>
<p>weight type to use. Options are &quot;one&quot; , &quot;AA&quot; - amino acids, &quot;coverage&quot; - coverage , &quot;inverse&quot; - inverse peptide frequencies</p>
</td></tr>
<tr><td><code id="prepareMatrix_+3A_sep">sep</code></td>
<td>
<p>separator for precursor (rownames)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sparse matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(prozor)
data(protpepmetashort)
library(Matrix)
colnames(protpepmetashort)
head(protpepmetashort)
dim(protpepmetashort)
count = prepareMatrix( protpepmetashort, peptideID = "peptideSeq" )
dim(count)
inverse = prepareMatrix( protpepmetashort, peptideID = "peptideSeq" , weight = "inverse")
#aa = prepareMatrix(protpepmetashort,  peptideID = "peptideSeq" , weight = "AA")
#xx = prepareMatrix(protpepmetashort,  peptideID = "peptideSeq" , weight = "coverage")
image( as.matrix(count) )

corProt = cor( as.matrix(count) )
par(mfrow =c(1,2))
image(corProt)

#penalise peptides matching many proteins
corProtn = cor( as.matrix(inverse) )
image(corProtn)

</code></pre>

<hr>
<h2 id='protpepmetashort'>Small version of pepprot dataset to speed up computation</h2><span id='topic+protpepmetashort'></span>

<h3>Description</h3>

<p>Small version of pepprot dataset to speed up computation
</p>

<hr>
<h2 id='prozor'>Minimal Protein Set Explaining Peptides</h2><span id='topic+prozor'></span>

<h3>Description</h3>

<p>Determine minimal protein set explaining
peptide spectrum matches. Utility functions for creating fasta amino acid databases with decoys and contaminants.
Peptide false discovery rate estimation for target decoy search results on psm, precursor, peptide and protein
level. Computing dynamic swath window sizes based on MS1 and MS2 signal distributions.
</p>

<hr>
<h2 id='readjustWindows'>Readjust windows so that boundaries in regions of few peaks.</h2><span id='topic+readjustWindows'></span>

<h3>Description</h3>

<p>Readjust windows so that boundaries in regions of few peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readjustWindows(wind, ms1data, digits = 1, maxbin = 15, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readjustWindows_+3A_wind">wind</code></td>
<td>
<p>a data frame with columns from and to</p>
</td></tr>
<tr><td><code id="readjustWindows_+3A_ms1data">ms1data</code></td>
<td>
<p>masses</p>
</td></tr>
<tr><td><code id="readjustWindows_+3A_digits">digits</code></td>
<td>
<p>mass accuracy</p>
</td></tr>
<tr><td><code id="readjustWindows_+3A_maxbin">maxbin</code></td>
<td>
<p>maximum number of bins</p>
</td></tr>
<tr><td><code id="readjustWindows_+3A_plot">plot</code></td>
<td>
<p>diagnostic plots (default FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of same format as <code>wind</code> but with improved start and end masses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(masses)
cdsw &lt;- Cdsw(masses)
breaks &lt;- cdsw$sampling_breaks(maxwindow=100,plot=TRUE)
table &lt;- cdsw$asTable()
dim(table)
head(table)

tmp &lt;- readjustWindows(table, masses,maxbin=10)
data.frame(tmp)

</code></pre>

<hr>
<h2 id='readPeptideFasta'>wrapper setting the correct parameters
seqinr::read.fasta for reading peptide sequences</h2><span id='topic+readPeptideFasta'></span>

<h3>Description</h3>

<p>peptides which do not have protein assignment drop out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readPeptideFasta(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readPeptideFasta_+3A_file">file</code></td>
<td>
<p>- fasta file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(seqinr)

file = system.file("extdata/fgcz_contaminants2021_20210929.fasta.gz",package = "prozor")
fasta = readPeptideFasta(file)

</code></pre>

<hr>
<h2 id='removeSignalPeptide'>remove signal peptides from main chain</h2><span id='topic+removeSignalPeptide'></span>

<h3>Description</h3>

<p>remove signal peptides from main chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeSignalPeptide(db, signal, idfun = makeID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeSignalPeptide_+3A_db">db</code></td>
<td>
<p>uniprot fasta database as list</p>
</td></tr>
<tr><td><code id="removeSignalPeptide_+3A_signal">signal</code></td>
<td>
<p>tab delimited file with signals</p>
</td></tr>
<tr><td><code id="removeSignalPeptide_+3A_idfun">idfun</code></td>
<td>
<p>function to generate id's</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with sequences with signal peptide removed
</p>

<hr>
<h2 id='reverseSeq'>create rev sequences to fasta list</h2><span id='topic+reverseSeq'></span>

<h3>Description</h3>

<p>peptides which do not have protein assignment drop out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverseSeq(fasta, revLab = "REV_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverseSeq_+3A_fasta">fasta</code></td>
<td>
<p>- an r list with SeqFastaAA</p>
</td></tr>
<tr><td><code id="reverseSeq_+3A_revlab">revLab</code></td>
<td>
<p>- how to label reverse sequences, default = REV_</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string with reversed sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(seqinr)
#library(prozor)

file = system.file("extdata/fgcz_contaminants2021_20210929.fasta.gz", package="prozor")
fasta = readPeptideFasta(file = file)
getAnnot(fasta[[1]])
x &lt;- reverseSeq(fasta)

revseq &lt;- reverseSeq(fasta ,revLab = "REV_")
stopifnot(length(revseq) == length(fasta))
stopifnot(grep("^REV_","REV_zz|ZZ_FGCZCont0000|")==1)

tmp &lt;- list(as.SeqFastaAA(("DYKDDDDK"),name="Flag|FLAG|p2079",Annot=""))

reverseSeq(tmp)

</code></pre>

<hr>
<h2 id='writeFasta'>write fasta lists into file</h2><span id='topic+writeFasta'></span>

<h3>Description</h3>

<p>peptides which do not have protein assignment drop out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFasta(file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeFasta_+3A_file">file</code></td>
<td>
<p>where to write</p>
</td></tr>
<tr><td><code id="writeFasta_+3A_...">...</code></td>
<td>
<p>fasta list or single file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>writes a file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example how to create a protein db with decoy sequences
library(seqinr)
#library(prozor)
file = system.file("extdata/fgcz_contaminants2021_20210929.fasta.gz",package = "prozor")
fasta = readPeptideFasta(file = file)
revfasta &lt;- reverseSeq(fasta)
decoyDB &lt;- c(fasta,revfasta)
stopifnot(length(decoyDB) == 2 * length(fasta))
## Not run: 
writeFasta(decoyDB, file="test.fasta")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
