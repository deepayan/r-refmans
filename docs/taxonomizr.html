<!DOCTYPE html><html><head><title>Help for package taxonomizr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {taxonomizr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accessionToTaxa'><p>Convert accessions to taxa</p></a></li>
<li><a href='#condenseTaxa'><p>Condense multiple taxonomic assignments to their most recent common branch</p></a></li>
<li><a href='#getAccession2taxid'><p>Download accession2taxid files from NCBI</p></a></li>
<li><a href='#getAccessions'><p>Find all accessions for a taxa</p></a></li>
<li><a href='#getCommon'><p>Find common names for a given taxa</p></a></li>
<li><a href='#getDescendants'><p>Get descendant ranks for a taxa</p></a></li>
<li><a href='#getId'><p>Find a given taxa by name</p></a></li>
<li><a href='#getId2'><p>Find a given taxa by name</p></a></li>
<li><a href='#getNamesAndNodes'><p>Download names and nodes files from NCBI</p></a></li>
<li><a href='#getRawTaxonomy'><p>Get all taxonomy for a taxa</p></a></li>
<li><a href='#getTaxonomy'><p>Get taxonomic ranks for a taxa</p></a></li>
<li><a href='#getTaxonomy2'><p>Get taxonomic ranks for a taxa</p></a></li>
<li><a href='#lastNotNa'><p>Return last not NA value</p></a></li>
<li><a href='#makeNewick'><p>Create a Newick tree from taxonomy</p></a></li>
<li><a href='#normalizeTaxa'><p>Bring multiple raw taxonomies into alignment</p></a></li>
<li><a href='#prepareDatabase'><p>Download data from NCBI and set up SQLite database</p></a></li>
<li><a href='#read.accession2taxid'><p>Read NCBI accession2taxid files</p></a></li>
<li><a href='#read.names'><p>Read NCBI names file</p></a></li>
<li><a href='#read.names.sql'><p>Read NCBI names file</p></a></li>
<li><a href='#read.nodes'><p>Read NCBI nodes file</p></a></li>
<li><a href='#read.nodes.sql'><p>Read NCBI nodes file</p></a></li>
<li><a href='#resumableDownload'><p>Download file using curl allowing resumption of interrupted files</p></a></li>
<li><a href='#streamingRead'><p>Process a large file piecewise</p></a></li>
<li><a href='#taxonomizr-package'><p>taxonomizr: Functions to Work with NCBI Accessions and Taxonomy</p></a></li>
<li><a href='#taxonomizrSwitch'><p>Switch from data.table to SQLite</p></a></li>
<li><a href='#topoSort'><p>Combine multiple sorted vectors into a single sorted vector</p></a></li>
<li><a href='#trimTaxa'><p>Trim columns from taxa file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Scott Sherrill-Mix &lt;ssm@msu.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions to Work with NCBI Accessions and Taxonomy</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Sherrill-Mix [aut, cre]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sherrillmix/taxonomizr/issues">https://github.com/sherrillmix/taxonomizr/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for assigning taxonomy to NCBI accession numbers and taxon IDs based on NCBI's accession2taxid and taxdump files. This package allows the user to download NCBI data dumps and create a local database for fast and local taxonomic assignment.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-15</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RSQLite, R.utils, data.table, curl (&ge; 5.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-15 14:53:02 UTC; scott</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-15 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='accessionToTaxa'>Convert accessions to taxa</h2><span id='topic+accessionToTaxa'></span>

<h3>Description</h3>

<p>Convert a vector of NCBI accession numbers to their assigned taxonomy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accessionToTaxa(accessions, sqlFile, version = c("version", "base"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accessionToTaxa_+3A_accessions">accessions</code></td>
<td>
<p>a vector of NCBI accession strings to convert to taxa</p>
</td></tr>
<tr><td><code id="accessionToTaxa_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path to a SQLite file screated by <code><a href="#topic+read.accession2taxid">read.accession2taxid</a></code></p>
</td></tr>
<tr><td><code id="accessionToTaxa_+3A_version">version</code></td>
<td>
<p>either 'version' indicating that taxaids are versioned e.g. Z17427.1 or 'base' indicating that taxaids do not have version numbers e.g. Z17427</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of NCBI taxa ids
</p>


<h3>References</h3>

<p><a href="https://ftp.ncbi.nih.gov/pub/taxonomy/accession2taxid/">https://ftp.ncbi.nih.gov/pub/taxonomy/accession2taxid/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTaxonomy">getTaxonomy</a></code>, <code><a href="#topic+read.accession2taxid">read.accession2taxid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>taxa&lt;-c(
 "accession\taccession.version\ttaxid\tgi",
 "Z17427\tZ17427.1\t3702\t16569",
 "Z17428\tZ17428.1\t3702\t16570",
 "Z17429\tZ17429.1\t3702\t16571",
 "Z17430\tZ17430.1\t3702\t16572",
 "X62402\tX62402.1\t9606\t30394"
)
inFile&lt;-tempfile()
sqlFile&lt;-tempfile()
writeLines(taxa,inFile)
read.accession2taxid(inFile,sqlFile,vocal=FALSE)
accessionToTaxa(c("Z17430.1","Z17429.1","X62402.1",'NOTREAL'),sqlFile)
</code></pre>

<hr>
<h2 id='condenseTaxa'>Condense multiple taxonomic assignments to their most recent common branch</h2><span id='topic+condenseTaxa'></span>

<h3>Description</h3>

<p>Take a table of taxonomic assignments, e.g. assignments from hits to a read, and condense it to a single vector with NAs where there are disagreements between the hits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condenseTaxa(taxaTable, groupings = rep(1, nrow(taxaTable)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condenseTaxa_+3A_taxatable">taxaTable</code></td>
<td>
<p>a matrix or data.frame with hits on the rows and various levels of taxonomy in the columns</p>
</td></tr>
<tr><td><code id="condenseTaxa_+3A_groupings">groupings</code></td>
<td>
<p>a vector of groups e.g. read queries to condense taxa within</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with <code>ncol(taxaTable)</code> taxonomy columns with a row for each unique id (labelled on rownames) with NAs where there was not complete agreement for an id
</p>


<h3>Examples</h3>

<pre><code class='language-R'>taxas&lt;-matrix(c(
 'a','b','c','e',
 'a','b','d','e'
),nrow=2,byrow=TRUE)
condenseTaxa(taxas)
condenseTaxa(taxas[c(1,2,2),],c(1,1,2))
</code></pre>

<hr>
<h2 id='getAccession2taxid'>Download accession2taxid files from NCBI</h2><span id='topic+getAccession2taxid'></span>

<h3>Description</h3>

<p>Download a nucl_xxx.accession2taxid.gz from NCBI servers. These can then be used to create a SQLite datanase with <code><a href="#topic+read.accession2taxid">read.accession2taxid</a></code>. Note that if the files already exist in the target directory then this function will not redownload them. Delete the files if a fresh download is desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAccession2taxid(
  outDir = ".",
  baseUrl = sprintf("%s://ftp.ncbi.nih.gov/pub/taxonomy/accession2taxid/", protocol),
  types = c("nucl_gb", "nucl_wgs"),
  protocol = "ftp",
  resume = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAccession2taxid_+3A_outdir">outDir</code></td>
<td>
<p>the directory to put the accession2taxid.gz files in</p>
</td></tr>
<tr><td><code id="getAccession2taxid_+3A_baseurl">baseUrl</code></td>
<td>
<p>the url of the directory where accession2taxid.gz files are located</p>
</td></tr>
<tr><td><code id="getAccession2taxid_+3A_types">types</code></td>
<td>
<p>the types if accession2taxid.gz files desired where type is the prefix of xxx.accession2taxid.gz. The default is to download all nucl_ accessions. For protein accessions, try <code>types=c('prot')</code>.</p>
</td></tr>
<tr><td><code id="getAccession2taxid_+3A_protocol">protocol</code></td>
<td>
<p>the protocol to be used for downloading. Probably either <code>'http'</code> or <code>'ftp'</code>. Overridden if <code>baseUrl</code> is provided directly</p>
</td></tr>
<tr><td><code id="getAccession2taxid_+3A_resume">resume</code></td>
<td>
<p>if TRUE attempt to resume downloading an interrupted file without starting over from the beginning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of file path strings of the locations of the output files
</p>


<h3>References</h3>

<p><a href="https://ftp.ncbi.nih.gov/pub/taxonomy/">https://ftp.ncbi.nih.gov/pub/taxonomy/</a>, <a href="https://www.ncbi.nlm.nih.gov/genbank/acc_prefix/">https://www.ncbi.nlm.nih.gov/genbank/acc_prefix/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.accession2taxid">read.accession2taxid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  if(readline(
    "This will download a lot data and take a while to process.
     Make sure you have space and bandwidth. Type y to continue: "
  )!='y')
    stop('This is a stop to make sure no one downloads a bunch of data unintentionally')

  getAccession2taxid()

## End(Not run)
</code></pre>

<hr>
<h2 id='getAccessions'>Find all accessions for a taxa</h2><span id='topic+getAccessions'></span>

<h3>Description</h3>

<p>Find accessions numbers for a given taxa ID the NCBI taxonomy. This will be pretty slow unless the database was built with indexTaxa=TRUE since the database would not have an index for taxaId.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAccessions(taxaId, sqlFile, version = c("version", "base"), limit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAccessions_+3A_taxaid">taxaId</code></td>
<td>
<p>a vector of taxonomic IDs</p>
</td></tr>
<tr><td><code id="getAccessions_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path to a SQLite file created by <code><a href="#topic+read.accession2taxid">read.accession2taxid</a></code></p>
</td></tr>
<tr><td><code id="getAccessions_+3A_version">version</code></td>
<td>
<p>either 'version' indicating that taxaids are versioned e.g. Z17427.1 or 'base' indicating that taxaids do not have version numbers e.g. Z17427</p>
</td></tr>
<tr><td><code id="getAccessions_+3A_limit">limit</code></td>
<td>
<p>return only this number of accessions or NULL for no limits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character strings giving taxa IDs (potentially comma concatenated for any taxa with ambiguous names)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.accession2taxid">read.accession2taxid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>taxa&lt;-c(
  "accession\taccession.version\ttaxid\tgi",
  "Z17427\tZ17427.1\t3702\t16569",
  "Z17428\tZ17428.1\t3702\t16570",
  "Z17429\tZ17429.1\t3702\t16571",
  "Z17430\tZ17430.1\t3702\t16572"
)
inFile&lt;-tempfile()
sqlFile&lt;-tempfile()
writeLines(taxa,inFile)
read.accession2taxid(inFile,sqlFile,vocal=FALSE)
getAccessions(3702,sqlFile)
</code></pre>

<hr>
<h2 id='getCommon'>Find common names for a given taxa</h2><span id='topic+getCommon'></span>

<h3>Description</h3>

<p>Find all common names recorded for a taxa in the NCBI taxonomy. Use <code><a href="#topic+getTaxonomy">getTaxonomy</a></code> for scientific names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCommon(taxa, sqlFile = "nameNode.sqlite", types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCommon_+3A_taxa">taxa</code></td>
<td>
<p>a vector of accession numbers</p>
</td></tr>
<tr><td><code id="getCommon_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path to a SQLite file containing a names tables</p>
</td></tr>
<tr><td><code id="getCommon_+3A_types">types</code></td>
<td>
<p>a vector of strings giving the type of names desired e.g. &quot;common name&quot;. If NULL then all types are returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of data.frames where each element corresponds to the query taxa IDs. Each data.frame contains columns name and type and each gives an available names and its name type
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTaxonomy">getTaxonomy</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>, <code><a href="#topic+getId">getId</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesText&lt;-"9894\t|\tGiraffa camelopardalis (Linnaeus, 1758)\t|\t\t|\tauthority\t|
9894\t|\tGiraffa camelopardalis\t|\t\t|\tscientific name\t|
9894\t|\tgiraffe\t|\t\t|\tgenbank common name\t|
9909\t|\taurochs\t|\t\t|\tgenbank common name\t|
9909\t|\tBos primigenius Bojanus, 1827\t|\t\t|\tauthority\t|
9909\t|\tBos primigenius\t|\t\t|\tscientific name\t|
9913\t|\tBos bovis\t|\t\t|\tsynonym\t|
9913\t|\tBos primigenius taurus\t|\t\t|\tsynonym\t|
9913\t|\tBos taurus Linnaeus, 1758\t|\t\t|\tauthority\t|
9913\t|\tBos taurus\t|\t\t|\tscientific name\t|
9913\t|\tBovidae sp. Adi Nefas\t|\t\t|\tincludes\t|
9913\t|\tbovine\t|\t\t|\tcommon name\t|
9913\t|\tcattle\t|\t\t|\tgenbank common name\t|
9913\t|\tcow\t|\t\t|\tcommon name\t|
9913\t|\tdairy cow\t|\t\t|\tcommon name\t|
9913\t|\tdomestic cattle\t|\t\t|\tcommon name\t|
9913\t|\tdomestic cow\t|\t\t|\tcommon name\t|
9913\t|\tox\t|\t\t|\tcommon name\t|
9913\t|\toxen\t|\t\t|\tcommon name\t|
9916\t|\tBoselaphus\t|\t\t|\tscientific name\t|"
tmpFile&lt;-tempfile()
writeLines(namesText,tmpFile)
sqlFile&lt;-tempfile()
read.names.sql(tmpFile,sqlFile)
getCommon(9909,sqlFile)
sapply(getCommon(c(9894,9913),sqlFile),function(xx)paste(xx$name,collapse='; '))
getCommon(c(9999999,9916,9894,9913),sqlFile,c("common name","genbank common name"))
</code></pre>

<hr>
<h2 id='getDescendants'>Get descendant ranks for a taxa</h2><span id='topic+getDescendants'></span>

<h3>Description</h3>

<p>Take a NCBI taxa ID and get the descendant taxa matching a given rank from a name and node SQLite database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDescendants(ids, sqlFile = "nameNode.sqlite", desiredTaxa = "species")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDescendants_+3A_ids">ids</code></td>
<td>
<p>a vector of ids to find descendants for</p>
</td></tr>
<tr><td><code id="getDescendants_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path to a SQLite file containing names and nodes tables</p>
</td></tr>
<tr><td><code id="getDescendants_+3A_desiredtaxa">desiredTaxa</code></td>
<td>
<p>a vector of strings giving the desired taxa levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of strings giving the names a for each descendant taxa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqlFile&lt;-tempfile()
namesText&lt;-c(
  "1\t|\troot\t|\t\t|\tscientific name\t|",
  "2\t|\tBacteria\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tProcaryotae\t|\tProcaryotae &lt;Bacteria&gt;\t|\tin-part\t|",
  "9606\t|\tHomo sapiens\t|\t\t|\tscientific name",
  "9605\t|\tHomo\t|\t\t|\tscientific name",
  "207598\t|\tHomininae\t|\t\t|\tscientific name",
  "9604\t|\tHominidae\t|\t\t|\tscientific name",
  "314295\t|\tHominoidea\t|\t\t|\tscientific name",
  "9526\t|\tCatarrhini\t|\t\t|\tscientific name",
  "314293\t|\tSimiiformes\t|\t\t|\tscientific name",
  "376913\t|\tHaplorrhini\t|\t\t|\tscientific name",
  "9443\t|\tPrimates\t|\t\t|\tscientific name",
  "314146\t|\tEuarchontoglires\t|\t\t|\tscientific name",
  "1437010\t|\tBoreoeutheria\t|\t\t|\tscientific name",
  "9347\t|\tEutheria\t|\t\t|\tscientific name",
  "32525\t|\tTheria\t|\t\t|\tscientific name",
  "40674\t|\tMammalia\t|\t\t|\tscientific name",
  "32524\t|\tAmniota\t|\t\t|\tscientific name",
  "32523\t|\tTetrapoda\t|\t\t|\tscientific name",
  "1338369\t|\tDipnotetrapodomorpha\t|\t\t|\tscientific name",
  "8287\t|\tSarcopterygii\t|\t\t|\tscientific name",
  "117571\t|\tEuteleostomi\t|\t\t|\tscientific name",
  "117570\t|\tTeleostomi\t|\t\t|\tscientific name",
  "7776\t|\tGnathostomata\t|\t\t|\tscientific name",
  "7742\t|\tVertebrata\t|\t\t|\tscientific name",
  "89593\t|\tCraniata\t|\t\t|\tscientific name",
  "7711\t|\tChordata\t|\t\t|\tscientific name",
  "33511\t|\tDeuterostomia\t|\t\t|\tscientific name",
  "33213\t|\tBilateria\t|\t\t|\tscientific name",
  "6072\t|\tEumetazoa\t|\t\t|\tscientific name",
  "33208\t|\tMetazoa\t|\t\t|\tscientific name",
  "33154\t|\tOpisthokonta\t|\t\t|\tscientific name",
  "2759\t|\tEukaryota\t|\t\t|\tscientific name",
  "131567\t|\tcellular organisms\t|\t\t|\tscientific name",
  "1425170\t|\tHomo heidelbergensis\t|\t\t|\tscientific name"
)
tmpFile&lt;-tempfile()
writeLines(namesText,tmpFile)
taxaNames&lt;-read.names.sql(tmpFile,sqlFile)
nodesText&lt;-c(
 "1\t|\t1\t|\tno rank\t|\t\t|\t8\t|\t0\t|\t1\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
  "2\t|\t131567\t|\tsuperkingdom\t|\t\t|\t0\t|\t0\t|\t11\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
  "6\t|\t335928\t|\tgenus\t|\t\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t0\t|\t0\t|\t\t|",
  "7\t|\t6\t|\tspecies\t|\tAC\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
  "9\t|\t32199\t|\tspecies\t|\tBA\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
  "9606\t|\t9605\t|\tspecies", "9605\t|\t207598\t|\tgenus", "207598\t|\t9604\t|\tsubfamily",
  "9604\t|\t314295\t|\tfamily", "314295\t|\t9526\t|\tsuperfamily",
  "9526\t|\t314293\t|\tparvorder", "314293\t|\t376913\t|\tinfraorder",
  "376913\t|\t9443\t|\tsuborder", "9443\t|\t314146\t|\torder",
  "314146\t|\t1437010\t|\tsuperorder", "1437010\t|\t9347\t|\tno rank",
  "9347\t|\t32525\t|\tno rank", "32525\t|\t40674\t|\tno rank",
  "40674\t|\t32524\t|\tclass", "32524\t|\t32523\t|\tno rank", "32523\t|\t1338369\t|\tno rank",
  "1338369\t|\t8287\t|\tno rank", "8287\t|\t117571\t|\tno rank",
  "117571\t|\t117570\t|\tno rank", "117570\t|\t7776\t|\tno rank",
  "7776\t|\t7742\t|\tno rank", "7742\t|\t89593\t|\tno rank", "89593\t|\t7711\t|\tsubphylum",
  "7711\t|\t33511\t|\tphylum", "33511\t|\t33213\t|\tno rank", "33213\t|\t6072\t|\tno rank",
  "6072\t|\t33208\t|\tno rank", "33208\t|\t33154\t|\tkingdom",
  "33154\t|\t2759\t|\tno rank", "2759\t|\t131567\t|\tsuperkingdom",
  "131567\t|\t1\t|\tno rank", '1425170\t|\t9605\t|\tspecies'
)
writeLines(nodesText,tmpFile)
taxaNodes&lt;-read.nodes.sql(tmpFile,sqlFile)
getDescendants(c(9604),sqlFile)
</code></pre>

<hr>
<h2 id='getId'>Find a given taxa by name</h2><span id='topic+getId'></span>

<h3>Description</h3>

<p>Find a taxa by string in the NCBI taxonomy. Note that NCBI species are stored as Genus species e.g. &quot;Bos taurus&quot;. Ambiguous taxa names will return a comma concatenated string e.g. &quot;123,234&quot; and generate a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getId(taxa, sqlFile = "nameNode.sqlite", onlyScientific = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getId_+3A_taxa">taxa</code></td>
<td>
<p>a vector of taxonomic names</p>
</td></tr>
<tr><td><code id="getId_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path to a SQLite file containing a names tables</p>
</td></tr>
<tr><td><code id="getId_+3A_onlyscientific">onlyScientific</code></td>
<td>
<p>If TRUE then only match to scientific names. If FALSE use all names in database for matching (potentially increasing ambiguous matches).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character strings giving taxa IDs (potentially comma concatenated for any taxa with ambiguous names)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTaxonomy">getTaxonomy</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>, <code><a href="#topic+getCommon">getCommon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesText&lt;-c(
  "1\t|\tall\t|\t\t|\tsynonym\t|",
  "1\t|\troot\t|\t\t|\tscientific name\t|",
  "3\t|\tMulti\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "4\t|\tMulti\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tBacteria\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tMonera\t|\tMonera &lt;Bacteria&gt;\t|\tin-part\t|",
  "2\t|\tProcaryotae\t|\tProcaryotae &lt;Bacteria&gt;\t|\tin-part\t|"
)
tmpFile&lt;-tempfile()
writeLines(namesText,tmpFile)
sqlFile&lt;-tempfile()
read.names.sql(tmpFile,sqlFile)
getId('Bacteria',sqlFile)
getId('Not a real name',sqlFile)
getId('Multi',sqlFile)
</code></pre>

<hr>
<h2 id='getId2'>Find a given taxa by name</h2><span id='topic+getId2'></span>

<h3>Description</h3>

<p>Find a taxa by string in the NCBI taxonomy. Note that NCBI species are stored as Genus species e.g. &quot;Bos taurus&quot;. Ambiguous taxa names will return a comma concatenated string e.g. &quot;123,234&quot; and generate a warning. NOTE: This function is now deprecated for <code><a href="#topic+getId">getId</a></code> (using SQLite rather than data.table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getId2(taxa, taxaNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getId2_+3A_taxa">taxa</code></td>
<td>
<p>a vector of taxonomic names</p>
</td></tr>
<tr><td><code id="getId2_+3A_taxanames">taxaNames</code></td>
<td>
<p>a names data.table from <code><a href="#topic+read.names">read.names</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character strings giving taxa IDs (potentially comma concatenated for any taxa with ambiguous names)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getId">getId</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesText&lt;-c(
  "1\t|\tall\t|\t\t|\tsynonym\t|",
  "1\t|\troot\t|\t\t|\tscientific name\t|",
  "3\t|\tMulti\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "4\t|\tMulti\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tBacteria\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tMonera\t|\tMonera &lt;Bacteria&gt;\t|\tin-part\t|",
  "2\t|\tProcaryotae\t|\tProcaryotae &lt;Bacteria&gt;\t|\tin-part\t|"
)
tmpFile&lt;-tempfile()
writeLines(namesText,tmpFile)
names&lt;-read.names(tmpFile)
getId2('Bacteria',names)
getId2('Not a real name',names)
getId2('Multi',names)
</code></pre>

<hr>
<h2 id='getNamesAndNodes'>Download names and nodes files from NCBI</h2><span id='topic+getNamesAndNodes'></span>

<h3>Description</h3>

<p>Download a taxdump.tar.gz file from NCBI servers and extract the names.dmp and nodes.dmp files from it. These can then be used to create a SQLite database with <code><a href="#topic+read.names.sql">read.names.sql</a></code> and <code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code>. Note that if the files already exist in the target directory then this function will not redownload them. Delete the files if a fresh download is desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNamesAndNodes(
  outDir = ".",
  url = sprintf("%s://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz", protocol),
  fileNames = c("names.dmp", "nodes.dmp"),
  protocol = "ftp",
  resume = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNamesAndNodes_+3A_outdir">outDir</code></td>
<td>
<p>the directory to put names.dmp and nodes.dmp in</p>
</td></tr>
<tr><td><code id="getNamesAndNodes_+3A_url">url</code></td>
<td>
<p>the url where taxdump.tar.gz is located</p>
</td></tr>
<tr><td><code id="getNamesAndNodes_+3A_filenames">fileNames</code></td>
<td>
<p>the filenames desired from the tar.gz file</p>
</td></tr>
<tr><td><code id="getNamesAndNodes_+3A_protocol">protocol</code></td>
<td>
<p>the protocol to be used for downloading. Probably either <code>'http'</code> or <code>'ftp'</code>. Overridden if <code>url</code> is provided directly</p>
</td></tr>
<tr><td><code id="getNamesAndNodes_+3A_resume">resume</code></td>
<td>
<p>if TRUE attempt to resume downloading an interrupted file without starting over from the beginning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of file path strings of the locations of the output files
</p>


<h3>References</h3>

<p><a href="https://ftp.ncbi.nih.gov/pub/taxonomy/">https://ftp.ncbi.nih.gov/pub/taxonomy/</a>, <a href="https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/">https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  getNamesAndNodes()

## End(Not run)
</code></pre>

<hr>
<h2 id='getRawTaxonomy'>Get all taxonomy for a taxa</h2><span id='topic+getRawTaxonomy'></span>

<h3>Description</h3>

<p>Take NCBI taxa IDs and get all taxonomic ranks from name and node SQLite database. Ranks that occur more than once are made unique with a postfix through <code><a href="base.html#topic+make.unique">make.unique</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRawTaxonomy(ids, sqlFile = "nameNode.sqlite")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRawTaxonomy_+3A_ids">ids</code></td>
<td>
<p>a vector of ids to find taxonomy for</p>
</td></tr>
<tr><td><code id="getRawTaxonomy_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path to a SQLite file containing names and nodes tables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of vectors with each element containing a vector of taxonomic strings with names corresponding to the taxonomic rank
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>, <code><a href="#topic+normalizeTaxa">normalizeTaxa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqlFile&lt;-tempfile()
namesText&lt;-c(
  "1\t|\tall\t|\t\t|\tsynonym\t|",
  "1\t|\troot\t|\t\t|\tscientific name\t|",
  "2\t|\tBacteria\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tMonera\t|\tMonera &lt;Bacteria&gt;\t|\tin-part\t|",
  "2\t|\tProcaryotae\t|\tProcaryotae &lt;Bacteria&gt;\t|\tin-part\t|",
  "9606\t|\tHomo sapiens\t|\t\t|\tscientific name",
  "9605\t|\tHomo\t|\t\t|\tscientific name",
  "207598\t|\tHomininae\t|\t\t|\tscientific name",
  "9604\t|\tHominidae\t|\t\t|\tscientific name",
  "314295\t|\tHominoidea\t|\t\t|\tscientific name",
  "9526\t|\tCatarrhini\t|\t\t|\tscientific name",
  "314293\t|\tSimiiformes\t|\t\t|\tscientific name",
  "376913\t|\tHaplorrhini\t|\t\t|\tscientific name",
  "9443\t|\tPrimates\t|\t\t|\tscientific name",
  "314146\t|\tEuarchontoglires\t|\t\t|\tscientific name",
  "1437010\t|\tBoreoeutheria\t|\t\t|\tscientific name",
  "9347\t|\tEutheria\t|\t\t|\tscientific name",
  "32525\t|\tTheria\t|\t\t|\tscientific name",
  "40674\t|\tMammalia\t|\t\t|\tscientific name",
  "32524\t|\tAmniota\t|\t\t|\tscientific name",
  "32523\t|\tTetrapoda\t|\t\t|\tscientific name",
  "1338369\t|\tDipnotetrapodomorpha\t|\t\t|\tscientific name",
  "8287\t|\tSarcopterygii\t|\t\t|\tscientific name",
  "117571\t|\tEuteleostomi\t|\t\t|\tscientific name",
  "117570\t|\tTeleostomi\t|\t\t|\tscientific name",
  "7776\t|\tGnathostomata\t|\t\t|\tscientific name",
  "7742\t|\tVertebrata\t|\t\t|\tscientific name",
  "89593\t|\tCraniata\t|\t\t|\tscientific name",
  "7711\t|\tChordata\t|\t\t|\tscientific name",
  "33511\t|\tDeuterostomia\t|\t\t|\tscientific name",
  "33213\t|\tBilateria\t|\t\t|\tscientific name",
  "6072\t|\tEumetazoa\t|\t\t|\tscientific name",
  "33208\t|\tMetazoa\t|\t\t|\tscientific name",
  "33154\t|\tOpisthokonta\t|\t\t|\tscientific name",
  "2759\t|\tEukaryota\t|\t\t|\tscientific name",
  "131567\t|\tcellular organisms\t|\t\t|\tscientific name"
)
tmpFile&lt;-tempfile()
writeLines(namesText,tmpFile)
taxaNames&lt;-read.names.sql(tmpFile,sqlFile)
nodesText&lt;-c(
 "1\t|\t1\t|\tno rank\t|\t\t|\t8\t|\t0\t|\t1\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
  "2\t|\t131567\t|\tsuperkingdom\t|\t\t|\t0\t|\t0\t|\t11\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
  "6\t|\t335928\t|\tgenus\t|\t\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t0\t|\t0\t|\t\t|",
  "7\t|\t6\t|\tspecies\t|\tAC\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
  "9\t|\t32199\t|\tspecies\t|\tBA\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
  "9606\t|\t9605\t|\tspecies", "9605\t|\t207598\t|\tgenus", "207598\t|\t9604\t|\tsubfamily",
  "9604\t|\t314295\t|\tfamily", "314295\t|\t9526\t|\tsuperfamily",
  "9526\t|\t314293\t|\tparvorder", "314293\t|\t376913\t|\tinfraorder",
  "376913\t|\t9443\t|\tsuborder", "9443\t|\t314146\t|\torder",
  "314146\t|\t1437010\t|\tsuperorder", "1437010\t|\t9347\t|\tno rank",
  "9347\t|\t32525\t|\tno rank", "32525\t|\t40674\t|\tno rank",
  "40674\t|\t32524\t|\tclass", "32524\t|\t32523\t|\tno rank", "32523\t|\t1338369\t|\tno rank",
  "1338369\t|\t8287\t|\tno rank", "8287\t|\t117571\t|\tno rank",
  "117571\t|\t117570\t|\tno rank", "117570\t|\t7776\t|\tno rank",
  "7776\t|\t7742\t|\tno rank", "7742\t|\t89593\t|\tno rank", "89593\t|\t7711\t|\tsubphylum",
  "7711\t|\t33511\t|\tphylum", "33511\t|\t33213\t|\tno rank", "33213\t|\t6072\t|\tno rank",
  "6072\t|\t33208\t|\tno rank", "33208\t|\t33154\t|\tkingdom",
  "33154\t|\t2759\t|\tno rank", "2759\t|\t131567\t|\tsuperkingdom",
  "131567\t|\t1\t|\tno rank"
)
writeLines(nodesText,tmpFile)
taxaNodes&lt;-read.nodes.sql(tmpFile,sqlFile)
getRawTaxonomy(c(9606,9605),sqlFile)
</code></pre>

<hr>
<h2 id='getTaxonomy'>Get taxonomic ranks for a taxa</h2><span id='topic+getTaxonomy'></span>

<h3>Description</h3>

<p>Take NCBI taxa IDs and get the corresponding taxa ranks from a name and node SQLite database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTaxonomy(
  ids,
  sqlFile = "nameNode.sqlite",
  ...,
  desiredTaxa = c("superkingdom", "phylum", "class", "order", "family", "genus",
    "species")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTaxonomy_+3A_ids">ids</code></td>
<td>
<p>a vector of ids to find taxonomy for</p>
</td></tr>
<tr><td><code id="getTaxonomy_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path to a SQLite file containing names and nodes tables</p>
</td></tr>
<tr><td><code id="getTaxonomy_+3A_...">...</code></td>
<td>
<p>legacy additional arguments to original data.table based getTaxonomy function. Used only for support for deprecated function, do not use in new code.</p>
</td></tr>
<tr><td><code id="getTaxonomy_+3A_desiredtaxa">desiredTaxa</code></td>
<td>
<p>a vector of strings giving the desired taxa levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of taxonomic strings with a row for each id and a column for each desiredTaxa rank
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqlFile&lt;-tempfile()
namesText&lt;-c(
  "1\t|\tall\t|\t\t|\tsynonym\t|",
  "1\t|\troot\t|\t\t|\tscientific name\t|",
  "2\t|\tBacteria\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tMonera\t|\tMonera &lt;Bacteria&gt;\t|\tin-part\t|",
  "2\t|\tProcaryotae\t|\tProcaryotae &lt;Bacteria&gt;\t|\tin-part\t|",
  "9606\t|\tHomo sapiens\t|\t\t|\tscientific name",
  "9605\t|\tHomo\t|\t\t|\tscientific name",
  "207598\t|\tHomininae\t|\t\t|\tscientific name",
  "9604\t|\tHominidae\t|\t\t|\tscientific name",
  "314295\t|\tHominoidea\t|\t\t|\tscientific name",
  "9526\t|\tCatarrhini\t|\t\t|\tscientific name",
  "314293\t|\tSimiiformes\t|\t\t|\tscientific name",
  "376913\t|\tHaplorrhini\t|\t\t|\tscientific name",
  "9443\t|\tPrimates\t|\t\t|\tscientific name",
  "314146\t|\tEuarchontoglires\t|\t\t|\tscientific name",
  "1437010\t|\tBoreoeutheria\t|\t\t|\tscientific name",
  "9347\t|\tEutheria\t|\t\t|\tscientific name",
  "32525\t|\tTheria\t|\t\t|\tscientific name",
  "40674\t|\tMammalia\t|\t\t|\tscientific name",
  "32524\t|\tAmniota\t|\t\t|\tscientific name",
  "32523\t|\tTetrapoda\t|\t\t|\tscientific name",
  "1338369\t|\tDipnotetrapodomorpha\t|\t\t|\tscientific name",
  "8287\t|\tSarcopterygii\t|\t\t|\tscientific name",
  "117571\t|\tEuteleostomi\t|\t\t|\tscientific name",
  "117570\t|\tTeleostomi\t|\t\t|\tscientific name",
  "7776\t|\tGnathostomata\t|\t\t|\tscientific name",
  "7742\t|\tVertebrata\t|\t\t|\tscientific name",
  "89593\t|\tCraniata\t|\t\t|\tscientific name",
  "7711\t|\tChordata\t|\t\t|\tscientific name",
  "33511\t|\tDeuterostomia\t|\t\t|\tscientific name",
  "33213\t|\tBilateria\t|\t\t|\tscientific name",
  "6072\t|\tEumetazoa\t|\t\t|\tscientific name",
  "33208\t|\tMetazoa\t|\t\t|\tscientific name",
  "33154\t|\tOpisthokonta\t|\t\t|\tscientific name",
  "2759\t|\tEukaryota\t|\t\t|\tscientific name",
  "131567\t|\tcellular organisms\t|\t\t|\tscientific name"
)
tmpFile&lt;-tempfile()
writeLines(namesText,tmpFile)
taxaNames&lt;-read.names.sql(tmpFile,sqlFile)
nodesText&lt;-c(
 "1\t|\t1\t|\tno rank\t|\t\t|\t8\t|\t0\t|\t1\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
  "2\t|\t131567\t|\tsuperkingdom\t|\t\t|\t0\t|\t0\t|\t11\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
  "6\t|\t335928\t|\tgenus\t|\t\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t0\t|\t0\t|\t\t|",
  "7\t|\t6\t|\tspecies\t|\tAC\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
  "9\t|\t32199\t|\tspecies\t|\tBA\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
  "9606\t|\t9605\t|\tspecies", "9605\t|\t207598\t|\tgenus", "207598\t|\t9604\t|\tsubfamily",
  "9604\t|\t314295\t|\tfamily", "314295\t|\t9526\t|\tsuperfamily",
  "9526\t|\t314293\t|\tparvorder", "314293\t|\t376913\t|\tinfraorder",
  "376913\t|\t9443\t|\tsuborder", "9443\t|\t314146\t|\torder",
  "314146\t|\t1437010\t|\tsuperorder", "1437010\t|\t9347\t|\tno rank",
  "9347\t|\t32525\t|\tno rank", "32525\t|\t40674\t|\tno rank",
  "40674\t|\t32524\t|\tclass", "32524\t|\t32523\t|\tno rank", "32523\t|\t1338369\t|\tno rank",
  "1338369\t|\t8287\t|\tno rank", "8287\t|\t117571\t|\tno rank",
  "117571\t|\t117570\t|\tno rank", "117570\t|\t7776\t|\tno rank",
  "7776\t|\t7742\t|\tno rank", "7742\t|\t89593\t|\tno rank", "89593\t|\t7711\t|\tsubphylum",
  "7711\t|\t33511\t|\tphylum", "33511\t|\t33213\t|\tno rank", "33213\t|\t6072\t|\tno rank",
  "6072\t|\t33208\t|\tno rank", "33208\t|\t33154\t|\tkingdom",
  "33154\t|\t2759\t|\tno rank", "2759\t|\t131567\t|\tsuperkingdom",
  "131567\t|\t1\t|\tno rank"
)
writeLines(nodesText,tmpFile)
taxaNodes&lt;-read.nodes.sql(tmpFile,sqlFile)
getTaxonomy(c(9606,9605),sqlFile)
</code></pre>

<hr>
<h2 id='getTaxonomy2'>Get taxonomic ranks for a taxa</h2><span id='topic+getTaxonomy2'></span>

<h3>Description</h3>

<p>Take NCBI taxa IDs and get the corresponding taxa ranks from name and node data.tables. NOTE: This function is now deprecated for <code><a href="#topic+getTaxonomy">getTaxonomy</a></code> (using SQLite rather than data.table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTaxonomy2(
  ids,
  taxaNodes,
  taxaNames,
  desiredTaxa = c("superkingdom", "phylum", "class", "order", "family", "genus",
    "species"),
  mc.cores = 1,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTaxonomy2_+3A_ids">ids</code></td>
<td>
<p>a vector of ids to find taxonomy for</p>
</td></tr>
<tr><td><code id="getTaxonomy2_+3A_taxanodes">taxaNodes</code></td>
<td>
<p>a nodes data.table from <code><a href="#topic+read.nodes">read.nodes</a></code></p>
</td></tr>
<tr><td><code id="getTaxonomy2_+3A_taxanames">taxaNames</code></td>
<td>
<p>a names data.table from <code><a href="#topic+read.names">read.names</a></code></p>
</td></tr>
<tr><td><code id="getTaxonomy2_+3A_desiredtaxa">desiredTaxa</code></td>
<td>
<p>a vector of strings giving the desired taxa levels</p>
</td></tr>
<tr><td><code id="getTaxonomy2_+3A_mc.cores">mc.cores</code></td>
<td>
<p>DEPRECATED the number of cores to use when processing. Note this option is now deprecated and has no effect. Please switch to <code><a href="#topic+getTaxonomy">getTaxonomy</a></code> (see <a href="#topic+taxonomizrSwitch">taxonomizrSwitch</a>) for much faster processing without requiring multiple cores.</p>
</td></tr>
<tr><td><code id="getTaxonomy2_+3A_debug">debug</code></td>
<td>
<p>if TRUE output node and name vectors with dput for each id (probably useful only for development)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of taxonomic strings with a row for each id and a column for each desiredTaxa rank
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nodes">read.nodes</a></code>, <code><a href="#topic+read.names">read.names</a></code>, <code><a href="#topic+getTaxonomy">getTaxonomy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesText&lt;-c(
  "1\t|\tall\t|\t\t|\tsynonym\t|",
  "1\t|\troot\t|\t\t|\tscientific name\t|",
  "2\t|\tBacteria\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tMonera\t|\tMonera &lt;Bacteria&gt;\t|\tin-part\t|",
  "2\t|\tProcaryotae\t|\tProcaryotae &lt;Bacteria&gt;\t|\tin-part\t|",
  "9606\t|\tHomo sapiens\t|\t\t|\tscientific name",
  "9605\t|\tHomo\t|\t\t|\tscientific name",
  "207598\t|\tHomininae\t|\t\t|\tscientific name",
  "9604\t|\tHominidae\t|\t\t|\tscientific name",
  "314295\t|\tHominoidea\t|\t\t|\tscientific name",
  "9526\t|\tCatarrhini\t|\t\t|\tscientific name",
  "314293\t|\tSimiiformes\t|\t\t|\tscientific name",
  "376913\t|\tHaplorrhini\t|\t\t|\tscientific name",
  "9443\t|\tPrimates\t|\t\t|\tscientific name",
  "314146\t|\tEuarchontoglires\t|\t\t|\tscientific name",
  "1437010\t|\tBoreoeutheria\t|\t\t|\tscientific name",
  "9347\t|\tEutheria\t|\t\t|\tscientific name",
  "32525\t|\tTheria\t|\t\t|\tscientific name",
  "40674\t|\tMammalia\t|\t\t|\tscientific name",
  "32524\t|\tAmniota\t|\t\t|\tscientific name",
  "32523\t|\tTetrapoda\t|\t\t|\tscientific name",
  "1338369\t|\tDipnotetrapodomorpha\t|\t\t|\tscientific name",
  "8287\t|\tSarcopterygii\t|\t\t|\tscientific name",
  "117571\t|\tEuteleostomi\t|\t\t|\tscientific name",
  "117570\t|\tTeleostomi\t|\t\t|\tscientific name",
  "7776\t|\tGnathostomata\t|\t\t|\tscientific name",
  "7742\t|\tVertebrata\t|\t\t|\tscientific name",
  "89593\t|\tCraniata\t|\t\t|\tscientific name",
  "7711\t|\tChordata\t|\t\t|\tscientific name",
  "33511\t|\tDeuterostomia\t|\t\t|\tscientific name",
  "33213\t|\tBilateria\t|\t\t|\tscientific name",
  "6072\t|\tEumetazoa\t|\t\t|\tscientific name",
  "33208\t|\tMetazoa\t|\t\t|\tscientific name",
  "33154\t|\tOpisthokonta\t|\t\t|\tscientific name",
  "2759\t|\tEukaryota\t|\t\t|\tscientific name",
  "131567\t|\tcellular organisms\t|\t\t|\tscientific name"
)
tmpFile&lt;-tempfile()
writeLines(namesText,tmpFile)
taxaNames&lt;-read.names(tmpFile)
nodesText&lt;-c(
 "1\t|\t1\t|\tno rank\t|\t\t|\t8\t|\t0\t|\t1\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
  "2\t|\t131567\t|\tsuperkingdom\t|\t\t|\t0\t|\t0\t|\t11\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
  "6\t|\t335928\t|\tgenus\t|\t\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t0\t|\t0\t|\t\t|",
  "7\t|\t6\t|\tspecies\t|\tAC\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
  "9\t|\t32199\t|\tspecies\t|\tBA\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
  "9606\t|\t9605\t|\tspecies", "9605\t|\t207598\t|\tgenus", "207598\t|\t9604\t|\tsubfamily",
  "9604\t|\t314295\t|\tfamily", "314295\t|\t9526\t|\tsuperfamily",
  "9526\t|\t314293\t|\tparvorder", "314293\t|\t376913\t|\tinfraorder",
  "376913\t|\t9443\t|\tsuborder", "9443\t|\t314146\t|\torder",
  "314146\t|\t1437010\t|\tsuperorder", "1437010\t|\t9347\t|\tno rank",
  "9347\t|\t32525\t|\tno rank", "32525\t|\t40674\t|\tno rank",
  "40674\t|\t32524\t|\tclass", "32524\t|\t32523\t|\tno rank", "32523\t|\t1338369\t|\tno rank",
  "1338369\t|\t8287\t|\tno rank", "8287\t|\t117571\t|\tno rank",
  "117571\t|\t117570\t|\tno rank", "117570\t|\t7776\t|\tno rank",
  "7776\t|\t7742\t|\tno rank", "7742\t|\t89593\t|\tno rank", "89593\t|\t7711\t|\tsubphylum",
  "7711\t|\t33511\t|\tphylum", "33511\t|\t33213\t|\tno rank", "33213\t|\t6072\t|\tno rank",
  "6072\t|\t33208\t|\tno rank", "33208\t|\t33154\t|\tkingdom",
  "33154\t|\t2759\t|\tno rank", "2759\t|\t131567\t|\tsuperkingdom",
  "131567\t|\t1\t|\tno rank"
)
writeLines(nodesText,tmpFile)
taxaNodes&lt;-read.nodes(tmpFile)
getTaxonomy2(c(9606,9605),taxaNodes,taxaNames,mc.cores=1)
</code></pre>

<hr>
<h2 id='lastNotNa'>Return last not NA value</h2><span id='topic+lastNotNa'></span>

<h3>Description</h3>

<p>A convenience function to return the last value which is not NA in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lastNotNa(x, default = "Unknown")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lastNotNa_+3A_x">x</code></td>
<td>
<p>a vector to look for the last value in</p>
</td></tr>
<tr><td><code id="lastNotNa_+3A_default">default</code></td>
<td>
<p>a default value to use when all values are NA in a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single element from the last non NA value in x (or the default)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lastNotNa(c(1:4,NA,NA))
lastNotNa(c(letters[1:4],NA,'z',NA))
lastNotNa(c(NA,NA))
</code></pre>

<hr>
<h2 id='makeNewick'>Create a Newick tree from taxonomy</h2><span id='topic+makeNewick'></span>

<h3>Description</h3>

<p>Create a Newick formatted tree from a data.frame of taxonomic assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeNewick(
  taxa,
  naSub = "_",
  excludeTerminalNAs = FALSE,
  quote = NULL,
  terminator = ";"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeNewick_+3A_taxa">taxa</code></td>
<td>
<p>a matrix with a row for each leaf of the tree and a column for each taxonomic classification e.g. the output from getTaxonomy</p>
</td></tr>
<tr><td><code id="makeNewick_+3A_nasub">naSub</code></td>
<td>
<p>a character string to substitute in place of NAs in the taxonomy</p>
</td></tr>
<tr><td><code id="makeNewick_+3A_excludeterminalnas">excludeTerminalNAs</code></td>
<td>
<p>If TRUE then do not output nodes downstream of the last named taxonomic level in a row</p>
</td></tr>
<tr><td><code id="makeNewick_+3A_quote">quote</code></td>
<td>
<p>If not NULL then wrap all entries with this character</p>
</td></tr>
<tr><td><code id="makeNewick_+3A_terminator">terminator</code></td>
<td>
<p>If not NULL then add this character to the end of the tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string giving a Newick formatted tree
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTaxonomy">getTaxonomy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>taxa&lt;-matrix(c('A','A','A','B','B','C','D','D','E','F','G','H'),nrow=3)
makeNewick(taxa)
taxa&lt;-matrix(c('A','A','A','B',NA,'C','D','D',NA,'F','G',NA),nrow=3)
makeNewick(taxa)
makeNewick(taxa,excludeTerminalNAs=TRUE)
makeNewick(taxa,quote="'")
</code></pre>

<hr>
<h2 id='normalizeTaxa'>Bring multiple raw taxonomies into alignment</h2><span id='topic+normalizeTaxa'></span>

<h3>Description</h3>

<p>Combine the raw taxonomy of several taxa into a single matrix where each row corresponds to a taxa and each column a taxonomic level. Named taxonomic levels are aligned between taxa then any unspecified clades are combined between the named levels. Taxonomic levels between named levels are arbitrarily combined from most generic to most specific. Working from the data provided in the NCBI taxonomy results in ambiguities so results should be used with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeTaxa(
  rawTaxa,
  cladeRegex = "^clade$|^clade\\.[0-9]+$|^$|no rank",
  rootFill = "_ROOT_",
  lineageOrder = c()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeTaxa_+3A_rawtaxa">rawTaxa</code></td>
<td>
<p>A list of vectors with each vector containing a named character vector with entries specifying taxonomy for a clade and names giving the corresponding taxonomic levels e.g. the output from <code><a href="#topic+getRawTaxonomy">getRawTaxonomy</a></code></p>
</td></tr>
<tr><td><code id="normalizeTaxa_+3A_claderegex">cladeRegex</code></td>
<td>
<p>A regex to identify ambiguous taxonomic levels. In the case of NCBI taxonomy, these unidentified levels are all labelled &quot;clade&quot; and <code><a href="#topic+getRawTaxonomy">getRawTaxonomy</a></code> may attach a unique digit attach to the end for uniqueness.</p>
</td></tr>
<tr><td><code id="normalizeTaxa_+3A_rootfill">rootFill</code></td>
<td>
<p>If a clade is upstream of the highest taxonomic level then it will be labeled with this prefix</p>
</td></tr>
<tr><td><code id="normalizeTaxa_+3A_lineageorder">lineageOrder</code></td>
<td>
<p>A vector giving an ordering for lineages from most specific to most generic. This should be unnecessary unless the taxonomy contains ambiguities e.g. one taxa goes from species to kingdom while another goes from genus to kingdom leaving it ambiguous whether genus or species is more specific</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with a row for each taxa and a column for each taxonomic level
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRawTaxonomy">getRawTaxonomy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rawTaxa&lt;-list(
   '81907' = c(species = "Alectura lathami", genus = "Alectura",
     family = "Megapodiidae", order = "Galliformes", superorder = "Galloanserae",
     infraclass = "Neognathae", class = "Aves", clade = "Coelurosauria",
     clade.1 = "Theropoda", clade.2 = "Saurischia", clade.3 = "Dinosauria",
     clade.4 = "Archosauria", clade.5 = "Archelosauria", clade.6 = "Sauria",
     clade.7 = "Sauropsida", clade.8 = "Amniota", clade.9 = "Tetrapoda",
     clade.10 = "Dipnotetrapodomorpha", superclass = "Sarcopterygii",
     clade.11 = "Euteleostomi", clade.12 = "Teleostomi", clade.13 = "Gnathostomata",
     clade.14 = "Vertebrata", subphylum = "Craniata", phylum = "Chordata",
     clade.15 = "Deuterostomia", clade.16 = "Bilateria", clade.17 = "Eumetazoa",
     kingdom = "Metazoa", clade.18 = "Opisthokonta", superkingdom = "Eukaryota",
     'no rank' = "cellular organisms"),
   '8496' = c(species = "Alligator mississippiensis",
     genus = "Alligator", subfamily = "Alligatorinae", family = "Alligatoridae",
     order = "Crocodylia", clade = "Archosauria", clade.1 = "Archelosauria",
     clade.2 = "Sauria", clade.3 = "Sauropsida", clade.4 = "Amniota",
     clade.5 = "Tetrapoda", clade.6 = "Dipnotetrapodomorpha", superclass = "Sarcopterygii",
     clade.7 = "Euteleostomi", clade.8 = "Teleostomi", clade.9 = "Gnathostomata",
     clade.10 = "Vertebrata", subphylum = "Craniata", phylum = "Chordata",
     clade.11 = "Deuterostomia", clade.12 = "Bilateria", clade.13 = "Eumetazoa",
     kingdom = "Metazoa", clade.14 = "Opisthokonta", superkingdom = "Eukaryota",
     'no rank' = "cellular organisms"),
   '38654' = c(species = "Alligator sinensis",
     genus = "Alligator", subfamily = "Alligatorinae", family = "Alligatoridae",
     order = "Crocodylia", clade = "Archosauria", clade.1 = "Archelosauria",
     clade.2 = "Sauria", clade.3 = "Sauropsida", clade.4 = "Amniota",
     clade.5 = "Tetrapoda", clade.6 = "Dipnotetrapodomorpha", superclass = "Sarcopterygii",
     clade.7 = "Euteleostomi", clade.8 = "Teleostomi", clade.9 = "Gnathostomata",
     clade.10 = "Vertebrata", subphylum = "Craniata", phylum = "Chordata",
     clade.11 = "Deuterostomia", clade.12 = "Bilateria", clade.13 = "Eumetazoa",
     kingdom = "Metazoa", clade.14 = "Opisthokonta", superkingdom = "Eukaryota",
     'no rank' = "cellular organisms")
)
normalizeTaxa(rawTaxa)
</code></pre>

<hr>
<h2 id='prepareDatabase'>Download data from NCBI and set up SQLite database</h2><span id='topic+prepareDatabase'></span>

<h3>Description</h3>

<p>Convenience function to do all necessary preparations downloading names, nodes and accession2taxid data from NCBI and preprocessing into a SQLite database for downstream use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareDatabase(
  sqlFile = "nameNode.sqlite",
  tmpDir = ".",
  getAccessions = TRUE,
  vocal = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareDatabase_+3A_sqlfile">sqlFile</code></td>
<td>
<p>character string giving the file location to store the SQLite database</p>
</td></tr>
<tr><td><code id="prepareDatabase_+3A_tmpdir">tmpDir</code></td>
<td>
<p>location for storing the downloaded files from NCBI. (Note that it may be useful to store these somewhere convenient to avoid redownloading)</p>
</td></tr>
<tr><td><code id="prepareDatabase_+3A_getaccessions">getAccessions</code></td>
<td>
<p>if TRUE download the very large accesssion2taxid files necessary to convert accessions to taxonomic IDs</p>
</td></tr>
<tr><td><code id="prepareDatabase_+3A_vocal">vocal</code></td>
<td>
<p>if TRUE output messages describing progress</p>
</td></tr>
<tr><td><code id="prepareDatabase_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+getNamesAndNodes">getNamesAndNodes</a></code>, <code><a href="#topic+getAccession2taxid">getAccession2taxid</a></code>, <code><a href="#topic+read.accession2taxid">read.accession2taxid</a></code>
</p>

<dl>
<dt><code>url</code></dt><dd><p>the url where taxdump.tar.gz is located</p>
</dd>
<dt><code>fileNames</code></dt><dd><p>the filenames desired from the tar.gz file</p>
</dd>
<dt><code>protocol</code></dt><dd><p>the protocol to be used for downloading. Probably either <code>'http'</code> or <code>'ftp'</code>. Overridden if <code>url</code> is provided directly</p>
</dd>
<dt><code>resume</code></dt><dd><p>if TRUE attempt to resume downloading an interrupted file without starting over from the beginning</p>
</dd>
<dt><code>baseUrl</code></dt><dd><p>the url of the directory where accession2taxid.gz files are located</p>
</dd>
<dt><code>types</code></dt><dd><p>the types if accession2taxid.gz files desired where type is the prefix of xxx.accession2taxid.gz. The default is to download all nucl_ accessions. For protein accessions, try <code>types=c('prot')</code>.</p>
</dd>
<dt><code>extraSqlCommand</code></dt><dd><p>for advanced use. A string giving a command to be called on the SQLite database before loading data. A couple potential uses: 
</p>
<ul>
<li><p> &quot;PRAGMA temp_store_directory = '/MY/TMP/DIR'&quot; to store SQLite temporary files in directory /MY/TMP/DIR. Useful if the temporary directory used by SQLite (which is not necessarily in the same location as R's) is small on your system </p>
</li>
<li><p> &quot;pragma temp_store = 2;&quot; to keep all SQLite temp files in memory. Don't do this unless you have a lot (&gt;100 Gb) of RAM</p>
</li></ul>
</dd>
<dt><code>indexTaxa</code></dt><dd><p>if TRUE add an index for taxa ID. This would only be necessary if you want to look up accessions by taxa ID e.g. <code><a href="#topic+getAccessions">getAccessions</a></code></p>
</dd>
<dt><code>overwrite</code></dt><dd><p>If TRUE, delete accessionTaxa table in database if present and regenerate</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character string giving the path to the SQLite file
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getNamesAndNodes">getNamesAndNodes</a></code>, <code><a href="#topic+getAccession2taxid">getAccession2taxid</a></code>, <code><a href="#topic+read.accession2taxid">read.accession2taxid</a></code>, <code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  if(readline(
    "This will download a lot data and take a while to process.
     Make sure you have space and bandwidth. Type y to continue: "
  )!='y')
    stop('This is a stop to make sure no one downloads a bunch of data unintentionally')

  prepareDatabase()

## End(Not run)
</code></pre>

<hr>
<h2 id='read.accession2taxid'>Read NCBI accession2taxid files</h2><span id='topic+read.accession2taxid'></span>

<h3>Description</h3>

<p>Take NCBI accession2taxid files, keep only accession and taxa and save it as a SQLite database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.accession2taxid(
  taxaFiles,
  sqlFile,
  vocal = TRUE,
  extraSqlCommand = "",
  indexTaxa = FALSE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.accession2taxid_+3A_taxafiles">taxaFiles</code></td>
<td>
<p>a string or vector of strings giving the path(s) to files to be read in</p>
</td></tr>
<tr><td><code id="read.accession2taxid_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path where the output SQLite file should be saved</p>
</td></tr>
<tr><td><code id="read.accession2taxid_+3A_vocal">vocal</code></td>
<td>
<p>if TRUE output status messages</p>
</td></tr>
<tr><td><code id="read.accession2taxid_+3A_extrasqlcommand">extraSqlCommand</code></td>
<td>
<p>for advanced use. A string giving a command to be called on the SQLite database before loading data. A couple potential uses: 
</p>
<ul>
<li><p> &quot;PRAGMA temp_store_directory = '/MY/TMP/DIR'&quot; to store SQLite temporary files in directory /MY/TMP/DIR. Useful if the temporary directory used by SQLite (which is not necessarily in the same location as R's) is small on your system </p>
</li>
<li><p> &quot;pragma temp_store = 2;&quot; to keep all SQLite temp files in memory. Don't do this unless you have a lot (&gt;100 Gb) of RAM</p>
</li></ul>
</td></tr>
<tr><td><code id="read.accession2taxid_+3A_indextaxa">indexTaxa</code></td>
<td>
<p>if TRUE add an index for taxa ID. This would only be necessary if you want to look up accessions by taxa ID e.g. <code><a href="#topic+getAccessions">getAccessions</a></code></p>
</td></tr>
<tr><td><code id="read.accession2taxid_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE, delete accessionTaxa table in database if present and regenerate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if sucessful
</p>


<h3>References</h3>

<p><a href="https://ftp.ncbi.nih.gov/pub/taxonomy/accession2taxid/">https://ftp.ncbi.nih.gov/pub/taxonomy/accession2taxid/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>taxa&lt;-c(
  "accession\taccession.version\ttaxid\tgi",
  "Z17427\tZ17427.1\t3702\t16569",
  "Z17428\tZ17428.1\t3702\t16570",
  "Z17429\tZ17429.1\t3702\t16571",
  "Z17430\tZ17430.1\t3702\t16572"
)
inFile&lt;-tempfile()
sqlFile&lt;-tempfile()
writeLines(taxa,inFile)
read.accession2taxid(inFile,sqlFile,vocal=FALSE)
db&lt;-RSQLite::dbConnect(RSQLite::SQLite(),dbname=sqlFile)
RSQLite::dbGetQuery(db,'SELECT * FROM accessionTaxa')
RSQLite::dbDisconnect(db)
</code></pre>

<hr>
<h2 id='read.names'>Read NCBI names file</h2><span id='topic+read.names'></span>

<h3>Description</h3>

<p>Take an NCBI names file, keep only scientific names and convert it to a data.table. NOTE: This function is now deprecated for <code><a href="#topic+read.names.sql">read.names.sql</a></code> (using SQLite rather than data.table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.names(nameFile, onlyScientific = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.names_+3A_namefile">nameFile</code></td>
<td>
<p>string giving the path to an NCBI name file to read from (both gzipped or uncompressed files are ok)</p>
</td></tr>
<tr><td><code id="read.names_+3A_onlyscientific">onlyScientific</code></td>
<td>
<p>If TRUE, only store scientific names. If FALSE, synonyms and other types are included (increasing the potential for ambiguous taxonomic assignments).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with columns id and name with a key on id
</p>


<h3>References</h3>

<p><a href="https://ftp.ncbi.nih.gov/pub/taxonomy/">https://ftp.ncbi.nih.gov/pub/taxonomy/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nodes">read.nodes</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesText&lt;-c(
  "1\t|\tall\t|\t\t|\tsynonym\t|",
  "1\t|\troot\t|\t\t|\tscientific name\t|",
  "2\t|\tBacteria\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tMonera\t|\tMonera &lt;Bacteria&gt;\t|\tin-part\t|",
  "2\t|\tProcaryotae\t|\tProcaryotae &lt;Bacteria&gt;\t|\tin-part\t|"
)
tmpFile&lt;-tempfile()
writeLines(namesText,tmpFile)
read.names(tmpFile)
</code></pre>

<hr>
<h2 id='read.names.sql'>Read NCBI names file</h2><span id='topic+read.names.sql'></span>

<h3>Description</h3>

<p>Take an NCBI names file, keep only scientific names and convert it to a SQLite table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.names.sql(nameFile, sqlFile = "nameNode.sqlite", overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.names.sql_+3A_namefile">nameFile</code></td>
<td>
<p>string giving the path to an NCBI name file to read from (both gzipped or uncompressed files are ok)</p>
</td></tr>
<tr><td><code id="read.names.sql_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path where the output SQLite file should be saved</p>
</td></tr>
<tr><td><code id="read.names.sql_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE, delete names table in database if present and regenerate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns a string with path to sqlfile
</p>


<h3>References</h3>

<p><a href="https://ftp.ncbi.nih.gov/pub/taxonomy/">https://ftp.ncbi.nih.gov/pub/taxonomy/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nodes">read.nodes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesText&lt;-c(
  "1\t|\tall\t|\t\t|\tsynonym\t|",
  "1\t|\troot\t|\t\t|\tscientific name\t|",
  "2\t|\tBacteria\t|\tBacteria &lt;prokaryotes&gt;\t|\tscientific name\t|",
  "2\t|\tMonera\t|\tMonera &lt;Bacteria&gt;\t|\tin-part\t|",
  "2\t|\tProcaryotae\t|\tProcaryotae &lt;Bacteria&gt;\t|\tin-part\t|"
)
tmpFile&lt;-tempfile()
writeLines(namesText,tmpFile)
sqlFile&lt;-tempfile()
read.names.sql(tmpFile,sqlFile)
</code></pre>

<hr>
<h2 id='read.nodes'>Read NCBI nodes file</h2><span id='topic+read.nodes'></span>

<h3>Description</h3>

<p>Take an NCBI nodes file and convert it to a data.table. NOTE: This function is now deprecated for <code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code> (using SQLite rather than data.table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nodes(nodeFile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nodes_+3A_nodefile">nodeFile</code></td>
<td>
<p>string giving the path to an NCBI node file to read from (both gzipped or uncompressed files are ok)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with columns id, parent and rank with a key on id
</p>


<h3>References</h3>

<p><a href="https://ftp.ncbi.nih.gov/pub/taxonomy/">https://ftp.ncbi.nih.gov/pub/taxonomy/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.names">read.names</a></code>, <code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes&lt;-c(
 "1\t|\t1\t|\tno rank\t|\t\t|\t8\t|\t0\t|\t1\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
 "2\t|\t131567\t|\tsuperkingdom\t|\t\t|\t0\t|\t0\t|\t11\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
 "6\t|\t335928\t|\tgenus\t|\t\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t0\t|\t0\t|\t\t|",
 "7\t|\t6\t|\tspecies\t|\tAC\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
 "9\t|\t32199\t|\tspecies\t|\tBA\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|"
)
tmpFile&lt;-tempfile()
writeLines(nodes,tmpFile)
read.nodes(tmpFile)
</code></pre>

<hr>
<h2 id='read.nodes.sql'>Read NCBI nodes file</h2><span id='topic+read.nodes.sql'></span>

<h3>Description</h3>

<p>Take an NCBI nodes file and convert it to a data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nodes.sql(nodeFile, sqlFile = "nameNode.sqlite", overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nodes.sql_+3A_nodefile">nodeFile</code></td>
<td>
<p>string giving the path to an NCBI node file to read from (both gzipped or uncompressed files are ok)</p>
</td></tr>
<tr><td><code id="read.nodes.sql_+3A_sqlfile">sqlFile</code></td>
<td>
<p>a string giving the path where the output SQLite file should be saved</p>
</td></tr>
<tr><td><code id="read.nodes.sql_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE, delete nodes table in database if present and regenerate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with columns id, parent and rank with a key on id
</p>


<h3>References</h3>

<p><a href="https://ftp.ncbi.nih.gov/pub/taxonomy/">https://ftp.ncbi.nih.gov/pub/taxonomy/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.names.sql">read.names.sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes&lt;-c(
 "1\t|\t1\t|\tno rank\t|\t\t|\t8\t|\t0\t|\t1\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
 "2\t|\t131567\t|\tsuperkingdom\t|\t\t|\t0\t|\t0\t|\t11\t|\t0\t|\t0\t|\t0\t|\t0\t|\t0\t|\t\t|",
 "6\t|\t335928\t|\tgenus\t|\t\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t0\t|\t0\t|\t\t|",
 "7\t|\t6\t|\tspecies\t|\tAC\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|",
 "9\t|\t32199\t|\tspecies\t|\tBA\t|\t0\t|\t1\t|\t11\t|\t1\t|\t0\t|\t1\t|\t1\t|\t0\t|\t\t|"
)
tmpFile&lt;-tempfile()
sqlFile&lt;-tempfile()
writeLines(nodes,tmpFile)
read.nodes.sql(tmpFile,sqlFile)
</code></pre>

<hr>
<h2 id='resumableDownload'>Download file using curl allowing resumption of interrupted files</h2><span id='topic+resumableDownload'></span>

<h3>Description</h3>

<p>A helper function that uses the <code>curl</code> package's <code>multi_download</code> to download a file using a temporary file to store progress and resume downloading on interruption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resumableDownload(
  url,
  outFile = basename(url),
  tmpFile = sprintf("%s.__TMP__", outFile),
  quiet = FALSE,
  resume = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resumableDownload_+3A_url">url</code></td>
<td>
<p>The address to download from</p>
</td></tr>
<tr><td><code id="resumableDownload_+3A_outfile">outFile</code></td>
<td>
<p>The file location to store final download at</p>
</td></tr>
<tr><td><code id="resumableDownload_+3A_tmpfile">tmpFile</code></td>
<td>
<p>The file location to store the intermediate download at</p>
</td></tr>
<tr><td><code id="resumableDownload_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE show the progress reported by <code>multi_download</code></p>
</td></tr>
<tr><td><code id="resumableDownload_+3A_resume">resume</code></td>
<td>
<p>If TRUE try to resume interrupted downloads using intermediate file <code>tmpFile</code>. Otherwise delete <code>tempFile</code> on error</p>
</td></tr>
<tr><td><code id="resumableDownload_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>multi_download</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly return the output from multi_download
</p>


<h3>See Also</h3>

<p><code><a href="curl.html#topic+multi_download">multi_download</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  url&lt;-'https://ftp.ncbi.nih.gov/pub/taxonomy/accession2taxid/prot.accession2taxid.FULL.1.gz'
  resumableDownload(url,'downloadedFile.gz')

## End(Not run)
</code></pre>

<hr>
<h2 id='streamingRead'>Process a large file piecewise</h2><span id='topic+streamingRead'></span>

<h3>Description</h3>

<p>A convenience function to read in a large file piece by piece, process it (hopefully reducing the size either by summarizing or removing extra rows or columns) and return the output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streamingRead(
  bigFile,
  n = 1e+06,
  FUN = function(xx) sub(",.*", "", xx),
  ...,
  vocal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streamingRead_+3A_bigfile">bigFile</code></td>
<td>
<p>a string giving the path to a file to be read in or a connection opened with &quot;r&quot; mode</p>
</td></tr>
<tr><td><code id="streamingRead_+3A_n">n</code></td>
<td>
<p>number of lines to read per chunk</p>
</td></tr>
<tr><td><code id="streamingRead_+3A_fun">FUN</code></td>
<td>
<p>a function taking the unparsed lines from a chunk of the bigfile as a single argument and returning the desired output</p>
</td></tr>
<tr><td><code id="streamingRead_+3A_...">...</code></td>
<td>
<p>any additional arguments to FUN</p>
</td></tr>
<tr><td><code id="streamingRead_+3A_vocal">vocal</code></td>
<td>
<p>if TRUE cat a &quot;.&quot; as each chunk is processed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the results from applying func to the multiple chunks of the file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmpFile&lt;-tempfile()
writeLines(LETTERS,tmpFile)
streamingRead(tmpFile,10,head,1)
writeLines(letters,tmpFile)
streamingRead(tmpFile,2,paste,collapse='',vocal=TRUE)
unlist(streamingRead(tmpFile,2,sample,1))
</code></pre>

<hr>
<h2 id='taxonomizr-package'>taxonomizr: Functions to Work with NCBI Accessions and Taxonomy</h2><span id='topic+taxonomizr'></span><span id='topic+taxonomizr-package'></span>

<h3>Description</h3>

<p>Functions for assigning taxonomy to NCBI accession numbers and taxon IDs based on NCBI's accession2taxid and taxdump files. This package allows the user to download NCBI data dumps and create a local database for fast and local taxonomic assignment.
</p>


<h3>Details</h3>

<p>taxonomizr provides some simple functions to parse NCBI taxonomy files and accession dumps and efficiently use them to assign taxonomy to accession numbers or taxonomic IDs (<a href="https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/">https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/</a>). This is useful for example to assign taxonomy to BLAST results. This is all done locally after downloading the appropriate files from NCBI using included functions. The major functions are:
</p>

<ul>
<li> <p><code><a href="#topic+prepareDatabase">prepareDatabase</a></code>: download data from NCBI and prepare SQLite database
</p>
</li>
<li> <p><code>link{accessionToTaxa}</code>: convert accession numbers to taxonomic IDs
</p>
</li>
<li> <p><code><a href="#topic+getTaxonomy">getTaxonomy</a></code>: convert taxonomic IDs to taxonomy
</p>
</li></ul>

<p>More specialized functions are:
</p>

<ul>
<li> <p><code><a href="#topic+getId">getId</a></code>: convert a biological name to taxonomic ID
</p>
</li>
<li> <p><code><a href="#topic+getAccessions">getAccessions</a></code>: find accessions for a given taxonomic ID
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Scott Sherrill-Mix <a href="mailto:ssm@msu.edu">ssm@msu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepareDatabase">prepareDatabase</a></code>, <code><a href="#topic+accessionToTaxa">accessionToTaxa</a></code>, <code><a href="#topic+getTaxonomy">getTaxonomy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  if(readline(
    "This will download a lot data and take a while to process.
     Make sure you have space and bandwidth. Type y to continue: "
  )!='y')
    stop('This is a stop to make sure no one downloads a bunch of data unintentionally')

  prepareDatabase('accessionTaxa.sql')
  blastAccessions&lt;-c("Z17430.1","Z17429.1","X62402.1")
  ids&lt;-accessionToTaxa(blastAccessions,'accessionTaxa.sql')
  getTaxonomy(ids,'accessionTaxa.sql')

## End(Not run)
</code></pre>

<hr>
<h2 id='taxonomizrSwitch'>Switch from data.table to SQLite</h2><span id='topic+taxonomizrSwitch'></span>

<h3>Description</h3>

<p>In version 0.5.0, taxonomizr switched from data.table to SQLite name and node lookups. See below for more details.
</p>


<h3>Details</h3>

<p>Version 0.5.0 marked a change for name and node lookups from using data.table to using SQLite. This was necessary to increase performance (10-100x speedup for <code><a href="#topic+getTaxonomy">getTaxonomy</a></code>) and create a simpler interface (a single SQLite database contains all necessary data). Unfortunately, this switch requires a couple breaking changes:
</p>

<ul>
<li> <p><code><a href="#topic+getTaxonomy">getTaxonomy</a></code> changes from <code>getTaxonomy(ids,namesDT,nodesDT)</code> to <code>getTaxonomy(ids,sqlFile)</code>
</p>
</li>
<li>  <p><code><a href="#topic+getId">getId</a></code> changes from  <code>getId(taxa,namesDT)</code> to <code>getId(taxa,sqlFile)</code>
</p>
</li>
<li> <p><code><a href="#topic+read.names">read.names</a></code> is deprecated, instead use <code><a href="#topic+read.names.sql">read.names.sql</a></code>. For example, instead of calling <code>names&lt;-read.names('names.dmp')</code> in every session, simply call <code>read.names.sql('names.dmp','accessionTaxa.sql')</code> once (or use the convenient <code><a href="#topic+prepareDatabase">prepareDatabase</a></code>)).
</p>
</li>
<li> <p><code><a href="#topic+read.nodes">read.nodes</a></code> is deprecated, instead use <code><a href="#topic+read.names.sql">read.names.sql</a></code>. For example. instead of calling <code>nodes&lt;-read.names('nodes.dmp')</code> in every session, simply call <code>read.nodes.sql('nodes.dmp','accessionTaxa.sql')</code> once (or use the convenient <code><a href="#topic+prepareDatabase">prepareDatabase</a></code>).
</p>
</li></ul>

<p>I've tried to ease any problems with this by overloading <code><a href="#topic+getTaxonomy">getTaxonomy</a></code> and <code><a href="#topic+getId">getId</a></code> to still function (with a warning) if passed a data.table names and nodes argument and providing a simpler <code><a href="#topic+prepareDatabase">prepareDatabase</a></code> function for completing all setup steps (hopefully avoiding direct calls to <code><a href="#topic+read.names">read.names</a></code> and <code><a href="#topic+read.nodes">read.nodes</a></code> for most users).
</p>
<p>I plan to eventually remove data.table functionality to avoid a split codebase so please switch to the new SQLite format in all new code.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTaxonomy">getTaxonomy</a></code>, <code><a href="#topic+read.names.sql">read.names.sql</a></code>, <code><a href="#topic+read.nodes.sql">read.nodes.sql</a></code>, <code><a href="#topic+prepareDatabase">prepareDatabase</a></code>, <code><a href="#topic+getId">getId</a></code>
</p>

<hr>
<h2 id='topoSort'>Combine multiple sorted vectors into a single sorted vector</h2><span id='topic+topoSort'></span>

<h3>Description</h3>

<p>Combine multiple sorted vectors into a single vector assuming there are no cycles or weird topologies. Where a global position is ambiguous, the result is placed arbitrarily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topoSort(vectors, maxIter = 1000, errorIfAmbiguous = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topoSort_+3A_vectors">vectors</code></td>
<td>
<p>A list of vectors each vector containing sorted elements to be merged into a global sorted vector</p>
</td></tr>
<tr><td><code id="topoSort_+3A_maxiter">maxIter</code></td>
<td>
<p>An integer specifying the maximum number of iterations before bailing out. This should be unnecessary and is just a safety feature in case of some unexpected input or bug.</p>
</td></tr>
<tr><td><code id="topoSort_+3A_errorifambiguous">errorIfAmbiguous</code></td>
<td>
<p>If TRUE then error if any ambiguities arise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with all unique elements sorted by the combined ordering provided by the input vectors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalizeTaxa">normalizeTaxa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>topoSort(list(c('a','b','f','g'),c('b','e','g','y','z'),c('b','d','e','f','y')))
</code></pre>

<hr>
<h2 id='trimTaxa'>Trim columns from taxa file</h2><span id='topic+trimTaxa'></span>

<h3>Description</h3>

<p>A simple script to delete the first row and then delete the first and fourth column of a four column tab delimited file and write to another file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimTaxa(inFile, outFile, desiredCols = c(2, 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimTaxa_+3A_infile">inFile</code></td>
<td>
<p>a single string giving the 4 column tab separated file to read from</p>
</td></tr>
<tr><td><code id="trimTaxa_+3A_outfile">outFile</code></td>
<td>
<p>a single string giving the file path to write to</p>
</td></tr>
<tr><td><code id="trimTaxa_+3A_desiredcols">desiredCols</code></td>
<td>
<p>the integer IDs for columns to pull out from file</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
