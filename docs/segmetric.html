<!DOCTYPE html><html lang="en"><head><title>Help for package segmetric</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {segmetric}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#segmetric-package'><p>segmetric</p></a></li>
<li><a href='#db_functions'><p>Database of metrics functions</p></a></li>
<li><a href='#general_functions'><p>General functions</p></a></li>
<li><a href='#metric_functions'><p>Metric functions</p></a></li>
<li><a href='#plot'><p>Plot function</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#ref_sf'><p>LEM+ dataset</p></a></li>
<li><a href='#seg_sf'><p>Segmentation dataset</p></a></li>
<li><a href='#segmetric_functions'><p>General functions</p></a></li>
<li><a href='#set_functions'><p>Set functions</p></a></li>
<li><a href='#subset_handling_functions'><p>Subset handling functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Metrics for Assessing Segmentation Accuracy for Geospatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A system that computes metrics to assess the segmentation 
    accuracy of geospatial data. These metrics calculate the discrepancy 
    between segmented and reference objects, and indicate the segmentation 
    accuracy. For more details on choosing evaluation metrics, we 
    suggest seeing Costa et al. (2018) &lt;<a href="https://doi.org/10.1016%2Fj.rse.2017.11.024">doi:10.1016/j.rse.2017.11.024</a>&gt; and 
    Jozdani et al. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.isprsjprs.2020.01.002">doi:10.1016/j.isprsjprs.2020.01.002</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, graphics, units</td>
</tr>
<tr>
<td>Suggests:</td>
<td>classInt, dplyr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), sf</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/michellepicoli/segmetric/issues">https://github.com/michellepicoli/segmetric/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://michellepicoli.github.io/segmetric/">https://michellepicoli.github.io/segmetric/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-10 12:12:54 UTC; araujopicoli</td>
</tr>
<tr>
<td>Author:</td>
<td>Rolf Simoes <a href="https://orcid.org/0000-0003-0953-4132"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Alber Sanchez <a href="https://orcid.org/0000-0001-7966-2880"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Michelle Picoli <a href="https://orcid.org/0000-0001-9855-2046"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michelle Picoli &lt;mipicoli@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-10 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='segmetric-package'>segmetric</h2><span id='topic+segmetric-package'></span><span id='topic+_PACKAGE'></span><span id='topic+segmetric'></span>

<h3>Description</h3>

<p>Metrics for assessing segmentation accuracy for geospatial data.
</p>


<h3>Purpose</h3>

<p>The <code>segmetric</code> package provides a set of metrics for the
segmentation accuracy assessment (or evaluation) of geospatial data.
It includes more than 20 metrics used in the literature for spatial
segmentation assessment (Van Rijsbergen, 1979; Levine and Nazif, 1982;
Janssen and Molenaar, 1995; Lucieer and Stein, 2002; Carleer et al., 2005;
Moller et al., 2007; van Coillie et al., 2008; Costa et al., 2008; Weidner,
2008; Feitosa et al., 2010; Clinton et al. 2010; Persello and Bruzzone, 2010;
Yang et al., 2014; and Zhang et al., 2015).
</p>


<h3>Extensions</h3>

<p>The <code>segmetric</code> package is extensible and provides a set of functions to
ease the implementation of new metrics. See <code>?sm_reg_metric()</code> to find how
new metrics are implemented.
</p>


<h3>Contributions</h3>

<p>Contribution to this package could be done at <code>segmetric</code>'s page on GitHub:
<a href="https://github.com/michellepicoli/segmetric">https://github.com/michellepicoli/segmetric</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michelle Picoli <a href="mailto:mipicoli@gmail.com">mipicoli@gmail.com</a> (<a href="https://orcid.org/0000-0001-9855-2046">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Rolf Simoes <a href="mailto:rolfsimoes@gmail.com">rolfsimoes@gmail.com</a> (<a href="https://orcid.org/0000-0003-0953-4132">ORCID</a>)
</p>
</li>
<li><p> Alber Sanchez <a href="mailto:albhasan@gmail.com">albhasan@gmail.com</a> (<a href="https://orcid.org/0000-0001-7966-2880">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Carleer, A.P., Debeir, O., Wolff, E., 2005. Assessment of very high spatial
resolution satellite image segmentations. Photogramm. Eng. Remote. Sens. 71,
1285-1294. doi: <a href="https://doi.org/10.14358/PERS.71.11.1285">10.14358/PERS.71.11.1285</a>.
</p>
</li>
<li><p> Clinton, N., Holt, A., Scarborough, J., Yan, L., Gong, P., 2010. Accuracy
assessment measures for object-based image segmentation goodness. Photogramm.
Eng. Remote. Sens. 76, pp. 289-299.
</p>
</li>
<li><p> Costa, G.A.O.P., Feitosa, R.Q., Cazes, T.B., Feijo, B., 2008. Genetic
adaptation of segmentation parameters. In: Blaschke, T., Lang, S., Hay, G.J.
(Eds.), Object-based Image Analysis. Springer Berlin Heidelberg, Berlin,
Heidelberg, pp. 679-695. doi: <a href="https://doi.org/10.1007/978-3-540-77058-9_37">10.1007/978-3-540-77058-9_37</a>.
</p>
</li>
<li><p> Dice, L.R., 1945. Measures of the amount of ecologic association between
species. Ecology, 26(3), pp.297-302.
</p>
</li>
<li><p> Feitosa, R.Q., Ferreira, R.S., Almeida, C.M., Camargo, F.F., Costa,
G.A.O.P., 2010. Similarity metrics for genetic adaptation of segmentation
parameters. In: 3rd International Conference on Geographic Object-Based Image
Analysis (GEOBIA 2010). The International Archives of the Photogrammetry,
Remote Sensing and Spatial Information Sciences, Ghent.
</p>
</li>
<li><p> Jaccard, P., 1912. The distribution of the flora in the alpine zone.
</p>
</li></ul>


<ol>
<li><p> New phytologist, 11(2), pp.37-50. doi: <a href="https://doi.org/10.1111/j.1469-8137.1912.tb05611.x">10.1111/j.1469-8137.1912.tb05611.x</a>
</p>
</li></ol>


<ul>
<li><p> Janssen, L.L.F., Molenaar, M., 1995. Terrain objects, their dynamics and
their monitoring by the integration of GIS and remote sensing. IEEE Trans.
Geosci. Remote Sens. 33, pp. 749-758. doi: <a href="https://doi.org/10.1109/36.387590">10.1109/36.387590</a>.
</p>
</li>
<li><p> Levine, M.D., Nazif, A.M., 1982. An experimental rule based system for
testing low level segmentation strategies. In: Preston, K., Uhr, L. (Eds.),
Multicomputers and Image Processing: Algorithms and Programs. Academic Press,
New York, pp. 149-160.
</p>
</li>
<li><p> Lucieer, A., Stein, A., 2002. Existential uncertainty of spatial objects
segmented from satellite sensor imagery. Geosci. Remote. Sens. IEEE Trans.
40, pp. 2518-2521. doi: <a href="https://doi.org/10.1109/TGRS.2002.805072">10.1109/TGRS.2002.805072</a>.
</p>
</li>
<li><p> Möller, M., Lymburner, L., Volk, M., 2007. The comparison index: a tool for
assessing the accuracy of image segmentation. Int. J. Appl. Earth Obs.
Geoinf. 9, pp. 311-321. doi: <a href="https://doi.org/10.1016/j.jag.2006.10.002">10.1016/j.jag.2006.10.002</a>.
</p>
</li>
<li><p> Persello, C., Bruzzone, L., 2010. A novel protocol for accuracy assessment
in classification of very high resolution images. IEEE Trans. Geosci. Remote
Sens. 48, pp. 1232-1244. doi: <a href="https://doi.org/10.1109/TGRS.2009.2029570">10.1109/TGRS.2009.2029570</a>.
</p>
</li>
<li><p> Rezatofighi, H., Tsoi, N., Gwak, J., Sadeghian, A., Reid, I., Savarese, S.,
</p>
</li></ul>


<ol>
<li><p> In: Proceedings of the IEEE/CVF Conference on Computer Vision and
Pattern Recognition (CVPR), pp. 658-666.
</p>
</li></ol>


<ul>
<li><p> Van Coillie, F.M.B., Verbeke, L.P.C., De Wulf, R.R., 2008. Semi-automated
forest stand delineation using wavelet based segmentation of very high
resolution optical imagery. In: Object-Based Image Analysis: Spatial Concepts
for Knowledge-Driven Remote Sensing Applications, pp. 237-256.
doi: <a href="https://doi.org/10.1007/978-3-540-77058-9_13">10.1007/978-3-540-77058-9_13</a>.
</p>
</li>
<li><p> Van Rijsbergen, C.J., 1979. Information Retrieval. Butterworth-Heinemann,
London.
</p>
</li>
<li><p> Weidner, U., 2008. Contribution to the assessment of segmentation quality
for remote sensing applications. In: Proceedings of the 21st Congress for
the International Society for Photogrammetry and Remote Sensing,
03–11 July, Beijing, China. Vol. XXXVII. Part B7, pp. 479-484.
</p>
</li>
<li><p> Yang, J., Li, P., He, Y., 2014. A multi-band approach to unsupervised
scale parameter selection for multi-scale image segmentation. ISPRS J.
Photogramm. Remote Sens. 94, pp. 13-24.
doi: <a href="https://doi.org/10.1016/j.isprsjprs.2014.04.008">10.1016/j.isprsjprs.2014.04.008</a>.
</p>
</li>
<li><p> Yang, J., He, Y., Caspersen, J. P., Jones, T. A., 2017. Delineating
Individual Tree Crowns in an Uneven-Aged, Mixed Broadleaf Forest Using
Multispectral Watershed Segmentation and Multiscale Fitting.
IEEE J. Sel. Top. Appl. Earth Obs. Remote Sens., 10(4), pp. 1390-1401.
doi: <a href="https://doi.org/10.1109/JSTARS.2016.2638822">10.1109/JSTARS.2016.2638822</a>.
</p>
</li>
<li><p> Zhan, Q., Molenaar, M., Tempfli, K., Shi, W., 2005. Quality assessment
for geo‐spatial objects derived from remotely sensed data. International
Journal of Remote Sensing, 26(14), pp.2953-2974.
doi: <a href="https://doi.org/10.1080/01431160500057764">10.1080/01431160500057764</a>
</p>
</li>
<li><p> Zhang, X., Feng, X., Xiao, P., He, G., Zhu, L., 2015a. Segmentation quality
evaluation using region-based precision and recall measures for remote
sensing images. ISPRS J. Photogramm. Remote Sens. 102, pp. 73-84.
doi: <a href="https://doi.org/10.1016/j.isprsjprs.2015.01.009">10.1016/j.isprsjprs.2015.01.009</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://michellepicoli.github.io/segmetric/">https://michellepicoli.github.io/segmetric/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/michellepicoli/segmetric/issues">https://github.com/michellepicoli/segmetric/issues</a>
</p>
</li></ul>


<hr>
<h2 id='db_functions'>Database of metrics functions</h2><span id='topic+db_functions'></span><span id='topic+.db_list'></span><span id='topic+.db_set'></span><span id='topic+.db_del'></span><span id='topic+.db_get'></span><span id='topic+sm_list_metrics'></span><span id='topic+sm_new_metric'></span><span id='topic+sm_reg_metric'></span><span id='topic+sm_unreg_metric'></span><span id='topic+sm_desc_metric'></span>

<h3>Description</h3>

<p>These functions are used to register new metrics in the <code>segmetric</code>
database.
</p>

<ul>
<li> <p><code>sm_list_metrics()</code>: List all registered metrics.
</p>
</li>
<li> <p><code>sm_new_metric()</code>: Create a new metric entry to be registered in
the database.
</p>
</li>
<li> <p><code>sm_reg_metric()</code>: Register a new metric in the database.
</p>
</li>
<li> <p><code>sm_unreg_metric()</code>: Remove a metric entry from the database.
</p>
</li>
<li> <p><code>sm_desc_metric()</code>: Describe a metric registered from the database.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>.db_list()

.db_set(key, value)

.db_del(key)

.db_get(key)

sm_list_metrics()

sm_new_metric(
  fn,
  fn_subset,
  name = "",
  optimal = 0,
  summarizable = TRUE,
  description = "",
  reference = ""
)

sm_reg_metric(metric_id, entry)

sm_unreg_metric(metric_id)

sm_desc_metric(metric_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="db_functions_+3A_fn">fn</code></td>
<td>
<p>A <code>function</code> that receives a <code>segmetric</code> object and
returns the metric values.</p>
</td></tr>
<tr><td><code id="db_functions_+3A_fn_subset">fn_subset</code></td>
<td>
<p>A <code>function</code> that returns a <code>subset</code>.</p>
</td></tr>
<tr><td><code id="db_functions_+3A_name">name</code></td>
<td>
<p>A <code>character</code> containing the metric name
(Defaults to <code>""</code>).</p>
</td></tr>
<tr><td><code id="db_functions_+3A_description">description</code></td>
<td>
<p>A <code>character</code> containing a description of the metric
(Defaults to <code>""</code>).</p>
</td></tr>
<tr><td><code id="db_functions_+3A_reference">reference</code></td>
<td>
<p>A <code>character</code> with the reference to a scientific
literature describing the metric.</p>
</td></tr>
<tr><td><code id="db_functions_+3A_metric_id">metric_id</code></td>
<td>
<p>A <code>character</code> value containing a unique metric
identification.</p>
</td></tr>
<tr><td><code id="db_functions_+3A_entry">entry</code></td>
<td>
<p>A <code>metric_entry</code> object returned by <code>new_metric()</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>sm_list_metrics()</code>: Return <code>character</code> vector with supported metrics.
</p>
</li>
<li> <p><code>sm_new_metric()</code>: Return a <code>metric_entry</code> object containing the
metric function (<code>fn</code>), name (<code>name</code>), description (<code>description</code>), and
reference (<code>reference</code>).
</p>
</li>
<li> <p><code>sm_reg_metric()</code>, <code>sm_unreg_metric()</code>: No return value, called to
(un)register a metric.
</p>
</li>
<li> <p><code>sm_desc_metric()</code>: No return value, called to print a metric description.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>sm_reg_metric(
    metric_id = "Example",
    entry = sm_new_metric(
        fn = function(m, ...) {
            sm_area(sm_ytilde(m)) / 
                sm_area(sm_ref(m), order = sm_ytilde(m))
        },
        fn_subset = sm_ytilde,
        name = "Metric name example",
        description = paste("Values range from A to B.",
                            "Optimal value is C"),
        reference = "Author (Year)"
    ))

sm_desc_metric("Example")
sm_list_metrics()

</code></pre>

<hr>
<h2 id='general_functions'>General functions</h2><span id='topic+general_functions'></span><span id='topic+sm_area'></span><span id='topic+sm_centroid'></span><span id='topic+sm_distance'></span><span id='topic+sm_intersection'></span><span id='topic+sm_subset_union'></span><span id='topic+sm_rbind'></span><span id='topic+sm_apply_group'></span><span id='topic+sm_summarize_group'></span><span id='topic+sm_norm_left'></span><span id='topic+sm_norm_right'></span><span id='topic+sm_options'></span>

<h3>Description</h3>

<p>These functions manipulate segmetric objects.
</p>

<ul>
<li> <p><code>sm_area()</code>: Return a vector of areas, one for each polygon.
</p>
</li>
<li> <p><code>sm_centroid()</code>: Return the centroids of the given polygons.
</p>
</li>
<li> <p><code>sm_intersection()</code>: Return the intersection of the given simple features.
</p>
</li>
<li> <p><code>sm_subset_union()</code>: Return the union of the given simple features.
</p>
</li>
<li> <p><code>sm_rbind()</code>: Return the merge of unique simple features.
</p>
</li>
<li> <p><code>sm_summarize_groups()</code>: Summarizes metric values by a group
(either reference or segment).
</p>
</li>
<li> <p><code>sm_options()</code>: Get/Set segmetric options.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sm_area(s, order = NULL)

sm_centroid(s, order = NULL)

sm_distance(s1, s2)

sm_intersection(s1, s2, touches = TRUE)

sm_subset_union(s)

sm_rbind(...)

sm_apply_group(x, groups, fn, ...)

sm_summarize_group(x, groups, fn, ...)

sm_norm_left(x, y)

sm_norm_right(x, y)

sm_options(..., digits = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="general_functions_+3A_s">s</code>, <code id="general_functions_+3A_s1">s1</code>, <code id="general_functions_+3A_s2">s2</code></td>
<td>
<p>Either a <code>ref_sf</code>, a <code>seg_sf</code>, or a <code>subset_sf</code> object
(inherited from <code>sf</code>).</p>
</td></tr>
<tr><td><code id="general_functions_+3A_order">order</code></td>
<td>
<p>A <code>subset_sf</code>. This argument arranges the returned values
according to the object passed here.</p>
</td></tr>
<tr><td><code id="general_functions_+3A_touches">touches</code></td>
<td>
<p>A <code>logical</code>. Is the border part of the intersection?</p>
</td></tr>
<tr><td><code id="general_functions_+3A_...">...</code></td>
<td>
<p>For <code>sm_rbind()</code>, a set of <code>subset_sf</code> objects to be
merged.</p>
</td></tr>
<tr><td><code id="general_functions_+3A_x">x</code>, <code id="general_functions_+3A_y">y</code></td>
<td>
<p>A <code>numeric</code> values (e.g. areas, lengths) to compute metrics.</p>
</td></tr>
<tr><td><code id="general_functions_+3A_groups">groups</code></td>
<td>
<p>A group identifier vector used to aggregate a metric
for each group.</p>
</td></tr>
<tr><td><code id="general_functions_+3A_fn">fn</code></td>
<td>
<p>A <code>function</code> to aggregate a metric for a group.</p>
</td></tr>
<tr><td><code id="general_functions_+3A_digits">digits</code></td>
<td>
<p>An <code>integer</code> indicating how many digits used to round
metric values.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>sm_area()</code>: Return a <code>numeric</code> vector with polygons' area.
</p>
</li>
<li> <p><code>sm_centroid()</code>: Return a <code>subset_sf</code> object with polygons' centroid.
</p>
</li>
<li> <p><code>sm_intersection()</code>: Return a <code>subset_sf</code> object with intersection
between polygons.
</p>
</li>
<li> <p><code>sm_subset_union()</code>: Return a <code>subset_sf</code> object with union
between intersecting polygons.
</p>
</li>
<li> <p><code>sm_rbind()</code>: Return a <code>subset_sf</code> object with unique features.
</p>
</li></ul>


<hr>
<h2 id='metric_functions'>Metric functions</h2><span id='topic+metric_functions'></span><span id='topic+sm_compute'></span><span id='topic+sm_metric_subset'></span>

<h3>Description</h3>

<p>The <code>sm_compute()</code> computes a given metric (<code>metric_id</code> parameter) from
segmentation objects. It compares the reference to the segmentation
polygons using a metric.
</p>
<p>A list with all supported metrics can be obtained
by <code>sm_list_metrics()</code> (see Details for more information).
</p>
<p>The <code>sm_metric_subset()</code> returns the subset used to compute the metrics
in segmetric object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm_compute(m, metric_id, ...)

sm_metric_subset(m, metric_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metric_functions_+3A_m">m</code></td>
<td>
<p>A <code>segmetric</code> object.</p>
</td></tr>
<tr><td><code id="metric_functions_+3A_metric_id">metric_id</code></td>
<td>
<p>A <code>character</code> vector with metrics id to be computed.</p>
</td></tr>
<tr><td><code id="metric_functions_+3A_...">...</code></td>
<td>
<p>Any additional argument to compute
a metric (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> &quot;<code>OS1</code>&quot; refers to Oversegmentation. Its values range from 0 (optimal) to 1
(Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>US1</code>&quot; refers to Undersegmentation. Its values range from 0 (optimal) to 1
(Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>OS2</code>&quot; refers to Oversegmentation. Its values range from 0 (optimal) to 1
(Persello and Bruzzone, 2010).
</p>
</li>
<li><p> &quot;<code>US2</code>&quot; refers to Undersegmentation. Its values range from 0 (optimal) to 1
(Persello and Bruzzone, 2010).
</p>
</li>
<li><p> &quot;<code>OS3</code>&quot; refers to Oversegmentation. Its values range from 0 (optimal) to 1
(Yang et al., 2014).
</p>
</li>
<li><p> &quot;<code>US3</code>&quot; refers to Undersegmentation. Its values range from 0 (optimal) to 1
(Yang et al., 2014).
</p>
</li>
<li><p> &quot;<code>AFI</code>&quot; refers to Area Fit Index. Its optimal value is 0 (Lucieer and Stein,
2002; Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>QR</code>&quot; refers to Quality Rate. Its values range from 0 (optimal) to 1
(Weidner, 2008; Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>D_index</code>&quot; refers to Index D. Its values range from 0 (optimal) to 1
(Levine and Nazif, 1982; Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>precision</code>&quot; refers to Precision. Its values range from 0 to 1 (optimal)
(Van Rijsbergen, 1979; Zhang et al., 2015).
</p>
</li>
<li><p> &quot;<code>recall</code>&quot; refers to Recall. Its values range from 0 to 1 (optimal) (Van
Rijsbergen, 1979; Zhang et al., 2015).
</p>
</li>
<li><p> &quot;<code>UMerging</code>&quot; refers to Undermerging. Its values range from 0 (optimal) to 1
(Levine and Nazif, 1982; Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>OMerging</code>&quot; refers to Overmerging. Its optimal value is 0
(Levine and Nazif, 1982; Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>M</code>&quot; refers to Match. Its values range from 0 to 1 (optimal) (Janssen and
Molenaar, 1995; Feitosa et al., 2010).
</p>
</li>
<li><p> &quot;<code>E</code>&quot; refers to Evaluation Measure. Its values range from 0 (optimal) to 100
(Carleer et al., 2005).
</p>
</li>
<li><p> &quot;<code>RAsub</code>&quot; refers to Relative Area. Its values range from 0 to 1 (optimal)
(Müller et al., 2007; Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>RAsuper</code>&quot; refers to Relative area. Its values range from 0 to 1 (optimal)
(Müller et al., 2007; Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>PI</code>&quot; refers to Purity Index. Its values range from 0 to 1 (optimal) (van
Coillie et al., 2008).
</p>
</li>
<li><p> &quot;<code>Fitness</code>&quot; refers to Fitness Function. Its optimal value is 0 (Costa et al.,
2008).
</p>
</li>
<li><p> &quot;<code>ED3</code>&quot; refers to Euclidean Distance. Its values range from 0 (optimal) to 1
(Yang et al., 2014).
</p>
</li>
<li><p> &quot;<code>F_measure</code>&quot; refers to F-measure metric. Its values range from 0 to 1
(optimal) (Van Rijsbergen, 1979; Zhang et al., 2015). It takes the optional
weight argument <code>alpha</code>, ranging from <code>0.0</code> to <code>1.0</code> (the default is <code>0.5</code>).
</p>
</li>
<li><p> &quot;<code>IoU</code>&quot; refers to Intersection over Union metric. Its values range
from 0 to 1 (optimal) (Jaccard, 1912; Rezatofighi et al., 2019).
</p>
</li>
<li><p> &quot;<code>SimSize</code>&quot; refers to the similarity size metric. Its values range from
0 to 1 (optimal) (Zhan et al., 2005).
</p>
</li>
<li><p> &quot;<code>qLoc</code>&quot;refers to quality of object’s location metric. Its optimal value
is 0 (Zhan et al., 2005).
</p>
</li>
<li><p> &quot;<code>RPsub</code>&quot; refers to Relative Position (sub) metric. Optimal value is 0
(Möller et al., 2007, Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>RPsuper</code>&quot; refers to Relative Position (super) metric. Its values range
from 0 (optimal) to 1 (Möller et al., 2007, Clinton et al., 2010).
</p>
</li>
<li><p> &quot;<code>OI2</code> refers to Overlap Index metric. Its values range from 0 to 1
(optimal) (Yang et al., 2017).
</p>
</li></ul>



<h3>Value</h3>

<p>Return a <code>numeric</code> vector with computed metric.
</p>


<h3>References</h3>

<p>A complete list of cited references is available in <code>?segmetric</code>.
</p>


<h3>See Also</h3>

<p><code>sm_list_metrics()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load sample datasets
data("sample_ref_sf", package = "segmetric")
data("sample_seg_sf", package = "segmetric")

# create segmetric object
m &lt;- sm_read(ref_sf = sample_ref_sf, seg_sf = sample_seg_sf)

# compute AFI metric and summarize it
sm_compute(m, "AFI") %&gt;% summary()

# compute three metrics and summarize them
sm_compute(m, c("AFI", "OS1", "US2")) %&gt;% summary()

# compute OS1, F_measure, and US2 metrics using pipe
m &lt;- sm_compute(m, "OS1") %&gt;%
  sm_compute("F_measure") %&gt;%
  sm_compute("US2")

# summarize them
summary(m)

</code></pre>

<hr>
<h2 id='plot'>Plot function</h2><span id='topic+plot'></span><span id='topic+plot.segmetric'></span>

<h3>Description</h3>

<p>Plot a segmetric map according to the parameter <code>type</code>:
</p>

<ul>
<li> <p><code>"base"</code>: simple plot of the reference or segmentation polygons;
</p>
</li>
<li> <p><code>"subset"</code>: plot polygons from a subset over the base plot;
</p>
</li>
<li> <p><code>"choropleth"</code>: plot a choropleth map from polygons of a subset using
metric values.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmetric'
plot(
  x,
  type = "base",
  ...,
  title = NULL,
  layers = c("ref_sf", "seg_sf"),
  background = "#FFFFFF",
  ref_color = "#FF00009F",
  ref_fill = "#FFFFFF00",
  ref_label = "reference",
  ref_size = 2,
  ref_symbol = 2,
  seg_color = "#0000009F",
  seg_fill = "#FFFFFF00",
  seg_label = "segment",
  seg_size = 1,
  seg_symbol = 3,
  selected_fill = "#9A9AFF50",
  plot_centroids = TRUE,
  centroids_color = "#000000FF",
  centroids_label = "centroid",
  subset_id = NULL,
  subset_color = "#FFFFFF00",
  subset_fill = "#F0E4167F",
  metric_id = NULL,
  break_style = "jenks",
  choropleth_palette = "YlGnBu",
  choropleth_palette_reverse = FALSE,
  choropleth_size = 0.1,
  plot_extent = NULL,
  plot_legend = TRUE,
  plot_axes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>A <code>segmetric</code> object.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>A <code>character</code>. Either <code>"base"</code>, <code>"subset"</code>, or <code>"choropleth"</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="plot_+3A_title">title</code></td>
<td>
<p>A <code>character</code> with plot title</p>
</td></tr>
<tr><td><code id="plot_+3A_layers">layers</code></td>
<td>
<p>A <code>character</code>. One or both of <code>"ref_sf"</code> and <code>"seg_sf"</code>
(works only for <code>type = "base"</code> and <code>type = "subset"</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_background">background</code></td>
<td>
<p>A <code>character</code> with valid color used in graph's background.</p>
</td></tr>
<tr><td><code id="plot_+3A_ref_color">ref_color</code>, <code id="plot_+3A_seg_color">seg_color</code>, <code id="plot_+3A_ref_fill">ref_fill</code>, <code id="plot_+3A_seg_fill">seg_fill</code></td>
<td>
<p>A <code>character</code> with a
valid hexadecimal color in <code>rgb</code> or <code>rgba</code> format. Set the border and fill
colors for reference and segmentation polygons.</p>
</td></tr>
<tr><td><code id="plot_+3A_ref_label">ref_label</code>, <code id="plot_+3A_seg_label">seg_label</code>, <code id="plot_+3A_centroids_label">centroids_label</code></td>
<td>
<p>A <code>character</code> with legend
labels for reference polygons, segmentation polygons, and centroids.</p>
</td></tr>
<tr><td><code id="plot_+3A_ref_size">ref_size</code>, <code id="plot_+3A_seg_size">seg_size</code></td>
<td>
<p>A <code>numeric</code>. Set symbol's size for centroids.</p>
</td></tr>
<tr><td><code id="plot_+3A_ref_symbol">ref_symbol</code>, <code id="plot_+3A_seg_symbol">seg_symbol</code></td>
<td>
<p>An <code>integer</code>. Symbol to represent polygons'
centroids (see <code>pch</code> param in <a href="graphics.html#topic+points">points</a>).</p>
</td></tr>
<tr><td><code id="plot_+3A_selected_fill">selected_fill</code></td>
<td>
<p>A <code>character</code> with a valid hexadecimal color in <code>rgb</code>
or <code>rgba</code> format. Set the fill color of selected reference or
segmentation polygons depending on <code>subset_id</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_plot_centroids">plot_centroids</code></td>
<td>
<p>A <code>logical</code>. Plot centroids or not.</p>
</td></tr>
<tr><td><code id="plot_+3A_centroids_color">centroids_color</code></td>
<td>
<p>A <code>character</code> with a valid hexadecimal color
in <code>rgb</code> or <code>rgba</code> format. Set the border colors for centroids.</p>
</td></tr>
<tr><td><code id="plot_+3A_subset_id">subset_id</code></td>
<td>
<p>A <code>character</code> with subset name
(required for <code>type = "subset"</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_subset_color">subset_color</code>, <code id="plot_+3A_subset_fill">subset_fill</code></td>
<td>
<p>A <code>character</code> with a valid hexadecimal
color in <code>rgb</code> or <code>rgba</code> format. Set the border and fill
colors for subset polygons (works only with <code>type = "subset"</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_metric_id">metric_id</code></td>
<td>
<p>A <code>character</code> with metric to be plotted in choropleth maps
(required for <code>type = "choropleth"</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_break_style">break_style</code></td>
<td>
<p>A <code>character</code> with the name of a method to compute
the intervals for choropleth maps. Can be one of <code>"sd"</code>, <code>"equal"</code>,
<code>"pretty"</code>, <code>"quantile"</code>, <code>"kmeans"</code>, <code>"hclust"</code>, <code>"bclust"</code>, <code>"fisher"</code>,
<code>"jenks"</code>, <code>"dpih"</code>, and <code>"headtails"</code> (see <code>style</code> parameter in
<a href="classInt.html#topic+classIntervals">classIntervals</a>).</p>
</td></tr>
<tr><td><code id="plot_+3A_choropleth_palette">choropleth_palette</code></td>
<td>
<p>A <code>character</code> with a valid palette to be used
in choropleth plots.</p>
</td></tr>
<tr><td><code id="plot_+3A_choropleth_palette_reverse">choropleth_palette_reverse</code></td>
<td>
<p>A <code>logical</code> indicating if palette should
be generated in reversely.</p>
</td></tr>
<tr><td><code id="plot_+3A_choropleth_size">choropleth_size</code></td>
<td>
<p>A <code>numeric</code> with border size used to plot polygons.</p>
</td></tr>
<tr><td><code id="plot_+3A_plot_extent">plot_extent</code></td>
<td>
<p>A <code>sf</code> object. Set the map extent for a plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_plot_legend">plot_legend</code></td>
<td>
<p>A <code>logical</code>. Plot legend or not.</p>
</td></tr>
<tr><td><code id="plot_+3A_plot_axes">plot_axes</code></td>
<td>
<p>A <code>logical</code>. Plot coordinates axis or not.</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='ref_sf'>LEM+ dataset</h2><span id='topic+ref_sf'></span><span id='topic+sample_ref_sf'></span>

<h3>Description</h3>

<p><code>ref_sf</code>: a dataset containing field boundaries from Luiz Eduardo Magalhaes
municipality, Brazil.
</p>
<p>The data covers the following extent:
xmin: -46.37683 ymin: -12.34579 xmax: -46.15776 ymax: -12.13663
CRS: EPSG:4326
</p>
<p><code>sample_ref_sf</code>: a subset of <code>ref_sf</code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref_sf

sample_ref_sf
</code></pre>


<h3>Format</h3>

<p>These datasets are objects of class <code>sf</code> (inherited from <code>tbl_df</code>,
<code>tbl</code>, <code>data.frame</code>) with 2 variables:
</p>

<ul>
<li><p><code>id</code>: identification
</p>
</li>
<li><p><code>geometry</code>: polygons
</p>
</li></ul>

<p><code>ref_sf</code>: a dataset with 195 features.
</p>
<p><code>sample_ref_sf</code>: a dataset with 5 features.
</p>


<h3>Source</h3>

<p>Oldoni et al. (2020) doi: <a href="https://doi.org/10.1016/j.dib.2020.106553">10.1016/j.dib.2020.106553</a>.
</p>


<h3>References</h3>


<ul>
<li><p> Oldoni, L.V., Sanches, I.D.A., Picoli, M.C.A.,
Covre, R.M. and Fronza, J.G., 2020. LEM+ dataset: For
agricultural remote sensing applications.
Data in Brief, 33, p.106553.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("ref_sf", package = "segmetric")
data("sample_ref_sf", package = "segmetric")
</code></pre>

<hr>
<h2 id='seg_sf'>Segmentation dataset</h2><span id='topic+seg_sf'></span><span id='topic+seg200_sf'></span><span id='topic+seg500_sf'></span><span id='topic+seg800_sf'></span><span id='topic+seg1000_sf'></span><span id='topic+sample_seg_sf'></span>

<h3>Description</h3>

<p><code>seg200_sf</code>,<code>seg500_sf</code>,<code>seg800_sf</code>,<code>seg1000_sf</code>: a dataset containing
segments generated from PlanetScope image, level 3B, acquired on
Feb 18, 2020, with 3.7-meter resolution (Planet Team, 2017), using the
multiresolution segmentation method (Baatz and Schape, 2000).
</p>
<p>The data covers the approximately the same area of LEM+ dataset
(see <a href="#topic+ref_sf">ref_sf</a>).
</p>
<p>The data was post-processed using the spectral difference algorithm on
band 3.
</p>
<p>The polygons were simplified using the Douglas-Peucker algorithm in QGIS.
</p>
<p>Self-intersections were removed using SAGA's Polygon Self-Intersection.
</p>
<p>Segmentation parameters:
</p>

<ul>
<li><p><code style="white-space: pre;">&#8288;scale parameter&#8288;</code>: 200 (<code>seg200_sf</code>), 500 (<code>seg500_sf</code>),
800 (<code>seg800_sf</code>), and 1000 (<code>seg1000_sf</code>)
</p>
</li>
<li><p><code>shape</code>: 0.9
</p>
</li>
<li><p><code>compactness</code>: 0.1
</p>
</li></ul>

<p>Spectral difference parameters:
</p>

<ul>
<li><p><code style="white-space: pre;">&#8288;spectral difference&#8288;</code>: 20
</p>
</li></ul>

<p>Simplification parameter:
</p>

<ul>
<li><p><code>distance</code>: 10-meters
</p>
</li></ul>

<p>Only those polygons intersecting reference data with an area-perimeter ratio
above 25 were selected.
</p>
<p><code>sample_seg_sf</code>: a subset of <code>seg_sf</code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg200_sf

seg500_sf

seg800_sf

seg1000_sf

sample_seg_sf
</code></pre>


<h3>Format</h3>

<p>These datasets are objects of class <code>sf</code> (inherited from <code>tbl_df</code>,
<code>tbl</code>, <code>data.frame</code>) with 2 variables:
</p>

<ul>
<li><p><code>id</code>: identification
</p>
</li>
<li><p><code>geometry</code>: polygons
</p>
</li></ul>

<p><code>seg200_sf</code>: a dataset with 547 features.
<code>seg500_sf</code>: a dataset with 215 features.
<code>seg800_sf</code>: a dataset with 169 features.
<code>seg1000_sf</code>: a dataset with 158 features.
</p>
<p>An object of class <code>sf</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 215 rows and 2 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 169 rows and 2 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 158 rows and 2 columns.
</p>
<p><code>sample_seg_sf</code>: a dataset with 6 features extracted from
<code>seg500_sf</code> dataset.
</p>


<h3>References</h3>


<ul>
<li><p> Planet Team, 2017. Planet Application Program
Interface: In Space for Life on Earth. San Francisco,
CA. <a href="https://www.planet.com">https://www.planet.com</a>
</p>
</li>
<li><p> Baatz, M., Schape, A., 2000. Multiresolution
segmentation - an optimization approach for high
quality multi-scale image segmentation. In: Strobl, J.,
Blaschke, T., Griesebner, G. (Eds.), Angewandte
Geographische Informations-Verarbeitung XII.
Wichmann Verlag, Karlsruhe, Germany, pp. 12-23. &lt;&gt;
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("seg200_sf", package = "segmetric")
data("seg500_sf", package = "segmetric")
data("seg800_sf", package = "segmetric")
data("seg1000_sf", package = "segmetric")
data("sample_seg_sf", package = "segmetric")
</code></pre>

<hr>
<h2 id='segmetric_functions'>General functions</h2><span id='topic+segmetric_functions'></span><span id='topic+.segmetric_check'></span><span id='topic+.segmetric_env'></span><span id='topic+sm_read'></span><span id='topic+sm_clear'></span><span id='topic+summary.segmetric'></span><span id='topic+sm_is_empty'></span><span id='topic++5B.segmetric'></span>

<h3>Description</h3>

<p>These functions manipulate <code>segmetric</code> objects.
</p>

<ul>
<li> <p><code>sm_read()</code>: Load the reference and segmentation polygons into segmetric.
</p>
</li>
<li> <p><code>sm_clear()</code>: Remove the already calculated metrics from segmetric.
</p>
</li>
<li> <p><code>print()</code>: Print a segmetric object.
</p>
</li>
<li> <p><code>plot()</code>: Plot the reference and segmentation polygons.
</p>
</li>
<li> <p><code>summary()</code>: Compute a measure of central tendency over the values of a metric.
</p>
</li>
<li> <p><code>sm_is_empty()</code>: Check if a <code>segmetric</code> object is empty.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>.segmetric_check(m)

.segmetric_env(m)

sm_read(ref_sf, seg_sf)

sm_clear(m)

## S3 method for class 'segmetric'
summary(object, weight = NULL, na_rm = TRUE, ...)

sm_is_empty(m)

## S3 method for class 'segmetric'
x[i]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmetric_functions_+3A_m">m</code></td>
<td>
<p>A <code>segmetric</code> object.</p>
</td></tr>
<tr><td><code id="segmetric_functions_+3A_ref_sf">ref_sf</code></td>
<td>
<p>A <code>sf</code> object. The reference polygons.</p>
</td></tr>
<tr><td><code id="segmetric_functions_+3A_seg_sf">seg_sf</code></td>
<td>
<p>A <code>sf</code> object. The segmentation polygons.</p>
</td></tr>
<tr><td><code id="segmetric_functions_+3A_object">object</code></td>
<td>
<p>A <code>segmetric</code> object.</p>
</td></tr>
<tr><td><code id="segmetric_functions_+3A_weight">weight</code></td>
<td>
<p>Weights to summarize metrics. Accepts <code>character</code> options
<code>"ref"</code>, <code>"seg"</code>, and <code>"inter"</code>, that weights using reference, segment,
and intersection areas, respectively. Also accepts a <code>numeric</code> vector
of weights of the same length as input metrics giving the weights to
be used.</p>
</td></tr>
<tr><td><code id="segmetric_functions_+3A_na_rm">na_rm</code></td>
<td>
<p>Should missing values (including <code>NaN</code>) be removed?</p>
</td></tr>
<tr><td><code id="segmetric_functions_+3A_...">...</code></td>
<td>
<p>Additional parameters (Not implemented).</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>sm_read()</code>, <code>sm_clear()</code>: Return a <code>segmetric</code> object containing an
empty list and an environment attribute to store the necessary datasets.
</p>
</li>
<li> <p><code>sm_is_empty()</code>: Return a <code>logical</code> vector indicating if each computed
metric is empty.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>sm_compute()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load sample datasets
data("sample_ref_sf", package = "segmetric")
data("sample_seg_sf", package = "segmetric")

# create segmetric object
m &lt;- sm_read(ref_sf = sample_ref_sf, seg_sf = sample_seg_sf)

# plot geometries
plot(m)

# compute a metric
sm_compute(m, "AFI")

# summarize the metric using mean
sm_compute(m, "AFI") %&gt;% summary()

# clear computed subsets
sm_clear(m)

</code></pre>

<hr>
<h2 id='set_functions'>Set functions</h2><span id='topic+set_functions'></span><span id='topic+sm_ytilde'></span><span id='topic+sm_xtilde'></span><span id='topic+sm_yprime'></span><span id='topic+sm_xprime'></span><span id='topic+sm_ya'></span><span id='topic+sm_yb'></span><span id='topic+sm_yc'></span><span id='topic+sm_yd'></span><span id='topic+sm_ystar'></span><span id='topic+sm_ycd'></span><span id='topic+sm_ye'></span><span id='topic+sm_yf'></span><span id='topic+sm_yg'></span>

<h3>Description</h3>

<p>These functions compute subsets required to calculate segmentation
metrics as described in Clinton et al. (2010) and Costa et al. (2017).
</p>

<ul>
<li> <p><code>sm_ref()</code>    returns the set of <code class="reqn">n</code> polygons of reference,
represented by <code class="reqn">X = \{x_{i}: i = 1, ....., n\}</code>
</p>
</li>
<li> <p><code>sm_seg()</code>    returns the set of <code class="reqn">m</code> segmentation polygons,
represented by <code class="reqn">Y = \{y_{j}: j = 1, ....., m\}</code>
</p>
</li>
<li> <p><code>sm_ytilde()</code> returns <code class="reqn">\tilde{Y}_{i}</code>, a subset of <code class="reqn">Y</code>,
where <code class="reqn">\tilde{Y}_{i} = \{y_{j}: \rm{area}(x_{i} \cap y_{j}) \neq 0\}</code>
</p>
</li>
<li> <p><code>sm_xtilde()</code> returns <code class="reqn">\tilde{X}_{j}</code>, a subset of <code class="reqn">X</code>, where
<code class="reqn">\tilde{X}_{j} = \{x_{i}: \rm{area}(y_{j} \cap x_{i}) \neq 0\}</code>
</p>
</li>
<li> <p><code>sm_yprime()</code> returns <code class="reqn">Y'_{i}</code>, a subset of <code class="reqn">Y</code>, where
<code class="reqn">Y'_{i} = \{y_{j}: max(\rm{area}(x_{i} \cap y_{j}))\}</code>
</p>
</li>
<li> <p><code>sm_xprime()</code> returns <code class="reqn">X'_{j}</code>, a subset of <code class="reqn">X</code>, where
<code class="reqn">X'_{j} = \{x_{i}: max(\rm{area}(y_{j} \cap x_{i}))\}</code>
</p>
</li>
<li> <p><code>sm_ya()</code>     returns <code class="reqn">Y\!a_{i}</code>, a subset of <code class="reqn">\tilde{Y}_{i}</code>,
where <code class="reqn">Y\!a_{i} = \{y_{j}: \rm{centroid}(x_{i}) \:\rm{in}\: y_{j}\}</code>
</p>
</li>
<li> <p><code>sm_yb()</code>     returns <code class="reqn">Y\!b_{i}</code>, a subset of <code class="reqn">\tilde{Y}_{i}</code>,
where <code class="reqn">Y\!b_{i} = \{y_{j}: \rm{centroid}(y_{j}) \:\rm{in}\: x_{i}\}</code>
</p>
</li>
<li> <p><code>sm_yc()</code>     returns <code class="reqn">Y\!c_{i}</code>, a subset of <code class="reqn">\tilde{Y}_{i}</code>,
where <code class="reqn">Y\!c_{i} = \{y_{j}: \rm{area}(x_{i} \cap y_{j}) / 
\rm{area}(y_{j}) &gt; 0.5\}</code>
</p>
</li>
<li> <p><code>sm_yd()</code>     returns <code class="reqn">Y\!d_{i}</code>, a subset of <code class="reqn">\tilde{Y}_{i}</code>,
where <code class="reqn">Y\!d_{i} = \{y_{j}: \rm{area}(x_{i} \cap y_{j}) / \rm{area}(x_{i}) &gt; 0.5\}</code>
</p>
</li>
<li> <p><code>sm_ystar()</code>  returns <code class="reqn">{Y}^{*}_{i}</code>, where
<code class="reqn">{Y}^{*}_{i} = Y\!a_{i} \cup Y\!b_{i} \cup Y\!c_{i} \cup Y\!c_{i}</code>
</p>
</li>
<li> <p><code>sm_ycd()</code>    returns <code class="reqn">Y\!cd_{i}</code>, where
<code class="reqn">Y\!cd_{i} = Y\!c_{i} \cup Y\!d_{i}</code>
</p>
</li>
<li> <p><code>sm_ye()</code>     returns <code class="reqn">Y\!e_{i}</code>, a subset of <code class="reqn">\tilde{Y}_{i}</code>,
where <code class="reqn">Y\!e_{i} = \{y_{j}: \rm{area}(x_{i} \cap y_{j}) / \rm{area}(y_{j}) = 1\}</code>
</p>
</li>
<li> <p><code>sm_yf()</code>     returns <code class="reqn">Y\!f_{i}</code>, a subset of <code class="reqn">\tilde{Y}_{i}</code>,
where <code class="reqn">Y\!f_{i} = \{y_{j}: \rm{area}(x_{i} \cap y_{j}) / \rm{area}(y_{j}) &gt; 0.55\}</code>
</p>
</li>
<li> <p><code>sm_yg()</code>     returns <code class="reqn">Y\!g_{i}</code>, a subset of <code class="reqn">\tilde{Y}_{i}</code>,
where <code class="reqn">Y\!g_{i} = \{y_{j}: \rm{area}(x_{i} \cap y_{j}) / \rm{area}(y_{j}) &gt; 0.75\}</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sm_ytilde(m)

sm_xtilde(m)

sm_yprime(m)

sm_xprime(m)

sm_ya(m)

sm_yb(m)

sm_yc(m)

sm_yd(m)

sm_ystar(m)

sm_ycd(m)

sm_ye(m)

sm_yf(m)

sm_yg(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_functions_+3A_m">m</code></td>
<td>
<p>A <code>segmetric</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>sm_ref()</code>: Return an object of class <code>ref_sf</code> (inherited from <code>sf</code>)
containing identification (<code>ref_id</code>) and geometry (<code>geometry</code>) columns.
</p>
</li>
<li> <p><code>sm_seg()</code>: Return an object of class <code>seg_sf</code> (inherited from <code>sf</code>)
containing identification (<code>seg_id</code>) and geometry (<code>geometry</code>) columns.
</p>
</li>
<li> <p><code>sm_ytilde()</code>, <code>sm_xtilde()</code>, <code>sm_yprime()</code>, <code>sm_xprime()</code>, <code>sm_ya()</code>,
<code>sm_yb()</code>, <code>sm_yc()</code>, <code>sm_yd()</code>, <code>sm_ystar()</code>, <code>sm_ycd()</code>, <code>sm_ye()</code>,
<code>sm_yf()</code>, and <code>sm_yg()</code>: Return an object of class <code>subset_sf</code>
(inherited from <code>sf</code>) containing identification (<code>ref_id</code> and <code>seg_id</code>),
and geometry (<code>geometry</code>) columns.
</p>
</li></ul>



<h3>References</h3>

<p>Clinton, N., Holt, A., Scarborough, J., Yan, L., &amp; Gong, P. (2010). Accuracy
Assessment Measures for Object-based Image Segmentation Goodness.
Photogrammetric Engineering &amp; Remote Sensing, 76(3), 289–299.
doi: <a href="https://doi.org/10.14358/PERS.76.3.289">10.14358/PERS.76.3.289</a>.
</p>
<p>Costa, H., Foody, G. M., &amp; Boyd, D. S. (2018). Supervised methods of image
segmentation accuracy assessment in land cover mapping. Remote Sensing of
Environment, 205(December 2017), 338–351. doi: <a href="https://doi.org/10.1016/j.rse.2017.11.024">10.1016/j.rse.2017.11.024</a>.
</p>

<hr>
<h2 id='subset_handling_functions'>Subset handling functions</h2><span id='topic+subset_handling_functions'></span><span id='topic+sm_list'></span><span id='topic+sm_exists'></span><span id='topic+sm_subset'></span><span id='topic+sm_indirect'></span><span id='topic+sm_segmetric'></span><span id='topic+sm_get'></span><span id='topic+sm_ref'></span><span id='topic+sm_seg'></span><span id='topic+sm_inset'></span><span id='topic+sm_inset.ref_sf'></span><span id='topic+sm_inset.seg_sf'></span><span id='topic+sm_inset.subset_sf'></span><span id='topic+sm_group_by'></span>

<h3>Description</h3>

<p>These functions are intended to be used in new metric extensions.
They handle <code>subset_sf</code> data (inherited from <code>sf</code> class) stored in
<code>segmetric</code> objects.
</p>

<ul>
<li> <p><code>sm_list()</code> lists subsets already computed and stored in a <code>segmetric</code>
object.
</p>
</li>
<li> <p><code>sm_exists()</code> verifies if a <code>subset_id</code> exists in a <code>segmetric</code> object.
</p>
</li>
<li> <p><code>sm_subset()</code> evaluates and stores a <code>subset_sf</code> object.
</p>
</li>
<li> <p><code>sm_indirect()</code> finds the <code>subset_id</code> of a given <code>subset_sf</code> object stored
in a <code>segmetric</code> object.
</p>
</li>
<li> <p><code>sm_segmetric()</code> returns the <code>segmetric</code> object that stores a given
<code>subset</code> object (either a <code>ref_sf</code>, a <code>seg_sf</code>, or a <code>subset_sf</code>).
</p>
</li>
<li> <p><code>sm_get()</code> retrieves a <code>subset_sf</code> object stored in a <code>segmetric</code> object.
</p>
</li>
<li> <p><code>sm_inset()</code> operator equivalent to inner join but returns only objects
from <code>s1</code>, or its corresponding row in <code>s2</code> if parameter <code>return_index</code>
is <code>TRUE</code>.
</p>
</li>
<li> <p><code>sm_group_by()</code>: Apply a function to groups of <code>subset_sf</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sm_list(m)

sm_exists(m, subset_id)

sm_subset(m, subset_id, expr = NULL)

sm_indirect(s)

sm_segmetric(s)

sm_get(m, subset_id)

sm_ref(m)

sm_seg(m)

sm_inset(s1, s2, return_index = FALSE)

## S3 method for class 'ref_sf'
sm_inset(s1, s2, return_index = FALSE)

## S3 method for class 'seg_sf'
sm_inset(s1, s2, return_index = FALSE)

## S3 method for class 'subset_sf'
sm_inset(s1, s2, return_index = FALSE)

sm_group_by(s, by, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_handling_functions_+3A_m">m</code></td>
<td>
<p>A <code>segmetric</code> object.</p>
</td></tr>
<tr><td><code id="subset_handling_functions_+3A_subset_id">subset_id</code></td>
<td>
<p>A <code>character</code> value informing a subset name.</p>
</td></tr>
<tr><td><code id="subset_handling_functions_+3A_expr">expr</code></td>
<td>
<p>A valid piece of code in R inside curly braces. This
code is evaluated to generate a subset.</p>
</td></tr>
<tr><td><code id="subset_handling_functions_+3A_s">s</code>, <code id="subset_handling_functions_+3A_s1">s1</code>, <code id="subset_handling_functions_+3A_s2">s2</code></td>
<td>
<p>Either a <code>ref_sf</code>, a <code>seg_sf</code>, or a <code>subset_sf</code> object.</p>
</td></tr>
<tr><td><code id="subset_handling_functions_+3A_return_index">return_index</code></td>
<td>
<p>A <code>logical</code> value indicating if the corresponding rows
in <code>s1</code> should be returned instead of the actual corresponding values
of <code>s2</code>.</p>
</td></tr>
<tr><td><code id="subset_handling_functions_+3A_by">by</code></td>
<td>
<p>A <code>character</code> value with the column to group.</p>
</td></tr>
<tr><td><code id="subset_handling_functions_+3A_fn">fn</code></td>
<td>
<p>A <code>function</code> to apply on each group.</p>
</td></tr>
<tr><td><code id="subset_handling_functions_+3A_...">...</code></td>
<td>
<p>For <code>sm_group_by()</code>, extra parameter to pass to
<code>fn</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>sm_list()</code>: Return a <code>character</code> vector with all names of subsets stored
in the <code>segmetric</code> object.
</p>
</li>
<li> <p><code>sm_exists()</code>: Return a <code>logical</code> value indicating if a given subset name is
stored in the <code>segmetric</code> object.
</p>
</li>
<li> <p><code>sm_subset()</code>: Return a <code>subset_sf</code> object.
</p>
</li>
<li> <p><code>sm_indirect()</code>: Return the subset name of a given <code>subset_sf</code> object
stored in a <code>segmetric</code> object.
</p>
</li>
<li> <p><code>sm_segmetric()</code>: Return a <code>segmetric</code> object that stores a given
<code>subset_sf</code> object.
</p>
</li>
<li> <p><code>sm_get()</code>: Return a <code>subset_sf</code> object stored in a <code>segmetric</code> object.
</p>
</li>
<li> <p><code>sm_inset()</code>: Return either a <code>subset_sf</code> object or an <code>integer</code> vector
with the index of corresponding rows of <code>s2</code> object.
</p>
</li>
<li> <p><code>sm_group_by()</code>: Return a <code>subset_sf</code> object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># load sample datasets
data("sample_ref_sf", package = "segmetric")
data("sample_seg_sf", package = "segmetric")

# create segmetric object
m &lt;- sm_read(ref_sf = sample_ref_sf, seg_sf = sample_seg_sf)

# lists only 'ref_sf' and 'seg_sf'
sm_list(m)

# computes 'Y_tilde' subset and stores it as 'test_subset' subset id
# sm_ytilde(m) also stores a subset under 'Y_tilde' id
s &lt;- sm_subset(m, "test_subset", sm_ytilde(m))

# lists 'ref_sf', 'seg_sf', 'test_subset', and 'Y_tilde'
sm_list(m)

# which segmetric object stores `s` subset?
m2 &lt;- sm_segmetric(s)

# m is identical to m2
identical(m, m2)

# which name `s` subset is stored in `m` segmetric object?
sm_indirect(s)

# retrieve 'test_subset' data from `m` object
s2 &lt;- sm_get(m, 'test_subset')

# s is identical to s2
identical(s, s2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
