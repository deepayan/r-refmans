<!DOCTYPE html><html><head><title>Help for package electoral</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {electoral}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#competitiveness'><p>Electoral Competitiveness</p></a></li>
<li><a href='#concentration'><p>Electoral Concentration</p></a></li>
<li><a href='#enp'><p>Effective Number of Parties (ENP)</p></a></li>
<li><a href='#pns'><p>Party Nationalization Score (PNS)</p></a></li>
<li><a href='#psns'><p>Party System Nationalization Score (PSNS)</p></a></li>
<li><a href='#seats'><p>Allocating Seats by any method</p></a></li>
<li><a href='#seats_ha'><p>Allocating Seats - Highest Averages</p></a></li>
<li><a href='#seats_lr'><p>Allocating Seats - Largest Remainders</p></a></li>
<li><a href='#volatility'><p>Electoral Volatility</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Allocating Seats Methods and Party System Scores</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Jorge Albuja</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jorge Albuja &lt;albuja@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Highest averages &amp; largest remainders allocating seats methods and
    several party system scores.
    Implemented highest averages allocating seats methods are D'Hondt, Webster,
    Danish, Imperiali, Hill-Huntington, Dean, Modified Sainte-Lague,
    equal proportions and Adams.
    Implemented largest remainders allocating seats methods are Hare, Droop,
    Hangenbach-Bischoff, Imperial, modified Imperial and quotas &amp; remainders.
    The main advantage of this package is that ties are always reported
    and not incorrectly allocated.
    Party system scores provided are competitiveness, concentration,
    effective number of parties, party nationalization score,
    party system nationalization score and volatility.
    References:
    Gallagher (1991) &lt;<a href="https://doi.org/10.1016%2F0261-3794%2891%2990004-C">doi:10.1016/0261-3794(91)90004-C</a>&gt;.
    Norris (2004, ISBN:0-521-82977-1).
    Consejo Nacional Electoral del Ecuador (2014)<a href="http://cne.gob.ec/documents/Estadisticas/Atlas/ATLAS/CAPITULO%206%20web.pdf">http://cne.gob.ec/documents/Estadisticas/Atlas/ATLAS/CAPITULO%206%20web.pdf</a>.
    Laakso &amp; Taagepera (1979) <a href="https://journals.sagepub.com/doi/pdf/10.1177/001041407901200101">https://journals.sagepub.com/doi/pdf/10.1177/001041407901200101</a>.
    Jones &amp; Mainwaring (2003) <a href="https://kellogg.nd.edu/sites/default/files/old_files/documents/304_0.pdf">https://kellogg.nd.edu/sites/default/files/old_files/documents/304_0.pdf</a>.
    Pedersen (1979) <a href="https://janda.org/c24/Readings/Pedersen/Pedersen.htm">https://janda.org/c24/Readings/Pedersen/Pedersen.htm</a>.
    Golosov (2010) <a href="https://ppq.sagepub.com/content/16/2/171.abstract">https://ppq.sagepub.com/content/16/2/171.abstract</a>.
    Golosov (2014) <a href="https://ppq.sagepub.com/content/early/2014/09/08/1354068814549342.abstract">https://ppq.sagepub.com/content/early/2014/09/08/1354068814549342.abstract</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ineq, tibble</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-31 22:06:10 UTC; jorgea</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-31 22:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='competitiveness'>Electoral Competitiveness</h2><span id='topic+competitiveness'></span>

<h3>Description</h3>

<p>Electoral competitiveness measures the difference in the percentages of valid votes obtained by the two most voted parties in a given territorial unit. It identifies the level of rivalry between the parties who occupied the first and second places in an election. Consejo Nacional Electoral del Ecuador (2014).
The formula is:
</p>
<p style="text-align: center;"><code class="reqn">Competitiveness = 1 - (p1 - p2)</code>
</p>

<p>where p1 and p2 are the 2 votes o seats proportions for the 2 most voted parties. Thus, it requires elections with at least 2 parties.
</p>
<p>The index is a number from 0 to 1, 0 means no competitiveness (p1 = 1 and p2 = 0) and 1 means maximum competitiveness (p1 = p2).
</p>
<p>Developed by Jorge Albuja Delgado (albuja@yahoo.com).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>competitiveness(votes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="competitiveness_+3A_votes">votes</code></td>
<td>
<p>2_or_more-length vector of number/share of votes/seats per party</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric with electoral competitiveness value in the interval [0, 1]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>competitiveness(votes = c(100, 150, 60))
</code></pre>

<hr>
<h2 id='concentration'>Electoral Concentration</h2><span id='topic+concentration'></span>

<h3>Description</h3>

<p>Electoral concentration is a measure of the accumulation of votes in the two most voted parties of a given territorial unit. It is the cumulative fraction of valid votes obtained by the two most voted parties in a given election (Consejo Nacional Electoral - Ecuador, 2014).
</p>
<p>The formula is:
</p>
<p style="text-align: center;"><code class="reqn">concentration = p1 + p2</code>
</p>

<p>where p1 is the vote/seat proportion for the most voted party,
and p2 is the vote/seat proportion for the second most voted party.
Thus, it requires elections with at least 2 parties.
</p>
<p>The index is a number positive up to 1. A value of 1 means maximum concentration (p1 + p2 = 1, i.e. pi = 0 for i = 3,4...)
</p>
<p>Developed by Jorge Albuja Delgado (albuja@yahoo.com).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration(votes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration_+3A_votes">votes</code></td>
<td>
<p>2_or_more-length vector of number o proportion of votes/seats per party</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric with concentration value in the interval (0, 1].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>concentration(votes = c(100, 150, 60))
</code></pre>

<hr>
<h2 id='enp'>Effective Number of Parties (ENP)</h2><span id='topic+enp'></span>

<h3>Description</h3>

<p>Computes the effective number of parties. The effective number of parties is a concept introduced by Laakso and Taagepera (1979) which provides for an adjusted number of political parties in a country&quot;s party system. The idea behind this measure is to count parties and, at the same time, to weight the count by their relative strength.
</p>
<p>Measuring how many parties, weighted according to size, are in a party system in a given election, the effective number of (electoral/legislative) parties is calculated employing the following formula:
</p>
<p style="text-align: center;"><code class="reqn">ENP = 1 / sum(pi^2)</code>
</p>

<p>where pi is the share of votes/seats of the ith party.
</p>
<p>A new approach developed by Golosov, Grigorii V. &quot;The Effective Number of Parties: A New Approach&quot; (2010) (http://ppq.sagepub.com/content/16/2/171.abstract) is also available.  
</p>
<p>Developed by Jorge Albuja Delgado (albuja@yahoo.com).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enp(votes, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enp_+3A_votes">votes</code></td>
<td>
<p>vector of number/share of votes/seats per party</p>
</td></tr>
<tr><td><code id="enp_+3A_method">method</code></td>
<td>
<p>string to choose from c(&quot;Laakso-Taagepera&quot;, &quot;Golosov&quot;). Defaults to &quot;Laakso-Taagepera&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
A single numeric with the effective number of parties (ENP) value.
=======
A single numeric with the effective number of parties value.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1e569c45b115684281e88833fa245b2c223ee30a
</p>


<h3>Examples</h3>

<pre><code class='language-R'>enp(votes = c(94545, 74162, 25273))
enp(votes = c(94545, 74162, 25273), "Golosov")
</code></pre>

<hr>
<h2 id='pns'>Party Nationalization Score (PNS)</h2><span id='topic+pns'></span>

<h3>Description</h3>

<p>Party nationalization score is a measure for the uniformity of vote share of a party over subnational units (provinces for Ecuador).  It is computed as 1 minus Gini inequality index (Jones and Mainwaring, 2003)
</p>
<p style="text-align: center;"><code class="reqn">PNS = 1 - G</code>
</p>

<p style="text-align: center;"><code class="reqn">G = (2*sum(i*xi)) / (n*sum(xi)) - (n + 1)/n</code>
</p>

<p>in which G is the Gini inequality index,
xi is the vote share in the province ith, indexed in non-decreasing order (xi &lt;= xi+1)
i is an index from 1 to n
n is the total of provinces
</p>
<p>Party nationalization score is a number from 0 to 1, a low value (near 0) means a low level of nationalization, i.e. heterogeneous distribution of vote shares in subnational territorial units.
</p>
<p>High score (near 1) indicates a high level of nationalization, i.e. homogeneous distribution of vote shares in subnational territorial units.
</p>
<p>A new approach developed by Golosov (2014) 'Party System Nationalization: The Problems of Measurement with an Application to Federal States' (http://ppq.sagepub.com/content/early/2014/09/08/1354068814549342.abstract) is also available.  
</p>
<p>See <code><a href="#topic+psns">psns</a></code> function for further information.
</p>
<p>Developed by Jorge Albuja Delgado (albuja@yahoo.com).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pns(subnational_shares, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pns_+3A_subnational_shares">subnational_shares</code></td>
<td>
<p>vector of vote shares per subnational unit (province) for a single party</p>
</td></tr>
<tr><td><code id="pns_+3A_method">method</code></td>
<td>
<p>string to choose from c('Jones-Mainwaring', 'Golosov'). Defaults to 'Jones-Mainwaring'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric with party nationalization score of a party, in the interval [0, 1]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pns(subnational_shares = c(0.467265, 0.542505))
pns(subnational_shares = c(0.467265, 0.542505), method = 'Golosov')
</code></pre>

<hr>
<h2 id='psns'>Party System Nationalization Score (PSNS)</h2><span id='topic+psns'></span>

<h3>Description</h3>

<p>Party System Nationalization Score is a measure for the uniformity of vote share of a party system over subnational units (provinces for Ecuador).  It is computed as the sum of part nationalization scores, weighted by the national share of every party (Jones and Mainwaring, 2003).
</p>
<p style="text-align: center;"><code class="reqn">PSNS = sum(PNSi*pi)</code>
</p>

<p>where PNSi is the party nationalization score for party ith,
and pi is the national vote share for party ith.
</p>
<p>Party system nationalization score is a number from 0 to 1, low value (near 0) means a low level of nationalization, i.e. heterogeneous distribution of vote shares in subnational territorial units.
</p>
<p>High score (near 1) indicates a high level of nationalization, i.e. homogeneous distribution of vote shares in subnational territorial units.
</p>
<p>A new approach developed by Golosov (2014) 'Party System Nationalization: The Problems of Measurement with an Application to Federal States' (http://ppq.sagepub.com/content/early/2014/09/08/1354068814549342.abstract) is also available.  
</p>
<p>Input tibble must have 3 columns with fixed names: 'PROVINCE', 'PARTY and 'VOTES'.
</p>
<p>See <code><a href="#topic+pns">pns</a></code> function for further information.
</p>
<p>Developed by Jorge Albuja Delgado (albuja@yahoo.com).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psns(tidy_votes, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psns_+3A_tidy_votes">tidy_votes</code></td>
<td>
<p>a tibble/data.frame in tidy format with 3 variables (columns): 'PROVINCE', 'PARTY' and 'VOTES', where:
</p>

<ol>
<li><p> PROVINCE: names or codes of subnational units.
</p>
</li>
<li><p> PARTY: names or codes of national parties.
</p>
</li>
<li><p> VOTES: number of votes for every PARTY in every PROVINCE.
</p>
</li></ol>

</td></tr>
<tr><td><code id="psns_+3A_method">method</code></td>
<td>
<p>string to choose from c('Jones-Mainwaring', 'Golosov'). Defaults to 'Jones-Mainwaring'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric with Party System Nationalization Score (PSNS) in the interval [0, 1]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(PROVINCE = c(1, 1, 1, 2, 2, 2),
               PARTY = c('1', '2', '3',  '1', '2', '3'),
               VOTES = c(66389, 55372, 20319, 28156, 18790, 4954))
psns(data)
psns(data, method = 'Golosov')
</code></pre>

<hr>
<h2 id='seats'>Allocating Seats by any method</h2><span id='topic+seats'></span>

<h3>Description</h3>

<p>This function is a wrapper for seats_ha and seats_lr functions. A shortcut to allocate seats by any method selected by its string name.
</p>
<p>Developed by Jorge Albuja Delgado (albuja@yahoo.com).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seats(parties, votes, n_seats, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seats_+3A_parties">parties</code></td>
<td>
<p>vector of names of parties, must be uniques</p>
</td></tr>
<tr><td><code id="seats_+3A_votes">votes</code></td>
<td>
<p>vector of votes, same length as parties.</p>
</td></tr>
<tr><td><code id="seats_+3A_n_seats">n_seats</code></td>
<td>
<p>number of seats to be allocated (integer equal or greater 1).</p>
</td></tr>
<tr><td><code id="seats_+3A_method">method</code></td>
<td>
<p>string according seat allocating method:  &quot;dhondt&quot;, &quot;webster&quot;, &quot;danish&quot;, &quot;imperiali&quot;, &quot;hill-huntington&quot;, &quot;dean&quot;, &quot;mod-saint-lague&quot;, &quot;equal-proportions&quot;, &quot;adams&quot;, &quot;hare&quot;, &quot;droop&quot;, &quot;hangenbach-bischoff&quot;, &quot;imperial&quot;, &quot;mod-imperial&quot; or &quot;quotas-remainders&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seats(parties = c("A", "B", "C"),
       votes = c(100, 150, 60),
       n_seats = 5,
       method = "hare")

seats(parties = c("V", "W", "X", "Y", "Z"),
      votes = c(100, 150, 60, 80, 160),
      n_seats = 15,
      method = "droop")
      
seats(parties = c("A", "B", "C"),
       votes = c(100, 150, 60),
       n_seats = 5,
       method = "dhondt")

seats(parties = c("V", "W", "X", "Y", "Z"),
      votes = c(100, 150, 60, 80, 160),
      n_seats = 15,
      method = "webster")
</code></pre>

<hr>
<h2 id='seats_ha'>Allocating Seats - Highest Averages</h2><span id='topic+seats_ha'></span>

<h3>Description</h3>

<p>Highest averages is the name for a variety of ways to allocate seats proportionally for representative assemblies with party list voting systems. It requires the number of votes for each party to be divided successively by a series of divisors. This produces a table of quotients, or averages, with a row for each divisor and a column for each party. The nth seat is allocated to the party whose column contains the nth largest entry in this table, up to the total number of seats available. Different methods uses different series of divisors:
</p>
<p>If there are n_seats seats to allocate these methods requires n_seats divisors (from 1 to n_seats), being the nth divisor:
</p>
<p>D'Hondt: n
</p>
<p>Webster: 2 * n - 1
</p>
<p>Danish: 3 * n - 2
</p>
<p>Imperiali: n + 1
</p>
<p>Hill-Huntington: sqrt(n * (n + 1))
</p>
<p>Dean: (2 * n) * (n + 1) / (2 * n + 1)
</p>
<p>Modified Sainte-Lague: (10 * n - 5) / 7
</p>
<p>Equal proportions: sqrt(n * (n - 1))
</p>
<p>Adams: n - 1
</p>
<p>In case of ties, the implemented algorithm not allocate the involved seats, and prints how many seats had been allocated and how many are in tie.
</p>
<p>More information: https://en.wikipedia.org/wiki/Highest_averages_method
</p>
<p>Developed by Jorge Albuja Delgado (albuja@yahoo.com).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seats_ha(parties, votes, n_seats, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seats_ha_+3A_parties">parties</code></td>
<td>
<p>vector of names of parties, must be uniques</p>
</td></tr>
<tr><td><code id="seats_ha_+3A_votes">votes</code></td>
<td>
<p>vector of votes, same length as parties.</p>
</td></tr>
<tr><td><code id="seats_ha_+3A_n_seats">n_seats</code></td>
<td>
<p>number of seats to be allocated (integer equal or greater 1).</p>
</td></tr>
<tr><td><code id="seats_ha_+3A_method">method</code></td>
<td>
<p>string according seat allocating method: &quot;dhondt&quot;, &quot;webster&quot;, &quot;danish&quot;, &quot;imperiali&quot;, &quot;hill-huntington&quot;, &quot;dean&quot;, &quot;mod-saint-lague&quot;, &quot;equal-proportions&quot; or &quot;adams&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the number seats allocated for each party in &quot;parties&quot;, with the same length as parties and votes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seats_ha(parties = c("A", "B", "C"),
       votes = c(100, 150, 60),
       n_seats = 5,
       method = "dhondt")

seats_ha(parties = c("V", "W", "X", "Y", "Z"),
      votes = c(100, 150, 60, 80, 160),
      n_seats = 15,
      method = "webster")
</code></pre>

<hr>
<h2 id='seats_lr'>Allocating Seats - Largest Remainders</h2><span id='topic+seats_lr'></span>

<h3>Description</h3>

<p>Largest remainders methods require the numbers of votes for each party to be divided by a quota representing the number of votes required for a seat (i.e. usually the total number of votes cast divided by the number of seats, or some similar formula). The result for each party will usually consist of an integer part plus a fractional remainder. Each party is first allocated a number of seats equal to their integer. This will generally leave some seats unallocated: the parties are then ranked on the basis of the fractional remainders, and the parties with the largest remainders are each allocated one additional seat until all the seats have been allocated. This gives the method its name. The quota formula for each largest remainder method is:
</p>
<p>Hare: (sum(votes))/n_seats
</p>
<p>Droop: (sum(votes))/(n_seats + 1) + 1
</p>
<p>Hangenbach Bischoff: (sum(votes))/(n_seats + 1)
</p>
<p>Imperial: (sum(votes))/(n_seats + 2)
</p>
<p>Modified Imperial: (sum(votes))/(n_seats + 3)
</p>
<p>Quotas &amp; remainders:
</p>

<ol>
<li><p> threshold: select all parties that meet votes_i &gt;= (sum(votes))/(2*n_seats)
</p>
</li>
<li><p> quota: (sum(votes))/n_seats  (only over selected parties)
</p>
</li></ol>

<p>In case of ties, the implemented algorithm not allocate the involved seats, and prints how many seats had been allocated and how many are in tie.
</p>
<p>More information: https://en.wikipedia.org/wiki/Largest_remainder_method
</p>
<p>Developed by Jorge Albuja Delgado (albuja@yahoo.com).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seats_lr(parties, votes, n_seats, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seats_lr_+3A_parties">parties</code></td>
<td>
<p>vector of names of parties, must be uniques</p>
</td></tr>
<tr><td><code id="seats_lr_+3A_votes">votes</code></td>
<td>
<p>vector of votes, same length as parties.</p>
</td></tr>
<tr><td><code id="seats_lr_+3A_n_seats">n_seats</code></td>
<td>
<p>number of seats to be allocated (integer equal or greater 1).</p>
</td></tr>
<tr><td><code id="seats_lr_+3A_method">method</code></td>
<td>
<p>string according seat allocating method: &quot;hare&quot;, &quot;droop&quot;, &quot;hangenbach-bischoff&quot;, &quot;imperial&quot;, &quot;mod-imperial&quot; or &quot;quotas-remainders&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the number seats allocated for each party.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seats_lr(parties = c("A", "B", "C"),
       votes = c(100, 150, 60),
       n_seats = 5,
       method = "hare")

seats_lr(parties = c("V", "W", "X", "Y", "Z"),
      votes = c(100, 150, 60, 80, 160),
      n_seats = 15,
      method = "droop")
</code></pre>

<hr>
<h2 id='volatility'>Electoral Volatility</h2><span id='topic+volatility'></span>

<h3>Description</h3>

<p>Defined as the net change within the electoral party system resulting from individual vote transfers, electoral volatility is measured according to the following formula:
</p>
<p style="text-align: center;"><code class="reqn">Volatility = sum|pi,t-1 - pi,t| / 2</code>
</p>

<p>in which pi,t is the vote/seat share for the party ith at a given election (t) and pi,t-1 is the vote/seat share of the same party ith at the previous elections (t-1) (Pedersen, 1979).
</p>
<p>The index is a number from 0 to 1, 0 means no volatility (proportion of votes/seats remains constant for every party) and 1 means total volatility (every party pass from 0 to any votes or viceversa).
</p>
<p>Developed by Jorge Albuja Delgado (albuja@yahoo.com).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volatility(votes_1, votes_2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volatility_+3A_votes_1">votes_1</code></td>
<td>
<p>vector of number/share of votes/seats per party at time t-1 (previous election)</p>
</td></tr>
<tr><td><code id="volatility_+3A_votes_2">votes_2</code></td>
<td>
<p>vector of number/share of votes/seats per party at time t (given election</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric with volatility value in the interval [0, 1]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>volatility(votes_1 = c(100, 150, 60),
           votes_2 = c(80, 120, 100))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
