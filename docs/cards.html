<!DOCTYPE html><html lang="en-US"><head><title>Help for package cards</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cards}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cards-package'><p>cards: Analysis Results Data</p></a></li>
<li><a href='#.calculate_stats_as_ard'><p>Calculate Continuous Statistics</p></a></li>
<li><a href='#.calculate_tabulation_statistics'><p>Calculate Tabulation Statistics</p></a></li>
<li><a href='#.check_dichotomous_value'><p>Perform Value Checks</p></a></li>
<li><a href='#.check_fmt_string'><p>Check 'xx' Format Structure</p></a></li>
<li><a href='#.check_for_missing_combos_in_denom'><p>Check for Missing Levels in <code>denominator</code></p></a></li>
<li><a href='#.check_no_ard_columns'><p>Check Protected Column Names</p></a></li>
<li><a href='#.check_var_nms'><p>Check Variable Names</p></a></li>
<li><a href='#.cli_condition_messaging'><p>Print Condition Messages Saved in an ARD</p></a></li>
<li><a href='#.cli_groups_and_variable'><p>Locate Condition Messages in an ARD</p></a></li>
<li><a href='#.create_list_for_attributes'><p>Create List for Attributes</p></a></li>
<li><a href='#.default_fmt_fn'><p>Add Default Formatting Functions</p></a></li>
<li><a href='#.detect_msgs'><p>Detect Columns with Non-Null Contents</p></a></li>
<li><a href='#.eval_ard_calls'><p>Evaluate the <code style="white-space: pre;">&#8288;ard_*()&#8288;</code> function calls</p></a></li>
<li><a href='#.fill_grps_from_variables'><p>Back Fill Group Variables</p></a></li>
<li><a href='#.fill_overall_grp_values'><p>Fill Overall Group Variables</p></a></li>
<li><a href='#.is_list_column_of_scalars'><p>List Column as a Vector Predicate</p></a></li>
<li><a href='#.is_named_list'><p>Named List Predicate</p></a></li>
<li><a href='#.lst_results_as_df'><p>Prepare Results as Data Frame</p></a></li>
<li><a href='#.nesting_rename_ard_columns'><p>Rename ARD Columns</p></a></li>
<li><a href='#.one_row_ard_to_nested_list'><p>Convert One Row to Nested List</p></a></li>
<li><a href='#.pair_columns'><p>Pair columns</p></a></li>
<li><a href='#.process_denominator'><p>Process <code>denominator</code> Argument</p></a></li>
<li><a href='#.process_nested_list_as_df'><p>Convert Nested Lists to Column</p></a></li>
<li><a href='#.purrr_list_flatten'><p>A list_flatten()-like Function</p></a></li>
<li><a href='#.rename_last_group_as_variable'><p>Rename Last Group to Variable</p></a></li>
<li><a href='#.shift_column_pair'><p>Shift column pair</p></a></li>
<li><a href='#.table_as_df'><p>Results from <code>table()</code> as Data Frame</p></a></li>
<li><a href='#.trim_ard'><p>Trim ARD</p></a></li>
<li><a href='#.unique_and_sorted'><p>ARD-flavor of unique()</p></a></li>
<li><a href='#adam'><p>Example ADaM Data</p></a></li>
<li><a href='#add_calculated_row'><p>Add Calculated Row</p></a></li>
<li><a href='#alias_as_fmt_fn'><p>Convert Alias to Function</p></a></li>
<li><a href='#apply_fmt_fn'><p>Apply Formatting Functions</p></a></li>
<li><a href='#ard_attributes'><p>ARD Attributes</p></a></li>
<li><a href='#ard_categorical'><p>Categorical ARD Statistics</p></a></li>
<li><a href='#ard_complex'><p>Complex ARD Summaries</p></a></li>
<li><a href='#ard_continuous'><p>Continuous ARD Statistics</p></a></li>
<li><a href='#ard_dichotomous'><p>Dichotomous ARD Statistics</p></a></li>
<li><a href='#ard_hierarchical'><p>Hierarchical ARD Statistics</p></a></li>
<li><a href='#ard_missing'><p>Missing ARD Statistics</p></a></li>
<li><a href='#ard_pairwise'><p>Pairwise ARD</p></a></li>
<li><a href='#ard_stack'><p>Stack ARDs</p></a></li>
<li><a href='#ard_stack_hierarchical'><p>Stacked Hierarchical ARD Statistics</p></a></li>
<li><a href='#ard_strata'><p>Stratified ARD</p></a></li>
<li><a href='#ard_total_n'><p>ARD Total N</p></a></li>
<li><a href='#as_card'><p>Data Frame as ARD</p></a></li>
<li><a href='#as_cards_fn'><p>As card function</p></a></li>
<li><a href='#as_nested_list'><p>ARD as Nested List</p></a></li>
<li><a href='#bind_ard'><p>Bind ARDs</p></a></li>
<li><a href='#cards.options'><p>Options in {cards}</p></a></li>
<li><a href='#check_ard_structure'><p>Check ARD Structure</p></a></li>
<li><a href='#default_stat_labels'><p>Defaults for Statistical Arguments</p></a></li>
<li><a href='#deprecated'><p>Deprecated functions</p></a></li>
<li><a href='#eval_capture_conditions'><p>Evaluate and Capture Conditions</p></a></li>
<li><a href='#get_ard_statistics'><p>ARD Statistics as List</p></a></li>
<li><a href='#label_round'><p>Generate Formatting Function</p></a></li>
<li><a href='#maximum_variable_value'><p>Maximum Value</p></a></li>
<li><a href='#mock'><p>Mock ARDs</p></a></li>
<li><a href='#nest_for_ard'><p>ARD Nesting</p></a></li>
<li><a href='#print_ard_conditions'><p>Print ARD Condition Messages</p></a></li>
<li><a href='#print.card'><p>Print</p></a></li>
<li><a href='#process_selectors'><p>Process tidyselectors</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rename_ard_columns'><p>Rename ARD Columns</p></a></li>
<li><a href='#rename_ard_groups'><p>Rename ARD Group Columns</p></a></li>
<li><a href='#replace_null_statistic'><p>Replace NULL Statistics with Specified Value</p></a></li>
<li><a href='#round5'><p>Rounding of Numbers</p></a></li>
<li><a href='#selectors'><p>ARD Selectors</p></a></li>
<li><a href='#shuffle_ard'><p>Shuffle ARD</p></a></li>
<li><a href='#summary_functions'><p>Summary Functions</p></a></li>
<li><a href='#syntax'><p>Selecting Syntax</p></a></li>
<li><a href='#tidy_ard_order'><p>Standard Order of ARD</p></a></li>
<li><a href='#tidy_as_ard'><p>Build ARD from Tidier</p></a></li>
<li><a href='#update_ard'><p>Update ARDs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Analysis Results Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Construct CDISC (Clinical Data Interchange Standards
    Consortium) compliant Analysis Results Data objects. These objects are
    used and re-used to construct summary tables, visualizations, and
    written reports. The package also exports utilities for working with
    these objects and creating new Analysis Results Data objects.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/insightsengineering/cards">https://github.com/insightsengineering/cards</a>,
<a href="https://insightsengineering.github.io/cards/">https://insightsengineering.github.io/cards/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/insightsengineering/cards/issues">https://github.com/insightsengineering/cards/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.6.1), dplyr (&ge; 1.1.2), glue (&ge; 1.6.2), lifecycle
(&ge; 1.0.3), rlang (&ge; 1.1.1), tidyr (&ge; 1.3.0), tidyselect (&ge;
1.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.2.0), withr (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/Needs/coverage:</td>
<td>hms</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown, jsonlite, yaml, gtsummary, tfrmt,
cardx, gt, fontawesome, insightsengineering/nesttemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-01 06:03:01 UTC; sjobergd</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel D. Sjoberg <a href="https://orcid.org/0000-0003-0862-2018"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Becca Krouse [aut],
  Emily de la Rua [aut],
  F. Hoffmann-La Roche AG [cph, fnd],
  GlaxoSmithKline Research &amp; Development Limited [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel D. Sjoberg &lt;danield.sjoberg@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-01 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cards-package'>cards: Analysis Results Data</h2><span id='topic+cards'></span><span id='topic+cards-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Construct CDISC (Clinical Data Interchange Standards Consortium) compliant Analysis Results Data objects. These objects are used and re-used to construct summary tables, visualizations, and written reports. The package also exports utilities for working with these objects and creating new Analysis Results Data objects.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Daniel D. Sjoberg <a href="mailto:danield.sjoberg@gmail.com">danield.sjoberg@gmail.com</a> (<a href="https://orcid.org/0000-0003-0862-2018">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Becca Krouse <a href="mailto:becca.z.krouse@gsk.com">becca.z.krouse@gsk.com</a>
</p>
</li>
<li><p> Emily de la Rua <a href="mailto:emily.de_la_rua@contractors.roche.com">emily.de_la_rua@contractors.roche.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> F. Hoffmann-La Roche AG [copyright holder, funder]
</p>
</li>
<li><p> GlaxoSmithKline Research &amp; Development Limited [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/insightsengineering/cards">https://github.com/insightsengineering/cards</a>
</p>
</li>
<li> <p><a href="https://insightsengineering.github.io/cards/">https://insightsengineering.github.io/cards/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/insightsengineering/cards/issues">https://github.com/insightsengineering/cards/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.calculate_stats_as_ard'>Calculate Continuous Statistics</h2><span id='topic+.calculate_stats_as_ard'></span>

<h3>Description</h3>

<p>Calculate statistics and return in an ARD format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.calculate_stats_as_ard(
  df_nested,
  variables,
  statistic,
  by,
  strata,
  data,
  new_col_name = "...ard_all_stats..."
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".calculate_stats_as_ard_+3A_df_nested">df_nested</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a nested data frame</p>
</td></tr>
<tr><td><code id=".calculate_stats_as_ard_+3A_variables">variables</code></td>
<td>
<p>(<code>character</code>)<br />
character vector of variables</p>
</td></tr>
<tr><td><code id=".calculate_stats_as_ard_+3A_statistic">statistic</code></td>
<td>
<p>(named <code>list</code>)<br />
named list of statistical functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_nested &lt;- ADSL |&gt;
  nest_for_ard(
    by = "ARM",
    strata = NULL,
    key = "...ard_nested_data..."
  )

cards:::.calculate_stats_as_ard(
  df_nested = data_nested,
  variables = "AGE",
  statistic = list(mean = "mean"),
  by = "ARM",
  strata = NULL,
  data = ADSL
)
</code></pre>

<hr>
<h2 id='.calculate_tabulation_statistics'>Calculate Tabulation Statistics</h2><span id='topic+.calculate_tabulation_statistics'></span>

<h3>Description</h3>

<p>Function takes the summary instructions from the
<code>statistic = list(variable_name = list(tabulation=c("n", "N", "p")))</code>
argument, and returns the tabulations in an ARD structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.calculate_tabulation_statistics(
  data,
  variables,
  by,
  strata,
  denominator,
  statistic
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".calculate_tabulation_statistics_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".calculate_tabulation_statistics_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to include in summaries. Default is <code>everything()</code>.</p>
</td></tr>
<tr><td><code id=".calculate_tabulation_statistics_+3A_by">by</code>, <code id=".calculate_tabulation_statistics_+3A_strata">strata</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to use for grouping or stratifying the table output.
Arguments are similar, but with an important distinction:
</p>
<p><code>by</code>: results are tabulated by <strong>all combinations</strong> of the columns specified,
including unobserved combinations and unobserved factor levels.
</p>
<p><code>strata</code>: results are tabulated by <strong>all <em>observed</em> combinations</strong> of the
columns specified.
</p>
<p>Arguments may be used in conjunction with one another.</p>
</td></tr>
<tr><td><code id=".calculate_tabulation_statistics_+3A_denominator">denominator</code></td>
<td>
<p>(<code>string</code>, <code>data.frame</code>, <code>integer</code>)<br />
Specify this argument to change the denominator,
e.g. the <code>"N"</code> statistic. Default is <code>'column'</code>. See below for details.</p>
</td></tr>
<tr><td><code id=".calculate_tabulation_statistics_+3A_statistic">statistic</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element one or more of  <code>c("n", "N", "p", "n_cum", "p_cum")</code>
(on the RHS of a formula).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.calculate_tabulation_statistics(
  ADSL,
  variables = "ARM",
  by = NULL,
  strata = NULL,
  denominator = "cell",
  statistic = list(ARM = list(tabulation = c("N")))
)
</code></pre>

<hr>
<h2 id='.check_dichotomous_value'>Perform Value Checks</h2><span id='topic+.check_dichotomous_value'></span>

<h3>Description</h3>

<p>Check the validity of the values passed in <code>ard_dichotomous(value)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_dichotomous_value(data, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".check_dichotomous_value_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".check_dichotomous_value_+3A_value">value</code></td>
<td>
<p>(named <code>list</code>)<br />
a named list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns invisible if check is successful, throws an error message if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.check_dichotomous_value(mtcars, list(cyl = 4))
</code></pre>

<hr>
<h2 id='.check_fmt_string'>Check 'xx' Format Structure</h2><span id='topic+.check_fmt_string'></span>

<h3>Description</h3>

<p>A function that checks a <strong>single</strong> string for consistency.
String must begin with 'x' and only consist of x's, a single period or none,
and may end with a percent symbol.
</p>
<p>If string is consistent, <code>TRUE</code> is returned. Otherwise an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_fmt_string(x, variable, stat_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".check_fmt_string_+3A_x">x</code></td>
<td>
<p>(<code>string</code>)<br />
string to check</p>
</td></tr>
<tr><td><code id=".check_fmt_string_+3A_variable">variable</code></td>
<td>
<p>(<code>character</code>)<br /> the variable whose statistic is to be formatted</p>
</td></tr>
<tr><td><code id=".check_fmt_string_+3A_stat_name">stat_name</code></td>
<td>
<p>(<code>character</code>)<br /> the name of the statistic that is to be formatted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.check_fmt_string("xx.x") # TRUE
cards:::.check_fmt_string("xx.x%") # TRUE
</code></pre>

<hr>
<h2 id='.check_for_missing_combos_in_denom'>Check for Missing Levels in <code>denominator</code></h2><span id='topic+.check_for_missing_combos_in_denom'></span>

<h3>Description</h3>

<p>When a user passes a data frame in the <code>denominator</code> argument, this function
checks that the data frame contains all the same levels of the <code>by</code>
and <code>strata</code> variables that appear in <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_for_missing_combos_in_denom(data, denominator, by, strata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".check_for_missing_combos_in_denom_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".check_for_missing_combos_in_denom_+3A_denominator">denominator</code></td>
<td>
<p>(<code>data.frame</code>)<br />
denominator data frame</p>
</td></tr>
<tr><td><code id=".check_for_missing_combos_in_denom_+3A_by">by</code></td>
<td>
<p>(<code>character</code>)<br />
character vector of by column names</p>
</td></tr>
<tr><td><code id=".check_for_missing_combos_in_denom_+3A_strata">strata</code></td>
<td>
<p>(<code>character</code>)<br />
character vector of strata column names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns invisible if check is successful, throws an error message if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.check_for_missing_combos_in_denom(ADSL, denominator = "col", by = "ARM", strata = "AGEGR1")
</code></pre>

<hr>
<h2 id='.check_no_ard_columns'>Check Protected Column Names</h2><span id='topic+.check_no_ard_columns'></span>

<h3>Description</h3>

<p>Checks that column names in a passed data frame are not protected, that is,
they do not begin with <code>"...ard_"</code> and end with <code>"..."</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_no_ard_columns(x, exceptions = "...ard_dummy_for_counting...")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".check_no_ard_columns_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".check_no_ard_columns_+3A_exceptions">exceptions</code></td>
<td>
<p>(<code>string</code>)<br />
character string of column names to exclude from checks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns invisible if check is successful, throws an error message if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame("ard_x" = 1)

cards:::.check_no_ard_columns(data)
</code></pre>

<hr>
<h2 id='.check_var_nms'>Check Variable Names</h2><span id='topic+.check_var_nms'></span>

<h3>Description</h3>

<p>Checks variable names in a data frame against protected names and modifies
them if needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_var_nms(x, vars_protected)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".check_var_nms_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".check_var_nms_+3A_vars_protected">vars_protected</code></td>
<td>
<p>(<code>character</code>)<br />
a character vector of protected names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(a = "x", b = "y", c = "z", .cards_idx = 1)

cards:::.check_var_nms(data, vars_protected = c("x", "z"))
</code></pre>

<hr>
<h2 id='.cli_condition_messaging'>Print Condition Messages Saved in an ARD</h2><span id='topic+.cli_condition_messaging'></span>

<h3>Description</h3>

<p>Print Condition Messages Saved in an ARD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cli_condition_messaging(x, msg_type, condition_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cli_condition_messaging_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id=".cli_condition_messaging_+3A_msg_type">msg_type</code></td>
<td>
<p>(<code>string</code>)<br />
message type. Options are <code>"warning"</code> and <code>"error"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns invisible if check is successful, throws warning/error messages if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_continuous(
  ADSL,
  by = ARM,
  variables = AGE
)

cards:::.cli_condition_messaging(ard, msg_type = "error")
</code></pre>

<hr>
<h2 id='.cli_groups_and_variable'>Locate Condition Messages in an ARD</h2><span id='topic+.cli_groups_and_variable'></span>

<h3>Description</h3>

<p>Prints a string of all <code>group##</code>/<code>group##_level</code> column values and
<code>variable</code> column values where condition messages occur, formatted
using glue syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cli_groups_and_variable(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cli_groups_and_variable_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_continuous(
  ADSL,
  by = ARM,
  variables = AGE,
  statistic = ~ list(
    mean = \(x) mean(x),
    mean_warning = \(x) {
      warning("warn1")
      warning("warn2")
      mean(x)
    },
    err_fn = \(x) stop("'tis an error")
  )
)

cards:::.cli_groups_and_variable(ard)
</code></pre>

<hr>
<h2 id='.create_list_for_attributes'>Create List for Attributes</h2><span id='topic+.create_list_for_attributes'></span>

<h3>Description</h3>

<p>Create List for Attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.create_list_for_attributes(ard_subset, attributes, i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".create_list_for_attributes_+3A_ard_subset">ard_subset</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id=".create_list_for_attributes_+3A_attributes">attributes</code></td>
<td>
<p>(<code>character</code>)<br />
a character vector of attribute names</p>
</td></tr>
<tr><td><code id=".create_list_for_attributes_+3A_i">i</code></td>
<td>
<p>(<code>integer</code>)<br />
a row index number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_categorical(ADSL, by = "ARM", variables = "AGEGR1")

cards:::.create_list_for_attributes(ard, c("group1", "group1_level"), 1)
</code></pre>

<hr>
<h2 id='.default_fmt_fn'>Add Default Formatting Functions</h2><span id='topic+.default_fmt_fn'></span>

<h3>Description</h3>

<p>Add Default Formatting Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.default_fmt_fn(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".default_fmt_fn_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_categorical(ADSL, by = "ARM", variables = "AGEGR1") |&gt;
  dplyr::mutate(fmt_fn = NA)

cards:::.default_fmt_fn(ard)
</code></pre>

<hr>
<h2 id='.detect_msgs'>Detect Columns with Non-Null Contents</h2><span id='topic+.detect_msgs'></span>

<h3>Description</h3>

<p>Function looks for non-null contents in requested columns and notifies user
before removal. Specifically used for detecting messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.detect_msgs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".detect_msgs_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".detect_msgs_+3A_...">...</code></td>
<td>
<p>(<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>)<br />
columns to search within</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_continuous(
  ADSL,
  by = ARM,
  variables = AGE,
  statistic = ~ list(
    mean = \(x) mean(x),
    mean_warning = \(x) {
      warning("warn1")
      warning("warn2")
      mean(x)
    },
    err_fn = \(x) stop("'tis an error")
  )
)

cards:::.detect_msgs(ard, "warning", "error")
</code></pre>

<hr>
<h2 id='.eval_ard_calls'>Evaluate the <code style="white-space: pre;">&#8288;ard_*()&#8288;</code> function calls</h2><span id='topic+.eval_ard_calls'></span>

<h3>Description</h3>

<p>Evaluate the <code style="white-space: pre;">&#8288;ard_*()&#8288;</code> function calls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.eval_ard_calls(data, .by, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".eval_ard_calls_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".eval_ard_calls_+3A_.by">.by</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to tabulate by in the series of ARD function calls</p>
</td></tr>
<tr><td><code id=".eval_ard_calls_+3A_...">...</code></td>
<td>
<p>(<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>)<br />
Series of ARD function calls to be run and stacked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of ARD data frames of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.eval_ard_calls(
  data = ADSL,
  .by = "ARM",
  ard_categorical(variables = "AGEGR1"),
  ard_continuous(variables = "AGE")
)
</code></pre>

<hr>
<h2 id='.fill_grps_from_variables'>Back Fill Group Variables</h2><span id='topic+.fill_grps_from_variables'></span>

<h3>Description</h3>

<p>This function back fills the values of group variables using
variable/variable_levels. The back filling will occur if the value of the
<code>variable</code> column matches the name of a grouping variable, and the grouping
variable's value is <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.fill_grps_from_variables(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".fill_grps_from_variables_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  variable = c(rep("A", 3), rep("B", 2)),
  variable_level = 1:5,
  A = rep(NA, 5),
  B = rep(NA, 5)
)

cards:::.fill_grps_from_variables(data)
</code></pre>

<hr>
<h2 id='.fill_overall_grp_values'>Fill Overall Group Variables</h2><span id='topic+.fill_overall_grp_values'></span>

<h3>Description</h3>

<p>This function fills the missing values of grouping variables with &quot;Overall
<code style="white-space: pre;">&#8288;variable name&#8288;</code>&quot; where relevant. Specifically it will modify grouping values
from rows with likely overall calculations present (e.g. non-missing
variable/variable_level, 100 percent missing group variables, and evidence that the
<code>variable</code> has been computed by group in other rows). &quot;Overall&quot; values will
be populated only for grouping variables that have been used in other calculations
of the same variable and statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.fill_overall_grp_values(x, vars_protected)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".fill_overall_grp_values_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- dplyr::tibble(
  grp = c("AA", "AA", NA, "BB", NA),
  variable = c("A", "B", "A", "C", "C"),
  variable_level = c(1, 2, 1, 3, 3),
  A = rep(NA, 5),
  B = rep(NA, 5),
  .cards_idx = c(1:5)
)

cards:::.fill_overall_grp_values(data, vars_protected = ".cards_idx")
</code></pre>

<hr>
<h2 id='.is_list_column_of_scalars'>List Column as a Vector Predicate</h2><span id='topic+.is_list_column_of_scalars'></span>

<h3>Description</h3>

<p>A predicate function to check whether a column is a list and can be
represented as a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is_list_column_of_scalars(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".is_list_column_of_scalars_+3A_x">x</code></td>
<td>
<p>(<code>any</code>)<br />
column to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.is_list_column_of_scalars(as.list(1:5))
</code></pre>

<hr>
<h2 id='.is_named_list'>Named List Predicate</h2><span id='topic+.is_named_list'></span>

<h3>Description</h3>

<p>A predicate function to check whether input is a named list and <em>not</em> a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is_named_list(x, allow_df = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".is_named_list_+3A_x">x</code></td>
<td>
<p>(<code>any</code>)<br />
object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.is_named_list(list(a = 1:3))
</code></pre>

<hr>
<h2 id='.lst_results_as_df'>Prepare Results as Data Frame</h2><span id='topic+.lst_results_as_df'></span>

<h3>Description</h3>

<p>Function takes the results from <code><a href="#topic+eval_capture_conditions">eval_capture_conditions()</a></code>, which is a
named list, e.g. <code>list(result=, warning=, error=)</code>, and converts it to a data
frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lst_results_as_df(x, variable, fun_name, fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".lst_results_as_df_+3A_x">x</code></td>
<td>
<p>(named <code>list</code>)<br />
the result from <code><a href="#topic+eval_capture_conditions">eval_capture_conditions()</a></code></p>
</td></tr>
<tr><td><code id=".lst_results_as_df_+3A_variable">variable</code></td>
<td>
<p>(<code>string</code>)<br />
variable name of the results</p>
</td></tr>
<tr><td><code id=".lst_results_as_df_+3A_fun_name">fun_name</code></td>
<td>
<p>(<code>string</code>)<br />
name of function called to get results in <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msgs &lt;- eval_capture_conditions({
  warning("Warning 1")
  warning("Warning 2")
  letters[1:2]
})

cards:::.lst_results_as_df(msgs, "result", "mean")
</code></pre>

<hr>
<h2 id='.nesting_rename_ard_columns'>Rename ARD Columns</h2><span id='topic+.nesting_rename_ard_columns'></span>

<h3>Description</h3>

<p>If <code>variable</code> is provided, adds the standard <code>variable</code> column to <code>x</code>. If <code>by</code>/<code>strata</code> are
provided, adds the standard <code>group##</code> column(s) to <code>x</code> and renames the provided columns to
<code>group##_level</code> in <code>x</code>, where <code style="white-space: pre;">&#8288;##&#8288;</code> is determined by the column's position in <code>c(by, strata)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.nesting_rename_ard_columns(x, variable = NULL, by = NULL, strata = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".nesting_rename_ard_columns_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".nesting_rename_ard_columns_+3A_variable">variable</code></td>
<td>
<p>(<code>character</code>)<br />
name of <code>variable</code> column in <code>x</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id=".nesting_rename_ard_columns_+3A_by">by</code></td>
<td>
<p>(<code>character</code>)<br />
character vector of names of <code>by</code> columns in <code>x</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id=".nesting_rename_ard_columns_+3A_strata">strata</code></td>
<td>
<p>(<code>character</code>)<br />
character vector of names of <code>strata</code> columns in <code>x</code>. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- nest_for_ard(
  data =
    ADAE |&gt;
      dplyr::left_join(ADSL[c("USUBJID", "ARM")], by = "USUBJID") |&gt;
      dplyr::filter(AOCCSFL %in% "Y"),
  by = "ARM",
  strata = "AESOC",
  rename_columns = FALSE
)

cards:::.nesting_rename_ard_columns(ard, by = "ARM", strata = "AESOC")
</code></pre>

<hr>
<h2 id='.one_row_ard_to_nested_list'>Convert One Row to Nested List</h2><span id='topic+.one_row_ard_to_nested_list'></span>

<h3>Description</h3>

<p>Convert One Row to Nested List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.one_row_ard_to_nested_list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".one_row_ard_to_nested_list_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card' with one row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an expression that represents an element of a nested list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_continuous(mtcars, variables = mpg) |&gt;
  dplyr::filter(dplyr::row_number() %in% 1L) |&gt;
  apply_fmt_fn() |&gt;
  cards:::.one_row_ard_to_nested_list()
</code></pre>

<hr>
<h2 id='.pair_columns'>Pair columns</h2><span id='topic+.pair_columns'></span>

<h3>Description</h3>

<p>This function ingests an ARD object and finds pairs of columns based on those requested for coalescing/renaming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pair_columns(x, columns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".pair_columns_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".pair_columns_+3A_columns">columns</code></td>
<td>
<p>(<code>character</code>)<br />
all columns to consider for coalescing/renaming</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of column pairs (as character vectors)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_categorical(ADSL, by = "ARM", variables = "AGEGR1") |&gt;
  cards:::.pair_columns(columns = c("group1", "group1_level", "variable", "variable_level"))
</code></pre>

<hr>
<h2 id='.process_denominator'>Process <code>denominator</code> Argument</h2><span id='topic+.process_denominator'></span>

<h3>Description</h3>

<p>Function takes the <code>ard_categorical(denominator)</code> argument and returns a
structured data frame that is merged with the count data and used as the
denominator in percentage calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.process_denominator(data, variables, denominator, by, strata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".process_denominator_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".process_denominator_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to include in summaries. Default is <code>everything()</code>.</p>
</td></tr>
<tr><td><code id=".process_denominator_+3A_denominator">denominator</code></td>
<td>
<p>(<code>string</code>, <code>data.frame</code>, <code>integer</code>)<br />
Specify this argument to change the denominator,
e.g. the <code>"N"</code> statistic. Default is <code>'column'</code>. See below for details.</p>
</td></tr>
<tr><td><code id=".process_denominator_+3A_by">by</code>, <code id=".process_denominator_+3A_strata">strata</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to use for grouping or stratifying the table output.
Arguments are similar, but with an important distinction:
</p>
<p><code>by</code>: results are tabulated by <strong>all combinations</strong> of the columns specified,
including unobserved combinations and unobserved factor levels.
</p>
<p><code>strata</code>: results are tabulated by <strong>all <em>observed</em> combinations</strong> of the
columns specified.
</p>
<p>Arguments may be used in conjunction with one another.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.process_denominator(mtcars, denominator = 1000, variables = "cyl", by = "gear")
</code></pre>

<hr>
<h2 id='.process_nested_list_as_df'>Convert Nested Lists to Column</h2><span id='topic+.process_nested_list_as_df'></span>

<h3>Description</h3>

<p>Some arguments, such as <code>stat_label</code>, are passed as nested lists. This
function properly unnests these lists and adds them to the results data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.process_nested_list_as_df(x, arg, new_column, unlist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".process_nested_list_as_df_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
result data frame</p>
</td></tr>
<tr><td><code id=".process_nested_list_as_df_+3A_arg">arg</code></td>
<td>
<p>(<code>list</code>)<br />
the nested list</p>
</td></tr>
<tr><td><code id=".process_nested_list_as_df_+3A_new_column">new_column</code></td>
<td>
<p>(<code>string</code>)<br />
new column name</p>
</td></tr>
<tr><td><code id=".process_nested_list_as_df_+3A_unlist">unlist</code></td>
<td>
<p>(<code>logical</code>)<br />
whether to fully unlist final results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_categorical(ADSL, by = "ARM", variables = "AGEGR1")

cards:::.process_nested_list_as_df(ard, NULL, "new_col")
</code></pre>

<hr>
<h2 id='.purrr_list_flatten'>A list_flatten()-like Function</h2><span id='topic+.purrr_list_flatten'></span>

<h3>Description</h3>

<p>Function operates similarly to <code>purrr::list_flatten(x, name_spec = "{inner}")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.purrr_list_flatten(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".purrr_list_flatten_+3A_x">x</code></td>
<td>
<p>(named <code>list</code>)<br />
a named list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = 1, b = list(b1 = 2, b2 = 3), c = list(c1 = 4, c2 = list(c2a = 5)))

cards:::.purrr_list_flatten(x)
</code></pre>

<hr>
<h2 id='.rename_last_group_as_variable'>Rename Last Group to Variable</h2><span id='topic+.rename_last_group_as_variable'></span>

<h3>Description</h3>

<p>In the <code style="white-space: pre;">&#8288;ard_hierarchical*()&#8288;</code> functions, the last grouping variable is
renamed to <code>variable</code> and <code>variable_level</code> before being returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rename_last_group_as_variable(df_result, by, variables)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rename_last_group_as_variable_+3A_df_result">df_result</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(x = 1, y = 2, group1 = 3, group2 = 4)

cards:::.rename_last_group_as_variable(data, by = "ARM", variables = "AESOC")
</code></pre>

<hr>
<h2 id='.shift_column_pair'>Shift column pair</h2><span id='topic+.shift_column_pair'></span>

<h3>Description</h3>

<p>This function ingests an ARD object and coalesces/renames a given pair of columns (variable and levels)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.shift_column_pair(x, col_pair)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".shift_column_pair_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".shift_column_pair_+3A_col_pair">col_pair</code></td>
<td>
<p>(<code>character</code>)<br />
character vector containing the column names for variables (first element) and their corresponding levels (second element)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_categorical(ADSL, by = "ARM", variables = "AGEGR1") |&gt;
  cards:::.shift_column_pair(col_pair = c("group1", "group1_level"))

</code></pre>

<hr>
<h2 id='.table_as_df'>Results from <code>table()</code> as Data Frame</h2><span id='topic+.table_as_df'></span>

<h3>Description</h3>

<p>Takes the results from <code><a href="base.html#topic+table">table()</a></code> and returns them as a data frame.
After the <code><a href="base.html#topic+table">table()</a></code> results are made into a data frame, all the variables
are made into character columns, and the function also restores the
column types to their original classes. For <code>strata</code> columns,
only observed combinations are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.table_as_df(
  data,
  variable = NULL,
  by = NULL,
  strata = NULL,
  useNA = c("no", "always"),
  count_column = "...ard_n..."
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".table_as_df_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id=".table_as_df_+3A_variable">variable</code></td>
<td>
<p>(<code>string</code>)<br />
a string indicating a column in data</p>
</td></tr>
<tr><td><code id=".table_as_df_+3A_by">by</code></td>
<td>
<p>(<code>character</code>)<br />
a character vector indicating columns in data</p>
</td></tr>
<tr><td><code id=".table_as_df_+3A_strata">strata</code></td>
<td>
<p>(<code>character</code>)<br />
a character vector indicating columns in data</p>
</td></tr>
<tr><td><code id=".table_as_df_+3A_usena">useNA</code></td>
<td>
<p>(<code>string</code>)<br />
one of <code>"no"</code> and <code>"always"</code>. Will be passed to <code>table(useNA)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.table_as_df(ADSL, variable = "ARM", by = "AGEGR1", strata = NULL)
</code></pre>

<hr>
<h2 id='.trim_ard'>Trim ARD</h2><span id='topic+.trim_ard'></span>

<h3>Description</h3>

<p>This function ingests an ARD object and trims columns and rows for downstream use in
displays. The resulting data frame contains only numeric results, no supplemental
information about errors/warnings, and unnested list columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.trim_ard(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".trim_ard_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- bind_ard(
  ard_categorical(ADSL, by = "ARM", variables = "AGEGR1"),
  ard_categorical(ADSL, variables = "ARM")
) |&gt;
  shuffle_ard(trim = FALSE)

ard |&gt; cards:::.trim_ard()
</code></pre>

<hr>
<h2 id='.unique_and_sorted'>ARD-flavor of unique()</h2><span id='topic+.unique_and_sorted'></span>

<h3>Description</h3>

<p>Essentially a wrapper for <code>unique(x) |&gt; sort()</code> with <code>NA</code> levels removed.
For factors, all levels are returned even if they are unobserved.
Similarly, logical vectors always return <code>c(TRUE, FALSE)</code>, even if
both levels are not observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.unique_and_sorted(x, useNA = c("no", "always"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".unique_and_sorted_+3A_x">x</code></td>
<td>
<p>(<code>any</code>)<br />
a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cards:::.unique_and_sorted(factor(letters[c(5, 5:1)], levels = letters))

cards:::.unique_and_sorted(c(FALSE, TRUE, TRUE, FALSE))

cards:::.unique_and_sorted(c(5, 5:1))
</code></pre>

<hr>
<h2 id='adam'>Example ADaM Data</h2><span id='topic+adam'></span><span id='topic+ADSL'></span><span id='topic+ADAE'></span><span id='topic+ADTTE'></span>

<h3>Description</h3>

<p>Data frame imported from the <a href="https://github.com/cdisc-org/sdtm-adam-pilot-project">CDISC SDTM/ADaM Pilot Project</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADSL

ADAE

ADTTE
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 254 rows and 48 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 1191 rows and 55 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 254 rows and 26 columns.
</p>

<hr>
<h2 id='add_calculated_row'>Add Calculated Row</h2><span id='topic+add_calculated_row'></span>

<h3>Description</h3>

<p>Use this function to add a new statistic row that is a function of the
other statistics in an ARD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_calculated_row(
  x,
  expr,
  stat_name,
  by = c(all_ard_groups(), all_ard_variables(), any_of("context")),
  stat_label = stat_name,
  fmt_fn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_calculated_row_+3A_x">x</code></td>
<td>
<p>(<code>card</code>)<br />
data frame of class <code>'card'</code></p>
</td></tr>
<tr><td><code id="add_calculated_row_+3A_expr">expr</code></td>
<td>
<p>(<code>expression</code>)<br />
an expression</p>
</td></tr>
<tr><td><code id="add_calculated_row_+3A_stat_name">stat_name</code></td>
<td>
<p>(<code>string</code>)<br />
string naming the new statistic</p>
</td></tr>
<tr><td><code id="add_calculated_row_+3A_by">by</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Grouping variables to calculate statistics within</p>
</td></tr>
<tr><td><code id="add_calculated_row_+3A_stat_label">stat_label</code></td>
<td>
<p>(<code>string</code>)<br />
string of the statistic label. Default is the <code>stat_name</code>.</p>
</td></tr>
<tr><td><code id="add_calculated_row_+3A_fmt_fn">fmt_fn</code></td>
<td>
<p>(<code>integer</code>, <code>function</code>, <code>string</code>)<br />
a function of an integer or string that can be converted to a function with
<code>alias_as_fmt_fn()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_continuous(mtcars, variables = mpg) |&gt;
  add_calculated_row(expr = max - min, stat_name = "range")

ard_continuous(mtcars, variables = mpg) |&gt;
  add_calculated_row(
    expr =
      dplyr::case_when(
        mean &gt; median ~ "Right Skew",
        mean &lt; median ~ "Left Skew",
        .default = "Symmetric"
      ),
    stat_name = "skew"
  )
</code></pre>

<hr>
<h2 id='alias_as_fmt_fn'>Convert Alias to Function</h2><span id='topic+alias_as_fmt_fn'></span>

<h3>Description</h3>

<p>Accepted aliases are non-negative integers and strings.
</p>
<p>The integers are converted to functions that round the statistics
to the number of decimal places to match the integer.
</p>
<p>The formatting strings come in the form <code>"xx"</code>, <code>"xx.x"</code>, <code>"xx.x%"</code>, etc.
The number of <code>x</code>s that appear after the decimal place indicate the number of
decimal places the statistics will be rounded to.
The number of <code>x</code>s that appear before the decimal place indicate the leading
spaces that are added to the result.
If the string ends in <code>"%"</code>, results are scaled by 100 before rounding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alias_as_fmt_fn(x, variable, stat_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alias_as_fmt_fn_+3A_x">x</code></td>
<td>
<p>(<code>integer</code>, <code>string</code>, or <code>function</code>)<br />
a non-negative integer, string alias, or function</p>
</td></tr>
<tr><td><code id="alias_as_fmt_fn_+3A_variable">variable</code></td>
<td>
<p>(<code>character</code>)<br /> the variable whose statistic is to be formatted</p>
</td></tr>
<tr><td><code id="alias_as_fmt_fn_+3A_stat_name">stat_name</code></td>
<td>
<p>(<code>character</code>)<br /> the name of the statistic that is to be formatted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alias_as_fmt_fn(1)
alias_as_fmt_fn("xx.x")
</code></pre>

<hr>
<h2 id='apply_fmt_fn'>Apply Formatting Functions</h2><span id='topic+apply_fmt_fn'></span>

<h3>Description</h3>

<p>Apply the formatting functions to each of the raw statistics.
Function aliases are converted to functions using <code><a href="#topic+alias_as_fmt_fn">alias_as_fmt_fn()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_fmt_fn(x, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_fmt_fn_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id="apply_fmt_fn_+3A_replace">replace</code></td>
<td>
<p>(scalar <code>logical</code>)<br />
logical indicating whether to replace values in the <code>'stat_fmt'</code> column (if present).
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_continuous(ADSL, variables = "AGE") |&gt;
  apply_fmt_fn()
</code></pre>

<hr>
<h2 id='ard_attributes'>ARD Attributes</h2><span id='topic+ard_attributes'></span><span id='topic+ard_attributes.data.frame'></span><span id='topic+ard_attributes.default'></span>

<h3>Description</h3>

<p>Add variable attributes to an ARD data frame.
</p>

<ul>
<li><p> The <code>label</code> attribute will be added for all columns, and when no label
is specified and no label has been set for a column using the <code style="white-space: pre;">&#8288;label=&#8288;</code> argument,
the column name will be placed in the label statistic.
</p>
</li>
<li><p> The <code>class</code> attribute will also be returned for all columns.
</p>
</li>
<li><p> Any other attribute returned by <code>attributes()</code> will also be added, e.g. factor levels.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ard_attributes(data, ...)

## S3 method for class 'data.frame'
ard_attributes(data, variables = everything(), label = NULL, ...)

## Default S3 method:
ard_attributes(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_attributes_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_attributes_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="ard_attributes_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
variables to include</p>
</td></tr>
<tr><td><code id="ard_attributes_+3A_label">label</code></td>
<td>
<p>(named <code>list</code>)<br />
named list of variable labels, e.g. <code>list(cyl = "No. Cylinders")</code>.
Default is <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- dplyr::tibble(var1 = letters, var2 = LETTERS)
attr(df$var1, "label") &lt;- "Lowercase Letters"

ard_attributes(df, variables = everything())
</code></pre>

<hr>
<h2 id='ard_categorical'>Categorical ARD Statistics</h2><span id='topic+ard_categorical'></span><span id='topic+ard_categorical.data.frame'></span>

<h3>Description</h3>

<p>Compute Analysis Results Data (ARD) for categorical summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ard_categorical(data, ...)

## S3 method for class 'data.frame'
ard_categorical(
  data,
  variables,
  by = dplyr::group_vars(data),
  strata = NULL,
  statistic = everything() ~ c("n", "p", "N"),
  denominator = "column",
  fmt_fn = NULL,
  stat_label = everything() ~ default_stat_labels(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_categorical_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_categorical_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ard_categorical_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to include in summaries. Default is <code>everything()</code>.</p>
</td></tr>
<tr><td><code id="ard_categorical_+3A_by">by</code>, <code id="ard_categorical_+3A_strata">strata</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to use for grouping or stratifying the table output.
Arguments are similar, but with an important distinction:
</p>
<p><code>by</code>: results are tabulated by <strong>all combinations</strong> of the columns specified,
including unobserved combinations and unobserved factor levels.
</p>
<p><code>strata</code>: results are tabulated by <strong>all <em>observed</em> combinations</strong> of the
columns specified.
</p>
<p>Arguments may be used in conjunction with one another.</p>
</td></tr>
<tr><td><code id="ard_categorical_+3A_statistic">statistic</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element one or more of  <code>c("n", "N", "p", "n_cum", "p_cum")</code>
(on the RHS of a formula).</p>
</td></tr>
<tr><td><code id="ard_categorical_+3A_denominator">denominator</code></td>
<td>
<p>(<code>string</code>, <code>data.frame</code>, <code>integer</code>)<br />
Specify this argument to change the denominator,
e.g. the <code>"N"</code> statistic. Default is <code>'column'</code>. See below for details.</p>
</td></tr>
<tr><td><code id="ard_categorical_+3A_fmt_fn">fmt_fn</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element is a named list of functions
(or the RHS of a formula),
e.g. <code style="white-space: pre;">&#8288;list(mpg = list(mean = \(x) round(x, digits = 2) |&gt; as.character()))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="ard_categorical_+3A_stat_label">stat_label</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas, or a single formula where
the list element is either a named list or a list of formulas defining the
statistic labels, e.g. <code>everything() ~ list(n = "n", p = "pct")</code> or
<code>everything() ~ list(n ~ "n", p ~ "pct")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Denominators</h3>

<p>By default, the <code>ard_categorical()</code> function returns the statistics <code>"n"</code>, <code>"N"</code>, and
<code>"p"</code>, where little <code>"n"</code> are the counts for the variable levels, and big <code>"N"</code> is
the number of non-missing observations. The default calculation for the
percentage is merely <code>p = n/N</code>.
</p>
<p>However, it is sometimes necessary to provide a different <code>"N"</code> to use
as the denominator in this calculation. For example, in a calculation
of the rates of various observed adverse events, you may need to update the
denominator to the number of enrolled subjects.
</p>
<p>In such cases, use the <code>denominator</code> argument to specify a new definition
of <code>"N"</code>, and subsequently <code>"p"</code>.
The argument expects one of the following inputs:
</p>

<ul>
<li><p> a string: one of <code>"column"</code>, <code>"row"</code>, or <code>"cell"</code>.
</p>

<ul>
<li> <p><code>"column"</code>, the default, returns percentages where the sum is equal to
one within the variable after the data frame has been subset with <code>by</code>/<code>strata</code>.
</p>
</li>
<li> <p><code>"row"</code> gives 'row' percentages where <code>by</code>/<code>strata</code> columns are the 'top'
of a cross table, and the variables are the rows. This is well-defined
for a single <code>by</code> or <code>strata</code> variable, and care must be taken when there
are more to ensure the the results are as you expect.
</p>
</li>
<li> <p><code>"cell"</code> gives percentages where the denominator is the number of non-missing
rows in the source data frame.
</p>
</li></ul>

</li>
<li><p> a data frame. Any columns in the data frame that overlap with the <code>by</code>/<code>strata</code>
columns will be used to calculate the new <code>"N"</code>.
</p>
</li>
<li><p> an integer. This single integer will be used as the new <code>"N"</code>
</p>
</li>
<li><p> a structured data frame. The data frame will include columns from <code>by</code>/<code>strata</code>.
The last column must be named <code>"...ard_N..."</code>. The integers in this column will
be used as the updated <code>"N"</code> in the calculations.
</p>
</li></ul>

<p>Lastly, when the <code>p</code> statistic is returned, the proportion is returned&mdash;bounded by <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
However, the default function to format the statistic scales the proportion by 100
and the percentage is returned which matches the default statistic label of <code>'%'</code>.
To get the formatted values, pass the ARD to <code>apply_fmt_fn()</code>.
</p>


<h3>Other Statistics</h3>

<p>In some cases, you may need other kinds of statistics for categorical variables.
Despite the name, <code>ard_continuous()</code> can be used to obtain these statistics.
</p>
<p>In the example below, we calculate the mode of a categorical variable.
</p>
<div class="sourceCode r"><pre>get_mode &lt;- function(x) {
  table(x) |&gt; sort(decreasing = TRUE) |&gt; names() |&gt; getElement(1L)
}

ADSL |&gt;
  ard_continuous(
    variables = AGEGR1,
    statistic = list(AGEGR1 = list(mode = get_mode))
  )
#&gt; {cards} data frame: 1 x 8
#&gt;   variable   context stat_name stat_label  stat fmt_fn
#&gt; 1   AGEGR1 continuo      mode       mode 65-80   &lt;fn&gt;
#&gt; i 2 more variables: warning, error
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>ard_categorical(ADSL, by = "ARM", variables = "AGEGR1")

ADSL |&gt;
  dplyr::group_by(ARM) |&gt;
  ard_categorical(
    variables = "AGEGR1",
    statistic = everything() ~ "n"
  )
</code></pre>

<hr>
<h2 id='ard_complex'>Complex ARD Summaries</h2><span id='topic+ard_complex'></span><span id='topic+ard_complex.data.frame'></span>

<h3>Description</h3>

<p>Function is similar to <code><a href="#topic+ard_continuous">ard_continuous()</a></code>, but allows for more complex
summaries. While <code>ard_continuous(statistic)</code> only allows for a univariable
function, <code>ard_complex(statistic)</code> can handle more complex data summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ard_complex(data, ...)

## S3 method for class 'data.frame'
ard_complex(
  data,
  variables,
  by = dplyr::group_vars(data),
  strata = NULL,
  statistic,
  fmt_fn = NULL,
  stat_label = everything() ~ default_stat_labels(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_complex_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_complex_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ard_complex_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to include in summaries.</p>
</td></tr>
<tr><td><code id="ard_complex_+3A_by">by</code>, <code id="ard_complex_+3A_strata">strata</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to tabulate by/stratify by for summary statistic
calculation. Arguments are similar, but with an important distinction:
</p>
<p><code>by</code>: results are calculated for <strong>all combinations</strong> of the columns specified,
including unobserved combinations and unobserved factor levels.
</p>
<p><code>strata</code>: results are calculated for <strong>all <em>observed</em> combinations</strong> of the
columns specified.
</p>
<p>Arguments may be used in conjunction with one another.</p>
</td></tr>
<tr><td><code id="ard_complex_+3A_statistic">statistic</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
The form of the statistics argument is identical to <code>ard_continuous(statistic)</code>
argument, except the summary function <em>must</em> accept the following arguments:
</p>

<ul>
<li> <p><code>x</code>: a vector
</p>
</li>
<li> <p><code>data</code>: the data frame that has been subset such that the <code>by</code>/<code>strata</code> columns
and rows in which <code>"variable"</code> is <code>NA</code> have been removed.
</p>
</li>
<li> <p><code>full_data</code>: the full data frame
</p>
</li>
<li> <p><code>by</code>: character vector of the <code>by</code> variables
</p>
</li>
<li> <p><code>strata</code>: character vector of the <code>strata</code> variables
It is unlikely any one function will need <em>all</em> of the above elements,
and it's recommended the function passed accepts <code>...</code> so that any unused
arguments will be properly ignored. The <code>...</code> also allows this function
to perhaps be updated in the future with more passed arguments. For example,
if one needs a second variable from the data frame, the function inputs
may look like: <code>foo(x, data, ...)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="ard_complex_+3A_fmt_fn">fmt_fn</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element is a named list of functions
(or the RHS of a formula),
e.g. <code style="white-space: pre;">&#8288;list(mpg = list(mean = \(x) round(x, digits = 2) |&gt; as.character()))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="ard_complex_+3A_stat_label">stat_label</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas, or a single formula where
the list element is either a named list or a list of formulas defining the
statistic labels, e.g. <code>everything() ~ list(mean = "Mean", sd = "SD")</code> or
<code>everything() ~ list(mean ~ "Mean", sd ~ "SD")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example how to mimic behavior of `ard_continuous()`
ard_complex(
  ADSL,
  by = "ARM",
  variables = "AGE",
  statistic = list(AGE = list(mean = \(x, ...) mean(x)))
)

# return the grand mean and the mean within the `by` group
grand_mean &lt;- function(data, full_data, variable, ...) {
  list(
    mean = mean(data[[variable]], na.rm = TRUE),
    grand_mean = mean(full_data[[variable]], na.rm = TRUE)
  )
}

ADSL |&gt;
  dplyr::group_by(ARM) |&gt;
  ard_complex(
    variables = "AGE",
    statistic = list(AGE = list(means = grand_mean))
  )
</code></pre>

<hr>
<h2 id='ard_continuous'>Continuous ARD Statistics</h2><span id='topic+ard_continuous'></span><span id='topic+ard_continuous.data.frame'></span>

<h3>Description</h3>

<p>Compute Analysis Results Data (ARD) for simple continuous summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ard_continuous(data, ...)

## S3 method for class 'data.frame'
ard_continuous(
  data,
  variables,
  by = dplyr::group_vars(data),
  strata = NULL,
  statistic = everything() ~ continuous_summary_fns(),
  fmt_fn = NULL,
  stat_label = everything() ~ default_stat_labels(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_continuous_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_continuous_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ard_continuous_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to include in summaries.</p>
</td></tr>
<tr><td><code id="ard_continuous_+3A_by">by</code>, <code id="ard_continuous_+3A_strata">strata</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to tabulate by/stratify by for summary statistic
calculation. Arguments are similar, but with an important distinction:
</p>
<p><code>by</code>: results are calculated for <strong>all combinations</strong> of the columns specified,
including unobserved combinations and unobserved factor levels.
</p>
<p><code>strata</code>: results are calculated for <strong>all <em>observed</em> combinations</strong> of the
columns specified.
</p>
<p>Arguments may be used in conjunction with one another.</p>
</td></tr>
<tr><td><code id="ard_continuous_+3A_statistic">statistic</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element is a named list of functions
(or the RHS of a formula),
e.g. <code style="white-space: pre;">&#8288;list(mpg = list(mean = \(x) mean(x)))&#8288;</code>.
</p>
<p>The value assigned to each variable must also be a named list, where the names
are used to reference a function and the element is the function object.
Typically, this function will return a scalar statistic, but a function that
returns a named list of results is also acceptable, e.g.
<code>list(conf.low = -1, conf.high = 1)</code>. However, when errors occur, the messaging
will be less clear in this setting.</p>
</td></tr>
<tr><td><code id="ard_continuous_+3A_fmt_fn">fmt_fn</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element is a named list of functions
(or the RHS of a formula),
e.g. <code style="white-space: pre;">&#8288;list(mpg = list(mean = \(x) round(x, digits = 2) |&gt; as.character()))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="ard_continuous_+3A_stat_label">stat_label</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas, or a single formula where
the list element is either a named list or a list of formulas defining the
statistic labels, e.g. <code>everything() ~ list(mean = "Mean", sd = "SD")</code> or
<code>everything() ~ list(mean ~ "Mean", sd ~ "SD")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_continuous(ADSL, by = "ARM", variables = "AGE")

# if a single function returns a named list, the named
# results will be placed in the resulting ARD
ADSL |&gt;
  dplyr::group_by(ARM) |&gt;
  ard_continuous(
    variables = "AGE",
    statistic =
      ~ list(conf.int = \(x) t.test(x)[["conf.int"]] |&gt;
        as.list() |&gt;
        setNames(c("conf.low", "conf.high")))
  )
</code></pre>

<hr>
<h2 id='ard_dichotomous'>Dichotomous ARD Statistics</h2><span id='topic+ard_dichotomous'></span><span id='topic+ard_dichotomous.data.frame'></span>

<h3>Description</h3>

<p>Compute Analysis Results Data (ARD) for dichotomous summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ard_dichotomous(data, ...)

## S3 method for class 'data.frame'
ard_dichotomous(
  data,
  variables,
  by = dplyr::group_vars(data),
  strata = NULL,
  value = maximum_variable_value(data[variables]),
  statistic = everything() ~ c("n", "N", "p"),
  denominator = NULL,
  fmt_fn = NULL,
  stat_label = everything() ~ default_stat_labels(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_dichotomous_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_dichotomous_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ard_dichotomous_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to include in summaries. Default is <code>everything()</code>.</p>
</td></tr>
<tr><td><code id="ard_dichotomous_+3A_by">by</code>, <code id="ard_dichotomous_+3A_strata">strata</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to use for grouping or stratifying the table output.
Arguments are similar, but with an important distinction:
</p>
<p><code>by</code>: results are tabulated by <strong>all combinations</strong> of the columns specified,
including unobserved combinations and unobserved factor levels.
</p>
<p><code>strata</code>: results are tabulated by <strong>all <em>observed</em> combinations</strong> of the
columns specified.
</p>
<p>Arguments may be used in conjunction with one another.</p>
</td></tr>
<tr><td><code id="ard_dichotomous_+3A_value">value</code></td>
<td>
<p>(named <code>list</code>)<br />
named list of dichotomous values to tabulate. Default is <code>maximum_variable_value(data)</code>,
which returns the largest/last value after a sort.</p>
</td></tr>
<tr><td><code id="ard_dichotomous_+3A_statistic">statistic</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element one or more of  <code>c("n", "N", "p", "n_cum", "p_cum")</code>
(on the RHS of a formula).</p>
</td></tr>
<tr><td><code id="ard_dichotomous_+3A_denominator">denominator</code></td>
<td>
<p>(<code>string</code>, <code>data.frame</code>, <code>integer</code>)<br />
Specify this argument to change the denominator,
e.g. the <code>"N"</code> statistic. Default is <code>'column'</code>. See below for details.</p>
</td></tr>
<tr><td><code id="ard_dichotomous_+3A_fmt_fn">fmt_fn</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element is a named list of functions
(or the RHS of a formula),
e.g. <code style="white-space: pre;">&#8288;list(mpg = list(mean = \(x) round(x, digits = 2) |&gt; as.character()))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="ard_dichotomous_+3A_stat_label">stat_label</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas, or a single formula where
the list element is either a named list or a list of formulas defining the
statistic labels, e.g. <code>everything() ~ list(n = "n", p = "pct")</code> or
<code>everything() ~ list(n ~ "n", p ~ "pct")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Denominators</h3>

<p>By default, the <code>ard_categorical()</code> function returns the statistics <code>"n"</code>, <code>"N"</code>, and
<code>"p"</code>, where little <code>"n"</code> are the counts for the variable levels, and big <code>"N"</code> is
the number of non-missing observations. The default calculation for the
percentage is merely <code>p = n/N</code>.
</p>
<p>However, it is sometimes necessary to provide a different <code>"N"</code> to use
as the denominator in this calculation. For example, in a calculation
of the rates of various observed adverse events, you may need to update the
denominator to the number of enrolled subjects.
</p>
<p>In such cases, use the <code>denominator</code> argument to specify a new definition
of <code>"N"</code>, and subsequently <code>"p"</code>.
The argument expects one of the following inputs:
</p>

<ul>
<li><p> a string: one of <code>"column"</code>, <code>"row"</code>, or <code>"cell"</code>.
</p>

<ul>
<li> <p><code>"column"</code>, the default, returns percentages where the sum is equal to
one within the variable after the data frame has been subset with <code>by</code>/<code>strata</code>.
</p>
</li>
<li> <p><code>"row"</code> gives 'row' percentages where <code>by</code>/<code>strata</code> columns are the 'top'
of a cross table, and the variables are the rows. This is well-defined
for a single <code>by</code> or <code>strata</code> variable, and care must be taken when there
are more to ensure the the results are as you expect.
</p>
</li>
<li> <p><code>"cell"</code> gives percentages where the denominator is the number of non-missing
rows in the source data frame.
</p>
</li></ul>

</li>
<li><p> a data frame. Any columns in the data frame that overlap with the <code>by</code>/<code>strata</code>
columns will be used to calculate the new <code>"N"</code>.
</p>
</li>
<li><p> an integer. This single integer will be used as the new <code>"N"</code>
</p>
</li>
<li><p> a structured data frame. The data frame will include columns from <code>by</code>/<code>strata</code>.
The last column must be named <code>"...ard_N..."</code>. The integers in this column will
be used as the updated <code>"N"</code> in the calculations.
</p>
</li></ul>

<p>Lastly, when the <code>p</code> statistic is returned, the proportion is returned&mdash;bounded by <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
However, the default function to format the statistic scales the proportion by 100
and the percentage is returned which matches the default statistic label of <code>'%'</code>.
To get the formatted values, pass the ARD to <code>apply_fmt_fn()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_dichotomous(mtcars, by = vs, variables = c(cyl, am), value = list(cyl = 4))

mtcars |&gt;
  dplyr::group_by(vs) |&gt;
  ard_dichotomous(
    variables = c(cyl, am),
    value = list(cyl = 4),
    statistic = ~"p"
  )
</code></pre>

<hr>
<h2 id='ard_hierarchical'>Hierarchical ARD Statistics</h2><span id='topic+ard_hierarchical'></span><span id='topic+ard_hierarchical_count'></span><span id='topic+ard_hierarchical.data.frame'></span><span id='topic+ard_hierarchical_count.data.frame'></span>

<h3>Description</h3>

<p><em>Functions <code>ard_hierarchical()</code> and <code>ard_hierarchical_count()</code> are primarily helper
functions for <code><a href="#topic+ard_stack_hierarchical">ard_stack_hierarchical()</a></code> and <code><a href="#topic+ard_stack_hierarchical_count">ard_stack_hierarchical_count()</a></code>,
meaning that it will be rare a user needs to call
<code>ard_hierarchical()</code>/<code>ard_hierarchical_count()</code> directly.</em>
</p>
<p>Performs hierarchical or nested tabulations, e.g. tabulates AE terms
nested within AE system organ class.
</p>

<ul>
<li> <p><code>ard_hierarchical()</code> includes summaries for the last variable listed
in the <code>variables</code> argument, nested within the other variables included.
</p>
</li>
<li> <p><code>ard_hierarchical_count()</code> includes summaries for <em>all</em> variables
listed in the <code>variables</code> argument each summary nested within the preceding
variables, e.g. <code>variables=c(AESOC, AEDECOD)</code> summarizes <code>AEDECOD</code> nested
in <code>AESOC</code>, and also summarizes the counts of <code>AESOC</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ard_hierarchical(data, ...)

ard_hierarchical_count(data, ...)

## S3 method for class 'data.frame'
ard_hierarchical(
  data,
  variables,
  by = dplyr::group_vars(data),
  statistic = everything() ~ c("n", "N", "p"),
  denominator = NULL,
  fmt_fn = NULL,
  stat_label = everything() ~ default_stat_labels(),
  id = NULL,
  ...
)

## S3 method for class 'data.frame'
ard_hierarchical_count(
  data,
  variables,
  by = dplyr::group_vars(data),
  fmt_fn = NULL,
  stat_label = everything() ~ default_stat_labels(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_hierarchical_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_hierarchical_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ard_hierarchical_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
variables to perform the nested/hierarchical tabulations within.</p>
</td></tr>
<tr><td><code id="ard_hierarchical_+3A_by">by</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
variables to perform tabulations by. All combinations of the variables
specified here appear in results. Default is <code>dplyr::group_vars(data)</code>.</p>
</td></tr>
<tr><td><code id="ard_hierarchical_+3A_statistic">statistic</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element one or more of  <code>c("n", "N", "p", "n_cum", "p_cum")</code>
(on the RHS of a formula).</p>
</td></tr>
<tr><td><code id="ard_hierarchical_+3A_denominator">denominator</code></td>
<td>
<p>(<code>data.frame</code>, <code>integer</code>)<br />
used to define the denominator and enhance the output.
The argument is required for <code>ard_hierarchical()</code> and optional
for <code>ard_hierarchical_count()</code>.
</p>

<ul>
<li><p> the univariate tabulations of the <code>by</code> variables are calculated with <code>denominator</code>,
when a data frame is passed, e.g. tabulation of the treatment assignment
counts that may appear in the header of a table.
</p>
</li>
<li><p> the <code>denominator</code> argument must be specified when <code>id</code> is used to
calculate the event rates.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ard_hierarchical_+3A_fmt_fn">fmt_fn</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element is a named list of functions
(or the RHS of a formula),
e.g. <code style="white-space: pre;">&#8288;list(mpg = list(mean = \(x) round(x, digits = 2) |&gt; as.character()))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="ard_hierarchical_+3A_stat_label">stat_label</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas, or a single formula where
the list element is either a named list or a list of formulas defining the
statistic labels, e.g. <code>everything() ~ list(n = "n", p = "pct")</code> or
<code>everything() ~ list(n ~ "n", p ~ "pct")</code>.</p>
</td></tr>
<tr><td><code id="ard_hierarchical_+3A_id">id</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
an optional argument used to assert there are no duplicates within
the <code>c(id, variables)</code> columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_hierarchical(
  data = ADAE |&gt;
    dplyr::slice_tail(n = 1L, by = c(USUBJID, TRTA, AESOC, AEDECOD)),
  variables = c(AESOC, AEDECOD),
  by = TRTA,
  id = USUBJID,
  denominator = ADSL |&gt; dplyr::rename(TRTA = ARM)
)

ard_hierarchical_count(
  data = ADAE,
  variables = c(AESOC, AEDECOD),
  by = TRTA
)
</code></pre>

<hr>
<h2 id='ard_missing'>Missing ARD Statistics</h2><span id='topic+ard_missing'></span><span id='topic+ard_missing.data.frame'></span>

<h3>Description</h3>

<p>Compute Analysis Results Data (ARD) for statistics related to data missingness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ard_missing(data, ...)

## S3 method for class 'data.frame'
ard_missing(
  data,
  variables,
  by = dplyr::group_vars(data),
  statistic = everything() ~ c("N_obs", "N_miss", "N_nonmiss", "p_miss", "p_nonmiss"),
  fmt_fn = NULL,
  stat_label = everything() ~ default_stat_labels(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_missing_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_missing_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ard_missing_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to include in summaries.</p>
</td></tr>
<tr><td><code id="ard_missing_+3A_by">by</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
results are tabulated by <strong>all combinations</strong> of the columns specified.</p>
</td></tr>
<tr><td><code id="ard_missing_+3A_statistic">statistic</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element is a named list of functions
(or the RHS of a formula),
e.g. <code style="white-space: pre;">&#8288;list(mpg = list(mean = \(x) mean(x)))&#8288;</code>.
</p>
<p>The value assigned to each variable must also be a named list, where the names
are used to reference a function and the element is the function object.
Typically, this function will return a scalar statistic, but a function that
returns a named list of results is also acceptable, e.g.
<code>list(conf.low = -1, conf.high = 1)</code>. However, when errors occur, the messaging
will be less clear in this setting.</p>
</td></tr>
<tr><td><code id="ard_missing_+3A_fmt_fn">fmt_fn</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element is a named list of functions
(or the RHS of a formula),
e.g. <code style="white-space: pre;">&#8288;list(mpg = list(mean = \(x) round(x, digits = 2) |&gt; as.character()))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="ard_missing_+3A_stat_label">stat_label</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas, or a single formula where
the list element is either a named list or a list of formulas defining the
statistic labels, e.g. <code>everything() ~ list(mean = "Mean", sd = "SD")</code> or
<code>everything() ~ list(mean ~ "Mean", sd ~ "SD")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_missing(ADSL, by = "ARM", variables = "AGE")

ADSL |&gt;
  dplyr::group_by(ARM) |&gt;
  ard_missing(
    variables = "AGE",
    statistic = ~"N_miss"
  )
</code></pre>

<hr>
<h2 id='ard_pairwise'>Pairwise ARD</h2><span id='topic+ard_pairwise'></span>

<h3>Description</h3>

<p>Utility to perform pairwise comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ard_pairwise(data, variable, .f, include = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_pairwise_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_pairwise_+3A_variable">variable</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Column to perform pairwise analyses for.</p>
</td></tr>
<tr><td><code id="ard_pairwise_+3A_.f">.f</code></td>
<td>
<p>(<code>function</code>)<br />
a function that creates ARDs. The function accepts a single argument and
a subset of <code>data</code> will be passed including the two levels of <code>variable</code>
for the pairwise analysis.</p>
</td></tr>
<tr><td><code id="ard_pairwise_+3A_include">include</code></td>
<td>
<p>(<code>vector</code>)<br />
a vector of levels of the <code>variable</code> column to include in comparisons.
Pairwise comparisons will only be performed for pairs that have a level
specified here. Default is <code>NULL</code> and all pairwise computations are included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of ARDs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_pairwise(
  ADSL,
  variable = ARM,
  .f = \(df) {
    ard_complex(
      df,
      variables = AGE,
      statistic = ~ list(ttest = \(x, data, ...) t.test(x ~ data$ARM)[c("statistic", "p.value")])
    )
  },
  include = "Placebo" # only include comparisons to the "Placebo" group
)
</code></pre>

<hr>
<h2 id='ard_stack'>Stack ARDs</h2><span id='topic+ard_stack'></span>

<h3>Description</h3>

<p>Stack multiple ARD calls sharing common input <code>data</code> and <code>by</code> variables.
Optionally incorporate additional information on represented variables, e.g.
overall calculations, rates of missingness, attributes, or transform results
with <code>shuffle_ard()</code>.
</p>
<p>If the <code>ard_stack(by)</code> argument is specified, a univariate tabulation of the
by variable will also be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ard_stack(
  data,
  ...,
  .by = NULL,
  .overall = FALSE,
  .missing = FALSE,
  .attributes = FALSE,
  .total_n = FALSE,
  .shuffle = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_stack_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_stack_+3A_...">...</code></td>
<td>
<p>(<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>)<br />
Series of ARD function calls to be run and stacked</p>
</td></tr>
<tr><td><code id="ard_stack_+3A_.by">.by</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to tabulate by in the series of ARD function calls.
Any rows with <code>NA</code> or <code>NaN</code> values are removed from all calculations.</p>
</td></tr>
<tr><td><code id="ard_stack_+3A_.overall">.overall</code></td>
<td>
<p>(<code>logical</code>)<br /> logical indicating whether overall statistics
should be calculated (i.e. re-run all <code style="white-space: pre;">&#8288;ard_*()&#8288;</code> calls with <code>by=NULL</code>).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ard_stack_+3A_.missing">.missing</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to include the results of <code>ard_missing()</code> for all
variables represented in the ARD. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ard_stack_+3A_.attributes">.attributes</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to include the results of <code>ard_attributes()</code> for all
variables represented in the ARD. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ard_stack_+3A_.total_n">.total_n</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to include of <code>ard_total_n()</code> in the returned ARD.</p>
</td></tr>
<tr><td><code id="ard_stack_+3A_.shuffle">.shuffle</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to perform <code>shuffle_ard()</code> on the final result.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_stack(
  data = ADSL,
  ard_categorical(variables = "AGEGR1"),
  ard_continuous(variables = "AGE"),
  .by = "ARM",
  .overall = TRUE,
  .attributes = TRUE
)

ard_stack(
  data = ADSL,
  ard_categorical(variables = "AGEGR1"),
  ard_continuous(variables = "AGE"),
  .by = "ARM",
  .shuffle = TRUE
)

</code></pre>

<hr>
<h2 id='ard_stack_hierarchical'>Stacked Hierarchical ARD Statistics</h2><span id='topic+ard_stack_hierarchical'></span><span id='topic+ard_stack_hierarchical_count'></span>

<h3>Description</h3>

<p>Use these functions to calculate multiple summaries of nested or hierarchical data
in a single call.
</p>

<ul>
<li> <p><code>ard_stack_hierarchical()</code>: Calculates <em>rates</em> of events (e.g. adverse events)
utilizing the <code>denominator</code> and <code>id</code> arguments to identify the rows in <code>data</code>
to include in each rate calculation.
</p>
</li>
<li> <p><code>ard_stack_hierarchical_count()</code>: Calculates <em>counts</em> of events utilizing
all rows for each tabulation.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ard_stack_hierarchical(
  data,
  variables,
  by = dplyr::group_vars(data),
  id,
  denominator,
  include = everything(),
  statistic = everything() ~ c("n", "N", "p"),
  overall = FALSE,
  over_variables = FALSE,
  attributes = FALSE,
  total_n = FALSE,
  shuffle = FALSE
)

ard_stack_hierarchical_count(
  data,
  variables,
  by = dplyr::group_vars(data),
  denominator = NULL,
  include = everything(),
  overall = FALSE,
  over_variables = FALSE,
  attributes = FALSE,
  total_n = FALSE,
  shuffle = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_stack_hierarchical_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Specifies the nested/hierarchical structure of the data.
The variables that are specified here and in the <code>include</code> argument
will have summary statistics calculated.</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_by">by</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
variables to perform tabulations by. All combinations of the variables
specified here appear in results. Default is <code>dplyr::group_vars(data)</code>.</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_id">id</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
argument used to subset <code>data</code> to identify rows in <code>data</code> to calculate
event rates in <code>ard_stack_hierarchical()</code>. See details below.</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_denominator">denominator</code></td>
<td>
<p>(<code>data.frame</code>, <code>integer</code>)<br />
used to define the denominator and enhance the output.
The argument is required for <code>ard_stack_hierarchical()</code> and optional
for <code>ard_stack_hierarchical_count()</code>.
</p>

<ul>
<li><p> the univariate tabulations of the <code>by</code> variables are calculated with <code>denominator</code>,
when a data frame is passed, e.g. tabulation of the treatment assignment
counts that may appear in the header of a table.
</p>
</li>
<li><p> the <code>denominator</code> argument must be specified when <code>id</code> is used to
calculate the event rates.
</p>
</li>
<li><p> if <code>total_n=TRUE</code>, the <code>denominator</code> argument is used to return the total N
</p>
</li></ul>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_include">include</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Specify the subset a columns indicated in the <code>variables</code> argument for which
summary statistics will be returned. Default is <code>everything()</code>.</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_statistic">statistic</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas,
or a single formula where the list element one or more of  <code>c("n", "N", "p", "n_cum", "p_cum")</code>
(on the RHS of a formula).</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_overall">overall</code></td>
<td>
<p>(scalar <code>logical</code>)<br /> logical indicating whether overall statistics
should be calculated (i.e. repeat the operations with <code>by=NULL</code> in <em>most cases</em>, see below for details).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_over_variables">over_variables</code></td>
<td>
<p>(scalar <code>logical</code>)<br />
logical indicating whether summary statistics
should be calculated over or across the columns listed in the <code>variables</code> argument.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_attributes">attributes</code></td>
<td>
<p>(scalar <code>logical</code>)<br />
logical indicating whether to include the results of <code>ard_attributes()</code> for all
variables represented in the ARD. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_total_n">total_n</code></td>
<td>
<p>(scalar <code>logical</code>)<br />
logical indicating whether to include of <code>ard_total_n(denominator)</code> in the returned ARD.</p>
</td></tr>
<tr><td><code id="ard_stack_hierarchical_+3A_shuffle">shuffle</code></td>
<td>
<p>(scalar <code>logical</code>)<br />
logical indicating whether to perform <code>shuffle_ard()</code> on the final result.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Subsetting Data for Rate Calculations</h3>

<p>To calculate event rates, the <code>ard_stack_hierarchical()</code> function identifies
rows to include in the calculation.
First, the primary data frame is sorted by the columns identified in
the <code>id</code>, <code>by</code>, and <code>variables</code> arguments.
</p>
<p>As the function cycles over the variables specified in the <code>variables</code> argument,
the data frame is grouped by <code>id</code>, <code>intersect(by, names(denominator))</code>, and <code>variables</code>
utilizing the last row within each of the groups.
</p>
<p>For example, if the call is
<code>ard_stack_hierarchical(data = ADAE, variables = c(AESOC, AEDECOD), id = USUBJID)</code>,
then we'd first subset ADAE to be one row within the grouping <code>c(USUBJID, AESOC, AEDECOD)</code>
to calculate the event rates in <code>'AEDECOD'</code>. We'd then repeat and
subset ADAE to be one row within the grouping <code>c(USUBJID, AESOC)</code>
to calculate the event rates in <code>'AESOC'</code>.
</p>


<h3>Overall Argument</h3>

<p>When we set <code>overall=TRUE</code>, we wish to re-run our calculations removing the
stratifying columns. For example, if we ran the code below, we results would
include results with the code chunk being re-run with <code>by=NULL</code>.
</p>
<div class="sourceCode r"><pre>ard_stack_hierarchical(
  data = ADAE,
  variables = c(AESOC, AEDECOD),
  by = TRTA,
  denominator = ADSL |&gt; dplyr::rename(TRTA = ARM),
  overall = TRUE
)
</pre></div>
<p>But there is another case to be aware of: when the <code>by</code> argument includes
columns that are not present in the <code>denominator</code>, for example when tabulating
results by AE grade or severity in addition to treatment assignment.
In the example below, we're tabulating results by treatment assignment and
AE severity. By specifying <code>overall=TRUE</code>, we will re-run the to get
results with <code>by = AESEV</code> and again with <code>by = NULL</code>.
</p>
<div class="sourceCode r"><pre>ard_stack_hierarchical(
  data = ADAE,
  variables = c(AESOC, AEDECOD),
  by = c(TRTA, AESEV),
  denominator = ADSL |&gt; dplyr::rename(TRTA = ARM),
  overall = TRUE
)
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>ard_stack_hierarchical(
  ADAE,
  variables = c(AESOC, AEDECOD),
  by = TRTA,
  denominator = ADSL |&gt; dplyr::rename(TRTA = ARM),
  id = USUBJID
)

ard_stack_hierarchical_count(
  ADAE,
  variables = c(AESOC, AEDECOD),
  by = TRTA,
  denominator = ADSL |&gt; dplyr::rename(TRTA = ARM)
)
</code></pre>

<hr>
<h2 id='ard_strata'>Stratified ARD</h2><span id='topic+ard_strata'></span>

<h3>Description</h3>

<p>General function for calculating ARD results within subgroups.
</p>
<p>While the examples below show use with other functions from the cards package,
this function would primarily be used with the statistical functions in the
cardx functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ard_strata(.data, .by = NULL, .strata = NULL, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_strata_+3A_.data">.data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_strata_+3A_.by">.by</code>, <code id="ard_strata_+3A_.strata">.strata</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
columns to tabulate by/stratify by for calculation.
Arguments are similar, but with an important distinction:
</p>
<p><code>.by</code>: results are tabulated by <strong>all combinations</strong> of the columns specified,
including unobserved combinations and unobserved factor levels.
</p>
<p><code>.strata</code>: results are tabulated by <strong>all <em>observed</em> combinations</strong> of the
columns specified.
</p>
<p>These argument <em>should not</em> include any columns that appear in the <code>.f</code> argument.</p>
</td></tr>
<tr><td><code id="ard_strata_+3A_.f">.f</code></td>
<td>
<p>(<code>function</code>, <code>formula</code>)<br />
a function or a formula that can be coerced to a function with
<code>rlang::as_function()</code> (similar to <code>purrr::map(.f)</code>)</p>
</td></tr>
<tr><td><code id="ard_strata_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the <code>.f</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_strata(
  ADSL,
  .by = ARM,
  .f = ~ ard_continuous(.x, variables = AGE)
)
</code></pre>

<hr>
<h2 id='ard_total_n'>ARD Total N</h2><span id='topic+ard_total_n'></span><span id='topic+ard_total_n.data.frame'></span>

<h3>Description</h3>

<p>Returns the total N for the data frame.
The placeholder variable name returned in the object is <code>"..ard_total_n.."</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ard_total_n(data, ...)

## S3 method for class 'data.frame'
ard_total_n(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ard_total_n_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="ard_total_n_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_total_n(ADSL)
</code></pre>

<hr>
<h2 id='as_card'>Data Frame as ARD</h2><span id='topic+as_card'></span>

<h3>Description</h3>

<p>Convert data frames to ARDs of class 'card'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_card(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_card_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.frame(
  stat_name = c("N", "mean"),
  stat_label = c("N", "Mean"),
  stat = c(10, 0.5)
) |&gt;
  as_card()
</code></pre>

<hr>
<h2 id='as_cards_fn'>As card function</h2><span id='topic+as_cards_fn'></span><span id='topic+is_cards_fn'></span><span id='topic+get_cards_fn_stat_names'></span>

<h3>Description</h3>

<p>Add attributes to a function that specify the expected results.
It is used when <code>ard_continuous()</code> or <code>ard_complex()</code> errors and constructs
an ARD with the correct structure when the results cannot be calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_cards_fn(f, stat_names)

is_cards_fn(f)

get_cards_fn_stat_names(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_cards_fn_+3A_f">f</code></td>
<td>
<p>(<code>function</code>)<br />
a function</p>
</td></tr>
<tr><td><code id="as_cards_fn_+3A_stat_names">stat_names</code></td>
<td>
<p>(<code>character</code>)<br />
a character vector of the expected statistic names returned by function <code>f</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># When there is no error, everything works as if we hadn't used `as_card_fn()`
ttest_works &lt;-
  as_cards_fn(
    \(x) t.test(x)[c("statistic", "p.value")],
    stat_names = c("statistic", "p.value")
  )
ard_continuous(
  mtcars,
  variables = mpg,
  statistic = ~ list(ttest = ttest_works)
)

# When there is an error and we use `as_card_fn()`,
#   we will see the same structure as when there is no error
ttest_error &lt;-
  as_cards_fn(
    \(x) {
      t.test(x)[c("statistic", "p.value")]
      stop("Intentional Error")
    },
    stat_names = c("statistic", "p.value")
  )
ard_continuous(
  mtcars,
  variables = mpg,
  statistic = ~ list(ttest = ttest_error)
)

# if we don't use `as_card_fn()` and there is an error,
#   the returned result is only one row
ard_continuous(
  mtcars,
  variables = mpg,
  statistic = ~ list(ttest = \(x) {
    t.test(x)[c("statistic", "p.value")]
    stop("Intentional Error")
  })
)
</code></pre>

<hr>
<h2 id='as_nested_list'>ARD as Nested List</h2><span id='topic+as_nested_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a><br />
Convert ARDs to nested lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_nested_list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_nested_list_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a nested list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_continuous(mtcars, by = "cyl", variables = c("mpg", "hp")) |&gt;
  as_nested_list()
</code></pre>

<hr>
<h2 id='bind_ard'>Bind ARDs</h2><span id='topic+bind_ard'></span>

<h3>Description</h3>

<p>Wrapper for <code>dplyr::bind_rows()</code> with additional checks
for duplicated statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_ard(
  ...,
  .distinct = TRUE,
  .update = FALSE,
  .order = FALSE,
  .quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_ard_+3A_...">...</code></td>
<td>
<p>(<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>)<br />
ARDs to combine. Each argument can either be an ARD,
or a list of ARDs. Columns are matched by name, and any missing
columns will be filled with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="bind_ard_+3A_.distinct">.distinct</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to remove non-distinct values from the ARD.
Duplicates are checked across grouping variables, primary variables,
context (if present), the <strong>statistic name and the statistic value</strong>.
Default is <code>FALSE</code>. If a statistic name and value is repeated and <code>.distinct=TRUE</code>,
the more recently added statistics will be retained, and the other(s) omitted.</p>
</td></tr>
<tr><td><code id="bind_ard_+3A_.update">.update</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to update ARD and remove duplicated named statistics.
Duplicates are checked across grouping variables, primary variables, and the
<strong>statistic name</strong>.
Default is <code>FALSE</code>. If a statistic name is repeated and <code>.update=TRUE</code>,
the more recently added statistics will be retained, and the other(s) omitted.</p>
</td></tr>
<tr><td><code id="bind_ard_+3A_.order">.order</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to order the rows of the stacked ARDs, allowing
statistics that share common group and variable values to appear in
consecutive rows. Default is <code>FALSE</code>. Ordering will be based on the order
of the group/variable values prior to stacking.</p>
</td></tr>
<tr><td><code id="bind_ard_+3A_.quiet">.quiet</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to suppress any messaging. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_categorical(ADSL, by = "ARM", variables = "AGEGR1")

bind_ard(ard, ard, .update = TRUE)
</code></pre>

<hr>
<h2 id='cards.options'>Options in {cards}</h2><span id='topic+cards.options'></span>

<h3>Description</h3>

<p>See below for options available in the {cards} package
</p>


<h3>cards.round_type</h3>

<p>There are two types of rounding types in the {cards} package that are implemented
in <code>label_round()</code>, <code>alias_as_fmt_fn()</code>, and <code>apply_fmt_fn()</code> functions' <code>round_type</code>
argument.
</p>

<ul>
<li> <p><code>'round-half-up'</code> (<em>default</em>): rounding method where values exactly halfway
between two numbers are rounded to the larger in magnitude number.
Rounding is implemented via <code><a href="#topic+round5">round5()</a></code>.
</p>
</li>
<li> <p><code>'round-to-even'</code>: base R's default IEC 60559 rounding standard.
See <code><a href="base.html#topic+round">round()</a></code> for details.
</p>
</li></ul>

<p>To change the default rounding to use IEC 60559, this option must be set <strong>both</strong>
when the ARDs are created and when <code>apply_fmt_fn()</code> is run. This ensures that
any <em>default</em> formatting functions created with <code>label_round()</code> utilize the
specified rounding method and the method is used what aliases are converted
into functions (which occurs in <code>apply_fmt_fn()</code> when it calls <code>alias_as_fmt_fn()</code>).
</p>

<hr>
<h2 id='check_ard_structure'>Check ARD Structure</h2><span id='topic+check_ard_structure'></span>

<h3>Description</h3>

<p>Function tests the structure and returns notes when object does not
conform to expected structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ard_structure(x, column_order = TRUE, method = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_ard_structure_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id="check_ard_structure_+3A_column_order">column_order</code></td>
<td>
<p>(scalar <code>logical</code>)<br />
check whether ordering of columns adheres to to <code>cards::tidy_ard_column_order()</code>.</p>
</td></tr>
<tr><td><code id="check_ard_structure_+3A_method">method</code></td>
<td>
<p>(scalar <code>logical</code>)<br />
check whether a <code>"stat_name"</code> equal to <code>"method"</code> appears in results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card' (invisible)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_continuous(ADSL, variables = "AGE") |&gt;
  dplyr::select(-warning, -error) |&gt;
  check_ard_structure()
</code></pre>

<hr>
<h2 id='default_stat_labels'>Defaults for Statistical Arguments</h2><span id='topic+default_stat_labels'></span>

<h3>Description</h3>

<p>Returns a named list of statistics labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_stat_labels()
</code></pre>


<h3>Value</h3>

<p>named list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># stat labels
default_stat_labels()
</code></pre>

<hr>
<h2 id='deprecated'>Deprecated functions</h2><span id='topic+deprecated'></span><span id='topic+label_cards'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a><br />
Some functions have been deprecated and are no longer being actively
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_cards(...)
</code></pre>

<hr>
<h2 id='eval_capture_conditions'>Evaluate and Capture Conditions</h2><span id='topic+eval_capture_conditions'></span><span id='topic+captured_condition_as_message'></span><span id='topic+captured_condition_as_error'></span>

<h3>Description</h3>

<p><strong><code>eval_capture_conditions()</code></strong>
</p>
<p>Evaluates an expression while also capturing error and warning conditions.
Function always returns a named list <code>list(result=, warning=, error=)</code>.
If there are no errors or warnings, those elements will be <code>NULL</code>.
If there is an error, the result element will be <code>NULL</code>.
</p>
<p>Messages are neither saved nor printed to the console.
</p>
<p>Evaluation is done via <code><a href="rlang.html#topic+eval_tidy">rlang::eval_tidy()</a></code>. If errors and warnings are produced
using the <code>{cli}</code> package, the messages are processed with <code>cli::ansi_strip()</code>
to remove styling from the message.
</p>
<p><strong><code>captured_condition_as_message()</code>/<code>captured_condition_as_error()</code></strong>
</p>
<p>These functions take the result from <code>eval_capture_conditions()</code> and return
errors or warnings as either messages (via <code>cli::cli_inform()</code>) or
errors (via <code>cli::cli_abort()</code>). These functions handle cases where the
condition messages may include curly brackets, which would typically cause
issues when processed with the <code style="white-space: pre;">&#8288;cli::cli_*()&#8288;</code> functions.
</p>
<p>Functions return the <code>"result"</code> from <code>eval_capture_conditions()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_capture_conditions(expr, data = NULL, env = caller_env())

captured_condition_as_message(
  x,
  message = c("The following {type} occured:", x = "{condition}"),
  type = c("error", "warning"),
  envir = rlang::current_env()
)

captured_condition_as_error(
  x,
  message = c("The following {type} occured:", x = "{condition}"),
  type = c("error", "warning"),
  call = get_cli_abort_call(),
  envir = rlang::current_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_capture_conditions_+3A_expr">expr</code></td>
<td>
<p>An <a href="rlang.html#topic+topic-defuse">expression</a> or
<a href="rlang.html#topic+topic-quosure">quosure</a> to evaluate.</p>
</td></tr>
<tr><td><code id="eval_capture_conditions_+3A_data">data</code></td>
<td>
<p>A data frame, or named list or vector. Alternatively, a
data mask created with <code><a href="rlang.html#topic+as_data_mask">as_data_mask()</a></code> or
<code><a href="rlang.html#topic+new_data_mask">new_data_mask()</a></code>. Objects in <code>data</code> have priority over those in
<code>env</code>. See the section about data masking.</p>
</td></tr>
<tr><td><code id="eval_capture_conditions_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>. This
environment is not applicable for quosures because they have
their own environments.</p>
</td></tr>
<tr><td><code id="eval_capture_conditions_+3A_x">x</code></td>
<td>
<p>(<code>captured_condition</code>)<br />
a captured condition created by <code>eval_capture_conditions()</code>.</p>
</td></tr>
<tr><td><code id="eval_capture_conditions_+3A_message">message</code></td>
<td>
<p>(<code>character</code>)<br />
message passed to <code>cli::cli_inform()</code> or <code>cli::cli_abort()</code>. The condition
being printed is saved in an object named <code>condition</code>, which should be
included in this message surrounded by curly brackets.</p>
</td></tr>
<tr><td><code id="eval_capture_conditions_+3A_type">type</code></td>
<td>
<p>(<code>string</code>)<br />
the type of condition to return. Must be one of <code>'error'</code> or <code>'warning'</code>.</p>
</td></tr>
<tr><td><code id="eval_capture_conditions_+3A_envir">envir</code></td>
<td>
<p>Environment to evaluate the glue expressions in.</p>
</td></tr>
<tr><td><code id="eval_capture_conditions_+3A_call">call</code></td>
<td>
<p>(<code>environment</code>)<br />
Execution environment of currently running function. Default is
<code>get_cli_abort_call()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># function executes without error or warning
eval_capture_conditions(letters[1:2])

# an error is thrown
res &lt;- eval_capture_conditions(stop("Example Error!"))
res
captured_condition_as_message(res)

# if more than one warning is returned, all are saved
eval_capture_conditions({
  warning("Warning 1")
  warning("Warning 2")
  letters[1:2]
})

# messages are not printed to the console
eval_capture_conditions({
  message("A message!")
  letters[1:2]
})
</code></pre>

<hr>
<h2 id='get_ard_statistics'>ARD Statistics as List</h2><span id='topic+get_ard_statistics'></span>

<h3>Description</h3>

<p>Returns the statistics from an ARD as a named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ard_statistics(x, ..., .column = "stat", .attributes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ard_statistics_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id="get_ard_statistics_+3A_...">...</code></td>
<td>
<p>(<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>)<br />
optional arguments indicating rows to subset of the ARD.
For example, to return only rows where the column <code>"AGEGR1"</code> is <code>"65-80"</code>,
pass <code>AGEGR1 %in% "65-80"</code>.</p>
</td></tr>
<tr><td><code id="get_ard_statistics_+3A_.column">.column</code></td>
<td>
<p>(<code>string</code>)<br />
string indicating the column that will be returned in the list.
Default is <code>"statistic"</code></p>
</td></tr>
<tr><td><code id="get_ard_statistics_+3A_.attributes">.attributes</code></td>
<td>
<p>(<code>character</code>)<br />
character vector of column names that will be returned
in the list as attributes.
Default is <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_categorical(ADSL, by = "ARM", variables = "AGEGR1")

get_ard_statistics(
  ard,
  group1_level %in% "Placebo",
  variable_level %in% "65-80",
  .attributes = "stat_label"
)
</code></pre>

<hr>
<h2 id='label_round'>Generate Formatting Function</h2><span id='topic+label_round'></span>

<h3>Description</h3>

<p>Returns a function with the requested rounding and scaling schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_round(digits = 1, scale = 1, width = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_round_+3A_digits">digits</code></td>
<td>
<p>(<code>integer</code>)<br />
a non-negative integer specifying the number of decimal places
round statistics to</p>
</td></tr>
<tr><td><code id="label_round_+3A_scale">scale</code></td>
<td>
<p>(<code>numeric</code>)<br />
a scalar real number. Before rounding, the input will be scaled by
this quantity</p>
</td></tr>
<tr><td><code id="label_round_+3A_width">width</code></td>
<td>
<p>(<code>integer</code>)<br />
a non-negative integer specifying the minimum width of the
returned formatted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>label_round(2)(pi)
label_round(1, scale = 100)(pi)
label_round(2, width = 5)(pi)
</code></pre>

<hr>
<h2 id='maximum_variable_value'>Maximum Value</h2><span id='topic+maximum_variable_value'></span>

<h3>Description</h3>

<p>For each column in the passed data frame, the function returns a named list
with the value being the largest/last element after a sort.
For factors, the last level is returned, and for logical vectors <code>TRUE</code> is returned.
This is used as the default value in <code>ard_dichotomous(value)</code> if not specified by
the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximum_variable_value(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maximum_variable_value_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ADSL[c("AGEGR1", "BMIBLGR1")] |&gt; maximum_variable_value()
</code></pre>

<hr>
<h2 id='mock'>Mock ARDs</h2><span id='topic+mock'></span><span id='topic+mock_categorical'></span><span id='topic+mock_continuous'></span><span id='topic+mock_dichotomous'></span><span id='topic+mock_missing'></span><span id='topic+mock_attributes'></span><span id='topic+mock_total_n'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a><br />
Create empty ARDs used to create mock tables or table shells.
Where applicable, the formatting functions are set to return <code>'xx'</code> or <code>'xx.x'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mock_categorical(
  variables,
  statistic = everything() ~ c("n", "p", "N"),
  by = NULL
)

mock_continuous(
  variables,
  statistic = everything() ~ c("N", "mean", "sd", "median", "p25", "p75", "min", "max"),
  by = NULL
)

mock_dichotomous(
  variables,
  statistic = everything() ~ c("n", "p", "N"),
  by = NULL
)

mock_missing(
  variables,
  statistic = everything() ~ c("N_obs", "N_miss", "N_nonmiss", "p_miss", "p_nonmiss"),
  by = NULL
)

mock_attributes(label)

mock_total_n()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mock_+3A_variables">variables</code></td>
<td>
<p>(<code>character</code> or named <code>list</code>)<br />
a character vector of variable names for functions <code>mock_continuous()</code>,
<code>mock_missing()</code>, and <code>mock_attributes()</code>.
</p>
<p>a named list for functions <code>mock_categorical()</code> and <code>mock_dichotomous()</code>,
where the list element is a vector of variable values. For
<code>mock_dichotomous()</code>, only a single value is allowed for each variable.</p>
</td></tr>
<tr><td><code id="mock_+3A_statistic">statistic</code></td>
<td>
<p>(<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, a list of formulas, or a single formula where the list elements
are character vectors of statistic names to appear in the ARD.</p>
</td></tr>
<tr><td><code id="mock_+3A_by">by</code></td>
<td>
<p>(named <code>list</code>)<br />
a named list where the list element is a vector of variable values.</p>
</td></tr>
<tr><td><code id="mock_+3A_label">label</code></td>
<td>
<p>(named <code>list</code>)<br />
named list of variable labels, e.g. <code>list(cyl = "No. Cylinders")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mock_categorical(
  variables =
    list(
      AGEGR1 = factor(c("&lt;65", "65-80", "&gt;80"), levels = c("&lt;65", "65-80", "&gt;80"))
    ),
  by = list(TRTA = c("Placebo", "Xanomeline High Dose", "Xanomeline Low Dose"))
) |&gt;
  apply_fmt_fn()

mock_continuous(
  variables = c("AGE", "BMIBL"),
  by = list(TRTA = c("Placebo", "Xanomeline High Dose", "Xanomeline Low Dose"))
) |&gt;
  # update the mock to report 'xx.xx' for standard deviations
  update_ard_fmt_fn(variables = c("AGE", "BMIBL"), stat_names = "sd", fmt_fn = \(x) "xx.xx") |&gt;
  apply_fmt_fn()
</code></pre>

<hr>
<h2 id='nest_for_ard'>ARD Nesting</h2><span id='topic+nest_for_ard'></span>

<h3>Description</h3>

<p>This function is similar to <code><a href="tidyr.html#topic+nest">tidyr::nest()</a></code>, except that it retains
rows for unobserved combinations (and unobserved factor levels) of by
variables, and unobserved combinations of stratifying variables.
</p>
<p>The levels are wrapped in lists so they can be stacked with other types
of different classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_for_ard(
  data,
  by = NULL,
  strata = NULL,
  key = "data",
  rename_columns = TRUE,
  list_columns = TRUE,
  include_data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nest_for_ard_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="nest_for_ard_+3A_by">by</code>, <code id="nest_for_ard_+3A_strata">strata</code></td>
<td>
<p>(<code>character</code>)<br />
columns to nest by/stratify by. Arguments are similar,
but with an important distinction:
</p>
<p><code>by</code>: data frame is nested by <strong>all combinations</strong> of the columns specified,
including unobserved combinations and unobserved factor levels.
</p>
<p><code>strata</code>: data frame is nested by <strong>all <em>observed</em> combinations</strong> of the
columns specified.
</p>
<p>Arguments may be used in conjunction with one another.</p>
</td></tr>
<tr><td><code id="nest_for_ard_+3A_key">key</code></td>
<td>
<p>(<code>string</code>)<br />
the name of the new column with the nested data frame. Default is <code>"data"</code>.</p>
</td></tr>
<tr><td><code id="nest_for_ard_+3A_rename_columns">rename_columns</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to rename the <code>by</code> and <code>strata</code> variables.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nest_for_ard_+3A_list_columns">list_columns</code></td>
<td>
<p>(<code>logical</code>)<br />
logical indicating whether to put levels of <code>by</code> and
<code>strata</code> columns in a list. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nest_for_ard_+3A_include_data">include_data</code></td>
<td>
<p>(scalar <code>logical</code>)<br />
logical indicating whether to include the data subsets as a list-column.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a nested tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nest_for_ard(
  data =
    ADAE |&gt;
      dplyr::left_join(ADSL[c("USUBJID", "ARM")], by = "USUBJID") |&gt;
      dplyr::filter(AOCCSFL %in% "Y"),
  by = "ARM",
  strata = "AESOC"
)
</code></pre>

<hr>
<h2 id='print_ard_conditions'>Print ARD Condition Messages</h2><span id='topic+print_ard_conditions'></span>

<h3>Description</h3>

<p>Function parses the errors and warnings observed while calculating the
statistics requested in the ARD and prints them to the console as messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_ard_conditions(x, condition_type = c("inform", "identity"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_ard_conditions_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id="print_ard_conditions_+3A_condition_type">condition_type</code></td>
<td>
<p>(<code>string</code>)<br />
indicates how warnings and errors are returned.
Default is <code>"inform"</code> where all are returned as messages.
When <code>"identity"</code>, errors are returned as errors and warnings as warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns invisible if check is successful, throws all condition messages if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># passing a character variable for numeric summary
ard_continuous(ADSL, variables = AGEGR1) |&gt;
  print_ard_conditions()
</code></pre>

<hr>
<h2 id='print.card'>Print</h2><span id='topic+print.card'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a><br />
Print method for objects of class 'card'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'card'
print(x, n = NULL, columns = c("auto", "all"), n_col = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.card_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
object of class 'card'</p>
</td></tr>
<tr><td><code id="print.card_+3A_n">n</code></td>
<td>
<p>(<code>integer</code>)<br />
integer specifying the number of rows to print</p>
</td></tr>
<tr><td><code id="print.card_+3A_columns">columns</code></td>
<td>
<p>(<code>string</code>)<br />
string indicating whether to print a selected number of columns or all.</p>
</td></tr>
<tr><td><code id="print.card_+3A_n_col">n_col</code></td>
<td>
<p>(<code>integer</code>)<br />
some columns are removed when there are more than a threshold of
columns present. This argument sets that threshold. This is only used
when <code>columns='auto'</code> and default is <code>6L</code>.
Columns <code>'error'</code>, <code>'warning'</code>, <code>'context'</code>, and <code>'fmt_fn'</code> <em>may</em> be removed
from the print. All other columns will be printed, even if more than <code>n_col</code>
columns are present.</p>
</td></tr>
<tr><td><code id="print.card_+3A_...">...</code></td>
<td>
<p>(<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>)<br />
not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card' (invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_categorical(ADSL, variables = AGEGR1) |&gt;
  print()
</code></pre>

<hr>
<h2 id='process_selectors'>Process tidyselectors</h2><span id='topic+process_selectors'></span><span id='topic+process_formula_selectors'></span><span id='topic+fill_formula_selectors'></span><span id='topic+process_selectors.data.frame'></span><span id='topic+process_formula_selectors.data.frame'></span><span id='topic+fill_formula_selectors.data.frame'></span><span id='topic+compute_formula_selector'></span><span id='topic+check_list_elements'></span><span id='topic+cards_select'></span>

<h3>Description</h3>

<p>Functions process tidyselect arguments passed to functions in the cards package.
The processed values are saved to the calling environment, by default.
</p>

<ul>
<li> <p><code>process_selectors()</code>: the arguments will be processed with tidyselect and
converted to a vector of character column names.
</p>
</li>
<li> <p><code>process_formula_selectors()</code>: for arguments that expect named lists or
lists of formulas (where the LHS of the formula is a tidyselector). This
function processes these inputs and returns a named list. If a name is
repeated, the last entry is kept.
</p>
</li>
<li> <p><code>fill_formula_selectors()</code>: when users override the default argument values,
it can be important to ensure that each column from a data frame is assigned
a value. This function checks that each column in <code>data</code> has an assigned
value, and if not, fills the value in with the default value passed here.
</p>
</li>
<li> <p><code>compute_formula_selector()</code>: used in <code>process_formula_selectors()</code> to
evaluate a single argument.
</p>
</li>
<li> <p><code>check_list_elements()</code>: used to check the class/type/values of the list
elements, primarily those processed with <code>process_formula_selectors()</code>.
</p>
</li>
<li> <p><code>cards_select()</code>: wraps <code>tidyselect::eval_select() |&gt; names()</code>, and returns
better contextual messaging when errors occur.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>process_selectors(data, ...)

process_formula_selectors(data, ...)

fill_formula_selectors(data, ...)

## S3 method for class 'data.frame'
process_selectors(data, ..., env = caller_env())

## S3 method for class 'data.frame'
process_formula_selectors(
  data,
  ...,
  env = caller_env(),
  include_env = FALSE,
  allow_empty = TRUE
)

## S3 method for class 'data.frame'
fill_formula_selectors(data, ..., env = caller_env())

compute_formula_selector(
  data,
  x,
  arg_name = caller_arg(x),
  env = caller_env(),
  strict = TRUE,
  include_env = FALSE,
  allow_empty = TRUE
)

check_list_elements(
  x,
  predicate,
  error_msg = NULL,
  arg_name = rlang::caller_arg(x)
)

cards_select(expr, data, ..., arg_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_selectors_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="process_selectors_+3A_...">...</code></td>
<td>
<p>(<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>)<br />
named arguments where the value of the argument is processed with tidyselect.
</p>

<ul>
<li> <p><code>process_selectors()</code>: the values are tidyselect-compatible selectors
</p>
</li>
<li> <p><code>process_formula_selectors()</code>: the values are named lists, list of formulas
a combination of both, or a single formula. Users may pass <code>~value</code> as a
shortcut for <code>everything() ~ value</code>.
</p>
</li>
<li> <p><code>check_list_elements()</code>: named arguments where the name matches an existing
list in the <code>env</code> environment, and the value is a predicate function
to test each element of the list, e.g. each element must be a string or
a function.
</p>
</li></ul>
</td></tr>
<tr><td><code id="process_selectors_+3A_env">env</code></td>
<td>
<p>(<code>environment</code>)<br />
env to save the results to. Default is the calling environment.</p>
</td></tr>
<tr><td><code id="process_selectors_+3A_include_env">include_env</code></td>
<td>
<p>(<code>logical</code>)<br />
whether to include the environment from the formula object in the returned
named list. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="process_selectors_+3A_allow_empty">allow_empty</code></td>
<td>
<p>(<code>logical</code>)<br />
Logical indicating whether empty result is acceptable while process
formula-list selectors. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="process_selectors_+3A_x">x</code></td>
<td>

<ul>
<li> <p><code>compute_formula_selector()</code>: (<code><a href="#topic+syntax">formula-list-selector</a></code>)<br />
a named list, list of formulas, or a single formula that will be
converted to a named list.
</p>
</li>
<li> <p><code>check_list_elements()</code>: (named <code>list</code>)<br />
a named list
</p>
</li></ul>
</td></tr>
<tr><td><code id="process_selectors_+3A_arg_name">arg_name</code></td>
<td>
<p>(<code>string</code>)<br />
the name of the argument being processed. Used
in error messaging. Default is <code>caller_arg(x)</code>.</p>
</td></tr>
<tr><td><code id="process_selectors_+3A_strict">strict</code></td>
<td>
<p>(<code>logical</code>)<br />
whether to throw an error if a variable doesn't exist in the reference data
(passed to <code><a href="tidyselect.html#topic+eval_select">tidyselect::eval_select()</a></code>)</p>
</td></tr>
<tr><td><code id="process_selectors_+3A_predicate">predicate</code></td>
<td>
<p>(<code>function</code>)<br />
a predicate function that returns <code>TRUE</code> or <code>FALSE</code></p>
</td></tr>
<tr><td><code id="process_selectors_+3A_error_msg">error_msg</code></td>
<td>
<p>(<code>character</code>)<br />
a character vector that will
be used in error messaging when mis-specified arguments are passed. Elements
<code>"{arg_name}"</code> and <code>"{variable}"</code> are available using glue syntax for messaging.</p>
</td></tr>
<tr><td><code id="process_selectors_+3A_expr">expr</code></td>
<td>
<p>(<code>expression</code>)<br />
Defused R code describing a selection according to the tidyselect syntax.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>process_selectors()</code>, <code>fill_formula_selectors()</code>, <code>process_formula_selectors()</code>
and <code>check_list_elements()</code> return NULL. <code>compute_formula_selector()</code> returns a
named list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_env &lt;- rlang::new_environment()

process_selectors(ADSL, variables = starts_with("TRT"), env = example_env)
get(x = "variables", envir = example_env)

fill_formula_selectors(ADSL, env = example_env)

process_formula_selectors(
  ADSL,
  statistic = list(starts_with("TRT") ~ mean, TRTSDT = min),
  env = example_env
)
get(x = "statistic", envir = example_env)

check_list_elements(
  get(x = "statistic", envir = example_env),
  predicate = function(x) !is.null(x),
  error_msg = c(
    "Error in the argument {.arg {arg_name}} for variable {.val {variable}}.",
    "i" = "Value must be a named list of functions."
  )
)

# process one list
compute_formula_selector(ADSL, x = starts_with("U") ~ 1L)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+starts_with'></span><span id='topic+ends_with'></span><span id='topic+contains'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+all_of'></span><span id='topic+any_of'></span><span id='topic+everything'></span><span id='topic+where'></span><span id='topic+last_col'></span><span id='topic+one_of'></span><span id='topic+vars'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code>, <code><a href="dplyr.html#topic+reexports">all_of</a></code>, <code><a href="dplyr.html#topic+reexports">any_of</a></code>, <code><a href="dplyr.html#topic+reexports">contains</a></code>, <code><a href="dplyr.html#topic+reexports">ends_with</a></code>, <code><a href="dplyr.html#topic+reexports">everything</a></code>, <code><a href="dplyr.html#topic+reexports">last_col</a></code>, <code><a href="dplyr.html#topic+reexports">matches</a></code>, <code><a href="dplyr.html#topic+reexports">num_range</a></code>, <code><a href="dplyr.html#topic+reexports">one_of</a></code>, <code><a href="dplyr.html#topic+reexports">starts_with</a></code>, <code><a href="dplyr.html#topic+vars">vars</a></code>, <code><a href="dplyr.html#topic+reexports">where</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rename_ard_columns'>Rename ARD Columns</h2><span id='topic+rename_ard_columns'></span>

<h3>Description</h3>

<p>This function combines a pair of <code>group</code>/<code>group_level</code> or <code>variable</code>/<code>variable_level</code> columns into a
single column. The <code>group_level</code> or <code>variable_level</code> column is renamed according to the value of
the <code>group</code> or <code>variable</code> column, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_ard_columns(
  x,
  columns = c(all_ard_groups(), all_ard_variables()),
  unlist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_ard_columns_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
a data frame</p>
</td></tr>
<tr><td><code id="rename_ard_columns_+3A_columns">columns</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Name of columns to coalesce together and rename.</p>
</td></tr>
<tr><td><code id="rename_ard_columns_+3A_unlist">unlist</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Columns to unlist. Often useful when performing visual inspection
of the results where the list-columns are more difficult to work with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ADSL |&gt;
  ard_categorical(by = ARM, variables = AGEGR1) |&gt;
  apply_fmt_fn() |&gt;
  rename_ard_columns(unlist = c(stat, stat_fmt))
</code></pre>

<hr>
<h2 id='rename_ard_groups'>Rename ARD Group Columns</h2><span id='topic+rename_ard_groups'></span><span id='topic+rename_ard_groups_shift'></span><span id='topic+rename_ard_groups_reverse'></span>

<h3>Description</h3>

<p>Functions for renaming group columns names in ARDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_ard_groups_shift(x, shift = -1)

rename_ard_groups_reverse(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_ard_groups_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'.</p>
</td></tr>
<tr><td><code id="rename_ard_groups_+3A_shift">shift</code></td>
<td>
<p>(<code>integer</code>)<br />
an integer specifying how many values to shift the group IDs,
e.g. <code>shift=-1</code> renames <code>group2</code> to <code>group1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_continuous(ADSL, by = c(SEX, ARM), variables = AGE)

# Example 1 ----------------------------------
rename_ard_groups_shift(ard, shift = -1)

# Example 2 ----------------------------------
rename_ard_groups_reverse(ard)
</code></pre>

<hr>
<h2 id='replace_null_statistic'>Replace NULL Statistics with Specified Value</h2><span id='topic+replace_null_statistic'></span>

<h3>Description</h3>

<p>When a statistical summary function errors, the <code>"stat"</code> column will be
<code>NULL</code>. It is, however, sometimes useful to replace these values with a
non-<code>NULL</code> value, e.g. <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_null_statistic(x, value = NA, rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_null_statistic_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id="replace_null_statistic_+3A_value">value</code></td>
<td>
<p>(usually a <code>scalar</code>)<br />
The value to replace <code>NULL</code> values with. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="replace_null_statistic_+3A_rows">rows</code></td>
<td>
<p>(<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>)<br />
Expression that return a logical value, and are defined in terms of the variables in <code>.data</code>.
Only rows for which the condition evaluates to <code>TRUE</code> are replaced.
Default is <code>TRUE</code>, which applies to all rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the quantile functions error because the input is character, while the median function returns NA
data.frame(x = rep_len(NA_character_, 10)) |&gt;
  ard_continuous(
    variables = x,
    statistic = ~ continuous_summary_fns(c("median", "p25", "p75"))
  ) |&gt;
  replace_null_statistic(rows = !is.null(error))
</code></pre>

<hr>
<h2 id='round5'>Rounding of Numbers</h2><span id='topic+round5'></span>

<h3>Description</h3>

<p>Rounds the values in its first argument to the specified number of
decimal places (default 0). Importantly, <code>round5()</code> <strong>does not</strong> use Base R's
&quot;round to even&quot; default. Standard rounding methods are implemented, for example,
<code>cards::round5(0.5) = 1</code>, whereas <code>base::round(0.5) = 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round5(x, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="round5_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br />
a numeric vector</p>
</td></tr>
<tr><td><code id="round5_+3A_digits">digits</code></td>
<td>
<p>(<code>integer</code>)<br />
integer indicating the number of decimal places</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function inspired by <code>janitor::round_half_up()</code>.
</p>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:4 / 2
round5(x) |&gt; setNames(x)

# compare results to Base R
round(x) |&gt; setNames(x)
</code></pre>

<hr>
<h2 id='selectors'>ARD Selectors</h2><span id='topic+selectors'></span><span id='topic+all_ard_groups'></span><span id='topic+all_ard_variables'></span><span id='topic+all_ard_group_n'></span><span id='topic+all_missing_columns'></span>

<h3>Description</h3>

<p>These selection helpers match variables according to a given pattern.
</p>

<ul>
<li> <p><code>all_ard_groups()</code>: Function selects grouping columns, e.g. columns
named <code>"group##"</code> or <code>"group##_level"</code>.
</p>
</li>
<li> <p><code>all_ard_variables()</code>: Function selects variables columns, e.g. columns
named <code>"variable"</code> or <code>"variable_level"</code>.
</p>
</li>
<li> <p><code>all_ard_group_n()</code>: Function selects <code>n</code> grouping columns.
</p>
</li>
<li> <p><code>all_missing_columns()</code>: Function selects columns that are all <code>NA</code> or empty.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>all_ard_groups(types = c("names", "levels"))

all_ard_variables(types = c("names", "levels"))

all_ard_group_n(n, types = c("names", "levels"))

all_missing_columns()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectors_+3A_types">types</code></td>
<td>
<p>(<code>character</code>)<br />
type(s) of columns to select. <code>"names"</code> selects the columns variable name columns,
and <code>"levels"</code> selects the level columns. Default is <code>c("names", "levels")</code>.</p>
</td></tr>
<tr><td><code id="selectors_+3A_n">n</code></td>
<td>
<p>(<code>integer</code>)<br />
integer(s) indicating which grouping columns to select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidyselect output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard &lt;- ard_categorical(ADSL, by = "ARM", variables = "AGEGR1")

ard |&gt; dplyr::select(all_ard_groups())
ard |&gt; dplyr::select(all_ard_variables())
</code></pre>

<hr>
<h2 id='shuffle_ard'>Shuffle ARD</h2><span id='topic+shuffle_ard'></span>

<h3>Description</h3>

<p>This function ingests an ARD object and shuffles the information to prepare for analysis.
Helpful for streamlining across multiple ARDs. Combines each group/group_level into 1
column, back fills missing grouping values from the variable levels where possible, and
optionally trims statistics-level metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_ard(x, trim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_ard_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id="shuffle_ard_+3A_trim">trim</code></td>
<td>
<p>(<code>logical</code>)<br />
logical representing whether or not to trim away statistic-level metadata and filter
only on numeric statistic values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bind_ard(
  ard_categorical(ADSL, by = "ARM", variables = "AGEGR1"),
  ard_categorical(ADSL, variables = "ARM")
) |&gt;
  shuffle_ard()
</code></pre>

<hr>
<h2 id='summary_functions'>Summary Functions</h2><span id='topic+summary_functions'></span><span id='topic+continuous_summary_fns'></span>

<h3>Description</h3>


<ul>
<li> <p><code>continuous_summary_fns()</code> returns a named list of summary functions
for continuous variables. Some functions include slight modifications to
their base equivalents. For example, the <code>min()</code> and <code>max()</code> functions
return <code>NA</code> instead of <code>Inf</code> when an empty vector is passed.
Statistics <code>"p25"</code> and <code>"p75"</code> are calculated with <code>quantile(type = 2)</code>,
which matches
<a href="https://psiaims.github.io/CAMIS/Comp/r-sas-summary-stats.html">SAS's default value</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>continuous_summary_fns(
  summaries = c("N", "mean", "sd", "median", "p25", "p75", "min", "max"),
  other_stats = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_functions_+3A_summaries">summaries</code></td>
<td>
<p>(<code>character</code>)<br />
a character vector of results to include in output. Select one or more from
'N', 'mean', 'sd', 'median', 'p25', 'p75', 'min', 'max'.</p>
</td></tr>
<tr><td><code id="summary_functions_+3A_other_stats">other_stats</code></td>
<td>
<p>(named <code>list</code>)<br />
named list of other statistic functions to supplement the pre-programmed functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of summary statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'># continuous variable summaries
ard_continuous(
  ADSL,
  variables = "AGE",
  statistic = ~ continuous_summary_fns(c("N", "median"))
)
</code></pre>

<hr>
<h2 id='syntax'>Selecting Syntax</h2><span id='topic+syntax'></span>

<h3>Description</h3>

<p>Selecting Syntax
</p>


<h3>Selectors</h3>

<p>The cards package also utilizes selectors: selectors from the tidyselect
package and custom selectors. Review their help files for details.
</p>

<ul>
<li> <p><strong>tidy selectors</strong>
</p>
<p><code><a href="#topic+everything">everything()</a></code>, <code><a href="#topic+all_of">all_of()</a></code>, <code><a href="#topic+any_of">any_of()</a></code>, <code><a href="#topic+starts_with">starts_with()</a></code>, <code><a href="#topic+ends_with">ends_with()</a></code>,
<code><a href="#topic+contains">contains()</a></code>, <code><a href="#topic+matches">matches()</a></code>, <code><a href="#topic+num_range">num_range()</a></code>, <code><a href="#topic+last_col">last_col()</a></code>
</p>
</li>
<li> <p><strong>cards selectors</strong>
</p>
<p><code><a href="#topic+all_ard_groups">all_ard_groups()</a></code>, <code><a href="#topic+all_ard_variables">all_ard_variables()</a></code>
</p>
</li></ul>



<h3>Formula and List Selectors</h3>

<p>Some arguments in the cards package accept list and
formula notation, e.g. <code>ard_continuous(statistic=)</code>.
Below enumerates a few tips and shortcuts for using the list and formulas.
</p>

<ol>
<li> <p><strong>List of Formulas</strong>
</p>
<p>Typical usage includes a list of formulas, where the LHS is a variable
name or a selector.
</p>
<div class="sourceCode r"><pre>ard_continuous(statistic = list(age ~ list(N = \(x) length(x)), starts_with("a") ~ list(mean = mean)))
</pre></div>
</li>
<li> <p><strong>Named List</strong>
</p>
<p>You may also pass a named list; however, the tidyselect selectors
are not supported with this syntax.
</p>
<div class="sourceCode r"><pre>ard_continuous(statistic = list(age = list(N = \(x) length(x))))
</pre></div>
</li>
<li> <p><strong>Hybrid Named List/List of Formulas</strong>
</p>
<p>You can pass a combination of formulas and named elements.
</p>
<div class="sourceCode r"><pre>ard_continuous(statistic = list(age = list(N = \(x) length(x)), starts_with("a") ~ list(mean = mean)))
</pre></div>
</li>
<li> <p><strong>Shortcuts</strong>
</p>
<p>You can pass a single formula, which is equivalent to passing the formula
in a list.
</p>
<div class="sourceCode r"><pre>ard_continuous(statistic = starts_with("a") ~ list(mean = mean)
</pre></div>
<p>As a shortcut to select all variables, you can omit the LHS of the formula.
The two calls below are equivalent.
</p>
<div class="sourceCode r"><pre>ard_continuous(statistic = ~list(N = \(x) length(x)))
ard_continuous(statistic = everything() ~ list(N = \(x) length(x)))
</pre></div>
</li>
<li> <p><strong>Combination Selectors</strong>
</p>
<p>Selectors can be combined using the <code>c()</code> function.
</p>
<div class="sourceCode r"><pre>ard_continuous(statistic = c(everything(), -age) ~ list(N = \(x) length(x)))
</pre></div>
</li></ol>


<hr>
<h2 id='tidy_ard_order'>Standard Order of ARD</h2><span id='topic+tidy_ard_order'></span><span id='topic+tidy_ard_column_order'></span><span id='topic+tidy_ard_row_order'></span>

<h3>Description</h3>

<p>ARD functions for relocating columns and rows to the standard order.
</p>

<ul>
<li> <p><code>tidy_ard_column_order()</code> relocates columns of the ARD to the standard order.
</p>
</li>
<li> <p><code>tidy_ard_row_order()</code> orders rows of ARD according to groups and
strata (group 1, then group2, etc), while retaining the column order of the input ARD.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tidy_ard_column_order(x, group_order = c("ascending", "descending"))

tidy_ard_row_order(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_ard_order_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id="tidy_ard_order_+3A_group_order">group_order</code></td>
<td>
<p>(<code>string</code>)<br />
specifies the ordering of the grouping variables.
Must be one of <code>c("ascending", "descending")</code>.
Default is <code>"ascending"</code>, where grouping variables begin with <code>"group1"</code> variables,
followed by <code>"group2"</code> variables, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># order columns
ard &lt;-
  dplyr::bind_rows(
    ard_continuous(mtcars, variables = "mpg"),
    ard_continuous(mtcars, variables = "mpg", by = "cyl")
  )

tidy_ard_column_order(ard) |&gt;
  tidy_ard_row_order()
</code></pre>

<hr>
<h2 id='tidy_as_ard'>Build ARD from Tidier</h2><span id='topic+tidy_as_ard'></span>

<h3>Description</h3>

<p>Function converts a model's one-row tidy data frame into an ARD structure.
The tidied data frame must have been constructed with
<code><a href="#topic+eval_capture_conditions">eval_capture_conditions()</a></code>.
</p>
<p>This function is primarily for developers and few consistency checks have
been included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_as_ard(
  lst_tidy,
  tidy_result_names,
  fun_args_to_record = character(0L),
  formals = list(),
  passed_args = list(),
  lst_ard_columns
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_as_ard_+3A_lst_tidy">lst_tidy</code></td>
<td>
<p>(named <code>list</code>)<br />
list of tidied results constructed with <code><a href="#topic+eval_capture_conditions">eval_capture_conditions()</a></code>,
e.g. <code>eval_capture_conditions(t.test(mtcars$mpg ~ mtcars$am) |&gt; broom::tidy())</code>.</p>
</td></tr>
<tr><td><code id="tidy_as_ard_+3A_tidy_result_names">tidy_result_names</code></td>
<td>
<p>(<code>character</code>)<br />
character vector of column names expected by the
tidier method. This is used to construct blank results in the event of an error.</p>
</td></tr>
<tr><td><code id="tidy_as_ard_+3A_fun_args_to_record">fun_args_to_record</code></td>
<td>
<p>(<code>character</code>)<br />
character vector of function argument names that are added to the ARD.</p>
</td></tr>
<tr><td><code id="tidy_as_ard_+3A_formals">formals</code></td>
<td>
<p>(<code>pairlist</code>)<br />
the results from <code>formals()</code>, e.g. <code>formals(fisher.test)</code>.
This is used to get the default argument values from unspecified arguments.</p>
</td></tr>
<tr><td><code id="tidy_as_ard_+3A_passed_args">passed_args</code></td>
<td>
<p>(named <code>list</code>)<br />
named list of additional arguments passed to the modeling function.</p>
</td></tr>
<tr><td><code id="tidy_as_ard_+3A_lst_ard_columns">lst_ard_columns</code></td>
<td>
<p>(named <code>list</code>)<br />
named list of values that will be added to the ARD data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example how one may create a fisher.test() ARD function
my_ard_fishertest &lt;- function(data, by, variable, ...) {
  # perform fisher test and format results -----------------------------------
  lst_tidy_fisher &lt;-
    eval_capture_conditions(
      # this manipulation is similar to `fisher.test(...) |&gt; broom::tidy()`
      stats::fisher.test(x = data[[variable]], y = data[[by]], ...)[c("p.value", "method")] |&gt;
        as.data.frame()
    )

  # build ARD ------------------------------------------------------------------
  tidy_as_ard(
    lst_tidy = lst_tidy_fisher,
    tidy_result_names = c("p.value", "method"),
    fun_args_to_record =
      c(
        "workspace", "hybrid", "hybridPars", "control", "or",
        "conf.int", "conf.level", "simulate.p.value", "B"
      ),
    formals = formals(stats::fisher.test),
    passed_args = dots_list(...),
    lst_ard_columns = list(group1 = by, variable = variable, context = "fishertest")
  )
}

my_ard_fishertest(mtcars, by = "am", variable = "vs")
</code></pre>

<hr>
<h2 id='update_ard'>Update ARDs</h2><span id='topic+update_ard'></span><span id='topic+update_ard_fmt_fn'></span><span id='topic+update_ard_stat_label'></span>

<h3>Description</h3>

<p>Functions used to update ARD formatting functions and statistic labels.
</p>
<p>This is a helper function to streamline the update process. If it does not
exactly meet your needs, recall that an ARD is just a data frame and it
can be modified directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_ard_fmt_fn(
  x,
  variables = everything(),
  stat_names,
  fmt_fn,
  filter = TRUE
)

update_ard_stat_label(
  x,
  variables = everything(),
  stat_names,
  stat_label,
  filter = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_ard_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
an ARD data frame of class 'card'</p>
</td></tr>
<tr><td><code id="update_ard_+3A_variables">variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
variables in <code>x$variable</code> to apply update. Default is <code>everything()</code>.</p>
</td></tr>
<tr><td><code id="update_ard_+3A_stat_names">stat_names</code></td>
<td>
<p>(<code>character</code>)<br />
character vector of the statistic names (i.e. values from <code>x$stat_name</code>) to
apply the update.</p>
</td></tr>
<tr><td><code id="update_ard_+3A_fmt_fn">fmt_fn</code></td>
<td>
<p>(<code>function</code>)<br />
a function or alias recognized by <code>alias_as_fmt_fn()</code>.</p>
</td></tr>
<tr><td><code id="update_ard_+3A_filter">filter</code></td>
<td>
<p>(<code>expression</code>)<br />
an expression that evaluates to a logical vector identifying rows in <code>x</code>
to apply the update to. Default is <code>TRUE</code>, and update is applied to
all rows.</p>
</td></tr>
<tr><td><code id="update_ard_+3A_stat_label">stat_label</code></td>
<td>
<p>(<code>function</code>)<br />
a string of the updated statistic label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ARD data frame of class 'card'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ard_continuous(ADSL, variables = AGE) |&gt;
  update_ard_fmt_fn(stat_names = c("mean", "sd"), fmt_fn = 8L) |&gt;
  update_ard_stat_label(stat_names = c("mean", "sd"), stat_label = "Mean (SD)") |&gt;
  apply_fmt_fn()

# same as above, but only apply update to the Placebo level
ard_continuous(
  ADSL,
  by = ARM,
  variables = AGE,
  statistic = ~ continuous_summary_fns(c("N", "mean"))
) |&gt;
  update_ard_fmt_fn(stat_names = "mean", fmt_fn = 8L, filter = group1_level == "Placebo") |&gt;
  apply_fmt_fn()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
