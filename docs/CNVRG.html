<!DOCTYPE html><html><head><title>Help for package CNVRG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CNVRG}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cnvrg_HMC'><p>Perform Hamiltonian Monte Carlo sampling</p></a></li>
<li><a href='#cnvrg_VI'><p>Perform variational inference sampling</p></a></li>
<li><a href='#CNVRG-package'><p>The 'CNVRG' package.</p></a></li>
<li><a href='#diff_abund'><p>Calculate features with different abundances between treatment groups</p></a></li>
<li><a href='#diversity_calc'><p>Calculate diversity entropies for each replicate</p></a></li>
<li><a href='#extract_pi_quantiles'><p>Extract quantiles of pi parameters</p></a></li>
<li><a href='#extract_point_estimate'><p>Extract point estimates of multinomial and Dirichlet parameters</p></a></li>
<li><a href='#fungi'><p>Fungal endophytes of Astragalus lentiginosus grown near Reno, NV</p></a></li>
<li><a href='#indexer'><p>Determine indices for treatment groups</p></a></li>
<li><a href='#isd_transform'><p>Transform data into estimates of absolute abundances using an ISD</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Dirichlet Multinomial Modeling of Relative Abundance Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua Harrison &lt;joshua.grant.harrison@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Dirichlet multinomial modeling of relative abundance data using functionality provided by the 'Stan' software. The purpose of this package is to provide a user friendly way to interface with 'Stan' that is suitable for those new to modeling. For more regarding the modeling mathematics and computational techniques we use see our publication in Molecular Ecology Resources titled 'Dirichlet multinomial modeling outperforms alternatives for analysis of ecological count data' (Harrison et al. 2020 &lt;<a href="https://doi.org/10.1111%2F1755-0998.13128">doi:10.1111/1755-0998.13128</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), rstan (&ge; 2.18.1), vegan,
rstantools (&ge; 2.1.1), tibble</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-03 22:39:09 UTC; joshuaharrison</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Harrison <a href="https://orcid.org/0000-0003-2524-0273"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Vivaswat Shastry <a href="https://orcid.org/0000-0002-7294-5607"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  W. John Calder <a href="https://orcid.org/0000-0002-8923-1803"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  C. Alex Buerkle <a href="https://orcid.org/0000-0003-4222-8858"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-04 04:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='cnvrg_HMC'>Perform Hamiltonian Monte Carlo sampling</h2><span id='topic+cnvrg_HMC'></span>

<h3>Description</h3>

<p>This function uses a compiled Dirichlet multinomial model and performs Hamiltonian Monte Carlo sampling of posteriors using 'Stan'.
After sampling it is important to check convergence. Use the summary function and shinystan to do this.
If you use this function then credit 'Stan' and 'RStan' along with this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnvrg_HMC(
  countData,
  starts,
  ends,
  algorithm = "NUTS",
  chains = 2,
  burn = 500,
  samples = 1000,
  thinning_rate = 2,
  cores = 1,
  params_to_save = c("pi", "p")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnvrg_HMC_+3A_countdata">countData</code></td>
<td>
<p>A matrix or data frame of counts.The first field should be sample names and the subsequent fields should be integer data. Data should be arranged so that the first n rows correspond to one treatment group and the next n rows correspond with the next treatment group, and so on. The row indices for the first and last sample in these groups are fed into this function via 'starts' and 'ends'.</p>
</td></tr>
<tr><td><code id="cnvrg_HMC_+3A_starts">starts</code></td>
<td>
<p>A vector defining the indices that correspond to the first sample in each treatment group. The indexer function can help with this.</p>
</td></tr>
<tr><td><code id="cnvrg_HMC_+3A_ends">ends</code></td>
<td>
<p>A vector defining the indices that correspond to the last sample in each treatment group. The indexer function can help with this.</p>
</td></tr>
<tr><td><code id="cnvrg_HMC_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use when sampling. Either 'NUTS' or 'HMC' or 'Fixed_param'. If unsure, then be like a squirrel. This is &quot;No U turn sampling&quot;. The abbreviation is from 'Stan'.</p>
</td></tr>
<tr><td><code id="cnvrg_HMC_+3A_chains">chains</code></td>
<td>
<p>The number of chains to run.</p>
</td></tr>
<tr><td><code id="cnvrg_HMC_+3A_burn">burn</code></td>
<td>
<p>The warm up or 'burn in' time.</p>
</td></tr>
<tr><td><code id="cnvrg_HMC_+3A_samples">samples</code></td>
<td>
<p>How many samples from the posterior to save.</p>
</td></tr>
<tr><td><code id="cnvrg_HMC_+3A_thinning_rate">thinning_rate</code></td>
<td>
<p>Thinning rate to use during sampling.</p>
</td></tr>
<tr><td><code id="cnvrg_HMC_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use.</p>
</td></tr>
<tr><td><code id="cnvrg_HMC_+3A_params_to_save">params_to_save</code></td>
<td>
<p>The parameters from which to save samples. Can be 'p', 'pi', 'theta'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can be helpful to use the indexer function to automatically identify the indices needed for the 'starts' and 'ends' parameters. See the vignette for an example.
</p>
<p>Warning: data must be input in the correct organized format or this function will not provide accurate results. See vignette if you are unsure how to organize data.
Warning: depending upon size of data to be analyzed this function can take a very long time to run.
</p>


<h3>Value</h3>

<p>A fitted 'Stan' object that includes the samples from the parameters designated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate an OTU table
com_demo &lt;-matrix(0, nrow = 10, ncol = 10)
com_demo[1:5,] &lt;- c(rep(3,5), rep(7,5)) #Alternates 3 and 7
com_demo[6:10,] &lt;- c(rep(7,5), rep(3,5)) #Reverses alternation
fornames &lt;- NA
for(i in 1:length(com_demo[1,])){
fornames[i] &lt;- paste("otu_", i, sep = "")
}
sample_vec &lt;- NA
for(i in 1:length(com_demo[,1])){
sample_vec[i] &lt;- paste("sample", i, sep = "_")
}
com_demo &lt;- data.frame(sample_vec, com_demo)
names(com_demo) &lt;- c("sample", fornames)

#These are toy data, many more samples, multiple chains, and a longer burn
#are likely advisable for real data.
fitstan_HMC &lt;- cnvrg_HMC(com_demo,starts = c(1,6),
ends=c(5,10),
chains = 1,
burn = 100,
samples = 150,
thinning_rate = 2)
</code></pre>

<hr>
<h2 id='cnvrg_VI'>Perform variational inference sampling</h2><span id='topic+cnvrg_VI'></span>

<h3>Description</h3>

<p>This function uses a compiled Dirichlet multinomial model and performs variational inference estimation of posteriors using 'Stan'.
Evaluating the performance of variational inference is currently under development per our understanding. Please roll over to the 'Stan' website and see if new diagnostics are available.
If you use this function then credit 'Stan' and 'RStan' along with this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnvrg_VI(
  countData,
  starts,
  ends,
  algorithm = "meanfield",
  output_samples = 500,
  params_to_save = c("pi", "p")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnvrg_VI_+3A_countdata">countData</code></td>
<td>
<p>A matrix or data frame of counts.The first field should be sample names and the subsequent fields should be integer data. Data should be arranged so that the first n rows correspond to one treatment group and the next n rows correspond with the next treatment group, and so on. The row indices for the first and last sample in these groups are fed into this function via 'starts' and 'ends'.</p>
</td></tr>
<tr><td><code id="cnvrg_VI_+3A_starts">starts</code></td>
<td>
<p>A vector defining the indices that correspond to the first sample in each treatment group. The indexer function can help with this.</p>
</td></tr>
<tr><td><code id="cnvrg_VI_+3A_ends">ends</code></td>
<td>
<p>A vector defining the indices that correspond to the last sample in each treatment group. The indexer function can help with this.</p>
</td></tr>
<tr><td><code id="cnvrg_VI_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use when performing variational inference. Either 'meanfield' or 'fullrank'. The former is the default.</p>
</td></tr>
<tr><td><code id="cnvrg_VI_+3A_output_samples">output_samples</code></td>
<td>
<p>The number of samples from the approximated posterior to save.</p>
</td></tr>
<tr><td><code id="cnvrg_VI_+3A_params_to_save">params_to_save</code></td>
<td>
<p>The parameters from which to save samples. Can be 'p', 'pi', 'theta'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can be helpful to use the indexer function to automatically identify the indices needed for the 'starts' and 'ends' parameters. See the vignette for an example.
</p>
<p>Warning: data must be input in the correct organized format or this function will not provide accurate results. See vignette if you are unsure how to organize data.
Warning: depending upon size of data to be analyzed this function can take a very long time to run.
</p>


<h3>Value</h3>

<p>A fitted 'Stan' object that includes the samples from the parameters designated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate an OTU table
</code></pre>

<hr>
<h2 id='CNVRG-package'>The 'CNVRG' package.</h2><span id='topic+CNVRG-package'></span><span id='topic+CNVRG'></span>

<h3>Description</h3>

<p>This package implements Dirichlet multinomial modeling of relative abundance data using functionality provided by the 'Stan' software. The purpose of this package is to provide a user friendly way to interface with 'Stan' that is suitable for those new modelling.
</p>


<h3>References</h3>

<p>Stan Development Team (2018). RStan: the R interface to Stan. R package version 2.18.2.
</p>

<hr>
<h2 id='diff_abund'>Calculate features with different abundances between treatment groups</h2><span id='topic+diff_abund'></span>

<h3>Description</h3>

<p>This function determines which features within the matrix that was modeled differ in relative abundance among treatment groups.
Pass in a model object, with samples for pi parameters.
This function only works for pi parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_abund(model_out, countData, prob_threshold = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_abund_+3A_model_out">model_out</code></td>
<td>
<p>Output of CNVRG modeling functions, including cnvrg_HMC and cnvrg_VI</p>
</td></tr>
<tr><td><code id="diff_abund_+3A_countdata">countData</code></td>
<td>
<p>Dataframe of count data that was modeled. Should be exactly the same as those data modeled! The first field should be sample name and integer count data should be in all other fields. This is passed in so that the names of fields can be used to make the output of differential relative abundance testing more readable.</p>
</td></tr>
<tr><td><code id="diff_abund_+3A_prob_threshold">prob_threshold</code></td>
<td>
<p>Probability threshold, below which it is considered that features had a high probability of differing between groups. Default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of this function gives the proportion of samples that were greater than zero after subtracting the two relevant posterior distributions. Therefore, values that are very large or very small denote a high certainty that the distributions subtracted differ.
If this concept is not clear, then read Harrison et al. 2020 'Dirichlet multinomial modeling outperforms alternatives for analysis of microbiome and other ecological count data' in Molecular Ecology Resources.
For a simple explanation, see this video: https://use.vg/OSVhFJ
</p>
<p>The posterior probability distribution of differences is also output. These samples can be useful for plotting or other downstream analyses.
Finally, a list of data frames describing the features that differed among treatment comparisons is output, with the probability of differences and the magnitude of those differences (the effect size) included.
</p>


<h3>Value</h3>

<p>A dataframe with the first field denoting the treatment comparison (e.g., treatment 1 vs. 2) and subsequent fields stating the proportion of samples from the posterior that were greater than zero (called &quot;certainty of diffs&quot;). Note that each treatment group is compared to all other groups, which leads to some redundancy in output. A list, called ppd_diffs, holding samples from the posterior probability distribution of the differences is also output. Finally, a list of dataframes describing results for only those features with a high probability of differing is output (this list is named: features_that_differed).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate an OTU table
com_demo &lt;-matrix(0, nrow = 10, ncol = 10)
com_demo[1:5,] &lt;- c(rep(3,5), rep(7,5)) #Alternates 3 and 7
com_demo[6:10,] &lt;- c(rep(7,5), rep(3,5)) #Reverses alternation
fornames &lt;- NA
for(i in 1:length(com_demo[1,])){
fornames[i] &lt;- paste("otu_", i, sep = "")
}
sample_vec &lt;- NA
for(i in 1:length(com_demo[,1])){
sample_vec[i] &lt;- paste("sample", i, sep = "_")
}
com_demo &lt;- data.frame(sample_vec, com_demo)
names(com_demo) &lt;- c("sample", fornames)

out &lt;- cnvrg_VI(com_demo,starts = c(1,6), ends=c(5,10))
diff_abund_test &lt;- diff_abund(model_out = out, countData = com_demo)
</code></pre>

<hr>
<h2 id='diversity_calc'>Calculate diversity entropies for each replicate</h2><span id='topic+diversity_calc'></span>

<h3>Description</h3>

<p>Calculate Shannon's or Simpson's indices for each replicate while propagating uncertainty in relative abundance estimates through calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity_calc(
  model_out,
  countData,
  params = "pi",
  entropy_measure = "shannon",
  equivalents = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversity_calc_+3A_model_out">model_out</code></td>
<td>
<p>Output of CNVRG modeling functions, including cnvrg_HMC and cnvrg_VI or isd_transform</p>
</td></tr>
<tr><td><code id="diversity_calc_+3A_countdata">countData</code></td>
<td>
<p>Dataframe of count data that was modeled. Should be exactly the same as those data modeled! The first field should be sample name and integer count data should be in all other fields. This is passed in so that the names of fields can be used to make the output of differential relative abundance testing more readable.</p>
</td></tr>
<tr><td><code id="diversity_calc_+3A_params">params</code></td>
<td>
<p>Parameter for which to calculate diversity, can be 'p' or 'pi' or both (e.g., c(&quot;pi&quot;,&quot;p&quot;))</p>
</td></tr>
<tr><td><code id="diversity_calc_+3A_entropy_measure">entropy_measure</code></td>
<td>
<p>Diversity entropy to use, can be one of 'shannon' or 'simpson'</p>
</td></tr>
<tr><td><code id="diversity_calc_+3A_equivalents">equivalents</code></td>
<td>
<p>Convert entropies into number equivalents. Defaults to true. See Jost (2006), &quot;Entropy and diversity&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes as input either a fitted Stan object from the cnvrg_HMC or cnvrg_VI functions, or the output of isd_transform.
As always, doublecheck the results to ensure the function has output reasonable values. Note that because there are no zero values
and all proportion estimates are non zero there is a lot of information within the modeled data. Because diversity entropies
are measures of information content, this means there will be a much higher entropy estimate for modeled data than the raw
count data. However, patterns of variation in diversity should be similar among treatment groups for modeled and raw data.
</p>


<h3>Value</h3>

<p>A list that has samples from posterior distributions of entropy metrics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate an OTU table
com_demo &lt;-matrix(0, nrow = 10, ncol = 10)
com_demo[1:5,] &lt;- c(rep(3,5), rep(7,5)) #Alternates 3 and 7
com_demo[6:10,] &lt;- c(rep(7,5), rep(3,5)) #Reverses alternation
fornames &lt;- NA
for(i in 1:length(com_demo[1,])){
fornames[i] &lt;- paste("otu_", i, sep = "")
}
sample_vec &lt;- NA
for(i in 1:length(com_demo[,1])){
sample_vec[i] &lt;- paste("sample", i, sep = "_")
}
com_demo &lt;- data.frame(sample_vec, com_demo)
names(com_demo) &lt;- c("sample", fornames)

out &lt;- cnvrg_VI(com_demo,starts = c(1,6), ends=c(5,10))
diversity_calc(model_out = out,params = c("pi","p"),
countData = com_demo, entropy_measure = 'shannon')
</code></pre>

<hr>
<h2 id='extract_pi_quantiles'>Extract quantiles of pi parameters</h2><span id='topic+extract_pi_quantiles'></span>

<h3>Description</h3>

<p>Provides quantiles of pi parameters for each feature and treatment group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_pi_quantiles(model_out, probs = c(0.05, 0.5, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_pi_quantiles_+3A_model_out">model_out</code></td>
<td>
<p>Output of CNVRG modeling functions, including cnvrg_HMC and cnvrg_VI</p>
</td></tr>
<tr><td><code id="extract_pi_quantiles_+3A_probs">probs</code></td>
<td>
<p>A vector of quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list specifying quantiles for each feature in each treatment group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate an OTU table
com_demo &lt;-matrix(0, nrow = 10, ncol = 10)
com_demo[1:5,] &lt;- c(rep(3,5), rep(7,5)) #Alternates 3 and 7
com_demo[6:10,] &lt;- c(rep(7,5), rep(3,5)) #Reverses alternation
fornames &lt;- NA
for(i in 1:length(com_demo[1,])){
fornames[i] &lt;- paste("otu_", i, sep = "")
}
sample_vec &lt;- NA
for(i in 1:length(com_demo[,1])){
sample_vec[i] &lt;- paste("sample", i, sep = "_")
}
com_demo &lt;- data.frame(sample_vec, com_demo)
names(com_demo) &lt;- c("sample", fornames)

out &lt;- cnvrg_VI(com_demo,starts = c(1,6), ends=c(5,10))
extract_pi_quantiles(model_out = out, probs = c(0.05,0.5,0.95))
</code></pre>

<hr>
<h2 id='extract_point_estimate'>Extract point estimates of multinomial and Dirichlet parameters</h2><span id='topic+extract_point_estimate'></span>

<h3>Description</h3>

<p>Provides the mean value of posterior probability distributions for parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_point_estimate(model_out, countData, params = c("pi", "p"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_point_estimate_+3A_model_out">model_out</code></td>
<td>
<p>Output of CNVRG modeling functions, including cnvrg_HMC and cnvrg_VI</p>
</td></tr>
<tr><td><code id="extract_point_estimate_+3A_countdata">countData</code></td>
<td>
<p>The count data modeled.</p>
</td></tr>
<tr><td><code id="extract_point_estimate_+3A_params">params</code></td>
<td>
<p>Parameters to be extracted, either pi (Dirichlet) or p (multinomial).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of of point estimates for model parameters. If both multinomial and Dirichlet parameters are requested then they will be named elements of a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate an OTU table
com_demo &lt;-matrix(0, nrow = 10, ncol = 10)
com_demo[1:5,] &lt;- c(rep(3,5), rep(7,5)) #Alternates 3 and 7
com_demo[6:10,] &lt;- c(rep(7,5), rep(3,5)) #Reverses alternation
fornames &lt;- NA
for(i in 1:length(com_demo[1,])){
fornames[i] &lt;- paste("otu_", i, sep = "")
}
sample_vec &lt;- NA
for(i in 1:length(com_demo[,1])){
sample_vec[i] &lt;- paste("sample", i, sep = "_")
}
com_demo &lt;- data.frame(sample_vec, com_demo)
names(com_demo) &lt;- c("sample", fornames)

out &lt;- cnvrg_VI(com_demo,starts = c(1,6), ends=c(5,10))
extract_point_estimate(model_out = out, countData = com_demo)
</code></pre>

<hr>
<h2 id='fungi'>Fungal endophytes of Astragalus lentiginosus grown near Reno, NV</h2><span id='topic+fungi'></span>

<h3>Description</h3>

<p>Fungal endophytes of Astragalus lentiginosus grown near Reno, NV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fungi
</code></pre>


<h3>Format</h3>

<p>A data frame with columns:
</p>

<dl>
<dt>treatment</dt><dd><p>A categorical variable describing if a plant was treated with a slurry of endophyte inoculum and whether it was positive or negative for Alternaria fulva.</p>
</dd>
<dt>Otu10</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu100</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu11</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu12</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu4</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu40</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu42</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu54</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu58</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu6</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu62</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu7</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu70</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu71</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu72</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu74</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu76</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu77</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu79</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu86</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu9</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu92</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu94</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu96</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu97</dt><dd><p>Contains count data.</p>
</dd>
<dt>Otu99</dt><dd><p>Contains count data.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Joshua G. Harrison, <a href="https://www.biorxiv.org/content/10.1101/608729v1.full">https://www.biorxiv.org/content/10.1101/608729v1.full</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 fungi

## End(Not run)
</code></pre>

<hr>
<h2 id='indexer'>Determine indices for treatment groups</h2><span id='topic+indexer'></span>

<h3>Description</h3>

<p>This function determines the indices for the first and last replicates within a vector describing treatment group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexer_+3A_x">x</code></td>
<td>
<p>Vector input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two named elements that contain start and end indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>indexer(c(rep("treatment1",5), rep("treatment2",5)))
</code></pre>

<hr>
<h2 id='isd_transform'>Transform data into estimates of absolute abundances using an ISD</h2><span id='topic+isd_transform'></span>

<h3>Description</h3>

<p>If an internal standard (ISD) has been added to samples such that the counts for that standard are representative of the same absolute abundance, then the ISD can be used to transform relative abundance data such that they are proportional to absolute abundances (Harrison et al. 2020).
This function performs this division while preserving uncertainty in relative abundance estimates of both the ISD and the other features present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isd_transform(model_out, isd_index, countData, format = "stan")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isd_transform_+3A_model_out">model_out</code></td>
<td>
<p>Output of CNVRG modeling functions, including cnvrg_HMC and cnvrg_VI</p>
</td></tr>
<tr><td><code id="isd_transform_+3A_isd_index">isd_index</code></td>
<td>
<p>The index for the field with information for the internal standard.</p>
</td></tr>
<tr><td><code id="isd_transform_+3A_countdata">countData</code></td>
<td>
<p>The count data modeled.</p>
</td></tr>
<tr><td><code id="isd_transform_+3A_format">format</code></td>
<td>
<p>The output format. Can be either 'or 'samples' or 'ml'. &quot;samples&quot; outputs samples from the posterior probability distribution, the last option (&quot;ml&quot;) outputs the mean of posterior samples for each parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An index for the ISD must be provided. This should be the field index that corresponds with the ISD. Remember that the index should mirror what has been modeled. Also, note that this function subtracts one from this index because the modeled data have a non integer sample field.
If the wrong index is passed in, the output of this function will be incorrect, but there will not be a fatal error or warning.
</p>
<p>A simple check that the correct index has been passed to the function is to examine the output and make sure that the field that should correspond with the ISD is one (signifying that the ISD was divided by itself).
</p>
<p>Output format can either as means of the samples for each pi parameter or the transformed samples from the posterior distribution for that parameter.
Harrison et al. 2020. 'The quest for absolute abundance: the use of internal standards for DNA based community ecology' Molecular Ecology Resources.
</p>


<h3>Value</h3>

<p>A dataframe, or list, specifying either point estimates for each feature in each treatment group (if output format is 'ml') or samples from the posterior (if output format is 'samples').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate an OTU table
com_demo &lt;-matrix(0, nrow = 10, ncol = 10)
com_demo[1:5,] &lt;- c(rep(3,5), rep(7,5)) #Alternates 3 and 7
com_demo[6:10,] &lt;- c(rep(7,5), rep(3,5)) #Reverses alternation
fornames &lt;- NA
for(i in 1:length(com_demo[1,])){
fornames[i] &lt;- paste("otu_", i, sep = "")
}
sample_vec &lt;- NA
for(i in 1:length(com_demo[,1])){
sample_vec[i] &lt;- paste("sample", i, sep = "_")
}
com_demo &lt;- data.frame(sample_vec, com_demo)
names(com_demo) &lt;- c("sample", fornames)

#Model the data
out &lt;- cnvrg_VI(com_demo,starts = c(1,6), ends=c(5,10))
#Transform the data
transformed_data &lt;- isd_transform(model_out = out, countData = com_demo,
isd_index = 3, format = "ml")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
