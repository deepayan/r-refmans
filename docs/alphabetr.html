<!DOCTYPE html><html><head><title>Help for package alphabetr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {alphabetr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bagpipe'><p>Identify candidate alpha/beta pairs.</p></a></li>
<li><a href='#chain_scores'><p>Calculate association scores between alpha and beta chain pairs.</p></a></li>
<li><a href='#combine_freq_results'><p>Combines the frequency estimation results from single TCR clones and dual TCR clones</p></a></li>
<li><a href='#create_clones'><p>Create a synthetic set of clones with a specific underlying clonal structure</p></a></li>
<li><a href='#create_data'><p>Simulate sequencing data obtained from the alphabetr approach with a specified clonal structure</p></a></li>
<li><a href='#create_data_singlecells'><p>Simulate sequencing data obtained single-cell sequencing</p></a></li>
<li><a href='#dual_discrim_dual_likelihood'><p>Calculate likelihood of two beta-sharing candidate alpha-beta pairs deriving from a dual clone</p></a></li>
<li><a href='#dual_discrim_shared_likelihood'><p>Calculate likelihood of two beta-sharing candidate alpha-beta pairs deriving from a dual clone</p></a></li>
<li><a href='#dual_eval'><p>Calculate dual depths and false dual rates for simulated alphabetr experiments</p></a></li>
<li><a href='#dual_tail'><p>Discriminate between beta-sharing clones and dual-alpha TCR clones (optimized</p>
for rare clones)</a></li>
<li><a href='#dual_top'><p>Discriminate between beta-sharing clones and dual-alpha TCR clones (optimized</p>
for common clones)</a></li>
<li><a href='#freq_estimate'><p>Estimation of frequencies of clones identified by <code>alphabetr</code></p></a></li>
<li><a href='#freq_eval'><p>Calculate the precision, CV, and accuracy of frequency estimates</p></a></li>
<li><a href='#likelihood_dual'><p>Calculate likelihood curve of frequency estimates for a dual-alpha or</p>
dual-beta TCR clone</a></li>
<li><a href='#likelihood_dualdual'><p>Calculate likelihood curve of frequency estimates for a dual-alpha and</p>
dual-beta TCR clone</a></li>
<li><a href='#likelihood_single'><p>Calculate likelihood curve of frequency estimates for a single TCR clone</p></a></li>
<li><a href='#read_alphabetr'><p>Read in alphabetr sequencing data into the binary matrix form needed by bagpipe()</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Algorithms for High-Throughput Sequencing of Antigen-Specific T
Cells</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides algorithms for frequency-based pairing of alpha-beta T
  cell receptors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3), clue (&ge; 0.3-50), dplyr (&ge; 0.4.3),
multicool (&ge; 0.1-9)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/edwardslee/alphabetr">http://github.com/edwardslee/alphabetr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/edwardslee/alphabetr">http://github.com/edwardslee/alphabetr</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-28 02:16:30 UTC; Edward</td>
</tr>
<tr>
<td>Author:</td>
<td>Edward Lee [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edward Lee &lt;email.edwardlee@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-28 17:31:24</td>
</tr>
</table>
<hr>
<h2 id='bagpipe'>Identify candidate alpha/beta pairs.</h2><span id='topic+bagpipe'></span>

<h3>Description</h3>

<p><code>bagpipe()</code> uses the alphabetr resampling procedure on sequencing data
to identify candidate alpha/beta pairs. The procedure takes a subsample of
the data without replacement, calculates association scores with
<code><a href="#topic+chain_scores">chain_scores</a></code>, and then for each well, uses the Hungarian
algorithm to determine the most likely pairings for the chains found in the
well. Each time this is done is a replicate, and the number of replicates is
specified as an option. A threshold is then used to filter the candidate
pairs that appear in proportion of the replicates larger than the threshold,
resulting in the final list of candidate pairs. Bagpipe is an acronym for
<strong>b</strong>ootstrapping <strong>a</strong>lphabetr <strong>g</strong>enerated
<strong>p</strong>a<strong>i</strong>rs <strong>p</strong>rocedur<strong>e</strong> (based on older versions
that utilized bootstrapping)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bagpipe(alpha, beta, replicates = 100, frac = 0.75, bootstrap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bagpipe_+3A_alpha">alpha</code></td>
<td>
<p>Matrix recording which alpha chains appear in each well of the
data. See <code><a href="#topic+create_data">create_data</a></code>.</p>
</td></tr>
<tr><td><code id="bagpipe_+3A_beta">beta</code></td>
<td>
<p>Matrix recording which beta chains appear in the each well of the
data. See <code><a href="#topic+create_data">create_data</a></code>.</p>
</td></tr>
<tr><td><code id="bagpipe_+3A_replicates">replicates</code></td>
<td>
<p>The number of times the resampling procedure is repeated,
i.e. the number of replicates. At least 100 replicates is recommended.</p>
</td></tr>
<tr><td><code id="bagpipe_+3A_frac">frac</code></td>
<td>
<p>The fraction of the wells resampled in each replicate. Default
is 75% of the wells</p>
</td></tr>
<tr><td><code id="bagpipe_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Legacy option. Calls a bootstrapping strategy (which
resamples with replacement) instead of sampling a subset without
replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A n x 5 matrix where n is the number of clones determined by
<code>bagpipe()</code>. Each row represents the chains of the clone.
Columns 1 and 2 represent the beta chain indices of the clone.
Columns 3 and 4 represent the alpha chain indices of the clone.
Column 5 represents the number of replicates that this clone was found in.
Column 5 is used to filter our the clones that have not be determined by
a certain &quot;threshold&quot; proportion of replicates.
</p>
<p>Note that column 1 == column 2 and column 3 == column 4 since
<code>bagpipe()</code> does not try to determine dual-alpha or dual-beta clones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # see the help for create_clones() and create_data()
 clones &lt;- create_clones(numb_beta = 1000,
                         dual_alpha = .3,
                         dual_beta = .06,
                         alpha_sharing = c(0.80, 0.15, 0.05),
                         beta_sharing  = c(0.75, 0.20, 0.05))
 dat &lt;- create_data(clones$TCR, plate = 5,
                    error_drop = c(.15, .01),
                    error_seq  = c(.05, .001),
                    error_mode = c("lognormal", "lognormal"),
                    skewed = 10,
                    prop_top = 0.6,
                    dist = "linear",
                    numb_cells = matrix(c(50, 480), ncol = 2))

 ## Not run: 
 # normally want to set replicates to 100 or more
 pairs &lt;- bagpipe(alpha = dat$alpha,
               beta  = dat$beta,
               replicates = 5,
               frac = 0.75,
               bootstrap = FALSE)

 # using a threshold of 0.3 of replicates
 pairs &lt;- pairs[pairs[, 5] &gt; 0.3, ]
 
## End(Not run)
</code></pre>

<hr>
<h2 id='chain_scores'>Calculate association scores between alpha and beta chain pairs.</h2><span id='topic+chain_scores'></span>

<h3>Description</h3>

<p><code>chain_scores()</code> calculates association scores between every pair of
alpha and beta chains based on the number of concurrent well appearances
each alpha and beta pair makes, scaled inversely by the number of unique
chains in that well. See Lee et. al. for more information about this
procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain_scores(data_a, data_b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain_scores_+3A_data_a">data_a</code></td>
<td>
<p>Matrix recording which alpha chains appear in each well of the
data. See <code><a href="#topic+create_clones">create_clones</a></code>.</p>
</td></tr>
<tr><td><code id="chain_scores_+3A_data_b">data_b</code></td>
<td>
<p>Matrix recording which beta chains appear in the each well of the
data. See <code><a href="#topic+create_clones">create_clones</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the alpha and beta association scores. Accessed
with <code>list$ascores</code> and <code>list$bscores</code> respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # see the help for create_clones() and create_data()
 clones &lt;- create_clones(numb_beta = 1000,
                         dual_alpha = .3,
                         dual_beta  = .06,
                         alpha_sharing = c(0.80, 0.15, 0.05),
                         beta_sharing  = c(0.75, 0.20, 0.05))
 dat &lt;- create_data(clones$TCR, plate = 5,
                    error_drop = c(.15, .01),
                    error_seq  = c(.05, .001),
                    error_mode = c("lognormal", "lognormal"),
                    skewed = 10,
                    prop_top = 0.6,
                    dist = "linear",
                    numb_cells = matrix(c(50, 480), ncol = 2))

 #this is done internally in bagpipe()
 scores &lt;- chain_scores(data_a = dat$alpha, data_b = dat$beta)
 scores &lt;- scores$ascores + t(scores$bscores)

</code></pre>

<hr>
<h2 id='combine_freq_results'>Combines the frequency estimation results from single TCR clones and dual TCR clones</h2><span id='topic+combine_freq_results'></span>

<h3>Description</h3>

<p><code>combine_freq_results()</code> combines the results of the frequency estimation
performed on single TCR clones (from the output of <code><a href="#topic+bagpipe">bagpipe</a></code>) and
the frequency estimation performed on dual clones. The code will find the
rows of the single TCR frequency results that are represented by the dual
clones and replace them with the appropriate dual clone entry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_freq_results(single, dual)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_freq_results_+3A_single">single</code></td>
<td>
<p>Frequency estimation results of single TCR clones (usually from
the first time <code><a href="#topic+freq_estimate">freq_estimate</a></code> is called)</p>
</td></tr>
<tr><td><code id="combine_freq_results_+3A_dual">dual</code></td>
<td>
<p>Frequency estimation results of dual TCR-alpha clones</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the same structure as the output of
<code><a href="#topic+freq_estimate">freq_estimate</a></code>. If two single &quot;clones&quot; in the <code>single</code>
data.frame is represented by a dual clone in <code>dual</code>, then it is
removed and replaced with one row represented by the dual clone.
</p>

<hr>
<h2 id='create_clones'>Create a synthetic set of clones with a specific underlying clonal structure</h2><span id='topic+create_clones'></span>

<h3>Description</h3>

<p><code>create_clones()</code> creates a set of (beta1, beta2, alpha1, alpha2)
quadruples that represent the indices of the chains of clones. The function
will take a fixed number of unique beta chains that are in the T cell
population, and then use the degree of beta and alpha sharing to determine
the number of unique alpha chains in the populations. These chains will
then be randomly assigned to each other, with a proportion of them being
dual TCR clones (i.e. alpha1 != alpha2 and/or beta1 != beta2), forming
our random list of clones with their chain indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_clones(numb_beta, dual_beta, dual_alpha, alpha_sharing, beta_sharing)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_clones_+3A_numb_beta">numb_beta</code></td>
<td>
<p>The number of unique betas in the clonal population</p>
</td></tr>
<tr><td><code id="create_clones_+3A_dual_beta">dual_beta</code></td>
<td>
<p>The proportion of clone that are dual TCRbeta clones, i.e.
has two distinct beta chains</p>
</td></tr>
<tr><td><code id="create_clones_+3A_dual_alpha">dual_alpha</code></td>
<td>
<p>The proportion of clones that are dual TCRalpha clones,
i.e. has two distinct alpha chains</p>
</td></tr>
<tr><td><code id="create_clones_+3A_alpha_sharing">alpha_sharing</code></td>
<td>
<p>A vector where the ith position represents the
proportion of alpha chains that are shared by i clones; alpha chains can
be shared by up to 7 clones</p>
</td></tr>
<tr><td><code id="create_clones_+3A_beta_sharing">beta_sharing</code></td>
<td>
<p>A vector where the ith position represents the
proportion of beta chains that are shared by i clones; beta chains can be
shared by up to 5 clones</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of four different matrices. Each matrix is has dimensions
n x 4, where n is the total number of clones and each row represents the
chains of a clone. Column 1 and column 2 are the beta index/indices of the
beta chain(s) used by the clone. Column 3 and 4 are the alpha index/indices
of the alpha chain(s) used by the clone. If a clone has a single beta
chain, then col 1 and col 2 will be equal. If a clone has a single alpha
chain, then col 3 and col 4 will be equal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Creating a population containing 1000 beta chains; 10% of clones with
 # dual-beta TCRs and 30% of clones with dual TCRs; 75% beta shared by one
 # clone, 20% by two clones, 5% by three clones; 80% alpha chains shared by
 # one clone, 15% by two clones, and 5% by three clones

 clones &lt;- create_clones(numb_beta = 1000,
                         dual_alpha = .3,
                         dual_beta  = .06,
                         alpha_sharing = c(0.80, 0.15, 0.05),
                         beta_sharing  = c(0.75, 0.20, 0.05))

</code></pre>

<hr>
<h2 id='create_data'>Simulate sequencing data obtained from the alphabetr approach with a specified clonal structure</h2><span id='topic+create_data'></span>

<h3>Description</h3>

<p><code>create_data()</code> simulates an alphabetr sequencing experiment by sampling
clones from a clonal structure specified by the user. The clones are
placed on a frequency distribution where a fixed number clones represents
the top proportion of the population in frequency and the other clones
represent the rest of the population in frequency. Different error models
and different sampling strategies can be simulated as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_data(TCR, plates, error_drop, error_seq, error_mode, skewed, prop_top,
  dist = "linear", numb_cells)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_data_+3A_tcr">TCR</code></td>
<td>
<p>The specified clonal structure, which can be created from
<code><a href="#topic+create_clones">create_clones</a></code>.</p>
</td></tr>
<tr><td><code id="create_data_+3A_plates">plates</code></td>
<td>
<p>The number of plates of data.</p>
</td></tr>
<tr><td><code id="create_data_+3A_error_drop">error_drop</code></td>
<td>
<p>A vector of length 2 with the mean of the drop error rate
and the sd of the drop error rate.</p>
</td></tr>
<tr><td><code id="create_data_+3A_error_seq">error_seq</code></td>
<td>
<p>A vector of length 2 with the mean of the in-frame error
rate and the sd of the in-frame error rate.</p>
</td></tr>
<tr><td><code id="create_data_+3A_error_mode">error_mode</code></td>
<td>
<p>A vector of two strings determining the &quot;mode&quot; of the error
models. The first element sets the mode of the drop errors, and the second
element sets the mode of the in-frame errors. The two modes available are
&quot;constant&quot; for a constant error rate and &quot;lognormal&quot; for error rates
drawn from a lognormal distribution. If the mode is set to &quot;constant&quot; the
sd specified in <code>error_drop</code> and/or <code>error_seq</code> will be ignored.</p>
</td></tr>
<tr><td><code id="create_data_+3A_skewed">skewed</code></td>
<td>
<p>Number of clones represent the top proportion of the population
by frequency (which is specified by <code>prop_top</code>).</p>
</td></tr>
<tr><td><code id="create_data_+3A_prop_top">prop_top</code></td>
<td>
<p>The proportion of the population in frequency represented by
the number of clones specified by <code>skewed</code>.</p>
</td></tr>
<tr><td><code id="create_data_+3A_dist">dist</code></td>
<td>
<p>The distribution of frequency of the top clones. Currently only
&quot;linear&quot; is available.</p>
</td></tr>
<tr><td><code id="create_data_+3A_numb_cells">numb_cells</code></td>
<td>
<p>A two column matrix determining the sampling strategy of
the experiment. The first column represents the number of cells per well,
and the second column represents the number of wells with that sample
size. The sum of column 2 should equal 96 times the number of plates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2. The first element is a matrix representing the
data of the alpha chains, and the second element is a matrix representing
the data of beta chains. The matrix represents the sequencing data by
representing the wells of the data by rows and the chain indices by
column. Entry [i, j] of the matrix represents if chain j is found in
well i (yes == 1, no == 0). e.g. if alpha chain 25 is found in well 10,
then [10, 25] of the alpha matrix will be 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # see the help for create_clones() for details of this function call
 clones &lt;- create_clones(numb_beta = 1000,
                         dual_alpha = .3,
                         dual_beta = .06,
                         alpha_sharing = c(0.80, 0.15, 0.05),
                         beta_sharing  = c(0.75, 0.20, 0.05))

 # creating a data set with 5 plates, lognormal error rates, 10 clones
 # making up the top 60% of the population in frequency, and a constant
 # sampling strategy of 50 cells per well for 480 wells (five 96-well plates)
 dat &lt;- create_data(clones$TCR, plate = 5,
                    error_drop = c(.15, .01),
                    error_seq  = c(.05, .001),
                    error_mode = c("lognormal", "lognormal"),
                    skewed = 10,
                    prop_top = 0.6,
                    dist = "linear",
                    numb_cells = matrix(c(50, 480), ncol = 2))

</code></pre>

<hr>
<h2 id='create_data_singlecells'>Simulate sequencing data obtained single-cell sequencing</h2><span id='topic+create_data_singlecells'></span>

<h3>Description</h3>

<p><code>create_data_singlecells()</code> simulates a single-cell sequencing
experiment by sampling clones from a clonal structure specified by the user
and using the same error models and frequency distributions used in
<code><a href="#topic+create_data">create_data</a></code>. These functions are almost identical except this
one simulates the sampling and sequencing of single T cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_data_singlecells(TCR, plates = 5, error_drop = c(0.15, 0.01),
  error_seq = c(0.05, 0.01), error_mode = c("constant", "constant"),
  skewed = 15, prop_top = 0.5, dist = "linear")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_data_singlecells_+3A_tcr">TCR</code></td>
<td>
<p>The specified clonal structure, which can be created from
<code><a href="#topic+create_clones">create_clones</a></code>.</p>
</td></tr>
<tr><td><code id="create_data_singlecells_+3A_plates">plates</code></td>
<td>
<p>The number of plates of data. The number of single-cells is 96
times <code>plates</code>.</p>
</td></tr>
<tr><td><code id="create_data_singlecells_+3A_error_drop">error_drop</code></td>
<td>
<p>A vector of length 2 with the mean of the drop error rate
and the sd of the drop error rate.</p>
</td></tr>
<tr><td><code id="create_data_singlecells_+3A_error_seq">error_seq</code></td>
<td>
<p>A vector of length 2 with the mean of the in-frame error
rate and the sd of the in-frame error rate.</p>
</td></tr>
<tr><td><code id="create_data_singlecells_+3A_error_mode">error_mode</code></td>
<td>
<p>A vector of two strings determining the &quot;mode&quot; of the error
models. The first element sets the mode of the drop errors, and the second
element sets the mode of the in-frame errors. The two modes available are
&quot;constant&quot; for a constant error rate and &quot;lognormal&quot; for error rates
drawn from a lognormal distribution. If the mode is set to &quot;constant&quot; the
sd specified in <code>error_drop</code> and/or <code>error_seq</code> will be ignored.</p>
</td></tr>
<tr><td><code id="create_data_singlecells_+3A_skewed">skewed</code></td>
<td>
<p>Number of clones represent the top proportion of the population
by frequency (which is specified by <code>prop_top</code>).</p>
</td></tr>
<tr><td><code id="create_data_singlecells_+3A_prop_top">prop_top</code></td>
<td>
<p>The proportion of the population in frequency represented by
the number of clones specified by <code>skewed</code>.</p>
</td></tr>
<tr><td><code id="create_data_singlecells_+3A_dist">dist</code></td>
<td>
<p>The distribution of frequency of the top clones. Currently only
&quot;linear&quot; is available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 3. The first element is a matrix representing the
data of the alpha chains ($alpha), and the second element is a matrix representing
the data of beta chains ($beta). The matrix represents the sequencing data by
representing the wells of the data by rows and the chain indices by
column. Entry [i, j] of the matrix represents if chain j is found in
well i (yes == 1, no == 0). e.g. if alpha chain 25 is found in well 10,
then [10, 25] of the alpha matrix will be 1.
</p>
<p>The third element of the list ($drop) is a matrix that records the index
of the <strong>clone</strong> sampled in the well (col 1), records if a drop error
occurred (col 2), and record if an in-frame error occurred (col 3).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # see the help for create_clones() for details of this function call
 clones &lt;- create_clones(numb_beta = 1000,
                      dual_alpha = .3,
                      dual_beta  = .06,
                      alpha_sharing = c(0.80, 0.15, 0.05),
                      beta_sharing  = c(0.75, 0.20, 0.05))

 # creating a data set with 480 single cells, lognormal error rates, 10 clones
 # making up the top 60% of the population in frequency, and a constant
 # sampling strategy of 50 cells per well for 480 wells (five 96-well plates)
 dat &lt;- create_data_singlecells(clones$TCR, plate = 5,
                                error_drop = c(.15, .01),
                                error_seq  = c(.05, .001),
                                error_mode = c("lognormal", "lognormal"),
                                skewed = 10,
                                prop_top = 0.6,
                                dist = "linear")


</code></pre>

<hr>
<h2 id='dual_discrim_dual_likelihood'>Calculate likelihood of two beta-sharing candidate alpha-beta pairs deriving from a dual clone</h2><span id='topic+dual_discrim_dual_likelihood'></span>

<h3>Description</h3>

<p><code>dual_discrim_dual_likelihood()</code> is used within <code><a href="#topic+dual_top">dual_top</a></code>
to calculate the likelihood that two alpha-beta pairs identified by
<code><a href="#topic+bagpipe">bagpipe</a></code> sharing the same beta chain derive from a single
dual-alpha clone (instead of two distinct clones sharing the same beta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual_discrim_dual_likelihood(est, err, numb_cells, numb_wells, binomials)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual_discrim_dual_likelihood_+3A_est">est</code></td>
<td>
<p>Frequency estimate of the putative dual-alpha clone</p>
</td></tr>
<tr><td><code id="dual_discrim_dual_likelihood_+3A_err">err</code></td>
<td>
<p>Mean drop error rate</p>
</td></tr>
<tr><td><code id="dual_discrim_dual_likelihood_+3A_numb_cells">numb_cells</code></td>
<td>
<p>Vector containing the number of cells per well</p>
</td></tr>
<tr><td><code id="dual_discrim_dual_likelihood_+3A_numb_wells">numb_wells</code></td>
<td>
<p>Vector containing the number of wells with the sample
sizes given by <code>numb_cells</code></p>
</td></tr>
<tr><td><code id="dual_discrim_dual_likelihood_+3A_binomials">binomials</code></td>
<td>
<p>Calculations of the needed binomial coefficients; this is
faster in R than in Rcpp (from my own tests)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric containing the negative log likelihood
</p>

<hr>
<h2 id='dual_discrim_shared_likelihood'>Calculate likelihood of two beta-sharing candidate alpha-beta pairs deriving from a dual clone</h2><span id='topic+dual_discrim_shared_likelihood'></span>

<h3>Description</h3>

<p><code>dual_discrim_shared_likelihood()</code> is used within <code><a href="#topic+dual_top">dual_top</a></code>
to calculate the likelihood that two alpha-beta pairs identified by
<code><a href="#topic+bagpipe">bagpipe</a></code> sharing the same beta chain derive from a two
distinct clones sharing the same beta chain dual-alpha clone (instead of
a single dual-alpha clone)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual_discrim_shared_likelihood(est1, est2, err, numb_cells, numb_wells,
  binomials, multinomials)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual_discrim_shared_likelihood_+3A_est1">est1</code></td>
<td>
<p>Frequency estimate of the first alpha-beta clone</p>
</td></tr>
<tr><td><code id="dual_discrim_shared_likelihood_+3A_est2">est2</code></td>
<td>
<p>Frequency estimate of the second alpha-beta clone</p>
</td></tr>
<tr><td><code id="dual_discrim_shared_likelihood_+3A_err">err</code></td>
<td>
<p>Mean drop error rate</p>
</td></tr>
<tr><td><code id="dual_discrim_shared_likelihood_+3A_numb_cells">numb_cells</code></td>
<td>
<p>Vector containing the number of cells per well</p>
</td></tr>
<tr><td><code id="dual_discrim_shared_likelihood_+3A_numb_wells">numb_wells</code></td>
<td>
<p>Vector containing the number of wells with the sample
sizes given by <code>numb_cells</code></p>
</td></tr>
<tr><td><code id="dual_discrim_shared_likelihood_+3A_binomials">binomials</code></td>
<td>
<p>Calculations of the needed binomial coefficients; this is
faster in R than in Rcpp (from my own tests)</p>
</td></tr>
<tr><td><code id="dual_discrim_shared_likelihood_+3A_multinomials">multinomials</code></td>
<td>
<p>Calculations of the needed multinomial coefficients;
this is way faster in R due to vectorization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric containing the negative log likelihood
</p>

<hr>
<h2 id='dual_eval'>Calculate dual depths and false dual rates for simulated alphabetr experiments</h2><span id='topic+dual_eval'></span>

<h3>Description</h3>

<p><code>dual_eval()</code> is used in simulation situations to compare the duals
determined by <code><a href="#topic+dual_top">dual_top</a></code> and <code><a href="#topic+dual_tail">dual_tail</a></code> (which can
be combined with <code>rbind()</code>) to the duals in the simulated T cell
population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual_eval(duals, pair, TCR, number_skewed, TCR_dual)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual_eval_+3A_duals">duals</code></td>
<td>
<p>A 4 column matrix (col 1 + 2 = beta indices, col 3 + 4 = alpha
indices) containing the indices of dual-alpha clones. The output of
<code><a href="#topic+dual_top">dual_top</a></code> and <code><a href="#topic+dual_tail">dual_tail</a></code> are in this form (and
the outputs of these two functions can combined by using <code>rbind()</code>)</p>
</td></tr>
<tr><td><code id="dual_eval_+3A_pair">pair</code></td>
<td>
<p>The output of <code><a href="#topic+bagpipe">bagpipe</a></code></p>
</td></tr>
<tr><td><code id="dual_eval_+3A_tcr">TCR</code></td>
<td>
<p>The clonal structure of the simulated T cell population. This is
obtained by subsetting the <code>TCR</code> element of the output of
<code><a href="#topic+create_clones">create_clones</a></code></p>
</td></tr>
<tr><td><code id="dual_eval_+3A_number_skewed">number_skewed</code></td>
<td>
<p>The number of clones represent the top proportion of
the T cell population by frequency (this is the same <code>number_skewed</code>
argument used when <code><a href="#topic+create_clones">create_clones</a></code> is called)</p>
</td></tr>
<tr><td><code id="dual_eval_+3A_tcr_dual">TCR_dual</code></td>
<td>
<p>The dual clones of the simulated T cell population. This is
obtained by subsetting the <code>dual_alph</code> element of the output of
<code><a href="#topic+create_clones">create_clones</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<ul>
<li> <p><code>fdr</code>, the false dual rate
</p>
</li>
<li> <p><code>numb_cand_duals</code>, the number of duals identified
</p>
</li>
<li> <p><code>adj_depth_top</code>, the adjusted dual depth of top clones
</p>
</li>
<li> <p><code>abs_depth_top</code>, the absolute dual depth of top clones
</p>
</li>
<li> <p><code>numb_correct_top</code>, the number of correctly identified dual
clones in the top
</p>
</li>
<li> <p><code>numb_duals_ans_top</code>, the number of top dual clones in the
simulated T cell population
</p>
</li>
<li> <p><code>numb_poss_top</code>, the number of top dual clones whose beta and
both alpha chains were identified by <code>bagpipe()</code>
</p>
</li>
<li> <p><code>numb_unestimated_top</code>, number of top dual clones whose
frequencies could not be calculated (usually because the clones
appeared in every well of the data)
</p>
</li>
<li> <p><code>adj_depth_tail</code>, the adjusted dual depth of tail clones
</p>
</li>
<li> <p><code>abs_depth_tail</code>, the absolute dual depth of tail clones
</p>
</li>
<li> <p><code>numb_correct_tail</code>, the number of correctly identified tail
clones
</p>
</li>
<li> <p><code>numb_duals_ans_tail</code>, the number of dual tail clones in the
simulated T cell population
</p>
</li>
<li> <p><code>numb_poss_tail</code>, the number of tail dual cloens whose beta
and both alpha chains were identified by <code>bagpipe()</code>
</p>
</li>
<li> <p><code>numb_unestimated_tail</code>, the number of tail clones whose
frequencies could not be calculated
</p>
</li></ul>


<hr>
<h2 id='dual_tail'>Discriminate between beta-sharing clones and dual-alpha TCR clones (optimized
for rare clones)</h2><span id='topic+dual_tail'></span>

<h3>Description</h3>

<p><code>dual_tail()</code> distinguishes between clones that share a common beta
chain and dual TCR clones with two productive alpha chains. The procedure
tests the null hypothesis that two candidate alpha, beta pairs with the
same beta represent two separate clones by using the frequency estimates
to calculate the number of wells that both clones are expected to be in.
This is compared to the actual number of wells that both clones appear in,
and if the actual number is greater than the expected number, than the
pairs are chosen to represent a dual TCR clone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual_tail(alpha, beta, freq_results, numb_cells)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual_tail_+3A_alpha">alpha</code></td>
<td>
<p>Matrix recording which alpha chains appear in each well of the
data. See <code><a href="#topic+create_data">create_data</a></code>.</p>
</td></tr>
<tr><td><code id="dual_tail_+3A_beta">beta</code></td>
<td>
<p>Matrix recording which beta chains appear in the each well of the
data. See <code><a href="#topic+create_data">create_data</a></code>.</p>
</td></tr>
<tr><td><code id="dual_tail_+3A_freq_results">freq_results</code></td>
<td>
<p>Output of <code><a href="#topic+freq_estimate">freq_estimate</a></code>.</p>
</td></tr>
<tr><td><code id="dual_tail_+3A_numb_cells">numb_cells</code></td>
<td>
<p>Vector containing the number of cells sampled in the wells
of each column of the plates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A n x 3 matrix where n is the number of candidate clones, column 1
is the beta index of the clone, and column 2-3 are the alpha indices of
the clone
</p>

<hr>
<h2 id='dual_top'>Discriminate between beta-sharing clones and dual-alpha TCR clones (optimized
for common clones)</h2><span id='topic+dual_top'></span>

<h3>Description</h3>

<p><code>dual_top()</code> distinguishes between clones that share a common beta
chain and dual TCR clones with two productive alpha chains. The procedure
calculates the likelihood that two (alpha, beta) pairs (with common a beta
chain) come from two distinct clones sharing the same beta chain vs the
likelihood that the two pairs derive from a dual TCR-alpha clone.
A significant difference between the two likelihoods is indicative of a
dual alpha clone, and these clones are returned as dual clones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual_top(alpha, beta, pair, error, numb_cells)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual_top_+3A_alpha">alpha</code></td>
<td>
<p>Matrix recording which alpha chains appear in each well of the
data. See <code><a href="#topic+create_data">create_data</a></code>.</p>
</td></tr>
<tr><td><code id="dual_top_+3A_beta">beta</code></td>
<td>
<p>Matrix recording which beta chains appear in the each well of the
data. See <code><a href="#topic+create_data">create_data</a></code>.</p>
</td></tr>
<tr><td><code id="dual_top_+3A_pair">pair</code></td>
<td>
<p>A matrix where each row is a beta/alpha pair, column 1 and 2 are
the beta indices, and column 3 and 4 are the alpha indices, and column 5
is the proportion of replicates the clone was found in (or equal to -1 if
the clone is dual)</p>
</td></tr>
<tr><td><code id="dual_top_+3A_error">error</code></td>
<td>
<p>The mean error &quot;dropped&quot; chain rate due to PCR or sequencing
errors.</p>
</td></tr>
<tr><td><code id="dual_top_+3A_numb_cells">numb_cells</code></td>
<td>
<p>The number of cells per well in each column of the plates.
Should be a vector of 12 elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dual-alpha clones, where col 1 and 2 are beta indices of
the clone (which should be equal) and col 3 and 4 are alpha indices of the
clone (which are different).
</p>

<hr>
<h2 id='freq_estimate'>Estimation of frequencies of clones identified by <code>alphabetr</code></h2><span id='topic+freq_estimate'></span>

<h3>Description</h3>

<p><code>freq_estimate()</code> estimates the frequencies of clones with confidence
intervals by using a maximum likelihood approach. The function looks at
the wells that a chains of a clone appear in and determines the most
likely frequency that explains the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_estimate(alpha, beta, pair, error = 0.15, numb_cells)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_estimate_+3A_alpha">alpha</code></td>
<td>
<p>Matrix recording which alpha chains appear in each well of the
data. See <code><a href="#topic+create_data">create_data</a></code>.</p>
</td></tr>
<tr><td><code id="freq_estimate_+3A_beta">beta</code></td>
<td>
<p>Matrix recording which beta chains appear in the each well of the
data. See <code><a href="#topic+create_data">create_data</a></code>.</p>
</td></tr>
<tr><td><code id="freq_estimate_+3A_pair">pair</code></td>
<td>
<p>A matrix where each row is a beta/alpha pair, column 1 and 2 are
the beta indices, and column 3 and 4 are the alpha indices, and column 5
is the proportion of replicates the clone was found in (or equal to -1 if
the clone is dual)</p>
</td></tr>
<tr><td><code id="freq_estimate_+3A_error">error</code></td>
<td>
<p>The mean error &quot;dropped&quot; chain rate due to PCR or sequencing
errors.</p>
</td></tr>
<tr><td><code id="freq_estimate_+3A_numb_cells">numb_cells</code></td>
<td>
<p>The number of cells per well in each column of the plates.
Should be a vector of 12 elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with frequency estimates and confidence intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 # obtained from the output of bagpipe()
 pairs &lt;- pairs[pairs[, 5] &gt; 0.3, ]
 freq  &lt;- freq_estimate(alpha = dat$alpha,
                        beta = dat$beta,
                        pair = pairs,
                        numb_cells = matrix(c(50, 480), ncol = 2))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='freq_eval'>Calculate the precision, CV, and accuracy of frequency estimates</h2><span id='topic+freq_eval'></span>

<h3>Description</h3>

<p><code>freq_eval()</code> will evaluated how well <code><a href="#topic+freq_estimate">freq_estimate</a></code> performed
by calculating the precision and CV of the frequency estimates for the top
clones and by determining the proportion of the top clones whose true clonal
frequency lies in the 95-percent CI determined by <code><a href="#topic+freq_estimate">freq_estimate</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_eval(freq, number_skewed, TCR, numb_clones, prop_top)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_eval_+3A_freq">freq</code></td>
<td>
<p>The output of <code><a href="#topic+freq_estimate">freq_estimate</a></code></p>
</td></tr>
<tr><td><code id="freq_eval_+3A_number_skewed">number_skewed</code></td>
<td>
<p>The number of clones represent the top proportion of
the T cell population by frequency (this is the same <code>number_skewed</code>
argument used when <code><a href="#topic+create_clones">create_clones</a></code> is called)</p>
</td></tr>
<tr><td><code id="freq_eval_+3A_tcr">TCR</code></td>
<td>
<p>The clonal structure of the simulated T cell population. This is
obtained by subsetting the <code>TCR</code> element of the output of
<code><a href="#topic+create_clones">create_clones</a></code></p>
</td></tr>
<tr><td><code id="freq_eval_+3A_numb_clones">numb_clones</code></td>
<td>
<p>Total number of distinct clones in the parent population</p>
</td></tr>
<tr><td><code id="freq_eval_+3A_prop_top">prop_top</code></td>
<td>
<p>The proportion of the population in frequency represented by
the number of clones specified by <code>skewed</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the precision, cv, and accuracy of the frequency estimation.
</p>

<hr>
<h2 id='likelihood_dual'>Calculate likelihood curve of frequency estimates for a dual-alpha or
dual-beta TCR clone</h2><span id='topic+likelihood_dual'></span>

<h3>Description</h3>

<p>Calculate likelihood curve of frequency estimates for a dual-alpha or
dual-beta TCR clone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood_dual(est, err, numb_wells, numb_cells, numb_sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_dual_+3A_est">est</code></td>
<td>
<p>Clonal frequency estimate</p>
</td></tr>
<tr><td><code id="likelihood_dual_+3A_err">err</code></td>
<td>
<p>Mean drop error rate</p>
</td></tr>
<tr><td><code id="likelihood_dual_+3A_numb_wells">numb_wells</code></td>
<td>
<p>A vector with the number of wells with the distinct
sample sizes</p>
</td></tr>
<tr><td><code id="likelihood_dual_+3A_numb_cells">numb_cells</code></td>
<td>
<p>A vector of the distinct sample sizes, i.e. the number of
cells per well</p>
</td></tr>
<tr><td><code id="likelihood_dual_+3A_numb_sample">numb_sample</code></td>
<td>
<p>A vector with the number of wells of the sample size of
the same position of <code>numb_cells</code> that contains both alpha and the
beta chain of the clone (for dual-alpha clones) or both beta and the
alpha chain of the clone (for dual-beta clones)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric with the negative log likelihood
</p>

<hr>
<h2 id='likelihood_dualdual'>Calculate likelihood curve of frequency estimates for a dual-alpha and
dual-beta TCR clone</h2><span id='topic+likelihood_dualdual'></span>

<h3>Description</h3>

<p>Calculate likelihood curve of frequency estimates for a dual-alpha and
dual-beta TCR clone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood_dualdual(est, err, numb_wells, numb_cells, numb_sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_dualdual_+3A_est">est</code></td>
<td>
<p>Clonal frequency estimate</p>
</td></tr>
<tr><td><code id="likelihood_dualdual_+3A_err">err</code></td>
<td>
<p>Mean drop error rate</p>
</td></tr>
<tr><td><code id="likelihood_dualdual_+3A_numb_wells">numb_wells</code></td>
<td>
<p>A vector with the number of wells with the distinct
sample sizes</p>
</td></tr>
<tr><td><code id="likelihood_dualdual_+3A_numb_cells">numb_cells</code></td>
<td>
<p>A vector of the distinct sample sizes, i.e. the number of
cells per well</p>
</td></tr>
<tr><td><code id="likelihood_dualdual_+3A_numb_sample">numb_sample</code></td>
<td>
<p>A vector  with the number of wells of the sample size of
the same position of <code>numb_cells</code> that contains both alpha and both
betachains the clone</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric with the negative log likelihood
</p>

<hr>
<h2 id='likelihood_single'>Calculate likelihood curve of frequency estimates for a single TCR clone</h2><span id='topic+likelihood_single'></span>

<h3>Description</h3>

<p>Calculate likelihood curve of frequency estimates for a single TCR clone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood_single(est, err, numb_wells, numb_cells, numb_sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_single_+3A_est">est</code></td>
<td>
<p>Clonal frequency estimate</p>
</td></tr>
<tr><td><code id="likelihood_single_+3A_err">err</code></td>
<td>
<p>Mean drop error rate</p>
</td></tr>
<tr><td><code id="likelihood_single_+3A_numb_wells">numb_wells</code></td>
<td>
<p>A vector with the number of wells with the distinct
sample sizes</p>
</td></tr>
<tr><td><code id="likelihood_single_+3A_numb_cells">numb_cells</code></td>
<td>
<p>A vector of the distinct sample sizes, i.e. the number of
cells per well</p>
</td></tr>
<tr><td><code id="likelihood_single_+3A_numb_sample">numb_sample</code></td>
<td>
<p>A vector with the number of wells of the sample size of
the same position of <code>numb_cells</code> that contains the alpha and beta
chains the clone</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric with the negative log likelihood
</p>

<hr>
<h2 id='read_alphabetr'>Read in alphabetr sequencing data into the binary matrix form needed by bagpipe()</h2><span id='topic+read_alphabetr'></span>

<h3>Description</h3>

<p><code>read_alphabetr()</code> will read in two different forms of a csv file to
convert sequencing data using the alphabetr approach into the binary
matrices required by <code><a href="#topic+bagpipe">bagpipe</a></code>. The csv file(s) can have one of
two forms. (1) A single csv file with three columns: column 1 containing
whether the sequence is &quot;TCRA&quot; or &quot;TCRB&quot;; column 2 containing the well
number; and column 3 containing the CDR3 sequence
(2) Two CSV files, one for TCRA and one for TCRB, with two columns: column
1 containing the well number and column 2 containing the CDR3 sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_alphabetr(data = NULL, data_alpha = NULL, data_beta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_alphabetr_+3A_data">data</code></td>
<td>
<p>To read in a 3-column csv file containing both TCRA and TCRB
sequencing information</p>
</td></tr>
<tr><td><code id="read_alphabetr_+3A_data_alpha">data_alpha</code></td>
<td>
<p>To read in a 2-column csv file containing TCRA sequencing
information. Must be used in conjunction with the <code>data_beta</code>
argument and cannot be used with the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="read_alphabetr_+3A_data_beta">data_beta</code></td>
<td>
<p>To read in a 2-column csv file containing TCRB sequencing
information. Must be used in conjunction with the <code>data_alpha</code>
argument and cannot eb used with the <code>data</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two binary matrices that represent the sequencing data and
two character vectors that give the CDR3 sequences associated with each
chain index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  dat &lt;- read_alphabetr(data = "alphabetr_data.csv")

  # saving the alpha and beta binary matrices
  data_alpha &lt;- dat$alpha
  data_beta  &lt;- dat$beta

  # finding the cdr3 sequences of alpha_2 and beta_4 respectively
  cdr3_alpha2 &lt;- dat$alpha_lib[2]
  cdr3_beta4  &lt;- dat$beta_lib[4]

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
