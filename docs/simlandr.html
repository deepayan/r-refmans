<!DOCTYPE html><html lang="en"><head><title>Help for package simlandr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simlandr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simlandr-package'><p>simlandr: Simulation-Based Landscape Construction for Dynamical Systems</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#arg_set-class'><p>Create and modify argument sets, then make an argument grid</p>
for batch simulation</a></li>
<li><a href='#as.mcmc.list'><p>as.mcmc.list generic function</p></a></li>
<li><a href='#as.mcmc.list.list'><p>Convert a list of simulation output to a mcmc.list object</p></a></li>
<li><a href='#attach_all_matrices'><p>Attach all matrices in a batch simulation</p></a></li>
<li><a href='#autolayer'><p>Autolayer generic function</p></a></li>
<li><a href='#autolayer.barrier'><p>Get a ggplot2 layer from a barrier object</p></a></li>
<li><a href='#batch_simulation'><p>Perform a batch simulation.</p></a></li>
<li><a href='#calculate_barrier'><p>Functions for calculating energy barrier from landscapes</p></a></li>
<li><a href='#check_conv'><p>Graphical diagnoses to check if the simulation converges</p></a></li>
<li><a href='#fill_in_struct'><p>Fill a vector of values into a structure list.</p></a></li>
<li><a href='#get_barrier_height'><p>Summarize the barrier height from a <code>barrier</code> object</p></a></li>
<li><a href='#get_dist'><p>Get the probability distribution from a landscape object</p></a></li>
<li><a href='#get_geom'><p>Get a ggplot2 layer from a barrier object</p></a></li>
<li><a href='#hash_big_matrix-class'><p>Class &quot;hash_big_matrix&quot;: big matrix with a md5 hash reference</p></a></li>
<li><a href='#make_2d_matrix'><p>Make a matrix of 2D static landscape plots for one or two parameters</p></a></li>
<li><a href='#make_2d_static'><p>Make 2D static landscape plot for a single simulation output</p></a></li>
<li><a href='#make_2d_tidy_dist'><p>Make a tidy <code>data.frame</code> from smooth 2d distribution matrix</p></a></li>
<li><a href='#make_3d_animation'><p>Make 3d animations from multiple simulations</p></a></li>
<li><a href='#make_3d_matrix'><p>Make a matrix of 3D static landscape plots for one or two parameters</p></a></li>
<li><a href='#make_3d_static'><p>Make 3D static landscape plots from simulation output</p></a></li>
<li><a href='#make_4d_static'><p>Make 4D static space-color plots from simulation output</p></a></li>
<li><a href='#make_barrier_grid_2d'><p>Make a grid for calculating barriers for 2d landscapes</p></a></li>
<li><a href='#make_barrier_grid_3d'><p>Make a grid for calculating barriers for 3d landscapes</p></a></li>
<li><a href='#make_kernel_dist'><p>Calculate 1D, 2D, or 3D kernel smooth distribution</p></a></li>
<li><a href='#modified_simulation'><p>Modify a single simulation</p></a></li>
<li><a href='#multi_init_simulation'><p>Simulate multiple 1-3D Markovian Stochastic Differential Equations</p></a></li>
<li><a href='#plot.landscape'><p>Make plots from landscape objects</p></a></li>
<li><a href='#save_landscape'><p>Save landscape plots</p></a></li>
<li><a href='#sim_fun_grad'><p>A simple gradient simulation function for testing</p></a></li>
<li><a href='#sim_fun_nongrad'><p>A simple non-gradient simulation function for testing</p></a></li>
<li><a href='#sim_fun_test'><p>A simple simulation function for testing</p></a></li>
<li><a href='#sim_fun_test2'><p>A simple yet meaningful simulation function for testing</p></a></li>
<li><a href='#sim_SDE'><p>Simulate 1-3D Markovian Stochastic Differential Equations</p></a></li>
<li><a href='#summary.barrier'><p>Summarize the barrier height from a <code>barrier</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation-Based Landscape Construction for Dynamical Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for constructing potential landscapes for dynamical
    systems using Monte Carlo simulation.  The method is based on the
    potential landscape definition by Wang et al. (2008)
    &lt;<a href="https://doi.org/10.1073%2Fpnas.0800579105">doi:10.1073/pnas.0800579105</a>&gt; (also see Zhou &amp; Li, 2016
    &lt;<a href="https://doi.org/10.1063%2F1.4943096">doi:10.1063/1.4943096</a>&gt; for further mathematical discussions) and can
    be used for a large variety of models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sciurus365.github.io/simlandr/">https://sciurus365.github.io/simlandr/</a>,
<a href="https://github.com/Sciurus365/simlandr">https://github.com/Sciurus365/simlandr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Sciurus365/simlandr/issues">https://github.com/Sciurus365/simlandr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bigmemory, coda, digest, dplyr, forcats, furrr, gganimate,
ggplot2, grDevices, htmlwidgets, ks, lifecycle, magrittr, MASS,
methods, plotly, progress, purrr, rlang, Sim.DiffProc, tibble,
tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, webshot</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-12 13:52:09 UTC; jingm</td>
</tr>
<tr>
<td>Author:</td>
<td>Jingmeng Cui <a href="https://orcid.org/0000-0003-3421-8457"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jingmeng Cui &lt;jingmeng.cui@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-12 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simlandr-package'>simlandr: Simulation-Based Landscape Construction for Dynamical Systems</h2><span id='topic+simlandr'></span><span id='topic+simlandr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A toolbox for constructing potential landscapes for dynamical systems using Monte Carlo simulation. The method is based on the potential landscape definition by Wang et al. (2008) <a href="https://doi.org/10.1073/pnas.0800579105">doi:10.1073/pnas.0800579105</a> (also see Zhou &amp; Li, 2016 <a href="https://doi.org/10.1063/1.4943096">doi:10.1063/1.4943096</a> for further mathematical discussions) and can be used for a large variety of models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jingmeng Cui <a href="mailto:jingmeng.cui@outlook.com">jingmeng.cui@outlook.com</a> (<a href="https://orcid.org/0000-0003-3421-8457">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://sciurus365.github.io/simlandr/">https://sciurus365.github.io/simlandr/</a>
</p>
</li>
<li> <p><a href="https://github.com/Sciurus365/simlandr">https://github.com/Sciurus365/simlandr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Sciurus365/simlandr/issues">https://github.com/Sciurus365/simlandr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code style="white-space: pre;">&#8288;magrittr::[\%&gt;\%][magrittr::pipe]&#8288;</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='arg_set-class'>Create and modify argument sets, then make an argument grid
for batch simulation</h2><span id='topic+arg_set-class'></span><span id='topic+new_arg_set'></span><span id='topic+add_arg_ele'></span><span id='topic+nele'></span><span id='topic+narg'></span><span id='topic+print.arg_set'></span><span id='topic+make_arg_grid'></span><span id='topic+print.arg_grid'></span>

<h3>Description</h3>

<p>An argument set contains the descriptions of the relevant variables in a
batch simulation. Use <code>new_arg_set()</code> to create an <code>arg_set</code>
object, and use <code>add_arg_ele()</code> to add an element to the <code>arg_set</code>. After
adding all elements in the argument set, use <code>make_arg_grid()</code> to make an
argument grid that can be used directly for running batch simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_arg_set()

add_arg_ele(arg_set, arg_name, ele_name, start, end, by)

nele(arg_set)

narg(arg_set)

## S3 method for class 'arg_set'
print(x, detail = FALSE, ...)

make_arg_grid(arg_set)

## S3 method for class 'arg_grid'
print(x, detail = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arg_set-class_+3A_arg_set">arg_set</code></td>
<td>
<p>An <code>arg_set</code> object.</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_arg_name">arg_name</code>, <code id="arg_set-class_+3A_ele_name">ele_name</code></td>
<td>
<p>The name of the argument and its element
in the simulation function</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_start">start</code>, <code id="arg_set-class_+3A_end">end</code>, <code id="arg_set-class_+3A_by">by</code></td>
<td>
<p>The data points where you want to test the variables.
Passed to <code>seq</code>.</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_x">x</code></td>
<td>
<p>An <code>arg_set</code> object</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_detail">detail</code></td>
<td>
<p>Do you want to print the object details as a full list?</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>new_arg_set()</code> returns an <code>arg_set</code> object.
</p>
<p><code>add_arg_ele()</code> returns an <code>arg_set</code> object.
</p>
<p><code>nele()</code> returns an integer.
</p>
<p><code>narg()</code> returns an integer.
</p>
<p><code>make_arg_gird()</code> returns an <code>arg_grid</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>new_arg_set()</code>: Create an <code>arg_set</code>.
</p>
</li>
<li> <p><code>add_arg_ele()</code>: Add an element to an <code>arg_set</code>.
</p>
</li>
<li> <p><code>nele()</code>: The number of elements in an <code>arg_set</code>.
</p>
</li>
<li> <p><code>narg()</code>: The number of arguments in an <code>arg_set</code>.
</p>
</li>
<li> <p><code>print(arg_set)</code>: Print an <code>arg_set</code> object.
</p>
</li>
<li> <p><code>make_arg_grid()</code>: Make an argument grid from an argument set.
</p>
</li>
<li> <p><code>print(arg_grid)</code>: Print an <code>arg_grid</code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+batch_simulation">batch_simulation()</a></code> for running batch simulation and a
concrete example.
</p>

<hr>
<h2 id='as.mcmc.list'>as.mcmc.list generic function</h2><span id='topic+as.mcmc.list'></span>

<h3>Description</h3>

<p>See <code><a href="coda.html#topic+mcmc.list">coda::as.mcmc.list()</a></code>, <code><a href="#topic+as.mcmc.list.list">as.mcmc.list.list()</a></code> for details.
</p>

<hr>
<h2 id='as.mcmc.list.list'>Convert a list of simulation output to a mcmc.list object</h2><span id='topic+as.mcmc.list.list'></span>

<h3>Description</h3>

<p>This function can be used to convert a list of simulation output to a mcmc.list object. This may be useful when the output of the simulation is a list of matrices, and you want to perform convergence checks using the functions in the coda package. See <code><a href="coda.html#topic+mcmc.list">coda::mcmc.list()</a></code> for more information, and also see the examples in the documentation of <code><a href="#topic+sim_SDE">sim_SDE()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
as.mcmc.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.mcmc.list.list_+3A_x">x</code></td>
<td>
<p>A list of simulation output</p>
</td></tr>
<tr><td><code id="as.mcmc.list.list_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mcmc.list object
</p>

<hr>
<h2 id='attach_all_matrices'>Attach all matrices in a batch simulation</h2><span id='topic+attach_all_matrices'></span>

<h3>Description</h3>

<p>Attach all matrices in a batch simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_all_matrices(bs, backingpath = "bp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attach_all_matrices_+3A_bs">bs</code></td>
<td>
<p>A <code>batch_simulation</code> object.</p>
</td></tr>
<tr><td><code id="attach_all_matrices_+3A_backingpath">backingpath</code></td>
<td>
<p>Passed to <code><a href="bigmemory.html#topic+big.matrix">bigmemory::as.big.matrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>batch_simulation</code> object with all <code>hash_big_matrix</code>es attached.
</p>

<hr>
<h2 id='autolayer'>Autolayer generic function</h2><span id='topic+autolayer'></span>

<h3>Description</h3>

<p>See <code><a href="ggplot2.html#topic+autolayer">ggplot2::autolayer()</a></code>, <code><a href="#topic+autolayer.barrier">autolayer.barrier()</a></code> for details.
</p>

<hr>
<h2 id='autolayer.barrier'>Get a ggplot2 layer from a barrier object</h2><span id='topic+autolayer.barrier'></span>

<h3>Description</h3>

<p>This layer can show the saddle point (2d) and the minimal energy path (3d) on the landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'barrier'
autolayer(object, path = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autolayer.barrier_+3A_object">object</code></td>
<td>
<p>A <code>barrier</code> object.</p>
</td></tr>
<tr><td><code id="autolayer.barrier_+3A_path">path</code></td>
<td>
<p>Show the minimum energy path in the graph?</p>
</td></tr>
<tr><td><code id="autolayer.barrier_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> layer that can be added to an existing landscape plot.
</p>

<hr>
<h2 id='batch_simulation'>Perform a batch simulation.</h2><span id='topic+batch_simulation'></span><span id='topic+print.batch_simulation'></span>

<h3>Description</h3>

<p>Perform a batch simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_simulation(
  arg_grid,
  sim_fun,
  default_list = list(),
  bigmemory = TRUE,
  ...
)

## S3 method for class 'batch_simulation'
print(x, detail = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batch_simulation_+3A_arg_grid">arg_grid</code></td>
<td>
<p>An <code>arg_grid</code> object. See <code><a href="#topic+make_arg_grid">make_arg_grid()</a></code>.</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_sim_fun">sim_fun</code></td>
<td>
<p>The simulation function. See <code><a href="#topic+sim_fun_test">sim_fun_test()</a></code>
for an example.</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_default_list">default_list</code></td>
<td>
<p>A list of default values for <code>sim_fun</code>.</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_bigmemory">bigmemory</code></td>
<td>
<p>Use <code><a href="#topic+hash_big_matrix-class">hash_big_matrix-class()</a></code> to store large matrices?</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>sim_fun</code></p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_x">x</code></td>
<td>
<p>An <code>arg_set</code> object</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_detail">detail</code></td>
<td>
<p>Do you want to print the object details as a full list?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>batch_simulation</code> object, also a data frame.
The first column, <code>var</code>, is a list of
<code>ele_list</code> that contains all the variables; the second to the second
last columns are the values of the variables; the last column is the
output of the simulation function.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>batch_simulation()</code>: Perform a batch simulation.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>batch_arg_set_grad &lt;- new_arg_set()
batch_arg_set_grad &lt;- batch_arg_set_grad %&gt;%
  add_arg_ele(
    arg_name = "parameter", ele_name = "a",
    start = -6, end = -1, by = 1
  )
batch_grid_grad &lt;- make_arg_grid(batch_arg_set_grad)
batch_output_grad &lt;- batch_simulation(batch_grid_grad, sim_fun_grad,
  default_list = list(
    initial = list(x = 0, y = 0),
    parameter = list(a = -4, b = 0, c = 0, sigmasq = 1)
  ),
  length = 1e2,
  seed = 1614,
  bigmemory = FALSE
)
print(batch_output_grad)
</code></pre>

<hr>
<h2 id='calculate_barrier'>Functions for calculating energy barrier from landscapes</h2><span id='topic+calculate_barrier'></span><span id='topic+calculate_barrier.2d_landscape'></span><span id='topic+calculate_barrier.3d_landscape'></span><span id='topic+calculate_barrier.2d_landscape_batch'></span><span id='topic+calculate_barrier.3d_landscape_batch'></span>

<h3>Description</h3>

<p>Functions for calculating energy barrier from landscapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_barrier(l, ...)

## S3 method for class ''2d_landscape''
calculate_barrier(
  l,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  base = exp(1),
  ...
)

## S3 method for class ''3d_landscape''
calculate_barrier(
  l,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  Umax,
  expand = TRUE,
  omit_unstable = FALSE,
  base = exp(1),
  ...
)

## S3 method for class ''2d_landscape_batch''
calculate_barrier(
  l,
  bg = NULL,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  base = exp(1),
  ...
)

## S3 method for class ''3d_landscape_batch''
calculate_barrier(
  l,
  bg = NULL,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  Umax,
  expand = TRUE,
  omit_unstable = FALSE,
  base = exp(1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_barrier_+3A_l">l</code></td>
<td>
<p>A <code>landscape</code> object.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_start_location_value">start_location_value</code>, <code id="calculate_barrier_+3A_end_location_value">end_location_value</code></td>
<td>
<p>The initial position (in value)
for searching the start/end point.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_start_r">start_r</code>, <code id="calculate_barrier_+3A_end_r">end_r</code></td>
<td>
<p>The search radius (in L1 distance) for the start/end point.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_base">base</code></td>
<td>
<p>The base of the log function.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_umax">Umax</code></td>
<td>
<p>The highest possible value of the potential function.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_expand">expand</code></td>
<td>
<p>If the values in the range all equal to <code>Umax</code>, expand the
range or not?</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_omit_unstable">omit_unstable</code></td>
<td>
<p>If a state is not stable (the &quot;local minimum&quot; overlaps
with the saddle point), omit that state or not?</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_bg">bg</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;2d_barrier_grid&#8288;</code> or <code style="white-space: pre;">&#8288;3d_barrier_grid&#8288;</code> object if you want to use
different parameters for each condition. Otherwise <code>NULL</code> as default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>barrier</code> object that contains the (batch) barrier calculation result(s).
</p>

<hr>
<h2 id='check_conv'>Graphical diagnoses to check if the simulation converges</h2><span id='topic+check_conv'></span><span id='topic+print.check_conv'></span>

<h3>Description</h3>

<p>Compare the distribution of different stages of simulation (for <code>plot_type == "bin"</code> or <code>plot_type = "density"</code>), or show how the percentiles of the distribution evolve over time (for <code>plot_type == cumuplot</code>, see <code><a href="coda.html#topic+cumuplot">coda::cumuplot()</a></code> for details). More convergence checking methods for MCMC data are available at the <code>coda</code> package. Be cautious: each convergence checking method has its shortcomings, so do not blindly use any results as the definitive conclusion that a simulation converges or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_conv(output, vars, sample_perc = 0.2, plot_type = "bin")

## S3 method for class 'check_conv'
print(x, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_conv_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output, or a <code>multi_init_simulation</code> object generated from <code><a href="#topic+multi_init_simulation">multi_init_simulation()</a></code>.</p>
</td></tr>
<tr><td><code id="check_conv_+3A_vars">vars</code></td>
<td>
<p>The names of variables to check.</p>
</td></tr>
<tr><td><code id="check_conv_+3A_sample_perc">sample_perc</code></td>
<td>
<p>The percentage of data sample for the initial, middle, and final stage of the simulation. Not required if <code>plot_type == "cumuplot"</code>.</p>
</td></tr>
<tr><td><code id="check_conv_+3A_plot_type">plot_type</code></td>
<td>
<p>Which type of plots should be generated? (&quot;bin&quot;, &quot;density&quot;, or &quot;cumuplot&quot; which uses <code><a href="coda.html#topic+cumuplot">coda::cumuplot()</a></code>)</p>
</td></tr>
<tr><td><code id="check_conv_+3A_x">x</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="check_conv_+3A_ask">ask</code></td>
<td>
<p>Ask to press enter to see the next plot?</p>
</td></tr>
<tr><td><code id="check_conv_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>check_conv</code> object that contains the convergence checking result(for <code>plot_type == "bin"</code> or <code>plot_type = "density"</code>), or draw the cumuplot without a return value (for <code>plot_type == cumuplot</code>).
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(check_conv)</code>: Print a <code>check_conv</code> object.
</p>
</li></ul>

<hr>
<h2 id='fill_in_struct'>Fill a vector of values into a structure list.</h2><span id='topic+fill_in_struct'></span>

<h3>Description</h3>

<p>Fill a vector of values into a structure list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_in_struct(vec, struct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_in_struct_+3A_vec">vec</code></td>
<td>
<p>A vector of values.</p>
</td></tr>
<tr><td><code id="fill_in_struct_+3A_struct">struct</code></td>
<td>
<p>A list with a certain structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ele_list</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modified_simulation">modified_simulation()</a></code>
</p>

<hr>
<h2 id='get_barrier_height'>Summarize the barrier height from a <code>barrier</code> object</h2><span id='topic+get_barrier_height'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated. Use <code><a href="base.html#topic+summary">summary()</a></code> instead. (See <code><a href="#topic+summary.barrier">summary.barrier()</a></code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_barrier_height(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_barrier_height_+3A_object">object</code></td>
<td>
<p>A <code>barrier</code> object.</p>
</td></tr>
<tr><td><code id="get_barrier_height_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (for a single barrier calculation result) or a <code>data.frame</code> (for batch barrier calculation results) that contains the barrier heights on the landscape.
</p>

<hr>
<h2 id='get_dist'>Get the probability distribution from a landscape object</h2><span id='topic+get_dist'></span>

<h3>Description</h3>

<p>Get the probability distribution from a landscape object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist(l, index = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dist_+3A_l">l</code></td>
<td>
<p>A <code>landscape</code> project.</p>
</td></tr>
<tr><td><code id="get_dist_+3A_index">index</code></td>
<td>
<p>1 to get the distribution in tidy format; 2 or &quot;raw&quot; to get the raw simulation result (<code>batch_simulation</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> that contains the distribution in the tidy format or the raw simulation result.
</p>

<hr>
<h2 id='get_geom'>Get a ggplot2 layer from a barrier object</h2><span id='topic+get_geom'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated. Use <code><a href="#topic+autolayer">autolayer()</a></code> instead. (See <code><a href="#topic+autolayer.barrier">autolayer.barrier()</a></code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_geom(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_geom_+3A_object">object</code></td>
<td>
<p>A <code>barrier</code> object.</p>
</td></tr>
<tr><td><code id="get_geom_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> layer that can be added to an existing landscape plot.
</p>

<hr>
<h2 id='hash_big_matrix-class'>Class &quot;hash_big_matrix&quot;: big matrix with a md5 hash reference</h2><span id='topic+hash_big_matrix-class'></span><span id='topic+hash_big_matrix'></span><span id='topic+as_hash_big_matrix'></span><span id='topic+attach_hash_big_matrix'></span>

<h3>Description</h3>

<p><code>hash_big_matrix</code> class is a modified class from <code><a href="bigmemory.html#topic+big.matrix-class">bigmemory::big.matrix-class()</a></code>. Its purpose is to
help users operate big matrices within hard disk in a reusable way, so that the large matrices do not consume
too much memory, and the matrices can be reused for the next time.
Comparing with <code><a href="bigmemory.html#topic+big.matrix-class">bigmemory::big.matrix-class()</a></code>, the major enhancement of <code>hash_big_matrix</code> class
is that the backing files are, by default, stored in a permanent place, with the md5 of the object as the file
name. With this explicit name, <code>hash_big_matrix</code> objects can be easily reloaded into workspace every time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_hash_big_matrix(x, backingpath = "bp", silence = TRUE, ...)

attach_hash_big_matrix(x, backingpath = "bp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hash_big_matrix-class_+3A_x">x</code></td>
<td>
<p>A matrix, vector, or data.frame for <code><a href="bigmemory.html#topic+big.matrix">bigmemory::as.big.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="hash_big_matrix-class_+3A_backingpath">backingpath</code>, <code id="hash_big_matrix-class_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="bigmemory.html#topic+big.matrix">bigmemory::as.big.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="hash_big_matrix-class_+3A_silence">silence</code></td>
<td>
<p>Suppress messages?</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>as_hash_big_matrix()</code>: Create a <code>hash_big_matrix</code> object from a matrix.
</p>
</li>
<li> <p><code>attach_hash_big_matrix()</code>: Attach a <code>hash_big_matrix</code> object from the backing file to the workspace.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>md5</code></dt><dd><p>The md5 value of the matrix.</p>
</dd>
<dt><code>address</code></dt><dd><p>Inherited from <code>big.matrix</code>.</p>
</dd>
</dl>

<hr>
<h2 id='make_2d_matrix'>Make a matrix of 2D static landscape plots for one or two parameters</h2><span id='topic+make_2d_matrix'></span>

<h3>Description</h3>

<p>Make a matrix of 2D static landscape plots for one or two parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_2d_matrix(
  bs,
  x,
  rows = NULL,
  cols,
  lims,
  kde_fun = c("ks", "base"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  individual_landscape = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_2d_matrix_+3A_bs">bs</code></td>
<td>
<p>A <code>batch_simulation</code> object created by <code style="white-space: pre;">&#8288;[batch_simulation()].&#8288;</code></p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_x">x</code></td>
<td>
<p>The name of the target variable.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_rows">rows</code>, <code id="make_2d_matrix_+3A_cols">cols</code></td>
<td>
<p>The names of the parameters. <code>rows</code> can be left blank if only one parameter is needed.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_individual_landscape">individual_landscape</code></td>
<td>
<p>Make individual landscape for each simulation? Default is <code>TRUE</code> so that it is possible to calculate barriers. Set to <code>FALSE</code> to save time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;2d_matrix_landscape&#8288;</code> object that describes the landscape of the system, including the smoothed distribution and the landscape plot.
</p>

<hr>
<h2 id='make_2d_static'>Make 2D static landscape plot for a single simulation output</h2><span id='topic+make_2d_static'></span><span id='topic+make_2d_single'></span>

<h3>Description</h3>

<p>Make 2D static landscape plot for a single simulation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_2d_static(
  output,
  x,
  lims,
  kde_fun = c("ks", "base"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  weight_var = NULL
)

make_2d_single(
  output,
  x,
  lims,
  kde_fun = c("ks", "base"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  weight_var = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_2d_static_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output, or a <code>mcmc</code>, <code>mcmc.list</code> object (see <code><a href="coda.html#topic+mcmc">coda::mcmc()</a></code>).</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_x">x</code></td>
<td>
<p>The name of the target variable.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_weight_var">weight_var</code></td>
<td>
<p>The name of the weight variable, in case the weight of each observation is different. This may be useful when a weighted MC (e.g., importance sampling) is used. Only effective for <code>kde_fun = "ks"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;2d_static_landscape&#8288;</code> object that describes the landscape of the system, including the smooth distribution and the landscape plot.
</p>

<hr>
<h2 id='make_2d_tidy_dist'>Make a tidy <code>data.frame</code> from smooth 2d distribution matrix</h2><span id='topic+make_2d_tidy_dist'></span>

<h3>Description</h3>

<p>Make a tidy <code>data.frame</code> from smooth 2d distribution matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_2d_tidy_dist(dist_2d, value = NULL, var_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_2d_tidy_dist_+3A_dist_2d">dist_2d</code></td>
<td>
<p><code>kde2d</code> distribution.</p>
</td></tr>
<tr><td><code id="make_2d_tidy_dist_+3A_value">value</code></td>
<td>
<p>The value of the variable of interest.</p>
</td></tr>
<tr><td><code id="make_2d_tidy_dist_+3A_var_name">var_name</code></td>
<td>
<p>The name of the variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy <code>data.frame</code>.
</p>

<hr>
<h2 id='make_3d_animation'>Make 3d animations from multiple simulations</h2><span id='topic+make_3d_animation'></span>

<h3>Description</h3>

<p>Make 3d animations from multiple simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_3d_animation(
  bs,
  x,
  y,
  fr,
  lims,
  kde_fun = c("ks", "MASS"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  individual_landscape = TRUE,
  mat_3d = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_3d_animation_+3A_bs">bs</code></td>
<td>
<p>A <code>batch_simulation</code> object created by <code style="white-space: pre;">&#8288;[batch_simulation()].&#8288;</code></p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_x">x</code>, <code id="make_3d_animation_+3A_y">y</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_fr">fr</code></td>
<td>
<p>The names of the parameters used to represent frames in the animation.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_individual_landscape">individual_landscape</code></td>
<td>
<p>Make individual landscape for each simulation? Default is <code>TRUE</code> so that it is possible to calculate barriers. Set to <code>FALSE</code> to save time.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_mat_3d">mat_3d</code></td>
<td>
<p>Also make the matrix by <code><a href="#topic+make_3d_matrix">make_3d_matrix()</a></code>? If so, the matrix can be drawn with <code style="white-space: pre;">&#8288;plot(&lt;landscape&gt;, 3)&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;3d_animation_landscape&#8288;</code> object that describes the landscape of the system, including the smoothed distribution and the landscape plot.
</p>

<hr>
<h2 id='make_3d_matrix'>Make a matrix of 3D static landscape plots for one or two parameters</h2><span id='topic+make_3d_matrix'></span>

<h3>Description</h3>

<p>Currently only 3D (x, y, color) is supported. Matrices with 3D (x, y, z) plots are not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_3d_matrix(
  bs,
  x,
  y,
  rows = NULL,
  cols,
  lims,
  kde_fun = c("ks", "MASS"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  individual_landscape = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_3d_matrix_+3A_bs">bs</code></td>
<td>
<p>A <code>batch_simulation</code> object created by <code style="white-space: pre;">&#8288;[batch_simulation()].&#8288;</code></p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_x">x</code>, <code id="make_3d_matrix_+3A_y">y</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_rows">rows</code>, <code id="make_3d_matrix_+3A_cols">cols</code></td>
<td>
<p>The names of the parameters. <code>rows</code> can be left blank if only one parameter is needed.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_individual_landscape">individual_landscape</code></td>
<td>
<p>Make individual landscape for each simulation? Default is <code>TRUE</code> so that it is possible to calculate barriers. Set to <code>FALSE</code> to save time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;3d_matrix_landscape&#8288;</code> object that describes the landscape of the system, including the smoothed distribution and the landscape plot.
</p>

<hr>
<h2 id='make_3d_static'>Make 3D static landscape plots from simulation output</h2><span id='topic+make_3d_static'></span><span id='topic+make_3d_single'></span>

<h3>Description</h3>

<p>Make 3D static landscape plots from simulation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_3d_static(
  output,
  x,
  y,
  lims,
  kde_fun = c("ks", "MASS"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  weight_var = NULL
)

make_3d_single(
  output,
  x,
  y,
  lims,
  kde_fun = c("ks", "MASS"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  weight_var = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_3d_static_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output, or a <code>mcmc</code>, <code>mcmc.list</code> object (see <code><a href="coda.html#topic+mcmc">coda::mcmc()</a></code>).</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_x">x</code>, <code id="make_3d_static_+3A_y">y</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_weight_var">weight_var</code></td>
<td>
<p>The name of the weight variable, in case the weight of each observation is different. This may be useful when a weighted MC (e.g., importance sampling) is used. Only effective for <code>kde_fun = "ks"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;3d_static_landscape&#8288;</code> object that describes the landscape of the system, including the smooth distribution and the landscape plot.
</p>

<hr>
<h2 id='make_4d_static'>Make 4D static space-color plots from simulation output</h2><span id='topic+make_4d_static'></span><span id='topic+make_4d_single'></span>

<h3>Description</h3>

<p>Make 4D static space-color plots from simulation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_4d_static(
  output,
  x,
  y,
  z,
  lims,
  kde_fun = "ks",
  n = 50,
  h,
  adjust = 1,
  Umax = 5,
  weight_var = NULL
)

make_4d_single(
  output,
  x,
  y,
  z,
  lims,
  kde_fun = "ks",
  n = 50,
  h,
  adjust = 1,
  Umax = 5,
  weight_var = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_4d_static_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output, or a <code>mcmc</code>, <code>mcmc.list</code> object (see <code><a href="coda.html#topic+mcmc">coda::mcmc()</a></code>).</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_x">x</code>, <code id="make_4d_static_+3A_y">y</code>, <code id="make_4d_static_+3A_z">z</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_weight_var">weight_var</code></td>
<td>
<p>The name of the weight variable, in case the weight of each observation is different. This may be useful when a weighted MC (e.g., importance sampling) is used. Only effective for <code>kde_fun = "ks"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;4d_static_landscape&#8288;</code> object that describes the landscape of the system, including the smoothed distribution and the landscape plot.
</p>

<hr>
<h2 id='make_barrier_grid_2d'>Make a grid for calculating barriers for 2d landscapes</h2><span id='topic+make_barrier_grid_2d'></span>

<h3>Description</h3>

<p>Make a grid for calculating barriers for 2d landscapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_barrier_grid_2d(
  ag,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  df = NULL,
  print_template = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_barrier_grid_2d_+3A_ag">ag</code></td>
<td>
<p>An <code>arg_grid</code> object.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_2d_+3A_start_location_value">start_location_value</code>, <code id="make_barrier_grid_2d_+3A_start_r">start_r</code>, <code id="make_barrier_grid_2d_+3A_end_location_value">end_location_value</code>, <code id="make_barrier_grid_2d_+3A_end_r">end_r</code></td>
<td>
<p>Default values for finding local minimum. See <code><a href="#topic+calculate_barrier">calculate_barrier()</a></code>.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_2d_+3A_df">df</code></td>
<td>
<p>A data frame for the variables. Use <code>print_template = TRUE</code> to get a template.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_2d_+3A_print_template">print_template</code></td>
<td>
<p>Print a template for <code>df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>barrier_grid_2d</code> object that specifies the condition for each barrier calculation.
</p>

<hr>
<h2 id='make_barrier_grid_3d'>Make a grid for calculating barriers for 3d landscapes</h2><span id='topic+make_barrier_grid_3d'></span>

<h3>Description</h3>

<p>Make a grid for calculating barriers for 3d landscapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_barrier_grid_3d(
  ag,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  df = NULL,
  print_template = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_barrier_grid_3d_+3A_ag">ag</code></td>
<td>
<p>An <code>arg_grid</code> object.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_3d_+3A_start_location_value">start_location_value</code>, <code id="make_barrier_grid_3d_+3A_start_r">start_r</code>, <code id="make_barrier_grid_3d_+3A_end_location_value">end_location_value</code>, <code id="make_barrier_grid_3d_+3A_end_r">end_r</code></td>
<td>
<p>Default values for finding local minimum. See <code><a href="#topic+calculate_barrier">calculate_barrier()</a></code>.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_3d_+3A_df">df</code></td>
<td>
<p>A data frame for the variables. Use <code>print_template = TRUE</code> to get a template.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_3d_+3A_print_template">print_template</code></td>
<td>
<p>Print a template for <code>df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>barrier_grid_3d</code> object that specifies the condition for each barrier calculation.
</p>

<hr>
<h2 id='make_kernel_dist'>Calculate 1D, 2D, or 3D kernel smooth distribution</h2><span id='topic+make_kernel_dist'></span>

<h3>Description</h3>

<p>Calculate 1D, 2D, or 3D kernel smooth distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_kernel_dist(
  output,
  var_names,
  lims,
  kde_fun,
  n,
  h,
  adjust,
  weight_var = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_kernel_dist_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output, or a <code>mcmc</code>, <code>mcmc.list</code> object (see <code><a href="coda.html#topic+mcmc">coda::mcmc()</a></code>).</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_var_names">var_names</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_weight_var">weight_var</code></td>
<td>
<p>The name of the weight variable, in case the weight of each observation is different. This may be useful when a weighted MC (e.g., importance sampling) is used. Only effective for <code>kde_fun = "ks"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the smooth distribution.
</p>

<hr>
<h2 id='modified_simulation'>Modify a single simulation</h2><span id='topic+modified_simulation'></span>

<h3>Description</h3>

<p>Modify a single simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modified_simulation(sim_fun, ele_list, default_list, bigmemory = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modified_simulation_+3A_ele_list">ele_list</code></td>
<td>
<p>An <code>ele_list</code> object generated by <code><a href="#topic+fill_in_struct">fill_in_struct()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='multi_init_simulation'>Simulate multiple 1-3D Markovian Stochastic Differential Equations</h2><span id='topic+multi_init_simulation'></span>

<h3>Description</h3>

<p>Simulate multiple Monte Carlo simulations of 1-3D Markovian Stochastic Differential Equations from a grid or random sample of initial values.
Parallel processing is supported. To register a parallel backend, use <code>future::plan()</code>. For example, <code>future::plan(future::multisession)</code>. For more information, see <code><a href="future.html#topic+plan">future::plan()</a></code>. Functions imported from other programming languages, such as C++ or Python functions, may not work in parallel processing.
If you are uncertain whether there are unknown stable states of the system that are difficult to reach, it is recommended to start with running a large number (i.e., increasing <code>R</code>) of short simulations to see if the system reaches to the known stable states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_init_simulation(
  sim_fun,
  R = 10,
  range_x0,
  sample_mode = c("grid", "random"),
  ...,
  .furrr_options = list(.options = furrr::furrr_options(seed = TRUE)),
  return_object = c("mcmc.list", "raw")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_init_simulation_+3A_sim_fun">sim_fun</code></td>
<td>
<p>The simulation function to use. It should accept an argument <code>x0</code> for the initial values. Other arguments can be passed through <code>...</code>.</p>
</td></tr>
<tr><td><code id="multi_init_simulation_+3A_r">R</code></td>
<td>
<p>The number of initial values to sample. If <code>sample_mode</code> is &quot;grid&quot;, this will be the number of initial values in each dimension. If <code>sample_mode</code> is &quot;random&quot;, this will be the total number of initial values.</p>
</td></tr>
<tr><td><code id="multi_init_simulation_+3A_range_x0">range_x0</code></td>
<td>
<p>The range of initial values to sample in a vector of length 2 for each dimension (i.e., <code style="white-space: pre;">&#8288;c(&lt;x0_minimum&gt;, &lt;x0_maximum&gt;, &lt;y0_minimum&gt;, &lt;y0_maximum&gt;, &lt;z0_minimum&gt;, &lt;z0_maximum&gt;)&#8288;</code>).</p>
</td></tr>
<tr><td><code id="multi_init_simulation_+3A_sample_mode">sample_mode</code></td>
<td>
<p>The mode of sampling initial values. Either &quot;grid&quot; or &quot;random&quot;. If &quot;grid&quot;, the initial values will be sampled from a grid. If &quot;random&quot;, the initial values will be sampled randomly.</p>
</td></tr>
<tr><td><code id="multi_init_simulation_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>sim_fun</code>.</p>
</td></tr>
<tr><td><code id="multi_init_simulation_+3A_.furrr_options">.furrr_options</code></td>
<td>
<p>A list of options to be passed to <code><a href="furrr.html#topic+future_map2">furrr::future_pmap()</a></code>.</p>
</td></tr>
<tr><td><code id="multi_init_simulation_+3A_return_object">return_object</code></td>
<td>
<p>The type of object to return. Either &quot;mcmc.list&quot; or &quot;raw&quot;. If &quot;mcmc.list&quot;, a list of mcmc objects will be returned. If &quot;raw&quot;, a tibble of initial values and raw simulation results will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of mcmc objects or a tibble of initial values and raw simulation results, depending on the value of <code>return_object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Adapted from the example in the Sim.DiffProc package

set.seed(1234, kind = "L'Ecuyer-CMRG")
mu &lt;- 4
sigma &lt;- 0.1
fx &lt;- expression(y, (mu * (1 - x^2) * y - x))
gx &lt;- expression(0, 2 * sigma)

multiple_mod2d &lt;- multi_init_simulation(sim_SDE, range_x0 = c(-3, 3, -10, 10),
R = 3, sample_mode = "grid", drift = fx, diffusion = gx,
N = 1000, Dt = 0.01, type = "str", method = "rk1",
keep_full = FALSE, M = 2)

# The output is a mcmc.list object. You can use the functions
# in the coda package to modify it and perform convergence check,
# for example,

library(coda)
plot(multiple_mod2d)
window(multiple_mod2d, start = 500)
effectiveSize(multiple_mod2d)

</code></pre>

<hr>
<h2 id='plot.landscape'>Make plots from landscape objects</h2><span id='topic+plot.landscape'></span>

<h3>Description</h3>

<p>Make plots from landscape objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'landscape'
plot(x, index = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.landscape_+3A_x">x</code></td>
<td>
<p>A landscape object</p>
</td></tr>
<tr><td><code id="plot.landscape_+3A_index">index</code></td>
<td>
<p>Default is 1. For some landscape objects, there is a second plot (usually 2d heatmaps for 3d landscapes)
or a third plot (usually 3d matrices for 3d animations).
Use <code>index = 2</code> to plot that one.</p>
</td></tr>
<tr><td><code id="plot.landscape_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot.
</p>

<hr>
<h2 id='save_landscape'>Save landscape plots</h2><span id='topic+save_landscape'></span>

<h3>Description</h3>

<p>Save landscape plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_landscape(l, path = NULL, selfcontained = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_landscape_+3A_l">l</code></td>
<td>
<p>A landscape object</p>
</td></tr>
<tr><td><code id="save_landscape_+3A_path">path</code></td>
<td>
<p>The path to save the output. Default: &quot;/pics/x_y.html&quot;.</p>
</td></tr>
<tr><td><code id="save_landscape_+3A_selfcontained">selfcontained</code></td>
<td>
<p>For 'plotly' plots, save the output as a self-contained html file? Default: FALSE.</p>
</td></tr>
<tr><td><code id="save_landscape_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="htmlwidgets.html#topic+saveWidget">htmlwidgets::saveWidget()</a></code>
or <code><a href="ggplot2.html#topic+ggsave">ggplot2::ggsave()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function saves the plot to a specific path. It does not have a return value.
</p>

<hr>
<h2 id='sim_fun_grad'>A simple gradient simulation function for testing</h2><span id='topic+sim_fun_grad'></span>

<h3>Description</h3>

<p>This is a toy stochastic gradient system which can have bistability in some conditions.
Model specification:
</p>
<p style="text-align: center;"><code class="reqn">U = x^4 + y^4 + axy + bx + cy</code>
</p>

<p style="text-align: center;"><code class="reqn">dx/dt = - \partial U/ \partial x + \sigma dW/dt = - 4x^3 - ay - b + \sigma dW/dt</code>
</p>

<p style="text-align: center;"><code class="reqn">dy/dt = - \partial U/ \partial y + \sigma dW/dt = - 4y^3 - ax - c + \sigma dW/dt</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sim_fun_grad(
  initial = list(x = 0, y = 0),
  parameter = list(a = -4, b = 0, c = 0, sigmasq = 1),
  length = 1e+05,
  stepsize = 0.01,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_fun_grad_+3A_initial">initial</code>, <code id="sim_fun_grad_+3A_parameter">parameter</code></td>
<td>
<p>Two sets of parameters. <code>initial</code> contains the initial value of <code>x</code> and <code>y</code>;
<code>parameter</code> contains <code style="white-space: pre;">&#8288;a,b,c&#8288;</code>, which control the shape of the potential landscape,
and <code>sigmasq</code>, which is the square of <code class="reqn">\sigma</code> and controls the amplitude of noise.</p>
</td></tr>
<tr><td><code id="sim_fun_grad_+3A_length">length</code></td>
<td>
<p>The length of simulation.</p>
</td></tr>
<tr><td><code id="sim_fun_grad_+3A_stepsize">stepsize</code></td>
<td>
<p>The step size used in the Euler method.</p>
</td></tr>
<tr><td><code id="sim_fun_grad_+3A_seed">seed</code></td>
<td>
<p>The initial seed that will be passed to <code>set.seed()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of simulation results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_fun_nongrad">sim_fun_nongrad()</a></code> and <code><a href="#topic+batch_simulation">batch_simulation()</a></code>.
</p>

<hr>
<h2 id='sim_fun_nongrad'>A simple non-gradient simulation function for testing</h2><span id='topic+sim_fun_nongrad'></span>

<h3>Description</h3>

<p>This is a toy stochastic non-gradient system which can have multistability in some conditions.
Model specification:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_fun_nongrad(
  initial = list(x1 = 0, x2 = 0, a = 1),
  parameter = list(b = 1, k = 1, S = 0.5, n = 4, lambda = 0.01, sigmasq1 = 8, sigmasq2 =
    8, sigmasq3 = 2),
  constrain_a = TRUE,
  amin = -0.3,
  amax = 1.8,
  length = 1e+05,
  stepsize = 0.01,
  seed = NULL,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_fun_nongrad_+3A_initial">initial</code>, <code id="sim_fun_nongrad_+3A_parameter">parameter</code></td>
<td>
<p>Two sets of parameters. <code>initial</code> contains the initial value of <code>x1</code>, <code>x2</code>, and <code>a</code>;
<code>parameter</code> contains <code style="white-space: pre;">&#8288;b,k,S,n,lambda&#8288;</code>, which control the model dynamics,
and <code style="white-space: pre;">&#8288;sigmasq1,sigmasq2,sigmasq3&#8288;</code>, which are the squares of <code class="reqn">\sigma_1,\sigma_2,\sigma_3</code> and controls the amplitude of noise.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_constrain_a">constrain_a</code></td>
<td>
<p>Should the value of <code>a</code> be constrained? (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_amin">amin</code>, <code id="sim_fun_nongrad_+3A_amax">amax</code></td>
<td>
<p>If <code>constrain_a</code>, the minimum and maximum values of a.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_length">length</code></td>
<td>
<p>The length of simulation.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_stepsize">stepsize</code></td>
<td>
<p>The step size used in the Euler method.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_seed">seed</code></td>
<td>
<p>The initial seed that will be passed to <code>set.seed()</code> function.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_progress">progress</code></td>
<td>
<p>Show progress bar of the simulation?</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">\frac {dx_ {1}}{dt}  =  \frac {ax_ {1}^ {n}}{S^ {n}+x_ {1}^ {n}} + \frac {bS^ {n}}{S^ {n}+x_ {2}^ {n}} - kx_ {1}+ \sigma_1 dW_1/dt</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac {dx_ {2}}{dt}  =  \frac {ax_ {2}^ {n}}{S^ {n}+x_ {2}^ {n}} + \frac {bS^ {n}}{S^ {n}+x_ {1}^ {n}} - kx_ {2}+ \sigma_2 dW_2/dt</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac {da}{dt} = -\lambda a+ \sigma_3 dW_3/dt</code>
</p>



<h3>Value</h3>

<p>A matrix of simulation results.
</p>


<h3>References</h3>

<p>Wang, J., Zhang, K., Xu, L., &amp; Wang, E. (2011). Quantifying the Waddington landscape and biological paths for development and differentiation. Proceedings of the National Academy of Sciences, 108(20), 8257-8262.
<a href="https://doi.org/10.1073/pnas.1017017108">doi:10.1073/pnas.1017017108</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_fun_grad">sim_fun_grad()</a></code> and <code><a href="#topic+batch_simulation">batch_simulation()</a></code>.
</p>

<hr>
<h2 id='sim_fun_test'>A simple simulation function for testing</h2><span id='topic+sim_fun_test'></span>

<h3>Description</h3>

<p>A simple simulation function for testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_fun_test(arg1, arg2, length = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_fun_test_+3A_arg1">arg1</code>, <code id="sim_fun_test_+3A_arg2">arg2</code></td>
<td>
<p>Two parameters. <code>arg1</code> contains <code>ele1</code>;
<code>arg2</code> contains <code>ele2</code> and <code>ele3</code>.</p>
</td></tr>
<tr><td><code id="sim_fun_test_+3A_length">length</code></td>
<td>
<p>The length of simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of simulation results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_fun_grad">sim_fun_grad()</a></code> and <code><a href="#topic+sim_fun_nongrad">sim_fun_nongrad()</a></code> for more realistic
examples.
</p>

<hr>
<h2 id='sim_fun_test2'>A simple yet meaningful simulation function for testing</h2><span id='topic+sim_fun_test2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>sim_fun_test2()</code> was renamed to <code>sim_fun_grad()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_fun_test2(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_fun_test2_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to <code><a href="#topic+sim_fun_grad">sim_fun_grad()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='sim_SDE'>Simulate 1-3D Markovian Stochastic Differential Equations</h2><span id='topic+sim_SDE'></span>

<h3>Description</h3>

<p>A wrapper to the simulation utilities provided by the <span class="pkg">Sim.DiffProc</span> package. You may skip this step and write your own simulation function for more customized simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_SDE(
  N = 1000,
  M = 1,
  x0,
  t0 = 0,
  T = 1,
  Dt = rlang::missing_arg(),
  drift,
  diffusion,
  corr = NULL,
  alpha = 0.5,
  mu = 0.5,
  type = "ito",
  method = "euler",
  keep_full = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_SDE_+3A_n">N</code></td>
<td>
<p>The number of time steps.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_m">M</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_x0">x0</code></td>
<td>
<p>The initial values of the SDE. The number of values determine the dimension of the SDE.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_t0">t0</code></td>
<td>
<p>initial time.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_t">T</code></td>
<td>
<p>terminal time.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_dt">Dt</code></td>
<td>
<p>time step. If missing, default will be (T - t0) / N.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_drift">drift</code></td>
<td>
<p>An expression of the drift function. The number of expressions determine the dimension of the SDE. Should be the function of <code>t</code>, <code>x</code>, <code>y</code> and <code>z</code> (<code>y</code> and <code>z</code> are only included for 2D or 3D cases).</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_diffusion">diffusion</code></td>
<td>
<p>An expression of the diffusion function. The number of expressions determine the dimension of the SDE. Should be the function of <code>t</code>, <code>x</code>, <code>y</code> and <code>z</code> (<code>y</code> and <code>z</code> are only included for 2D or 3D cases).</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_corr">corr</code></td>
<td>
<p>The correlations between the Brownian motions. Only used for 2D or 3D cases. Must be a real symmetric positive-definite matrix of size 2x2 or 3x3. If NULL, the default is the identity matrix.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_alpha">alpha</code>, <code id="sim_SDE_+3A_mu">mu</code></td>
<td>
<p>weight of the predictor-corrector scheme; the default <code>alpha = 0.5</code> and <code>mu = 0.5</code>.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_type">type</code></td>
<td>
<p>if <code>type="ito"</code> simulation sde of Itô type, else <code>type="str"</code> simulation sde of Stratonovich type; the default <code>type="ito"</code>.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_method">method</code></td>
<td>
<p>numerical methods of simulation, the default <code>method = "euler"</code>.</p>
</td></tr>
<tr><td><code id="sim_SDE_+3A_keep_full">keep_full</code></td>
<td>
<p>Whether to keep the full snssde1d/snssde2d/snssde3d object. If TRUE, the full object will be returned. If FALSE, only the simulated values will be returned as a matrix or a list of matrices (when <code>M &gt;= 2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of <code>keep_full</code>, the output will be a list of <code>snssde1d</code>, <code>snssde2d</code> or <code>snssde3d</code> objects, or a matrix or a list of matrices of the simulated values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># From the Sim.DiffProc package

set.seed(1234, kind = "L'Ecuyer-CMRG")
mu &lt;- 4
sigma &lt;- 0.1
fx &lt;- expression(y, (mu * (1 - x^2) * y - x))
gx &lt;- expression(0, 2 * sigma)
mod2d &lt;- sim_SDE(drift = fx, diffusion = gx, N = 1000,
Dt = 0.01, x0 = c(0, 0), type = "str", method = "rk1",
M = 2, keep_full = FALSE)

print(as.mcmc.list(mod2d))
</code></pre>

<hr>
<h2 id='summary.barrier'>Summarize the barrier height from a <code>barrier</code> object</h2><span id='topic+summary.barrier'></span>

<h3>Description</h3>

<p>Summarize the barrier height from a <code>barrier</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'barrier'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.barrier_+3A_object">object</code></td>
<td>
<p>A <code>barrier</code> object.</p>
</td></tr>
<tr><td><code id="summary.barrier_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (for a single barrier calculation result) or a <code>data.frame</code> (for batch barrier calculation results) that contains the barrier heights on the landscape.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
