<!DOCTYPE html><html><head><title>Help for package simlandr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simlandr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simlandr-package'><p>simlandr: Simulation-Based Landscape Construction for Dynamical Systems</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#arg_set-class'><p>Create and modify argument sets, then make an argument grid</p>
for batch simulation</a></li>
<li><a href='#attach_all_matrices'><p>Attach all matrices in a batch simulation</p></a></li>
<li><a href='#autolayer'><p>Autolayer generic function</p></a></li>
<li><a href='#autolayer.barrier'><p>Get a ggplot2 layer from a barrier object</p></a></li>
<li><a href='#batch_simulation'><p>Perform a batch simulation.</p></a></li>
<li><a href='#calculate_barrier'><p>Functions for calculating energy barrier from landscapes</p></a></li>
<li><a href='#check_conv'><p>Graphical diagnoses to check if the simulation converges</p></a></li>
<li><a href='#fill_in_struct'><p>Fill a vector of values into a structure list.</p></a></li>
<li><a href='#get_barrier_height'><p>Summarize the barrier height from a <code>barrier</code> object</p></a></li>
<li><a href='#get_dist'><p>Get the probability distribution from a landscape object</p></a></li>
<li><a href='#get_geom'><p>Get a ggplot2 layer from a barrier object</p></a></li>
<li><a href='#hash_big_matrix-class'><p>Class &quot;hash_big_matrix&quot;: big matrix with a md5 hash reference</p></a></li>
<li><a href='#make_2d_matrix'><p>Make a matrix of 2D static landscape plots for one or two parameters</p></a></li>
<li><a href='#make_2d_static'><p>Make 2D static landscape plot for a single simulation output</p></a></li>
<li><a href='#make_2d_tidy_dist'><p>Make a tidy <code>data.frame</code> from smooth 2d distribution matrix</p></a></li>
<li><a href='#make_3d_animation'><p>Make 3d animations from multiple simulations</p></a></li>
<li><a href='#make_3d_matrix'><p>Make a matrix of 3D static landscape plots for one or two parameters</p></a></li>
<li><a href='#make_3d_static'><p>Make 3D static landscape plots from simulation output</p></a></li>
<li><a href='#make_4d_static'><p>Make 4D static space-color plots from simulation output</p></a></li>
<li><a href='#make_barrier_grid_2d'><p>Make a grid for calculating barriers for 2d landscapes</p></a></li>
<li><a href='#make_barrier_grid_3d'><p>Make a grid for calculating barriers for 3d landscapes</p></a></li>
<li><a href='#make_kernel_dist'><p>Calculate 1D, 2D, or 3D kernel smooth distribution</p></a></li>
<li><a href='#modified_simulation'><p>Modify a single simulation</p></a></li>
<li><a href='#plot.landscape'><p>Make plots from landscape objects</p></a></li>
<li><a href='#save_landscape'><p>Save landscape plots</p></a></li>
<li><a href='#sim_fun_grad'><p>A simple gradient simulation function for testing</p></a></li>
<li><a href='#sim_fun_nongrad'><p>A simple non-gradient simulation function for testing</p></a></li>
<li><a href='#sim_fun_test'><p>A simple simulation function for testing</p></a></li>
<li><a href='#sim_fun_test2'><p>A simple yet meaningful simulation function for testing</p></a></li>
<li><a href='#summary.barrier'><p>Summarize the barrier height from a <code>barrier</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation-Based Landscape Construction for Dynamical Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for constructing potential landscapes for dynamical
    systems using Monte Carlo simulation.  The method is based on the
    potential landscape definition by Wang et al. (2008)
    &lt;<a href="https://doi.org/10.1073%2Fpnas.0800579105">doi:10.1073/pnas.0800579105</a>&gt; (also see Zhou &amp; Li, 2016
    &lt;<a href="https://doi.org/10.1063%2F1.4943096">doi:10.1063/1.4943096</a>&gt; for further mathematical discussions) and can
    be used for a large variety of models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sciurus365.github.io/simlandr/">https://sciurus365.github.io/simlandr/</a>,
<a href="https://github.com/Sciurus365/simlandr">https://github.com/Sciurus365/simlandr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Sciurus365/simlandr/issues">https://github.com/Sciurus365/simlandr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>bigmemory, digest, dplyr, forcats, gganimate, ggplot2,
grDevices, htmlwidgets, ks, lifecycle, magrittr, MASS, methods,
plotly, progress, purrr, rlang, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda, knitr, rmarkdown, webshot</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 14:38:10 UTC; jingm</td>
</tr>
<tr>
<td>Author:</td>
<td>Jingmeng Cui <a href="https://orcid.org/0000-0003-3421-8457"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jingmeng Cui &lt;jingmeng.cui@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 18:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='simlandr-package'>simlandr: Simulation-Based Landscape Construction for Dynamical Systems</h2><span id='topic+simlandr'></span><span id='topic+simlandr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A toolbox for constructing potential landscapes for dynamical systems using Monte Carlo simulation. The method is based on the potential landscape definition by Wang et al. (2008) <a href="https://doi.org/10.1073/pnas.0800579105">doi:10.1073/pnas.0800579105</a> (also see Zhou &amp; Li, 2016 <a href="https://doi.org/10.1063/1.4943096">doi:10.1063/1.4943096</a> for further mathematical discussions) and can be used for a large variety of models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jingmeng Cui <a href="mailto:jingmeng.cui@outlook.com">jingmeng.cui@outlook.com</a> (<a href="https://orcid.org/0000-0003-3421-8457">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://sciurus365.github.io/simlandr/">https://sciurus365.github.io/simlandr/</a>
</p>
</li>
<li> <p><a href="https://github.com/Sciurus365/simlandr">https://github.com/Sciurus365/simlandr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Sciurus365/simlandr/issues">https://github.com/Sciurus365/simlandr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code style="white-space: pre;">&#8288;magrittr::[\%&gt;\%][magrittr::pipe]&#8288;</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='arg_set-class'>Create and modify argument sets, then make an argument grid
for batch simulation</h2><span id='topic+arg_set-class'></span><span id='topic+new_arg_set'></span><span id='topic+add_arg_ele'></span><span id='topic+nele'></span><span id='topic+narg'></span><span id='topic+print.arg_set'></span><span id='topic+make_arg_grid'></span><span id='topic+print.arg_grid'></span>

<h3>Description</h3>

<p>An argument set contains the descriptions of the relevant variables in a
batch simulation. Use <code>new_arg_set()</code> to create an <code>arg_set</code>
object, and use <code>add_arg_ele()</code> to add an element to the <code>arg_set</code>. After
adding all elements in the argument set, use <code>make_arg_grid()</code> to make an
argument grid that can be used directly for running batch simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_arg_set()

add_arg_ele(arg_set, arg_name, ele_name, start, end, by)

nele(arg_set)

narg(arg_set)

## S3 method for class 'arg_set'
print(x, detail = FALSE, ...)

make_arg_grid(arg_set)

## S3 method for class 'arg_grid'
print(x, detail = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arg_set-class_+3A_arg_set">arg_set</code></td>
<td>
<p>An <code>arg_set</code> object.</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_arg_name">arg_name</code>, <code id="arg_set-class_+3A_ele_name">ele_name</code></td>
<td>
<p>The name of the argument and its element
in the simulation function</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_start">start</code>, <code id="arg_set-class_+3A_end">end</code>, <code id="arg_set-class_+3A_by">by</code></td>
<td>
<p>The data points where you want to test the variables.
Passed to <code>seq</code>.</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_x">x</code></td>
<td>
<p>An <code>arg_set</code> object</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_detail">detail</code></td>
<td>
<p>Do you want to print the object details as a full list?</p>
</td></tr>
<tr><td><code id="arg_set-class_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>new_arg_set()</code> returns an <code>arg_set</code> object.
</p>
<p><code>add_arg_ele()</code> returns an <code>arg_set</code> object.
</p>
<p><code>nele()</code> returns an integer.
</p>
<p><code>narg()</code> returns an integer.
</p>
<p><code>make_arg_gird()</code> returns an <code>arg_grid</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>new_arg_set()</code>: Create an <code>arg_set</code>.
</p>
</li>
<li> <p><code>add_arg_ele()</code>: Add an element to an <code>arg_set</code>.
</p>
</li>
<li> <p><code>nele()</code>: The number of elements in an <code>arg_set</code>.
</p>
</li>
<li> <p><code>narg()</code>: The number of arguments in an <code>arg_set</code>.
</p>
</li>
<li> <p><code>print(arg_set)</code>: Print an <code>arg_set</code> object.
</p>
</li>
<li> <p><code>make_arg_grid()</code>: Make an argument grid from an argument set.
</p>
</li>
<li> <p><code>print(arg_grid)</code>: Print an <code>arg_grid</code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+batch_simulation">batch_simulation()</a></code> for running batch simulation and a
concrete example.
</p>

<hr>
<h2 id='attach_all_matrices'>Attach all matrices in a batch simulation</h2><span id='topic+attach_all_matrices'></span>

<h3>Description</h3>

<p>Attach all matrices in a batch simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_all_matrices(bs, backingpath = "bp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attach_all_matrices_+3A_bs">bs</code></td>
<td>
<p>A <code>batch_simulation</code> object.</p>
</td></tr>
<tr><td><code id="attach_all_matrices_+3A_backingpath">backingpath</code></td>
<td>
<p>Passed to <code><a href="bigmemory.html#topic+big.matrix">bigmemory::as.big.matrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>batch_simulation</code> object with all <code>hash_big_matrix</code>es attached.
</p>

<hr>
<h2 id='autolayer'>Autolayer generic function</h2><span id='topic+autolayer'></span>

<h3>Description</h3>

<p>See <code><a href="ggplot2.html#topic+autolayer">ggplot2::autolayer()</a></code>, <code><a href="#topic+autolayer.barrier">autolayer.barrier()</a></code> for details.
</p>

<hr>
<h2 id='autolayer.barrier'>Get a ggplot2 layer from a barrier object</h2><span id='topic+autolayer.barrier'></span>

<h3>Description</h3>

<p>This layer can show the saddle point (2d) and the minimal energy path (3d) on the landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'barrier'
autolayer(object, path = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autolayer.barrier_+3A_object">object</code></td>
<td>
<p>A <code>barrier</code> object.</p>
</td></tr>
<tr><td><code id="autolayer.barrier_+3A_path">path</code></td>
<td>
<p>Show the minimum energy path in the graph?</p>
</td></tr>
<tr><td><code id="autolayer.barrier_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> layer that can be added to an existing landscape plot.
</p>

<hr>
<h2 id='batch_simulation'>Perform a batch simulation.</h2><span id='topic+batch_simulation'></span><span id='topic+print.batch_simulation'></span>

<h3>Description</h3>

<p>Perform a batch simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_simulation(arg_grid, sim_fun, default_list, bigmemory = TRUE, ...)

## S3 method for class 'batch_simulation'
print(x, detail = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_simulation_+3A_arg_grid">arg_grid</code></td>
<td>
<p>An <code>arg_grid</code> object. See <code><a href="#topic+make_arg_grid">make_arg_grid()</a></code>.</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_sim_fun">sim_fun</code></td>
<td>
<p>The simulation function. See <code><a href="#topic+sim_fun_test">sim_fun_test()</a></code>
for an example.</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_default_list">default_list</code></td>
<td>
<p>A list of default values for <code>sim_fun</code>.</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_bigmemory">bigmemory</code></td>
<td>
<p>Use <code><a href="#topic+hash_big_matrix-class">hash_big_matrix-class()</a></code> to store large matrices?</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>sim_fun</code></p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_x">x</code></td>
<td>
<p>An <code>arg_set</code> object</p>
</td></tr>
<tr><td><code id="batch_simulation_+3A_detail">detail</code></td>
<td>
<p>Do you want to print the object details as a full list?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>batch_simulation</code> object, also a data frame.
The first column, <code>var</code>, is a list of
<code>ele_list</code> that contains all the variables; the second to the second
last columns are the values of the variables; the last column is the
output of the simulation function.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>batch_simulation()</code>: Perform a batch simulation.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>batch_arg_set_grad &lt;- new_arg_set()
batch_arg_set_grad &lt;- batch_arg_set_grad %&gt;%
  add_arg_ele(
    arg_name = "parameter", ele_name = "a",
    start = -6, end = -1, by = 1
  )
batch_grid_grad &lt;- make_arg_grid(batch_arg_set_grad)
batch_output_grad &lt;- batch_simulation(batch_grid_grad, sim_fun_grad,
  default_list = list(
    initial = list(x = 0, y = 0),
    parameter = list(a = -4, b = 0, c = 0, sigmasq = 1)
  ),
  length = 1e2,
  seed = 1614,
  bigmemory = FALSE
)
print(batch_output_grad)
</code></pre>

<hr>
<h2 id='calculate_barrier'>Functions for calculating energy barrier from landscapes</h2><span id='topic+calculate_barrier'></span><span id='topic+calculate_barrier.2d_landscape'></span><span id='topic+calculate_barrier.3d_landscape'></span><span id='topic+calculate_barrier.2d_landscape_batch'></span><span id='topic+calculate_barrier.3d_landscape_batch'></span>

<h3>Description</h3>

<p>Functions for calculating energy barrier from landscapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_barrier(l, ...)

## S3 method for class ''2d_landscape''
calculate_barrier(
  l,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  base = exp(1),
  ...
)

## S3 method for class ''3d_landscape''
calculate_barrier(
  l,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  Umax,
  expand = TRUE,
  omit_unstable = FALSE,
  base = exp(1),
  ...
)

## S3 method for class ''2d_landscape_batch''
calculate_barrier(
  l,
  bg = NULL,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  base = exp(1),
  ...
)

## S3 method for class ''3d_landscape_batch''
calculate_barrier(
  l,
  bg = NULL,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  Umax,
  expand = TRUE,
  omit_unstable = FALSE,
  base = exp(1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_barrier_+3A_l">l</code></td>
<td>
<p>A <code>landscape</code> object.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_start_location_value">start_location_value</code>, <code id="calculate_barrier_+3A_end_location_value">end_location_value</code></td>
<td>
<p>The initial position (in value)
for searching the start/end point.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_start_r">start_r</code>, <code id="calculate_barrier_+3A_end_r">end_r</code></td>
<td>
<p>The search radius (in L1 distance) for the start/end point.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_base">base</code></td>
<td>
<p>The base of the log function.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_umax">Umax</code></td>
<td>
<p>The highest possible value of the potential function.</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_expand">expand</code></td>
<td>
<p>If the values in the range all equal to <code>Umax</code>, expand the
range or not?</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_omit_unstable">omit_unstable</code></td>
<td>
<p>If a state is not stable (the &quot;local minimum&quot; overlaps
with the saddle point), omit that state or not?</p>
</td></tr>
<tr><td><code id="calculate_barrier_+3A_bg">bg</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;2d_barrier_grid&#8288;</code> or <code style="white-space: pre;">&#8288;3d_barrier_grid&#8288;</code> object if you want to use
different parameters for each condition. Otherwise <code>NULL</code> as default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>barrier</code> object that contains the (batch) barrier calculation result(s).
</p>

<hr>
<h2 id='check_conv'>Graphical diagnoses to check if the simulation converges</h2><span id='topic+check_conv'></span><span id='topic+print.check_conv'></span>

<h3>Description</h3>

<p>Compare the distribution of different stages of simulation (for <code>plot_type == "bin"</code> or <code>plot_type = "density"</code>), or show how the percentiles of the distribution evolve over time (for <code>plot_type == cumuplot</code>, see <code><a href="coda.html#topic+cumuplot">coda::cumuplot()</a></code> for details). More convergence checking methods for MCMC data are available at the <code>coda</code> package. Be cautious: each convergence checking method has its shortcomings, so do not blindly use any results as the definitive conclusion that a simulation converges or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_conv(output, vars, sample_perc = 0.2, plot_type = "bin")

## S3 method for class 'check_conv'
print(x, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_conv_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output.</p>
</td></tr>
<tr><td><code id="check_conv_+3A_vars">vars</code></td>
<td>
<p>The names of variables to check.</p>
</td></tr>
<tr><td><code id="check_conv_+3A_sample_perc">sample_perc</code></td>
<td>
<p>The percentage of data sample for the initial, middle, and final stage of the simulation. Not required if <code>plot_type == "cumuplot"</code>.</p>
</td></tr>
<tr><td><code id="check_conv_+3A_plot_type">plot_type</code></td>
<td>
<p>Which type of plots should be generated? (&quot;bin&quot;, &quot;density&quot;, or &quot;cumuplot&quot; which uses <code><a href="coda.html#topic+cumuplot">coda::cumuplot()</a></code>)</p>
</td></tr>
<tr><td><code id="check_conv_+3A_x">x</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="check_conv_+3A_ask">ask</code></td>
<td>
<p>Ask to press enter to see the next plot?</p>
</td></tr>
<tr><td><code id="check_conv_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>check_conv</code> object that contains the convergence checking result(for <code>plot_type == "bin"</code> or <code>plot_type = "density"</code>), or draw the cumuplot without a return value (for <code>plot_type == cumuplot</code>).
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(check_conv)</code>: Print a <code>check_conv</code> object.
</p>
</li></ul>

<hr>
<h2 id='fill_in_struct'>Fill a vector of values into a structure list.</h2><span id='topic+fill_in_struct'></span>

<h3>Description</h3>

<p>Fill a vector of values into a structure list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_in_struct(vec, struct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_in_struct_+3A_vec">vec</code></td>
<td>
<p>A vector of values.</p>
</td></tr>
<tr><td><code id="fill_in_struct_+3A_struct">struct</code></td>
<td>
<p>A list with a certain structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ele_list</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modified_simulation">modified_simulation()</a></code>
</p>

<hr>
<h2 id='get_barrier_height'>Summarize the barrier height from a <code>barrier</code> object</h2><span id='topic+get_barrier_height'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated. Use <code><a href="base.html#topic+summary">summary()</a></code> instead. (See <code><a href="#topic+summary.barrier">summary.barrier()</a></code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_barrier_height(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_barrier_height_+3A_object">object</code></td>
<td>
<p>A <code>barrier</code> object.</p>
</td></tr>
<tr><td><code id="get_barrier_height_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (for a single barrier calculation result) or a <code>data.frame</code> (for batch barrier calculation results) that contains the barrier heights on the landscape.
</p>

<hr>
<h2 id='get_dist'>Get the probability distribution from a landscape object</h2><span id='topic+get_dist'></span>

<h3>Description</h3>

<p>Get the probability distribution from a landscape object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist(l, index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dist_+3A_l">l</code></td>
<td>
<p>A <code>landscape</code> project.</p>
</td></tr>
<tr><td><code id="get_dist_+3A_index">index</code></td>
<td>
<p>1 to get the distribution in tidy format; 2 or &quot;raw&quot; to get the raw simulation result (<code>batch_simulation</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> that contains the distribution in the tidy format or the raw simulation result.
</p>

<hr>
<h2 id='get_geom'>Get a ggplot2 layer from a barrier object</h2><span id='topic+get_geom'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated. Use <code><a href="#topic+autolayer">autolayer()</a></code> instead. (See <code><a href="#topic+autolayer.barrier">autolayer.barrier()</a></code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_geom(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_geom_+3A_object">object</code></td>
<td>
<p>A <code>barrier</code> object.</p>
</td></tr>
<tr><td><code id="get_geom_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> layer that can be added to an existing landscape plot.
</p>

<hr>
<h2 id='hash_big_matrix-class'>Class &quot;hash_big_matrix&quot;: big matrix with a md5 hash reference</h2><span id='topic+hash_big_matrix-class'></span><span id='topic+hash_big_matrix'></span><span id='topic+as_hash_big_matrix'></span><span id='topic+attach_hash_big_matrix'></span>

<h3>Description</h3>

<p><code>hash_big_matrix</code> class is a modified class from <code><a href="bigmemory.html#topic+big.matrix-class">bigmemory::big.matrix-class()</a></code>. Its purpose is to
help users operate big matrices within hard disk in a reusable way, so that the large matrices do not consume
too much memory, and the matrices can be reused for the next time.
Comparing with <code><a href="bigmemory.html#topic+big.matrix-class">bigmemory::big.matrix-class()</a></code>, the major enhancement of <code>hash_big_matrix</code> class
is that the backing files are, by default, stored in a permanent place, with the md5 of the object as the file
name. With this explicit name, <code>hash_big_matrix</code> objects can be easily reloaded into workspace every time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_hash_big_matrix(x, backingpath = "bp", silence = TRUE, ...)

attach_hash_big_matrix(x, backingpath = "bp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hash_big_matrix-class_+3A_x">x</code></td>
<td>
<p>A matrix, vector, or data.frame for <code><a href="bigmemory.html#topic+big.matrix">bigmemory::as.big.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="hash_big_matrix-class_+3A_backingpath">backingpath</code>, <code id="hash_big_matrix-class_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="bigmemory.html#topic+big.matrix">bigmemory::as.big.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="hash_big_matrix-class_+3A_silence">silence</code></td>
<td>
<p>Suppress messages?</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>as_hash_big_matrix()</code>: Create a <code>hash_big_matrix</code> object from a matrix.
</p>
</li>
<li> <p><code>attach_hash_big_matrix()</code>: Attach a <code>hash_big_matrix</code> object from the backing file to the workspace.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>md5</code></dt><dd><p>The md5 value of the matrix.</p>
</dd>
<dt><code>address</code></dt><dd><p>Inherited from <code>big.matrix</code>.</p>
</dd>
</dl>

<hr>
<h2 id='make_2d_matrix'>Make a matrix of 2D static landscape plots for one or two parameters</h2><span id='topic+make_2d_matrix'></span>

<h3>Description</h3>

<p>Make a matrix of 2D static landscape plots for one or two parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_2d_matrix(
  bs,
  x,
  rows = NULL,
  cols,
  lims,
  kde_fun = c("ks", "base"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  individual_landscape = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_2d_matrix_+3A_bs">bs</code></td>
<td>
<p>A <code>batch_simulation</code> object created by <code style="white-space: pre;">&#8288;[batch_simulation()].&#8288;</code></p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_x">x</code></td>
<td>
<p>The name of the target variable.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_rows">rows</code>, <code id="make_2d_matrix_+3A_cols">cols</code></td>
<td>
<p>The names of the parameters. <code>rows</code> can be left blank if only one parameter is needed.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
<tr><td><code id="make_2d_matrix_+3A_individual_landscape">individual_landscape</code></td>
<td>
<p>Make individual landscape for each simulation? Default is <code>TRUE</code> so that it is possible to calculate barriers. Set to <code>FALSE</code> to save time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;2d_matrix_landscape&#8288;</code> object that describes the landscape of the system, including the smoothed distribution and the landscape plot.
</p>

<hr>
<h2 id='make_2d_static'>Make 2D static landscape plot for a single simulation output</h2><span id='topic+make_2d_static'></span><span id='topic+make_2d_single'></span>

<h3>Description</h3>

<p>Make 2D static landscape plot for a single simulation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_2d_static(
  output,
  x,
  lims,
  kde_fun = c("ks", "base"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5
)

make_2d_single(
  output,
  x,
  lims,
  kde_fun = c("ks", "base"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_2d_static_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_x">x</code></td>
<td>
<p>The name of the target variable.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_2d_static_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;2d_static_landscape&#8288;</code> object that describes the landscape of the system, including the smooth distribution and the landscape plot.
</p>

<hr>
<h2 id='make_2d_tidy_dist'>Make a tidy <code>data.frame</code> from smooth 2d distribution matrix</h2><span id='topic+make_2d_tidy_dist'></span>

<h3>Description</h3>

<p>Make a tidy <code>data.frame</code> from smooth 2d distribution matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_2d_tidy_dist(dist_2d, value = NULL, var_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_2d_tidy_dist_+3A_dist_2d">dist_2d</code></td>
<td>
<p><code>kde2d</code> distribution.</p>
</td></tr>
<tr><td><code id="make_2d_tidy_dist_+3A_value">value</code></td>
<td>
<p>The value of the variable of interest.</p>
</td></tr>
<tr><td><code id="make_2d_tidy_dist_+3A_var_name">var_name</code></td>
<td>
<p>The name of the variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy <code>data.frame</code>.
</p>

<hr>
<h2 id='make_3d_animation'>Make 3d animations from multiple simulations</h2><span id='topic+make_3d_animation'></span>

<h3>Description</h3>

<p>Make 3d animations from multiple simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_3d_animation(
  bs,
  x,
  y,
  fr,
  lims,
  kde_fun = c("ks", "MASS"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  individual_landscape = TRUE,
  mat_3d = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_3d_animation_+3A_bs">bs</code></td>
<td>
<p>A <code>batch_simulation</code> object created by <code style="white-space: pre;">&#8288;[batch_simulation()].&#8288;</code></p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_x">x</code>, <code id="make_3d_animation_+3A_y">y</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_fr">fr</code></td>
<td>
<p>The names of the parameters used to represent frames in the animation.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_individual_landscape">individual_landscape</code></td>
<td>
<p>Make individual landscape for each simulation? Default is <code>TRUE</code> so that it is possible to calculate barriers. Set to <code>FALSE</code> to save time.</p>
</td></tr>
<tr><td><code id="make_3d_animation_+3A_mat_3d">mat_3d</code></td>
<td>
<p>Also make the matrix by <code><a href="#topic+make_3d_matrix">make_3d_matrix()</a></code>? If so, the matrix can be drawn with <code style="white-space: pre;">&#8288;plot(&lt;landscape&gt;, 3)&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;3d_animation_landscape&#8288;</code> object that describes the landscape of the system, including the smoothed distribution and the landscape plot.
</p>

<hr>
<h2 id='make_3d_matrix'>Make a matrix of 3D static landscape plots for one or two parameters</h2><span id='topic+make_3d_matrix'></span>

<h3>Description</h3>

<p>Currently only 3D (x, y, color) is supported. Matrices with 3D (x, y, z) plots are not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_3d_matrix(
  bs,
  x,
  y,
  rows = NULL,
  cols,
  lims,
  kde_fun = c("ks", "MASS"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5,
  individual_landscape = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_3d_matrix_+3A_bs">bs</code></td>
<td>
<p>A <code>batch_simulation</code> object created by <code style="white-space: pre;">&#8288;[batch_simulation()].&#8288;</code></p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_x">x</code>, <code id="make_3d_matrix_+3A_y">y</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_rows">rows</code>, <code id="make_3d_matrix_+3A_cols">cols</code></td>
<td>
<p>The names of the parameters. <code>rows</code> can be left blank if only one parameter is needed.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
<tr><td><code id="make_3d_matrix_+3A_individual_landscape">individual_landscape</code></td>
<td>
<p>Make individual landscape for each simulation? Default is <code>TRUE</code> so that it is possible to calculate barriers. Set to <code>FALSE</code> to save time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;3d_matrix_landscape&#8288;</code> object that describes the landscape of the system, including the smoothed distribution and the landscape plot.
</p>

<hr>
<h2 id='make_3d_static'>Make 3D static landscape plots from simulation output</h2><span id='topic+make_3d_static'></span><span id='topic+make_3d_single'></span>

<h3>Description</h3>

<p>Make 3D static landscape plots from simulation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_3d_static(
  output,
  x,
  y,
  lims,
  kde_fun = c("ks", "MASS"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5
)

make_3d_single(
  output,
  x,
  y,
  lims,
  kde_fun = c("ks", "MASS"),
  n = 200,
  h,
  adjust = 1,
  Umax = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_3d_static_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_x">x</code>, <code id="make_3d_static_+3A_y">y</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_3d_static_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;3d_static_landscape&#8288;</code> object that describes the landscape of the system, including the smooth distribution and the landscape plot.
</p>

<hr>
<h2 id='make_4d_static'>Make 4D static space-color plots from simulation output</h2><span id='topic+make_4d_static'></span><span id='topic+make_4d_single'></span>

<h3>Description</h3>

<p>Make 4D static space-color plots from simulation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_4d_static(
  output,
  x,
  y,
  z,
  lims,
  kde_fun = "ks",
  n = 50,
  h,
  adjust = 1,
  Umax = 5
)

make_4d_single(
  output,
  x,
  y,
  z,
  lims,
  kde_fun = "ks",
  n = 50,
  h,
  adjust = 1,
  Umax = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_4d_static_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_x">x</code>, <code id="make_4d_static_+3A_y">y</code>, <code id="make_4d_static_+3A_z">z</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
<tr><td><code id="make_4d_static_+3A_umax">Umax</code></td>
<td>
<p>The maximum displayed value of potential.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;4d_static_landscape&#8288;</code> object that describes the landscape of the system, including the smoothed distribution and the landscape plot.
</p>

<hr>
<h2 id='make_barrier_grid_2d'>Make a grid for calculating barriers for 2d landscapes</h2><span id='topic+make_barrier_grid_2d'></span>

<h3>Description</h3>

<p>Make a grid for calculating barriers for 2d landscapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_barrier_grid_2d(
  ag,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  df = NULL,
  print_template = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_barrier_grid_2d_+3A_ag">ag</code></td>
<td>
<p>An <code>arg_grid</code> object.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_2d_+3A_start_location_value">start_location_value</code>, <code id="make_barrier_grid_2d_+3A_start_r">start_r</code>, <code id="make_barrier_grid_2d_+3A_end_location_value">end_location_value</code>, <code id="make_barrier_grid_2d_+3A_end_r">end_r</code></td>
<td>
<p>Default values for finding local minimum. See <code><a href="#topic+calculate_barrier">calculate_barrier()</a></code>.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_2d_+3A_df">df</code></td>
<td>
<p>A data frame for the variables. Use <code>print_template = TRUE</code> to get a template.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_2d_+3A_print_template">print_template</code></td>
<td>
<p>Print a template for <code>df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>barrier_grid_2d</code> object that specifies the condition for each barrier calculation.
</p>

<hr>
<h2 id='make_barrier_grid_3d'>Make a grid for calculating barriers for 3d landscapes</h2><span id='topic+make_barrier_grid_3d'></span>

<h3>Description</h3>

<p>Make a grid for calculating barriers for 3d landscapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_barrier_grid_3d(
  ag,
  start_location_value,
  start_r,
  end_location_value,
  end_r,
  df = NULL,
  print_template = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_barrier_grid_3d_+3A_ag">ag</code></td>
<td>
<p>An <code>arg_grid</code> object.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_3d_+3A_start_location_value">start_location_value</code>, <code id="make_barrier_grid_3d_+3A_start_r">start_r</code>, <code id="make_barrier_grid_3d_+3A_end_location_value">end_location_value</code>, <code id="make_barrier_grid_3d_+3A_end_r">end_r</code></td>
<td>
<p>Default values for finding local minimum. See <code><a href="#topic+calculate_barrier">calculate_barrier()</a></code>.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_3d_+3A_df">df</code></td>
<td>
<p>A data frame for the variables. Use <code>print_template = TRUE</code> to get a template.</p>
</td></tr>
<tr><td><code id="make_barrier_grid_3d_+3A_print_template">print_template</code></td>
<td>
<p>Print a template for <code>df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>barrier_grid_3d</code> object that specifies the condition for each barrier calculation.
</p>

<hr>
<h2 id='make_kernel_dist'>Calculate 1D, 2D, or 3D kernel smooth distribution</h2><span id='topic+make_kernel_dist'></span>

<h3>Description</h3>

<p>Calculate 1D, 2D, or 3D kernel smooth distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_kernel_dist(output, var_names, lims, kde_fun, n, h, adjust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_kernel_dist_+3A_output">output</code></td>
<td>
<p>A matrix of simulation output.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_var_names">var_names</code></td>
<td>
<p>The names of the target variables.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_lims">lims</code></td>
<td>
<p>The limits of the range for the density estimator as <code>c(xl, xu)</code> for 2D landscapes, <code>c(xl, xu, yl, yu)</code> for 3D landscapes, <code>c(xl, xu, yl, yu, zl, zu)</code> for 4D landscapes. If missing, the range of the data extended by 10% for both sides will be used. For landscapes based on multiple simulations, the largest range of all simulations (which means the lowest lower limit and the highest upper limit) will be used by default.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_kde_fun">kde_fun</code></td>
<td>
<p>Which kernel estimator to use? Choices: &quot;ks&quot; <code><a href="ks.html#topic+kde">ks::kde()</a></code> (default; faster and using less memory); &quot;base&quot; <code>base::density()</code> (only for 2D landscapes); &quot;MASS&quot; <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> (only for 3D landscapes).</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_n">n</code></td>
<td>
<p>The number of equally spaced points in each axis, at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_h">h</code></td>
<td>
<p>A number, or possibly a vector for 3D and 4D landscapes, specifying the smoothing bandwidth to be used. If missing, the default value of the kernel estimator will be used (but <code>bw = "SJ"</code> for <code>base::density()</code>). Note that the definition of bandwidth might be different for different kernel estimators. For landscapes based on multiple simulations, the largest <code>h</code> of all simulations will be used by default.</p>
</td></tr>
<tr><td><code id="make_kernel_dist_+3A_adjust">adjust</code></td>
<td>
<p>The multiplier to the bandwidth. The bandwidth used is actually <code>adjust * h</code>. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the smooth distribution.
</p>

<hr>
<h2 id='modified_simulation'>Modify a single simulation</h2><span id='topic+modified_simulation'></span>

<h3>Description</h3>

<p>Modify a single simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modified_simulation(sim_fun, ele_list, default_list, bigmemory = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modified_simulation_+3A_ele_list">ele_list</code></td>
<td>
<p>An <code>ele_list</code> object generated by <code><a href="#topic+fill_in_struct">fill_in_struct()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.landscape'>Make plots from landscape objects</h2><span id='topic+plot.landscape'></span>

<h3>Description</h3>

<p>Make plots from landscape objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'landscape'
plot(x, index = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.landscape_+3A_x">x</code></td>
<td>
<p>A landscape object</p>
</td></tr>
<tr><td><code id="plot.landscape_+3A_index">index</code></td>
<td>
<p>Default is 1. For some landscape objects, there is a second plot (usually 2d heatmaps for 3d landscapes)
or a third plot (usually 3d matrices for 3d animations).
Use <code>index = 2</code> to plot that one.</p>
</td></tr>
<tr><td><code id="plot.landscape_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot.
</p>

<hr>
<h2 id='save_landscape'>Save landscape plots</h2><span id='topic+save_landscape'></span>

<h3>Description</h3>

<p>Save landscape plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_landscape(l, path = NULL, selfcontained = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_landscape_+3A_l">l</code></td>
<td>
<p>A landscape object</p>
</td></tr>
<tr><td><code id="save_landscape_+3A_path">path</code></td>
<td>
<p>The path to save the output. Default: &quot;/pics/x_y.html&quot;.</p>
</td></tr>
<tr><td><code id="save_landscape_+3A_selfcontained">selfcontained</code></td>
<td>
<p>For 'plotly' plots, save the output as a self-contained html file? Default: FALSE.</p>
</td></tr>
<tr><td><code id="save_landscape_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="htmlwidgets.html#topic+saveWidget">htmlwidgets::saveWidget()</a></code>
or <code><a href="ggplot2.html#topic+ggsave">ggplot2::ggsave()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function saves the plot to a specific path. It does not have a return value.
</p>

<hr>
<h2 id='sim_fun_grad'>A simple gradient simulation function for testing</h2><span id='topic+sim_fun_grad'></span>

<h3>Description</h3>

<p>This is a toy stochastic gradient system which can have bistability in some conditions.
Model specification:
</p>
<p style="text-align: center;"><code class="reqn">U = x^4 + y^4 + axy + bx + cy</code>
</p>

<p style="text-align: center;"><code class="reqn">dx/dt = - \partial U/ \partial x + \sigma dW/dt = - 4x^3 - ay - b + \sigma dW/dt</code>
</p>

<p style="text-align: center;"><code class="reqn">dy/dt = - \partial U/ \partial y + \sigma dW/dt = - 4y^3 - ax - c + \sigma dW/dt</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sim_fun_grad(
  initial = list(x = 0, y = 0),
  parameter = list(a = -4, b = 0, c = 0, sigmasq = 1),
  length = 1e+05,
  stepsize = 0.01,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_fun_grad_+3A_initial">initial</code>, <code id="sim_fun_grad_+3A_parameter">parameter</code></td>
<td>
<p>Two sets of parameters. <code>initial</code> contains the initial value of <code>x</code> and <code>y</code>;
<code>parameter</code> contains <code style="white-space: pre;">&#8288;a,b,c&#8288;</code>, which control the shape of the potential landscape,
and <code>sigmasq</code>, which is the square of <code class="reqn">\sigma</code> and controls the amplitude of noise.</p>
</td></tr>
<tr><td><code id="sim_fun_grad_+3A_length">length</code></td>
<td>
<p>The length of simulation.</p>
</td></tr>
<tr><td><code id="sim_fun_grad_+3A_stepsize">stepsize</code></td>
<td>
<p>The step size used in the Euler method.</p>
</td></tr>
<tr><td><code id="sim_fun_grad_+3A_seed">seed</code></td>
<td>
<p>The initial seed that will be passed to <code>set.seed()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of simulation results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_fun_nongrad">sim_fun_nongrad()</a></code> and <code><a href="#topic+batch_simulation">batch_simulation()</a></code>.
</p>

<hr>
<h2 id='sim_fun_nongrad'>A simple non-gradient simulation function for testing</h2><span id='topic+sim_fun_nongrad'></span>

<h3>Description</h3>

<p>This is a toy stochastic non-gradient system which can have multistability in some conditions.
Model specification:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_fun_nongrad(
  initial = list(x1 = 0, x2 = 0, a = 1),
  parameter = list(b = 1, k = 1, S = 0.5, n = 4, lambda = 0.01, sigmasq1 = 8, sigmasq2 =
    8, sigmasq3 = 2),
  constrain_a = TRUE,
  amin = -0.3,
  amax = 1.8,
  length = 1e+05,
  stepsize = 0.01,
  seed = NULL,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_fun_nongrad_+3A_initial">initial</code>, <code id="sim_fun_nongrad_+3A_parameter">parameter</code></td>
<td>
<p>Two sets of parameters. <code>initial</code> contains the initial value of <code>x1</code>, <code>x2</code>, and <code>a</code>;
<code>parameter</code> contains <code style="white-space: pre;">&#8288;b,k,S,n,lambda&#8288;</code>, which control the model dynamics,
and <code style="white-space: pre;">&#8288;sigmasq1,sigmasq2,sigmasq3&#8288;</code>, which are the squares of <code class="reqn">\sigma_1,\sigma_2,\sigma_3</code> and controls the amplitude of noise.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_constrain_a">constrain_a</code></td>
<td>
<p>Should the value of <code>a</code> be constrained? (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_amin">amin</code>, <code id="sim_fun_nongrad_+3A_amax">amax</code></td>
<td>
<p>If <code>constrain_a</code>, the minimum and maximum values of a.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_length">length</code></td>
<td>
<p>The length of simulation.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_stepsize">stepsize</code></td>
<td>
<p>The step size used in the Euler method.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_seed">seed</code></td>
<td>
<p>The initial seed that will be passed to <code>set.seed()</code> function.</p>
</td></tr>
<tr><td><code id="sim_fun_nongrad_+3A_progress">progress</code></td>
<td>
<p>Show progress bar of the simulation?</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">\frac {dx_ {1}}{dt}  =  \frac {ax_ {1}^ {n}}{S^ {n}+x_ {1}^ {n}} + \frac {bS^ {n}}{S^ {n}+x_ {2}^ {n}} - kx_ {1}+ \sigma_1 dW_1/dt</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac {dx_ {2}}{dt}  =  \frac {ax_ {2}^ {n}}{S^ {n}+x_ {2}^ {n}} + \frac {bS^ {n}}{S^ {n}+x_ {1}^ {n}} - kx_ {2}+ \sigma_2 dW_2/dt</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac {da}{dt} = -\lambda a+ \sigma_3 dW_3/dt</code>
</p>



<h3>Value</h3>

<p>A matrix of simulation results.
</p>


<h3>References</h3>

<p>Wang, J., Zhang, K., Xu, L., &amp; Wang, E. (2011). Quantifying the Waddington landscape and biological paths for development and differentiation. Proceedings of the National Academy of Sciences, 108(20), 8257-8262.
<a href="https://doi.org/10.1073/pnas.1017017108">doi:10.1073/pnas.1017017108</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_fun_grad">sim_fun_grad()</a></code> and <code><a href="#topic+batch_simulation">batch_simulation()</a></code>.
</p>

<hr>
<h2 id='sim_fun_test'>A simple simulation function for testing</h2><span id='topic+sim_fun_test'></span>

<h3>Description</h3>

<p>A simple simulation function for testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_fun_test(par1, par2, length = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_fun_test_+3A_par1">par1</code>, <code id="sim_fun_test_+3A_par2">par2</code></td>
<td>
<p>Two parameters. <code>par1</code> contains <code>var1</code>;
<code>par2</code> contains <code>var2</code> and <code>var3</code>.</p>
</td></tr>
<tr><td><code id="sim_fun_test_+3A_length">length</code></td>
<td>
<p>The length of simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of simulation results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_fun_grad">sim_fun_grad()</a></code> and <code><a href="#topic+sim_fun_nongrad">sim_fun_nongrad()</a></code> for more realistic
examples.
</p>

<hr>
<h2 id='sim_fun_test2'>A simple yet meaningful simulation function for testing</h2><span id='topic+sim_fun_test2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>sim_fun_test2()</code> was renamed to <code>sim_fun_grad()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_fun_test2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_fun_test2_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to <code><a href="#topic+sim_fun_grad">sim_fun_grad()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='summary.barrier'>Summarize the barrier height from a <code>barrier</code> object</h2><span id='topic+summary.barrier'></span>

<h3>Description</h3>

<p>Summarize the barrier height from a <code>barrier</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'barrier'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.barrier_+3A_object">object</code></td>
<td>
<p>A <code>barrier</code> object.</p>
</td></tr>
<tr><td><code id="summary.barrier_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (for a single barrier calculation result) or a <code>data.frame</code> (for batch barrier calculation results) that contains the barrier heights on the landscape.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
