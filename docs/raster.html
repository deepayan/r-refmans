<!DOCTYPE html><html><head><title>Help for package raster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {raster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#raster-package'>
<p>Overview of the functions in the raster package</p></a></li>
<li><a href='#addLayer'><p>Add or drop a layer</p></a></li>
<li><a href='#adjacent'><p>Adjacent cells</p></a></li>
<li><a href='#aggregate'><p>Aggregate raster cells or SpatialPolygons/Lines</p></a></li>
<li><a href='#alignExtent'><p>Align an extent (object of class Extent)</p></a></li>
<li><a href='#animate'><p>Animate layers of a Raster* object</p></a></li>
<li><a href='#approxNA'><p>Estimate values for cell values that are <code>NA</code> by interpolating between layers</p></a></li>
<li><a href='#area'><p>Size of cells</p></a></li>
<li><a href='#Arith-methods'><p>Arithmetic with Raster* objects</p></a></li>
<li><a href='#as.character'><p>Character representation of a Raster or Extent object</p></a></li>
<li><a href='#as.data.frame'><p>Get a data.frame with raster cell values, or coerce SpatialPolygons, Lines, or Points to a data.frame</p></a></li>
<li><a href='#as.list'><p>Create a list of RasterLayer objects</p></a></li>
<li><a href='#as.logical'><p> Change cell values to logical or integer values</p></a></li>
<li><a href='#as.matrix'><p>Get a vector, matrix, or array with raster cell values</p></a></li>
<li><a href='#as.raster'><p>Coerce to a 'raster' object</p></a></li>
<li><a href='#atan2'><p>Two argument arc-tangent</p></a></li>
<li><a href='#autocorrelation'><p>Spatial autocorrelation</p></a></li>
<li><a href='#bands'><p>Number of bands</p></a></li>
<li><a href='#barplot'><p>Bar plot of a RasterLayer</p></a></li>
<li><a href='#bind'>
<p>Bind Spatial* objects</p></a></li>
<li><a href='#blockSize'><p>Block size for writing files</p></a></li>
<li><a href='#boundaries'><p>boundaries (edges) detection</p></a></li>
<li><a href='#boxplot'>
<p>Box plot of Raster objects</p></a></li>
<li><a href='#brick'><p> Create a RasterBrick object</p></a></li>
<li><a href='#buffer'><p>buffer</p></a></li>
<li><a href='#calc'><p>Calculate</p></a></li>
<li><a href='#cellFrom'><p>Get cell, row, or column number</p></a></li>
<li><a href='#cellsFromExtent'><p>Cells from extent, and vice versa</p></a></li>
<li><a href='#cellStats'><p>Statistics across cells</p></a></li>
<li><a href='#clamp'><p>Clamp values</p></a></li>
<li><a href='#clearValues'><p>Clear values</p></a></li>
<li><a href='#click'><p>Query by clicking on a map</p></a></li>
<li><a href='#clump'><p>Detect clumps</p></a></li>
<li><a href='#cluster'><p>Use a multi-core cluster</p></a></li>
<li><a href='#colortable'><p>colortable</p></a></li>
<li><a href='#Compare-methods'><p>Compare Raster* objects</p></a></li>
<li><a href='#compareCRS'><p> Partially compare two CRS objects</p></a></li>
<li><a href='#compareRaster'><p>Compare Raster objects</p></a></li>
<li><a href='#contour'><p>Contour plot</p></a></li>
<li><a href='#corLocal'><p>Local correlation coefficient</p></a></li>
<li><a href='#cover'><p> Replace NA values with values of other layers</p></a></li>
<li><a href='#crop'><p>Crop</p></a></li>
<li><a href='#crosstab'><p>Cross-tabulate</p></a></li>
<li><a href='#cut'><p>Convert values to classes</p></a></li>
<li><a href='#cv'><p>Coefficient of variation</p></a></li>
<li><a href='#datasource'><p>Are values in memory and/or on disk?</p></a></li>
<li><a href='#dataType'><p>Data type</p></a></li>
<li><a href='#density'><p>Density plot</p></a></li>
<li><a href='#dim'><p>Dimensions of a Raster* object</p></a></li>
<li><a href='#direction'><p>Direction</p></a></li>
<li><a href='#disaggregate'><p>Disaggregate</p></a></li>
<li><a href='#distance'><p>Distance</p></a></li>
<li><a href='#distanceFromPoints'><p>Distance from points</p></a></li>
<li><a href='#draw'><p> Draw a line or polygon</p></a></li>
<li><a href='#drawExtent'><p> Create an Extent object by drawing on a map</p></a></li>
<li><a href='#erase'>
<p>Erase parts of a SpatialPolygons* or SpatialLines* object. The inverse of this can be done with <code>intersect</code></p></a></li>
<li><a href='#extend'><p>Extend</p></a></li>
<li><a href='#extension'><p>Filename extensions</p></a></li>
<li><a href='#extent'><p>Extent</p></a></li>
<li><a href='#Extent math'><p>round Extent coordinates</p></a></li>
<li><a href='#Extent-class'><p>Class &quot;Extent&quot;</p></a></li>
<li><a href='#extract'><p>Extract values from Raster objects</p></a></li>
<li><a href='#Extract by index'><p>Indexing to extract values of a Raster* object</p></a></li>
<li><a href='#Extreme coordinates'><p>Coordinates of the Extent of a Raster object</p></a></li>
<li><a href='#extremeValues'><p>Minimum and maximum values</p></a></li>
<li><a href='#factors'><p>Factors</p></a></li>
<li><a href='#filename'><p>Filename</p></a></li>
<li><a href='#filledContour'><p>Filled contour plot</p></a></li>
<li><a href='#flip'><p>Flip</p></a></li>
<li><a href='#flowPath'><p>Flow path</p></a></li>
<li><a href='#focal'><p>Focal values</p></a></li>
<li><a href='#focalWeight'><p>Focal weights matrix</p></a></li>
<li><a href='#freq'><p>Frequency table</p></a></li>
<li><a href='#Gain and offset'><p>Gain and offset of values on file</p></a></li>
<li><a href='#geom'><p>Get the coordinates of a vector type Spatial* object</p></a></li>
<li><a href='#getData'><p>Get geographic data</p></a></li>
<li><a href='#getValues'><p>Get raster cell values</p></a></li>
<li><a href='#getValuesBlock'><p>Get a block of raster cell values</p></a></li>
<li><a href='#getValuesFocal'><p>Get focal raster cell values</p></a></li>
<li><a href='#gridDistance'><p>Distance on a grid</p></a></li>
<li><a href='#hdr'><p>Header files</p></a></li>
<li><a href='#head'><p>Show the head or tail of a Raster* object</p></a></li>
<li><a href='#hillShade'><p>Hill shading</p></a></li>
<li><a href='#hist'><p>Histogram</p></a></li>
<li><a href='#image'><p>Image</p></a></li>
<li><a href='#inifile'><p>Read a .ini file</p></a></li>
<li><a href='#initialize'><p>Initialize a Raster object with values</p></a></li>
<li><a href='#interpolate'><p>Interpolate</p></a></li>
<li><a href='#intersect'>
<p>Intersect</p></a></li>
<li><a href='#isLonLat'><p>Is this longitude/latitude data?</p></a></li>
<li><a href='#KML'><p>Write a KML or KMZ file</p></a></li>
<li><a href='#layerize'><p>Layerize</p></a></li>
<li><a href='#layerStats'><p>Correlation and (weighted) covariance</p></a></li>
<li><a href='#localFun'><p>Local functions</p></a></li>
<li><a href='#Logic-methods'><p>Logical operators and functions</p></a></li>
<li><a href='#mask'><p>Mask values in a Raster object</p></a></li>
<li><a href='#match'><p>Value matching for Raster* objects</p></a></li>
<li><a href='#Math-methods'><p>Mathematical functions</p></a></li>
<li><a href='#merge'>
<p>Merge Raster* objects</p></a></li>
<li><a href='#metadata'><p> Metadata</p></a></li>
<li><a href='#modal'><p>modal value</p></a></li>
<li><a href='#mosaic'>
<p>Merge Raster* objects using a function for overlapping areas</p></a></li>
<li><a href='#movingFun'><p>Moving functions</p></a></li>
<li><a href='#names'><p>Names of raster layers</p></a></li>
<li><a href='#NAvalue'><p>Set the NA value of a RasterLayer</p></a></li>
<li><a href='#ncell'><p>Number or rows, columns, and cells of a Raster* object</p></a></li>
<li><a href='#nlayers'><p>Number of layers</p></a></li>
<li><a href='#Options'><p>Global options for the raster package</p></a></li>
<li><a href='#origin'><p>Origin</p></a></li>
<li><a href='#overlay'><p>Overlay Raster objects</p></a></li>
<li><a href='#pairs'>
<p>Pairs plot (matrix of scatterplots)</p></a></li>
<li><a href='#persp'><p>Perspective plot</p></a></li>
<li><a href='#plot'><p>Plot a Raster* object</p></a></li>
<li><a href='#plotRGB'><p>Red-Green-Blue plot of a multi-layered Raster object</p></a></li>
<li><a href='#pointDistance'><p>Distance between points</p></a></li>
<li><a href='#predict'><p>Spatial model predictions</p></a></li>
<li><a href='#Programming'><p>Helper functions for programming</p></a></li>
<li><a href='#projection'><p> Get or set a coordinate reference system (projection)</p></a></li>
<li><a href='#projectRaster'><p>Project a Raster object</p></a></li>
<li><a href='#properties'><p>Raster file properties</p></a></li>
<li><a href='#quantile'><p>Raster quantiles</p></a></li>
<li><a href='#raster'><p>Create a RasterLayer object</p></a></li>
<li><a href='#Raster-class'><p> Raster* classes</p></a></li>
<li><a href='#rasterFromCells'><p>Subset a raster by cell numbers</p></a></li>
<li><a href='#rasterFromXYZ'><p> Create a Raster* object from x, y, z values</p></a></li>
<li><a href='#rasterize'><p>Rasterize points, lines, or polygons</p></a></li>
<li><a href='#rasterTmpFile'><p>Temporary files</p></a></li>
<li><a href='#rasterToContour'><p> Raster to contour lines conversion</p></a></li>
<li><a href='#rasterToPoints'><p> Raster to points conversion</p></a></li>
<li><a href='#rasterToPolygons'><p> Raster to polygons conversion</p></a></li>
<li><a href='#Rcpp-class'><p> Rcpp classes</p></a></li>
<li><a href='#readAll'><p>Read values from disk</p></a></li>
<li><a href='#reclassify'><p>Reclassify</p></a></li>
<li><a href='#rectify'><p>rectify a Raster object</p></a></li>
<li><a href='#replacement'><p>Replace cell values or layers of a Raster* object</p></a></li>
<li><a href='#resample'><p>Resample a Raster object</p></a></li>
<li><a href='#resolution'><p>Resolution</p></a></li>
<li><a href='#RGB'><p>Create a Red-Green-Blue Raster object</p></a></li>
<li><a href='#rotate'><p>Rotate</p></a></li>
<li><a href='#rotated'><p>Do the raster cells have a rotation?</p></a></li>
<li><a href='#round'><p>Integer values</p></a></li>
<li><a href='#rowFromCell'><p>Row or column number from a cell number</p></a></li>
<li><a href='#rowSums'><p>rowSums and colSums for Raster objects</p></a></li>
<li><a href='#SampleInt'><p>Sample integer values</p></a></li>
<li><a href='#sampleRandom'><p>Random sample</p></a></li>
<li><a href='#sampleRegular'><p>Regular sample</p></a></li>
<li><a href='#sampleStratified'><p>Stratified random sample</p></a></li>
<li><a href='#scale'><p>Scale values</p></a></li>
<li><a href='#scalebar'><p>scalebar</p></a></li>
<li><a href='#select'>
<p>Geometric subsetting</p></a></li>
<li><a href='#setExtent'><p>Set the extent of a RasterLayer</p></a></li>
<li><a href='#setMinMax'><p>Compute min and max values</p></a></li>
<li><a href='#setValues'><p>Set values of a Raster object</p></a></li>
<li><a href='#shapefile'>
<p>Read or write a shapefile</p></a></li>
<li><a href='#shift'><p>Shift</p></a></li>
<li><a href='#Slope and aspect'><p>Slope and aspect</p></a></li>
<li><a href='#spEasy'><p>Create SpatialLines* or SpatialPolygons*</p></a></li>
<li><a href='#spplot'><p>Use spplot to plot a Raster* or other object</p></a></li>
<li><a href='#stack'><p>Create a RasterStack object</p></a></li>
<li><a href='#stackApply'><p>Apply a function on subsets of a RasterStack or RasterBrick</p></a></li>
<li><a href='#stackSave'><p>Save or open a RasterStack file</p></a></li>
<li><a href='#stackSelect'><p>Select cell values from a multi-layer Raster* object</p></a></li>
<li><a href='#stretch'><p>Stretch</p></a></li>
<li><a href='#subset'><p>Subset layers in a Raster* object</p></a></li>
<li><a href='#substitute'><p> Substitute values in a Raster* object</p></a></li>
<li><a href='#Summary'><p>Summary</p></a></li>
<li><a href='#Summary-methods'><p> Summary methods</p></a></li>
<li><a href='#symdif'>
<p>Symetrical difference</p></a></li>
<li><a href='#terrain'><p>Terrain characteristics</p></a></li>
<li><a href='#text'><p>Add labels to a map</p></a></li>
<li><a href='#transpose'><p>Transpose</p></a></li>
<li><a href='#trim'><p>Trim</p></a></li>
<li><a href='#union'>
<p>Union Extent or SpatialPolygons* objects</p></a></li>
<li><a href='#unique'><p>Unique values</p></a></li>
<li><a href='#unstack'><p> Unstack</p></a></li>
<li><a href='#update'><p>Update raster cells of files (on disk)</p></a></li>
<li><a href='#validCell'><p>Validity of a cell, column or row number</p></a></li>
<li><a href='#validNames'><p>Create valid names</p></a></li>
<li><a href='#weighted.mean'><p>Weighted mean of rasters</p></a></li>
<li><a href='#which'><p>Which cells are TRUE?</p></a></li>
<li><a href='#which.min'><p>Where is the min or max value?</p></a></li>
<li><a href='#writeFormats'><p>File types for writing</p></a></li>
<li><a href='#writeRaster'><p>Write raster data to a file</p></a></li>
<li><a href='#writeValues'><p>Write values to a file</p></a></li>
<li><a href='#xyFromCell'><p>Coordinates from a row, column or cell number</p></a></li>
<li><a href='#z-values'><p>Get or set z-values</p></a></li>
<li><a href='#zApply'><p>z (time) apply</p></a></li>
<li><a href='#zonal'><p>Zonal statistics</p></a></li>
<li><a href='#zoom'><p>Zoom in on a map</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geographic Data Analysis and Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>3.6-26</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-12</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, methods, terra (&ge; 1.7-29)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>sp (&ge; 1.4-5), R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ncdf4, igraph, tcltk, parallel, rasterVis, MASS, sf,
tinytest, gstat, fields, exactextractr</td>
</tr>
<tr>
<td>Description:</td>
<td>Reading, writing, manipulating, analyzing and modeling of spatial data. This package has been superseded by the "terra" package <a href="https://CRAN.R-project.org/package=terra">https://CRAN.R-project.org/package=terra</a>. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rspatial.org/raster">https://rspatial.org/raster</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rspatial/raster/issues/">https://github.com/rspatial/raster/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-12 15:29:22 UTC; rhijm</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert J. Hijmans <a href="https://orcid.org/0000-0001-5872-2872"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Jacob van Etten [ctb],
  Michael Sumner [ctb],
  Joe Cheng [ctb],
  Dan Baston [ctb],
  Andrew Bevan [ctb],
  Roger Bivand [ctb],
  Lorenzo Busetto [ctb],
  Mort Canty [ctb],
  Ben Fasoli [ctb],
  David Forrest [ctb],
  Aniruddha Ghosh [ctb],
  Duncan Golicher [ctb],
  Josh Gray [ctb],
  Jonathan A. Greenberg [ctb],
  Paul Hiemstra [ctb],
  Kassel Hingee [ctb],
  Alex Ilich [ctb],
  Institute for Mathematics Applied Geosciences [cph],
  Charles Karney [ctb],
  Matteo Mattiuzzi [ctb],
  Steven Mosher [ctb],
  Babak Naimi [ctb],
  Jakub Nowosad [ctb],
  Edzer Pebesma [ctb],
  Oscar Perpinan Lamigueiro [ctb],
  Etienne B. Racine [ctb],
  Barry Rowlingson [ctb],
  Ashton Shortridge [ctb],
  Bill Venables [ctb],
  Rafael Wueest [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert J. Hijmans &lt;r.hijmans@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-14 13:40:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='raster-package'> 
Overview of the functions in the raster package
</h2><span id='topic+raster-package'></span>

<h3>Description</h3>

<p>The raster package provides classes and functions to manipulate geographic (spatial) data in 'raster' format. Raster data divides space into cells (rectangles; pixels) of equal size (in units of the coordinate reference system). Such continuous spatial data are also referred to as 'grid' data, and be contrasted with discrete (object based) spatial data (points, lines, polygons).
</p>
<p>The package should be particularly useful when using very large datasets that can not be loaded into the computer's memory. Functions will work correctly, because they process large files in chunks, i.e., they read, compute, and write blocks of data, without loading all values into memory at once.
</p>
<p>Below is a list of some of the most important functions grouped by theme. See the vignette for more information and some examples (you can open it by running this command: <code>vignette('Raster')</code>)
</p>


<h3>Details</h3>

<p>The package implements classes for Raster data (see <a href="#topic+Raster-class">Raster-class</a>) and supports
</p>

<ul>
<li><p> Creation of Raster* objects from scratch or from file
</p>
</li>
<li><p> Handling extremely large raster files
</p>
</li>
<li><p> Raster algebra and overlay functions
</p>
</li>
<li><p> Distance, neighborhood (focal) and patch functions
</p>
</li>
<li><p> Polygon, line and point to raster conversion
</p>
</li>
<li><p> Model predictions
</p>
</li>
<li><p> Summarizing raster values
</p>
</li>
<li><p> Easy access to raster cell-values
</p>
</li>
<li><p> Plotting (making maps)
</p>
</li>
<li><p> Manipulation of raster extent, resolution and origin
</p>
</li>
<li><p> Computation of row, column and cell numbers to coordinates and vice versa
</p>
</li>
<li><p> Reading and writing various raster file types
</p>
</li></ul>

<p>. 
</p>


<h3>I. Creating Raster* objects</h3>

<p>RasterLayer, RasterStack, and RasterBrick objects are, as a group, referred to as Raster* objects. Raster* objects can be created, from scratch, files, or from objects of other classes, with the following functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+raster">raster</a></code></td><td style="text-align: left;"> To create a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+stack">stack</a></code> </td><td style="text-align: left;"> To create a RasterStack (multiple layers)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+brick">brick</a></code> </td><td style="text-align: left;"> To create a RasterBrick (multiple layers)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+subset">subset</a></code> </td><td style="text-align: left;"> Select layers of a RasterStack/Brick</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+addLayer">addLayer</a></code> </td><td style="text-align: left;"> Add a layer to a Raster* object</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+dropLayer">dropLayer</a></code> </td><td style="text-align: left;"> Remove a layer from a RasterStack or RasterBrick </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+unstack">unstack</a></code> </td><td style="text-align: left;"> Create a list of RasterLayer objects from a RasterStack </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> --------------------------------------------------------------------------------------------------- </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>



<h3>II. Changing the spatial extent and/or resolution of Raster* objects</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+merge">merge</a></code> </td><td style="text-align: left;"> Combine Raster* objects with different extents (but same origin and resolution) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mosaic">mosaic</a></code> </td><td style="text-align: left;"> Combine RasterLayers with different extents and a function for overlap areas </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crop">crop</a></code> </td><td style="text-align: left;"> Select a geographic subset of a Raster* object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extend">extend</a></code> </td><td style="text-align: left;"> Enlarge a Raster* object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+trim">trim</a></code> </td><td style="text-align: left;"> Trim a Raster* object by removing exterior rows and/or columns that only have NAs</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+aggregate">aggregate</a></code> </td><td style="text-align: left;"> Combine cells of a Raster* object to create larger cells </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+disaggregate">disaggregate</a></code> </td><td style="text-align: left;"> Subdivide cells </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+resample">resample</a></code> </td><td style="text-align: left;"> Warp values to a Raster* object with a different origin or resolution </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+projectRaster">projectRaster</a></code> </td><td style="text-align: left;"> project values to a raster with a different coordinate reference system </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+shift">shift</a></code> </td><td style="text-align: left;"> Move the location of Raster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+flip">flip</a></code> </td><td style="text-align: left;">  Flip values horizontally or vertically </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rotate">rotate</a></code> </td><td style="text-align: left;"> Rotate values around the date-line (for lon/lat data) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+t">t</a></code> </td><td style="text-align: left;"> Transpose a Raster* object</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>III. Raster algebra</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Arith-methods">Arith-methods</a></code> </td><td style="text-align: left;"> Arith functions (<code>+, -, *, ^, %%, %/%, /</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+Math-methods">Math-methods</a></code> </td><td style="text-align: left;"> Math functions like <code>abs, sqrt, trunc, log, log10, exp, sin, round</code> </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+Logic-methods">Logic-methods</a></code> </td><td style="text-align: left;"> Logic functions (<code>!, &amp;, |</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Summary-methods">Summary-methods</a></code> </td><td style="text-align: left;"> Summary functions (<code>mean, max, min, range, prod, sum, any, all</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Compare-methods">Compare-methods</a></code> </td><td style="text-align: left;"> Compare functions (<code>==, !=, &gt;, &lt;, &lt;=, &gt;=</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>IV. Cell based computation</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+calc">calc</a></code> </td><td style="text-align: left;"> Computations on a single Raster* object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+overlay">overlay</a></code> </td><td style="text-align: left;"> Computations on multiple RasterLayer objects </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cover">cover</a></code> </td><td style="text-align: left;"> First layer covers second layer except where the first layer is <code>NA</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mask">mask</a></code> </td><td style="text-align: left;"> Use values from first Raster except where cells of the mask Raster are <code>NA</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cut">cut</a></code> </td><td style="text-align: left;"> Reclassify values using ranges </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+subs">subs</a></code> </td><td style="text-align: left;"> Reclassify values using an 'is-becomes' matrix </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+reclassify">reclassify</a></code> </td><td style="text-align: left;"> Reclassify using a 'from-to-becomes' matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+init">init</a></code> </td><td style="text-align: left;"> Initialize cells with new values </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+stackApply">stackApply</a></code> </td><td style="text-align: left;"> Computations on groups of layers in Raster* object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+stackSelect">stackSelect</a></code> </td><td style="text-align: left;"> Select cell values from different layers using an index RasterLayer</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>V. Spatial contextual computation</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+distance">distance</a></code> </td><td style="text-align: left;"> Shortest distance to a cell that is not <code>NA</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+gridDistance">gridDistance</a></code> </td><td style="text-align: left;"> Distance when traversing grid cells that are not <code>NA</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+distanceFromPoints">distanceFromPoints</a></code> </td><td style="text-align: left;"> Shortest distance to any point in a set of points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+direction">direction</a></code> </td><td style="text-align: left;"> Direction (azimuth) to or from cells that are not <code>NA</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+focal">focal</a></code> </td><td style="text-align: left;"> Focal (neighborhood; moving window) functions </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+localFun">localFun</a></code> </td><td style="text-align: left;"> Local association (using neighborhoods) functions </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+boundaries">boundaries</a></code> </td><td style="text-align: left;"> Detection of boundaries (edges)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+clump">clump</a></code> </td><td style="text-align: left;"> Find clumps (patches) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+adjacent">adjacent</a></code> </td><td style="text-align: left;"> Identify cells that are adjacent to a set of cells on a raster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+area">area</a></code> </td><td style="text-align: left;"> Compute area of cells (for longitude/latitude data) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+terrain">terrain</a></code> </td><td style="text-align: left;"> Compute slope, aspect and other characteristics from elevation data </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+Moran">Moran</a></code> </td><td style="text-align: left;"> Compute global or local Moran or Geary indices of spatial autocorrelation  </td>
</tr>
<tr>
 <td style="text-align: left;">	
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>VI. Model predictions</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+predict">predict</a></code> </td><td style="text-align: left;"> Predict a non-spatial model to a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+interpolate">interpolate</a></code> </td><td style="text-align: left;"> Predict a spatial model to a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>VII. Data type conversion</h3>

<p>You can coerce Raster* objects to Spatial* objects using <code>as</code>, as in <code>as(object, 'SpatialGridDataFrame')</code>  
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+raster">raster</a></code> </td><td style="text-align: left;"> RasterLayer from SpatialGrid*, image, or matrix objects</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterize">rasterize</a></code> </td><td style="text-align: left;"> Rasterizing points, lines or polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterToPoints">rasterToPoints</a></code> </td><td style="text-align: left;"> Create points from a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterToPolygons">rasterToPolygons</a></code> </td><td style="text-align: left;"> Create polygons from a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterToContour">rasterToContour</a></code> </td><td style="text-align: left;"> Contour lines from a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterFromXYZ">rasterFromXYZ</a></code> </td><td style="text-align: left;"> RasterLayer from regularly spaced points</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterFromCells">rasterFromCells</a></code> </td><td style="text-align: left;"> RasterLayer from a Raster object and cell numbers</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>VIII. Summarizing</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cellStats">cellStats</a></code> </td><td style="text-align: left;"> Summarize a Raster cell values with a function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="base.html#topic+summary">summary</a></code> </td><td style="text-align: left;"> Summary of the values of a Raster* object (quartiles and mean) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+freq">freq</a></code> </td><td style="text-align: left;"> Frequency table of Raster cell values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crosstab">crosstab</a></code> </td><td style="text-align: left;"> Cross-tabulate two Raster* objects</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+unique">unique</a></code> </td><td style="text-align: left;"> Get the unique values in a Raster* object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+zonal">zonal</a></code> </td><td style="text-align: left;"> Summarize a Raster* object by zones in a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>IX. Accessing values of Raster* object cells</h3>

<p>Apart from the function listed below, you can also use indexing with <code>[</code> for cell numbers, and <code>[[</code> for row / column number combinations <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+getValues">getValues</a></code> </td><td style="text-align: left;"> Get all cell values (fails with very large rasters), or a row of values (safer) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+getValuesBlock">getValuesBlock</a></code> </td><td style="text-align: left;"> Get values for a block (a rectangular area) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+getValuesFocal">getValuesFocal</a></code> </td><td style="text-align: left;"> Get focal values for one or more rows</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.matrix">as.matrix</a></code> </td><td style="text-align: left;"> Get cell values as a matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.array">as.array</a></code> </td><td style="text-align: left;"> Get cell values as an array </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extract">extract</a></code> </td><td style="text-align: left;"> Extract cell values from a Raster* object (e.g., by cell, coordinates, polygon)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sampleRandom">sampleRandom</a></code> </td><td style="text-align: left;"> Random sample </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sampleRegular">sampleRegular</a></code> </td><td style="text-align: left;"> Regular sample </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+minValue">minValue</a></code> </td><td style="text-align: left;"> Get the minimum value of the cells of a Raster* object (not always known) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+maxValue">maxValue</a></code> </td><td style="text-align: left;"> Get the maximum value of the cells of a Raster* object (not always known) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+setMinMax">setMinMax</a></code> </td><td style="text-align: left;"> Compute the minimum and maximum value of a Raster* object if these are not known </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>X. Plotting</h3>

<p>See the rasterVis package for additional plotting methods for Raster* objects using methods from 'lattice' and other packages.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>Maps</b> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot">plot</a></code> </td><td style="text-align: left;"> Plot a Raster* object. The main method to create a map </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plotRGB">plotRGB</a></code> </td><td style="text-align: left;"> Combine three layers (red, green, blue channels) into a single 'real color' image </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+spplot">spplot</a></code> </td><td style="text-align: left;"> Plot a Raster* with the spplot function (sp package) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+image">image</a></code> </td><td style="text-align: left;"> Plot a Raster* with the image function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+persp">persp</a></code> </td><td style="text-align: left;"> Perspective plot of a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+contour">contour</a></code> </td><td style="text-align: left;"> Contour plot of a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+filledContour">filledContour</a></code> </td><td style="text-align: left;"> Filled contour plot of a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+text">text</a></code> </td><td style="text-align: left;"> Plot the values of a RasterLayer on top of a map </td>
</tr>
<tr>
 <td style="text-align: left;">
    .</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>Interacting with a map</b> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+zoom">zoom</a></code> </td><td style="text-align: left;"> Zoom in to a part of a map </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+click">click</a></code> </td><td style="text-align: left;"> Query values of Raster* or Spatial* objects by clicking on a map </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+select">select</a></code> </td><td style="text-align: left;"> Select a geometric subset of a Raster* or Spatial* object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+drawPoly">drawPoly</a></code> </td><td style="text-align: left;"> Create a SpatialPolygons object by drawing it </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+drawLine">drawLine</a></code> </td><td style="text-align: left;"> Create a SpatialLines object by drawing it </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+drawExtent">drawExtent</a></code> </td><td style="text-align: left;"> Create an Extent object by drawing it </td>
</tr>
<tr>
 <td style="text-align: left;">	
    .</td>
</tr>
<tr>
 <td style="text-align: left;">
	<b>Other plots</b> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot">plot</a></code> </td><td style="text-align: left;"> x-y scatter plot of the values of two RasterLayer objects</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+hist">hist</a></code> </td><td style="text-align: left;"> Histogram of Raster* object values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+barplot">barplot</a></code> </td><td style="text-align: left;"> barplot of a RasterLayer </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+density">density</a></code> </td><td style="text-align: left;"> Density plot of Raster* object values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pairs">pairs</a></code> </td><td style="text-align: left;"> Pairs plot for layers in a RasterStack or RasterBrick </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+boxplot">boxplot</a></code> </td><td style="text-align: left;"> Box plot of the values of one or multiple layers</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>XI. Getting and setting Raster* dimensions </h3>

<p>Basic parameters of existing Raster* objects can be obtained, and in most cases changed. If there are values associated with a RasterLayer object (either in memory or via a link to a file) these are lost when you change the number of columns or rows or the resolution. This is not the case when the extent is changed (as the number of columns and rows will not be affected). Similarly, with <b>projection</b> you can set the projection, but this does not transform the data (see <a href="#topic+projectRaster">projectRaster</a> for that).   
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ncol">ncol</a></code></td><td style="text-align: left;"> The number of columns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nrow">nrow</a></code> </td><td style="text-align: left;"> The number of rows </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ncell">ncell</a></code> </td><td style="text-align: left;"> The number of cells (can not be set directly, only via ncol or nrow) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+res">res</a></code> </td><td style="text-align: left;"> The resolution (x and y) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nlayers">nlayers</a></code> </td><td style="text-align: left;"> How many layers does the object have? </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+names">names</a></code> </td><td style="text-align: left;"> Get or set the layer names </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+xres">xres</a></code> </td><td style="text-align: left;"> The x resolution (can be set with res) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+yres">yres</a></code> </td><td style="text-align: left;"> The y resolution (can be set with res)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xmin">xmin</a></code> </td><td style="text-align: left;"> The minimum x coordinate (or longitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xmax">xmax</a></code> </td><td style="text-align: left;"> The maximum x coordinate (or longitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ymin">ymin</a></code> </td><td style="text-align: left;"> The minimum y coordinate (or latitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ymax">ymax</a></code> </td><td style="text-align: left;"> The maximum y coordinate (or latitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+extent">extent</a></code> </td><td style="text-align: left;"> The extent (minimum and maximum x and y coordinates) </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+origin">origin</a></code> </td><td style="text-align: left;"> The origin of a Raster* object</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crs">crs</a></code> </td><td style="text-align: left;"> The coordinate reference system (map projection) </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+isLonLat">isLonLat</a></code> </td><td style="text-align: left;"> Test if an object has a longitude/latitude coordinate reference system </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+filename">filename</a></code> </td><td style="text-align: left;"> Filename to which a RasterLayer or RasterBrick is linked </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+bandnr">bandnr</a></code> </td><td style="text-align: left;"> layer (=band) of a multi-band file that this RasterLayer is linked to </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+nbands">nbands</a></code> </td><td style="text-align: left;"> How many bands (layers) does the file associated with a RasterLayer object have? </td>
</tr>
<tr>
 <td style="text-align: left;">	
    <code><a href="#topic+compareRaster">compareRaster</a></code> </td><td style="text-align: left;"> Compare the geometry of Raster* objects </td>
</tr>
<tr>
 <td style="text-align: left;">		
    <code><a href="#topic+NAvalue">NAvalue</a></code> </td><td style="text-align: left;"> Get or set the <code>NA</code> value (for reading from a file) </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
	
</td>
</tr>

</table>



<h3>XII. Computing row, column, cell numbers and coordinates</h3>

<p>Cell numbers start at 1 in the upper-left corner. They increase within rows, from left to right, and then row by row from top to bottom. Likewise, row numbers start at 1 at the top of the raster, and column numbers start at 1 at the left side of the raster. 
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xFromCol">xFromCol</a></code> </td><td style="text-align: left;"> x-coordinates from column numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+yFromRow">yFromRow</a></code> </td><td style="text-align: left;"> y-coordinates from row numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xFromCell">xFromCell</a></code> </td><td style="text-align: left;"> x-coordinates from row numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+yFromCell">yFromCell</a></code> </td><td style="text-align: left;"> y-coordinates from cell numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xyFromCell">xyFromCell</a></code> </td><td style="text-align: left;"> x and y coordinates from cell numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+colFromX">colFromX</a></code> </td><td style="text-align: left;"> Column numbers from x-coordinates (or longitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rowFromY">rowFromY</a></code> </td><td style="text-align: left;"> Row numbers from y-coordinates (or latitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rowColFromCell">rowColFromCell</a></code> </td><td style="text-align: left;"> Row and column numbers from cell numbers</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cellFromXY">cellFromXY</a></code> </td><td style="text-align: left;"> Cell numbers from x and y coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cellFromRowCol">cellFromRowCol</a></code> </td><td style="text-align: left;"> Cell numbers from row and column numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cellsFromExtent">cellsFromExtent</a></code> </td><td style="text-align: left;"> Cell numbers from extent object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+coordinates">coordinates</a></code> </td><td style="text-align: left;"> x and y coordinates for all cells </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+validCell">validCell</a></code> </td><td style="text-align: left;"> Is this a valid cell number? </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+validCol">validCol</a></code> </td><td style="text-align: left;"> Is this a valid column number? </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+validRow">validRow</a></code> </td><td style="text-align: left;"> Is this a valid row number? </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>XIII. Writing files</h3>


<table>
<tr>
 <td style="text-align: left;">
   <b>Basic</b></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+setValues">setValues</a></code> </td><td style="text-align: left;"> Put new values in a Raster* object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+writeRaster">writeRaster</a></code> </td><td style="text-align: left;"> Write all values of Raster* object to disk </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+KML">KML</a></code> </td><td style="text-align: left;"> Save raster as KML file </td>
</tr>
<tr>
 <td style="text-align: left;">	
   .</td>
</tr>
<tr>
 <td style="text-align: left;">
   <b>Advanced</b></td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+blockSize">blockSize</a></code> </td><td style="text-align: left;"> Get suggested block size for reading and writing </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+writeStart">writeStart</a></code> </td><td style="text-align: left;"> Open a file for writing </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+writeValues">writeValues</a></code> </td><td style="text-align: left;"> Write some values  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+writeStop">writeStop</a></code> </td><td style="text-align: left;"> Close the file after writing </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+update">update</a></code> </td><td style="text-align: left;"> Change the values of an existing file </td>
</tr>
<tr>
 <td style="text-align: left;">	
    --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>XIV. Manipulation of SpatialPolygons* and other vector type Spatial* objects</h3>

<p>Some of these functions are in the <code>sp</code> package. The name in <b>bold</b> is the equivalent command in ArcGIS. 
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+bind">bind</a></code> </td><td style="text-align: left;"> <b>append</b> combine Spatial* objects of the same (vector) type </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+erase">erase</a></code> or "-" </td><td style="text-align: left;"> <b>erase</b> parts of a SpatialPolygons* object</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+intersect">intersect</a></code> or "*"  </td><td style="text-align: left;"> <b>intersect</b> SpatialPolygons* objects</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+union">union</a></code> or "+" </td><td style="text-align: left;"> <b>union</b> SpatialPolygons* objects</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+cover">cover</a></code> </td><td style="text-align: left;"> <b>update</b> and <b>identity</b> for a SpatialPolygons and another one</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+symdif">symdif</a></code> </td><td style="text-align: left;"><b>symmetrical difference</b> of two SpatialPolygons* objects </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <code><a href="#topic+aggregate">aggregate</a></code> </td><td style="text-align: left;"> <b>dissolve</b> smaller polygons into larger ones </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="sp.html#topic+disaggregate">disaggregate</a></code> </td><td style="text-align: left;"> <b>explode</b>: turn polygon parts into separate polygons (in the <code>sp</code> package) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+crop">crop</a></code> </td><td style="text-align: left;"> <b>clip</b> a Spatial* object using a rectangle (Extent object)</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+select">select</a></code> </td><td style="text-align: left;"> <b>select</b> - interactively select spatial features</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+click">click</a></code> </td><td style="text-align: left;"> <b>identify</b> attributes by clicking on a map</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="sp.html#topic+merge">merge</a></code> </td><td style="text-align: left;"> <b>Join table</b> (in the <code>sp</code> package) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="sp.html#topic+over">over</a></code> </td><td style="text-align: left;"> spatial queries between Spatial* objects </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+extract">extract</a></code> </td><td style="text-align: left;"> spatial queries between Spatial* and Raster* objects </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+as.data.frame">as.data.frame</a></code> </td><td style="text-align: left;"> coerce coordinates of <code>SpatialLines</code> or <code>SpatialPolygons</code> into a data.frame</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>



<h3>XV. Extent objects</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extent">extent</a></code> </td><td style="text-align: left;"> Create an extent object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+intersect">intersect</a></code> </td><td style="text-align: left;"> Intersect two extent objects  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+union">union</a></code> </td><td style="text-align: left;"> Combine two extent objects </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="base.html#topic+round">round</a></code> </td><td style="text-align: left;"> round/floor/ceiling of the coordinates of an Extent object </td>
</tr>
<tr>
 <td style="text-align: left;">			
    <code><a href="#topic+alignExtent">alignExtent</a></code> </td><td style="text-align: left;"> Align an extent with a Raster* object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+drawExtent">drawExtent</a></code> </td><td style="text-align: left;"> Create an Extent object by drawing it on top of a map (see plot) </td>
</tr>
<tr>
 <td style="text-align: left;">		
    --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>XVI. Miscellaneous</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterOptions">rasterOptions</a></code> </td><td style="text-align: left;"> Show, set, save or get session options </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+getData">getData</a></code> </td><td style="text-align: left;"> Download and geographic data</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pointDistance">pointDistance</a></code> </td><td style="text-align: left;"> Distance between points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+readIniFile">readIniFile</a></code> </td><td style="text-align: left;"> Read a (windows) 'ini' file </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+hdr">hdr</a></code> </td><td style="text-align: left;"> Write header file for a number of raster formats </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+trim">trim</a></code> </td><td style="text-align: left;"> Remove leading and trailing blanks from a character string </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extension">extension</a></code> </td><td style="text-align: left;"> Get or set the extension of a filename </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cv">cv</a></code> </td><td style="text-align: left;"> Coefficient of variation  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+modal">modal</a></code> </td><td style="text-align: left;"> Modal value  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sampleInt">sampleInt</a></code> </td><td style="text-align: left;"> Random sample of (possibly very large) range of integer values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+showTmpFiles">showTmpFiles</a></code> </td><td style="text-align: left;"> Show temporary files </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+removeTmpFiles">removeTmpFiles</a></code> </td><td style="text-align: left;"> Remove temporary files </td>
</tr>
<tr>
 <td style="text-align: left;">
    --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>XVII. For programmers</h3>


<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+canProcessInMemory">canProcessInMemory</a></code> </td><td style="text-align: left;"> Test whether a file can be created in memory </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+pbCreate">pbCreate</a></code> </td><td style="text-align: left;"> Initialize a progress bar  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+pbStep">pbStep</a></code> </td><td style="text-align: left;"> Take a progress bar step </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+pbClose">pbClose</a></code> </td><td style="text-align: left;"> Close a progress bar </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+readStart">readStart</a></code> </td><td style="text-align: left;"> Open file connections for efficient multi-chunk reading </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+readStop">readStop</a></code> </td><td style="text-align: left;"> Close file connections </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+rasterTmpFile">rasterTmpFile</a></code>  </td><td style="text-align: left;"> Get a name for a temporary file </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+inMemory">inMemory</a></code> </td><td style="text-align: left;"> Are the cell values in memory? </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+fromDisk">fromDisk</a></code> </td><td style="text-align: left;"> Are the cell values read from a file? </td>
</tr>
<tr>
 <td style="text-align: left;">	
    --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Acknowledgments</h3>

<p>Extensive contributions were made by Jacob van Etten, Jonathan Greenberg, Matteo Mattiuzzi, and Michael Sumner. Significant help was also provided by Phil Heilman, Agustin Lobo, Oscar Perpinan Lamigueiro, Stefan Schlaffer, Jon Olav Skoien, Steven Mosher, and Kevin Ummel. Contributions were also made by Jochen Albrecht, Neil Best, Andrew Bevan, Roger Bivand, Isabelle Boulangeat, Lyndon Estes, Josh Gray, Tim Haering, Herry Herry, Paul Hiemstra, Ned Hornig, Mayeul Kauffmann, Bart Kranstauber, Rainer Krug, Alice Laborte, John Lewis, Lennon Li, Justin McGrath, Babak Naimi, Carsten Neumann, Joshua Perlman, Richard Plant, Edzer Pebesma, Etienne Racine, David Ramsey, Shaun Walbridge, Julian Zeidler and many others.
</p>


<h3>Author(s)</h3>

<p>Except where indicated otherwise, the functions in this package were written by Robert J. Hijmans</p>

<hr>
<h2 id='addLayer'>Add or drop a layer</h2><span id='topic+addLayer'></span><span id='topic+addLayer+2CRaster-method'></span><span id='topic+dropLayer'></span><span id='topic+dropLayer+2CRasterStack-method'></span><span id='topic+dropLayer+2CRasterBrick-method'></span>

<h3>Description</h3>

<p>Add a layer to a Raster* object or drop a layer from a RasterStack or RasterBrick. The object returned is always a RasterStack (unless nothing to add or drop was provided, in which case the original object is returned).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLayer(x, ...) 
dropLayer(x, i, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLayer_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="addLayer_+3A_i">i</code></td>
<td>
<p>integer. Indices of the layers to be dropped</p>
</td></tr>
<tr><td><code id="addLayer_+3A_...">...</code></td>
<td>
<p>Additional arguments. The layers to add for addLayer. None implemented for dropLayer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterStack
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+subset">subset</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("external/test.grd", package="raster")
s &lt;- stack(file, file, file)
r &lt;- raster(file)
s &lt;- addLayer(s, r/2, r*2)
s
s &lt;- dropLayer(s, c(3, 5))
nlayers(s)
</code></pre>

<hr>
<h2 id='adjacent'>Adjacent cells</h2><span id='topic+adjacent'></span><span id='topic+adjacent+2CBasicRaster-method'></span>

<h3>Description</h3>

<p>Identify cells that are adjacent to a set of cells on a raster. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BasicRaster'
adjacent(x, cells, directions=4, pairs=TRUE, target=NULL, sorted=FALSE, 
         include=FALSE, id=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacent_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="adjacent_+3A_cells">cells</code></td>
<td>
<p>vector of cell numbers for which adjacent cells should be found. Cell numbers start with 1 in the upper-left corner and increase from left to right and from top to bottom</p>
</td></tr>
<tr><td><code id="adjacent_+3A_directions">directions</code></td>
<td>
<p>the number of directions in which cells should be connected: 4 (rook's case), 8 (queen's case), 16 (knight and one-cell queen moves), or 'bishop' to connect cells with one-cell diagonal moves. Or a neighborhood matrix (see Details)</p>
</td></tr>
<tr><td><code id="adjacent_+3A_pairs">pairs</code></td>
<td>
<p>logical. If <code>TRUE</code>, a matrix of pairs of adjacent cells is returned. If <code>FALSE</code>, a vector of cells adjacent to <code>cells</code> is returned</p>
</td></tr>
<tr><td><code id="adjacent_+3A_target">target</code></td>
<td>
<p>optional vector of target cell numbers that should be considered. All other adjacent cells are ignored</p>
</td></tr>
<tr><td><code id="adjacent_+3A_sorted">sorted</code></td>
<td>
<p>logical. Should the results be sorted? </p>
</td></tr>
<tr><td><code id="adjacent_+3A_include">include</code></td>
<td>
<p>logical. Should the focal cells be included in the result? </p>
</td></tr>
<tr><td><code id="adjacent_+3A_id">id</code></td>
<td>
<p>logical. Should the id of the cells be included in the result? (numbered from 1 to length(cells) </p>
</td></tr>
<tr><td><code id="adjacent_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A neighborhood matrix identifies the cells around each cell that are considered adjacent. The matrix should have one, and only one, cell with value 0 (the focal cell); at least one cell with value 1 (the adjacent cell(s)); All other cells are not considered adjacent and ignored.
</p>


<h3>Value</h3>

<p>matrix or vector with adjacent cells. 
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Jacob van Etten</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrows=10, ncols=10)
adjacent(r, cells=c(1, 55), directions=8, pairs=TRUE) 

a &lt;- adjacent(r, cell = c(1,55,90), directions=4, sorted=TRUE) 
a

r[c(1,55,90)] &lt;- 1
r[a] &lt;- 2
plot(r)

# same result as above
rook &lt;- matrix(c(NA, 1, NA, 
                  1, 0,  1, 
                 NA, 1, NA), ncol=3, byrow=TRUE)

adjacent(r, cells = c(1,55,90), directions=rook, sorted=TRUE) 


# Count the number of times that a cell with a certain value
# occurs next to a cell with a certain value
set.seed(0)
r &lt;- raster(ncol=10, nrow=10)
values(r) &lt;- round(runif(ncell(r)) * 5)
a &lt;- adjacent(r, 1:ncell(r), 4, pairs=TRUE)
tb &lt;- table(r[a[,1]], r[a[,2]])
tb
# make a matrix out of the 'table' object
tb &lt;- unclass(tb)
plot(raster(tb, xmn=-0.5, xmx=5.5, ymn=-0.5, ymx=5.5))
</code></pre>

<hr>
<h2 id='aggregate'>Aggregate raster cells or SpatialPolygons/Lines</h2><span id='topic+aggregate'></span><span id='topic+aggregate+2CRaster-method'></span><span id='topic+aggregate+2CSpatialPolygons-method'></span><span id='topic+aggregate+2CSpatialLines-method'></span>

<h3>Description</h3>

<p>Raster* objects: 
</p>
<p>Aggregate a Raster* object to create a new RasterLayer or RasterBrick with a lower resolution (larger cells). 
Aggregation groups rectangular areas to create larger cells. The value for the resulting cells is computed with a user-specified function. 
</p>
<p>SpatialPolygon*:
</p>
<p>Aggregate a SpatialPolygon* object, optionally by combining polygons that have the same attributes for one or more variables. If the polygons touch or overlap, internal boundaries are optionally &quot;dissolved&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
aggregate(x, fact, fun=mean, expand=TRUE, na.rm=TRUE, filename='', ...)

## S4 method for signature 'SpatialPolygons'
aggregate(x, by, sums, dissolve=TRUE, vars=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_+3A_x">x</code></td>
<td>
<p>Raster* object or SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="aggregate_+3A_fact">fact</code></td>
<td>
<p>postive integer. Aggregation factor expressed as number of cells in each direction (horizontally and vertically). Or two integers (horizontal and vertical aggregation factor) or three integers (when also aggregating over layers). See Details</p>
</td></tr>  
<tr><td><code id="aggregate_+3A_fun">fun</code></td>
<td>
<p>function used to aggregate values </p>
</td></tr>  
<tr><td><code id="aggregate_+3A_expand">expand</code></td>
<td>
<p>logical. If <code>TRUE</code> the output Raster* object will be larger than the input Raster* object if a division of the number of columns or rows with <code>factor</code> is not an integer</p>
</td></tr>
<tr><td><code id="aggregate_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, NA cells are removed from calculations </p>
</td></tr>
<tr><td><code id="aggregate_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="aggregate_+3A_...">...</code></td>
<td>
<p>if <code>x</code> is a Raster* object, additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="aggregate_+3A_by">by</code></td>
<td>
<p>character or integer. The variables (column names or numbers) that should be used to aggregate (dissolve) the SpatialPolygons by only maintaining unique combinations of these variables. The default setting is to use no variables and aggregate all polygons. You can also supply a vector with a length of length(x)</p>
</td></tr>
<tr><td><code id="aggregate_+3A_sums">sums</code></td>
<td>
<p>list with function(s) and variable(s) to summarize. This should be a list of lists in which each element of the main lists has two items. The first item is function (e.g. mean), the second element is a vector of column names (or indices) that need to summarize with that function. Be careful with character and factor variables (you can use, e.g. 'first' <code>function(x)x[1]</code> or 'last' <code>function(x)x[length(x)]</code> or <code>modal</code> for these variables</p>
</td></tr>
<tr><td><code id="aggregate_+3A_vars">vars</code></td>
<td>
<p>deprecated. Same as <code>by</code></p>
</td></tr>  
<tr><td><code id="aggregate_+3A_dissolve">dissolve</code></td>
<td>
<p>logical. If <code>TRUE</code> borders between touching or overlapping polygons are removed</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Aggregation of a <code>x</code> will result in a Raster* object with fewer cells. The number of cells is the number of cells of <code>x</code> divided by <code>fact*fact</code> (when fact is a single number) or <code>prod(fact)</code> (when fact consists of 2 or 3 numbers). If necessary this number is adjusted according to the value of <code>expand</code>. For example, <code>fact=2</code> will result in a new Raster* object with <code>2*2=4</code> times fewer cells. If two numbers are supplied, e.g., <code>fact=c(2,3)</code>, the first will be used for aggregating in the horizontal direction, and the second for aggregating in the vertical direction, and the returned object will have <code>2*3=6</code> times fewer cells. Likewise, <code>fact=c(2,3,4)</code> aggregates cells in groups of 2 (rows) by 3 (columns) and 4 (layers).
</p>
<p>Aggregation starts at the upper-left end of a raster (you can use <code><a href="#topic+flip">flip</a></code> if you want to start elsewhere). If a division of the number of columns or rows with <code>factor</code> does not return an integer, the extent of the resulting Raster object will either be somewhat smaller or somewhat larger than the original RasterLayer. For example, if an input RasterLayer has 100 columns, and <code>fact=12</code>, the output Raster object will have either 8 columns (<code>expand=FALSE</code>) (using <code>8 x 12 = 96</code> of the original columns) or 9 columns (<code>expand=TRUE</code>). In both cases, the maximum x coordinate of the output RasterLayer would, of course, also be adjusted.
</p>
<p>The function <code>fun</code> should take multiple numbers, and return a single number. For example <code>mean</code>, <code>modal</code>, <code>min</code> or <code>max</code>. 
It should also accept a <code>na.rm</code> argument (or ignore it as one of the 'dots' arguments). 
</p>


<h3>Value</h3>

<p>RasterLayer or RasterBrick, or a SpatialPolygons* object
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Jacob van Etten</p>


<h3>See Also</h3>

 <p><code><a href="#topic+disaggregate">disaggregate</a></code>, <code><a href="#topic+resample">resample</a></code>. For SpatialPolygons* <code><a href="sp.html#topic+disaggregate">disaggregate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
# a new aggregated raster, no values
ra &lt;- aggregate(r, fact=10)
r &lt;- setValues(r, runif(ncell(r)))

# a new aggregated raster, max of the values
ra &lt;- aggregate(r, fact=10, fun=max)

# multiple layers
s &lt;- stack(r, r*2)
x &lt;- aggregate(s,2)

#SpatialPolygons
p &lt;- shapefile(system.file("external/lux.shp", package="raster"))
p
pa0 &lt;- aggregate(p)
pa0
pa1 &lt;- aggregate(p, by='NAME_1', sums=list(list(mean, 'ID_2')))
pa1

</code></pre>

<hr>
<h2 id='alignExtent'>Align an extent (object of class Extent)</h2><span id='topic+alignExtent'></span>

<h3>Description</h3>

<p>Align an Extent object with the (boundaries of the) cells of a Raster* object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignExtent(extent, object, snap='near')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignExtent_+3A_extent">extent</code></td>
<td>
<p>Extent object</p>
</td></tr>  
<tr><td><code id="alignExtent_+3A_object">object</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="alignExtent_+3A_snap">snap</code></td>
<td>
<p>Character. One of 'near', 'in', or 'out', to determine in which direction the extent should be aligned. To the nearest border, inwards or outwards</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Aligning an Extent object to another object assures that it gets the same origin and resolution. This should only be used to adjust objects because of imprecision in the data. alignExtent should not be used to force data to match that really does not match (use e.g. <code><a href="#topic+resample">resample</a></code> or (dis)aggregate for this).
</p>


<h3>Value</h3>

<p>Extent object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+extent">extent</a></code>, <code><a href="#topic+drawExtent">drawExtent</a></code>, <code><a href="#topic+Extent-class">Extent-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
e &lt;- extent(-10.1, 9.9, -20.1, 19.9)
ea &lt;- alignExtent(e, r)
e
extent(r)
ea

</code></pre>

<hr>
<h2 id='animate'>Animate layers of a Raster* object</h2><span id='topic+animate'></span><span id='topic+animate+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Animate (sequentially plot) the layers of a RasterStack or RasterBrick* object to create a movie
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterStackBrick'
animate(x, pause=0.25, main, zlim, maxpixels=50000, n=10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="animate_+3A_pause">pause</code></td>
<td>
<p>numeric. How long should be the pause be between layers?</p>
</td></tr>  
<tr><td><code id="animate_+3A_main">main</code></td>
<td>
<p>title for each layer. If not supplied the z-value is used if available. Otherwise the names are used.</p>
</td></tr>  
<tr><td><code id="animate_+3A_zlim">zlim</code></td>
<td>
<p>numeric vector of lenght 2. Range of values to plot</p>
</td></tr>
<tr><td><code id="animate_+3A_maxpixels">maxpixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to use for the plot. If <code>maxpixels &lt; ncell(x)</code>, <code>sampleRegular</code> is used before plotting</p>
</td></tr>
<tr><td><code id="animate_+3A_n">n</code></td>
<td>
<p>integer &gt; 0. Number of loops</p>
</td></tr>
<tr><td><code id="animate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot">plot</a></code>, <code><a href="#topic+spplot">spplot</a></code>, <code><a href="#topic+plotRGB">plotRGB</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brick(system.file("external/rlogo.grd", package="raster"))
animate(b, n=1)
</code></pre>

<hr>
<h2 id='approxNA'>Estimate values for cell values that are <code>NA</code> by interpolating between layers</h2><span id='topic+approxNA'></span><span id='topic+approxNA+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>approxNA uses the <code>stats</code> function <code><a href="stats.html#topic+approx">approx</a></code> to estimate values for cells that are <code>NA</code> by interpolation across layers. Layers are considered equidistant, unless an argument 'z' is used, or <code><a href="#topic+getZ">getZ</a></code> returns values, in which case these values are used to determine distance between layers.
</p>
<p>For estimation based on neighbouring cells see <code><a href="#topic+focal">focal</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterStackBrick'
approxNA(x, filename="", method="linear", yleft, yright,
            rule=1, f=0, ties=mean, z=NULL, NArule=1, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approxNA_+3A_x">x</code></td>
<td>
<p>RasterStack or RasterBrick object</p>
</td></tr>
<tr><td><code id="approxNA_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="approxNA_+3A_method">method</code></td>
<td>
<p>specifies the interpolation method to be used. Choices are &quot;linear&quot; or &quot;constant&quot; (step function; see the example in <code><a href="stats.html#topic+approx">approx</a></code></p>
</td></tr>
<tr><td><code id="approxNA_+3A_yleft">yleft</code></td>
<td>
<p>the value to be returned before a non-<code>NA</code> value is encountered. The default is defined by the value of rule given below</p>
</td></tr>
<tr><td><code id="approxNA_+3A_yright">yright</code></td>
<td>
<p>the value to be returned after the last non-<code>NA</code> value is encountered. The default is defined by the value of rule given below</p>
</td></tr>
<tr><td><code id="approxNA_+3A_rule">rule</code></td>
<td>
<p>an integer (of length 1 or 2) describing how interpolation is to take place at for the first and last cells (before or after any non-<code>NA</code> values are encountered). If rule is 1 then NAs are returned for such points and if it is 2, the value at the closest data extreme is used. Use, e.g., <code>rule = 2:1</code>, if the left and right side extrapolation should differ</p>
</td></tr>
<tr><td><code id="approxNA_+3A_f">f</code></td>
<td>
<p>for method = &quot;constant&quot; a number between 0 and 1 inclusive, indicating a compromise between left- and right-continuous step functions. If y0 and y1 are the values to the left and right of the point then the value is <code>y0*(1-f)+y1*f</code> so that <code>f = 0)</code> is right-continuous and <code>f = 1</code> is left-continuous</p>
</td></tr>
<tr><td><code id="approxNA_+3A_ties">ties</code></td>
<td>
<p>Handling of tied 'z' values. Either a function with a single vector argument returning a single number result or the string &quot;ordered&quot;</p>
</td></tr>
<tr><td><code id="approxNA_+3A_z">z</code></td>
<td>
<p>numeric vector to indicate the distance between layers (e.g., time, depth). The default is 1:nlayers(x) </p>
</td></tr>  
<tr><td><code id="approxNA_+3A_narule">NArule</code></td>
<td>
<p>single integer used to determine what to do when only a single layer with a non-<code>NA</code> value is encountered (and linear interpolation is not possible). The default value of 1 indicates that all layers will get this value for that cell; all other values do not change the cell values</p>
</td></tr>  
<tr><td><code id="approxNA_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterBrick
</p>


<h3>See Also</h3>

 <p><code> <a href="#topic+focal">focal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=5, nrows=5)
r1 &lt;- setValues(r, runif(ncell(r)))
r2 &lt;- setValues(r, runif(ncell(r)))
r3 &lt;- setValues(r, runif(ncell(r)))
r4 &lt;- setValues(r, runif(ncell(r)))
r5 &lt;- setValues(r, NA)
r6 &lt;- setValues(r, runif(ncell(r)))
r1[6:10] &lt;- NA
r2[5:15] &lt;- NA
r3[8:25] &lt;- NA
s &lt;- stack(r1,r2,r3,r4,r5,r6)
s[1:5] &lt;- NA
x1 &lt;- approxNA(s)
x2 &lt;- approxNA(s, rule=2)
x3 &lt;- approxNA(s, rule=2, z=c(1,2,3,5,14,15))

</code></pre>

<hr>
<h2 id='area'>Size of cells</h2><span id='topic+area'></span><span id='topic+area+2CRasterLayer-method'></span><span id='topic+area+2CRasterStackBrick-method'></span><span id='topic+area+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Raster objects: Compute the approximate surface area of cells in an unprojected (longitude/latitude) Raster object. It is an approximation because area is computed as the height (latitudinal span) of a cell (which is constant among all cells) times the width (longitudinal span) in the (latitudinal) middle of a cell. The width is smaller at the poleward side than at the equator-ward side of a cell. This variation is greatest near the poles and the values are thus not very precise for very high latitudes. 
</p>
<p>SpatialPolygons: Compute the area of the spatial features. Works for both planar and angular (lon/lat) coordinate reference systems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
area(x, filename="", na.rm=FALSE, weights=FALSE, ...)

## S4 method for signature 'RasterStackBrick'
area(x, filename="", na.rm=FALSE, weights=FALSE, ...)

## S4 method for signature 'SpatialPolygons'
area(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_+3A_x">x</code></td>
<td>
<p>Raster* or SpatialPolygons object</p>
</td></tr>
<tr><td><code id="area_+3A_filename">filename</code></td>
<td>
<p>character. Filename for the output Raster object (optional)</p>
</td></tr>
<tr><td><code id="area_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells that are <code>NA</code> are ignored</p>
</td></tr>
<tr><td><code id="area_+3A_weights">weights</code></td>
<td>
<p>logical. If <code>TRUE</code>, the area of each cells is divided by the total area of all cells that are not <code>NA</code></p>
</td></tr>
<tr><td><code id="area_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Details</h3>

<p>If <code>x</code> is a RasterStack/Brick, a RasterBrick will be returned if <code>na.rm=TRUE</code>. However, if <code>na.rm=FALSE</code>, a RasterLayer is returned, because the values would be the same for all layers.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a Raster* object: RasterLayer or RasterBrick. Cell values represent the size of the cell in km2, or the relative size if <code>weights=TRUE</code>. If the CRS is not longitude/latitude the values returned are the product of the cell resolution (typically in square meter).
</p>
<p>If <code>x</code> is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=18, ncol=36)
a &lt;- area(r)

p &lt;- shapefile(system.file("external/lux.shp", package="raster"))
p$area &lt;- round(area(p) / 10000000,1)
p$area
</code></pre>

<hr>
<h2 id='Arith-methods'>Arithmetic with Raster* objects</h2><span id='topic+Arith-methods'></span><span id='topic+Arith+2CExtent+2Cnumeric-method'></span><span id='topic+Arith+2CRaster+2CRaster-method'></span><span id='topic+Arith+2CRaster+2Cmissing-method'></span><span id='topic+Arith+2CRasterLayer+2Clogical-method'></span><span id='topic+Arith+2CRasterLayer+2Cnumeric-method'></span><span id='topic+Arith+2CRasterLayerSparse+2Cnumeric-method'></span><span id='topic+Arith+2CRasterStackBrick+2Clogical-method'></span><span id='topic+Arith+2CRasterStackBrick+2Cnumeric-method'></span><span id='topic+Arith+2Clogical+2CRasterLayer-method'></span><span id='topic+Arith+2Clogical+2CRasterStackBrick-method'></span><span id='topic+Arith+2Cnumeric+2CExtent-method'></span><span id='topic+Arith+2Cnumeric+2CRasterLayer-method'></span><span id='topic+Arith+2Cnumeric+2CRasterLayerSparse-method'></span><span id='topic+Arith+2Cnumeric+2CRasterStackBrick-method'></span><span id='topic++2B+2CSpatialPolygons+2CSpatialPolygons-method'></span><span id='topic++2B+2CSpatialLines+2CSpatialLines-method'></span><span id='topic++2B+2CSpatialPoints+2CSpatialPoints-method'></span><span id='topic+-+2CSpatialPolygons+2CSpatialPolygons-method'></span><span id='topic++2A+2CSpatialPolygons+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Standard arithmetic operators for computations with Raster* objects and numeric values. The following operators are available:
<code> +, -, *, /, ^, %%, %/% </code>
</p>
<p>The input Raster* objects should have the same extent, origin and resolution. If only the extent differs, the computation will continue for 
the intersection of the Raster objects. Operators are applied on a cell by cell basis.
For a RasterLayer, numeric values are recycled by row.  For a RasterStack or RasterBrick, recycling is done by layer. 
RasterLayer objects can be combined RasterStack/Brick objects, in which case the RasterLayer is 'recycled'.
When using multiple RasterStack or RasterBrick objects, the number of layers of these objects needs to be the same. 
</p>
<p>In addition to arithmetic with Raster* objects, the following operations are supported for SpatialPolygons* objects.
Given SpatialPolygon objects <code>x</code> and <code>y</code>:
</p>
<p><code>x+y</code> is the same as <code><a href="#topic+union">union</a>(x, y)</code>. For SpatialLines* and SpatialPoints* it is equivalent to <code><a href="#topic+bind">bind</a>(x, y)</code>
</p>
<p><code>x*y</code> is the same as <code><a href="#topic+intersect">intersect</a>(x, y)</code>
</p>
<p><code>x-y</code> is the same as <code><a href="#topic+erase">erase</a>(x, y)</code>
</p>


<h3>Details</h3>

<p>If the values of the output Raster* cannot be held in memory, they will be saved to a temporary file. 
You can use <code><a href="base.html#topic+options">options</a></code> to set the default file format, datatype and progress bar.
</p>


<h3>Value</h3>

<p>A Raster* object, and in some cases the side effect of a new file on disk.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Math-methods">Math-methods</a></code>, <code><a href="#topic+overlay">overlay</a></code>, <code><a href="#topic+calc">calc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- raster(ncols=10, nrows=10)
values(r1) &lt;- runif(ncell(r1))
r2 &lt;- setValues(r1, 1:ncell(r1) / ncell(r1) )
r3 &lt;- r1 + r2
r2 &lt;- r1 / 10
r3 &lt;- r1 * (r2 - 1 + r1^2 / r2)

# recycling by row
r4 &lt;- r1 * 0 + 1:ncol(r1)

# multi-layer object mutiplication, no recycling
b1 &lt;- brick(r1, r2, r3)
b2 &lt;- b1 * 10

# recycling by layer
b3 &lt;- b1 + c(1, 5, 10)

# addition of the cell-values of two RasterBrick objects
b3 &lt;- b2 + b1

# summing two RasterBricks and one RasterLayer. The RasterLayer is 'recycled'
b3 &lt;- b1 + b2 + r1
</code></pre>

<hr>
<h2 id='as.character'>Character representation of a Raster or Extent object</h2><span id='topic+as.character'></span><span id='topic+as.character+2CRaster-method'></span><span id='topic+as.character+2CExtent-method'></span>

<h3>Description</h3>

<p><code>as.character</code> returns a text (R code) representation of a Raster* or Extent object. The main purpose of this is to allow quick generation of objects to use in examples on, for example, stackoverflow.com. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
as.character(x, ...)
## S4 method for signature 'Extent'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character_+3A_x">x</code></td>
<td>
<p> Raster* or Extent object </p>
</td></tr>
<tr><td><code id="as.character_+3A_...">...</code></td>
<td>
<p> additional arguments, none implemented </p>
</td></tr> 
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=3, nrow=3)
values(r) &lt;- 1:ncell(r)
as.character(r)
s &lt;- stack(r, r)
as.character(s)
as.character(extent(s))

x &lt;- as.character(s)
eval(parse(text=x))

y &lt;- as.character(extent(s))
eval(parse(text=y))
</code></pre>

<hr>
<h2 id='as.data.frame'>Get a data.frame with raster cell values, or coerce SpatialPolygons, Lines, or Points to a data.frame</h2><span id='topic+as.data.frame'></span><span id='topic+as.data.frame+2CRaster-method'></span><span id='topic+as.data.frame+2CSpatialPolygons-method'></span><span id='topic+as.data.frame+2CSpatialLines-method'></span>

<h3>Description</h3>

<p><code>as.matrix</code> returns all values of a Raster* object as a matrix. For RasterLayers, rows and columns in the matrix represent rows and columns in the RasterLayer object. For other Raster* objects, the matrix returned by <code>as.matrix</code> has columns for each layer and rows for each cell.
</p>
<p><code>as.array</code> returns an array of matrices that are like those returned by <code>as.matrix</code> for a RasterLayer
</p>
<p>If there is insufficient memory to load all values, you can use <code><a href="#topic+getValues">getValues</a></code> or <code><a href="#topic+getValuesBlock">getValuesBlock</a></code> to read chunks of the file. You could also first use <code><a href="#topic+sampleRegular">sampleRegular</a></code>
</p>
<p>The methods for Spatial* objects allow for easy creation of a data.frame with the coordinates and attributes; the default method only returns the attributes data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
as.data.frame(x, row.names=NULL, optional=FALSE, xy=FALSE, 
              na.rm=FALSE, long=FALSE, ...)

## S4 method for signature 'SpatialPolygons'
as.data.frame(x, row.names=NULL, optional=FALSE,
              xy=FALSE, centroids=TRUE, sepNA=FALSE, ...)

## S4 method for signature 'SpatialLines'
as.data.frame(x, row.names=NULL, optional=FALSE, 
              xy=FALSE, sepNA=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row names for the data frame. Missing values are not allowed</p>
</td></tr> 
<tr><td><code id="as.data.frame_+3A_optional">optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see make.names) is optional</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code>, also return the spatial coordinates</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, remove rows with NA values. This can be particularly useful for very large datasets with many NA values</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_long">long</code></td>
<td>
<p>logical. If <code>TRUE</code>, values are <code><a href="stats.html#topic+reshape">reshape</a>d</code> from a wide to a long format</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_centroids">centroids</code></td>
<td>
<p>logical. If <code>TRUE</code> return the centroids instead of all spatial coordinates (only relevant if <code>xy=TRUE</code>)</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_sepna">sepNA</code></td>
<td>
<p>logical. If <code>TRUE</code> the parts of the spatial objects are separated by lines that are <code>NA</code> (only if <code>xy=TRUE</code> and, for polygons, if <code>centroids=FALSE</code></p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p>Additional arguments (none)</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=3, nrow=3)
values(r) &lt;- sqrt(1:ncell(r))
r[3:5] &lt;- NA
as.data.frame(r)
s &lt;- stack(r, r*2)
as.data.frame(s)
as.data.frame(s, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='as.list'>Create a list of RasterLayer objects</h2><span id='topic+as.list+2CRaster-method'></span>

<h3>Description</h3>

<p>Create a list of RasterLayer objects from Raster* objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list_+3A_x">x</code></td>
<td>
<p> Raster* object </p>
</td></tr>
<tr><td><code id="as.list_+3A_...">...</code></td>
<td>
<p>additional Raster* objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=3, nrow=3)
values(r) &lt;- 1:ncell(r)
as.list(r)

s &lt;- stack(r,r*2,r*3)
as.list(s, r)
</code></pre>

<hr>
<h2 id='as.logical'> Change cell values to logical or integer values</h2><span id='topic+as.logical+2CRaster-method'></span><span id='topic+as.integer+2CRaster-method'></span>

<h3>Description</h3>

<p>Change values of a Raster* object to logical or integer values. With <code>as.logical</code>, zero becomes <code>FALSE</code>, all other values become <code>TRUE</code>. With <code>as.integer</code> values are truncated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
as.logical(x, filename='', ...)

## S4 method for signature 'Raster'
as.integer(x, filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.logical_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="as.logical_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="as.logical_+3A_...">...</code></td>
<td>
<p>additional optional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+logical">logical</a></code>, <code><a href="base.html#topic+integer">integer</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=10, ncol=10)
set.seed(0)
values(r) &lt;- runif(ncell(r)) * 10
r
r &lt;- as.integer(r)
r
as.logical(r)
</code></pre>

<hr>
<h2 id='as.matrix'>Get a vector, matrix, or array with raster cell values</h2><span id='topic+as.vector'></span><span id='topic+as.matrix'></span><span id='topic+as.array'></span><span id='topic+as.array+2CRasterStackBrick-method'></span><span id='topic+as.array+2CRasterLayer-method'></span><span id='topic+as.matrix+2CRasterStackBrick-method'></span><span id='topic+as.matrix+2CRasterLayer-method'></span><span id='topic+as.matrix+2CExtent-method'></span><span id='topic+as.vector+2CExtent-method'></span><span id='topic+as.vector+2CRaster-method'></span>

<h3>Description</h3>

<p><code>as.vector</code> returns a vector of cell values. For a RasterLayer it is equivalent to getValues(x). 
</p>
<p><code>as.matrix</code> returns all values of a Raster* object as a matrix. For RasterLayers, rows and columns in the matrix represent rows and columns in the RasterLayer object. For other Raster* objects, the matrix returned by <code>as.matrix</code> has columns for each layer and rows for each cell. 
</p>
<p><code>as.array</code> returns an array of matrices that are like those returned by <code>as.matrix</code> for a RasterLayer
</p>
<p>If there is insufficient memory to load all values, you can use <code><a href="#topic+getValues">getValues</a></code> or <code><a href="#topic+getValuesBlock">getValuesBlock</a></code> to read chunks of the file.
</p>
<p><code>as.matrix</code> and <code>as.vector</code> can also be used to obtain the coordinates from an Extent object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.matrix(x, ...)
as.array(x, ...)

## S4 method for signature 'Extent'
as.vector(x, mode='any')

## S4 method for signature 'Raster'
as.vector(x, mode='any')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix_+3A_x">x</code></td>
<td>
<p> Raster* or (for <code>as.matrix</code> and <code>as.vector</code>) Extent object </p>
</td></tr>
<tr><td><code id="as.matrix_+3A_mode">mode</code></td>
<td>
<p>Character string giving an atomic mode (such as &quot;numeric&quot; or &quot;character&quot;) or &quot;list&quot;, or &quot;any&quot;. Note: this argument is currently ignored!</p>
</td></tr>
<tr><td><code id="as.matrix_+3A_...">...</code></td>
<td>
<p> additional arguments: 
</p>
<p><code>maxpixels</code> Integer. To regularly subsample very large objects 
</p>
<p><code>transpose</code> Logical. Transpose the data? (for as.array only)
</p>
</td></tr></table>


<h3>Value</h3>

<p>matrix, array, or vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=3, nrow=3)
values(r) &lt;- 1:ncell(r)
as.matrix(r)
s &lt;- stack(r,r)
as.array(s)
as.vector(extent(s))
</code></pre>

<hr>
<h2 id='as.raster'>Coerce to a 'raster' object</h2><span id='topic+as.raster'></span><span id='topic+as.raster+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Implementation of the generic <code><a href="grDevices.html#topic+as.raster">as.raster</a></code> function to create a 'raster' (small r) object. NOT TO BE CONFUSED with the Raster* (big R) objects defined by the raster package! Such objects can be used for plotting with the <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.raster(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.raster_+3A_x">x</code></td>
<td>
<p> RasterLayer object </p>
</td></tr>
<tr><td><code id="as.raster_+3A_...">...</code></td>
<td>
<p> Additional arguments. 
</p>
<p><code>maxpixels</code> Integer. To regularly subsample very large objects 
</p>
<p><code>col</code> Vector of colors. Default is col=rev(terrain.colors(255)))
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'raster' object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=3, nrow=3)
values(r) &lt;- 1:ncell(r)
as.raster(r)
</code></pre>

<hr>
<h2 id='atan2'>Two argument arc-tangent</h2><span id='topic+atan2+2CRaster+2CRaster-method'></span><span id='topic+atan2'></span>

<h3>Description</h3>

<p>For Raster* objects x and y, atan2(y, x) returns the angle in radians for the tangent y/x, handling the case when x is zero. See <code><a href="base.html#topic+Trig">Trig</a></code>
</p>
<p>See <code><a href="#topic+Math-methods">Math-methods</a></code> for other trigonometric and mathematical functions that can be used with Raster* objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atan2(y, x) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atan2_+3A_y">y</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="atan2_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+Math-methods">Math-methods</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- r2 &lt;- raster(nrow=10, ncol=10)
values(r1) &lt;- (runif(ncell(r1))-0.5) * 10
values(r2) &lt;- (runif(ncell(r1))-0.5) * 10
atan2(r1, r2)
</code></pre>

<hr>
<h2 id='autocorrelation'>Spatial autocorrelation</h2><span id='topic+Geary'></span><span id='topic+Moran'></span><span id='topic+MoranLocal'></span><span id='topic+GearyLocal'></span>

<h3>Description</h3>

<p>Compute Moran's I or Geary's C measures of global spatial autocorrelation in a RasterLayer, or compute the the local Moran or Geary index (Anselin, 1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Geary(x, w=matrix(c(1,1,1,1,0,1,1,1,1), 3,3))
Moran(x, w=matrix(c(1,1,1,1,0,1,1,1,1), 3,3))
MoranLocal(x, w=matrix(c(1,1,1,1,0,1,1,1,1), 3,3))
GearyLocal(x, w=matrix(c(1,1,1,1,0,1,1,1,1), 3,3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorrelation_+3A_x">x</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="autocorrelation_+3A_w">w</code></td>
<td>
<p>Spatial weights defined by or a rectangular matrix with odd length (3, 5, ...) sides (as in <code><a href="#topic+focal">focal</a></code>) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default setting uses a 3x3 neighborhood to compute &quot;Queen's case&quot; indices. You can use a filter (weights matrix) to do other things, such as &quot;Rook's case&quot;, or different lags. 
</p>


<h3>Value</h3>

<p>A single value (Moran's I or Geary's C) or a RasterLayer (Local Moran or Geary values)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Babak Naimi</p>


<h3>References</h3>

<p>Moran, P.A.P., 1950. Notes on continuous stochastic phenomena. Biometrika 37:17-23
</p>
<p>Geary, R.C., 1954. The contiguity ratio and statistical mapping. The Incorporated Statistician 5: 115-145
</p>
<p>Anselin, L., 1995. Local indicators of spatial association-LISA. Geographical Analysis 27:93-115
</p>


<h3>See Also</h3>

<p>The spdep package for additional and more general approaches for computing indices of spatial autocorrelation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrows=10, ncols=10)
values(r) &lt;- 1:ncell(r)

Moran(r)
# Rook's case
f &lt;- matrix(c(0,1,0,1,0,1,0,1,0), nrow=3)
Moran(r, f)

Geary(r)

x1 &lt;- MoranLocal(r)

# Rook's case
x2 &lt;- MoranLocal(r, w=f)
</code></pre>

<hr>
<h2 id='bands'>Number of bands</h2><span id='topic+bandnr'></span><span id='topic+bandnr+2CRasterLayer-method'></span><span id='topic+nbands'></span>

<h3>Description</h3>

<p>A 'band' refers to a single layer for a possibly multi-layer file. Most RasterLayer objects will refer to files with a single layer. 
The term 'band' is frequently used in remote sensing to refer to a variable (layer) in a multi-variable dataset as these variables typically reperesent reflection in different bandwidths in the electromagnetic spectrum. But in that context, bands could be stored in a single or in separate files. In the context of the raster package, the term band is equivalent to a layer in a raster file.
</p>
<p><code>nbands</code> returns the number of bands of the file that a RasterLayer points to (and 1 if it does not point at any file). This functions also works for a RasterStack for which it is equivalent to <code><a href="#topic+nlayers">nlayers</a></code>.
</p>
<p><code>band</code> returns the specific band the RasterLayer refers to (1 if the RasterLayer points at single layer file or does not point at any file). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbands(x)
bandnr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bands_+3A_x">x</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="bands_+3A_...">...</code></td>
<td>
<p>Additional arguments (none at this time)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric &gt;= 1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlayers">nlayers</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("external/rlogo.grd", package="raster")
r &lt;- raster(f, layer=2)
nbands(r)
bandnr(r)
</code></pre>

<hr>
<h2 id='barplot'>Bar plot of a RasterLayer</h2><span id='topic+barplot'></span><span id='topic+barplot+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Create a barplot of the values of a RasterLayer. For large datasets a regular sample with a size of approximately <code>maxpixels</code> is used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
barplot(height, maxpixels=1000000, digits=0, breaks=NULL, col=rainbow, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplot_+3A_height">height</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="barplot_+3A_maxpixels">maxpixels</code></td>
<td>
<p>integer. To regularly subsample very large objects</p>
</td></tr>
<tr><td><code id="barplot_+3A_digits">digits</code></td>
<td>
<p>integer used to determine how to <code><a href="base.html#topic+round">round</a></code> the values before tabulating. Set to <code>NULL</code> or to a large number if you do not want any rounding </p>
</td></tr>
<tr><td><code id="barplot_+3A_breaks">breaks</code></td>
<td>
<p>breaks used to group the data as in <code><a href="base.html#topic+cut">cut</a></code></p>
</td></tr>
<tr><td><code id="barplot_+3A_col">col</code></td>
<td>
<p>a color generating function such as <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, or a vector of colors</p>
</td></tr>
<tr><td><code id="barplot_+3A_...">...</code></td>
<td>
<p>additional arguments for plotting as in <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector (or matrix, when <code>beside = TRUE</code>) of the coordinates of the bar midpoints, useful for adding to the graph. See <code><a href="graphics.html#topic+barplot">barplot</a></code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+hist">hist</a>, <a href="#topic+boxplot">boxplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
f &lt;- system.file("external/test.grd", package="raster")
r &lt;- raster(f)
barplot(r, digits=-2, las=2, ylab='Frequency')

op &lt;- par(no.readonly = TRUE)
par(mai = c(1, 2, .5, .5))
barplot(r, breaks=10, col=c('red', 'blue'), horiz=TRUE, digits=NULL, las=1)
par(op)
</code></pre>

<hr>
<h2 id='bind'> 
Bind Spatial* objects
</h2><span id='topic+bind'></span><span id='topic+bind+2CSpatialPolygons+2CSpatialPolygons-method'></span><span id='topic+bind+2CSpatialLines+2CSpatialLines-method'></span><span id='topic+bind+2CSpatialPoints+2CSpatialPoints-method'></span><span id='topic+bind+2Cmatrix+2Cmatrix-method'></span><span id='topic+bind+2Cmatrix+2Cmissing-method'></span><span id='topic+bind+2Cdata.frame+2Cdata.frame-method'></span><span id='topic+bind+2Cdata.frame+2Cmissing-method'></span><span id='topic+bind+2Clist+2Cmissing-method'></span>

<h3>Description</h3>

<p>Bind (append) Spatial* objects into a single object. All objects must be of the same vector type base class (SpatialPoints, SpatialLines, or SpatialPolygons)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatialPolygons,SpatialPolygons'
bind(x, y, ..., keepnames=FALSE)

## S4 method for signature 'SpatialLines,SpatialLines'
bind(x, y, ..., keepnames=FALSE)

## S4 method for signature 'SpatialPoints,SpatialPoints'
bind(x, y, ..., keepnames=FALSE)

## S4 method for signature 'data.frame,data.frame'
bind(x, y, ..., variables=NULL)

## S4 method for signature 'list,missing'
bind(x, y, ..., keepnames=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_x">x</code></td>
<td>
<p>Spatial* object or data.frame, or a list of Spatial* objects</p>
</td></tr>
<tr><td><code id="bind_+3A_y">y</code></td>
<td>
<p>Spatial* object or data.frame, or missing</p>
</td></tr>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p>Additional Spatial* objects</p>
</td></tr>
<tr><td><code id="bind_+3A_keepnames">keepnames</code></td>
<td>
<p>Logical. If <code>TRUE</code> the row.names are kept (if unique)</p>
</td></tr> 
<tr><td><code id="bind_+3A_variables">variables</code></td>
<td>
<p>character. Variable (column) names to keep, If <code>NULL</code>, all variables are kept</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Spatial* object
</p>


<h3>See Also</h3>

 <p><code><a href="sp.html#topic+merge">merge</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- readRDS(system.file("external/lux.rds", package="raster"))
mersch &lt;- p[p$NAME_2=='Mersch', ]
diekirch &lt;- p[p$NAME_2=='Diekirch', ]
remich &lt;- p[p$NAME_2=='Remich', ]
remich$NAME_1 &lt;- NULL
x &lt;- bind(mersch, diekirch, remich)
plot(x)
data.frame(x)
</code></pre>

<hr>
<h2 id='blockSize'>Block size for writing files</h2><span id='topic+blockSize'></span><span id='topic+blockSize+2CRaster-method'></span>

<h3>Description</h3>

<p>This function can be used to suggest chunk sizes (always a number of entire rows), and corresponding row numbers, to be used when processing Raster* objects in chunks. Normally used together with <code><a href="#topic+writeValues">writeValues</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
blockSize(x, chunksize, n=nlayers(x), minblocks=4, minrows=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockSize_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="blockSize_+3A_chunksize">chunksize</code></td>
<td>
<p>Integer, normally missing. Can be used to set the block size; unit is number of cells. Block size is then computed in units of number of rows (always &gt;= 1)  </p>
</td></tr>
<tr><td><code id="blockSize_+3A_n">n</code></td>
<td>
<p>Integer. number of layers to consider. The function divides chunksize by n to determine blocksize </p>
</td></tr>
<tr><td><code id="blockSize_+3A_minblocks">minblocks</code></td>
<td>
<p>Integer. Minimum number of blocks </p>
</td></tr>
<tr><td><code id="blockSize_+3A_minrows">minrows</code></td>
<td>
<p>Integer. Minimum number of rows in each block </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements: 
</p>
<p><code>rows</code>, the suggested row numbers at which to start the blocks for reading and writing, 
</p>
<p><code>nrows</code>, the number of rows in each block, and,
</p>
<p><code>n</code>, the total number of blocks 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+writeValues">writeValues</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/test.grd", package="raster"))
blockSize(r)
</code></pre>

<hr>
<h2 id='boundaries'>boundaries (edges) detection</h2><span id='topic+boundaries'></span><span id='topic+boundaries+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Detect boundaries (edges). boundaries are cells that have more than one class in the 4 or 8 cells surrounding it, or, if <code>classes=FALSE</code>, cells with values and cells with <code>NA</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
boundaries(x, type='inner', classes=FALSE, directions=8, asNA=FALSE, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundaries_+3A_x">x</code></td>
<td>
<p>RasterLayer object</p>
</td></tr>
<tr><td><code id="boundaries_+3A_type">type</code></td>
<td>
<p>character. 'inner' or 'outer'</p>
</td></tr>
<tr><td><code id="boundaries_+3A_classes">classes</code></td>
<td>
<p>character. Logical. If <code>TRUE</code> all different values are (after rounding) distinguished, as well as <code>NA</code>. If <code>FALSE</code> (the default) only edges between <code>NA</code> and non-<code>NA</code> cells are considered</p>
</td></tr>
<tr><td><code id="boundaries_+3A_directions">directions</code></td>
<td>
<p>integer. Which cells are considered adjacent? Should be 8 (Queen's case) or 4 (Rook's case)</p>
</td></tr>
<tr><td><code id="boundaries_+3A_asna">asNA</code></td>
<td>
<p>logical. If <code>TRUE</code>, non-edges are returned as <code>NA</code> instead of zero</p>
</td></tr>
<tr><td><code id="boundaries_+3A_filename">filename</code></td>
<td>
<p>character. Filename for the output RasterLayer (optional)</p>
</td></tr>
<tr><td><code id="boundaries_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr> 
</table>


<h3>Value</h3>

<p>RasterLayer. Cell values are either 1 (a border) or 0 (not a border), or <code>NA</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+focal">focal</a></code>, <code><a href="#topic+clump">clump</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=18, ncol=36, xmn=0)
r[150:250] &lt;- 1
r[251:450] &lt;- 2
plot( boundaries(r, type='inner') )
plot( boundaries(r, type='outer') )
plot( boundaries(r, classes=TRUE) )
</code></pre>

<hr>
<h2 id='boxplot'>
Box plot of Raster objects
</h2><span id='topic+boxplot'></span><span id='topic+boxplot+2CRasterLayer-method'></span><span id='topic+boxplot+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Box plot of layers in a Raster object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterStackBrick'
boxplot(x, maxpixels=100000, ...)

## S4 method for signature 'RasterLayer'
boxplot(x, y=NULL, maxpixels=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="boxplot_+3A_y">y</code></td>
<td>
<p>If <code>x</code> is a RasterLayer object, y can be an additional RasterLayer to group the values of <code>x</code> by 'zone'</p>
</td></tr>
<tr><td><code id="boxplot_+3A_maxpixels">maxpixels</code></td>
<td>
<p>Integer. Number of pixels to sample from each layer of large Raster objects</p>
</td></tr>
<tr><td><code id="boxplot_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>graphics::<a href="graphics.html#topic+boxplot">boxplot</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pairs">pairs</a>, <a href="#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- r2 &lt;- r3 &lt;- raster(ncol=10, nrow=10)
values(r1) &lt;- rnorm(ncell(r1), 100, 40)
values(r2) &lt;- rnorm(ncell(r1), 80, 10)
values(r3) &lt;- rnorm(ncell(r1), 120, 30)
s &lt;- stack(r1, r2, r3)
names(s) &lt;- c('A', 'B', 'C')

boxplot(s, notch=TRUE, col=c('red', 'blue', 'orange'), main='Box plot', ylab='random' )
</code></pre>

<hr>
<h2 id='brick'> Create a RasterBrick object</h2><span id='topic+brick'></span><span id='topic+brick+2Ccharacter-method'></span><span id='topic+brick+2Cmissing-method'></span><span id='topic+brick+2CRasterLayer-method'></span><span id='topic+brick+2CRasterStack-method'></span><span id='topic+brick+2CRasterBrick-method'></span><span id='topic+brick+2CExtent-method'></span><span id='topic+brick+2Carray-method'></span><span id='topic+brick+2Clist-method'></span><span id='topic+brick+2CSpatialPixels-method'></span><span id='topic+brick+2CSpatialGrid-method'></span><span id='topic+brick+2Ckasc-method'></span><span id='topic+brick+2Cgrf-method'></span><span id='topic+brick+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>A RasterBrick is a multi-layer raster object. They are typically created from a multi-layer (band) file; but they can also exist entirely in memory. They are similar to a RasterStack (that can be created with <code><a href="#topic+stack">stack</a></code>), but processing time should be shorter when using a RasterBrick. Yet they are less flexible as they can only point to a single file.
</p>
<p>A RasterBrick can be created from RasterLayer objects, from a RasterStack, or from a (multi-layer) file. The can also be created from SpatialPixels*, SpatialGrid*, and Extent objects, and from a three-dimensional array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
brick(x, ...)

## S4 method for signature 'RasterStack'
brick(x, values=TRUE, nl, filename='', ...) 

## S4 method for signature 'RasterBrick'
brick(x, nl, ...)

## S4 method for signature 'RasterLayer'
brick(x, ..., values=TRUE, nl=1, filename='') 

## S4 method for signature 'missing'
brick(nrows=180, ncols=360, xmn=-180, xmx=180, ymn=-90, ymx=90, nl=1, crs)

## S4 method for signature 'Extent'
brick(x, nrows=10, ncols=10, crs="", nl=1)

## S4 method for signature 'array'
brick(x, xmn=0, xmx=1, ymn=0, ymx=1, crs="", transpose=FALSE)

## S4 method for signature 'SpatialGrid'
brick(x)

## S4 method for signature 'SpatialPixels'
brick(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brick_+3A_x">x</code></td>
<td>
<p>character (filename, see Details); Raster* object; missing; array; SpatialGrid*; SpatialPixels*; Extent; or list of Raster* objects. Supported file types are the 'native' raster package format and those that can be read via GDAL, and NetCDF files (see details)</p>
</td></tr>
<tr><td><code id="brick_+3A_...">...</code></td>
<td>
<p>see Details</p>
</td></tr>
<tr><td><code id="brick_+3A_values">values</code></td>
<td>
<p>logical. If <code>TRUE</code>, the cell values of '<code>x</code>' are copied to the RasterBrick object that is returned</p>
</td></tr>
<tr><td><code id="brick_+3A_nl">nl</code></td>
<td>
<p>integer &gt; 0. How many layers should the RasterBrick have?</p>
</td></tr>
<tr><td><code id="brick_+3A_filename">filename</code></td>
<td>
<p>character. Filename if you want the RasterBrick to be saved on disk</p>
</td></tr>
<tr><td><code id="brick_+3A_nrows">nrows</code></td>
<td>
<p>integer &gt; 0. Number of rows</p>
</td></tr>
<tr><td><code id="brick_+3A_ncols">ncols</code></td>
<td>
<p>integer &gt; 0. Number of columns</p>
</td></tr>
<tr><td><code id="brick_+3A_xmn">xmn</code></td>
<td>
<p>minimum x coordinate (left border)</p>
</td></tr>
<tr><td><code id="brick_+3A_xmx">xmx</code></td>
<td>
<p>maximum x coordinate (right border)</p>
</td></tr>
<tr><td><code id="brick_+3A_ymn">ymn</code></td>
<td>
<p>minimum y coordinate (bottom border)</p>
</td></tr>
<tr><td><code id="brick_+3A_ymx">ymx</code></td>
<td>
<p>maximum y coordinate (top border)</p>
</td></tr>
<tr><td><code id="brick_+3A_crs">crs</code></td>
<td>
<p>character or object of class CRS. PROJ4 type description of a Coordinate Reference System (map projection). If this argument is missing, and the x coordinates are within -360 .. 360 and the y coordinates are within -90 .. 90, &quot;+proj=longlat +datum=WGS84&quot; is used</p>
</td></tr>
<tr><td><code id="brick_+3A_transpose">transpose</code></td>
<td>
<p>if <code>TRUE</code>, the values in the array are transposed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a RasterLayer, the additional arguments can be used to pass additional Raster* objects.
</p>
<p>If there is a <code>filename</code> argument, the additional arguments are as for <code><a href="#topic+writeRaster">writeRaster</a></code>. 
</p>
<p>If <code>x</code> represents a filename there is the following additional argument:
</p>
<p><code>native</code>: logical. If <code>TRUE</code> (not the default), reading and writing of IDRISI, BIL, BSQ, BIP, and Arc ASCII files is done with native (raster package) drivers, rather then via GDAL.
</p>
<p>In addition, if <code>x</code> is a <b>NetCDF</b> filename there are the following additional arguments:
</p>
<p><code>varname</code>: character. The variable name (e.g. 'altitude' or 'precipitation'. If not supplied and the file has multiple
variables are a guess will be made (and reported))
</p>
<p><code>lvar</code>: integer &gt; 0 (default=3). To select the 'level variable' (3rd dimension variable) to use, if the file has 4 dimensions (e.g. depth instead of time)
</p>
<p><code>level</code>: integer &gt; 0 (default=1). To select the 'level' (4th dimension variable) to use, if the file has 4 dimensions, e.g. to create a RasterBrick of weather over time at a certain height.
</p>
<p><code>dims</code>: integer vector to indicated the order of the dimensions. Default is <code>dims=c(1,2,3)</code> (rows, cols, time).  
</p>
<p>To use NetCDF files the <code>ncdf4</code> package needs to be available. It is assumed that these files follow, or are compatible with the CF-1 convention.
</p>


<h3>Value</h3>

<p>RasterBrick
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+raster">raster</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brick(system.file("external/rlogo.grd", package="raster"))
b
nlayers(b)
names(b)
extract(b, 870)
</code></pre>

<hr>
<h2 id='buffer'>buffer</h2><span id='topic+buffer'></span><span id='topic+buffer+2CRasterLayer-method'></span><span id='topic+buffer+2CSpatial-method'></span>

<h3>Description</h3>

<p>Calculate a buffer around all cells that are not <code>NA</code> or around SpatialPoints, Lines, or Polygons.
</p>
<p>Note that the distance unit of the buffer <code>width</code> parameter is meters if the RasterLayer is not projected (<code>+proj=longlat</code>), and in map units (typically also meters) when it is projected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
buffer(x, width=0, filename='', doEdge=FALSE, ...)

## S4 method for signature 'Spatial'
buffer(x, width=1, dissolve=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buffer_+3A_x">x</code></td>
<td>
<p>RasterLayer or Spatial* object</p>
</td></tr>
<tr><td><code id="buffer_+3A_width">width</code></td>
<td>
<p>numeric &gt; 0. Unit is meter if <code>x</code> has a longitude/latitude CRS, or mapunits in other cases</p>
</td></tr>
<tr><td><code id="buffer_+3A_filename">filename</code></td>
<td>
<p>character. Filename for the output RasterLayer (optional)</p>
</td></tr>
<tr><td><code id="buffer_+3A_doedge">doEdge</code></td>
<td>
<p>logical. If <code>TRUE</code>, the <code><a href="#topic+boundaries">boundaries</a></code> function is called first. This may be efficient in cases where you compute a buffer around very large areas because <code>boundaries</code> determines the edge cells that matter for distance computation</p>
</td></tr>
<tr><td><code id="buffer_+3A_dissolve">dissolve</code></td>
<td>
<p>logical. If <code>TRUE</code>, buffer geometries of overlapping polygons are dissolved and all geometries are aggregated and attributes (the data.frame) are dropped</p>
</td></tr>
<tr><td><code id="buffer_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer or SpatialPolygons* object</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>,  <code><a href="#topic+gridDistance">gridDistance</a></code>,  <code><a href="#topic+pointDistance">pointDistance</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=36,nrow=18)
values(r) &lt;- NA
r[500] &lt;- 1
b &lt;- buffer(r, width=5000000) 
#plot(b)
</code></pre>

<hr>
<h2 id='calc'>Calculate</h2><span id='topic+calc'></span><span id='topic+calc+2CRaster+2Cfunction-method'></span>

<h3>Description</h3>

 
<p>Calculate values for a new Raster* object from another Raster* object, using a formula. 
</p>
<p>If <code>x</code> is a RasterLayer, <code>fun</code> is typically a function that can take a single vector as input, and return a vector of values of the same length (e.g. <code>sqrt</code>). If <code>x</code> is a RasterStack or RasterBrick, fun should operate on a vector of values (one vector for each cell). <code>calc</code> returns a RasterLayer if <code>fun</code> returns a single value (e.g. <code>sum</code>) and it returns a RasterBrick if <code>fun</code> returns more than one number, e.g., <code>fun=quantile</code>.
</p>
<p>In many cases, what can be achieved with <code>calc</code>, can also be accomplished with a more intuitive 'raster-algebra' notation (see <code><a href="#topic+Arith-methods">Arith-methods</a></code>). For example, <code>r &lt;- r * 2</code> instead of
</p>
<p><code>r &lt;- calc(r, fun=function(x){x * 2}</code>, or <code>r &lt;- sum(s)</code> instead of
</p>
<p><code>r &lt;- calc(s, fun=sum)</code>. However, <code>calc</code> should be faster when using complex formulas on large datasets. With <code>calc</code> it is possible to set an output filename and file type preferences. 
</p>
<p>See (<code><a href="#topic+overlay">overlay</a></code>) to use functions that refer to specific layers, like (<code>function(a,b,c){a + sqrt(b) / c}</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,function'
calc(x, fun, filename='', na.rm, forcefun=FALSE, forceapply=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="calc_+3A_fun">fun</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="calc_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="calc_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove <code>NA</code> values, if supported by 'fun' (only relevant when summarizing a multilayer Raster object into a RasterLayer)</p>
</td></tr>
<tr><td><code id="calc_+3A_forcefun">forcefun</code></td>
<td>
<p>logical. Force <code>calc</code> to not use fun with apply; for use with ambiguous functions and for debugging (see Details)</p>
</td></tr>
<tr><td><code id="calc_+3A_forceapply">forceapply</code></td>
<td>
<p>logical. Force <code>calc</code> to use fun with apply; for use with ambiguous functions and for debugging (see Details)</p>
</td></tr>
<tr><td><code id="calc_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>    
</table>


<h3>Details</h3>

<p>The intent of some functions can be ambiguous. Consider:
</p>
<p><code>library(raster)</code>
</p>
<p><code>r &lt;- raster(volcano)</code>
</p>
<p><code>calc(r, function(x) x * 1:10)</code>
</p>
<p>In this case, the cell values are multiplied in a vectorized manner and a single layer is returned where the first cell has been multiplied with one, the second cell with two, the 11th cell with one again, and so on. But perhaps the intent was to create 10 new layers (<code>x*1, x*2, ...</code>)? This can be achieved by using argument <code>forceapply=TRUE</code> 
</p>
<p><code>calc(r, function(x) x * 1:10, forceapply=TRUE)</code>
</p>


<h3>Value</h3>

<p>a Raster* object
</p>


<h3>Note</h3>

<p>For large objects <code>calc</code> will compute values chunk by chunk. This means that for the result of <code>fun</code> to be  correct it should not depend on having access to _all_ values at once. For example, to scale the values of a Raster* object by subtracting its mean value (for each layer), you would _not_ do, for Raster object <code>x</code>: 
</p>
<p><code>calc(x, function(x)scale(x, scale=FALSE))</code>
</p>
<p>Because the mean value of each chunk will likely be different. Rather do something like
</p>
<p><code>m &lt;- cellStats(x, 'mean')</code>
</p>
<p><code>x - m</code>
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Matteo Mattiuzzi</p>


<h3>See Also</h3>

 <p><code> <a href="#topic+overlay">overlay</a></code> ,  <code> <a href="#topic+reclassify">reclassify</a></code>,  <a href="#topic+Arith-methods">Arith-methods</a>, <a href="#topic+Math-methods">Math-methods</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=36, nrows=18)
values(r) &lt;- 1:ncell(r)

# multiply values with 10
fun &lt;- function(x) { x * 10 }
rc1 &lt;- calc(r, fun)

# set values below 100 to NA. 
fun &lt;- function(x) { x[x&lt;100] &lt;- NA; return(x) }
rc2 &lt;- calc(r, fun)

# set NA values to -9999
fun &lt;- function(x) { x[is.na(x)] &lt;- -9999; return(x)} 
rc3 &lt;- calc(rc2, fun)

# using a RasterStack as input
s &lt;- stack(r, r*2, sqrt(r))
# return a RasterLayer
rs1 &lt;- calc(s, sum)

# return a RasterBrick
rs2 &lt;- calc(s, fun=function(x){x * 10})
# recycling by layer
rs3 &lt;- calc(s, fun=function(x){x * c(1, 5, 10)})

# use overlay when you want to refer to individual layer in the function
# but it can be done with calc: 
rs4 &lt;- calc(s, fun=function(x){x[1]+x[2]*x[3]})

## 
# Some regression examples
## 

# create data
r &lt;- raster(nrow=10, ncol=10)
s1 &lt;- lapply(1:12, function(i) setValues(r, rnorm(ncell(r), i, 3)))
s2 &lt;- lapply(1:12, function(i) setValues(r, rnorm(ncell(r), i, 3)))
s1 &lt;- stack(s1)
s2 &lt;- stack(s2)

# regression of values in one brick (or stack) with another
s &lt;- stack(s1, s2)
# s1 and s2 have 12 layers; coefficients[2] is the slope
fun &lt;- function(x) { lm(x[1:12] ~ x[13:24])$coefficients[2] }
x1 &lt;- calc(s, fun)

# regression of values in one brick (or stack) with 'time'
time &lt;- 1:nlayers(s)
fun &lt;- function(x) { lm(x ~ time)$coefficients[2] }
x2 &lt;- calc(s, fun)

# get multiple layers, e.g. the slope _and_ intercept
fun &lt;- function(x) { lm(x ~ time)$coefficients }
x3 &lt;- calc(s, fun)


### A much (&gt; 100 times) faster approach is to directly use 
### linear algebra and pre-compute some constants

## add 1 for a model with an intercept
X &lt;- cbind(1, time)

## pre-computing constant part of least squares
invXtX &lt;- solve(t(X) %*% X) %*% t(X)

## much reduced regression model; [2] is to get the slope
quickfun &lt;- function(y) (invXtX %*% y)[2]
x4 &lt;- calc(s, quickfun) 
</code></pre>

<hr>
<h2 id='cellFrom'>Get cell, row, or column number</h2><span id='topic+cellFromRowCol'></span><span id='topic+cellFromRowCol+2CBasicRaster+2Cnumeric+2Cnumeric-method'></span><span id='topic+colFromX'></span><span id='topic+colFromX+2CBasicRaster+2Cnumeric-method'></span><span id='topic+rowFromY'></span><span id='topic+rowFromY+2CBasicRaster+2Cnumeric-method'></span><span id='topic+cellFromXY'></span><span id='topic+cellFromXY+2CBasicRaster+2CANY-method'></span><span id='topic+cellFromRow'></span><span id='topic+cellFromCol'></span><span id='topic+cellFromRowColCombine'></span><span id='topic+cellFromRowColCombine+2CBasicRaster+2Cnumeric+2Cnumeric-method'></span><span id='topic+fourCellsFromXY'></span><span id='topic+cellFromLine'></span><span id='topic+cellFromPolygon'></span>

<h3>Description</h3>

<p>Get cell number(s) of a Raster* object from row and/or column numbers.   
Cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom.
The last cell number equals the number of cells of the Raster* object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellFromRowCol(object, row, col, ...)
cellFromRowColCombine(object, row, col, ...)
cellFromRow(object, rownr)
cellFromCol(object, colnr)
colFromX(object, x)
rowFromY(object, y)
cellFromXY(object, xy)
cellFromLine(object, lns)
cellFromPolygon(object, p, weights=FALSE)
fourCellsFromXY(object, xy, duplicates=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellFrom_+3A_object">object</code></td>
<td>
<p>Raster* object (or a SpatialPixels* or SpatialGrid* object)</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_colnr">colnr</code></td>
<td>
<p>column number; or vector of column numbers</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_rownr">rownr</code></td>
<td>
<p>row number; or vector of row numbers</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_col">col</code></td>
<td>
<p>column number; or vector of column numbers</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_row">row</code></td>
<td>
<p>row number; or vector of row numbers</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_x">x</code></td>
<td>
<p>x coordinate(s)</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_y">y</code></td>
<td>
<p>y coordinate(s)</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_xy">xy</code></td>
<td>
<p>matrix of x and y coordinates, or a SpatialPoints or SpatialPointsDataFrame object</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_lns">lns</code></td>
<td>
<p>SpatialLines object</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_p">p</code></td>
<td>
<p>SpatialPolygons object</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_weights">weights</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the fraction of each cell that is covered is also returned</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_duplicates">duplicates</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the same cell number can be returned twice (if the point in the middle of a division between two cells) or four times (if a point is in the center of a cell)</p>
</td></tr>
<tr><td><code id="cellFrom_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cellFromRowCol</code> returns the cell numbers obtained for each row / col number pair. In contrast, <code>cellFromRowColCombine</code> returns the cell numbers obtained by the combination of all row and column numbers supplied as arguments.
</p>
<p><code>fourCellsFromXY</code> returns the four cells that are nearest to a point (if the point falls on the raster). Also see <code><a href="#topic+adjacent">adjacent</a></code>.
</p>


<h3>Value</h3>

<p>vector of row, column or cell numbers. <code>cellFromLine</code> and <code>cellFromPolygon</code> return a list, <code>fourCellsFromXY</code> returns a matrix. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyFromCell">xyFromCell</a>, <a href="#topic+cellsFromExtent">cellsFromExtent</a>, <a href="#topic+rowColFromCell">rowColFromCell</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=10, nrows=10)
cellFromRowCol(r, 5, 5)
cellFromRowCol(r, 1:2, 1:2)
cellFromRowColCombine(r, 1:3, 1:2)
cellFromCol(r, 1)
cellFromRow(r, 1)

colFromX(r, 0.5)
rowFromY(r, 0.5)
cellFromXY(r, cbind(c(0.5,5), c(15, 88)))
fourCellsFromXY(r, cbind(c(0.5,5), c(15, 88)))

cds1 &lt;- rbind(c(-180,-20), c(-160,5), c(-60, 0), c(-160,-60), c(-180,-20))
cds2 &lt;- rbind(c(80,0), c(100,60), c(120,0), c(120,-55), c(80,0))
pols &lt;- SpatialPolygons(list(Polygons(list(Polygon(cds1)), 1), Polygons(list(Polygon(cds2)), 2)))
cellFromPolygon(r, pols)
</code></pre>

<hr>
<h2 id='cellsFromExtent'>Cells from extent, and vice versa</h2><span id='topic+cellsFromExtent'></span><span id='topic+extentFromCells'></span>

<h3>Description</h3>

<p>cellsFromExtent returns the cell numbers for a Raster* object that are within a specfied extent (rectangular area), supply an object of class Extent, or another Raster* object.
</p>
<p>extentFromCells returns an Extent object from a Raster* object and cell numbers. All cells are within the returned Extent. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellsFromExtent(object, extent, expand=FALSE)
extentFromCells(object, cells)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellsFromExtent_+3A_object">object</code></td>
<td>
<p>A Raster* object</p>
</td></tr>
<tr><td><code id="cellsFromExtent_+3A_extent">extent</code></td>
<td>
<p>An object of class Extent (which you can create with newExtent(), or another Raster* object )</p>
</td></tr>  
<tr><td><code id="cellsFromExtent_+3A_expand">expand</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>NA</code> is returned for (virtual) cells implied by <code>bndbox</code>, 
that are outside the RasterLayer (<code>object</code>). If <code>FALSE</code>, only cell numbers for the area where <code>object</code> and <code>bndbox</code>
overlap are returned (see <a href="#topic+intersect">intersect</a>) </p>
</td></tr>
<tr><td><code id="cellsFromExtent_+3A_cells">cells</code></td>
<td>
<p>numeric. A vector of cell numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of cell numbers 
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+extent">extent</a></code>, <code><a href="#topic+cellFromXY">cellFromXY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
bb &lt;- extent(-5, 5, -5, 5)
cells &lt;- cellsFromExtent(r, bb)
r &lt;- crop(r, bb)
values(r) &lt;- cells

e &lt;- extentFromCells(r, 50:55)
</code></pre>

<hr>
<h2 id='cellStats'>Statistics across cells</h2><span id='topic+cellStats'></span><span id='topic+cellStats+2CRasterLayer-method'></span><span id='topic+cellStats+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Compute statistics for the cells of each layer of a Raster* object. In the <code>raster</code> package, functions such as max, min, and mean, when used with Raster* objects as argument, return a new Raster* object (with a value computed for each cell). In contrast, cellStats returns a single value, computed from the all the values of a layer. Also see <code><a href="#topic+layerStats">layerStats</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
cellStats(x, stat='mean', na.rm=TRUE, asSample=TRUE, ...)

## S4 method for signature 'RasterStackBrick'
cellStats(x, stat='mean', na.rm=TRUE, asSample=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellStats_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="cellStats_+3A_stat">stat</code></td>
<td>
<p>The function to be applied. See Details</p>
</td></tr>
<tr><td><code id="cellStats_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should <code>NA</code> values be removed?</p>
</td></tr>
<tr><td><code id="cellStats_+3A_assample">asSample</code></td>
<td>
<p>Logical. Only relevant for <code>stat=sd</code> in which case, if <code>TRUE</code>, the standard deviation for a sample (denominator is <code>n-1</code>) is computed, rather than for the population (denominator is <code>n</code>)</p>
</td></tr>
<tr><td><code id="cellStats_+3A_...">...</code></td>
<td>
<p>Additional arguments </p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>cellStats</code> will fail (gracefully) for very large Raster* objects except for a number of known functions: sum, mean, min, max, sd, 'skew' and 'rms'. 'skew' (skewness) and 'rms' (Root Mean Square) must be supplied as a character value (with quotes), the other known functions may be supplied with or without quotes. For other functions you could perhaps use a sample of the RasterLayer that can be held in memory (see <code><a href="#topic+sampleRegular">sampleRegular</a></code> )
</p>


<h3>Value</h3>

<p>Numeric
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+freq">freq</a></code>, <code><a href="#topic+quantile">quantile</a></code>, <code><a href="#topic+extremeValues">minValue</a></code>, <code><a href="#topic+extremeValues">maxValue</a></code>, <code><a href="#topic+setMinMax">setMinMax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=18, ncol=36)
values(r) &lt;- runif(ncell(r)) * 10
# works for large files
cellStats(r, 'mean')
# same, but does not work for very large files
cellStats(r, mean)
# multi-layer object
cellStats(brick(r,r), mean)
</code></pre>

<hr>
<h2 id='clamp'>Clamp values</h2><span id='topic+clamp'></span><span id='topic+clamp+2CRaster-method'></span><span id='topic+clamp+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Clamp values to a minimum and maximum value. That is, all values below the lower clamp value and above the upper clamp value become NA (or the lower/upper value if <code>useValue=TRUE</code>) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
clamp(x, lower=-Inf, upper=Inf, useValues=TRUE, filename="", ...)
## S4 method for signature 'numeric'
clamp(x, lower=-Inf, upper=Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clamp_+3A_x">x</code></td>
<td>
<p>RasterLayer, or numeric vector</p>
</td></tr>
<tr><td><code id="clamp_+3A_lower">lower</code></td>
<td>
<p>numeric. lowest value</p>
</td></tr>
<tr><td><code id="clamp_+3A_upper">upper</code></td>
<td>
<p>numeric. highest value</p>
</td></tr>
<tr><td><code id="clamp_+3A_usevalues">useValues</code></td>
<td>
<p>logical. If <code>FALSE</code> values outside the clamping range become <code>NA</code>, if <code>TRUE</code>, they get the extreme values</p>
</td></tr>
<tr><td><code id="clamp_+3A_filename">filename</code></td>
<td>
<p>character. Filename for the output RasterLayer (optional)</p>
</td></tr>  
<tr><td><code id="clamp_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Raster object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reclassify">reclassify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=12, nrows=12)
values(r) &lt;- 1:ncell(r)
rc &lt;- clamp(r, 25, 75) 
rc
</code></pre>

<hr>
<h2 id='clearValues'>Clear values</h2><span id='topic+clearValues'></span>

<h3>Description</h3>

<p>Clear cell values of a Raster* object from memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clearValues(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clearValues_+3A_x">x</code></td>
<td>
<p>Raster* object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Raster* object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+values">values</a></code>, <code><a href="#topic+replacement">replacement</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(ncol=10, nrow=10)
values(r) &lt;- 1:ncell(r)
r &lt;- clearValues(r)
</code></pre>

<hr>
<h2 id='click'>Query by clicking on a map</h2><span id='topic+click'></span><span id='topic+click+2CRaster-method'></span><span id='topic+click+2CSpatialGrid-method'></span><span id='topic+click+2CSpatialPixels-method'></span><span id='topic+click+2Cmissing-method'></span><span id='topic+click+2CSpatialPolygons-method'></span><span id='topic+click+2CSpatialLines-method'></span><span id='topic+click+2CSpatialPoints-method'></span>

<h3>Description</h3>

<p>Click on a map (plot) to get values of a Raster* or Spatial* object at that location; and optionally the coordinates and cell number of the location. For SpatialLines and SpatialPoints you need to click twice (draw a box).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
click(x, n=Inf, id=FALSE, xy=FALSE, cell=FALSE, type="n", show=TRUE, ...)

## S4 method for signature 'SpatialGrid'
click(x, n=1, id=FALSE, xy=FALSE, cell=FALSE, type="n", ...)

## S4 method for signature 'SpatialPolygons'
click(x, n=1, id=FALSE, xy=FALSE, type="n", ...)

## S4 method for signature 'SpatialLines'
click(x, ...)

## S4 method for signature 'SpatialPoints'
click(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="click_+3A_x">x</code></td>
<td>
<p>Raster*, or Spatial* object (or missing)</p>
</td></tr>
<tr><td><code id="click_+3A_n">n</code></td>
<td>
<p>number of clicks on the map</p>
</td></tr>
<tr><td><code id="click_+3A_id">id</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a numeric ID is shown on the map that corresponds to the row number of the output</p>
</td></tr>
<tr><td><code id="click_+3A_xy">xy</code></td>
<td>
<p>Logical. If <code>TRUE</code>, xy coordinates are included in the output</p>
</td></tr>
<tr><td><code id="click_+3A_cell">cell</code></td>
<td>
<p>Logical. If <code>TRUE</code>, cell numbers are included in the output</p>
</td></tr>
<tr><td><code id="click_+3A_type">type</code></td>
<td>
<p>One of &quot;n&quot;, &quot;p&quot;, &quot;l&quot; or &quot;o&quot;. If &quot;p&quot; or &quot;o&quot; the points are plotted; if &quot;l&quot; or &quot;o&quot; they are joined by lines. See ?locator</p>
</td></tr>
<tr><td><code id="click_+3A_show">show</code></td>
<td>
<p>logical. Print the values after each click?</p>
</td></tr>
<tr><td><code id="click_+3A_...">...</code></td>
<td>
<p>additional graphics parameters used if type != &quot;n&quot; for plotting the locations. See ?locator</p>
</td></tr>   
</table>


<h3>Value</h3>

<p>The value(s) of <code>x</code> at the point(s) clicked on (or touched by the box drawn).
</p>


<h3>Note</h3>

<p>The plot only provides the coordinates for a spatial query, the values are read from the Raster* or Spatial* object that is passed as an argument. Thus you can extract values from an object that has not been plotted, as long as it spatialy overlaps with with the extent of the plot.
</p>
<p>Unless the process is terminated prematurely values at at most <code>n</code> positions are determined. The identification process can be terminated by clicking the second mouse button and selecting 'Stop' from the menu, or from the 'Stop' menu on the graphics window. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+select">select</a>, <a href="#topic+drawExtent">drawExtent</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 r &lt;- raster(system.file("external/test.grd", package="raster"))
 plot(r)
 click(r)
 # now click on the plot (map)

## End(Not run)</code></pre>

<hr>
<h2 id='clump'>Detect clumps</h2><span id='topic+clump'></span><span id='topic+clump+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Detect clumps (patches) of connected cells. Each clump gets a unique ID. NA and zero are used as background values (i.e. these values are used to separate clumps). You can use queen's or rook's case, using the <code>directions</code> argument. For larger files that are processed in chunks, the highest clump number is not necessarily equal to the number of clumps (unless you use argument <code>gaps=FALSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
clump(x, filename="", directions=8, gaps=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clump_+3A_x">x</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="clump_+3A_filename">filename</code></td>
<td>
<p>Character. Filename for the output RasterLayer (optional)</p>
</td></tr>  
<tr><td><code id="clump_+3A_directions">directions</code></td>
<td>
<p>Integer. Which cells are considered adjacent? Should be 8 (Queen's case) or 4 (Rook's case) </p>
</td></tr>
<tr><td><code id="clump_+3A_gaps">gaps</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), there may be 'gaps' in the chunk numbers (e.g. you may have clumps with IDs 1, 2, 3 and 5, but not 4). If it is <code>FALSE</code>, these numbers will be recoded from 1 to n (4 in this example)</p>
</td></tr>  
<tr><td><code id="clump_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>Note</h3>

<p>This function requires that the igraph package is available.
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Jacob van Etten</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=12, nrows=12)
set.seed(0)
values(r) &lt;- round(runif(ncell(r))*0.7 )
rc &lt;- clump(r) 
freq(rc)
plot(rc)
</code></pre>

<hr>
<h2 id='cluster'>Use a multi-core cluster</h2><span id='topic+beginCluster'></span><span id='topic+endCluster'></span><span id='topic+clusterR'></span>

<h3>Description</h3>

<p><code>beginCluster</code> creates, and <code>endCluster</code> deletes a 'snow' cluster object. This object can be used for multi-core computing with those 'raster' functions that support it. 
</p>
<p><code>beginCluster</code> determines the number of nodes (cores) that are available and uses all of them (unless the argument <code>n</code> is used). 
</p>
<p>NOTE: beginCluster may fail when the package 'nws' is installed. You can fix that by removing the 'nws' package, or by setting the cluster type manually, e.g. <code>beginCluster(type="SOCK")</code>
</p>
<p>endCluster closes the cluster and removes the object.
</p>
<p>The use of the cluster is automatic in these functions: <code><a href="#topic+projectRaster">projectRaster</a></code>, <code><a href="#topic+resample">resample</a></code> and in <code><a href="#topic+extract">extract</a></code> when using polygons.
</p>
<p><code>clusterR</code> is a flexible interface for using cluster with other functions. This function only works with functions that have a Raster* object as first argument and that operate on a cell by cell basis (i.e., there is no effect of neigboring cells) and return an object with the same number of cells as the input raster object. The first argument of the function called must be a Raster* object. There can only be one Raster* object argument. For example, it works with <code><a href="#topic+calc">calc</a></code> and it also works with <code><a href="#topic+overlay">overlay</a></code> as long as you provide a single RasterStack or RasterBrick as the first argument. 
</p>
<p>This function is particularly useful to speed up computations in functions like predict, interpolate, and perhaps calc. 
</p>
<p>Among other functions, it does _not_ work with merge, crop, mosaic, (dis)aggregate, resample, projectRaster, focal, distance, buffer, direction. But note that projectRaster has a build-in capacity for clustering that is automatically used if beginCluster() has been called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beginCluster(n, type='SOCK', nice, exclude)
endCluster()
clusterR(x, fun, args=NULL, export=NULL, filename='', cl=NULL, m=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_n">n</code></td>
<td>
<p>Integer. The number of nodes to be used (optional)</p>
</td></tr>
<tr><td><code id="cluster_+3A_type">type</code></td>
<td>
<p>Character. The cluster type to be used</p>
</td></tr>
<tr><td><code id="cluster_+3A_nice">nice</code></td>
<td>
<p>Integer. To set the prioirty for the workers, between -20 and 20 (UNIX like platforms only)</p>
</td></tr>
<tr><td><code id="cluster_+3A_exclude">exclude</code></td>
<td>
<p>Character. Packages to exclude from loading on the nodes (because they may fail there) but are required/loaded on the master </p>
</td></tr>
<tr><td><code id="cluster_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="cluster_+3A_fun">fun</code></td>
<td>
<p>function that takes <code>x</code> as its first argument</p>
</td></tr>
<tr><td><code id="cluster_+3A_args">args</code></td>
<td>
<p>list with the arguments for the function (excluding <code>x</code>, which should always be the first argument</p>
</td></tr>
<tr><td><code id="cluster_+3A_export">export</code></td>
<td>
<p>character. Vector of variable names to export to the cluster nodes such that the are visible to fun (e.g. a parameter that is not passed as an argument)</p>
</td></tr>
<tr><td><code id="cluster_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="cluster_+3A_cl">cl</code></td>
<td>
<p>cluster object (do not use it if beginCluster() has been called</p>
</td></tr>
<tr><td><code id="cluster_+3A_m">m</code></td>
<td>
<p>tuning parameter to determine how many blocks should be used. The number is rounded and multiplied with the number of nodes.</p>
</td></tr>
<tr><td><code id="cluster_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>beginCluster and endCluster: None. The side effect is to create or delete a cluster object.
</p>
<p>clusterR: as for the function called with argument <code>fun</code>
</p>


<h3>Note</h3>

<p>If you want to write your own cluster-enabled functions see <code><a href="#topic+getCluster">getCluster</a>, <a href="#topic+returnCluster">returnCluster</a></code>, and the vignette about writing functions.
</p>


<h3>Author(s)</h3>

<p>Matteo Mattiuzzi and Robert J. Hijmans</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# set up the cluster object for parallel computing
beginCluster()

r &lt;- raster()
values(r) &lt;- 1:ncell(r)

x &lt;- clusterR(r, sqrt, verbose=T)

f1 &lt;- function(x) calc(x, sqrt)
y &lt;- clusterR(r, f1)

s &lt;- stack(r, r*2, r*3)
f2 &lt;- function(d,e,f) (d + e) / (f * param)
param &lt;- 122
ov &lt;- clusterR(s, overlay, args=list(fun=f2), export='param')

pts &lt;- matrix(c(0,0, 45,45), ncol=2, byrow=T)
d &lt;- clusterR(r, distanceFromPoints, args=list(xy=pts))

values(r) &lt;- runif(ncell(r))
m &lt;- c(0, 0.25, 1,  0.25, 0.5, 2,  0.5, 1, 3)
m &lt;- matrix(m, ncol=3, byrow=TRUE)
rc1 &lt;- clusterR(r, reclassify, args=list(rcl=m, right=FALSE), 
               filename=rasterTmpFile(), datatype='INT2S', overwrite=TRUE)

# equivalent to:
rc2 &lt;- reclassify(r, rcl=m, right=FALSE, filename=rasterTmpFile(), datatype='INT2S', overwrite=TRUE)


# example with the calc function
a &lt;- 10
f3 &lt;- function(x) sum(x)+a

z1 &lt;- clusterR(s, calc, args=list(fun=f3), export='a')

# for some raster functions that use another function as an argument 
# you can write your own parallel function instead of using clusterR
# get cluster object created with beginCluster
cl &lt;- getCluster()  

library(parallel)
clusterExport(cl, "a")
z2 &lt;- calc(s, fun=function(x){ parApply(cl, x, 1, f3)} )
# set flag that cluster is available again
returnCluster()
#

# done with cluster object		
endCluster()

## End(Not run)
</code></pre>

<hr>
<h2 id='colortable'>colortable</h2><span id='topic+colortable'></span><span id='topic+colortable+3C-'></span>

<h3>Description</h3>

<p>Get or set the colortable of a RasterLayer. A colortable is a vector of 256 colors in the RGB triple format as returned by the <code><a href="grDevices.html#topic+rgb">rgb</a></code> function (e.g. &quot;#C4CDDA&quot;). 
</p>
<p>When setting the colortable, it is assumed that the values are integers in the range [0,255]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colortable(x)
colortable(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colortable_+3A_x">x</code></td>
<td>
<p>RasterLayer object</p>
</td></tr>
<tr><td><code id="colortable_+3A_value">value</code></td>
<td>
<p>vector of 256 character values</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+plotRGB">plotRGB</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10)
values(r) &lt;- sample(0:255, ncell(r), replace=TRUE)
ctab &lt;- sample(rainbow(256))
colortable(r) &lt;- ctab
plot(r)
head(colortable(r)) 
</code></pre>

<hr>
<h2 id='Compare-methods'>Compare Raster* objects</h2><span id='topic+Compare-methods'></span><span id='topic+Compare+2CExtent+2CExtent-method'></span><span id='topic+Compare+2CRaster+2CRaster-method'></span><span id='topic+Compare+2CRaster+2Clogical-method'></span><span id='topic+Compare+2CRaster+2Cnumeric-method'></span><span id='topic+Compare+2Clogical+2CRaster-method'></span><span id='topic+Compare+2Cnumeric+2CRaster-method'></span><span id='topic++3D+3D+2CBasicRaster+2CBasicRaster-method'></span><span id='topic++21+3D+2CBasicRaster+2CBasicRaster-method'></span>

<h3>Description</h3>

<p>These methods compare the location and resolution of Raster* objects. That is, they compare their spatial extent, projection, and number of rows and columns. 
</p>
<p>For <code>BasicRaster</code> objects you can use <code>==</code> and <code>!=</code>, the values returned is a single logical value <code>TRUE</code> or <code>FALSE</code>
</p>
<p>For RasterLayer objects, these operators also compare the values associated with the objects, and the result is a RasterLayer object with logical (Boolean) values. 
</p>
<p>The following methods have been implemented for RasterLayer objects:
</p>
<p><code>==, !=, &gt;, &lt;,  &lt;=, &gt;=</code>
</p>


<h3>Value</h3>

<p>A logical value or a RasterLayer object, and in some cases the side effect of a new file on disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- raster()
r1 &lt;- setValues(r1, round(10 * runif(ncell(r1))))
r2 &lt;- setValues(r1, round(10 * runif(ncell(r1))))
as(r1, 'BasicRaster') == as(r2, 'BasicRaster')
r3 &lt;- r1 == r2

b &lt;- extent(0, 360, 0, 180)
r4 &lt;- setExtent(r2, b)
as(r2, 'BasicRaster') != as(r4, 'BasicRaster')
# The following would give an error. You cannot compare RasterLayer 
# that do not have the same BasicRaster properties.
#r3 &lt;- r1 &gt; r4
</code></pre>

<hr>
<h2 id='compareCRS'> Partially compare two CRS objects </h2><span id='topic+compareCRS'></span>

<h3>Description</h3>

<p>Compare CRS objects 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareCRS(x, y, unknown=FALSE, verbatim=FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareCRS_+3A_x">x</code></td>
<td>
<p>CRS object, or object from which it can be extracted with <code><a href="#topic+projection">projection</a></code>, or PROJ.4 format character string</p>
</td></tr>
<tr><td><code id="compareCRS_+3A_y">y</code></td>
<td>
<p>same as <code>x</code></p>
</td></tr>
<tr><td><code id="compareCRS_+3A_unknown">unknown</code></td>
<td>
<p>logical. Return <code>TRUE</code> if <code>x</code> or <code>y</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="compareCRS_+3A_verbatim">verbatim</code></td>
<td>
<p>logical. If <code>TRUE</code> compare <code>x</code> and <code>y</code>, verbatim (not partially)</p>
</td></tr>
<tr><td><code id="compareCRS_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, messages about the comparison may be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p><code>sp::identicalCRS</code>,  <code><a href="#topic+crs">crs</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
compareCRS("+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84",
  "+proj=longlat +datum=WGS84")
compareCRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0",
  "+proj=longlat +datum=WGS84")
compareCRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0", 
  "+proj=longlat +datum=WGS84", verbatim=TRUE)
compareCRS("+proj=longlat +datum=WGS84", NA)
compareCRS("+proj=longlat +datum=WGS84", NA, unknown=TRUE)
</code></pre>

<hr>
<h2 id='compareRaster'>Compare Raster objects</h2><span id='topic+compareRaster'></span><span id='topic+all.equal+2CRaster+2CRaster-method'></span>

<h3>Description</h3>

<p>Evaluate whether a two or more Raster* objects have the same extent, number of rows and columns, projection, resolution, and origin (or a subset of these comparisons). 
</p>
<p>all.equal is a wrapper around compareRaster with options <code>values=TRUE</code>, <code>stopiffalse=FALSE</code> and <code>showwarning=TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareRaster(x, ..., extent=TRUE, rowcol=TRUE, crs=TRUE, res=FALSE, orig=FALSE,
         rotation=TRUE, values=FALSE, tolerance, stopiffalse=TRUE, showwarning=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareRaster_+3A_x">x</code></td>
<td>
<p>Raster* object </p>
</td></tr>
<tr><td><code id="compareRaster_+3A_...">...</code></td>
<td>
<p>Raster* objects</p>
</td></tr>
<tr><td><code id="compareRaster_+3A_extent">extent</code></td>
<td>
<p>logical. If <code>TRUE</code>, bounding boxes are compared</p>
</td></tr>
<tr><td><code id="compareRaster_+3A_rowcol">rowcol</code></td>
<td>
<p>logical. If <code>TRUE</code>, number of rows and columns of the objects are compared</p>
</td></tr>
<tr><td><code id="compareRaster_+3A_crs">crs</code></td>
<td>
<p>logical. If <code>TRUE</code>, coordinate reference systems are compared.</p>
</td></tr>
<tr><td><code id="compareRaster_+3A_res">res</code></td>
<td>
<p>logical. If <code>TRUE</code>, resolutions are compared (redundant when checking extent and rowcol)</p>
</td></tr>
<tr><td><code id="compareRaster_+3A_orig">orig</code></td>
<td>
<p>logical. If <code>TRUE</code>, origins are compared</p>
</td></tr>
<tr><td><code id="compareRaster_+3A_rotation">rotation</code></td>
<td>
<p>logical. If <code>TRUE</code>, rotations are compared</p>
</td></tr>  
<tr><td><code id="compareRaster_+3A_values">values</code></td>
<td>
<p>logical. If <code>TRUE</code>, cell values are compared</p>
</td></tr>
<tr><td><code id="compareRaster_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric between 0 and 0.5. If not supplied, the default value is used (see <code><a href="#topic+rasterOptions">rasterOptions</a></code>. It sets difference (relative to the cell resolution) that is permissible for objects to be considered 'equal', if they have a non-integer origin or resolution. See <a href="Matrix.html#topic+all.equal">all.equal</a>. </p>
</td></tr>
<tr><td><code id="compareRaster_+3A_stopiffalse">stopiffalse</code></td>
<td>
<p>logical. If <code>TRUE</code>, an error will occur if the objects are not the same</p>
</td></tr>
<tr><td><code id="compareRaster_+3A_showwarning">showwarning</code></td>
<td>
<p>logical. If <code>TRUE</code>, an warning will be given if objects are not the same. Only relevant when <code>stopiffalse</code> is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- raster()
r2 &lt;- r1
r3 &lt;- r1
compareRaster(r1, r2, r3)
nrow(r3) &lt;- 10

# compareRaster(r1, r3)
compareRaster(r1, r3, stopiffalse=FALSE)
compareRaster(r1, r3, rowcol=FALSE)

all.equal(r1, r2)
all.equal(r1, r3)
</code></pre>

<hr>
<h2 id='contour'>Contour plot</h2><span id='topic+contour'></span><span id='topic+contour+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Contour plot of a RasterLayer. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
contour(x, maxpixels=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="contour_+3A_maxpixels">maxpixels</code></td>
<td>
<p>maximum number of pixels used to create the contours</p>
</td></tr>
<tr><td><code id="contour_+3A_...">...</code></td>
<td>
<p>any argument that can be passed to <code><a href="graphics.html#topic+contour">contour</a></code> (graphics package)</p>
</td></tr>  
</table>


<h3>See Also</h3>

 
<p><code><a href="#topic+persp">persp</a></code>, <code><a href="#topic+filledContour">filledContour</a></code>, <code><a href="#topic+rasterToContour">rasterToContour</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/test.grd", package="raster"))
plot(r)
contour(r, add=TRUE)
</code></pre>

<hr>
<h2 id='corLocal'>Local correlation coefficient</h2><span id='topic+corLocal'></span><span id='topic+corLocal+2CRasterLayer+2CRasterLayer-method'></span><span id='topic+corLocal+2CRasterStackBrick+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Local correlation coefficient for two RasterLayer objects (using a focal neighborhood) or for two RasterStack or Brick objects (with the same number of layers (&gt; 2))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,RasterLayer'
corLocal(x, y, ngb=5, 
     method=c("pearson", "kendall", "spearman"), test=FALSE, filename='', ...)


## S4 method for signature 'RasterStackBrick,RasterStackBrick'
corLocal(x, y,  
     method=c("pearson", "kendall", "spearman"), test=FALSE, filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corLocal_+3A_x">x</code></td>
<td>
<p>RasterLayer or RasterStack/RasterBrick</p>
</td></tr>
<tr><td><code id="corLocal_+3A_y">y</code></td>
<td>
<p>object of the same class as <code>x</code>, and with the same number of layers</p>
</td></tr>
<tr><td><code id="corLocal_+3A_ngb">ngb</code></td>
<td>
<p>neighborhood size. Either a single integer or a vector of two integers c(nrow, ncol)</p>
</td></tr>
<tr><td><code id="corLocal_+3A_method">method</code></td>
<td>
<p>character indicating which correlation coefficient is to be used. One of <code>"pearson"</code>, <code>"kendall"</code>, or <code>"spearman"</code></p>
</td></tr>
<tr><td><code id="corLocal_+3A_test">test</code></td>
<td>
<p>logical. If <code>TRUE</code>, return a p-value</p>
</td></tr> 
<tr><td><code id="corLocal_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="corLocal_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>Note</h3>

<p><code>NA</code> values are omitted</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+cor">cor</a></code>, <code><a href="stats.html#topic+cor.test">cor.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- stack(system.file("external/rlogo.grd", package="raster"))
b &lt;- aggregate(b, 2, mean)

set.seed(0)
b[[2]] &lt;- flip(b[[2]], 'y') + runif(ncell(b))
b[[1]] &lt;- b[[1]] + runif(ncell(b))

x &lt;- corLocal(b[[1]], b[[2]], test=TRUE )
# plot(x)

# only cells where the p-value &lt; 0.1
xm &lt;- mask(x[[1]], x[[2]] &lt; 0.1, maskvalue=FALSE)
plot(xm)


# for global correlation, use the cor function
x &lt;- as.matrix(b)
cor(x, method="spearman")
 
# use sampleRegular for large datasets
x &lt;- sampleRegular(b, 1000)
cor.test(x[,1], x[,2])

# RasterStack or Brick objects
y &lt;- corLocal(b, flip(b, 'y'))
</code></pre>

<hr>
<h2 id='cover'> Replace NA values with values of other layers </h2><span id='topic+cover'></span><span id='topic+cover+2CRasterLayer+2CRasterLayer-method'></span><span id='topic+cover+2CRasterStackBrick+2CRaster-method'></span><span id='topic+cover+2CSpatialPolygons+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>For Raster* objects: Replace <code>NA</code> values in the first Raster object (<code>x</code>) with the values of the second (<code>y</code>), and so forth for additional Rasters. If <code>x</code> has multiple layers, the subsequent Raster objects should have the same number of layers, or have a single layer only (which will be recycled).
</p>
<p>For SpatialPolygons* objects: Areas of <code>x</code> that overlap with <code>y</code> are replaced by (or intersected with) <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,RasterLayer'
cover(x, y, ..., filename='')

## S4 method for signature 'RasterStackBrick,Raster'
cover(x, y, ..., filename='')

## S4 method for signature 'SpatialPolygons,SpatialPolygons'
cover(x, y, ..., identity=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cover_+3A_x">x</code></td>
<td>
<p>Raster* or SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="cover_+3A_y">y</code></td>
<td>
<p>Same as <code>x</code></p>
</td></tr>
<tr><td><code id="cover_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="cover_+3A_...">...</code></td>
<td>
<p>Same as <code>x</code>. If <code>x</code> is a Raster* object, also additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr> 
<tr><td><code id="cover_+3A_identity">identity</code></td>
<td>
<p>logical. If <code>TRUE</code> overlapping areas are intersected rather than replaced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick object, or SpatialPolygons object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># raster objects
r1 &lt;- raster(ncols=36, nrows=18)
values(r1) &lt;- 1:ncell(r1)
r2 &lt;- setValues(r1, runif(ncell(r1)))
r2[r2 &lt; 0.5] &lt;- NA
r3 &lt;- cover(r2, r1)


#SpatialPolygons
p &lt;- shapefile(system.file("external/lux.shp", package="raster"))
b &lt;- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
crs(b) &lt;- crs(p)
b &lt;- SpatialPolygonsDataFrame(b, data.frame(ID_1=9))
	
cv1 &lt;- cover(p, b)
cv2 &lt;- cover(p, b, identity=TRUE)

</code></pre>

<hr>
<h2 id='crop'>Crop</h2><span id='topic+crop'></span><span id='topic+crop+2CRaster-method'></span><span id='topic+crop+2CSpatial-method'></span><span id='topic+crop+2CRaster+2CANY-method'></span><span id='topic+crop+2CSpatial+2CANY-method'></span>

<h3>Description</h3>

<p>crop returns a geographic subset of an object as specified by an Extent object (or object from which an extent object can be extracted/created). 
If <code>x</code> is a Raster* object, the Extent is aligned to <code>x</code>. Areas included in <code>y</code> but outside the extent of <code>x</code> are ignored (see <code><a href="#topic+extend">extend</a></code> if you want a larger area).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
crop(x, y, filename="", snap='near', datatype=NULL, ...)

## S4 method for signature 'Spatial'
crop(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_+3A_x">x</code></td>
<td>
<p>Raster* object or SpatialPolygons*, SpatialLines*, or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="crop_+3A_y">y</code></td>
<td>
<p>Extent object, or any object from which an Extent object can be extracted (see Details)</p>
</td></tr>
<tr><td><code id="crop_+3A_filename">filename</code></td>
<td>
<p>Character, output filename. Optional</p>
</td></tr>
<tr><td><code id="crop_+3A_snap">snap</code></td>
<td>
<p>Character. One of 'near', 'in', or 'out', for use with <code><a href="#topic+alignExtent">alignExtent</a></code></p>
</td></tr>  
<tr><td><code id="crop_+3A_datatype">datatype</code></td>
<td>
<p>Character. Output <code><a href="#topic+dataType">dataType</a></code> (by default it is the same as the input datatype)</p>
</td></tr>  
<tr><td><code id="crop_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Objects from which an Extent can be extracted/created include RasterLayer, RasterStack, RasterBrick and objects of the Spatial* classes from the sp package. You can check this with the <code><a href="#topic+extent">extent</a></code> function. New Extent objects can also be created with function <code><a href="#topic+extent">extent</a></code> and <code><a href="#topic+drawExtent">drawExtent</a></code> by clicking twice on a plot.
</p>
<p>To crop by row and column numbers you can create an extent like this (for Raster <code>x</code>, row 5 to 10, column 7 to 12)
<code>crop(x, extent(x, 5, 10, 7, 12))</code>
</p>


<h3>Value</h3>

<p>RasterLayer or RasterBrick object; or SpatialLines or SpatialPolygons object.
</p>


<h3>Note</h3>

<p>values within the extent of a Raster* object can be set to NA with <a href="#topic+mask">mask</a></p>


<h3>See Also</h3>

 
<p><code><a href="#topic+extend">extend</a></code>, <code><a href="#topic+merge">merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=45, ncol=90)
values(r) &lt;- 1:ncell(r)
e &lt;- extent(-160, 10, 30, 60)
rc &lt;- crop(r, e)	

# use row and column numbers:
rc2 &lt;- crop(r, extent(r, 5, 10, 7, 15))

# crop Raster* with Spatial* object
b &lt;- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
crs(b) &lt;- crs(r)
rb &lt;- crop(r, b)

# crop a SpatialPolygon* object with another one
p &lt;- shapefile(system.file("external/lux.shp", package="raster"))
pb &lt;- crop(p, b)
</code></pre>

<hr>
<h2 id='crosstab'>Cross-tabulate</h2><span id='topic+crosstab'></span><span id='topic+crosstab+2CRaster+2CRaster-method'></span><span id='topic+crosstab+2CRasterStackBrick+2Cmissing-method'></span>

<h3>Description</h3>

<p>Cross-tabulate two RasterLayer objects, or mulitiple layers in a RasterStack or RasterBrick to create a contingency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,Raster'
crosstab(x, y, digits=0, long=FALSE, useNA=FALSE, progress='', ...)

## S4 method for signature 'RasterStackBrick,missing'
crosstab(x, digits=0, long=FALSE, useNA=FALSE, progress='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosstab_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="crosstab_+3A_y">y</code></td>
<td>
<p>Raster* object if <code>x</code> is a RasterLayer; Can be missing if <code>x</code> is a RasterStack or RasterBrick</p>
</td></tr>
<tr><td><code id="crosstab_+3A_digits">digits</code></td>
<td>
<p>integer. The number of digits for rounding the values before cross-tabulation</p>
</td></tr>
<tr><td><code id="crosstab_+3A_long">long</code></td>
<td>
<p>logical. If <code>TRUE</code> the results are returned in 'long' format data.frame instead of a table</p>
</td></tr>
<tr><td><code id="crosstab_+3A_usena">useNA</code></td>
<td>
<p>logical, indicting if the table should includes counts of <code>NA</code> values</p>
</td></tr>
<tr><td><code id="crosstab_+3A_progress">progress</code></td>
<td>
<p>character. &quot;text&quot;, &quot;window&quot;, or &quot;&quot; (the default, no progress bar), only for large files that cannot be processed in one step</p>
</td></tr>
<tr><td><code id="crosstab_+3A_...">...</code></td>
<td>
<p>additional arguments. none implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table or data.frame
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+freq">freq</a></code>, <code><a href="#topic+zonal">zonal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nc=5, nr=5)
values(r) &lt;- runif(ncell(r)) * 2
s &lt;- setValues(r, runif(ncell(r)) * 3)
crosstab(r,s)

rs &lt;- r/s
r[1:5] &lt;- NA
s[20:25] &lt;- NA
x &lt;- stack(r, s, rs)
crosstab(x, useNA=TRUE, long=TRUE)
</code></pre>

<hr>
<h2 id='cut'>Convert values to classes</h2><span id='topic+cut'></span><span id='topic+cut+2CRaster-method'></span>

<h3>Description</h3>

<p>Cut uses the base function <code><a href="base.html#topic+cut">cut</a></code> to classify the values of a Raster* object according to which interval they fall in. The intervals are defined by the argument <code>breaks</code>. The leftmost interval corresponds to level one, the next leftmost to level two and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_+3A_x">x</code></td>
<td>
<p>A Raster* object</p>
</td></tr>
<tr><td><code id="cut_+3A_...">...</code></td>
<td>
<p>additional arguments. See <a href="base.html#topic+cut">cut</a></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>See Also</h3>

 <p><code> <a href="#topic+subs">subs</a>, <a href="#topic+reclassify">reclassify</a>, <a href="#topic+calc">calc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- raster(ncols=36, nrows=18)
values(r) &lt;- rnorm(ncell(r)) 
breaks &lt;- -2:2 * 3
rc &lt;- cut(r, breaks=breaks)
</code></pre>

<hr>
<h2 id='cv'>Coefficient of variation</h2><span id='topic+cv'></span><span id='topic+cv+2CANY-method'></span><span id='topic+cv+2CRaster-method'></span>

<h3>Description</h3>

<p>Compute the coefficient of variation (expressed as a percentage). If there is only a single value, <code>sd</code> is <code>NA</code> and <code>cv</code> returns <code>NA</code> if <code>aszero=FALSE</code> (the default). However, if (<code>aszero=TRUE</code>), <code>cv</code> returns <code>0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
cv(x, ..., aszero=FALSE, na.rm = FALSE)

## S4 method for signature 'Raster'
cv(x, ..., aszero=FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_+3A_x">x</code></td>
<td>
<p>A vector of numbers (typically integers for modal), or a Raster* object</p>
</td></tr>
<tr><td><code id="cv_+3A_...">...</code></td>
<td>
<p>additional (vectors of) numbers, or Raster objects</p>
</td></tr>
<tr><td><code id="cv_+3A_aszero">aszero</code></td>
<td>
<p>logical. If <code>TRUE</code>, a zero is returned (rather than an NA) if the cv of single value is computed</p>
</td></tr>
<tr><td><code id="cv_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove (ignore) NA values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or RasterLayer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- c(0,1,2,3,3,3,3,4,4,4,5,5,6,7,7,8,9,NA)
cv(data, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='datasource'>Are values in memory and/or on disk?</h2><span id='topic+fromDisk'></span><span id='topic+inMemory'></span><span id='topic+inMemory+2CBasicRaster-method'></span><span id='topic+hasValues'></span><span id='topic+hasValues+2CBasicRaster-method'></span>

<h3>Description</h3>

 
<p>These are helper functions for programmers and for debugging that provide information about whether a Raster object has associated values, and if these are in memory or on disk. 
</p>
<p><code>fromDisk</code> is <code>TRUE</code> if the data source is a file on disk; and <code>FALSE</code> if the object only exists in memory. 
</p>
<p><code>inMemory</code>i is <code>TRUE</code> if all values are currently in memory (RAM); and <code>FALSE</code> if not (in which case they either are on disk, or there are no values).
</p>
<p><code>hasValues</code> is <code>TRUE</code> if the object has cell values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromDisk(x)
## S4 method for signature 'BasicRaster'
inMemory(x)
## S4 method for signature 'BasicRaster'
hasValues(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datasource_+3A_x">x</code></td>
<td>
<p> Raster* object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs &lt;- raster(system.file("external/test.grd", package="raster"))
inMemory(rs)
fromDisk(rs)
rs &lt;- readAll(rs)
inMemory(rs)
fromDisk(rs)
rs &lt;- rs + 1
inMemory(rs)
fromDisk(rs)
rs &lt;- raster(rs)
inMemory(rs)
fromDisk(rs)
rs &lt;- setValues(rs, 1:ncell(rs))
inMemory(rs)
fromDisk(rs)
#rs &lt;- writeRaster(rs, filename=rasterTmpFile(), overwrite=TRUE)
#inMemory(rs)
#fromDisk(rs)
</code></pre>

<hr>
<h2 id='dataType'>Data type </h2><span id='topic+dataType'></span><span id='topic+dataType+3C-'></span>

<h3>Description</h3>

<p>Get the datatype of a RasterLayer object. The datatype determines the interpretation of values written to disk. 
Changing the datatype of a Raster* object does not directly affect the way they are stored in memory. For native file formats (.grd/.gri files) it does affect how values are read from file. This is not the case for file formats that are read via GDAL (such as .tif and .img files) or netcdf.
</p>
<p>If you change the datatype of a RasterLayer and then read values from a native format file these may be completely wrong, so only do this for debugging or when the information in the header file was wrong. To set the datatype of a new file, you can give a 'datatype' argument to the functions that write values to disk (e.g. <code><a href="#topic+writeRaster">writeRaster</a></code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataType(x)
dataType(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataType_+3A_x">x</code></td>
<td>
<p> A <code>RasterLayer</code> object </p>
</td></tr>
<tr><td><code id="dataType_+3A_value">value</code></td>
<td>
<p> A data type (see below) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting the data type is useful if you want to write values to disk. In other cases use functions such as round()
</p>
<p>Datatypes are described by 5 characters. The first three indicate whether the values are integers, decimal number or logical values. The fourth character indicates the number of bytes used to save the values on disk, and the last character indicates whether the numbers are signed (i.e. can be negative and positive values) or not (only zero and positive values allowed)
</p>
<p>The following datatypes are available:
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>Datatype definition</b> </td><td style="text-align: left;"> <b>minimum possible value</b> </td><td style="text-align: left;"> <b>maximum possible value</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>LOG1S</code> </td><td style="text-align: left;"> FALSE (0)</td><td style="text-align: left;"> TRUE (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>INT1S</code> </td><td style="text-align: left;"> -127 </td><td style="text-align: left;">  127 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>INT1U</code> </td><td style="text-align: left;"> 0 </td><td style="text-align: left;">  255 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>INT2S</code> </td><td style="text-align: left;"> -32,767</td><td style="text-align: left;">  32,767 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>INT2U</code> </td><td style="text-align: left;"> 0 </td><td style="text-align: left;">  65,534 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>INT4S</code> </td><td style="text-align: left;"> -2,147,483,647 </td><td style="text-align: left;"> 2,147,483,647 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>INT4U</code> </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 4,294,967,296 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>FLT4S</code> </td><td style="text-align: left;"> -3.4e+38 </td><td style="text-align: left;">  3.4e+38 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>FLT8S</code> </td><td style="text-align: left;"> -1.7e+308 </td><td style="text-align: left;">   1.7e+308 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>For all integer types, except the single byte types, the lowest (signed) or highest (unsigned) value is used to store <code>NA</code>. Single byte files do not have <code>NA</code> values. Logical values are stored as signed single byte integers, they do have an <code>NA</code> value (-127)
</p>
<p><code>INT4U</code> is available but they are best avoided as R does not support 32-bit unsigned integers.
</p>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(system.file("external/test.grd", package="raster"))
dataType(r)
## Not run: 
s &lt;- writeRaster(r, 'new.grd', datatype='INT2U', overwrite=TRUE)
dataType(s)

## End(Not run)
</code></pre>

<hr>
<h2 id='density'>Density plot</h2><span id='topic+density'></span><span id='topic+density+2CRaster-method'></span>

<h3>Description</h3>

<p>Create density plots of values in a Raster object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
density(x, layer, maxpixels=100000, plot=TRUE, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_+3A_x">x</code></td>
<td>
<p>Raster object</p>
</td></tr>
<tr><td><code id="density_+3A_layer">layer</code></td>
<td>
<p>numeric. Can be used to subset the layers to plot in a multilayer object (RasterBrick or RasterStack)</p>
</td></tr>
<tr><td><code id="density_+3A_maxpixels">maxpixels</code></td>
<td>
<p>the maximum number of (randomly sampled) cells to be used for creating the plot</p>
</td></tr>
<tr><td><code id="density_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> produce a plot, else return a density object</p>
</td></tr>
<tr><td><code id="density_+3A_main">main</code></td>
<td>
<p>main title for each plot (can be missing)</p>
</td></tr>
<tr><td><code id="density_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to base plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density plot (and a density object, returned invisibly if <code>plot=TRUE)</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logo &lt;- stack(system.file("external/rlogo.grd", package="raster")) 
density(logo)
</code></pre>

<hr>
<h2 id='dim'>Dimensions of a Raster* object</h2><span id='topic+dim'></span><span id='topic+dim+2CRasterStackBrick-method'></span><span id='topic+dim+2CBasicRaster-method'></span><span id='topic+dim+3C-+2CBasicRaster-method'></span><span id='topic+dim+3C-+2CRasterLayer-method'></span><span id='topic+dim+3C-+2CRasterBrick-method'></span>

<h3>Description</h3>

<p>Get or set the number of rows, columns, and layers of a Raster* object. You cannot use this function to set the dimensions of a RasterStack object.
</p>
<p>When setting the dimensions, you can provide a row number, or a vector with the row and the column number (for a RasterLayer and a RasterBrick), or a row and column number and the number of layers (only for a RasterBrick)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BasicRaster'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_+3A_x">x</code></td>
<td>
<p>Raster(* object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer or Raster* object
</p>


<h3>See Also</h3>

 <p><code> <a href="#topic+ncell">ncell</a>, <a href="#topic+extent">extent</a>, <a href="#topic+res">res</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
dim(r)
dim(r) &lt;- c(18) 
dim(r)
dim(r) &lt;- c(18, 36) 
dim(r)
b &lt;- brick(r)
dim(b)
dim(b) &lt;- c(10, 10, 5)
dim(b)
</code></pre>

<hr>
<h2 id='direction'>Direction</h2><span id='topic+direction'></span><span id='topic+direction+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>The direction (azimuth) to or from the nearest cell that is not <code>NA</code>. The direction unit is in radians, unless you use argument <code>degrees=TRUE</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
direction(x, filename='', degrees=FALSE, from=FALSE, doEdge=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direction_+3A_x">x</code></td>
<td>
<p>RasterLayer object</p>
</td></tr>
<tr><td><code id="direction_+3A_filename">filename</code></td>
<td>
<p>Character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="direction_+3A_degrees">degrees</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default) the unit of direction is radians.</p>
</td></tr>
<tr><td><code id="direction_+3A_from">from</code></td>
<td>
<p>Logical. Default is <code>FALSE</code>. If <code>TRUE</code>, the direction from (instead of to)  the nearest cell that is not <code>NA</code> is returned</p>
</td></tr>
<tr><td><code id="direction_+3A_doedge">doEdge</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the <code><a href="#topic+boundaries">boundaries</a></code> function is called first. This may be efficient in cases where you compute the distance to large blobs. Calling <code>boundaries</code> determines the edge cells that matter for direction computation</p>
</td></tr>
<tr><td><code id="direction_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>,  <code><a href="#topic+gridDistance">gridDistance</a></code>
</p>
<p>For the direction between (longitude/latitude) points, see the <code>azimuth</code> function in the <code>geosphere</code> package 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=36,nrow=18)
values(r) &lt;- NA
r[306] &lt;- 1
b &lt;- direction(r) 
#plot(b)
</code></pre>

<hr>
<h2 id='disaggregate'>Disaggregate</h2><span id='topic+disaggregate'></span><span id='topic+disaggregate+2CRaster-method'></span>

<h3>Description</h3>

<p>Disaggregate a RasterLayer to create a new RasterLayer with a higher resolution (smaller cells). The values in the new RasterLayer are the same as in the larger original cells unless you specify <code>method="bilinear"</code>, in which case values are locally interpolated (using the <code><a href="#topic+resample">resample</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
disaggregate(x, fact=NULL, method='', filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disaggregate_+3A_x">x</code></td>
<td>
<p>a Raster object</p>
</td></tr>
<tr><td><code id="disaggregate_+3A_fact">fact</code></td>
<td>
<p>integer. amount of disaggregation expressed as number of cells (horizontally and vertically). This can be a single integer or two integers c(x,y), in which case the first one is the horizontal disaggregation factor and y the vertical disaggreation factor. If a single integer value is supplied, cells are disaggregated with the same factor in x and y direction</p>
</td></tr>
<tr><td><code id="disaggregate_+3A_method">method</code></td>
<td>
<p>Character. <code>''</code> or <code>'bilinear'</code>. If <code>'bilinear'</code>, values are locally interpolated (using the <code><a href="#topic+resample">resample</a></code> function</p>
</td></tr>
<tr><td><code id="disaggregate_+3A_filename">filename</code></td>
<td>
<p>Character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="disaggregate_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster object
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Jim Regetz</p>


<h3>See Also</h3>

 <p><code><a href="#topic+aggregate">aggregate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=10, nrows=10)
rd &lt;- disaggregate(r, fact=c(10, 2))
ncol(rd)
nrow(rd)
values(r) &lt;- 1:ncell(r)
rd &lt;- disaggregate(r, fact=c(4, 2), method='bilinear')

</code></pre>

<hr>
<h2 id='distance'>Distance</h2><span id='topic+distance'></span><span id='topic+distance+2CRasterLayer+2Cmissing-method'></span><span id='topic+distance+2CRasterLayer+2CRasterLayer-method'></span><span id='topic+distance+2CSpatial+2CSpatial-method'></span>

<h3>Description</h3>

<p>For a single <code>RasterLayer</code> (<code>y</code> is missing) this method computes the distance, for all cells that are <code>NA</code>, to the nearest cell that is not <code>NA</code>.
The distance unit is in meters if the RasterLayer is not projected (<code>+proj=longlat</code>) and in map units (typically also meters) when it is projected.
</p>
<p>If two <code>RasterLayer</code> objects are provided, the cell-value distances are computed. 
If two <code>Spatial</code> vector type objects are provided, the distances between pairs of geographic object are computed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,missing'
distance(x, y, filename='', doEdge=TRUE, ...)
## S4 method for signature 'RasterLayer,RasterLayer'
distance(x, y, ...)
## S4 method for signature 'Spatial,Spatial'
distance(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_x">x</code></td>
<td>
<p>RasterLayer object</p>
</td></tr>
<tr><td><code id="distance_+3A_y">y</code></td>
<td>
<p>missing, RasterLayer or Spatial object</p>
</td></tr>
<tr><td><code id="distance_+3A_filename">filename</code></td>
<td>
<p>Character. Filename for the output RasterLayer (optional)</p>
</td></tr>
<tr><td><code id="distance_+3A_doedge">doEdge</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the <code><a href="#topic+boundaries">boundaries</a></code> function is called first. This may be efficient in cases where you compute the distance to large blobs. Calling <code>boundaries</code> determines the edge cells that matter for distance computation</p>
</td></tr>
<tr><td><code id="distance_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer</p>


<h3>See Also</h3>

<p><code><a href="#topic+distanceFromPoints">distanceFromPoints</a></code>,  <code><a href="#topic+gridDistance">gridDistance</a></code>,  <code><a href="#topic+pointDistance">pointDistance</a></code>  
</p>
<p>See the <code>gdistance</code> package for more advanced distances, and the <code>geosphere</code> package for great-circle distances (and more) between points in longitude/latitude coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=36,nrow=18)
values(r) &lt;- NA
r[500] &lt;- 1
dist &lt;- distance(r) 
#plot(dist / 1000)
</code></pre>

<hr>
<h2 id='distanceFromPoints'>Distance from points</h2><span id='topic+distanceFromPoints'></span>

<h3>Description</h3>

<p>The function calculates the distance from a set of points to all cells of a Raster* object.
</p>
<p>The distance unit is in meters if the coordinate reference system (crs) of the Raster* object is (<code>+proj=longlat</code>) or assumed to be if the crs is <code>NA</code>. In all other cases it is in the units defined by the crs (which typically is meters). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceFromPoints(object, xy, filename='', ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceFromPoints_+3A_object">object</code></td>
<td>
<p>Raster object</p>
</td></tr>
<tr><td><code id="distanceFromPoints_+3A_xy">xy</code></td>
<td>
<p>matrix of x and y coordinates, or a SpatialPoints* object.</p>
</td></tr>
<tr><td><code id="distanceFromPoints_+3A_filename">filename</code></td>
<td>
<p>character. Optional filename for the output RasterLayer</p>
</td></tr>
<tr><td><code id="distanceFromPoints_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Distances for <code>longlat</code> data are computed on the WGS84 spheroid using GeographicLib (Karney, 2013)
</p>


<h3>Value</h3>

<p>RasterLayer</p>


<h3>References</h3>

<p>C.F.F. Karney, 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+crs">crs</a></code>, <code><a href="#topic+distance">distance</a></code>,  <code><a href="#topic+gridDistance">gridDistance</a></code>,  <code><a href="#topic+pointDistance">pointDistance</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=36,nrow=18)
xy &lt;- c(0,0)
d1 &lt;- distanceFromPoints(r, xy) 
crs(r) = '+proj=utm +zone=12 +datum=WGS84'
d2 &lt;- distanceFromPoints(r, xy) 
par(mfrow=c(1,2))
plot(d1)
plot(d2)
</code></pre>

<hr>
<h2 id='draw'> Draw a line or polygon </h2><span id='topic+drawPoly'></span><span id='topic+drawLine'></span>

<h3>Description</h3>

<p>Draw a line or polygon on a plot (map) and save it for later use. After calling the function, start clicking on the map. To finish, right-click and select 'stop'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawPoly(sp=TRUE, col='red', lwd=2, ...)
drawLine(sp=TRUE, col='red', lwd=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_+3A_sp">sp</code></td>
<td>
<p>logical. If <code>TRUE</code>, the output will be a sp object (SpatialPolygons or SpatialLines). Otherwise a matrix of coordinates is returned</p>
</td></tr>  
<tr><td><code id="draw_+3A_col">col</code></td>
<td>
<p>the color of the lines to be drawn</p>
</td></tr>
<tr><td><code id="draw_+3A_lwd">lwd</code></td>
<td>
<p>the width of the lines to be drawn</p>
</td></tr>
<tr><td><code id="draw_+3A_...">...</code></td>
<td>
<p>additional arguments padded to locator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>sp==TRUE</code> a SpatialPolygons or SpatialLines object; otherwise a matrix of coordinates
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+locator">locator</a></code>  </p>

<hr>
<h2 id='drawExtent'> Create an Extent object by drawing on a map</h2><span id='topic+drawExtent'></span>

<h3>Description</h3>

<p>Click on two points of a plot (map) to obtain an object of class <code><a href="#topic+Extent">Extent</a></code> ('bounding box')  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawExtent(show=TRUE, col="red") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawExtent_+3A_show">show</code></td>
<td>
<p>logical. If <code>TRUE</code>, the extent will be drawn on the map</p>
</td></tr>  
<tr><td><code id="drawExtent_+3A_col">col</code></td>
<td>
<p>sets the color of the lines of the extent </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extent
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
r1 &lt;- raster(nrow=10, ncol=10)
values(r1) &lt;- runif(ncell(r1))
plot(r1)
# after running the following line, click on the map twice
e &lt;- drawExtent()
# after running the following line, click on the map twice
mean(values(crop(r1, drawExtent())))

## End(Not run)
</code></pre>

<hr>
<h2 id='erase'> 
Erase parts of a SpatialPolygons* or SpatialLines* object. The inverse of this can be done with <code><a href="#topic+intersect">intersect</a></code>
</h2><span id='topic+erase'></span><span id='topic+erase+2CSpatialPolygons+2CSpatialPolygons-method'></span><span id='topic+erase+2CSpatialLines+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Erase parts of a SpatialPolygons* or SpatialLines* object with a SpatialPolygons* object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatialPolygons,SpatialPolygons'
erase(x, y, ...)

## S4 method for signature 'SpatialLines,SpatialPolygons'
erase(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erase_+3A_x">x</code></td>
<td>
<p>SpatialPolygons or SpatialLines object</p>
</td></tr>
<tr><td><code id="erase_+3A_y">y</code></td>
<td>
<p>SpatialPolygons object</p>
</td></tr>
<tr><td><code id="erase_+3A_...">...</code></td>
<td>
<p>Additional arguments (none)</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Spatial*
</p>


<h3>See Also</h3>

<p>The equivalent for raster data is <code><a href="#topic+mask">mask</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># erase parts of polygons with other polygons
p &lt;- shapefile(system.file("external/lux.shp", package="raster"))
b &lt;- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
crs(b) &lt;- crs(p)
e &lt;- erase(p, b)
plot(e)

	
# erase parts of lines with polygons	
	r &lt;- raster(extent(p) +c(-.1,.1,-.1,.1), crs=crs(p))
	start &lt;- xyFromCell(r, cellFromCol(r, 1))
	end &lt;- xyFromCell(r, cellFromCol(r, ncol(r)))
	lines &lt;- do.call(spLines, lapply(1:10, function(i)rbind(start[i,], end[i,])))
	crs(lines) &lt;- crs(p)
	
	e2 &lt;- erase(lines, p)
	plot(p)
	lines(lines, col='blue', lwd=4, lty=3)
	lines(e2, col='red', lwd=2)
</code></pre>

<hr>
<h2 id='extend'>Extend</h2><span id='topic+extend'></span><span id='topic+extend+2CRaster-method'></span><span id='topic+extend+2CExtent-method'></span>

<h3>Description</h3>

<p>Extend returns an Raster* object with a larger spatial extent. The output Raster object has the outer minimum and maximum coordinates of the input Raster and Extent arguments. Thus, all of the cells of the original raster are included. See <code><a href="#topic+crop">crop</a></code> if you (also) want to remove rows or columns. 
</p>
<p>There is also an extend method for Extent objects to enlarge (or reduce) an Extent. You can also use algebraic notation to do that (see examples).
</p>
<p>This function has replaced function &quot;expand&quot; (to avoid a name conflict with the Matrix package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
extend(x, y, value=NA, snap="near", filename='', ...) 

## S4 method for signature 'Extent'
extend(x, y, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_+3A_x">x</code></td>
<td>
<p>Raster or Extent object</p>
</td></tr>
<tr><td><code id="extend_+3A_y">y</code></td>
<td>
<p>If <code>x</code> is a Raster object, <code>y</code> should be an Extent object, or any object that is or has an Extent object, or an object from which it can be extracted (such as sp objects). Alternatively, you can provide a numeric vector of length 2 indicating the number of rows and columns that need to be added (or a single number when the number of rows and columns is equal)
</p>
<p>If <code>x</code> is an Extent object, <code>y</code> should be a numeric vector of 1, 2, or 4 elements</p>
</td></tr>
<tr><td><code id="extend_+3A_value">value</code></td>
<td>
<p>value to assign to new cells</p>
</td></tr>  
<tr><td><code id="extend_+3A_snap">snap</code></td>
<td>
<p>Character. One of &quot;near&quot;, &quot;in&quot;, or &quot;out&quot;, to determine in which direction the extent should be aligned. To the nearest border, inwards or outwards</p>
</td></tr>  
<tr><td><code id="extend_+3A_filename">filename</code></td>
<td>
<p>Character (optional)</p>
</td></tr>  
<tr><td><code id="extend_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick, or Extent
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Etienne B. Racine (Extent method)</p>


<h3>See Also</h3>

<p><code><a href="#topic+crop">crop</a></code>, <code><a href="#topic+merge">merge</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(xmn=-150, xmx=-120, ymx=60, ymn=30, ncol=36, nrow=18)
values(r) &lt;- 1:ncell(r)
e &lt;- extent(-180, 0, 0, 90)
re &lt;- extend(r, e)

# extend with a number of rows and columns (at each side)
re2 &lt;- extend(r, c(2,10))

# Extent object
e &lt;- extent(r)
e
extend(e, 10)
extend(e, 10, -10, 0, 20)
e + 10
e * 2
</code></pre>

<hr>
<h2 id='extension'>Filename extensions</h2><span id='topic+extension'></span><span id='topic+extension+3C-'></span>

<h3>Description</h3>

<p>Get or change a filename extension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extension(filename, value=NULL, maxchar=10)
extension(filename) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extension_+3A_filename">filename</code></td>
<td>
<p>A filename, with or without the path</p>
</td></tr>
<tr><td><code id="extension_+3A_value">value</code></td>
<td>
<p>A file extension with or without a dot, e.g., &quot;.txt&quot; or &quot;txt&quot;</p>
</td></tr>
<tr><td><code id="extension_+3A_maxchar">maxchar</code></td>
<td>
<p>Maximum number of characters after the last dot in the filename, for that string to be considered a filename extension </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A file extension, filename or path.  
</p>
<p>If <code>ext(filename)</code> is used without a <code>value</code> argument, it returns the file extension; otherwise it returns the filename (with new extensions set to <code>value</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- "c:/temp folder/filename.exten sion"
extension(fn)
extension(fn) &lt;- ".txt"
extension(fn)
fn &lt;- extension(fn, '.document')
extension(fn)
extension(fn, maxchar=4)
</code></pre>

<hr>
<h2 id='extent'>Extent</h2><span id='topic+extent'></span><span id='topic+extent+2CExtent-method'></span><span id='topic+extent+2CBasicRaster-method'></span><span id='topic+extent+2CSpatial-method'></span><span id='topic+extent+2Csf-method'></span><span id='topic+extent+2Cbbox-method'></span><span id='topic+extent+2Cmatrix-method'></span><span id='topic+extent+2Cnumeric-method'></span><span id='topic+extent+2Clist-method'></span><span id='topic+extent+2CGridTopology-method'></span><span id='topic+bbox+2CRaster-method'></span><span id='topic+bbox+2CExtent-method'></span>

<h3>Description</h3>

<p>This function returns an Extent object of a Raster* or Spatial* object (or an Extent object), or creates an 
Extent object from a 2x2 matrix (first row: xmin, xmax; second row: ymin, ymax), vector (length=4; order= xmin, xmax, ymin, ymax) or list (with at least two elements, with names 'x' and 'y')
</p>
<p><code>bbox</code> returns a <code>sp</code> package like 'bbox' object (a matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extent(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extent_+3A_x">x</code></td>
<td>
<p>Raster* or Extent object, a matrix, a bbox, or a vector of four numbers </p>
</td></tr> 
<tr><td><code id="extent_+3A_...">...</code></td>
<td>
<p>Additional arguments. When x is a single number representing 'xmin', you can pass three additional numbers (xmax, ymin, ymax)
</p>
<p>When <code>x</code> is a Raster* object, you can pass four additional arguments to crop the extent: <code>r1, r2, c1, c2</code>, representing the first and last row and column number </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extent object
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans; Etienne Racine wrote the extent function for a list</p>


<h3>See Also</h3>

 <p><code><a href="#topic+extent">extent</a></code>, <code><a href="#topic+drawExtent">drawExtent</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
extent(r)
extent(c(0, 20, 0, 20))
#is equivalent to
extent(0, 20, 0, 20)
extent(matrix(c(0, 0, 20, 20), nrow=2))
x &lt;- list(x=c(0,1,2), y=c(-3,5))
extent(x)

#crop the extent by row and column numbers
extent(r, 1, 20, 10, 30)
</code></pre>

<hr>
<h2 id='Extent+20math'>round Extent coordinates</h2><span id='topic+floor+2CExtent-method'></span><span id='topic+ceiling+2CExtent-method'></span>

<h3>Description</h3>

<p>use <code>round(x, digits=0)</code> to round the coordinates of an Extent object to the number of digits specified. This can be useful when dealing with a small imprecision in the data (e.g. 179.9999 instead of 180). <code>floor</code> and <code>ceiling</code> move the coordiantes to the outer or inner whole integer numbers.
</p>
<p>It is also possible to use Arithmetic functions with Extent objects (but these work perhaps unexpectedly!)
</p>
<p>See <code><a href="#topic+Math-methods">Math-methods</a></code> for these (and many more) methods with Raster* objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Extent'
floor(x)
## S4 method for signature 'Extent'
ceiling(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extent+2B20math_+3A_x">x</code></td>
<td>
<p>Extent object </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Math-methods">Math-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- extent(c(0.999999,  10.000011, -60.4, 60))
round(e)
ceiling(e)
floor(e)
</code></pre>

<hr>
<h2 id='Extent-class'>Class &quot;Extent&quot; </h2><span id='topic+Extent'></span><span id='topic+Extent-class'></span><span id='topic+show+2CExtent-method'></span>

<h3>Description</h3>

<p>Objects of class Extent are used to define the spatial extent (extremes) of objects of the BasicRaster and Raster* classes. 
</p>


<h3>Objects from the Class</h3>

<p>You can use the <code><a href="#topic+extent">extent</a></code> function to create Extent objects, or to extract them from Raster* and Spatial* objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>xmin</code>:</dt><dd><p>minimum x coordinate</p>
</dd>
<dt><code>xmax</code>:</dt><dd><p>maximum x coordinate</p>
</dd>
<dt><code>ymin</code>:</dt><dd><p>minumum y coordinate</p>
</dd>
<dt><code>ymax</code>:</dt><dd><p>maximum y coordinate</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p>display values of a Extent object </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+extent">extent</a></code>, <code><a href="#topic+setExtent">setExtent</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>ext &lt;- extent(-180,180,-90,90)
ext
</code></pre>

<hr>
<h2 id='extract'>Extract values from Raster objects</h2><span id='topic+extract'></span><span id='topic+extract+2CRaster+2Cvector-method'></span><span id='topic+extract+2CRaster+2Cmatrix-method'></span><span id='topic+extract+2CRaster+2Cdata.frame-method'></span><span id='topic+extract+2CRaster+2CSpatialPoints-method'></span><span id='topic+extract+2CRaster+2CSpatialLines-method'></span><span id='topic+extract+2CRaster+2CSpatialPolygons-method'></span><span id='topic+extract+2CRaster+2Csf-method'></span><span id='topic+extract+2CRaster+2CExtent-method'></span><span id='topic+extract+2CSpatialPolygons+2CSpatialPoints-method'></span><span id='topic+extract+2CSpatialPolygons+2Cdata.frame-method'></span><span id='topic+extract+2CSpatialPolygons+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Extract values from a Raster* object at the locations of spatial vector data. There are methods for points, lines, and polygons (classes from 'sp' or 'sf'), for a matrix or data.frame of points. You can also use cell numbers and Extent (rectangle) objects to extract values. 
</p>
<p>If <code>y</code> represents points, <code>extract</code> returns the values of a Raster* object for the cells in which a set of points fall.
If <code>y</code> represents lines, the <code>extract</code> method returns the values of the cells of a Raster* object that are touched by a line. If <code>y</code> represents polygons, the <code>extract</code> method returns the values of the cells of a Raster* object that are covered by a polygon. A cell is covered if its center is inside the polygon (but see the <code>weights</code> option for considering partly covered cells; and argument <code>small</code> for getting values for small polygons).
</p>
<p>It is also possible to extract values for point locations from SpatialPolygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,matrix'
extract(x, y, method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE, 
   fun=NULL, na.rm=TRUE, layer, nl, df=FALSE, factors=FALSE, ...)

## S4 method for signature 'Raster,SpatialLines'
extract(x, y, fun=NULL, na.rm=FALSE, cellnumbers=FALSE, df=FALSE, layer,
   nl, factors=FALSE, along=FALSE, sp=FALSE, ...)

## S4 method for signature 'Raster,SpatialPolygons'
extract(x, y, fun=NULL, na.rm=FALSE, exact=FALSE, weights=FALSE,  
   normalizeWeights=TRUE, cellnumbers=FALSE, small=TRUE, df=FALSE, layer, nl, 
   factors=FALSE, sp=FALSE, ...)


## S4 method for signature 'SpatialPolygons,SpatialPoints'
extract(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="extract_+3A_y">y</code></td>
<td>
<p>points represented by a two-column matrix or data.frame, or <code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a>*</code>; <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a>*</code>; <code><a href="sp.html#topic+SpatialLines">SpatialLines</a></code>; <code>sf</code> spatial vector objects; <code><a href="#topic+Extent">Extent</a></code>; or a numeric vector representing cell numbers</p>
</td></tr>
<tr><td><code id="extract_+3A_method">method</code></td>
<td>
<p>character. <code>'simple'</code> or <code>'bilinear'</code>. If <code>'simple'</code> values for the cell a point falls in are returned. If <code>'bilinear'</code> the returned values are interpolated from the values of the four nearest raster cells.</p>
</td></tr>
<tr><td><code id="extract_+3A_buffer">buffer</code></td>
<td>
<p>numeric. The radius of a buffer around each point from which to extract cell values. If the distance between the sampling point and the center of a cell is less than or equal to the buffer, the cell is included. The buffer can be specified as a single value, or as a vector of the length of the number of points.  If the data are not projected (latitude/longitude), the unit should be meters. Otherwise it should be in map-units (typically also meters).</p>
</td></tr>  
<tr><td><code id="extract_+3A_small">small</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>y</code> represents points and a <code>buffer</code> argument is used, the function always return a number, also when the buffer does not include the center of a single cell. The value of the cell in which the point falls is returned if no cell center is within the buffer. If <code>y</code> represents polygons, a value is also returned for relatively small polygons (e.g. those smaller than a single cell of the Raster* object), or polygons with an odd shape, for which otherwise no values are returned because they do not cover any raster cell centers. In some cases, you could alternatively use the centroids of such polygons, for example using <code>extract(x, coordinates(y))</code> or <code>extract(x, coordinates(y), method='bilinear')</code>.</p>
</td></tr>
<tr><td><code id="extract_+3A_fun">fun</code></td>
<td>
<p>function to summarize the values (e.g. <code>mean</code>). The function should take a single numeric vector as argument and return a single value (e.g. mean, min or max), and accept a <code>na.rm</code> argument. Thus, standard R functions not including an na.rm argument must be wrapped as in this example: fun=function(x,...)length(x). If <code>y</code> represents points, <code>fun</code> is only used when a buffer is used (and hence multiple values per spatial feature would otherwise be returned).</p>
</td></tr> 
<tr><td><code id="extract_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Only useful when an argument <code>fun</code> is supplied. If <code>na.rm=TRUE</code> (the default value), NA values are removed before fun is applied. This argument may be ignored if the function used has a <code>...</code> argument and ignores an additional <code>na.rm</code> argument</p>
</td></tr>
<tr><td><code id="extract_+3A_cellnumbers">cellnumbers</code></td>
<td>
<p>logical. If <code>cellnumbers=TRUE</code>, cell-numbers will also be returned (if no <code>fun</code> argument is  supplied, and when extracting values with points, if <code>buffer</code> is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="extract_+3A_df">df</code></td>
<td>
<p>logical. If <code>df=TRUE</code>, results will be returned as a data.frame. The first column is a sequential ID, the other column(s) are the extracted values</p>
</td></tr>
<tr><td><code id="extract_+3A_exact">exact</code></td>
<td>
<p>logical. If <code>TRUE</code> the fraction of each cell that is (partly) covered by the polygon is extracted, not only the cells of which the centers are covered. This option is particularly useful if the polygons are small relative to the cells size of the Raster* object</p>
</td></tr>
<tr><td><code id="extract_+3A_weights">weights</code></td>
<td>
<p>logical. If <code>TRUE</code> the fraction of a cell that is covered is returned or used by <code>fun</code>. These can be used as weights can be used for averaging; see examples. If <code>exact</code> is <code>FALSE</code>, this is the approximate fraction of each cell that is covered by the polygon, rounded to 1/100 </p>
</td></tr>
<tr><td><code id="extract_+3A_normalizeweights">normalizeWeights</code></td>
<td>
<p>logical. If <code>TRUE</code>, weights are normalized such that they add up to one for each polygon</p>
</td></tr>
<tr><td><code id="extract_+3A_factors">factors</code></td>
<td>
<p>logical. If <code>TRUE</code>, factor values are returned, else their integer representation is returned</p>
</td></tr>
<tr><td><code id="extract_+3A_layer">layer</code></td>
<td>
<p>integer. First layer for which you want values (if <code>x</code> is a multilayer object)</p>
</td></tr>
<tr><td><code id="extract_+3A_nl">nl</code></td>
<td>
<p> integer. Number of layers for which you want values (if <code>x</code> is a multilayer object)</p>
</td></tr>
<tr><td><code id="extract_+3A_along">along</code></td>
<td>
<p> boolean. Should returned values be ordered to go along the lines?</p>
</td></tr>
<tr><td><code id="extract_+3A_sp">sp</code></td>
<td>
<p> boolean. Should the extracted values be added to the data.frame of the Spatial* object <code>y</code>? This only applies if <code>y</code> is a Spatial* object and, for SpatialLines and SpatialPolygons, if <code>fun</code> is not NULL. In this case the returned value is the expanded Spatial object</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A vector for RasterLayer objects, and a matrix for RasterStack or RasterBrick objects. A list (or a data.frame if <code>df=TRUE</code>) if <code>y</code> is a SpatialPolygons* or SpatialLines* object or if a <code>buffer</code> argument is used (but not a <code>fun</code> argument). If <code>sp=TRUE</code> and  <code>y</code> is a Spatial* object and  <code>fun</code> is not NULL a Spatial* object is returned. The order of the returned values corresponds to the order of object <code>y</code>. If <code>df=TRUE</code>, this is also indicated in the first variable ('ID').
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getValues">getValues</a>, <a href="#topic+getValuesFocal">getValuesFocal</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=36, nrow=18, vals=1:(18*36))

###############################
# extract values by cell number
###############################
extract(r, c(1:2, 10, 100))
s &lt;- stack(r, sqrt(r), r/r)
extract(s, c(1, 10, 100), layer=2, n=2)

###############################
# extract values with points
###############################
xy &lt;- cbind(-50, seq(-80, 80, by=20))
extract(r, xy)

sp &lt;- SpatialPoints(xy)
extract(r, sp, method='bilinear')

# examples with a buffer
extract(r, xy[1:3,], buffer=1000000)
extract(r, xy[1:3,], buffer=1000000, fun=mean)

## illustrating the varying size of a buffer (expressed in meters) 
## on a longitude/latitude raster
 z &lt;- extract(r, xy, buffer=1000000)
 s &lt;- raster(r)
 for (i in 1:length(z)) { s[z[[i]]] &lt;- i }
 
## compare with raster that is not longitude/latitude
 crs(r) &lt;- "+proj=utm +zone=17" 
 xy[,1] &lt;- 50
 z &lt;- extract(r, xy, buffer=8)
 for (i in 1:length(z)) { s[z[[i]]] &lt;- i }
 plot(s)
# library(maptools)
# data(wrld_simpl)
# plot(wrld_simpl, add=TRUE)

###############################
# extract values with lines
###############################
r &lt;- raster(ncol=36, nrow=18, vals=1:(18*36))
cds1 &lt;- rbind(c(-50,0), c(0,60), c(40,5), c(15,-45), c(-10,-25))
cds2 &lt;- rbind(c(80,20), c(140,60), c(160,0), c(140,-55))
lines &lt;- spLines(cds1, cds2)

extract(r, lines)

###############################
# extract values with polygons
###############################
cds1 &lt;- rbind(c(-180,-20), c(-160,5), c(-60, 0), c(-160,-60), c(-180,-20))
cds2 &lt;- rbind(c(80,0), c(100,60), c(120,0), c(120,-55), c(80,0))
polys &lt;- spPolygons(cds1, cds2)

v &lt;- extract(r, polys)
# mean for each polygon
unlist(lapply(v, function(x) if (!is.null(x)) mean(x, na.rm=TRUE) else NA ))

# v &lt;- extract(r, polys, cellnumbers=TRUE)

# weighted mean
# v &lt;- extract(r, polys, weights=TRUE, fun=mean)
# equivalent to:
# v &lt;- extract(r, polys, weights=TRUE)
# sapply(v, function(x) if (!is.null(x)) {sum(apply(x, 1, prod)) / sum(x[,2])} else NA)


###############################
# extract values with an extent
###############################
e &lt;- extent(150,170,-60,-40)
extract(r, e)
#plot(r)
#plot(e, add=T)
</code></pre>

<hr>
<h2 id='Extract+20by+20index'>Indexing to extract values of a Raster* object</h2><span id='topic++5B+5B+2CRaster+2CANY+2CANY-method'></span><span id='topic++5B+2CRaster+2CSpatial+2Cmissing-method'></span><span id='topic++5B+2CRaster+2CRasterLayer+2Cmissing-method'></span><span id='topic++5B+2CRaster+2CExtent+2Cmissing-method'></span><span id='topic++5B+2CRaster+2Cnumeric+2Cnumeric-method'></span><span id='topic++5B+2CRaster+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CRaster+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+2CRaster+2Cmatrix+2Cmissing-method'></span><span id='topic++5B+2CRaster+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CRaster+2Clogical+2Cmissing-method'></span><span id='topic++5B+2CExtent+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CExtent+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>These are shorthand methods that call other methods that should normally be used, such as <code><a href="#topic+getValues">getValues</a></code>, <code><a href="#topic+extract">extract</a></code>, <code><a href="#topic+crop">crop</a></code>. 
</p>
<p><code>object[i]</code> can be used to access values of a Raster* object, using cell numbers. You can also use row and column numbers as index, using <code>object[i,j]</code> or <code>object[i,]</code> or <code>object[,j]</code>. In addition you can supply an Extent, SpatialPolygons, SpatialLines or SpatialPoints object. 
</p>
<p>If <code>drop=TRUE</code> (the default) cell values are returned (a vector for a RasterLayer, a matrix for a RasterStack or RasterBrick). If <code>drop=FALSE</code> a Raster* object is returned that has the extent covering the requested cells, and with all other non-requested cells within this extent set to <code>NA</code>.
</p>
<p>If you supply a RasterLayer, its values will be used as logical (TRUE/FALSE) indices if both Raster objects have the same extent and resolution; otherwise the cell values within the extent of the RasterLayer are returned.
</p>
<p>Double brackes '[[ ]]' can be used to extract one or more layers from a multi-layer object.
</p>


<h3>Methods</h3>


<p><code>x[i]</code>
</p>
<p><code>x[i,j]</code>
</p>
<p>Arguments
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>x</code> </td><td style="text-align: left;"> a Raster* object </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>i</code> </td><td style="text-align: left;"> cell number(s), row number(s), a (logical) RasterLayer, Spatial* object </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>j</code> </td><td style="text-align: left;"> column number(s) (only available if i is (are) a row number(s)) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>drop</code> </td><td style="text-align: left;"> If <code>TRUE</code>, cell values are returned. Otherwise, a Raster* object is returned </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>See Also</h3>

 <p><code><a href="#topic+getValues">getValues</a>, <a href="#topic+setValues">setValues</a>, <a href="#topic+extract">extract</a>, <a href="#topic+crop">crop</a>, <a href="#topic+rasterize">rasterize</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=5)
values(r) &lt;- 1:ncell(r) 

r[1]
r[1:10]
r[1,]
r[,1]
r[1:2, 1:2]

s &lt;- stack(r, sqrt(r))
s[1:3]
s[[2]]

</code></pre>

<hr>
<h2 id='Extreme+20coordinates'>Coordinates of the Extent of a Raster object</h2><span id='topic+xmin'></span><span id='topic+xmax'></span><span id='topic+ymin'></span><span id='topic+ymax'></span><span id='topic+xmin+3C-'></span><span id='topic+xmax+3C-'></span><span id='topic+ymin+3C-'></span><span id='topic+ymax+3C-'></span><span id='topic+xmin+2CBasicRaster-method'></span><span id='topic+xmax+2CBasicRaster-method'></span><span id='topic+ymin+2CBasicRaster-method'></span><span id='topic+ymax+2CBasicRaster-method'></span><span id='topic+xmin+2CExtent-method'></span><span id='topic+xmax+2CExtent-method'></span><span id='topic+ymin+2CExtent-method'></span><span id='topic+ymax+2CExtent-method'></span><span id='topic+xmin+2CSpatial-method'></span><span id='topic+xmax+2CSpatial-method'></span><span id='topic+ymin+2CSpatial-method'></span><span id='topic+ymax+2CSpatial-method'></span><span id='topic+xmin+3C-+2CExtent+2Cnumeric-method'></span><span id='topic+xmin+3C-+2CBasicRaster+2Cnumeric-method'></span><span id='topic+xmax+3C-+2CExtent+2Cnumeric-method'></span><span id='topic+xmax+3C-+2CBasicRaster+2Cnumeric-method'></span><span id='topic+ymin+3C-+2CExtent+2Cnumeric-method'></span><span id='topic+ymin+3C-+2CBasicRaster+2Cnumeric-method'></span><span id='topic+ymax+3C-+2CExtent+2Cnumeric-method'></span><span id='topic+ymax+3C-+2CBasicRaster+2Cnumeric-method'></span>

<h3>Description</h3>

<p>These functions return or set the extreme coordinates of a Raster* object; and return them for Spatial* objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmin(x)
xmax(x)
ymin(x)
ymax(x)

xmin(x, ...) &lt;- value
xmax(x, ...) &lt;- value
ymin(x, ...) &lt;- value
ymax(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extreme+2B20coordinates_+3A_x">x</code></td>
<td>
<p>Raster* or Extent object</p>
</td></tr>
<tr><td><code id="Extreme+2B20coordinates_+3A_value">value</code></td>
<td>
<p>numeric. x or y coordinate</p>
</td></tr>  
<tr><td><code id="Extreme+2B20coordinates_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+extent">extent</a></code>,  <code><a href="#topic+dimensions">dimensions</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- raster(xmn=-0.5, xmx = 9.5, ncols=10)
xmin(r)
xmax(r)
ymin(r)
ymax(r)
xmin(r) &lt;- -180
xmax(r) &lt;- 180
</code></pre>

<hr>
<h2 id='extremeValues'>Minimum and maximum values</h2><span id='topic+minValue'></span><span id='topic+maxValue'></span><span id='topic+minValue+2CRasterLayer-method'></span><span id='topic+minValue+2CRasterStack-method'></span><span id='topic+minValue+2CRasterBrick-method'></span><span id='topic+maxValue+2CRasterLayer-method'></span><span id='topic+maxValue+2CRasterStack-method'></span><span id='topic+maxValue+2CRasterBrick-method'></span>

<h3>Description</h3>

<p>Returns the minimum or maximum value of a RasterLayer or layer in a RasterStack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minValue(x, ...)
maxValue(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extremeValues_+3A_x">x</code></td>
<td>
<p>RasterLayer or RasterStack object</p>
</td></tr>
<tr><td><code id="extremeValues_+3A_...">...</code></td>
<td>
<p>Additional argument: layer number (for RasterStack or RasterBrick objects) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a Raster* object is created from a file on disk, the min and max values are often not known (depending on the file format). You can use <code><a href="#topic+setMinMax">setMinMax</a></code> to set them in the Raster* object.
</p>


<h3>Value</h3>

<p>a number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
r &lt;- setValues(r, 1:ncell(r))
minValue(r)
maxValue(r)
r &lt;- setValues(r, round(100 * runif(ncell(r)) + 0.5))
minValue(r)
maxValue(r)

r &lt;- raster(system.file("external/test.grd", package="raster"))
minValue(r)
maxValue(r)
</code></pre>

<hr>
<h2 id='factors'>Factors</h2><span id='topic+is.factor'></span><span id='topic+is.factor+2CRaster-method'></span><span id='topic+is.factor+2CRasterStack-method'></span><span id='topic+as.factor'></span><span id='topic+as.factor+2CRasterLayer-method'></span><span id='topic+levels'></span><span id='topic+levels+2CRaster-method'></span><span id='topic+levels+2CRasterStack-method'></span><span id='topic+levels+3C-'></span><span id='topic+levels+3C-+2CRaster-method'></span><span id='topic+asFactor'></span><span id='topic+asFactor+2CRasterLayer-method'></span><span id='topic+factorValues'></span><span id='topic+ratify'></span><span id='topic+ratify+2CRaster-method'></span><span id='topic+deratify'></span>

<h3>Description</h3>

<p>These functions allow for defining a RasterLayer as a categorical variable. Such a RasterLayer is linked to other values via a &quot;Raster Attribute Table&quot; (RAT). Thus the cell values are an index, whereas the actual values of interest are in the RAT. The RAT is a data.frame. The first column in the RAT (&quot;ID&quot;) has the unique cell values of the layer; this column should normally not be changed. The other columns can be of any basic type (factor, character, integer, numeric or logical). The functions documented here are mainly available such that files with a RAT can be read and processed; currently there is not too much further support. Whether a layer is defined as a factor or not is currently ignored by almost all functions. An exception is the 'extract' function (when used with option df=TRUE).
</p>
<p>Function 'levels' returns the RAT for inspection. It can be modified and set using <code>levels &lt;- value</code>  (but use caution as it is easy to mess things up). 
</p>
<p><code>as.factor</code> and <code>ratify</code> create a layer with a RAT table. Function 'deratify' creates a single layer for a (or each) variable in the RAT table. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.factor(x)
as.factor(x)
levels(x)

## S4 method for signature 'Raster'
ratify(x, filename="", count=FALSE, ...)

factorValues(x, v, layer=1, att=NULL, append.names=FALSE)
deratify(x, att=NULL, layer=1, complete=FALSE, drop=TRUE, fun='mean', filename='', ...) 

asFactor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factors_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="factors_+3A_v">v</code></td>
<td>
<p>integer cell values</p>
</td></tr>
<tr><td><code id="factors_+3A_layer">layer</code></td>
<td>
<p>integer &gt; 0 indicating which layer to use (in a RasterStack or RasterBrick)</p>
</td></tr>
<tr><td><code id="factors_+3A_att">att</code></td>
<td>
<p>numeric or character. Which variable(s) in the RAT table should be used. If <code>NULL</code>, all variables are extracted. If using a numeric, skip the first two default columns</p>
</td></tr>
<tr><td><code id="factors_+3A_append.names">append.names</code></td>
<td>
<p>logical. Should names of data.frame returned by a combination of the name of the layer and the RAT variables? (can be useful for multilayer objects</p>
</td></tr>
<tr><td><code id="factors_+3A_filename">filename</code></td>
<td>
<p>character. Optional</p>
</td></tr>  
<tr><td><code id="factors_+3A_count">count</code></td>
<td>
<p>logical. If <code>TRUE</code>, a columns with frequencies is added</p>
</td></tr>  
<tr><td><code id="factors_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>    
<tr><td><code id="factors_+3A_complete">complete</code></td>
<td>
<p>logical. If <code>TRUE</code>, the layer returned is no longer a factor</p>
</td></tr>  
<tr><td><code id="factors_+3A_drop">drop</code></td>
<td>
<p>logical. If <code>TRUE</code> a factor is converted to a numerical value if possible</p>
</td></tr>  
<tr><td><code id="factors_+3A_fun">fun</code></td>
<td>
<p>character. Used to get a single value for each class for a weighted RAT table. 'mean', 'min', 'max', 'smallest', or 'largest'</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Raster* object; list (levels); boolean (is.factor); matrix (factorValues)
</p>


<h3>Note</h3>

<p>asFactor is deprecated and should not be used</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
r &lt;- raster(nrow=10, ncol=10)
values(r) &lt;- runif(ncell(r)) * 10
is.factor(r)

r &lt;- round(r)
f &lt;- as.factor(r)
is.factor(f)

x &lt;- levels(f)[[1]]
x
x$code &lt;- letters[10:20]
levels(f) &lt;- x
levels(f)
f

r &lt;- raster(nrow=10, ncol=10)
values(r) = 1
r[51:100] = 2
r[3:6, 1:5] = 3
r &lt;- ratify(r)

rat &lt;- levels(r)[[1]]
rat$landcover &lt;- c("Pine", "Oak", "Meadow")
rat$code &lt;- c(12,25,30)
levels(r) &lt;- rat
r

# extract values for some cells
i &lt;- extract(r, c(1,2, 25,100))
i
# get the attribute values for these cells
factorValues(r, i)

# write to file:
# rr &lt;- writeRaster(r, rasterTmpFile(), overwrite=TRUE)
# rr

# create a single-layer factor 
x &lt;- deratify(r, "landcover")
x
is.factor(x)
levels(x)
</code></pre>

<hr>
<h2 id='filename'>Filename</h2><span id='topic+filename'></span>

<h3>Description</h3>

<p>Get the filename of a Raster* object. You cannot set the filename of an object (except for RasterStack objects); but you can provide a 'filename= ' argument to a function that creates a new RasterLayer or RasterBrick* object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filename(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filename_+3A_x">x</code></td>
<td>
<p>A Raster* object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Raster* object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster( system.file("external/test.grd", package="raster") )
filename(r)
</code></pre>

<hr>
<h2 id='filledContour'>Filled contour plot</h2><span id='topic+filledContour'></span>

<h3>Description</h3>

<p>Filled contour plot of a RasterLayer. This is a wrapper around <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> for RasterLayer objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filledContour(x, y=1, maxpixels=100000, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filledContour_+3A_x">x</code></td>
<td>
<p>A Raster* object</p>
</td></tr>
<tr><td><code id="filledContour_+3A_y">y</code></td>
<td>
<p>Integer. The layer number of x (if x has multiple layers)</p>
</td></tr>
<tr><td><code id="filledContour_+3A_maxpixels">maxpixels</code></td>
<td>
<p>The maximum number of pixels</p>
</td></tr>
<tr><td><code id="filledContour_+3A_...">...</code></td>
<td>
<p>Any argument that can be passed to <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> (graphics package)</p>
</td></tr>  
</table>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>, <code><a href="#topic+persp">persp</a></code>, <code><a href="#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/test.grd", package="raster"))
filledContour(r)
</code></pre>

<hr>
<h2 id='flip'>Flip</h2><span id='topic+flip'></span><span id='topic+flip+2CRasterLayer-method'></span><span id='topic+flip+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Flip the values of a Raster* object by inverting the order of the rows (direction=y) or the columns direction='x'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
flip(x, direction='y', filename='', ...)

## S4 method for signature 'RasterStackBrick'
flip(x, direction='y', filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="flip_+3A_direction">direction</code></td>
<td>
<p>Character. 'y' or 'x'; or 1 (=x) or 2 (=y)</p>
</td></tr>
<tr><td><code id="flip_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="flip_+3A_...">...</code></td>
<td>
<p>if <code>x</code> is a Raster* object, additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick
</p>


<h3>See Also</h3>

<p> transpose: <code><a href="#topic+t">t</a></code>, <code><a href="#topic+rotate">rotate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=18, ncol=36)
m &lt;- matrix(1:ncell(r), nrow=18)
values(r) &lt;- as.vector(t(m))
rx &lt;- flip(r, direction='x')
values(r) &lt;- as.vector(m)
ry &lt;- flip(r, direction='y')
</code></pre>

<hr>
<h2 id='flowPath'>Flow path</h2><span id='topic+flowPath'></span>

<h3>Description</h3>

<p>Compute the flow path (drainage path) starting at a given point. See package <code>gdistance</code> for more path computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowPath(x, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flowPath_+3A_x">x</code></td>
<td>
<p>RasterLayer of flow direction (as can be created with <code><a href="#topic+terrain">terrain</a></code></p>
</td></tr>
<tr><td><code id="flowPath_+3A_p">p</code></td>
<td>
<p>starting point. Either two numbers: x (longitude) and y (latitude) coordinates; or a single cell number	</p>
</td></tr>
<tr><td><code id="flowPath_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>numeric (cell numbers)
</p>


<h3>Author(s)</h3>

<p>Ashton Shortridge</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volcano)
v &lt;- raster(volcano, xmn=2667400, xmx=2668010, ymn=6478700, ymx=6479570, crs="+init=epsg:27200")
fd &lt;- terrain(v, opt = "flowdir")
path &lt;- flowPath(fd, 2407)
xy &lt;- xyFromCell(fd, path)
plot(v)
lines(xy)
</code></pre>

<hr>
<h2 id='focal'>Focal values</h2><span id='topic+focal'></span><span id='topic+focal+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Calculate focal (&quot;moving window&quot;) values for the neighborhood of focal cells using a matrix of weights, perhaps in combination with a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
focal(x, w, fun, filename='', na.rm=FALSE, pad=FALSE, padValue=NA, NAonly=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focal_+3A_x">x</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="focal_+3A_w">w</code></td>
<td>
<p>matrix of weights (the moving window), e.g. a 3 by 3 matrix with values 1; see Details. The matrix does not need to be square, but the sides must be odd numbers. If you need even sides, you can add a column or row with weights of zero or <code>NA</code></p>
</td></tr>
<tr><td><code id="focal_+3A_fun">fun</code></td>
<td>
<p>function (optional). The function fun should take multiple numbers, and return a single number. For example mean, modal, min or max. It should also accept a <code>na.rm</code> argument (or ignore it, e.g. as one of the 'dots' arguments. For example, <code>length</code> will fail, but <code>function(x, ...){na.omit(length(x))}</code> works. </p>
</td></tr>
<tr><td><code id="focal_+3A_filename">filename</code></td>
<td>
<p>character. Filename for a new raster (optional)</p>
</td></tr>
<tr><td><code id="focal_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> will be removed from focal computations. The result will only be <code>NA</code> if all focal cells are <code>NA</code>. Except for some special cases (weights of 1, functions like min, max, mean), using <code>na.rm=TRUE</code> may not be a good idea in this function because it can unbalance the effect of the weights</p>
</td></tr>
<tr><td><code id="focal_+3A_pad">pad</code></td>
<td>
<p>logical. If <code>TRUE</code>, additional 'virtual' rows and columns are padded to <code>x</code> such that there are no edge effects. This can be useful when a function needs to have access to the central cell of the filter</p>
</td></tr>
<tr><td><code id="focal_+3A_padvalue">padValue</code></td>
<td>
<p>numeric. The value of the cells of the padded rows and columns</p>
</td></tr>
<tr><td><code id="focal_+3A_naonly">NAonly</code></td>
<td>
<p>logical. If <code>TRUE</code>, only cell values that are <code>NA</code> are replaced with the computed focal values</p>
</td></tr>
<tr><td><code id="focal_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>focal</code> uses a matrix of weights for the neighborhood of the focal cells. The default function is <code>sum</code>. It is computationally much more efficient to adjust the weights-matrix than to use another function through the <code>fun</code> argument. Thus while the following two statements are equivalent (if there are no <code>NA</code> values), the first one is faster than the second one:
</p>
<p><code>a &lt;- focal(x, w=matrix(1/9, nc=3, nr=3))</code>
</p>
<p><code>b &lt;- focal(x, w=matrix(1,3,3), fun=mean)</code>
</p>
<p>There is, however, a difference if <code>NA</code> values are considered. One can use the <code>na.rm=TRUE</code> option which may make sense when using a function like <code>mean</code>. However, the results would be wrong when using a weights matrix.
</p>
<p>Laplacian filter: <code>filter=matrix(c(0,1,0,1,-4,1,0,1,0), nrow=3)</code>
</p>
<p>Sobel filters: <code>fx=matrix(c(-1,-2,-1,0,0,0,1,2,1) / 4, nrow=3)</code>
and <code>fy=matrix(c(1,0,-1,2,0,-2,1,0,-1)/4, nrow=3)</code>
</p>
<p>see the <code><a href="#topic+focalWeight">focalWeight</a></code> function to create distance based circular, rectangular, or Gaussian filters.
</p>
<p>Note that there is a difference between 0 and NA in the weights matrix. A zero weight cell is included in the computation, whereas a NA weight cell is excluded. This does not matter for &quot;sum&quot;, nor for &quot;mean&quot; (zeros are removed), but it affects many other functions such as &quot;var&quot; as you could be adding a lot of zeros that should not be there.
</p>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+focalWeight">focalWeight</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=36, nrows=18, xmn=0)
values(r) &lt;- runif(ncell(r)) 

# 3x3 mean filter
r3 &lt;- focal(r, w=matrix(1/9,nrow=3,ncol=3)) 

# 5x5 mean filter
r5 &lt;- focal(r, w=matrix(1/25,nrow=5,ncol=5)) 

# Gaussian filter
gf &lt;- focalWeight(r, 2, "Gauss")
rg &lt;- focal(r, w=gf)

# The max value for the lower-rigth corner of a 3x3 matrix around a focal cell
f = matrix(c(0,0,0,0,1,1,0,1,1), nrow=3)
f
rm &lt;- focal(r, w=f, fun=max)

# global lon/lat data: no 'edge effect' for the columns
xmin(r) &lt;- -180
r3g &lt;- focal(r, w=matrix(1/9,nrow=3,ncol=3)) 


## Not run: 
## focal can be used to create a cellular automaton

# Conway's Game of Life 
w &lt;- matrix(c(1,1,1,1,0,1,1,1,1), nr=3,nc=3)
gameOfLife &lt;- function(x) {
	f &lt;- focal(x, w=w, pad=TRUE, padValue=0)
	# cells with less than two or more than three live neighbours die
	x[f&lt;2 | f&gt;3] &lt;- 0
	# cells with three live neighbours become alive
	x[f==3] &lt;- 1
	x
}

# simulation function
sim &lt;- function(x, fun, n=100, pause=0.25) {
	for (i in 1:n) {
		x &lt;- fun(x)
		plot(x, legend=FALSE, asp=NA, main=i)
		dev.flush()
		Sys.sleep(pause)
	}
	invisible(x)
}

# Gosper glider gun
m &lt;- matrix(0, nc=48, nr=34)
m[c(40, 41, 74, 75, 380, 381, 382, 413, 417, 446, 452, 480, 
  486, 517, 549, 553, 584, 585, 586, 619, 718, 719, 720, 752, 
  753, 754, 785, 789, 852, 853, 857, 858, 1194, 1195, 1228, 1229)] &lt;- 1
init &lt;- raster(m)

# run the model
sim(init, gameOfLife, n=150, pause=0.05)

## Implementation of Sobel edge-detection filter
## for RasterLayer r
sobel &lt;- function(r) {
	fy &lt;- matrix(c(1,0,-1,2,0,-2,1,0,-1), nrow=3)
	fx &lt;- matrix(c(-1,-2,-1,0,0,0,1,2,1) , nrow=3)
	rx &lt;- focal(r, fx)
	ry &lt;- focal(r, fy)
	sqrt(rx^2 + ry^2)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='focalWeight'>Focal weights matrix</h2><span id='topic+focalWeight'></span>

<h3>Description</h3>

<p>Calculate focal (&quot;moving window&quot;) weight matrix for use in the <code><a href="#topic+focal">focal</a></code> function. The sum of the values adds up to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focalWeight(x, d, type=c('circle', 'Gauss', 'rectangle'), fillNA=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focalWeight_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="focalWeight_+3A_d">d</code></td>
<td>
<p>numeric. If <code>type=circle</code>, the radius of the circle (in units of the CRS). If <code>type=rectangle</code> the dimension of the rectangle (one or two numbers). If <code>type=Gauss</code> the size of sigma, and optionally another number to determine the size of the matrix returned (default is 3 times sigma)</p>
</td></tr> 
<tr><td><code id="focalWeight_+3A_type">type</code></td>
<td>
<p>character indicating the type of filter to be returned</p>
</td></tr>
<tr><td><code id="focalWeight_+3A_fillna">fillNA</code></td>
<td>
<p>logical. If <code>TRUE</code>, zeros are set to <code>NA</code> such that they are ignored in the computations. Only applies to <code>type="circle"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix that can be used in <code><a href="#topic+focal">focal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=180, nrows=180, xmn=0, crs="+proj=utm +zone=1")
# Gaussian filter for square cells
gf &lt;- focalWeight(r, .5, "Gauss")
focalWeight(r, 2, "circle", fillNA=TRUE)
</code></pre>

<hr>
<h2 id='freq'>Frequency table</h2><span id='topic+freq'></span><span id='topic+freq+2CRasterLayer-method'></span><span id='topic+freq+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Frequency table of the values of a RasterLayer.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
freq(x, digits=0, value=NULL, useNA='ifany', progress='', ...)

## S4 method for signature 'RasterStackBrick'
freq(x, digits=0, value=NULL, useNA='ifany', merge=FALSE, progress='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_+3A_x">x</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="freq_+3A_digits">digits</code></td>
<td>
<p>non-negative integer for rounding the cell values. Argument is passed to <code>round</code> </p>
</td></tr>
<tr><td><code id="freq_+3A_value">value</code></td>
<td>
<p>numeric, logical or NA. An optional single value to only count the number of cells with that value</p>
</td></tr>
<tr><td><code id="freq_+3A_usena">useNA</code></td>
<td>
<p>character. What to do with NA values? Options are &quot;no&quot;, &quot;ifany&quot;, &quot;always&quot;. See to <code><a href="base.html#topic+table">table</a></code> </p>
</td></tr>
<tr><td><code id="freq_+3A_progress">progress</code></td>
<td>
<p>character to specify a progress bar. Choose from 'text', 'window', or &rdquo; (the default, no progress bar)</p>
</td></tr>
<tr><td><code id="freq_+3A_merge">merge</code></td>
<td>
<p>logical. If <code>TRUE</code> the list will be merged into a single data.frame</p>
</td></tr>
<tr><td><code id="freq_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (RasterLayer). List of matrices (one for each layer) or data.frame (if <code>merge=TRUE</code>) (RasterStack or RasterBrick)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+crosstab">crosstab</a> </code> and <code><a href="#topic+zonal">zonal</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=18, ncol=36)
values(r) &lt;- runif(ncell(r))
r[1:5] &lt;- NA
r &lt;- r * r * r * 5
freq(r)

freq(r, value=2)

s &lt;- stack(r, r*2, r*3)
freq(s, merge=TRUE)
</code></pre>

<hr>
<h2 id='Gain+20and+20offset'>Gain and offset of values on file</h2><span id='topic+gain'></span><span id='topic+offs'></span><span id='topic+gain+3C-'></span><span id='topic+offs+3C-'></span>

<h3>Description</h3>

<p>These functions can be used to get or set the gain and offset parameters used to transform values when reading them from a file. The gain and offset parameters are applied to the raw values using the formula below: 
</p>
<p><code>value &lt;- value * gain + offset</code>
</p>
<p>The default value for gain is 1 and for offset is 0. 'gain' is sometimes referred to as 'scale'.
</p>
<p>Note that setting gain and/or offset are intended to be used with values that are stored in a file. For a Raster* object with values in memory, assigning gain or offset values will lead to the inmediate computation of new values; in such cases it would be clearer to use <code><a href="#topic+Arith-methods">Arith-methods</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gain(x)
gain(x) &lt;- value
offs(x)
offs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gain+2B20and+2B20offset_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="Gain+2B20and+2B20offset_+3A_value">value</code></td>
<td>
<p>Single numeric value </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster* object or numeric value(s)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(system.file("external/test.grd", package="raster"))
gain(r)
offs(r)
r[1505:1510]
gain(r) &lt;- 10
offs(r) &lt;- 5
r[1505:1510]
</code></pre>

<hr>
<h2 id='geom'>Get the coordinates of a vector type Spatial* object</h2><span id='topic+geom'></span><span id='topic+geom+2CSpatialPolygons-method'></span><span id='topic+geom+2CSpatialLines-method'></span><span id='topic+geom+2CSpatialPoints-method'></span><span id='topic+geom+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Extract the coordinates of a Spatial object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatialPolygons'
geom(x, sepNA=FALSE, ...)
## S4 method for signature 'SpatialLines'
geom(x, sepNA=FALSE, ...)
## S4 method for signature 'SpatialPoints'
geom(x, ...)
## S4 method for signature 'data.frame'
geom(x, d, gt, crs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_+3A_x">x</code></td>
<td>
<p>SpatialPolygons*, SpatialLines*, or SpatialPoints* object; or a data.frame</p>
</td></tr>
<tr><td><code id="geom_+3A_sepna">sepNA</code></td>
<td>
<p>logical. If <code>TRUE</code>, geometries are separated by a row with <code>NA</code> values</p>
</td></tr>
<tr><td><code id="geom_+3A_...">...</code></td>
<td>
<p>additional arguments, none implemented</p>
</td></tr>
<tr><td><code id="geom_+3A_d">d</code></td>
<td>
<p>data.frame that matches the number of objects in data.frame <code>x</code></p>
</td></tr>
<tr><td><code id="geom_+3A_gt">gt</code></td>
<td>
<p>character. geometry type. Must be one of &quot;polygons&quot;, &quot;lines&quot;, &quot;points&quot;</p>
</td></tr>
<tr><td><code id="geom_+3A_crs">crs</code></td>
<td>
<p>character. PROJ.4 crs string</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Matrix with 6, (5 SpatialLines), or 3 (SpatialPoints) columns. object (sequential object number) part (sequential part number within the object; not for SpatialPoints), cump (cumulative part number; not for SpatialPoints), hole (is this a hole or not; only for SpatialPolygons), x (x coordinate or longitude), y (y coordinate or latitude)
</p>


<h3>See Also</h3>

 <p><code><a href="sp.html#topic+coordinates">coordinates</a></code>, <code><a href="sp.html#topic+geometry-methods">geometry</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- readRDS(system.file("external/lux.rds", package="raster"))
x &lt;- geom(p)
head(x)
	
# and back to a SpatialPolygonsDataFrame	
x &lt;- data.frame(x)
sp &lt;- as(x, "SpatialPolygons")
crs(sp) &lt;- crs(p)
spdf &lt;- SpatialPolygonsDataFrame(sp, data.frame(p), match.ID=FALSE)
</code></pre>

<hr>
<h2 id='getData'>Get geographic data </h2><span id='topic+getData'></span><span id='topic+ccodes'></span>

<h3>Description</h3>

<p>Get geographic data for anywhere in the world. Data are read from files that are first downloaded if necessary. Function <code>ccodes</code> returns country names and the ISO codes
</p>
<p>See the geodata package for access to more recent versions of the data available through this function, and for many other datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getData(name, download=TRUE, path="", ...)
ccodes()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getData_+3A_name">name</code></td>
<td>
<p>Data set name, currently supported are 'GADM', 'countries', 'SRTM', 'alt', and 'worldclim'. See Details for more info</p>
</td></tr>
<tr><td><code id="getData_+3A_download">download</code></td>
<td>
<p>Logical. If <code>TRUE</code> data will be downloaded if not locally available</p>
</td></tr>
<tr><td><code id="getData_+3A_path">path</code></td>
<td>
<p>Character. Path name indicating where to store the data. Default is the current working directory </p>
</td></tr>
<tr><td><code id="getData_+3A_...">...</code></td>
<td>
<p> Additional required (!) parameters. These are data set specific. See Details</p>
</td></tr>   
</table>


<h3>Details</h3>

  
<p>'alt' stands for altitude (elevation); the data were aggregated from SRTM 90 m resolution data between -60 and 60 latitude. 'GADM' is a database of global administrative boundaries. 'worldclim' is a database of global interpolated climate data. 'SRTM' refers to the hole-filled CGIAR-SRTM (90 m resolution). 'countries' has polygons for all countries at a higher resolution than the 'wrld_simpl' data in the maptools package . 
</p>
<p>If <code>name</code> is 'alt' or 'GADM' you must provide a 'country=' argument. Countries are specified by their 3 letter ISO codes. Use getData('ISO3') to see these codes. In the case of GADM you must also provide the level of administrative subdivision (0=country, 1=first level subdivision). In the case of alt you can set 'mask' to FALSE. If it is TRUE values for neighbouring countries are set to NA. For example:
</p>
<p><code>getData('GADM', country='FRA', level=1)</code>
</p>
<p><code>getData('alt', country='FRA', mask=TRUE)</code>
</p>
<p>If <code>name</code> is 'SRTM' you must provide 'lon' and 'lat' arguments (longitude and latitude). These should be single numbers somewhere within the SRTM tile that you want.
</p>
<p><code>getData('SRTM', lon=5, lat=45)</code>
</p>
<p>If <code>name='worldclim'</code> you must also provide arguments <code>var</code>, and a resolution <code>res</code>. Valid variables names are 'tmin', 'tmax', 'prec' and 'bio'. Valid resolutions are 0.5, 2.5, 5, and 10 (minutes of a degree). In the case of <code>res=0.5</code>, you must also provide a <code>lon</code> and <code>lat</code> argument for a tile; for the lower resolutions global data will be downloaded. In all cases there are 12 (monthly) files for each variable except for 'bio' which contains 19 files.
</p>
<p><code>getData('worldclim', var='tmin', res=0.5, lon=5, lat=45)</code>
</p>
<p><code>getData('worldclim', var='bio', res=10)</code>
</p>
<p>To get (projected) future climate data (CMIP5), you must provide arguments <code>var</code> and <code>res</code> as above. Only resolutions 2.5, 5, and 10 are currently available. In addition, you need to provide <code>model</code>, <code>rcp</code> and <code>year</code>. For example,
</p>
<p><code>getData('CMIP5', var='tmin', res=10, rcp=85, model='AC', year=70)</code>
</p>
<p>function (var, model, rcp, year, res, lon, lat, path, download = TRUE) 
</p>
<p>'model' should be one of &quot;AC&quot;, &quot;BC&quot;, &quot;CC&quot;, &quot;CE&quot;, &quot;CN&quot;, &quot;GF&quot;, &quot;GD&quot;, &quot;GS&quot;, &quot;HD&quot;, &quot;HG&quot;, &quot;HE&quot;, &quot;IN&quot;, &quot;IP&quot;, &quot;MI&quot;, &quot;MR&quot;, &quot;MC&quot;, &quot;MP&quot;, &quot;MG&quot;, or  &quot;NO&quot;.
</p>
<p>'rcp' should be one of 26, 45, 60, or 85.
</p>
<p>'year' should be 50 or 70
</p>
<p>Not all combinations are available. See www.worldclim.org for details.
</p>


<h3>Value</h3>

<p>A spatial object (Raster* or Spatial*)
</p>


<h3>References</h3>

<p><a href="https://www.worldclim.org">https://www.worldclim.org</a>
</p>
<p><a href="https://gadm.org">https://gadm.org</a>
</p>
<p>https://srtm.csi.cgiar.org/
</p>
<p><a href="https://diva-gis.org/gdata">https://diva-gis.org/gdata</a>
</p>

<hr>
<h2 id='getValues'>Get raster cell values</h2><span id='topic+values'></span><span id='topic+values+2CRaster-method'></span><span id='topic+getValues'></span><span id='topic+getValues+2CRasterLayer+2Cmissing+2Cmissing-method'></span><span id='topic+getValues+2CRasterLayerSparse+2Cmissing+2Cmissing-method'></span><span id='topic+getValues+2CRasterStack+2Cmissing+2Cmissing-method'></span><span id='topic+getValues+2CRasterBrick+2Cmissing+2Cmissing-method'></span><span id='topic+getValues+2CRasterLayer+2Cnumeric+2Cmissing-method'></span><span id='topic+getValues+2CRasterLayerSparse+2Cnumeric+2Cmissing-method'></span><span id='topic+getValues+2CRasterStack+2Cnumeric+2Cmissing-method'></span><span id='topic+getValues+2CRasterBrick+2Cnumeric+2Cmissing-method'></span><span id='topic+getValues+2CRasterLayer+2Cnumeric+2Cnumeric-method'></span><span id='topic+getValues+2CRasterLayerSparse+2Cnumeric+2Cnumeric-method'></span><span id='topic+getValues+2CRasterStack+2Cnumeric+2Cnumeric-method'></span><span id='topic+getValues+2CRasterBrick+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>getValues returns all values or the values for a number of rows of a Raster* object. Values returned for a RasterLayer are a vector. The values returned for a RasterStack or RasterBrick are always a matrix, with the rows representing cells, and the columns representing layers
</p>
<p><code>values</code> is a shorthand version of getValues (for all rows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getValues(x, row, nrows, ...)

values(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="getValues_+3A_row">row</code></td>
<td>
<p>Numeric. Row number, should be between 1 and nrow(x), or missing in which case all values are returned</p>
</td></tr>
<tr><td><code id="getValues_+3A_nrows">nrows</code></td>
<td>
<p>Numeric. Number of rows. Should be an integer &gt; 0, or missing</p>
</td></tr>
<tr><td><code id="getValues_+3A_...">...</code></td>
<td>
<p>Additional arguments. When x is a <code>RasterLayer</code>: <code>format</code> to specify the output format. Either &quot;matrix&quot; or, the default &quot;&quot;, in which case a vector is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or matrix of raster values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getValuesBlock">getValuesBlock</a>, <a href="#topic+getValuesFocal">getValuesFocal</a>, <a href="#topic+setValues">setValues</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/test.grd", package="raster"))
r
v &lt;- getValues(r)
length(v)
head(v)
getValues(r, row=10)
</code></pre>

<hr>
<h2 id='getValuesBlock'>Get a block of raster cell values</h2><span id='topic+getValuesBlock'></span><span id='topic+getValuesBlock+2CRasterLayer-method'></span><span id='topic+getValuesBlock+2CRasterLayerSparse-method'></span><span id='topic+getValuesBlock+2CRasterStack-method'></span><span id='topic+getValuesBlock+2CRasterBrick-method'></span>

<h3>Description</h3>

<p>getValuesBlock returns values for a block (rectangular area) of values of a Raster* object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
getValuesBlock(x, row=1, nrows=1, col=1, ncols=(ncol(x)-col+1), format='', ...)

## S4 method for signature 'RasterBrick'
getValuesBlock(x, row=1, nrows=1, col=1, ncols=(ncol(x)-col+1), lyrs, ...)

## S4 method for signature 'RasterStack'
getValuesBlock(x, row=1, nrows=1, col=1, ncols=(ncol(x)-col+1), lyrs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValuesBlock_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="getValuesBlock_+3A_row">row</code></td>
<td>
<p>positive integer. Row number to start from, should be between 1 and nrow(x)</p>
</td></tr>
<tr><td><code id="getValuesBlock_+3A_nrows">nrows</code></td>
<td>
<p>positive integer. How many rows? Default is 1</p>
</td></tr>
<tr><td><code id="getValuesBlock_+3A_col">col</code></td>
<td>
<p>positive integer. Column number to start from, should be between 1 and ncol(x)</p>
</td></tr>
<tr><td><code id="getValuesBlock_+3A_ncols">ncols</code></td>
<td>
<p>positive integer. How many columns? Default is the number of columns left after the start column</p>
</td></tr>
<tr><td><code id="getValuesBlock_+3A_format">format</code></td>
<td>
<p>character. When <code>x</code> is a <code>RasterLayer</code>, if <code>format='matrix'</code> or <code>format='m'</code>, a matrix is returned instead of a vector. If <code>format='matrix'</code>, it is a nrow x ncol matrix. If <code>format='m'</code> it is a 1 column matrix (the benefit is that the type of output is now the same for all Raster objects)</p>
</td></tr>
<tr><td><code id="getValuesBlock_+3A_lyrs">lyrs</code></td>
<td>
<p>integer (vector). Which layers? Default is all layers (<code>1:nlayers(x)</code>)</p>
</td></tr>
<tr><td><code id="getValuesBlock_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or vector (if <code>(x=RasterLayer)</code>, unless <code>format='matrix'</code>)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getValues">getValues</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/test.grd", package="raster"))
b &lt;- getValuesBlock(r, row=100, nrows=3, col=10, ncols=5)
b 
b &lt;- matrix(b, nrow=3, ncol=5, byrow=TRUE)
b

logo &lt;- brick(system.file("external/rlogo.grd", package="raster"))
getValuesBlock(logo, row=35, nrows=3, col=50, ncols=3, lyrs=2:3)
</code></pre>

<hr>
<h2 id='getValuesFocal'>Get focal raster cell values</h2><span id='topic+getValuesFocal'></span><span id='topic+getValuesFocal+2CRaster-method'></span><span id='topic+getValuesFocal+2CRaster+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic+getValuesFocal+2CRaster+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>This function returns a matrix (or matrices) for all focal values of a number of rows of a Raster* object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
getValuesFocal(x, row, nrows, ngb, names=FALSE, padValue=NA, array=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValuesFocal_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="getValuesFocal_+3A_row">row</code></td>
<td>
<p>Numeric. Row number, should be between 1 and nrow(x). Can be omitted to get all rows</p>
</td></tr>
<tr><td><code id="getValuesFocal_+3A_nrows">nrows</code></td>
<td>
<p>Numeric. Number of rows, should be a positive integer smaller than <code>row+nrow(x)</code>. Should be omitted if <code>row</code> is omitted</p>
</td></tr>
<tr><td><code id="getValuesFocal_+3A_ngb">ngb</code></td>
<td>
<p>Neighbourhood size. Either a single integer or a vector of two integers <code>c(nrow, ncol)</code></p>
</td></tr>
<tr><td><code id="getValuesFocal_+3A_names">names</code></td>
<td>
<p>logical. If <code>TRUE</code>, the matrix returned has row and column names</p>
</td></tr>
<tr><td><code id="getValuesFocal_+3A_padvalue">padValue</code></td>
<td>
<p>numeric. The value of the cells of the &quot;padded&quot; rows and columns. That is 'virtual' values for cells within a neighbourhood, but outside the raster</p>
</td></tr> 
<tr><td><code id="getValuesFocal_+3A_array">array</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>x</code> has multiple layers, an array is returned in stead of a list of matrices</p>
</td></tr>
<tr><td><code id="getValuesFocal_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> has a single layer, a matrix with one row for each focal cell, and one column for each neighbourhood cell around it.
</p>
<p>If <code>x</code> has multiple layers, an array (if <code>array=TRUE</code>) or a list of such matrices (one list element (matrix) for each layer)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getValues">getValues</a>, <a href="#topic+focal">focal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nr=5, nc=5, crs='+proj=utm +zone=12')
values(r) &lt;- 1:25
as.matrix(r)
getValuesFocal(r, row=1, nrows=2, ngb=3, names=TRUE)
getValuesFocal(stack(r,r), row=1, nrows=1, ngb=3, names=TRUE, array=TRUE)
</code></pre>

<hr>
<h2 id='gridDistance'>Distance on a grid</h2><span id='topic+gridDistance'></span><span id='topic+gridDistance+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>The function calculates the distance to cells of a RasterLayer when the path has to go through the centers of neighboring raster cells (currently only implemented as a 'queen' case in which cells have 8 neighbors).
</p>
<p>The distance is in meters if the coordinate reference system (CRS) of the RasterLayer is longitude/latitude (<code>+proj=longlat</code>) and in the units of the CRS (typically meters) in other cases. 
</p>
<p>Distances are computed by summing local distances between cells, which are connected with their neighbours in 8 directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
gridDistance(x, origin, omit=NULL, filename="", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridDistance_+3A_x">x</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="gridDistance_+3A_origin">origin</code></td>
<td>
<p>value(s) of the cells from which the distance is calculated</p>
</td></tr>
<tr><td><code id="gridDistance_+3A_omit">omit</code></td>
<td>
<p>value(s) of the cells which cannot be traversed (optional)</p>
</td></tr>
<tr><td><code id="gridDistance_+3A_filename">filename</code></td>
<td>
<p>character. output filename (optional)</p>
</td></tr>
<tr><td><code id="gridDistance_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Details</h3>

<p>If the RasterLayer to be processed is big, it will be processed in chunks. This may lead to errors in the case of complex objects spread over different chunks (meandering rivers, for instance). You can try to solve these issues by varying the chunk size, see function setOptions().
</p>


<h3>Value</h3>

<p>RasterLayer</p>


<h3>Author(s)</h3>

<p>Jacob van Etten and Robert J. Hijmans </p>


<h3>See Also</h3>

<p>See <code><a href="#topic+distance">distance</a></code> for 'as the crow flies' distance. Additional distance measures and options (directions, cost-distance) are available in the '<code>gdistance</code>' package.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#world lon/lat raster
r &lt;- raster(ncol=10,nrow=10, vals=1)
r[48] &lt;- 2
r[66:68] &lt;- 3
d &lt;- gridDistance(r,origin=2,omit=3) 
plot(d)

#UTM small area
crs(r) &lt;- "+proj=utm +zone=15 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
d &lt;- gridDistance(r,origin=2,omit=3) 
plot(d)

</code></pre>

<hr>
<h2 id='hdr'>Header files</h2><span id='topic+hdr'></span>

<h3>Description</h3>

<p>Write header files to use together with raster binary files to read the data in other applications. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdr(x, format, extension='.wld', filename='') 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdr_+3A_x">x</code></td>
<td>
<p>RasterLayer or RasterBrick object associated with a binary values file on disk </p>
</td></tr>
<tr><td><code id="hdr_+3A_format">format</code></td>
<td>
<p>Type of header file: 'VRT', 'BIL', 'ENVI', 'ErdasRaw', 'IDRISI', 'SAGA', 'RASTER', 'WORLDFILE', 'PRJ' </p>
</td></tr>
<tr><td><code id="hdr_+3A_extension">extension</code></td>
<td>
<p>File extension, only used with an ESRI worldfile (<code>format='WORLDFILE'</code>)</p>
</td></tr>
<tr><td><code id="hdr_+3A_filename">filename</code></td>
<td>
<p>character. Need to be provided if <code>x</code> is not associated with a file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RasterLayer object must be associated with a file on disk.
</p>
<p>You can use <code><a href="#topic+writeRaster">writeRaster</a></code> to save a existing file in another format. But if you have a file in a 'raster' format (or similar), you can also only export a header file, 
and use the data file (.gri) that already exists. The function can write a VRT (GDAL virtual raster) header (.vrt); an ENVI or BIL header (.hdr) file; an Erdas Raw (.raw) header file; an IDRISI (.rdc) or SAGA (.sgrd). 
This (hopefully) allows for reading the binary data (.gri), perhaps after changing the file extension, in other programs such as ENVI or ArcGIS.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+writeRaster">writeRaster</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Not run: 
r &lt;- raster(system.file("external/test.grd", package="raster"))
r &lt;- writeRaster(r, filename='export.grd', overwrite=TRUE)
hdr(r, format="ENVI") 

## End(Not run)
</code></pre>

<hr>
<h2 id='head'>Show the head or tail of a Raster* object</h2><span id='topic+head'></span><span id='topic+head+2CRasterLayer-method'></span><span id='topic+head+2CRasterStackBrick-method'></span><span id='topic+head+2CSpatial-method'></span><span id='topic+tail'></span><span id='topic+tail+2CRasterLayer-method'></span><span id='topic+tail+2CRasterStackBrick-method'></span><span id='topic+tail+2CSpatial-method'></span>

<h3>Description</h3>

<p>Show the head (first rows/columns) or tail (last rows/columns) of the cell values of a Raster* object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head(x, ...) 
tail(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="head_+3A_...">...</code></td>
<td>
<p>Additional arguments: <code>rows=10</code> and <code>cols=20</code>, to set the maximum number of rows and columns that are shown. For RasterStack and RasterBrick objects there is an additional argument <code>lyrs</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getValuesBlock">getValuesBlock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=25, ncol=25)
values(r) = 1:ncell(r)
head(r)
tail(r, cols=10, rows=5)
</code></pre>

<hr>
<h2 id='hillShade'>Hill shading</h2><span id='topic+hillShade'></span>

<h3>Description</h3>

<p>Compute hill shade from slope and aspect layers (both in radians). Slope and aspect can be computed with function <code><a href="#topic+terrain">terrain</a></code>. 
</p>
<p>A hill shade layer is often used as a backdrop on top of which another, semi-transparent, layer is drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hillShade(slope, aspect, angle=45, direction=0, filename='', normalize=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hillShade_+3A_slope">slope</code></td>
<td>
<p>RasterLayer object with slope values (in radians) </p>
</td></tr>
<tr><td><code id="hillShade_+3A_aspect">aspect</code></td>
<td>
<p>RasterLayer object with aspect values (in radians) </p>
</td></tr>
<tr><td><code id="hillShade_+3A_angle">angle</code></td>
<td>
<p> The the elevation angle of the light source (sun), in degrees</p>
</td></tr>
<tr><td><code id="hillShade_+3A_direction">direction</code></td>
<td>
<p> The direction (azimuth) angle of the light source (sun), in degrees</p>
</td></tr>
<tr><td><code id="hillShade_+3A_filename">filename</code></td>
<td>
<p>Character. Optional filename</p>
</td></tr>
<tr><td><code id="hillShade_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, values below zero are set to zero and the results are multiplied with 255</p>
</td></tr>
<tr><td><code id="hillShade_+3A_...">...</code></td>
<td>
<p>Standard additional arguments for writing RasterLayer files</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Bevan, Robert J. Hijmans</p>


<h3>References</h3>

<p>Horn, B.K.P., 1981. Hill shading and the reflectance map. Proceedings of the IEEE 69(1):14-47
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+terrain">terrain</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
alt &lt;- getData('alt', country='CHE')
slope &lt;- terrain(alt, opt='slope')
aspect &lt;- terrain(alt, opt='aspect')
hill &lt;- hillShade(slope, aspect, 40, 270)
plot(hill, col=grey(0:100/100), legend=FALSE, main='Switzerland')
plot(alt, col=rainbow(25, alpha=0.35), add=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='hist'>Histogram</h2><span id='topic+hist'></span><span id='topic+hist+2CRaster-method'></span>

<h3>Description</h3>

<p>Create a histogram of the values of a RasterLayer. For large datasets a sample is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
hist(x, layer, maxpixels=100000, plot=TRUE, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="hist_+3A_layer">layer</code></td>
<td>
<p>integer (or character) to indicate layer number (or name). Can be used to subset the layers to plot in a multilayer Raster* object</p>
</td></tr> 
<tr><td><code id="hist_+3A_maxpixels">maxpixels</code></td>
<td>
<p>integer. To regularly subsample very large objects</p>
</td></tr>
<tr><td><code id="hist_+3A_plot">plot</code></td>
<td>
<p>logical. Plot the histogram or only return the histogram values</p>
</td></tr>
<tr><td><code id="hist_+3A_main">main</code></td>
<td>
<p>character. Main title(s) for the plot. Default is the value of <code><a href="#topic+names">names</a></code></p>
</td></tr>
<tr><td><code id="hist_+3A_...">...</code></td>
<td>
<p>Additional arguments. See under Methods and at <code><a href="graphics.html#topic+hist">hist</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>This function is principally used for the side-effect of plotting a histogram, but it also returns an S3 object of class 'histogram' (invisibly if <code>plot=TRUE</code>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pairs">pairs</a>, <a href="#topic+boxplot">boxplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r1 &lt;- raster(nrows=50, ncols=50)
r1 &lt;- setValues(r1, runif(ncell(r1)))
r2 &lt;- setValues(r1, runif(ncell(r1)))
rs &lt;- r1 + r2
rp &lt;- r1 * r2
par(mfrow=c(2,2))
plot(rs, main='sum')
plot(rp, main='product')
hist(rs)
a = hist(rp)
a
</code></pre>

<hr>
<h2 id='image'>Image</h2><span id='topic+image'></span><span id='topic+image+2CRasterLayer-method'></span><span id='topic+image+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Create an &quot;image&quot; type plot of a RasterLayer. This is an implementation of a generic function in the graphics package. In most cases the 
<code><a href="#topic+plot">plot</a></code> function would be preferable because it produces a legend (and has some additional options).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image(x, ...) 
## S4 method for signature 'RasterLayer'
image(x, maxpixels=500000, useRaster=TRUE, ...)

## S4 method for signature 'RasterStackBrick'
image(x, y=1, maxpixels=100000, useRaster=TRUE, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="image_+3A_maxpixels">maxpixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to use for the plot. If <code>maxpixels &lt; ncell(x)</code>, <code>sampleRegular</code> is used before plotting</p>
</td></tr>
<tr><td><code id="image_+3A_useraster">useRaster</code></td>
<td>
<p>If <code>TRUE</code>, the rasterImage function is used for plotting. Otherwise the image function is used. This can be useful if rasterImage does not work well on your system (see note)</p>
</td></tr>
<tr><td><code id="image_+3A_main">main</code></td>
<td>
<p>character. Main plot title</p>
</td></tr>
<tr><td><code id="image_+3A_...">...</code></td>
<td>
<p>Any argument that can be passed to <code><a href="graphics.html#topic+image">image</a></code> (graphics package)</p>
</td></tr>  
<tr><td><code id="image_+3A_y">y</code></td>
<td>
<p>If <code>x</code> is a RasterStack or RasterBrick: integer, character (layer name(s)), or missing to select which layer(s) to plot</p>
</td></tr>
</table>


<h3>Note</h3>

<p>raster uses <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> from the graphics package. For unknown reasons this does not work on Windows Server and on a few versions of Windows XP. On that system you may need to use argument <code>useRaster=FALSE</code> to get a plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+image">image</a></code>, <code><a href="#topic+contour">contour</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(system.file("external/test.grd", package="raster"))
image(r)
</code></pre>

<hr>
<h2 id='inifile'>Read a .ini file</h2><span id='topic+readIniFile'></span>

<h3>Description</h3>

<p>This function reads  <code>'.ini'</code>  files. These are text file databases that are organized in [sections] containing pairs of &quot;name = value&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readIniFile(filename, token='=', commenttoken=';', aslist=FALSE, case)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inifile_+3A_filename">filename</code></td>
<td>
<p>Character. Filename of the .ini file</p>
</td></tr>
<tr><td><code id="inifile_+3A_token">token</code></td>
<td>
<p>Character. The character that separates the &quot;name&quot; (variable name) from the &quot;value&quot;</p>
</td></tr>
<tr><td><code id="inifile_+3A_commenttoken">commenttoken</code></td>
<td>
<p>Character. This token and everything that follows on the same line is considered a 'comment' that is not for machine consumption and is ignored in processing</p>
</td></tr> 
<tr><td><code id="inifile_+3A_aslist">aslist</code></td>
<td>
<p>Logical. Should the values be returned as a list</p>
</td></tr>
<tr><td><code id="inifile_+3A_case">case</code></td>
<td>
<p>Optional. Function that operates on the text, such as <code><a href="base.html#topic+toupper">toupper</a></code> or  <code><a href="base.html#topic+tolower">tolower</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for using inistrings that have &quot;=&quot; as part of a value (but the token cannot be part of the 'name' of a variable!). Sections can be missing. 
</p>


<h3>Value</h3>

<p>A n*3 matrix of characters with columns: section, name, value; or a list if <code>aslist=TRUE</code>.
</p>

<hr>
<h2 id='initialize'>Initialize a Raster object with values</h2><span id='topic+init'></span><span id='topic+init+2CRaster-method'></span>

<h3>Description</h3>

<p>Create a new RasterLayer with values reflecting a cell property: 'x', 'y', 'col', 'row', or 'cell'. Alternatively, a function can be used. In that case, cell values are initialized without reference to pre-existing values. E.g., initialize with a random number (<code>fun=<a href="stats.html#topic+runif">runif</a></code>). While there are more direct ways of achieving this for small objects (see examples) for which a vector with all values can be created in memory, the <code>init</code> function will also work for Raster* objects with many cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
init(x, fun, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="initialize_+3A_fun">fun</code></td>
<td>
<p>function to be applied. This must be a function that can take the number of cells as a single argument to return a vector of values with a length equal to the number of cells, such as <code>fun=runif</code>. You can also supply one of the following character values: 'x', 'y', 'row', 'col', or 'cell' to get the x or coordinate, row, col or cell number; you can also use 'chess', to get a chessboard pattern</p>
</td></tr>
<tr><td><code id="initialize_+3A_filename">filename</code></td>
<td>
<p>character. Optional output filename</p>
</td></tr>
<tr><td><code id="initialize_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>Note</h3>

<p>For backwards compatibility, the character values valid for <code>fun</code> can also be passed as named argument <code>v</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=36, nrows=18)

x &lt;- init(r, fun='cell')

y &lt;- init(r, fun=runif)

# there are different ways to set all values to 1 
# for large rasters:
# set1f &lt;- function(x){rep(1, x)}
# z1 &lt;- init(r, fun=set1f, filename=rasterTmpFile(), overwrite=TRUE)

# This is equivalent to (but not memory safe):
z2 &lt;- setValues(r, rep(1, ncell(r)))
# or  
values(r) &lt;- rep(1, ncell(r))
# or  
values(r) &lt;- 1
</code></pre>

<hr>
<h2 id='interpolate'>Interpolate</h2><span id='topic+interpolate'></span><span id='topic+interpolate+2CRaster-method'></span>

<h3>Description</h3>

<p>Make a RasterLayer with interpolated values using a fitted model object of classes such as 'gstat' (gstat package) or 'Krige' (fields package). That is, these are models that have location ('x' and 'y', or 'longitude' and 'latitude') as independent variables. If x and y are the only independent variables provide an empty (no associated data in memory or on file) RasterLayer for which you want predictions. If there are more spatial predictor variables provide these as a Raster* object in the first argument of the function. If you do not have x and y locations as implicit predictors in your model you should use <code><a href="#topic+predict">predict</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
interpolate(object, model, filename="", fun=predict, xyOnly=TRUE,
   xyNames=c('x', 'y'), ext=NULL, const=NULL, index=1, na.rm=TRUE, debug.level=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_+3A_object">object</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="interpolate_+3A_model">model</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="interpolate_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="interpolate_+3A_fun">fun</code></td>
<td>
<p>function. Default value is 'predict', but can be replaced with e.g. 'predict.se' (depending on the class of the model object)</p>
</td></tr>
<tr><td><code id="interpolate_+3A_xyonly">xyOnly</code></td>
<td>
<p>logical. If <code>TRUE</code>, values of the Raster* object are not considered as co-variables; and only x and y (longitude and latitude) are used. This should match the model</p>
</td></tr>
<tr><td><code id="interpolate_+3A_xynames">xyNames</code></td>
<td>
<p>character. variable names that the model uses for the spatial coordinates. E.g., <code>c('longitude', 'latitude')</code></p>
</td></tr>
<tr><td><code id="interpolate_+3A_ext">ext</code></td>
<td>
<p>Extent object to limit the prediction to a sub-region of <code>x</code></p>
</td></tr>
<tr><td><code id="interpolate_+3A_const">const</code></td>
<td>
<p>data.frame. Can be used to add a constant for which there is no Raster object for model predictions. This is particulary useful if the constant is a character-like factor value</p>
</td></tr>
<tr><td><code id="interpolate_+3A_index">index</code></td>
<td>
<p>integer. To select the column if 'predict.model' returns a matrix with multiple columns</p>
</td></tr>
<tr><td><code id="interpolate_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Remove cells with NA values in the predictors before solving the model (and return <code>NA</code> for those cells). In most cases this will not affect the output. This option prevents errors with models that cannot handle <code>NA</code> values</p>
</td></tr>
<tr><td><code id="interpolate_+3A_debug.level">debug.level</code></td>
<td>
<p>for gstat models only. See ?</p>
</td></tr>
<tr><td><code id="interpolate_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the predict.'model' function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+predict">predict</a></code>, <code><a href="gstat.html#topic+predict.gstat">predict.gstat</a></code>, <code><a href="fields.html#topic+Tps">Tps</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Thin plate spline interpolation with x and y only
# some example data
r &lt;- raster(system.file("external/test.grd", package="raster"))
ra &lt;- aggregate(r, 10)
xy &lt;- data.frame(xyFromCell(ra, 1:ncell(ra)))
v &lt;- getValues(ra)
# remove NAs
i &lt;- !is.na(v)
xy &lt;- xy[i,]
v &lt;- v[i]

#### Thin plate spline model
library(fields) 
tps &lt;- Tps(xy, v)
p &lt;- raster(r)

# use model to predict values at all locations
p &lt;- interpolate(p, tps)
p &lt;- mask(p, r)

plot(p)
## change the fun from predict to fields::predictSE to get the TPS standard error
se &lt;- interpolate(p, tps, fun=predictSE)
se &lt;- mask(se, r)
plot(se)

## another variable; let's call it elevation
elevation &lt;- (init(r, 'x') * init(r, 'y')) / 100000000
names(elevation) &lt;- 'elev'

z &lt;- extract(elevation, xy)

# add as another independent variable
xyz &lt;- cbind(xy, z)
tps2 &lt;- Tps(xyz, v)
p2 &lt;- interpolate(elevation, tps2, xyOnly=FALSE)

# as a linear coveriate
tps3 &lt;- Tps(xy, v, Z=z)

# Z is a separate argument in Krig.predict, so we need a new function
# Internally (in interpolate) a matrix is formed of x, y, and elev (Z)

pfun &lt;- function(model, x, ...) {
   predict(model, x[,1:2], Z=x[,3], ...)
}
p3 &lt;- interpolate(elevation, tps3, xyOnly=FALSE, fun=pfun)

#### gstat examples
library(gstat)
data(meuse)

## inverse distance weighted (IDW)
r &lt;- raster(system.file("external/test.grd", package="raster"))
data(meuse)
mg &lt;- gstat(id = "zinc", formula = zinc~1, locations = ~x+y, data=meuse, 
            nmax=7, set=list(idp = .5))
z &lt;- interpolate(r, mg)
z &lt;- mask(z, r)

## kriging
coordinates(meuse) &lt;- ~x+y
crs(meuse) &lt;- crs(r)

## ordinary kriging
v &lt;- variogram(log(zinc)~1, meuse)
m &lt;- fit.variogram(v, vgm(1, "Sph", 300, 1))
gOK &lt;- gstat(NULL, "log.zinc", log(zinc)~1, meuse, model=m)
OK &lt;- interpolate(r, gOK)

# examples below provided by Maurizio Marchi
## universial kriging
vu &lt;- variogram(log(zinc)~elev, meuse)
mu &lt;- fit.variogram(vu, vgm(1, "Sph", 300, 1))
gUK &lt;- gstat(NULL, "log.zinc", log(zinc)~elev, meuse, model=mu)
names(r) &lt;- 'elev'
UK &lt;- interpolate(r, gUK, xyOnly=FALSE)

## co-kriging
gCoK &lt;- gstat(NULL, 'log.zinc', log(zinc)~1, meuse)
gCoK &lt;- gstat(gCoK, 'elev', elev~1, meuse)
gCoK &lt;- gstat(gCoK, 'cadmium', cadmium~1, meuse)
gCoK &lt;- gstat(gCoK, 'copper', copper~1, meuse)
coV &lt;- variogram(gCoK)
plot(coV, type='b', main='Co-variogram')
coV.fit &lt;- fit.lmc(coV, gCoK, vgm(model='Sph', range=1000))
coV.fit
plot(coV, coV.fit, main='Fitted Co-variogram')
coK &lt;- interpolate(r, coV.fit)
plot(coK)

</code></pre>

<hr>
<h2 id='intersect'> 
Intersect
</h2><span id='topic+intersect'></span><span id='topic+intersect+2CExtent+2CANY-method'></span><span id='topic+intersect+2CRaster+2CANY-method'></span><span id='topic+intersect+2CSpatialPoints+2CANY-method'></span><span id='topic+intersect+2CSpatialPolygons+2CSpatialPolygons-method'></span><span id='topic+intersect+2CSpatialPolygons+2CSpatialLines-method'></span><span id='topic+intersect+2CSpatialPolygons+2CSpatialPoints-method'></span><span id='topic+intersect+2CSpatialPolygons+2CANY-method'></span><span id='topic+intersect+2CSpatialLines+2CSpatialPolygons-method'></span><span id='topic+intersect+2CSpatialLines+2CSpatialLines-method'></span>

<h3>Description</h3>

<p>It depends on the classes of the <code>x</code> and <code>y</code> what is returned. 
</p>
<p>If <code>x</code> is a Raster* object the extent of <code>y</code> is used, irrespective of the class of <code>y</code>, and a Raster* is returned. This is equivalent to <code><a href="#topic+crop">crop</a></code>. 
</p>
<p>If <code>x</code> is a Spatial* object, a new Spatial* object is returned. If <code>x</code> or <code>y</code> has a data.frame, these are also returned (after merging if necessary) as part of a Spatial*DataFrame. 
</p>
<p>Intersecting SpatialPoints* with SpatialPoints* uses the extent (bounding box) of <code>y</code> to get the intersection. Intersecting of SpatialPoints* and SpatialLines* is not supported because of numerical inaccuracies with that. You can use <code><a href="#topic+buffer">buffer</a></code>, to create SpatialPoygons* from SpatialLines* and use that in intersect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Extent,ANY'
intersect(x, y)

## S4 method for signature 'Raster,ANY'
intersect(x, y)

## S4 method for signature 'SpatialPoints,ANY'
intersect(x, y)

## S4 method for signature 'SpatialPolygons,SpatialPolygons'
intersect(x, y)

## S4 method for signature 'SpatialPolygons,SpatialLines'
intersect(x, y)

## S4 method for signature 'SpatialPolygons,SpatialPoints'
intersect(x, y)

## S4 method for signature 'SpatialLines,SpatialPolygons'
intersect(x, y)

## S4 method for signature 'SpatialLines,SpatialLines'
intersect(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect_+3A_x">x</code></td>
<td>
<p>Extent, Raster*, SpatialPolygons*, SpatialLines* or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="intersect_+3A_y">y</code></td>
<td>
<p>same as for <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>x</code> is an Extent object: Extent
</p>
<p>if <code>x</code> is a Raster* object: Raster*
</p>
<p>if <code>x</code> is a SpatialPoints* object: SpatialPoints*
</p>
<p>if <code>x</code> is a SpatialPolygons* object: SpatialPolygons*
</p>
<p>if <code>x</code> is a SpatialLines* object and if <code>y</code> is a SpatialLines* object: SpatialPoints*
</p>
<p>if <code>x</code> is a SpatialLines* object and if <code>y</code> is a SpatialPolygons* object: SpatialLines*
</p>


<h3>See Also</h3>

<p><code><a href="#topic+union">union</a>, <a href="#topic+extent">extent</a>, <a href="#topic+crop">crop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- extent(-10, 10, -20, 20)
e2 &lt;- extent(0, 20, -40, 5)
intersect(e1, e2)

#SpatialPolygons
p &lt;- shapefile(system.file("external/lux.shp", package="raster"))
b &lt;- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
projection(b) &lt;- projection(p)
i &lt;- intersect(p, b)
plot(p)
plot(b, add=TRUE, col='red')
plot(i, add=TRUE, col='blue', lwd=2)

</code></pre>

<hr>
<h2 id='isLonLat'>Is this longitude/latitude data?</h2><span id='topic+isLonLat'></span><span id='topic+isLonLat+2CBasicRaster-method'></span><span id='topic+isLonLat+2CSpatial-method'></span><span id='topic+isLonLat+2CCRS-method'></span><span id='topic+isLonLat+2Ccharacter-method'></span><span id='topic+isLonLat+2CANY-method'></span><span id='topic+couldBeLonLat'></span><span id='topic+couldBeLonLat+2CBasicRaster-method'></span><span id='topic+couldBeLonLat+2CSpatial-method'></span><span id='topic+couldBeLonLat+2CANY-method'></span>

<h3>Description</h3>

<p>Test whether a Raster* or other object has a longitude/latitude coordinate reference system (CRS) by inspecting the PROJ.4 coordinate reference system description. <code>couldBeLonLat</code> also returns <code>TRUE</code> if the CRS is <code>NA</code> but the x coordinates are within -365 and 365 and the y coordinates are within -90.1 and 90.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BasicRaster'
isLonLat(x, ...)
## S4 method for signature 'Spatial'
isLonLat(x, ...)
## S4 method for signature 'BasicRaster'
couldBeLonLat(x, warnings=TRUE, ...)
## S4 method for signature 'Spatial'
couldBeLonLat(x, warnings=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isLonLat_+3A_x">x</code></td>
<td>
<p>Raster* or Spatial* object</p>
</td></tr>
<tr><td><code id="isLonLat_+3A_warnings">warnings</code></td>
<td>
<p>logical. If <code>TRUE</code>, a warning is given if the CRS is <code>NA</code> or when the CRS is longitude/latitude but the coordinates do not match that</p>
</td></tr>
<tr><td><code id="isLonLat_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
isLonLat(r)
crs(r) &lt;- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84"
isLonLat(r)
</code></pre>

<hr>
<h2 id='KML'>Write a KML or KMZ file</h2><span id='topic+KML'></span><span id='topic+KML+2CSpatial-method'></span><span id='topic+KML+2CRasterLayer-method'></span><span id='topic+KML+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Export raster data to a KML file and an accompanying PNG image file. Multi-layer objects can be used to create an animation. 
The function attempts to combine these into a single (and hence more convenient) KMZ file (a zip file containing the KML and PNG files). 
</p>
<p>See package plotKML for more advanced functionality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
KML(x, filename, col=rev(terrain.colors(255)), 
     colNA=NA, maxpixels=100000, blur=1, zip='', overwrite=FALSE, ...)

## S4 method for signature 'RasterStackBrick'
KML(x, filename, time=NULL, col=rev(terrain.colors(255)), 
     colNA=NA, maxpixels=100000, blur=1, zip='', overwrite=FALSE, ...)

## S4 method for signature 'Spatial'
KML(x, filename, zip='', overwrite=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KML_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="KML_+3A_filename">filename</code></td>
<td>
<p>output filename</p>
</td></tr>
<tr><td><code id="KML_+3A_time">time</code></td>
<td>
<p>character vector with time lables for multilayer objects. The length of this vector should be nlayers(x) to indicate &quot;when&quot; or nlayers(x)+1 to indicate &quot;begin-end&quot;</p>
</td></tr>
<tr><td><code id="KML_+3A_col">col</code></td>
<td>
<p>color scheme to be used (see <a href="graphics.html#topic+image">image</a>)</p>
</td></tr>
<tr><td><code id="KML_+3A_colna">colNA</code></td>
<td>
<p>The color to use for the background (default is transparent)</p>
</td></tr>
<tr><td><code id="KML_+3A_maxpixels">maxpixels</code></td>
<td>
<p>maximum number of pixels. If ncell(raster) &gt; maxpixels, sampleRegular is used to reduce the number of pixels</p>
</td></tr>
<tr><td><code id="KML_+3A_blur">blur</code></td>
<td>
<p>Integer (default=1). Higher values help avoid blurring of isolated pixels (at the expense of a png file that is blur^2 times larger)</p>
</td></tr>
<tr><td><code id="KML_+3A_zip">zip</code></td>
<td>
<p>If there is no zip program on your path (on windows), you can supply the full path to a zip.exe here, in order to make a KMZ file</p>
</td></tr>
<tr><td><code id="KML_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, overwrite the file if it exists</p>
</td></tr>
<tr><td><code id="KML_+3A_...">...</code></td>
<td>
<p>If <code>x</code> is a Raster* object, additional arguments that can be passed to <a href="graphics.html#topic+image">image</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for the side-effect files written to disk. 
</p>


<h3>Author(s)</h3>

<p>This function was adapted for the raster package by Robert J. Hijmans, with ideas from Tony Fischbach, and based on functions in the maptools package by Duncan Golicher, David Forrest and Roger Bivand.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Meuse data from the sp package
data(meuse.grid)
b &lt;- rasterFromXYZ(meuse.grid)
projection(b) &lt;- "+init=epsg:28992" 				  
# transform to longitude/latitude
p &lt;- projectRaster(b, crs="+proj=longlat +datum=WGS84", method='ngb')
KML(p, file='meuse.kml')

## End(Not run)
</code></pre>

<hr>
<h2 id='layerize'>Layerize</h2><span id='topic+layerize'></span><span id='topic+layerize+2CRasterLayer+2Cmissing-method'></span><span id='topic+layerize+2CRasterLayer+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Create a RasterBrick with a Boolean layer for each class (value, or subset of the values) in a RasterLayer. For example, if the cell values of a RasterLayer indicate what vegetation type they are, this function will create a layer (presence/absence; dummy variable) for each of these classes. Classes and cell values are always truncated to integers.
</p>
<p>You can supply a second spatially overlapping RasterLayer with larger cells (do not use smaller cells!). In this case the cell values are counts for each class. A similar result might be obtained more efficiently by using layerize with a single RasterLayer followed by <code><a href="#topic+aggregate">aggregate</a>(x,  , sum)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,missing'
layerize(x, classes=NULL, falseNA=FALSE, filename='', ...)

## S4 method for signature 'RasterLayer,RasterLayer'
layerize(x, y, classes=NULL, filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layerize_+3A_x">x</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="layerize_+3A_y">y</code></td>
<td>
<p>RasterLayer or missing</p>
</td></tr>
<tr><td><code id="layerize_+3A_classes">classes</code></td>
<td>
<p>numeric. The values (classes) for which layers should be made. If <code>NULL</code> all classes are used</p>
</td></tr>
<tr><td><code id="layerize_+3A_falsena">falseNA</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells that are not of the class represented by a layer are <code>NA</code> rather then <code>FALSE</code></p>
</td></tr>
<tr><td><code id="layerize_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="layerize_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterBrick
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=20, ncol=20)
values(r) &lt;- c(rep(NA, 50), rep(1:5, 70))
b &lt;- layerize(r)

r2 &lt;- raster(nrow=5, ncol=5)
b2 &lt;- layerize(r, r2)
</code></pre>

<hr>
<h2 id='layerStats'>Correlation and (weighted) covariance</h2><span id='topic+layerStats'></span>

<h3>Description</h3>

<p>Compute correlation and (weighted) covariance for multi-layer Raster objects. Like <code><a href="#topic+cellStats">cellStats</a></code> this function returns a few values, not a Raster* object (see <code><a href="#topic+Summary-methods">Summary-methods</a></code> for that). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layerStats(x, stat, w, asSample=TRUE, na.rm=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layerStats_+3A_x">x</code></td>
<td>
<p>RasterStack or RasterBrick for which to compute a statistic</p>
</td></tr>
<tr><td><code id="layerStats_+3A_stat">stat</code></td>
<td>
<p>Character. The statistic to compute: either 'cov' (covariance), 'weighted.cov' (weighted covariance), or 'pearson' (correlation coefficient)</p>
</td></tr>
<tr><td><code id="layerStats_+3A_w">w</code></td>
<td>
<p>RasterLayer with the weights (should have the same extent, resolution and number of layers as <code>x</code>) to compute the weighted covariance</p>
</td></tr>
<tr><td><code id="layerStats_+3A_assample">asSample</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the statistic for a sample (denominator is <code>n-1</code>) is computed, rather than for the population (denominator is <code>n</code>)</p>
</td></tr>
<tr><td><code id="layerStats_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="layerStats_+3A_...">...</code></td>
<td>
<p>Additional arguments (none implemetned)</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>List with two items: the correlation or (weighted) covariance matrix, and the (weighted) means.
</p>


<h3>Author(s)</h3>

<p>Jonathan A. Greenberg &amp; Robert Hijmans. Weighted covariance based on code by Mort Canty</p>


<h3>References</h3>

<p>For the weighted covariance:
</p>

<ul>
<li> <p>Canty, M.J. and A.A. Nielsen, 2008. Automatic radiometric normalization of multitemporal satellite imagery with the iteratively re-weighted MAD transformation. Remote Sensing of Environment 112:1025-1036.
</p>
</li>
<li> <p>Nielsen, A.A., 2007. The regularized iteratively reweighted MAD method for change detection in multi- and hyperspectral data. IEEE Transactions on Image Processing 16(2):463-478. 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cellStats">cellStats</a></code>, <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>, <code><a href="#topic+weighted.mean">weighted.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brick(system.file("external/rlogo.grd", package="raster"))
layerStats(b, 'pearson')

layerStats(b, 'cov')

# weigh by column number
w &lt;- init(b, v='col')
layerStats(b, 'weighted.cov', w=w)
</code></pre>

<hr>
<h2 id='localFun'>Local functions</h2><span id='topic+localFun'></span><span id='topic+localFun+2CRasterLayer+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Local functions for two RasterLayer objects (using a focal neighborhood)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,RasterLayer'
localFun(x, y, ngb=5, fun, filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localFun_+3A_x">x</code></td>
<td>
<p>RasterLayer or RasterStack/RasterBrick</p>
</td></tr>
<tr><td><code id="localFun_+3A_y">y</code></td>
<td>
<p>object of the same class as <code>x</code>, and with the same number of layers</p>
</td></tr>
<tr><td><code id="localFun_+3A_ngb">ngb</code></td>
<td>
<p>integer. rectangular neighbourhood size. Either a single integer or a vector of two integers c(rows, cols), such as c(3,3) to have a 3 x 3 focal window</p>
</td></tr>
<tr><td><code id="localFun_+3A_fun">fun</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="localFun_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="localFun_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>Note</h3>

<p>The first two arguments that <code>fun</code> needs to accept are vectors representing the local cells of RasterLayer <code>x</code> and <code>y</code> (each of length <code>ngb * ngb</code>). It also must have an ellipsis (<code>...</code>) argument</p>


<h3>See Also</h3>

 <p><code><a href="#topic+corLocal">corLocal</a></code>, <code><a href="#topic+localFun">localFun</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
b &lt;- stack(system.file("external/rlogo.grd", package="raster"))
x &lt;- flip(b[[2]], 'y') + runif(ncell(b))
y &lt;- b[[1]] + runif(ncell(b))

f &lt;- localFun(x, y, fun=cor)

## Not run: 
# local regression:
rfun &lt;- function(x, y, ...) {
	m &lt;- lm(y~x)
	# return R^2
	summary(m)$r.squared
}

ff &lt;- localFun(x, y, fun=rfun)
plot(f, ff)

## End(Not run)
</code></pre>

<hr>
<h2 id='Logic-methods'>Logical operators and functions</h2><span id='topic+Logic-methods'></span><span id='topic+Logic+2CRaster+2CRaster-method'></span><span id='topic+is.na+2CRaster-method'></span><span id='topic+is.nan+2CRaster-method'></span><span id='topic+is.finite+2CRaster-method'></span><span id='topic+is.infinite+2CRaster-method'></span><span id='topic++21+2CRaster-method'></span>

<h3>Description</h3>

<p>The following logical (boolean) operators are available for computations with RasterLayer objects: 
</p>
<p><code>&amp;, |, and !</code>
</p>
<p>The following functions are available with a Raster* argument: 
</p>
<p><code>is.na</code>, <code>is.nan</code>, <code>is.finite</code>, <code>is.infinite</code>
</p>


<h3>Value</h3>

<p>A Raster object with logical (<code>TRUE/FALSE</code> values)
</p>


<h3>Note</h3>

<p>These are convenient operators/functions that are most usful for relatively small RasterLayers for which all the values can be held in memory. 
If the values of the output RasterLayer cannot be held in memory, they will be saved to a temporary file. In that case it could be more 
efficient to use <code><a href="#topic+calc">calc</a></code> instead.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Math-methods">Math-methods</a></code>, <code><a href="#topic+overlay">overlay</a></code>, <code><a href="#topic+calc">calc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=10, nrows=10)
values(r) &lt;- runif(ncell(r)) * 10
r1 &lt;- r &lt; 3 | r &gt; 6
r2 &lt;- !r1
r3 &lt;- r &gt;= 3 &amp; r &lt;= 6
r4 &lt;- r2 == r3
r[r&gt;3] &lt;- NA
r5 &lt;- is.na(r)
r[1:5]
r1[1:5]
r2[1:5]
r3[1:5]

</code></pre>

<hr>
<h2 id='mask'>Mask values in a Raster object</h2><span id='topic+mask'></span><span id='topic+mask+2CRasterLayer+2CRasterLayer-method'></span><span id='topic+mask+2CRasterStackBrick+2CRasterLayer-method'></span><span id='topic+mask+2CRasterLayer+2CRasterStackBrick-method'></span><span id='topic+mask+2CRasterStackBrick+2CRasterStackBrick-method'></span><span id='topic+mask+2CRaster+2CSpatial-method'></span><span id='topic+mask+2CRaster+2Csf-method'></span>

<h3>Description</h3>

<p>Create a new Raster* object that has the same values as <code>x</code>, except for the cells that are <code>NA</code> (or other <code>maskvalue</code>) in a 'mask'. These cells become <code>NA</code> (or other <code>updatevalue</code>). The mask can be either another Raster* object of the same extent and resolution, or a Spatial* object (e.g. SpatialPolygons) in which case all cells that are not covered by the Spatial object are set to <code>updatevalue</code>. You can use <code>inverse=TRUE</code> to set the cells that are not <code>NA</code> (or other <code>maskvalue</code>) in the mask, or not covered by the Spatial* object, to <code>NA</code> (or other <code>updatvalue</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,RasterLayer'
mask(x, mask, filename="", inverse=FALSE, 
      maskvalue=NA, updatevalue=NA, updateNA=FALSE, ...)

## S4 method for signature 'RasterStackBrick,RasterLayer'
mask(x, mask, filename="", inverse=FALSE,
      maskvalue=NA, updatevalue=NA, updateNA=FALSE, ...)

## S4 method for signature 'RasterLayer,RasterStackBrick'
mask(x, mask, filename="", inverse=FALSE, 
      maskvalue=NA, updatevalue=NA, updateNA=FALSE, ...)

## S4 method for signature 'RasterStackBrick,RasterStackBrick'
mask(x, mask, filename="", inverse=FALSE, 
      maskvalue=NA, updatevalue=NA, updateNA=FALSE, ...)

## S4 method for signature 'Raster,Spatial'
mask(x, mask, filename="", inverse=FALSE, 
      updatevalue=NA, updateNA=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="mask_+3A_mask">mask</code></td>
<td>
<p>Raster* object or a Spatial* object</p>
</td></tr>
<tr><td><code id="mask_+3A_filename">filename</code></td>
<td>
<p>character. Optional output filename</p>
</td></tr>
<tr><td><code id="mask_+3A_inverse">inverse</code></td>
<td>
<p>logical. If <code>TRUE</code>, areas on mask that are _not_ the <code>maskvalue</code> are masked</p>
</td></tr>
<tr><td><code id="mask_+3A_maskvalue">maskvalue</code></td>
<td>
<p>numeric. The value in <code>mask</code> that indicates the cells of <code>x</code> that should become <code>updatevalue</code> (default = <code>NA</code>)</p>
</td></tr>
<tr><td><code id="mask_+3A_updatevalue">updatevalue</code></td>
<td>
<p>numeric. The value that cells of <code>x</code> should become if they are not covered by <code>mask</code> (and not <code>NA</code>)</p>
</td></tr>
<tr><td><code id="mask_+3A_updatena">updateNA</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> values outside the masked area are also updated to the the <code>updatevalue</code> (only relevant if the <code>updatevalue</code> is not <code>NA</code></p>
</td></tr>
<tr><td><code id="mask_+3A_...">...</code></td>
<td>
<p>additional arguments as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster* object</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasterize">rasterize</a>, <a href="#topic+crop">crop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10)
m &lt;- raster(ncol=10, nrow=10)
values(r) &lt;- runif(ncell(r)) * 10
values(m) &lt;- runif(ncell(r))
m[m &lt; 0.5] &lt;- NA
mr &lt;- mask(r, m)

m2 &lt;- m &gt; .7
mr2 &lt;- mask(r, m2, maskvalue=TRUE)
</code></pre>

<hr>
<h2 id='match'>Value matching for Raster* objects</h2><span id='topic+match'></span><span id='topic+match+2CRaster-method'></span><span id='topic++25in+25'></span><span id='topic++25in+25+2CRaster-method'></span>

<h3>Description</h3>

<p><code>match</code> returns a Raster* object with the position of the matched values. The cell values are the index of the table argument. 
</p>
<p><code>%in%</code> returns a logical Raster* object indicating if the cells values were matched or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match(x, table, nomatch = NA_integer_, incomparables = NULL)

x %in% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="match_+3A_table">table</code></td>
<td>
<p>vector of the values to be matched against</p>
</td></tr>
<tr><td><code id="match_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned in the case when no match is found. Note that it is coerced to integer</p>
</td></tr>
<tr><td><code id="match_+3A_incomparables">incomparables</code></td>
<td>
<p>a vector of values that cannot be matched. Any value in x matching a value in this vector is assigned the nomatch value. For historical reasons, FALSE is equivalent to NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+calc">calc</a>, <a href="base.html#topic+match">match</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=10, ncol=10)
values(r) &lt;- 1:100
m &lt;- match(r, c(5:10, 50:55))
n &lt;- r %in% c(5:10, 50:55)
</code></pre>

<hr>
<h2 id='Math-methods'>Mathematical functions</h2><span id='topic+Math-methods'></span><span id='topic+Math2+2CExtent-method'></span><span id='topic+Math2+2CRaster-method'></span><span id='topic+Math+2CRaster-method'></span><span id='topic+Math+2CRasterLayerSparse-method'></span><span id='topic+log+2CRaster-method'></span>

<h3>Description</h3>

<p>Generic mathematical functions that can be used with a Raster* object as argument:   
</p>
<p><code>"abs", "sign", "sqrt", "ceiling", "floor", "trunc",  "cummax", "cummin", </code>
</p>
<p><code>"cumprod", "cumsum", "log", "log10", "log2", "log1p", "acos", "acosh", "asin", </code>
</p>
<p><code>"asinh", "atan", "atanh", "exp", "expm1", "cos", "cosh", "sin", "sinh", "tan", "tanh"</code>. 
</p>


<h3>Note</h3>

<p>You can use the, somewhat more flexible, function <code><a href="#topic+calc">calc</a></code> instead of the Math-methods.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Arith-methods">Arith-methods</a></code>, <code><a href="#topic+calc">calc</a></code>, <code><a href="#topic+overlay">overlay</a></code>, <code><a href="#topic+atan2">atan2</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- raster(nrow=10, ncol=10)
r1 &lt;- setValues(r1, runif(ncell(r1)) * 10)
r2 &lt;- sqrt(r1)
s &lt;- stack(r1, r2) - 5
b &lt;- abs(s)
</code></pre>

<hr>
<h2 id='merge'> 
Merge Raster* objects
</h2><span id='topic+merge'></span><span id='topic+merge+2CRaster+2CRaster-method'></span><span id='topic+merge+2CRasterStackBrick+2Cmissing-method'></span><span id='topic+merge+2CExtent+2CANY-method'></span>

<h3>Description</h3>

<p>Merge Raster* objects to form a new Raster object with a larger spatial extent. If objects overlap, the values get priority in the same order as the arguments, but <code>NA</code> values are ignored (except when <code>overlap=FALSE</code>). See <code><a href="#topic+subs">subs</a></code> to merge a <code>Raster*</code> object and a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,Raster'
merge(x, y, ..., tolerance=0.05, filename="", overlap=TRUE, ext=NULL)

## S4 method for signature 'RasterStackBrick,missing'
merge(x, ..., tolerance=0.05, filename="", ext=NULL)

## S4 method for signature 'Extent,ANY'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_+3A_x">x</code></td>
<td>
<p>Raster* or Extent object</p>
</td></tr>
<tr><td><code id="merge_+3A_y">y</code></td>
<td>
<p>Raster* if <code>x</code> is a Raster* object (or missing). If <code>x</code> is an Extent, <code>y</code> can be an Extent or object from which an Extent can be extracted</p>
</td></tr>
<tr><td><code id="merge_+3A_...">...</code></td>
<td>
<p>additional Raster or Extent objects (and/or arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a>)</code></p>
</td></tr>
<tr><td><code id="merge_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric. permissible difference in origin (relative to the cell resolution). See <code><a href="base.html#topic+all.equal">all.equal</a></code></p>
</td></tr>
<tr><td><code id="merge_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="merge_+3A_overlap">overlap</code></td>
<td>
<p>logical. If <code>FALSE</code> values of overlapping objects are based on the first layer, even if they are <code>NA</code></p>
</td></tr>
<tr><td><code id="merge_+3A_ext">ext</code></td>
<td>
<p>Extent object (optional) to limit the output to that extent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Raster objects must have the same origin and resolution. In areas where the Raster objects overlap, the values of the Raster object that is first in the sequence of arguments will be retained. If you would rather use the average of cell values, or do another computation, you can use <code><a href="#topic+mosaic">mosaic</a></code> instead of merge.
</p>


<h3>Value</h3>

<p>RasterLayer or RasterBrick
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- raster(xmx=-150, ymn=60, ncols=30, nrows=30)
values(r1) &lt;- 1:ncell(r1)
r2 &lt;- raster(xmn=-100, xmx=-50, ymx=50, ymn=30)
res(r2) &lt;- c(xres(r1), yres(r1))
values(r2) &lt;- 1:ncell(r2)
rm &lt;- merge(r1, r2)

# if you have many RasterLayer objects in a list
# you can use do.call:
x &lt;- list(r1, r2)
# add arguments such as filename
# x$filename &lt;- 'test.tif'
m &lt;- do.call(merge, x)
</code></pre>

<hr>
<h2 id='metadata'> Metadata </h2><span id='topic+metadata'></span><span id='topic+metadata+2CRaster-method'></span><span id='topic+metadata+3C-'></span>

<h3>Description</h3>

<p>Get or set a metadata to a Raster object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
metadata(x)
metadata(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metadata_+3A_x">x</code></td>
<td>
<p>Raster* object </p>
</td></tr>
<tr><td><code id="metadata_+3A_value">value</code></td>
<td>
<p>list with named elements. Each element may be another list of named elements (but these nested lists are not allowed to be lists themselves)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster* object or list
</p>


<h3>Note</h3>

<p>The metadata can contain single values or vectors of basic data types (character, integer, numeric) and Date. Some other types may also be supported. You cannot use a matrix or data.frame as a meta-data element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(nc=10, nr=10)
values(r) &lt;- 1:ncell(r)

m &lt;- list(wave=list(a=1, b=2, c=c('cool', 'important')), that=list(red='44', blue=1:5,
       days=as.Date(c('2014-1-15','2014-2-15'))), this='888 miles from here', today=NA)

metadata(r) &lt;- m

## Not run: 

x &lt;- writeRaster(r, rasterTmpFile(), overwrite=TRUE)
metax &lt;- metadata(x)

identical(metax, m)

# nested too deep
badmeta1 &lt;- list(wave=list(a=1, b=2, c='x'), that=list(red='4', blue=list(bad=5)))
metadata(r) &lt;- badmeta1

# missing names
badmeta2 &lt;- list(wave=list(1, 2, c='x'), that=list(red='44', blue=14), this='8m')
metadata(r) &lt;- badmeta2

# matrix not allowed
badmeta3 &lt;- list(wave=list(a=1, b=matrix(1:4, ncol=2), c='x'), that=list(red='4'))
metadata(r) &lt;- badmeta3

## End(Not run)
</code></pre>

<hr>
<h2 id='modal'>modal value</h2><span id='topic+modal'></span><span id='topic+modal+2CANY-method'></span><span id='topic+modal+2CRaster-method'></span>

<h3>Description</h3>

<p>Compute the mode for a vector of numbers, or across raster layers. The mode, or modal value, is the most frequent value in a set of values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
modal(x, ..., ties='random', na.rm=FALSE, freq=FALSE)

## S4 method for signature 'Raster'
modal(x, ..., ties='random', na.rm=FALSE, freq=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modal_+3A_x">x</code></td>
<td>
<p>vector of numbers (typically integers), characters, logicals, or factors, or a Raster* object</p>
</td></tr>
<tr><td><code id="modal_+3A_...">...</code></td>
<td>
<p>additional argument of the same type as <code>x</code></p>
</td></tr>
<tr><td><code id="modal_+3A_ties">ties</code></td>
<td>
<p>character. Indicates how to treat ties. Either 'random', 'lowest', 'highest', 'first', or 'NA'</p>
</td></tr>
<tr><td><code id="modal_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> values are ignored. If <code>FALSE</code>, <code>NA</code> is returned if <code>x</code> has any <code>NA</code> values</p>
</td></tr>
<tr><td><code id="modal_+3A_freq">freq</code></td>
<td>
<p>return the frequency of the modal value, instead of the modal value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or RasterLayer. The vector has length 1 and is of the same type as <code>x</code>, except when <code>x</code> is a factor and additional arguments (values) are supplied, in which case the values are coerced to characters and a character value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- c(0,1,2,3,3,3,3,4,4,4,5,5,6,7,7,8,9,NA)
modal(data, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='mosaic'> 
Merge Raster* objects using a function for overlapping areas 
</h2><span id='topic+mosaic'></span><span id='topic+mosaic+2CRaster+2CRaster-method'></span>

<h3>Description</h3>

<p>Mosaic Raster* objects to form a new object with a larger spatial extent. A function is used to compute cell values in areas where layers overlap (in contrast to the <code><a href="#topic+merge">merge</a></code> function  which uses the values of the 'upper' layer). All objects must have the same origin, resolution, and coordinate reference system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,Raster'
mosaic(x, y, ..., fun, tolerance=0.05, filename="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="mosaic_+3A_y">y</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="mosaic_+3A_...">...</code></td>
<td>
<p>Additional Raster or Extent objects (and/or arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a>)</code></p>
</td></tr>
<tr><td><code id="mosaic_+3A_fun">fun</code></td>
<td>
<p>Function. E.g. mean, min, or max. Must be a function that accepts a 'na.rm' argument</p>
</td></tr>
<tr><td><code id="mosaic_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric. permissible difference in origin (relative to the cell resolution). See <code><a href="base.html#topic+all.equal">all.equal</a></code></p>
</td></tr>
<tr><td><code id="mosaic_+3A_filename">filename</code></td>
<td>
<p>Character. Output filename (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Raster objects must have the same origin and resolution. 
</p>


<h3>Value</h3>

<p>RasterLayer or RasterBrick object.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+merge">merge</a></code>, <code><a href="#topic+extend">extend</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=100, nrow=100)
r1 &lt;- crop(r, extent(-10, 11, -10, 11))
r2 &lt;- crop(r, extent(0, 20, 0, 20))
r3 &lt;- crop(r, extent(9, 30, 9, 30))

values(r1) &lt;- 1:ncell(r1)
values(r2) &lt;- 1:ncell(r2)
values(r3) &lt;- 1:ncell(r3)

m1 &lt;- mosaic(r1, r2, r3, fun=mean)

s1 &lt;- stack(r1, r1*2)
s2 &lt;- stack(r2, r2/2)
s3 &lt;- stack(r3, r3*4)
m2 &lt;- mosaic(s1, s2, s3, fun=min)

# if you have a list of Raster objects, you can use do.call
x &lt;- list(r1, r2, r3)
names(x)[1:2] &lt;- c('x', 'y')
x$fun &lt;- mean
x$na.rm &lt;- TRUE

y &lt;- do.call(mosaic, x)

</code></pre>

<hr>
<h2 id='movingFun'>Moving functions</h2><span id='topic+movingFun'></span>

<h3>Description</h3>

<p>Helper function to compute 'moving' functions, such as the 'moving average'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movingFun(x, n, fun=mean, type='around', circular=FALSE, na.rm=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movingFun_+3A_x">x</code></td>
<td>
<p>A vector of numbers</p>
</td></tr>
<tr><td><code id="movingFun_+3A_n">n</code></td>
<td>
<p>Size of the 'window', i.e. the number of sequential elements to use in the function</p>
</td></tr>
<tr><td><code id="movingFun_+3A_fun">fun</code></td>
<td>
<p>A function like mean, min, max, sum</p>
</td></tr>
<tr><td><code id="movingFun_+3A_type">type</code></td>
<td>
<p>Character. One of 'around', 'to', or 'from'. The choice indicates which values should be used in the computation. The focal element is always used. If <code>type</code> is 'around', the other elements are before and after the focal element. Alternatively, you can select the elements preceding the focal element ('to') or those coming after it ('from'). For example, to compute the movingFun with <code>n=3</code> for element 5 of a vector; 'around' used elements 4,5,6; 'to' used elements 3,4,5, and 'from' uses elements 5,6,7</p>
</td></tr>
<tr><td><code id="movingFun_+3A_circular">circular</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the data are considered to have a circular nature (e.g. months of the year), and the last elements in vector <code>x</code> are used in the computation of the moving function of the first element(s) of the vector, and the first elements are used in the computation of the moving function for the last element(s)</p>
</td></tr>
<tr><td><code id="movingFun_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>NA</code> values should be ingored (by <code>fun</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans, inspired by Diethelm Wuertz' rollFun function in the fTrading package</p>


<h3>Examples</h3>

<pre><code class='language-R'>movingFun(1:12, 3, mean)
movingFun(1:12, 3, mean, 'to')
movingFun(1:12, 3, mean, 'from')
movingFun(1:12, 3, mean, circular=TRUE)

v &lt;- c(0,1,2,3,3,3,3,4,4,4,5,5,6,7,7,8,9,NA)
movingFun(v, n=5)
movingFun(v, n=5, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='names'>Names of raster layers</h2><span id='topic+labels+2CRaster-method'></span><span id='topic+names'></span><span id='topic+names+3C-'></span><span id='topic+names+2CRaster-method'></span><span id='topic+names+2CRasterStack-method'></span><span id='topic+names+3C-+2CRaster-method'></span>

<h3>Description</h3>

<p>Get or set the names of the layers of a Raster* object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
names(x)

## S4 replacement method for signature 'Raster'
names(x)&lt;-value

## S4 method for signature 'Raster'
labels(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="names_+3A_object">object</code></td>
<td>
<p>Raster* object</p>
</td></tr>  
<tr><td><code id="names_+3A_value">value</code></td>
<td>
<p>character (vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nlayers">nlayers</a>, <a href="#topic+bands">bands</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=5, nrows=5)
values(r) &lt;- 1:ncell(r)
s &lt;- stack(r, r, r)
nlayers(s)
names(s)
names(s) &lt;- c('a', 'b', 'c')
names(s)[2] &lt;- 'hello world'
names(s)
s
labels(s)
</code></pre>

<hr>
<h2 id='NAvalue'>Set the NA value of a RasterLayer </h2><span id='topic+NAvalue+3C-'></span><span id='topic+NAvalue'></span>

<h3>Description</h3>

<p>NAvalue returns the value that is used to write NA values to disk (in 'raster' type files). 
If you set the NA value of a Raster* object, this value will be interpreted as NA when reading the values from a file. 
Values already in memory will not be affected. 
</p>
<p>If the NA value is smaller than zero, all values smaller or equal to that number will be set to NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NAvalue(x) &lt;- value
NAvalue(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NAvalue_+3A_x">x</code></td>
<td>
<p>A <code>Raster</code> object</p>
</td></tr>
<tr><td><code id="NAvalue_+3A_value">value</code></td>
<td>
<p>the value to be interpreted as NA; set this before reading the values from the file. Integer values are matched exactly; for decimal values files any value &lt;= the value will be interpreted as NA</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Returns or set the NA value used for storage on disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r1 &lt;- raster(system.file("external/rlogo.grd", package="raster"))
r2 &lt;- r1
NAvalue(r2)
NAvalue(r2) &lt;- 255
#plot(r1)
#x11()
#plot(r2)
</code></pre>

<hr>
<h2 id='ncell'>Number or rows, columns, and cells of a Raster* object</h2><span id='topic+ncol'></span><span id='topic+nrow'></span><span id='topic+nrow+2CBasicRaster-method'></span><span id='topic+ncol+2CBasicRaster-method'></span><span id='topic+ncell'></span><span id='topic+ncell+2CANY-method'></span><span id='topic+ncell+2CBasicRaster-method'></span><span id='topic+length+2CBasicRaster-method'></span><span id='topic+nrow+3C-'></span><span id='topic+ncol+3C-'></span><span id='topic+nrow+3C-+2CBasicRaster+2Cnumeric-method'></span><span id='topic+ncol+3C-+2CBasicRaster+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Get the number of rows, columns, or cells of a Raster* object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncol(x)
nrow(x)
ncell(x)
ncol(x, ...) &lt;- value
nrow(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncell_+3A_x">x</code></td>
<td>
<p>a Raster object</p>
</td></tr>
<tr><td><code id="ncell_+3A_value">value</code></td>
<td>
<p>row or column number (integer &gt; 0)</p>
</td></tr>  
<tr><td><code id="ncell_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Integer
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dim">dim</a>, <a href="#topic+extent">extent</a></code>, <a href="#topic+res">res</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
ncell(r)
ncol(r)
nrow(r)
dim(r)

nrow(r) &lt;- 18
ncol(r) &lt;- 36
# equivalent to
dim(r) &lt;- c(18, 36) 
</code></pre>

<hr>
<h2 id='nlayers'>Number of layers</h2><span id='topic+nlayers'></span><span id='topic+nlayers+2CBasicRaster-method'></span><span id='topic+nlayers+2CRaster-method'></span><span id='topic+nlayers+2CRasterStack-method'></span><span id='topic+nlayers+2CRasterBrick-method'></span><span id='topic+nlayers+2CSpatial-method'></span>

<h3>Description</h3>

<p>Get the number of layers in a Raster* object, typically used with a (multilayer) RasterStack or RasterBrick object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlayers(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlayers_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+names">names</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=10, nrows=10)
values(r) &lt;- 1:ncell(r)
s &lt;- stack(r, r, r)
nlayers(s)
s &lt;- stack(s,s)
nlayers(s)
s &lt;- dropLayer(s, 2:3)
nlayers(s)

</code></pre>

<hr>
<h2 id='Options'>Global options for the raster package</h2><span id='topic+rasterOptions'></span><span id='topic+tmpDir'></span>

<h3>Description</h3>

<p>Set, inspect, reset, save a number of global options used by the raster package.
</p>
<p>Most of these options are used when writing files to disk. They can be ignored by specific functions if the corresponding argument is provided as an argument to these functions.
</p>
<p>The default location is returned by <code>rasterTmpDir</code>. It is the same as that of the R temp directory but you can change it (for the current session) with <code>rasterOptions(tmpdir="path")</code>.
</p>
<p>To permanently set any of these options, you can add them to <code>&lt;your R installation&gt;/etc/Rprofile.site&gt;</code>. For example, to change the default directory used to save temporary files, add a line like this: <code>options(rasterTmpDir='c:/temp/')</code> to that file. All temporary raster files in that folder that are older than 24 hrs are deleted when the raster package is loaded.
</p>
<p>Function <code>tmpDir</code> returns the location of the temporary files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterOptions(format, overwrite, datatype, tmpdir, tmptime, progress,
     timer, chunksize, minmemory, maxmemory, memfrac, todisk, setfileext, 
	 tolerance, standardnames, depracatedwarnings, addheader, default=FALSE)


tmpDir(create=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Options_+3A_format">format</code></td>
<td>
<p>character. The default file format to use. See <code><a href="#topic+writeFormats">writeFormats</a></code></p>
</td></tr>
<tr><td><code id="Options_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. The default value for overwriting existing files. If <code>TRUE</code>, existing files will be overwritten</p>
</td></tr>
<tr><td><code id="Options_+3A_datatype">datatype</code></td>
<td>
<p>character. The default data type to use. See <a href="#topic+dataType">dataType</a></p>
</td></tr>
<tr><td><code id="Options_+3A_tmpdir">tmpdir</code></td>
<td>
<p>character. The default location for writing temporary files; See <code><a href="#topic+rasterTmpFile">rasterTmpFile</a></code></p>
</td></tr>
<tr><td><code id="Options_+3A_tmptime">tmptime</code></td>
<td>
<p>number &gt; 1. The number of hours after which a temporary file will be deleted. As files are deleted when loading the raster package, this option is only useful if you  save this option so that it is loaded when starting a new session</p>
</td></tr>
<tr><td><code id="Options_+3A_progress">progress</code></td>
<td>
<p>character. Valid values are &quot;text&quot;,  &quot;window&quot; and &quot;&quot; (the default in most functions, no progress bar)</p>
</td></tr>
<tr><td><code id="Options_+3A_timer">timer</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the time it took to complete the function is printed</p>
</td></tr>
<tr><td><code id="Options_+3A_chunksize">chunksize</code></td>
<td>
<p>integer. Maximum number of bytes to read/write in a single chunk while processing (chunk by chunk) disk based Raster* objects</p>
</td></tr>
<tr><td><code id="Options_+3A_maxmemory">maxmemory</code></td>
<td>
<p>numeric. Maximum number of bytes to read into memory. If a process is expected to require more than this value, <code><a href="#topic+canProcessInMemory">canProcessInMemory</a></code> will return <code>FALSE</code>. It cannot be set to a value smaller than 10000 </p>
</td></tr>
<tr><td><code id="Options_+3A_minmemory">minmemory</code></td>
<td>
<p>numeric. Minimum number of bytes that are guaranteed to be fit into memory. If a process is expected to require more than this value, RAM available will be estimated. It cannot be set to a value smaller than 10000</p>
</td></tr>
<tr><td><code id="Options_+3A_memfrac">memfrac</code></td>
<td>
<p>numeric. Fraction of available RAM that may be used by a process</p>
</td></tr>
<tr><td><code id="Options_+3A_todisk">todisk</code></td>
<td>
<p>logical. For debugging only. Default is <code>FALSE</code> and should normally not be changed. If <code>TRUE</code>, results are always written to disk, even if no filename is supplied (a temporary filename is used)</p>
</td></tr>
<tr><td><code id="Options_+3A_setfileext">setfileext</code></td>
<td>
<p>logical. Default is <code>TRUE</code>. If <code>TRUE</code>, the file extension will be changed when writing (if known for the file type). E.g. GTiff files will be saved with the .tif extension </p>
</td></tr>
<tr><td><code id="Options_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric. The tolerance used when comparing the origin and resolution of Raster* objects. Expressed as the fraction of a single cell. This should be a number between 0 and 0.5 </p>
</td></tr>
<tr><td><code id="Options_+3A_standardnames">standardnames</code></td>
<td>
<p>logical. Default is <code>TRUE</code>. Should <code><a href="#topic+names">names</a></code> be standardized to be syntactically valid names (using <code><a href="base.html#topic+make.names">make.names</a></code>)</p>
</td></tr>
<tr><td><code id="Options_+3A_depracatedwarnings">depracatedwarnings</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) a warning is generated when a depracated (obsolete) function is used</p>
</td></tr>
<tr><td><code id="Options_+3A_addheader">addheader</code></td>
<td>
<p>character. If not equal to <code>''</code> (the default) an additional header file is written when a raster format file (grd/gri) is written. Supported formats are as in <code><a href="#topic+hdr">hdr</a></code></p>
</td></tr>
<tr><td><code id="Options_+3A_default">default</code></td>
<td>
<p>logical. If <code>TRUE</code>, all options are set to their default values</p>
</td></tr>
<tr><td><code id="Options_+3A_create">create</code></td>
<td>
<p>logical. If <code>TRUE</code>, the temporary files directory is created if it does not exist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of the current options (invisibly). If no arguments are provided the options are printed.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+options">options</a></code>, <code><a href="#topic+rasterTmpFile">rasterTmpFile</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rasterOptions()
rasterOptions(chunksize=2e+07)

## End(Not run)
</code></pre>

<hr>
<h2 id='origin'>Origin</h2><span id='topic+origin'></span><span id='topic+origin+2CBasicRaster-method'></span><span id='topic+origin+3C-'></span><span id='topic+origin+3C-+2CBasicRaster-method'></span>

<h3>Description</h3>

<p>Origin returns (or sets) the coordinates of the point of origin of a Raster* object. This is the point closest to (0, 0) that you could get if you moved towards that point in steps of the x and y resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>origin(x, ...)
origin(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="origin_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="origin_+3A_value">value</code></td>
<td>
<p>numeric vector of length 1 or 2</p>
</td></tr>
<tr><td><code id="origin_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A vector of two numbers (x and y coordinates), or a changed origin for <code>x</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+extent">extent</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(xmn=-0.5, xmx = 9.5, ncols=10)
origin(r)
r
origin(r) &lt;- 0
r
</code></pre>

<hr>
<h2 id='overlay'>Overlay Raster objects</h2><span id='topic+overlay'></span><span id='topic+overlay+2CRaster+2CRaster-method'></span><span id='topic+overlay+2CRaster+2Cmissing-method'></span>

<h3>Description</h3>

<p>Create a new Raster* object, based on two or more Raster* objects. (You can also use a single object, but perhaps <code><a href="#topic+calc">calc</a></code> is what you are looking for in that case).
</p>
<p>You should supply a function <code>fun</code> to set the way that the RasterLayers are combined. The number of arguments in the function must match the number of Raster objects (or take any number). For example, if you combine two RasterLayers you could use multiply: <code>fun=function(x,y){return(x*y)}</code> percentage: <code>fun=function(x,y){return(100 * x / y)}</code>. If you combine three layers you could use <code>fun=function(x,y,z){return((x + y) * z)}</code>
</p>
<p>Note that the function must work for vectors (not only for single numbers). That is, it must return the same number of elements as its input vectors. Alternatively, you can also supply a function such as <code>sum</code>, that takes <code>n</code> arguments (as <code>'...'</code>), and perhaps also has a <code>na.rm</code> argument, like in <code>sum(..., na.rm)</code>.
</p>
<p>If a single mutli-layer object is provided, its layers are treated as individual RasterLayer objects if the argument <code>unstack=TRUE</code> is used. If multiple objects are provided, they should have the same number of layers, or it should be possible to recycle them (e.g., 1, 3, and 9 layers, which would return a RasterBrick with 9 layers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,Raster'
overlay(x, y, ..., fun, filename="", recycle=TRUE, forcefun=FALSE)

## S4 method for signature 'Raster,missing'
overlay(x, y, ..., fun, filename="", unstack=TRUE, forcefun=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlay_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="overlay_+3A_y">y</code></td>
<td>
<p>Raster* object, or missing (only useful if <code>x</code> has multiple layers)</p>
</td></tr>
<tr><td><code id="overlay_+3A_...">...</code></td>
<td>
<p>Additional Raster objects (and/or arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a>)</code></p>
</td></tr>    
<tr><td><code id="overlay_+3A_fun">fun</code></td>
<td>
<p>Function to be applied. When using RasterLayer objects, the number of arguments of the function should match the number of Raster objects, or it should take any number of arguments. When using multi-layer objects the function should match the number of layers of the RasterStack/Brick object (unless unstack=FALSE) </p>
</td></tr>
<tr><td><code id="overlay_+3A_filename">filename</code></td>
<td>
<p>Character. Output filename (optional) </p>
</td></tr>
<tr><td><code id="overlay_+3A_recycle">recycle</code></td>
<td>
<p>Logical. Should layers from Raster objects with fewer layers be recycled?</p>
</td></tr>  
<tr><td><code id="overlay_+3A_unstack">unstack</code></td>
<td>
<p>Logical. Should layers be unstacked before computation (i.e. does the <code>fun</code> refer to individual layers in a multilayer object)?</p>
</td></tr>  
<tr><td><code id="overlay_+3A_forcefun">forcefun</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, overlay will not attempt to internally use apply (it is rarely necessary to use this argument)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of the overlay function you can also use arithmetic functions such as <code>*, /, +, -</code> with Raster objects (see examples). In that case you cannot specify an output filename. Moreover, the overlay function should be more efficient when using large data files that cannot be loaded into memory, as the use of the complex arithmetic functions might lead to the creation of many temporary files.
</p>
<p>While you can supply functions such as <code>sum</code> or <code>mean</code>, it would be more direct to use the Raster* objects as arguments to those functions (e.g. <code>sum(r1,r2,r3)</code>)  
</p>
<p>See <code><a href="#topic+rasterize">rasterize</a></code> and <code><a href="#topic+extract">extract</a></code> for &quot;overlays&quot; involving Raster* objects and polygons, lines, or points.
</p>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+calc">calc</a>,  <a href="#topic+Arith-methods">Arith-methods</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10)
r1 &lt;- init(r, fun=runif)
r2 &lt;- init(r, fun=runif)
r3 &lt;- overlay(r1, r2, fun=function(x,y){return(x+y)})

# long version for multiplication
r4 &lt;- overlay(r1, r2, fun=function(x,y){(x*y)} )

#use the individual layers of a RasterStack to get a RasterLayer
s &lt;- stack(r1, r2)
r5 &lt;- overlay(s, fun=function(x,y) x*y )
# equivalent to
r5c &lt;- calc(s, fun=function(x) x[1]*x[2] )


#Combine RasterStack and RasterLayer objects (s2 has four layers. 
# r1 (one layer) and s (two layers) are recycled) 
s2 &lt;- stack(r1, r2, r3, r4)
b &lt;- overlay(r1, s, s2, fun=function(x,y,z){return(x*y*z)} )

# use a single RasterLayer (same as calc function)
r6 &lt;- overlay(r1, fun=sqrt)

# multiplication with more than two layers 
# (make sure the number of RasterLayers matches the arguments of 'fun')
r7 &lt;- overlay(r1, r2, r3, r4, fun=function(a,b,c,d){return(a*b+c*d)} )  
# equivalent function, efficient if values can be loaded in memory
r8 &lt;- r1 * r2 + r3 * r4

# Also works with multi-layer objects. 
s1 &lt;- stack(r1, r2, r3)
x &lt;- overlay(s1, s1, fun=function(x,y)x+y+5)

# in this case the first layer of the shorter object is recycled.
# i.e., s2 is treated as stack(r1, r3, r1)
s2 &lt;- stack(r1, r3)
y &lt;- overlay(s1, s2, fun=sum)
</code></pre>

<hr>
<h2 id='pairs'>
Pairs plot (matrix of scatterplots)
</h2><span id='topic+pairs'></span><span id='topic+pairs+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Pair plots of layers in a RasterStack or RasterBrick. This is a wrapper around graphics function <code><a href="graphics.html#topic+pairs">pairs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterStackBrick'
pairs(x, hist=TRUE, cor=TRUE, use="pairwise.complete.obs", maxpixels=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs_+3A_x">x</code></td>
<td>
<p>RasterBrick or RasterStack</p>
</td></tr>
<tr><td><code id="pairs_+3A_hist">hist</code></td>
<td>
<p>Logical. If TRUE a histogram of the values is shown on the diagonal</p>
</td></tr>
<tr><td><code id="pairs_+3A_cor">cor</code></td>
<td>
<p>Logical. If TRUE the correlation coefficient is shown in the upper panels</p>
</td></tr>
<tr><td><code id="pairs_+3A_use">use</code></td>
<td>
<p>Argument passed to the <code><a href="stats.html#topic+cor">cor</a></code> function</p>
</td></tr>
<tr><td><code id="pairs_+3A_maxpixels">maxpixels</code></td>
<td>
<p>Integer. Number of pixels to sample from each layer of large Raster objects</p>
</td></tr>
<tr><td><code id="pairs_+3A_...">...</code></td>
<td>
<p>Additional arguments (only <code>cex</code> and <code>main</code>)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+boxplot">boxplot</a>, <a href="#topic+hist">hist</a>, <a href="#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/test.grd", package="raster") )
s &lt;- stack(r, 1/r, sqrt(r))
pairs(s)

## Not run: 
# to make indvidual histograms:
hist(r)
# or scatter plots:
plot(r, 1/r)

## End(Not run)
</code></pre>

<hr>
<h2 id='persp'>Perspective plot</h2><span id='topic+persp'></span><span id='topic+persp+2CRasterLayer-method'></span><span id='topic+persp+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Perspective plot of a RasterLayer. This is an implementation of a generic function in the graphics package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
persp(x,  maxpixels=1e+05, ext=NULL, ...)

## S4 method for signature 'RasterStackBrick'
persp(x, y=1, maxpixels=10000, ext=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="persp_+3A_y">y</code></td>
<td>
<p>integer <code>&gt; 0 &amp; &lt;= nlayers(x)</code> to select the layer of <code>x</code> if <code>x</code> is a RasterLayer or RasterBrick</p>
</td></tr>
<tr><td><code id="persp_+3A_maxpixels">maxpixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to use for the plot. If <code>maxpixels &lt; ncell(x)</code>, <code>sampleRegular</code> is used before plotting</p>
</td></tr>
<tr><td><code id="persp_+3A_ext">ext</code></td>
<td>
<p>Extent. Can be used to zoom in to a region (see also <code><a href="#topic+zoom">zoom</a></code> and <code><a href="#topic+crop">crop</a>(x, <a href="#topic+drawExtent">drawExtent</a>())</code></p>
</td></tr>
<tr><td><code id="persp_+3A_...">...</code></td>
<td>
<p>Any argument that can be passed to <code><a href="graphics.html#topic+persp">persp</a></code> (graphics package)</p>
</td></tr>  
</table>


<h3>See Also</h3>

 <p><code><a href="rasterVis.html#topic+plot3d">plot3D</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="#topic+contour">contour</a></code>, <code><a href="#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(system.file("external/test.grd", package="raster"))
persp(r)
</code></pre>

<hr>
<h2 id='plot'>Plot a Raster* object</h2><span id='topic+plot'></span><span id='topic+plot+2CRaster+2CANY-method'></span><span id='topic+plot+2CRaster+2CRaster-method'></span><span id='topic+plot+2CExtent+2Cmissing-method'></span><span id='topic+lines+2CRasterLayer-method'></span><span id='topic+lines+2CExtent-method'></span>

<h3>Description</h3>

<p>Plot (that is, make a map of) the values of a Raster* object, or make a scatterplot of their values.
</p>
<p>Points, lines, and polygons can be drawn on top of a map using <code>plot(..., add=TRUE)</code>, or with functions like <code>points, lines, polygons</code>
</p>
<p>See the <code>rasterVis</code> package for more advanced (trellis/lattice) plotting of Raster* objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,ANY'
plot(x, y, maxpixels=500000, col, alpha=NULL,
   colNA=NA, add=FALSE, ext=NULL, useRaster=TRUE, interpolate=FALSE, 
   addfun=NULL, nc, nr, maxnl=16, main, npretty=0, ...)
   

## S4 method for signature 'Raster,Raster'
plot(x, y, maxpixels=100000, cex, xlab, ylab, nc, nr, 
    maxnl=16, main, add=FALSE, gridded=FALSE, ncol=25, nrow=25, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>If <code>x</code> is a RasterStack or RasterBrick: integer, character (layer name(s)), or missing to select which layer(s) to plot. If missing, all RasterLayers in the RasterStack will be plotted (up to a maximum of 16). Or another Raster* object of the same extent and resolution, to produce a scatter plot of the cell values. </p>
</td></tr>
<tr><td><code id="plot_+3A_maxpixels">maxpixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to use for the plot. If <code>maxpixels &lt; ncell(x)</code>, <code>sampleRegular</code> is used before plotting. If <code>gridded=TRUE</code> maxpixels may be ignored to get a larger sample</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>A color palette, i.e. a vector of n contiguous colors generated by functions like <a href="grDevices.html#topic+rainbow">rainbow</a>, <a href="grDevices.html#topic+heat.colors">heat.colors</a>, <a href="grDevices.html#topic+topo.colors">topo.colors</a>, <a href="sp.html#topic+bpy.colors">bpy.colors</a> or one or your own making, perhaps using <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>. If none is provided, <code>rev(terrain.colors(255))</code> is used unless <code>x</code> has a 'color table'</p>
</td></tr>
<tr><td><code id="plot_+3A_alpha">alpha</code></td>
<td>
<p>Number between 0 and 1 to set transparency. 0 is entirely transparent, 1 is not transparent (NULL is equivalent to 1)</p>
</td></tr>
<tr><td><code id="plot_+3A_colna">colNA</code></td>
<td>
<p>The color to use for the background (default is transparent)</p>
</td></tr>  
<tr><td><code id="plot_+3A_add">add</code></td>
<td>
<p>Logical. Add to current plot?</p>
</td></tr>
<tr><td><code id="plot_+3A_ext">ext</code></td>
<td>
<p>An extent object to zoom in a region (see also <code><a href="#topic+zoom">zoom</a></code> and <code><a href="#topic+crop">crop</a>(x, <a href="#topic+drawExtent">drawExtent</a>())</code></p>
</td></tr>
<tr><td><code id="plot_+3A_useraster">useRaster</code></td>
<td>
<p>If <code>TRUE</code>, the rasterImage function is used for plotting. Otherwise the image function is used. This can be useful if rasterImage does not work well on your system (see note)</p>
</td></tr>
<tr><td><code id="plot_+3A_interpolate">interpolate</code></td>
<td>
<p>Logical. Should the image be interpolated (smoothed)? Only used when <code>useRaster = TRUE</code></p>
</td></tr>
<tr><td><code id="plot_+3A_addfun">addfun</code></td>
<td>
<p>Function to add additional items such as points or polygons to the plot (map). Typically containing statements like
&quot;points(xy); plot(polygons, add=TRUE)&quot;. This is particularly useful to add something to each map when plotting a multi-layer Raster* object.</p>
</td></tr>
<tr><td><code id="plot_+3A_npretty">npretty</code></td>
<td>
<p>integer. Number of decimals for <a href="base.html#topic+pretty">pretty</a> lables on the axes</p>
</td></tr>  
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Graphical parameters. Any argument that can be passed to <code><a href="fields.html#topic+image.plot">image.plot</a></code> and to base <code>plot</code>, 
such as axes=FALSE, main='title', ylab='latitude'</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code></td>
<td>
<p>Optional. x-axis label)</p>
</td></tr>
<tr><td><code id="plot_+3A_ylab">ylab</code></td>
<td>
<p>Optional. y-axis label)</p>
</td></tr>
<tr><td><code id="plot_+3A_nc">nc</code></td>
<td>
<p>Optional. The number of columns to divide the plotting device in (when plotting multiple layers in a RasterLayer or RasterBrick object)</p>
</td></tr>
<tr><td><code id="plot_+3A_nr">nr</code></td>
<td>
<p>Optional. The number of rows to divide the plotting device in (when plotting multiple layers in a RasterLayer or RasterBrick object)</p>
</td></tr>
<tr><td><code id="plot_+3A_maxnl">maxnl</code></td>
<td>
<p>integer. Maximum number of layers to plot (for a multi-layer object)</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>character. Main plot title</p>
</td></tr>
<tr><td><code id="plot_+3A_cex">cex</code></td>
<td>
<p>Symbol size for scatter plots</p>
</td></tr>
<tr><td><code id="plot_+3A_gridded">gridded</code></td>
<td>
<p>logical. If <code>TRUE</code> the scatterplot is gridded (counts by cells)</p>
</td></tr>
<tr><td><code id="plot_+3A_ncol">ncol</code></td>
<td>
<p>integer. Number of columns for gridding</p>
</td></tr>
<tr><td><code id="plot_+3A_nrow">nrow</code></td>
<td>
<p>integer. Number of rows for gridding</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the code for the plot function for a single Raster* object was taken from image.plot (fields package). 
</p>
<p>Raster objects with a color-table (e.g. a graphics file) are plotted according to that color table.
</p>


<h3>Note</h3>

<p>raster uses <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> from the graphics package. For unknown reasons this does not work on Windows Server and on a few versions of Windows XP. On that system you may need to use argument <code>useRaster=FALSE</code> to get a plot.
</p>


<h3>See Also</h3>

<p>The <code>rasterVis</code> package has lattice based methods for plotting Raster* objects (like <code><a href="#topic+spplot">spplot</a></code>)
</p>
<p>red-green-blue plots (e.g. false color composites) can be made with <code><a href="#topic+plotRGB">plotRGB</a></code>
</p>
<p><code><a href="#topic+barplot">barplot</a></code>, <code><a href="#topic+hist">hist</a></code>, <code><a href="#topic+text">text</a></code>, <code><a href="#topic+persp">persp</a></code>, <code><a href="#topic+contour">contour</a></code>, <code><a href="#topic+pairs">pairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# RasterLayer
r &lt;- raster(nrows=10, ncols=10)
r &lt;- setValues(r, 1:ncell(r))
plot(r)

e &lt;- extent(r)
plot(e, add=TRUE, col='red', lwd=4)
e &lt;- e / 2
plot(e, add=TRUE, col='red')


# Scatterplot of 2 RasterLayers
r2 &lt;- sqrt(r)
plot(r, r2)
plot(r, r2, gridded=TRUE)

# Multi-layer object (RasterStack / Brick)
s &lt;- stack(r, r2, r/r)
plot(s, 2)
plot(s)

# two objects, different range, one scale:
values(r) &lt;- runif(ncell(r))
r2 &lt;- r/2
brks &lt;- seq(0, 1, by=0.1) 
nb &lt;- length(brks)-1 
cols &lt;- rev(terrain.colors(nb))
par(mfrow=c(1,2))
plot(r, breaks=brks, col=cols, lab.breaks=brks, zlim=c(0,1), main='first') 
plot(r2, breaks=brks, col=cols, lab.breaks=brks, zlim=c(0,1), main='second') 


# breaks and labels
x &lt;- raster(nc=10, nr=10)
values(x) &lt;- runif(ncell(x))
brk &lt;- c(0, 0.25, 0.75, 1)
arg &lt;- list(at=c(0.12,0.5,0.87), labels=c("Low","Med.","High"))
plot(x, col=terrain.colors(3), breaks=brk)
plot(x, col=terrain.colors(3), breaks=brk, axis.args=arg)
par(mfrow=c(1,1))

# color ramp
plot(x, col=colorRampPalette(c("red", "white", "blue"))(255))

# adding random points to the map
xy &lt;- cbind(-180 + runif(10) * 360, -90 + runif(10) * 180)
points(xy, pch=3, cex=5)

# for SpatialPolygons do
# plot(pols, add=TRUE)

# adding the same points to each map of each layer of a RasterStack
fun &lt;- function() {
	points(xy, cex=2)
	points(xy, pch=3, col='red')
}
plot(s, addfun=fun)

</code></pre>

<hr>
<h2 id='plotRGB'>Red-Green-Blue plot of a multi-layered Raster object</h2><span id='topic+plotRGB'></span><span id='topic+plotRGB+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Make a Red-Green-Blue plot based on three layers (in a RasterBrick or RasterStack). Three layers (sometimes referred to as &quot;bands&quot; because they may represent different bandwidths in the electromagnetic spectrum) are combined such that they represent the red, green and blue channel. This function can be used to make 'true (or false) color images' from Landsat and other multi-band satellite images. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterStackBrick'
plotRGB(x, r=1, g=2, b=3, scale, maxpixels=500000, stretch=NULL, 
ext=NULL, interpolate=FALSE, colNA='white', alpha, bgalpha, addfun=NULL, zlim=NULL, 
zlimcol=NULL, axes=FALSE, xlab='', ylab='', asp=NULL, add=FALSE, margins=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRGB_+3A_x">x</code></td>
<td>
<p>RasterBrick or RasterStack</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_r">r</code></td>
<td>
<p>integer. Index of the Red channel, between 1 and nlayers(x)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_g">g</code></td>
<td>
<p>integer. Index of the Green channel, between 1 and nlayers(x)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_b">b</code></td>
<td>
<p>integer. Index of the Blue channel, between 1 and nlayers(x)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_scale">scale</code></td>
<td>
<p>integer. Maximum (possible) value in the three channels. Defaults to 255 or to the maximum value of <code>x</code> if that is known and larger than 255</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_maxpixels">maxpixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of pixels to use</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_stretch">stretch</code></td>
<td>
<p>character. Option to stretch the values to increase the contrast of the image: &quot;lin&quot; or &quot;hist&quot;</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_ext">ext</code></td>
<td>
<p>An <code><a href="#topic+Extent">Extent</a></code> object to zoom in to a region of interest (see <code><a href="#topic+drawExtent">drawExtent</a></code>)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_interpolate">interpolate</code></td>
<td>
<p>logical. If <code>TRUE</code>, interpolate the image when drawing</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_colna">colNA</code></td>
<td>
<p>color for the background (<code>NA</code> values)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_alpha">alpha</code></td>
<td>
<p>transparency. Integer between 0 (transparent) and 255 (opaque)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_bgalpha">bgalpha</code></td>
<td>
<p>Background transparency. Integer between 0 (transparent) and 255 (opaque)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_addfun">addfun</code></td>
<td>
<p>Function to add additional items such as points or polygons to the plot (map). See <code><a href="#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plotRGB_+3A_zlim">zlim</code></td>
<td>
<p>numeric vector of length 2. Range of values to plot (optional)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_zlimcol">zlimcol</code></td>
<td>
<p>If <code>NULL</code> the values outside the range of zlim get the color of the extremes of the range. If zlimcol has any other value, the values outside the zlim range get the color of <code>NA</code> values (see colNA)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_axes">axes</code></td>
<td>
<p>logical. If <code>TRUE</code> axes are drawn (and arguments such as <code>main="title"</code> will be honored)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_xlab">xlab</code></td>
<td>
<p>character. Label of x-axis</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_ylab">ylab</code></td>
<td>
<p>character. Label of y-axis</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_asp">asp</code></td>
<td>
<p>numeric. Aspect (ratio of x and y. If NULL, and appropriate value is computed to match data for the longitude/latitude coordinate reference system, and 1 for planar coordinate reference systems</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_add">add</code></td>
<td>
<p>logical. If <code>TRUE</code> add values to current plot</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_margins">margins</code></td>
<td>
<p>logical. If <code>TRUE</code> standard whitespace margins are used. If <code>FALSE</code>, graphics::par(plt=c(0,1,0,1)) is used</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_...">...</code></td>
<td>
<p>graphical parameters as in <code><a href="#topic+plot">plot</a></code> or <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert J. Hijmans; stretch option based on functions by Josh Gray </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brick(system.file("external/rlogo.grd", package="raster"))
plotRGB(b)
plotRGB(b, 3, 2, 1)
plotRGB(b, 3, 2, 1, stretch='hist')
</code></pre>

<hr>
<h2 id='pointDistance'>Distance between points</h2><span id='topic+pointDistance'></span>

<h3>Description</h3>

<p>Calculate the geographic distance between two (sets of) points on the WGS ellipsoid (<code>lonlat=TRUE</code>) or on a plane (<code>lonlat=FALSE</code>). If both sets do not have the same number of points, the distance between each pair of points is given. If both sets have the same number of points, the distance between each point and the corresponding point in the other set is given, except if <code>allpairs=TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointDistance(p1, p2, lonlat, allpairs=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointDistance_+3A_p1">p1</code></td>
<td>
<p>x and y coordinate of first (set of) point(s), either as c(x, y), matrix(ncol=2), or SpatialPoints*. </p>
</td></tr>
<tr><td><code id="pointDistance_+3A_p2">p2</code></td>
<td>
<p>x and y coordinate of second (set of) second point(s) (like for <code>p1</code>). If this argument is missing, a distance matrix is computed for <code>p1</code> </p>
</td></tr>
<tr><td><code id="pointDistance_+3A_lonlat">lonlat</code></td>
<td>
<p>logical. If <code>TRUE</code>, coordinates should be in degrees; else they should represent planar ('Euclidean') space (e.g. units of meters) </p>
</td></tr>
<tr><td><code id="pointDistance_+3A_allpairs">allpairs</code></td>
<td>
<p>logical. Only relevant if the number of points in <code>x</code> and <code>y</code> is the same. If <code>FALSE</code> the distance between each point in <code>x</code> with the corresponding point in <code>y</code> is returned. If <code>TRUE</code> a full distance matrix is returned </p>
</td></tr>
<tr><td><code id="pointDistance_+3A_...">...</code></td>
<td>
<p>Additional arguments. None implemented </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value, or a vector, or matrix of values giving the distance in meters (lonlat=TRUE) or map-units (for instance, meters in the case of UTM)
If <code>p2</code> is missing, a distance matrix is returned
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Jacob van Etten. The distance for longitude/latitude data uses GeographicLib by C.F.F. Karney</p>


<h3>See Also</h3>

<p><code><a href="#topic+distanceFromPoints">distanceFromPoints</a>, <a href="#topic+distance">distance</a>, <a href="#topic+gridDistance">gridDistance</a></code>, <code><a href="sp.html#topic+spDistsN1">spDistsN1</a></code>. 
The <code>geosphere</code> package has many additional distance functions and other functions that operate on spherical coordinates</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- cbind(c(1,5,55,31),c(3,7,20,22))
b &lt;- cbind(c(4,2,8,65),c(50,-90,20,32))   

pointDistance(c(0, 0), c(1, 1), lonlat=FALSE)
pointDistance(c(0, 0), c(1, 1), lonlat=TRUE)
pointDistance(c(0, 0), a, lonlat=TRUE)
pointDistance(a, b, lonlat=TRUE)
   
#Make a distance matrix 
dst &lt;- pointDistance(a, lonlat=TRUE)
# coerce to dist object
dst &lt;- as.dist(dst)
</code></pre>

<hr>
<h2 id='predict'>Spatial model predictions</h2><span id='topic+predict'></span><span id='topic+predict+2CRaster-method'></span>

<h3>Description</h3>

<p>Make a Raster object with predictions from a fitted model object (for example, obtained with <code>lm</code>, <code>glm</code>). The first argument is a Raster object with the independent (predictor) variables. The <code><a href="#topic+names">names</a></code> in the Raster object should exactly match those expected by the model. This will be the case if the same Raster object was used (via <code>extract</code>) to obtain the values to fit the model (see the example). Any type of model (e.g. glm, gam, randomForest) for which a predict method has been implemented (or can be implemented) can be used. 
</p>
<p>This approach (predict a fitted model to raster data) is commonly used in remote sensing (for the classification of satellite images) and in ecology, for species distribution modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
predict(object, model, filename="", fun=predict, ext=NULL, 
   const=NULL, index=1, na.rm=TRUE, inf.rm=FALSE, factors=NULL, 
   format, datatype, overwrite=FALSE, progress='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>Raster* object. Typically a multi-layer type (RasterStack or RasterBrick)</p>
</td></tr>
<tr><td><code id="predict_+3A_model">model</code></td>
<td>
<p>fitted model of any class that has a 'predict' method (or for which you can supply a similar method as <code>fun</code> argument. E.g. glm, gam, or randomForest </p>
</td></tr>
<tr><td><code id="predict_+3A_filename">filename</code></td>
<td>
<p>character. Optional output filename </p>
</td></tr>
<tr><td><code id="predict_+3A_fun">fun</code></td>
<td>
<p>function. Default value is 'predict', but can be replaced with e.g. predict.se (depending on the type of model), or your own custom function.</p>
</td></tr>
<tr><td><code id="predict_+3A_ext">ext</code></td>
<td>
<p>Extent object to limit the prediction to a sub-region of <code>x</code> </p>
</td></tr>
<tr><td><code id="predict_+3A_const">const</code></td>
<td>
<p>data.frame. Can be used to add a constant for which there is no Raster object for model predictions. Particularly useful if the constant is a character-like factor value for which it is currently not possible to make a RasterLayer </p>
</td></tr>
<tr><td><code id="predict_+3A_index">index</code></td>
<td>
<p>integer. To select the column(s) to use if predict.'model' returns a matrix with multiple columns </p>
</td></tr>
<tr><td><code id="predict_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Remove cells with <code>NA</code> values in the predictors before solving the model (and return a <code>NA</code> value for those cells). This option prevents errors with models that cannot handle <code>NA</code> values. In most other cases this will not affect the output. An exception is when predicting with a boosted regression trees model because these return predicted values even if some (or all!) variables are <code>NA</code> </p>
</td></tr>
<tr><td><code id="predict_+3A_inf.rm">inf.rm</code></td>
<td>
<p>logical. Remove cells with values that are not finite (some models will fail with -Inf/Inf values). This option is ignored when <code>na.rm=FALSE</code></p>
</td></tr>
<tr><td><code id="predict_+3A_factors">factors</code></td>
<td>
<p>list with levels for factor variables. The list elements should be named with names that correspond to names in <code>object</code> such that they can be matched. This argument may be omitted for standard models such as 'glm' as the predict function will extract the levels from the <code>model</code> object, but it is necessary in some other cases (e.g. cforest models from the party package)</p>
</td></tr>
<tr><td><code id="predict_+3A_format">format</code></td>
<td>
<p>character. Output file type. See <a href="#topic+writeRaster">writeRaster</a> (optional) </p>
</td></tr>
<tr><td><code id="predict_+3A_datatype">datatype</code></td>
<td>
<p>character. Output data type. See <a href="#topic+dataType">dataType</a> (optional) </p>
</td></tr>
<tr><td><code id="predict_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If TRUE, &quot;filename&quot; will be overwritten if it exists </p>
</td></tr>
<tr><td><code id="predict_+3A_progress">progress</code></td>
<td>
<p>character. &quot;text&quot;, &quot;window&quot;, or &quot;&quot; (the default, no progress bar)  </p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to the predict.'model' function </p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+interpolate">interpolate</a></code> if your model has 'x' and 'y' as implicit independent variables (e.g., in kriging).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple model to predict the location of the R in the R-logo using 20 presence points 
# and 50 (random) pseudo-absence points. This type of model is often used to predict
# species distributions. See the dismo package for more of that.

# create a RasterStack or RasterBrick with with a set of predictor layers
logo &lt;- brick(system.file("external/rlogo.grd", package="raster"))
names(logo)

## Not run: 
# the predictor variables
par(mfrow=c(2,2))
plotRGB(logo, main='logo')
plot(logo, 1, col=rgb(cbind(0:255,0,0), maxColorValue=255))
plot(logo, 2, col=rgb(cbind(0,0:255,0), maxColorValue=255))
plot(logo, 3, col=rgb(cbind(0,0,0:255), maxColorValue=255))
par(mfrow=c(1,1))

## End(Not run)

# known presence and absence points
p &lt;- matrix(c(48, 48, 48, 53, 50, 46, 54, 70, 84, 85, 74, 84, 95, 85, 
   66, 42, 26, 4, 19, 17, 7, 14, 26, 29, 39, 45, 51, 56, 46, 38, 31, 
   22, 34, 60, 70, 73, 63, 46, 43, 28), ncol=2)

a &lt;- matrix(c(22, 33, 64, 85, 92, 94, 59, 27, 30, 64, 60, 33, 31, 9,
   99, 67, 15, 5, 4, 30, 8, 37, 42, 27, 19, 69, 60, 73, 3, 5, 21,
   37, 52, 70, 74, 9, 13, 4, 17, 47), ncol=2)

# extract values for points
xy &lt;- rbind(cbind(1, p), cbind(0, a))
v &lt;- data.frame(cbind(pa=xy[,1], extract(logo, xy[,2:3])))

#build a model, here an example with glm 
model &lt;- glm(formula=pa~., data=v)

#predict to a raster
r1 &lt;- predict(logo, model, progress='text')

plot(r1)
points(p, bg='blue', pch=21)
points(a, bg='red', pch=21)

# use a modified function to get a RasterBrick with p and se
# from the glm model. The values returned by 'predict' are in a list,
# and this list needs to be transformed to a matrix

predfun &lt;- function(model, data) {
  v &lt;- predict(model, data, se.fit=TRUE)
  cbind(p=as.vector(v$fit), se=as.vector(v$se.fit))
}

# predfun returns two variables, so use index=1:2
r2 &lt;- predict(logo, model, fun=predfun, index=1:2)


## Not run: 
# You can use multiple cores to speed up the predict function
# by calling it via the clusterR function (you may need to install the snow package)
beginCluster()
r1c &lt;- clusterR(logo, predict, args=list(model))
r2c &lt;- clusterR(logo, predict, args=list(model=model, fun=predfun, index=1:2))

## End(Not run)

# principal components of a RasterBrick
# here using sampling to simulate an object too large
# to feed all its values to prcomp
sr &lt;- sampleRandom(logo, 100)
pca &lt;- prcomp(sr)

# note the use of the 'index' argument
x &lt;- predict(logo, pca, index=1:3)
plot(x)

## Not run: 
# partial least square regression
library(pls)
model &lt;- plsr(formula=pa~., data=v)
# this returns an array:
predict(model, v[1:5,])
# write a function to turn that into a matrix
pfun &lt;- function(x, data) {
   y &lt;- predict(x, data)
   d &lt;- dim(y)
   dim(y) &lt;- c(prod(d[1:2]), d[3])
   y
}

pp &lt;- predict(logo, model, fun=pfun, index=1:3)

# Random Forest

library(randomForest)
rfmod &lt;- randomForest(pa ~., data=v)

## note the additional argument "type='response'" that is 
## passed to predict.randomForest
r3 &lt;- predict(logo, rfmod, type='response', progress='window')

## get a RasterBrick with class membership probabilities
vv &lt;- v
vv$pa &lt;- as.factor(vv$pa)
rfmod2 &lt;- randomForest(pa ~., data=vv)
r4 &lt;- predict(logo, rfmod2, type='prob', index=1:2)
spplot(r4)


# cforest (other Random Forest implementation) example with factors argument
v$red &lt;- as.factor(round(v$red/100))
logo$red &lt;- round(logo[[1]]/100)

library(party)
m &lt;- cforest(pa~., control=cforest_unbiased(mtry=3), data=v)
f &lt;- list(levels(v$red))
names(f) &lt;- 'red'
# the second argument in party:::predict.RandomForest
# is "OOB", and not "newdata" or similar. We need to write a wrapper
# predict function to deal with this 	
predfun &lt;- function(m, d, ...) predict(m, newdata=d, ...)

pc &lt;- predict(logo, m, OOB=TRUE, factors=f, fun=predfun)

# knn example, using calc instead of predict
library(class)
cl &lt;- factor(c(rep(1, nrow(p)), rep(0, nrow(a))))
train &lt;- extract(logo, rbind(p, a))
k &lt;- calc(logo, function(x) as.integer(as.character(knn(train, x, cl))))

## End(Not run)
</code></pre>

<hr>
<h2 id='Programming'>Helper functions for programming</h2><span id='topic+readStart'></span><span id='topic+readStop'></span><span id='topic+readStart+2CRaster-method'></span><span id='topic+readStart+2CRasterStack-method'></span><span id='topic+readStop+2CRaster-method'></span><span id='topic+readStop+2CRasterStack-method'></span><span id='topic+canProcessInMemory'></span><span id='topic+pbCreate'></span><span id='topic+pbStep'></span><span id='topic+pbClose'></span><span id='topic+getCluster'></span><span id='topic+returnCluster'></span>

<h3>Description</h3>

 
<p>These are low level functions that can be used by programmers to develop new functions. If in doubt, it is almost certain that you do not need these functions as these are already embedded in all other functions in the raster package.
</p>
<p><code>canProcessInMemory</code> is typically used within functions. In the raster package this function is used to determine if the amount of memory needed for the function is available. If there is not enough memory available, the function returns <code>FALSE</code>, and the function that called it will write the results to a temporary file. 
</p>
<p>readStart opens file connection(s) for reading, readStop removes it. 
</p>
<p>pbCreate creates a progress bar, pbStep sets the progress, and pbClose closes it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canProcessInMemory(x, n=4, verbose=FALSE)
pbCreate(nsteps, progress, style=3, label='Progress', ...)
pbStep(pb, step=NULL, label='')
pbClose(pb, timer)
readStart(x, ...)
readStop(x)
getCluster()
returnCluster()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Programming_+3A_x">x</code></td>
<td>
<p>RasterLayer or RasterBrick object (for connections) or RasterStack object (canProcessInMemory)</p>
</td></tr>
<tr><td><code id="Programming_+3A_n">n</code></td>
<td>
<p>integer. The number of copies of the Raster* object cell values that a function needs to be able to have in memory</p>
</td></tr>  
<tr><td><code id="Programming_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> the amount of memory needed and available is printed</p>
</td></tr>
<tr><td><code id="Programming_+3A_nsteps">nsteps</code></td>
<td>
<p>integer. Number of steps the progress bar will make from start to end (e.g. nrow(raster)) </p>
</td></tr>
<tr><td><code id="Programming_+3A_progress">progress</code></td>
<td>
<p>character. 'text', 'window', or &rdquo;</p>
</td></tr>
<tr><td><code id="Programming_+3A_style">style</code></td>
<td>
<p>style for text progress bar. See <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> </p>
</td></tr>
<tr><td><code id="Programming_+3A_label">label</code></td>
<td>
<p>character. Label for the window type progress bar</p>
</td></tr>
<tr><td><code id="Programming_+3A_...">...</code></td>
<td>
<p>additional arguments (None implemented, except for 'silent=TRUE' for readStart for files read with gdal, and other arguments passed to gdal.open)</p>
</td></tr>
<tr><td><code id="Programming_+3A_pb">pb</code></td>
<td>
<p> progress bar object created with pbCreate </p>
</td></tr>
<tr><td><code id="Programming_+3A_step">step</code></td>
<td>
<p>which step is this ( 1 &lt;= step &lt;= nsteps ). If step is <code>NULL</code>, a single step is taken </p>
</td></tr>
<tr><td><code id="Programming_+3A_timer">timer</code></td>
<td>
<p>logical. If <code>TRUE</code>, time to completion will be printed. If missing, the value will be taken from the rasterOptions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>canProcessInMemory: logical
</p>
<p>closeConnection: RasterLayer or RasterBrick object
</p>
<p>getCluster: snow cluster object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=100, ncol=100)
canProcessInMemory(r, 4)
r &lt;- raster(nrow=50000, ncol=50000)
canProcessInMemory(r, 2, verbose=TRUE)
rasterOptions(maxmem=Inf, memfrac=.8)
rasterOptions(default=TRUE)
</code></pre>

<hr>
<h2 id='projection'> Get or set a coordinate reference system (projection) </h2><span id='topic+wkt'></span><span id='topic+wkt+2CANY-method'></span><span id='topic+wkt+2CRaster-method'></span><span id='topic+crs'></span><span id='topic+crs+2CANY-method'></span><span id='topic+crs+3C-'></span><span id='topic+projection'></span><span id='topic+projection+3C-'></span><span id='topic+proj4string'></span><span id='topic+proj4string+2CBasicRaster-method'></span><span id='topic+proj4string+2CCRS-method'></span><span id='topic+proj4string+3C-'></span><span id='topic+as.character+2CCRS-method'></span><span id='topic+is.na+2CCRS-method'></span><span id='topic+crs+3C-+2CBasicRaster-method'></span><span id='topic+crs+3C-+2CSpatial-method'></span>

<h3>Description</h3>

<p>Get or set the coordinate reference system (CRS) of a Raster* object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'ANY'
crs(x, asText=FALSE, ...)
## S4 method for signature 'Raster'
wkt(obj)
crs(x, ...) &lt;- value

projection(x, asText=TRUE)
projection(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projection_+3A_x">x</code></td>
<td>
<p>Raster* or Spatial object </p>
</td></tr>
<tr><td><code id="projection_+3A_obj">obj</code></td>
<td>
<p>Raster*, Spatial, or CRS object </p>
</td></tr>
<tr><td><code id="projection_+3A_astext">asText</code></td>
<td>
<p>logical. If <code>TRUE</code>, the projection is returned as text. Otherwise a <code><a href="sp.html#topic+CRS-class">CRS-class</a></code> object is returned</p>
</td></tr>
<tr><td><code id="projection_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr>
<tr><td><code id="projection_+3A_value">value</code></td>
<td>
<p><code>CRS</code> object or a character string describing a projection and datum in the PROJ.4 format </p>
</td></tr>
</table>


<h3>Details</h3>

<p> projections are done by with the PROJ library </p>


<h3>Value</h3>

<p>Raster*, Spatial*, or character object
</p>


<h3>Note</h3>

<p><code>crs</code> replaces earlier function <code>projection</code>.  
For compatibility with <code>sp</code> you can use <code>proj4string</code> instead of <code>crs</code>.
<code>wkt</code> returns the &quot;well-known-text&quot; representation of the crs.  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+projectRaster">projectRaster</a>, <a href="sp.html#topic+spTransform">spTransform</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster()
crs(r)
crs(r) &lt;- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84"
crs(r)
w &lt;- wkt(r)
w
cat(w, "\n")
</code></pre>

<hr>
<h2 id='projectRaster'>Project a Raster object</h2><span id='topic+projectRaster'></span><span id='topic+projectExtent'></span>

<h3>Description</h3>

<p>Project the values of a Raster* object to a new Raster* object with another projection (coordinate reference system, (CRS)). 
</p>
<p>You can do this by providing the new projection as a single argument in which case the function sets the extent and resolution of the new object. To have more control over the transformation, and, for example, to assure that the new object lines up with other datasets, you can provide a Raster* object with the properties that the input data should be projected to.
</p>
<p><code>projectExtent</code> returns a RasterLayer with a projected extent, but without any values. This RasterLayer can then 
be adjusted (e.g. by setting its resolution) and used as a template <code>'to'</code> in <code>projectRaster</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectRaster(from, to, res, crs, method="bilinear", 
             alignOnly=FALSE, over=FALSE, filename="", ...) 

projectExtent(object, crs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectRaster_+3A_from">from</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="projectRaster_+3A_to">to</code></td>
<td>
<p>Raster* object with the parameters to which 'from' should be projected</p>
</td></tr>
<tr><td><code id="projectRaster_+3A_res">res</code></td>
<td>
<p>single or (vector of) two numerics. To, optionally, set the output resolution if 'to' is missing</p>
</td></tr>
<tr><td><code id="projectRaster_+3A_crs">crs</code></td>
<td>
<p>character or object of class 'CRS'. PROJ.4 description of the coordinate reference system. In projectRaster this is used to set the output CRS if 'to' is missing, or if 'to' has no valid CRS</p>
</td></tr>
<tr><td><code id="projectRaster_+3A_method">method</code></td>
<td>
<p>method used to compute values for the new RasterLayer. Either 'ngb' (nearest neighbor), which is useful for categorical variables, or 'bilinear' (bilinear interpolation; the default value), which is appropriate for continuous variables.</p>
</td></tr>
<tr><td><code id="projectRaster_+3A_alignonly">alignOnly</code></td>
<td>
<p>logical. Use <code>to</code> or other parameters only to align the output (i.e. same origin and resolution), but use the projected extent from <code>from</code></p>
</td></tr>
<tr><td><code id="projectRaster_+3A_over">over</code></td>
<td>
<p>logical. If <code>TRUE</code> wrapping around the date-line is turned off. This can be desirable for global data (to avoid mapping the same areas twice) but it is not desirable in other cases</p>
</td></tr>
<tr><td><code id="projectRaster_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>  
<tr><td><code id="projectRaster_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
<tr><td><code id="projectRaster_+3A_object">object</code></td>
<td>
<p>Raster* object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two approaches you can follow to project the values of a Raster object.
</p>
<p>1) Provide a <code>crs</code> argument, and, optionally, a <code>res</code> argument, but do not provide a <code>to</code> argument.
</p>
<p>2) Create a template Raster with the CRS you want to project to. You can use an existing object, or use <code>projectExtent</code> for this or an existing Raster* object. Also set the number of rows and columns (or the resolution), and perhaps adjust the extent. The resolution of the output raster should normally be similar to that of the input raster. Then use that object as <code>from</code> argument to project the input Raster to. 
This is the preferred method because you have most control. For example you can assure that the resulting Raster object lines up with other Raster objects.
</p>
<p>Projection is performed using the PROJ library. 
</p>
<p>Also see <code>projInfo('proj')</code>, <code>projInfo('ellps')</code>, and <code>projInfo('datum')</code> for valid PROJ.4 values. 
</p>


<h3>Value</h3>

<p>RasterLayer or RasterBrick object.
</p>


<h3>Note</h3>

<p>If the resolution of the output is much larger than that of the input, you should first aggregate the input such that the resolution of the input becomes more similar (perhaps a little smaller) to the output.
</p>


<h3>Note</h3>

<p>User beware. Sadly, the PROJ.4 notation has been partly deprecated in the GDAL/PROJ library that is used by this function. You can still use it, but *only* with the the WGS84 datum. Other datums are silently ignored. 
</p>
<p>When printing a Spat* object the PROJ.4 notation is shown because it is the most concise and clear format available. However, internally a WKT representation is used (see <code><a href="#topic+crs">crs</a></code>).
</p>
<p>Vector (points, lines, polygons) can be transformed with <code><a href="sp.html#topic+spTransform">spTransform</a></code>.
</p>
<p><code>projectExtent</code> does not work very well when transforming projected circumpolar data to (e.g.) longitude/latitude. 
With such data you may need to adjust the returned object. E.g. do <code>ymax(object) &lt;- 90</code>
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Joe Cheng</p>


<h3>See Also</h3>

<p><code><a href="#topic+resample">resample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a new (not projected) RasterLayer with cellnumbers as values
r &lt;- raster(xmn=-110, xmx=-90, ymn=40, ymx=60, ncols=40, nrows=40, crs="+proj=longlat")
r &lt;- setValues(r, 1:ncell(r))
projection(r)

# proj.4 projection description
newproj &lt;- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84"

#simplest approach
pr1 &lt;- projectRaster(r, crs=newproj)

# alternatively also set the resolution
pr2 &lt;- projectRaster(r, crs=newproj, res=20000)

# inverse projection, back to the properties of 'r'
inv &lt;- projectRaster(pr2, r)

# to have more control, provide an existing Raster object, here we create one
# using projectExtent (no values are transferred)
pr3 &lt;- projectExtent(r, newproj)
# Adjust the cell size 
res(pr3) &lt;- 200000
# now project
pr3 &lt;- projectRaster(r, pr3)

</code></pre>

<hr>
<h2 id='properties'>Raster file properties</h2><span id='topic+dataSize'></span><span id='topic+dataSigned'></span>

<h3>Description</h3>

<p>Properties of the values of the file that a RasterLayer object points to
</p>
<p><code>dataSize</code> returns the number of bytes used for each value (pixel, grid cell)
<code>dataSigned</code> is TRUE for data types that include negative numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataSize(object)
dataSigned(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="properties_+3A_object">object</code></td>
<td>
<p>Raster* object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>varies
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+filename">filename</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/test.grd", package="raster"))
dataSize(r)
dataSigned(r)
dataType(r)
</code></pre>

<hr>
<h2 id='quantile'>Raster quantiles</h2><span id='topic+quantile'></span><span id='topic+quantile+2CRaster-method'></span>

<h3>Description</h3>

<p>Compute quantiles for the cell values of a RasterLayer. If you want to compute quantiles for each cell across a number of layers, you can use <code><a href="#topic+calc">calc</a>(x, fun=quantile)</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_+3A_x">x</code></td>
<td>
<p>Raster object</p>
</td></tr>
<tr><td><code id="quantile_+3A_...">...</code></td>
<td>
<p>Additional arguments: <code>na.rm=TRUE</code>, <code>ncells=NULL</code>, and additional arguments to the stats::quantile function, see <code><a href="stats.html#topic+quantile">quantile</a></code></p>
</td></tr>  
</table>
<p>ncells can be used to set the number of cells to be sampled, for very large raster datasets.
</p>


<h3>Value</h3>

<p>A vector of quantiles
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+density">density</a></code>, <code><a href="#topic+cellStats">cellStats</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=100, nrow=100)
values(r) &lt;- rnorm(ncell(r), 0, 50)
quantile(r)
quantile(r, probs = c(0.25, 0.75), type=7,names = FALSE)
</code></pre>

<hr>
<h2 id='raster'>Create a RasterLayer object</h2><span id='topic+raster'></span><span id='topic+raster+2Cmissing-method'></span><span id='topic+raster+2Ccharacter-method'></span><span id='topic+raster+2CExtent-method'></span><span id='topic+raster+2CBasicRaster-method'></span><span id='topic+raster+2CRasterLayer-method'></span><span id='topic+raster+2CRasterLayerSparse-method'></span><span id='topic+raster+2CRasterStack-method'></span><span id='topic+raster+2CRasterBrick-method'></span><span id='topic+raster+2CSpatial-method'></span><span id='topic+raster+2CSpatialGrid-method'></span><span id='topic+raster+2CSpatialPixels-method'></span><span id='topic+raster+2Cmatrix-method'></span><span id='topic+raster+2Clist-method'></span><span id='topic+raster+2Cim-method'></span><span id='topic+raster+2Casc-method'></span><span id='topic+raster+2Ckasc-method'></span><span id='topic+raster+2Ckde-method'></span><span id='topic+raster+2Cgrf-method'></span><span id='topic+raster+2Csf-method'></span><span id='topic+raster+2CGridTopology-method'></span><span id='topic+raster+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Methods to create a RasterLayer object. RasterLayer objects can be created from scratch, a file, an Extent object, a matrix, an 'image' object, or from a Raster*, Spatial*, im (spatstat) asc, kasc (adehabitat*), grf (geoR) or kde object.
</p>
<p>In many cases, e.g. when a RasterLayer is created from a file, it does (initially) not contain any cell (pixel) values in (RAM) memory, it only has the parameters that describe the RasterLayer. You can access cell-values with <code><a href="#topic+getValues">getValues</a>, <a href="#topic+extract">extract</a></code> and related functions. You can assign new values with  <code><a href="#topic+setValues">setValues</a></code> and with <code><a href="#topic+replacement">replacement</a></code>.
</p>
<p>For an overview of the functions in the raster package have a look here: <code><a href="#topic+raster-package">raster-package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
raster(x, band=1, ...)

## S4 method for signature 'RasterLayer'
raster(x) 

## S4 method for signature 'RasterStack'
raster(x, layer=0) 

## S4 method for signature 'RasterBrick'
raster(x, layer=0) 

## S4 method for signature 'missing'
raster(nrows=180, ncols=360, xmn=-180, xmx=180, ymn=-90, ymx=90, 
		crs, ext, resolution, vals=NULL)

## S4 method for signature 'Extent'
raster(x, nrows=10, ncols=10, crs="", ...)

## S4 method for signature 'matrix'
raster(x, xmn=0, xmx=1, ymn=0, ymx=1, crs="", template=NULL)

## S4 method for signature 'Spatial'
raster(x, origin, ...) 

## S4 method for signature 'SpatialGrid'
raster(x, layer=1, values=TRUE)

## S4 method for signature 'SpatialPixels'
raster(x, layer=1, values=TRUE)

## S4 method for signature 'sf'
raster(x, origin, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_+3A_x">x</code></td>
<td>
<p>filename (character), Extent, Raster*, sf, SpatialPixels*, SpatialGrid*, object, 'image', matrix, im, or missing. Supported file types are the 'native' raster package format and those that can be read by GDAL</p>
</td></tr>
<tr><td><code id="raster_+3A_band">band</code></td>
<td>
<p>integer. The layer to use in a multi-layer file</p>
</td></tr>
<tr><td><code id="raster_+3A_...">...</code></td>
<td>
<p>Additional arguments, see Details </p>
</td></tr>  
<tr><td><code id="raster_+3A_layer">layer</code></td>
<td>
<p>integer. The layer (variable) to use in a multi-layer file, or the layer to extract from a RasterStack/Brick or SpatialPixelsDataFrame or SpatialGridDataFrame. An empty RasterLayer (no associated values) is returned if <code>layer=0</code></p>
</td></tr>
<tr><td><code id="raster_+3A_values">values</code></td>
<td>
<p>logical. If <code>TRUE</code>, the cell values of '<code>x</code>' are copied to the RasterLayer object that is returned</p>
</td></tr>
<tr><td><code id="raster_+3A_nrows">nrows</code></td>
<td>
<p>integer &gt; 0. Number of rows</p>
</td></tr>
<tr><td><code id="raster_+3A_ncols">ncols</code></td>
<td>
<p>integer &gt; 0. Number of columns</p>
</td></tr>
<tr><td><code id="raster_+3A_xmn">xmn</code></td>
<td>
<p>minimum x coordinate (left border)</p>
</td></tr>
<tr><td><code id="raster_+3A_xmx">xmx</code></td>
<td>
<p>maximum x coordinate (right border)</p>
</td></tr>
<tr><td><code id="raster_+3A_ymn">ymn</code></td>
<td>
<p>minimum y coordinate (bottom border)</p>
</td></tr>
<tr><td><code id="raster_+3A_ymx">ymx</code></td>
<td>
<p>maximum y coordinate (top border)</p>
</td></tr>
<tr><td><code id="raster_+3A_ext">ext</code></td>
<td>
<p>object of class Extent. If present, the arguments xmn, xmx, ymn and ynx are ignored</p>
</td></tr>
<tr><td><code id="raster_+3A_crs">crs</code></td>
<td>
<p>character or object of class CRS. PROJ.4 type description of a Coordinate Reference System (map projection). If this argument is missing, and the x coordinates are within -360 .. 360 and the y coordinates are within -90 .. 90, &quot;+proj=longlat +datum=WGS84&quot; is used. Also see under Details if <code>x</code> is a character (filename)</p>
</td></tr>
<tr><td><code id="raster_+3A_resolution">resolution</code></td>
<td>
<p>numeric vector of length 1 or 2 to set the resolution (see <code><a href="#topic+res">res</a></code>). If this argument is used, arguments <code>ncols</code> and <code>nrows</code> are ignored </p>
</td></tr>
<tr><td><code id="raster_+3A_vals">vals</code></td>
<td>
<p>optional. Values for the new RasterLayer. Accepted formats are as for <code><a href="#topic+setValues">setValues</a></code></p>
</td></tr>
<tr><td><code id="raster_+3A_origin">origin</code></td>
<td>
<p>minimum y coordinate (bottom border)</p>
</td></tr>
<tr><td><code id="raster_+3A_template">template</code></td>
<td>
<p>Raster* or Extent object used to set the extent (and CRS in case of a Raster* object). If not <code>NULL</code>, arguments <code>xmn</code>, <code>xmx</code>, <code>ymn</code>, <code>ymx</code> and <code>crs</code> (unless <code>template</code> is an Extent object) are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a filename, the following additional variables are recognized:
</p>
<p><code>sub</code>: positive integer. Subdataset number for a file with subdatasets
</p>
<p><code>native</code>: logical.  Default is <code>FALSE</code>. If <code>TRUE</code>, reading and writing of IDRISI, BIL, BSQ, BIP, SAGA, and Arc ASCII files is done with native (raster package) drivers, rather then via GDAL. 'raster' and netcdf format files are always read with native drivers. 
</p>
<p><code>RAT</code>: logical. The default is <code>TRUE</code>, in which case a raster attribute table is created for files that have one
</p>
<p><code>offset</code>: integer. To indicate the number of header rows on non-standard ascii files (rarely useful; use with caution)
</p>
<p><code>crs</code>: character. PROJ.4 string to set the CRS. Ignored when the file provides a CRS description that can be interpreted.
</p>
<p>If <code>x</code> represents a <b>NetCDF</b> file, the following additional variable is recognized:
</p>
<p><code>varname</code>: character. The variable name, such as 'tasmax' or 'pr'. If not supplied and the file has multiple variables are a guess will be made (and reported)
</p>
<p><code>lvar</code>: integer &gt; 0 (default=3). To select the 'level variable' (3rd dimension variable) to use, if the file has 4 dimensions (e.g. depth instead of time)<br />
</p>
<p><code>level</code>: integer &gt; 0 (default=1). To select the 'level' (4th dimension variable) to use, if the file has 4 dimensions, e.g. to create a RasterBrick of weather over time at a certain height. <br />
</p>
<p>To use NetCDF files the <code>ncdf4</code> package needs to be available. It is assumed that these files follow, or are compatible with, the CF-1 convention (The GMT format may also work). If the ncdf file does not have a standard extension (which is used to recognize the file format), you can use argument <code>ncdf=TRUE</code> to indicate the format.
</p>
<p>If <code>x</code> is a <code>Spatial</code> or an <code>Extent</code> object, additional arguments are for the method with signature <code>'missing'</code>
</p>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+stack">stack</a>, <a href="#topic+brick">brick</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a RasterLayer object from a file
#   N.B.: For your own files, omit the 'system.file' and 'package="raster"' bits
#   these are just to get the path to files installed with the package

f &lt;- system.file("external/test.grd", package="raster")
f
r &lt;- raster(f)

logo &lt;- raster(system.file("external/rlogo.grd", package="raster")) 


#from scratch
r1 &lt;- raster(nrows=108, ncols=21, xmn=0, xmx=10)

#from an Extent object
e &lt;- extent(r)
r2 &lt;- raster(e)

#from another Raster* object
r3 &lt;- raster(r)
s &lt;- stack(r, r, r)
r4 &lt;- raster(s)
r5 &lt;- raster(s, 3)

</code></pre>

<hr>
<h2 id='Raster-class'> Raster* classes</h2><span id='topic+BasicRaster-class'></span><span id='topic+Raster-class'></span><span id='topic+RasterLayer-class'></span><span id='topic+RasterLayerSparse-class'></span><span id='topic+RasterStack-class'></span><span id='topic+RasterBrick-class'></span><span id='topic+RasterStackBrick-class'></span><span id='topic+VectorLayer-class'></span><span id='topic+SpatialVector-class'></span><span id='topic+print+2CRaster-method'></span><span id='topic+show+2CBasicRaster-method'></span><span id='topic+show+2CRasterLayer-method'></span><span id='topic+show+2CRasterStack-method'></span><span id='topic+show+2CRasterBrick-method'></span><span id='topic+print+2CSpatial-method'></span>

<h3>Description</h3>

<p>A raster is a database organized as a rectangular grid that is sub-divided into rectangular cells of equal area (in terms of the units of the coordinate reference system). The 'raster' package defines a number of &quot;S4 classes&quot; to manipulate such data.
</p>
<p>The main user level classes are <code>RasterLayer</code>, <code>RasterStack</code> and <code>RasterBrick</code>. They all inherit from <code>BasicRaster</code> and can contain values for the raster cells.
</p>
<p>An object of the <code>RasterLayer</code> class refers to a single layer (variable) of raster data. The object can point to a file on disk that holds the values of the raster cells, or hold these values in memory. Or it can not have any associated values at all.
</p>
<p>A <code>RasterStack</code> represents a collection of <code>RasterLayer</code> objects with the same extent and resolution. Organizing <code>RasterLayer</code> objects in a <code>RasterStack</code> can be practical when dealing with multiple layers; for example to summarize their values (see <code><a href="#topic+calc">calc</a></code>) or in spatial modeling (see <code><a href="#topic+predict">predict</a></code>). 
</p>
<p>An object of class <code>RasterBrick</code> can also contain multiple layers of raster data, but they are more tightly related. An object of class  <code>RasterBrick</code> can refer to only a single (multi-layer) data file, whereas each layer in a <code>RasterStack</code> can refer to another file (or another band in a multi-band file). This has implications for processing speed and flexibility. A <code>RasterBrick</code> should process quicker than a <code>RasterStack</code> (irrespective if values are on disk or in memory). However, a <code>RasterStack</code> is more flexible as a single object can refer to layers that have values stored on disk as well as in memory. If a layer that does not refer to values on disk (they only exists in memory) is added to a <code>RasterBrick</code>, it needs to load all its values into memory (and this may not be possible because of memory size limitations). 
</p>
<p>Objects can be created from file or from each other with the following functions: <code><a href="#topic+raster">raster</a>, <a href="#topic+brick">brick</a></code> and <a href="#topic+stack">stack</a>.
</p>
<p><code>Raster*</code> objects can also be created from SpatialPixels* and SpatialGrid* objects from the sp package using <code>as</code>, or simply with the function <code><a href="#topic+raster">raster</a></code>, <code><a href="#topic+brick">brick</a></code>, or <code><a href="#topic+stack">stack</a></code>. Vice versa, <code>Raster*</code> objects can be coerced into a sp type object with <code>as( , )</code>, e.g. <code>as(x, 'SpatialGridDataFrame')</code> . 
</p>
<p>Common generic methods implemented for these classes include: 
</p>
<p><code>summary</code>, <code>show</code>, <code>dim</code>, and <code>plot, ...</code> 
</p>
<p><code>[</code> is implemented for RasterLayer. 
</p>
<p>The classes described above inherit from the <code>BasicRaster</code> class which inherits from <code>BasicRaster</code>. The <code>BasicRaster</code> class describes the main properties of a raster such as the number of columns and rows, and it contains an object of the <code>link[raster]{Extent-class}</code> to describe its spatial extent (coordinates). It also holds the 'coordinate reference system' in a slot of class  <code><a href="sp.html#topic+CRS-class">CRS-class</a></code> defined in the <code>sp</code> package. A <code>BasicRaster</code> cannot contain any raster cell values and is therefore seldomly used.
</p>
<p>The <code>Raster*</code> class inherits from <code>BasicRaster</code>. It is a virtual class; which means that you cannot create an object of this class. It is used only to define methods for all the classes that inherit from it (<code>RasterLayer</code>, <code>RasterStack</code> and <code>RasterBrick</code>). Another virtual class is the <code>RasterStackBrick</code> class. It is formed by a class union of <code>RasterStack</code> and <code>RasterBrick</code>. You cannot make objects of it, but methods defined for objects of this class as arguments will accept objects of the <code>RasterLayer</code> and <code>RasterStack</code> as that argument.
</p>
<p>Classes <code>RasterLayer</code> and <code>RasterBrick</code> have a slot with an object of class <code>RasterFile</code> that describes the properties of the file they point to (if they do).  <code>RasterLayer</code> has a slot with an object of class <code>SingleLayerData</code>, and the <code>RasterBrick</code> class has a slot with an object of class <code>MultipleLayerData</code>. These 'datalayer' classes can contain (some of) the values of the raster cells.
</p>
<p>These classes are not further described here because users should not need to directly access these slots. The 'setter' functions such as <code>setValues</code> should be used instead. Using such 'setter' functions is much safer because a change in one slot should often affect the values in other slots. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("RasterLayer", ...)</code>, or with the helper functions such as <code>raster</code>.
</p>


<h3>Slots</h3>

<p>Slots for RasterLayer and RasterBrick objects
</p>

<dl>
<dt><code>title</code>:</dt><dd><p>Character</p>
</dd> 
<dt><code>file</code>:</dt><dd><p>Object of class <code>".RasterFile"</code> </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>".SingleLayerData"</code> or <code>".MultipleLayerData"</code></p>
</dd>
<dt><code>history</code>:</dt><dd><p>To record processing history, not yet in use </p>
</dd>
<dt><code>legend</code>:</dt><dd><p>Object of class <code>.RasterLegend</code>, Default legend. Should store preferences for plotting. Not yet implemented except that it stores the color table of images, if available</p>
</dd>
<dt><code>extent</code>:</dt><dd><p>Object of <code><a href="#topic+Extent-class">Extent-class</a></code> </p>
</dd>
<dt><code>ncols</code>:</dt><dd><p>Integer</p>
</dd> 
<dt><code>nrows</code>:</dt><dd><p>Integer</p>
</dd> 
<dt><code>crs</code>:</dt><dd><p>Object of class <code>"CRS"</code>, i.e. the coordinate reference system. In Spatial* objects this slot is called 'proj4string' </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("RasterLayer")
</code></pre>

<hr>
<h2 id='rasterFromCells'>Subset a raster by cell numbers</h2><span id='topic+rasterFromCells'></span>

<h3>Description</h3>

<p>This function returns a new raster based on an existing raster and cell numbers for that raster.
The new raster is cropped to the cell numbers provided, and, if <code>values=TRUE</code> has values that are the cell numbers of the original raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterFromCells(x, cells, values=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterFromCells_+3A_x">x</code></td>
<td>
<p>Raster* object (or a SpatialPixels* or SpatialGrid* object)</p>
</td></tr>
<tr><td><code id="rasterFromCells_+3A_cells">cells</code></td>
<td>
<p>vector of cell numbers</p>
</td></tr>
<tr><td><code id="rasterFromCells_+3A_values">values</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the new RasterLayer has cell values that correspond to the cell numbers of <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom.
The last cell number equals the number of cells of the Raster* object.
</p>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rowFromCell">rowFromCell</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=100, nrows=100)
cells &lt;- c(3:5, 210)
r &lt;- rasterFromCells(r, cells)
cbind(1:ncell(r), getValues(r))
</code></pre>

<hr>
<h2 id='rasterFromXYZ'> Create a Raster* object from x, y, z values </h2><span id='topic+rasterFromXYZ'></span>

<h3>Description</h3>

<p>Create a Raster* object from x, y and z values. x and y represent spatial coordinates and must be on a regular grid. If the resolution is not supplied, it is assumed to be the minimum distance between x and y coordinates, but a resolution of up to 10 times smaller is evaluated if a regular grid can otherwise not be created. z values can be single or multiple columns (variables)
If the exact properties of the RasterLayer are known beforehand, it may be preferable to simply create a new RasterLayer with the raster function instead, compute cell numbers and assign the values with these (see example below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterFromXYZ(xyz, res=c(NA,NA), crs="", digits=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterFromXYZ_+3A_xyz">xyz</code></td>
<td>
<p>matrix or data.frame with at least three columns: x and y coordinates, and values (z). There may be several 'z' variables (columns)</p>
</td></tr>
<tr><td><code id="rasterFromXYZ_+3A_res">res</code></td>
<td>
<p>numeric. The x and y cell resolution (optional)</p>
</td></tr>
<tr><td><code id="rasterFromXYZ_+3A_crs">crs</code></td>
<td>
<p>CRS object or a character string describing a projection and datum in PROJ.4 format</p>
</td></tr>
<tr><td><code id="rasterFromXYZ_+3A_digits">digits</code></td>
<td>
<p>numeric, indicating the requested precision for detecting whether points are on a regular grid (a low number of digits is a low precision)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+rasterize">rasterize</a> for points that are not on a regular grid</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=5, ncol=5, xmn=0, xmx=10, ymn=0, ymx=10, crs="")
set.seed(1)
values(r) &lt;- sample(1:25)
r[r &lt; 15] &lt;- NA
xyz &lt;- rasterToPoints(r)

rst &lt;- rasterFromXYZ(xyz)

# equivalent to:
rr &lt;- raster(nrow=5, ncol=5, xmn=0, xmx=10, ymn=0, ymx=10)
cells &lt;- cellFromXY(rr, xyz[,1:2])
rr[cells] &lt;- xyz[,3]

# multiple layers
xyzz &lt;- cbind(xyz, a=1:nrow(xyz), b=nrow(xyz):1)
b &lt;- rasterFromXYZ(xyzz)
</code></pre>

<hr>
<h2 id='rasterize'>Rasterize points, lines, or polygons</h2><span id='topic+rasterize'></span><span id='topic+rasterize+2Cmatrix+2CRaster-method'></span><span id='topic+rasterize+2Cdata.frame+2CRaster-method'></span><span id='topic+rasterize+2Csf+2CRaster-method'></span><span id='topic+rasterize+2CSpatialPoints+2CRaster-method'></span><span id='topic+rasterize+2CSpatialLines+2CRaster-method'></span><span id='topic+rasterize+2CSpatialPolygons+2CRaster-method'></span><span id='topic+rasterize+2CExtent+2CRaster-method'></span>

<h3>Description</h3>

<p>Transfer values associated with 'object' type spatial data (points, lines, polygons) to raster cells.
</p>
<p>For polygons, values are transferred if the polygon covers the center of a raster cell. For lines, values are transferred to all cells that are touched by a line. You can combine this behaviour by rasterizing polygons as lines first and then as polygons.
</p>
<p>If <code>x</code> represents points, each point is assigned to a grid cell. Points that fall on a border between cells are placed in the cell to the right and/or in the cell below. The value of a grid cell is determined by the values associated with the points and function <code>fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,Raster'
rasterize(x, y, field, fun='last', background=NA,
     mask=FALSE, update=FALSE, updateValue='all', filename="", na.rm=TRUE, ...)

## S4 method for signature 'SpatialPoints,Raster'
rasterize(x, y, field, fun='last', background=NA,
    mask=FALSE, update=FALSE, updateValue='all', filename="", na.rm=TRUE, ...)

## S4 method for signature 'SpatialLines,Raster'
rasterize(x, y, field, fun='last', background=NA,
    mask=FALSE, update=FALSE, updateValue='all', filename="", ...)

## S4 method for signature 'SpatialPolygons,Raster'
rasterize(x, y, field, fun='last', background=NA,
    mask=FALSE, update=FALSE, updateValue='all', filename="",
    getCover=FALSE, silent=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterize_+3A_x">x</code></td>
<td>
<p>points (a SpatialPoints* object, or a two-column matrix (or data.frame)), SpatialLines*, SpatialPolygons*, or an Extent object </p>
</td></tr>
<tr><td><code id="rasterize_+3A_y">y</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="rasterize_+3A_field">field</code></td>
<td>
<p>numeric or character. The value(s) to be transferred. This can be a single number, or a vector of numbers that has the same length as the number of spatial features (points, lines, polygons). If <code>x</code> is a Spatial*DataFrame, this can be the column name of the variable to be transferred. If missing, the attribute index is used (i.e. numbers from 1 to the number of features). You can also provide a vector with the same length as the number of spatial features, or a matrix where the number of rows matches the number of spatial features</p>
</td></tr>
<tr><td><code id="rasterize_+3A_fun">fun</code></td>
<td>
<p>function or character. To determine what values to assign to cells that are covered by multiple spatial features. You can use functions such as <code>min, max</code>, or <code>mean</code>, or one of the following character values: <code>'first'</code>, <code>'last'</code>, <code>'count'</code>. The default value is <code>'last'</code>. In the case of SpatialLines*, <code>'length'</code> is also allowed (currently for planar coordinate systems only).
</p>
<p>If <code>x</code> represents points, <code>fun</code> must accept a <code>na.rm</code> argument, either explicitly or through the ellipses ('dots'). This means that <code>fun=length</code> fails, but <code>fun=function(x,...)length(x)</code> works, although it ignores the <code>na.rm</code> argument. To use the <code>na.rm</code> argument you can use a function like this: <code>fun=function(x, na.rm){if (na.rm) length(na.omit(x)) else (length(x)}</code>, or use a function that removes <code>NA</code> values in all cases, like this function to compute the number of unique values per grid cell &quot;richness&quot;: <code>fun=function(x, ...) {length(unique(na.omit(x)))} </code>. If you want to count the number of points in each grid cell, you can use <code> fun='count'</code> or  <code>fun=function(x,...){length(x)}</code>.
</p>
<p>You can also pass multiple functions using a statement like <code>fun=function(x, ...) c(length(x),mean(x))</code>, in which case the returned object is a RasterBrick (multiple layers).
</p>
</td></tr>
<tr><td><code id="rasterize_+3A_background">background</code></td>
<td>
<p>numeric. Value to put in the cells that are not covered by any of the features of <code>x</code>. Default is <code>NA</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_mask">mask</code></td>
<td>
<p>logical. If <code>TRUE</code> the values of the input Raster object are 'masked' by the spatial features of <code>x</code>. That is, cells that spatially overlap with the spatial features retain their values, the other cells become <code>NA</code>. Default is <code>FALSE</code>. This option cannot be used when <code>update=TRUE</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_update">update</code></td>
<td>
<p>logical. If <code>TRUE</code>, the values of the Raster* object are updated for the cells that overlap the spatial features of <code>x</code>. Default is <code>FALSE</code>. Cannot be used when <code>mask=TRUE</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_updatevalue">updateValue</code></td>
<td>
<p>numeric (normally an integer), or character. Only relevant when <code>update=TRUE</code>. Select, by their values, the cells to be updated with the values of the spatial features. Valid character values are <code>'all'</code>, <code>'NA'</code>, and <code>'!NA'</code>. Default is <code>'all'</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="rasterize_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, <code>NA</code> values are removed if <code>fun</code> honors the <code>na.rm</code> argument</p>
</td></tr>
<tr><td><code id="rasterize_+3A_getcover">getCover</code></td>
<td>
<p>logical. If <code>TRUE</code>, the fraction of each grid cell that is covered by the polygons is returned (and the values of <code>field, fun, mask</code>, and <code>update</code> are ignored. The fraction covered is estimated by dividing each cell into 100 subcells and determining presence/absence of the polygon in the center of each subcell</p>
</td></tr>
<tr><td><code id="rasterize_+3A_silent">silent</code></td>
<td>
<p>Logical. If <code>TRUE</code>, feedback on the polygon count is suppressed. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_...">...</code></td>
<td>
<p>Additional arguments for file writing as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+extract">extract</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
###############################
# rasterize points
###############################
r &lt;- raster(ncols=36, nrows=18)
n &lt;- 1000
set.seed(123)
x &lt;- runif(n) * 360 - 180
y &lt;- runif(n) * 180 - 90
xy &lt;- cbind(x, y)
# get the (last) indices
r0 &lt;- rasterize(xy, r)
# presence/absensce (NA) (is there a point or not?)
r1 &lt;- rasterize(xy, r, field=1)
# how many points?
r2 &lt;- rasterize(xy, r, fun=function(x,...)length(x))
vals &lt;- runif(n)
# sum of the values associated with the points
r3 &lt;- rasterize(xy, r, vals, fun=sum)

# with a SpatialPointsDataFrame
vals &lt;- 1:n
p &lt;- data.frame(xy, name=vals)
coordinates(p) &lt;- ~x+y
r &lt;- rasterize(p, r, 'name', fun=min)
#r2 &lt;- rasterize(p, r, 'name', fun=max)
#plot(r, r2, cex=0.5)

###############################
# rasterize lines
###############################
cds1 &lt;- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60))
cds2 &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
cds3 &lt;- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45))

lines &lt;- spLines(cds1, cds2, cds3)

r &lt;- raster(ncols=90, nrows=45)
r &lt;- rasterize(lines, r)

## Not run: 
plot(r)
plot(lines, add=TRUE)

r &lt;- rasterize(lines, r, fun='count')
plot(r)

values(r) &lt;- 1:ncell(r)
r &lt;- rasterize(lines, r, mask=TRUE)
plot(r)

values(r) &lt;- 1
r[lines] &lt;- 10
plot(r)

## End(Not run)

###############################
# rasterize polygons
###############################

p1 &lt;- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60), c(-180,-20))
hole &lt;- rbind(c(-150,-20), c(-100,-10), c(-110,20), c(-150,-20))
p1 &lt;- list(p1, hole)
p2 &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55), c(-10,0))
p3 &lt;- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45), c(-125,0))

pols &lt;- spPolygons(p1, p2, p3)

r &lt;- raster(ncol=90, nrow=45)
r &lt;- rasterize(pols, r, fun=sum)


## Not run: 

plot(r)
plot(pols, add=T)

# add a polygon
p5 &lt;- rbind(c(-180,10), c(0,90), c(40,90), c(145,-10),
            c(-25, -15), c(-180,0), c(-180,10))
addpoly &lt;- SpatialPolygons(list(Polygons(list(Polygon(p5)), 1)))
addpoly &lt;- as(addpoly, "SpatialPolygonsDataFrame")
addpoly@data[1,1] &lt;- 10
r2 &lt;- rasterize(addpoly, r, field=1, update=TRUE, updateValue="NA")
plot(r2)
plot(pols, border="blue", lwd=2, add=TRUE)
plot(addpoly, add=TRUE, border="red", lwd=2)

# get the percentage cover of polygons in a cell
r3 &lt;- raster(ncol=36, nrow=18)
r3 &lt;- rasterize(pols, r3, getCover=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='rasterTmpFile'>Temporary files</h2><span id='topic+rasterTmpFile'></span><span id='topic+removeTmpFiles'></span><span id='topic+showTmpFiles'></span>

<h3>Description</h3>

<p>Functions in the raster package create temporary files if the values of an output Raster* object cannot be stored in memory (RAM). This can happen
when no filename is provided to a function and in functions where you cannot provide a filename (e.g. when using 'raster algebra').
</p>
<p>Temporary files are automatically removed at the start of each session. During a session you can use <code>showTmpFiles</code> to see what is there and <code>removeTmpFiles</code> to delete all the temporary files.  <code>rasterTmpFile</code> returns a temporary filename. These can be useful when developing your own functions. These filenames consist of  <code>prefix_date_time_pid_rn</code> where <code>pid</code> is the process id returned by <code><a href="base.html#topic+Sys.getpid">Sys.getpid</a></code> and <code>rn</code> is a 5 digit random number. This should make tempfiles unique if created at different times and also when created in parallel processes (different pid) that use <code><a href="base.html#topic+set.seed">set.seed</a></code> and call rasterTmpFile at the same time. It is possible, however, to create overlapping names (see the examples), which is undesirable and can be avoided by setting the prefix argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterTmpFile(prefix='r_tmp_')
showTmpFiles()
removeTmpFiles(h=24)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterTmpFile_+3A_prefix">prefix</code></td>
<td>
<p>Character. Prefix to the filename (which will be followed by 10 random numbers)</p>
</td></tr>
<tr><td><code id="rasterTmpFile_+3A_h">h</code></td>
<td>
<p>Numeric. The minimum age of the files in number of hours (younger files are not deleted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rasterTmpFile</code> returns a valid file name
</p>
<p><code>showTmpFiles</code> returns the names (.grd only) of the files in the temp directory
</p>
<p><code>removeTmpFiles</code> returns nothing
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rasterOptions">rasterOptions</a></code>, <code><a href="base.html#topic+tempfile">tempfile</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rasterTmpFile('mytemp_')
showTmpFiles()
removeTmpFiles(h=24)

## End(Not run)</code></pre>

<hr>
<h2 id='rasterToContour'> Raster to contour lines conversion</h2><span id='topic+rasterToContour'></span>

<h3>Description</h3>

<p>RasterLayer to contour lines. This is a wrapper around <code><a href="grDevices.html#topic+contourLines">contourLines</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToContour(x, maxpixels=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToContour_+3A_x">x</code></td>
<td>
<p> a RasterLayer object </p>
</td></tr>
<tr><td><code id="rasterToContour_+3A_maxpixels">maxpixels</code></td>
<td>
<p> Maximum number of raster cells to use; this function fails when too many cells are used</p>
</td></tr>
<tr><td><code id="rasterToContour_+3A_...">...</code></td>
<td>
<p>Any argument that can be passed to <code><a href="grDevices.html#topic+contourLines">contourLines</a></code> </p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Most of the code was taken from maptools::ContourLines2SLDF, by Roger Bivand &amp; Edzer Pebesma 
</p>


<h3>Value</h3>

<p>SpatialLinesDataFrame 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("external/test.grd", package="raster")
r &lt;- raster(f)
x &lt;- rasterToContour(r)
class(x)
plot(r)
plot(x, add=TRUE)
</code></pre>

<hr>
<h2 id='rasterToPoints'> Raster to points conversion</h2><span id='topic+rasterToPoints'></span>

<h3>Description</h3>

<p>Raster to point conversion. Cells with NA are not converted. A function can be used to select a subset of the raster cells (by their values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToPoints(x, fun=NULL, spatial=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToPoints_+3A_x">x</code></td>
<td>
<p>A Raster* object </p>
</td></tr>
<tr><td><code id="rasterToPoints_+3A_fun">fun</code></td>
<td>
<p>Function to select a subset of raster values</p>
</td></tr>
<tr><td><code id="rasterToPoints_+3A_spatial">spatial</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function returns a SpatialPointsDataFrame object </p>
</td></tr>
<tr><td><code id="rasterToPoints_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently only <code>progress</code> to specify a progress bar. &quot;text&quot;, &quot;window&quot;, or &quot;&quot; (the default, no progress bar)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fun</code> should be a simple function returning a logical value. 
</p>
<p>E.g.: <code>fun=function(x){x==1}</code> or  <code>fun=function(x){x&gt;3}</code>
</p>


<h3>Value</h3>

<p>A matrix with three columns: x, y, and v (value), or a SpatialPointsDataFrame object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(nrow=18, ncol=36)
values(r) &lt;- runif(ncell(r)) * 10
r[r&gt;8] &lt;- NA
p &lt;- rasterToPoints(r)
p &lt;- rasterToPoints(r, fun=function(x){x&gt;6})
#plot(r)
#points(p)
</code></pre>

<hr>
<h2 id='rasterToPolygons'> Raster to polygons conversion</h2><span id='topic+rasterToPolygons'></span>

<h3>Description</h3>

<p>Raster to polygons conversion. Cells with NA are not converted. A function can be used to select a subset of the raster cells (by their values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToPolygons(x, fun=NULL, n=4, na.rm=TRUE, digits=12, dissolve=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToPolygons_+3A_x">x</code></td>
<td>
<p> Raster* object </p>
</td></tr>
<tr><td><code id="rasterToPolygons_+3A_fun">fun</code></td>
<td>
<p> function to select a subset of raster values (only allowed if <code>x</code> has a single layer)</p>
</td></tr>
<tr><td><code id="rasterToPolygons_+3A_n">n</code></td>
<td>
<p> integer. The number of nodes for each polygon. Only 4, 8, and 16 are allowed </p>
</td></tr>
<tr><td><code id="rasterToPolygons_+3A_na.rm">na.rm</code></td>
<td>
<p> If <code>TRUE</code>, cells with <code>NA</code> values in all layers are ignored </p>
</td></tr>
<tr><td><code id="rasterToPolygons_+3A_digits">digits</code></td>
<td>
<p> number of digits to round the coordinates to </p>
</td></tr>
<tr><td><code id="rasterToPolygons_+3A_dissolve">dissolve</code></td>
<td>
<p>logical. If <code>TRUE</code>, polygons with the same attribute value will be dissolved into multi-polygon regions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fun</code> should be a simple function returning a logical value. 
</p>
<p>E.g.: <code>fun=function(x){x==1}</code> or  <code>fun=function(x){x&gt;3 &amp; x&lt;6}</code>
</p>


<h3>Value</h3>

<p>SpatialPolygonsDataFrame
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(nrow=18, ncol=36)
values(r) &lt;- runif(ncell(r)) * 10
r[r&gt;8] &lt;- NA
pol &lt;- rasterToPolygons(r, fun=function(x){x&gt;6})

#plot(r &gt; 6)
#plot(pol, add=TRUE, col='red')
</code></pre>

<hr>
<h2 id='Rcpp-class'> Rcpp classes</h2><span id='topic+SpPoly'></span><span id='topic+SpPolygons'></span><span id='topic+SpPolyPart'></span><span id='topic+SpExtent'></span><span id='topic+SpPoly-class'></span><span id='topic+SpPolyPart-class'></span><span id='topic+SpPolygons-class'></span><span id='topic+Rcpp_SpExtent-class'></span><span id='topic+Rcpp_SpPolygons-class'></span><span id='topic+Rcpp_SpPoly-class'></span><span id='topic+Rcpp_SpPolyPart-class'></span>

<h3>Description</h3>

<p>These classes are for internal use only
</p>

<hr>
<h2 id='readAll'>Read values from disk</h2><span id='topic+readAll+2CRasterLayer-method'></span><span id='topic+readAll+2CRasterStack-method'></span><span id='topic+readAll+2CRasterBrick-method'></span><span id='topic+readAll'></span>

<h3>Description</h3>

<p>Read all values from a raster file associated with a Raster* object into memory. This function should normally not be used. In most cases <code><a href="#topic+getValues">getValues</a></code> or <code><a href="#topic+getValuesBlock">getValuesBlock</a></code> is more appropriate as <code>readAll</code> will fail when there is no file associated with the RasterLayer (values may only exist in memory). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAll(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readAll_+3A_object">object</code></td>
<td>
<p>a Raster* object</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+getValues">getValues</a></code>, <code><a href="#topic+getValuesBlock">getValuesBlock</a></code>, <code><a href="#topic+extract">extract</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/test.grd", package="raster"))
r &lt;- readAll(r)
</code></pre>

<hr>
<h2 id='reclassify'>Reclassify</h2><span id='topic+reclassify'></span><span id='topic+reclassify+2CRaster-method'></span>

<h3>Description</h3>

<p>Reclassify values of a Raster* object. The function (re)classifies groups of values to other values. For example, all values between 1 and 10 become 1, and all values between 11 and 15 become 2 (see functions <code><a href="#topic+subs">subs</a></code> and <code><a href="#topic+cut">cut</a></code> for alternative approaches). 
</p>
<p>Reclassification is done with matrix <code>rcl</code>, in the row order of the reclassify table. Thus, if there are overlapping ranges, the first time a number is within a range determines the reclassification value.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
reclassify(x, rcl, filename='', include.lowest=FALSE, right=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reclassify_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="reclassify_+3A_rcl">rcl</code></td>
<td>
<p>matrix for reclassification. This matrix can have 3 or 2 columns. 
</p>
<p>In a <code>3-column matrix</code> the first two columns are &quot;from&quot; - &quot;to&quot; for the input values, and the third column &quot;becomes&quot; has the new value for that range. (You can also supply a vector that can be coerced into a n*3 matrix (with <code>byrow=TRUE</code>)). 
</p>
<p>A <code>2-column matrix</code> represents (&quot;is&quot;, &quot;becomes&quot;) which can be useful for integer values. In that case, the <code>right</code> argument is automatically set to <code>NA</code></p>
</td></tr>
<tr><td><code id="reclassify_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional) </p>
</td></tr>
<tr><td><code id="reclassify_+3A_include.lowest">include.lowest</code></td>
<td>
<p>logical, indicating if a value equal to the lowest value in rcl (or highest value in the second column, for right = FALSE) should be included. The default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="reclassify_+3A_right">right</code></td>
<td>
<p>logical, indicating if the intervals should be closed on the right (and open on the left) or vice versa. The default is <code>TRUE</code>. A special case is to use right=NA. In this case both the left and right intervals are open</p>
</td></tr>
<tr><td><code id="reclassify_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>See Also</h3>

 <p><code> <a href="#topic+subs">subs</a>, <a href="#topic+clamp">clamp</a>, <a href="#topic+cut">cut</a>, <a href="#topic+calc">calc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- raster(ncols=36, nrows=18)
values(r) &lt;- runif(ncell(r)) 
# reclassify the values into three groups 
# all values &gt; 0 and &lt;= 0.25 become 1, etc.
m &lt;- c(0, 0.25, 1,  0.25, 0.5, 2,  0.5, 1, 3)
rclmat &lt;- matrix(m, ncol=3, byrow=TRUE)
rc &lt;- reclassify(r, rclmat)

# for values &gt;= 0 (instead of &gt; 0), do
rc &lt;- reclassify(r, rclmat, include.lowest=TRUE)

# equivalent to
rc &lt;- reclassify(r, c(-Inf,0.25,1, 0.25,0.5,2, 0.5,Inf,3))
</code></pre>

<hr>
<h2 id='rectify'>rectify a Raster object</h2><span id='topic+rectify'></span><span id='topic+rectify+2CRaster-method'></span>

<h3>Description</h3>

<p>rectify changes a rotated Raster* object into a non-rotated (rectangular) object. This is wrapper function around <code><a href="#topic+resample">resample</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
rectify(x, ext, res, method='ngb', filename='', ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectify_+3A_x">x</code></td>
<td>
<p>Raster* object to be rectified</p>
</td></tr>
<tr><td><code id="rectify_+3A_ext">ext</code></td>
<td>
<p>Optional. Extent object or object from which an Extent object can be extracted</p>
</td></tr>
<tr><td><code id="rectify_+3A_res">res</code></td>
<td>
<p>Optional. Single or two numbers to set the resolution</p>
</td></tr>
<tr><td><code id="rectify_+3A_method">method</code></td>
<td>
<p>Method used to compute values for the new RasterLayer, should be &quot;bilinear&quot; for bilinear interpolation, or &quot;ngb&quot; for nearest neighbor </p>
</td></tr>
<tr><td><code id="rectify_+3A_filename">filename</code></td>
<td>
<p>Character. Output filename </p>
</td></tr>
<tr><td><code id="rectify_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick object
</p>

<hr>
<h2 id='replacement'>Replace cell values or layers of a Raster* object</h2><span id='topic++5B+3C-+2CRasterLayer+2CRasterLayer+2Cmissing-method'></span><span id='topic++5B+3C-+2CRasterLayer+2Cmissing+2Cmissing-method'></span><span id='topic++5B+3C-+2CRasterStackBrick+2CRaster+2Cmissing-method'></span><span id='topic++5B+3C-+2CRasterStackBrick+2Cmissing+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2CRasterStack+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2CRaster+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2CRasterStackBrick+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2CRasterLayer+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+3C-+2CRaster+2Cnumeric+2Cnumeric-method'></span><span id='topic++5B+3C-+2CRaster+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+3C-+2CRaster+2Cmatrix+2Cmissing-method'></span><span id='topic++5B+3C-+2CRaster+2Clogical+2Cmissing-method'></span><span id='topic++5B+3C-+2CRaster+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2CRaster+2CSpatial+2Cmissing-method'></span><span id='topic++5B+3C-+2CRaster+2CExtent+2Cmissing-method'></span><span id='topic++5B+3C-+2CExtent+2Cnumeric+2Cmissing-method'></span><span id='topic++24+3C-+2CRaster-method'></span><span id='topic++24+2CRaster-method'></span>

<h3>Description</h3>

<p>You can set values of a Raster* object, when <code>i</code> is a vector of cell numbers, a Raster*, Extent, or Spatial* object. 
</p>
<p>These are shorthand methods that work best for relatively small Raster* objects. In other cases you can use functions such as <code><a href="#topic+calc">calc</a> and <a href="#topic+rasterize">rasterize</a></code>. 
</p>


<h3>Methods</h3>


<p><code>x[i] &lt;- value</code>
</p>
<p><code>x[i,j] &lt;- value</code>
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <b>Arguments:</b> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>x</code> </td><td style="text-align: left;"> a Raster* object </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>i</code> </td><td style="text-align: left;"> cell number(s), row number(s), Extent, Spatial* object </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>j</code> </td><td style="text-align: left;"> columns number(s) (only available if i is (are) a row number(s)) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>value</code> </td><td style="text-align: left;"> new cell value(s) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>See Also</h3>

 <p><a href="#topic+calc">calc</a>, <a href="#topic+rasterize">rasterize</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=5)
values(r) &lt;- 1:ncell(r) * 2
r[1,] &lt;- 1
r[,1] &lt;- 2
r[1,1] &lt;- 3

s &lt;- stack(r, sqrt(r))
s[s&lt;5] &lt;- NA

</code></pre>

<hr>
<h2 id='resample'>Resample a Raster object</h2><span id='topic+resample'></span><span id='topic+resample+2CRaster+2CRaster-method'></span>

<h3>Description</h3>

<p>Resample transfers values between non matching Raster* objects (in terms of origin and resolution). Use <code><a href="#topic+projectRaster">projectRaster</a></code> if the target has a different coordinate reference system (projection).
</p>
<p>Before using resample, you may want to consider using these other functions instead: <code><a href="#topic+aggregate">aggregate</a></code>, <code><a href="#topic+disaggregate">disaggregate</a></code>, <code><a href="#topic+crop">crop</a></code>, <code><a href="#topic+extend">extend</a></code>, <code><a href="#topic+merge">merge</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,Raster'
resample(x, y, method="bilinear", filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>Raster* object to be resampled</p>
</td></tr>
<tr><td><code id="resample_+3A_y">y</code></td>
<td>
<p>Raster* object with parameters that <code>x</code> should be resampled to</p>
</td></tr>
<tr><td><code id="resample_+3A_method">method</code></td>
<td>
<p>method used to compute values for the new RasterLayer, should be <code>"bilinear"</code> for bilinear interpolation, or <code>"ngb"</code> for using the nearest neighbor</p>
</td></tr>
<tr><td><code id="resample_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional) </p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick object 
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Joe Cheng</p>


<h3>See Also</h3>

 <p><code><a href="#topic+aggregate">aggregate</a></code>, <code><a href="#topic+disaggregate">disaggregate</a></code>, <code><a href="#topic+crop">crop</a></code>, <code><a href="#topic+extend">extend</a></code>, <code><a href="#topic+merge">merge</a></code>, <code><a href="#topic+projectRaster">projectRaster</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=3, ncol=3)
values(r) &lt;- 1:ncell(r)
s &lt;- raster(nrow=10, ncol=10)
s &lt;- resample(r, s, method='bilinear')
#par(mfrow=c(1,2))
#plot(r)
#plot(s)
</code></pre>

<hr>
<h2 id='resolution'>Resolution</h2><span id='topic+xres'></span><span id='topic+yres'></span><span id='topic+res'></span><span id='topic+xres+2CBasicRaster-method'></span><span id='topic+yres+2CBasicRaster-method'></span><span id='topic+res+2CBasicRaster-method'></span><span id='topic+res+3C-'></span><span id='topic+res+3C-+2CBasicRaster-method'></span>

<h3>Description</h3>

<p>Get (or set) the x and/or y resolution of a Raster* object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xres(x)
yres(x)
res(x)
res(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolution_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="resolution_+3A_value">value</code></td>
<td>
<p>Resolution (single number or vector of two numbers) </p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A single numeric value or two numeric values.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+extent">extent</a></code>, <code><a href="#topic+ncell">ncell</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=18, nrow=18)
xres(r)
yres(r)
res(r)

res(r) &lt;- 1/120
# set yres differently
res(r) &lt;- c(1/120, 1/60)


</code></pre>

<hr>
<h2 id='RGB'>Create a Red-Green-Blue Raster object</h2><span id='topic+RGB'></span><span id='topic+RGB+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Make a Red-Green-Blue object that can be used to create images. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
RGB(x, filename='', col=rainbow(25), breaks=NULL, alpha=FALSE, 
		colNA='white', zlim=NULL, zlimcol=NULL, ext=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RGB_+3A_x">x</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="RGB_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="RGB_+3A_col">col</code></td>
<td>
<p>A color palette, that is a vector of n contiguous colors generated by functions like <a href="grDevices.html#topic+rainbow">rainbow</a>, <a href="grDevices.html#topic+heat.colors">heat.colors</a>, <a href="grDevices.html#topic+topo.colors">topo.colors</a>, <a href="sp.html#topic+bpy.colors">bpy.colors</a> or one or your own making, perhaps using <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>. If none is provided, <code>rev(terrain.colors(255))</code> is used unless <code>x</code> has a 'color table'</p>
</td></tr>
<tr><td><code id="RGB_+3A_breaks">breaks</code></td>
<td>
<p>numeric. A set of finite numeric breakpoints for the colours: must have one more breakpoint than colour and be in increasing order</p>
</td></tr>  
<tr><td><code id="RGB_+3A_alpha">alpha</code></td>
<td>
<p>If <code>TRUE</code> a fourth layer to set the background transparency is added</p>
</td></tr>
<tr><td><code id="RGB_+3A_colna">colNA</code></td>
<td>
<p>color for the background (<code>NA</code> values)</p>
</td></tr>
<tr><td><code id="RGB_+3A_zlim">zlim</code></td>
<td>
<p>vector of lenght 2. Range of values to plot</p>
</td></tr>
<tr><td><code id="RGB_+3A_zlimcol">zlimcol</code></td>
<td>
<p>If <code>NULL</code> the values outside the range of zlim get the color of the extremes of the range. If zlimcol has any other value, the values outside the zlim range get the color of <code>NA</code> values (see colNA)</p>
</td></tr>
<tr><td><code id="RGB_+3A_ext">ext</code></td>
<td>
<p>An <code><a href="#topic+Extent">Extent</a></code> object to zoom in to a region of interest (see <code><a href="#topic+drawExtent">drawExtent</a></code>)</p>
</td></tr>
<tr><td><code id="RGB_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterBrick</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotRGB">plotRGB</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/test.grd", package="raster"))
x &lt;- RGB(r)
plot(x, col=gray(0:9/10))
plotRGB(x)
</code></pre>

<hr>
<h2 id='rotate'>Rotate</h2><span id='topic+rotate'></span><span id='topic+rotate+2CRaster-method'></span>

<h3>Description</h3>

<p>Rotate a Raster* object that has x coordinates (longitude) from 0 to 360, to standard coordinates between -180 and 180 degrees. Longitude between 0 and 360 is frequently used in global climate models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
rotate(x, filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="rotate_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="rotate_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>RasterLayer or a RasterBrick object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+flip">flip</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- raster(nrow=18, ncol=36)
m &lt;- matrix(1:ncell(r), nrow=18)
values(r) &lt;- as.vector(t(m))
extent(r) &lt;- extent(0, 360, -90, 90)
rr &lt;- rotate(r)
</code></pre>

<hr>
<h2 id='rotated'>Do the raster cells have a rotation?</h2><span id='topic+rotated'></span>

<h3>Description</h3>

<p>Do the raster cells have a rotation?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotated(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotated_+3A_x">x</code></td>
<td>
<p>A Raster* object</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Logical value
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rectify">rectify</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
rotated(r)
</code></pre>

<hr>
<h2 id='round'>Integer values</h2><span id='topic+round+2CRasterLayer-method'></span><span id='topic+trunc+2CRasterLayer-method'></span><span id='topic+ceiling+2CRasterLayer-method'></span><span id='topic+floor+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>These functions take a single RasterLayer argument <code>x</code> and change its values to integers.
</p>
<p><code>ceiling</code> returns a RasterLayer with the smallest integers not less than the corresponding values of x. 
</p>
<p><code>floor</code> returns a RasterLayer with the largest integers not greater than the corresponding values of x. 
</p>
<p><code>trunc</code> returns a RasterLayer with the integers formed by truncating the values in x toward 0. 
</p>
<p><code>round</code> returns a RasterLayer with values rounded to the specified number of digits (decimal places; default 0). 
</p>


<h3>Details</h3>

<p>see ?base::round
</p>


<h3>Value</h3>

<p>a RasterLayer object
</p>


<h3>Methods</h3>


<p>ceiling(x)
floor(x)
trunc(x, ...)
round(x, digits = 0)
</p>
<dl>
<dt>x</dt><dd><p>a RasterLayer object</p>
</dd>
<dt>digits</dt><dd><p>integer indicating the precision to be used</p>
</dd>
<dt>...</dt><dd><p>additional arguments</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10)
values(r) &lt;- runif(ncell(r)) * 10
s &lt;- round(r)

</code></pre>

<hr>
<h2 id='rowFromCell'>Row or column number from a cell number</h2><span id='topic+rowFromCell'></span><span id='topic+rowFromCell+2CBasicRaster+2Cnumeric-method'></span><span id='topic+colFromCell'></span><span id='topic+colFromCell+2CBasicRaster+2Cnumeric-method'></span><span id='topic+rowColFromCell'></span><span id='topic+rowColFromCell+2CBasicRaster+2Cnumeric-method'></span>

<h3>Description</h3>

<p>These functions get the row and/or column number from a cell number of a Raster* object)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colFromCell(object, cell)
rowFromCell(object, cell)
rowColFromCell(object, cell)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowFromCell_+3A_object">object</code></td>
<td>
<p>Raster* object (or a SpatialPixels* or SpatialGrid* object)</p>
</td></tr>
<tr><td><code id="rowFromCell_+3A_cell">cell</code></td>
<td>
<p>cell number(s)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The colFromCell and similar functions accept a single value, or a vector or list of these values,
Cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom.
The last cell number equals the number of cells of the Raster* object.
</p>


<h3>Value</h3>

<p>row of column number(s) 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cellFrom">cellFrom</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=10, nrows=10)
colFromCell(r, c(5,15))
rowFromCell(r, c(5,15))
rowColFromCell(r, c(5,15))
</code></pre>

<hr>
<h2 id='rowSums'>rowSums and colSums for Raster objects</h2><span id='topic+rowSums'></span><span id='topic+rowSums+2CRaster-method'></span><span id='topic+colSums'></span><span id='topic+colSums+2CRaster-method'></span>

<h3>Description</h3>

<p>Sum values of Raster objects by row or column. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
rowSums(x, na.rm=FALSE, dims=1L,...) 
## S4 method for signature 'Raster'
colSums(x, na.rm=FALSE, dims=1L,...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowSums_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="rowSums_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> values are ignored</p>
</td></tr>
<tr><td><code id="rowSums_+3A_dims">dims</code></td>
<td>
<p>this argument is ignored</p>
</td></tr>
<tr><td><code id="rowSums_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector (if <code>x</code> is a RasterLayer) or matrix
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+cellStats">cellStats</a></code> for summing all cells values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=2, nrows=5)
values(r) &lt;- 1:10
as.matrix(r)
rowSums(r)
colSums(r)
</code></pre>

<hr>
<h2 id='SampleInt'>Sample integer values</h2><span id='topic+sampleInt'></span>

<h3>Description</h3>

<p>Take a random sample from a range of integer values between 1 and <code>n</code>. Its purpose is similar to that of <code><a href="base.html#topic+sample">sample</a></code>, but that function fails when <code>n</code> is very large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleInt(n, size, replace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SampleInt_+3A_n">n</code></td>
<td>
<p>Positive number (integer); the number of items to choose from </p>
</td></tr>
<tr><td><code id="SampleInt_+3A_size">size</code></td>
<td>
<p>Non-negative integer; the number of items to choose</p>
</td></tr>  
<tr><td><code id="SampleInt_+3A_replace">replace</code></td>
<td>
<p>Logical. Should sampling be with replacement?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of integer numbers</p>


<h3>Examples</h3>

<pre><code class='language-R'>  sampleInt(1e+12, 10)
  
# this may fail:
#  sample.int(1e+12, 10)
#  sample.int(1e+9, 10)
</code></pre>

<hr>
<h2 id='sampleRandom'>Random sample</h2><span id='topic+sampleRandom'></span><span id='topic+sampleRandom+2CRaster-method'></span>

<h3>Description</h3>

<p>Take a random sample from the cell values of a Raster* object (without replacement). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
sampleRandom(x, size, na.rm=TRUE, ext=NULL, 
    cells=FALSE, rowcol=FALSE, xy=FALSE, sp=FALSE, asRaster=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleRandom_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="sampleRandom_+3A_size">size</code></td>
<td>
<p>positive integer giving the number of items to choose</p>
</td></tr> 
<tr><td><code id="sampleRandom_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default), <code>NA</code> values are removed from random sample</p>
</td></tr>
<tr><td><code id="sampleRandom_+3A_ext">ext</code></td>
<td>
<p>Extent object. To limit regular sampling to the area within the extent</p>
</td></tr>
<tr><td><code id="sampleRandom_+3A_cells">cells</code></td>
<td>
<p>logical. If <code>TRUE</code>, sampled cell numbers are also returned</p>
</td></tr>
<tr><td><code id="sampleRandom_+3A_rowcol">rowcol</code></td>
<td>
<p>logical. If <code>TRUE</code>, sampled row and column numbers are also returned</p>
</td></tr>
<tr><td><code id="sampleRandom_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code>, coordinates of sampled cells are also returned</p>
</td></tr>
<tr><td><code id="sampleRandom_+3A_sp">sp</code></td>
<td>
<p>logical. If <code>TRUE</code>, a SpatialPointsDataFrame is returned</p>
</td></tr>
<tr><td><code id="sampleRandom_+3A_asraster">asRaster</code></td>
<td>
<p>logical. If <code>TRUE</code>, a Raster* object is returned with random cells with values, all other cells with <code>NA</code></p>
</td></tr>
<tr><td><code id="sampleRandom_+3A_...">...</code></td>
<td>
<p>Additional arguments as in <code><a href="#topic+writeRaster">writeRaster</a></code>. Only relevant when <code>asRaster=TRUE</code></p>
</td></tr> 
</table>


<h3>Details</h3>

<p>With argument <code>na.rm=TRUE</code>, the returned sample may be smaller than requested
</p>


<h3>Value</h3>

<p>A vector, matrix (if <code>cells=TRUE</code> or <code>x</code> is a multi-layered object), or a SpatialPointsDataFrame (if <code>sp=TRUE</code> )
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleRegular">sampleRegular</a>, <a href="#topic+sampleStratified">sampleStratified</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> r &lt;- raster(system.file("external/test.grd", package="raster"))
 sampleRandom(r, size=10)
 s &lt;- stack(r, r)
 sampleRandom(s, size=5, cells=TRUE, sp=TRUE)
</code></pre>

<hr>
<h2 id='sampleRegular'>Regular sample</h2><span id='topic+sampleRegular'></span><span id='topic+sampleRegular+2CRaster-method'></span>

<h3>Description</h3>

<p>Take a systematic sample from a Raster* object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
sampleRegular(x, size, ext=NULL, cells=FALSE, xy=FALSE, asRaster=FALSE, 
            sp=FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleRegular_+3A_x">x</code></td>
<td>
<p>Raster object</p>
</td></tr>
<tr><td><code id="sampleRegular_+3A_size">size</code></td>
<td>
<p>positive integer giving the number of items to choose.</p>
</td></tr>  
<tr><td><code id="sampleRegular_+3A_ext">ext</code></td>
<td>
<p>Extent. To limit regular sampling to the area within that box</p>
</td></tr>  
<tr><td><code id="sampleRegular_+3A_cells">cells</code></td>
<td>
<p>logical. Also return sampled cell numbers (if asRaster=FALSE) </p>
</td></tr>  
<tr><td><code id="sampleRegular_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code>, coordinates of sampled cells are also returned</p>
</td></tr>
<tr><td><code id="sampleRegular_+3A_asraster">asRaster</code></td>
<td>
<p>logical. If <code>TRUE</code>, a RasterLayer or RasterBrick is returned, rather than the sampled values</p>
</td></tr>  
<tr><td><code id="sampleRegular_+3A_sp">sp</code></td>
<td>
<p>logical. If <code>TRUE</code>, a SpatialPointsDataFrame is returned</p>
</td></tr>  
<tr><td><code id="sampleRegular_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (single layer object), matrix (multi-layered object; or if <code>cells=TRUE</code>, or <code>xy=TRUE</code>), Raster* object (if <code>asRaster=TRUE</code>), or SpatialPointsDataFrame (if <code>sp=TRUE</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleRandom">sampleRandom</a></code>, <a href="#topic+sampleStratified">sampleStratified</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> r &lt;- raster(system.file("external/test.grd", package="raster"))
 v &lt;- sampleRegular(r, size=100)
 x &lt;- sampleRegular(r, size=100, asRaster=TRUE)
</code></pre>

<hr>
<h2 id='sampleStratified'>Stratified random sample</h2><span id='topic+sampleStratified'></span><span id='topic+sampleStratified+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Take a stratified random sample from the cell values of a Raster* object (without replacement). An attempt is made to sample <code>size</code> cells from each stratum. The values in the RasterLayer <code>x</code> are rounded to integers; with each value representing a stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
sampleStratified(x, size, exp=10, na.rm=TRUE, xy=FALSE, ext=NULL, sp=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleStratified_+3A_x">x</code></td>
<td>
<p>Raster* object, with values (rounded to integers) representing strata</p>
</td></tr>
<tr><td><code id="sampleStratified_+3A_size">size</code></td>
<td>
<p>positive integer giving the number of items to choose</p>
</td></tr> 
<tr><td><code id="sampleStratified_+3A_exp">exp</code></td>
<td>
<p>numeric &gt;= 1. 'Expansion factor' that is multiplied with size to get an intial sample. Can be increased when you get an insufficient number of samples for small strata</p>
</td></tr>
<tr><td><code id="sampleStratified_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default), <code>NA</code> values are removed from random sample</p>
</td></tr>
<tr><td><code id="sampleStratified_+3A_xy">xy</code></td>
<td>
<p>logical. Return coordinates of cells rather than cell numbers</p>
</td></tr>
<tr><td><code id="sampleStratified_+3A_ext">ext</code></td>
<td>
<p>Extent object. To limit regular sampling to the area within the extent</p>
</td></tr>
<tr><td><code id="sampleStratified_+3A_sp">sp</code></td>
<td>
<p>logical. If <code>TRUE</code>, a SpatialPointsDataFrame is returned</p>
</td></tr>  
<tr><td><code id="sampleStratified_+3A_...">...</code></td>
<td>
<p>Additional arguments. None implemented</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function may not work well when the size (number of cells) of some strata is relatively small.
</p>


<h3>Value</h3>

<p>matrix of cell numbers (and optionally coordinates) by stratum
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleRandom">sampleRandom</a>, <a href="#topic+sampleRegular">sampleRegular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> r &lt;- raster(ncol=10, nrow=10)
 names(r) &lt;- 'stratum'
 values(r) &lt;- round((runif(ncell(r))+0.5)*3)
 sampleStratified(r, size=3)
</code></pre>

<hr>
<h2 id='scale'>Scale values</h2><span id='topic+scale'></span><span id='topic+scale+2CRaster-method'></span>

<h3>Description</h3>

<p>Center and/or scale raster data 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
scale(x, center=TRUE, scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="scale_+3A_center">center</code></td>
<td>
<p>logical or numeric. If <code>TRUE</code>, centering is done by subtracting the layer means (omitting <code>NA</code>s), and if <code>FALSE</code>, no centering is done. If <code>center</code> is a numeric vector with length equal to the <code>nlayers(x)</code>, then each layer of <code>x</code> has the corresponding value from center subtracted from it.</p>
</td></tr>
<tr><td><code id="scale_+3A_scale">scale</code></td>
<td>
<p>logical or numeric. If <code>TRUE</code>, scaling is done by dividing the (centered) layers of <code>x</code> by their standard deviations if <code>center</code> is <code>TRUE</code>, and the root mean square otherwise. If scale is <code>FALSE</code>, no scaling is done. If <code>scale</code> is a numeric vector with length equal to <code>nlayers(x)</code>, each layer of <code>x</code> is divided by the corresponding value. Scaling is done after centering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+scale">scale</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brick(system.file("external/rlogo.grd", package="raster"))
bs &lt;- scale(b)
</code></pre>

<hr>
<h2 id='scalebar'>scalebar</h2><span id='topic+scalebar'></span>

<h3>Description</h3>

<p>Add a scalebar to a plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalebar(d, xy = NULL, type = "line", divs = 2, below = "", 
       lonlat = NULL, label, adj=c(0.5, -0.5), lwd = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalebar_+3A_d">d</code></td>
<td>
<p>distance covered by scalebar</p>
</td></tr>
<tr><td><code id="scalebar_+3A_xy">xy</code></td>
<td>
<p>x and y coordinate to place the plot. Can be NULL. Use <code>xy=click()</code> to make this interactive </p>
</td></tr>
<tr><td><code id="scalebar_+3A_type">type</code></td>
<td>
<p>&quot;line&quot; or &quot;bar&quot;</p>
</td></tr>
<tr><td><code id="scalebar_+3A_divs">divs</code></td>
<td>
<p>Number of divisions for a bar type. 2 or 4</p>
</td></tr>
<tr><td><code id="scalebar_+3A_below">below</code></td>
<td>
<p>Text to go below scalebar (e.g., &quot;kilometers&quot;)</p>
</td></tr>
<tr><td><code id="scalebar_+3A_lonlat">lonlat</code></td>
<td>
<p>Logical or NULL. If logical, <code>TRUE</code> indicates if the plot is using longitude/latitude coordinates. If <code>NULL</code> this is guessed from the plot's coordinates</p>
</td></tr>
<tr><td><code id="scalebar_+3A_adj">adj</code></td>
<td>
<p>adjustment for text placement</p>
</td></tr>
<tr><td><code id="scalebar_+3A_label">label</code></td>
<td>
<p>Vector of three numbers to label the scale bar (beginning, midpoint, end)</p>
</td></tr>
<tr><td><code id="scalebar_+3A_lwd">lwd</code></td>
<td>
<p>line width for the &quot;line&quot; type scalebar</p>
</td></tr>
<tr><td><code id="scalebar_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods </p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Use for side effect of a scalebar added to a plot
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans; partly based on a function by Josh Gray  </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("external/test.grd", package="raster")
r &lt;- raster(f)
plot(r)
scalebar(1000)
scalebar(1000, xy=c(178000, 333500), type='bar', divs=4)
</code></pre>

<hr>
<h2 id='select'>
Geometric subsetting
</h2><span id='topic+select'></span><span id='topic+select+2CRaster-method'></span><span id='topic+select+2CSpatial-method'></span>

<h3>Description</h3>

<p>Geometrically subset Raster* or Spatial* objects by drawing on a plot (map).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
select(x, use='rec', ...)

## S4 method for signature 'Spatial'
select(x, use='rec', draw=TRUE, col='cyan', size=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_x">x</code></td>
<td>
<p>Raster*, SpatialPoints*, SpatialLines*, or SpatialPolygons*</p>
</td></tr>
<tr><td><code id="select_+3A_use">use</code></td>
<td>
<p>character: 'rec' or 'pol'. To use a rectangle or a polygon for selecting</p>
</td></tr>
<tr><td><code id="select_+3A_draw">draw</code></td>
<td>
<p>logical. Add the selected features to the plot?</p>
</td></tr>
<tr><td><code id="select_+3A_col">col</code></td>
<td>
<p>color to use to draw the selected features (when <code>draw=TRUE)</code></p>
</td></tr>
<tr><td><code id="select_+3A_size">size</code></td>
<td>
<p>integer &gt; 0. Size to draw the selected features with (when <code>draw=TRUE)</code>)</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster* or Spatial* object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+click">click</a>, <a href="#topic+crop">crop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# select a subset of a RasterLayer
r &lt;- raster(nrow=10, ncol=10)
values(r) &lt;- 1:ncell(r)
plot(r)
s &lt;- select(r) # now click on the map twice

# plot the selection on a new canvas:
x11()
plot(s)


# select a subset of a SpatialPolygons object
p1 &lt;- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60), c(-180,-20))
hole &lt;- rbind(c(-150,-20), c(-100,-10), c(-110,20), c(-150,-20))
p2 &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55), c(-10,0))
p3 &lt;- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45), c(-125,0))
pols &lt;- SpatialPolygons( list(  Polygons(list(Polygon(p1), Polygon(hole)), 1),
      Polygons(list(Polygon(p2)), 2), Polygons(list(Polygon(p3)), 3)))
pols@polygons[[1]]@Polygons[[2]]@hole &lt;- TRUE

plot(pols, col=rainbow(3))
ps &lt;- select(pols) # now click on the map twice
ps

## End(Not run)
</code></pre>

<hr>
<h2 id='setExtent'>Set the extent of a RasterLayer</h2><span id='topic+setExtent'></span><span id='topic+extent+3C-'></span>

<h3>Description</h3>

<p>setExtent sets the extent of a Raster* object. Either by providing a new Extent object or by setting the extreme
coordinates one by one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setExtent(x, ext, keepres=FALSE, snap=FALSE)
extent(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setExtent_+3A_x">x</code></td>
<td>
<p>A Raster* object</p>
</td></tr>
<tr><td><code id="setExtent_+3A_ext">ext</code></td>
<td>
<p> An object of class Extent (which you can create with <code><a href="#topic+extent">extent</a></code>, or an object that has an extent (e.g. a Raster* or Spatial* object) ) </p>
</td></tr>   
<tr><td><code id="setExtent_+3A_keepres">keepres</code></td>
<td>
<p>logical. If <code>TRUE</code>, the resolution of the cells will stay the same after adjusting the bounding box (by adjusting the number of rows and columns). 
If <code>FALSE</code>, the number of rows and columns will stay the same, and the resolution will be adjusted.
</p>
</td></tr>
<tr><td><code id="setExtent_+3A_snap">snap</code></td>
<td>
<p>logical. If <code>TRUE</code>, the extent is adjusted so that the cells of the input and output RasterLayer are aligned</p>
</td></tr>
<tr><td><code id="setExtent_+3A_value">value</code></td>
<td>
<p>An object of class Extent (which you can create with <code><a href="#topic+extent">extent</a></code> )</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>a Raster* object
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+extent">extent</a></code>, <code><a href="#topic+Extent-class">Extent-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
bb &lt;- extent(-10, 10, -20, 20)
extent(r) &lt;- bb
r &lt;- setExtent(r, bb, keepres=TRUE)

</code></pre>

<hr>
<h2 id='setMinMax'>Compute min and max values</h2><span id='topic+setMinMax+2CRasterLayer-method'></span><span id='topic+setMinMax+2CRasterStack-method'></span><span id='topic+setMinMax+2CRasterBrick-method'></span><span id='topic+setMinMax'></span>

<h3>Description</h3>

<p>The minimum and maximum value of a RasterLayer are computed (from a file on disk if necessary) and stored in the returned Raster* object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMinMax(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMinMax_+3A_x">x</code></td>
<td>
<p>Raster object </p>
</td></tr>
<tr><td><code id="setMinMax_+3A_...">...</code></td>
<td>
<p>additional arguments, none implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getValues">getValues</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(system.file("external/test.grd", package="raster"))
r
r &lt;- setMinMax(r)
r
</code></pre>

<hr>
<h2 id='setValues'>Set values of a Raster object</h2><span id='topic+values+3C-'></span><span id='topic+values+3C-+2CRasterLayer+2CANY-method'></span><span id='topic+values+3C-+2CRasterLayerSparse+2CANY-method'></span><span id='topic+values+3C-+2CRasterStack+2CANY-method'></span><span id='topic+values+3C-+2CRasterBrick+2CANY-method'></span><span id='topic+setValues'></span><span id='topic+setValues+2CRasterLayer-method'></span><span id='topic+setValues+2CRasterLayerSparse-method'></span><span id='topic+setValues+2CRasterStack-method'></span><span id='topic+setValues+2CRasterBrick-method'></span>

<h3>Description</h3>

<p>Assign (new) values to a Raster* object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
setValues(x, values, ...)

## S4 method for signature 'RasterBrick'
setValues(x, values, layer=-1, ...)

## S4 method for signature 'RasterStack'
setValues(x, values, layer=-1, ...)

## S4 method for signature 'RasterLayerSparse'
setValues(x, values, index=NULL, ...)

values(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setValues_+3A_x">x</code></td>
<td>
<p>A <code>Raster*</code> </p>
</td></tr>
<tr><td><code id="setValues_+3A_values">values</code></td>
<td>
<p>Cell values to associate with the Raster* object. There should be values for all cells</p>
</td></tr>
<tr><td><code id="setValues_+3A_value">value</code></td>
<td>
<p>Cell values to associate with the Raster* object. There should be values for all cells</p>
</td></tr>
<tr><td><code id="setValues_+3A_layer">layer</code></td>
<td>
<p>Layer number (only relevant for RasterBrick and RasterStack objects). If missing, the values of all layers is set</p>
</td></tr>  
<tr><td><code id="setValues_+3A_index">index</code></td>
<td>
<p>Cell numbers corresponding to the values</p>
</td></tr>
<tr><td><code id="setValues_+3A_...">...</code></td>
<td>
<p>Additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Raster* object
</p>


<h3>Note</h3>

<p>While you can access the 'values' slot of the objects directly, you would do that at your own peril because when setting values, multiple slots need to be changed; which is what setValues takes care of. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+replacement">replacement</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(ncol=10, nrow=10)
vals &lt;- 1:ncell(r)
r &lt;- setValues(r, vals)
# equivalent to
values(r) &lt;- vals
</code></pre>

<hr>
<h2 id='shapefile'>
Read or write a shapefile
</h2><span id='topic+shapefile'></span><span id='topic+shapefile+2Ccharacter-method'></span><span id='topic+shapefile+2CSpatial-method'></span>

<h3>Description</h3>

<p>Reading and writing of &quot;ESRI shapefile&quot; format spatial data. Only the three vector types (points, lines, and polygons) can be stored in shapefiles. 
</p>
<p>A shapefile should consist of at least four files: .shp (the geometry), .dbf (the attributes), .shx (the index that links the two, and .prj (the coordinate reference system). If the .prj file is missing, a warning is given. If any other file is missing an error occurs (although one could in principle recover the .shx from the .shp file). Additional files are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
shapefile(x, stringsAsFactors=FALSE, verbose=FALSE, warnPRJ=TRUE, ...)

## S4 method for signature 'Spatial'
shapefile(x, filename='', overwrite=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapefile_+3A_x">x</code></td>
<td>
<p>character (a file name, when reading a shapefile) or Spatial* object (when writing a shapefile)</p>
</td></tr>
<tr><td><code id="shapefile_+3A_filename">filename</code></td>
<td>
<p>character. Filename to write a shapefile</p>
</td></tr>
<tr><td><code id="shapefile_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. Overwrite existing shapefile?</p>
</td></tr>
<tr><td><code id="shapefile_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, information about the file is printed</p>
</td></tr>
<tr><td><code id="shapefile_+3A_warnprj">warnPRJ</code></td>
<td>
<p>logical. If <code>TRUE</code>, a warning is given if there is no .prj file</p>
</td></tr>
<tr><td><code id="shapefile_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical. If <code>TRUE</code>, strings are converted to factors</p>
</td></tr>
<tr><td><code id="shapefile_+3A_...">...</code></td>
<td>
<p>Additional arguments (none)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial*DataFrame (reading). Nothing is returned when writing a shapefile.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- system.file("external/lux.shp", package="raster")
filename
p &lt;- shapefile(filename)

## Not run: 
shapefile(p, 'copy.shp')

## End(Not run)
</code></pre>

<hr>
<h2 id='shift'>Shift</h2><span id='topic+shift'></span><span id='topic+shift+2CRaster-method'></span><span id='topic+shift+2CSpatialPolygons-method'></span><span id='topic+shift+2CSpatialLines-method'></span><span id='topic+shift+2CSpatialPoints-method'></span>

<h3>Description</h3>

<p>Shift the location of a Raster* of vector type Spatial* object in the x and/or y direction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
shift(x, dx=0, dy=0, filename='', ...)

## S4 method for signature 'SpatialPolygons'
shift(x, dx=0, dy=0,  ...)

## S4 method for signature 'SpatialLines'
shift(x, dx=0, dy=0,  ...)

## S4 method for signature 'SpatialPoints'
shift(x, dx=0, dy=0,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p>Raster* or Spatial* object</p>
</td></tr>
<tr><td><code id="shift_+3A_dx">dx</code></td>
<td>
<p>numeric. The shift in horizontal direction</p>
</td></tr>
<tr><td><code id="shift_+3A_dy">dy</code></td>
<td>
<p>numeric. The shift in vertical direction</p>
</td></tr>
<tr><td><code id="shift_+3A_filename">filename</code></td>
<td>
<p>character file name (optional)</p>
</td></tr>
<tr><td><code id="shift_+3A_...">...</code></td>
<td>
<p>if <code>x</code> is a Raster* object: additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code> </p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Same object type as <code>x</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+flip">flip</a></code>, <code><a href="#topic+rotate">rotate</a></code>, and the elide function in the maptools package </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster()
r &lt;- shift(r, dx=1, dy=-1)
</code></pre>

<hr>
<h2 id='Slope+20and+20aspect'>Slope and aspect</h2><span id='topic+slopeAspect'></span>

<h3>Description</h3>

<p>DEPRACATED. Use <code><a href="#topic+terrain">terrain</a></code> instead. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slopeAspect(dem, filename='', out=c('slope', 'aspect'), unit='radians', 
                 neighbors=8, flatAspect, ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slope+2B20and+2B20aspect_+3A_dem">dem</code></td>
<td>
<p>DEPRACATED</p>
</td></tr>
<tr><td><code id="Slope+2B20and+2B20aspect_+3A_filename">filename</code></td>
<td>
<p>DEPRACATED</p>
</td></tr>
<tr><td><code id="Slope+2B20and+2B20aspect_+3A_out">out</code></td>
<td>
<p>DEPRACATED</p>
</td></tr>
<tr><td><code id="Slope+2B20and+2B20aspect_+3A_unit">unit</code></td>
<td>
<p>DEPRACATED</p>
</td></tr>
<tr><td><code id="Slope+2B20and+2B20aspect_+3A_neighbors">neighbors</code></td>
<td>
<p>DEPRACATED</p>
</td></tr>
<tr><td><code id="Slope+2B20and+2B20aspect_+3A_flataspect">flatAspect</code></td>
<td>
<p>DEPRACATED</p>
</td></tr>
<tr><td><code id="Slope+2B20and+2B20aspect_+3A_...">...</code></td>
<td>
<p>DEPRACATED</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+terrain">terrain</a></code> </p>

<hr>
<h2 id='spEasy'>Create SpatialLines* or SpatialPolygons*</h2><span id='topic+spLines'></span><span id='topic+spPolygons'></span>

<h3>Description</h3>

<p>Helper functions to simplify the creation of SpatialLines* or SpatialPolygons* objects from coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spLines(x, ..., attr=NULL, crs="") 
spPolygons(x, ..., attr=NULL, crs="") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spEasy_+3A_x">x</code></td>
<td>
<p>matrix of list with matrices. Each matrix must have two columns with x and y coordinates (or longitude and latitude, in that order). Multi-line or multi-polygon objects can be formed by combining matrices in a list</p>
</td></tr>
<tr><td><code id="spEasy_+3A_...">...</code></td>
<td>
<p>additional matrices and/or lists with matrices</p>
</td></tr>  
<tr><td><code id="spEasy_+3A_attr">attr</code></td>
<td>
<p>data.frame with the attributes to create a *DataFrame object. The number of rows must match the number of lines/polgyons</p>
</td></tr>
<tr><td><code id="spEasy_+3A_crs">crs</code></td>
<td>
<p>the coordinate reference system (PROJ4 or WKT notation)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatialLines* or SpatialPolygons*
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60))
x2 &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
x3 &lt;- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45))
x4 &lt;- rbind(c(41,-41.5), c(51,-35), c(62,-41), c(51,-50))

a &lt;- spLines(x1, x2, x3)
b &lt;- spLines(x1, list(x2, x3), attr=data.frame(id=1:2), crs='+proj=longlat +datum=WGS84')
b

hole &lt;- rbind(c(-150,-20), c(-100,-10), c(-110,20), c(-130,10))
d &lt;- spPolygons(list(x1,hole), x2, list(x3, x4))

att &lt;- data.frame(ID=1:3, name=c('a', 'b', 'c'))
e &lt;- spPolygons(list(x1,hole), x2, list(x3, x4), attr=att, crs='+proj=longlat +datum=WGS84')
e
</code></pre>

<hr>
<h2 id='spplot'>Use spplot to plot a Raster* or other object</h2><span id='topic+spplot'></span><span id='topic+spplot+2CRaster-method'></span><span id='topic+spplot+2CSpatRaster-method'></span><span id='topic+spplot+2CSpatialPoints-method'></span><span id='topic+spplot+2CSpatialLines-method'></span><span id='topic+spplot+2CSpatialPolygons-method'></span><span id='topic+lines+2CSpatialPolygons-method'></span><span id='topic+spplot+2CSpatVector-method'></span>

<h3>Description</h3>

<p>A wrapper function around <a href="sp.html#topic+spplot">spplot</a> (sp package). With spplot it is easy to map several layers with a single legend for all maps. ssplot is itself a wrapper around the <a href="lattice.html#topic+levelplot">levelplot</a> function in the lattice package, and see the help for these functions for additional options.
</p>
<p>One of the advantages of the wrapper function for Raster* objects is the additional <code>maxpixels</code> argument to sample large objects for faster drawing.
</p>
<p>There are also added spplot methods for Spatial objects that have no data.frame and for SpatVector (terra package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
spplot(obj, ..., maxpixels=50000, as.table=TRUE, zlim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spplot_+3A_obj">obj</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="spplot_+3A_...">...</code></td>
<td>
<p>Any argument that can be passed to <code><a href="sp.html#topic+spplot">spplot</a></code> and <a href="lattice.html#topic+levelplot">levelplot</a></p>
</td></tr>
<tr><td><code id="spplot_+3A_maxpixels">maxpixels</code></td>
<td>
<p>integer. Number of pixels to sample from each layer of large Raster objects</p>
</td></tr>
<tr><td><code id="spplot_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the plots are ordered from top to bottom</p>
</td></tr> 
<tr><td><code id="spplot_+3A_zlim">zlim</code></td>
<td>
<p>Vector of two elements indicating the minimum and maximum values to be mapped (values outside that ranage are set to these limits)</p>
</td></tr> 
</table>


<h3>See Also</h3>

<p><code> <a href="#topic+plot">plot</a>, <a href="#topic+plotRGB">plotRGB</a> </code>
</p>
<p>The rasterVis package has more advanced plotting methods for Raster objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(system.file("external/test.grd", package="raster"))
s &lt;- stack(r, r*2)
names(s) &lt;- c('meuse', 'meuse x 2')

spplot(s)

pts &lt;- data.frame(sampleRandom(r, 10, xy=TRUE))
coordinates(pts) &lt;- ~ x + y

spplot(s, scales = list(draw = TRUE), 
		xlab = "easting", ylab = "northing", 
		col.regions = rainbow(99, start=.1), 
		names.attr=c('original', 'times two'),
		sp.layout = list("sp.points", pts, pch=20, cex=2, col='black'),
		par.settings = list(fontsize = list(text = 12)), at = seq(0, 4000, 500))

</code></pre>

<hr>
<h2 id='stack'>Create a RasterStack object</h2><span id='topic+stack'></span><span id='topic+stack+2Ccharacter-method'></span><span id='topic+stack+2CRaster-method'></span><span id='topic+stack+2Clist-method'></span><span id='topic+stack+2Cmissing-method'></span><span id='topic+stack+2CSpatialPixelsDataFrame-method'></span><span id='topic+stack+2CSpatialGridDataFrame-method'></span><span id='topic+stack+2Ckasc-method'></span><span id='topic+stack+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>A RasterStack is a collection of RasterLayer objects with the same spatial extent and resolution. A RasterStack can be created from RasterLayer objects, or from raster files, or both. It can also be created from a SpatialPixelsDataFrame or a SpatialGridDataFrame object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
stack(x, ..., bands=NULL, varname="", native=FALSE, RAT=TRUE, quick=FALSE)

## S4 method for signature 'Raster'
stack(x, ..., layers=NULL)

## S4 method for signature 'missing'
stack(x)

## S4 method for signature 'list'
stack(x, bands=NULL, native=FALSE, RAT=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_+3A_x">x</code></td>
<td>
<p>filename (character), Raster* object, missing (to create an empty RasterStack), SpatialGrid*, SpatialPixels*, or list (of filenames and/or Raster* objects). If <code>x</code> is a list, additional arguments <code>...</code> are ignored</p>
</td></tr>
<tr><td><code id="stack_+3A_bands">bands</code></td>
<td>
<p>integer. which bands (layers) of the file should be used (default is all layers)</p>
</td></tr>
<tr><td><code id="stack_+3A_layers">layers</code></td>
<td>
<p>integer (or character with layer names) indicating which layers of a RasterBrick should be used (default is all layers)</p>
</td></tr>
<tr><td><code id="stack_+3A_native">native</code></td>
<td>
<p>logical. If <code>TRUE</code> native drivers are used instead of gdal drivers (where available, such as for  BIL and Arc-ASCII files)</p>
</td></tr>
<tr><td><code id="stack_+3A_rat">RAT</code></td>
<td>
<p>logical. If <code>TRUE</code> a raster attribute table is created for files that have one</p>
</td></tr>
<tr><td><code id="stack_+3A_quick">quick</code></td>
<td>
<p>logical. If <code>TRUE</code> the extent and resolution of the objects are not compared. This speeds up the creation of the RasteStack but should be use with great caution. Only use this option when you are absolutely sure that all the data in all the files are aligned, and you need to create RasterStack for many (&gt;100) files</p>
</td></tr>
<tr><td><code id="stack_+3A_varname">varname</code></td>
<td>
<p>character. To select the variable of interest in a NetCDF file (see <code><a href="#topic+raster">raster</a></code>)</p>
</td></tr>
<tr><td><code id="stack_+3A_...">...</code></td>
<td>
<p>additional filenames or Raster* objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterStack
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+addLayer">addLayer</a>, <a href="#topic+addLayer">dropLayer</a>, <a href="#topic+raster">raster</a>, <a href="#topic+brick">brick</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># file with one layer
fn &lt;- system.file("external/test.grd", package="raster")
s &lt;- stack(fn, fn)
r &lt;- raster(fn)
s &lt;- stack(r, fn) 
nlayers(s)

# file with three layers
slogo &lt;- stack(system.file("external/rlogo.grd", package="raster")) 
nlayers(slogo)
slogo
</code></pre>

<hr>
<h2 id='stackApply'>Apply a function on subsets of a RasterStack or RasterBrick</h2><span id='topic+stackApply'></span>

<h3>Description</h3>

<p>Apply a function on subsets of a RasterStack or RasterBrick. The layers to be combined are indicated with the vector <code>indices</code>. 
The function used should return a single value, and the number of layers in the output Raster* equals the number of unique values in <code>indices</code>.
For example, if you have a RasterStack with 6 layers, you can use <code>indices=c(1,1,1,2,2,2)</code> and <code>fun=sum</code>. This will return a RasterBrick with two layers. The first layer is the sum of the first three layers in the input RasterStack, and the second layer is the sum of the last three layers in the input RasterStack. Indices are recycled such that <code>indices=c(1,2)</code> would also return a RasterBrick with two layers (one based on the odd layers (1,3,5), the other based on the even layers (2,4,6)). 
</p>
<p>See <code><a href="#topic+calc">calc</a></code> if you want to use a more efficient function that returns multiple layers based on _all_ layers in the Raster* object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackApply(x, indices, fun, filename='', na.rm=TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackApply_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="stackApply_+3A_indices">indices</code></td>
<td>
<p>integer. Vector of length <code>nlayers(x)</code> (shorter vectors are recycled) containing all integer values between 1 and the number of layers of the output Raster*</p>
</td></tr>
<tr><td><code id="stackApply_+3A_fun">fun</code></td>
<td>
<p>function that returns a single value, e.g. <code>mean</code> or <code>min</code>, and that takes a <code>na.rm</code> argument (or can pass through arguments via <code>...</code>)</p>
</td></tr>
<tr><td><code id="stackApply_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> cells are removed from calculations</p>
</td></tr>
<tr><td><code id="stackApply_+3A_filename">filename</code></td>
<td>
<p>character. Optional output filename</p>
</td></tr>
<tr><td><code id="stackApply_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A new Raster* object, and in some cases the side effect of a new file on disk.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc">calc</a>, <a href="#topic+stackSelect">stackSelect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10)
values(r) &lt;- 1:ncell(r)
s &lt;- brick(r,r,r,r,r,r)
s &lt;- s * 1:6
b1 &lt;- stackApply(s, indices=c(1,1,1,2,2,2), fun=sum)
b1
b2 &lt;- stackApply(s, indices=c(1,2,3,1,2,3), fun=sum)
b2
</code></pre>

<hr>
<h2 id='stackSave'>Save or open a RasterStack file</h2><span id='topic+stackSave'></span><span id='topic+stackOpen'></span>

<h3>Description</h3>

<p>A RasterStack is a collection of RasterLayers with the same spatial extent and resolution. They can be created from RasterLayer objects,
or from file names. These two functions allow you to save the references to raster files and recreate a rasterStack object later. They only work if the RasterStack points to layers that have their values on disk. The values are not saved, only the references to the files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackOpen(stackfile)
stackSave(x, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackSave_+3A_stackfile">stackfile</code></td>
<td>
<p> Filename for the RasterStack (to save it on disk) </p>
</td></tr>
<tr><td><code id="stackSave_+3A_x">x</code></td>
<td>
<p> RasterStack object </p>
</td></tr>
<tr><td><code id="stackSave_+3A_filename">filename</code></td>
<td>
<p>File name </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a RasterStack is saved to a file, only pointers (filenames) to raster datasets are saved, not the data. 
If the name or location of a raster file changes, the RasterStack becomes invalid.
</p>


<h3>Value</h3>

<p>RasterStack object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+writeRaster">writeRaster</a></code>, <code><a href="#topic+stack">stack</a></code>, <code><a href="#topic+addLayer">addLayer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("external/test.grd", package="raster")
s &lt;- stack(c(file, file))

## Not run: 
s &lt;- stackSave(s, "mystack")
# note that filename adds an extension .stk to a stackfile  
s2 &lt;- stackOpen("mystack.stk")
s2

## End(Not run)
</code></pre>

<hr>
<h2 id='stackSelect'>Select cell values from a multi-layer Raster* object</h2><span id='topic+stackSelect'></span><span id='topic+stackSelect+2CRasterStackBrick+2CRaster-method'></span>

<h3>Description</h3>

<p>Use a Raster* object to select cell values from different layers in a multi-layer Raster* object. The object to select values <code>y</code> should have values between <code>1</code> and <code>nlayers(x)</code>. The values of <code>y</code> are rounded. 
</p>
<p>See <code><a href="#topic+extract">extract</a></code> for extraction of values by cell, point, or otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterStackBrick,Raster'
stackSelect(x, y, recycle=FALSE, type='index', filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackSelect_+3A_x">x</code></td>
<td>
<p>RasterStack or RasterBrick object</p>
</td></tr>
<tr><td><code id="stackSelect_+3A_y">y</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="stackSelect_+3A_recycle">recycle</code></td>
<td>
<p>Logical. Recursively select values (default = <code>FALSE</code>. Only relevant if <code>y</code> has multiple layers. E.g. if <code>x</code> has 12 layers, and <code>y</code> has 4 layers, the indices of the <code>y</code> layers are used three times.</p>
</td></tr>
<tr><td><code id="stackSelect_+3A_type">type</code></td>
<td>
<p>Character. Only relevant when <code>recycle=TRUE</code>. Can be 'index' or 'truefalse'. If it is 'index', the cell values of <code>y</code> should represent layer numbers. If it is 'truefalse' layer numbers are indicated by 0 (not used, NA returned) and 1 (used)</p>
</td></tr>
<tr><td><code id="stackSelect_+3A_filename">filename</code></td>
<td>
<p>Character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="stackSelect_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stackApply">stackApply</a></code>, <code><a href="#topic+extract">extract</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10, vals=1)
s &lt;- stack(r, r+2, r+5)
values(r) &lt;- round((runif(ncell(r)))*3)
x &lt;- stackSelect(s, r)
</code></pre>

<hr>
<h2 id='stretch'>Stretch</h2><span id='topic+stretch'></span><span id='topic+stretch+2CRaster-method'></span>

<h3>Description</h3>

<p>Linear stretch of values in a Raster object. Provide the desired output range (minv and maxv) and the lower and upper bounds in the original data, either as quantiles (if <code>minq=0</code> and <code>maxq=1</code> you use the minimum and maximum cell values), or as actual values (<code>smin</code> and <code>smax</code>; e.g. precomputed quantile values). If <code>smin</code> and <code>smax</code> are both not <code>NA</code>, <code>minq</code> and <code>maxq</code> are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
stretch(x, minv=0, maxv=255, minq=0, maxq=1, smin=NA, smax=NA,
          samplesize=1000000, filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stretch_+3A_x">x</code></td>
<td>
<p>Raster object</p>
</td></tr> 
<tr><td><code id="stretch_+3A_minv">minv</code></td>
<td>
<p>numeric &gt;= 0 and smaller than maxv. lower bound of stretched value</p>
</td></tr>
<tr><td><code id="stretch_+3A_maxv">maxv</code></td>
<td>
<p>numeric &lt;= 255 and larger than maxv. upper bound of stretched value</p>
</td></tr>
<tr><td><code id="stretch_+3A_minq">minq</code></td>
<td>
<p>numeric &gt;= 0 and smaller than maxq. lower quantile bound of original value. Ignored if smin is supplied</p>
</td></tr>
<tr><td><code id="stretch_+3A_maxq">maxq</code></td>
<td>
<p>numeric &lt;= 1 and larger than minq. upper quantile bound of original value. Ignored if smax is supplied</p>
</td></tr>
<tr><td><code id="stretch_+3A_smin">smin</code></td>
<td>
<p>numeric &lt; smax. user supplied lower value for the layers, to be used instead of a quantile computed by the function itself</p>
</td></tr>
<tr><td><code id="stretch_+3A_smax">smax</code></td>
<td>
<p>numeric &gt; smin. user supplied upper value for the layers, to be used instead of a quantile computed by the function itself</p>
</td></tr>
<tr><td><code id="stretch_+3A_samplesize">samplesize</code></td>
<td>
<p>numeric &gt; 1. If samplesize &lt; ncell(x), a regular sample of samplesize is taken from x to compute the quantiles (to speed things up)</p>
</td></tr>
<tr><td><code id="stretch_+3A_filename">filename</code></td>
<td>
<p>character. Filename for the output Raster object (optional)</p>
</td></tr>
<tr><td><code id="stretch_+3A_...">...</code></td>
<td>
<p> additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster
</p>


<h3>See Also</h3>

<p>stretch argument in <code><a href="#topic+plotRGB">plotRGB</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nc=10, nr=10)
values(r) &lt;- rep(1:2, 50)
stretch(r)
s &lt;- stack(r, r*2)
stretch(s)
</code></pre>

<hr>
<h2 id='subset'>Subset layers in a Raster* object</h2><span id='topic+subset'></span><span id='topic+subset+2CRaster-method'></span><span id='topic+subset+2CRasterStack-method'></span>

<h3>Description</h3>

<p>Extract a set of layers from a RasterStack or RasterBrick object.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
subset(x, subset, drop=TRUE, filename='', ...)

## S4 method for signature 'RasterStack'
subset(x, subset, drop=TRUE, filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>RasterBrick or RasterStack object</p>
</td></tr>
<tr><td><code id="subset_+3A_subset">subset</code></td>
<td>
<p>integer or character. Should indicate the layers (represented as integer or by their name)</p>
</td></tr>
<tr><td><code id="subset_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, a selection of a single layer will be returned as a RasterLayer</p>
</td></tr>
<tr><td><code id="subset_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="subset_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+addLayer">dropLayer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- stack(system.file("external/rlogo.grd", package="raster"))
sel &lt;- subset(s, 2:3)

# Note that this is equivalent to
sel2 &lt;- s[[2:3]]


# and in this particular case:
sel3 &lt;- dropLayer(s, 1)

nlayers(s)
nlayers(sel)

# effect of 'drop=FALSE' when selecting a single layer
sel &lt;- subset(s, 2)
class(sel)
sel &lt;- subset(s, 2, drop=FALSE)
class(sel)
</code></pre>

<hr>
<h2 id='substitute'> Substitute values in a Raster* object</h2><span id='topic+subs'></span><span id='topic+subs+2CRaster+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Substitute (replace) values in a Raster* object with values in a <code>data.frame</code>. The <code>data.frame</code> should have a column to identify the key (ID) to match with the cell values of the Raster* object, and one or more columns with replacement values. By default these are the first and second column but you can specify other columns with arguments <code>by</code> and <code>which</code>. It is possible to match one table to multiple layers, or to use multiple layers as a single key, but not both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,data.frame'
subs(x, y, by=1, which=2, subsWithNA=TRUE, filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substitute_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="substitute_+3A_y">y</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="substitute_+3A_by">by</code></td>
<td>
<p>column number(s) or name(s) identifying the key (ID) to match rows in data.frame <code>y</code> to values of the Raster object</p>
</td></tr>
<tr><td><code id="substitute_+3A_which">which</code></td>
<td>
<p>column number or name that has the new (replacement) values</p>
</td></tr>
<tr><td><code id="substitute_+3A_subswithna">subsWithNA</code></td>
<td>
<p>logical. If <code>TRUE</code> values that are not matched become NA. If <code>FALSE</code>, they retain their original value (which could also be <code>NA</code>). This latter option is handy when you want to replace only one or a few values. It cannot be used when <code>x</code> has multiple layers</p>
</td></tr>
<tr><td><code id="substitute_+3A_filename">filename</code></td>
<td>
<p>character. Optional output filename</p>
</td></tr>
<tr><td><code id="substitute_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Details</h3>

<p>You could obtain the same result with <code><a href="#topic+reclassify">reclassify</a></code>, but <code>subs</code> is more efficient for simple replacement. Use <code>reclassify</code> if you want to replace ranges of values with new values. 
</p>
<p>You can also replace values using a fitted model. E.g. fit a model to <code>glm</code> or <code>loess</code> and then call <a href="#topic+predict">predict</a>
</p>


<h3>Value</h3>

<p>Raster object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+reclassify">reclassify</a>, <a href="#topic+clamp">clamp</a>, <a href="#topic+cut">cut</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10)
values(r) &lt;- round(runif(ncell(r)) * 10)
df &lt;- data.frame(id=2:8, v=c(10,10,11,11,12:14))
x &lt;- subs(r, df)
x2 &lt;- subs(r, df, subsWithNA=FALSE)

df$v2 &lt;- df$v * 10
x3 &lt;- subs(r, df, which=2:3)

s &lt;- stack(r, r*3)
names(s) &lt;- c('first', 'second')
x4 &lt;- subs(s, df)
x5 &lt;- subs(s, df, which=2:3)
</code></pre>

<hr>
<h2 id='Summary'>Summary</h2><span id='topic+summary+2CRasterLayer-method'></span><span id='topic+summary+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Summarize a Raster* object. A sample is used for very large files. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
summary(object, maxsamp=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summary_+3A_object">object</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="Summary_+3A_maxsamp">maxsamp</code></td>
<td>
<p>positive integer. Sample size used for large datasets</p>
</td></tr>
<tr><td><code id="Summary_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with (an estimate of) the median, minimum and maximum values, the first and third quartiles, and the number of cells with <code>NA</code> values</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cellStats">cellStats</a>, link[raster]{quantile}</code>  </p>

<hr>
<h2 id='Summary-methods'> Summary methods </h2><span id='topic+Summary-methods'></span><span id='topic+mean+2CRaster-method'></span><span id='topic+median+2CRaster-method'></span><span id='topic+Summary+2CRaster-method'></span>

<h3>Description</h3>

<p>The following summary methods are available for Raster* objects:
</p>
<p><code>mean, median, max, min, range, prod, sum, any, all</code>
</p>
<p>All methods take <code>na.rm</code> as an additional logical argument. Default is <code>na.rm=FALSE</code>. If <code>TRUE</code>, <code>NA</code> values are removed from calculations. 
These methods compute a summary statistic based on cell values of RasterLayers and the result of these methods is always a single RasterLayer (except for range, which returns a RasterBrick with two layers).  See <code><a href="#topic+calc">calc</a></code> for functions not included here (e.g. median) or any other custom functions.
</p>
<p>You can mix RasterLayer, RasterStack and RasterBrick objects with single numeric or logical values. However, because generic functions are used, the method applied is chosen based on the first argument: '<code>x</code>'. This means that if <code>r</code> is a RasterLayer object, <code>mean(r, 5)</code> will work, but <code>mean(5, r)</code> will not work.
</p>
<p>To summarize all cells within a single RasterLayer, see <code><a href="#topic+cellStats">cellStats</a></code> and <code><a href="#topic+extremeValues">maxValue</a></code> and <code><a href="#topic+extremeValues">minValue</a></code>
</p>


<h3>Value</h3>

<p>a RasterLayer</p>


<h3>See Also</h3>

 <p><code><a href="#topic+calc">calc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- raster(nrow=10, ncol=10)
r1 &lt;- setValues(r1, runif(ncell(r1)))
r2 &lt;- setValues(r1, runif(ncell(r1)))
r3 &lt;- setValues(r1, runif(ncell(r1)))
r &lt;- max(r1, r2, r3)
r &lt;- range(r1, r2, r3, 1.2)

s &lt;- stack(r1, r2, r3)
r &lt;- mean(s, 2)
</code></pre>

<hr>
<h2 id='symdif'> 
Symetrical difference
</h2><span id='topic+symdif'></span><span id='topic+symdif+2CSpatialPolygons+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Symetrical difference of SpatialPolygons* objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatialPolygons,SpatialPolygons'
symdif(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symdif_+3A_x">x</code></td>
<td>
<p>SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="symdif_+3A_y">y</code></td>
<td>
<p>SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="symdif_+3A_...">...</code></td>
<td>
<p>Additional SpatialPolygons* object(s)</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatialPolygons*
</p>


<h3>See Also</h3>

<p><code><a href="#topic+erase">erase</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#SpatialPolygons
p &lt;- shapefile(system.file("external/lux.shp", package="raster"))
b &lt;- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
crs(b) &lt;- crs(p)
sd &lt;- symdif(p, b)
plot(sd, col='red')

</code></pre>

<hr>
<h2 id='terrain'>Terrain characteristics</h2><span id='topic+terrain'></span><span id='topic+terrain+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Compute slope, aspect and other terrain characteristics from a raster with elevation data. The elevation data should be in map units (typically meter) for projected (planar) raster data. They should be in meters when the coordinate reference system (CRS) is longitude/latitude. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
terrain(x, opt="slope", unit="radians", neighbors=8, filename="", ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terrain_+3A_x">x</code></td>
<td>
<p>RasterLayer object with elevation values. Values should have the same unit as the map units, or in meters when the crs is longitude/latitude</p>
</td></tr>
<tr><td><code id="terrain_+3A_opt">opt</code></td>
<td>
<p>Character vector containing one or more of these options: slope, aspect, TPI, TRI, roughness, flowdir (see Details)</p>
</td></tr>
<tr><td><code id="terrain_+3A_unit">unit</code></td>
<td>
<p>Character. 'degrees', 'radians' or 'tangent'. Only relevant for slope and aspect. If 'tangent' is selected that is used for slope, but for aspect 'degrees' is used (as 'tangent' has no meaning for aspect) </p>
</td></tr>
<tr><td><code id="terrain_+3A_neighbors">neighbors</code></td>
<td>
<p>Integer. Indicating how many neighboring cells to use to compute slope for any cell. Either 8 (queen case) or 4 (rook case). Only used for slope and aspect, see Details</p>
</td></tr>
<tr><td><code id="terrain_+3A_filename">filename</code></td>
<td>
<p>Character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="terrain_+3A_...">...</code></td>
<td>
<p>Standard additional arguments for writing Raster* objects to file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>neighbors=4</code>, slope and aspect are computed according to Fleming and Hoffer (1979) and Ritter (1987). When <code>neigbors=8</code>, slope and aspect are computed according to Horn (1981). The Horn algorithm may be best for rough surfaces, and the Fleming and Hoffer algorithm may be better for smoother surfaces (Jones, 1997; Burrough and McDonnell, 1998).
If slope = 0, aspect is set to 0.5*pi radians (or 90 degrees if unit='degrees'). When computing slope or aspect, the CRS (<code><a href="#topic+projection">projection</a></code>) of the RasterLayer <code>x</code> must be known (may not be <code>NA</code>), to be able to safely differentiate between planar and longitude/latitude data.
</p>
<p>flowdir returns the 'flow direction' (of water), i.e. the direction of the greatest drop in elevation (or the smallest rise if all neighbors are higher). They are encoded as powers of 2 (0 to 7). The cell to the right of the focal cell 'x' is 1, the one below that is 2, and so on:
</p>

<table>
<tr>
 <td style="text-align: right;">
32 </td><td style="text-align: right;">64 </td><td style="text-align: right;"> 128</td>
</tr>
<tr>
 <td style="text-align: right;"> 
16 </td><td style="text-align: right;"> x </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 8 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 2 </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>

<p>If two cells have the same drop in elevation, a random cell is picked. That is not ideal as it may prevent the creation of connected flow networks. ArcGIS implements the approach of Greenlee (1987) and I might adopt that in the future.
</p>
<p>The terrain indices are according to Wilson et al. (2007). TRI (Terrain Ruggedness Index) is the mean of the absolute differences between the value of a cell and the value of its 8 surrounding cells. TPI (Topographic Position Index) is the difference between the value of a cell and the mean value of its 8 surrounding cells. Roughness is the difference between the maximum and the minimum value of a cell and its 8 surrounding cells.
</p>
<p>Such measures can also be computed with the <code><a href="#topic+focal">focal</a></code> function:
</p>
<p>f &lt;- matrix(1, nrow=3, ncol=3)
</p>
<p>TRI &lt;- focal(x, w=f, fun=function(x, ...) sum(abs(x[-5]-x[5]))/8, pad=TRUE, padValue=NA)
</p>
<p>TPI &lt;- focal(x, w=f, fun=function(x, ...) x[5] - mean(x[-5]), pad=TRUE, padValue=NA)
</p>
<p>rough &lt;- focal(x, w=f, fun=function(x, ...) max(x) - min(x), pad=TRUE, padValue=NA, na.rm=TRUE)
</p>


<h3>References</h3>

<p>Burrough, P., and R.A. McDonnell, 1998. Principles of Geographical Information Systems. Oxford University Press.
</p>
<p>Fleming, M.D. and Hoffer, R.M., 1979. Machine processing of landsat MSS data and DMA topographic data for forest cover type mapping. LARS Technical Report 062879. Laboratory for Applications of Remote Sensing, Purdue University, West Lafayette, Indiana.
</p>
<p>Greenlee, D.D., 1987. Raster and vector processing for scanned linework. Photogrammetric Engineering and Remote Sensing 53:1383-1387
</p>
<p>Horn, B.K.P., 1981. Hill shading and the reflectance map. Proceedings of the IEEE 69:14-47
</p>
<p>Jones, K.H., 1998. A comparison of algorithms used to compute hill slope as a property of the DEM. Computers &amp; Geosciences 24: 315-323 
</p>
<p>Ritter, P., 1987. A vector-based slope and aspect generation algorithm. Photogrammetric Engineering and Remote Sensing 53: 1109-1111
</p>
<p>Wilson, M.F.J., O'Connell, B., Brown, C., Guinan, J.C., Grehan, A.J., 2007. Multiscale terrain analysis of multibeam bathymetry data for habitat mapping on the continental slope. Marine Geodesy 30: 3-35.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+hillShade">hillShade</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
elevation &lt;- getData('alt', country='CHE')
x &lt;- terrain(elevation, opt=c('slope', 'aspect'), unit='degrees')
plot(x)


# TPI for different neighborhood size:
tpiw &lt;- function(x, w=5) {
	m &lt;- matrix(1/(w^2-1), nc=w, nr=w)
	m[ceiling(0.5 * length(m))] &lt;- 0
	f &lt;- focal(x, m)
	x - f
}
tpi5 &lt;- tpiw(elevation, w=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='text'>Add labels to a map</h2><span id='topic+text'></span><span id='topic+text+2CRasterLayer-method'></span><span id='topic+text+2CRasterStackBrick-method'></span><span id='topic+text+2CSpatialPoints-method'></span><span id='topic+text+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Plots labels, that is a textual (rather than color) representation of values, on top an existing plot (map). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
text(x, labels, digits=0, fun=NULL, halo=FALSE, ...)

## S4 method for signature 'RasterStackBrick'
text(x, labels, digits=0, fun=NULL, halo=FALSE, ...)

## S4 method for signature 'SpatialPolygons'
text(x, labels, halo=FALSE, ...)

## S4 method for signature 'SpatialPoints'
text(x, labels, halo=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_+3A_x">x</code></td>
<td>
<p>Raster*, SpatialPoints* or SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="text_+3A_labels">labels</code></td>
<td>
<p>character. Optional. Vector of labels with <code>length(x)</code> or a variable name from <code>names(x)</code></p>
</td></tr>
<tr><td><code id="text_+3A_digits">digits</code></td>
<td>
<p>integer. how many digits should be used?</p>
</td></tr>
<tr><td><code id="text_+3A_fun">fun</code></td>
<td>
<p>function to subset the values plotted (as in <code><a href="#topic+rasterToPoints">rasterToPoints</a></code>)</p>
</td></tr>
<tr><td><code id="text_+3A_halo">halo</code></td>
<td>
<p>logical. If <code>TRUE</code> a 'halo' is printed around the text. If <code>TRUE</code>, additional arguments <code>hc='white'</code> and <code>hw=0.1</code> can be modified to set the colour and width of the halo</p>
</td></tr>
<tr><td><code id="text_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to graphics function <code><a href="graphics.html#topic+text">text</a></code> </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+text">text</a>, <a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- raster(nrows=4, ncols=4)
r &lt;- setValues(r, 1:ncell(r))
plot(r)
text(r)

plot(r)
text(r, halo=TRUE, hc='blue', col='white', hw=0.2)

plot(r, col=bpy.colors(5))
text(r, fun=function(x){x&lt;5 | x&gt;12}, col=c('red', 'white'), vfont=c("sans serif", "bold"), cex=2)
</code></pre>

<hr>
<h2 id='transpose'>Transpose</h2><span id='topic+t'></span><span id='topic+t+2CRasterLayer-method'></span><span id='topic+t+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Transpose a Raster* object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpose_+3A_x">x</code></td>
<td>
<p>a Raster* object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick
</p>


<h3>See Also</h3>

<p> transpose: <code><a href="#topic+flip">flip</a>, <a href="#topic+rotate">rotate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(nrow=18, ncol=36)
values(r) &lt;- 1:ncell(r)
rt &lt;- t(r)
</code></pre>

<hr>
<h2 id='trim'>Trim</h2><span id='topic+trim'></span><span id='topic+trim+2CRaster-method'></span><span id='topic+trim+2Ccharacter-method'></span><span id='topic+trim+2Cmatrix-method'></span><span id='topic+trim+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Trim (shrink) a Raster* object by removing outer rows and columns that all have the same value (e.g. NA).
</p>
<p>Or remove the whitespace before or after a string of characters (or a matrix, or the character values in a data.frame).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster'
trim(x, padding=0, values=NA, filename='', ...)
## S4 method for signature 'character'
trim(x, internal=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_x">x</code></td>
<td>
<p>Raster* object or a character string</p>
</td></tr>
<tr><td><code id="trim_+3A_values">values</code></td>
<td>
<p>numeric. Value(s) based on which a Raster* should be trimmed</p>
</td></tr>
<tr><td><code id="trim_+3A_padding">padding</code></td>
<td>
<p>integer. Number of outer rows/columns to keep</p>
</td></tr>
<tr><td><code id="trim_+3A_filename">filename</code></td>
<td>
<p>character. Optional output filename</p>
</td></tr>
<tr><td><code id="trim_+3A_internal">internal</code></td>
<td>
<p>logical. If <code>TRUE</code>, sequential internal spaces are replaced by a single space</p>
</td></tr>
<tr><td><code id="trim_+3A_...">...</code></td>
<td>
<p>If <code>x</code> is a Raster* object: additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A RasterLayer or RasterBrick object (if <code>x</code> is a Raster* object) or a character string (if <code>x</code> is a character string).
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Jacob van Etten</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=18,nrow=18)
r[39:49] &lt;- 1
r[113:155] &lt;- 2
r[200] &lt;- 6
s &lt;- trim(r) 


trim("    hi folks    !   ")
</code></pre>

<hr>
<h2 id='union'> 
Union Extent or SpatialPolygons* objects
</h2><span id='topic+union'></span><span id='topic+union+2CExtent+2CExtent-method'></span><span id='topic+union+2CSpatialPolygons+2CSpatialPolygons-method'></span><span id='topic+union+2CSpatialPolygons+2Cmissing-method'></span><span id='topic+union+2CSpatialPoints+2CSpatialPoints-method'></span><span id='topic+union+2CSpatialLines+2CSpatialLines-method'></span>

<h3>Description</h3>

<p>Extent objects: Objects are combined into their union. See <code><a href="#topic+crop">crop</a></code> and <code><a href="#topic+extend">extend</a></code> to union a Raster object with an Extent object.
</p>
<p>Two SpatialPolygons* objects. Overlapping polygons (between layers, not within layers) are intersected, other spatial objects are appended. Tabular attributes are joined. See <code><a href="#topic+bind">bind</a></code> if you want to combine polygons without intersection.
</p>
<p>Single SpatialPolygons* object. Overlapping polygons are intersected. Original attributes are lost. New attributes allow for determining how many, and which, polygons overlapped. 
</p>
<p>Union for SpatialLines and SpatialPoints simply combines the two data sets; without any geometric intersections. This is equivalent to <code><a href="#topic+bind">bind</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Extent,Extent'
union(x, y)

## S4 method for signature 'SpatialPolygons,SpatialPolygons'
union(x, y)

## S4 method for signature 'SpatialPolygons,missing'
union(x, y)

## S4 method for signature 'SpatialLines,SpatialLines'
union(x, y)

## S4 method for signature 'SpatialPoints,SpatialPoints'
union(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="union_+3A_x">x</code></td>
<td>
<p>Extent or SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="union_+3A_y">y</code></td>
<td>
<p>Same as <code>x</code> or missing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extent or SpatialPolygons object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect">intersect</a>, <a href="#topic+extent">extent</a>, <a href="#topic+setExtent">setExtent</a></code>
</p>
<p><code><a href="sp.html#topic+merge">merge</a></code> for merging a data.frame with attributes of Spatial objects 
and <code><a href="#topic++2B+2CSpatialPolygons+2CSpatialPolygons-method">+,SpatialPolygons,SpatialPolygons-method</a></code> for an algebraic notation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- extent(-10, 10, -20, 20)
e2 &lt;- extent(0, 20, -40, 5)
union(e1, e2)

#SpatialPolygons
p &lt;- shapefile(system.file("external/lux.shp", package="raster"))
p0 &lt;- aggregate(p)
b &lt;- as(extent(6, 6.4, 49.75, 50), 'SpatialPolygons')
crs(b) &lt;- crs(p)
u &lt;- union(p0, b)
plot(u, col=2:4)

</code></pre>

<hr>
<h2 id='unique'>Unique values</h2><span id='topic+unique'></span><span id='topic+unique+2CRasterLayer+2Cmissing-method'></span><span id='topic+unique+2CRasterStackBrick+2Cmissing-method'></span>

<h3>Description</h3>

<p>This function returns the unique values in a RasterLayer object or the unique combinations of the layers in a multilayer object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,missing'
unique(x, incomparables=FALSE, na.last=NA, progress="", ...) 

## S4 method for signature 'RasterStackBrick,missing'
unique(x, incomparables=FALSE, na.last=NA, progress="", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_+3A_x">x</code></td>
<td>
<p>Raster object</p>
</td></tr>
<tr><td><code id="unique_+3A_incomparables">incomparables</code></td>
<td>
<p>must be missing. The default value <code>FALSE</code> is used. See <code><a href="base.html#topic+unique">unique</a></code></p>
</td></tr>
<tr><td><code id="unique_+3A_na.last">na.last</code></td>
<td>
<p>logical. for controlling the treatment of <code>NA</code>s. If <code>TRUE</code>, missing values in the data are put last; if <code>FALSE</code>, they are put first; if <code>NA</code>, they are removed.</p>
</td></tr>
<tr><td><code id="unique_+3A_progress">progress</code></td>
<td>
<p>character. Use &quot;text&quot; or &quot;window&quot; for a progress indicator</p>
</td></tr>
<tr><td><code id="unique_+3A_...">...</code></td>
<td>
<p>additional arguments. as in <code><a href="base.html#topic+unique">unique</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>vector or matrix
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+unique">unique</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10)
values(r) &lt;- round(runif(ncell(r))*10)
unique(r)
unique(stack(r, round(r/2)))
</code></pre>

<hr>
<h2 id='unstack'> Unstack </h2><span id='topic+unstack'></span><span id='topic+unstack+2CRasterStack-method'></span><span id='topic+unstack+2CRasterBrick-method'></span>

<h3>Description</h3>

<p>Create a list of RasterLayer objects from a RasterStack or RasterBrick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unstack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstack_+3A_x">x</code></td>
<td>
<p> a RasterStack object </p>
</td></tr>
<tr><td><code id="unstack_+3A_...">...</code></td>
<td>
<p>not used. further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of RasterLayer objects
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+stack">stack</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  file &lt;- system.file("external/test.grd", package="raster")
  s &lt;- stack(file, file)
  list1 &lt;- unstack(s)
  b &lt;- brick(s)
  list2 &lt;- unstack(b)
</code></pre>

<hr>
<h2 id='update'>Update raster cells of files (on disk)</h2><span id='topic+update'></span><span id='topic+update+2CRasterLayer-method'></span><span id='topic+update+2CRasterBrick-method'></span>

<h3>Description</h3>

<p>Update cell values of a file (i.e., cell values on disk) associated with a RasterLayer or RasterBrick. 
</p>
<p>User beware: this function _will_ make changes to your file (first make a copy if you are not sure what you are doing).
</p>
<p>Writing starts at a cell number <code>cell</code>. You can write a vector of values (in cell order), or a matrix. You can also provide a vector of cell numbers (of the same length as vector <code>v</code>) to update individual cells.
</p>
<p>See <code><a href="#topic+writeFormats">writeFormats</a></code> for supported formats. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
update(object, v, cell, ...)
## S4 method for signature 'RasterBrick'
update(object, v, cell, band, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>RasterLayer or RasterBrick that is associated with a file</p>
</td></tr>
<tr><td><code id="update_+3A_v">v</code></td>
<td>
<p>vector or matrix with new values</p>
</td></tr> 
<tr><td><code id="update_+3A_cell">cell</code></td>
<td>
<p>cell from where to start writing. Or a vector of cell numbers if v is a vector of the same length</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="update_+3A_band">band</code></td>
<td>
<p>band (layer) to update (for RasterBrick objects)</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# setting up an example RasterLayer with file
r &lt;- raster(nrow=5, ncol=10, vals=0)
r &lt;- writeRaster(r, rasterTmpFile(), overwrite=TRUE, datatype='INT2S')
as.matrix(r)

# update with a vector starting a cell
r &lt;- update(r, v=rep(1, 5), cell=6)
# 99.99 gets rounded because this is an integer file
r &lt;- update(r, v=9.99, cell=50)
as.matrix(r)

# update with a vector of values and matching vector of cell numbers
r &lt;- update(r, v=5:1, cell=c(5,15,25,35,45))
as.matrix(r)

# updating with a marix, anchored at a cell number
m &lt;- matrix(1:10, ncol=2)
r &lt;- update(r, v=m, cell=2)
as.matrix(r)

## End(Not run)
</code></pre>

<hr>
<h2 id='validCell'>Validity of a cell, column or row number</h2><span id='topic+validCell'></span><span id='topic+validCol'></span><span id='topic+validRow'></span>

<h3>Description</h3>

<p>Simple helper functions to determine if a row, column or cell number is valid for a certain Raster* object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validCell(object, cell) 
validCol(object, colnr) 
validRow(object, rownr) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validCell_+3A_object">object</code></td>
<td>
<p>Raster* object (or a SpatialPixels* or SpatialGrid* object)</p>
</td></tr>
<tr><td><code id="validCell_+3A_cell">cell</code></td>
<td>
<p>cell number(s)</p>
</td></tr>
<tr><td><code id="validCell_+3A_colnr">colnr</code></td>
<td>
<p>column number; or vector of column numbers</p>
</td></tr>
<tr><td><code id="validCell_+3A_rownr">rownr</code></td>
<td>
<p>row number; or vector of row numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#using a new default raster (1 degree global)
r &lt;- raster()
validCell(r, c(-1, 0, 1))
validRow(r, c(-1, 1, 100, 10000))
</code></pre>

<hr>
<h2 id='validNames'>Create valid names</h2><span id='topic+validNames'></span>

<h3>Description</h3>

<p>Create a set of valid names (trimmed, no duplicates, not starting with a number). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validNames(x, prefix='layer')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validNames_+3A_x">x</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="validNames_+3A_prefix">prefix</code></td>
<td>
<p>character string used if x is empty</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>character 
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+make.names">make.names</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>validNames(c('a', 'a', '', '1', NA, 'b', 'a'))
</code></pre>

<hr>
<h2 id='weighted.mean'>Weighted mean of rasters</h2><span id='topic+weighted.mean'></span><span id='topic+weighted.mean+2CRasterStackBrick+2Cvector-method'></span><span id='topic+weighted.mean+2CRasterStackBrick+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Computes the weighted mean for each cell of a number or raster layers. The weights can be spatially variable or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterStackBrick,vector'
weighted.mean(x, w, na.rm=FALSE, filename='', ...)

## S4 method for signature 'RasterStackBrick,RasterStackBrick'
weighted.mean(x, w, na.rm=FALSE,filename='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.mean_+3A_x">x</code></td>
<td>
<p>RasterStack or RasterBrick</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_w">w</code></td>
<td>
<p>A vector of weights (one number for each layer), or for spatially variable weights, a RasterStack or RasterBrick with weights (should have the same extent, resolution and number of layers as x)</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_filename">filename</code></td>
<td>
<p>Character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Summary-methods">Summary-methods</a></code>, <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brick(system.file("external/rlogo.grd", package="raster"))

# give least weight to first layer, most to last layer
wm1 &lt;- weighted.mean(b, w=1:3)

# spatially varying weights
# weigh by column number
w1 &lt;- init(b, v='col')

# weigh by row number
w2 &lt;- init(b, v='row')
w &lt;- stack(w1, w2, w2)

wm2 &lt;- weighted.mean(b, w=w)
</code></pre>

<hr>
<h2 id='which'>Which cells are TRUE?</h2><span id='topic+Which'></span><span id='topic+Which+2CRasterLayer-method'></span>

<h3>Description</h3>

<p><code>Which</code> returns a RasterLayer with <code>TRUE</code> or <code>FALSE</code> setting cells that are <code>NA</code> to <code>FALSE</code> (unless <code>na.rm=FALSE</code>). If the RasterLayer has numbers, all values that are 0 become <code>FALSE</code> and all other values become <code>TRUE</code>. The function can also return the cell numbers that are <code>TRUE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer'
Which(x, cells=FALSE, na.rm=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_+3A_x">x</code></td>
<td>
<p>RasterLayer</p>
</td></tr>
<tr><td><code id="which_+3A_cells">cells</code></td>
<td>
<p>logical. If <code>TRUE</code>, cell numbers are returned, otherwise a RasterLayer is returned</p>
</td></tr>
<tr><td><code id="which_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> values are treated as <code>FALSE</code>, otherwise they remain <code>NA</code> (only when <code>cells=FALSE</code>)</p>
</td></tr>
<tr><td><code id="which_+3A_...">...</code></td>
<td>
<p>Additional arguments (none implemented)</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+which.max">which.max</a></code>,  <code><a href="#topic+which.min">which.min</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10)
set.seed(0)
values(r) &lt;- runif(ncell(r))
r[r &lt; 0.2 ] &lt;- 0
r[r &gt; 0.8] &lt;- 1
r[r &gt; 0 &amp; r &lt; 1 ] &lt;- 0.5

Which(r, cells=TRUE)
Which(r &gt; 0.5, cells=TRUE)

s1 &lt;- r &gt; 0.5
s2 &lt;- Which(r &gt; 0.5)
s1[1:15]
s2[1:15]

# this expression
x1 &lt;- Which(r, na.rm=FALSE)
# is the inverse of
x2 &lt;- r==0
</code></pre>

<hr>
<h2 id='which.min'>Where is the min or max value?</h2><span id='topic+which.min'></span><span id='topic+which.max'></span><span id='topic+whiches.min'></span><span id='topic+whiches.max'></span><span id='topic+which.min+2CRasterLayer-method'></span><span id='topic+which.max+2CRasterLayer-method'></span><span id='topic+which.min+2CRasterStackBrick-method'></span><span id='topic+which.max+2CRasterStackBrick-method'></span><span id='topic+whiches.min+2CRasterStackBrick-method'></span><span id='topic+whiches.max+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Which cells have the minumum / maximum value (for a RasterLayer), or which layer has the minimum/maximum value (for a RasterStack or RasterBrick)?
</p>
<p>which.min and which.max return the index of the first layer that has the min or max value for a cell. This can be problematic if there are ties. 
</p>
<p>In you want the index of all the layers that have the min or max value, use whiches.min or whiches.max (only for objects with less than 10 layers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.min(x)
which.max(x)
whiches.min(x, ...)
whiches.max(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.min_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="which.min_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(which.*): vector of cell numbers (if <code>x</code> is a RasterLayer). If <code>x</code> is a RasterStack or RasterBrick, a RasterLayer giving the number of the first layer with the minimum or maximum value for a cell.
</p>
<p>(whiches.*). An integer in which each digit represents a layer. For example, 35 means &quot;layers 3 and 5&quot;
</p>


<h3>Note</h3>

<p>There is a limit to accurate integer number representation. Therefore, do not use <code>whiches.*</code> with more than 15 layers.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Which">Which</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brick(system.file("external/rlogo.grd", package="raster")) 

r &lt;- which.min(b)

i &lt;- which.min(b[[3]])
xy &lt;- xyFromCell(b, i)
plot(b[[3]])
points(xy)

x &lt;- whiches.min(b)
freq(x)

</code></pre>

<hr>
<h2 id='writeFormats'>File types for writing</h2><span id='topic+writeFormats'></span>

<h3>Description</h3>

<p>List supported file types for writing RasterLayer values to disk.
</p>
<p>When a function writes a file to disk, the file format is determined by the 'format=' argument if supplied, or else by the file extension (if the extension is known). If other cases the default format is used. The 'factory-fresh' default format is 'raster', but this can be changed using <code><a href="#topic+rasterOptions">rasterOptions</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFormats()
</code></pre>


<h3>Details</h3>

<p>writeFormats returns a matrix of the file formats (the &quot;drivers&quot;) that are supported.
</p>
<p>Supported formats include:
</p>

<table>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: left;"> <b>File type</b> </td><td style="text-align: left;"> <b>Long name</b> </td><td style="text-align: left;"> <b>default extension</b> </td><td style="text-align: right;"> <b>Multiband support</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>raster</code>    </td><td style="text-align: left;"> 'Native' raster package format </td><td style="text-align: left;"> .grd </td><td style="text-align: right;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>ascii</code>     </td><td style="text-align: left;"> ESRI Ascii  </td><td style="text-align: left;"> .asc                 </td><td style="text-align: right;">  No </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>SAGA</code>      </td><td style="text-align: left;"> SAGA GIS    </td><td style="text-align: left;"> .sdat                </td><td style="text-align: right;">  No </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>IDRISI</code>    </td><td style="text-align: left;"> IDRISI      </td><td style="text-align: left;"> .rst                 </td><td style="text-align: right;">  No </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>CDF</code>       </td><td style="text-align: left;"> netCDF (requires ncdf4) </td><td style="text-align: left;"> .nc    </td><td style="text-align: right;">  Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>GTiff</code>     </td><td style="text-align: left;"> GeoTiff </td><td style="text-align: left;"> .tif    </td><td style="text-align: right;">  Yes  </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>ENVI</code>      </td><td style="text-align: left;"> ENVI .hdr Labelled       </td><td style="text-align: left;"> .envi   </td><td style="text-align: right;"> Yes  </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>EHdr</code>      </td><td style="text-align: left;"> ESRI .hdr Labelled       </td><td style="text-align: left;">  .bil   </td><td style="text-align: right;"> Yes  </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>HFA</code>       </td><td style="text-align: left;"> Erdas Imagine Images (.img)  </td><td style="text-align: left;"> .img </td><td style="text-align: right;"> Yes  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'> 
writeFormats() 
</code></pre>

<hr>
<h2 id='writeRaster'>Write raster data to a file</h2><span id='topic+writeRaster+2CRasterLayer+2Ccharacter-method'></span><span id='topic+writeRaster+2CRasterStackBrick+2Ccharacter-method'></span><span id='topic+writeRaster'></span>

<h3>Description</h3>

<p>Write an entire Raster* object to a file, using one of the many supported formats. See <code><a href="#topic+writeValues">writeValues</a></code> for writing in chunks (e.g.  by row). 
</p>
<p>When writing a file to disk, the file format is determined by the 'format=' argument if supplied, or else by the file extension (if the extension is known). If other cases the default format is used. The default format is 'raster', but this setting can be changed (see <code><a href="#topic+rasterOptions">rasterOptions</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,character'
writeRaster(x, filename, format, ...)

## S4 method for signature 'RasterStackBrick,character'
writeRaster(x, filename, format, bylayer, suffix='numbers', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeRaster_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="writeRaster_+3A_filename">filename</code></td>
<td>
<p>Output filename</p>
</td></tr>
<tr><td><code id="writeRaster_+3A_format">format</code></td>
<td>
<p>Character. Output file type. See <code><a href="#topic+writeFormats">writeFormats</a></code>. If this argument is not provided, it is attempted to infer it from the filename extension. If that fails, the default format is used. The default format is 'raster', but this can be changed using <code><a href="#topic+rasterOptions">rasterOptions</a></code></p>
</td></tr>
<tr><td><code id="writeRaster_+3A_...">...</code></td>
<td>
<p>Additional arguments: 
</p>
<p><code>datatype</code>: Character. Output data type (e.g. 'INT2S' or 'FLT4S'). See <code><a href="#topic+dataType">dataType</a></code>. If no datatype is specified, 'FLT4S' is used, unless this default value was changed with <code><a href="#topic+rasterOptions">rasterOptions</a></code>
</p>
<p><code>overwrite</code>: Logical. If TRUE, &quot;filename&quot; will be overwritten if it exists
</p>
<p><code>progress</code>: Character. Set a value to show a progress bar. Valid values are &quot;text&quot; and &quot;window&quot;.
</p>
<p><code>NAflag</code>: Numeric. To overwrite the default value used to represent <code>NA</code> in a file 
</p>
<p><code>bandorder</code>: Character. 'BIL', 'BIP', or 'BSQ'. For 'native' file formats only.
For some other formats you can use the 'options' argument (see below)
</p>
<p><code>options</code>: Character. File format specific GDAL options. E.g., when
writing a geotiff file you can use: <code>options=c("COMPRESS=NONE", "TFW=YES")</code>
</p>
<p>You can use options=c(&quot;PROFILE=BASELINE&quot;) to create a plain  tif with no GeoTIFF tags. 
This can be useful when writing files to be read by applications intolerant of unrecognised tags. 
</p>
<p>NetCDF files have the following additional, optional, arguments: <code>varname</code>, <code>varunit</code>, <code>longname</code>, <code>xname</code>, <code>yname</code>, <code>zname</code>, <code>zunit</code>
</p>
<p><code>prj</code>: Logical. If <code>TRUE</code>, the crs is written to a .prj file. This can be useful 
when writing to an ascii file or another file type that does not store the crs
</p>
<p><code>setStatistics</code>: logical. If <code>TRUE</code> (the default) the min and max cell values are written to file (if the format permits it)
</p>
</td></tr>
<tr><td><code id="writeRaster_+3A_bylayer">bylayer</code></td>
<td>
<p>if <code>TRUE</code>, write a separate file for each layer. You can provide a vector of filenames that matches the number of layers. Or you can provide a single filename that will get a unique suffix (see below)</p>
</td></tr>
<tr><td><code id="writeRaster_+3A_suffix">suffix</code></td>
<td>
<p>'numbers' or 'names' to determine the suffix that each file gets when <code>bylayer=TRUE</code>; either a number between <code>1</code> and <code>nlayers(x)</code> or <code>names(x)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>writeFormats</code> for supported file types (&quot;formats&quot;, &quot;drivers&quot;).
</p>
<p>In multi-layer files (i.e. files saved from RasterStack or RasterBrick objects), in the native 'raster' format, the band-order can be set to BIL ('Bands Interleaved by Line'), BIP ('Bands Interleaved by Pixels') or BSQ ('Bands SeQuential'). Note that bandorder is not the same as filetype here. 
</p>
<p>Supported file types include:
</p>

<table>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: left;"> <b>File type</b> </td><td style="text-align: left;"> <b>Long name</b> </td><td style="text-align: left;"> <b>default extension</b> </td><td style="text-align: right;"> <b>Multiband support</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>raster</code>    </td><td style="text-align: left;"> 'Native' raster package format </td><td style="text-align: left;"> .grd </td><td style="text-align: right;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>ascii</code>     </td><td style="text-align: left;"> ESRI Ascii  </td><td style="text-align: left;"> .asc                 </td><td style="text-align: right;">  No </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>SAGA</code>      </td><td style="text-align: left;"> SAGA GIS    </td><td style="text-align: left;"> .sdat                </td><td style="text-align: right;">  No </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>IDRISI</code>    </td><td style="text-align: left;"> IDRISI      </td><td style="text-align: left;"> .rst                 </td><td style="text-align: right;">  No </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>CDF</code>       </td><td style="text-align: left;"> netCDF (requires ncdf4) </td><td style="text-align: left;"> .nc    </td><td style="text-align: right;">  Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>GTiff</code>     </td><td style="text-align: left;"> GeoTiff </td><td style="text-align: left;"> .tif    </td><td style="text-align: right;">  Yes  </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>ENVI</code>      </td><td style="text-align: left;"> ENVI .hdr Labelled       </td><td style="text-align: left;"> .envi   </td><td style="text-align: right;"> Yes  </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>EHdr</code>      </td><td style="text-align: left;"> ESRI .hdr Labelled       </td><td style="text-align: left;">  .bil   </td><td style="text-align: right;"> Yes  </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>HFA</code>       </td><td style="text-align: left;"> Erdas Imagine Images (.img)  </td><td style="text-align: left;"> .img </td><td style="text-align: right;"> Yes  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>This function is used for the side-effect of writing values to a file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+writeFormats">writeFormats</a></code>, <code><a href="#topic+writeValues">writeValues</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
tmp &lt;- tempdir()
r &lt;- raster(system.file("external/test.grd", package="raster"))

# take a small part
r &lt;- crop(r, extent(179880, 180800, 329880, 330840) )

# write to an integer binary file
rf &lt;- writeRaster(r, filename=file.path(tmp, "allint.grd"), datatype='INT4S', overwrite=TRUE)

# make a brick and save multi-layer file
b &lt;- brick(r, sqrt(r))
bf &lt;- writeRaster(b, filename=file.path(tmp, "multi.grd"), bandorder='BIL', overwrite=TRUE)

# write to a new geotiff file
rf &lt;- writeRaster(r, filename=file.path(tmp, "test.tif"), format="GTiff", overwrite=TRUE)
bf &lt;- writeRaster(b, filename=file.path(tmp, "multi.tif"), 
						options="INTERLEAVE=BAND", overwrite=TRUE)

 
# write to netcdf 
if (require(ncdf4)) {	
 rnc &lt;- writeRaster(r, filename=file.path(tmp, "netCDF.nc"), format="CDF", overwrite=TRUE)   
}
</code></pre>

<hr>
<h2 id='writeValues'>Write values to a file</h2><span id='topic+writeStart'></span><span id='topic+writeStart+2CRasterLayer+2Ccharacter-method'></span><span id='topic+writeStart+2CRasterBrick+2Ccharacter-method'></span><span id='topic+writeStop'></span><span id='topic+writeStop+2CRasterLayer-method'></span><span id='topic+writeStop+2CRasterBrick-method'></span><span id='topic+writeValues'></span><span id='topic+writeValues+2CRasterLayer+2Cvector-method'></span><span id='topic+writeValues+2CRasterBrick+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Functions for writing blocks (&gt;= 1 row(s)) of values to files. Writing has to start at the first cell of a row (identified with argument <code>start</code>) and the values written must represent 1 or more entire rows. Begin by opening a file with <code>writeStart</code>, then write values to it in chunks. When writing is done close the file with <code>writeStop</code>. 
</p>
<p>If you want to write all values of a Raster* object at once, you can also use <code><a href="#topic+writeRaster">writeRaster</a></code> which is easier to use but more limited. The functions described here allow writing values to file using chunks of different sizes (e.g. 1 or 10 rows). Function <code><a href="#topic+blockSize">blockSize</a></code> can be used to suggest a chunk size to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,character'
writeStart(x, filename, options=NULL, format, prj=FALSE, ...)
## S4 method for signature 'RasterBrick,character'
writeStart(x, filename, options=NULL, format, prj=FALSE, ...)
## S4 method for signature 'RasterLayer,vector'
writeValues(x, v, start, ...)
## S4 method for signature 'RasterBrick,matrix'
writeValues(x, v, start, ...)
## S4 method for signature 'RasterLayer'
writeStop(x)
## S4 method for signature 'RasterBrick'
writeStop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeValues_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="writeValues_+3A_filename">filename</code></td>
<td>
<p>character. Output file name</p>
</td></tr>
<tr><td><code id="writeValues_+3A_options">options</code></td>
<td>
<p>character, see <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="writeValues_+3A_format">format</code></td>
<td>
<p>character, see <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="writeValues_+3A_prj">prj</code></td>
<td>
<p>logical. If <code>TRUE</code>, a &quot;prj&quot; file is written</p>
</td></tr>
<tr><td><code id="writeValues_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="writeValues_+3A_v">v</code></td>
<td>
<p>vector (RasterLayer) or matrix (RasterBrick) of values</p>
</td></tr>
<tr><td><code id="writeValues_+3A_start">start</code></td>
<td>
<p>Integer. Row number (counting starts at 1) from where to start writing <code>v</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>RasterLayer or RasterBrick 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+writeRaster">writeRaster</a>, <a href="#topic+blockSize">blockSize</a>, <a href="#topic+update">update</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 

## Not run: 
r &lt;- raster(system.file("external/test.grd", package="raster"))
# write to a new binary file in chunks
s &lt;- raster(r)
# 
tr &lt;- blockSize(r)
tr
s &lt;- writeStart(s, filename='test.grd',  overwrite=TRUE)
for (i in 1:tr$n) {
	v &lt;- getValuesBlock(r, row=tr$row[i], nrows=tr$nrows[i])
	s &lt;- writeValues(s, v, tr$row[i])
}
s &lt;- writeStop(s)

s2 &lt;- writeStart(s, filename='test2.tif', format='GTiff', overwrite=TRUE)
# writing last row first
for (i in tr$n:1) {
	v &lt;- getValuesBlock(r, row=tr$row[i], nrows=tr$nrows[i])
	s2 &lt;- writeValues(s2, v, tr$row[i])
}
# row number 5 once more
v &lt;- getValuesBlock(r, row=5, nrows=1)
writeValues(s2, v, 5)
s2 &lt;- writeStop(s2)


## write values of a RasterStack to a RasterBrick
s &lt;- stack(system.file("external/rlogo.grd", package="raster"))
# create empty brick
b &lt;- brick(s, values=FALSE)  
b &lt;- writeStart(b, filename="test.grd", format="raster",overwrite=TRUE)
tr &lt;- blockSize(b)
for (i in 1:tr$n) {
	v &lt;- getValuesBlock(s, row=tr$row[i], nrows=tr$nrows[i])
	b &lt;- writeValues(b, v, tr$row[i])
}
b &lt;- writeStop(b)
# note that the above is equivalent to 
# b &lt;- writeRaster(s, filename="test.grd", format="raster",overwrite=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='xyFromCell'>Coordinates from a row, column or cell number</h2><span id='topic+xFromCol'></span><span id='topic+xFromCol+2CRaster+2Cnumeric-method'></span><span id='topic+xFromCol+2CRaster+2Cmissing-method'></span><span id='topic+yFromRow'></span><span id='topic+yFromRow+2CRaster+2Cnumeric-method'></span><span id='topic+yFromRow+2CRaster+2Cmissing-method'></span><span id='topic+xFromCell'></span><span id='topic+xFromCell+2CRaster+2Cnumeric-method'></span><span id='topic+yFromCell'></span><span id='topic+yFromCell+2CRaster+2Cnumeric-method'></span><span id='topic+xyFromCell'></span><span id='topic+xyFromCell+2CBasicRaster-method'></span><span id='topic+xyFromCell+2CBasicRaster+2CANY-method'></span><span id='topic+xyFromCell+2CRaster-method'></span><span id='topic+xyFromCell+2CRaster-method'></span><span id='topic+coordinates'></span><span id='topic+coordinates+2CRaster-method'></span><span id='topic+coordinates+2CExtent-method'></span>

<h3>Description</h3>

<p>These functions get coordinates of the center of raster cells for a row, column, or cell number of a Raster* object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,numeric'
xFromCol(object, col)
## S4 method for signature 'Raster,numeric'
yFromRow(object, row)
## S4 method for signature 'Raster,numeric'
xFromCell(object, cell)
## S4 method for signature 'Raster,numeric'
yFromCell(object, cell)
## S4 method for signature 'BasicRaster,ANY'
xyFromCell(object, cell, spatial=FALSE, ...)
## S4 method for signature 'Raster'
coordinates(obj, ...)
## S4 method for signature 'Extent'
coordinates(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyFromCell_+3A_object">object</code></td>
<td>
<p>Raster* object (or a SpatialPixels* or SpatialGrid* object)</p>
</td></tr>
<tr><td><code id="xyFromCell_+3A_col">col</code></td>
<td>
<p>column number; or vector of column numbers. If missing, the x coordinates for all columns are returned</p>
</td></tr>
<tr><td><code id="xyFromCell_+3A_row">row</code></td>
<td>
<p>row number; or vector of row numbers. If missing, the y coordinates for all rows are returned</p>
</td></tr>
<tr><td><code id="xyFromCell_+3A_cell">cell</code></td>
<td>
<p>cell number(s)</p>
</td></tr>
<tr><td><code id="xyFromCell_+3A_spatial">spatial</code></td>
<td>
<p>If <code>spatial=TRUE</code>, <code>xyFromCell</code> returns a SpatialPoints object instead of a matrix</p>
</td></tr>
<tr><td><code id="xyFromCell_+3A_...">...</code></td>
<td>
<p>additional arguments. None implemented</p>
</td></tr>
<tr><td><code id="xyFromCell_+3A_obj">obj</code></td>
<td>
<p>Raster object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom.
The last cell number equals the number of cells of the Raster* object.
</p>


<h3>Value</h3>

<p>xFromCol, yFromCol, xFromCell, yFromCell: vector of x or y coordinates 
</p>
<p>xyFromCell: matrix(x,y) with coordinate pairs 
</p>
<p>coordinates: xy coordinates for all cells
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cellFromXY">cellFromXY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#using a new default raster (1 degree global)
r &lt;- raster()
xFromCol(r, c(1, 120, 180))
yFromRow(r, 90)
xyFromCell(r, 10000)
xyFromCell(r, c(0, 1, 32581, ncell(r), ncell(r)+1))

#using a file from disk
r &lt;- raster(system.file("external/test.grd", package="raster"))
r
cellFromXY(r, c(180000, 330000))
#xy for corners of a raster:
xyFromCell(r, c(1, ncol(r), ncell(r)-ncol(r)+1, ncell(r)))
</code></pre>

<hr>
<h2 id='z-values'>Get or set z-values</h2><span id='topic+getZ'></span><span id='topic+setZ'></span>

<h3>Description</h3>

<p>Initial functions for a somewhat more formal approach to get or set z values (e.g. time) associated with layers of Raster* objects. In development.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setZ(x, z, name='time')
getZ(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z-values_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="z-values_+3A_z">z</code></td>
<td>
<p>vector of z values of any type (e.g. of class 'Date')</p>
</td></tr>
<tr><td><code id="z-values_+3A_name">name</code></td>
<td>
<p>character label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>setZ: Raster* object
</p>
<p>getZ: vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncol=10, nrow=10)
s &lt;- stack(lapply(1:3, function(x) setValues(r, runif(ncell(r)))))
s &lt;- setZ(s, as.Date('2000-1-1') + 0:2)
s
getZ(s)
</code></pre>

<hr>
<h2 id='zApply'>z (time) apply</h2><span id='topic+zApply'></span>

<h3>Description</h3>

<p>Experimental function to apply a function over a (time) series of layers of a Raster object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zApply(x, by, fun=mean, name='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zApply_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="zApply_+3A_by">by</code></td>
<td>
<p>aggregation indices or function </p>
</td></tr>
<tr><td><code id="zApply_+3A_fun">fun</code></td>
<td>
<p>function to compute aggregated values </p>
</td></tr>
<tr><td><code id="zApply_+3A_name">name</code></td>
<td>
<p>character label of the new time series </p>
</td></tr>  
<tr><td><code id="zApply_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Raster* object
</p>


<h3>Author(s)</h3>

<p>Oscar Perpinan Lamigueiro &amp; Robert J. Hijmans</p>


<h3>Examples</h3>

<pre><code class='language-R'># 12 values of irradiation, 1 for each month
G0dm=c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,7.027,5.369,3.562,2.814,2.179)*1000;
# RasterBrick with 12 layers based on G0dm + noise
r &lt;- raster(nc=10, nr=10)
s &lt;- brick(lapply(1:12, function(x) setValues(r, G0dm[x]+100*rnorm(ncell(r)) )))

# time
tm &lt;- seq(as.Date('2010-01-15'), as.Date('2010-12-15'), 'month')
s &lt;- setZ(s, tm, 'months')

# library(zoo)
# x &lt;- zApply(s, by=as.yearqtr, fun=mean, name='quarters')
</code></pre>

<hr>
<h2 id='zonal'>Zonal statistics</h2><span id='topic+zonal'></span><span id='topic+zonal+2CRasterLayer+2CRasterLayer-method'></span><span id='topic+zonal+2CRasterStackBrick+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Compute zonal statistics, that is summarized values of a Raster* object for each &quot;zone&quot; defined by a RasterLayer. 
</p>
<p>If <code>stat</code> is a true <code>function</code>, <code>zonal</code> will fail (gracefully) for very large Raster objects, but it will in most cases work for functions that can be defined as by a character argument ('mean', 'sd', 'min', 'max', or 'sum'). In addition you can use 'count' to count the number of cells in each zone (only useful with <code>na.rm=TRUE</code>, otherwise <code>freq(z)</code> would be more direct.
</p>
<p>If a function is used, it should accept a <code>na.rm</code> argument (or at least a <code>...</code> argument)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,RasterLayer'
zonal(x, z, fun='mean', digits=0, na.rm=TRUE, ...) 

## S4 method for signature 'RasterStackBrick,RasterLayer'
zonal(x, z, fun='mean', digits=0, na.rm=TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonal_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="zonal_+3A_z">z</code></td>
<td>
<p>RasterLayer with codes representing zones</p>
</td></tr>
<tr><td><code id="zonal_+3A_fun">fun</code></td>
<td>
<p>function to be applied to summarize the values by zone. Either as character: 'mean', 'sd', 'min', 'max', 'sum'; or, for relatively small Raster* objects, a proper function</p>
</td></tr>
<tr><td><code id="zonal_+3A_digits">digits</code></td>
<td>
<p>integer. Number of digits to maintain in 'zones'. By default averaged to an integer (zero digits)</p>
</td></tr>
<tr><td><code id="zonal_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> values in <code>x</code> are ignored</p>
</td></tr>
<tr><td><code id="zonal_+3A_...">...</code></td>
<td>
<p>additional arguments. One implemented: <code>progress</code>, as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with a value for each zone (unique value in <code>zones</code>)
</p>


<h3>See Also</h3>

<p> See <code><a href="#topic+cellStats">cellStats</a></code> for 'global' statistics (i.e., all of <code>x</code> is considered a single zone), and <code><a href="#topic+extract">extract</a></code> for summarizing values for polygons</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(ncols=10, nrows=10)
values(r) &lt;- runif(ncell(r)) * 1:ncell(r)
z &lt;- r
values(z) &lt;- rep(1:5, each=20)
# for large files, use a character value rather than a function
zonal(r, z, 'sum')

# for smaller files you can also provide a function
## Not run: 
zonal(r, z, mean)
zonal(r, z, min)

## End(Not run)

# multiple layers
zonal(stack(r, r*10), z, 'sum')
</code></pre>

<hr>
<h2 id='zoom'>Zoom in on a map</h2><span id='topic+zoom'></span><span id='topic+zoom+2CRaster-method'></span><span id='topic+zoom+2CSpatial-method'></span><span id='topic+zoom+2Cmissing-method'></span>

<h3>Description</h3>

<p>Zoom in on a map (plot) by providing a new extent, by default this is done by clicking twice on the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoom(x, ...) 
## S4 method for signature 'Raster'
zoom(x, ext=drawExtent(), maxpixels=100000, layer=1, new=TRUE, useRaster=TRUE, ...)

## S4 method for signature 'Spatial'
zoom(x, ext=drawExtent(), new=TRUE, ...)

## S4 method for signature 'missing'
zoom(x, ext=drawExtent(), new=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zoom_+3A_x">x</code></td>
<td>
<p>Raster* or Spatial* (vector type) object</p>
</td></tr>
<tr><td><code id="zoom_+3A_ext">ext</code></td>
<td>
<p>Extent object, or other object from which an extent can be extracted</p>
</td></tr>
<tr><td><code id="zoom_+3A_maxpixels">maxpixels</code></td>
<td>
<p>Maximum number of pixels used for the map</p>
</td></tr>
<tr><td><code id="zoom_+3A_layer">layer</code></td>
<td>
<p>Positive integer to select the layer to be used if x is a mutilayer Raster object</p>
</td></tr>
<tr><td><code id="zoom_+3A_new">new</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the zoomed in map will appear on a new device (window)</p>
</td></tr>
<tr><td><code id="zoom_+3A_useraster">useRaster</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a bitmap raster is used to plot the image instead of polygons</p>
</td></tr>
<tr><td><code id="zoom_+3A_...">...</code></td>
<td>
<p>additional paramters for base plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extent object (invisibly)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+drawExtent">drawExtent</a></code>, <code><a href="#topic+plot">plot</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
