<!DOCTYPE html><html><head><title>Help for package quantregGrowth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quantregGrowth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#quantregGrowth-package'>
<p>Non-Crossing Additive Regression Quantiles and Non-Parametric Growth Charts.</p></a></li>
<li><a href='#charts'>
<p>Easy computing growth charts</p></a></li>
<li><a href='#gcrq'>
<p>Growth charts regression quantiles with automatic smoothness estimation</p></a></li>
<li><a href='#growthData'><p>Simulated data to illustrate capabilities of the package</p></a></li>
<li><a href='#logLik.gcrq'>
<p>Log Likelihood, AIC and BIC for gcrq objects</p></a></li>
<li><a href='#ncross.rq.fitXB'>
<p>Estimation of noncrossing regression quantiles with monotonicity restrictions.</p></a></li>
<li><a href='#plot.gcrq'>
<p>Plot method for gcrq objects</p></a></li>
<li><a href='#predict.gcrq'>
<p>Prediction for &quot;gcrq&quot; objects</p></a></li>
<li><a href='#print.gcrq'><p> Print method for the gcrq class</p></a></li>
<li><a href='#ps'>
<p>Specifying a smooth term in the gcrq formula.</p></a></li>
<li><a href='#SiChildren'>
<p>Age, height and weight in a sample of Italian children</p></a></li>
<li><a href='#summary.gcrq'>
<p>Summarizing model fits for growth charts regression quantiles</p></a></li>
<li><a href='#vcov.gcrq'>
<p>Variance-Covariance Matrix for a Fitted 'gcrq' Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Crossing Additive Regression Quantiles and Non-Parametric
Growth Charts</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vito M. R. Muggeo &lt;vito.muggeo@unipa.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits non-crossing regression quantiles as a function of linear covariates and multiple smooth terms, including varying coefficients, via B-splines with L1-norm difference penalties.  
    Random intercepts and variable selection are allowed via the lasso penalties.
    The smoothing parameters are estimated as part of the model fitting, see Muggeo and others (2021) &lt;<a href="https://doi.org/10.1177%2F1471082X20929802">doi:10.1177/1471082X20929802</a>&gt;. Monotonicity and concavity 
    constraints on the fitted curves are allowed, see Muggeo and others (2013) &lt;<a href="https://doi.org/10.1007%2Fs10651-012-0232-1">doi:10.1007/s10651-012-0232-1</a>&gt;, 
    and also &lt;<a href="https://doi.org/10.13140%2FRG.2.2.12924.85122">doi:10.13140/RG.2.2.12924.85122</a>&gt; or &lt;<a href="https://doi.org/10.13140%2FRG.2.2.29306.21445">doi:10.13140/RG.2.2.29306.21445</a>&gt; some code examples.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), quantreg, splines, SparseM, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, mgcv, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-20 08:43:42 UTC; vito</td>
</tr>
<tr>
<td>Author:</td>
<td>Vito M. R. Muggeo <a href="https://orcid.org/0000-0002-3386-4054"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-20 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='quantregGrowth-package'>
Non-Crossing Additive Regression Quantiles and Non-Parametric Growth Charts. 
</h2><span id='topic+quantregGrowth-package'></span><span id='topic+quantregGrowth'></span>

<h3>Description</h3>

<p>Fits non-crossing regression quantiles as a function of linear covariates 
and smooth terms via P-splines with difference penalties. Random intercepts and selection of linear variables are allowed via the lasso penalties. Estimation of (possibly adaptive) smoothing/tuning parameters (for the spline terms, the random intercepts and the variables selector) are carried out efficientely as part of model fitting.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> quantregGrowth</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.7-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-05-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Package quantregGrowth allows estimation of growth charts via quantile regression. Given a set of percentiles (i.e. probability values), <code>gcrq</code> estimates non-crossing quantile curves as a flexible function of quantitative covariates (typically age in growth charts), and possibly additional linear terms. To ensure flexibility, B-splines with a difference <code class="reqn">L_1</code> penalty are employed to estimate non parametrically the curves wherein monotonicity and concavity constraints may be also set. Multiple smooth terms, including varying coefficients, are allowed and the amount of smoothness for each term is efficiently included in the model fitting algorithm, see Muggeo et al. (2021). <code>plot.gcrq</code> displays the fitted lines along with observations and poitwise confidence intervals. 
</p>


<h3>Author(s)</h3>

<p>Vito M.R. Muggeo
</p>
<p>Maintainer: Vito M.R. Muggeo &lt;vito.muggeo@unipa.it&gt;
</p>


<h3>References</h3>

<p>Muggeo VMR, Torretta F, Eilers PHC, Sciandra M, Attanasio M (2021).
Multiple smoothing parameters selection in additive regression quantiles,
<em>Statistical Modelling</em>, <b>21</b>, 428-448. 
</p>
<p>Muggeo VMR (2021). Additive Quantile regression with automatic smoothness selection: the R package quantregGrowth. <br />
https://www.researchgate.net/publication/350844895
</p>
<p>Muggeo VMR, Sciandra M, Tomasello A, Calvo S (2013).
Estimating growth charts via nonparametric quantile
regression: a practical framework with application
in ecology, <em>Environ Ecol Stat</em>, <b>20</b>, 519-531.
</p>
<p>Muggeo VMR (2018). Using the R package quantregGrowth: some examples. <br />
https://www.researchgate.net/publication/323573492
</p>
<p>Some references on growth charts (the first two papers employ the so-called LMS method)
</p>
<p>Cole TJ, Green P (1992) Smoothing reference centile curves: the LMS method and penalized likelihood.
<em>Statistics in Medicine</em> <b>11</b>, 1305-1319.
</p>
<p>Rigby RA, Stasinopoulos DM (2004) Smooth centile curves for skew and kurtotic data modelled using the
Box-Cox power exponential distribution. <em>Statistics in Medicine</em> <b>23</b>, 3053-3076.
</p>
<p>Wei Y, Pere A, Koenker R, He X (2006) Quantile regression methods for reference growth charts. 
<em>Statistics in Medicine</em> <b>25</b>, 1369-1382.
</p>
<p>Some references on regression quantiles
</p>
<p>Koenker R (2005) Quantile regression. Cambridge University Press, Cambridge.
</p>
<p>Cade BS, Noon BR (2003) A gentle introduction to quantile regression for ecologists. <em>Front Ecol Environ</em>
<b>1</b>, 412-420.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcrq">gcrq</a></code>, <code><a href="quantreg.html#topic+rq">rq</a></code> in package quantreg
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#see ?gcrq for some examples
</code></pre>

<hr>
<h2 id='charts'>
Easy computing growth charts
</h2><span id='topic+charts'></span>

<h3>Description</h3>

<p>Computes and returns quantiles as a function of the specified covariate values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charts(fit, k, file = NULL, digits=2, conf.level=0, 
    dataframe=FALSE, transf=NULL, se.type=c("sandw","boot"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charts_+3A_fit">fit</code></td>
<td>

<p>The object fit returned by <code><a href="#topic+gcrq">gcrq</a></code>
</p>
</td></tr>
<tr><td><code id="charts_+3A_k">k</code></td>
<td>

<p>Numeric indicating the covariate values. If integer (and scalar, specified via <code>5L</code>, say) , <code>k</code> equispaced values in the covariate range are taken. 
</p>
</td></tr>
<tr><td><code id="charts_+3A_file">file</code></td>
<td>

<p>If specified, the (path) file name wherein the returned matrix including the quantiles will be written via <code>write.csv()</code>
</p>
</td></tr>
<tr><td><code id="charts_+3A_digits">digits</code></td>
<td>

<p>Number of digits whereby the estimated quantiles are rounded. 
</p>
</td></tr>
<tr><td><code id="charts_+3A_conf.level">conf.level</code></td>
<td>

<p>If larger than zero, the pointwise confidence intervals for the estimated quantiles are also returned. If <code>conf.level=0</code> the simple point estimates. 
</p>
</td></tr>
<tr><td><code id="charts_+3A_dataframe">dataframe</code></td>
<td>

<p>Logical. If <code>TRUE</code> and <code>conf.level&gt;0</code> a dataframe is returned having point estimate and confidence intervals collapsed.  Otherwise a matrix having number of rows equal to the number of covariate values.
</p>
</td></tr>
<tr><td><code id="charts_+3A_transf">transf</code></td>
<td>

<p>An optional character string (with <code>"y"</code> as argument) meaning a function to apply to the predicted values. E.g. <code>"(exp(y)-0.1)"</code>. 
If <code>NULL</code> (default) it is taken as the inverse of function <code>transf</code> (*if*) supplied in <code>gcrq</code>. The standard errors (provided <code>se.fit=TRUE</code> has been set) are adjusted accordingly via the Delta method. See argument <code>"transf"</code> in <code>gcrq()</code>. If <code>transf</code> has been specified in <code>gcrq()</code>, use <code>transf="y"</code> to force predictions on the transformed scale, i.e. without back transforming.
</p>
</td></tr>
<tr><td><code id="charts_+3A_se.type">se.type</code></td>
<td>

<p>Which covariance matrix should be used, provided that <code>conf.level&gt;0</code>. See <code>type</code> in <code><a href="#topic+predict.gcrq">predict.gcrq</a></code>. 
</p>
</td></tr>
<tr><td><code id="charts_+3A_...">...</code></td>
<td>

<p>Further arguments passed on to <code>write.csv()</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is simply a wrapper for <code><a href="#topic+predict.gcrq">predict.gcrq</a></code>
</p>


<h3>Value</h3>

<p>A matrix having number of columns equal to the number of quantile curves and number of rows depending <code>k</code> 
</p>


<h3>Note</h3>

<p><code>charts</code> just works with models having a single smooth term. See <code><a href="#topic+predict.gcrq">predict.gcrq</a></code> when the model involves multiple covariates.
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.gcrq">predict.gcrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
charts(_fit_, k=1L) #prediction at the minimum of covariate
charts(_fit_, k=1) #prediction at covariate value 1.

charts(_fit_, k=10L)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='gcrq'>
Growth charts regression quantiles with automatic smoothness estimation
</h2><span id='topic+gcrq'></span>

<h3>Description</h3>

<p>Modelling unspecified nonlinear relationships between covariates and quantiles of the response conditional distribution. Typical example is estimation nonparametric growth charts (via quantile regression). Quantile curves are estimated via B-splines with 
a <code class="reqn">L_1</code> penalty on the spline coefficient differences, while non-crossing and possible monotonicity and concavity restrictions are set to obtain estimates
more biologically plausible. Linear terms can be specified in the model formula. Multiple smooth terms, including varying coefficients, with automatic selection of corresponding smoothing parameters are allowed.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcrq(formula, tau=c(.1,.25,.5,.75,.9), data, subset, weights, na.action, 
    transf=NULL, y=TRUE, n.boot=0, eps=0.001, display=FALSE, 
    method=c("REML","ML"), df.opt=2, df.nc=FALSE, lambda0=.1, h=0.8, lambda.max=1000, 
    tol=0.01, it.max=15, single.lambda=TRUE, foldid=NULL, nfolds=10, 
    lambda.ridge=0, adjX.constr=TRUE, contrasts=NULL, sparse=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcrq_+3A_formula">formula</code></td>
<td>

<p>a standard R formula to specify the response in the left hand side, and the covariates in the right hand side, such as <code>y~ps(x)+z</code>, see Details for further examples.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_tau">tau</code></td>
<td>

<p>a numeric vector to specify the quantile curves of interest. Default to probability values <code class="reqn">(.1,.25,.5,.75,.9)</code>.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_data">data</code></td>
<td>

<p>the dataframe where the variables required by the formula, subset and weights arguments are stored.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_subset">subset</code></td>
<td>

<p>optional. A vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_weights">weights</code></td>
<td>

<p>optional. A numeric vector specifying weights to be assigned to the observations in the fitting process.
Currently unimplemented. 
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates how the possible &lsquo;NA&rsquo;s are handled.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_transf">transf</code></td>
<td>

<p>an optional character string (with <code>"y"</code> as argument) meaning a function to apply to the response variable 
before fitting. It can be useful to guarantee fitted values within a specified range; e.g. if <code>y&gt;=0</code>, we could set <code>"log(y+0.1)"</code>. If provided, the resulting object fit refers to the model for the transformed response and it will include the corresponding inverse function (numerically computed) to be used to back transform predictions (see argument <code>transf</code> in <code>predict.gcrq</code> and <code>plot.gcrq</code>).
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_y">y</code></td>
<td>

<p>logical. If <code>TRUE</code> (default) the returned object includes also the responses vector.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_n.boot">n.boot</code></td>
<td>

<p>Number of nonparametric (cases resampling) bootstrap samples to be used. If <code>n.boot&gt;0</code>, the covariance matrix can be obtained as empirical covariance matrix of the bootstrap distributions, see <code><a href="#topic+vcov.gcrq">vcov.gcrq</a></code>. Notice that the smoothing parameter (if relevant) is assumed fixed. Namely it does change throughout the bootstrap replicates.  
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_eps">eps</code></td>
<td>

<p>A small positive constant to ensure noncrossing curves (i.e. the minimum distance between two consecutive curves). Use it at your risk! If <code>eps</code> is large, the resulting fitted quantile curves could appear unreasonable.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_display">display</code></td>
<td>

<p>Logical. Should the iterative process be printed? Ignored if no smooth is specified in the formula or if all the smoothing parameters specified in <code>ps</code> terms are fixed.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_method">method</code></td>
<td>

<p>character, <code>"ML"</code> or <code>"REML"</code> affecting the smoothing parameter estimation. Default is <code>"REML"</code> which appears to provide better performance in simulation studies. 
Ignored if no smoothing parameter has to be estimated. 
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_df.opt">df.opt</code></td>
<td>

<p>How the model and term-specific degrees of freedom are computed. <code>df.opt=1</code> means via the null penalized coefficients, and <code>df.opt=2</code> via the trace of the approximate hat  matrix. Ignored if no smoothing parameter is be estimated.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_df.nc">df.nc</code></td>
<td>

<p>logical. If <code>TRUE</code> and the model refers to multiple quantile curves, the degrees of freedom account for the noncrossing constraints. 
Ignored for single quantile fits. Default to <code>FALSE</code>, as it is still experimental.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_lambda0">lambda0</code></td>
<td>

<p>the starting value for the lambdas to be estimated. Ignored if all the smoothing parameters specified in <code>ps</code> terms are fixed.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_h">h</code></td>
<td>

<p>The step halving factor affecting estimation of the smoothing parameters. Lower values lead to slower updates in the lambda values. Ignored if all the smoothing parameters specified in <code>ps</code> terms are fixed.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_lambda.max">lambda.max</code></td>
<td>

<p>The upper bound for lambda estimation. Ignored if all the smoothing parameters specified in <code>ps</code> terms are fixed.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_tol">tol</code></td>
<td>

<p>The tolerance value to declare convergence. Ignored if all the smoothing parameters specified in <code>ps</code> terms are fixed.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_it.max">it.max</code></td>
<td>

<p>The maximum number of iterations in lambdas estimation. Ignored if all the smoothing parameters specified in <code>ps</code> terms are fixed.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_single.lambda">single.lambda</code></td>
<td>

<p>Logical. Should the smoothing parameter (for each smooth term) to be the same across the quantile curves being estimated? Ignored when just a single quantile curve is being estimated.  
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_foldid">foldid</code></td>
<td>

<p>optional. A numeric vector identifying the group labels to perform cross validation to select the smoothing parameter. 
Ignored if the <code>lambda</code> argument in <code>ps()</code> is not a vector.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_nfolds">nfolds</code></td>
<td>

<p>optional. If <code>foldid</code> is not provided, it is scalar specifying the number of &lsquo;folds&rsquo; (groups) which should be used to perform cross validation to select 
the smoothing parameter. Default to 10, but it is ignored if the <code>lambda</code> argument in <code>ps()</code> is not a vector.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_lambda.ridge">lambda.ridge</code></td>
<td>

<p>Numerical value (typically very small) to stabilize model estimation.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_adjx.constr">adjX.constr</code></td>
<td>
<p>logical. If <code>TRUE</code>, each linear covariate is shifted (by substracting its min) in order to set up effective constraints to prevent crossing. Useful only if <code>tau</code> is a vector and the model includes linear terms.
</p>
</td></tr>
<tr><td><code id="gcrq_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See argument <code>contrasts.arg</code> in <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="gcrq_+3A_sparse">sparse</code></td>
<td>
<p>logical. If <code>TRUE</code>, the model is fitted via sparse algebra as implemented in the SparseM package. Typically <code>sparse=TRUE</code> is used when the model involves a single smooth with a very rich basis and a large sample size, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits regression quantiles at specified percentiles given in <code>tau</code> as a function of 
covariates specified in the <code>formula</code> argument. The <code>formula</code> may include linear terms and  one or several <code><a href="#topic+ps">ps</a></code> 
terms to model nonlinear relationships with quantitative covariates, usually age in growth charts. When the <code>lambda</code> argument 
in <code>ps()</code> is a negative scalar, the smoothing parameter is estimated iteratively as discussed in Muggeo et al. (2021). If a positive scalar, it represents the actual smoothing parameter value. 
</p>
<p>When the model includes a single <code>ps</code> term, setting <code>sparse=TRUE</code> (introduced since version 1.7-0) could reduce the computational time especially when the sample size is large and the basis involves several terms. However when <code>sparse=TRUE</code> is set, no linear term is allowed and for the smooth term a full and uncentred basis is used (i.e., equivalent to setting <code>dropc=FALSE</code> and <code>center=FALSE</code> along with <code>constr.fit=FALSE</code> in <code>ps()</code>). Therefore the correct call would be
</p>
<p><code>gcrq(y ~ 0+ps(x), sparse=TRUE) #if y~ps(x), a warning is printed as the intercept is not explicitly removed</code>
</p>
<p>which is equivalent to
</p>
<p><code>gcrq(y ~ 0+ps(x, dropc=FALSE, center=FALSE)) #sparse=FALSE is the default</code>
</p>
<p>Smoothing parameter selection via 'K-fold' cross validation (CV) is also allowed (but not recommended) if the model includes a single <code>ps</code> term:  <code>lambda</code> should be a vector of candidate values, and the final fit is returned at the &lsquo;optimal&rsquo; lambda value. To select the smoothing parameter via CV, <code>foldid</code> or <code>nfolds</code> may be supplied. If provided, <code>foldid</code> overwrites <code>nfolds</code>, otherwise <code>foldid</code> is obtained via random extraction, namely <code>sample(rep(seq(nfolds), length = n))</code>. However selection of smoothing parameter via CV is allowed only with a unique <code>ps</code> term in the formula.
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>gcrq</code>, that is a list with the following components (only the most important are listed)
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>The matrix of estimated regression parameters; the number of columns equals the number of the fitted quantile curves.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the design matrix of the final fit (including the dummy rows used by penalty).</p>
</td></tr>
<tr><td><code>edf.j</code></td>
<td>
<p>a matrix reporting the edf values for each term at each quantile curve. See the section 'Warning' below.  </p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>a vector including the values of the objective functions at the solution for each quantile curve.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a matrix of fitted quantiles (a column for each <code>tau</code> value)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a matrix of residuals (a column for each <code>tau</code> value)</p>
</td></tr>
<tr><td><code>D.matrix</code></td>
<td>
<p>the penalty matrix (multiplied by the smoothing parameter value).</p>
</td></tr>
<tr><td><code>D.matrix.nolambda</code></td>
<td>
<p>the penalty matrix.</p>
</td></tr>
<tr><td><code>pLin</code></td>
<td>
<p>number of linear covariates in the model.</p>
</td></tr>
<tr><td><code>info.smooth</code></td>
<td>
<p>some information on the smoothing term (if included in the formula via <code>ps</code>).</p>
</td></tr>
<tr><td><code>BB</code></td>
<td>
<p>further information on the smoothing term (if present in the formula via <code>ps</code>), including 
stuff useful for plotting via <code>plot.gcrq()</code>.</p>
</td></tr>
<tr><td><code>Bderiv</code></td>
<td>
<p>if the smooth term is included, the first derivative of the B spline basis.</p>
</td></tr>
<tr><td><code>boot.coef</code></td>
<td>
<p>The array including the estimated coefficients at different bootstrap samples (provided that <code>n.boot</code>&gt;0 has been set).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector (if <code>gcrq()</code> has been called with <code>y=TRUE</code>).</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>the contrasts used, when the model contains a factor.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>the levels of the factors (when included) used in fitting.</p>
</td></tr>
<tr><td><code>taus</code></td>
<td>
<p>a vector of values between 0 and 1 indicating the estimated quantile curves.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Variable selection is still at an experimental stage. 
</p>
<p>When including linear terms, the covariates <code class="reqn">X_j</code> are shifted such that <code class="reqn">min(X_j)=0</code>. 
</p>
<p>The options <code>'REML'</code> or <code>'ML'</code> of the argument <code>method</code>, refer to how the degrees of freedom are computed to update the lambda estimates. 
</p>
<p>Currently, standard errors are obtained via the sandwich formula or the nonparametric bootstrap (case resampling). Both methods ignore uncertainty in the smoothing parameter selection. 
</p>
<p>Since version 1.2-1, computation of the approximate edf can account for the noncrossing constraints by specifying <code>df.nc=TRUE</code>. That could affect model estimation when the smoothing parameter(s) have to be estimated, because the term specific edf are used to update the lambda value(s). When lambda is not being estimated (it is fixed or there is no <code>ps</code> term in the formula), parameter estimate is independent of the <code>df.nc</code> value. The <code>summary.gcrq</code> method reports if the edf account for the noncrossing constraints.     
</p>
<p>Using <code>ps(.., center=TRUE)</code> in the formula leads to lower uncertainty in the fitted curve while guaranteeing noncrossing constraints.  
</p>
<p>Currently, decomposition of Bsplines (i.e. <code>ps(..,decom=TRUE)</code>) is incompatible with shape (monotonicity and concavity) restrictions and even with noncrossing constraints.
</p>


<h3>Note</h3>

<p>This function is based upon the package quantreg by R. Koenker.
Currently methods specific to the class <code>"gcrq"</code> are <code>print.gcrq</code>, <code>summary.gcrq</code>, <code>vcov.gcrq</code>, <code>plot.gcrq</code>, <code>predict.gcrq</code>, <code>AIC.gcrq</code>, and <code>logLik.gcrq</code>.
</p>
<p>If the sample is not large, and/or the basis rank is large (i.e. a large number of columns) and/or there are relatively few distinct values in the covariate distribution, the fitting algorithm may fail returning error messages like the following 
</p>
<p><code>&gt; Error info =  20 in stepy2: singular design</code>
</p>
<p>To remedy it, it suffices to change some arguments in <code>ps()</code>: to decrease <code>ndx</code> or <code>deg</code> (even by a small amount) or 
to increase (even by a small amount) the lambda value. Sometimes even by changing slightly the tau probability value (for instance from 0.80 to 0.79) can bypass the aforementioned errors.
</p>


<h3>Author(s)</h3>

<p> Vito M. R. Muggeo, <a href="mailto:vito.muggeo@unipa.it">vito.muggeo@unipa.it</a> </p>


<h3>References</h3>

<p>V.M.R. Muggeo, F. Torretta, P.H.C. Eilers, M. Sciandra, M. Attanasio (2021).
Multiple smoothing parameters selection in additive regression quantiles,
Statistical Modelling, 21: 428-448.
</p>
<p>V. M. R. Muggeo (2021). Additive Quantile regression with automatic smoothness selection: the R package quantregGrowth. 
https://www.researchgate.net/publication/350844895
</p>
<p>V. M. R. Muggeo, M. Sciandra, A. Tomasello, S. Calvo (2013).
Estimating growth charts via nonparametric quantile
regression: a practical framework with application
in ecology, Environ Ecol Stat, 20, 519-531.
</p>
<p>V. M. R. Muggeo (2018). Using the R package quantregGrowth: some examples. <br />
https://www.researchgate.net/publication/323573492
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ps">ps</a></code>, <code><a href="#topic+plot.gcrq">plot.gcrq</a></code>, <code><a href="#topic+predict.gcrq">predict.gcrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##=== Example 1: an additive model from ?mgcv::gam

d&lt;-mgcv::gamSim(n=200, eg=1)
o&lt;-gcrq(y ~ ps(x0) + ps(x1)+ ps(x2) + ps(x3), data=d, tau=.5, n.boot=50)
plot(o, res=TRUE, col=2, conf.level=.9, shade=TRUE, split=TRUE)



##=== Example 2: some simple examples involving just a single smooth

data(growthData) #load data
tauss&lt;-seq(.1,.9,by=.1) #fix the percentiles of interest

m1&lt;-gcrq(y~ps(x), tau=tauss, data=growthData) #lambda estimated..

m2&lt;-gcrq(y~ps(x, lambda=0), tau=tauss, data=growthData) #unpenalized.. very wiggly curves
#strongly penalized models
m3&lt;-gcrq(y~ps(x, lambda=1000, d=2), tau=tauss, data=growthData) #linear 
m4&lt;-gcrq(y~ps(x, lambda=1000, d=3), tau=tauss, data=growthData) #quadratic  

#penalized model with monotonicity restrictions
m5&lt;-gcrq(y~ps(x, monotone=1, lambda=10), tau=tauss, data=growthData)

#monotonicity constraints,lambda estimated, and varying penalty
m6&lt;-gcrq(y~ps(x, monotone=1, lambda=10, var.pen="(1:k)"), tau=tauss, data=growthData) 
m6a&lt;-gcrq(y~ps(x, monotone=1, lambda=10, var.pen="(1:k)^2"), tau=tauss, data=growthData) 

par(mfrow=c(2,3))
plot(m1, res=TRUE, col=-1)
plot(m2, pch=20, res=TRUE)
plot(m3, add=TRUE, lty=2, col=4)
plot(m4, pch=20, res=TRUE)
plot(m5, pch=4, res=TRUE, legend=TRUE, col=2)
plot(m6, lwd=2, col=3)
plot(m6a, lwd=2, col=4)

#select lambda via 'K-fold' CV (only with a single smooth term)
m7&lt;-gcrq(y~ps(x, lambda=seq(0,10,l=20)), tau=tauss, data=growthData) 
par(mfrow=c(1,2))
plot(m7, cv=TRUE) #display CV score versus lambda values
plot(m7, res=TRUE, grid=list(x=5, y=8), col=4) #fit at the best lambda (by CV) 


##=== Example 3: VC models

n=50
x&lt;-1:n/n
mu0&lt;-10+sin(2*pi*x)
mu1&lt;- 7+4*x
y&lt;-c(mu0,mu1)+rnorm(2*n)*.2 #small noise.. just to illustrate..
x&lt;-c(x,x)
z&lt;-rep(0:1, each=n)

# approach 1: a smooth in each *factor* level 
g&lt;-factor(z)
o &lt;-gcrq(y~ g+ps(x,by=g), tau=.5) 
predict(o, newdata=data.frame(x=c(.3,.7), g=factor(c(0,1))))
par(mfrow=c(1,2))
plot(x[1:50],mu0,type="l")
plot(o, term=1, add=TRUE)
points(c(.3,.7), predict(o, newdata=data.frame(x=c(.3,.7), g=factor(c(0,0)))), pch=4, lwd=3,col=2)

plot(x[1:50],mu1,type="l")
plot(o, term=2, add=T, shift=coef(o)["g1",], col=3) #note the argument 'shift'
points(c(.3,.7), predict(o, newdata=data.frame(x=c(.3,.7), g=factor(c(1,1)))), pch=4, lwd=3,col=3)


# approach 2: a general smooth plus the (smooth) 'interaction' with a continuous covariate..
b1 &lt;-gcrq(y~ ps(x) + z+ ps(x,by=z), tau=.5)
par(mfrow=c(1,2))
plot(x[1:50],mu0,type="l")
plot(b1, add=TRUE, term=1) #plot the 1st smooth term

#plot the 2nd smooth of 'b1' (which is actually the difference mu1-mu0) 
plot(x[1:50], mu1-mu0, type="l")
plot(b1, term=2, add=TRUE, interc=FALSE, shift=coef(b1)["z",]) 



##=== Example 4: random intercepts example

n=50
x&lt;-1:n/n

set.seed(69)
z&lt;- sample(1:15, size=n, replace=TRUE)
#table(z)

#true model: linear effect + 3 non-null coeffs when z= 3, 7, and 13
y&lt;-2*x+  I(z==3)- I(z==7)  + 2*I(z==13) + rnorm(n)*.15
id&lt;-factor(z)

o &lt;-gcrq(y~x+ps(id), tau=.5) 
plot(o, term=1) #plot the subject-specific intercepts


#== variable selection
n=50
p=30
p1&lt;-10

X&lt;-matrix(rnorm(n*p,5),n,p)
b&lt;-rep(0,p)
id&lt;-sample(1:p, p1)
b[id]&lt;-round(runif(p1,.5,2),2)
b[id]&lt;-b[id]* sign(ifelse(runif(p1)&lt;.5,1,-1))
lp &lt;- drop(tcrossprod(X,t(b)))
y &lt;- 2+lp+rnorm(n)*1.5

gcrq(y~ps(X), tau=.7) 

## End(Not run)
</code></pre>

<hr>
<h2 id='growthData'>Simulated data to illustrate capabilities of the package</h2><span id='topic+growthData'></span>

<h3>Description</h3>

<p>The <code>growthData</code> data frame has 200 rows and 3 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(growthData)</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 3 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>the supposed &lsquo;age&rsquo; variable.</p>
</dd>
<dt><code>y</code></dt><dd><p>the supposed growth variable (e.g. weight).</p>
</dd>
<dt><code>z</code></dt><dd><p>an additional variable to be considered in the model.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Simulated data to illustrate capabilities of the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(growthData)
with(growthData, plot(x,y))
</code></pre>

<hr>
<h2 id='logLik.gcrq'>
Log Likelihood, AIC and BIC for gcrq objects
</h2><span id='topic+logLik.gcrq'></span><span id='topic+AIC.gcrq'></span>

<h3>Description</h3>

<p>The function returns the log-likelihood value(s) evaluated at the estimated coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcrq'
logLik(object, summ=TRUE, ...)
## S3 method for class 'gcrq'
AIC(object, ..., k=2, bondell=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.gcrq_+3A_object">object</code></td>
<td>

<p>A <code>gcrq</code> fit returned by <code>gcrq()</code>
</p>
</td></tr>
<tr><td><code id="logLik.gcrq_+3A_summ">summ</code></td>
<td>

<p>If <code>TRUE</code>, the log likelihood values (and relevant edf) are summed over the different taus to provide a unique value accounting for the different quantile curves. If <code>FALSE</code>, tau-specific values are returned.
</p>
</td></tr>
<tr><td><code id="logLik.gcrq_+3A_k">k</code></td>
<td>

<p>Optional numeric specifying the penalty of the edf in the AIC formula. <code>k &lt; 0</code> means <code>k=log(n)</code>.
</p>
</td></tr>
<tr><td><code id="logLik.gcrq_+3A_bondell">bondell</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the <em>SIC</em> according to formula (7) in Bondell et al. (2010) is computed. 
</p>
</td></tr>
<tr><td><code id="logLik.gcrq_+3A_...">...</code></td>
<td>

<p>optional  arguments (nothing in <code>logLik.gcrq</code>). For <code>AIC.gcrq</code>, <code>summ=TRUE</code> or <code>FALSE</code> can be set. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'logLikelihood' is computed by assuming an asymmetric Laplace distribution for the response as in <code><a href="quantreg.html#topic+logLik.rq">logLik.rq</a></code>, namely <code class="reqn">n (\log(\tau(1-\tau))-1-\log(\rho_\tau/n))</code>, where <code class="reqn">\rho_\tau</code> is the minimized objective function. When there are multiple quantile curves <code class="reqn">j=1,2,...,J</code> (and <code>summ=TRUE</code>) the formula is
</p>
<p><code class="reqn">n (\sum_j\log(\tau_j(1-\tau_j))-J-\log(\sum_j\rho_{\tau_j}/(n J)))</code>
</p>
<p><code>AIC.gcrq</code> simply returns <code>-2*logLik + k*edf</code> where <code>k</code> is 2 or <code>log(n)</code>.  
</p>


<h3>Value</h3>

<p>The log likelihood(s) of the model fit <code>object</code>
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>References</h3>

<p>Bondell HD, Reich BJ, Wang H (2010) Non-crossing quantile regression curve estimation, Biometrika, 97: 825-838.
</p>


<h3>See Also</h3>

<p><code><a href="quantreg.html#topic+logLik.rq">logLik.rq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
## logLik(o) #a unique value (o is the fit object  from gcrq)
## logLik(o, summ=FALSE) #vector of the log likelihood values
## AIC(o, k=-1) #BIC
   
</code></pre>

<hr>
<h2 id='ncross.rq.fitXB'>
Estimation of noncrossing regression quantiles with monotonicity restrictions.
</h2><span id='topic+ncross.rq.fitXB'></span><span id='topic+ncross.rq.fitXBsparse'></span><span id='topic+ncross.rq.fitX'></span><span id='topic+gcrq.rq.cv'></span>

<h3>Description</h3>

<p>These are internal functions of package <code>quantregGrowth</code> and should be not 
called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncross.rq.fitXB(y, x, B=NULL, X=NULL, taus, monotone=FALSE, concave=FALSE, 
    nomiBy=NULL, byVariabili=NULL, ndx=10, deg=3, dif=3, lambda=0, eps=.0001, 
    var.pen=NULL, penMatrix=NULL, lambda.ridge=0, dropcList=FALSE, 
    decomList=FALSE, vcList=FALSE, dropvcList=FALSE, centerList=FALSE, 
    ridgeList=FALSE, ps.matrix.list=FALSE, colmeansB=NULL, Bconstr=NULL, 
    adjX.constr=TRUE, adList=FALSE, it.j=10, myeps=NULL, ...)

ncross.rq.fitXBsparse(y, x, B=NULL, X=NULL, taus, monotone=FALSE, concave=FALSE,
    nomiBy=NULL, byVariabili=NULL, ndx=10, deg=3, dif=3, lambda=0, eps=.0001, 
    var.pen=NULL, penMatrix=NULL, lambda.ridge=0,  dropcList=FALSE, decomList=FALSE, 
    vcList=FALSE, dropvcList=FALSE, centerList=FALSE, ridgeList=FALSE, 
    ps.matrix.list=FALSE, colmeansB=NULL, Bconstr=NULL, adjX.constr=TRUE, 
    adList=FALSE, it.j=10, myeps=NULL, ...)
    

ncross.rq.fitX(y, X = NULL, taus, adjX.constr=TRUE, lambda.ridge = 0, 
    eps = 1e-04, ...) 
    

gcrq.rq.cv(y, B, X, taus, monotone, concave, ndx, lambda, deg, dif, var.pen=NULL, 
    penMatrix=NULL, lambda.ridge=0, dropcList=FALSE, decomList=FALSE, 
    vcList=vcList, dropvcList=FALSE, nfolds=10, foldid=NULL, eps=.0001, 
    sparse=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncross.rq.fitXB_+3A_y">y</code></td>
<td>
<p>the responses vector. see <code><a href="#topic+gcrq">gcrq</a></code>
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_x">x</code></td>
<td>

<p>the covariate supposed to have a nonlinear relationship.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_b">B</code></td>
<td>

<p>the B-spline basis.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_x">X</code></td>
<td>

<p>the design matrix for the linear parameters.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_taus">taus</code></td>
<td>

<p>the percentiles of interest.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_monotone">monotone</code></td>
<td>

<p>numerical value (-1/0/+1) to define a non-increasing, unconstrained, and non-decreasing flexible fit, respectively. 
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_concave">concave</code></td>
<td>

<p>numerical value (-1/0/+1) to possibly define concave or convex fits. 
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_nomiby">nomiBy</code></td>
<td>

<p>useful for VC models (when <code>B</code> is not provided).
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_byvariabili">byVariabili</code></td>
<td>

<p>useful for VC models (when <code>B</code> is not provided).
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_ndx">ndx</code></td>
<td>

<p>number of internal intervals within the covariate range, see <code>ndx</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_deg">deg</code></td>
<td>

<p>spline degree, see <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_dif">dif</code></td>
<td>

<p>difference order of the spline coefficients in the penalty term.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_lambda">lambda</code></td>
<td>

<p>smoothing parameter value(s), see <code>lambda</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_eps">eps</code></td>
<td>

<p>tolerance value.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_var.pen">var.pen</code></td>
<td>

<p>Varying penalty, see <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_penmatrix">penMatrix</code></td>
<td>

<p>Specified penalty matrix, see <code>pen.matrix</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_lambda.ridge">lambda.ridge</code></td>
<td>

<p>a (typically very small) value, see <code>lambda.ridge</code> <code><a href="#topic+gcrq">gcrq</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_dropclist">dropcList</code></td>
<td>

<p>see <code>dropc</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_decomlist">decomList</code></td>
<td>

<p>see <code>decompose</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_vclist">vcList</code></td>
<td>

<p>to indicate if the smooth is VC or not,  see <code>by</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_dropvclist">dropvcList</code></td>
<td>

<p>see <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_centerlist">centerList</code></td>
<td>

<p>see <code>center</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_ridgelist">ridgeList</code></td>
<td>

<p>see <code>ridge</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_ps.matrix.list">ps.matrix.list</code></td>
<td>

<p>nothing relevant for the user.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_colmeansb">colmeansB</code></td>
<td>

<p>see <code>center</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_bconstr">Bconstr</code></td>
<td>
<p>see <code>constr.fit</code> in <code><a href="#topic+ps">ps</a>.</code>
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_foldid">foldid</code></td>
<td>

<p>vector (optional) to perform cross validation, see the same arguments in <code><a href="#topic+gcrq">gcrq</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_nfolds">nfolds</code></td>
<td>

<p>number of folds for crossvalidation, see the same arguments in <code><a href="#topic+gcrq">gcrq</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_cv">cv</code></td>
<td>

<p>returning cv scores; see the same arguments in <code><a href="#topic+gcrq">gcrq</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_adjx.constr">adjX.constr</code></td>
<td>
<p>logical to shift the linear covariates. Appropriate only with linear terms.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_adlist">adList</code></td>
<td>
<p>see <code>ad</code> in <code><a href="#topic+ps">ps</a></code>.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_it.j">it.j</code></td>
<td>
<p>Ignore.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_myeps">myeps</code></td>
<td>
<p>Ignore.
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_sparse">sparse</code></td>
<td>
<p>logical, meaning if sparse computations have to be used. 
</p>
</td></tr>
<tr><td><code id="ncross.rq.fitXB_+3A_...">...</code></td>
<td>

<p>optional.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are called by <code><a href="#topic+gcrq">gcrq</a></code> to fit growth charts based on regression 
quantiles with non-crossing and monotonicity restrictions. The computational methods are based on the package 
quantreg by R. Koenker and details are described in the reference paper.
</p>


<h3>Value</h3>

<p>A list of fit information.
</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcrq">gcrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##See ?gcrq
</code></pre>

<hr>
<h2 id='plot.gcrq'>
Plot method for gcrq objects
</h2><span id='topic+plot.gcrq'></span>

<h3>Description</h3>

<p>Displaying the estimated growth charts from a <code>gcrq</code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcrq'
plot(x, term=NULL, add = FALSE, res = FALSE, conf.level=0, axis.tau=FALSE, 
   interc=TRUE, se.interc=FALSE, legend = FALSE, select.tau, deriv = FALSE, 
   cv = FALSE, transf=NULL, lambda0=FALSE, shade=FALSE, overlap=NULL, rug=FALSE, 
   overall.eff=TRUE, grid=NULL, smoos=NULL, split=FALSE, shift=0, type=c("sandw","boot"),
   n.points=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gcrq_+3A_x">x</code></td>
<td>

<p>a fitted <code>"gcrq"</code> object.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_term">term</code></td>
<td>

<p>the variable name or its index in the formula entering the model. Can be vector. Both linear ad spline terms (i.e. included in the model via <code>ps</code>) can be specified and relevant fitted quantile curves (as optionally specified by <code>select.tau</code>) will be plotted. If the model includes both linear and smooth terms, the smooth terms are counted and drawn *first*: therefore if the model formula is <code>y~z+ps(x)</code>, <code>term=1</code> refers to the smooth term. If <code>NULL</code>, all smooth terms are plotted according to the <code>split</code> argument.
If the model includes multiple quantile curves and <code>axis.tau=TRUE</code>, <code>term=1</code> refers to the model intercept (if in the model). The variable name should be reported within 'ps()', e.g. <code>'ps(age)'</code> regardless of additional arguments
specified in <code>ps</code>.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_interc">interc</code></td>
<td>

<p>Should the smooth term be plotted along with the model intercept (provided it is included in the model)? Of course such argument is ignored if the smooth term has been called via <code>ps(, dropc=FALSE)</code> and the plot always includes implicitly the &lsquo;intercept&rsquo;. Note that <code>interc=TRUE</code> is requested to display the noncrossing curves (if multiple quantile curves are being plotted).  
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_se.interc">se.interc</code></td>
<td>

<p>logical. If <code>TRUE</code> the standard errors of fitted quantile curves account for uncertainty of the model intercept (provided it is included in the model). If <code>FALSE</code>, then the uncertainty relates purely to the (usually centred) smooth itself. Ignored if <code>conf.level=0</code>.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_add">add</code></td>
<td>

<p>logical. If <code>TRUE</code> the fitted quantile curves are added on the current plot.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_res">res</code></td>
<td>

<p>logical. If <code>TRUE</code> &lsquo;partial residuals&rsquo; are also displayed on the plot. Borrowing terminology from GLM, partial residuals for covariate 
<code class="reqn">X_j</code> are defined as <br /> fitted values corresponding to <code class="reqn">X_j</code> + residuals (from the actual fit). <br /> If there is a single covariate, the partial residuals correspond to observed data. If multiple quantile curves have been estimated, the fitted values coming from the &lsquo;middle&rsquo; quantile curve are employed to compute the partial residuals. &lsquo;Middle&rsquo; means 'corresponding to the <code class="reqn">\tau_k</code> closest to 0.50'. I don't know if that is the best choice.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_conf.level">conf.level</code></td>
<td>

<p>logical. If larger than zero, pointwise confidence intervals for the fitted quantile curve are also shown (at the confidence level specified by <code>conf.level</code>). Such confidence intervals are independent of the possible intercept accounted for via the <code>intercept</code> argument. See <code>type</code>
to select different methods (bootstrap or sandwich) to compute the standard errors. 
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_axis.tau">axis.tau</code></td>
<td>

<p>logical. If <code>TRUE</code>, the estimated coefficient <code>term</code> is plotted against the probability values. This graph could be useful if the model has been estimated at several <code>tau</code> values. 
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_legend">legend</code></td>
<td>

<p>logical. If <code>TRUE</code> a legend is drawn on on the right side of the plot.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_select.tau">select.tau</code></td>
<td>

<p>an optional numeric vector to draw only some of the fitted quantiles. Percentile values or integers 1 to <code>length(tau)</code> may be supplied. 
</p>
</td></tr>                                                                           
<tr><td><code id="plot.gcrq_+3A_deriv">deriv</code></td>
<td>

<p>logical. If <code>TRUE</code> the first derivative of the fitted curves are displayed.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_cv">cv</code></td>
<td>

<p>logical. If <code>TRUE</code> and the <code>"gcrq"</code> object contains a single smooth term wherein lambda has been selected via CV, then 
the cross-validation scores against the lambda values are plotted.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_transf">transf</code></td>
<td>

<p>An optional character string (with <code>"y"</code> as argument) meaning a function to apply to the predicted values (and possibly residuals) 
before plotting. E.g. <code>"(exp(y)-0.1)"</code>. If <code>NULL</code> (default) it is taken as the inverse of function <code>transf</code> (*if*) supplied in <code>gcrq</code>. See argument <code>"transf"</code> in <code>gcrq()</code>. If <code>transf</code> has been specified in <code>gcrq()</code>, use <code>transf="y"</code> to force plotting on the transformed scale, i.e. without back transforming.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_lambda0">lambda0</code></td>
<td>

<p>logical. If <code>cv=TRUE</code>, should the CV plot include also the first CV value? Usually the first CV value is at lambda=0, 
and typically it is much bigger than the other values making the plot not easy to read. Default to <code>FALSE</code> not to display the
first CV value in the plot.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_shade">shade</code></td>
<td>

<p>logical. If <code>TRUE</code> and <code>conf.level</code>&gt;0, the pointwise confidence intervals are portrayed via shaded areas.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_overlap">overlap</code></td>
<td>

<p>NULL or numeric (scalar or vector). If provided and different from <code>NULL</code>, it represents the abscissa values (on the covariate scale) where the legends (i.e. the probability values) of each curve are set. It will be recycled, if its length differs from the number of quantile curves. If unspecified (i.e. <code>overlap=NULL</code>), the legends are placed outside the fitted lines on the right side. If specified, <code>legend=TRUE</code> is implicitly assumed.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_rug">rug</code></td>
<td>

<p>logical. If <code>TRUE</code>, the covariate distribution is displayed as a rug plot at the foot of the plot. Default to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_overall.eff">overall.eff</code></td>
<td>

<p>logical. If the smooth term has been called via <code>ps(.., decom=TRUE)</code>, by specifying <code>overall.eff=TRUE</code> the overall smooth effect is drawn, otherwise only the penalized part is portrayed (always <em>without</em> intercept).
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_grid">grid</code></td>
<td>

<p>if provided, a grid of horizontal and vertical lines is drawn. <code>grid</code> has to be a list with the following components <code>x,y,col,lty,lwd</code>. 
If <code>x</code> (<code>y</code>) is a vector, the vertical (horizontal) lines are drawn at these locations. If <code>x</code> (<code>y</code>) is a scalar, the vertical (horizontal) lines are drawn at <code>x</code> (<code>y</code>) equispaced values. <code>col, lty,lwd</code> refer to the lines to be drawn.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_smoos">smoos</code></td>
<td>

<p>logical, indicating if the residuals (provided that <code>res=TRUE</code>) will be drawn using a <em>smoothed</em> scatterplot. If <code>NULL</code> (default) the smoothed scatterplot will be employed when the number of observation is larger than 10000.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_split">split</code></td>
<td>

<p>logical. If there are multiple terms (both smooth and linear) and <code>split=TRUE</code>, <code>plot.gcrq()</code> tries to split the plotting area in 2 columns and number of rows depending on the number of smooths. If <code>split=FALSE</code>, the plots are produced on the current device according to the current graphics settings. Ignored if there is single smooth term. 
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_shift">shift</code></td>
<td>

<p>Numerical value(s) to be added to the curve(s) to be plotted. If vector with length equal to the number of quantile curves to plot, the <code>shift[j]</code> is added to the jth quantile curve. 
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_type">type</code></td>
<td>

<p>If <code>conf.level&gt;0</code>, which covariance matrix should be used to compute and to portray the pointwise confidence intervals? <code>'boot'</code> means case-resampling bootstrap (see <code>n.boot</code> in <code>gcrq()</code>, <code>'sandw'</code> mean via the sandwich formula.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_n.points">n.points</code></td>
<td>

<p>On how many values the plotted lines should rely on? If <code>NULL</code>, 100 values which suffice most of times. Increasing <code>n.points</code> can be useful when adaptive smoothing is used.
</p>
</td></tr>
<tr><td><code id="plot.gcrq_+3A_...">...</code></td>
<td>

<p>Additional graphical parameters:<br /> 
<code>xlab</code>, <code>ylab</code>, <code>ylim</code>, and <code>xlim</code> (effective when <code>add=FALSE</code>);<br />
<code>lwd</code>, <code>lty</code>, and <code>col</code> for the fitted quantile lines; <code>col&lt;0</code> means color palette for the different curves; <br />
<code>cex</code> and <code>text.col</code> for the legend (if <code>legend=TRUE</code> or <code>overlap</code> is specified); <br />
<code>cex.p</code>, <code>col.p</code>, and <code>pch.p</code> for the points (if <code>res=TRUE</code>).<br />
When <code>axis.tau=TRUE</code>, all arguments accepted by <code>plot()</code>, <code>points()</code>, <code>matplot()</code>, and <code>matpoints()</code> but <code>pch, type, xlab, ylab, lty</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a &quot;gcrq&quot; object and diplays the fitted quantile curves as a function of the covariate specified in <code>term</code>. If <code>conf.level</code>&gt;0 pointwise confidence intervals are also displayed. When the object contains the component <code>cv</code>, <code>plot.gcrq</code> can display cross-validation scores against the lambda values, see argument <code>cv</code>. If a single quantile curve is being displayed, the default 'ylab' includes the relevant edf value (leaving out the basis intercept). If <code>axis.tau=TRUE</code> and the fit includes several quantile curves, <code>plot.gcrq()</code> portrays the estimated coefficients versus the probability values. If <code>term</code> refers to a categorical variable, the point estimates against the categories are plotted (<code>conf.level</code> is ignored).
</p>


<h3>Value</h3>

<p>The function simply generates a new plot or adds fitted curves to an existing one. 
</p>


<h3>Note</h3>

<p>Plotting non-crossing curves could depend on the arguments 'interc' and 'shift', in turn depending on how the model has been specified. Take care about that! 
</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcrq">gcrq</a></code>, <code><a href="#topic+predict.gcrq">predict.gcrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## use the fits from ?gcrq
#The additive model
plot(o, res=TRUE, col=2, conf.level=.9, shade=TRUE, split=TRUE)


par(mfrow=c(2,2))
plot(m5, select.tau=c(.1,.5,.9), overlap=0.6, legend=TRUE)
plot(m5, grid=list(x=8,y=5), lty=1) #a 8 times 5 grid.. 
plot(m7, cv=TRUE) #display CV score versus lambda values
plot(m7, res=TRUE, grid=list(x=5, y=8), col=4) #fitted curves at the best lambda value


## End(Not run)

</code></pre>

<hr>
<h2 id='predict.gcrq'>
Prediction for &quot;gcrq&quot; objects
</h2><span id='topic+predict.gcrq'></span>

<h3>Description</h3>

<p>Takes a &quot;gcrq&quot; objects and computes fitted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcrq'
predict(object, newdata, se.fit=FALSE, transf=NULL, xreg, 
                      type=c("sandw","boot"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gcrq_+3A_object">object</code></td>
<td>

<p>a fitted <code>"gcrq"</code> object.
</p>
</td></tr>
<tr><td><code id="predict.gcrq_+3A_newdata">newdata</code></td>
<td>

<p>a dataframe including <em>all</em> the covariates of the model. The smooth term is represented by a covariate 
and proper basis functions will be build accordingly. If omitted, the fitted values are used. Ignored if <code>xreg</code> is provided. 
</p>
</td></tr>
<tr><td><code id="predict.gcrq_+3A_se.fit">se.fit</code></td>
<td>

<p>logical. If <code>TRUE</code>, standard errors of the fitted quantiles are computed using the bootstrap or the sandwich covariance matrix, according to the argument <code>type</code>.
</p>
</td></tr>
<tr><td><code id="predict.gcrq_+3A_transf">transf</code></td>
<td>

<p>An optional character string (with <code>"y"</code> as argument) meaning a function to apply to the predicted values. E.g. <code>"(exp(y)-0.1)"</code>. 
If <code>NULL</code> (default) it is taken as the inverse of function <code>transf</code> (*if*) supplied in <code>gcrq</code>. The standard errors (provided <code>se.fit=TRUE</code> has been set) are adjusted accordingly via the Delta method. See argument <code>"transf"</code> in <code>gcrq()</code>. If <code>transf</code> has been specified in <code>gcrq()</code>, use <code>transf="y"</code> to force predictions on the transformed scale, i.e. without back transforming.
</p>
</td></tr>
<tr><td><code id="predict.gcrq_+3A_xreg">xreg</code></td>
<td>

<p>the design matrix for which predictions are requested. If provided, <code>xreg</code> has to include the basis functions of the B-spline.
</p>
</td></tr>
<tr><td><code id="predict.gcrq_+3A_type">type</code></td>
<td>

<p>If <code>se.fit=TRUE</code>, which cov matrix should be used? <code>'boot'</code> means case-resampling bootstrap (see <code>n.boot</code> in <code>gcrq()</code>), <code>'sandw'</code> mean via the sandwich formula.
</p>
</td></tr>
<tr><td><code id="predict.gcrq_+3A_...">...</code></td>
<td>
<p> arguments passed to other functions </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.gcrq</code> computes fitted quantiles as a function of observations included in <code>newdata</code> or <code>xreg</code>. 
Either <code>newdata</code> or <code>xreg</code> have to be supplied, but <code>newdata</code> is ignored 
when <code>xreg</code> is provided.
</p>


<h3>Value</h3>

<p>If <code>se.fit=FALSE</code>, a matrix of fitted values with number of rows equal to number of rows of input data 
and number of columns depending on the number of fitted quantile curves (i.e length of <code>taus</code>). If <code>se.fit=TRUE</code>, a list of matrices (fitted values and standard errors).
</p>


<h3>Author(s)</h3>

<p>Vito M.R. Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcrq">gcrq</a></code>, <code><a href="#topic+plot.gcrq">plot.gcrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##see ?gcrq
## predict(m1, newdata=data.frame(x=c(.3,.7)))


</code></pre>

<hr>
<h2 id='print.gcrq'> Print method for the gcrq class </h2><span id='topic+print.gcrq'></span>

<h3>Description</h3>

<p>Printing the most important feautures of a gcrq model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcrq'
print(x, digits = max(3, getOption("digits") - 4), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gcrq_+3A_x">x</code></td>
<td>
<p> object of class <code>gcrq</code> </p>
</td></tr>
<tr><td><code id="print.gcrq_+3A_digits">digits</code></td>
<td>
<p> number of digits to be printed </p>
</td></tr>
<tr><td><code id="print.gcrq_+3A_...">...</code></td>
<td>
<p> arguments passed to other functions </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.gcrq">summary.gcrq</a></code></p>

<hr>
<h2 id='ps'>
Specifying a smooth term in the gcrq formula.
</h2><span id='topic+ps'></span>

<h3>Description</h3>

<p>Function used to define the smooth term (via P-splines) within the gcrq formula. 
The function actually does not evaluate a (spline) smooth, but simply it 
passes relevant information to proper fitter functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps(..., lambda = -1, d = 3, by=NULL, ndx = NULL, deg = 3, knots=NULL,
    monotone = 0, concave = 0, var.pen = NULL, pen.matrix=NULL, dropc=TRUE, 
    center=TRUE, K=NULL, decom=FALSE, constr.fit=TRUE, shared.pen=FALSE, 
    st=FALSE, ad=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ps_+3A_...">...</code></td>
<td>

<p>The covariate supposed to have a nonlinear relationship with the quantile curve(s) being estimated. A B-spline is built, and a (difference) penalty is applied. In growth charts this variable is typically the age. 
If the covariate is a factor, category-specific coefficients are estimated subject to a lasso penalty. See the last example in ?gcrq. A matrix of (continuous) covariates can be also supplied to perfom variable selection (among its columns).
</p>
</td></tr>
<tr><td><code id="ps_+3A_lambda">lambda</code></td>
<td>

<p>A supplied smoothing parameter for the smooth term. If it is negative scalar, the smoothing parameter is estimated iteratively as discussed in Muggeo et al. (2021). If a positive scalar, it represents the actual smoothing parameter. If it is a vector, cross validation is performed to select the &lsquo;best&rsquo; value. See Details in <code><a href="#topic+gcrq">gcrq</a></code>. 
</p>
</td></tr>
<tr><td><code id="ps_+3A_d">d</code></td>
<td>

<p>The difference order of the penalty. Default to 3 Ignored if <code>pen.matrix</code> is supplied. 
</p>
</td></tr>
<tr><td><code id="ps_+3A_by">by</code></td>
<td>

<p>if different from <code>NULL</code>, a numeric or factor variable of the same dimension as the covariate in <code>...</code> If numeric the elements multiply the smooth (i.e. a varying coefficient model); if factor, a smooth is fitted for each factor level. Usually the variable <code>by</code> is also included as main effect in the formula, see examples in <code><a href="#topic+gcrq">gcrq</a></code>. When <code>by</code> includes a factor, the formula should include the model intecept, i.e. <code>y~g+ps(x,by=g)</code> and not <code>y~ 0+g+ps(x,by=g)</code>. 
</p>
</td></tr>
<tr><td><code id="ps_+3A_ndx">ndx</code></td>
<td>

<p>The number of intervals of the covariate range used to build the B-spline basis. Non-integer values are rounded by <code>round()</code>. If <code>NULL</code>, default, it is taken <code class="reqn">min(n/4,9)</code> (versions &lt;=1.1-0 it was <code class="reqn">min(n/4,40)</code>, the empirical rule of Ruppert). It could be reduced further (but no less than 5 or 6, say) if the sample size is not large and the default value leads to some error in the fitting procedure, see section <code>Note</code> in <code><a href="#topic+gcrq">gcrq</a></code>. Likewise, if the underlying relationship is strongly nonlinear, <code>ndx</code> could be increased. The returned basis wil have '<code>ndx</code>+<code>deg</code>-<code>1</code>' (if <code>dropc=TRUE</code>) basis functions.
</p>
</td></tr>
<tr><td><code id="ps_+3A_deg">deg</code></td>
<td>

<p>The degree of the spline polynomial. Default to 3. The B-spline basis is composed by <code>ndx</code>+<code>deg</code> basis functions and if <code>dropc=TRUE</code> the first column is removed for identifiability (and the model intercept is estimated without any penalty). 
</p>
</td></tr>
<tr><td><code id="ps_+3A_knots">knots</code></td>
<td>

<p>The knots locations. If <code>NULL</code>, equispaced knots are set. Note if predictions outside the observed covariate range have to be computed (via <code>predict.gcrq</code>), the knots should be set enought outside the observed range. 
</p>
</td></tr>
<tr><td><code id="ps_+3A_monotone">monotone</code></td>
<td>

<p>Numeric value to set up monotonicity restrictions on the first derivative of fitted smooth function
</p>

<ul>
<li><p>  '0' = no constraint (default);
</p>
</li>
<li><p>  '1' = non-decreasing smooth function;
</p>
</li>
<li><p> '-1' = non-increasing smooth function.
</p>
</li></ul>

</td></tr>
<tr><td><code id="ps_+3A_concave">concave</code></td>
<td>

<p>Numeric value to set up monotonicity restrictions on the second derivative of fitted smooth function
</p>

<ul>
<li><p>  '0' = no constraint (default);
</p>
</li>
<li><p>  '1' = concave smooth function;
</p>
</li>
<li><p> '-1' = convex smooth function.
</p>
</li></ul>

</td></tr>
<tr><td><code id="ps_+3A_var.pen">var.pen</code></td>
<td>

<p>A character indicating the varying penalty. See Details.
</p>
</td></tr>
<tr><td><code id="ps_+3A_pen.matrix">pen.matrix</code></td>
<td>

<p>if provided, a penalty matrix <code class="reqn">A</code>, say, such that the penalty in the objective function, apart from the smoothing parameter, is <code class="reqn">||Ab||_1</code> where <code class="reqn">b</code> is the spline coefficient vector being penalized.
</p>
</td></tr>
<tr><td><code id="ps_+3A_dropc">dropc</code></td>
<td>

<p>logical. Should the first column of the B-spline basis be dropped for the basis identifiability? Default to <code>TRUE</code>. Note, if <code>dropc=FALSE</code> is set, 
it is necessary to omit the model intercept AND not to center the basis, i.e. <code>center=FALSE</code>. Alternatively, both a full basis and the model intercept may be included by adding a small ridge penalty via <code>lambda.ridge&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="ps_+3A_center">center</code></td>
<td>

<p>logical. If <code>TRUE</code> the smooth effects are 'centered' over the covariate values, i.e. <code class="reqn">\sum_i \hat{f}(x_i)=0</code>.
</p>
</td></tr>
<tr><td><code id="ps_+3A_k">K</code></td>
<td>

<p>A scalar tuning the selection of wiggliness of the smoothed curve when <code class="reqn">\lambda</code> has to be estimated (i.e. <code>lambda&lt;0</code> is set). The larger <code>K</code>, the smoother the curve. Simulations suggest <code>K=2</code> for the smoothing, and <code>K=log(n/p^(2/3))</code> for variable selection and random intercepts (<code>p</code> is the number of variables or number of subjects). See details.
</p>
</td></tr>
<tr><td><code id="ps_+3A_decom">decom</code></td>
<td>

<p>logical. If <code>TRUE</code>, the B-spline <code class="reqn">B</code> (with a <code class="reqn">d</code> order difference penalty) is decomposed into truncated power functions namely unpenalized polynomial terms up to degree d-1, and additional terms <code class="reqn">Z= B D'(DD')^{-1}</code>. Only the coefficients of <code class="reqn">Z</code> are penalized via an identity matrix, i.e. a lasso penalty. Currently <code>decom=TRUE</code> does not work with shape (monotonicity and concavity) restrictions and noncrossing constraints.
</p>
</td></tr>
<tr><td><code id="ps_+3A_constr.fit">constr.fit</code></td>
<td>

<p>logical. If <code>monotone</code> or <code>concave</code> are different from 0, <code>constr.fit=TRUE</code> means that these constraints are set on the fitted quantiles rather than on the spline coefficients.
</p>
</td></tr>
<tr><td><code id="ps_+3A_shared.pen">shared.pen</code></td>
<td>

<p>logical. If <code>TRUE</code> and the smooth is a VC term with a factor specified in <code>by</code>, the smooths in each level of the factor share the same smoothing parameter.
</p>
</td></tr>
<tr><td><code id="ps_+3A_st">st</code></td>
<td>

<p>logical. If <code>TRUE</code> the variable(s) are standardized via the <code>scale()</code> function. Typically used for variable selection via lasso, i.e. when a matrix of covariates is passed in <code>ps()</code>.
</p>
</td></tr>
<tr><td><code id="ps_+3A_ad">ad</code></td>
<td>

<p>a positive number to carry out a form of <em>adaptive</em> lasso. More specifically, at each step of the iterative algorithm, the penalty is <code class="reqn">\lambda\sum_jw_j|\beta_j|</code> where <code class="reqn">w_j=|\tilde{\beta}_j|^\mathtt{-ad}</code> and <code class="reqn">\tilde{\beta}_j</code> are estimates coming from the previous iteration with a different value of  <code class="reqn">\lambda</code>. <code>ad=0</code> means the standard lasso and <code>ad=1</code> adaptive lasso (with weights updated during the iterative process. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a numeric variable has been supplied, <code>ps()</code> builds a B-spline basis with number of columns equal to <code>ndx+deg</code> (or <code>length(knots)-deg-1</code>). However, unless <code>dropc=FALSE</code> is specified, the first column is removed for identifiability, and the spline coefficients are penalized via differences of order <code>d</code>; <code>d=0</code> leads to a penalty on the coefficients themselves.  If <code>pen.matrix</code> is supplied, <code>d</code> is ignored. Since versions 1.5-0 and 1.6-0, a factor or matrix can be supplied.
</p>
<p><code>lambda</code> is the tuning parameter, fixed or to be estimated. When <code>lambda</code>=0 an unpenalized (and typically wiggly) fit is obtained, and as lambda increases the curve gets smoother till a <code>d-1</code> degree polynomial. At 'intermediate' lambda values, the fitted curve is a <em>piecewise</em> polynomial of degree <code>d-1</code>.
</p>
<p>It is also possible to put a varying penalty via the argument <code>var.pen</code>. Namely for a 
constant smoothing (<code>var.pen=NULL</code>) the penalty is <code class="reqn">\lambda\sum_k |\Delta^d_k|</code> where 
<code class="reqn">\Delta^d_k</code> is the k-th difference (of order <code>d</code>) of the spline coefficients. For instance if <code class="reqn">d=1</code>, 
<code class="reqn">|\Delta^1_k|=|b_k-b_{k-1}|</code> where the <code class="reqn">b_k</code>  are the spline coefficients.
When a varying penalty is set, the penalty becomes <code class="reqn">\lambda\sum_k |\Delta_k^d| w_k</code> where the weights <code class="reqn">w_k</code> depend on <code>var.pen</code>; for instance <code>var.pen="((1:k)^2)"</code> results in <code class="reqn">w_k=k^2</code>. See models <code>m6</code> and <code>m6a</code> in the examples of <code><a href="#topic+gcrq">gcrq</a></code>.
</p>
<p>If <code>decom=TRUE</code>, the smooth can be plotted with or without the fixed part, see <code>overall.eff</code> in the function <code><a href="#topic+plot.gcrq">plot.gcrq</a></code>.
</p>


<h3>Value</h3>

<p>The function simply returns the covariate with added attributes relevant to 
smooth term.
</p>


<h3>Note</h3>

<p>For shape-constrained fits, use <code>constr.fit=FALSE</code> only if you are using a single full and uncentred basis, namely something like <br /> <code>gcrq(y~0+ps(x, center=FALSE, dropc=FALSE, monotone=1, constr.fit=FALSE),..)</code>.
</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo
</p>


<h3>References</h3>

<p>Muggeo VMR, Torretta F, Eilers PHC, Sciandra M, Attanasio M (2021).
Multiple smoothing parameters selection in additive regression quantiles,
<em>Statistical Modelling</em>, 21, 428-448.
</p>
<p>For a general discussion on using B-spline and penalties in regression model see
</p>
<p>Eilers PHC, Marx BD. (1996) Flexible smoothing with B-splines and penalties. 
Statistical Sciences, 11:89-121.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcrq">gcrq</a></code>, <code><a href="#topic+plot.gcrq">plot.gcrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##see ?gcrq

##gcrq(y ~ ps(x),..) #it works (default: center = TRUE, dropc = TRUE)
##gcrq(y ~ 0 + ps(x, center = TRUE, dropc = FALSE)) #it does NOT work
##gcrq(y ~ 0 + ps(x, center = FALSE, dropc = FALSE)) #it works

</code></pre>

<hr>
<h2 id='SiChildren'>
Age, height and weight in a sample of Italian children
</h2><span id='topic+SiChildren'></span>

<h3>Description</h3>

<p>Age, height and weight in a sample of 1424 Italian children born in Sicily in the eighties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SiChildren")</code></pre>


<h3>Format</h3>

<p>A data frame with 1424 observations on the following 3 variables.
</p>

<dl>
<dt><code>age</code></dt><dd><p>age in years</p>
</dd>
<dt><code>height</code></dt><dd><p>child height (in centimeter) </p>
</dd>
<dt><code>weight</code></dt><dd><p>child weight (in kilo)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data refer on the usual antropometric measures of Italian boys born in Sicily in the first years of 80s. Data have been kindly provided by prof M. Chiodi
</p>


<h3>Source</h3>

<p>Gattuccio F., and Pirronello S., and Chiodi M (1988)
Possibilita' di identificazione di tipologie evolutive del periodo puberale: proposta di una metodica pr finalita' predittive, <em>Rivista di pediatria preventiva e sociale nipiologia</em>, 189-199
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SiChildren)
## see the package vignette for an example using such dataset
</code></pre>

<hr>
<h2 id='summary.gcrq'>
Summarizing model fits for growth charts regression quantiles
</h2><span id='topic+summary.gcrq'></span>

<h3>Description</h3>

<p>summary and print methods for class <code>gcrq</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcrq'
summary(object, type=c("sandw","boot"), digits = max(3, getOption("digits") - 3), 
    signif.stars =getOption("show.signif.stars"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gcrq_+3A_object">object</code></td>
<td>

<p>An object of class <code>"gcrq"</code>.
</p>
</td></tr>
<tr><td><code id="summary.gcrq_+3A_type">type</code></td>
<td>

<p>Which covariance matrix should be used to compute the estimate standard errors? <code>'boot'</code> means case-resampling bootstrap (see <code>n.boot</code> in <code>gcrq()</code>), <code>'sandw'</code> mean via the sandwich formula.
</p>
</td></tr>
<tr><td><code id="summary.gcrq_+3A_digits">digits</code></td>
<td>

<p>controls number of digits printed in output.
</p>
</td></tr>
<tr><td><code id="summary.gcrq_+3A_signif.stars">signif.stars</code></td>
<td>

<p>Should significance stars be printed? 
</p>
</td></tr>
<tr><td><code id="summary.gcrq_+3A_...">...</code></td>
<td>

<p>further arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.gcrq</code> returns some information on the fitted quantile curve at different probability values, such as the estimates, standard errors, values of check (objective) function values at solution. Currently there is no <code>print.summary.gcrq</code> method, so 
<code>summary.gcrq</code> itself prints results.
</p>
<p>The SIC returned by <code>print.gcrq</code> and <code>summary.gcrq</code> is computed as <code class="reqn">\log(\rho_\tau/n) + \log(n)  edf/(2 n)</code>, where <code class="reqn">\rho_tau</code> is the usual asymmetric sum of residuals (in absolute value). For multiple <code class="reqn">J</code> quantiles it is <code class="reqn">\log(\sum_\tau\rho_\tau/(n J)) + \log(n J)  edf/(2 n J)</code>. Note that computation of SIC in <code><a href="#topic+AIC.gcrq">AIC.gcrq</a></code> relies on the Laplace assumption for the response. 
</p>


<h3>Author(s)</h3>

<p>Vito M.R. Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcrq">gcrq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see ?gcrq
##summary(o)

</code></pre>

<hr>
<h2 id='vcov.gcrq'>
Variance-Covariance Matrix for a Fitted 'gcrq' Model
</h2><span id='topic+vcov.gcrq'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the parameter estimates of a fitted gcrq model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcrq'
vcov(object, term, type=c("sandw","boot"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.gcrq_+3A_object">object</code></td>
<td>

<p>a fitted model object of class <code>"gcrq"</code> returned by <code>gcrq()</code>.
</p>
</td></tr>
<tr><td><code id="vcov.gcrq_+3A_term">term</code></td>
<td>

<p>if specified, the returned covariance matrix includes entries relevant to parameter estimates for that 'term' only. If missing, the returned matrices refer to all model parameter estimates. Currently <code>term</code> is not allowed. 
</p>
</td></tr>
<tr><td><code id="vcov.gcrq_+3A_type">type</code></td>
<td>

<p>Which cov matrix should be returned? <code>'boot'</code> means case-resampling bootstrap (see <code>n.boot</code> in <code>gcrq()</code>), <code>'sandw'</code> mean via the 
sandwich formula.
</p>
</td></tr>
<tr><td><code id="vcov.gcrq_+3A_...">...</code></td>
<td>

<p>additional arguments.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrap-based covariance matrix, i.e. <code>type="boot"</code>, is computable only if the object fit has been obtained by specifying <code>n.boot&gt;0</code> in <code>gcrq()</code>.
</p>


<h3>Value</h3>

<p>A list (its length equal the length of <code>tau</code> specified in <code>gcrq</code>) of square matrices. Namely the list includes the covariance matrices of the parameter estimates for each regression quantile curve.
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.gcrq">summary.gcrq</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
