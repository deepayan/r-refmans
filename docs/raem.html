<!DOCTYPE html><html lang="en"><head><title>Help for package raem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {raem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_element'><p>Add or remove an element from an existing <code>aem</code> object</p></a></li>
<li><a href='#aem'><p>Create an analytic element model</p></a></li>
<li><a href='#areasink'><p>Create a circular area-sink analytic element with specified recharge</p></a></li>
<li><a href='#capzone'><p>Calculate the capture zone of a well element</p></a></li>
<li><a href='#constant'><p>Create a constant-head analytic element</p></a></li>
<li><a href='#contours'><p>Plot contours of a state-variable of the analytic element model</p></a></li>
<li><a href='#dirflow'><p>Compute flow in the direction of a given angle</p></a></li>
<li><a href='#element_discharge'><p>Get the computed discharge from an element</p></a></li>
<li><a href='#flow'><p>Calculate flow variables</p></a></li>
<li><a href='#flow_through_line'><p>Calculate the total flow passing through a line</p></a></li>
<li><a href='#head_to_potential'><p>Convert hydraulic head to potential and vice versa</p></a></li>
<li><a href='#headareasink'><p>Create a head-specified area-sink analytic element</p></a></li>
<li><a href='#headlinesink'><p>Create a head-specified line-sink analytic element</p></a></li>
<li><a href='#headwell'><p>Create a analytic element of a well with a constant head</p></a></li>
<li><a href='#linesink'><p>Create a strength-specified line-sink analytic element</p></a></li>
<li><a href='#satthick'><p>Compute the saturated thickness</p></a></li>
<li><a href='#state-variables'><p>Calculate state-variables</p></a></li>
<li><a href='#tracelines'><p>Compute tracelines of particles</p></a></li>
<li><a href='#uniformflow'><p>Create an analytic element with uniform flow</p></a></li>
<li><a href='#well'><p>Create an analytic element of a constant-discharge well</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Analytic Element Modeling of Steady Single-Layer Groundwater
Flow</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A model of single-layer groundwater flow in steady-state
    under the Dupuit-Forchheimer assumption can be created by placing
    elements such as wells, area-sinks and line-sinks at arbitrary
    locations in the flow field. Output variables include hydraulic head
    and the discharge vector. Particle traces can be computed numerically
    in three dimensions. The underlying theory is described in Haitjema
    (1995) &lt;<a href="https://doi.org/10.1016%2FB978-0-12-316550-3.X5000-4">doi:10.1016/B978-0-12-316550-3.X5000-4</a>&gt; and references
    therein.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cneyens/raem">https://github.com/cneyens/raem</a>, <a href="https://cneyens.github.io/raem/">https://cneyens.github.io/raem/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cneyens/raem/issues">https://github.com/cneyens/raem/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>deSolve, graphics, parallel, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>isoband, knitr, rmarkdown, sf, terra, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'aem.R' 'areasink.R' 'constant.R' 'flow-variables.R'
'linesink.R' 'tracelines.R' 'plot.R' 'state-variables.R'
'uniformflow.R' 'utils.R' 'well.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-18 10:52:23 UTC; casne</td>
</tr>
<tr>
<td>Author:</td>
<td>Cas Neyens [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cas Neyens &lt;cas.neyens@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-23 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_element'>Add or remove an element from an existing <code>aem</code> object</h2><span id='topic+add_element'></span><span id='topic+remove_element'></span>

<h3>Description</h3>

<p><code><a href="#topic+add_element">add_element()</a></code> adds a new element to an <code>aem</code> object.
</p>
<p><code><a href="#topic+remove_element">remove_element()</a></code> removes an element from an <code>aem</code> object based on its name or type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_element(aem, element, name = NULL, solve = FALSE, ...)

remove_element(aem, name = NULL, type = NULL, solve = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_element_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="add_element_+3A_element">element</code></td>
<td>
<p>analytic element of class <code>element</code>.</p>
</td></tr>
<tr><td><code id="add_element_+3A_name">name</code></td>
<td>
<p>optional name of the element as character. Duplicate element names in <code>aem</code> are not allowed..</p>
</td></tr>
<tr><td><code id="add_element_+3A_solve">solve</code></td>
<td>
<p>logical, should the model be solved after adding or removing the element? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_element_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="add_element_+3A_type">type</code></td>
<td>
<p>class of the element(s) to remove. Either <code>name</code> or <code>type</code> should be specified in <code><a href="#topic+remove_element">remove_element()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>aem</code> model with the addition of <code>element</code> or with the removal of element(s). If <code>solve = TRUE</code>,
the model is solved using <code><a href="#topic+solve.aem">solve.aem()</a></code>. The name of the new element is taken from the <code>name</code> argument,
the object name or set to <code>element_1</code> with <code>1</code> being the index of the new element in the element list. See examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aem">aem()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- aem(k = 10, top = 10, base = 0, n = 0.2)
mnew &lt;- add_element(m, constant(xc = 0, yc = 1000, hc = 12), name = 'rf')

# if name not supplied, tries to obtain it from object name
rf &lt;- constant(xc = 0, yc = 1000, hc = 12)
mnew &lt;- add_element(m, rf)

# or else sets it sequentially from number of elements
mnew &lt;- add_element(m, constant(xc = 0, yc = 1000, hc = 12))


# add_element() adn remove_element() are pipe-friendly
mnew &lt;- aem(k = 10, top = 10, base = 0, n = 0.2) |&gt;
    add_element(rf, name = 'rf') |&gt;
    add_element(headwell(xw = 0, yw = 100, rw = 0.3, hc = 8),
                name = 'headwell', solve = TRUE)


# removing elements
mnew &lt;- remove_element(mnew, name = 'rf')
mnew &lt;- remove_element(mnew, type = 'headwell')

</code></pre>

<hr>
<h2 id='aem'>Create an analytic element model</h2><span id='topic+aem'></span><span id='topic+solve.aem'></span><span id='topic+plot.element'></span><span id='topic+plot.aem'></span>

<h3>Description</h3>

<p><code><a href="#topic+aem">aem()</a></code> creates an analytic element model to which elements can be added
</p>
<p><code><a href="#topic+solve.aem">solve.aem()</a></code> solves the system of equations as constructed by the elements in the <code>aem</code> model
</p>
<p><code><a href="#topic+plot.element">plot.element()</a></code> plots the location of an analytic element with point or line geometry.
</p>
<p><code><a href="#topic+plot.aem">plot.aem()</a></code> plots the locations of all analytic elements with a point or line geometry
in an <code>aem</code> object by calling <code><a href="#topic+plot.element">plot.element()</a></code> on them, or adds them to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aem(
  k,
  top,
  base,
  n,
  ...,
  type = c("variable", "confined"),
  verbose = FALSE,
  maxiter = 10
)

## S3 method for class 'aem'
solve(a, b, maxiter = 10, verbose = FALSE, ...)

## S3 method for class 'element'
plot(
  x,
  y = NULL,
  add = FALSE,
  pch = 16,
  cex = 0.75,
  use.widths = TRUE,
  col = "black",
  xlim,
  ylim,
  ...
)

## S3 method for class 'aem'
plot(x, y = NULL, add = FALSE, xlim, ylim, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aem_+3A_k">k</code></td>
<td>
<p>numeric, hydraulic conductivity of the aquifer.</p>
</td></tr>
<tr><td><code id="aem_+3A_top">top</code></td>
<td>
<p>numeric, top elevation of the aquifer.</p>
</td></tr>
<tr><td><code id="aem_+3A_base">base</code></td>
<td>
<p>numeric, bottom elevation of the aquifer.</p>
</td></tr>
<tr><td><code id="aem_+3A_n">n</code></td>
<td>
<p>numeric, effective porosity of the aquifer as a fraction of total unit volume. Used for determining flow velocities with <code><a href="#topic+velocity">velocity()</a></code>.</p>
</td></tr>
<tr><td><code id="aem_+3A_...">...</code></td>
<td>
<p>for <code>aem()</code>, objects of class <code>element</code>, or a single (named) list with <code>element</code> objects. Otherwise, ignored.</p>
</td></tr>
<tr><td><code id="aem_+3A_type">type</code></td>
<td>
<p>character specifying the type of flow in the aquifer, either <code>variable</code> (default) or <code>confined</code>. See details.</p>
</td></tr>
<tr><td><code id="aem_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if information during the solving process should be printed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aem_+3A_maxiter">maxiter</code></td>
<td>
<p>integer specifying the maximum allowed iterations for a non-linear solution. Defaults to 10. See details.</p>
</td></tr>
<tr><td><code id="aem_+3A_a">a</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="aem_+3A_b">b</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="aem_+3A_x">x</code></td>
<td>
<p><code>aem</code> object, or analytic element of class <code>element</code> to plot. If not a point or line geometry, nothing is plotted.</p>
</td></tr>
<tr><td><code id="aem_+3A_y">y</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="aem_+3A_add">add</code></td>
<td>
<p>logical, should the plot be added to the existing plot? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aem_+3A_pch">pch</code></td>
<td>
<p>numeric point symbol value, defaults to <code>16</code>. For a reference point, a value of <code>4</code> is used.</p>
</td></tr>
<tr><td><code id="aem_+3A_cex">cex</code></td>
<td>
<p>numeric symbol size value, defaults to <code>0.75</code>.</p>
</td></tr>
<tr><td><code id="aem_+3A_use.widths">use.widths</code></td>
<td>
<p>logical, if line elements with non-zero width are plotted, should they be plotted as polygons including
the width (<code>TRUE</code>; default) or as infinitesimally thin lines (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="aem_+3A_col">col</code></td>
<td>
<p>color of element. Defaults to <code>'black'</code>.</p>
</td></tr>
<tr><td><code id="aem_+3A_xlim">xlim</code></td>
<td>
<p>numeric, plot limits along the x-axis. Required if <code>add = FALSE</code>.</p>
</td></tr>
<tr><td><code id="aem_+3A_ylim">ylim</code></td>
<td>
<p>numeric, plot limits along the y-axis. Required if <code>add = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>type = 'variable'</code> allows for unconfined/confined flow, i.e. flow with variable saturated thickness. If <code>type = 'confined'</code>,
the saturated thickness is always constant and equal to the aquifer thickness. This results in a linear model when head-specified elements with
a resistance are used, whereas <code>type = 'variable'</code> would create a non-linear model in that case.
</p>
<p><code><a href="#topic+solve.aem">solve.aem()</a></code> is called on the <code>aem</code> object before it is returned by <code>aem()</code>, which solves the system of equations.
</p>


<h4>Solving</h4>

<p><code><a href="#topic+solve.aem">solve.aem()</a></code> sets up the system of equations, and calls <code><a href="base.html#topic+solve">solve()</a></code> to
solve. If head-specified elements are supplied, an element of class <code>constant</code> as
created by <code><a href="#topic+constant">constant()</a></code> (also called the reference point), should be supplied as well.
Constructing an <code>aem</code> object by a call to <code><a href="#topic+aem">aem()</a></code> automatically calls <code><a href="#topic+solve.aem">solve.aem()</a></code>.
</p>
<p>If the system of equations is non-linear, i.e. when the flow system is unconfined (variable
saturated thickness) and elements with hydraulic resistance are specified, a Picard iteration is entered.
During each Picard iteration step (outer iteration), the previously solved model parameters are used to set up and
solve a linear system of equations. The model parameters are then updated and the next outer iteration step is
entered, until <code>maxiter</code> iterations are reached. For an linear model, <code>maxiter</code> is ignored.
</p>



<h4>Plotting</h4>

<p>If the analytic element has a point geometry and has a collocation point
(e.g. <code><a href="#topic+headwell">headwell()</a></code>), that point is also plotted with <code>pch = 1</code>.
</p>

<p>A reference point (as created by <code><a href="#topic+constant">constant()</a></code>) is never plotted when plotting the model
as it is not a hydraulic feature. Area-sinks (as created by <code><a href="#topic+areasink">areasink()</a></code> or <code><a href="#topic+headareasink">headareasink()</a></code>)
are also never plotted as they would clutter the plot. These elements can be plotted by
calling <code>plot()</code> on them directly.
</p>


<h3>Value</h3>

<p><code><a href="#topic+aem">aem()</a></code> returns an object of class <code>aem</code> which is a list consisting of <code>k</code>, <code>top</code>, <code>base</code>, <code>n</code>,
a list containing all elements with the names of the objects specified in <code>...</code>, and a logical <code>solved</code>
indicating if the model is solved.
</p>
<p><code><a href="#topic+solve.aem">solve.aem()</a></code> returns the solved <code>aem</code> object, i.e. after finding the solution
to the system of equations as constructed by the contained elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_element">add_element()</a></code> <code><a href="#topic+contours">contours()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- 10
top &lt;- 10
base &lt;- 0
n &lt;- 0.2
TR &lt;- k * (top - base)

w &lt;- well(xw = 50, yw = 0, Q = 200)
rf &lt;- constant(xc = -500, yc = 0, h = 20)
uf &lt;- uniformflow(gradient = 0.002, angle = -45, TR = TR)
hdw &lt;- headwell(xw = 0, yw = 100, rw = 0.3, hc = 8)
ls &lt;- linesink(x0 = -200, y0 = -150, x1 = 200, y1 = 150, sigma = 1)

# Creating aem ----
m &lt;- aem(k, top, base, n, w, rf, uf, hdw, ls)

# or with elements in named list
m &lt;- aem(k, top, base, n,
         list('well' = w, 'constant' = rf, 'flow' = uf, 'headwell' = hdw, 'river' = ls),
         type = 'confined')

# Solving ----
m &lt;- solve(m)

# solving requires a reference point (constant) element if head-specified elements are supplied
try(
  m &lt;- aem(k = k, top = top, base = base, n = n, w, uf, hdw)
)

# Plotting ----
plot(ls)
plot(w, add = TRUE)
plot(uf) # empty

plot(m, xlim = c(-500, 500), ylim = c(-250, 250))

xg &lt;- seq(-500, 500, length = 200)
yg &lt;- seq(-250, 250, length = 100)

contours(m, x = xg, y = yg, col = 'dodgerblue', nlevels = 20)
plot(m, add = TRUE)

</code></pre>

<hr>
<h2 id='areasink'>Create a circular area-sink analytic element with specified recharge</h2><span id='topic+areasink'></span>

<h3>Description</h3>

<p><code><a href="#topic+areasink">areasink()</a></code> creates a circular area-sink analytic element with constant, uniform specified recharge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areasink(xc, yc, N, R, location = c("top", "base"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="areasink_+3A_xc">xc</code></td>
<td>
<p>numeric, x location of the center of the area-sink.</p>
</td></tr>
<tr><td><code id="areasink_+3A_yc">yc</code></td>
<td>
<p>numeric, y location of the center of the area-sink.</p>
</td></tr>
<tr><td><code id="areasink_+3A_n">N</code></td>
<td>
<p>numeric, uniform constant leakage value (positive is into aquifer) in length per time.</p>
</td></tr>
<tr><td><code id="areasink_+3A_r">R</code></td>
<td>
<p>numeric, radius of the circular area-sink.</p>
</td></tr>
<tr><td><code id="areasink_+3A_location">location</code></td>
<td>
<p>character, either <code>top</code> (default) or <code>base</code> specifying the vertical position of the area-sink.</p>
</td></tr>
<tr><td><code id="areasink_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Area-sinks can be used to simulate areal recharge or seepage at the aquifer top, or leakage into
or out of the aquifer at its base. The <code>location</code> argument is used when calculating the vertical flow
component.
</p>


<h3>Value</h3>

<p>Circular area-sink analytic element which is an object of class <code>areasink</code> and inherits from <code>element</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+headareasink">headareasink()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as &lt;- areasink(xc = -500, yc = 0, N = 0.001, R = 500)

# flux assuming a constant head difference over a confining unit
dh &lt;- 3
res &lt;- 10 / 0.0001
as &lt;- areasink(xc = -500, yc = 0, N = -dh/res, R = 500, location = 'base')

</code></pre>

<hr>
<h2 id='capzone'>Calculate the capture zone of a well element</h2><span id='topic+capzone'></span>

<h3>Description</h3>

<p><code><a href="#topic+capzone">capzone()</a></code> determines the capture zone of a well element in the flow field by performing backward
particle tracking until the requested time is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capzone(aem, well, time, npar = 15, dt = time/10, zstart = aem$base, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capzone_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="capzone_+3A_well">well</code></td>
<td>
<p>analytic element of class <code>well</code>.</p>
</td></tr>
<tr><td><code id="capzone_+3A_time">time</code></td>
<td>
<p>numeric, time of the capture zone.</p>
</td></tr>
<tr><td><code id="capzone_+3A_npar">npar</code></td>
<td>
<p>integer, number of particles to use in the backward tracking. Defaults to 15.</p>
</td></tr>
<tr><td><code id="capzone_+3A_dt">dt</code></td>
<td>
<p>numeric, time step length used in the particle tracking. Defaults <code>time / 10</code>.</p>
</td></tr>
<tr><td><code id="capzone_+3A_zstart">zstart</code></td>
<td>
<p>numeric value with the starting elevation of the particles. Defaults to the base of the aquifer.</p>
</td></tr>
<tr><td><code id="capzone_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+tracelines">tracelines()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+capzone">capzone()</a></code> is a thin wrapper around <code><a href="#topic+tracelines">tracelines()</a></code>. Backward particle tracking is performed using <code><a href="#topic+tracelines">tracelines()</a></code>
and setting <code>forward = FALSE</code>. Initial particle locations are computed by equally spacing <code>npar</code> locations at the well
radius at the <code>zstart</code> elevation. To obtain a sharper delineation of the capture zone envelope, try using more particles
or decreasing <code>dt</code>.
</p>
<p>Note that different <code>zstart</code> values only have an effect in models with vertical flow components.
</p>


<h3>Value</h3>

<p><code><a href="#topic+capzone">capzone()</a></code> returns an object of class <code>tracelines</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tracelines">tracelines()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A model with vertical flow components
k &lt;- 10
top &lt;- 10; base &lt;- 0
n &lt;- 0.3

uf &lt;- uniformflow(TR = 100, gradient = 0.001, angle = -10)
rf &lt;- constant(TR, xc = -1000, yc = 0, hc = 20)
w1 &lt;- well(200, 50, Q = 250)
w2 &lt;- well(-200, -100, Q = 450)
as &lt;- areasink(0, 0, N = 0.001, R = 1500)

m &lt;- aem(k, top, base, n = n, uf, rf, w1, w2, as)

# 5-year capture zone at two different starting levels
# here, the number of particles are set to small values to speed up the examples
# increase the number of particles to obtain a sharper delineation of the envelope
cp5a &lt;- capzone(m, w1, time = 5 * 365, zstart = base, npar = 6, dt = 365 / 4)
cp5b &lt;- capzone(m, w1, time = 5 * 365, zstart = 8, npar = 6, dt = 365 / 4)

xg &lt;- seq(-800, 800, length = 100)
yg &lt;- seq(-500, 500, length = 100)
contours(m, xg, yg, col = 'dodgerblue', nlevels = 20)
plot(cp5a, add = TRUE)
plot(cp5b, add = TRUE, col = 'forestgreen') # smaller zone

# plot the convex hull of the endpoints as a polygon
endp &lt;- endpoints(cp5b)
hull &lt;- chull(endp[, c('x', 'y')])
polygon(endp[hull, c('x', 'y')], col = adjustcolor('forestgreen', alpha.f = 0.7))

</code></pre>

<hr>
<h2 id='constant'>Create a constant-head analytic element</h2><span id='topic+constant'></span>

<h3>Description</h3>

<p><code><a href="#topic+constant">constant()</a></code> creates an analytic element containing a constant head, often referred to
as <em>the reference point</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constant(xc, yc, hc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constant_+3A_xc">xc</code></td>
<td>
<p>numeric, x location of the reference point.</p>
</td></tr>
<tr><td><code id="constant_+3A_yc">yc</code></td>
<td>
<p>numeric, y location of the reference point.</p>
</td></tr>
<tr><td><code id="constant_+3A_hc">hc</code></td>
<td>
<p>numeric, hydraulic head at the reference point.</p>
</td></tr>
<tr><td><code id="constant_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Constant-head analytic element point which is an object of class <code>constant</code> and inherits from <code>element</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rf &lt;- constant(xc = -100, yc = 0, hc = 10)

</code></pre>

<hr>
<h2 id='contours'>Plot contours of a state-variable of the analytic element model</h2><span id='topic+contours'></span>

<h3>Description</h3>

<p><code><a href="#topic+contours">contours()</a></code> creates a contour plot of a state-variable computed by the analytic element
model <code>aem</code>, or adds the contour lines to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contours(
  aem,
  x,
  y,
  variable = c("heads", "streamfunction", "potential"),
  asp = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contours_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="contours_+3A_x">x</code></td>
<td>
<p>numeric, vector or marginal x coordinates at which the gridded values are computed. These must be in ascending order.</p>
</td></tr>
<tr><td><code id="contours_+3A_y">y</code></td>
<td>
<p>numeric, vector or marginal y coordinates at which the gridded values are computed. These must be in ascending order.</p>
</td></tr>
<tr><td><code id="contours_+3A_variable">variable</code></td>
<td>
<p>character indicating which state-variable to plot. Possible values are <code>heads</code> (default),
<code>streamfunction</code> and <code>potential</code>.</p>
</td></tr>
<tr><td><code id="contours_+3A_asp">asp</code></td>
<td>
<p>the <code>y/x</code> aspect ratio, see <code><a href="graphics.html#topic+plot.window">plot.window()</a></code>. Defaults to 1 (equal unit lengths).</p>
</td></tr>
<tr><td><code id="contours_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+contour">contour()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+contours">contours()</a></code> is a wrapper around <code><a href="graphics.html#topic+contour">contour()</a></code>. It obtains the values of <code>variable</code> at
the grid points defined by marginal vectors <code>x</code> and <code>y</code> and constructs the matrix supplied to <code><a href="graphics.html#topic+contour">contour()</a></code> by reversing the rows and
transposing the matrix (see also the documentation of <code><a href="graphics.html#topic+image">image()</a></code>).
</p>


<h3>Value</h3>

<p>A contour plot of the selected variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aem">aem()</a></code> <code><a href="graphics.html#topic+contour">contour()</a></code> <code><a href="graphics.html#topic+image">image()</a></code> <code><a href="#topic+heads">heads()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- well(xw = 50, yw = 0, Q = 200)
wi &lt;- well(xw = -200, yw = 0, Q = -100)
uf &lt;- uniformflow(gradient = 0.002, angle = -45, TR = 100)
rf &lt;- constant(-1000, 0, hc = 10)
ml &lt;- aem(k = 10, top = 10, base = 0, n = 0.2, w, wi, uf, rf)

# grid points
xg &lt;- seq(-350, 200, length = 100)
yg &lt;- seq(-125, 125, length = 100)

contours(ml, xg, yg, nlevels = 20, col = 'dodgerblue', labcex = 1)
contours(ml, xg, yg, 'streamfunction', nlevels = 20, col = 'orange',
         drawlabels = FALSE, add = TRUE)

# Not to be confused by contour()
try(
contour(ml, xg, yg, nlevels = 20, col = 'dodgerblue', labcex = 1)
)

# For image() or filled.contour()
library(graphics)
h &lt;- heads(ml, xg, yg, as.grid = TRUE)
h_im &lt;- t(h[dim(h)[1]:1,])
image(xg, yg, h_im, asp = 1)
contour(xg, yg, h_im, asp = 1, add = TRUE) # contours() is a wrapper for this
filled.contour(xg, yg, h_im, asp = 1)

</code></pre>

<hr>
<h2 id='dirflow'>Compute flow in the direction of a given angle</h2><span id='topic+dirflow'></span>

<h3>Description</h3>

<p><code><a href="#topic+dirflow">dirflow()</a></code> computes a flow variable at the given points in the direction of the supplied angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirflow(
  aem,
  x,
  y,
  angle,
  flow = c("discharge", "darcy", "velocity"),
  as.grid = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dirflow_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="dirflow_+3A_x">x</code></td>
<td>
<p>numeric x coordinates to evaluate <code>flow</code> at.</p>
</td></tr>
<tr><td><code id="dirflow_+3A_y">y</code></td>
<td>
<p>numeric y coordinates to evaluate <code>flow</code> at.</p>
</td></tr>
<tr><td><code id="dirflow_+3A_angle">angle</code></td>
<td>
<p>numeric, angle of the direction to evaluate <code>flow</code>, in degrees counterclockwise from the x-axis.</p>
</td></tr>
<tr><td><code id="dirflow_+3A_flow">flow</code></td>
<td>
<p>character specifying which flow variable to use. Possible values are <code>discharge</code> (default), <code>darcy</code> and <code>velocity</code>. See <code><a href="#topic+flow">flow()</a></code>.</p>
</td></tr>
<tr><td><code id="dirflow_+3A_as.grid">as.grid</code></td>
<td>
<p>logical, should a matrix be returned? Defaults to FALSE. See details.</p>
</td></tr>
<tr><td><code id="dirflow_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+discharge">discharge()</a></code>, <code><a href="#topic+darcy">darcy()</a></code> or <code><a href="#topic+velocity">velocity()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The x and y components of <code>flow</code> are used to calculate the directed value using <code>angle</code>.
The <code>z</code> coordinate in <code><a href="#topic+discharge">discharge()</a></code>, <code><a href="#topic+darcy">darcy()</a></code> or <code><a href="#topic+velocity">velocity()</a></code> is set at the aquifer base. Under Dupuit-Forchheimer,
the x and y components of the flow vector do not change along the vertical axis.
</p>


<h3>Value</h3>

<p>A vector of <code>length(x)</code> (equal to <code>length(y)</code>) with the flow values at <code>x</code> and <code>y</code> in the direction of <code>angle</code>.
If <code>as.grid = TRUE</code>, a matrix of dimensions <code>c(length(y), length(x))</code> described by
marginal vectors <code>x</code> and <code>y</code> containing the directed flow values at the grid points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flow">flow()</a></code>, <code><a href="#topic+flow_through_line">flow_through_line()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rf &lt;- constant(-1000, 0, hc = 10)
uf &lt;- uniformflow(TR = 100, gradient = 0.001, angle = -45)
w &lt;- well(10, -50, Q = 200)

m &lt;- aem(k = 10, top = 10, base = 0, n = 0.2, rf, uf)
dirflow(m, x = c(0, 100), y = 50, angle = -45)

m &lt;- aem(k = 10, top = 10, base = 0, n = 0.2, rf, uf, w, type = 'confined')
dirflow(m, x = c(0, 50, 100), y = c(0, 50), angle = -90,
flow = 'velocity', as.grid = TRUE)

</code></pre>

<hr>
<h2 id='element_discharge'>Get the computed discharge from an element</h2><span id='topic+element_discharge'></span>

<h3>Description</h3>

<p><code><a href="#topic+element_discharge">element_discharge()</a></code> obtains the computed discharge into or out of the aquifer
for a individual analytic element or all elements of a given type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_discharge(aem, name = NULL, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_discharge_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="element_discharge_+3A_name">name</code></td>
<td>
<p>character vector with the name of the element(s) as available in <code>aem$elements</code>.</p>
</td></tr>
<tr><td><code id="element_discharge_+3A_type">type</code></td>
<td>
<p>character with the type (class) of element to obtain the summed discharge from. See details.</p>
</td></tr>
<tr><td><code id="element_discharge_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>name</code> or <code>type</code> should be specified. If <code>type</code> is specified, only one type is allowed.
Possible values are <code style="white-space: pre;">&#8288;'headwell', 'well', 'linesink', 'headlinesink', 'areasink'&#8288;</code> or <code>'headareasink'</code>.
</p>
<p>Only elements that add or remove water from the aquifer will return a non-zero discharge value.
</p>


<h3>Value</h3>

<p>A numeric named vector of length <code>length(name)</code> with the discharge into (negative) or out of (positive)
the aquifer. If <code>type</code> is specified, a single named numeric value with the total discharge into (negative) or
out of (positive) the aquifer which is the sum of all individual elements of class <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- 10
top &lt;- 10
base &lt;- 0
n &lt;- 0.2
TR &lt;- k * (top - base)

rf &lt;- constant(xc = -500, yc = 0, h = 20)
uf &lt;- uniformflow(gradient = 0.002, angle = -45, TR = TR)
w1 &lt;- well(xw = 50, yw = 0, Q = 200)
w2 &lt;- well(xw = 0, yw = 100, Q = 400)
hw &lt;- headwell(xw = -100, yw = 0, hc = 7.5)
hls &lt;- headlinesink(x0 = -200, y0 = -150, x1 = 200, y1 = 150, hc = 8)
as &lt;- areasink(xc = 0, yc = 0, N = 0.0005, R = 500)
m &lt;- aem(k, top, base, n, rf, uf, w1, w2, hw, hls, as)

element_discharge(m, name = c('hls', 'as'))
element_discharge(m, type = 'well')

# zero discharge for uniform flow element as it does not add or remove water
element_discharge(m, name = 'uf')
</code></pre>

<hr>
<h2 id='flow'>Calculate flow variables</h2><span id='topic+flow'></span><span id='topic+discharge'></span><span id='topic+darcy'></span><span id='topic+velocity'></span><span id='topic+domega'></span><span id='topic+discharge.aem'></span><span id='topic+darcy.aem'></span><span id='topic+velocity.aem'></span><span id='topic+domega.aem'></span><span id='topic+domega.element'></span>

<h3>Description</h3>

<p><code><a href="#topic+discharge">discharge()</a></code> computes the <code style="white-space: pre;">&#8288;x, y&#8288;</code> and <code>z</code> components of the discharge vector for an <code>aem</code> object
at the given x, y and z coordinates.
</p>
<p><code><a href="#topic+darcy">darcy()</a></code> computes the <code style="white-space: pre;">&#8288;x, y&#8288;</code> and <code>z</code> components of the Darcy flux vector (also called <em>specific discharge vector</em>)
for an <code>aem</code> object at the given x, y and z coordinates.
</p>
<p><code><a href="#topic+velocity">velocity()</a></code> computes the <code style="white-space: pre;">&#8288;x, y&#8288;</code> and <code>z</code> components of the average linear groundwater flow velocity vector
for an <code>aem</code> object at the given x, y and z coordinates.
</p>
<p><code><a href="#topic+domega">domega()</a></code> computes the complex discharge for an <code>aem</code> or <code>element</code> object
at the given x and y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discharge(...)

darcy(...)

velocity(...)

domega(...)

## S3 method for class 'aem'
discharge(
  aem,
  x,
  y,
  z,
  as.grid = FALSE,
  magnitude = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'aem'
darcy(aem, x, y, z, as.grid = FALSE, magnitude = FALSE, ...)

## S3 method for class 'aem'
velocity(aem, x, y, z, as.grid = FALSE, magnitude = FALSE, R = 1, ...)

## S3 method for class 'aem'
domega(aem, x, y, as.grid = FALSE, ...)

## S3 method for class 'element'
domega(element, x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flow_+3A_...">...</code></td>
<td>
<p>ignored or arguments passed from <code><a href="#topic+velocity">velocity()</a></code> or <code><a href="#topic+darcy">darcy()</a></code> to <code><a href="#topic+discharge">discharge()</a></code>.</p>
</td></tr>
<tr><td><code id="flow_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="flow_+3A_x">x</code></td>
<td>
<p>numeric x coordinates to evaluate the flow at.</p>
</td></tr>
<tr><td><code id="flow_+3A_y">y</code></td>
<td>
<p>numeric y coordinates to evaluate the flow at.</p>
</td></tr>
<tr><td><code id="flow_+3A_z">z</code></td>
<td>
<p>numeric z coordinates to evaluate at</p>
</td></tr>
<tr><td><code id="flow_+3A_as.grid">as.grid</code></td>
<td>
<p>logical, should a matrix be returned? Defaults to <code>FALSE</code>. See details.</p>
</td></tr>
<tr><td><code id="flow_+3A_magnitude">magnitude</code></td>
<td>
<p>logical, should the magnitude of the flow vector be returned as well? Default to <code>FALSE</code>. See details.</p>
</td></tr>
<tr><td><code id="flow_+3A_verbose">verbose</code></td>
<td>
<p>logical, if <code>TRUE</code> (default), warnings with regards to setting <code>Qz</code> to <code>NA</code> are printed. See details.</p>
</td></tr>
<tr><td><code id="flow_+3A_r">R</code></td>
<td>
<p>numeric, retardation coefficient used in <code>velocity()</code>. Defaults to 1 (no retardation).</p>
</td></tr>
<tr><td><code id="flow_+3A_element">element</code></td>
<td>
<p>analytic element of class <code>element</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no <code><a href="#topic+discharge">discharge()</a></code>, <code><a href="#topic+darcy">darcy()</a></code> or <code><a href="#topic+velocity">velocity()</a></code> method for an object of class <code>element</code> because an <code>aem</code> object is required
to obtain the aquifer base and top.
</p>
<p>If the <code>z</code> coordinate is above the saturated aquifer level (i.e. the water-table for unconfined conditions or
the aquifer top for confined conditions), or below the aquifer base, <code>Qz</code> values are set to <code>NA</code> with a warning (if <code>verbose = TRUE</code>).
The <code>Qx</code> and <code>Qy</code> values are not set to <code>NA</code>, for convenience in specifying the <code>z</code> coordinate when only lateral flow
is of interest.
</p>


<h3>Value</h3>

<p>For <code><a href="#topic+discharge">discharge()</a></code>, a matrix with the number of rows equal to the number of points to evaluate
the discharge vector at, and with columns <code>Qx</code>, <code>Qy</code> and <code>Qz</code> corresponding to <code style="white-space: pre;">&#8288;x, y&#8288;</code> and <code>z</code> components
of the discharge vector at coordinates <code>x</code>, <code>y</code> and <code>z</code>. If <code>as.grid = TRUE</code>, an array of dimensions
<code>c(length(y), length(x), length(z), 3)</code> described by marginal vectors <code>x</code>, <code>y</code> and <code>z</code> (columns, rows and third dimension)
containing the <code style="white-space: pre;">&#8288;x, y&#8288;</code> and <code>z</code> components of the discharge vector (<code>Qx</code>, <code>Qy</code> and <code>Qz</code>) as the fourth dimension.
</p>
<p>The <code>x</code> component of <code><a href="#topic+discharge">discharge()</a></code> is the real value of <code><a href="#topic+domega">domega()</a></code>, the <code>y</code> component
the negative imaginary component and the <code>z</code> component is calculated based on area-sink strengths
and/or the curvature of the phreatic surface.
</p>
<p>If <code>magnitude = TRUE</code>, the last dimension of the returned array is expanded to include
the magnitude of the discharge/Darcy/velocity vector, calculated as <code>sqrt(Qx^2 + Qy^2 + Qz^2)</code>
(or <code>sqrt(qx^2 + qy^2 + qz^2)</code> or <code>sqrt(vx^2 + vy^2 + vz^2)</code>, respectively).
</p>
<p>For <code><a href="#topic+darcy">darcy()</a></code>, the same as for <code><a href="#topic+discharge">discharge()</a></code> but with the <code>x</code>, <code>y</code> and <code>z</code> components of the
Darcy flux vector (<code>qx</code>, <code>qy</code> and <code>qz</code>). The values are computed by dividing the values of <code><a href="#topic+discharge">discharge()</a></code> by
the saturated thickness at <code>x</code>, <code>y</code> and <code>z</code>.
</p>
<p>For <code><a href="#topic+velocity">velocity()</a></code>, the same as for <code><a href="#topic+discharge">discharge()</a></code> but with the <code>x</code>, <code>y</code> and <code>z</code> components of the
average linear groundwater flow velocity vector (<code>vx</code>, <code>vy</code> and <code>vz</code>). The values are computed by dividing
the <code><a href="#topic+darcy">darcy()</a></code> values by the effective porosity (<code>aem$n</code>) and the retardation coefficient <code>R</code>.
</p>
<p>For <code><a href="#topic+domega">domega()</a></code>, a vector of <code>length(x)</code> (equal to <code>length(y)</code>) with the complex discharge values at <code>x</code> and <code>y</code>,
If <code>as.grid = TRUE</code>, a matrix of dimensions <code>c(length(y), length(x))</code> described by
marginal vectors <code>x</code> and <code>y</code> containing the complex discharge values at the grid points.
<code><a href="#topic+domega">domega()</a></code> is the derivative of <code><a href="#topic+omega">omega()</a></code> in the x and y directions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+state-variables">state-variables()</a></code>, <code><a href="#topic+satthick">satthick()</a></code>, <code><a href="#topic+dirflow">dirflow()</a></code>, <code><a href="#topic+flow_through_line">flow_through_line()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- well(xw = 55, yw = 0, Q = 200)
uf &lt;- uniformflow(gradient = 0.002, angle = -45, TR = 100)
as &lt;- areasink(xc = 0, yc = 0, N = 0.001, R = 500)
rf &lt;- constant(xc = -1000, yc = 1000, hc = 10)
ml &lt;- aem(k = 10, top = 10, base = -15, n = 0.2, w, uf, as, rf)

xg &lt;- seq(-100, 100, length = 5)
yg &lt;- seq(-75, 75, length = 3)

# Discharge vector
discharge(ml, c(150, 0), c(80, -80), z = -10)
discharge(ml, c(150, 0), c(80, -80), z = c(2, 5), magnitude = TRUE)
discharge(ml, xg, yg, z = 2, as.grid = TRUE)
discharge(ml, c(150, 0), c(80, -80), z = ml$top + c(-5, 0.5)) # NA for z &gt; water-table

# Darcy flux
darcy(ml, c(150, 0), c(80, -80), c(0, 5), magnitude = TRUE)

# Velocity
velocity(ml, c(150, 0), c(80, -80), c(0, 5), magnitude = TRUE, R = 5)

# Complex discharge
domega(ml, c(150, 0), c(80, -80))

# Complex discharge for elements
domega(w, c(150, 0), c(80, -80))

</code></pre>

<hr>
<h2 id='flow_through_line'>Calculate the total flow passing through a line</h2><span id='topic+flow_through_line'></span>

<h3>Description</h3>

<p><code><a href="#topic+flow_through_line">flow_through_line()</a></code> computes the integrated flow passing through a straight line at a right angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flow_through_line(
  aem,
  x0,
  y0,
  x1,
  y1,
  flow = c("discharge", "darcy"),
  split = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flow_through_line_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object</p>
</td></tr>
<tr><td><code id="flow_through_line_+3A_x0">x0</code></td>
<td>
<p>numeric, starting x location of line.</p>
</td></tr>
<tr><td><code id="flow_through_line_+3A_y0">y0</code></td>
<td>
<p>numeric, starting y location of line.</p>
</td></tr>
<tr><td><code id="flow_through_line_+3A_x1">x1</code></td>
<td>
<p>numeric, ending x location of line.</p>
</td></tr>
<tr><td><code id="flow_through_line_+3A_y1">y1</code></td>
<td>
<p>numeric, ending y location of line.</p>
</td></tr>
<tr><td><code id="flow_through_line_+3A_flow">flow</code></td>
<td>
<p>character specifying which flow variable to use. Possible values are <code>discharge</code> (default) and <code>darcy</code>. See <code><a href="#topic+flow">flow()</a></code>.</p>
</td></tr>
<tr><td><code id="flow_through_line_+3A_split">split</code></td>
<td>
<p>logical, should the flow be split up into positive and negative flows (<code>TRUE</code>) or should they be summed (<code>FALSE</code>; default)? See details.</p>
</td></tr>
<tr><td><code id="flow_through_line_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The flow is computed normal to the line and integrated along the line length using <code><a href="stats.html#topic+integrate">stats::integrate()</a></code>.
The flow value is positive going to the left when looking in the direction of the line (i.e. to the left going from <code>x0-y0</code>
to <code>x1-y1</code>).
</p>
<p>If <code>split = FALSE</code> (the default), a single value is returned which is the sum of the positive and negative flows perpendicular to the line.
If <code>split = TRUE</code>, both the positive and negative component of the total flow through the line are returned.
</p>
<p>If the line corresponds to a line element, the integration might fail. Try to perturbate the line vertices slightly in that case.
</p>


<h3>Value</h3>

<p>If <code>split = FALSE</code>, a single value with the total flow of variable <code>flow</code> passing through the line at a right angle.
If <code>split = TRUE</code> a named vector with the total positive and total negative value of <code>flow</code> passing through the line.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flow">flow()</a></code>, <code><a href="#topic+dirflow">dirflow()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rf &lt;- constant(-1000, 0, hc = 10)
uf &lt;- uniformflow(TR = 100, gradient = 0.001, angle = -45)
m &lt;- aem(k = 10, top = 10, base = 0, n = 0.2, rf, uf)

xg &lt;- seq(-500, 500, l=100); yg &lt;- seq(-300, 300, l=100)
contours(m, xg, yg, col='dodgerblue', nlevels=20)

x0 &lt;- -200
y0 &lt;- -50
x1 &lt;- 300
y1 &lt;- 100
lines(matrix(c(x0, y0, x1, y1), ncol = 2, byrow = TRUE))

flow_through_line(m, x0, y0, x1, y1)
flow_through_line(m, x1, y1, x0, y0) # reverse direction of line

w &lt;- well(125, 200, 150)
m &lt;- aem(k = 10, top = 10, base = 0, n = 0.2, rf, uf, w)
contours(m, xg, yg, col='dodgerblue', nlevels=20)
lines(matrix(c(x0, y0, x1, y1), ncol = 2, byrow = TRUE))

flow_through_line(m, x0, y0, x1, y1, flow = 'darcy')
flow_through_line(m, x0, y0, x1, y1, flow = 'darcy', split = TRUE)

</code></pre>

<hr>
<h2 id='head_to_potential'>Convert hydraulic head to potential and vice versa</h2><span id='topic+head_to_potential'></span><span id='topic+potential_to_head'></span>

<h3>Description</h3>

<p><code><a href="#topic+head_to_potential">head_to_potential()</a></code> calculates the discharge potential from the hydraulic head.
</p>
<p><code><a href="#topic+potential_to_head">potential_to_head()</a></code> calculates the hydraulic head from the discharge potential.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head_to_potential(aem, h, ...)

potential_to_head(aem, phi, na.below = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="head_to_potential_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="head_to_potential_+3A_h">h</code></td>
<td>
<p>numeric hydraulic head values as vector or matrix.</p>
</td></tr>
<tr><td><code id="head_to_potential_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="head_to_potential_+3A_phi">phi</code></td>
<td>
<p>numeric discharge potential values as vector or matrix.</p>
</td></tr>
<tr><td><code id="head_to_potential_+3A_na.below">na.below</code></td>
<td>
<p>logical indicating if calculated head values below the aquifer base should be set to <code>NA</code>. Defaults to <code>TRUE</code>. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+head_to_potential">head_to_potential()</a></code> returns the discharge potentials calculated from <code>h</code>, in the same
structure as <code>h</code>.
</p>
<p><code><a href="#topic+potential_to_head">potential_to_head()</a></code> returns the hydraulic heads calculated from <code>phi</code>, in the same
structure as <code>phi</code>.
</p>
<p>The conversion of potential to head or vice versa is different for confined (constant saturated thickness)
and unconfined (variable saturated thickness) aquifers as set by the <code>type</code> argument in <code>aem()</code>.
</p>
<p>If <code>na.below = FALSE</code>, negative potentials can be converted to hydraulic heads if flow is unconfined (<code>aem$type = 'variable'</code>).
The resulting heads are below the aquifer base. This may be useful for some use cases, e.g. in preliminary model construction
or for internal functions. In most cases however, these values should be set to <code>NA</code> (the default behavior) since other analytic
elements will continue to extract or inject water even though the saturated thickness of the aquifer is negative,
which is not realistic. In those cases, setting <code>aem$type = 'confined'</code> might prove useful. Also note that these heads below the
aquifer base will not be correctly re-converted to potentials using <code><a href="#topic+head_to_potential">head_to_potential()</a></code>. As such, caution should be taken when
setting <code>na.below = FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- 10
top &lt;- 10; base &lt;- 0
uf &lt;- uniformflow(TR = 100, gradient = 0.001, angle = -45)
rf &lt;- constant(TR, xc = -1000, yc = 0, hc = 10)
w1 &lt;- well(200, 50, Q = 250)
m &lt;- aem(k, top, base, n = 0.2, uf, rf, w1, type = 'variable') # variable saturated thickness
mc &lt;- aem(k, top, base, n = 0.2, uf, rf, w1, type = 'confined') # constant saturated thickness
xg &lt;- seq(-500, 500, length = 100)
yg &lt;- seq(-250, 250, length = 100)

h &lt;- heads(m, x = xg, y = yg, as.grid = TRUE)
hc &lt;- heads(mc, x = xg, y = yg, as.grid = TRUE)
pot &lt;- head_to_potential(m, h)
potc &lt;- head_to_potential(mc, hc)

phi &lt;- potential(m, x = xg, y = yg, as.grid = TRUE)
phic &lt;- potential(mc, x = xg, y = yg, as.grid = TRUE)
hds &lt;- potential_to_head(m, phi)
hdsc &lt;- potential_to_head(mc, phic)

# Converting negative potentials results in NA's with warning
try(
potential_to_head(m, -300)
)

# unless na.below = FALSE
potential_to_head(m, -300, na.below = FALSE)

</code></pre>

<hr>
<h2 id='headareasink'>Create a head-specified area-sink analytic element</h2><span id='topic+headareasink'></span>

<h3>Description</h3>

<p><code><a href="#topic+headareasink">headareasink()</a></code> creates a circular area-sink analytic element with constant specified head. The constant leakage flux
into or out of the aquifer from the area-sink is computed by solving the corresponding <code>aem</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headareasink(xc, yc, hc, R, resistance = 0, location = c("top", "base"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="headareasink_+3A_xc">xc</code></td>
<td>
<p>numeric, x location of the center of the area-sink.</p>
</td></tr>
<tr><td><code id="headareasink_+3A_yc">yc</code></td>
<td>
<p>numeric, y location of the center of the area-sink.</p>
</td></tr>
<tr><td><code id="headareasink_+3A_hc">hc</code></td>
<td>
<p>numeric, specified hydraulic head at the center of the area-sink.</p>
</td></tr>
<tr><td><code id="headareasink_+3A_r">R</code></td>
<td>
<p>numeric, radius of the circular area-sink.</p>
</td></tr>
<tr><td><code id="headareasink_+3A_resistance">resistance</code></td>
<td>
<p>numeric, hydraulic resistance of the area-sink at its connection with the aquifer. Defaults to 0 (no resistance).</p>
</td></tr>
<tr><td><code id="headareasink_+3A_location">location</code></td>
<td>
<p>character, either <code>top</code> (default) or <code>base</code> specifying the vertical position of the area-sink.</p>
</td></tr>
<tr><td><code id="headareasink_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constant leakage flux from the area-sink is computed by solving the <code>aem</code> model given
the specified head <code>hc</code> for the area-sink. This head is located at the so-called collocation point,
which is placed at the center of the area-sink. A positive flux is into the aquifer. Note that this head-dependent
flux is constant over the domain and computed only at the collocation point. The flux is therefore determined
by the difference in aquifer head and specified head at that location only, and does not vary across the domain with
varying aquifer head.
</p>
<p>The resistance can be increased for a area-sink in poor connection with the aquifer, e.g. because of
a confining unit of low hydraulic conductivity between the aquifer and the area-sink. If the aquifer is unconfined
(i.e. has a variable saturated thickness), the system of equations will then become non-linear with respect to the hydraulic
head and iteration is required to solve the model.
</p>


<h3>Value</h3>

<p>Circular head-specified area-sink analytic element which is an object of class <code>headareasink</code> and inherits from <code>areasink</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+areasink">areasink()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>has &lt;- headareasink(xc = -500, yc = 0, hc = 3, R = 500, res = 1000)
has &lt;- headareasink(xc = -500, yc = 0, hc = 3, R = 500, location = 'base')

</code></pre>

<hr>
<h2 id='headlinesink'>Create a head-specified line-sink analytic element</h2><span id='topic+headlinesink'></span>

<h3>Description</h3>

<p><code><a href="#topic+headlinesink">headlinesink()</a></code> creates a line-sink analytic element with constant specified head. The discharge
into the line-sink per unit length is computed by solving the corresponding <code>aem</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headlinesink(x0, y0, x1, y1, hc, resistance = 0, width = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="headlinesink_+3A_x0">x0</code></td>
<td>
<p>numeric, starting x location of line-sink.</p>
</td></tr>
<tr><td><code id="headlinesink_+3A_y0">y0</code></td>
<td>
<p>numeric, starting y location of line-sink.</p>
</td></tr>
<tr><td><code id="headlinesink_+3A_x1">x1</code></td>
<td>
<p>numeric, ending x location of line-sink.</p>
</td></tr>
<tr><td><code id="headlinesink_+3A_y1">y1</code></td>
<td>
<p>numeric, ending y location of line-sink.</p>
</td></tr>
<tr><td><code id="headlinesink_+3A_hc">hc</code></td>
<td>
<p>numeric, specified hydraulic head of the line-sink.</p>
</td></tr>
<tr><td><code id="headlinesink_+3A_resistance">resistance</code></td>
<td>
<p>numeric, hydraulic resistance of the line-sink at its connection with the aquifer. Defaults to 0 (no resistance).</p>
</td></tr>
<tr><td><code id="headlinesink_+3A_width">width</code></td>
<td>
<p>numeric, width of the line-sink. Used with <code>resistance</code> to calculate the line-sink strength, and by <code><a href="#topic+tracelines">tracelines()</a></code> to
determine if a particle has reached the line. Defaults to zero (infinitesimally narrow line).</p>
</td></tr>
<tr><td><code id="headlinesink_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The strength of the line-sink (discharge per unit length of line-sink) is computed by solving
the <code>aem</code> model given the specified head <code>hc</code> for the line-sink. This head is located at the so-called
collocation point, which is placed at the center of the line-sink.
</p>
<p>The resistance can be increased for a line-sink in poor connection with the aquifer. The effect of a larger
or smaller wetted perimeter can be mimicked by adjusting the <code>resistance</code> and/or <code>width</code> accordingly. If
<code>width = 0</code> (the default) it is removed from the conductance calculation. If the aquifer is unconfined
(i.e. has a variable saturated thickness), the system of equations becomes non-linear with respect to the
hydraulic head and iteration is required to solve the model.
</p>


<h3>Value</h3>

<p>Head-specified line-sink analytic element which is an object of class <code>headlinesink</code> and inherits from <code>linesink</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linesink">linesink()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hls &lt;- headlinesink(-75, 50, 100, 50, hc = 10)
hls &lt;- headlinesink(-75, 50, 100, 50, hc = 10, resistance = 10, width = 4)

</code></pre>

<hr>
<h2 id='headwell'>Create a analytic element of a well with a constant head</h2><span id='topic+headwell'></span>

<h3>Description</h3>

<p><code><a href="#topic+headwell">headwell()</a></code> creates an analytic element of a well with a constant, specified head. The discharge
into the well is computed by solving the corresponding <code>aem</code> model. The head can be specified at
the well or at any other location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headwell(xw, yw, hc, rw = 0.3, xc = xw, yc = yw, rc = rw, resistance = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="headwell_+3A_xw">xw</code></td>
<td>
<p>numeric, x location of the well.</p>
</td></tr>
<tr><td><code id="headwell_+3A_yw">yw</code></td>
<td>
<p>numeric, y location of the well.</p>
</td></tr>
<tr><td><code id="headwell_+3A_hc">hc</code></td>
<td>
<p>numeric, specified hydraulic head at the collocation point.</p>
</td></tr>
<tr><td><code id="headwell_+3A_rw">rw</code></td>
<td>
<p>numeric, radius of the well. Defaults to 0.3 (meter).</p>
</td></tr>
<tr><td><code id="headwell_+3A_xc">xc</code></td>
<td>
<p>numeric, x location of the collocation point. See details. Defaults to <code>xw</code>.</p>
</td></tr>
<tr><td><code id="headwell_+3A_yc">yc</code></td>
<td>
<p>numeric, y location of the collocation point. See details. Defaults to <code>yw</code>.</p>
</td></tr>
<tr><td><code id="headwell_+3A_rc">rc</code></td>
<td>
<p>numeric, radius of the collocation point. See details. Defaults to <code>rw</code>.</p>
</td></tr>
<tr><td><code id="headwell_+3A_resistance">resistance</code></td>
<td>
<p>numeric, hydraulic resistance at the collocation point. Defaults to 0 (no resistance).</p>
</td></tr>
<tr><td><code id="headwell_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discharge from the well at location <code>xw - yw</code> is computed by solving the <code>aem</code> model given
the specified head <code>hc</code>. This head is specified at <code>xc + rc - yc</code>, called the collocation point.
This can be used to compute the discharge of the well by specifying the head at some other location.
By default, the location of the well and the collocation point are the same.
</p>
<p>The hydraulic resistance of the well screen at the collocation point can be increased for a well in poor connection with
the aquifer. If the aquifer is unconfined (i.e. has a variable saturated thickness), the system of equations becomes
non-linear with respect to the hydraulic head and iteration is required to solve the model.
</p>


<h3>Value</h3>

<p>Analytic element of a well with constant head which is an object of class <code>headwell</code> and inherits from <code>well</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+well">well()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hw &lt;- headwell(xw = 400, yw = 300, hc = 20, rw = 0.3)
hw &lt;- headwell(xw = 400, yw = 300, hc = 20, rw = 0.3, resistance = 10)
hw &lt;- headwell(xw = 400, yw = 300, hc = 20, rw = 0.3, xc = 500, yc = 500, rc = 0)

</code></pre>

<hr>
<h2 id='linesink'>Create a strength-specified line-sink analytic element</h2><span id='topic+linesink'></span>

<h3>Description</h3>

<p><code><a href="#topic+linesink">linesink()</a></code> creates a line-sink analytic element with constant specified strength.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linesink(x0, y0, x1, y1, sigma, width = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linesink_+3A_x0">x0</code></td>
<td>
<p>numeric, starting x location of line-sink.</p>
</td></tr>
<tr><td><code id="linesink_+3A_y0">y0</code></td>
<td>
<p>numeric, starting y location of line-sink.</p>
</td></tr>
<tr><td><code id="linesink_+3A_x1">x1</code></td>
<td>
<p>numeric, ending x location of line-sink.</p>
</td></tr>
<tr><td><code id="linesink_+3A_y1">y1</code></td>
<td>
<p>numeric, ending y location of line-sink.</p>
</td></tr>
<tr><td><code id="linesink_+3A_sigma">sigma</code></td>
<td>
<p>numeric, specific strength of the line-sink, i.e. discharge per unit length of line-sink. Positive is out of aquifer.</p>
</td></tr>
<tr><td><code id="linesink_+3A_width">width</code></td>
<td>
<p>numeric, width of the line-sink. Only used in <code><a href="#topic+tracelines">tracelines()</a></code> to determine if a particle has reached the line.
Defaults to zero (infinitesimally narrow line).</p>
</td></tr>
<tr><td><code id="linesink_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Strength-specified line-sink analytic element which is an object of class <code>linesink</code> and inherits from <code>element</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+headlinesink">headlinesink()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ls &lt;- linesink(-75, 50, 100, 50, sigma = 1, width = 3)

</code></pre>

<hr>
<h2 id='satthick'>Compute the saturated thickness</h2><span id='topic+satthick'></span>

<h3>Description</h3>

<p><code><a href="#topic+satthick">satthick()</a></code> computes the saturated thickness of the aquifer from an <code>aem</code> object
at the given x and y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>satthick(aem, x, y, as.grid = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="satthick_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="satthick_+3A_x">x</code></td>
<td>
<p>numeric x coordinates to evaluate at.</p>
</td></tr>
<tr><td><code id="satthick_+3A_y">y</code></td>
<td>
<p>numeric y coordinates to evaluate at.</p>
</td></tr>
<tr><td><code id="satthick_+3A_as.grid">as.grid</code></td>
<td>
<p>logical, should a matrix be returned? Defaults to <code>FALSE</code>. See details.</p>
</td></tr>
<tr><td><code id="satthick_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+heads">heads()</a></code> when <code>aem$type = 'variable'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the aquifer is confined at <code>x</code> and <code>y</code>, the saturated thickness equals the aquifer thickness.
For flow with variable saturated thickness (<code>aem$type = 'variable'</code>), if the aquifer is unconfined at <code>x</code> and <code>y</code>,
the saturated thickness is calculated as the hydraulic head at <code>x</code> and <code>y</code> minus the aquifer base.
</p>


<h3>Value</h3>

<p>A vector of <code>length(x)</code> (equal to <code>length(y)</code>) with the saturated thicknesses at <code>x</code> and <code>y</code>.
If <code>as.grid = TRUE</code>, a matrix of dimensions <code>c(length(y), length(x))</code> described by
marginal vectors <code>x</code> and <code>y</code> containing the saturated thicknesses at the grid points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flow">flow()</a></code>, <code><a href="#topic+state-variables">state-variables()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uf &lt;- uniformflow(100, 0.001, 0)
rf &lt;- constant(-1000, 0, 11)
m &lt;- aem(k = 10, top = 10, base = 0, n = 0.2, uf, rf, type = 'confined')

satthick(m, x = c(-200, 0, 200), y = 0) # confined
s &lt;- satthick(m, x = seq(-500, 500, length = 100),
              y = seq(-250, 250, length = 100), as.grid = TRUE)
str(s)

mv &lt;- aem(k = 10, top = 10, base = 0, n = 0.2, uf, rf, type = 'variable')
satthick(mv, x = c(-200, 0, 200), y = 0) # variable

</code></pre>

<hr>
<h2 id='state-variables'>Calculate state-variables</h2><span id='topic+state-variables'></span><span id='topic+heads'></span><span id='topic+omega'></span><span id='topic+potential'></span><span id='topic+streamfunction'></span><span id='topic+omega.aem'></span><span id='topic+potential.aem'></span><span id='topic+streamfunction.aem'></span><span id='topic+omega.element'></span><span id='topic+potential.element'></span><span id='topic+streamfunction.element'></span>

<h3>Description</h3>

<p><code><a href="#topic+heads">heads()</a></code> computes the hydraulic head at the given x and y coordinates for an <code>aem</code> object.
</p>
<p><code><a href="#topic+omega">omega()</a></code> computes the complex potential for an <code>aem</code> or <code>element</code> object
at the given x and y coordinates.
</p>
<p><code><a href="#topic+potential">potential()</a></code> computes the discharge potential for an <code>aem</code> or <code>element</code> object
at the given x and y coordinates.
</p>
<p><code><a href="#topic+streamfunction">streamfunction()</a></code> computes the stream function for an <code>aem</code> or <code>element</code> object
at the given x and y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heads(aem, x, y, as.grid = FALSE, na.below = TRUE, ...)

omega(...)

potential(...)

streamfunction(...)

## S3 method for class 'aem'
omega(aem, x, y, as.grid = FALSE, ...)

## S3 method for class 'aem'
potential(aem, x, y, as.grid = FALSE, ...)

## S3 method for class 'aem'
streamfunction(aem, x, y, as.grid = FALSE, ...)

## S3 method for class 'element'
omega(element, x, y, ...)

## S3 method for class 'element'
potential(element, x, y, ...)

## S3 method for class 'element'
streamfunction(element, x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="state-variables_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="state-variables_+3A_x">x</code></td>
<td>
<p>numeric x coordinates to evaluate the variable at.</p>
</td></tr>
<tr><td><code id="state-variables_+3A_y">y</code></td>
<td>
<p>numeric y coordinates to evaluate the variable at.</p>
</td></tr>
<tr><td><code id="state-variables_+3A_as.grid">as.grid</code></td>
<td>
<p>logical, should a matrix be returned? Defaults to <code>FALSE</code>. See details.</p>
</td></tr>
<tr><td><code id="state-variables_+3A_na.below">na.below</code></td>
<td>
<p>logical indicating if calculated head values below the aquifer base should be set to <code>NA</code>. Defaults to <code>TRUE</code>. See <code><a href="#topic+potential_to_head">potential_to_head()</a></code>.</p>
</td></tr>
<tr><td><code id="state-variables_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="state-variables_+3A_element">element</code></td>
<td>
<p>analytic element of class <code>element</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+heads">heads()</a></code> should not to be confused with <code><a href="utils.html#topic+head">utils::head()</a></code>, which returns the first part of an object.
</p>


<h3>Value</h3>

<p>For <code><a href="#topic+heads">heads()</a></code>, a vector of <code>length(x)</code> (equal to <code>length(y)</code>) with the hydraulic head values at <code>x</code> and <code>y</code>.
If <code>as.grid = TRUE</code>, a matrix of dimensions <code>c(length(y), length(x))</code> described by
marginal vectors <code>x</code> and <code>y</code> containing the hydraulic head values at the grid points.
The heads are computed from <code><a href="#topic+potential">potential()</a></code> and the aquifer parameters using <code><a href="#topic+potential_to_head">potential_to_head()</a></code>.
</p>
<p>For <code><a href="#topic+omega">omega()</a></code>, the same as for <code><a href="#topic+heads">heads()</a></code> but containing the complex potential values
evaluated at <code>x</code> and <code>y</code>.
</p>
<p>For <code><a href="#topic+potential">potential()</a></code>, the same as for <code><a href="#topic+heads">heads()</a></code> but containing the discharge potential values
evaluated at <code>x</code> and <code>y</code>, which are the real components of <code><a href="#topic+omega">omega()</a></code>.
</p>
<p>For <code><a href="#topic+streamfunction">streamfunction()</a></code>, the same as for <code><a href="#topic+heads">heads()</a></code> but containing the stream function values
evaluated at <code>x</code> and <code>y</code>, which are the imaginary components of <code><a href="#topic+omega">omega()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flow">flow()</a></code>, <code><a href="#topic+satthick">satthick()</a></code>, <code><a href="#topic+head_to_potential">head_to_potential()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- well(xw = 55, yw = 0, Q = 200)
uf &lt;- uniformflow(gradient = 0.002, angle = -45, TR = 100)
rf &lt;- constant(xc = -1000, yc = 1000, hc = 10)
ml &lt;- aem(k = 10, top = 10, base = -15, n = 0.2, w, uf, rf)

xg &lt;- seq(-100, 100, length = 5)
yg &lt;- seq(-75, 75, length = 3)

# Hydraulic heads
heads(ml, c(50, 0), c(25, -25))
heads(ml, xg, yg, as.grid = TRUE)

# do not confuse heads() with utils::head, which will give an error
try(
head(ml, c(50, 0), c(25, -25))
)

# Complex potential
omega(ml, c(50, 0), c(25, -25))

# Discharge potential
potential(ml, c(50, 0), c(25, -25))

# Stream function
streamfunction(ml, c(50, 0), c(25, -25))

# For elements
omega(w, c(50, 0), c(-25, 25))

potential(w, c(50, 0), c(-25, 25))

streamfunction(w, c(50, 0), c(-25, 25))

</code></pre>

<hr>
<h2 id='tracelines'>Compute tracelines of particles</h2><span id='topic+tracelines'></span><span id='topic+endpoints'></span><span id='topic+plot.tracelines'></span>

<h3>Description</h3>

<p><code><a href="#topic+tracelines">tracelines()</a></code> tracks particle locations moving forward or backward with the advective groundwater flow
by numerically integrating the velocity vector. The resulting set of connected coordinates produces the
tracelines.
</p>
<p><code><a href="#topic+endpoints">endpoints()</a></code> obtains the final time and locations of tracked particles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracelines(
  aem,
  x0,
  y0,
  z0,
  times,
  forward = TRUE,
  R = 1,
  tfunc = NULL,
  tol = 0.001,
  ncores = 0,
  ...
)

endpoints(tracelines, ...)

## S3 method for class 'tracelines'
plot(x, y = NULL, add = FALSE, type = "l", arrows = FALSE, marker = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tracelines_+3A_aem">aem</code></td>
<td>
<p><code>aem</code> object.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_x0">x0</code></td>
<td>
<p>numeric vector with starting x locations of the particles.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_y0">y0</code></td>
<td>
<p>numeric vector with starting y locations of the particles.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_z0">z0</code></td>
<td>
<p>numeric vector with starting z locations of the particles.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_times">times</code></td>
<td>
<p>numeric vector with the times at which particle locations should be registered.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_forward">forward</code></td>
<td>
<p>logical, should forward (<code>TRUE</code>; default) or backward (<code>FALSE</code>) tracking be performed.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_r">R</code></td>
<td>
<p>numeric, retardation coefficient passed to <code><a href="#topic+velocity">velocity()</a></code>. Defaults to 1 (no retardation).</p>
</td></tr>
<tr><td><code id="tracelines_+3A_tfunc">tfunc</code></td>
<td>
<p>function or list of functions with additional termination events for particles. See details. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_tol">tol</code></td>
<td>
<p>numeric tolerance used to define when particles have crossed a line element. Defaults to 0.001 length units.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_ncores">ncores</code></td>
<td>
<p>integer, number of cores to use when running in parallel. Defaults to 0 (no parallel computing). See details.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+plot">plot()</a></code> or <code><a href="graphics.html#topic+arrows">arrows()</a></code> when plotting. Otherwise ignored.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_tracelines">tracelines</code></td>
<td>
<p>object of class <code>tracelines</code> as returned by <code><a href="#topic+tracelines">tracelines()</a></code>.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_x">x</code></td>
<td>
<p>object of class <code>tracelines</code>.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_y">y</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="tracelines_+3A_add">add</code></td>
<td>
<p>logical, should the plot be added to the existing plot? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_type">type</code></td>
<td>
<p>character indicating what type of plot to draw. See <code><a href="base.html#topic+plot">plot()</a></code>. Defaults to <code>'l'</code> (lines).</p>
</td></tr>
<tr><td><code id="tracelines_+3A_arrows">arrows</code></td>
<td>
<p>logical indicating if arrows should be drawn using <code><a href="graphics.html#topic+arrows">arrows()</a></code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tracelines_+3A_marker">marker</code></td>
<td>
<p>numeric, time interval at which to plot point markers. Defaults to <code>NULL</code> (no markers). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="deSolve.html#topic+lsoda">deSolve::lsoda()</a></code> is used to numerically integrate the velocity vector.
</p>
<p>Particles are terminated prematurely when they have reached the inner annulus of well elements, when they
have crossed a line element (or enter half its non-zero width on either side) or when they travel above the saturated aquifer
level (i.e. the water-table for unconfined conditions or the aquifer top for confined conditions), or below the aquifer base.
Note that these last two conditions can only occur in models with vertical flow components.
The returned time value is the time of termination.
</p>
<p>The <code>tfunc</code> argument can be used to specify additional termination events. It is a function (or a list of functions) that
takes arguments <code>t</code>, <code>coords</code> and <code>parms</code>. These are, respectively, a numeric value with the current tracking time,
a numeric vector of length 3 with the current <code>x</code>, <code>y</code> and <code>z</code> coordinate of the particle, and a list with elements
<code>aem</code> and <code>R</code> (named as such). It should return a single logical value indicating if the particle should terminate. See examples.
</p>
<p>If initial particle locations are above the saturated aquifer level, they are reset to this elevation with a warning.
Initial particle locations below the aquifer base are reset at the aquifer base with a warning. A small
perturbation is added to these elevations to avoid the particle tracking algorithm to get stuck at these locations.
If the algorithm does get stuck (i.e. excessive run-times), try resetting the <code>z0</code> values to elevations well inside the saturated domain.
</p>
<p>Initial particle locations inside a termination point are dropped with a warning.
</p>
<p>Backward particle tracking is performed by reversing the flow field (i.e. multiplying the velocities with <code>-1</code>).
</p>
<p>Traceline computation is embarrassingly parallel. When <code>ncores &gt; 0</code>, the <code>parallel</code> package is used to set up the cluster with the requested nodes and
the tracelines are computed using <code><a href="parallel.html#topic+clusterApply">parallel::parLapplyLB()</a></code>. <code>ncores</code> should not exceed the number of available cores as returned by <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.
</p>


<h4>Plotting</h4>

<p>The <code>marker</code> value can be used to plot point markers at given time intervals, e.g. every 365 days (see examples).
The x and y locations of each particle at the marked times are obtained by linearly interpolating from the computed particle locations.
</p>



<h3>Value</h3>

<p><code><a href="#topic+tracelines">tracelines()</a></code> returns an object of class <code>tracelines</code> which is a list with length equal to the number of particles where each list element contains
a matrix with columns <code>time</code>, <code>x</code>, <code>y</code> and <code>z</code> specifying the registered time and coordinates of the particle as it is tracked through the flow field.
</p>
<p>The final row represents either the location at the maximum <code>times</code> value or, if the particle terminated prematurely, the time and location of the termination.
</p>
<p>The matrices are ordered in increasing time. By connecting the coordinates, the tracelines can be produced.
</p>
<p><code><a href="#topic+endpoints">endpoints()</a></code> returns a matrix with columns <code>time</code>, <code>x</code>, <code>y</code> and <code>z</code> specifying the final time and coordinates
of the particles in the <code>tracelines</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capzone">capzone()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a model with uniform background flow
k &lt;- 10
top &lt;- 10; base &lt;- 0
n &lt;- 0.2
R &lt;- 5
hc &lt;- 20

uf &lt;- uniformflow(TR = 100, gradient = 0.001, angle = -10)
rf &lt;- constant(TR, xc = -1000, yc = 0, hc = hc)

m &lt;- aem(k, top, base, n = n, uf, rf)

# calculate forward particle traces
x0 &lt;- -200; y0 &lt;- seq(-200, 200, 200)
times &lt;- seq(0, 25 * 365, 365 / 4)
paths &lt;- tracelines(m, x0 = x0, y0 = y0, z = top, times = times)
endp &lt;- endpoints(paths)

xg &lt;- seq(-500, 500, length = 100)
yg &lt;- seq(-300, 300, length = 100)

# plot
contours(m, xg, yg, col = 'dodgerblue', nlevels = 20)
plot(paths, add = TRUE, col = 'orange')
points(endp[, c('x', 'y')])

# Backward tracking with retardation; plot point marker every 5 years
paths_back &lt;- tracelines(m, x0 = x0, y0 = y0, z0 = top, times = times, R = R, forward = FALSE)
plot(paths_back, add = TRUE, col = 'forestgreen', marker = 5*365, cex = 0.5)

# -------
# Termination at wells, line-sinks and user-defined zone
w1 &lt;- well(200, 50, Q = 250)
w2 &lt;- well(-200, -100, Q = 450)
ls &lt;- headlinesink(x0 = -100, y0 = 100, x1 = 400, y1 = -300, hc = 7)

m &lt;- aem(k, top, base, n = n, uf, rf, w1, w2, ls)

# User-defined termination in rectangular zone
tzone &lt;- cbind(x = c(-300, -200, -200, -300), y = c(150, 150, 100, 100))
termf &lt;- function(t, coords, parms) {
  x &lt;- coords[1]
  y &lt;- coords[2]
  in_poly &lt;- x &lt;= max(tzone[,'x']) &amp; x &gt;= min(tzone[,'x']) &amp;
    y &lt;= max(tzone[,'y']) &amp; y &gt;= min(tzone[,'y'])
  return(in_poly)
}

x0 &lt;- c(-300, -200, 0, 200, 300)
y0 &lt;- 200
times &lt;- seq(0, 5 * 365, 365 / 15)
paths &lt;- tracelines(m, x0 = x0, y0 = y0, z0 = top, times = times, tfunc = termf)

contours(m, xg, yg, col = 'dodgerblue', nlevels = 20)
plot(m, add = TRUE)
polygon(tzone)
plot(paths, add = TRUE, col = 'orange')

# -------
# model with vertical flow due to area-sink
as &lt;- areasink(xc = 0, yc = 0, N = 0.001, R = 1500)
m &lt;- aem(k, top, base, n = n, uf, rf, w1, w2, as)

# starting z0 locations are above aquifer top and will be reset to top with warning
x0 &lt;- seq(-400, 200, 200); y0 &lt;- 200
times &lt;- seq(0, 5 * 365, 365 / 4)
paths &lt;- tracelines(m, x0 = x0, y0 = y0, z0 = top + 0.5, times = times)

contours(m, xg, yg, col = 'dodgerblue', nlevels = 20)
plot(m, add = TRUE)
plot(paths, add = TRUE, col = 'orange')

# -------
# plot vertical cross-section of traceline 4 along increasing y-axis (from south to north)
plot(paths[[4]][,c('y', 'z')], type = 'l')

# -------
# parallel computing by setting ncores &gt; 0
mp &lt;- aem(k, top, base, n = n, uf, rf)
pathsp &lt;- tracelines(mp, x0 = x0, y0 = y0, z = top, times = times, ncores = 2)

# -------
# plot arrows
contours(m, xg, yg, col = 'dodgerblue', nlevels = 20)
plot(paths, add = TRUE, col = 'orange', arrows = TRUE, length = 0.05)

# plot point markers every 2.5 years
contours(m, xg, yg, col = 'dodgerblue', nlevels = 20)
plot(paths, add = TRUE, col = 'orange', marker = 2.5 * 365, pch = 20)

# plot point markers every 600 days
plot(paths, add = TRUE, col = 'forestgreen', marker = 600, pch = 1)

</code></pre>

<hr>
<h2 id='uniformflow'>Create an analytic element with uniform flow</h2><span id='topic+uniformflow'></span>

<h3>Description</h3>

<p><code><a href="#topic+uniformflow">uniformflow()</a></code> creates an analytic element of constant uniform background flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniformflow(TR, gradient, angle, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniformflow_+3A_tr">TR</code></td>
<td>
<p>numeric, constant transmissivity value used to define the discharge.</p>
</td></tr>
<tr><td><code id="uniformflow_+3A_gradient">gradient</code></td>
<td>
<p>numeric, hydraulic gradient. Positive in the direction of flow.</p>
</td></tr>
<tr><td><code id="uniformflow_+3A_angle">angle</code></td>
<td>
<p>numeric, angle of the primary direction of background flow
in degrees counterclockwise from the x-axis.</p>
</td></tr>
<tr><td><code id="uniformflow_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>TR</code> and <code>gradient</code> are multiplied to obtain the discharge which remains
constant throughout the system, independent of the saturated thickness of the aquifer.
</p>
<p>Groundwater flow is always in the direction of the <em>negative</em> hydraulic gradient. Note that <code>gradient</code> is
specified here as positive in the direction of flow for convenience.
</p>


<h3>Value</h3>

<p>Analytic element of constant uniform flow which is an object of class <code>uniformflow</code> and inherits from <code>element</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uf &lt;- uniformflow(TR = 100, gradient = 0.002, angle = -45) # South-eastern direction
</code></pre>

<hr>
<h2 id='well'>Create an analytic element of a constant-discharge well</h2><span id='topic+well'></span>

<h3>Description</h3>

<p><code><a href="#topic+well">well()</a></code> creates an analytic element of a well with constant discharge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>well(xw, yw, Q, rw = 0.3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="well_+3A_xw">xw</code></td>
<td>
<p>numeric, x location of the well.</p>
</td></tr>
<tr><td><code id="well_+3A_yw">yw</code></td>
<td>
<p>numeric, y location of the well.</p>
</td></tr>
<tr><td><code id="well_+3A_q">Q</code></td>
<td>
<p>numeric, volumetric discharge of the well (positive is out of aquifer).</p>
</td></tr>
<tr><td><code id="well_+3A_rw">rw</code></td>
<td>
<p>numeric, radius of well. Defaults to 0.3 length units.</p>
</td></tr>
<tr><td><code id="well_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inner annulus of a well element constitutes a singularity in the equations as the hydraulic head is undefined at
a distance smaller than <code>rw</code> from the well center. If a state- or flow-variable is calculated within this annulus, its
location is reset to its nearest location on the well screen.
</p>
<p>The well is assumed to fully penetrate the saturated aquifer.
</p>


<h3>Value</h3>

<p>Analytic element of a well with constant discharge which is an object of class <code>well</code> and inherits from <code>element</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+headwell">headwell()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- well(xw = 50, yw = 0, Q = 200, rw = 0.3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
