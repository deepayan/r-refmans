<!DOCTYPE html><html><head><title>Help for package colorSpec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {colorSpec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#colorSpec-package'><p>Package colorSpec - Color Calculations with Emphasis on Spectral Data</p></a></li>
<li><a href='#ABC'>
<p>Standard Illuminants A, B, and C (1931)</p></a></li>
<li><a href='#actinometric'><p>convert a colorSpec object to be actinometric</p></a></li>
<li><a href='#applyspec'><p>apply a function to each spectrum in a colorSpec object</p></a></li>
<li><a href='#as.data.frame'><p>Convert a colorSpec Object to a data.frame</p></a></li>
<li><a href='#atmosphere'><p>atmospheric transmittance along a horizontal path</p></a></li>
<li><a href='#bandSpectra'><p>Compute Band-based Material Spectra, and Bands for Existing Material Spectra</p></a></li>
<li><a href='#bind'><p>Combine colorSpec Objects</p></a></li>
<li><a href='#calibrate'><p>make a linear modification to a colorSpec responder</p></a></li>
<li><a href='#canonicalOptimalColors'><p>compute the Canonical Optimal Colors</p></a></li>
<li><a href='#chop'><p>chop spectra into low and high parts</p></a></li>
<li><a href='#colorSpec'><p>constructing and testing colorSpec Objects</p></a></li>
<li><a href='#computeADL'><p>compute ADL coordinates by ray tracing</p></a></li>
<li><a href='#computeCCT'><p>Compute Correlated Color Temperature (CCT) of Light Spectra</p></a></li>
<li><a href='#computeCRI'><p>Compute Color Rendering Index (CRI) of Light Spectra</p></a></li>
<li><a href='#computeSSI'><p>Compute the Spectrum Similarity Index of light spectra</p></a></li>
<li><a href='#convolvewith'><p>Convolve each spectrum in a colorSpec object with a kernel</p></a></li>
<li><a href='#coredata'><p>Extract the Core Data of a colorSpec Object</p></a></li>
<li><a href='#cs.options'><p>Functions to set and retrieve colorSpec package options</p></a></li>
<li><a href='#D50'>
<p>Standard Illuminant D50 (1964)</p></a></li>
<li><a href='#D65'>
<p>Standard Illuminant D65 (1964)</p></a></li>
<li><a href='#daylight'>
<p>Standard Daylight Components</p></a></li>
<li><a href='#DisplayRGB'><p>Compute Display RGB from Linear RGB</p></a></li>
<li><a href='#emulate'><p>modify a colorSpec responder to emulate (approximate) another responder</p></a></li>
<li><a href='#extradata'><p>extradata of a colorSpec object</p></a></li>
<li><a href='#F96T12'>
<p>Photon Irradiance of F96T12 Fluorescent Bulb</p></a></li>
<li><a href='#Flea2.RGB'>
<p>Flea2 Camera FL2-14S3C from Point Grey</p></a></li>
<li><a href='#Fluorescents'>
<p>Standard series F Illuminants F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, and F12</p></a></li>
<li><a href='#HigherPasserines'>
<p>Cone Fundamentals for the Higher Passerines</p></a></li>
<li><a href='#Hoya'>
<p>standard Hoya filters</p></a></li>
<li><a href='#interpolate'><p>interpolate spectra</p></a></li>
<li><a href='#invert'><p>estimate spectra from responses, effectively inverting the operator from spectrum to response</p></a></li>
<li><a href='#lightResponsivitySpectra'><p>compute standard light responsivity spectra</p></a></li>
<li><a href='#LightSpectra'><p>compute standard light spectra</p></a></li>
<li><a href='#linearize'><p>linearize a colorSpec object - to make it ready for colorimetric calculations</p></a></li>
<li><a href='#lms1971'><p>Cone Fundamentals - 2-degree (1971)</p></a></li>
<li><a href='#lms2000'><p>Cone Fundamentals - 2-degree (2000)</p></a></li>
<li><a href='#logging'><p>Logging in colorSpec package</p></a></li>
<li><a href='#luminsivity'><p>Luminous Efficiency Functions (photopic and scotopic)</p></a></li>
<li><a href='#materialSpectra'><p>compute standard material spectra</p></a></li>
<li><a href='#mean'><p>calculate mean of multiple spectra</p></a></li>
<li><a href='#metadata'><p>metadata of a colorSpec object</p></a></li>
<li><a href='#multiply'><p>multiply a colorSpec object by scalar, vector, or matrix</p></a></li>
<li><a href='#officialXYZ'><p>Query the Official XYZ values for Standard Illuminants</p></a></li>
<li><a href='#organization'><p>organization of a colorSpec object</p></a></li>
<li><a href='#photometric'><p>convert illuminant spectra to photometric units</p></a></li>
<li><a href='#plot'><p>plot spectra</p></a></li>
<li><a href='#plotOptimals'><p>Plot Optimal Colors</p></a></li>
<li><a href='#print'><p>Convert colorSpec object to readable text</p></a></li>
<li><a href='#probeOptimalColors'><p>compute optimal colors by ray tracing</p></a></li>
<li><a href='#product'><p>Compute the product of colorSpec objects</p></a></li>
<li><a href='#ptransform'><p>make a linear transformation to a colorSpec responder</p></a></li>
<li><a href='#quantity'><p>quantity of a colorSpec object</p></a></li>
<li><a href='#radiometric'><p>convert a colorSpec object from actinometric to radiometric</p></a></li>
<li><a href='#readCGATS'><p>read tables from files in ANSI/CGATS.17 format</p></a></li>
<li><a href='#readSpectra'><p>read colorSpec objects from files</p></a></li>
<li><a href='#resample'><p>resample a colorSpec Object to new wavelengths</p></a></li>
<li><a href='#responsivityMetrics'><p>Compute Metrics for a Light Responder (e.g. a camera) or a Material Responder (e.g. a scanner)</p></a></li>
<li><a href='#scanner'>
<p>standard RGB scanners</p></a></li>
<li><a href='#sectionOptimalColors'><p>compute sections of an optimal color surface by hyperplanes</p></a></li>
<li><a href='#solar.irradiance'>
<p>Standard Solar Irradiance - Extraterrestrial and Terrestrial</p></a></li>
<li><a href='#specnames'><p>specnames of a colorSpec object</p></a></li>
<li><a href='#standardRGB'><p>Convert from XYZ to some standard RGB spaces</p></a></li>
<li><a href='#subset'><p>extract a subset of a colorSpec Object</p></a></li>
<li><a href='#theoreticalRGB'>
<p>Theoretical RGB Cameras - BT.709.RGB, Adobe.RGB, and ACES.RGB</p></a></li>
<li><a href='#wavelength'><p>wavelength vector of a colorSpec object</p></a></li>
<li><a href='#xyz1931'>
<p>CIE Color Matching Functions - 2-degree (1931)</p></a></li>
<li><a href='#xyz1964'>
<p>CIE Color Matching Functions - 10-degree (1964)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Color Calculations with Emphasis on Spectral Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5-0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Glenn Davis [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Glenn Davis &lt;gdavis@gluonics.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate with spectral properties of light sources, materials, cameras, eyes, and scanners.
    Build complex systems from simpler parts using a spectral product algebra. For light sources,
    compute CCT, CRI, and SSI.  For object colors, compute optimal colors and Logvinenko coordinates.
    Work with the standard CIE illuminants and color matching functions, and read spectra from 
    text files, including CGATS files.  Estimate a spectrum from its response. A user guide and 9 vignettes are included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spacesXYZ, rootSolve, MASS, quadprog, rgl, knitr, rmarkdown,
spacesRGB, microbenchmark, arrangements</td>
</tr>
<tr>
<td>Enhances:</td>
<td>plyr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-28 02:44:27 UTC; Glenn</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-28 06:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='colorSpec-package'>Package colorSpec - Color Calculations with Emphasis on Spectral Data</h2><span id='topic+colorSpec-package'></span>

<h3>Description</h3>

<p>Package <span class="pkg">colorSpec</span> is for working with spectral color data in <span class="rlang"><b>R</b></span>.
</p>


<h3>Details</h3>

<p><b>Features</b>:
</p>

<ol>
<li><p> a clear classification of the commonly seen spectra into 4 types - depending on the vector space to which they belong
</p>
</li>
<li><p>  flexible organization for the spectra in memory, using an S3 class - <b>colorSpec</b>
</p>
</li>
<li><p>  a product algebra for the <b>colorSpec</b> objects
</p>
</li>
<li><p>  uniform handling of biological eyes, electronic cameras, and general action spectra
</p>
</li>
<li><p>  a few advanced calculations, such as computing optimal colors  (aka Macadam Limits)
</p>
</li>
<li><p>  inverse colorimetry, e.g. reflectance recovery from response
</p>
</li>
<li><p>  built-in essential tables, such as the CIE illuminants and color matching functions
</p>
</li>
<li><p>  a package logging system with log levels taken from the popular <b>Log4J</b>
</p>
</li>
<li><p>  support for reading a few spectrum file types, including CGATS
</p>
</li>
<li><p>  bonus files containing some other interesting spectra
</p>
</li>
<li><p>  minimal dependencies on other <span class="rlang"><b>R</b></span> packages
</p>
</li></ol>

<p><b>Non-features</b>:
</p>

<ol>
<li><p> there is no support for many common 3D color spaces, such as CIELAB, HSL, etc..  
For these spaces see packages 
<span class="pkg">colorspace</span>,
<span class="pkg">colorscience</span>,
<span class="pkg">spacesRGB</span>, and
<span class="pkg">spacesXYZ</span>.
</p>
</li>
<li><p>  there are few non-linear operations 
</p>
</li>
<li><p>  there is little support for scientific units; for these see package <span class="pkg">colorscience</span>
</p>
</li>
<li><p> photons are parameterized by wavelength in nanometers; 
other wavelength units (such as Angstrom and micron)
and alternative parameterizations (such as wavenumber and electronvolt)
are not available
</p>
</li></ol>

<p>Regarding the non-linear operations in 2, 
the only such operations are conversion of linear RGB to display RGB, 
conversion of absorbance to transmittance,
and the reparameterized wavelength in <code><a href="#topic+computeADL">computeADL</a></code>.
The electronic camera model is purely linear
with no dark current offset or other deviations.
</p>
<p>Many ideas are taken from packages
<span class="pkg">hyperSpec</span>, <span class="pkg">hsdar</span>, <span class="pkg">pavo</span>, and <span class="pkg">zoo</span>.
</p>


<h3>Author(s)</h3>

<p>Glenn Davis &lt;gdavis@gluonics.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorSpec">colorSpec</a></code> for the S3 class provided by this package.
</p>
<p><b>colorSpec User Guide</b>
</p>

<hr>
<h2 id='ABC'>
Standard Illuminants A, B, and C (1931)
</h2><span id='topic+A.1nm'></span><span id='topic+B.5nm'></span><span id='topic+C.5nm'></span><span id='topic+ABC'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>A.1nm</code> </td><td style="text-align: left;"> standard Illuminant A, 360 to 780 nm at 1 nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>B.5nm</code> </td><td style="text-align: left;"> standard Illuminant B, 320 to 780 nm at 5 nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>C.5nm</code> </td><td style="text-align: left;"> standard Illuminant C, 320 to 780 nm at 5 nm intervals
</td>
</tr>

</table>



<h3>Format</h3>

<p>Each is a <b>colorSpec</b> object organized as a vector, with <code><a href="#topic+quantity">quantity</a></code> equal to <code>"energy".</code>
</p>


<h3>Details</h3>

<p>All of these have been divided by 100, to make the values at 560nm near 1 instead of 100.
</p>


<h3>Source</h3>

<p><a href="http://www.cvrl.org">http://www.cvrl.org</a>
</p>


<h3>References</h3>

<p>Günther Wyszecki and W. S. Stiles.
<b>Color Science : Concepts and Methods, Quantitative Data and Formulae</b>.
Second Edition.
Wiley-Interscience. 1982.
</p>

<table>
<tr>
 <td style="text-align: left;">
A </td><td style="text-align: left;"> Table I(3.3.4)  pp. 754-758. </td>
</tr>
<tr>
 <td style="text-align: left;">
B </td><td style="text-align: left;"> Table II(3.3.4)  pp. 759. </td>
</tr>
<tr>
 <td style="text-align: left;">
C </td><td style="text-align: left;"> Table II(3.3.4)  pp. 759. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+D50">D50</a></code>
<code><a href="#topic+D65">D65</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(xyz1931.1nm)
white.point = product( D65.1nm, xyz1931.1nm, wave='auto' )
</code></pre>

<hr>
<h2 id='actinometric'>convert a colorSpec object to be actinometric</h2><span id='topic+actinometric.colorSpec'></span><span id='topic+actinometric'></span><span id='topic+is.actinometric.colorSpec'></span><span id='topic+is.actinometric'></span>

<h3>Description</h3>

<p>Convert a radiometric <b>colorSpec</b> object to have
quantity that is actinometric (number of photons).
Test an object for whether it is actinometric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
actinometric( x, multiplier=1, warn=FALSE )

## S3 method for class 'colorSpec'
is.actinometric( x )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actinometric_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object</p>
</td></tr>
<tr><td><code id="actinometric_+3A_multiplier">multiplier</code></td>
<td>
<p>a scalar which is multiplied by the output, and intended for unit conversion</p>
</td></tr>
<tr><td><code id="actinometric_+3A_warn">warn</code></td>
<td>
<p>if <code>TRUE</code> and a conversion actually takes place, the a <code>WARN</code> message is issued.
This makes the user aware of the conversion, so units can be verified.  This can be useful when <code>actinometric()</code> is called from another <b>colorSpec</b> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code><a href="#topic+quantity">quantity</a></code> of <code>x</code> does not start with <code>'energy'</code>
then the quantity is not radiometric and so <code>x</code> is returned unchanged.
Otherwise <code>x</code> is radiometric (energy-based), and must be converted.
</p>
<p>If <code><a href="#topic+type">type</a>(x)</code> is <code>'light'</code> then
the most common radiometric energy unit is joule.<br />
The conversion equation is:
</p>
<p style="text-align: center;"><code class="reqn"> Q = E * \lambda * 10^6 / (N_A * h * c)</code>
</p>

<p>wher <code class="reqn">Q</code> is the photon count,
<code class="reqn">E</code> is the energy of the photons,
<code class="reqn">N_A</code> is Avogadro's constant,
<code class="reqn">h</code> is Planck's constant, <code class="reqn">c</code> is the speed of light,
and <code class="reqn">\lambda</code> is the wavelength.
The output unit of photon count is
(<code class="reqn">\mu</code>mole of photons) = (<code class="reqn">6.02214 * 10^{17}</code> photons).
If a different unit for <code>Q</code> is desired, 
then the output should be scaled appropriately.
For example, if the desired unit of photon count is exaphotons,
then set <code>multiplier=0.602214</code>.
</p>
<p>If the <code><a href="#topic+quantity">quantity</a>(x)</code> is <code>'energy-&gt;electrical'</code>,
then the most common radiometric unit of responsivity to light
is coulombs/joule (C/J) or  amps/watt (A/W).
The conversion equation is:
</p>
<p style="text-align: center;"><code class="reqn"> QE = R_e * ((h * c)/e) / \lambda </code>
</p>

<p>where <code class="reqn">QE</code> is the quantum efficiency,
<code class="reqn">R_e</code> is the energy-based responsivity,
and <code class="reqn">e</code> is the charge of an electron (in C).<br />
If the unit of <code>x</code> is not C/J, 
then <code>multiplier</code> should be set appropriately.
</p>
<p>If the <code><a href="#topic+quantity">quantity</a>(x)</code> is 
<code>'energy-&gt;neural'</code> or  <code>'energy-&gt;action'</code>,
the most common radiometric unit of energy is joule (J).
</p>
<p>The conversion equation is:
</p>
<p style="text-align: center;"><code class="reqn"> R_p = R_e  * 10^{-6} * ( N_A * h * c) / \lambda </code>
</p>

<p>where <code class="reqn">R_p</code> is the photon-based responsivity,
and <code class="reqn">R_e</code> is the energy-based responsivity,
The output unit of photon count is
(<code class="reqn">\mu</code>mole of photons) = (<code class="reqn">6.02214 * 10^{17}</code> photons).
This essentially the reciprocal of the first conversion equation.
</p>
<p>The argument <code>multiplier</code> is applied to the right side of all the above
conversion equations.
</p>


<h3>Value</h3>

<p><code>actinometric()</code> returns a <b>colorSpec</b> object
with <code><a href="#topic+quantity">quantity</a></code> that is
actinometric (photon-based) and not radiometric (energy-based).
If <code>type(x)</code> is a material type
(<code>'material'</code> or <code>'responsivity.material'</code>)
then <code>x</code> is returned unchanged.
</p>
<p>If <code>quantity(x)</code> starts with <code>'photons'</code>,
then <code>is.actinometric()</code> returns <code>TRUE</code>, and otherwise <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>To log the executed conversion equation,
execute <code>cs.options(loglevel='INFO')</code>.
</p>


<h3>Source</h3>

<p>Wikipedia.
<b>Photon counting</b>.
<a href="https://en.wikipedia.org/wiki/Photon_counting">https://en.wikipedia.org/wiki/Photon_counting</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>, 
<code><a href="#topic+type">type</a></code>,
<code><a href="#topic+cs.options">cs.options</a></code>,
<code><a href="#topic+radiometric">radiometric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colSums( solar.irradiance ) # step size is 1nm, from 280 to 1000 nm. organized as a matrix
# AirMass.0  GlobalTilt AirMass.1.5 
#  944.5458    740.3220    649.7749  # irradiance, watts*m^{-2}


colSums( actinometric(solar.irradiance) )
# AirMass.0  GlobalTilt AirMass.1.5 
#  4886.920    3947.761    3522.149  # photon irradiance, (umoles of photons)*sec^{-1}*m^{-2}

colSums( actinometric(solar.irradiance,multiplier=0.602214) )
# AirMass.0  GlobalTilt AirMass.1.5 
#  2942.972    2377.397    2121.088  # photon irradiance, exaphotons*sec^{-1}*m^{-2}

</code></pre>

<hr>
<h2 id='applyspec'>apply a function to each spectrum in a colorSpec object</h2><span id='topic+applyspec.colorSpec'></span><span id='topic+applyspec'></span>

<h3>Description</h3>

<p>apply a function to each spectrum in a <b>colorSpec</b> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
applyspec( x, FUN, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyspec_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with N wavelengths</p>
</td></tr>
<tr><td><code id="applyspec_+3A_fun">FUN</code></td>
<td>
<p>a function that takes an N-vector as argument and returns an N-vector</p>
</td></tr>  
<tr><td><code id="applyspec_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>applyspec()</code> simply calls <code><a href="base.html#topic+apply">apply</a>()</code>
with the right <code>MARGIN</code>.
</p>


<h3>Value</h3>

<p>a <b>colorSpec</b> object with the same dimensions,
<code><a href="#topic+wavelength">wavelength</a></code>, <code><a href="#topic+quantity">quantity</a></code>, and <code><a href="#topic+organization">organization</a></code>.
If <code>FUN</code> does not return an N-vector, it is an ERROR and
<code>applyspec()</code> returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>,
<code><a href="#topic+wavelength">wavelength</a></code>,
<code><a href="#topic+linearize">linearize</a></code>,  
<code><a href="#topic+organization">organization</a></code>,
<code><a href="base.html#topic+apply">apply</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  convert absorbance to transmittance
path = system.file( "extdata/stains/Hematoxylin.txt", package='colorSpec' )
x = readSpectra( path )
x = applyspec( x, function(y) {10^(-y)} ) # this is what linearize(x) does
</code></pre>

<hr>
<h2 id='as.data.frame'>Convert a colorSpec Object to a data.frame</h2><span id='topic+as.data.frame.colorSpec'></span>

<h3>Description</h3>

<p>convert a <b>colorSpec</b> object to a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
as.data.frame( x, row.names=NULL, optional=FALSE, organization='auto', ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_organization">organization</code></td>
<td>
<p>The organization of the returned <code>data.frame</code>,
which can be <code>'row'</code>, <code>'col'</code>, or <code>'auto'</code>.
If <code>'auto'</code>, then <code>'row'</code> or <code>'col'</code> is selected automatically,
see <b>Details</b></p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_row.names">row.names</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_optional">optional</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p>extra arguments ignored</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>If <code>organization</code> is <code>'auto'</code>,
and the organization of <code>x</code> is <code>'df.row'</code>,
then <code>organization</code> is set to <code>'row'</code>
and the returned <code>data.frame</code> has the spectra in the rows.
Otherwise the returned <code>data.frame</code> has the spectra in the columns.
</p>


<h3>Value</h3>

<p>If the returned <code>data.frame</code> has the spectra in the rows,
then the spectra are in a matrix in the last column (with name <code>spectra</code>),
and any existing <code>extradata</code> are also returned in the other columns.
The wavelengths are only present in character form,
as the <code>colnames</code> of the matrix.<br />
If the returned <code>data.frame</code> has the spectra in the columns,
then the wavelengths are in the first column, and the spectra are in the other columns.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.matrix">as.matrix</a></code>,
<code><a href="#topic+extradata">extradata</a></code>
</p>

<hr>
<h2 id='atmosphere'>atmospheric transmittance along a horizontal path</h2><span id='topic+atmosTransmittance'></span>

<h3>Description</h3>

<p>Calculate transmittance along a horizontal optical path in the atmosphere,
as a function of length (distance) and the molecular and aerosol properties.
Because the path is horizontal, the atmospheric properties are
assumed to be constant on the path.
Only molecular scattering is considered.
There is no modeling of molecular absorption;
for visible wavelengths this is reasonable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atmosTransmittance( distance, wavelength=380:720, 
                    molecules=list(N=2.547305e25,n0=1.000293),
                    aerosols=list(metrange=25000,alpha=0.8,beta=0.0001) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atmosphere_+3A_distance">distance</code></td>
<td>
<p>the length of the optical path, in meters.
It can also be a numeric vector of lengths.</p>
</td></tr>
<tr><td><code id="atmosphere_+3A_wavelength">wavelength</code></td>
<td>
<p>a vector of wavelengths, in nm, for the transmittance calculations</p>
</td></tr>
<tr><td><code id="atmosphere_+3A_molecules">molecules</code></td>
<td>
<p>a list of molecular properties, see <b>Details</b>.
If this is <code>NULL</code>, then the molecular transmittance is identically 1.</p>
</td></tr>
<tr><td><code id="atmosphere_+3A_aerosols">aerosols</code></td>
<td>
<p>a list of aerosol properties, see <b>Details</b>.
If this is <code>NULL</code>, then the aerosol transmittance is identically 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list <code>molecules</code> has 2 parameters that describe the molecules in the atmosphere.
<code>N</code> is the molecular density of the atmosphere at sea level,
in <code class="reqn">molecules/meter^3</code>.
The given default is the density at sea level.
<code>n0</code> is the refractive index of pure molecular air (with no aerosols).
For the molecular attenuation,
the standard model for Rayleigh scattering is used,
and there is no modeling of molecular absorption.
</p>
<p>The list <code>aerosols</code> has 3 parameters that describe the aerosols in the atmosphere.
The standard Angstrom aerosol attenuation model is:
</p>
<p style="text-align: center;"><code class="reqn">attenuation(\lambda) = \beta * (\lambda/\lambda_0)^{-\alpha}</code>
</p>

<p><code class="reqn">\alpha</code> is the Angstrom exponent, and is dimensionless.
<code class="reqn">attenuation</code> and <code class="reqn">\beta</code> have unit <code class="reqn">m^{-1}</code>.
And <code class="reqn">\lambda_0</code>=550nm.
</p>
<p><code>metrange</code> is the <em>Meteorological Range</em> of the atmosphere in meters,
as defined by <cite>Koschmieder</cite>.
This is the distance at which the transmittance=0.02 at <code class="reqn">\lambda_0</code>.
If <code>metrange</code> is not <code>NULL</code> (the default is 25000)
then both <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are calculated to achieve
this desired <code>metrange</code>, and the supplied <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
are ignored.
<code class="reqn">\alpha</code> is calculated from <code>metrange</code> using the <cite>Kruse</cite> model,
see <b>Note</b>.
<code class="reqn">\beta</code> is calculated so that the product of
molecular and aerosol transmittance yields the desired <code>metrange</code>.
In fact:
</p>
<p style="text-align: center;"><code class="reqn">\beta = -\mu_0 - log(0.02) / V_r</code>
</p>

<p>where <code class="reqn">\mu_0</code> is the molecular attenuation at <code class="reqn">\lambda_0</code>,
and <code class="reqn">V_r</code> is the meteorological range.
For a log message with the calculated values,
execute <code>cs.options(loglevel='INFO')</code> before calling <code>atmosTransmittance()</code>.
</p>


<h3>Value</h3>

<p><code>atmosTransmittance()</code> returns a
<b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'transmittance'</code>.
There is a spectrum in the object for each value in the vector <code>distance</code>.
The <code>specnames</code> are set to <code>sprintf("dist=%gm",distance)</code>.<br />
The final transmittance is the product of the molecular transmittance
and the aerosol transmittance.
If both <code>molecules</code> and <code>aerosols</code> are <code>NULL</code>,
then the final transmittance is identically 1;
the atmosphere has become a vacuum.
</p>


<h3>Note</h3>

<p>The Kruse model for <code class="reqn">\alpha</code> as a function of <code class="reqn">V_r</code>
is defined in 3 pieces.
For <code class="reqn">0 \le V_r &lt; 6000</code>, <code class="reqn">\alpha = 0.585 * (V_r/1000)^{1/3}</code>.
For <code class="reqn">6000 \le V_r &lt; 50000</code>, <code class="reqn">\alpha = 1.3</code>.
And for <code class="reqn">V_r \ge</code> 50000, <code class="reqn">\alpha = 1.6</code>.
So <code class="reqn">\alpha</code> is increasing, but not strictly, and not continuously.
<code class="reqn">V_r</code> is in meters.
See <em>Kruse</em> and <em>Kaushal</em>.
</p>
<p>The built-in object <code><a href="#topic+atmosphere2003">atmosphere2003</a></code> is transmittance along
an optical path that is <b>NOT</b> horizontal,
and extends to outer space.
This is <em>much</em> more complicated to calculate.
</p>


<h3>References</h3>

<p>Angstrom, Anders.
On the atmospheric transmission of sun radiation and on dust in the air.
<em>Geogr. Ann.</em>,
no. 2. 1929.
</p>
<p>Kaushal, H. and Jain, V.K. and Kar, S.
<b>Free Space Optical Communication</b>.
Springer. 2017.
</p>
<p>Koschmieder, Harald.
Theorie der horizontalen Sichtweite.
<em>Beitrage zur Physik der Atmosphare</em>. 1924.
<b>12</b>. pages 33-53.
</p>
<p>P. W. Kruse, L. D. McGlauchlin, and R. B. McQuistan.
<b>Elements of Infrared Technology: Generation, Transmission, and Detection</b>.
J. Wiley &amp; Sons, New York, 1962.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solar.irradiance">solar.irradiance</a></code>,
<code><a href="#topic+specnames">specnames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trans = atmosTransmittance( c(5,10,15,20,25)*1000 ) # 5 distances with atmospheric defaults

# verify that transmittance[550]=0.02 at dist=25000
plot( trans, legend='bottomright', log='y' )

# repeat, but this time assign alpha and beta explicitly
trans = atmosTransmittance( c(5,10,15,20,25)*1000, aero=list(alpha=1,beta=0.0001) )
</code></pre>

<hr>
<h2 id='bandSpectra'>Compute Band-based Material Spectra, and Bands for Existing Material Spectra</h2><span id='topic+bandMaterial'></span><span id='topic+bandRepresentation'></span><span id='topic+bandRepresentation.colorSpec'></span>

<h3>Description</h3>

<p>A band-based material spectrum is a superimposition of bandpass filters, and (optionally) a bandstop filter.
The 2 functions in this topic convert a vector of numbers between 0 and 1 to a band representation,
and back again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandMaterial( lambda, wavelength=380:780 )

## S3 method for class 'colorSpec'
bandRepresentation( x )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandSpectra_+3A_lambda">lambda</code></td>
<td>
<p>a numeric Mx2 matrix with wavelength pairs in the rows,
or a vector that can be converted to such a matrix, by row.
The two wavelengths in a row (the <em>transition wavelengths</em>) define either a bandpass or bandstop filter,
and all the rows are superimposed to define the transmittance spectrum of the final material.
If the 2 wavelengths are denoted by <code class="reqn">\lambda_1</code> and <code class="reqn">\lambda_2</code>,
and <code class="reqn">\lambda_1 &lt; \lambda_2</code> then the filter is a bandpass filter.
If the 2 wavelengths are swapped, then the spectrum is &quot;flipped&quot;
and is a bandstop filter, and the band &quot;wraps around&quot; from long wavelengths to short.
There can be at most 1 bandstop filter in the matrix, otherwise it is an error.
The bands must be pairwise disjoint, otherwise it is an error.
To get a material with transmittance identically 0, set <code>lambda</code> to a 0x2 matrix.
To get a material with transmittance identically 1, 
set <code>lambda</code> to a 1x2 matrix with
<code class="reqn">\lambda_1=\beta_0</code> and <code class="reqn">\lambda_2=\beta_N</code>, where <code class="reqn">N</code> is the number of wavelengths.
See vignette <a href="../doc/convexity.pdf"><b>Convexity and Transitions</b></a>
for the definition of <code class="reqn">\beta_0</code> and  <code class="reqn">\beta_N</code>
and other mathematical details.
<br />
<code>lambda</code> can also be a list of such matrices, which are processed separately, see <b>Value</b>.
</p>
</td></tr>
<tr><td><code id="bandSpectra_+3A_wavelength">wavelength</code></td>
<td>
<p>a vector of wavelengths for the returned object</p>
</td></tr>  
<tr><td><code id="bandSpectra_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code> equal to <code>'material'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bandRepresentation()</code> is a right-inverse of <code>bandMaterial()</code>, 
see <b>Examples</b> and the test script <code>test-bands.R</code>. 
For more mathematical details, see the vignette
<a href="../doc/convexity.pdf"><b>Convexity and Transitions</b></a>.
</p>


<h3>Value</h3>

<p><code>bandMaterial()</code> returns a
<b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'transmitance'</code>.
If <code>lambda</code> is a matrix, then the object has 1 spectrum.
If <code>lambda</code> is a list of matrices with length N, then the object has N spectra.
</p>
<p><code>bandRepresentation()</code>
returns a list of matrices with 2 columns.
There is a matrix in the list for each spectrum in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rectangularMaterial">rectangularMaterial</a>()</code>,
vignette <a href="../doc/convexity.pdf"><b>Convexity and Transitions</b></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  make a vector superimposing a bandpass and a bandstop filter, and of the proper length 401
vec = c( rep(1,100), 0.5, rep(0,40), .25, rep(1,50), 0.9, rep(0,100), 0.4, rep(1,107) )

#	 convert that vector to a colorSpec object, with a single spectrum
spec = colorSpec( vec, wavelength=380:780, quantity='transmittance', specnames='sample' )

#	 extract and print the 2 bands
lambda = bandRepresentation( spec ) ;  print(lambda)

##  $sample
##      lambda1 lambda2
##  BS   673.10   480.0
##  BP1  521.25   572.4

#  convert the 2 bands  (the transition wavelengths) back to a vector of length 401
#  and compare with the original vector
delta = vec - coredata( bandMaterial(lambda) )

range(delta)
##  [1] -9.092727e-14  2.275957e-14
</code></pre>

<hr>
<h2 id='bind'>Combine colorSpec Objects</h2><span id='topic+bind'></span><span id='topic+bind.colorSpec'></span>

<h3>Description</h3>

<p>Take a sequence of <b>colorSpec</b> objects and combine their spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
bind( ... )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p><b>colorSpec</b> objects with the same <code><a href="#topic+wavelength">wavelength</a></code> and <code><a href="#topic+quantity">quantity</a></code>, and with distinct <code><a href="#topic+specnames">specnames</a></code> (no duplicates)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+organization">organization</a></code> of the returned object is the most complex of those in the inputs,
where the order of complexity is:
</p>
<p><code>'matrix'</code>  &lt;  <code>'df.col'</code>  &lt;  <code>'df.row'</code>
</p>
<p>If the selected <code>organization</code> is <code>'df.row'</code>, the <code>extradata</code> is combined in a way that preserves all the columns.
Missing data is filled with <code>NA</code>s, analogous to
<code><a href="plyr.html#topic+rbind.fill">rbind.fill</a>()</code>.
</p>
<p>The <code><a href="#topic+metadata">metadata</a></code> of the returned object is copied from the first object in the input list.
</p>


<h3>Value</h3>

<p><code>bind()</code> returns a <b>colorSpec</b> object, or <code>NULL</code> in case of ERROR.  If the bind is
successful, the number of spectra in the output object is the sum of the number of spectra
in the input objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wavelength">wavelength</a></code>,
<code><a href="#topic+quantity">quantity</a></code>,
<code><a href="#topic+specnames">specnames</a></code>,
<code><a href="#topic+organization">organization</a></code>,
<code><a href="#topic+extradata">extradata</a></code>,
<code><a href="#topic+metadata">metadata</a></code>,
<code><a href="plyr.html#topic+rbind.fill">rbind.fill</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rosco = readSpectra( system.file( 'extdata/objects/Rosco.txt', package='colorSpec' ) )
Rosco = resample( Rosco, wave=wavelength(Hoya) )
numSpectra(Hoya)        # prints 4
numSpectra(Rosco)       # prints 42

filters = bind( Hoya, Rosco )
numSpectra(filters)     # prints 46

colnames( extradata(Hoya) )
## [1] "SAMPLE_NAME"  "FresnelReflectance"  "Thickness"

colnames( extradata(Rosco) )
## [1] "Model"  "SampleID"  "SAMPLE_NAME"  "Substrate"  "RefractiveIndex"  "Thickness"

##  The columns in common are "SAMPLE_NAME" and "Thickness"


colnames( extradata(filters) )
## [1] "FresnelReflectance" "Model" "RefractiveIndex" "SAMPLE_NAME"
## [5] "SampleID" "Substrate" "Thickness"
##
## "SAMPLE_NAME" and "Thickness" are combined in the usual way
## The other columns are present, and missing data is filled with NAs
</code></pre>

<hr>
<h2 id='calibrate'>make a linear modification to a colorSpec responder</h2><span id='topic+calibrate'></span><span id='topic+calibrate.colorSpec'></span>

<h3>Description</h3>

<p>make a linear modification to a <b>colorSpec</b> responder with M spectra,
so a specific stimulus (a single spectrum) creates a specific response (an M-vector).
It is generalized form of <em>white balance</em>.<br />
The options are complicated, but in all cases the returned object is
<code><a href="#topic+multiply">multiply</a>(x,gmat)</code> where <code>gmat</code> is an internally calculated MxM matrix - called the <em>gain matrix</em>.
Stated another way, the spectra in the output are linear combinations of spectra in
the input <code>x</code>.<br />
In case of ERROR, a message is logged and the original <code>x</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
calibrate( x, stimulus=NULL, response=NULL, method=NULL )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> responder with M spectra.
The <code>type</code> must be <code>'responsivity.light'</code> or <code>'responsivity.material'</code>.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_stimulus">stimulus</code></td>
<td>
<p>a <b>colorSpec</b> object with a single spectrum, with <code>type</code> either
<code>'light'</code> or <code>'material'</code> to match <code>x</code>.
The wavelength sequence of <code>stimulus</code> must be equal to that of <code>x</code>.<br />
If <code>stimulus</code> is <code>NULL</code>, then an appropriate default is chosen, see <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="calibrate_+3A_response">response</code></td>
<td>
<p>an M-vector, or a scalar which is then replicated to length M.
Normally all entries are not <code>NA</code>, but it is OK to have exactly one that is not <code>NA</code>.
In this special case, a single scaling factor is computed from that non-<code>NA</code> coordinate,
and then applied to <em>all</em> M coordinates; the <code>method</code> must be <code>'scaling'</code>.
This is useful for the recommended method for calibration in ASTM E308-01 section 7.1.2.
The same type of scaling is also recommended method in CIE 15: Technical Report section 7.1.
In this case <code>response=c(NA,100,NA)</code> so the special coordinate is the luminance Y.
See the <b>Examples</b> below and the vignettes
<a href="../doc/gallery.pdf"><b>Viewing Object Colors in a Gallery</b></a>
and  
<a href="../doc/lens-aging.pdf"><b>The Effect of the Aging Human Lens on Color Vision</b></a>.<br />
All entries in <code>response</code>, that are not <code>NA</code>, must be positive.<br />  
If <code>response</code> is <code>NULL</code>, then an appropriate default <em>may be</em> chosen, see <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="calibrate_+3A_method">method</code></td>
<td>
<p>an MxM <em>adaptation matrix</em>.
<code>method</code> can also be <code>'scaling'</code> and it is then set to the MxM identity matrix,
which scales each responsivity spectrum in <code>x</code> independently.<br />
If M=3, <code>method</code> can also be <code>'Bradford'</code>, <code>'Von Kries'</code>, <code>'MCAT02'</code>, or <code>'Bianco+Schettini'</code>,
and it is then set to the popular corresponding <em>chromatic adaptation matrix</em>.
For these special matrices, the spectra in <code>x</code> are <b>not</b> scaled independently;
there is &quot;cross-talk&quot;.<br />
If <code>method</code> is <code>NULL</code>, then an appropriate default is chosen, see <b>Details</b>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>stimulus</code> is <code>NULL</code>, it is set to
<code><a href="#topic+illuminantE">illuminantE</a>()</code> or <code><a href="#topic+neutralMaterial">neutralMaterial</a>()</code> to match <code>x</code>.
</p>
<p>If <code>response</code> is <code>NULL</code> and the response of <code>x</code> is <code>electrical</code> or <code>action</code>,
then <code>response</code> is set to an M-vector of all 1s.
If <code>response</code> is <code>NULL</code> and the response of <code>x</code> is <code>neural</code>,
then this is an ERROR and the user is prompted to supply a specific <code>response</code>.
</p>
<p>If <code>method</code> is <code>NULL</code>, its assignment is complicated.<br />
If M=3 and the response of <code>x</code> is <code>neural</code>, 
and the <code>specnames</code> of <code>x</code> partially match <code>c('x','y','z')</code> (case-insensitive),
and none of the components of <code>response</code> are <code>NA</code>,
then the neural response is assumed to be human,   and the <code>method</code> is set to <code>'Bradford'</code>.<br />
Otherwise <code>method</code> is set to <code>'scaling'</code>.
</p>


<h3>Value</h3>

<p>a <b>colorSpec</b> object equal to <code><a href="#topic+multiply">multiply</a>(x,gmat)</code>
where <code>gmat</code> is an internally calculated MxM matrix.
The <code><a href="#topic+quantity">quantity</a>()</code> and <code><a href="#topic+wavelength">wavelength</a>()</code> are preserved.<br />
Note that <code>gmat</code> is not the same as the the MxM <em>adaptation matrix</em>.
To inspect <code>gmat</code> execute <code><a href="base.html#topic+summary">summary</a>()</code> on the returned object.
If <code>method</code> is <code>'scaling'</code> then <code>gmat</code> is diagonal and the
diagonal entries are the M gain factors needed to achieve the calibration.<br />
Useful data is attached as attribute <code>"calibrate"</code>.
</p>


<h3>Note</h3>

<p>Chromatic adaptation transforms, such as <code>'Bradford'</code>,
do not belong in the realm of spectra,
for this is not really a spectral calculation.
For more about this subject see the explanation in <cite>Digital Color Management</cite>,
Chapter 15 - Myths and Misconceptions.
These sophisticated adaptation transforms are provided in <code>calibrate()</code> because it is possible and convenient.
</p>


<h3>References</h3>

<p>ASTM E308-01.
Standard Practice for Computing the Colors of Objects by Using the CIE System.
2001.
</p>
<p>CIE 15: Technical Report: Colorimetry, 3rd edition.
CIE 15:2004.
</p>
<p>Edward J. Giorgianni and Thomas E. Madden.
<b>Digital Color Management: Encoding Solutions.</b> 2nd Edition
John Wiley. 2009.
Chapter 15 - Myths and Misconceptions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.regular">is.regular</a>()</code>,
<code><a href="#topic+multiply">multiply</a>()</code>,
<code><a href="#topic+quantity">quantity</a>()</code>,
<code><a href="#topic+wavelength">wavelength</a>()</code>,
<code><a href="#topic+colorSpec">colorSpec</a></code>,
<code><a href="base.html#topic+summary">summary</a>()</code>,
<code><a href="#topic+illuminantE">illuminantE</a>()</code>,
<code><a href="#topic+neutralMaterial">neutralMaterial</a>()</code>,
<code><a href="#topic+product">product</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave = 380:780

# make an art gallery illuminated by illuminant A, and with tristimulus XYZ as output
gallery = product( A.1nm, 'artwork', xyz1931.1nm, wave=wave )

#  calibrate simplistically,
#  so the perfect reflecting diffuser has the standard XYZ coordinates for Illuminant A
#  using the convention that Y=100 (instead of Y=1)
A = 100 * spacesXYZ::standardXYZ('A')
A
##         X   Y      Z
##  A 109.85 100 35.585


gallery.cal1 = calibrate( gallery, response=A, method='scaling' )

#  calibrate following the ASTM and CIE recommendation
gallery.cal2 = calibrate( gallery, response=c(NA,100,NA), method='scaling' )

#   make the Perfect Reflecting Diffuser for testing
prd = neutralMaterial( 1, wave=wave ) ; specnames(prd) = 'PRD'

#   compare responses to the PRD for gallery.cal1 and gallery.cal2
white.1 = product( prd, gallery.cal1 )
white.2 = product( prd, gallery.cal2 )
white.1 ; white.2 ; white.1 - white.2 

##           X   Y      Z
##  PRD 109.85 100 35.585
##             X   Y        Z
##  PRD 109.8488 100 35.58151
##                X             Y           Z
##  PRD 0.001210456 -2.842171e-14 0.003489313


# make an RGB flatbead scanner from illuminant F11 and a Flea2 camera
scanner = product( subset(Fs.5nm,'F11'), 'paper', Flea2.RGB, wave='auto')
# adjust RGB gain factors (white balance) so the perfect reflecting diffuser yields RGB=(1,1,1)
scanner = calibrate( scanner )

# same flatbead scanner, but this time with some "white headroom"
scanner = product( subset(Fs.5nm,'F11'), 'paper', Flea2.RGB, wave='auto' )
scanner = calibrate( scanner, response=0.95 )
scanner
</code></pre>

<hr>
<h2 id='canonicalOptimalColors'>compute the Canonical Optimal Colors</h2><span id='topic+canonicalOptimalColors'></span><span id='topic+canonicalOptimalColors.colorSpec'></span>

<h3>Description</h3>

<p>Consider a <b>colorSpec</b> object <code>x</code> with <code>type</code> 
equal to <code>'responsivity.material'</code>.
The set of all possible material reflectance functions (or transmittance functions) 
is convex, closed, and bounded (in any reasonable function space),
and this implies that the set of all possible output responses 
from <code>x</code> is also convex, closed, and bounded.
The latter set is called the <em>object-color solid</em> or <em>Rösch Farbkörper</em> for <code>x</code>.
A color on the boundary of the <em>object-color solid</em> is called an <em>optimal color</em> for <code>x</code>.
The corresponding transmittance spectrum is called an  <em>optimal spectrum</em> for <code>x</code>.
The special points <b>W</b> (the response to the perfect reflecting diffuser)
and <b>0</b> (the response to the perfect absorbing diffuser) are optimal.
</p>
<p>Currently the function only works if the number of spectra in 
<code>x</code> is 3 (e.g. RGB or XYZ).
In this case the <em>object-color solid</em> is a zonohedron whose boundary
is the union of parallelograms, which may be coplanar.
These parallelograms are indexed by distinct pairs of the wavelengths of <code>x</code>;
if <code>x</code> has N wavelengths, then there are N*(N-1) parallelograms.
The center of each parallelogram is called a <em>canonical optimal color</em>.
Interestingly, the special points <b>W</b> and <b>0</b> are not canonical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
canonicalOptimalColors( x, lambda, spectral=FALSE )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canonicalOptimalColors_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code>
equal to <code>'responsivity.material'</code> and 3 spectra</p>
</td></tr>
<tr><td><code id="canonicalOptimalColors_+3A_lambda">lambda</code></td>
<td>
<p>a numeric Mx2 matrix whose rows contain distinct pairs of wavelengths of <code>x</code>,
or a numeric vector that can be converted to such a matrix, by row.
If any entry in <code>lambda</code> is not a wavelength of <code>x</code>,
it is an error. </p>
</td></tr>
<tr><td><code id="canonicalOptimalColors_+3A_spectral">spectral</code></td>
<td>
<p>if <code>TRUE</code>, the function returns a <b>colorSpec</b> object
with the optimal spectra, see <b>Value</b>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 3 responsivities are regarded not as continuous functions, 
but as step functions.
This implies that the color solid is a zonohedron.
In the preprocessing phase the zonohedral representation is calculated.
The faces of the zonohedron are either parallelograms,
or <em>compound faces</em> that can be partitioned into parallelograms.
The centers of all these parallelograms are the canonical optimal colors.
<br />
The optimal spectra take value 1/2 at the 2 given wavelengths, and 0 or 1 elsewhere.
If the 2 wavelengths are <code class="reqn">\lambda_1</code> and <code class="reqn">\lambda_2</code>,
and <code class="reqn">\lambda_1 &lt; \lambda_2</code> then the spectrum is approximately a bandpass filter.
If the 2 wavelengths are swapped, then the spectrum is &quot;flipped&quot;
and is approximately a bandstop filter.
</p>


<h3>Value</h3>

<p>If argument <code>spectral=FALSE</code>,
<code>canonicalOptimalColors()</code> returns a <code>data.frame</code> with a row for each row in <code>lambda</code>.
The columns in the output are:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>the given matrix argument <code>lambda</code></p>
</td></tr> 
<tr><td><code>optimal</code></td>
<td>

<p>the computed optimal colors - an Mx3 matrix
</p>
</td></tr>
<tr><td><code>transitions</code></td>
<td>
<p>the number of transitions in the optimal spectrum, this is a positive even number</p>
</td></tr>
</table>
<p>If <code>rownames(lambda)</code> is not <code>NULL</code>, they are copied to the row names of the output.
</p>
<p>If argument <code>spectral=TRUE</code>,
it returns a <b>colorSpec</b> object with quantity 
<code>'transmittance'</code>.
This object contains the optimal spectra,
and the above-mentioned <code>data.frame</code> can then be obtained by applying
<code><a href="#topic+extradata">extradata</a>()</code> to the returned object.
</p>
<p>In case of global error, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Centore, Paul.
<em>A zonohedral approach to optimal colours</em>.
<b>Color Research &amp; Application</b>.
Vol. 38.
No. 2.
pp. 110-119.
April 2013.
</p>
<p>Logvinenko, A. D.
An object-color space. 
<b>Journal of Vision</b>.
9(11):5, 1-23, (2009).<br />
<code>https://jov.arvojournals.org/article.aspx?articleid=2203976</code>
doi:10.1167/9.11.5.
</p>
<p>Schrödinger, E. (1920). 
Theorie der Pigmente von grösster Leuchtkraft. 
<b>Annalen der Physik</b>.
62, 603-622.
</p>
<p>West, G. and M. H. Brill.
Conditions under which Schrödinger object colors are optimal.
<b>Journal of the Optical Society of America</b>.
73. pp. 1223-1225. 1983.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probeOptimalColors">probeOptimalColors</a>()</code>,
<code><a href="#topic+bandRepresentation">bandRepresentation</a>()</code>,
<code><a href="#topic+scanner.ACES">scanner.ACES</a></code>,
<code><a href="#topic+extradata">extradata</a>()</code>,
<code><a href="#topic+type">type</a></code>,
vignette <a href="../doc/convexity.pdf"><b>Convexity and Transitions</b></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave    = seq(400,700,by=5)
D50.eye = product( D50.5nm, 'material', xyz1931.1nm, wavelength=wave )
canonicalOptimalColors( D50.eye, c(500,600, 550,560, 580,585) )
##    lambda.1 lambda.2   optimal.x   optimal.y   optimal.z transitions
##  1      500      600 47.02281830 80.07281030  4.33181530           2
##  2      550      560  5.18490614 10.09045773  0.06121505           2
##  3      580      585 26.91247649 21.49031008  0.03457904           6
</code></pre>

<hr>
<h2 id='chop'>chop spectra into low and high parts</h2><span id='topic+chop'></span><span id='topic+chop.colorSpec'></span>

<h3>Description</h3>

<p>chop all spectra in a <b>colorSpec</b> object into low and high parts at a blending interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
chop( x, interval, adj=0.5 )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chop_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object</p>
</td></tr>
<tr><td><code id="chop_+3A_interval">interval</code></td>
<td>
<p>a numeric vector with length 2 giving the endpoints of the interval, in nm</p>
</td></tr>
<tr><td><code id="chop_+3A_adj">adj</code></td>
<td>
<p>a number in [0,1] defining weights of low and high parts over the interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each spectrum, the low and high parts sum to the original spectrum.
The low part vanishes on the right of the interval, and the high part vanishes on the left.
</p>


<h3>Value</h3>

<p><code>chop(x)</code> returns a <b>colorSpec</b> object with twice the number of spectra in <code>x</code>
and with <code><a href="#topic+organization">organization</a></code> equal to <code>'matrix'</code>.
The names of the new spectra are formed by appending &quot;.lo&quot; and &quot;.hi&quot; to the original spectrum names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+organization">organization</a></code>,  
</p>


<h3>Examples</h3>

<pre><code class='language-R'># chop blue butane flame into diatomic carbon and hydrocarbon parts
path = system.file( "extdata/sources/BlueFlame.txt", package="colorSpec" )
blueflame = readSpectra( path, seq(375,650,0.5) )
plot( chop( blueflame, interval=c(432,435), adj=0.8 ) )

# chop 'white' LED into blue and yellow parts
path = system.file( "extdata/sources/Gepe-G-2001-LED.sp", package="colorSpec" )
LED = readSpectra( path )
plot( chop( LED, c(470,495) ) )
</code></pre>

<hr>
<h2 id='colorSpec'>constructing and testing colorSpec Objects</h2><span id='topic+colorSpec'></span><span id='topic+is.colorSpec'></span><span id='topic+as.colorSpec'></span><span id='topic+as.colorSpec.default'></span>

<h3>Description</h3>

<p>The function <code>colorSpec()</code> is the constructor for <b>colorSpec</b> objects.
</p>
<p><code>is.colorSpec()</code> tests whether an object is a valid <b>colorSpec</b> object.<br />
<code>as.colorSpec()</code> converts other variables to a <b>colorSpec</b> object,
and is designed to be overridden by other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorSpec( data, wavelength, quantity='auto', organization='auto', specnames=NULL )

is.colorSpec(x)

## Default S3 method:
as.colorSpec( ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorSpec_+3A_data">data</code></td>
<td>
<p>a vector or matrix of the spectrum values.
In case <code>data</code> is a vector, there is a single spectrum and the number
of points in that spectrum is the length of the vector.
In case <code>data</code> is a matrix, the spectra are stored in the columns,
so the number of points in each spectrum is the number of rows in <code>data</code>,
and the number of spectra is the number of columns in <code>data</code>.
It is OK for the matrix to have only 0 or 1 column.</p>
</td></tr>
<tr><td><code id="colorSpec_+3A_wavelength">wavelength</code></td>
<td>
<p>a numeric vector of wavelengths for all the spectra, in nm.
The length of this vector must be equal to <code><a href="base.html#topic+NROW">NROW</a>(data)</code>.
The sequence must be increasing.
The <code>wavelength</code> vector can be changed after construction.</p>
</td></tr>
<tr><td><code id="colorSpec_+3A_quantity">quantity</code></td>
<td>
<p>a character string giving the <code>quantity</code> of all spectra
in <code>data</code>; see <code><a href="#topic+quantity">quantity</a></code> for a list of possible values.  
In case of <code>'auto'</code>, a guess is made from the <code>specnames</code>.
The <code>quantity</code> can be changed after construction.</p>
</td></tr>
<tr><td><code id="colorSpec_+3A_organization">organization</code></td>
<td>
<p>a character string giving the desired organization 
of the returned <b>colorSpec</b> object.
In case of <code>'auto'</code>, the organization is <code>'vector'</code> or <code>'matrix'</code>
depending on <code>data</code>.
Other possible organizations are <code>'df.col'</code> or <code>'df.row'</code>;
see <code><a href="#topic+organization">organization</a></code> for discussion of all 4 possible organizations.
The organization can be changed after construction.
</p>
</td></tr>
<tr><td><code id="colorSpec_+3A_specnames">specnames</code></td>
<td>
<p>a character vector with length equal to the number of spectra,
and with no duplicates.
If <code>specnames</code> is <code>NULL</code> and <code>data</code> is a vector,
then <code>specnames</code> is set to <code>deparse(substitute(data))</code>.
If <code>specnames</code> is <code>NULL</code> and <code>data</code> is a matrix,
then <code>specnames</code> is set to <code>colnames(data)</code>.
If <code>specnames</code> is <em>still</em> not a character vector with the right length,
or if there are duplicate names, then <code>specnames</code> is set to
<code>'S1', 'S2', ...</code> with a warning message.
The <code>specnames</code> vector can be changed after construction.
</p>
</td></tr>  
<tr><td><code id="colorSpec_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object to test for being a valid <b>colorSpec</b> object.</p>
</td></tr>
<tr><td><code id="colorSpec_+3A_...">...</code></td>
<td>
<p>arguments for use in other packages.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Under the hood, a <b>colorSpec</b> object is either a <code>vector</code>, <code>matrix</code>, or <code>data.frame</code>.
It is of S3 class <code>'colorSpec'</code> with these extra attributes:
</p>

<dl>
<dt><code>wavelength</code></dt><dd><p>a numeric vector of wavelengths for all the spectra.  If the organization of the object is <code>'df.col'</code>, then this is absent.</p>
</dd>
<dt><code>quantity</code> </dt><dd><p>a character string that gives the physical quantity of all spectra, see <code><a href="#topic+quantity">quantity</a>()</code> for a list of possible values.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>a named list for user-defined data.  The names <code>'path'</code>, <code>'header'</code> and <code>'date'</code> are already reserved; see <code><a href="#topic+metadata">metadata</a>()</code>.</p>
</dd>
<dt><code>step.wl</code></dt><dd><p>step between adjacent wavelengths in nm. This is assigned only when the wavelengths are regular; see <code><a href="#topic+is.regular">is.regular</a>()</code>. </p>
</dd>
<dt><code>specname</code> </dt><dd><p>only assigned when the <code>organization</code> is <code>'vector'</code>, in which case it is equal to the single character string name of the single spectrum.
Note that the word <code>specname</code> is singular. Also see <code><a href="#topic+specnames">specnames</a>()</code>.</p>
</dd>
</dl>

<p>And there are a few more attributes that exist only in special cases;
see the <b>colorSpec User Guide</b>.
</p>


<h3>Value</h3>

<p><code>colorSpec()</code> returns a <b>colorSpec</b> object, or <code>NULL</code> in case of ERROR.
Compare this function with <code>stats::<a href="stats.html#topic+ts">ts</a>()</code>.
</p>
<p><code>is.colorSpec()</code> returns <code>TRUE</code> or <code>FALSE</code>.
It does more than check the <code>class</code>,
and also checks <code>wavelength</code>, <code>quantity</code>, and <code>organization</code>.
If <code>FALSE</code>, it logs (at <code>loglevel='DEBUG'</code>)
the reason that <code>x</code> is invalid.
</p>
<p><code>as.colorSpec.default()</code> issues an ERROR message and returns <code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wavelength">wavelength</a></code>,
<code><a href="#topic+quantity">quantity</a></code>,
<code><a href="#topic+organization">organization</a></code>,  
<code><a href="#topic+metadata">metadata</a></code>,
<code><a href="#topic+step.wl">step.wl</a></code>,
<code><a href="#topic+specnames">specnames</a></code>,
<code><a href="#topic+is.regular">is.regular</a></code>,
<code><a href="#topic+coredata">coredata</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  make a synthetic Gaussian bandpass filter

center = 600
wave   = 400:700
trans  = exp( -(wave-center)^2 / 20^2 )

filter.bp   = colorSpec( trans, wave, quantity='transmittance', specnames='myfilter' )

organization( filter.bp )  # returns:  "vector"

# and now plot it
plot( filter.bp )
</code></pre>

<hr>
<h2 id='computeADL'>compute ADL coordinates by ray tracing</h2><span id='topic+computeADL'></span><span id='topic+computeADL.colorSpec'></span>

<h3>Description</h3>

<p>Consider a <b>colorSpec</b> object <code>x</code> with <code>type</code> equal to <code>responsivity.material</code>.
The set of all possible material reflectance functions (or transmittance functions) 
is convex, closed, and bounded (in any reasonable function space),
and this implies that the set of all possible output responses 
from <code>x</code> is also convex, closed, and bounded.
The latter set is called the <em>object-color solid</em> or <em>Rösch Farbkörper</em> for <code>x</code>.
A color on the boundary of the <em>object-color solid</em> is called an <em>optimal color</em>.
The special points <b>W</b> (the response to the perfect reflecting diffuser)
and <b>0</b> are on the boundary of this set.
The interior of the line segment of neutrals joining <b>0</b> to <b>W</b> is in the interior of the
<em>object-color solid</em>.
It is natural to parameterize this segment from 0 to 1 (from <b>0</b> to <b>W</b>).
The solid is symmetrical about the neutral gray midpoint <b>G</b>=<b>W/2</b>.
</p>
<p>Now suppose that <code>x</code> has 3 spectra (3 responses)
and consider a color response <b>R</b> not equal to <b>G</b>.
There is a ray based at <b>G</b> and passing through <b>R</b>
that intersects the boundary of the 
<em>object-color solid</em> at an <em>optimal color</em> <b>B</b> on the boundary
with Logvinenko coordinates <code class="reqn">(\delta,\omega)</code>.
If these 2 coordinates are combined with <code class="reqn">\alpha</code>, where
<b>R</b> = <code class="reqn">(1-\alpha)</code><b>G</b> + <code class="reqn">\alpha</code><b>B</b>, 
it yields the <em>Logvinenko coordinates</em>
<code class="reqn">(\alpha,\delta,\omega)</code> of <b>R</b>.
These coordinates are also denoted by ADL; see <b>References</b>.
A response is in the <em>object-color solid</em> iff <code class="reqn">\alpha \le 1</code>.
A response is  <em>optimal</em> iff <code class="reqn">\alpha=1</code>.
</p>
<p>The coordinates of <b>0</b> are <code class="reqn">(\alpha,\delta,\omega)</code>=(1,0,0).
The coordinates of <b>W</b> are <code class="reqn">(\alpha,\delta,\omega)</code>=(1,1,0).
The coordinates of <b>G</b> are undefined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
computeADL( x, response )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeADL_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code> equal to <code>responsivity.material</code> and 3 spectra </p>
</td></tr>
<tr><td><code id="computeADL_+3A_response">response</code></td>
<td>
<p>a numeric Nx3 matrix with responses in the rows, or a numeric vector
that can be converted to such a matrix, by row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each response, a ray is computed and the ray tracing is
done by <code><a href="#topic+probeOptimalColors">probeOptimalColors</a>()</code>.
</p>


<h3>Value</h3>

<p><code>computeADL()</code> returns a <code>data.frame</code> with a row for each response.
The columns in the data frame are:
</p>
<table>
<tr><td><code>response</code></td>
<td>
<p>the input response vector</p>
</td></tr>
<tr><td><code>ADL</code></td>
<td>
<p>the computed ADL coordinates of the response vector</p>
</td></tr>  
<tr><td><code>omega</code></td>
<td>
<p>the reparameterized <code class="reqn">\lambda</code> in the interval [0,1];  see <b>References</b></p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>lambda.1 and lambda.2 at the 2 transitions, in nm.
lambda.1 &lt; lambda.2  =&gt; bandpass,
and lambda.1 &gt; lambda.2 =&gt; bandstop.</p>
</td></tr>
</table>
<p>If an individual ray could not be traced,
or if the optimal spectrum has more than 2 transitions,
the row contains <code>NA</code> in appropriate columns.
<br />
In case of global error, the function returns <code>NULL</code>.
</p>


<h3>WARNING</h3>

<p>Since this function is really a simple wrapper around 
<code><a href="#topic+probeOptimalColors">probeOptimalColors</a>()</code>,
please see the performance warnings there.
</p>


<h3>References</h3>

<p>Logvinenko, A. D.
An object-color space. 
<b>Journal of Vision</b>.
9(11):5, 1-23, (2009).<br />
<code>https://jov.arvojournals.org/article.aspx?articleid=2203976</code>.
doi:10.1167/9.11.5.
</p>
<p>Godau, Christoph and Brian Funt.
XYZ to ADL: Calculating Logvinenko's Object Color Coordinates.
Proceedings Eighteenth IS&amp;T Color Imaging Conference.
San Antonio. Nov 2009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type">type</a>()</code>,
<code><a href="#topic+probeOptimalColors">probeOptimalColors</a>()</code>,
vignette <a href="../doc/optimals.pdf"><b>Plotting Chromaticity Loci of Optimal Colors</b></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D50.eye = product( D50.5nm, 'varmat', xyz1931.1nm, wave=seq(360,830,by=5) )
computeADL( D50.eye, c(30,50,70) )
##    response.X response.Y response.Z   ADL.alpha   ADL.delta  ADL.lambda     omega 
##  1         30         50         70   0.7371475   0.5384104 473.3594572 0.3008817

##  lambda.1 lambda.2
##  427.2011 555.5261

## since alpha &lt; 1, XYZ=c(30,50,70) is *inside* the object-color solid of D50.eye
</code></pre>

<hr>
<h2 id='computeCCT'>Compute Correlated Color Temperature (CCT) of Light Spectra</h2><span id='topic+computeCCT'></span><span id='topic+computeCCT.colorSpec'></span>

<h3>Description</h3>

<p>Compute the CCT, in K,
of a <b>colorSpec</b> object with <code>type</code> equal to <code>'light'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
computeCCT( x, isotherms='robertson', locus='robertson', strict=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeCCT_+3A_x">x</code></td>
<td>
<p>an <b>colorSpec</b> <span class="rlang"><b>R</b></span> object with <code>type</code> equal to <code>'light'</code>, and M spectra </p>
</td></tr>
<tr><td><code id="computeCCT_+3A_isotherms">isotherms</code></td>
<td>
<p>A character vector whose elements match one
of the available isotherm families:
<code>'robertson'</code>, <code>'mccamy'</code>, and <code>'native'</code>.
Matching is partial and case-insensitive.
When more than one family is given, a matrix is returned, see <b>Value</b>.
When <code>isotherms='native'</code> the isotherms are defined implicitly
as lines perpendicular to the locus, see <b>Details</b> in 
<code><a href="spacesXYZ.html#topic+CCT">spacesXYZ::CCTfromXYZ</a>()</code>.
The character <code>NA</code> (<code>NA_character_</code>) is taken as
a synonym for <code>'native'</code>.
</p>
</td></tr>
<tr><td><code id="computeCCT_+3A_locus">locus</code></td>
<td>

<p>valid values are <code>'robertson'</code> and <code>'precision'</code>, see above.
Matching is partial and case-insensitive.
</p>
</td></tr>
<tr><td><code id="computeCCT_+3A_strict">strict</code></td>
<td>
<p>The CIE considers the CCT of a chromaticity <code>uv</code> to be meaningful only
if the distance from <code>uv</code> to the Planckian locus is less than or equal to 0.05 
[in CIE UCS 1960].
If <code>strict=FALSE</code>, then this condition is ignored.
Otherwise, the distance is computed along the corresponding isotherm,
and if it exceeds 0.05 the returned CCT is set to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>computeCCT()</code>, for each spectrum,
XYZ is computed using <code><a href="#topic+xyz1931.1nm">xyz1931.1nm</a></code>,
and the result passed to <code>spacesXYZ::CCTfromXYZ()</code>.
If the <code>quantity</code> of <code>x</code> is <code>'photons'</code> (actinometric) each spectrum is
converted to <code>'energy'</code> (radiometric) on the fly.<br /> 
</p>


<h3>Value</h3>

<p><code>computeCCT()</code> returns a numeric vector of length M,
where M is the number of spectra in <code>x</code>.
The vector's <code>names</code> is set to <code>specnames(x)</code>.<br />
If the <code>type</code> of <code>x</code> is not <code>'light'</code>,
then a warning is issued and all values are <code>NA_real_</code>.<br />
</p>


<h3>References</h3>

<p>McCamy, C. S.
<em>Correlated color temperature as an explicit function of chromaticity coordinates</em>.
Color Research &amp; Application.
Volume 17.
Issue 2.
pages 142-144.
April 1992.
</p>
<p>Robertson, A. R.
Computation of correlated color temperature and distribution temperature.
Journal of the Optical Society of America.
58. pp. 1528-1535 (1968).
</p>
<p>Wyszecki, Günther and W. S. Stiles.
<b>Color Science: Concepts and Methods, Quantitative Data and Formulae, Second Edition.</b>
John Wiley &amp; Sons, 1982.
Table 1(3.11). pp. 227-228.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type">type</a>()</code>, 
<code><a href="#topic+quantity">quantity</a>()</code>,
<code><a href="#topic+xyz1931">xyz1931</a></code>,
<code><a href="#topic+planckSpectra">planckSpectra</a>()</code>,    
<code><a href="#topic+specnames">specnames</a>()</code>,
<code><a href="spacesXYZ.html#topic+CCT">spacesXYZ::CCTfromXYZ</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>computeCCT( D65.1nm )                       # returns 6502.068
computeCCT( D65.1nm, isotherms='native' )   # returns 6503.323
computeCCT( A.1nm )                         # returns 2855.656
computeCCT( A.1nm, isotherms='native' )     # returns 2855.662
computeCCT( A.1nm, isotherms='mccamy' )     # returns 2857.188

moon = readSpectra( system.file( "extdata/sources/moonlight.txt", package='colorSpec' ) )
computeCCT( moon )                  # returns 4482.371
</code></pre>

<hr>
<h2 id='computeCRI'>Compute Color Rendering Index (CRI) of Light Spectra</h2><span id='topic+computeCRI'></span><span id='topic+computeCRI.colorSpec'></span>

<h3>Description</h3>

<p>Compute the CIE 1974 color rendering index (CRI) of a light spectrum, 
called the <em>the test illuminant</em>.<br />
From the given spectrum a <em>reference illuminant</em> is selected with the same CCT 
(Correlated Color Temperature).
A selected set of 8 color samples is rendered in XYZ (1931) with both illuminants
and 8 color differences are computed in a special <b>CIEUVW</b> color space.
For each color difference a CRI is computed, where 100 is a perfect color match.
The final CRI is the average of these 8 CRI values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
computeCRI( x, adapt=TRUE, attach=FALSE, tol=5.4e-3 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeCRI_+3A_x">x</code></td>
<td>
<p>an <b>colorSpec</b> <span class="rlang"><b>R</b></span> object with <code>type</code> equal to <code>'light'</code>, and exactly 1 spectrum </p>
</td></tr>
<tr><td><code id="computeCRI_+3A_adapt">adapt</code></td>
<td>
<p>if <code>TRUE</code>, then a special chromatic adaption is performed, see <b>Details</b> </p>
</td></tr>
<tr><td><code id="computeCRI_+3A_attach">attach</code></td>
<td>
<p>if <code>TRUE</code>, then a large list of intermediate calculations
is attached to the returned number, as attribute <code>data</code>. 
This attached list includes data for all special 14 color samples, although
the last 6 do not affect the returned CRI.</p>
</td></tr>
<tr><td><code id="computeCRI_+3A_tol">tol</code></td>
<td>
<p>for the CRI to be meaningful the chromaticities of the test and reference illuminants must be sufficiently close in the CIE
1960 uniform chromaticity space.
If the tolerance is exceeded, the function returns <code>NA</code>.
The default <code>tol=5.4e-3</code> is the one recommended by the CIE, 
but the argument allows the user to override it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CCT of <code>x</code> is computed by <code>computeCCT()</code> with default options.
<br />
If <code>adapt</code> is <code>TRUE</code> the 8 test <code>uv</code> points
are chromatically adapted from the test illuminant to the reference illuminant
using a special von Kries type transformation; see <cite>Oleari</cite> and
<cite>Wikipedia</cite>.
The test UVW values are computed relative to the reference illuminant.
<br />
If <code>adapt</code> is <code>FALSE</code> the 8 test <code>uv</code> points
are <em>not</em> chromatically adapted,
and the test UVW values are computed relative to the test illuminant.
</p>


<h3>Value</h3>

<p><code>computeCRI()</code> returns a single number <code class="reqn">\le</code> 100.
In case of ERROR it returns <code>NA</code>. 
If <code>attach</code> is <code>TRUE</code> a large list
of intermediate calculations is attached to the returned number.
</p>


<h3>Source</h3>

<p>The test color reflectance spectra are taken from:<br />
http://www.lrc.rpi.edu/programs/nlpip/lightinganswers/lightsources/scripts/NLPIP_LightSourceColor_Script.m
</p>


<h3>References</h3>

<p>Oleari, Claudio, Gabriele Simone.
<b>Standard Colorimetry: Definitions, Algorithms and Software</b>.
John Wiley. 2016.
pp. 465-470.
</p>
<p>Günther Wyszecki and W. S. Stiles.
<b>Color Science: Concepts and Methods, Quantitative Data and Formulae, Second Edition</b>.
John Wiley &amp; Sons, 1982.
Table 1(3.11). p. 828.
</p>
<p>Wikipedia.
<b>Color rendering index</b>.
<a href="https://en.wikipedia.org/wiki/Color_rendering_index">https://en.wikipedia.org/wiki/Color_rendering_index</a>
</p>
<p>Hunt, R. W. G. and M. R. Pointer.
<b>Measuring Colour</b>.  4th edition.
John Wiley &amp; Sons.
2011.
Appendix 7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type">type</a></code>, 
<code><a href="#topic+xyz1931">xyz1931</a></code>,  
<code><a href="#topic+computeCCT">computeCCT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>computeCRI( subset(Fs.5nm,'F2') )       # returns 64.15195
computeCRI( subset(Fs.5nm,'F4') )       # returns 51.36348
</code></pre>

<hr>
<h2 id='computeSSI'>Compute the Spectrum Similarity Index of light spectra</h2><span id='topic+computeSSI'></span><span id='topic+computeSSI.colorSpec'></span>

<h3>Description</h3>

<p>Compute the Spectrum Similarity Index (SSI), an index between 0 and 100,
of a <b>colorSpec</b> object with <code>type</code> equal to <code>'light'</code>.
It compares a test spectrum with a reference spectrum (an ideal).
The value 100 means a perfect match to the reference, 
and a smaller value mean a poorer match (similar to CRI).
Only values in the interval [375,675] nm are used; for details see <cite>Holm</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
computeSSI( x, reference=NULL, digits=0, isotherms='mccamy', locus='robertson' )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSSI_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code> equal to <code>'light'</code>, and M test spectra </p>
</td></tr>
<tr><td><code id="computeSSI_+3A_reference">reference</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code> equal to <code>'light'</code>,
and either 1 or M reference spectra.
<code>reference</code> can also be <code>NULL</code> (the default),
which means to generate each reference spectrum from the corresponding test spectrum.</p>
</td></tr>
<tr><td><code id="computeSSI_+3A_digits">digits</code></td>
<td>
<p>the number of digits after the decimal point in the returned vector.
According to <cite>Holm</cite> the output should be rounded to the nearest integer,
which corresponds to <code>digits=0</code>.
To return full precision, set <code>digits=Inf</code>.</p>
</td></tr>
<tr><td><code id="computeSSI_+3A_isotherms">isotherms</code></td>
<td>
<p>this is only used when <code>reference=NULL</code>.
It is passed to <code><a href="#topic+computeCCT">computeCCT</a>()</code>
in order to compute the CCT of each test spectrum.</p>
</td></tr>
<tr><td><code id="computeSSI_+3A_locus">locus</code></td>
<td>
<p>this is only used when <code>reference=NULL</code>.
It is passed to <code><a href="#topic+computeCCT">computeCCT</a>()</code>
in order to compute the CCT of each test spectrum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>reference</code> contains a single spectrum, 
then each test spectrum is compared to that one reference spectrum.
If <code>reference</code> contains M spectra,
then the i'th test spectrum is compared to the i'th reference spectrum.
</p>
<p>If <code>reference=NULL</code> then for each test spectrum
the CCT is computed and used to compute a reference spectrum with the same CCT.
It is either a Planckian (black-body) or daylight illuminant, see <cite>Holm</cite> for details.
The test spectrum and auto-computed reference spectrum are then compared.
</p>


<h3>Value</h3>

<p><code>computeSSI()</code> returns a numeric vector of length M,
where M is the number of spectra in <code>x</code>.
The vector's <code>names</code> is set from <code>specnames(x)</code>
and a compact code for the corresponding reference spectrum.
</p>
<p>If the <code>type</code> of <code>x</code> is not <code>'light'</code>,
or <code>reference</code> is not valid,
then the function returns NULL.
</p>


<h3>References</h3>

<p>J. Holm and T. Maier and P. Debevec and C. LeGendre and J. Pines and J. Erland and G. Joblove and S. Dyer and B. Sloan and J. di Gennaro and D. Sherlock.
<em>A Cinematographic Spectral Similarity Index</em>.
SMPTE 2016 Annual Technical Conference and Exhibition.
pp. 1-36.
(2016).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type">type</a>()</code>, 
<code><a href="#topic+computeCCT">computeCCT</a>()</code>,
<code><a href="#topic+planckSpectra">planckSpectra</a>()</code>,    
<code><a href="#topic+daylightSpectra">daylightSpectra</a>()</code>, 
<code><a href="#topic+specnames">specnames</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>computeSSI( planckSpectra( 1000*(2:6) )  )
##  P2000_SSI[2027K] P3000_SSI[3057K] P4000_SSI[D4063] P5000_SSI[D5061] P6000_SSI[D6063] 
##                99               98               93               92               92 
</code></pre>

<hr>
<h2 id='convolvewith'>Convolve each spectrum in a colorSpec object with a kernel</h2><span id='topic+convolvewith'></span><span id='topic+convolvewith.colorSpec'></span>

<h3>Description</h3>

<p>This function convolves each spectrum in a colorSpec object with a kernel of odd length.
Its primary purpose is to correct raw spectrometer data
(with positive instrumental bandwidth) to have bandwidth=0.
Two popular correction kernels for this, with lengths 3 and 5,
are built-in options, see <b>Details</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
convolvewith( x, coeff )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolvewith_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with N wavelengths</p>
</td></tr>
<tr><td><code id="convolvewith_+3A_coeff">coeff</code></td>
<td>

<p>a convolution kernel of odd length. The center entry of this vector is taken
as index 0 in the convolution.<br />
<code>coeff</code> can also be the string <code>'SS3'</code> which means to apply the Stearns&amp;Stearns
bandwidth correction kernel <code>coeff=c(-1,14,-1)/12</code>, see <b>Details</b>.<br />
<code>coeff</code> can also be the string <code>'SS5'</code> which means to apply the Stearns&amp;Stearns 
bandwidth correction kernel <code>coeff=c(1,-12,120,-12,1)/98</code>, see <b>Details</b>.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The built-in kernels, <code>'SS3'</code> and  <code>'SS5'</code>, were derived
by <cite>Stearns &amp; Stearns</cite> under specific hypotheses on the
spectrometer profile, bandpass, and pitch; see <b>References</b>.<br />
Missing values at both ends are filled by copying from the nearest valid value.<br />
The function creates a function calling <code>stats::filter()</code>
and passes that function to <code>applyspec()</code>.
</p>


<h3>Value</h3>

<p>a <b>colorSpec</b> object with the same dimensions,
<code><a href="#topic+wavelength">wavelength</a></code>, <code><a href="#topic+quantity">quantity</a></code>, and <code><a href="#topic+organization">organization</a></code>.
If <code>coeff</code> is invalid it is an ERROR and
<code>convolvewith()</code> returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Stearns, E.I., Stearns R.E.
An example of a method for correction radiance data for bandpass error.
<em>Color Research and Application</em>.
13-4. 257-259. 1988.
</p>
<p>Schanda, Janos.
CIE Colorimetry, in
<em>Colorimetry: Understanding the CIE System</em>. 
Wiley Interscience. 2007.
p. 124.
</p>
<p>Oleari, Claudio, Gabriele Simone.
<em>Standard Colorimetry: Definitions, Algorithms and Software</em>.
John Wiley. 2016.
p. 309.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>,
<code><a href="#topic+wavelength">wavelength</a></code>,
<code><a href="#topic+linearize">linearize</a></code>,  
<code><a href="#topic+applyspec">applyspec</a></code>,    
<code><a href="#topic+organization">organization</a></code>
</p>

<hr>
<h2 id='coredata'>Extract the Core Data of a colorSpec Object</h2><span id='topic+coredata'></span><span id='topic+coredata.colorSpec'></span><span id='topic+as.matrix.colorSpec'></span>

<h3>Description</h3>

<p>functions for extracting the core data contained in a <b>colorSpec</b> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
coredata( x, forcemat=FALSE )

## S3 method for class 'colorSpec'
as.matrix( x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coredata_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object</p>
</td></tr>
<tr><td><code id="coredata_+3A_forcemat">forcemat</code></td>
<td>
<p>if <code>x</code> has only 1 spectrum, return a matrix with 1 column instead of a vector</p>
</td></tr>
<tr><td><code id="coredata_+3A_...">...</code></td>
<td>
<p>extra arguments ignored</p>
</td></tr>  
</table>


<h3>Value</h3>

<table>
<tr><td><code>coredata</code></td>
<td>

<p>If <code>x</code> has <code>organization</code> equal to <code>'vector'</code> then it returns <code>x</code>,
unless <code>forcemat</code> is <code>TRUE</code> when it returns <code>x</code> as a matrix with 1 column.<br />
If <code>x</code> has any other <code>organization</code> then it returns a matrix
with spectra in the columns.
All of the <b>colorSpec</b> attributes are stripped except the column names,
and the row names are set to <code>as.character(wavelength(x))</code>.</p>
</td></tr>
<tr><td><code>as.matrix</code></td>
<td>
<p>a wrapper for <code>coredata</code> with <code>forcemat=TRUE</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+organization">organization</a></code>
</p>

<hr>
<h2 id='cs.options'>Functions to set and retrieve colorSpec package options</h2><span id='topic+cs.options'></span>

<h3>Description</h3>

<p><b>colorSpec</b> has a few options.
The options are stored in the <b>R</b> global list and they are:
</p>
<p><code>colorSpec.loglevel</code>, 
<code>colorSpec.logformat</code>, and 
<code>colorSpec.stoponerror</code>
</p>
<p>For details on what they do see <code><a href="#topic+logging">logging</a></code>.
</p>
<p>They can be set using the built-in function <code><a href="base.html#topic+options">options</a>()</code>.
When <span class="rlang"><b>R</b></span> starts up,
an option can be set using a call to <code>options()</code> in the file <b>Rprofile.site</b>.
If <b>colorSpec</b> is later loaded, the value of the option will not be changed.
If an option has not been assigned, then it is created with a default value.
</p>
<p>The function <code>cs.options()</code> makes setting the options a little easier
in a few ways:
</p>
  
<ul>
<li><p> it automatically prepends the string <code>'colorSpec.'</code>
</p>
</li>
<li><p> partial matching of the option name is enabled
</p>
</li>
<li><p> a warning is issued when the option value has the wrong type
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cs.options( ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cs.options_+3A_...">...</code></td>
<td>

<p>named arguments are set; 
unnamed arguments are ignored with a warning.
See <b>Examples</b>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with all the <b>colorSpec</b> options.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logging">logging</a></code>,
<code><a href="base.html#topic+options">options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs.options( loglevel="DEBUG", stop=FALSE )  # 'stop' partially matches 'stoponerror'
cs.options( stop='TRUE' )                   # warns that value has the wrong type
cs.options( stop=FALSE, "DEBUG" )           # warns that the 2nd argument has no name
cs.options( loglevel="WARN" )               # back to default
</code></pre>

<hr>
<h2 id='D50'>
Standard Illuminant D50 (1964)
</h2><span id='topic+D50'></span><span id='topic+D50.5nm'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>D50.5nm</code> </td><td style="text-align: left;"> standard Illuminant D50, from 300 to 830 nm at 5 nm intervals.
</td>
</tr>

</table>


<h3>Format</h3>

<p>A <b>colorSpec</b> object organized as a vector, with 107 data points 
and <code><a href="#topic+specnames">specnames</a></code> equal to <code>'D50'</code>.
</p>


<h3>Details</h3>

<p>This spectrum is not copied from a table from a CIE publication, though it does match such a table.
It is computed using the function <code><a href="#topic+daylightSpectra">daylightSpectra</a>()</code> by following
the special CIE recipe given in the <b>References</b>.
The temperature is set to (14388/14380) * 5000 = 5002.781 Kelvin.
The coefficients of the daylight components <code class="reqn">S_0, S_1</code>, and <code class="reqn">S_2</code> are
rounded to 3 decimal places.
This linear combination is computed at 10nm intervals and then linearly interpolated to 5nm intervals.
The result is normalized to value 1 at 560nm (instead of the usual 100),
and finally rounded to 5 decimal places.  See <b>Examples</b>.
</p>


<h3>References</h3>

<p>Günther Wyszecki and W.S. Stiles.
<b>Color Science : Concepts and Methods, Quantitative Data and Formulae</b>.
Second Edition.
Wiley-Interscience. 1982.
Table I(3.3.4)  pp. 754-758
</p>
<p>CIE 15: Technical Report: Colorimetry, 3rd edition.
CIE 15:2004.
Table T.1, pp 30-32, and Note 5 on page 69.
</p>
<p>Schanda, Janos.
CIE Colorimetry, in
<em>Colorimetry: Understanding the CIE System</em>. 
Wiley Interscience. 2007.
p. 42.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ABC">ABC</a></code> ,
<code><a href="#topic+D65">D65</a></code> ,
<code><a href="#topic+daylightSpectra">daylightSpectra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   the CIE recipe for computing D50.5nm
correction  = 14388 / 14380     # note 5, page 69 in CIE 15:2004
D50.10nm    = daylightSpectra( correction*5000, wavelength=seq(300,830,by=10), roundMs=TRUE )
D50.5nm     = resample( D50.10nm, seq(300,830,by=5), method='linear' )
D50.5nm     = round( D50.5nm, 5 )

summary( D50.5nm )
white.point = product( D50.5nm, xyz1931.1nm, wave='auto' )
</code></pre>

<hr>
<h2 id='D65'>
Standard Illuminant D65 (1964)
</h2><span id='topic+D65'></span><span id='topic+D65.1nm'></span><span id='topic+D65.5nm'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>D65.1nm</code> </td><td style="text-align: left;"> standard Illuminant D65, 300 to 830 nm at 1 nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>D65.5nm</code> </td><td style="text-align: left;"> standard Illuminant D65, 380 to 780 nm at 5 nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Format</h3>

<p>Each is a <b>colorSpec</b> object organized as a vector, 
with <code><a href="#topic+specnames">specnames</a></code> equal to <code>'D65'</code>.
</p>


<h3>Details</h3>

<p>Both of these have been divided by 100, 
to make the values at 560nm equal to 1 instead of 100.
</p>


<h3>Source</h3>

<p><a href="http://www.cvrl.org">http://www.cvrl.org</a>
</p>


<h3>References</h3>

<p>Günther Wyszecki and W.S. Stiles.
<b>Color Science : Concepts and Methods, Quantitative Data and Formulae</b>.
Second Edition.
Wiley-Interscience. 1982.
Table I(3.3.4)  pp. 754-758
</p>
<p>ASTM E 308-01.
Standard Practice for Computing the Colors of Objects by Using the CIE System.
Table 3. pages 3-4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ABC">ABC</a></code>, <code><a href="#topic+D50">D50</a></code>, <code><a href="#topic+daylightSpectra">daylightSpectra</a></code> , <code><a href="#topic+daylight">daylight</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary( D65.1nm )
white.point = product( D65.1nm, xyz1931.1nm, wave='auto' )
</code></pre>

<hr>
<h2 id='daylight'>
Standard Daylight Components
</h2><span id='topic+daylight1964'></span><span id='topic+daylight2013'></span><span id='topic+daylight'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>daylight1964</code> </td><td style="text-align: left;"> spectral components <code class="reqn">S_0, S_1, S_2</code>; from 300 to 830 nm at 5 nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>daylight2013</code> </td><td style="text-align: left;"> smoothed spectral components  <code class="reqn">S_0, S_1, S_2</code>; from 300 to 830 nm at 1 nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Format</h3>

<p>Each is a <b>colorSpec</b> object organized as a matrix with 3 columns
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>S0</code> </td><td style="text-align: left;"> component 0, the mean power spectrum </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>S1</code> </td><td style="text-align: left;"> component 1, the 1st characteristic spectrum </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>S2</code> </td><td style="text-align: left;"> component 2, the 2nd characteristic spectrum </td>
</tr>
<tr>
 <td style="text-align: left;">    
  </td>
</tr>

</table>



<h3>Source</h3>

<p><code>http://www.cie.co.at/publ/abst/datatables15_2004/CIE_sel_colorimetric_tables.xls</code>
</p>
<p><code>http://vision.vein.hu/~schanda/CIE%20TC1-74/</code>
</p>


<h3>References</h3>

<p>Günther Wyszecki and W.S. Stiles.
<b>Color Science : Concepts and Methods, Quantitative Data and Formulae</b>.
Second Edition.
Wiley-Interscience. 1982.
Table V(3.3.4)  p. 762.
</p>
<p>Smoothing spectral power distribution of daylights.
Zsolt Kosztyan and Janos Schanda.
Color Research &amp; Application.
Volume 38, Issue 5, pages 316-321, October 2013.
</p>
<p>CIE 15: Technical Report: Colorimetry, 3rd edition.
CIE 15:2004.
Table T.2, pp 33-34
</p>
<p>JUDD, D.B., MACADAM, D.L. and WYSZECKI, G.,
with the collaboration of BUDDE, H.W, CONDIT, H.R, HENDERSON, S.T, and SIMONDS, J.L. 
Spectral distribution of typical daylight as a function of correlated color temperature. 
J Opt. Soc. Am. 54, 1031-1040, 1964.
</p>
<p>Zsolt Kosztyan and Janos Schanda.
Smoothing spectral power distribution of daylights.
Color Research &amp; Application.
Volume 38, Issue 5, pages 316-321, October 2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D65">D65</a></code>,
<code><a href="#topic+D50">D50</a></code>, 
<code><a href="#topic+daylightSpectra">daylightSpectra</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary( daylight1964 )
day1964 = daylightSpectra( c(5000,6500), comp=daylight1964 )
day2013 = daylightSpectra( c(5000,6500), comp=daylight2013 )

plot( day1964, col='black' )
plot( day2013, col='black', add=TRUE )

</code></pre>

<hr>
<h2 id='DisplayRGB'>Compute Display RGB from Linear RGB</h2><span id='topic+DisplayRGBfromLinearRGB'></span>

<h3>Description</h3>

<p>All RGB displays have a non-linear &quot;gamma function&quot; of some sort.
This function converts from linear RGB to an RGB appropriate for 
the gamma function of the display;
which is also called the <em>electro-optical conversion function</em> (EOCF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DisplayRGBfromLinearRGB( RGB, gamma='sRGB' )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DisplayRGB_+3A_rgb">RGB</code></td>
<td>
<p>linear RGB values organized as a vector or matrix of any size; 
all 3 channels are treated the same way so size does not matter</p>
</td></tr>
<tr><td><code id="DisplayRGB_+3A_gamma">gamma</code></td>
<td>
<p>either the string <code>'sRGB'</code> or a positive number giving the gamma of the display.</p>
</td></tr></table>


<h3>Value</h3>

<p>The function first clamps the input <code>RGB</code> to the interval [0,1].
If <code>gamma='sRGB'</code> (not case-sensitive) it then maps [0,1] to [0,1] using the special
piecewise-defined sRGB function, see <cite>Wikipedia</cite>.
In case <code>gamma</code> is a positive number, the function raises all values to the power <code>1/gamma</code>.
The dimensions and names of the input are copied to the output. <br />
In case of error, the function returns the clamped input values.
</p>


<h3>WARNING</h3>

<p>This function is deprecated.
New software should use <code>spacesRGB::SignalRGBfromLinearRGB()</code> instead.
</p>


<h3>Source</h3>

<p>Wikipedia.
<b>sRGB</b>.
<a href="https://en.wikipedia.org/wiki/SRGB">https://en.wikipedia.org/wiki/SRGB</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RGBfromXYZ">RGBfromXYZ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DisplayRGBfromLinearRGB( c(0.2, 0.5) )
# [1] 0.4845292 0.7353570     #  this is display sRGB, in [0,1]

DisplayRGBfromLinearRGB( c(-0.1, 0.2, 0.5, 1), 2.2 )
# [1] 0.0000000 0.4811565 0.7297401 1.0000000    #  gamma=2.2

x = seq( 0, 1, len=101)
plot( x, DisplayRGBfromLinearRGB(x), type='l' )
</code></pre>

<hr>
<h2 id='emulate'>modify a colorSpec responder to emulate (approximate) another responder</h2><span id='topic+emulate'></span><span id='topic+emulate.colorSpec'></span>

<h3>Description</h3>

<p>The two possible modifications are:
</p>

<ul>
<li><p> pre-multiplication by a transmitting filter
</p>
</li>
<li><p> post-multiplication by a matrix
</p>
</li></ul>

<p>Both of these are optional.
If neither of these modifications is enabled, the original <code>x</code> is returned.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
emulate( x, y, filter=FALSE, matrix=TRUE )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emulate_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> responder with M spectra, to be modified. 
The <code>type</code> must be <code>'responsivity.light'</code> or <code>'responsivity.material'</code></p>
</td></tr>
<tr><td><code id="emulate_+3A_y">y</code></td>
<td>
<p>a <b>colorSpec</b> responder with N spectra, to be emulated by a modified <code>x</code>.
It must have the same <code>type</code> and <code>wavelength</code> vector as <code>x</code>
</p>
</td></tr>
<tr><td><code id="emulate_+3A_filter">filter</code></td>
<td>
<p>enable filter pre-multiplication.</p>
</td></tr>
<tr><td><code id="emulate_+3A_matrix">matrix</code></td>
<td>
<p>enable matrix post-multiplication.
If <code>matrix=TRUE</code> then the computed matrix <code>A</code> is MxN. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>filter=FALSE</code> and <code>matrix=TRUE</code> then
the returned value is <code>multiply(x,A)</code>,
where the matrix <code>A</code> is computed to minimize the difference with
<code>y</code>, in the least squares sense (Frobenius matrix norm).
The function <code><a href="MASS.html#topic+ginv">ginv</a>()</code> is used here.
</p>
<p>If <code>filter=TRUE</code> and <code>matrix=FALSE</code> then
the returned value is <code>product(filter,x)</code>,
where the object <code>filter</code> is computed to minimize the difference with
<code>y</code>, in the least squares sense (Frobenius matrix norm).
This calculation is fairly straightforward,
but requires that the responsivity of <code>x</code> does not vanish at any wavelength.
It also requires that <code>M=N</code>.
The computed filter may be unrealistic, i.e. the transmittance may be &gt; 1.
If this happens a <code>WARN</code> message is issued.
</p>
<p>If <code>filter=TRUE</code> and <code>matrix=TRUE</code> then
the returned value is <code>product(filter,multiply(x,A))</code>,
where <code>(filter,A)</code> are chosen with the above minimization criterion.
If <code>N=1</code> then we must have <code>M=1</code> as well;
the calculation is trivial and the emulation is exact.
If <code>N</code> <code class="reqn">\ge</code> <code>2</code>,
the calculation is iterative - solving alternatively for 
<code>filter</code> and <code>A</code> until convergence.
The function <code><a href="MASS.html#topic+ginv">ginv</a>()</code> is used on each iteration.
This is a bilinear optimization.
If convergence fails, it is an error and the function returns <code>NULL</code>.
If convergence succeeds, there is 1 degree of freedom in the <code>(filter,A)</code> pair.
If one is scaled by a positive constant, the other can be scaled by the inverse,
and the returned object is the same.
The filter is scaled so the maximum transmittance is 1.
</p>
<p>If <code>filter=FALSE</code> and <code>matrix=FALSE</code> then
the original <code>x</code> is returned, with a <code>WARN</code> message.
</p>


<h3>Value</h3>

<p>a <b>colorSpec</b> object close to <code>y</code>, as in <b>Details</b>.
The <code>quantity</code> is the same as <code>y</code>.
The <code>specnames()</code> are the same as those of <code>y</code>,
except that <code>".em"</code> is appended to each one.
The function attaches attribute <code>"emulate"</code>,
whose value is a list containing <code>filter</code> and/or <code>A</code> as appropriate.
</p>


<h3>Examples</h3>

<p>see the vignette <a href="../doc/emulation.pdf"><b>Emulation of one Camera by another Camera</b></a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wavelength">wavelength</a></code>,
<code><a href="#topic+type">type</a></code>,
<code><a href="#topic+quantity">quantity</a></code>,
<code><a href="#topic+multiply">multiply</a></code>,
<code><a href="#topic+product">product</a></code>,
<code><a href="#topic+specnames">specnames</a></code>
</p>

<hr>
<h2 id='extradata'>extradata of a colorSpec object</h2><span id='topic+extradata'></span><span id='topic+extradata+3C-'></span><span id='topic+extradata.colorSpec'></span><span id='topic+extradata+3C-.colorSpec'></span>

<h3>Description</h3>

<p>Retrieve or set the extradata of a <b>colorSpec</b> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
extradata(x)

## S3 replacement method for class 'colorSpec'
extradata(x,add=FALSE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extradata_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b>  object with M spectra</p>
</td></tr>
<tr><td><code id="extradata_+3A_value">value</code></td>
<td>
<p>a <code>data.frame</code> with M rows.
It is OK for <code>value</code> to have 0 columns,
and <code>value</code> can also be <code>NULL</code>; see <code>add</code>.
</p>
</td></tr>
<tr><td><code id="extradata_+3A_add">add</code></td>
<td>
<p> If <code>add</code> is <code>FALSE</code>,
then any existing extradata is discarded and replaced by <code>value</code>,
except when <code>value</code> is <code>NULL</code> when <code>x</code> is left with no <code>extradata</code>.<br />
If <code>add</code> is <code>TRUE</code>, then <code>value</code> is appended to the existing extradata,
except when <code>value</code> is <code>NULL</code> when <code>x</code> is left unchanged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>organization</code> of <code>x</code> is not <code>'df.row'</code>, 
then <code>extradata</code> cannot be stored in <code>x</code> and the assignment is ignored, with a warning.
First change the <code><a href="#topic+organization">organization</a></code> to <code>'df.row'</code>,
and <em>then</em> assign the <code>extradata</code>.
</p>
<p>If the <code>organization</code> of <code>x</code> is <code>'df.row'</code>, but <code>value</code> does not have
the right number of rows, the assignment is ignored, with a warning.<br />
</p>


<h3>Value</h3>

<p><code>extradata(x)</code> returns a <code>data.frame</code> with M rows,
where M is the number of spectra in <code>x</code>.  
The <code>rownames</code> are set to the <code>specnames</code> of <code>x</code>.
If there is no extra data then the number of columns in this <code>data.frame</code> is 0.
</p>


<h3>Note</h3>

<p>Do not confuse <code>extradata</code> and <code>metadata</code>.<br />
<code>metadata</code> is unstructured data that is attached to the entire <b>colorSpec</b> object.
<code>extradata</code> is structured data, with a row of data for each spectrum in the object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metadata">metadata</a></code>, 
<code><a href="#topic+organization">organization</a></code>
</p>

<hr>
<h2 id='F96T12'>
Photon Irradiance of F96T12 Fluorescent Bulb
</h2><span id='topic+F96T12'></span>

<h3>Description</h3>

<p><code>F96T12</code><br />
Sylvania F96T12 CW/VHO 215-Watt fluorescent bulb photon irradiance, 
measured with a LI-COR LI-1800 spectroradiometer,
from 300 to 900 nm at 1 nm intervals.
</p>


<h3>Format</h3>

<p>A <b>colorSpec</b> object organized as a vector, with 601 data points 
and <code><a href="#topic+specnames">specnames</a></code> equal to <code>'F96T12'</code>.
</p>


<h3>Details</h3>

<p>The unit is (<code class="reqn">\mu</code>mole of photons)<code class="reqn"> *sec^{-1}*m^{-2}*nm^{-1}</code>.
</p>


<h3>Source</h3>

<p>Pedro J. Aphalo.
<a href="https://www.mv.helsinki.fi/home/aphalo/photobio/lamps.html">https://www.mv.helsinki.fi/home/aphalo/photobio/lamps.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ABC">ABC</a></code> ,
<code><a href="#topic+D65">D65</a></code> ,
<code><a href="#topic+daylightSpectra">daylightSpectra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum( F96T12 ) 
# [1] 320.1132  photon irradiance, (micromoles of photons)*m^{-2}

sum( radiometric(F96T12) )
# [1] 68.91819  irradiance, watts*m^{-2}
</code></pre>

<hr>
<h2 id='Flea2.RGB'>
Flea2 Camera FL2-14S3C from Point Grey
</h2><span id='topic+Flea2.RGB'></span><span id='topic+Flea2'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>Flea2.RGB</code> </td><td style="text-align: left;"> an RGB responder to light, from 360 to 800 nm at 10 nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Format</h3>

<p>A <b>colorSpec</b> object with <code>quantity</code> equal to <code>'energy-&gt;electrical'</code> and 3 spectra:
<code>Red</code>, <code>Green</code>, and <code>Blue</code>.
<br />
</p>


<h3>Details</h3>

<p>This data is read from the file <b>Flea2-spectral.txt</b> which was digitized from the
plot in <b>Flea2-spectral.png</b>.
<br />
</p>


<h3>Source</h3>

<p><a href="https://ptgreycamera.com/product/camera/flir/flea2/firewireb-flea2/fl2-14s3c-c/">https://ptgreycamera.com/product/camera/flir/flea2/firewireb-flea2/fl2-14s3c-c/</a>
<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>,
vignette <a href="../doc/blueflame.pdf"><b>Blue Flame and Green Comet</b></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Make a scanner from a tungsten source and a Flea2 camera
Flea2.scanner = product( A.1nm, "VARMATERIAL", Flea2.RGB, wavelength=420:680 )
Flea2.scanner = calibrate( Flea2.scanner )
</code></pre>

<hr>
<h2 id='Fluorescents'>
Standard series F Illuminants F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, and F12
</h2><span id='topic+Fs.5nm'></span><span id='topic+Fluorescents'></span>

<h3>Description</h3>

<p><code>Fs.5nm</code> contains 12 CIE Fluorescent Illuminants, from 380 to 780 nm, at 5nm intervals.
</p>


<h3>Format</h3>

<p><code>Fs.5nm</code> is a <b>colorSpec</b> object with 12 spectra.
It is organized as a data frame  with <code><a href="#topic+quantity">quantity</a></code> equal to <code>"energy".</code>
</p>


<h3>Note</h3>

<p>The series F illuminants do not seem to be normalized in a consistent way.
</p>


<h3>Source</h3>

<p><a href="http://www.rit-mcsl.org/UsefulData/Fluorescents.htm">http://www.rit-mcsl.org/UsefulData/Fluorescents.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ABC">ABC</a></code>,  <code><a href="#topic+D50">D50</a></code>,   <code><a href="#topic+D65">D65</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   plot only F4
plot( subset(Fs.5nm,"F4") )
</code></pre>

<hr>
<h2 id='HigherPasserines'>
Cone Fundamentals for the Higher Passerines
</h2><span id='topic+HigherPasserines'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>HigherPasserines</code> </td><td style="text-align: left;"> Tetrachromatic Cone Fundamentals of Higher Passerine Birds </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Format</h3>

<p>A <b>colorSpec</b> object organized as a matrix with the 4 spectra:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>UV</code> </td><td style="text-align: left;"> the UV wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Short</code> </td><td style="text-align: left;"> the short wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Medium</code> </td><td style="text-align: left;"> the medium wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>Long</code> </td><td style="text-align: left;"> the long wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The <code>wavelength</code> is from 300 to 700 nm, at 1nm intervals.
</p>


<h3>Source</h3>

<p><code>https://onlinelibrary.wiley.com/doi/full/10.1111/j.1095-8312.2005.00540.x</code>
</p>


<h3>References</h3>

<p>Endler &amp; Mielke.
Comparing entire colour patterns as birds see them.
Biological Journal of the Linnean Society.
Volume 86, Issue 4, pages 405-431, December 2005.
Original Name of File: BIJ_540_Endler_Mielke_OnlineAppendix.txt.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lms2000">lms2000</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(HigherPasserines)
</code></pre>

<hr>
<h2 id='Hoya'>
standard Hoya filters
</h2><span id='topic+Hoya'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>Hoya</code> </td><td style="text-align: left;"> 4 standard Hoya filters; from 300 to 750 nm at 10nm intervals.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Format</h3>

<p>A <b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'transmittance'</code> and 4 spectra:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>R-60</code>   </td><td style="text-align: left;">   long-pass red filter with cutoff about 600nm</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>G-533</code>  </td><td style="text-align: left;">   band-pass green filter with peak about 533nm</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>B-440</code>  </td><td style="text-align: left;">   band-pass blue filter with peak about 440nm</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>LB-120</code> </td><td style="text-align: left;">   Light-balancing Blue filter with mired shift equal to -120 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p><a href="https://hoyaoptics.com/">https://hoyaoptics.com/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   compute response of ACES scanner to the Hoya filters
product( Hoya, scanner.ACES, wave='auto' )
</code></pre>

<hr>
<h2 id='interpolate'>interpolate spectra</h2><span id='topic+interpolate'></span><span id='topic+interpolate.colorSpec'></span>

<h3>Description</h3>

<p>interpolate along a 1-parameter path of spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
interpolate( x, p, pout, pname=deparse(substitute(p)) )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object, typically with multiple spectra</p>
</td></tr>
<tr><td><code id="interpolate_+3A_p">p</code></td>
<td>
<p>a numeric vector with <code>length(p)==numSpectra(x)</code>. The value <code>p[i]</code> is associated with the <code>i</code>'th spectrum in <code>x</code>.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_pout">pout</code></td>
<td>
<p>a numeric vector of parameter values at which interpolation of the spectra in <code>x</code> take place</p>
</td></tr>
<tr><td><code id="interpolate_+3A_pname">pname</code></td>
<td>
<p>the name of the parameter <code>p</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each spectrum in <code>x</code> can be thought of as a point in a high-dimensional space,
and each point has a real-valued parameter associated with it.
The function performs natural spline interpolation on these points,
one coordinate at a time.
For each wavelength value it calls <code><a href="stats.html#topic+spline">spline</a></code>
with <code>method='natural'</code>.
</p>


<h3>Value</h3>

<p><code>interpolate(x)</code> returns a <b>colorSpec</b> object <code>y</code>
with a spectrum for each value in <code>pout</code>.
The organization of <code>y</code> is <code>'df.row'</code>,
and <code>extradata(y)</code> has a single column which is a copy of <code>pout</code>.
The name of the column is <code>pname</code>.
The names in <code>specnames(y)</code> are <code>&lt;pname&gt;=&lt;pout&gt;</code>.
Other properties of <code>y</code>,
e.g. <code><a href="#topic+wavelength">wavelength</a></code>, <code><a href="#topic+quantity">quantity</a></code>, ...,
are the same as <code>x</code>.<br />
In case of ERROR, the function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+organization">organization</a></code>,   
<code><a href="#topic+wavelength">wavelength</a></code>,
<code><a href="#topic+extradata">extradata</a></code>,
<code><a href="stats.html#topic+spline">spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path = system.file( "extdata/stains/PhenolRed-Fig7.txt", package="colorSpec" )
wave = 350:650
phenolred = readSpectra( path, wavelength=wave )
pH = as.numeric( sub( '[^0-9]+([0-9]+)$', '\\1', specnames(phenolred) ) )
pHvec = seq(min(pH),max(pH),by=0.05)
phenolinterp = interpolate( phenolred, pH, pHvec )
</code></pre>

<hr>
<h2 id='invert'>estimate spectra from responses, effectively inverting the operator from spectrum to response</h2><span id='topic+invert'></span><span id='topic+invert.colorSpec'></span>

<h3>Description</h3>

<p>Given a light responder (e.g. an eye or a camera),
two light spectra that produce the same response from the responder
are called <em>metamers</em> for that responder.
Similarly, given a material responder (e.g. a scanner),
two reflectance spectra that produce the same response from the responder
are called <em>metamers</em> for that responder.
</p>
<p>For a given responder and response, 
there are typically infinitely many <em>metamers</em>.
The set of all of them is often called the <em>metameric suite</em>.
The goal of the function <code>invert()</code> is to calculate a &quot;good&quot; metamer
in the &quot;suite&quot;.
<cite>Koenderink</cite> calls this topic <em>inverse colorimetry</em>.
In the case that the estimated spectrum is a reflectance spectrum,
the topic is often called <em>reflectance estimation</em> or <em>reflectance recovery</em>,
see <cite>Bianco</cite>.
</p>
<p>The <em>centroid method</em>, which is the default and the featured method
in this package, computes the centroid of the set of all the metamers (if any).
The centroid is computed in an infinite-dimensional context 
and is expounded further in
<cite>Davis</cite>.
</p>
<p>The <em>Hawkyard method</em>, see <cite>Hawkyard</cite> and <cite>Bianco</cite>,
has been around a long time.
The centroid and Hawkyard methods have similarities,
e.g. both are low-dimensional with the number of variables equal to
the number of responses (usually 3).
The Hawkyard method is very fast, but has a key problem, see below.
</p>
<p>The <em>Transformed Least Slope Squared</em> (TLSS) method was developed
by Scott Burns, see <b>References</b>.
This is my name for it, not his.
What I call TLLS is actually is a combination of Burns' LHTSS and LLSS methods;
the one that <code>invert()</code> chooses depends on <code>type(x)</code>, see below.
Both of these are high-dimensional,
with the number of variables equal to #(responses) + #(wavelengths).
</p>
<p>The first argument to <code>invert()</code> is the responder <code>x</code>,
and the second is the matrix <code>response</code> of responses (e.g. XYZs or RGBs).
</p>
<p>The goal is to return a &quot;good&quot; spectrum for each response so that:
</p>

<table>
<tr>
 <td style="text-align: center;">
<code>product( invert(x,response), x )</code> <code class="reqn">~\cong~</code> <code>response</code>
</td>
</tr>

</table>

<p>The error is returned as column <code>estim.precis</code>, see below.
</p>
<p>First consider the case where <code>x</code> has type <code>type='responsivity.material'</code>.
The goal is to compute a reflectance spectra.
All the methods will fail if the response is on the object-color boundary
(an <em>optimal color</em>) or outside the boundary.
They <em>may</em> also fail if the response is inside the object-color
solid (the <em>Rösch Farbkörper</em>) and very close to the boundary.
<br />
The centroid method solves a non-linear system that contains a 
<em>Langevin-function-based</em> squashing function, see <cite>Davis</cite> for details.
When successful it always returns a feasible spectrum
with small <code>estim.precis</code>.
<br />
The Hawkyard method is linear and very fast,
but in raw form it may return a non-feasible reflectance spectrum.
In this case <code>invert()</code> simply clamps to the interval [0,1] and so
<code>estim.precis</code> can be large.
<br />
The TLSS method solves a non-linear system that contains
the squashing function <code class="reqn">(\tanh(z) + 1)/2</code>, see <cite>Burns</cite> for details.
When successful it always returns a feasible spectrum
with small <code>estim.precis</code>.
</p>
<p>Now consider the case where <code>x</code> has <code>type='responsivity.light'</code>.
The goal is to compute the spectrum of a light source.
All the methods will fail if chromaticity of the response is on the boundary
of the inverted-U (assuming <code>x</code> models the human eye) or outside the boundary.
They <em>may</em> also fail if the response is inside the inverted-U
and very close to the boundary.
<br />
The centroid method works on a relatively small range of chromaticities;
it will fail if the response is too far from the response to Illuminant E.
See <cite>Davis</cite> for the details.
When successful it always returns an everywhere positive spectrum
with small <code>estim.precis</code>.
This method has the desirable property that if the response is multiplied by
a positive number, the computed spectrum is multiplied by that same number.
<br />
The Hawkyard method does not work in this case.
<br />
The TLSS method solves a non-linear system that contains
the squashing function <code class="reqn">\exp(z)</code>, see <cite>Burns</cite> for the details.
When successful it always returns an everywhere positive spectrum
with small <code>estim.precis</code>.
This method succeeds on a larger set of chromaticities than the centroid method.
It also has the desirable scaling multiplication property mentioned above.
</p>
<p>The centroid and Hawkyard methods have an equalization option,
which is controlled by the argument <code>alpha</code>
and is enabled by default, see below.
When enabled, if the response comes from a constant spectrum
(a perfectly neutral gray material, or a multiple of Illuminant E),
then the computed spectrum is that same constant spectrum (up to numerical precision).
I call this the <em>neutral-exact property</em>.
Equalization is a complicated mechanism, for details see <cite>Davis</cite>.
For the TLSS method, the neutral-exact property is intrinsic,
and <code>alpha</code> is ignored.
<br />
NOTE:
If the responder has only one output channel (e.g. a monochrome camera)
and equalization is enabled,
then <em>all</em> responses are inverted to a constant spectrum.
This may or may not be desirable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
invert( x, response, method='centroid', alpha=1 )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type(x)</code> = 
<code>'responsivity.material'</code> or <code>'responsivity.light'</code> and M responsivities.
The wavelengths must be regular (equidistant).</p>
</td></tr>
<tr><td><code id="invert_+3A_response">response</code></td>
<td>
<p> a numeric NxM matrix, or a numeric vector that can be converted
to such matrix, by row. The N responses are contained in the rows.
The <code>rownames(response)</code> are copied to the output <code>specnames</code>.</p>
</td></tr>
<tr><td><code id="invert_+3A_method">method</code></td>
<td>
<p>either <code>'centroid'</code> or <code>'Hawkyard'</code> or <code>'TLSS'</code>.  
<code>'Hawkyard'</code> is only valid when 
<code>type(x)</code> is <code>'responsivity.material'</code>.
Matching is partial and case-insensitive.</p>
</td></tr>
<tr><td><code id="invert_+3A_alpha">alpha</code></td>
<td>
<p>a vector of M weighting coefficients, 
or a single number that is replicated to length M. 
When <code>method='centroid'</code>, <code>alpha</code> is used for <em>equalizing</em> 
the responsivities, which is recommended.
For <code>alpha</code> to be valid, the linear combination of the M responsitivies,
with coefficients <code>alpha</code>, must be positive.
To disable equalization (not recommended) and use the original responsivities, 
set <code>alpha=NULL</code>. 
Similarly, when <code>method='Hawkyard'</code>, <code>alpha</code> is used for equalizing 
the responsivities, which is also recommended.
When <code>method='TLSS'</code>, <code>alpha</code> is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>method='centroid'</code> the function calls the non-linear root-finder 
<code><a href="rootSolve.html#topic+multiroot">rootSolve::multiroot</a>()</code>,
which is general purpose and &quot;full Newton&quot;.
</p>
<p>For <code>method='Hawkyard'</code> the function solves a linear system by
inverting a small matrix (#[responses] x #[responses]).
The spectra are then clamped to [0,1].
</p>
<p>For <code>method='TLSS'</code> the function solves a constrained least-squares problem
using Lagrange multipliers.
A critical point is found using a &quot;full Newton&quot; iteration.
The original MATLAB code is posted at <cite>Burns</cite>,
and was  ported from MATLAB to R with only trivial changes.
When computing a reflectance spectrum, the Hawkyard method is used for the
initial guess, after little extra clamping.
This improved guess cuts the number of iterations substantially, 
and the extra computation time is negligible.
</p>


<h3>Value</h3>

<p>If <code>type(x)='responsivity.material'</code> it returns a <b>colorSpec</b> object
with <code>type</code> = <code>'material'</code> (<code>quantity</code> = <code>'reflectance'</code>).
</p>
<p>If <code>type(x)='responsivity.light'</code> it returns a <b>colorSpec</b> object
with <code>type</code> = <code>'light'</code>
(<code>quantity</code>=<code>'energy'</code> or <code>quantity</code>=<code>'photons'</code>
depending on <code>quantity(x)</code>).
</p>
<p>In either case, the returned object has <code>organization</code> = <code>'df.row'</code> 
and the <code>extradata</code> is a <code>data.frame</code> with these columns:
</p>
<table>
<tr><td><code>response</code></td>
<td>
<p>the input matrix of desired responses</p>
</td></tr>
<tr><td><code>estim.precis</code></td>
<td>
<p>the difference between the desired response and actual response.  It   is the mean of the absolute value of the differences.
See <code><a href="rootSolve.html#topic+multiroot">rootSolve::multiroot</a>()</code> </p>
</td></tr>  
<tr><td><code>time.msec</code></td>
<td>
<p>the time to compute the spectrum, in msec. 
When <code>method='Hawkyard'</code>, all N spectra are computed at once, 
so all N spectra are assigned the same mean time.</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>the number of iterations that were required to find the relevant root. 
This is not present when <code>method='Hawkyard'</code>.</p>
</td></tr>
<tr><td><code>clamped</code></td>
<td>
<p>a logical indicating whether the reflectance was clamped to [0,1]. This is present only  when <code>method='Hawkyard'</code>.</p>
</td></tr>
</table>
<p>If a response could not be estimated, 
the row contains <code>NA</code> in appropriate columns,
and a warning is issued.<br />
</p>
<p>In case of global error, the function returns <code>NULL</code>.
</p>


<h3>Known Issues</h3>

<p>If <code>type(x)='responsivity.light'</code> the centroid method may fail
(not converge) if the response is too far from that of Illuminant E.
</p>


<h3>References</h3>

<p>Davis, Glenn.
A Centroid for Sections of a Cube in a Function Space, with Application to Colorimetry.
<a href="https://arxiv.org/abs/1811.00990">https://arxiv.org/abs/1811.00990</a>.
[math.FA].
2018.
</p>
<p>Bianco, Simone.
Reflectance spectra recovery from tristimulus values by adaptive estimation with metameric shape correction.
vol. 27, no 8.
<em>Journal of the Optical Society of America A</em>.
pages 1868-1877.
2010
<a href="https://opg.optica.org/josaa/abstract.cfm?uri=josaa-27-8-1868">https://opg.optica.org/josaa/abstract.cfm?uri=josaa-27-8-1868</a>.
</p>
<p>Burns, Scott A. 
Generating Reflectance Curves from sRGB Triplets.
<a href="http://scottburns.us/reflectance-curves-from-srgb/">http://scottburns.us/reflectance-curves-from-srgb/</a>.
</p>
<p>Hawkyard, C. J.
Synthetic reflectance curves by additive mixing.
<em>Journal of the Society of Dyers and Colourists</em>.
vol. 109. no. 10.
Blackwell Publishing Ltd.
pp. 323-329.
1993.
</p>
<p>Koenderink, J.J.
Color for the Sciences.
MIT Press.
2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type">type</a>()</code>,
<code><a href="#topic+quantity">quantity</a>()</code>,
<code><a href="#topic+organization">organization</a>()</code>,
<code><a href="#topic+specnames">specnames</a>()</code>,
<code><a href="#topic+product">product</a>()</code>,
<code><a href="#topic+extradata">extradata</a>()</code>,
<code><a href="rootSolve.html#topic+multiroot">rootSolve::multiroot</a>()</code>,
vignette <a href="../doc/inversion.pdf"><b>Estimating a Spectrum from its Response</b></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave = 400:700
E.eye = product( illuminantE(1,wave), "material", xyz1931.1nm, wavelength=wave )
path = system.file( 'extdata/targets/CC_Avg30_spectrum_CGATS.txt', package='colorSpec' )
MacbethCC = readSpectra( path, wavelength=wave )
XYZ = product( MacbethCC, E.eye, wavelength=wave )
est.eq   = invert( E.eye, XYZ, method='centroid', alpha=1 )
extra   = extradata(est.eq)
range(extra$estim.precis)       # prints   0.000000e+00 3.191741e-08
</code></pre>

<hr>
<h2 id='lightResponsivitySpectra'>compute standard light responsivity spectra</h2><span id='topic+lightResponsivitySpectra'></span><span id='topic+erythemalSpectrum'></span>

<h3>Description</h3>

<p>Some action spectra standards are defined by simple equations;
the erythemal spectrum for human sunburn is one of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erythemalSpectrum( wavelength=250:400 )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lightResponsivitySpectra_+3A_wavelength">wavelength</code></td>
<td>
<p>a vector of wavelengths, in nm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This erythemal spectrum is defined in 4 pieces: 
<code class="reqn">\lambda \le 298</code>, 
<code class="reqn"> 298 \le \lambda \le 328</code>,
<code class="reqn"> 328 \le \lambda \le 400</code>, and 
<code class="reqn"> 400 &lt; \lambda</code>.  The unit is nm.
The spectrum is used in the definition of the international standard <b>UV Index</b>.
</p>


<h3>Value</h3>

<p>For <code>erythemalSpectrum()</code> <br />
A <b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'energy-&gt;action'</code>.
The responsivity is 0 for <code class="reqn">\lambda</code> &gt; 400 nm, so this putting this spectrum in the category
of human vision is a bit of a stretch.
</p>


<h3>Source</h3>

<p><a href="https://en.wikipedia.org/wiki/Ultraviolet_index">https://en.wikipedia.org/wiki/Ultraviolet_index</a>
</p>


<h3>References</h3>

<p>McKinlay, A.F., and B.L. Diffey.
A reference action spectrum for ultraviolet induced erythema in human skin. 
CIE Res. Note, 6(1), 17-22. (1987)
</p>


<h3>See Also</h3>

<p><a href="#topic+daylight">daylight</a>,
<code><a href="#topic+quantity">quantity</a></code>,
<a href="#topic+materialSpectra">materialSpectra</a>,
<a href="#topic+lightSpectra">lightSpectra</a>
</p>

<hr>
<h2 id='LightSpectra'>compute standard light spectra</h2><span id='topic+lightSpectra'></span><span id='topic+daylightSpectra'></span><span id='topic+planckSpectra'></span><span id='topic+illuminantE'></span>

<h3>Description</h3>

<p>Two families of standard illuminants that are parameterized by temperature are the
Planckian spectra (black-body spectra), and daylight spectra.
For the daylight spectra, a smoothed version is available.
Illuminant E, a third and trivial spectrum, is also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planckSpectra( temperature, wavelength=300:830, normalize=TRUE, c2=1.4388e-2 )

daylightSpectra( temperature, wavelength=NULL, 
                    components=colorSpec::daylight1964, roundMs=FALSE )

illuminantE( energy=1, wavelength=380:780 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LightSpectra_+3A_temperature">temperature</code></td>
<td>
<p>a vector of temperatures, in Kelvin</p>
</td></tr>
<tr><td><code id="LightSpectra_+3A_wavelength">wavelength</code></td>
<td>
<p>a vector of wavelengths.
For <code>planckSpectra()</code> and  <code>illuminantE()</code> this is required. 
For <code>daylightSpectra()</code> this is optional. 
The default <code>wavelength=NULL</code> means to use the wavelengths in <code>components</code>, 
and otherwise <code>components</code> is resampled at the given <code>wavelength</code> vector. </p>
</td></tr>
<tr><td><code id="LightSpectra_+3A_normalize">normalize</code></td>
<td>
<p>a logical value.  
If <code>TRUE</code> the Planck spectra are normalized to have value 1 at 560nm.
If <code>FALSE</code> then the quantity returned is radiant exitance with unit 
<code class="reqn">W * m^{-2} * nm^{-1}</code>. </p>
</td></tr>
<tr><td><code id="LightSpectra_+3A_c2">c2</code></td>
<td>
<p>the value of <code class="reqn">hc/k</code> in Planck's law.
<code class="reqn">h</code> is the Planck constant; 
<code class="reqn">c</code> is the speed of light in <code class="reqn">m/sec</code>; and 
<code class="reqn">k</code> is the Boltzmann constant.
The default value of 1.4388e-2 <code class="reqn">m*K</code> was recommended by the CIE in 2005;
in 1986 the CIE recommended <code>c2</code>=1.438e-2.
If <code>c2='calc'</code> then <code>c2</code> is calculated directly from the 3 physical constants,
as recommended by CODATA 2014.
</p>
</td></tr>
<tr><td><code id="LightSpectra_+3A_components">components</code></td>
<td>
<p>a <b>colorSpec</b> object with the daylight components <code class="reqn">S_0, S_1</code>, and <code class="reqn">S_2</code>.
The default is <code><a href="#topic+daylight1964">daylight1964</a></code> and
a smoothed version <code><a href="#topic+daylight2013">daylight2013</a></code> is also available.</p>
</td></tr>
<tr><td><code id="LightSpectra_+3A_roundms">roundMs</code></td>
<td>
<p>a logical value.  The original CIE method for the daylight spectra requires
rounding intermediate coefficients M1 and M2 to 3 decimal places.
This rounding is necessary to reproduce the tabulated values in Table T.1 of the CIE
publication in <b>References</b>.</p>
</td></tr>
<tr><td><code id="LightSpectra_+3A_energy">energy</code></td>
<td>
<p>a vector of energy levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>planckSpectra()</code> the valid range of temperatures is 
0 to <code>Inf</code> (<code class="reqn">\infty</code>) K, but with exceptions at the endpoints.
For a negative temperature the spectrum is set to all <code>NA</code>s.
<br />
If <code>temperature=0</code> and <code>normalize=TRUE</code>, the spectrum is set to all <code>NA</code>s.
If <code>temperature=0</code> and <code>normalize=FALSE</code>, the spectrum is set to all 0s.
<br />
Conversely, if <code>temperature=Inf</code> and <code>normalize=FALSE</code>, 
the spectrum is set to all <code>NA</code>s.
If <code>temperature=Inf</code> and <code>normalize=TRUE</code>, 
the spectrum is set to the pointwise limit <code class="reqn">(560/\lambda)^4</code> (which appears blue).
</p>
<p>For <code>daylightSpectra()</code> the valid range of temperatures is 4000 to 25000 K.
For a temperature outside this range the spectrum is set to all <code>NA</code>s.
</p>
<p>The equations for <code>daylightSpectra()</code> and <code>planckSpectra()</code> are complex 
and can be found in the <b>References</b>.
</p>
<p><code>IlluminantE()</code> is trivial - all constant energy.
</p>


<h3>Value</h3>

<p>For <code>planckSpectra()</code> and <code>daylightSpectra()</code> :<br />
A <b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'energy'</code>,
and <code><a href="#topic+organization">organization</a></code> equal to <code>'matrix'</code> or <code>'vector'</code>.
The <code>specname</code>s are <code>PNNNN</code> or <code>DNNNN</code>
for <code>planckSpectra()</code> and <code>daylightSpectra()</code> respectively.<br />
The number of spectra in the object is the number of temperatures = <code>length(temperature)</code>.<br />
</p>
<p>For <code>illuminantE()</code> :<br />
A <b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'energy'</code>. <br />
The number of spectra in the object is the number of 
energy levels = <code>length(energy)</code>.
</p>


<h3>References</h3>

<p>Günther Wyszecki and W.S. Stiles.
<b>Color Science : Concepts and Methods, Quantitative Data and Formulae</b>.
Second Edition.
Wiley-Interscience. 1982.
page 146.
</p>
<p>CIE 15: Technical Report: Colorimetry, 3rd edition.
CIE 15:2004.
Table T.1, pp 30-32, and Note 5 on page 69.
</p>
<p>Schanda, Janos.
CIE Colorimetry, in
<em>Colorimetry: Understanding the CIE System</em>. 
Wiley Interscience. 2007.
p. 42.
</p>


<h3>See Also</h3>

<p><a href="#topic+daylight">daylight</a>, <code><a href="#topic+resample">resample</a></code>, <code><a href="#topic+organization">organization</a></code>, <code><a href="#topic+quantity">quantity</a></code>,
<a href="#topic+materialSpectra">materialSpectra</a>
</p>

<hr>
<h2 id='linearize'>linearize a colorSpec object - to make it ready for colorimetric calculations</h2><span id='topic+linearize'></span><span id='topic+linearize.colorSpec'></span>

<h3>Description</h3>

<p>linearize spectra and return modified object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
linearize( x )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearize_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code><a href="#topic+quantity">quantity</a>(x)</code> is not <code>'absorbance'</code>
then <code>x</code> is returned unchanged.
</p>
<p>If the <code><a href="#topic+quantity">quantity</a>(x)</code> is <code>'absorbance'</code>
then absorbance is converted to transmittance using
</p>
<p style="text-align: center;"><code class="reqn"> transmittance = 10^{-absorbance} </code>
</p>

<p>Surprisingly, there does not seem to be a similar logarithmic version of reflectance.
Plots with log(responsivity) is somewhat common, but does not seem to have a separate name.
I have not seen log(radiometric power).
</p>


<h3>Value</h3>

<p><code>linearize</code> returns a <b>colorSpec</b> object with linear quantities.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>
</p>

<hr>
<h2 id='lms1971'>Cone Fundamentals - 2-degree (1971)</h2><span id='topic+lms1971.5nm'></span><span id='topic+lms1971'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>lms1971.5nm</code> </td><td style="text-align: left;"> the Vos &amp; Walraven (1971) 2° cone fundamentals from 380 to 780 nm, at 5nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Format</h3>

<p>A <b>colorSpec</b> object organized as a matrix with 3 columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>long</code>   </td><td style="text-align: left;"> the long wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>medium</code> </td><td style="text-align: left;"> the medium wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>short</code>  </td><td style="text-align: left;"> the short wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p><a href="http://www.cvrl.org/database/text/cones/vw.htm">http://www.cvrl.org/database/text/cones/vw.htm</a>
</p>


<h3>References</h3>

<p>Vos, J. J. &amp; Walraven, P. L.
On the derivation of the foveal receptor primaries. 
<b>Vision Research</b>.
11 (1971) pp. 799-818.
</p>


<h3>See Also</h3>

<p><a href="#topic+lms2000">lms2000</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(lms1971.5nm)
white.point = product( D65.1nm, lms1971.5nm, wave='auto' )
</code></pre>

<hr>
<h2 id='lms2000'>Cone Fundamentals - 2-degree (2000)</h2><span id='topic+lms2000.1nm'></span><span id='topic+lms2000'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>lms2000.1nm</code> </td><td style="text-align: left;"> the Stockman and Sharpe (2000) 2° cone fundamentals from 390 to 830 nm, at 1nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Format</h3>

<p>A <b>colorSpec</b> object organized as a matrix with 3 columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>long</code>   </td><td style="text-align: left;"> the long wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>medium</code> </td><td style="text-align: left;"> the medium wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>short</code>  </td><td style="text-align: left;"> the short wavelength responsivity </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p><a href="http://www.cvrl.org/cones.htm">http://www.cvrl.org/cones.htm</a>
</p>


<h3>References</h3>

<p>Stockman, A., Sharpe, L. T., &amp; Fach, C. C. (1999). 
The spectral sensitivity of the human short-wavelength cones. 
<b>Vision Research</b>.
39, 2901-2927.
</p>
<p>Stockman, A., &amp; Sharpe, L. T. (2000). 
Spectral sensitivities of the middle- and long-wavelength sensitive cones 
derived from measurements in observers of known genotype. 
<b>Vision Research</b>.
40, 1711-1737.
</p>


<h3>See Also</h3>

<p><a href="#topic+lms1971">lms1971</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(lms2000.1nm)
white.point = product( D65.1nm, lms2000.1nm, wave='auto' )
</code></pre>

<hr>
<h2 id='logging'>Logging in colorSpec package</h2><span id='topic+logging'></span>

<h3>Description</h3>

<p>There is some flexibility in the <b>colorSpec</b> logging level and format.
Logging output goes to <code>stderr()</code>, just like the message stream;
but see <code><a href="base.html#topic+sink">sink</a>()</code> (and the pitfalls of using it).<br />
</p>


<h3>Logging Options</h3>


<dl>
<dt><code>colorSpec.loglevel</code></dt><dd><p>The levels are:
<code>"FATAL", "ERROR", "WARN", "INFO", "DEBUG",</code> and <code>"TRACE"</code> - the usual ones from <b>Log4j</b>.
The initial level is <code>"WARN"</code>.
A <code>"FATAL"</code> event usually means an internal package error.
When setting <code>colorSpec.loglevel</code> an initial letter is sufficient.</p>
</dd>
<dt><code>colorSpec.logformat</code></dt><dd><p>The format is given by a string with standard <b>Log4j</b> <em>conversion specifications</em>:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>%t</code>  </td><td style="text-align: left;">    the date/time of the logging event. </td><td style="text-align: left;"> <code>%t</code> can be followed by standard <code>strftime</code> specs in braces; see example.</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>%l</code>  </td><td style="text-align: left;">    the level of the logging event      </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>%n</code>  </td><td style="text-align: left;">    namespace where event occurred      </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>%f</code>  </td><td style="text-align: left;">    function where event occurred       </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>%m</code>  </td><td style="text-align: left;">    the message itself                  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

</dd>
<dt><code>colorSpec.stoponerror</code></dt><dd><p>If the this option is <code>TRUE</code> (the default),
a log event with level <code>"ERROR"</code> stops execution;
otherwise, execution keeps going.
For interactive use, <code>TRUE</code> is probably better.
For long batch jobs, <code>FALSE</code> might be appropriate,
since then a single error may not force a complete repeat.<br />
A <code>"FATAL"</code> event always stops execution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Wikipedia.
<b>Log4j</b>.
<a href="https://en.wikipedia.org/wiki/Log4j">https://en.wikipedia.org/wiki/Log4j</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>, 
<code><a href="#topic+cs.options">cs.options</a></code>, 
<code><a href="base.html#topic+sink">sink</a></code>, 
<code><a href="base.html#topic+stderr">stderr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options( colorSpec.logformat="%t{%H:%M:%OS3} %l %n::%f(). %m", colorSpec.stoponerror=TRUE )

# or equivalently
cs.options( logformat="%t{%H:%M:%OS3} %l %n::%f(). %m", stop=TRUE )
</code></pre>

<hr>
<h2 id='luminsivity'>Luminous Efficiency Functions (photopic and scotopic)</h2><span id='topic+luminsivity.1nm'></span><span id='topic+luminsivity'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>luminsivity.1nm</code> </td><td style="text-align: left;">    Four luminous efficiency functions, from 360 to 830 nm, at 1nm step
</td>
</tr>

</table>



<h3>Format</h3>

<p>A <b>colorSpec</b> object, with quantity <code>'energy-&gt;neural'</code>, and with 4 spectra:
</p>

<dl>
<dt><code>photopic1924</code></dt><dd><p>The luminous efficiency function adopted by the CIE in 1924,
and defining the <em>standard photopic observer</em>.
It is only to be used when light levels are high enough
that the sensitivity of the eye is mediated by cones, and not rods.
It is the same as the <em>y-bar</em> function in <code>xyz1931.1nm</code>.
It is used to define the <em>candela</em> in the <em>International System</em> (SI)
and is the only one of these functions to appear in the SI.
It was downloaded from
<a href="http://www.cvrl.org/database/data/lum/vl1924e_1.csv">http://www.cvrl.org/database/data/lum/vl1924e_1.csv</a>
where it is defined from 360 to 830 nm.
</p>
</dd>
<dt><code>scotopic1951</code></dt><dd><p>The luminous efficiency function adopted by the CIE in 1951,
and defining the <em>standard scotopic observer</em>.
It is only to be used when light levels are low enough to exclude the activation of cones.
It has no effective role in colorimetry.
It was downloaded from
<a href="http://www.cvrl.org/database/data/lum/scvle_1.csv">http://www.cvrl.org/database/data/lum/scvle_1.csv</a>
where it is defined from 380 to 780 nm.
It has been padded with 0s to 360 to 830 nm.
</p>
</dd>
<dt><code>photopic1978</code></dt><dd><p>The luminous efficiency function for photopic vision,
with adjustments in the blue region by Judd (1951) and Vos (1978).
It was published by the CIE in 1988.
It was downloaded from
<a href="http://www.cvrl.org/database/data/lum/vme_1.csv">http://www.cvrl.org/database/data/lum/vme_1.csv</a>
where it is defined from 380 to 780 nm.
It has been padded with 0s to 360 to 830 nm.
</p>
</dd>
<dt><code>photopic2008</code></dt><dd><p>The CIE (2008) <em>physiologically-relevant</em> luminous efficiency function for photopic vision,
by Stockman, Jagle, Pirzer, &amp; Sharpe.
It was downloaded from
<a href="http://www.cvrl.org/database/data/lum/linCIE2008v2e_1.csv">http://www.cvrl.org/database/data/lum/linCIE2008v2e_1.csv</a>
where it is defined from 390 to 830 nm.
It has been padded with 0s to 360 to 830 nm.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>Luminsivity is a self-coined <em>portmanteau word</em>:
<code>luminsivity</code> = <code>luminous</code> * <code>responsivity</code>.
The word is unrelated to <em>emissivity</em>.
The term <em>luminous responsivity</em> is not common, but appears on page 15 of <em>Grum</em>.
The term <em>luminous efficiency function</em> is standard, but too long.
The term <em>luminosity function</em> is common, but <em>luminosity</em> is ambiguous and also appears in astronomy and scattering theory.<br />
The object <code>luminsivity.1nm</code> is used by the function <code><a href="#topic+photometric">photometric</a>()</code>.
</p>


<h3>Source</h3>

<p>Colour &amp; Vision Research Laboratory.
Institute of Opthalmology.
University College London. UK.
<a href="http://www.cvrl.org/">http://www.cvrl.org/</a>
</p>


<h3>References</h3>

<p>Grum, Franc and Richard J. Becherer.
<b>Radiometry</b>.
Optical Radiation Measurements, Volume 1.
Academic Press.
1979.
</p>
<p>Stockman, A., Jagle, H., Pirzer, M., &amp; Sharpe, L. T. (2008).
The dependence of luminous efficiency on chromatic adaptation.
Journal of Vision, 8, 16:1, 1-26.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyz1931.1nm">xyz1931.1nm</a></code>,
<code><a href="#topic+photometric">photometric</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(luminsivity.1nm)
product( D65.1nm, luminsivity.1nm, wave='auto' )
</code></pre>

<hr>
<h2 id='materialSpectra'>compute standard material spectra</h2><span id='topic+materialSpectra'></span><span id='topic+neutralMaterial'></span><span id='topic+rectangularMaterial'></span><span id='topic+lensAbsorbance'></span>

<h3>Description</h3>

<p>Compute neutral gray material constant reflectance/transmittance,
and rectangular spectra.
Also compute absorbance of the human lens, as a function of age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neutralMaterial( gray=1, wavelength=380:780 )
rectangularMaterial( lambda, alpha=1, wavelength=380:780 )

lensAbsorbance( age=32, wavelength=400:700 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="materialSpectra_+3A_gray">gray</code></td>
<td>
<p>a numeric N-vector of gray levels, in the interval [0,1].  
<code>gray=1</code> represents the <em>Perfect Reflecting Diffuser</em>. </p>
</td></tr>
<tr><td><code id="materialSpectra_+3A_lambda">lambda</code></td>
<td>
<p>a numeric Nx2 matrix with wavelength pairs in the rows,
or a vector that can be converted to such a matrix, by row.
The two wavelengths are the two <em>transition wavelengths</em> of the returned spectrum,
see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="materialSpectra_+3A_alpha">alpha</code></td>
<td>
<p>a numeric N-vector of <em>chromatic amplitudes</em> in the interval [-1,1].
N must be equal to <code>nrow(lambda)</code>.
<code>alpha</code> can also be a single number, 
which is then replicated to length <code>nrow(lambda)</code>.
The <em>chromatic amplitude</em> is defined by <cite>Logvinenko</cite>
and controls the size of both transitions, see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="materialSpectra_+3A_age">age</code></td>
<td>
<p>a numeric N-vector of ages in years; all ages must be <code class="reqn">\ge</code> 20. </p>
</td></tr>    
<tr><td><code id="materialSpectra_+3A_wavelength">wavelength</code></td>
<td>
<p>a vector of wavelengths for the returned object</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>A <em>rectangular spectrum</em>, or <em>rectangular metamer</em>, is easiest to define
when <code class="reqn">\alpha=1</code> and <code class="reqn">\lambda_1 &lt; \lambda_2</code>.
In this case it is a band-pass filter with transmittance=1 for 
<code class="reqn">\lambda \in [\lambda_1 , \lambda_2]</code> and transmittance=0 otherwise.
To create a long-pass filter, just set <code class="reqn">\lambda_2</code> to <code>Inf</code>,
or any large wavelength outside the spectrum range;
and similarly for a short-pass filter.<br />
When <code class="reqn">0&lt;\alpha&lt;1</code> the spectrum is a weighted mixture of this band-pass filter
with a perfect neutral gray filter with transmittance=0.5 at all <code class="reqn">\lambda</code>,
using <code class="reqn">\alpha</code> and <code class="reqn">1-\alpha</code> as the two weights.
The minimum transmittance is <code class="reqn">(1-\alpha)/2</code> and the maximum is <code class="reqn">(1+\alpha)/2</code>,
and their difference, the <em>chromatic amplitude</em>, is <code class="reqn">\alpha</code>.
It is still a band-pass filter.<br />
If <code class="reqn">\alpha=0</code> the spectrum is a perfect neutral with transmittance=0.5.
<br />
To &quot;flip&quot; the spectrum to its complement (change band-pass to band-stop, etc.), 
change <code class="reqn">\alpha</code> to a negative number, or swap <code class="reqn">\lambda_1</code> and <code class="reqn">\lambda_2</code>.
If <code class="reqn">\lambda_1==\lambda_2</code> then the spectrum is undefined and a warning is issued
(unless <code class="reqn">\alpha=0</code>).
</p>


<h3>Value</h3>

<p><code>neutralMaterial()</code> returns a
<b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'reflectance'</code>.
The reflectance of each spectrum is constant and taken from <code>gray</code>.
There are N spectra in the object - one for each gray level.
</p>
<p><code>rectangularMaterial()</code> returns a
<b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'transmitance'</code>.
The transmitance of each spectrum is a step function with 0, 1 or 2 transitions (jumps)
defined by the corresponding row in <code>lambda</code>.
If <code>rownames(lambda)</code> is not <code>NULL</code>, they are copied to <code>specnames</code>
of the output.
Otherwise the <code>specnames</code> are computed from the shape of the spectrum
using these acronyms:
LP (long-pass), SP (short-pass), BP (band-pass), BS (band-stop),
and N (neutral, in case <code>alpha==0</code>).
</p>
<p><code>lensAbsorbance()</code> returns a
<b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'absorbance'</code>.
The absorbance model for the human lens is taken from <cite>Pokorny</cite>.
There are N spectra in the object - one for each age (N=<code>length(age)</code>).
</p>


<h3>Logvinenko</h3>

<p>It is clear that there are 3 degrees-of-freedom in the
spectra returned by <code>rectangularMaterial()</code>.
<em>Logvinenko</em> shows that these spectra in fact form a 3D ball,
which he calls the <em>rectangle color atlas</em>.
He also shows that if a material responder satisfies  the 2-transition condition,
then these spectra uniquely generate <em>all</em> 
colors in the corresponding object color solid.
For more on this, see the vignette <a href="../doc/inversion.pdf"><b>Estimating a Spectrum from its Response</b></a>.
</p>


<h3>Ostwald</h3>

<p>Every spectrum returned by <code>rectangularMaterial()</code> is an Ostwald ideal spectrum.
In Ostwald's terminology, 
the <em>color content</em> = <em>chromatic amplitude</em> = <code class="reqn">\alpha</code>.
And the <em>black content</em> = <em>white content</em> = <code class="reqn">(1-\alpha)/2</code>.
Note that the sum of these 3 contents is 1.
However, Ostwald allows <em>black content</em> and <em>white content</em> to be unequal,
as long as the sum of the 3 contents is 1, and all are non-negative.
Thus there is one extra degree-of-freedom for Ostwald's ideal spectra,
for a total of 4 degrees-of-freedom.
If an additional argument (or arguments) were added to <code>rectangularMaterial()</code>,
then it could return all Ostwald ideal spectra.
</p>


<h3>References</h3>

<p>Foss, Carl E.  and Dorothy Nickerson and Walter C. Granville.
Analysis of the Ostwald Color System.
<em>J. Opt. Soc. Am.</em>.
vol. 34.
no. 7.
pp. 361-381.
July, 1944.
</p>
<p>Logvinenko, A. D.
An object-color space. 
<b>Journal of Vision</b>.
9(11):5, 1-23, (2009).<br />
<code>https://jov.arvojournals.org/article.aspx?articleid=2203976</code>.
doi:10.1167/9.11.5.
</p>
<p>Pokorny, Joel, Vivianne C. Smith, and Margaret Lutze.
Aging of the Human Lens.
<b>Applied Optics</b>.
Vol. 26, No. 8.
15 April 1987.
Table I.  Page 1439.
</p>


<h3>See Also</h3>

<p><a href="#topic+lightSpectra">lightSpectra</a>,
<code><a href="#topic+quantity">quantity</a>()</code>,
<code><a href="#topic+specnames">specnames</a>()</code>,
<code><a href="#topic+computeADL">computeADL</a>()</code>,
vignette <a href="../doc/inversion.pdf"><b>Estimating a Spectrum from its Response</b></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   make a perfect reflecting diffuser (PRD)
prd = neutralMaterial( 1 )

#   make a perfect transmitting filter (PTF)
ptf = prd
quantity(ptf) = 'transmittance'

#   make a band-stop filter (for interval [500,550])
#   with 1% transmittance in the band, and 99% outside the band
bs = rectangularMaterial( c(500,550), -0.98, 400:700 )
bs = rectangularMaterial( c(550,500),  0.98, 400:700 )  # equivalent to previous line

#   compare transmittance at 3 ages: 20, 32, and 80 years
plot( linearize(lensAbsorbance( c(20,32,80) )), col='black', lty=1:3 )
</code></pre>

<hr>
<h2 id='mean'>calculate mean of multiple spectra</h2><span id='topic+mean.colorSpec'></span><span id='topic+mean'></span>

<h3>Description</h3>

<p>compute mean of all spectra in a <b>colorSpec</b> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
mean( x, ... )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_+3A_x">x</code></td>
<td>
<p>a colorSpec object</p>
</td></tr>
<tr><td><code id="mean_+3A_...">...</code></td>
<td>
<p>further arguments ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function might be useful when capturing many spectra on a spectrometer
and averaging them to reduce noise.
</p>


<h3>Value</h3>

<p>a <b>colorSpec</b> object with single spectrum = average of all spectra in <b>colorSpec</b>.
</p>

<hr>
<h2 id='metadata'>metadata of a colorSpec object</h2><span id='topic+metadata'></span><span id='topic+metadata+3C-'></span><span id='topic+metadata.colorSpec'></span><span id='topic+metadata+3C-.colorSpec'></span>

<h3>Description</h3>

<p>Retrieve or set the metadata of a <b>colorSpec</b> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
metadata(x, ...)

## S3 replacement method for class 'colorSpec'
metadata(x, add=FALSE ) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metadata_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="metadata_+3A_...">...</code></td>
<td>
<p>optional names of metadata to return</p>
</td></tr>
<tr><td><code id="metadata_+3A_value">value</code></td>
<td>
<p>a named <code>list</code>.  
If <code>add</code> is <code>FALSE</code>, <code>value</code> replaces any existing <code>metadata</code>.   
If <code>add</code> is <code>TRUE</code>,  <code>value</code> is appended to the existing list of metadata.
If a name already exists, its value is updated using <code><a href="utils.html#topic+modifyList">modifyList</a>()</code>.
Unnamed items in  <code>value</code> are ignored.</p>
</td></tr>
<tr><td><code id="metadata_+3A_add">add</code></td>
<td>
<p>if <code>add=FALSE</code>, any existing metadata is discarded.
If <code>add=TRUE</code> then existing metadata is preserved, using <code>modifyList()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The metadata list is stored as <code>attr(x,'metadata')</code>.
After construction this list is empty.
</p>


<h3>Value</h3>

<p><code>metadata(x)</code> with no additional arguments returns the complete named list of metadata.
If arguments are present, then only those <code>metadata</code> items are returned.
</p>


<h3>Note</h3>

<p>Do not confuse <code>extradata</code> and <code>metadata</code>.<br />
<code>metadata</code> is unstructured data that is attached to the entire <b>colorSpec</b> object.
<code>extradata</code> is structured data, with a row of data for each spectrum in the object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extradata">extradata</a></code>,
<code><a href="utils.html#topic+modifyList">modifyList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# get list of *all* metadata
metadata(x)

# get just the file 'path'
metadata( x, 'path' )

# set the 'date'
metadata( x ) = list( date="2016-04-01" )

## End(Not run)
</code></pre>

<hr>
<h2 id='multiply'>multiply a colorSpec object by scalar, vector, or matrix</h2><span id='topic+multiply'></span><span id='topic+normalize'></span><span id='topic+multiply.colorSpec'></span><span id='topic+normalize.colorSpec'></span>

<h3>Description</h3>

<p>multiply spectra by coefficients and return modified object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
multiply( x, s )

## S3 method for class 'colorSpec'
normalize( x, norm='L1' )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiply_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with M spectra</p>
</td></tr>
<tr><td><code id="multiply_+3A_s">s</code></td>
<td>
<p>a scalar, an M-vector, or an MxP matrix. 
In the case of a matrix, assigning <code>colnames(s)</code> is recommended;
see <b>Details</b>.</p>
</td></tr>  
<tr><td><code id="multiply_+3A_norm">norm</code></td>
<td>
<p>one of <code>'L1'</code>, <code>'L2'</code>, or <code>'Linf'</code>, specifying one of the standard vector norms <code class="reqn">L^1, L^2, or L^{inf}</code>. <br />
<code>norm</code> can also be a numeric wavelength (e.g. 560 nm), and then the spectrum is scaled to have value 1 at this wavelength.  Of course, this is not a true vector norm. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>multiply()</code>:<br />
If <code>s</code> is an  MxP  matrix, say <b>S</b>, and one thinks of the spectra as
organized in an  NxM  matrix <b>X</b>, 
then the new spectra are defined by the matrix <b>XS</b>, which is  NxP.
If the P column names of <code>s</code> are set, then they are copied to the 
<code>specnames</code> of the output.
Otherwise, default spectrum names are assigned as in   
<code><a href="#topic+colorSpec">colorSpec</a>()</code>, with a warning. <br />
If <code>s</code> is an M-vector, then <b>S</b>=<code>diag(s)</code> is computed and used in the previous sentence.
This has the effect of multiplying spectrum i by <code>s</code>[i].<br />
If <code>s</code> is a scalar then every spectrum is multiplied by <code>s</code>.<br />
The multiplication may produce negative entries, but no check is made for this.<br />  
WARNING: An M-vector and an Mx1 matrix may yield quite different results.
</p>
<p>For <code>normalize()</code>:<br />
<code>normalize()</code> calls <code>multiply()</code> with <code>s</code> = an M-vector.
If the norm of a spectrum is 0, then it is left unchanged.   
</p>


<h3>Value</h3>

<p><code>multiply</code> returns a <b>colorSpec</b> object with the matrix of spectra
of <code>x</code> multiplied by <code>s</code>.
</p>
<p><code>normalize</code> returns a <b>colorSpec</b> object with each spectrum
of <code>x</code> scaled to have given norm equal to 1.
</p>
<p>In both functions, the <code><a href="#topic+quantity">quantity</a></code> and <code><a href="#topic+wavelength">wavelength</a></code> are preserved.  
</p>


<h3>Note</h3>

<p>If <code>x</code> is organized as a matrix, and <code>s</code> is a scalar,
the one can use the simpler and equivalent <code>s*x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+product">product</a>()</code>,
<code><a href="#topic+quantity">quantity</a>()</code>,
<code><a href="#topic+wavelength">wavelength</a>()</code>,
<code><a href="#topic+specnames">specnames</a>()</code>,  
<code><a href="#topic+colorSpec">colorSpec</a>()</code>
</p>

<hr>
<h2 id='officialXYZ'>Query the Official XYZ values for Standard Illuminants</h2><span id='topic+officialXYZ'></span>

<h3>Description</h3>

<p>In careful calcuations with standard illuminants,
it is often helpful to have the 'official' values of XYZ,
i.e. with the right number of decimal places.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>officialXYZ( name )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="officialXYZ_+3A_name">name</code></td>
<td>
<p>a subvector of
<code>c('A','B','C','D50','D50.ICC','D55','D65','D75',</code>
<code>'E','F2','F7','F11')</code>, which are the names of some standard illuminants</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All XYZ values are taken from the ASTM publication in <b>References</b>,
except <code>B</code> which is taken from <cite>Wyszecki &amp; Stiles</cite>
and <code>D50.ICC</code> which is taken from ICC publications.
The latter is different than that of ASTM.
</p>


<h3>Value</h3>

<p>An Mx3 matrix where M is the length of <code>name</code>.  
Each row filled with the official XYZ, but if the illuminant name is not recognized the row is all <code>NA</code>s.
The matrix <code>rownames</code> are set to <code>name</code>, and <code>colnames</code> to <code>c('X','Y','Z')</code>.
</p>


<h3>WARNING</h3>

<p>This function is deprecated.
New software should use <code>spacesRGB::standardXYZ()</code> instead.
</p>


<h3>Note</h3>

<p>The input names are case-sensitive.
The output XYZ is normalized so that <code>Y=1</code>.
</p>


<h3>References</h3>

<p>ASTM E 308 - 01.
Standard Practice for Computing the Colors of Objects by Using the CIE System.
(2001).
</p>
<p>Günther Wyszecki and W. S. Stiles.
Color Science: Concepts and Methods, Quantitative Data and Formulae, Second Edition.
John Wiley &amp; Sons, 1982.
Table I(3.3.8) p. 769.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ABC">ABC</a></code>, 
<code><a href="#topic+D50">D50</a></code>,  
<code><a href="#topic+D65">D65</a></code>,
<code><a href="#topic+Fluorescents">Fluorescents</a></code>,
<code><a href="#topic+illuminantE">illuminantE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>officialXYZ( c('A','D50','D50.ICC','D65') ) 
#                 X Y         Z
# A       1.0985000 1 0.3558500
# D50     0.9642200 1 0.8252100
# D50.ICC 0.9642029 1 0.8249054
# D65     0.9504700 1 1.0888300
</code></pre>

<hr>
<h2 id='organization'>organization of a colorSpec object</h2><span id='topic+organization'></span><span id='topic+organization+3C-'></span><span id='topic+organization.colorSpec'></span><span id='topic+organization+3C-.colorSpec'></span>

<h3>Description</h3>

<p>Retrieve or set the organization of a <b>colorSpec</b> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
organization(x)

## S3 replacement method for class 'colorSpec'
organization(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="organization_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="organization_+3A_value">value</code></td>
<td>
<p>a valid organization: <code>'vector'</code>, <code>'matrix'</code>, <code>'df.col'</code>, or <code>'df.row'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>organization(x)</code> is <code>"vector"</code>, then <code>x</code> is a vector
representing a single spectrum.  Compare this with <code>stats::<a href="stats.html#topic+ts">ts</a>()</code>.
</p>
<p>If <code>organization(x)</code> is <code>"matrix"</code>, then <code>x</code> is a matrix
and the spectra are stored in the columns.
</p>
<p>If <code>organization(x)</code> is <code>"df.col"</code>, then <code>x</code> is a <code>data.frame</code>
with M+1 columns, where M is the number of spectra.
The wavelengths are stored in column 1, and the spectra in columns 2:(M+1).
This organization is good for printing to the console, and writing to files.
</p>
<p>If the <code>organization</code> of <code>x</code> is <code>"df.row"</code>, then <code>x</code> is a <code>data.frame</code>
with N rows, where N is the number of spectra.
The spectra are stored in the last column, which is a matrix with the name <code>"spectra"</code>.
The other columns preceding <code>spectra</code> (if present) contain extra data associated with
the spectra; see <code><a href="#topic+extradata">extradata</a></code>.
</p>


<h3>Value</h3>

<p><code>organization(x)</code> returns a valid organization:
<code>'vector'</code>, <code>'matrix'</code>, <code>'df.col'</code>, or <code>'df.row'</code>.
</p>


<h3>Note</h3>

<p>In <code>organization(x) &lt;- value</code><br />
if <code>x</code> has more than 1 spectrum,
then <code>value</code> equal to <code>'vector'</code> is invalid and ignored.<br />
If <code>organization(x)</code> is equal to <code>'df.row'</code> and also has <code><a href="#topic+extradata">extradata</a></code>,
then changing the <code>organization</code> silently discards the <code>extradata</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorSpec">colorSpec</a></code>; <code><a href="#topic+extradata">extradata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>organization(Hoya)              # returns 'df.row'
organization(Hoya) = 'matrix'   # extradata in Hoya is silently discarded
</code></pre>

<hr>
<h2 id='photometric'>convert illuminant spectra to photometric units</h2><span id='topic+photometric'></span><span id='topic+photometric.colorSpec'></span>

<h3>Description</h3>

<p>Convert radiometric units of power or energy to photometric units, 
using 4 standard photometric weighting curves.  
Actinometric units (number of photons) are converted to
radiometric units (energy of photons) on-the-fly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
photometric( x, photopic=683, scotopic=1700, multiplier=1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="photometric_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code> equal to <code>'light'</code>, and with M spectra</p>
</td></tr>
<tr><td><code id="photometric_+3A_photopic">photopic</code></td>
<td>
<p>the conversion factor for photopic vision, in lumen/watt.  
The CIE standard is 683, and another common value is 683.002.</p>
</td></tr>
<tr><td><code id="photometric_+3A_scotopic">scotopic</code></td>
<td>
<p>the conversion factor for scotopic vision, in lumen/watt.  
The CIE standard is 1700, and another common value is 1700.06.</p>
</td></tr>
<tr><td><code id="photometric_+3A_multiplier">multiplier</code></td>
<td>
<p>an conversion factor intended for conversion of units,
and applied to both photopic and scotopic vision.
For example if the input unit of <code>x</code> is <code class="reqn">watt*sr^{-1}</code>,
and the desired output unit is <code class="reqn">candlepower</code>, then set
<code>multiplier=1/0.981</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the product of <code>x</code> with <code>luminsivity.1nm</code>.
This product is an Mx4 matrix, where M is the number of spectra in <code>x</code>.
There are 3 columns for photopic vision, and 1 column for scotopic vision.
These columns are multiplied by the appropriate conversion factors
and the resulting Mx4 matrix is returned.
</p>
<p>The 5 power-based input quantities and corresponding photometric outputs are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>radiant power</b> [<code class="reqn">watt</code>] </td><td style="text-align: left;">  ---&gt;  </td><td style="text-align: left;">  <b>luminous flux</b> [<code class="reqn">lumen</code>] </td>
</tr>
<tr>
 <td style="text-align: left;">
<b>irradiance</b>  [<code class="reqn">watt*m^{-2}</code>] </td><td style="text-align: left;">  ---&gt;  </td><td style="text-align: left;">  <b>illuminance</b> [<code class="reqn">lumen*m^{-2} = lux</code>] </td>
</tr>
<tr>
 <td style="text-align: left;">
<b>radiant exitance</b>  [<code class="reqn">watt*m^{-2}</code>] </td><td style="text-align: left;">  ---&gt;  </td><td style="text-align: left;">  <b>luminous exitance</b> [<code class="reqn">lumen*m^{-2} = lux</code>] </td>
</tr>
<tr>
 <td style="text-align: left;">
<b>radiant intensity</b>  [<code class="reqn">watt*sr^{-1}</code>] </td><td style="text-align: left;">  ---&gt;  </td><td style="text-align: left;">  <b>luminous intensity</b> [<code class="reqn">lumen*sr^{-1} = candela</code>] </td>
</tr>
<tr>
 <td style="text-align: left;">
<b>radiance</b>  [<code class="reqn">watt*sr^-1*m^{-2}</code>] </td><td style="text-align: left;">  ---&gt;  </td><td style="text-align: left;">  <b>luminance</b> [<code class="reqn">candela*m^{-2} =  nit</code>] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The 2 <em>common</em> energy-based input quantities and corresponding photometric outputs are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>radiant energy</b> [<code class="reqn">joule</code>] </td><td style="text-align: left;">  ---&gt;  </td><td style="text-align: left;">  <b>luminous energy</b> [<code class="reqn">talbot = lumen-second</code>] </td>
</tr>
<tr>
 <td style="text-align: left;">
<b>radiant exposure</b>  [<code class="reqn">joule*m^{-2}</code>] </td><td style="text-align: left;">  ---&gt;  </td><td style="text-align: left;">  <b>luminous exposure</b> [<code class="reqn">talbot*m^{-2} = lux-second</code>] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>and there are 3 more obtained by integrating over time.
For example &quot;time-integrated radiance&quot; &mdash;&gt;  &quot;time integrated luminance&quot;.
But I have not been able to find names for these 3.
The <em>talbot</em> is the unofficial name for a lumen-second.
</p>


<h3>Value</h3>

<p><code>photometric()</code> returns an Mx4 matrix, where M is the number of spectra in <code>x</code>.
The <code>rownames</code> are <code>specnames(x)</code>,
and the <code>colnames</code> are <code>specnames(luminsivity.1nm)</code>.<br />
In case of ERROR it returns <code>NULL</code>.<br />
</p>


<h3>Note</h3>

<p>To get the right output quantity and units, 
the user must know the input quantity and units.
If the units are different than those in the above list,
then set <code>multiplier</code> appropriately.<br />
It is up to the user to determine whether
<em>photopic</em> or <em>scotopic</em> vision (or neither) is appropriate.
The intermediate <em>mesopic</em> vision is currently a subject of research by the CIE,
and might be added to this function in the future.
</p>


<h3>References</h3>

<p>Poynton, Charles.
<b>Digital Video and HD - Algorithms and Interfaces</b>.
Morgan Kaufmann.
Second Edition. 2012.
Appendix B, pp. 573-580.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>,
<code><a href="#topic+type">type</a></code>,
<code><a href="#topic+luminsivity.1nm">luminsivity.1nm</a></code>,
<code><a href="#topic+radiometric">radiometric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>photometric( solar.irradiance )  # unit is watt*m^{-2}

#             photopic1924 scotopic1951 photopic1978 photopic2008  # units are lux
# AirMass.0      133100.41     313883.2    133843.65     140740.3
# GlobalTilt     109494.88     250051.5    110030.31     115650.0
# AirMass.1.5     97142.25     215837.1     97571.57     102513.7
</code></pre>

<hr>
<h2 id='plot'>plot spectra</h2><span id='topic+plot.colorSpec'></span>

<h3>Description</h3>

<p>plot the spectra in a <b>colorSpec</b> object as lines or points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
plot( x, color=NULL, subset=NULL, main=TRUE, legend=TRUE, CCT=FALSE, add=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>a colorSpec object</p>
</td></tr>
<tr><td><code id="plot_+3A_color">color</code></td>
<td>

<p>If <code>color=NULL</code> then colors are computed from the spectra themselves.
If <code>type(x)</code> is <code>'material'</code> the color is computed using
illuminant <code>D65.1nm</code> and responder <code>BT.709.RGB</code> with no further normalization.
Otherwise the spectrum color is faked by changing its <code>quantity</code> to <code>'energy'</code>
and taking the <code><a href="#topic+product">product</a></code> with <code>BT.709.RGB</code>.
The resulting RGBs are normalized to have a maximum of 1.
This RGB normalization is done <em>before</em> processing the <code>subset</code> argument.<br />
If <code>color='auto'</code> then a suitable set of colors is generated using
<code><a href="grDevices.html#topic+colorRamp">colorRamp</a>()</code>.<br />
Otherwise <code>color</code> is passed on to <code><a href="graphics.html#topic+lines.default">lines.default</a>()</code>
as the <code>col</code> argument,  e.g. <code>col='black'</code>.
</p>
</td></tr>
<tr><td><code id="plot_+3A_subset">subset</code></td>
<td>
<p>specifies a subset of <code>x</code> to plot;
see <code><a href="#topic+subset">subset</a>()</code> for acceptable arguments.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>If <code>main=TRUE</code> then a main title is generated from the file <code>'path'</code> in
the <code>metadata</code> list, or from <code>deparse(substitute(x))</code>.
If <code>main=FALSE</code> then no main title is displayed.
And if <code>main</code> is a string then that string is used as the main title.
</p>
</td></tr>
<tr><td><code id="plot_+3A_legend">legend</code></td>
<td>
<p>If <code>legend=TRUE</code> then a pretty legend using <code><a href="#topic+specnames">specnames</a>(x)</code>
is placed in the <code>'topright'</code> corner of the plot.  
If <code>legend</code> is a string it is interpreted as naming a corner of the 
plot and passed as such to the function <code><a href="graphics.html#topic+legend">legend</a></code>.
If <code>legend=FALSE</code> then no legend is drawn.
</p>
</td></tr>
<tr><td><code id="plot_+3A_cct">CCT</code></td>
<td>

<p>If <code>CCT=TRUE</code> and the <code>type</code> of <code>x</code> is <code>'light'</code> then
the CCT of each spectrum is added to the legend; see <code><a href="#topic+computeCCT">computeCCT</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot_+3A_add">add</code></td>
<td>

<p>If <code>add=TRUE</code> then the lines are added to an existing plot,
and these arguments are ignored:
<code>main</code>, <code>ylab</code>, <code>xlim</code>, <code>ylim</code>,
and <code>log</code>; see <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>other graphical parameters, see <b>Details</b></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Commonly used graphical parameters are:
</p>

<dl>
<dt><code>type</code></dt><dd><p>passed to <code><a href="graphics.html#topic+lines.default">lines.default</a>()</code>, 
with default <code>type='l'</code>.
Other valid values are <code>'p'</code> (points), <code>'b'</code>, <code>'c'</code>, <code>'o'</code>, 
<code>'h'</code>, <code>'S'</code>, <code>'s'</code>, and <code>'n'</code>,
see <code><a href="graphics.html#topic+plot">plot</a>()</code> for their meanings.
<br />
An additional <code>type='step'</code> is available.
This option draws each spectrum as a <em>step function</em>,
similar to <code>'S'</code> and <code>'s'</code>,
except that the jumps are <em>between</em> the wavelengths
(with appropriate extensions at min and max wavelengths).
The function <code><a href="graphics.html#topic+segments">segments</a>()</code> is used for the drawing.
For <code>type='step'</code>, <code>lwd</code> and <code>lty</code> should be vectors of length 1 or 2.
If the length of <code>lwd</code> is 1, then horizontal segments are draw with that width,
but vertical segments are not drawn.
If the length of <code>lwd</code> is 2, 
then vertical segments are draw with width <code>lwd[2]</code>.
If the length of <code>lty</code> is 2, then the styles are applied to the
horizontal and vertical segments in that order.
If the length of <code>lty</code> is 1, then that style is applied to both
horizontal and vertical segments.
For examples of this plotting option, see the vignette 
<a href="../doc/convexity.pdf"><b>Convexity and Transitions</b></a>.</p>
</dd>
<dt><code>lwd, lty</code></dt><dd><p>passed to <code><a href="graphics.html#topic+lines.default">lines.default</a>()</code>,
except when <code>type='step'</code> when they are passed to <code><a href="graphics.html#topic+segments">segments</a>()</code>.
In the former case these can be vectors, and components are passed
sequentially to each spectrum, similar to <code><a href="graphics.html#topic+matplot">matplot</a>()</code>.
In the latter case, see the description in <code>type</code>.
The default value for both is 1.</p>
</dd>
<dt><code>pch</code></dt><dd><p>passed to <code><a href="graphics.html#topic+lines.default">lines.default</a>()</code>,
but it only has meaning when <code>type='p'</code>, <code>'b'</code>, or <code>'o'</code>.
This can be a vector, and components are passed sequentially to each spectrum.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>If <code>ylab</code> is a string 
then it is passed on to <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>,
otherwise suitable default string is generated.</p>
</dd>
<dt><code>xlim, ylim</code></dt><dd><p>If <code>xlim</code> and <code>ylim</code> are 2-vectors, they are passed
to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>. 
If one of the components is <code>NA</code> then a suitable default is supplied.</p>
</dd>
<dt><code>log</code></dt><dd><p>passed on to <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>. 
Care must be taken for <code>y</code> because
many spectra are 0 at some wavelengths, and even negative. Use <code>ylim</code> in such cases.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeCCT">computeCCT</a>()</code>,
<code><a href="#topic+subset">subset</a>()</code>,
<code><a href="graphics.html#topic+lines">lines</a>()</code>,
<code><a href="graphics.html#topic+segments">segments</a>()</code>,
<code><a href="graphics.html#topic+plot">plot</a>()</code>,
<code><a href="graphics.html#topic+matplot">matplot</a>()</code>,
<code><a href="grDevices.html#topic+colorRamp">colorRamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot( 100 * BT.709.RGB )
plot( xyz1931.1nm, add=TRUE, lty=2, legend=FALSE )
</code></pre>

<hr>
<h2 id='plotOptimals'>Plot Optimal Colors</h2><span id='topic+plotOptimals3D'></span><span id='topic+plotOptimals3D.colorSpec'></span><span id='topic+plotOptimals2D'></span><span id='topic+plotOptimals2D.colorSpec'></span>

<h3>Description</h3>

<p>Consider a <b>colorSpec</b> object <code>x</code> with <code>type</code> 
equal to <code>'responsivity.material'</code> and 3 responsivity spectra.
The function <code>plotOptimals3D()</code> 
makes a plot of the <em>object-color solid</em> for <code>x</code>.
This solid is a <em>zonohedron</em> in 3D.
The 3D drawing package <span class="pkg">rgl</span> is required.
<br />
Consider a <b>colorSpec</b> object <code>x</code> with <code>type</code> 
equal to <code>'responsivity.material'</code> and 2 responsivity spectra.
The function <code>plotOptimals2D()</code> 
makes a plot of the <em>object-color solid</em> for <code>x</code>.
This solid is a <em>zonogon</em> in 2D.
The 3D drawing package <span class="pkg">rgl</span> is <em>not</em> required.
<br />
The set of all possible material reflectance functions (or transmittance functions) 
is convex, closed, and bounded (in any reasonable function space),
and this implies that the set of all possible output responses 
from <code>x</code> is also convex, closed, and bounded.
The latter set is called the <em>object-color solid</em>,
or <em>Rösch Farbkörper</em>, for <code>x</code>.
A color on the boundary of the <em>object-color solid</em> is called an <em>optimal color</em>.
For more discussion see <code><a href="#topic+sectionOptimalColors">sectionOptimalColors</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
plotOptimals3D( x, size=50, type='w', both=TRUE )

## S3 method for class 'colorSpec'
plotOptimals2D( x )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotOptimals_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code> equal to
<code>'responsivity.material'</code> and 2 or 3 spectra, as appropriate.
</p>
</td></tr>
<tr><td><code id="plotOptimals_+3A_size">size</code></td>
<td>
<p>an integer giving the number of wavelengths at which to resample <code>x</code>.
To skip resampling, set <code>size=NA</code>.
</p>
</td></tr>
<tr><td><code id="plotOptimals_+3A_type">type</code></td>
<td>
<p><code>type='w'</code> for a wireframe plot of the parallelogram faces.
<code>type='p'</code> for a point plot with points at the centers of the parallelograms.
</p>
</td></tr>
<tr><td><code id="plotOptimals_+3A_both">both</code></td>
<td>
<p>the color solid is symmetric about its center, so only half of it must
be computed.
If <code>both=TRUE</code> it plots one half in black and the other half in red.
If <code>both=FALSE</code> it only plots one half in black.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions return <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Details for 3D</h3>

<p>If <code>n</code> is the number of wavelengths,
the number of parallelogram faces of the zonohedron is <code>n*(n-1)</code>.
The time to compute these faces increase with <code>n</code> even faster,
so that is why the default <code>size=50</code> is a fairly small number.
It was chosen to be a reasonable compromise between detail and performance.
<br />
In addition to the wireframe or points,
it draws the box with opposite vertices at the &quot;poles&quot; <b>0</b> and <b>W</b>
and the diagonal segment of neutral grays that connects <b>0</b> and <b>W</b>.
</p>


<h3>Details for 2D</h3>

<p>If <code>n</code> is the number of wavelengths,
the number of edges in the zonogon is <code>2*n</code>.
Computing these edges is fast and visualization is easy,
so there are no plotting options at this time.
</p>


<h3>Note</h3>

<p>If all responsivity functions of <code>x</code> are non-negative,
the <em>object-color solid</em> of <code>x</code> is inside the box.
If the responsivity functions of <code>x</code> have negative lobes,
the <em>object-color solid</em> of <code>x</code> extends outside the box.
Indeed, the box may actually be <em>inside</em> the optimals.
</p>


<h3>References</h3>

<p>Centore, Paul.
<em>A Zonohedral Approach to Optimal Colours</em>.
<b>Color Research &amp; Application</b>.
Vol. 38.
No. 2.
pp. 110-119.
April 2013.
</p>
<p>Logvinenko, A. D.
An object-color space. 
Journal of Vision.
9(11):5, 1-23, (2009).<br />
<code>https://jov.arvojournals.org/article.aspx?articleid=2203976</code>.
doi:10.1167/9.11.5.
</p>
<p>West, G. and M. H. Brill.
Conditions under which Schrödinger object colors are optimal.
<b>Journal of the Optical Society of America</b>.
73. pp. 1223-1225. 1983.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type">type</a>()</code>,
<code><a href="#topic+probeOptimalColors">probeOptimalColors</a>()</code>,
<code><a href="#topic+sectionOptimalColors">sectionOptimalColors</a>()</code>,  
vignette <a href="../doc/optimals.pdf"><b>Plotting Chromaticity Loci of Optimal Colors</b></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
human = product( D50.5nm, 'slot', xyz1931.5nm, wave=seq(400,770,by=5) )
plotOptimals3D( human )

plotOptimals2D( subset(human,2:3) )     # y and z only

scanner = product( D50.5nm, 'slot', BT.709.RGB, wave=seq(400,770,by=5) )
plotOptimals3D( scanner )
</code></pre>

<hr>
<h2 id='print'>Convert colorSpec object to readable text</h2><span id='topic+summary.colorSpec'></span><span id='topic+print.colorSpec'></span>

<h3>Description</h3>

<p>display a <b>colorSpec</b> object as readable text.
Output goes to <code>stdout()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
print( x, ...)

## S3 method for class 'colorSpec'
summary( object, long=TRUE, ... )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>a colorSpec object</p>
</td></tr>
<tr><td><code id="print_+3A_object">object</code></td>
<td>
<p>a colorSpec object</p>
</td></tr>
<tr><td><code id="print_+3A_long">long</code></td>
<td>
<p>logical indicating whether to print <code>metadata</code>, <code>calibrate</code>,
<code>sequence</code>, and <code>emulate</code> data</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>further arguments ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>long=FALSE</code>,
<code>summary()</code> prints a summary of the wavelength vector, and names of all spectra.
For each spectrum it prints the range of values, <code>LambdaMax</code>, and
<code>extradata</code> if any.
If <code>long=TRUE</code> it also prints data listed above (if any).<br />
The function <code>print()</code> simply calls <code>summary()</code> with <code>long=FALSE</code>.
</p>


<h3>Value</h3>

<p>Both functions return (invisibly) the character vector that was just printed
to <code>stdout()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extradata">extradata</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="base.html#topic+stdout">stdout</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print( xyz1931.1nm )

xyz1931.1nm     # same thing, just calls print()
</code></pre>

<hr>
<h2 id='probeOptimalColors'>compute optimal colors by ray tracing</h2><span id='topic+probeOptimalColors'></span><span id='topic+probeOptimalColors.colorSpec'></span>

<h3>Description</h3>

<p>Consider a <b>colorSpec</b> object <code>x</code> with <code>type</code> 
equal to <code>'responsivity.material'</code>.
The set of all possible material reflectance functions (or transmittance functions) 
is convex, closed, and bounded (in any reasonable function space),
and this implies that the set of all possible output responses 
from <code>x</code> is also convex, closed, and bounded.
The latter set is called the <em>object-color solid</em> or <em>Rösch Farbkörper</em> for <code>x</code>.
A color on the boundary of the <em>object-color solid</em> is called an <em>optimal color</em>.
The special points <b>W</b> (the response to the perfect reflecting diffuser)
and <b>0</b> are on the boundary of this set.
The interior of the line segment of neutrals joining <b>0</b> to <b>W</b> is in the interior of the
<em>object-color solid</em>.
It is natural to parameterize this segment from 0 to 1 (from <b>0</b> to <b>W</b>).
</p>
<p>A ray <code class="reqn">r</code> that is based at a point on the interior of the neutral line segment
must intersect the boundary of the <em>object-color solid</em> in a unique optimal color.
The purpose of the function <code>probeOptimalColors()</code> is to compute that intersection point.
</p>
<p>Currently the function only works if the number of spectra in 
<code>x</code> is 3 (e.g. RGB or XYZ).
</p>
<p>Before <span class="pkg">colorSpec</span> v 0.8-1 this function used a 2D root-finding
method that could only find
optimal colors whose spectra contain 0, 1, or 2 transitions.
But starting with v0.8-1, we have switched to zonohedral representation
of the object-color solid, which makes it possible to discover more than 2 transitions.
The inspiration for this change is the article by <cite>Centore</cite>.
To <em>inspect</em> these computed spectra, the argument <code>spectral</code> must be set
to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
probeOptimalColors( x, gray, direction, aux=FALSE, spectral=FALSE, tol=1.e-6 )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probeOptimalColors_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code>
equal to <code>'responsivity.material'</code> and 3 spectra</p>
</td></tr>
<tr><td><code id="probeOptimalColors_+3A_gray">gray</code></td>
<td>
<p>vector of numbers in the open interval (0,1) that define neutral grays on the
line segment from black to white; this neutral gray point is the basepoint of a probe ray</p>
</td></tr>
<tr><td><code id="probeOptimalColors_+3A_direction">direction</code></td>
<td>
<p>a numeric Nx3 matrix with directions of the probe rays in the rows,
or a numeric vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="probeOptimalColors_+3A_aux">aux</code></td>
<td>
<p>a logical that specifies whether to return extra performance and diagnostic data; see <b>Details</b></p>
</td></tr>
<tr><td><code id="probeOptimalColors_+3A_spectral">spectral</code></td>
<td>
<p>if <code>TRUE</code>, the function returns a <b>colorSpec</b> object
with the optimal spectra, see <b>Value</b>.
</p>
</td></tr>
<tr><td><code id="probeOptimalColors_+3A_tol">tol</code></td>
<td>
<p>error tolerance for the intersection of probe and object-color boundary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each gray level and each direction defines a ray.
So the total number of rays traced is <code>length(gray)</code> * <code>nrow(direction)</code>.
The 3 responsivities are regarded not as continuous functions, 
but as step functions.
This implies that the color solid is a zonohedron.
In the preprocessing phase the zonohedral representation is calculated.
The faces of the zonohedron are either parallelograms,
or <em>compound faces</em> that can be partitioned into parallelograms.
The centers of all these parallelograms are computed, along with their normals
and plane constants.
<br />
This representation of the color solid is very strict regarding the
2-transition assumption.
During use, one can count on there being some spectra with more than two transitions.
Forcing the best 2-transition spectrum is a possible topic for the future.
</p>


<h3>Value</h3>

<p>If argument <code>spectral=FALSE</code>,
<code>probeOptimalColors()</code> returns a <code>data.frame</code> with a row for each traced ray.
There are <code>length(gray)</code> * <code>nrow(direction)</code> rays.
The columns in the output are:
</p>
<table>
<tr><td><code>gray</code></td>
<td>
<p>the graylevel defining the <code class="reqn">basepoint</code> of the ray. 
<code class="reqn">basepoint = gray*W</code> 
</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>the <code class="reqn">direction</code> of the ray</p>
</td></tr> 
<tr><td><code>s</code></td>
<td>
<p>computed scalar so that <code class="reqn">basepoint + s*direction</code> is optimal</p>
</td></tr>
<tr><td><code>optimal</code></td>
<td>

<p>the optimal color on the boundary; <code class="reqn">optimal = basepoint + s*direction</code> 
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>lambda.1 and lambda.2 at the 2 transitions, in nm. 
lambda.1 &lt; lambda.2 =&gt; bandpass,
and lambda.1 &gt; lambda.2 =&gt; bandstop.
It will happen that the optimal spectrum has more than 2 transitions;
in this case both lambdas are set to <code>NA</code>.
</p>
</td></tr>
<tr><td><code>dol</code></td>
<td>

<p><code>delta</code> and <code>omega</code> - the Logvinenko parameters <code class="reqn">(\delta,\omega)</code> for optimal colors, plus <code>lambda</code> (<code class="reqn">\lambda</code>) in nm. 
<code class="reqn">\omega</code> is the reparameterization of <code class="reqn">\lambda</code> ;  see <cite>Logvinenko</cite>.
If there are more than 2 transistions, these are set to <code>NA</code>.
</p>
</td></tr>
</table>
<p>If aux is <code>TRUE</code>, these auxiliary columns related to performance and diagnostics are added:   
</p>
<table>
<tr><td><code>timetrace</code></td>
<td>
<p>time to trace the ray, in seconds</p>
</td></tr>
<tr><td><code>parallelograms</code></td>
<td>

<p># of parallelograms in the (possibly compound) face. 1 means just a single parallelogram.
</p>
</td></tr>
<tr><td><code>tested</code></td>
<td>

<p># of parallelograms actually tested for ray intersection. This only has meaning for compound faces.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the 2 coordinates of the intersection point inside the parallelogram</p>
</td></tr>
</table>
<p>If argument <code>spectral=TRUE</code>,
<code>probeOptimalColors()</code> returns a <b>colorSpec</b> object with quantity 
<code>'reflectance'</code>.
This object contains the optimal spectra, and can be used to inspect the spectra
with more than 2 transitions, which will happen.
The above-mentioned <code>data.frame</code> can then be obtained by applying
<code><a href="#topic+extradata">extradata</a>()</code> to the returned object.
</p>
<p>If an individual ray could not be traced (which should be rare), 
the row contains <code>NA</code> in appropriate columns.<br />
In case of global error, the function returns <code>NULL</code>.
</p>


<h3>WARNING</h3>

<p>The preprocessing calculation of the zonohedron dominates the total time.
And this time goes up rapidly with the number of wavelengths.
We recommend using a wavelength step of 5nm, as in the <b>Examples</b>.
For best results, batch a lot of rays into a single function call
and then process the output.
<br />
Moreover, the preprocessing time is dominated by the partitioning
of the compound faces into parallelograms.
This is made worse by spectral responses with little overlap,
as in <code><a href="#topic+scanner.ACES">scanner.ACES</a></code>.
In these cases, try a larger step size, and then reduce.
Optimizing these compound faces is a possible topic for the future.
</p>


<h3>References</h3>

<p>Centore, Paul.
<em>A zonohedral approach to optimal colours</em>.
<b>Color Research &amp; Application</b>.
Vol. 38.
No. 2.
pp. 110-119.
April 2013.
</p>
<p>Logvinenko, A. D.
An object-color space. 
<b>Journal of Vision</b>.
9(11):5, 1-23, (2009).<br />
<code>https://jov.arvojournals.org/article.aspx?articleid=2203976</code>.
doi:10.1167/9.11.5.
</p>
<p>Schrödinger, E. (1920). 
Theorie der Pigmente von grösster Leuchtkraft. 
<b>Annalen der Physik</b>.
62, 603-622.
</p>
<p>West, G. and M. H. Brill.
Conditions under which Schrödinger object colors are optimal.
<b>Journal of the Optical Society of America</b>.
73. pp. 1223-1225. 1983.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type">type</a></code>,
vignette <a href="../doc/optimals.pdf"><b>Plotting Chromaticity Loci of Optimal Colors</b></a>,
<code><a href="#topic+scanner.ACES">scanner.ACES</a></code>,
<code><a href="#topic+extradata">extradata</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave    = seq(400,700,by=5)
D50.eye = product( D50.5nm, 'material', xyz1931.1nm, wavelength=wave )
probeOptimalColors( D50.eye, c(0.2,0.5,0.9), c(1,2,1, -1,-2,-1) )

##    gray direction.1 direction.2 direction.3         s  optimal.1  optimal.2
##  1  0.2           1           2           1 32.306207  52.533143  85.612065
##  2  0.2          -1          -2          -1  8.608798  11.618138   3.782055
##  3  0.5           1           2           1 20.993144  71.560483  94.485416
##  4  0.5          -1          -2          -1 20.993144  29.574196  10.512842
##  5  0.9           1           2           1  4.333700  95.354911 103.165832
##  6  0.9          -1          -2          -1 35.621938  55.399273  23.254556

##     optimal.3 lambda.1 lambda.2    dol.delta    dol.omega   dol.lambda
##  1  49.616046 451.8013 598.9589   0.63409966   0.48287469 536.97618091
##  2   8.701041 636.3031 429.4659   0.08458527   0.99624955 674.30015903
##  3  64.267740 441.9105 615.0822   0.78101041   0.49048222 538.73234859
##  4  22.281453 615.0822 441.9105   0.21898959   0.99048222 662.20606601
##  5  82.227974 422.9191 648.7404   0.95800430   0.49825407 540.49590064
##  6  42.272337 593.2415 455.2425   0.42035428   0.97962398 650.57382749


# create a 0-1 spectrum with 2 transitions
rectspec = rectangularMaterial( lambda=c(579.8697,613.7544), alpha=1, wave=wave )

# compute the corresponding color XYZ
XYZ = product( rectspec, D50.eye )
XYZ
##                             X        Y          Z
##  BP_[579.87,613.754] 33.42026 21.96895 0.02979764

# trace a ray from middle gray through XYZ
white.XYZ   = product( neutralMaterial(1,wave=wave), D50.eye )
direction   = XYZ - white.XYZ/2

res = probeOptimalColors( D50.eye, 0.5, direction, aux=FALSE )
res$s         
##  1.00004   the ray has gone past the original color to the boundary

res$optimal
##              X        Y          Z
##  [1,] 33.41958 21.96774 0.02808178

res$lambda    
##  NA NA     because there are more than 2 transitions in the true optimal

# since s=1.00004 &gt; 1,
# XYZ is actually in the interior of the color solid, and not on the boundary.
# The boundary is a little-bit further along the ray,
# and the corresponding spectrum has more than 2 transitions.
</code></pre>

<hr>
<h2 id='product'>Compute the product of colorSpec objects</h2><span id='topic+product'></span><span id='topic+product.colorSpec'></span>

<h3>Description</h3>

<p>Take a sequence of <b>colorSpec</b> objects and compute their product.
Only certain types of sequences are allowed.
The return value can be a new <b>colorSpec</b> object or a matrix;
see <b>Details</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
product( ... )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="product_+3A_...">...</code></td>
<td>
<p>unnamed arguments are <b>colorSpec</b> objects,
and possibly a single character string, see <b>Details</b>.
Possible named arguments are:
</p>

<dl>
<dt><code>wavelength</code></dt><dd><p>The default <code>wavelength='identical'</code> means that all the <b>colorSpec</b> objects must have the same wavelength sequence; if they do not it is an ERROR. <code>wavelength</code> can be a new wavelength sequence, and all the objects are then
<code><a href="#topic+resample">resample</a></code>d at these new wavelengths. <code>wavelength</code> can also be <code>'auto'</code> or <code>NULL</code> which means to compute a suitable wavelength sequence from those of the objects, see <b>Details</b>. It is OK to abbreviate the string <code>wavelength</code>
(e.g. to <code>wave</code>); see <b>Examples</b>.
It is OK for the wavelength sequence to be irregular;
when the return value is a matrix
the integration weights the spectrum values appropriately.<br />
</p>
</dd>
<dt> <code>method</code>, <code>span</code>, <code>extrapolation</code>, <code>clamp</code> </dt><dd><p>passed to <code>resample()</code> with no checking or changes<br />
</p>
</dd>
<dt> <code>integration</code></dt><dd><p>only applies when the return type is matrix.
The default option is <code>'rectangular'</code>, which means to weight the spectrum
value equally at all wavelengths; this is the ASTM E308-01 recommendation.
The other option is <code>'trapezoidal'</code>, which means to give the 2 endpoint
wavelength values 1/2 the weight of the others.
Trapezoidal integration is provided mostly for compatibility with other software.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>To explain the allowable product sequences
it is helpful to introduce some simple notation for the objects:
</p>

<table>
<tr>
 <td style="text-align: left;">
 <b>notation</b> </td><td style="text-align: left;"> <b>colorSpec</b> <code>type</code> </td><td style="text-align: left;"> <b>description of the object</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code class="reqn">L</code> </td><td style="text-align: left;"> <code>light</code> </td><td style="text-align: left;"> a light source </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code class="reqn">M</code> </td><td style="text-align: left;"> <code>material</code> </td><td style="text-align: left;"> a material </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code class="reqn">R_L</code> </td><td style="text-align: left;"> <code>responsivity.light</code> </td><td style="text-align: left;"> a light responder (aka detector)</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code class="reqn">R_M</code> </td><td style="text-align: left;"> <code>responsivity.material</code> </td><td style="text-align: left;"> a material responder (e.g. a scanner)</td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>

<p>It is also helpful to define a sequence of positive integers
to be <em>conformable</em> iff it has at most one value greater than 1.
For example,
a sequence of all 1s is conformable.  A sequence of all <code class="reqn">q</code>'s is conformable.
The sequences <code>c(1,3)</code> and <code>c(1,1,4,1,1,4,1)</code> are conformable,
but <code>c(1,1,4,1,3,4,1)</code> is not.
</p>
<p>There are 6 types of sequences for which the product is defined:
<br />
</p>
<p>1. &nbsp;&nbsp; <code class="reqn"> M_1 * M_2 * ... * M_m </code>  &#x21a6; <code class="reqn">M'</code> <br />
The product of <code class="reqn">m</code> materials is another material.
Think of a stack of <code class="reqn">m</code> transmitting filters effectively forming a new filter.
If we think of each object as a matrix (with the spectra in the columns),
then the product is element-by-element using <span class="rlang"><b>R</b></span>'s <code>*</code> - the Hadamard product.
The numbers of spectra in the terms must be conformable.
If some objects have 1 spectrum and all the others have <code class="reqn">q</code>,
then the column-vector spectrums are repeated <code class="reqn">q</code> times to form a
matrix with <code class="reqn">q</code> columns.
If the numbers of spectra are not conformable,
it is an ERROR and the function returns <code>NULL</code>.
<br />
As an example, suppose <code class="reqn">M_1</code> has 1 spectrum and <code class="reqn">M_2</code> has <code class="reqn">q</code> spectra,
and <code class="reqn">m=2</code>.
Then the product is a material with <code class="reqn">q</code> spectra.
Think of an IR-blocking filter followed by the RGB filters in a 3-CCD camera.
<br /> <br />
</p>
<p>2. &nbsp;&nbsp;  <code class="reqn"> L * M_1 * M_2 * ... * M_m </code>  &#x21a6; <code class="reqn">L'</code> <br />
The product of a light source followed by <code class="reqn">m</code> materials is a light source.
Think of a light source
followed by a stack of <code class="reqn">m</code> transmitting filters, effectively forming a new light source.
The numbers of spectra in the terms must be conformable as in sequence 1,
and the matrices are multiplied element by element.<br />
As an example, suppose <code class="reqn">L</code> has 1 spectrum and <code class="reqn">M_1</code> has <code class="reqn">q</code> spectra,
and <code class="reqn">m=1</code>.
Then the product is a light source with <code class="reqn">q</code> spectra.
Think of a light source followed by a filter wheel with <code class="reqn">q</code> filters.
<br /> <br />
</p>
<p>3. &nbsp;&nbsp;  <code class="reqn"> M_1 * M_2 * ... * M_m * R_L </code>  &#x21a6; <code class="reqn">R_L'</code> <br />
The product of <code class="reqn">m</code> materials followed by a light responder, is a light responder.
Think of a stack of <code class="reqn">m</code> transmitting filters in front of a camera, effectively forming a new camera.
The numbers of spectra in the terms must be conformable as in sequence 1,
and the matrices are multiplied element by element.<br />
As an example, suppose <code class="reqn">R_L</code> has 1 spectrum and <code class="reqn">M_1</code> has <code class="reqn">q</code> spectra,
and <code class="reqn">m=1</code>.
Then the product is a light responder with <code class="reqn">q</code> spectra.
Think of a 3-CCD camera in which all 3 CCDs have exactly the same responsivity
and so can be modeled with a single object <code class="reqn">R_L</code>.
<br /> <br />
</p>
<p>4. &nbsp;&nbsp; <code class="reqn">L * M_1 * ... *</code> &bull; <code class="reqn">* ... * M_m * R_L </code>  &#x21a6; <code class="reqn">R_M'</code> <br />
This is the strangest product.
The bullet symbol &bull; means that a variable material is inserted at that slot
in the sequence (or light path).
For each material spectrum inserted there is a response from <code class="reqn">R_L</code>.
Therefore the product of this sequence is a material responder <code class="reqn">R_M</code>.
Think of a light source <code class="reqn">L</code> going through
a transparent object  &bull;  on a flatbed scanner and into a camera <code class="reqn">R_L</code>.
For more about the mathematics of this product,
see the <b>colorSpec-guide.pdf</b> in the doc directory.
These material responder spectra are the same as the
<em>effective spectral responsivities</em> in <cite>Digital Color Management</cite>.
The numbers of spectra in the terms must be conformable as in sequence 1,
and the product is a material responder with <code class="reqn">q</code> spectra.
<br />
In the function <code>product()</code> the location of the &bull; is marked
by any character string whatsoever - it's up to the user who might choose
something that describes the typical material (between the light source and camera).
For example one might choose:<br />
<code>scanner = product( A.1nm, 'photo', Flea2.RGB, wave='auto') </code><br />
to model a scanner that is most commonly used to scan photographs.
Other possible strings could be <code>'artwork'</code>, <code>'crystal'</code>, <code>'varmaterial'</code>,
or even <code>'slot'</code>.
See the vignette <a href="../doc/gallery.pdf"><b>Viewing Object Colors in a Gallery</b></a> for a worked-out example.
<br /> <br />
</p>
<p>5. &nbsp;&nbsp;  <code class="reqn"> L * M_1 * M_2 * ... * M_m * R_L </code>  &#x21a6; <code class="reqn">matrix</code> <br />
The product of a light source, followed by <code class="reqn">m</code> materials,
followed by a light responder, is a matrix!
The numbers of spectra in the terms must splittable into
a conformable left part (<code class="reqn">L'</code> from sequence 2.)
and a conformable right part (<code class="reqn">R_L'</code> from sequence 3.).
There is a row for each spectrum in <code class="reqn">L'</code>,
and a column for each spectrum in <code class="reqn">R_L'</code>.
Suppose the element-by-element product of the left part is
<code class="reqn">n</code>&times;<code class="reqn">p</code>
and the element-by-element product of the right part is
and <code class="reqn">n</code>&times;<code class="reqn">q</code>,
where <code class="reqn">n</code> is the number of wavelengths.
Then the output matrix is the usual matrix product <code>%*%</code>
of the transpose of the left part times and right part,
which is <code class="reqn">p</code>&times;<code class="reqn">q</code>.
<br />
As an example, think of a light source followed by a
reflective color target with 24 patches
followed by an RGB camera.
The sequence of spectra counts is <code>c(1,24,3)</code>
which is splittable into <code>c(1,24)</code> and <code>c(3)</code>.
The product matrix is 24&times;3.
See the vignette <a href="../doc/gallery.pdf"><b>Viewing Object Colors in a Gallery</b></a> for a worked-out example.<br />
Note that is OK for there to be no materials in this product;
it is OK if <code class="reqn">m=0</code>.
See the vignette <a href="../doc/blueflame.pdf"><b>Blue Flame and Green Comet</b></a>
for a worked-out example.
<br /> <br />
</p>
<p>6. &nbsp;&nbsp;  <code class="reqn"> M_1 * M_2 * ... * M_m * R_M </code> &#x21a6; <code class="reqn">matrix</code> <br />
The product of <code class="reqn">m</code> materials followed by a material responder, is a matrix !
The sequence of numbers of spectra must be splittable into left and right
parts as in sequence 4, and the product matrix is formed the same way.
One reason for computing this matrix in 2 steps is that one can
<code><a href="#topic+calibrate">calibrate</a></code> the material responder separately in a customizable way.
See the vignette <a href="../doc/gallery.pdf"><b>Viewing Object Colors in a Gallery</b></a>
for a worked-out example with a flatbed scanner.
<br /> <br />
</p>
<p>Note that sequences 5. and 6. are the only ones that
use the usual matrix product <code>%*%</code>.
They may also use the Hadamard matrix product <code>*</code>, as in sequences 1 to 4.
</p>
<p>The argument <code>wavelength</code> can also be <code>'auto'</code> or <code>NULL</code>.
In this case the intersection of all the wavelength ranges of the objects is computed.
If the intersection is empty, it is an ERROR and the function returns <code>NULL</code>.
The wavelength step <code><a href="#topic+step.wl">step.wl</a></code>
is taken to be the smallest over all the object wavelength sequences.
If the minimum <code><a href="#topic+step.wl">step.wl</a></code> is less than 1 nanometer,
it is rounded off to the nearest power of 2 (e.g 1, 0.5, 0.25, ...).
</p>


<h3>Value</h3>

<p><code>product()</code> returns either a <b>colorSpec</b> object or a matrix, see <b>Details</b>.
</p>
<p>If <code>product()</code> returns a <b>colorSpec</b> object, the <code><a href="#topic+organization">organization</a></code>
of the object is <code>'matrix'</code> or <code>'vector'</code>;
any <code><a href="#topic+extradata">extradata</a></code> is lost.
However, all terms in the product are saved in <code>attr(*,'sequence')</code>.
One can use <code><a href="utils.html#topic+str">str</a>()</code> to inspect this attribute.
</p>
<p>If <code>product()</code> returns a matrix,
this matrix can sometimes be ambiguous, see <b>Note</b>.
</p>
<p>All actinometric terms are converted to radiometric on-the-fly and the returned
<b>colorSpec</b> object is also radiometric.
</p>
<p>In case of ERROR it returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The product for sequences 1, 2, and 3 is associative.
After all matrices are filled out to have  <code class="reqn">q</code> columns,
the result is essentially a Hadamard product of matrices,
which is associative.
Also note that a subsequence of sequences 2 and 3 might be sequence 1.
</p>
<p>The product for sequence 4 is never associative,
since subproducts that contain the variable &bull; are undefined.
However the  result is essentially a Hadamard product of matrices, and is unambiguous.
</p>
<p>The product for sequence 5 is associative in special cases, but not in general.
The problem is that the left and right splitting point is not unique.
If all objects have only a single spectrum, then it *is* associative,
and therefore unambiguous.
If the left part has a different number of multiple spectra than the right part,
then it is not associative in general since some ways of grouping the
product may be undefined.<br />
Moreover, in some cases the product can be ambiguous.
Suppose that the vector of spectrum counts is <code>c(1,3,1)</code>;
this could come from a single light source, followed by 3 filters (e.g. RGB),
followed by a graylevel camera.
There are 2 ways to split this: <code>"1|3,1"</code> and <code>"1,3|1"</code>.
The first split is interpreted as the light source into a camera with 3 channels.
The second split is interpreted as 3 colored light sources into a graylevel camera.
In the first split the returned matrix is a <code>1x3</code> row vector.
In the second split the returned matrix is a <code>3x1</code> column vector.
For the vector <code>"1,3,1"</code>, one can show that
the computed components in the 2 vectors are equal,
so the ambiguity is benign.
But consider the longer sequence  <code>"1,3,3,1"</code>.
There are 3 ways to split this, and the returned matrices are
<code>1x3</code>, <code>3x3</code>, and <code>3x1</code>.
So this ambiguity is obviously a problem.
Whenever there is an ambiguity, the function chooses a splitting
in which the left part is as long as possible, and issues a warning message.
The user should inspect the result carefully.
To avoid the ambiguity, the user should break the product into smaller pieces
and call <code>product()</code> multiple times.
</p>
<p>The product for sequence 6 is essentially the same as sequence 5,
and the function issues a warning message when appropriate.
Note that a subproduct is defined only if it avoids the final multiplication with <code class="reqn">R_M</code>.
</p>


<h3>References</h3>

<p>Edward J. Giorgianni and Thomas E. Madden.
<b>Digital Color Management: Encoding Solutions.</b> 2nd Edition
John Wiley. 2009.
Figure 10.11a. page 141.
</p>
<p>Wikipedia.
<b>Hadamard product (matrices)</b>.
<a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">https://en.wikipedia.org/wiki/Hadamard_product_(matrices)</a>
</p>
<p>ASTM E308-01.
Standard Practice for Computing the Colors of Objects by Using the CIE System.
(2001).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wavelength">wavelength</a></code>,
<code><a href="#topic+type">type</a></code>,
<code><a href="#topic+resample">resample</a></code>,
<code><a href="#topic+calibrate">calibrate</a></code>,
<code><a href="#topic+radiometric">radiometric</a></code>,
<code><a href="#topic+step.wl">step.wl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  sequence 1.
path = system.file( "extdata/objects/Midwest-SP700-2014.txt", package='colorSpec' )
blocker.IR = readSpectra( path )
product( blocker.IR, Hoya, wave='auto' )


#  sequence 2.
product( subset(solar.irradiance,1), atmosphere2003, blocker.IR, Hoya, wave='auto' )


#  sequence 3.
plumbicon = readSpectra( system.file( "extdata/cameras/plumbicon30mm.txt", package='colorSpec' ) )
product( blocker.IR, subset(Hoya,1:3), plumbicon, wave='auto' )


#   sequence 4.
#   make an RGB scanner
bluebalancer = subset(Hoya,'LB')
# combine tungsten light source A.1nm with blue light-balance filter
# use the string 'artwork' to mark the variable material slot
scanner = product( A.1nm, bluebalancer, 'artwork', Flea2.RGB, wave='auto' )


#  sequence 5.
product( D65.1nm, Flea2.RGB, wave='auto' )  # a 1x3 matrix, no materials
product( D65.1nm, neutralMaterial(0.01), Flea2.RGB, wave='auto' ) # a 1x3 matrix, 1 material
path = system.file( "extdata/sources/Lumencor-SpectraX.txt", package='colorSpec' )
lumencor = readSpectra( path, wave=340:660 )
product( lumencor, Flea2.RGB, wave='auto' )   # a 7x3 matrix, no materials


#  sequence 6.
scanner = calibrate( scanner )
target = readSpectra( system.file( "extdata/targets/N130501.txt", package='colorSpec') )
product( target, scanner, wave='auto' )  #  a 288x3 matrix

</code></pre>

<hr>
<h2 id='ptransform'>make a linear transformation to a colorSpec responder</h2><span id='topic+ptransform'></span><span id='topic+ptransform.colorSpec'></span>

<h3>Description</h3>

<p>apply a linear transformation to a <b>colorSpec</b> responder with M spectra,
so that multiples of M given <em>primary</em> vectors
are transformed to the standard basis of <code class="reqn">R^M</code>.
And a given <em>white</em> vector is transformed to the M-vector of all 1s.<br />
The returned object is always
<code>multiply(x,A)</code> where  <code>A</code> is an internally calculated MxM matrix.
The name <code>ptransform</code> is short for <em>projective transformation</em>.<br />
In case of ERROR, a message is logged and NULL returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
ptransform( x, primary, white, digits=Inf )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptransform_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> responder with M spectra.  
<code>type(x)</code> must be <code>'responsivity.light'</code> or <code>'responsivity.material'</code>.
</p>
</td></tr>
<tr><td><code id="ptransform_+3A_primary">primary</code></td>
<td>
<p>an MxM matrix whose rows define the M primary vectors
in the response space of <code>x</code>.
It is OK for each row to have a single value that is NA.
In this case the NA value is changed so that the sum of the row is 1.
This is done because typically the rows represent chromaticities
in the response space of <code>x</code>.
After this change, the rows of <code>primary</code> must form a basis of <code class="reqn">R^M</code>.<br />
<code>rownames(primary)</code> must be defined; when M=3 they are typically
<code>c('R','G','B')</code>.
</p>
</td></tr>
<tr><td><code id="ptransform_+3A_white">white</code></td>
<td>
<p>an M-vector in the response space of <code>x</code>,
that is typically the ideal white point of a color display.
When <code>white</code> is expressed in the basis defined by <code>primary</code>,
the coordinates must all be non-zero.<br />
<code>white</code> can also be a <b>colorSpec</b> object with a single spectrum
suitable as stimulus for <code>x</code>;
in this case the vector <code>white</code> is set to
<code> product( white, x, wavelength='auto' )</code>.
</p>
</td></tr>
<tr><td><code id="ptransform_+3A_digits">digits</code></td>
<td>
<p>if a positive integer,
then <code>white</code> is rounded to this number of decimal digits,
but in a non-standard way, see <b>Details</b>.  
This is typically done so the internally calculated MxM matrix <code>A</code> agrees
with that from a color standard, see <b>Examples</b>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formal mathematical requirements for <code>primary</code> and <code>white</code> are:
</p>
 
<ul>
<li><p> The rows of <code>primary</code> must form a basis of <code class="reqn">R^M</code>.
Equivalently, if <code class="reqn">P</code> denotes the matrix <code>primary</code>,
then <code class="reqn">P</code> is invertible.
</p>
</li>
<li><p> The coordinates of <code>white</code> in this basis are all non-zero.
Equivalently, if <code class="reqn">x</code> is the solution of <code class="reqn"> x P = white</code>,
then every component of x is non-zero.
</p>
</li></ul>

<p>Assuming both of these are true, then there is a unique matrix <code class="reqn">A</code> so that
</p>
 
<ul>
<li> <p><code class="reqn">A</code> transforms a multiple of the <code class="reqn">i</code>'th row of <code class="reqn">P</code> to the <code class="reqn">i</code>'th
standard basis vector of <code class="reqn">R^M</code>.
</p>
</li>
<li> <p><code class="reqn">A</code> transforms <code>white</code> to the M-vector of all 1s.
</p>
</li></ul>

<p>This statement is essentially the fundamental theorem of (analytic) projective geometry;
see <em>Bumcrot</em> page 87, and <em>Semple</em> page 398.
The rows of <code class="reqn">P</code> plus <code class="reqn">white</code> define a <em>projective frame</em>;
the former are the <em>fundamental points</em> and the latter is the <em>unit point</em>.
</p>
<p>If <code>digits</code> is a positive integer,
the chromaticity of <code>white</code> is computed by dividing <code>white</code> by <code>sum(white)</code>.
The latter must be non-zero, or else it is an ERROR.
This chromaticity is rounded to <code>digits</code> decimal digits, while preserving the sum of 1.
This <em>rounded chromaticity</em> is non-zero, and defines a line through 0.
The vector <code>white</code> is projected onto this line to get the new and rounded <code>white</code>,
with the rounded chromaticity.
See <b>Examples</b>.
</p>


<h3>Value</h3>

<p>a <b>colorSpec</b> object equal to <code>multiply(x,A)</code> 
where <code>A</code> is an internally calculated MxM matrix.  
The <code><a href="#topic+quantity">quantity</a></code> and <code><a href="#topic+wavelength">wavelength</a></code> are preserved.
The <code>specnames</code> of the returned object are set to <code>tolower( rownames(primary) )</code>.<br />
The user may want to change the <code><a href="#topic+quantity">quantity</a></code> of the returned object;
see <b>Examples</b>.
</p>


<h3>References</h3>

<p>Bumcrot, Robert J.
<b>Modern Projective Geometry</b>.
Holt, Rinehart, and Winston. 1969.
</p>
<p>IEC 61966-2-1:1999.
Multimedia systems and equipment - Colour measurement and management.
Part 2-1: Colour management - Default RGB colour space - sRGB.
<a href="https://webstore.iec.ch/publication/6169">https://webstore.iec.ch/publication/6169</a>
</p>
<p>Semple, J. G. and G. T. Kneebone.
<b>Algebraic Projective Geometry</b>.
Oxford. 1952.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>,
<code><a href="#topic+wavelength">wavelength</a></code>,
<code><a href="#topic+colorSpec">colorSpec</a></code>,
<code><a href="#topic+multiply">multiply</a></code>,
<code><a href="#topic+product">product</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############ Example for sRGB   ###########

# assign the standard sRGB primaries
P = matrix( c(0.64,0.33,NA,  0.3,0.6,NA, 0.15,0.06,NA ), 3, 3, byrow=TRUE )
rownames(P) = c('R','G','B')
P
#   [,1] [,2] [,3]
# R 0.64 0.33   NA
# G 0.30 0.60   NA
# B 0.15 0.06   NA

white = product( D65.1nm, xyz1931.1nm, wave='auto' )
white
#           X        Y        Z
# D65 100.437 105.6708 115.0574

white/sum(white)
#             X         Y         Z
# D65 0.3127269 0.3290232 0.3582499    

# But the sRGB standard D65 is xy=(0.3127,0.3290)
# so when the next line is executed,
# the calculated 3x3 matrix will *NOT* agree with the sRGB standard
y = ptransform( xyz1931.1nm, P, white, digits=Inf )

product( D65.1nm, y, wave='auto' )
#     R G B
# D65 1 1 1      # this is exactly what we want, but the internal 3x3 matrix is a little off

# now repeat, but this time round the white chromaticity to
# xy=(0.3127,0.3290) in order to get the matrix right
y = ptransform( xyz1931.1nm, P, white, digits=4 )

rgb = product( D65.1nm, y, wave='auto' )
rgb
#            R        G        B
# D65 1.000238 1.000053 0.999835   # off in the 4'th digit  (WARN: this is linear RGB)

255 * rgb
#            R        G        B
# D65 255.0607 255.0134 254.9579   # good enough for 8-bit RGB

65535 * rgb
#            R        G        B
# D65 65550.59 65538.44 65524.18   # NOT good enough for 16-bit RGB  

# So for 16-bit RGB, one can get the white RGB right, or the 3x3 matrix right, but not both !


############ Example for ProPhoto RGB   ###########

# assign the standard ProPhoto RGB primaries
P = matrix( c(0.7347,0.2653,NA,  0.1596,0.8404,NA, 0.0366,0.0001,NA ), 3, 3, byrow=TRUE )
rownames(P) = c('R','G','B')
P
#     [,1]   [,2] [,3]
# R 0.7347 0.2653   NA
# G 0.1596 0.8404   NA
# B 0.0366 0.0001   NA

white = product( D50.5nm, xyz1931.5nm, wave='auto' )
white
#            X       Y        Z
# D50 101.2815 105.042 86.67237

white / sum(white)
#             X         Y         Z
# D50 0.3456755 0.3585101 0.2958144  

# but the ProPhoto RGB standard is xy=(0.3457,0.3585);  proceed anyway
y = ptransform( xyz1931.5nm, P, white, digits=Inf )

product( D50.5nm, y, wave='auto' )
#     R G B
# D50 1 1 1     #  this is exactly what we want, but the internal 3x3 matrix is a little off

# the following line is an equivalent way to compute y.
# pass D50.5nm directly as the 'white' argument
y = ptransform( xyz1931.5nm, P, D50.5nm )
</code></pre>

<hr>
<h2 id='quantity'>quantity of a colorSpec object</h2><span id='topic+quantity'></span><span id='topic+quantity+3C-'></span><span id='topic+type'></span><span id='topic+quantity.colorSpec'></span><span id='topic+quantity+3C-.colorSpec'></span><span id='topic+type.colorSpec'></span>

<h3>Description</h3>

<p>Retrieve or set the quantity of a <b>colorSpec</b> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
quantity(x)

## S3 replacement method for class 'colorSpec'
quantity(x) &lt;- value

## S3 method for class 'colorSpec'
type(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantity_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="quantity_+3A_value">value</code></td>
<td>
<p>a valid <code>quantity</code> string; see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 4 valid <code>types</code>, which are further divided into 14 valid quantities.
All of these are strings:
</p>
<p>For <code>type='light'</code><br />
<code>quantity = </code> <code>'energy'</code> (radiometric), or <code>'photons'</code> (actinometric)
</p>
<p>For <code>type='responsivity.light'</code><br />
<code>quantity = </code> <code>'energy-&gt;electrical'</code>, <code>'energy-&gt;neural'</code>, <code>'energy-&gt;action'</code>,<br /> 
<code>'photons-&gt;electrical'</code>, <code>'photons-&gt;neural'</code>, or <code>'photons-&gt;action'</code> <br />
</p>
<p>For <code>type='material'</code><br />
<code>quantity = </code> <code>'reflectance'</code>, <code>'transmittance'</code>, or <code>'absorbance'</code> <br />
</p>
<p>For <code>type='responsivity.material'</code><br />
<code>quantity = </code> <code>'material-&gt;electrical'</code>, <code>'material-&gt;neural'</code>, or <code>'material-&gt;action'</code> <br />
</p>
<p>Also see the <b>colorSpec User Guide</b>.
</p>


<h3>Value</h3>

<p><code>quantity()</code> returns the quantity of <code>x</code>
</p>
<p><code>type()</code> returns the type of <code>x</code>, which depends only on the <code>quantity</code>.
</p>


<h3>Note</h3>

<p>The <b>colorSpec</b> <code>quantity</code> is more general than the physical SI quantity;
for example <code>quantity='energy'</code> really includes 10 distinct SI quantities
and maybe more.
The unit is left arbitrary in most cases.
Exceptions are <code>reflectance</code>, <code>transmittance</code>, and <code>absorbance</code>
which are dimensionless.
</p>
<p>Changing the <code>quantity</code> should only be done if one knows what one is doing.
It does not change the underlying numbers.
For example, changing <code>photons</code> to <code>energy</code> does not do numerical conversion.
For this specific conversion, see <code><a href="#topic+radiometric">radiometric</a>()</code>.
</p>
<p>Similarly, see <code><a href="#topic+linearize">linearize</a>()</code> for conversion
from <code>absorbance</code> to <code>transmittance</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorSpec">colorSpec</a></code>,
<code><a href="#topic+radiometric">radiometric</a></code>,
<code><a href="#topic+linearize">linearize</a></code>
</p>

<hr>
<h2 id='radiometric'>convert a colorSpec object from actinometric to radiometric</h2><span id='topic+radiometric'></span><span id='topic+radiometric.colorSpec'></span><span id='topic+is.radiometric'></span><span id='topic+is.radiometric.colorSpec'></span>

<h3>Description</h3>

<p>Convert a <b>colorSpec</b> object to have quantity that is radiometric (energy of photons) - to prepare it for colorimetric calculations.
Test an object for whether it is radiometric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
radiometric( x, multiplier=1, warn=FALSE )

## S3 method for class 'colorSpec'
is.radiometric( x )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radiometric_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object</p>
</td></tr>
<tr><td><code id="radiometric_+3A_multiplier">multiplier</code></td>
<td>
<p>a scalar which is multiplied by the output, and intended for unit conversion</p>
</td></tr>
<tr><td><code id="radiometric_+3A_warn">warn</code></td>
<td>
<p>if <code>TRUE</code> and a conversion actually takes place, the a <code>WARN</code> message is issued.
This makes the user aware of the conversion, so units can be verified.  This can be useful when <code>radiometric()</code> is called from another <b>colorSpec</b> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code><a href="#topic+quantity">quantity</a></code> of <code>x</code> does not start with <code>'photons'</code>
then the quantity is not actinometric
and so <code>x</code> is returned unchanged.
Otherwise <code>x</code> is actinometric (photon-based).
</p>
<p>If <code><a href="#topic+type">type</a>(x)</code> is <code>'light'</code> then
the most common actinometric unit of photon count is
(<code class="reqn">\mu</code>mole of photons) = (<code class="reqn">6.02214 x 10^{17}</code> photons).
The conversion equation is:
</p>
<p style="text-align: center;"><code class="reqn"> E = Q * 10^{-6} * N_A * h * c / \lambda </code>
</p>

<p>where <code class="reqn">E</code> is the energy of the photons,
<code class="reqn">Q</code> is the photon count,
<code class="reqn">N_A</code> is Avogadro's constant,
<code class="reqn">h</code> is Planck's constant, <code class="reqn">c</code> is the speed of light,
and <code class="reqn">\lambda</code> is the wavelength in meters.
The output energy unit is joule.<br />
If the unit of <code>Q</code> is not (<code class="reqn">\mu</code>mole of photons), 
then the output should be scaled appropriately.
For example, if the unit of photon count is exaphotons,
then set <code>multiplier=1/0.602214</code>.
</p>
<p>If the <code><a href="#topic+quantity">quantity</a>(x)</code> is <code>'photons-&gt;electrical'</code>,
then the most common actinometric unit of responsivity to light is quantum efficiency (QE).
The conversion equation is:
</p>
<p style="text-align: center;"><code class="reqn"> R_e = QE * \lambda * e / (h * c) </code>
</p>

<p>where <code class="reqn">R_e</code> is the energy-based responsivity,
<code class="reqn">QE</code> is the quantum efficiency,
and <code class="reqn">e</code> is the charge of an electron (in C).
The output responsivity unit is coulombs/joule (C/J) or  amps/watt (A/W).<br />
If the unit of <code>x</code> is not quantum efficiency, 
then <code>multiplier</code> should be set appropriately.
</p>
<p>If the <code><a href="#topic+quantity">quantity</a>(x)</code> is 
<code>'photons-&gt;neural'</code> or  <code>'photons-&gt;action'</code>,
the most common actinometric unit of photon count is
(<code class="reqn">\mu</code>mole of photons) = (<code class="reqn">6.02214 x 10^{17}</code> photons).
The conversion equation is:
</p>
<p style="text-align: center;"><code class="reqn"> R_e = R_p * \lambda * 10^6 / ( N_A * h * c) </code>
</p>

<p>where <code class="reqn">R_e</code> is the energy-based responsivity,
<code class="reqn">R_p</code> is the photon-based responsivity.
This essentially the reciprocal of the first conversion equation.
</p>
<p>The argument <code>multiplier</code> is applied to the right side of all the above
conversion equations.
</p>


<h3>Value</h3>

<p><code>radiometric()</code> returns a <b>colorSpec</b> object with
<code><a href="#topic+quantity">quantity</a></code> that is
radiometric (energy-based) and not actinometric (photon-based).
If <code>type(x)</code> is a material type
(<code>'material'</code> or <code>'responsivity.material'</code>)
then <code>x</code> is returned unchanged.
</p>
<p>If <code>quantity(x)</code> starts with <code>'energy'</code>,
then <code>is.radiometric()</code> returns <code>TRUE</code>, and otherwise <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>To log the executed conversion equation,
execute <code>cs.options(loglevel='INFO')</code>.
</p>


<h3>Source</h3>

<p>Wikipedia.
<b>Photon counting</b>.
<a href="https://en.wikipedia.org/wiki/Photon_counting">https://en.wikipedia.org/wiki/Photon_counting</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>, 
<code><a href="#topic+type">type</a></code>, 
<code><a href="#topic+F96T12">F96T12</a></code>,
<code><a href="#topic+cs.options">cs.options</a></code>,
<code><a href="#topic+actinometric">actinometric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum( F96T12 )    # the step size is 1nm, from 300 to 900nm
# [1] 320.1132  photon irradiance, (micromoles of photons)*m^{-2}*sec^{-1}

sum( radiometric(F96T12) )
# [1] 68.91819  irradiance, watts*m^{-2}
</code></pre>

<hr>
<h2 id='readCGATS'>read tables from files in ANSI/CGATS.17 format</h2><span id='topic+readCGATS'></span>

<h3>Description</h3>

<p>The CGATS text format supports a preamble followed by N tables, where N <code class="reqn">\ge</code> 1.
Each table can have a separate header.
A table may or may not contain spectral data, see <b>Note</b>.
The function converts each table to a <code>data.frame</code> with attributes;
see <b>Details</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCGATS( path, collapsesingle=FALSE )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readCGATS_+3A_path">path</code></td>
<td>
<p>the path name of a single file, in CGATS format</p>
</td></tr>
<tr><td><code id="readCGATS_+3A_collapsesingle">collapsesingle</code></td>
<td>
<p>If <code>path</code> has only one table (N=1) and <code>collapsesingle</code> is <code>TRUE</code>,
then return the single <code>data.frame</code> (instead of a list with 1 <code>data.frame</code>).
If <code>path</code> has multiple tables (N <code class="reqn">\ge</code> 2), then <code>collapsesingle</code> is ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned list is given attributes: <code>"path"</code>,  <code>"preamble"</code>, 
and (if present) <code>"date"</code>, <code>"created"</code>, <code>"originator"</code>, and <code>"file_descriptor"</code>.
The attribute values are all character vectors.
The value of attribute <code>"path"</code> is the argument <code>path</code>,
and the other values are extracted from <code>"preamble"</code>.
The length of <code>"preamble"</code> is (typically) greater than 1, and the others have length 1.
Each line of the preamble is a keyword-value pair.
The keyword <code>ORIGINATOR</code> is converted to attribute <code>"originator"</code>.
The keyword <code>FILE_DESCRIPTOR</code> is converted to attribute <code>"file_descriptor"</code>.
The keyword <code>CREATED</code> is converted to attributes  <code>"created"</code> and <code>"date"</code>.
The list is also given <code>names</code>.
If the keyword <code>TABLE_NAME</code> is present in the table header, then its value is used.
Otherwise the names are <code>"TABLE_1"</code>, <code>"TABLE_2"</code>, ...
</p>
<p>Each <code>data.frame</code> in the list is assigned attributes: <code>"header"</code>, 
and (if present) <code>"descriptor"</code>.
The length of <code>"header"</code> is (typically) greater than 1, and <code>"descriptor"</code> has length 1.
Each line of the table header is a keyword-value pair.
The keywords <code>DESCRIPTOR</code> and  <code>TABLE_DESCRIPTOR</code>  
are converted to attribute <code>"descriptor"</code>.
</p>
<p>For the lines between <code>BEGIN_DATA</code> and <code>END_DATA</code>,
two conventions for separating the values are supported:
</p>
  
<ul>
<li><p>  In the standard convention, fields are separated by contiguous spaces or tabs, and character strings (which may have embedded spaces or even tabs) 
are enclosed by double-quotes.
This is is the convention in the CGATS standard.
The function <code><a href="base.html#topic+scan">scan</a>()</code> is used here.
</p>
</li>
<li><p> In the non-standard convention, fields are separated by a <em>single</em> tab,
and character strings (which may have embedded spaces but not tabs) are <em>not</em> enclosed by double-quotes.
This convention is often easier to work with in spreadsheet software.
The function <code><a href="base.html#topic+strsplit">strsplit</a>()</code> is used here.
</p>
</li></ul>

<p>The function <code>readCGATS()</code> selects the separation convention 
by examining the line after <code>BEGIN_DATA_FORMAT</code>.
If this line is split by a single tab and the number of fields
matches that given on the <code>NUMBER_OF_FIELDS</code> line,
then the non-standard convention is selected;
otherwise, the standard convention is selected.
</p>


<h3>Value</h3>

<p><code>readCGATS()</code> returns a list of <code>data.frame</code>s - 
one <code>data.frame</code> for each table found in <code>path</code>.
The list and each individual <code>data.frame</code> have attributes, see <b>Details</b>.
</p>
<p>If <code>path</code> has only a single table (the majority of files have only 1) 
and <code>collapsesingle</code> is <code>TRUE</code>, then the attributes of the list
are copied to those of the <code>data.frame</code>,
and the <code>data.frame</code> is then returned.
The name of the table is lost.
</p>
<p>If there is an error in any table, then the function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>In the <code>BEGIN_DATA_FORMAT</code> line(s),
field names may not be quoted and may not have embedded spaces.
<br />
The CGATS standard allows duplicated field names,
and <code>readCGATS()</code> returns them as they appear, with no attempt to append numbers
in order to make them unique.
Examples of field names which may be duplicated are:
<code>SPECTRAL_NM</code>, <code>SPECTRAL_DEC</code>, and <code>SPECTRAL_PCT</code>;
for more on these see <code><a href="#topic+readSpectraCGATS">readSpectraCGATS</a>()</code>.
<br />
No attempt is made to recognize those tables that contain spectral data.
For conversion of spectral data to <b>colorSpec</b> objects, see <code><a href="#topic+readSpectraCGATS">readSpectraCGATS</a>()</code>.
</p>


<h3>References</h3>

<p>ANSI/CGATS.17. 
Graphic technology - Exchange format for colour and process control data using XML or ASCII text.
<a href="https://webstore.ansi.org/">https://webstore.ansi.org/</a>
2009.
</p>
<p>ISO/28178. Graphic technology - Exchange format for colour and process control data using XML or ASCII text.
<a href="https://www.iso.org/standard/44527.html">https://www.iso.org/standard/44527.html</a>.
2009.
</p>
<p>CGATS.17 Text File Format.
<a href="http://www.colorwiki.com/wiki/CGATS.17_Text_File_Format">http://www.colorwiki.com/wiki/CGATS.17_Text_File_Format</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readSpectraCGATS">readSpectraCGATS</a></code>,
<code><a href="base.html#topic+scan">scan</a></code>,
<code><a href="base.html#topic+strsplit">strsplit</a></code>,
<code><a href="base.html#topic+names">names</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   read file with 2 tables of non-spectral data
A70 = readSpectra( system.file( "tests/A70.ti3", package='colorSpec' ) )
length(A70)         # [1] 2   # the file has 2 tables
ncol( A70[[1]] )    # [1] 7   # the 1st table has 7 columns
ncol( A70[[2]] )    # [1] 4   # the 2nd table has 4 columns
</code></pre>

<hr>
<h2 id='readSpectra'>read colorSpec objects from files</h2><span id='topic+readSpectra'></span><span id='topic+readAllSpectra'></span><span id='topic+readSpectraXYY'></span><span id='topic+readSpectraSpreadsheet'></span><span id='topic+readSpectrumScope'></span><span id='topic+readSpectraControl'></span><span id='topic+readSpectraCGATS'></span>

<h3>Description</h3>

<p>These functions read <b>colorSpec</b> objects from files.
In case of <code>ERROR</code>, they return <code>NULL</code>.
There are 5 different file formats supported; see <b>Details</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSpectra( pathvec, ... )

readSpectraXYY( path )
readSpectraSpreadsheet( path )
readSpectrumScope( path )
readSpectraCGATS( path )
readSpectraControl( path )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSpectra_+3A_pathvec">pathvec</code></td>
<td>
<p>a character vector to (possibly) multiple files.
The file extension and a few lines from each file are read
and a guess is made regarding the file format.</p>
</td></tr>
<tr><td><code id="readSpectra_+3A_...">...</code></td>
<td>
<p>optional arguments passed on to <code><a href="#topic+resample">resample</a>()</code>.
The most important is <code>wavelength</code>.
If these are missing then <code><a href="#topic+resample">resample</a>()</code> is not called.</p>
</td></tr>
<tr><td><code id="readSpectra_+3A_path">path</code></td>
<td>
<p>a path to a single file with the corresponding format:
<code>XYY</code>, <code>Spreadsheet</code>, <code>Scope</code>, 
<code>CGATS</code>, or <code>Control</code>.  See Details.
If the function cannot recognize the format, it returns NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readSpectra()</code> reads the first few lines of the file in order
to determine the format,
and then calls the corresponding format-specific function.
If <code>readSpectra()</code> cannot determine the format, it returns NULL.
The 5 file formats are:
</p>
<p><code>XYY</code> <br />         
There is a column header line matching <code>^(wave|wv?l)</code> (not case sensitive)
followed by the the names of the spectra. 
All lines above this one are taken to be <code>metadata</code>.
The separarator on this header line can be space, tab, or comma; 
the line is examined and the separator found there is used in the lines with data below. 
The organization of the returned object is <code>'df.col'</code>.  
This is probably the most common file format;
see the sample file <code>ciexyz31_1.csv</code>.<br />
</p>
<p><code>Spreadsheet</code>  <br />
There is a line matching <code>"^(ID|SAMPLE|Time)"</code>. This line and lines below must be tab-separated.  Fields matching <code>'^[A-Z]+([0-9.]+)nm$'</code> are taken to be spectral data and other fields are taken to be <code>extradata</code>.  All lines above this one are taken to be <code>metadata</code>.
The organization of the returned object is <code>'df.row'</code>.
This is a good format for automated acquisition, using a spectrometer, of many spectra.
See the sample file <code>N130501.txt</code> from <b>Wolf Faust</b>.<br />
</p>
<p><code>Scope</code>  <br />
This is a file format used by <b>Ocean Optics</b> spectrometer software.  
There is a line <br />
<code>&gt;&gt;&gt;&gt;&gt;Begin Processed Spectral Data&lt;&lt;&lt;&lt;&lt;</code><br />
followed by wavelength and energy separated by a tab.  
There is only 1 spectrum per file.  
The <code>organization</code> of the returned object is <code>'vector'</code>.
See the sample file <code>pos1-20x.scope</code>. <br />
</p>
<p><code>CGATS</code>  <br />
This is a complex format that is best understood by looking at some samples, such as<br />
<code>extdata/objects/Rosco.txt</code>;
see also the <b>References</b>.
The function <code><a href="#topic+readCGATS">readCGATS</a>()</code> is first called to get all the tables,
and then for each table the column names are examined.
There are 2 conventions for presenting the spectral data:
</p>
  
<ul>
<li><p> In the standard convention the fields <code>SPECTRAL_DEC</code> or <code>SPECTRAL_PCT</code>
have the spectral values.
The former is the true value, and the latter is the true value x 100.
Each value column is preceded a corresponding wavelength column,
which has the field name <code>SPECTRAL_NM</code>.
Note that these field names are highly duplicated.
In principle, this convention allows each record in a CGATS table to have
a different wavelength vector.
However, this complication is rejected by <code>readSpectraCGATS()</code>,
which treats it as an ERROR.
</p>
</li>
<li><p> In the non-standard convention the field names that match the pattern<br />
<code>"^(nm|SPEC_|SPECTRAL_)[_A-Z]*([0-9.]+)$"</code>
are considered to be spectral value data, and other fields are considered <code>extradata</code>.
The wavelength is the numerical value of the 2nd parenthesized expression <code>([0-9.]+)</code>
in nanometers.
Note that every record in this CGATS table has the same wavelength vector.
Although this convention is non-standard, it appears in files from many companies,
including X-Rite.
</p>
</li></ul>

<p>If a <code>data.frame</code> has spectral data, it is converted to a <b>colorSpec</b> object
and placed in the returned list.
The organization of the resulting <b>colorSpec</b> object is <code>'df.row'</code>.
If the <code>data.frame</code> of <code>extradata</code> contains a column 
<code>SAMPLE_NAME</code>, <code>SAMPLE_ID</code>, <code>SampleID</code>, or <code>Name</code>, 
(examined in that order), then that column is taken to be the <code>specnames</code>
of the object.
If a table has no spectral data, then it is ignored.
If the CGATS file has no tables with spectral data, then it is an ERROR
and the function returns <code>NULL</code>.
</p>
<p><code>Control</code> <br />
This is a personal format used for digitizing images of plots from manufacturer
datasheets and academic papers. It is structured like a <code>.INI</code> file.  
There is a <code>[Control]</code>
section establishing a simple linear map from pixels to the wavelength and spectrum quantities.
Only 3 points are really necessary.
It is OK for there to be a little rotation of the plot axes relative to the image.
This is followed by a section for each spectrum, in XY pixel units only.
Conversion to wavelength and spectral quantities is done on-the-fly after they are read.
Extrapolation can be a problem, especially when the value is near 0.
To force constant extrapolation (see <code><a href="#topic+resample">resample</a>()</code>),
repeat the control point (knot) at the endpoint.
See the sample file <code>Lumencor-SpectraX.txt</code>.
The organization of the returned objects is <code>'vector'</code>.<br />
</p>


<h3>Value</h3>

<p><code>readSpectra()</code> returns a single <b>colorSpec</b> object or <code>NULL</code> in case of ERROR.
If there are multiple files in <code>pathvec</code> and they cannot be combined using <code>bind()</code> because their wavelengths are different, it is an ERROR.
To avoid this ERROR, the <code>wavelength</code> argument can be used for
resampling to common wavelengths.
If there are multiple files, the <code><a href="#topic+organization">organization</a></code> of the returned object is
<code>'df.row'</code> and the first column is the <code>path</code>
from which the spectrum was read.
</p>
<p>The functions <code>readSpectraXYY()</code>, <code>readSpectraSpreadsheet()</code>, 
and <code>readSpectraScope()</code>, return a single <b>colorSpec</b> object,
or <code>NULL</code> in case of ERROR.
</p>
<p>The functions <code>readSpectraCGATS()</code> and <code>readSpectraControl()</code>
are more complicated.
These 2 file formats can contain multiple spectra with different <code>wavelength</code> sequences,
so both functions return a <em>list</em> of <b>colorSpec</b> objects,
even when that list has length 1.
If no spectral objects are found, they return <code>NULL</code>.
</p>
<p>If <code>readSpectra()</code> calls <code>readSpectraCGATS()</code> or <code>readSpectraControl()</code>
and receives a list of <b>colorSpec</b> objects,
<code>readSpectra()</code> attempts to <code><a href="#topic+bind">bind</a>()</code> them into a single object.
If they all have the same wavelength vector, then the <code>bind()</code> succeeds and the
single <b>colorSpec</b> object is returned.
Otherwise the <code>bind()</code> fails, and it is an ERROR.
To avoid this error <code>readSpectra()</code> can be called with a
<code>wavelength</code> argument. 
The multiple spectra are resampled using <code><a href="#topic+resample">resample</a>()</code> and
<em>then</em> combined using <code>bind()</code>,
which makes it much more convenient to read such files.
</p>


<h3>Note</h3>

<p>During import, each read function tries to guess the <code>quantity</code> 
from spectrum names or other cues.  
For example the first line in <b>N130501.txt</b> is <code>IT8.7/1</code>,
which indicates that the quantity is <code>'transmittance'</code>
(a reflective target is denoted by <code>IT8.7/2</code>).  
If a confident guess cannot be made, it makes a wild guess and issues a warning.  
If the quantity is incorrect, one can assign the correct value after import.  
Alternatively one can add a line to the header part of the file with the 
keyword <code>'quantity'</code> followed by some white-space and the correct value.  
It is OK to put the value in quotes.
See example files under folder <b>extdata</b>.
</p>


<h3>References</h3>

<p>CGATS.17 Text File Format.
<a href="http://www.colorwiki.com/wiki/CGATS.17_Text_File_Format">http://www.colorwiki.com/wiki/CGATS.17_Text_File_Format</a>.
</p>
<p>ANSI/CGATS.17. 
Graphic technology - Exchange format for colour and process control data using XML or ASCII text.
<a href="https://webstore.ansi.org/">https://webstore.ansi.org/</a>
2009.
</p>
<p>ISO/28178. Graphic technology - Exchange format for colour and process control data using XML or ASCII text.
<a href="https://www.iso.org/standard/44527.html">https://www.iso.org/standard/44527.html</a>.
2009.
<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wavelength">wavelength</a></code>,
<code><a href="#topic+quantity">quantity</a></code>,
<code><a href="#topic+metadata">metadata</a></code>,
<code><a href="#topic+resample">resample</a></code>,
<code><a href="#topic+bind">bind</a></code>,  
<code><a href="#topic+readCGATS">readCGATS</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   read file with header declaring the quantity to be "photons-&gt;neural"
bird = readSpectra( system.file( "extdata/eyes/BirdEyes.txt", package='colorSpec' ) )
quantity(bird)   # [1] "photons-&gt;neural"
</code></pre>

<hr>
<h2 id='resample'>resample a colorSpec Object to new wavelengths</h2><span id='topic+resample'></span><span id='topic+resample.colorSpec'></span>

<h3>Description</h3>

<p>interpolate or smooth to new wavelengths.  
Simple extrapolation and clamping is also performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
resample( x, wavelength, method='auto', span=0.02, extrapolation='const', clamp='auto' )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object</p>
</td></tr>
<tr><td><code id="resample_+3A_wavelength">wavelength</code></td>
<td>
<p>vector of new wavelengths, in nanometers</p>
</td></tr>
<tr><td><code id="resample_+3A_method">method</code></td>
<td>
<p>interpolation methods available are 
<code>'sprague'</code>, <code>'spline'</code>, and <code>'linear'</code>.
Also available is <code>'auto'</code> which means to use <code>'sprague'</code>
if <code>x</code> is regular, and <code>'spline'</code> otherwise.

An available smoothing method is <code>'loess'</code>.
See <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="resample_+3A_span">span</code></td>
<td>
<p>smoothing argument passed to <code><a href="stats.html#topic+loess">loess</a>()</code>
during interpolation, and not used by other methods.
The default value <code>span=0.02</code> is suitable for
<code>.scope</code> spectra but may be too small in many other cases.</p>
</td></tr>  
<tr><td><code id="resample_+3A_extrapolation">extrapolation</code></td>
<td>
<p>extrapolation methods available are
<code>'const'</code> and <code>'linear'</code>.
These can be abbreviated to the initial letter.
Also available is a numeric value, which is used for simple padding.
See <b>Details</b>.<br />
Also available is a vector or list of length 2 that combines 2 of the above.
The first item is used on the low side (shorter wavelengths),
and the second item is used on the high side (longer wavelengths).
</p>
</td></tr>
<tr><td><code id="resample_+3A_clamp">clamp</code></td>
<td>
<p>clamp methods available are
<code>'auto'</code>, <code>TRUE</code>, and <code>FALSE</code>.
Also available is a numeric vector of length 2,
which defines the clamping interval.    
See <b>Details</b>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If method is <code>'sprague'</code>, the quintic polynomial in <cite>De Kerf</cite> is used.
Six weights are applied to nearby data values: 3 on each side.
The <code>'sprague'</code> method is only supported when <code>x</code> is regular.
</p>
<p>If method is <code>'spline'</code>, the function <code>stats::<a href="stats.html#topic+spline">spline</a>()</code>
is called with <code>method='natural'</code>.
The <code>'spline'</code> method is supported even when <code>x</code> is irregular.
</p>
<p>If method is <code>'linear'</code>, the function <code>stats::<a href="stats.html#topic+approx">approx</a>()</code> is called.
Two weights are applied to nearby data values: 1 on each side.
The <code>'linear'</code> method is supported even when <code>x</code> is irregular.
</p>
<p>If method is <code>'loess'</code>, the function <code>stats::<a href="stats.html#topic+loess">loess</a>()</code> is called
with the given <code>span</code> parameter.
Smoothing is most useful for noisy data, e.g. raw data from a spectrometer.
I have found that <code>span=0.02</code> works well for Ocean Optics <code>.scope</code> files, 
but this may be too small in other cases, which triggers an error in <code>stats::loess()</code>. 
The <code>'loess'</code> method is supported even when <code>x</code> is irregular.
</p>
<p>If extrapolation is <code>'const'</code>,
the extreme values at each end are simply extended.
If extrapolation is <code>'linear'</code>,
the line defined by the 2 extreme values at each end is used for extrapolation.
If the ultimate and penultimate wavelengths are equal,
then this line is undefined and the function reverts to <code>'const'</code>.
</p>
<p>If clamp is <code>'auto'</code>,
output values are clamped to the physically realizable interval
appropriate for <code>x</code>.
This is the interval [0,1]  when
<code>quantity(x)</code> is <code>'reflectance'</code> or <code>'transmittance'</code>,
and the interval [0,<code class="reqn">\infty</code>)  otherwise.
Exception: If an input spectrum in <code>x</code> violates a limit,
then clamping the output spectrum to this limit is <em>NOT</em> enforced.
This happens most frequenty for theoretical (or matrixed) cameras,
such as <code><a href="#topic+BT.709.RGB">BT.709.RGB</a></code>.
</p>
<p>If clamp is <code>TRUE</code>, the result is the same as <code>'auto'</code>,
but with no exceptions.
If clamp is <code>FALSE</code>, then no clamping is done.
</p>
<p>If clamp is a numerical interval, then clamping is done to that interval,
with no exceptions.
The two standard intervals mentioned above can be expressed in <b>R</b>
as <code>c(0,1)</code> and <code>c(0,Inf)</code> respectively.
</p>


<h3>Value</h3>

<p><code>resample(x)</code> returns a <b>colorSpec</b> object 
with the new <code>wavelength</code>.
Other properties, e.g. <code><a href="#topic+organization">organization</a></code>, <code><a href="#topic+quantity">quantity</a></code>, ...,
are preserved.<br />
In case of ERROR, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>De Kerf, Joseph L. F.
<b>The interpolation method of Sprague-Karup</b>.
<em>Journal of Computational and Applied Mathematics</em>.
volume I, no 2, 1975.
equation (S).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+organization">organization</a>()</code>,   
<code><a href="#topic+quantity">quantity</a>()</code>,
<code><a href="#topic+wavelength">wavelength</a>()</code>,
<code><a href="#topic+is.regular">is.regular</a>()</code>,
<code><a href="#topic+theoreticalRGB">theoreticalRGB</a></code>,
<code><a href="stats.html#topic+spline">spline</a>()</code>,
<code><a href="stats.html#topic+approx">approx</a>()</code>,
<code><a href="stats.html#topic+loess">loess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path = system.file( "extdata/sources/pos1-20x.scope", package='colorSpec' )
y = readSpectra( path )
# plot noisy data in gray
plot( y, col='gray' )
# plot smoothed plot in black on top of the noisy one to check quality
plot( resample( y, 200:880, meth='loess', span=0.02 ), col='black', add=TRUE )
</code></pre>

<hr>
<h2 id='responsivityMetrics'>Compute Metrics for a Light Responder (e.g. a camera) or a Material Responder (e.g. a scanner)</h2><span id='topic+responsivityMetrics'></span><span id='topic+responsivityMetrics.colorSpec'></span>

<h3>Description</h3>

<p>This function computes a few technical metrics regarding some
geometric objects related to a responder:
the spherical chromaticity polygon, cone, convex cone, and color-solid.
</p>
<p>Currently the function only works if the number of spectra in <code>x</code> is 3 (e.g. RGB or XYZ).
In this case the rows of <code>as.matrix(x)</code> (after weighting by step size)
are called the <em>generators</em>; they are vectors in <code class="reqn">R^3</code> 
and we require that they are all in some open linear halfspace (unless a generator is 0).
The 0-based rays through the generators intersect a plane inside the halfspace to form the vertices
of the <em>chromaticity polygon</em> <code class="reqn">P</code>.
The 0-based rays through points of the interior of <code class="reqn">P</code> form a cone,
and the convex hull of this cone is a convex cone.
The central projection of <code class="reqn">P</code> onto the unit sphere is the <em>spherical chromaticity polygon</em> <code class="reqn">P_S</code>.
If <code>type</code> is <code>'responsivity.material'</code>, then <code>x</code> has an
<em>object-color solid</em> or <em>Rösch Farbkörper</em>,
which is a zonohedron <code class="reqn">Z</code>.
See <cite>Centore</cite> and vignette
<a href="../doc/convexity.pdf"><b>Convexity and Transitions</b></a>
for details.
<br />
Some simplification of the generators is performed during pre-processing.
Generators that are 0 (in all channels) are removed,
and a group of generators that are all positive multiples of each other is replaced by their sum.
The 3-vectors are called the <em>condensed generators</em>.
These simplifications do not change any of the geometric objects defined above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
responsivityMetrics( x )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="responsivityMetrics_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code>
equal to <code>'responsivity.light'</code> or <code>'responsivity.material'</code>, and 3 spectra</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>responsivityMetrics()</code> returns a list with these items:
</p>
<table>
<tr><td><code>generators</code></td>
<td>

<p>a pair of integers, the 1st is the number of original generators,
and the 2nd is the number of condensed generators
</p>
</td></tr>
<tr><td><code>zeros</code></td>
<td>
<p>vector of wavelengths at which the responsivity is 0 (in all 3 channels)</p>
</td></tr>
<tr><td><code>multiples</code></td>
<td>
<p>a list of vectors of wavelengths; the responsivities in each vector (group) are positive multiples of each other</p>
</td></tr>
<tr><td><code>salient</code></td>
<td>
<p>a logical where TRUE means that there is some open linear halfspace that contains all the non-zero generators.  If all the responsivities are non-negative, which is the usual case, then <code>salient=TRUE</code>.</p>
</td></tr>
<tr><td><code>normal</code></td>
<td>
<p>If <code>salient=TRUE</code>, then the inward pointing unit normal for the previous halfspace.
Otherwise, <code>normal=NA</code>.</p>
</td></tr>
</table>
<p>If <code>salient=TRUE</code>, then the list also contains:
</p>
<table>
<tr><td><code>concavities</code></td>
<td>
<p>a <code>data.frame</code> with 2 columns: <code>wavelength</code> and <code>extangle</code>,
where <code>extangle</code> is the external angle at the wavelength (for the spherical chromaticity polygon <code class="reqn">P_S</code>), 
and is negative.
A negative angle means that <code class="reqn">P_S</code> is concave at that vertex.</p>
</td></tr>
<tr><td><code>coneangle</code></td>
<td>
<p>the solid angle of the cone generated by the generators.
This is identical to the area of the spherical chromaticity polygon, with concavities preserved.
</p>
</td></tr>
<tr><td><code>cxconeangle</code></td>
<td>
<p>the solid angle of the convex cone generated by the generators, with no concavities.
This is identical to the area of the convex hull of the spherical chromaticity polygon.
If all responsivities are non-negative, which is the usual case, then this solid angle is less than
the solid angle of an octant, which is <code class="reqn">\pi/2</code>.</p>
</td></tr>
</table>
<p>If the type of x is <code>'responsivity.material'</code> then the list also contains:    
</p>
<table>
<tr><td><code>area</code></td>
<td>
<p>the surface area of the object-color solid of <code>x</code></p>
</td></tr>
<tr><td><code>volume</code></td>
<td>
<p>the volume of the object-color solid of <code>x</code></p>
</td></tr>
</table>
<p>In case of global error, the function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>To determine the value of <code>salient</code>, the package <b>quadprog</b> might be required.
</p>


<h3>References</h3>

<p>Centore, Paul.
<em>A zonohedral approach to optimal colours</em>.
<b>Color Research &amp; Application</b>.
Vol. 38.
No. 2.
pp. 110-119.
April 2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type">type</a></code>,
vignette <a href="../doc/convexity.pdf"><b>Convexity and Transitions</b></a>
</p>

<hr>
<h2 id='scanner'>
standard RGB scanners
</h2><span id='topic+scanner.ACES'></span>

<h3>Description</h3>

<p><code>scanner.ACES</code> is an RGB responder to material; 
an ACES/SMPTE standard for scanning RGB film.
The 3 spectra are defined from 368 to 728 nm, at 2nm intervals.
</p>


<h3>Format</h3>

<p>A <b>colorSpec</b> object with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'material-&gt;electrical'</code> and 3 spectra:
<code>r</code>, <code>g</code>, and <code>b</code>.
</p>


<h3>Details</h3>

<p>The responsivities have been scaled (by <code><a href="#topic+calibrate">calibrate</a></code>) so the response to the <em>perfect transmitting filter</em> (PTF) is RGB=(1,1,1).
</p>


<h3>References</h3>

<p>Technical Bulletin
TB-2014-005.
Informative Notes on
SMPTE ST 2065-2 - Academy Printing Density (APD).
Spectral Responsivities, Reference Measurement Device and Spectral Calculation.
</p>
<p>SMPTE ST 2065-3 Academy Density Exchange Encoding (ADX).
Encoding Academy Printing Density (APD) Values.
</p>
<p>The Academy of Motion Picture Arts and Sciences.
Science and Technology Council.
Academy Color Encoding System (ACES) Project Committee.
Version 1.0 December 19, 2014.
Annex A		Spectral Responsivities.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a></code>, <code><a href="#topic+calibrate">calibrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   compute response of ACES scanner to the Hoya filters
product( Hoya, scanner.ACES, wave='auto' )

##                  R            G          B
## R-60   0.902447043 2.022522e-05 0.00000000
## G-533  0.038450857 4.900983e-01 0.05431134
## B-440  0.008466317 1.686241e-02 0.42863320
## LB-120 0.184408941 3.264111e-01 0.53492533
</code></pre>

<hr>
<h2 id='sectionOptimalColors'>compute sections of an optimal color surface by hyperplanes</h2><span id='topic+sectionOptimalColors'></span><span id='topic+sectionOptimalColors.colorSpec'></span>

<h3>Description</h3>

<p>Consider a <b>colorSpec</b> object <code>x</code> with <code>type</code> 
equal to <code>'responsivity.material'</code>.
The set of all possible material reflectance functions (or transmittance functions) 
is convex, closed, and bounded (in fact they form a cube),
and this implies that the set of all possible output responses 
from <code>x</code> is also convex, closed, and bounded.
The latter set is called the <em>object-color solid</em> or <em>Rösch Farbkörper</em> for <code>x</code>.
If the dimension of the response of <code>x</code> is 2, 
this solid is a convex polygon
that is centrally symmetric - a <em>zonogon</em>.
If the dimension of the response of <code>x</code> is 3 (e.g. RGB or XYZ), 
this solid is a special type of centrally symmetric convex polyhedron
called a <em>zonohedron</em>, see <cite>Centore</cite>.
This function only supports dimensions 2 and 3.
Denote this object-color solid by <b>Z</b>.
</p>
<p>A color on the boundary of <b>Z</b> is called an <em>optimal color</em>.
Consider the intersection of a hyperplane with the boundary of <b>Z</b>.
Let the equation of the hyperplane be given by:
</p>
<p style="text-align: center;"><code class="reqn"> &lt;v,normal&gt; = \beta </code>
</p>

<p>where <code class="reqn">normal</code> is orthogonal to the hyperplane,
and <code class="reqn">\beta</code> is the plane constant, and <code class="reqn">v</code> is a variable vector.
The purpose of the function <code>sectionOptimalColors()</code> 
is to compute the intersection set.
</p>
<p>In dimension 2 this hyperplane is a line, and the intersection is
generically 2 points, and 1 point if the line only intersects the boundary
(we ignore the special case when the intersection is an edge of the polygon).
</p>
<p>In dimension 3 this hyperplane is a 2D plane, and the intersection is
generically a polygon, and 1 point if the line only intersects the boundary
(we ignore the special case when the intersection is a face of the zonohedron).
</p>
<p>Of course, the intersection can also be empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
sectionOptimalColors( x, normal, beta )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sectionOptimalColors_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object with <code>type</code>
equal to <code>'responsivity.material'</code> and M spectra, where M=2 or 3.</p>
</td></tr>
<tr><td><code id="sectionOptimalColors_+3A_normal">normal</code></td>
<td>
<p>a nonzero vector of dimension M, that is the normal to a hyperplane</p>
</td></tr>
<tr><td><code id="sectionOptimalColors_+3A_beta">beta</code></td>
<td>
<p>a vector of numbers of positive length.
The number <code>beta[k]</code> defines the plane <code>&lt;v,normal&gt; = beta[k]</code>. </p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>Consider first the case that the dimension of <code>x</code> is 3,
so that <b>Z</b> is a zonohedron.
In the preprocessing phase the zonohedral representation is calculated.
The faces of <b>Z</b> are either parallelograms,
or <em>compound faces</em> that are partitioned into parallelograms.
The centers of all these parallelograms are computed,
along with their extent in direction <code class="reqn">normal</code>.
For a given plane <code class="reqn">&lt;v,normal&gt;=\beta</code>,
the parallelograms that intersect the plane are extracted.
The boundary of each parallelogram intersects the plane in 2 points (in general)
and one of those points is computed.
The set of all these points is then sorted into proper order around the boundary.
<br />
In the case that the dimension of <code>x</code> is 2,
so that <b>Z</b> is a zonogon,
the parallelograms are replaced by line segments (edges),
and the processing is much easier.
</p>


<h3>Value</h3>

<p>The function returns a list with an item for each value in vector <code>beta</code>.
Each item in the output is a list with these items:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>the value of the plane constant <code class="reqn">\beta</code></p>
</td></tr> 
<tr><td><code>section</code></td>
<td>
<p>an NxM matrix, where N is the number of points in the section,
and M is the dimension of <code>normal</code>.
If the intersection is empty, then N=0.</p>
</td></tr>
</table>
<p>In case of global error, the function returns <code>NULL</code>.
</p>


<h3>WARNING</h3>

<p>The preprocessing calculation of the zonohedron dominates the total time.
And this time goes up rapidly with the number of wavelengths.
We recommend using a wavelength step of 5nm, as in the <b>Examples</b>.
For best results, batch a lot of <code>beta</code>s into a single function call
and then process the output.
<br />
Moreover, the preprocessing time is dominated by the partitioning
of the compound faces into parallelograms.
This is made worse by an <code>x</code> whose spectral responses have little overlap,
as in <code><a href="#topic+scanner.ACES">scanner.ACES</a></code>.
In these cases, try a larger step size, and then reduce.
Optimizing these compound faces is a possible topic for the future.
</p>


<h3>References</h3>

<p>Centore, Paul.
<em>A Zonohedral Approach to Optimal Colours</em>.
<b>Color Research &amp; Application</b>.
Vol. 38.
No. 2.
pp. 110-119.
April 2013.
</p>
<p>Logvinenko, A. D.
An object-color space. 
<b>Journal of Vision</b>.
9(11):5, 1-23, (2009).<br />
<code>https://jov.arvojournals.org/article.aspx?articleid=2203976</code>.
doi:10.1167/9.11.5.
</p>


<h3>See Also</h3>

<p>vignette <a href="../doc/optimals.pdf"><b>Plotting Chromaticity Loci of Optimal Colors</b></a>,
<code><a href="#topic+probeOptimalColors">probeOptimalColors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave = seq(420,680,by=5)
Flea2.scanner = product( A.1nm, "material", Flea2.RGB, wavelength=wave )
seclist = sectionOptimalColors( Flea2.scanner, normal=c(0,1,0), beta=10 )
length( seclist[[1]]$section )
seclist[[1]]$section[ 1:5, ]
## [1] 207   # the polygon has 207 vertices, and the first 5 are:
##            Red Green      Blue
##  [1,] 109.2756    10 3.5391342
##  [2,] 109.5729    10 2.5403628
##  [3,] 109.8078    10 1.7020526
##  [4,] 109.9942    10 1.0111585
##  [5,] 110.1428    10 0.4513051
</code></pre>

<hr>
<h2 id='solar.irradiance'>
Standard Solar Irradiance - Extraterrestrial and Terrestrial
</h2><span id='topic+solar.irradiance'></span><span id='topic+atmosphere2003'></span>

<h3>Description</h3>


<dl>
<dt><code>solar.irradiance</code></dt><dd><p>Three power spectra; from 280 to 1000 nm at 1 nm intervals. The unit is <code class="reqn">W*m^{-2}*nm^{-1}</code>.</p>
</dd>
<dt><code>atmosphere2003</code></dt><dd><p>a transmittance spectrum = the quotient of 2 spectra from <code>solar.irradiance</code></p>
</dd>
</dl>



<h3>Format</h3>

<p><code>solar.irradiance</code> is a
<b>colorSpec</b> object with <code>quantity</code> equal to <code>'energy'</code> and with 3 spectra:
</p>

<dl>
<dt><code>AirMass.0</code></dt><dd><p>Extraterrestrial Radiation (solar spectrum at top of atmosphere) at mean Earth-Sun distance</p>
</dd>
<dt><code>GlobalTilt</code></dt><dd><p>spectral radiation from solar disk plus sky diffuse
and diffuse reflected from ground on south facing surface tilted 37 deg from horizontal</p>
</dd>
<dt><code>AirMass.1.5</code></dt><dd><p>the sum of Direct and Circumsolar irradiance, when the optical path is 1.5 times that of the sun at zenith, see <b>Details</b></p>
</dd>
</dl>

<p><code>atmosphere2003</code> is a <b>colorSpec</b> object with <code>quantity</code> equal to <code>'transmittance'</code> and with 1 spectrum:
</p>

<dl>
<dt><code>AirMass.1.5</code></dt><dd><p>the quotient <code>AirMass.1.5</code> / <code>AirMass.0</code> from <code>solar.irradiance</code> </p>
</dd>
</dl>


<h3>Details</h3>

<p><b>Direct</b> is Direct Normal Irradiance Nearly parallel (0.5 deg divergent cone) radiation
on surface with surface normal tracking (pointing to) the sun,
excluding scattered sky and reflected ground radiation.
</p>
<p><b>Circumsolar</b> is Spectral irradiance within +/- 2.5 degree (5 degree diameter) field of view
centered on the 0.5 deg diameter solar disk, but excluding the radiation from the disk.
</p>


<h3>Note</h3>

<p>The reference spectra in ASTM G173-03 are designed for
Photovoltaic Performance Evaluation.
</p>
<p>The original wavelength sequence in ASTM G173-03 is irregular.
The interval is 0.5 nanometer from 280 to 400 nm,
1 nm from 400 to 1700 nm,
an intermediate wavelength at 1702 nm,
and 5 nm from 1705 to 4000 nm.
To create the object <code>solar.irradiance</code> with a regular step size,
the original was resampled from 280 to 1000 nm at 1nm intervals.
</p>


<h3>Source</h3>

<p>Reference Solar Spectral Irradiance: ASTM G-173.
<a href="http://rredc.nrel.gov/solar/spectra/am1.5/astmg173/astmg173.html">http://rredc.nrel.gov/solar/spectra/am1.5/astmg173/astmg173.html</a>
</p>


<h3>References</h3>

<p>ASTM G173-03 Reference Spectra Derived from SMARTS v. 2.9.2.<br />
Standard Tables for Reference Solar Spectral Irradiances: Direct Normal and Hemispherical on 37-deg Tilted Surface (2003)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D65">D65</a></code>,
<code><a href="#topic+D50">D50</a></code>, 
<code><a href="#topic+daylightSpectra">daylightSpectra</a></code>,
<code><a href="#topic+resample">resample</a></code>,
vignette <a href="../doc/blueflame.pdf"><b>Blue Flame and Green Comet</b></a>
</p>

<hr>
<h2 id='specnames'>specnames of a colorSpec object</h2><span id='topic+specnames'></span><span id='topic+specnames+3C-'></span><span id='topic+numSpectra'></span><span id='topic+specnames.colorSpec'></span><span id='topic+specnames+3C-.colorSpec'></span><span id='topic+numSpectra.colorSpec'></span>

<h3>Description</h3>

<p>Retrieve or set the specnames of a <b>colorSpec</b> object.  Retrieve the number of spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
specnames(x)

## S3 replacement method for class 'colorSpec'
specnames(x) &lt;- value

## S3 method for class 'colorSpec'
numSpectra(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specnames_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="specnames_+3A_value">value</code></td>
<td>
<p>a character vector with length equal to the number of spectra in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>organization</code> of <code>x</code> is <code>"vector"</code> then <code>x</code> is a vector
and <code>value</code> is a single string, which is stored as <code>attr(x,'specname')</code>.
</p>
<p>If the <code>organization</code> of <code>x</code> is <code>"matrix"</code>, then <code>x</code> is a matrix
and <code>value</code> is stored as <code>colnames(x)</code>.
</p>
<p>If the <code>organization</code> of <code>x</code> is <code>"df.col"</code>, then <code>x</code> is a <code>data.frame</code>
with <code>N+1</code> columns, where <code>N</code> is the number of spectra.
<code>value</code> is stored as <code>colnames(x)[2:(N+1)]</code>.
</p>
<p>If the <code>organization</code> of <code>x</code> is <code>"df.row"</code>, then <code>x</code> is a <code>data.frame</code>
and <code>value</code> is stored as <code>row.names(x)</code>.
</p>


<h3>Value</h3>

<p><code>specnames()</code> returns a character vector with the names of the spectra.
</p>
<p><code>numSpectra(x)</code> is equal to <code>length(specnames(x))</code> but much more efficient.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rownames">rownames</a></code>, <code><a href="base.html#topic+colnames">colnames</a></code>
</p>

<hr>
<h2 id='standardRGB'>Convert from XYZ to some standard RGB spaces</h2><span id='topic+RGBfromXYZ'></span>

<h3>Description</h3>

<p>To display an XYZ value, it typically must be converted to a standard RGB space.
This is the function to do it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGBfromXYZ( XYZ, space )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardRGB_+3A_xyz">XYZ</code></td>
<td>
<p>a 3-vector, or a matrix with 3 columns with XYZs in the rows</p>
</td></tr>
<tr><td><code id="standardRGB_+3A_space">space</code></td>
<td>
<p>the name of the RGB space - either <code>'sRGB'</code> or <code>'Adobe RGB'</code>. 
The match is case-insensitive, and spaces in the string are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>XYZ</code> is multiplied by the appropriate 3x3 conversion matrix
(for <b>sRGB</b> or <b>Adobe RGB</b>).
These matrices are taken from <cite>Lindbloom</cite> and not from the corresponding <cite>Wikipedia</cite> articles; 
for the reason why see <b>Note</b>.
</p>


<h3>Value</h3>

<p>An Mx3 matrix where M is the number of rows in <code>XYZ</code>, or M=1 if XYZ is a 3-vector.
Each row of the returned matrix is filled with linear RGB in the appropriate RGB space.
Values outside the unit cube are not clamped.
To compute non-linear display RGB, see <code><a href="#topic+DisplayRGBfromLinearRGB">DisplayRGBfromLinearRGB</a>()</code>. <br />
In case of error the function returns <code>NULL</code>.
</p>


<h3>WARNING</h3>

<p>This function is deprecated.
New software should use <code>spacesRGB::RGBfromXYZ()</code> instead.
The new function returns &quot;signal RGB&quot; instead of linear RGB.
</p>


<h3>Note</h3>

<p>An RGB space is normally defined by the xy chromaticities of the 3 primaries and the white point.
We follow <cite>Lindbloom</cite> in using the 'official' XYZ of the white point from ASTM E308.
Using this XYZ of the white point makes the color space a little more consistent
with other areas of color.<br />
For example, from IEC 61966-2-1 we have
D65 xyY=(0.3127,0.3290,1) -&gt;  XYZ=(0.9504559,1,1.0890578).
But from ASTM E308, D65 XYZ=(0.95047,1,1.08883), which is a little different.
</p>


<h3>Source</h3>

<p>IEC 61966-2-1:1999.
Multimedia systems and equipment - Colour measurement and management.
Part 2-1: Colour management - Default RGB colour space - sRGB.
<a href="https://webstore.iec.ch/publication/6169">https://webstore.iec.ch/publication/6169</a>
</p>
<p>Lindbloom, Bruce.
RGB/XYZ Matrices.
<a href="http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html">http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html</a>
</p>
<p>Wikipedia.
<b>sRGB</b>.
<a href="https://en.wikipedia.org/wiki/SRGB">https://en.wikipedia.org/wiki/SRGB</a>
</p>
<p>Wikipedia.
<b>Adobe RGB</b>.
<a href="https://en.wikipedia.org/wiki/Adobe_RGB_color_space">https://en.wikipedia.org/wiki/Adobe_RGB_color_space</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D65">D65</a></code>,
<code><a href="#topic+officialXYZ">officialXYZ</a></code>,
<code><a href="#topic+DisplayRGBfromLinearRGB">DisplayRGBfromLinearRGB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RGBfromXYZ( officialXYZ('D65'), 'sRGB' )
#      R G B
# [1,] 1 1 1    # not really 1s, but difference &lt; 1.e-7

RGBfromXYZ( c(.3127,0.3290,0.3583)/0.3290, 'sRGB' )
#              R        G       B
# [1,] 0.9998409 1.000023 1.00024    difference &gt; 1.e-5
</code></pre>

<hr>
<h2 id='subset'>extract a subset of a colorSpec Object</h2><span id='topic+subset.colorSpec'></span><span id='topic+subset'></span>

<h3>Description</h3>

<p>extract a subset of the spectra in a <b>colorSpec</b> object.<br />  
The subset can be specified by indexes, by a logical vector, or by a regular expression matching the
<code><a href="#topic+specnames">specnames</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
subset( x, subset, ... )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> object</p>
</td></tr>
<tr><td><code id="subset_+3A_subset">subset</code></td>
<td>
<p>an integer vector, a logical vector, or a regular expression</p>
</td></tr>
<tr><td><code id="subset_+3A_...">...</code></td>
<td>
<p>additional arguments ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>subset</code> is an integer vector, each integer must be between 1 and M,
where M the number of spectra in <code>x</code>.
No duplicates are allowed.
The number of spectra returned is equal to <code>length(subset)</code>.
It is OK for the <code>length</code> to be 0, in which case the function returns the empty subset.
</p>
<p>If <code>subset</code> is a logical vector, its length must be equal to M.
The number of spectra returned is equal to the number of <code>TRUE</code>s in <code>subset</code>.
</p>
<p>If <code>subset</code> is a regular expression, the number of spectra returned is equal to
the number of <code>specnames(x)</code> matched by the expression. 
</p>


<h3>Value</h3>

<p><code>subset(x)</code> returns a <b>colorSpec</b> object with the same <code><a href="#topic+organization">organization</a></code> as <code>x</code>.
Exception: if the organization of <code>x</code> is <code>'vector'</code> and the subset is empty,
then the returned object is a matrix with 0 columns.
</p>


<h3>Note</h3>

<p><code>subset()</code> can also be used for re-ordering the spectra; 
just set argument <code>subset</code> to the desired permutation vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+organization">organization</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tritanope = subset( lms2000.1nm, 1:2 )  # keep long and medium cone fundamentals, but drop the short

sml2000.1nm = subset( lms2000.1nm, 3:1 ) #   reorder from short to long
</code></pre>

<hr>
<h2 id='theoreticalRGB'>
Theoretical RGB Cameras - BT.709.RGB, Adobe.RGB, and ACES.RGB
</h2><span id='topic+theoreticalRGB'></span><span id='topic+BT.709.RGB'></span><span id='topic+Adobe.RGB'></span><span id='topic+ACES.RGB'></span>

<h3>Description</h3>

<p>These are 3 built-in <b>colorSpec</b> objects, 
with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'energy-&gt;electrical'</code>.
</p>

<dl>
<dt><code>BT.709.RGB</code></dt><dd><p>a theoretical RGB responder to light.  
The 3 responsivity spectra are constructed so that the RGBs from this theoretical camera, when displayed on an sRGB display after correct EOTF adjustment, would emit light with the same XYZs as the captured scene (up to a constant multiple). 
All three responsivities have negative lobes.</p>
</dd>
<dt><code>Adobe.RGB</code></dt><dd><p>a theoretical RGB responder to light.  
The 3 responsivity spectra are constructed so that the RGBs from this theoretical camera, when displayed on an Adobe RGB display after correct EOTF adjustment, would emit light with the same XYZs as the captured scene (up to a constant multiple).
All three responsivities have negative lobes.</p>
</dd>
<dt><code>ACES.RGB</code></dt><dd><p>a theoretical RGB responder to light.  
Unlike the two above cameras, the responsivities are non-negative and so this camera
could be built, in principle.
These are the ACES RICD (Reference Input Capture Device)  spectral sensitivities.</p>
</dd>
</dl>



<h3>Format</h3>

<p>All are <b>colorSpec</b> objects with <code><a href="#topic+quantity">quantity</a></code> equal to <code>'energy-&gt;electrical'</code> and 3 spectra:
<code>r</code>, <code>g</code>, and <code>b</code>.
The wavelengths are 360 to 830 nm at 1 nm intervals.
</p>


<h3>Details</h3>

<p>All responsitivity spectra are linear combinations of the spectra in <code><a href="#topic+xyz1931.1nm">xyz1931.1nm</a></code>.
These 3 theoretical cameras satisfy the <em>Maxwell-Ives criterion</em> by construction.
<br />
For <code>BT.709.RGB</code> and <code>Adobe.RGB</code>,
the responsivities are scaled so the response to <code><a href="#topic+D65.1nm">D65.1nm</a></code> is RGB=(1,1,1).
These responsivities have negative lobes.
<br />
The BT.709 primaries and white point are the same as those of sRGB (though the EOTF functions are different).  <br />
Adobe RGB and sRGB share the same Red, Blue, and White chromaticities, and only differ in the Green.
This implies that for both cameras the Green output is 0 at Red and Blue, and 1 at White.
This in turn implies that the Green output is identical for both cameras for all input spectra,
and so the Green responsivity spectra are identical for both cameras.
<br />
For <code>ACES.RGB</code> the responsivities are area normalized
as in Annex C of S-2008-001.
They are scaled so that the response to Illuminant E is RGB=(1,1,1).
For an example of white-balancing, as in Annex B,
see the examples below.
</p>


<h3>References</h3>

<p>Poynton, Charles.
<b>Digital Video and HD - Algorithms and Interfaces</b>.
Morgan Kaufmann.
Second Edition. 2012.
Figure 26.5 on page 302.
</p>
<p><b>Academy Color Encoding Specification (ACES)</b>.
S-2008-001.
2011.
Annex B, pp. 23-25.
Annex C, pp. 26-33.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantity">quantity</a>()</code>,
<code><a href="#topic+D65.1nm">D65.1nm</a></code>,
<code><a href="#topic+xyz1931.1nm">xyz1931.1nm</a></code>,
<code><a href="#topic+ptransform">ptransform</a>()</code>,
<code><a href="#topic+calibrate">calibrate</a>()</code>,
vignette <a href="../doc/blueflame.pdf"><b>Blue Flame and Green Comet</b></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######    BT.709.RGB is created using the following recipe  ########
P = matrix( c(0.64,0.33,NA,  0.3,0.6,NA, 0.15,0.06,NA ), 3, 3, byrow=TRUE )
rownames(P) = c('R','G','B')    
BT.709.RGB  = ptransform( xyz1931.1nm, P, D65.1nm )  
quantity(BT.709.RGB) = "energy-&gt;electrical"

#######    Adobe.RGB recipe is the same, except for the matrix P  ########
P = matrix( c(0.64,0.33,NA,  0.21,0.71,NA, 0.15,0.06,NA ), 3, 3, byrow=TRUE )
rownames(P) = c('R','G','B')    
Adobe.RGB  = ptransform( xyz1931.1nm, P, D65.1nm )  
quantity(Adobe.RGB) = "energy-&gt;electrical"

#######  white-balancing ACES.RGB for CIE Standard Illuminant D60 ########
# in a scene illuminated by daylight illuminant D6003,
# and with a perfect-reflecting-diffuser in that scene,
# object 'camera1' would have response RGB=(1,1,1) for that diffuser.
D6003 = daylightSpectra( 6000*1.4388/1.4380, wavelength=wavelength(ACES.RGB) )
camera1 = calibrate( ACES.RGB, D6003, 1, method='scaling' )
</code></pre>

<hr>
<h2 id='wavelength'>wavelength vector of a colorSpec object</h2><span id='topic+wavelength'></span><span id='topic+wavelength+3C-'></span><span id='topic+numWavelengths'></span><span id='topic+is.regular'></span><span id='topic+step.wl'></span><span id='topic+wavelength.colorSpec'></span><span id='topic+wavelength+3C-.colorSpec'></span><span id='topic+numWavelengths.colorSpec'></span><span id='topic+is.regular.colorSpec'></span><span id='topic+step.wl.colorSpec'></span>

<h3>Description</h3>

<p>Retrieve or set the wavelengths of a <b>colorSpec</b> object.  
Retrieve the number of wavelengths, and whether the wavelength sequence is regular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colorSpec'
wavelength(x)

## S3 replacement method for class 'colorSpec'
wavelength(x) &lt;- value

## S3 method for class 'colorSpec'
numWavelengths(x)

## S3 method for class 'colorSpec'
is.regular(x)
step.wl(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wavelength_+3A_x">x</code></td>
<td>
<p>a <b>colorSpec</b> <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="wavelength_+3A_value">value</code></td>
<td>
<p>a numeric vector with length equal to the number of wavelengths in <code>x</code>.  
The wavelengths must be increasing. The unit must be nanometers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>organization</code> of <code>x</code> is <code>'df.col'</code>, then <code>x</code> is a <code>data.frame</code>
and the wavelength vector is stored in the first column of <code>x</code>.<br />
Otherwise, the wavelength vector is stored as <code>attr(x,'wavelength')</code>.
</p>


<h3>Value</h3>

<p><code>wavelength()</code> returns a numeric vector with the wavelengths of the spectra, in nanometers.
</p>
<p><code>numWavelengths(x)</code> is equal to <code>length(wavelength(x))</code> but much more efficient.
</p>
<p><code>is.regular()</code> returns <code>TRUE</code> or <code>FALSE</code>,
depending on whether the step between consecutive wavelengths is a constant.
A truncation error of 1.e-6 nm is tolerated here.  
For example, the X-Rite ColorMunki spectrometer in hi-res mode has a step of 3.33333nm, 
and it is considered regular.
</p>
<p><code>step.wl()</code> returns the <em>mean</em> step in nm,
whether the wavelengths are regular or not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorSpec">colorSpec</a></code> 
</p>

<hr>
<h2 id='xyz1931'>
CIE Color Matching Functions - 2-degree (1931)
</h2><span id='topic+xyz1931.1nm'></span><span id='topic+xyz1931.5nm'></span><span id='topic+xyz1931'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>xyz1931.1nm</code> </td><td style="text-align: left;"> the 1931 2° functions from 360 to 830 nm, at 1nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>xyz1931.5nm</code> </td><td style="text-align: left;"> the 1931 2° functions from 380 to 780 nm, at 5nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Format</h3>

<p>Each is a <b>colorSpec</b> object organized as a matrix with 3 variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>x</code> </td><td style="text-align: left;"> the x-bar responsivity function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>y</code> </td><td style="text-align: left;"> the y-bar responsivity function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>z</code> </td><td style="text-align: left;"> the z-bar responsivity function </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p><a href="http://www.cvrl.org">http://www.cvrl.org</a>
</p>


<h3>References</h3>

<p>Günther Wyszecki and W.S. Stiles.
<b>Color Science : Concepts and Methods, Quantitative Data and Formulae</b>.
Second Edition.
Wiley-Interscience. 1982.
Table I(3.3.1).
pp. 723-735.
</p>
<p>ASTM E 308 - 01.
Standard Practice for Computing the Colors of Objects by Using the CIE System.
Table 1 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyz1964">xyz1964</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(xyz1931.1nm)
white.point = product( D65.1nm, xyz1931.1nm, wave='auto' )
</code></pre>

<hr>
<h2 id='xyz1964'>
CIE Color Matching Functions - 10-degree (1964)
</h2><span id='topic+xyz1964'></span><span id='topic+xyz1964.1nm'></span><span id='topic+xyz1964.5nm'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>xyz1964.1nm</code> </td><td style="text-align: left;"> the 10° 1964 functions from 360 to 830 nm, at 1nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>xyz1964.5nm</code> </td><td style="text-align: left;"> the 10° 1964 functions from 380 to 780 nm, at 5nm intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Format</h3>

<p>Each is a <b>colorSpec</b> object organized as a matrix with 3 columns.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>x</code> </td><td style="text-align: left;"> the x-bar responsivity function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>y</code> </td><td style="text-align: left;"> the y-bar responsivity function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>z</code> </td><td style="text-align: left;"> the z-bar responsivity function </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p><a href="http://www.cvrl.org">http://www.cvrl.org</a>
</p>


<h3>References</h3>

<p>Günther Wyszecki and W.S. Stiles.
<b>Color Science : Concepts and Methods, Quantitative Data and Formulae</b>.
Second Edition.
Wiley-Interscience. 1982.
Table I(3.3.1).
pp. 723-735.
</p>
<p>ASTM E 308 - 01.
Standard Practice for Computing the Colors of Objects by Using the CIE System.
Table 1 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyz1931">xyz1931</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(xyz1964.1nm)
white.point = product( D65.1nm, xyz1964.1nm, wave='auto' )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
