<!DOCTYPE html><html><head><title>Help for package TSCS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TSCS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#appraisal_index'><p>Compute Appraisal Index of Interpolation/Prediction Result</p></a></li>
<li><a href='#plot_compare'><p>Graphic Comparison Between Estimates and True Values</p></a></li>
<li><a href='#plot_dif'><p>Plot Interior Spatial Locations and System Boundary - 2D Map</p></a></li>
<li><a href='#plot_map'><p>Visualize Spatial(Cross-Section) Data of a Given Time Point - 2D Map</p></a></li>
<li><a href='#plot_NA'><p>Visualize the Spatial Distribution of Missing Observations - 2D Map</p></a></li>
<li><a href='#plot3D_dif'><p>Plot Interior Spatial Locations and System Boundary - 3D Map</p></a></li>
<li><a href='#plot3D_map'><p>Visualize Spatial(Cross-Section) Data of a Given Time Point - 3D Map</p></a></li>
<li><a href='#plot3D_NA'><p>Visualize the Spatial Distribution of Missing Observations - 3D Map</p></a></li>
<li><a href='#TSCS'><p>A Package for TSCS Spatial Interpolation Method</p></a></li>
<li><a href='#tscsEstimate'><p>The Second Step of TSCS for 2D Rectangular Grid System - Estimation</p></a></li>
<li><a href='#tscsEstimate3D'><p>The Second Step of TSCS for 3D Rectangular Grid System - Estimation</p></a></li>
<li><a href='#tscsRegression'><p>The First Step of TSCS for 2D Rectangular Grid System - Regression</p></a></li>
<li><a href='#tscsRegression3D'><p>The First Step of TSCS for 3D Rectangular Grid System - Regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Cointegrated System</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tianjian Yang &lt;yangtj5@mail2.sysu.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions to implement Time Series Cointegrated System (TSCS)
    spatial interpolation and relevant data visualization.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2 (&ge; 2.2.1), tseries (&ge; 0.10-42), rgl (&ge;
0.98.1), grDevices</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-10-02 11:11:52 UTC; MSI</td>
</tr>
<tr>
<td>Author:</td>
<td>Tianjian Yang [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-10-02 11:19:48 UTC</td>
</tr>
</table>
<hr>
<h2 id='appraisal_index'>Compute Appraisal Index of Interpolation/Prediction Result</h2><span id='topic+appraisal_index'></span>

<h3>Description</h3>

<p>Two appraisal indexes used for evaluating the result of interpolation/prediction - RMSE and
standard deviation of error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appraisal_index(est, true)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appraisal_index_+3A_est">est</code></td>
<td>
<p>a numeric vector; estimations.</p>
</td></tr>
<tr><td><code id="appraisal_index_+3A_true">true</code></td>
<td>
<p>a numeric vector; true values.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The first appraisal index is RMSE, abbr. of root-mean-square error. It is used for measuring the differences
between estimated values by a method and the values actually observed. Smaller RMSE means more accurate
interpolation/prediction.
</p>
</li>
<li><p> The second appraisal index is standard deviation of error, which is used for measuring how far the errors
are spread out from their mean, namely, stability of errors. Smaller value means greater stability of errors,
suggesting that errors would not fluctuate heavily due to difference of data.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of 2 is returned, including:
</p>

<dl>
<dt><code>RMSE</code></dt><dd><p>numeric; RMSE.</p>
</dd>
<dt><code>std</code></dt><dd><p>numeric; standard deviation of error.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+plot_compare">plot_compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression(data = data, h = 1, v = 1, alpha = 0.01); # regression
basis$percentage # see the percentage of cointegrated relationships
est &lt;- tscsEstimate(matrix = basis$coef_matrix, newdata = newdata, h = 1, v = 1); # estimation
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,3], true = true) # graphic comparison
index &lt;- appraisal_index(est = est$estimate[,3], true = true); # RMSE &amp; std
index

## data visualization:

plot_dif(data = data[,1:2], h = 1, v = 1) # differentiate boundary and interior spatial locations
plot_NA(newdata = newdata) # show spatial locations with missing value, for a cross-section data
plot_map(newdata = newdata) # plot the 2D spatial map, for a cross-section data

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_compare'>Graphic Comparison Between Estimates and True Values</h2><span id='topic+plot_compare'></span>

<h3>Description</h3>

<p>Provided that you have the true values of missing observations, you can compare them
with the results of interpolation. <code>plot_compare</code> visualizes the comparison
between estimates and true values. (NB: this plotting function can also be used
in other similar situations involving comparison between estimates and true values.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_compare(est, true, cex = 1, width = 1, P = 6/7, AI = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_compare_+3A_est">est</code></td>
<td>
<p>a numeric vector; estimations.</p>
</td></tr>
<tr><td><code id="plot_compare_+3A_true">true</code></td>
<td>
<p>a numeric vector; true values.</p>
</td></tr>
<tr><td><code id="plot_compare_+3A_cex">cex</code></td>
<td>
<p>numeric; size of point to be plotted. (default: 1)</p>
</td></tr>
<tr><td><code id="plot_compare_+3A_width">width</code></td>
<td>
<p>numeric; width of fitted straight line. (default: 1)</p>
</td></tr>
<tr><td><code id="plot_compare_+3A_p">P</code></td>
<td>
<p>numeric, between 0 and 1; position for superimposing values of appraisal indexes. (default: 6/7)</p>
</td></tr>
<tr><td><code id="plot_compare_+3A_ai">AI</code></td>
<td>
<p>logical; <code>TRUE</code> for presenting appraisal indexes while <code>FALSE</code> for not. (default: TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attentions:
</p>

<ul>
<li><p> The values in <code>est</code> and <code>true</code> vectors should be arranged in the same order,
in correspondence with the sequence of observations.
</p>
</li>
<li><p> If the maximum value of either <code>est</code> or <code>true</code> is greater than 1000, or the
minimum is smaller than -1000, please make appropriate transformation that limits your data
to bound [-1000,1000].
</p>
</li></ul>

<p>In the plot:
</p>

<ul>
<li><p> The big red point is the origin.
</p>
</li>
<li><p> The red line stands for straight line <code>y = x</code>.
</p>
</li>
<li><p> The blue line stands for fitted straight line.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+appraisal_index">appraisal_index</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression(data = data, h = 1, v = 1, alpha = 0.01) # regression
basis$percentage # see the percentage of cointegrated relationships
est &lt;- tscsEstimate(matrix = basis$coef_matrix, newdata = newdata, h = 1, v = 1) # estimation
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,3], true = true) # graphic comparison
index &lt;- appraisal_index(est = est$estimate[,3], true = true); # RMSE &amp; std
index

## data visualization:

plot_dif(data = data[,1:2], h = 1, v = 1) # differentiate boundary and interior spatial locations
plot_NA(newdata = newdata) # show spatial locations with missing value, for a cross-section data
plot_map(newdata = newdata) # plot the 2D spatial map, for a cross-section data

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_dif'>Plot Interior Spatial Locations and System Boundary - 2D Map</h2><span id='topic+plot_dif'></span>

<h3>Description</h3>

<p><code>plot_dif</code> differentiates boundary and interior spatial locations in a spatial domain (a collection of
spatial locations with their coordinates). Since TSCS method is only capable of interpolation but not
extrapolation, it is necessary to highlight the difference between interior spatial locations and system boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dif(coords, h, v, xlab = NULL, ylab = NULL, title = NULL, cex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dif_+3A_coords">coords</code></td>
<td>
<p>data frame; should only contain the two variables: X coordinate and Y coordinate. Each row uniquely
denotes a spatial location. (coordinates must be numeric)</p>
</td></tr>
<tr><td><code id="plot_dif_+3A_h">h</code></td>
<td>
<p>numeric; side length of the unit grid in X coordinate direction.</p>
</td></tr>
<tr><td><code id="plot_dif_+3A_v">v</code></td>
<td>
<p>numeric; side length of the unit grid in Y coordinate direction.</p>
</td></tr>
<tr><td><code id="plot_dif_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to the name of X coordinate.</p>
</td></tr>
<tr><td><code id="plot_dif_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to the name of Y coordinate.</p>
</td></tr>
<tr><td><code id="plot_dif_+3A_title">title</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_dif_+3A_cex">cex</code></td>
<td>
<p>numeric; size of plotting point for each spatial location. (default: 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_dif</code> is exclusive to 2D rectangular grid system. Similarly, if you want to fathom how this package
handles 3D rectangular grid system, please refer to <code>plot3D_dif</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3D_dif">plot3D_dif</a></code>, <code><a href="#topic+plot_NA">plot_NA</a></code>, <code><a href="#topic+plot_map">plot_map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression(data = data, h = 1, v = 1, alpha = 0.01); # regression
basis$percentage # see the percentage of cointegrated relationships
est &lt;- tscsEstimate(matrix = basis$coef_matrix, newdata = newdata, h = 1, v = 1); # estimation
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,3], true = true) # graphic comparison
index &lt;- appraisal_index(est = est$estimate[,3], true = true); # RMSE &amp; std
index

## data visualization:

plot_dif(data = data[,1:2], h = 1, v = 1) # differentiate boundary and interior spatial locations
plot_NA(newdata = newdata) # show spatial locations with missing value, for a cross-section data
plot_map(newdata = newdata) # plot the 2D spatial map, for a cross-section data

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_map'>Visualize Spatial(Cross-Section) Data of a Given Time Point - 2D Map</h2><span id='topic+plot_map'></span>

<h3>Description</h3>

<p><code>plot_map</code> draws a two-dimensional spatial map. It is plotted based on the cross-section data
of a given time point, which is also often extracted from spatio-temporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_map(newdata, xlab = NULL, ylab = NULL, title = NULL, cex = 2,
  shape = 15, low = "blue", mid = "yellow", high = "red",
  na.value = "white", midpoint = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_map_+3A_newdata">newdata</code></td>
<td>
<p>data frame; should only contain the three variables in order: X coordinate, Y coordinate and observation.
This is the cross-section data or pure spatial data of a particular time point you have selected,
with missing observations that you want to predict. (coordinates must be numeric)</p>
</td></tr>
<tr><td><code id="plot_map_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to the name of X coordinate.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to the name of Y coordinate.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title">title</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_cex">cex</code></td>
<td>
<p>numeric; size of plotting point for each spatial locations. (default: 2)</p>
</td></tr>
<tr><td><code id="plot_map_+3A_shape">shape</code></td>
<td>
<p>either an integer specifying a symbol or a single character to be used as the default
in plotting points. (default: 15)</p>
</td></tr>
<tr><td><code id="plot_map_+3A_low">low</code>, <code id="plot_map_+3A_high">high</code></td>
<td>
<p>colours for low and high ends of the gradient. (default: &quot;blue&quot;,&quot;red&quot;)</p>
</td></tr>
<tr><td><code id="plot_map_+3A_mid">mid</code></td>
<td>
<p>colour for midpoint of the gradient. (default: &quot;yellow&quot;)</p>
</td></tr>
<tr><td><code id="plot_map_+3A_na.value">na.value</code></td>
<td>
<p>colour for missing values/observations. (default: &quot;white&quot;)</p>
</td></tr>
<tr><td><code id="plot_map_+3A_midpoint">midpoint</code></td>
<td>
<p>numeric; the midpoint of the gradient scale, defaults to the midpoint value of index presented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_map</code> is exclusive to 2D rectangular grid system. Similarly, if you want to fathom how this package
handles 3D rectangular grid system, please refer to <code>plot3D_map</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3D_map">plot3D_map</a></code>, <code><a href="#topic+plot_NA">plot_NA</a></code>, <code><a href="#topic+plot_dif">plot_dif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression(data = data, h = 1, v = 1, alpha = 0.01); # regression
basis$percentage # see the percentage of cointegrated relationships
est &lt;- tscsEstimate(matrix = basis$coef_matrix, newdata = newdata, h = 1, v = 1); # estimation
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,3], true = true) # graphic comparison
index &lt;- appraisal_index(est = est$estimate[,3], true = true); # RMSE &amp; std
index

## data visualization:

plot_dif(data = data[,1:2], h = 1, v = 1) # differentiate boundary and interior spatial locations
plot_NA(newdata = newdata) # show spatial locations with missing value, for a cross-section data
plot_map(newdata = newdata) # plot the 2D spatial map, for a cross-section data

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_NA'>Visualize the Spatial Distribution of Missing Observations - 2D Map</h2><span id='topic+plot_NA'></span>

<h3>Description</h3>

<p><code>plot_NA</code> shows spatial locations with or without missing observation. It is plotted based on
the cross-section data of a given time point, which is also often extracted from spatio-temporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_NA(newdata, xlab = NULL, ylab = NULL, title = NULL, cex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_NA_+3A_newdata">newdata</code></td>
<td>
<p>data frame; should only contain the three variables in order: X coordinate, Y coordinate and observation.
This is the cross-section data or pure spatial data of a particular time point you have selected,
with missing observations that you want to predict. (coordinates must be numeric)</p>
</td></tr>
<tr><td><code id="plot_NA_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to the name of X coordinate.</p>
</td></tr>
<tr><td><code id="plot_NA_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to the name of Y coordinate.</p>
</td></tr>
<tr><td><code id="plot_NA_+3A_title">title</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_NA_+3A_cex">cex</code></td>
<td>
<p>numeric; size of plotting point for each spatial location. (default: 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_NA</code> is exclusive to 2D rectangular grid system. Similarly, if you want to fathom how this package
handles 3D rectangular grid system, please refer to <code>plot3D_NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3D_NA">plot3D_NA</a></code>, <code><a href="#topic+plot_map">plot_map</a></code>, <code><a href="#topic+plot_dif">plot_dif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression(data = data, h = 1, v = 1, alpha = 0.01); # regression
basis$percentage # see the percentage of cointegrated relationships
est &lt;- tscsEstimate(matrix = basis$coef_matrix, newdata = newdata, h = 1, v = 1); # estimation
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,3], true = true) # graphic comparison
index &lt;- appraisal_index(est = est$estimate[,3], true = true); # RMSE &amp; std
index

## data visualization:

plot_dif(data = data[,1:2], h = 1, v = 1) # differentiate boundary and interior spatial locations
plot_NA(newdata = newdata) # show spatial locations with missing value, for a cross-section data
plot_map(newdata = newdata) # plot the 2D spatial map, for a cross-section data

## End(Not run)
</code></pre>

<hr>
<h2 id='plot3D_dif'>Plot Interior Spatial Locations and System Boundary - 3D Map</h2><span id='topic+plot3D_dif'></span>

<h3>Description</h3>

<p><code>plot3D_dif</code> differentiates boundary and interior spatial locations in a spatial domain (a collection of
spatial locations with their coordinates). Since TSCS method is only capable of interpolation but not
extrapolation, it is necessary to highlight the difference between interior spatial locations and system boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3D_dif(coords, h1, h2, v, xlab = NULL, ylab = NULL, zlab = NULL,
  title = NULL, cex = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3D_dif_+3A_coords">coords</code></td>
<td>
<p>data frame; should only contain the three variables: X coordinate, Y coordinate and Z coordinate.
Each row uniquely denotes a spatial location. (coordinates must be numeric)</p>
</td></tr>
<tr><td><code id="plot3D_dif_+3A_h1">h1</code></td>
<td>
<p>numeric; side length of the unit cubic grid in X coordinate direction (horizontal).</p>
</td></tr>
<tr><td><code id="plot3D_dif_+3A_h2">h2</code></td>
<td>
<p>numeric; side length of the unit cubic grid in Y coordinate direction (horizontal).</p>
</td></tr>
<tr><td><code id="plot3D_dif_+3A_v">v</code></td>
<td>
<p>numeric; side length of the unit cubic grid in Z coordinate direction (vertical).</p>
</td></tr>
<tr><td><code id="plot3D_dif_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to the name of X coordinate.</p>
</td></tr>
<tr><td><code id="plot3D_dif_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to the name of Y coordinate.</p>
</td></tr>
<tr><td><code id="plot3D_dif_+3A_zlab">zlab</code></td>
<td>
<p>a label for the z axis, defaults to the name of Z coordinate.</p>
</td></tr>
<tr><td><code id="plot3D_dif_+3A_title">title</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot3D_dif_+3A_cex">cex</code></td>
<td>
<p>numeric; size of point to be plotted for each spatial location. (default: 3)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The resulting plot is interactive, where the red points are interior spatial locations
while the black points denote system boundary.
</p>
</li>
<li> <p><code>plot3D_dif</code> is exclusive to 3D rectangular grid system. Similarly, if you want to fathom how
this package handles 2D rectangular grid system, please refer to <code>plot_dif</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot_dif">plot_dif</a></code>, <code><a href="#topic+plot3D_NA">plot3D_NA</a></code>, <code><a href="#topic+plot3D_map">plot3D_map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression3D(data = data, h1 = 3.75, h2 = 2.5, v = 5, alpha = 0.01);
basis$percentage
est &lt;- tscsEstimate3D(matrix = basis$coef_matrix, newdata = newdata, h1 = 3.75, h2 = 2.5, v = 5);
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,4], true = true)
index &lt;- appraisal_index(est = est$estimate[,4], true = true);
index

## data visualization:

plot3D_dif(data = data[,1:3], h1 = 3.75, h2 = 2.5, v = 5)
plot3D_NA(newdata = newdata)
plot3D_map(newdata = newdata)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot3D_map'>Visualize Spatial(Cross-Section) Data of a Given Time Point - 3D Map</h2><span id='topic+plot3D_map'></span>

<h3>Description</h3>

<p><code>plot_map</code> draws a three-dimensional spatial map. It is plotted based on the cross-section data
of a given time point, which is also often extracted from spatio-temporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3D_map(newdata, xlab = NULL, ylab = NULL, zlab = NULL, title = NULL,
  cex = 9, colorNA = "white")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3D_map_+3A_newdata">newdata</code></td>
<td>
<p>data frame; should only contain the four variables in order: X coordinate, Y coordinate, Z coordinate
and observation. This is the cross-section data or pure spatial data of a particular time point you have selected,
with missing observations that you want to predict. (coordinates must be numeric)</p>
</td></tr>
<tr><td><code id="plot3D_map_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to the name of X coordinate.</p>
</td></tr>
<tr><td><code id="plot3D_map_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to the name of Y coordinate.</p>
</td></tr>
<tr><td><code id="plot3D_map_+3A_zlab">zlab</code></td>
<td>
<p>a label for the z axis, defaults to the name of Z coordinate.</p>
</td></tr>
<tr><td><code id="plot3D_map_+3A_title">title</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot3D_map_+3A_cex">cex</code></td>
<td>
<p>numeric; size of plotting point for each spatial locations. (default: 9)</p>
</td></tr>
<tr><td><code id="plot3D_map_+3A_colorna">colorNA</code></td>
<td>
<p>colour for missing values/observations. (default: &quot;white&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The resulting plot is interactive.
</p>
</li>
<li> <p><code>plot3D_map</code> is exclusive to 3D rectangular grid system. Similarly, if you want to fathom how
this package handles 2D rectangular grid system, please refer to <code>plot_map</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot_map">plot_map</a></code>, <code><a href="#topic+plot3D_NA">plot3D_NA</a></code>, <code><a href="#topic+plot3D_dif">plot3D_dif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression3D(data = data, h1 = 3.75, h2 = 2.5, v = 5, alpha = 0.01);
basis$percentage
est &lt;- tscsEstimate3D(matrix = basis$coef_matrix, newdata = newdata, h1 = 3.75, h2 = 2.5, v = 5);
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,4], true = true)
index &lt;- appraisal_index(est = est$estimate[,4], true = true);
index

## data visualization:

plot3D_dif(data = data[,1:3], h1 = 3.75, h2 = 2.5, v = 5)
plot3D_NA(newdata = newdata)
plot3D_map(newdata = newdata)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot3D_NA'>Visualize the Spatial Distribution of Missing Observations - 3D Map</h2><span id='topic+plot3D_NA'></span>

<h3>Description</h3>

<p><code>plot3D_NA</code> shows spatial locations with or without missing observation. It is plotted based on
the cross-section data of a given time point, which is also often extracted from spatio-temporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3D_NA(newdata, xlab = NULL, ylab = NULL, zlab = NULL, title = NULL,
  cex = 3, color = "orange", colorNA = "blue")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3D_NA_+3A_newdata">newdata</code></td>
<td>
<p>data frame; should only contain the four variables in order: X coordinate, Y coordinate, Z coordinate
and observation. This is the cross-section data or pure spatial data of a particular time point you have selected,
with missing observations that you want to predict. (coordinates must be numeric)</p>
</td></tr>
<tr><td><code id="plot3D_NA_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to the name of X coordinate.</p>
</td></tr>
<tr><td><code id="plot3D_NA_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to the name of Y coordinate.</p>
</td></tr>
<tr><td><code id="plot3D_NA_+3A_zlab">zlab</code></td>
<td>
<p>a label for the z axis, defaults to the name of Z coordinate.</p>
</td></tr>
<tr><td><code id="plot3D_NA_+3A_title">title</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot3D_NA_+3A_cex">cex</code></td>
<td>
<p>numeric; size of plotting point for each spatial location. (default: 3)</p>
</td></tr>
<tr><td><code id="plot3D_NA_+3A_color">color</code></td>
<td>
<p>colour to be used to fill the spatial locations. (default: &quot;orange&quot;)</p>
</td></tr>
<tr><td><code id="plot3D_NA_+3A_colorna">colorNA</code></td>
<td>
<p>colour for denoting missing values/observations. (default: &quot;blue&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The resulting plot is interactive.
</p>
</li>
<li> <p><code>plot3D_NA</code> is exclusive to 3D rectangular grid system. Similarly, if you want to fathom how
this package handles 2D rectangular grid system, please refer to <code>plot_NA</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot_NA">plot_NA</a></code>, <code><a href="#topic+plot3D_map">plot3D_map</a></code>, <code><a href="#topic+plot3D_dif">plot3D_dif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression3D(data = data, h1 = 3.75, h2 = 2.5, v = 5, alpha = 0.01);
basis$percentage
est &lt;- tscsEstimate3D(matrix = basis$coef_matrix, newdata = newdata, h1 = 3.75, h2 = 2.5, v = 5);
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,4], true = true)
index &lt;- appraisal_index(est = est$estimate[,4], true = true);
index

## data visualization:

plot3D_dif(data = data[,1:3], h1 = 3.75, h2 = 2.5, v = 5)
plot3D_NA(newdata = newdata)
plot3D_map(newdata = newdata)

## End(Not run)
</code></pre>

<hr>
<h2 id='TSCS'>A Package for TSCS Spatial Interpolation Method</h2><span id='topic+TSCS'></span><span id='topic+TSCS-package'></span>

<h3>Description</h3>

<p>This package provides functions to implement TSCS spatial interpolation and
relevant data visualization. For TSCS method, the current version is only able to
make use of spatio-temporal data whose spatial domain is a 2D or 3D rectangular grid system.
</p>


<h3>Details</h3>


<ol>
<li><p> TSCS (abbr. of Time Series Cointegrated System) method is a spatial
interpolation method based on analysis of historical spatio-temporal data.
It can be regarded as a desirable alternative to spatio-temporal interpolation
in some cases where we merely intend to interpolate a series of cross-section data
at each observed time point for a given spatial domain.
</p>
</li>
<li><p> The basic assumption of TSCS method is that, for any spatial location within
the spatial domain of spatio-temporal data, its time series and the time series of
its adjacent spatial locations are cointegrated (long-term equilibrium relationships).
</p>
</li>
<li><p> As to TSCS method, package of the current version is only able to make use of
spatio-temporal data whose spatial domain is a 2D or 3D rectangular grid system.
</p>
</li></ol>



<h3>Package Functions</h3>


<ul>
<li> <p><code>tscsRegression, tscsRegression3D</code> : obtains regression coefficient matrix, the first step of
TSCS for 2D and 3D rectangular grid system respectively.
</p>
</li>
<li> <p><code>tscsEstimate, tscsEstimate3D</code> : estimates the missing observations within a cross-section data
(pure spatial data) of a particular time point you have selected, the second step of TSCS for 2D and 3D
rectangular grid system respectively.
</p>
</li>
<li> <p><code>plot_dif, plot3D_dif</code> : differentiates boundary and interior spatial locations in a spatial domain.
</p>
</li>
<li> <p><code>plot_NA, plot3D_NA</code> : shows spatial locations with or without missing observation in a spatial domain.
</p>
</li>
<li> <p><code>plot_map, plot3D_map</code> : draws the spatial map for a cross-section data.
</p>
</li>
<li> <p><code>plot_compare</code> : visualizes the comparison between estimates and true values (if you have).
</p>
</li>
<li> <p><code>appraisal_index</code> : computes the two appraisal indexes used for evaluating the result of
interpolation/prediction - RMSE and standard deviation of error. (if you have the true values)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tianjian Yang &lt;yangtj5@mail2.sysu.edu.cn&gt;
</p>

<hr>
<h2 id='tscsEstimate'>The Second Step of TSCS for 2D Rectangular Grid System - Estimation</h2><span id='topic+tscsEstimate'></span>

<h3>Description</h3>

<p><code>tscsEstimate</code> estimates the missing observations within the cross-section data (pure spatial data)
of a particular time point you have selected, namely, the interpolation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tscsEstimate(matrix, newdata, h, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tscsEstimate_+3A_matrix">matrix</code></td>
<td>
<p>data frame; the first return value <code>coef_matrix</code> of function <code>tscsRegression</code>
in the first step of TSCS.</p>
</td></tr>
<tr><td><code id="tscsEstimate_+3A_newdata">newdata</code></td>
<td>
<p>data frame; should only contain the three variables in order: X coordinate, Y coordinate and observation.
This is the cross-section data or pure spatial data of a particular time point you have selected,
with missing observations that you want to predict. (coordinates must be numeric)</p>
</td></tr>
<tr><td><code id="tscsEstimate_+3A_h">h</code></td>
<td>
<p>numeric; side length of the unit grid in X coordinate direction.</p>
</td></tr>
<tr><td><code id="tscsEstimate_+3A_v">v</code></td>
<td>
<p>numeric; side length of the unit grid in Y coordinate direction.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The first step of TSCS spatial interpolation should be carried out by function <code>tscsRegression</code>,
which is the prerequisite of <code>tscsEstimate</code>.
</p>
</li>
<li><p> For 3D rectangular grid system, the procedure of TSCS stays the same.
Please see <code>tscsRegression3D</code> and <code>tscsEstimate3D</code>.
</p>
</li>
<li><p> Attentions:
Since TSCS is only capable of interpolation but not extrapolation, please make sure that
the missing observations in a given spatial domain are all located at interior spatial locations.
Otherwise, extrapolation would occur with an error following.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of 3 is returned, including:
</p>

<dl>
<dt><code>estimate</code></dt><dd><p>data frame; estimate of missing observations which contains the 3 variables in order:
X coordinate, Y coordinate and estimation.</p>
</dd>
<dt><code>complete</code></dt><dd><p>data frame; an updated version of the cross-section data (pure spatial data) <code>newdata</code>,
with all of its missing observations interpolated.</p>
</dd>
<dt><code>NA_id</code></dt><dd><p>an integer vector; reveals the instance ID, in data frame <code>newdata</code>,
of spatial locations with missing observation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tscsRegression">tscsRegression</a></code>, <code><a href="#topic+tscsEstimate3D">tscsEstimate3D</a></code>, <code><a href="#topic+plot_NA">plot_NA</a></code>, <code><a href="#topic+plot_map">plot_map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression(data = data, h = 1, v = 1, alpha = 0.01); # regression
basis$percentage # see the percentage of cointegrated relationships
est &lt;- tscsEstimate(matrix = basis$coef_matrix, newdata = newdata, h = 1, v = 1); # estimation
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,3], true = true) # graphic comparison
index &lt;- appraisal_index(est = est$estimate[,3], true = true); # RMSE &amp; std
index

## data visualization:

plot_dif(data = data[,1:2], h = 1, v = 1) # differentiate boundary and interior spatial locations
plot_NA(newdata = newdata) # show spatial locations with missing value, for a cross-section data
plot_map(newdata = newdata) # plot the 2D spatial map, for a cross-section data

## End(Not run)
</code></pre>

<hr>
<h2 id='tscsEstimate3D'>The Second Step of TSCS for 3D Rectangular Grid System - Estimation</h2><span id='topic+tscsEstimate3D'></span>

<h3>Description</h3>

<p><code>tscsEstimate</code> estimates the missing observations within the cross-section data (pure spatial data)
of a particular time point you have selected, namely, the interpolation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tscsEstimate3D(matrix, newdata, h1, h2, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tscsEstimate3D_+3A_matrix">matrix</code></td>
<td>
<p>data frame; the first return value <code>coef_matrix</code> of function <code>tscsRegression3D</code>
in the first step of TSCS.</p>
</td></tr>
<tr><td><code id="tscsEstimate3D_+3A_newdata">newdata</code></td>
<td>
<p>data frame; should only contain the four variables in order: X coordinate, Y coordinate, Z coordinate
and observation. This is the cross-section data or pure spatial data of a particular time point you have selected,
with missing observations that you want to predict. (coordinates must be numeric)</p>
</td></tr>
<tr><td><code id="tscsEstimate3D_+3A_h1">h1</code></td>
<td>
<p>numeric; side length of the unit cubic grid in X coordinate direction (horizontal).</p>
</td></tr>
<tr><td><code id="tscsEstimate3D_+3A_h2">h2</code></td>
<td>
<p>numeric; side length of the unit cubic grid in Y coordinate direction (horizontal).</p>
</td></tr>
<tr><td><code id="tscsEstimate3D_+3A_v">v</code></td>
<td>
<p>numeric; side length of the unit cubic grid in Z coordinate direction (vertical).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The first step of TSCS spatial interpolation should be carried out by function <code>tscsRegression3D</code>,
which is the prerequisite of <code>tscsEstimate3D</code>.
</p>
</li>
<li><p> For 2D rectangular grid system, the procedure of TSCS stays the same.
Please see <code>tscsRegression</code> and <code>tscsEstimate</code>.
</p>
</li>
<li><p> Attentions:
Since TSCS is only capable of interpolation but not extrapolation, please make sure that
the missing observations in a given spatial domain are all located at interior spatial locations.
Otherwise, extrapolation would occur with an error following.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of 3 is returned, including:
</p>

<dl>
<dt><code>estimate</code></dt><dd><p>data frame; estimate of missing observations which contains the 4 variables in order:
X coordinate, Y coordinate, Z coordinate and estimation.</p>
</dd>
<dt><code>complete</code></dt><dd><p>data frame; an updated version of the cross-section data (pure spatial data) <code>newdata</code>,
with all of its missing observations interpolated.</p>
</dd>
<dt><code>NA_id</code></dt><dd><p>an integer vector; reveals the instance ID, in data frame <code>newdata</code>,
of spatial locations with missing observation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tscsRegression3D">tscsRegression3D</a></code>, <code><a href="#topic+tscsEstimate">tscsEstimate</a></code>, <code><a href="#topic+plot3D_NA">plot3D_NA</a></code>, <code><a href="#topic+plot3D_map">plot3D_map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression3D(data = data, h1 = 3.75, h2 = 2.5, v = 5, alpha = 0.01);
basis$percentage
est &lt;- tscsEstimate3D(matrix = basis$coef_matrix, newdata = newdata, h1 = 3.75, h2 = 2.5, v = 5);
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,4], true = true)
index &lt;- appraisal_index(est = est$estimate[,4], true = true);
index

## data visualization:

plot3D_dif(data = data[,1:3], h1 = 3.75, h2 = 2.5, v = 5)
plot3D_NA(newdata = newdata)
plot3D_map(newdata = newdata)

## End(Not run)
</code></pre>

<hr>
<h2 id='tscsRegression'>The First Step of TSCS for 2D Rectangular Grid System - Regression</h2><span id='topic+tscsRegression'></span>

<h3>Description</h3>

<p>To implement TSCS spatial interpolation for a spatial domain that is a 2D rectangular grid system,
the first step is obtaining regression coefficient matrix, which can be done
by function <code>tscsRegression</code>. It is the prerequisite of TSCS interpolation process
because the 'matrix' derived from historical spatio-temporal data is the initial value of
the second step - estimating missing observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tscsRegression(data, h, v, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tscsRegression_+3A_data">data</code></td>
<td>
<p>data frame; should contain these variables in order: X coordinate, Y coordinate and observations
as time goes on. That is to say, each row should include X and Y coordinate first, and then a time series.
This is the historical spatio-temporal data that you intend to analyze as the basis for
interpolation later on in <code>tscsEstimate</code>.</p>
</td></tr>
<tr><td><code id="tscsRegression_+3A_h">h</code></td>
<td>
<p>numeric; side length of the unit grid in X coordinate direction.</p>
</td></tr>
<tr><td><code id="tscsRegression_+3A_v">v</code></td>
<td>
<p>numeric; side length of the unit grid in Y coordinate direction.</p>
</td></tr>
<tr><td><code id="tscsRegression_+3A_alpha">alpha</code></td>
<td>
<p>numeric; specify the significance level for ADF test, to test if the time series of a group of
spatial locations are cointegrated. (default: 0.05)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The second step of TSCS spatial interpolation should be carried out by function <code>tscsEstimate</code>,
where you have to input the cross-section data or pure spatial data of a particular time point
you have selected, with missing observations that you want to predict.
</p>
</li>
<li><p> For 3D rectangular grid system, the procedure of TSCS stays the same.
Please see <code>tscsRegression3D</code> and <code>tscsEstimate3D</code>.
</p>
</li>
<li><p> Attentions:
(1) Since TSCS is only capable of interpolation but not extrapolation, it is necessary to highlight the
difference between interior spatial locations and system boundary. Function <code>plot_dif</code> can help.
(2) NA value in historical spatio-temporal data <code>data</code> is not allowed. Please handle them beforehand
(such as filling these NA values through spatio-temporal kriging).
</p>
</li></ul>



<h3>Value</h3>

<p>A list of 2 is returned, including:
</p>

<dl>
<dt><code>coef_matrix</code></dt><dd><p>data frame; regression coefficient matrix to be used as input parameter of function
<code>tscsEstimate</code> in the second step of TSCS interpolation.</p>
</dd>
<dt><code>percentage</code></dt><dd><p>numeric; percentage of cointegrated relationships, a measurement of the degree
it satisfies the assumption of cointegrated system. It is highly affected by parameter <code>alpha</code>,
the significance level you have set. Explicitly, smaller <code>alpha</code> results in smaller <code>percentage</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tscsEstimate">tscsEstimate</a></code>, <code><a href="#topic+tscsRegression3D">tscsRegression3D</a></code>, <code><a href="#topic+plot_dif">plot_dif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression(data = data, h = 1, v = 1, alpha = 0.01); # regression
basis$percentage # see the percentage of cointegrated relationships
est &lt;- tscsEstimate(matrix = basis$coef_matrix, newdata = newdata, h = 1, v = 1); # estimation
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,3], true = true) # graphic comparison
index &lt;- appraisal_index(est = est$estimate[,3], true = true); # RMSE &amp; std
index

## data visualization:

plot_dif(data = data[,1:2], h = 1, v = 1) # differentiate boundary and interior spatial locations
plot_NA(newdata = newdata) # show spatial locations with missing value, for a cross-section data
plot_map(newdata = newdata) # plot the 2D spatial map, for a cross-section data

## End(Not run)
</code></pre>

<hr>
<h2 id='tscsRegression3D'>The First Step of TSCS for 3D Rectangular Grid System - Regression</h2><span id='topic+tscsRegression3D'></span>

<h3>Description</h3>

<p>To implement TSCS spatial interpolation for a spatial domain that is a 3D rectangular grid system,
the first step is obtaining regression coefficient matrix, which can be done
by function <code>tscsRegression3D</code>. It is the prerequisite of TSCS interpolation process
because the 'matrix' derived from historical spatio-temporal data is the initial value of
the second step - estimating missing observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tscsRegression3D(data, h1, h2, v, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tscsRegression3D_+3A_data">data</code></td>
<td>
<p>data frame; should contain these variables in order: X coordinate, Y coordinate, Z coordinate and
observations as time goes on. That is to say, each row should include X, Y and Z coordinate first, and then
a time series. This is the historical spatio-temporal data that you intend to analyze as the basis for
interpolation later on in <code>tscsEstimate3D</code>.</p>
</td></tr>
<tr><td><code id="tscsRegression3D_+3A_h1">h1</code></td>
<td>
<p>numeric; side length of the unit cubic grid in X coordinate direction (horizontal).</p>
</td></tr>
<tr><td><code id="tscsRegression3D_+3A_h2">h2</code></td>
<td>
<p>numeric; side length of the unit cubic grid in Y coordinate direction (horizontal).</p>
</td></tr>
<tr><td><code id="tscsRegression3D_+3A_v">v</code></td>
<td>
<p>numeric; side length of the unit cubic grid in Z coordinate direction (vertical).</p>
</td></tr>
<tr><td><code id="tscsRegression3D_+3A_alpha">alpha</code></td>
<td>
<p>numeric; specify the significance level for ADF test, to test if the time series of a group of
spatial locations are cointegrated. (default: 0.05)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The second step of TSCS spatial interpolation should be carried out by function <code>tscsEstimate3D</code>,
where you have to input the cross-section data or pure spatial data of a particular time point
you have selected, with missing observations that you want to predict.
</p>
</li>
<li><p> For 2D rectangular grid system, the procedure of TSCS stays the same.
Please see <code>tscsRegression</code> and <code>tscsEstimate</code>.
</p>
</li>
<li><p> Attentions:
(1) Since TSCS is only capable of interpolation but not extrapolation, it is necessary to highlight the
difference between interior spatial locations and system boundary. Function <code>plot3D_dif</code> can help.
(2) NA value in historical spatio-temporal data <code>data</code> is not allowed. Please handle them beforehand
(such as filling these NA values through spatio-temporal kriging).
</p>
</li></ul>



<h3>Value</h3>

<p>A list of 2 is returned, including:
</p>

<dl>
<dt><code>coef_matrix</code></dt><dd><p>data frame; regression coefficient matrix to be used as input parameter of function
<code>tscsEstimate</code> in the second step of TSCS interpolation.</p>
</dd>
<dt><code>percentage</code></dt><dd><p>numeric; percentage of cointegrated relationships, a measurement of the degree
it satisfies the assumption of cointegrated system. It is highly affected by parameter <code>alpha</code>,
the significance level you have set. Explicitly, smaller <code>alpha</code> results in smaller <code>percentage</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tscsEstimate3D">tscsEstimate3D</a></code>, <code><a href="#topic+tscsRegression">tscsRegression</a></code>, <code><a href="#topic+plot3D_dif">plot3D_dif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## TSCS spatial interpolation procedure:

basis &lt;- tscsRegression3D(data = data, h1 = 3.75, h2 = 2.5, v = 5, alpha = 0.01);
basis$percentage
est &lt;- tscsEstimate3D(matrix = basis$coef_matrix, newdata = newdata, h1 = 3.75, h2 = 2.5, v = 5);
str(est)

## comparison of estimates and true values:

plot_compare(est = est$estimate[,4], true = true)
index &lt;- appraisal_index(est = est$estimate[,4], true = true);
index

## data visualization:

plot3D_dif(data = data[,1:3], h1 = 3.75, h2 = 2.5, v = 5)
plot3D_NA(newdata = newdata)
plot3D_map(newdata = newdata)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
