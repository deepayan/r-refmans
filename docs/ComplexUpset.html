<!DOCTYPE html><html><head><title>Help for package ComplexUpset</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ComplexUpset}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aes_percentage'><p>Generate mapping for labeling percentages</p></a></li>
<li><a href='#arrange_venn'><p>Arrange points for Venn diagram</p></a></li>
<li><a href='#compare_between_intersections'><p>Compare covariates between intersections</p></a></li>
<li><a href='#create_upset_abc_example'><p>Create an example dataset with three sets: A, B and C</p></a></li>
<li><a href='#geom_venn_circle'><p>Circle for Venn diagram</p></a></li>
<li><a href='#geom_venn_label_region'><p>Label for a region of Venn diagram</p></a></li>
<li><a href='#geom_venn_label_set'><p>Label for a set of Venn diagram</p></a></li>
<li><a href='#geom_venn_region'><p>Region of Venn diagram</p></a></li>
<li><a href='#get_size_mode'><p>Retrieve symbol for given mode that can be used in aesthetics mapping with double bang (<code style="white-space: pre;">&#8288;!!&#8288;</code>)</p></a></li>
<li><a href='#intersection_matrix'><p>Prepare layers for sets sizes plot</p></a></li>
<li><a href='#intersection_ratio'><p>Barplot annotation of relative intersections sizes</p></a></li>
<li><a href='#intersection_size'><p>Barplot annotation of intersections sizes</p></a></li>
<li><a href='#reverse_log_trans'><p>Logarithmic scale for use with <code>upset_set_size()</code></p></a></li>
<li><a href='#scale_color_venn_mix'><p>Color scale for Venn diagram</p></a></li>
<li><a href='#scale_fill_venn_mix'><p>Fill scale for Venn diagram</p></a></li>
<li><a href='#upset'><p>Compose an UpSet plot</p></a></li>
<li><a href='#upset_annotate'><p>Annotation panel shorthand</p></a></li>
<li><a href='#upset_data'><p>Prepare data for UpSet plots</p></a></li>
<li><a href='#upset_default_themes'><p>Default themes modified by specified arguments</p></a></li>
<li><a href='#upset_mode'><p>Layer defining the intersection mode for the data to be displayed</p></a></li>
<li><a href='#upset_modify_themes'><p>Default themes modified by specified component-specific arguments</p></a></li>
<li><a href='#upset_query'><p>Highlight chosen sets or intersections</p></a></li>
<li><a href='#upset_set_size'><p>Prepare layers for sets sizes plot</p></a></li>
<li><a href='#upset_stripes'><p>Define appearence of the stripes</p></a></li>
<li><a href='#upset_test'><p>Test for differences between intersections</p></a></li>
<li><a href='#upset_text_percentage'><p>Generate percentage label of the intersection/union sizes ratio</p></a></li>
<li><a href='#upset_themes'><p>List of default themes for upset components</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Complex UpSet Plots Using 'ggplot2' Components</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>UpSet plots are an improvement over Venn Diagram for set overlap visualizations.
    Striving to bring the best of the 'UpSetR' and 'ggplot2', this package offers a way to create
    complex overlap visualisations, using simple and familiar tools, i.e. geoms of 'ggplot2'.
    For introduction to UpSet concept, see Lex et al. (2014) &lt;<a href="https://doi.org/10.1109%2FTVCG.2014.2346248">doi:10.1109/TVCG.2014.2346248</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/krassowski/complex-upset">https://github.com/krassowski/complex-upset</a>,
<a href="https://krassowski.github.io/complex-upset/">https://krassowski.github.io/complex-upset/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/krassowski/complex-upset/issues">https://github.com/krassowski/complex-upset/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, covr, tibble,
ggplot2movies, vdiffr, jsonlite, data.table</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, patchwork, scales, colorspace</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-10 23:51:20 UTC; krassowski</td>
</tr>
<tr>
<td>Author:</td>
<td>Michał Krassowski <a href="https://orcid.org/0000-0002-9638-7785"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michał Krassowski &lt;krassowski.michal+r@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-11 15:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='aes_percentage'>Generate mapping for labeling percentages</h2><span id='topic+aes_percentage'></span>

<h3>Description</h3>

<p>Generate mapping for labeling percentages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes_percentage(relative_to, digits = 0, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes_percentage_+3A_relative_to">relative_to</code></td>
<td>
<p>defines proportion that should be calculated, relative to <code>'intersection'</code>, <code>'group'</code>, or <code>'all'</code> observed values</p>
</td></tr>
<tr><td><code id="aes_percentage_+3A_digits">digits</code></td>
<td>
<p>number of digits to show (default=0)</p>
</td></tr>
<tr><td><code id="aes_percentage_+3A_sep">sep</code></td>
<td>
<p>separator separator between the digit and percent sign (no separator by default)</p>
</td></tr>
</table>

<hr>
<h2 id='arrange_venn'>Arrange points for Venn diagram</h2><span id='topic+arrange_venn'></span>

<h3>Description</h3>

<p>Arrange points for Venn diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_venn(
  data,
  sets = NULL,
  radius = 1.5,
  max_iterations = 10,
  verbose = FALSE,
  outwards_adjust = 1.3,
  extract_sets = FALSE,
  extract_regions = FALSE,
  repeat_in_intersections = FALSE,
  starting_grid_size = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_venn_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in sets</p>
</td></tr>
<tr><td><code id="arrange_venn_+3A_sets">sets</code></td>
<td>
<p>vector with names of columns representing membership in sets</p>
</td></tr>
<tr><td><code id="arrange_venn_+3A_radius">radius</code></td>
<td>
<p>the radius of the circle</p>
</td></tr>
<tr><td><code id="arrange_venn_+3A_max_iterations">max_iterations</code></td>
<td>
<p>the maximal number of iterations</p>
</td></tr>
<tr><td><code id="arrange_venn_+3A_verbose">verbose</code></td>
<td>
<p>should debugging notes be printed?</p>
</td></tr>
<tr><td><code id="arrange_venn_+3A_outwards_adjust">outwards_adjust</code></td>
<td>
<p>the multiplier defining the distance from the centre</p>
</td></tr>
<tr><td><code id="arrange_venn_+3A_extract_sets">extract_sets</code></td>
<td>
<p>should only sets be extracted?</p>
</td></tr>
<tr><td><code id="arrange_venn_+3A_extract_regions">extract_regions</code></td>
<td>
<p>should all unique regions be extracted?</p>
</td></tr>
<tr><td><code id="arrange_venn_+3A_repeat_in_intersections">repeat_in_intersections</code></td>
<td>
<p>repeat intersection k times where k is the number of sets it belongs to?</p>
</td></tr>
<tr><td><code id="arrange_venn_+3A_starting_grid_size">starting_grid_size</code></td>
<td>
<p>the starting size of the grid for placement of elements</p>
</td></tr>
</table>

<hr>
<h2 id='compare_between_intersections'>Compare covariates between intersections</h2><span id='topic+compare_between_intersections'></span>

<h3>Description</h3>

<p>Compare covariates between intersections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_between_intersections(
  data,
  intersect,
  test = kruskal.test,
  tests = list(),
  ignore = list(),
  ignore_mode_columns = TRUE,
  mode = "exclusive_intersection",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_between_intersections_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in classes</p>
</td></tr>
<tr><td><code id="compare_between_intersections_+3A_intersect">intersect</code></td>
<td>
<p>which columns should be used to compose the intersection</p>
</td></tr>
<tr><td><code id="compare_between_intersections_+3A_test">test</code></td>
<td>
<p>the default test function; it is expected to accept <code>formula</code> and <code>data</code> parameters, and a list with <code>p.value</code>, <code>statistic</code>, and <code>method</code></p>
</td></tr>
<tr><td><code id="compare_between_intersections_+3A_tests">tests</code></td>
<td>
<p>a named list with tests for specific variables, overwriting the default test</p>
</td></tr>
<tr><td><code id="compare_between_intersections_+3A_ignore">ignore</code></td>
<td>
<p>a list with names of variables to exclude from testing</p>
</td></tr>
<tr><td><code id="compare_between_intersections_+3A_ignore_mode_columns">ignore_mode_columns</code></td>
<td>
<p>whether the membership columns and size columns for all modes should be ignored</p>
</td></tr>
<tr><td><code id="compare_between_intersections_+3A_mode">mode</code></td>
<td>
<p>region selection mode; note that modes other than <code>exclusive_intersection</code> repeat observations in different test group, introducing dependencies. See <code>get_size_mode()</code> for accepted values.</p>
</td></tr>
<tr><td><code id="compare_between_intersections_+3A_...">...</code></td>
<td>
<p>passed to <code>upset_data()</code></p>
</td></tr>
</table>

<hr>
<h2 id='create_upset_abc_example'>Create an example dataset with three sets: A, B and C</h2><span id='topic+create_upset_abc_example'></span>

<h3>Description</h3>

<p>Create an example dataset with three sets: A, B and C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_upset_abc_example()
</code></pre>

<hr>
<h2 id='geom_venn_circle'>Circle for Venn diagram</h2><span id='topic+geom_venn_circle'></span>

<h3>Description</h3>

<p>Circle for Venn diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_venn_circle(
  data,
  mapping = aes_(),
  sets = NULL,
  radius = 1.5,
  resolution = 100,
  size = 0.8,
  color = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_venn_circle_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in sets</p>
</td></tr>
<tr><td><code id="geom_venn_circle_+3A_mapping">mapping</code></td>
<td>
<p>the aesthetics mapping</p>
</td></tr>
<tr><td><code id="geom_venn_circle_+3A_sets">sets</code></td>
<td>
<p>vector with names of columns representing membership in sets</p>
</td></tr>
<tr><td><code id="geom_venn_circle_+3A_radius">radius</code></td>
<td>
<p>the radius of the circle</p>
</td></tr>
<tr><td><code id="geom_venn_circle_+3A_resolution">resolution</code></td>
<td>
<p>the resolution of the circle rasterizer</p>
</td></tr>
<tr><td><code id="geom_venn_circle_+3A_size">size</code></td>
<td>
<p>width of the outline</p>
</td></tr>
<tr><td><code id="geom_venn_circle_+3A_color">color</code></td>
<td>
<p>the color of the outline</p>
</td></tr>
<tr><td><code id="geom_venn_circle_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+geom_polygon">ggplot2::geom_polygon</a></code>
</p>

<dl>
<dt><code>stat</code></dt><dd><p>The statistical transformation to use on the data for this
layer, as a string.</p>
</dd>
<dt><code>position</code></dt><dd><p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</dd>
<dt><code>rule</code></dt><dd><p>Either <code>"evenodd"</code> or <code>"winding"</code>. If polygons with holes are
being drawn (using the <code>subgroup</code> aesthetic) this argument defines how the
hole coordinates are interpreted. See the examples in <code><a href="grid.html#topic+grid.path">grid::pathGrob()</a></code> for
an explanation.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</dd>
<dt><code>show.legend</code></dt><dd><p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</dd>
<dt><code>inherit.aes</code></dt><dd><p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='geom_venn_label_region'>Label for a region of Venn diagram</h2><span id='topic+geom_venn_label_region'></span>

<h3>Description</h3>

<p>Label for a region of Venn diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_venn_label_region(
  data,
  mapping = aes_(),
  sets = NULL,
  outwards_adjust = 1.3,
  fill = alpha("white", 0.85),
  size = 5,
  label.size = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_venn_label_region_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in sets</p>
</td></tr>
<tr><td><code id="geom_venn_label_region_+3A_mapping">mapping</code></td>
<td>
<p>the aesthetics mapping</p>
</td></tr>
<tr><td><code id="geom_venn_label_region_+3A_sets">sets</code></td>
<td>
<p>vector with names of columns representing membership in sets</p>
</td></tr>
<tr><td><code id="geom_venn_label_region_+3A_outwards_adjust">outwards_adjust</code></td>
<td>
<p>the multiplier defining the distance from the centre</p>
</td></tr>
<tr><td><code id="geom_venn_label_region_+3A_fill">fill</code></td>
<td>
<p>the fill of the label</p>
</td></tr>
<tr><td><code id="geom_venn_label_region_+3A_size">size</code></td>
<td>
<p>the text size</p>
</td></tr>
<tr><td><code id="geom_venn_label_region_+3A_label.size">label.size</code></td>
<td>
<p>the size of the label outline</p>
</td></tr>
<tr><td><code id="geom_venn_label_region_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_label</a></code>
</p>

<dl>
<dt><code>stat</code></dt><dd><p>The statistical transformation to use on the data for this
layer, as a string.</p>
</dd>
<dt><code>position</code></dt><dd><p>Position adjustment, either as a string, or the result of
a call to a position adjustment function. Cannot be jointy specified with
<code>nudge_x</code> or <code>nudge_y</code>.</p>
</dd>
<dt><code>parse</code></dt><dd><p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</dd>
<dt><code>nudge_x</code></dt><dd><p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</dd>
<dt><code>nudge_y</code></dt><dd><p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</dd>
<dt><code>label.padding</code></dt><dd><p>Amount of padding around label. Defaults to 0.25 lines.</p>
</dd>
<dt><code>label.r</code></dt><dd><p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</dd>
<dt><code>show.legend</code></dt><dd><p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</dd>
<dt><code>inherit.aes</code></dt><dd><p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='geom_venn_label_set'>Label for a set of Venn diagram</h2><span id='topic+geom_venn_label_set'></span>

<h3>Description</h3>

<p>Label for a set of Venn diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_venn_label_set(
  data,
  mapping = aes_(),
  sets = NULL,
  outwards_adjust = 2.5,
  fill = alpha("white", 0.85),
  size = 5,
  label.size = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_venn_label_set_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in sets</p>
</td></tr>
<tr><td><code id="geom_venn_label_set_+3A_mapping">mapping</code></td>
<td>
<p>the aesthetics mapping</p>
</td></tr>
<tr><td><code id="geom_venn_label_set_+3A_sets">sets</code></td>
<td>
<p>vector with names of columns representing membership in sets</p>
</td></tr>
<tr><td><code id="geom_venn_label_set_+3A_outwards_adjust">outwards_adjust</code></td>
<td>
<p>the multiplier defining the distance from the centre</p>
</td></tr>
<tr><td><code id="geom_venn_label_set_+3A_fill">fill</code></td>
<td>
<p>the fill of the label</p>
</td></tr>
<tr><td><code id="geom_venn_label_set_+3A_size">size</code></td>
<td>
<p>the text size</p>
</td></tr>
<tr><td><code id="geom_venn_label_set_+3A_label.size">label.size</code></td>
<td>
<p>the size of the label outline</p>
</td></tr>
<tr><td><code id="geom_venn_label_set_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_label</a></code>
</p>

<dl>
<dt><code>stat</code></dt><dd><p>The statistical transformation to use on the data for this
layer, as a string.</p>
</dd>
<dt><code>position</code></dt><dd><p>Position adjustment, either as a string, or the result of
a call to a position adjustment function. Cannot be jointy specified with
<code>nudge_x</code> or <code>nudge_y</code>.</p>
</dd>
<dt><code>parse</code></dt><dd><p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</dd>
<dt><code>nudge_x</code></dt><dd><p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</dd>
<dt><code>nudge_y</code></dt><dd><p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</dd>
<dt><code>label.padding</code></dt><dd><p>Amount of padding around label. Defaults to 0.25 lines.</p>
</dd>
<dt><code>label.r</code></dt><dd><p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</dd>
<dt><code>show.legend</code></dt><dd><p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</dd>
<dt><code>inherit.aes</code></dt><dd><p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='geom_venn_region'>Region of Venn diagram</h2><span id='topic+geom_venn_region'></span>

<h3>Description</h3>

<p>Region of Venn diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_venn_region(data, mapping = aes_(), sets = NULL, resolution = 250, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_venn_region_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in sets</p>
</td></tr>
<tr><td><code id="geom_venn_region_+3A_mapping">mapping</code></td>
<td>
<p>the aesthetics mapping</p>
</td></tr>
<tr><td><code id="geom_venn_region_+3A_sets">sets</code></td>
<td>
<p>vector with names of columns representing membership in sets</p>
</td></tr>
<tr><td><code id="geom_venn_region_+3A_resolution">resolution</code></td>
<td>
<p>the resolution of the circle rasterizer</p>
</td></tr>
<tr><td><code id="geom_venn_region_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+geom_polygon">ggplot2::geom_polygon</a></code>
</p>

<dl>
<dt><code>stat</code></dt><dd><p>The statistical transformation to use on the data for this
layer, as a string.</p>
</dd>
<dt><code>position</code></dt><dd><p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</dd>
<dt><code>rule</code></dt><dd><p>Either <code>"evenodd"</code> or <code>"winding"</code>. If polygons with holes are
being drawn (using the <code>subgroup</code> aesthetic) this argument defines how the
hole coordinates are interpreted. See the examples in <code><a href="grid.html#topic+grid.path">grid::pathGrob()</a></code> for
an explanation.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</dd>
<dt><code>show.legend</code></dt><dd><p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</dd>
<dt><code>inherit.aes</code></dt><dd><p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='get_size_mode'>Retrieve symbol for given mode that can be used in aesthetics mapping with double bang (<code style="white-space: pre;">&#8288;!!&#8288;</code>)</h2><span id='topic+get_size_mode'></span>

<h3>Description</h3>

<p>Retrieve symbol for given mode that can be used in aesthetics mapping with double bang (<code style="white-space: pre;">&#8288;!!&#8288;</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_size_mode(mode, suffix = "_size")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_size_mode_+3A_mode">mode</code></td>
<td>
<p>the mode to use. Accepted values: <code>exclusive_intersection</code> (alias <code>distinct</code>), <code>inclusive_intersection</code> (alias <code>intersect</code>), <code>inclusive_union</code> (alias <code>union</code>), <code>exclusive_union</code>.</p>
</td></tr>
<tr><td><code id="get_size_mode_+3A_suffix">suffix</code></td>
<td>
<p>the column suffix in use as passed to <code>upset_data()</code></p>
</td></tr>
</table>

<hr>
<h2 id='intersection_matrix'>Prepare layers for sets sizes plot</h2><span id='topic+intersection_matrix'></span>

<h3>Description</h3>

<p>Prepare layers for sets sizes plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersection_matrix(
  geom = geom_point(size = 3),
  segment = geom_segment(),
  outline_color = list(active = "black", inactive = "grey70")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersection_matrix_+3A_geom">geom</code></td>
<td>
<p>a geom_point call, allowing to specify parameters (e.g. <code>geom=geom_point(shape='square')</code>)</p>
</td></tr>
<tr><td><code id="intersection_matrix_+3A_segment">segment</code></td>
<td>
<p>a geom_segment call, allowing to specify parameters (e.g. <code>segment=geom_segment(linetype='dotted')</code>)</p>
</td></tr>
<tr><td><code id="intersection_matrix_+3A_outline_color">outline_color</code></td>
<td>
<p>a named list with two colors for outlines of active and inactive dots</p>
</td></tr>
</table>

<hr>
<h2 id='intersection_ratio'>Barplot annotation of relative intersections sizes</h2><span id='topic+intersection_ratio'></span>

<h3>Description</h3>

<p>A large intersection size can be driven by a large number of members in a group;
to account for that, one can divide the intersection size by the size of a union of the same groups.
This cannot be calculated for the null intersection (observations which do not belong to either of the groups).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersection_ratio(
  mapping = aes(),
  counts = TRUE,
  bar_number_threshold = 0.75,
  text_colors = c(on_background = "black", on_bar = "white"),
  text = list(),
  text_mapping = aes(),
  mode = "distinct",
  denominator_mode = "union",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersection_ratio_+3A_mapping">mapping</code></td>
<td>
<p>additional aesthetics for <code>geom_bar()</code></p>
</td></tr>
<tr><td><code id="intersection_ratio_+3A_counts">counts</code></td>
<td>
<p>whether to display count number labels above the bars</p>
</td></tr>
<tr><td><code id="intersection_ratio_+3A_bar_number_threshold">bar_number_threshold</code></td>
<td>
<p>if less than one, labels for bars height greater than this threshold will be placed on (not above) the bars</p>
</td></tr>
<tr><td><code id="intersection_ratio_+3A_text_colors">text_colors</code></td>
<td>
<p>a name vector of characters specifying the color when <code>on_background</code> and <code>on_bar</code> (see <code>bar_number_threshold</code>)</p>
</td></tr>
<tr><td><code id="intersection_ratio_+3A_text">text</code></td>
<td>
<p>additional parameters passed to <code>geom_text()</code></p>
</td></tr>
<tr><td><code id="intersection_ratio_+3A_text_mapping">text_mapping</code></td>
<td>
<p>additional aesthetics for <code>geom_text()</code></p>
</td></tr>
<tr><td><code id="intersection_ratio_+3A_mode">mode</code></td>
<td>
<p>region selection mode, defines which intersection regions will be accounted for when computing the size. See <code>get_size_mode()</code> for accepted values.</p>
</td></tr>
<tr><td><code id="intersection_ratio_+3A_denominator_mode">denominator_mode</code></td>
<td>
<p>region selection mode for computing the denominator in ratio. See <code>get_size_mode()</code> for accepted values.</p>
</td></tr>
<tr><td><code id="intersection_ratio_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+intersection_size">intersection_size</a></code>
</p>

<dl>
<dt><code>position</code></dt><dd><p>position passed to <code>geom_bar()</code></p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='intersection_size'>Barplot annotation of intersections sizes</h2><span id='topic+intersection_size'></span>

<h3>Description</h3>

<p>Barplot annotation of intersections sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersection_size(
  mapping = aes(),
  counts = TRUE,
  bar_number_threshold = 0.85,
  text_colors = c(on_background = "black", on_bar = "white"),
  text = list(),
  text_mapping = aes(),
  mode = "distinct",
  position = position_stack(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersection_size_+3A_mapping">mapping</code></td>
<td>
<p>additional aesthetics for <code>geom_bar()</code></p>
</td></tr>
<tr><td><code id="intersection_size_+3A_counts">counts</code></td>
<td>
<p>whether to display count number labels above the bars</p>
</td></tr>
<tr><td><code id="intersection_size_+3A_bar_number_threshold">bar_number_threshold</code></td>
<td>
<p>if less than one, labels for bars height greater than this threshold will be placed on (not above) the bars</p>
</td></tr>
<tr><td><code id="intersection_size_+3A_text_colors">text_colors</code></td>
<td>
<p>a name vector of characters specifying the color when <code>on_background</code> and <code>on_bar</code> (see <code>bar_number_threshold</code>)</p>
</td></tr>
<tr><td><code id="intersection_size_+3A_text">text</code></td>
<td>
<p>additional parameters passed to <code>geom_text()</code></p>
</td></tr>
<tr><td><code id="intersection_size_+3A_text_mapping">text_mapping</code></td>
<td>
<p>additional aesthetics for <code>geom_text()</code></p>
</td></tr>
<tr><td><code id="intersection_size_+3A_mode">mode</code></td>
<td>
<p>region selection mode, defines which intersection regions will be accounted for when computing the size. See <code>get_size_mode()</code> for accepted values.</p>
</td></tr>
<tr><td><code id="intersection_size_+3A_position">position</code></td>
<td>
<p>position passed to <code>geom_bar()</code></p>
</td></tr>
<tr><td><code id="intersection_size_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar</a></code>
</p>

<dl>
<dt><code>data</code></dt><dd><p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</dd>
<dt><code>width</code></dt><dd><p>Bar width. By default, set to 90% of the resolution of the data.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</dd>
<dt><code>orientation</code></dt><dd><p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</dd>
<dt><code>show.legend</code></dt><dd><p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</dd>
<dt><code>inherit.aes</code></dt><dd><p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</dd>
<dt><code>stat</code></dt><dd><p>Override the default connection between <code>geom_bar()</code> and
<code>stat_count()</code>.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='reverse_log_trans'>Logarithmic scale for use with <code>upset_set_size()</code></h2><span id='topic+reverse_log_trans'></span>

<h3>Description</h3>

<p>Inspired by <a href="https://stackoverflow.com/a/11054781">Brian Diggs' answer</a> which is CC-BY-SA 4.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_log_trans(base = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_log_trans_+3A_base">base</code></td>
<td>
<p>logarithm base (default 10)</p>
</td></tr>
</table>

<hr>
<h2 id='scale_color_venn_mix'>Color scale for Venn diagram</h2><span id='topic+scale_color_venn_mix'></span>

<h3>Description</h3>

<p>Color scale for Venn diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_color_venn_mix(
  data,
  sets = NULL,
  colors = c("red", "blue", "green"),
  na.value = "grey40",
  highlight = NULL,
  active_color = "orange",
  inactive_color = "NA",
  scale = scale_color_manual,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_color_venn_mix_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in sets</p>
</td></tr>
<tr><td><code id="scale_color_venn_mix_+3A_sets">sets</code></td>
<td>
<p>vector with names of columns representing membership in sets</p>
</td></tr>
<tr><td><code id="scale_color_venn_mix_+3A_colors">colors</code></td>
<td>
<p>named list of colors for sets (one set=one color)</p>
</td></tr>
<tr><td><code id="scale_color_venn_mix_+3A_na.value">na.value</code></td>
<td>
<p>value for elements not belonging to any of the sets</p>
</td></tr>
<tr><td><code id="scale_color_venn_mix_+3A_highlight">highlight</code></td>
<td>
<p>which regions of the diagram to highlight</p>
</td></tr>
<tr><td><code id="scale_color_venn_mix_+3A_active_color">active_color</code></td>
<td>
<p>color for highlight</p>
</td></tr>
<tr><td><code id="scale_color_venn_mix_+3A_inactive_color">inactive_color</code></td>
<td>
<p>color for lack of highlight</p>
</td></tr>
<tr><td><code id="scale_color_venn_mix_+3A_scale">scale</code></td>
<td>
<p>the base scale (default=<code>scale_color_manual()</code>)</p>
</td></tr>
<tr><td><code id="scale_color_venn_mix_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_color_manual</a></code>
</p>

<dl>
<dt><code>values</code></dt><dd><p>a set of aesthetic values to map data values to. The values
will be matched in order (usually alphabetical) with the limits of the
scale, or with <code>breaks</code> if provided. If this is a named vector, then the
values will be matched based on the names instead. Data values that don't
match will be given <code>na.value</code>.</p>
</dd>
<dt><code>aesthetics</code></dt><dd><p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='scale_fill_venn_mix'>Fill scale for Venn diagram</h2><span id='topic+scale_fill_venn_mix'></span>

<h3>Description</h3>

<p>Fill scale for Venn diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_venn_mix(..., na.value = "NA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_fill_venn_mix_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+scale_color_venn_mix">scale_color_venn_mix</a></code>
</p>

<dl>
<dt><code>data</code></dt><dd><p>a dataframe including binary columns representing membership in sets</p>
</dd>
<dt><code>sets</code></dt><dd><p>vector with names of columns representing membership in sets</p>
</dd>
<dt><code>colors</code></dt><dd><p>named list of colors for sets (one set=one color)</p>
</dd>
<dt><code>highlight</code></dt><dd><p>which regions of the diagram to highlight</p>
</dd>
<dt><code>active_color</code></dt><dd><p>color for highlight</p>
</dd>
<dt><code>inactive_color</code></dt><dd><p>color for lack of highlight</p>
</dd>
<dt><code>scale</code></dt><dd><p>the base scale (default=<code>scale_color_manual()</code>)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_fill_venn_mix_+3A_na.value">na.value</code></td>
<td>
<p>value for elements not belonging to any of the known sets</p>
</td></tr>
</table>

<hr>
<h2 id='upset'>Compose an UpSet plot</h2><span id='topic+upset'></span>

<h3>Description</h3>

<p>Compose an UpSet plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset(
  data,
  intersect,
  base_annotations = "auto",
  name = "group",
  annotations = list(),
  themes = upset_themes,
  stripes = upset_stripes(),
  labeller = identity,
  height_ratio = 0.5,
  width_ratio = 0.3,
  wrap = FALSE,
  set_sizes = upset_set_size(),
  mode = "distinct",
  queries = list(),
  guides = NULL,
  encode_sets = TRUE,
  matrix = intersection_matrix(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in classes</p>
</td></tr>
<tr><td><code id="upset_+3A_intersect">intersect</code></td>
<td>
<p>which columns should be used to compose the intersection</p>
</td></tr>
<tr><td><code id="upset_+3A_base_annotations">base_annotations</code></td>
<td>
<p>a named list with default annotations (i.e. the intersection size barplot)</p>
</td></tr>
<tr><td><code id="upset_+3A_name">name</code></td>
<td>
<p>the label shown below the intersection matrix</p>
</td></tr>
<tr><td><code id="upset_+3A_annotations">annotations</code></td>
<td>
<p>a named list of annotations, each being a list with: <code style="white-space: pre;">&#8288;list(aes=mapping, geom=geom or list of geoms)&#8288;</code>;
</p>

<ul>
<li><p> (optional) <code style="white-space: pre;">&#8288;highlight_geom=list of geoms&#8288;</code> geoms which can be highlighted with queries,
</p>
</li>
<li><p> (optional) <code style="white-space: pre;">&#8288;top_geom=list of geoms&#8288;</code> which should show up on top of highlighted queries.
</p>
</li></ul>
</td></tr>
<tr><td><code id="upset_+3A_themes">themes</code></td>
<td>
<p>a named list of themes for components and annotations, see <code>upset_default_themes()</code>/<code>upset_modify_themes()</code></p>
</td></tr>
<tr><td><code id="upset_+3A_stripes">stripes</code></td>
<td>
<p>specification of the stripes appearance created with <code>upset_stripes()</code></p>
</td></tr>
<tr><td><code id="upset_+3A_labeller">labeller</code></td>
<td>
<p>function modifying the names of the sets (rows in the matrix)</p>
</td></tr>
<tr><td><code id="upset_+3A_height_ratio">height_ratio</code></td>
<td>
<p>ratio of the intersection matrix to intersection size height</p>
</td></tr>
<tr><td><code id="upset_+3A_width_ratio">width_ratio</code></td>
<td>
<p>ratio of the overall set size width to intersection matrix width</p>
</td></tr>
<tr><td><code id="upset_+3A_wrap">wrap</code></td>
<td>
<p>whether the plot should be wrapped into a group (makes adding a tile/combining with other plots easier)</p>
</td></tr>
<tr><td><code id="upset_+3A_set_sizes">set_sizes</code></td>
<td>
<p>the overall set sizes plot, e.g. from <code>upset_set_size()</code> (<code>FALSE</code> to hide)</p>
</td></tr>
<tr><td><code id="upset_+3A_mode">mode</code></td>
<td>
<p>region selection mode for computing the number of elements in intersection fragment. See <code>get_size_mode()</code> for accepted values.</p>
</td></tr>
<tr><td><code id="upset_+3A_queries">queries</code></td>
<td>
<p>a list of queries generated with <code>upset_query()</code></p>
</td></tr>
<tr><td><code id="upset_+3A_guides">guides</code></td>
<td>
<p>action for legends aggregation and placement ('keep', 'collect', 'over' the set sizes)</p>
</td></tr>
<tr><td><code id="upset_+3A_encode_sets">encode_sets</code></td>
<td>
<p>whether set names (column in input data) should be encoded as numbers (set to TRUE to overcome R limitations of max 10 kB for variable names for datasets with huge numbers of sets); default TRUE for upset() and FALSE for upset_data().</p>
</td></tr>
<tr><td><code id="upset_+3A_matrix">matrix</code></td>
<td>
<p>the intersection matrix plot</p>
</td></tr>
<tr><td><code id="upset_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+upset_data">upset_data</a></code>
</p>

<dl>
<dt><code>min_size</code></dt><dd><p>minimal number of observations in an intersection for it to be included</p>
</dd>
<dt><code>max_size</code></dt><dd><p>maximal number of observations in an intersection for it to be included</p>
</dd>
<dt><code>min_degree</code></dt><dd><p>minimal degree of an intersection for it to be included</p>
</dd>
<dt><code>max_degree</code></dt><dd><p>maximal degree of an intersection for it to be included</p>
</dd>
<dt><code>n_intersections</code></dt><dd><p>the exact number of the intersections to be displayed; n largest intersections that meet the size and degree criteria will be shown</p>
</dd>
<dt><code>keep_empty_groups</code></dt><dd><p>whether empty sets should be kept (including sets which are only empty after filtering by size)</p>
</dd>
<dt><code>warn_when_dropping_groups</code></dt><dd><p>whether a warning should be issued when empty sets are being removed</p>
</dd>
<dt><code>warn_when_converting</code></dt><dd><p>whether a warning should  be issued when input is not boolean</p>
</dd>
<dt><code>sort_sets</code></dt><dd><p>whether to sort the rows in the intersection matrix (descending sort by default); one of: <code>'ascending'</code>, <code>'descending'</code>, <code>FALSE</code></p>
</dd>
<dt><code>sort_intersections</code></dt><dd><p>whether to sort the columns in the intersection matrix (descending sort by default); one of: <code>'ascending'</code>, <code>'descending'</code>, <code>FALSE</code></p>
</dd>
<dt><code>sort_intersections_by</code></dt><dd><p>the mode of sorting, the size of the intersection (cardinality) by default; one of: <code>'cardinality'</code>, <code>'degree'</code>, <code>'ratio'</code>, or any combination of these (e.g. <code>c('degree', 'cardinality')</code>)</p>
</dd>
<dt><code>sort_ratio_numerator</code></dt><dd><p>the mode for numerator when sorting by ratio</p>
</dd>
<dt><code>sort_ratio_denominator</code></dt><dd><p>the mode for denominator when sorting by ratio</p>
</dd>
<dt><code>group_by</code></dt><dd><p>the mode of grouping intersections; one of: <code>'degree'</code>, <code>'sets'</code></p>
</dd>
<dt><code>size_columns_suffix</code></dt><dd><p>suffix for the columns to store the sizes (adjust if conflicts with your data)</p>
</dd>
<dt><code>intersections</code></dt><dd><p>whether only the intersections present in data (<code>observed</code>, default), or all intersections (<code>all</code>) should be computed; using all intersections for a high number of sets is not computationally feasible - use <code>min_degree</code> and <code>max_degree</code> to narrow down the selection; this is only useful for modes different from the default exclusive intersection. You can also provide a list with a custom selection of intersections (order is respected when you set <code>sort_intersections=FALSE</code>)</p>
</dd>
<dt><code>max_combinations_datapoints_n</code></dt><dd><p>a fail-safe limit preventing accidental use of <code>intersections='all'</code> with a high number of sets and observations</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='upset_annotate'>Annotation panel shorthand</h2><span id='topic+upset_annotate'></span>

<h3>Description</h3>

<p>Simplifies creation of annotation panels, automatically building aesthetics mappings,
at a cost of lower flexibility than when providing a custom mapping; <code>aes(x=intersection)</code> is prespecified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_annotate(y, geom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_annotate_+3A_y">y</code></td>
<td>
<p>A string with the name of the y aesthetic</p>
</td></tr>
<tr><td><code id="upset_annotate_+3A_geom">geom</code></td>
<td>
<p>A geom to be used as an annotation</p>
</td></tr>
</table>

<hr>
<h2 id='upset_data'>Prepare data for UpSet plots</h2><span id='topic+upset_data'></span>

<h3>Description</h3>

<p>Prepare data for UpSet plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_data(
  data,
  intersect,
  min_size = 0,
  max_size = Inf,
  min_degree = 0,
  max_degree = Inf,
  n_intersections = NULL,
  keep_empty_groups = FALSE,
  warn_when_dropping_groups = FALSE,
  warn_when_converting = "auto",
  sort_sets = "descending",
  sort_intersections = "descending",
  sort_intersections_by = "cardinality",
  sort_ratio_numerator = "exclusive_intersection",
  sort_ratio_denominator = "inclusive_union",
  group_by = "degree",
  mode = "exclusive_intersection",
  size_columns_suffix = "_size",
  encode_sets = FALSE,
  max_combinations_datapoints_n = 10^10,
  intersections = "observed"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_data_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in classes</p>
</td></tr>
<tr><td><code id="upset_data_+3A_intersect">intersect</code></td>
<td>
<p>which columns should be used to compose the intersection</p>
</td></tr>
<tr><td><code id="upset_data_+3A_min_size">min_size</code></td>
<td>
<p>minimal number of observations in an intersection for it to be included</p>
</td></tr>
<tr><td><code id="upset_data_+3A_max_size">max_size</code></td>
<td>
<p>maximal number of observations in an intersection for it to be included</p>
</td></tr>
<tr><td><code id="upset_data_+3A_min_degree">min_degree</code></td>
<td>
<p>minimal degree of an intersection for it to be included</p>
</td></tr>
<tr><td><code id="upset_data_+3A_max_degree">max_degree</code></td>
<td>
<p>maximal degree of an intersection for it to be included</p>
</td></tr>
<tr><td><code id="upset_data_+3A_n_intersections">n_intersections</code></td>
<td>
<p>the exact number of the intersections to be displayed; n largest intersections that meet the size and degree criteria will be shown</p>
</td></tr>
<tr><td><code id="upset_data_+3A_keep_empty_groups">keep_empty_groups</code></td>
<td>
<p>whether empty sets should be kept (including sets which are only empty after filtering by size)</p>
</td></tr>
<tr><td><code id="upset_data_+3A_warn_when_dropping_groups">warn_when_dropping_groups</code></td>
<td>
<p>whether a warning should be issued when empty sets are being removed</p>
</td></tr>
<tr><td><code id="upset_data_+3A_warn_when_converting">warn_when_converting</code></td>
<td>
<p>whether a warning should  be issued when input is not boolean</p>
</td></tr>
<tr><td><code id="upset_data_+3A_sort_sets">sort_sets</code></td>
<td>
<p>whether to sort the rows in the intersection matrix (descending sort by default); one of: <code>'ascending'</code>, <code>'descending'</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="upset_data_+3A_sort_intersections">sort_intersections</code></td>
<td>
<p>whether to sort the columns in the intersection matrix (descending sort by default); one of: <code>'ascending'</code>, <code>'descending'</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="upset_data_+3A_sort_intersections_by">sort_intersections_by</code></td>
<td>
<p>the mode of sorting, the size of the intersection (cardinality) by default; one of: <code>'cardinality'</code>, <code>'degree'</code>, <code>'ratio'</code>, or any combination of these (e.g. <code>c('degree', 'cardinality')</code>)</p>
</td></tr>
<tr><td><code id="upset_data_+3A_sort_ratio_numerator">sort_ratio_numerator</code></td>
<td>
<p>the mode for numerator when sorting by ratio</p>
</td></tr>
<tr><td><code id="upset_data_+3A_sort_ratio_denominator">sort_ratio_denominator</code></td>
<td>
<p>the mode for denominator when sorting by ratio</p>
</td></tr>
<tr><td><code id="upset_data_+3A_group_by">group_by</code></td>
<td>
<p>the mode of grouping intersections; one of: <code>'degree'</code>, <code>'sets'</code></p>
</td></tr>
<tr><td><code id="upset_data_+3A_mode">mode</code></td>
<td>
<p>region selection mode for sorting and trimming by size. See <code>get_size_mode()</code> for accepted values.</p>
</td></tr>
<tr><td><code id="upset_data_+3A_size_columns_suffix">size_columns_suffix</code></td>
<td>
<p>suffix for the columns to store the sizes (adjust if conflicts with your data)</p>
</td></tr>
<tr><td><code id="upset_data_+3A_encode_sets">encode_sets</code></td>
<td>
<p>whether set names (column in input data) should be encoded as numbers (set to TRUE to overcome R limitations of max 10 kB for variable names for datasets with huge numbers of sets); default TRUE for upset() and FALSE for upset_data()</p>
</td></tr>
<tr><td><code id="upset_data_+3A_max_combinations_datapoints_n">max_combinations_datapoints_n</code></td>
<td>
<p>a fail-safe limit preventing accidental use of <code>intersections='all'</code> with a high number of sets and observations</p>
</td></tr>
<tr><td><code id="upset_data_+3A_intersections">intersections</code></td>
<td>
<p>whether only the intersections present in data (<code>observed</code>, default), or all intersections (<code>all</code>) should be computed; using all intersections for a high number of sets is not computationally feasible - use <code>min_degree</code> and <code>max_degree</code> to narrow down the selection; this is only useful for modes different from the default exclusive intersection. You can also provide a list with a custom selection of intersections (order is respected when you set <code>sort_intersections=FALSE</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='upset_default_themes'>Default themes modified by specified arguments</h2><span id='topic+upset_default_themes'></span>

<h3>Description</h3>

<p>Return the default UpSet themes with all themes modified with provided arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_default_themes(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_default_themes_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>theme()</code></p>
</td></tr>
</table>

<hr>
<h2 id='upset_mode'>Layer defining the intersection mode for the data to be displayed</h2><span id='topic+upset_mode'></span>

<h3>Description</h3>

<p>By default the annotations are given data corresponding to the same mode as the mode of the passed in the <code>upset()</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_mode(mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_mode_+3A_mode">mode</code></td>
<td>
<p>region selection mode, defines which mode data will be made available for the annotation. See <code>get_size_mode()</code> for accepted values.</p>
</td></tr>
</table>

<hr>
<h2 id='upset_modify_themes'>Default themes modified by specified component-specific arguments</h2><span id='topic+upset_modify_themes'></span>

<h3>Description</h3>

<p>Return the default UpSet themes with specific themes modified with provided themes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_modify_themes(to_update)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_modify_themes_+3A_to_update">to_update</code></td>
<td>
<p>a named list of themes to be used to modify themes of specific components; see <code>names(upset_themes)</code> for components names.</p>
</td></tr>
</table>

<hr>
<h2 id='upset_query'>Highlight chosen sets or intersections</h2><span id='topic+upset_query'></span>

<h3>Description</h3>

<p>Highlight sets or intersections matching specified query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_query(
  set = NULL,
  intersect = NULL,
  group = NULL,
  only_components = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_query_+3A_set">set</code></td>
<td>
<p>name of the set to highlight</p>
</td></tr>
<tr><td><code id="upset_query_+3A_intersect">intersect</code></td>
<td>
<p>a vector of names for the intersection to highlight; pass <code>NA</code> to select the empty intersection</p>
</td></tr>
<tr><td><code id="upset_query_+3A_group">group</code></td>
<td>
<p>name of the set to highlight when using <code>group_by='sets'</code></p>
</td></tr>
<tr><td><code id="upset_query_+3A_only_components">only_components</code></td>
<td>
<p>which components to modify; by default all eligible components will be modified; the available components are 'overall_sizes', 'intersections_matrix', 'Intersection size', and any annotations specified</p>
</td></tr>
<tr><td><code id="upset_query_+3A_...">...</code></td>
<td>

<ul>
<li><p> passed to geoms in modified components
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>upset_query(intersect=c('Drama', 'Comedy'), color='red', fill='red')
upset_query(set='Drama', fill='blue')
</code></pre>

<hr>
<h2 id='upset_set_size'>Prepare layers for sets sizes plot</h2><span id='topic+upset_set_size'></span>

<h3>Description</h3>

<p>Prepare layers for sets sizes plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_set_size(
  mapping = aes(),
  geom = geom_bar(width = 0.6),
  position = "left",
  filter_intersections = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_set_size_+3A_mapping">mapping</code></td>
<td>
<p>additional aesthetics</p>
</td></tr>
<tr><td><code id="upset_set_size_+3A_geom">geom</code></td>
<td>
<p>a geom to use</p>
</td></tr>
<tr><td><code id="upset_set_size_+3A_position">position</code></td>
<td>
<p>on which side of the plot should the set sizes be displayed ('left' or 'right')</p>
</td></tr>
<tr><td><code id="upset_set_size_+3A_filter_intersections">filter_intersections</code></td>
<td>
<p>whether the intersections filters (e.g. <code>n_intersections</code> or <code>min_size</code>) should influence displayed set sizes</p>
</td></tr>
</table>

<hr>
<h2 id='upset_stripes'>Define appearence of the stripes</h2><span id='topic+upset_stripes'></span>

<h3>Description</h3>

<p>Define appearence of the stripes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_stripes(
  mapping = aes(),
  geom = geom_segment(size = 7),
  colors = c("white", "grey95"),
  data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_stripes_+3A_mapping">mapping</code></td>
<td>
<p>additional aesthetics</p>
</td></tr>
<tr><td><code id="upset_stripes_+3A_geom">geom</code></td>
<td>
<p>a geom to use, should accept <code>x</code>, <code>y</code>, <code>xend</code>, <code>yend</code> and <code>color</code> aesthetics</p>
</td></tr>
<tr><td><code id="upset_stripes_+3A_colors">colors</code></td>
<td>
<p>a vector of colors to repeat as many times as needed for the fill of stripes, or a named vector specifying colors for values of the variable mapped to the color aesthetics in the mapping argument</p>
</td></tr>
<tr><td><code id="upset_stripes_+3A_data">data</code></td>
<td>
<p>the dataset describing the sets with a column named <code>set</code> and any other columns as needed for mapping</p>
</td></tr>
</table>

<hr>
<h2 id='upset_test'>Test for differences between intersections</h2><span id='topic+upset_test'></span>

<h3>Description</h3>

<p>This is a wrapper around <code>compare_between_intersections()</code>, adding sorting by FDR, warnings, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_test(data, intersect, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_test_+3A_data">data</code></td>
<td>
<p>a dataframe including binary columns representing membership in classes</p>
</td></tr>
<tr><td><code id="upset_test_+3A_intersect">intersect</code></td>
<td>
<p>which columns should be used to compose the intersection</p>
</td></tr>
<tr><td><code id="upset_test_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+compare_between_intersections">compare_between_intersections</a></code>
</p>

<dl>
<dt><code>test</code></dt><dd><p>the default test function; it is expected to accept <code>formula</code> and <code>data</code> parameters, and a list with <code>p.value</code>, <code>statistic</code>, and <code>method</code></p>
</dd>
<dt><code>tests</code></dt><dd><p>a named list with tests for specific variables, overwriting the default test</p>
</dd>
<dt><code>ignore</code></dt><dd><p>a list with names of variables to exclude from testing</p>
</dd>
<dt><code>ignore_mode_columns</code></dt><dd><p>whether the membership columns and size columns for all modes should be ignored</p>
</dd>
<dt><code>mode</code></dt><dd><p>region selection mode; note that modes other than <code>exclusive_intersection</code> repeat observations in different test group, introducing dependencies. See <code>get_size_mode()</code> for accepted values.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='upset_text_percentage'>Generate percentage label of the intersection/union sizes ratio</h2><span id='topic+upset_text_percentage'></span>

<h3>Description</h3>

<p>For use together with <code>intersection_size</code> or <code>intersection_ratio</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_text_percentage(digits = 0, sep = "", mode = "distinct")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_text_percentage_+3A_digits">digits</code></td>
<td>
<p>How many digits to show when rounding the percentage?</p>
</td></tr>
<tr><td><code id="upset_text_percentage_+3A_sep">sep</code></td>
<td>
<p>set to space (<code>' '</code>) if you prefer a whitespace between the number and the <code style="white-space: pre;">&#8288;\%&#8288;</code> sign.</p>
</td></tr>
<tr><td><code id="upset_text_percentage_+3A_mode">mode</code></td>
<td>
<p>region selection mode for computing the numerator in ratio. See <code>get_size_mode()</code> for accepted values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot2::aes(label=!!upset_text_percentage())
</code></pre>

<hr>
<h2 id='upset_themes'>List of default themes for upset components</h2><span id='topic+upset_themes'></span>

<h3>Description</h3>

<p>List of default themes for upset components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset_themes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
