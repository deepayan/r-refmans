<!DOCTYPE html><html><head><title>Help for package DCSmooth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DCSmooth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dcs'><p>Nonparametric Double Conditional Smoothing for 2D Surfaces</p></a></li>
<li><a href='#DCSmooth-package'><p>Nonparametric Regression and Bandwidth Selection for Spatial Models</p></a></li>
<li><a href='#kernel.assign'><p>Assign a Kernel Function</p></a></li>
<li><a href='#kernel.list'><p>Print a list of available kernels in the DCSmooth package</p></a></li>
<li><a href='#plot.dcs'><p>Contour Plot for the Double Conditional Smoothing</p></a></li>
<li><a href='#print.dcs'><p>Summarize Results from Double Conditional Smoothing</p></a></li>
<li><a href='#print.dcs_options'><p>Print and Summarize Options for Double Conditional Smoothing</p></a></li>
<li><a href='#print.summary_dcs'><p>Print the Summary of a DCS estimation</p></a></li>
<li><a href='#print.summary_sarma'><p>Print the Summary of a &quot;sarma&quot;/&quot;sfarima&quot; object</p></a></li>
<li><a href='#residuals.dcs'><p>Residuals of &quot;dcs&quot;-object</p></a></li>
<li><a href='#returns.alv'><p>Returns of Allianz SE</p></a></li>
<li><a href='#sarma.est'><p>Estimation of an SARMA-process</p></a></li>
<li><a href='#sarma.sim'><p>Simulation of a <code class="reqn">SARMA(p, q)</code>-process</p></a></li>
<li><a href='#set.options'><p>Set Options for the DCS procedure</p></a></li>
<li><a href='#sfarima.est'><p>Estimation of a SFARIMA-process</p></a></li>
<li><a href='#sfarima.sim'><p>Simulation of a <code class="reqn">SFARIMA(p, q, d)</code>-process</p></a></li>
<li><a href='#summary.dcs'><p>Summarizing Results from Double Conditional Smoothing</p></a></li>
<li><a href='#summary.dcs_options'><p>Print and Summarize Options for Double Conditional Smoothing</p></a></li>
<li><a href='#summary.sarma'><p>Summarizing SARMA/SFARIMA Estimation or Simulation</p></a></li>
<li><a href='#surface.dcs'><p>3D Surface Plot of &quot;dcs&quot;-object or numeric matrix</p></a></li>
<li><a href='#temp.nunn'><p>Temperatures from Nunn, CO</p></a></li>
<li><a href='#temp.yuma'><p>Temperatures from Yuma, AZ</p></a></li>
<li><a href='#volumes.alv'><p>Volumes of Allianz SE</p></a></li>
<li><a href='#wind.nunn'><p>Wind Speed from Nunn, CO</p></a></li>
<li><a href='#wind.yuma'><p>Wind Speed from Yuma, AZ</p></a></li>
<li><a href='#y.norm1'><p>Single Gaussian Peak</p></a></li>
<li><a href='#y.norm2'><p>Double Gaussian Peak</p></a></li>
<li><a href='#y.norm3'><p>Double Gaussian Ridges</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Regression and Bandwidth Selection for Spatial
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Bastian Schaefer [aut, cre],
  Sebastian Letmathe [ctb],
  Yuanhua Feng [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bastian Schaefer &lt;bastian.schaefer@uni-paderborn.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Nonparametric smoothing techniques for data on a lattice and
    functional time series. Smoothing is done via kernel regression or
    local polynomial regression, a bandwidth selection procedure based on
    an iterative plug-in algorithm is implemented. This package allows for
    modeling a dependency structure of the error terms of the
    nonparametric regression model.  Methods used in this paper are
    described in Feng/Schaefer (2021)
    <a href="https://ideas.repec.org/p/pdn/ciepap/144.html">https://ideas.repec.org/p/pdn/ciepap/144.html</a>, Schaefer/Feng (2021)
    <a href="https://ideas.repec.org/p/pdn/ciepap/143.html">https://ideas.repec.org/p/pdn/ciepap/143.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, foreach, fracdiff, parallel, plotly, Rcpp, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-21 14:58:07 UTC; Bastian Schäfer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-21 15:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='dcs'>Nonparametric Double Conditional Smoothing for 2D Surfaces</h2><span id='topic+dcs'></span>

<h3>Description</h3>

<p><code>dcs</code> provides a double conditional nonparametric smoothing of the
expectation surface of a functional time series or a random field on a
lattice. Bandwidth selection is done via an iterative plug-in method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcs(Y, dcs_options = set.options(), h = "auto", parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcs_+3A_y">Y</code></td>
<td>
<p>A numeric matrix that contains the observations of the random field
or functional time-series.</p>
</td></tr>
<tr><td><code id="dcs_+3A_dcs_options">dcs_options</code></td>
<td>
<p>An object of class <code>"dcs_options"</code>, specifying the
parameters for the smoothing and bandwidth selection procedure.</p>
</td></tr>
<tr><td><code id="dcs_+3A_h">h</code></td>
<td>
<p>Bandwidth for smoothing the observations in <code>Y</code>. Can be a
two-valued numerical vector with bandwidths in row- and column-direction.
If the value is <code>"auto"</code> (the default), bandwidth selection will be 
carried out by the iterative plug-in algorithm.</p>
</td></tr>
<tr><td><code id="dcs_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating if parallel computing should be
used for faster computation. Default value is <code>parallel = FALSE</code>.
Parallelization seems to be efficient at above 400,000 observations.</p>
</td></tr>
<tr><td><code id="dcs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>dcs</code>. Currently supported are
numerical vectors <code>X</code> and/or <code>T</code> containing the exogenous
covariates with respect to the rows and columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dcs</code> returns an object of class &quot;dcs&quot;, including
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code>Y</code> </td><td style="text-align: left;"> matrix of original observations. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>X, T</code> </td><td style="text-align: left;"> vectors of covariates over rows (<code>X</code>) and columns 
  (<code>T</code>). </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>M</code> </td><td style="text-align: left;"> resulting matrix of smoothed values. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>R</code> </td><td style="text-align: left;"> matrix of residuals of estimation, <code class="reqn">Y - M</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>h</code> </td><td style="text-align: left;"> optimized or given bandwidths. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>c_f</code> </td><td style="text-align: left;"> estimated variance coefficient. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>var_est</code> </td><td style="text-align: left;"> estimated variance model. If the variance function is
  modeled by an SARMA/SFARIMA, <code>var_est</code> is an object of class "sarma"/
  "sfarima".</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>dcs_options</code> </td><td style="text-align: left;"> an object of class <code>cds_options</code> containing the
  initial options of the dcs procedure. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>iterations</code> </td><td style="text-align: left;"> number of iterations of the IPI-procedure. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>time_used</code> </td><td style="text-align: left;"> time spend searching for optimal bandwidths (not
  overall runtime of the function). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>See the vignette for a more detailed description of the function.
</p>


<h3>References</h3>

<p>Schäfer, B. and Feng, Y. (2021). Fast Computation and Bandwidth Selection 
Algorithms for Smoothing Functional Time Series. Working Papers CIE 143, 
Paderborn University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.options">set.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("DCSmooth") for examples and explanation

y &lt;- y.norm1 + matrix(rnorm(101^2), nrow = 101, ncol = 101)
dcs(y)

</code></pre>

<hr>
<h2 id='DCSmooth-package'>Nonparametric Regression and Bandwidth Selection for Spatial Models</h2><span id='topic+DCSmooth-package'></span><span id='topic+DCSmooth'></span>

<h3>Description</h3>

<p>Nonparametric smoothing techniques for data on a lattice and
    functional time series. Smoothing is done via kernel regression or
    local polynomial regression, a bandwidth selection procedure based on
    an iterative plug-in algorithm is implemented. This package allows for
    modeling a dependency structure of the error terms of the
    nonparametric regression model.  Methods used in this paper are
    described in Feng/Schaefer (2021)
    &lt;https://ideas.repec.org/p/pdn/ciepap/144.html&gt;, Schaefer/Feng (2021)
    &lt;https://ideas.repec.org/p/pdn/ciepap/143.html&gt;.</p>


<h3>Package Content</h3>


<p>Index of help topics:
</p>
<pre>
DCSmooth-package        Nonparametric Regression and Bandwidth
                        Selection for Spatial Models
dcs                     Nonparametric Double Conditional Smoothing for
                        2D Surfaces
kernel.assign           Assign a Kernel Function
kernel.list             Print a list of available kernels in the
                        DCSmooth package
plot.dcs                Contour Plot for the Double Conditional
                        Smoothing
print.dcs               Summarize Results from Double Conditional
                        Smoothing
print.dcs_options       Print and Summarize Options for Double
                        Conditional Smoothing
print.summary_dcs       Print the Summary of a DCS estimation
print.summary_sarma     Print the Summary of a "sarma"/"sfarima" object
residuals.dcs           Residuals of "dcs"-object
returns.alv             Returns of Allianz SE
sarma.est               Estimation of an SARMA-process
sarma.sim               Simulation of a SARMA(p, q)-process
set.options             Set Options for the DCS procedure
sfarima.est             Estimation of a SFARIMA-process
sfarima.sim             Simulation of a SFARIMA(p, q, d)-process
summary.dcs             Summarizing Results from Double Conditional
                        Smoothing
summary.dcs_options     Print and Summarize Options for Double
                        Conditional Smoothing
summary.sarma           Summarizing SARMA/SFARIMA Estimation or
                        Simulation
surface.dcs             3D Surface Plot of "dcs"-object or numeric
                        matrix
temp.nunn               Temperatures from Nunn, CO
temp.yuma               Temperatures from Yuma, AZ
volumes.alv             Volumes of Allianz SE
wind.nunn               Wind Speed from Nunn, CO
wind.yuma               Wind Speed from Yuma, AZ
y.norm1                 Single Gaussian Peak
y.norm2                 Double Gaussian Peak
y.norm3                 Double Gaussian Ridges
</pre>

<h3>Maintainer</h3>

<p>Bastian Schaefer &lt;bastian.schaefer@uni-paderborn.de&gt;</p>


<h3>Author(s)</h3>

<p>Bastian Schaefer [aut, cre], Sebastian Letmathe [ctb], Yuanhua
    Feng [ths]</p>

<hr>
<h2 id='kernel.assign'>Assign a Kernel Function</h2><span id='topic+kernel.assign'></span>

<h3>Description</h3>

<p>Assign a Kernel Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.assign(kernel_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.assign_+3A_kernel_id">kernel_id</code></td>
<td>
<p>a string specifying the kernel identifier as given in the
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>kernel.assign</code> returns an object of class &quot;function&quot;. This
function takes two arguments, a numeric vector in the first argument and a
single number in the second. The function itself will return a matrix with
one column and the same number of rows as the input vector.
</p>


<h3>Details</h3>

<p><code>kernel.assign</code> sets a pointer to a specified kernel function available 
in the DCSmooth package. The kernels are boundary kernels of the form
<code class="reqn">K(u,q)</code>, where <code class="reqn">u \in [-1, q]</code> and <code class="reqn">q \in [0, 1]</code>
q = [0, 1]. Kernels are of the Müller-Wang type (&quot;MW&quot;), Müller type (&quot;M&quot;)
or truncated kernels (&quot;TR&quot;).
</p>


<h3>References</h3>

<p>Müller, H.-G. and Wang, J.-L. (1994). Hazard rate estimation under random
censoring with varying kernels and bandwidths. Biometrics, 50:61-76.
</p>
<p>Müller, H.-G. (1991). Smooth optimum kernel estimators near endpoints.
Biometrika, 78:521-530.
</p>
<p>Feng, Y. and Schäfer B. (2021). Boundary Modification in Local Regression.
Working Papers CIE 144, Paderborn University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel.list">kernel.list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # See vignette("DCSmooth") for further examples and explanation

u &lt;- seq(from = -1, to = 0.5, length.out = 151)
kern_MW220 &lt;- kernel.assign("MW_220")
k &lt;- kern_MW220(u, 0.5)
plot(u, k, type = "l") 

</code></pre>

<hr>
<h2 id='kernel.list'>Print a list of available kernels in the DCSmooth package</h2><span id='topic+kernel.list'></span>

<h3>Description</h3>

<p>Print a list of available kernels in the DCSmooth package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.list(print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.list_+3A_print">print</code></td>
<td>
<p>Logical value. Should the list be printed to the console? If
<code>TRUE</code> (the default), the list is printed to the console, if
<code>FALSE</code> the list of identifiers is returned from the function as
(surprise!) a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>print = FALSE</code>, a list is returned containing the kernel
identifiers
</p>


<h3>Details</h3>

<p><code>kernel.list</code> is used to get a list of available kernels in the DCSmooth
package. 
</p>
<p><code>kernel.list</code> prints a list of identifiers <code>kernel_id</code> of available
kernels in the DCSmooth package. The available kernel types are &quot;T&quot;: 
truncated, &quot;MW&quot;: Müller-Wang boundary correction, &quot;M&quot;: Müller boundary
correction.
</p>


<h3>References</h3>

<p>Müller, H.-G. and Wang, J.-L. (1994). Hazard rate estimation under random
censoring with varying kernels and bandwidths. Biometrics, 50:61-76.
</p>
<p>Müller, H.-G. (1991). Smooth optimum kernel estimators near endpoints.
Biometrika, 78:521-530.
</p>
<p>Feng, Y. and Schäfer B. (2021). Boundary Modification in Local Regression.
Working Papers CIE 144, Paderborn University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel.assign">kernel.assign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # See vignette("DCSmooth") for further examples and explanation
 
 kernel.list()

</code></pre>

<hr>
<h2 id='plot.dcs'>Contour Plot for the Double Conditional Smoothing</h2><span id='topic+plot.dcs'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"dcs"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcs'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dcs_+3A_x">x</code></td>
<td>
<p>an object of class &quot;dcs_options&quot;, usually, a result of a call to 
<code><a href="#topic+set.options">set.options</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dcs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print.dcs_options</code>. The
argument <code>plot_choice</code> overrides the prompt to specify a plot, can be 
<code>c(1, 2, 3)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Details</h3>

<p><code>plot.dcs</code> provides a contour plot of either the original data (1),
smoothed surface (2) or residuals (3).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surface.dcs">surface.dcs</a></code> to plot the surface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Contour plot of smoothed surface
y &lt;- y.norm1 + matrix(rnorm(101^2), nrow = 101, ncol = 101)
dcs_object &lt;- dcs(y)
plot(dcs_object, plot_choice = 2)

</code></pre>

<hr>
<h2 id='print.dcs'>Summarize Results from Double Conditional Smoothing</h2><span id='topic+print.dcs'></span>

<h3>Description</h3>

<p><code>print</code> method for class <code>"dcs"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dcs_+3A_x">x</code></td>
<td>
<p>an object of class &quot;dcs&quot;, usually, a result of a call to 
<code><a href="#topic+dcs">dcs</a></code>.</p>
</td></tr>
<tr><td><code id="print.dcs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print.dcs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Details</h3>

<p><code>print.dcs</code> prints a short summary of an object of class <code>dcs</code>,
only including bandwidths and the estimated variance coefficient (only if
automatic bandwidth selection is used).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.dcs">plot.dcs</a></code>, <code><a href="#topic+print.dcs_options">print.dcs_options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- y.norm1 + matrix(rnorm(101^2), nrow = 101, ncol = 101)
dcs_object &lt;- dcs(y)
print(dcs_object)
dcs_object

</code></pre>

<hr>
<h2 id='print.dcs_options'>Print and Summarize Options for Double Conditional Smoothing</h2><span id='topic+print.dcs_options'></span>

<h3>Description</h3>

<p><code>print</code> method for class <code>"dcs_options"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcs_options'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dcs_options_+3A_x">x</code></td>
<td>
<p>an object of class &quot;dcs_options&quot;, usually, a result of a call
to <code><a href="#topic+set.options">set.options</a></code>.</p>
</td></tr>
<tr><td><code id="print.dcs_options_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print.dcs_options</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Details</h3>

<p><code>print.dcs_options</code> prints the main options and 
<code>summary.dcs_options</code> prints main and advanced (IPI) options used for
the <code><a href="#topic+dcs">dcs</a></code> function. Arguments should be an object of class
<code>"dcs_options"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.dcs">print.dcs</a></code>, <code><a href="#topic+summary.dcs_options">summary.dcs_options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Default options
myOpt &lt;- set.options()
print(myOpt)
summary(myOpt)

## Use Kernel regression
myOpt &lt;- set.options(type = "KR")
print(myOpt)
summary(myOpt)

</code></pre>

<hr>
<h2 id='print.summary_dcs'>Print the Summary of a DCS estimation</h2><span id='topic+print.summary_dcs'></span>

<h3>Description</h3>

<p><code>print</code> method for class <code>"summary_dcs"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_dcs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary_dcs_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary_dcs"</code>.</p>
</td></tr>
<tr><td><code id="print.summary_dcs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print.summary_dcs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dcs">summary.dcs</a></code>
</p>

<hr>
<h2 id='print.summary_sarma'>Print the Summary of a &quot;sarma&quot;/&quot;sfarima&quot; object</h2><span id='topic+print.summary_sarma'></span><span id='topic+print.summary_sfarima'></span>

<h3>Description</h3>

<p><code>print</code> methods for class <code>"summary_sarma"</code>/
<code>"summary_sfarima"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_sarma'
print(x, ...)

## S3 method for class 'summary_sfarima'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary_sarma_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary_sarma"</code> or
<code>"summary_sfarima"</code>.</p>
</td></tr>
<tr><td><code id="print.summary_sarma_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print.summary_sarma</code>/
<code>print.summary_sfarima</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sarma">summary.sarma</a></code> <code><a href="#topic+summary.sfarima">summary.sfarima</a></code>
</p>

<hr>
<h2 id='residuals.dcs'>Residuals of &quot;dcs&quot;-object</h2><span id='topic+residuals.dcs'></span>

<h3>Description</h3>

<p>Returns the residuals of an object of class <code>"dcs"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcs'
residuals(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.dcs_+3A_x">x</code></td>
<td>
<p>an object of class <code>"dcs"</code>, usually the result of a call to
<code><a href="#topic+dcs">dcs</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.dcs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>residuals.dcs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">n_x \times n_t</code>-matrix of residuals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcs">dcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = y.norm1 + matrix(rnorm(101^2), nrow = 101, ncol = 101)
dcs_object = dcs(y)
residuals(dcs_object)

</code></pre>

<hr>
<h2 id='returns.alv'>Returns of Allianz SE</h2><span id='topic+returns.alv'></span>

<h3>Description</h3>

<p>The (log-) returns of the shares of the German insurance company Allianz SE
from 2007-01-02 to 2010-12-30 aggregated to 5-minute observations. The data
is adjusted to matrix form for direct use with the <code>DCSmooth</code>-functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returns.alv
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 1016 rows representing the days and 101 columns
representing the intraday time points.
</p>

<hr>
<h2 id='sarma.est'>Estimation of an SARMA-process</h2><span id='topic+sarma.est'></span><span id='topic+qarma.est'></span>

<h3>Description</h3>

<p>Parametric Estimation of an <code class="reqn">SARMA(p, q)</code>-process on a 
lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma.est(Y, method = "HR", model_order = list(ar = c(1, 1), ma = c(1, 1)))

qarma.est(Y, model_order = list(ar = c(1, 1), ma = c(1, 1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sarma.est_+3A_y">Y</code></td>
<td>
<p>A numeric matrix that contains the demeaned observations of the
random field or functional time-series.</p>
</td></tr>
<tr><td><code id="sarma.est_+3A_method">method</code></td>
<td>
<p>Method used for estimation of the parameters. One of <code>
"HR", "sep", "RSS"</code>, default value is <code>"HR"</code></p>
</td></tr>
<tr><td><code id="sarma.est_+3A_model_order">model_order</code></td>
<td>
<p>A list containing the orders of the SARMA model in the
form <code>model_order = list(ar = c(p1, p2), ma = c(q1, q2))</code>. Default
value is a <code class="reqn">SARMA((1, 1), (1, 1))</code> model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>"sarma"</code> including
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>Y</code> </td><td style="text-align: left;"> The matrix of observations, inherited from input.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>innov</code> The estimated innovations.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>model</code> </td><td style="text-align: left;"> The estimated model consisting of the coefficient 
  matrices <code>ar</code> and <code>ma</code> and standard deviation of innovations
  <code>sigma</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>stnry</code> </td><td style="text-align: left;"> An logical variable indicating whether the estimated
  model is stationary.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>The MA- and AR-parameters of a top-left quadrant ARMA process are estimated
by the specified method. The lag-orders of the <code class="reqn">SARMA(p, q)</code> are given by
<code class="reqn">p = (p_1, p_2), q = (q_1, q_2)</code>, where
<code class="reqn">p_1, q_1</code> are the lags over the rows and <code class="reqn">p_2, q_2</code>
are the lags over the columns. The estimation process is based on the model
</p>
<p style="text-align: center;"><code class="reqn">\phi(B_{1}B_{2})X_{i,j} = \theta(B_{1}B_{2})u_{i,j}</code>
</p>
<p>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sarma.sim">sarma.sim</a></code>, <code><a href="#topic+sfarima.est">sfarima.est</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("DCSmooth") for examples and explanation

## simulation of SARMA process
ma &lt;- matrix(c(1, 0.2, 0.4, 0.1), nrow = 2, ncol = 2)
ar &lt;- matrix(c(1, 0.5, -0.1, 0.1), nrow = 2, ncol = 2)
sigma &lt;- 0.5
sarma_model &lt;- list(ar = ar, ma = ma, sigma = sigma)
sarma_simulated &lt;- sarma.sim(100, 100, model = sarma_model)
sarma_simulated$model

## estimation of SARMA process
sarma.est(sarma_simulated$Y)$model
sarma.est(sarma_simulated$Y, 
           model_order = list(ar = c(1, 1), ma = c(1, 1)))$model

</code></pre>

<hr>
<h2 id='sarma.sim'>Simulation of a <code class="reqn">SARMA(p, q)</code>-process</h2><span id='topic+sarma.sim'></span><span id='topic+qarma.sim'></span>

<h3>Description</h3>

<p><code>sarma.sim</code> simulates a specified SARMA-model
on a lattice with normally distributed innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma.sim(n_x, n_t, model)

qarma.sim(n_x, n_t, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sarma.sim_+3A_n_x">n_x</code></td>
<td>
<p>Number of simulated observation rows.</p>
</td></tr>
<tr><td><code id="sarma.sim_+3A_n_t">n_t</code></td>
<td>
<p>Number of simulated observation columns.</p>
</td></tr>
<tr><td><code id="sarma.sim_+3A_model">model</code></td>
<td>
<p>A list containing the coefficient matrices <code>ar</code> and 
<code>ma</code> of the SARMA model as well as the standard deviation of 
innovations <code>sigma</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>"sarma"</code>, consisting of
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>Y</code> </td><td style="text-align: left;"> A <code class="reqn">n_x \times n_t</code>-matrix of simulated values
  of the specified SARMA process.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>innov</code> </td><td style="text-align: left;"> The innovations used for simulation, iid. drawn from a 
   normal distribution with zero mean and variance 
   <code class="reqn">\sigma^2</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>model</code> </td><td style="text-align: left;"> The model used for simulation, inherited from input.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>stnry</code> </td><td style="text-align: left;"> An logical variable indicating whether the simulated 
  model is stationary.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Simulation of a top-left dependent spatial ARMA process (SARMA). This 
function returns an object of class <code>"sarma"</code>. The simulated innovations
are created from a normal distribution with specified variance
<code class="reqn">\sigma^2</code>.
</p>
<p>see the vignette for further details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sarma.est">sarma.est</a></code>, <code><a href="#topic+sfarima.est">sfarima.est</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("DCSmooth") for examples and explanation
 
ma &lt;- matrix(c(1, 0.2, 0.4, 0.1), nrow = 2, ncol = 2)
ar &lt;- matrix(c(1, 0.5, -0.1, 0.1), nrow = 2, ncol = 2)
sigma &lt;- 0.5
sarma_model &lt;- list(ar = ar, ma = ma, sigma = sigma)

sarma_sim &lt;- sarma.sim(100, 100, model = sarma_model)
summary(sarma_sim)

</code></pre>

<hr>
<h2 id='set.options'>Set Options for the DCS procedure</h2><span id='topic+set.options'></span>

<h3>Description</h3>

<p>Set Options for the DCS procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.options(
  type = "LP",
  kerns = c("MW_220", "MW_220"),
  drv = c(0, 0),
  var_model = "iid",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.options_+3A_type">type</code></td>
<td>
<p>either local polynomial regression (<code>"LP"</code>, the default) or 
kernel regression (<code>"KR"</code>).</p>
</td></tr>
<tr><td><code id="set.options_+3A_kerns">kerns</code></td>
<td>
<p>a character vector of length 2 containing the identifier for the
kernels to be used in kernel regression. Weighting functions in local
polynomial regression are computed according to the identifier. Default value
is <code>MW_220</code>, the Mueller-Wang kernel of order <code class="reqn">(2, 2, 0)</code>. If only
a single value is provided, it is used as kernel in both directions.</p>
</td></tr>
<tr><td><code id="set.options_+3A_drv">drv</code></td>
<td>
<p>A non-negative vector of length 2, containing the derivative
orders to be estimated from the given data. The default is <code>c(0, 0)</code>. For
LP-regression, polynomial order is selected as <code class="reqn">(\nu_1 + 1, \nu_2 + 1)</code>.
If only a single value is provided, it is used as derivative in both 
directions.</p>
</td></tr>
<tr><td><code id="set.options_+3A_var_model">var_model</code></td>
<td>
<p>the method of estimating the variance coefficient <code class="reqn">c_f</code>. 
Currently available are <code>var_model = c("iid", "sarma_HR", "sarma_sep",
"sarma_RSS", "sfarima_RSS")</code>. Replacing the argument <code>var_model</code>. For
code using <code>var_est</code>, the argument is converted to <code>var_model</code>.</p>
</td></tr>
<tr><td><code id="set.options_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>set.options()</code>. This includes
<code>IPI_options</code>, a list containing further options used by the iterative
plug-in algorithm. For convenience, any of the options usually included in 
the list <code>IPI_options</code> can be passed as argument directly to 
<code>set.options</code> and will be converted into the <code>IPI_options</code> list.
Further arguments accepted are <code>model_order</code> controlling the order of
the variance model, if either an SARMA or SFARIMA model is used. This 
argument is either a list of the form <code>list(ar = c(1, 1), ma = c(1, 1))</code>
or specifies an order selection criterion from <code>c("aic", "bic", "gpac")</code>.
If an order selection criterion is used, the argument <code>order_max</code> 
controls the maximum order to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"dcs_options"</code>.
</p>


<h3>Details</h3>

<p>This function is used to set the options for bandwidth selection in the 
<code>dcs</code> function.
Detailed information can be found in the vignette.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcs">dcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("DCSmooth") for examples and explanation

set.options()

myOpt &lt;- set.options(type = "KR", var_model = "iid")
y &lt;- y.norm1 + matrix(rnorm(101^2), nrow = 101, ncol = 101)
dcs(y, dcs_options = myOpt)
</code></pre>

<hr>
<h2 id='sfarima.est'>Estimation of a SFARIMA-process</h2><span id='topic+sfarima.est'></span>

<h3>Description</h3>

<p>Parametric Estimation of a <code class="reqn">SFARIMA(p, q, d)</code>-process on a 
lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfarima.est(Y, model_order = list(ar = c(1, 1), ma = c(1, 1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfarima.est_+3A_y">Y</code></td>
<td>
<p>A numeric matrix that contains the demeaned observations of the
random field or functional time-series.</p>
</td></tr>
<tr><td><code id="sfarima.est_+3A_model_order">model_order</code></td>
<td>
<p>A list containing the orders of the SFARIMA model in the
form <code>model_order = list(ar = c(p1, p2), ma = c(q1, q2))</code>. Default
value is a <code class="reqn">SFARIMA((1, 1), (1, 1), d)</code> model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>"sfarima"</code> including
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>Y</code> </td><td style="text-align: left;"> The matrix of observations, inherited from input.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>innov</code> The estimated innovations.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>model</code> </td><td style="text-align: left;"> The estimated model consisting of the coefficient 
  matrices <code>ar</code> and <code>ma</code>, the estimated long memory parameters
  <code>d</code> and standard deviation of innovations <code>sigma</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>stnry</code> </td><td style="text-align: left;"> An logical variable indicating whether the estimated
  model is stationary.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>The MA- and AR-parameters as well as the long-memory parameters </p>
<p style="text-align: center;"><code class="reqn">d</code>
</p>
<p> of a
SFARIMA process are estimated by minimization of the residual sum of squares
RSS. Lag-orders of <code class="reqn">SFARIMA(p, q, d)</code> are given by <code class="reqn">p = (p_1, p_2), 
q = (q_1, q_2)</code>, where <code class="reqn">p_1, q_1</code> are
the lags over the rows and <code class="reqn">p_2, q_2</code> are the lags over the 
columns. The estimated process is based on the (separable) model 
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{ij} = \Psi_1(B) \Psi_2(B) \eta_{ij}</code>
</p>
<p>, where </p>
<p style="text-align: center;"><code class="reqn">\Psi_i =
(1 - B_i)^{-d_i}\phi^{-1}_i(B_i)\psi_i(B_i), i = 1,2</code>
</p>
<p>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sarma.est">sarma.est</a>, <a href="#topic+sfarima.sim">sfarima.sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("DCSmooth") for examples and explanation

## simulation of SFARIMA process
ma &lt;- matrix(c(1, 0.2, 0.4, 0.1), nrow = 2, ncol = 2)
ar &lt;- matrix(c(1, 0.5, -0.1, 0.1), nrow = 2, ncol = 2)
d &lt;- c(0.1, 0.1)
sigma &lt;- 0.5
sfarima_model &lt;- list(ar = ar, ma = ma, d = d, sigma = sigma)
sfarima_sim &lt;- sfarima.sim(50, 50, model = sfarima_model)

## estimation of SFARIMA process
sfarima.est(sfarima_sim$Y)$model
sfarima.est(sfarima_sim$Y, 
           model_order = list(ar = c(1, 1), ma = c(0, 0)))$model

</code></pre>

<hr>
<h2 id='sfarima.sim'>Simulation of a <code class="reqn">SFARIMA(p, q, d)</code>-process</h2><span id='topic+sfarima.sim'></span>

<h3>Description</h3>

<p><code>sfarima.sim</code> simulates a specified SFARIMA-model
on a lattice with normally distributed innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfarima.sim(n_x, n_t, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfarima.sim_+3A_n_x">n_x</code></td>
<td>
<p>Number of simulated observation rows.</p>
</td></tr>
<tr><td><code id="sfarima.sim_+3A_n_t">n_t</code></td>
<td>
<p>Number of simulated observation columns.</p>
</td></tr>
<tr><td><code id="sfarima.sim_+3A_model">model</code></td>
<td>
<p>A list containing the coefficient matrices <code>ar</code> and 
<code>ma</code> of the QARMA model, the long memory parameter vector <code>d</code> as
well as the standard deviation of innovations <code>sigma</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>"sfarima"</code>, consisting
of
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>Y</code> </td><td style="text-align: left;"> A <code class="reqn">n_x \times n_t</code>-matrix of simulated values
  of the specified SFARIMA process.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>innov</code> </td><td style="text-align: left;"> The innovations used for simulation, iid. drawn from a 
   normal distribution with zero mean and variance 
   <code class="reqn">\sigma^2</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>model</code> </td><td style="text-align: left;"> The model used for simulation, inherited from input.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>stnry</code> </td><td style="text-align: left;"> An logical variable indicating whether the simulated 
  model is stationary.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Simulation of a separable spatial fractionally ARIMA process (SFARIMA). This 
function returns an object of class <code>"sfarima"</code>. The simulated
innovations are created from a normal distribution with specified variance
<code class="reqn">\sigma^2</code>.
</p>
<p>see the vignette for further details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qarma.est">qarma.est</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("DCSmooth") for examples and explanation
 
ma &lt;- matrix(c(1, 0.2, 0.4, 0.1), nrow = 2, ncol = 2)
ar &lt;- matrix(c(1, 0.5, -0.1, 0.1), nrow = 2, ncol = 2)
d &lt;- c(0.1, 0.1)
sigma &lt;- 0.5
sfarima_model &lt;- list(ar = ar, ma = ma, d = d, sigma = sigma)

sfarima_sim &lt;- sfarima.sim(100, 100, model = sfarima_model)
surface.dcs(sfarima_sim$Y)

</code></pre>

<hr>
<h2 id='summary.dcs'>Summarizing Results from Double Conditional Smoothing</h2><span id='topic+summary.dcs'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"dcs"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dcs_+3A_object">object</code></td>
<td>
<p>an object of class &quot;dcs&quot;, usually, a result of a call to 
<code><a href="#topic+dcs">dcs</a></code>.</p>
</td></tr>
<tr><td><code id="summary.dcs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>summary.dcs</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.dcs</code> returns an object of class 
<code>summary_dcs</code> including </p>

<table>
<tr>
 <td style="text-align: left;">
 <code>h_opt</code> </td><td style="text-align: left;"> estimated optimal bandwidth from the IPI-procedure. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>c_f</code> </td><td style="text-align: left;"> estimated variance factor. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>iterations</code> </td><td style="text-align: left;"> number of iterations of the IPI-procedure. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>time_used</code> </td><td style="text-align: left;"> time spend searching for optimal bandwidths (not 
  overall runtime of the function). </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>var_est</code> </td><td style="text-align: left;"> estimated variance model. Has class "sarma" if an
  SARMA model is used and class "sfarima" if an SFARIMA model is used.</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>var_model_id</code> </td><td style="text-align: left;"> identifier for the variance model estimated. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>var_model_order</code> </td><td style="text-align: left;"> order of the estimated variance model, if either
  SARMA or SFARIMA is used. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>dcs_options</code> </td><td style="text-align: left;"> an object of class <code>cds_options</code> containing the
  initial options of the dcs procedure. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p><code>summary.dcs</code> strips an object of class <code>"dcs"</code> from all large
matrices (<code>Y</code>, <code>X</code>, <code>T</code>, <code>M</code>, <code>R</code>), allowing
for easier handling of meta-statistics of the bandwidth selection procedure.
</p>
<p><code>print.summary_dcs</code> returns a list of summary statistics
from the dcs procedure. The output depends on the use of the <code>dcs</code>-
function. If automatic bandwidth selection is chosen, <code>summary.dcs</code>
prints detailed statistics of the type of regression, the estimated 
bandwidths <code>h_x</code>, <code>h_t</code>, the variance coefficient <code>c_f</code> and 
performance statistics such as the number of iterations of the IPI-algorithm 
and the time used for bandwidth selection.
</p>
<p>The method used for estimation of the variance coefficient is printed and 
the results of an SARMA/SFARIMA-estimation, if available.
</p>
<p>If bandwidths are supplied to <code>dcs</code>, <code>summary.dcs</code> only prints
the given bandwidths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- y.norm1 + matrix(rnorm(101^2), nrow = 101, ncol = 101)
dcs_object &lt;- dcs(y)
summary(dcs_object)

</code></pre>

<hr>
<h2 id='summary.dcs_options'>Print and Summarize Options for Double Conditional Smoothing</h2><span id='topic+summary.dcs_options'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"dcs_options"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcs_options'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dcs_options_+3A_object">object</code></td>
<td>
<p>an object of class &quot;dcs_options&quot;, usually, a result of a call
to <code><a href="#topic+set.options">set.options</a></code>.</p>
</td></tr>
<tr><td><code id="summary.dcs_options_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>summary.dcs_options</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Details</h3>

<p><code>print.dcs_options</code> prints the main options and 
<code>summary.dcs_options</code> prints main and advanced (IPI) options used for
the <code><a href="#topic+dcs">dcs</a></code> function. Arguments should be an object of class
<code>"dcs_options"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.dcs">print.dcs</a></code>, <code><a href="#topic+print.dcs_options">print.dcs_options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Default options
myOpt &lt;- set.options()
print(myOpt)
summary(myOpt)

## Use Kernel regression
myOpt &lt;- set.options(type = "KR")
print(myOpt)
summary(myOpt)

</code></pre>

<hr>
<h2 id='summary.sarma'>Summarizing SARMA/SFARIMA Estimation or Simulation</h2><span id='topic+summary.sarma'></span><span id='topic+summary.sfarima'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;sarma&quot; or &quot;sfarima&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sarma'
summary(object, ...)

## S3 method for class 'sfarima'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sarma_+3A_object">object</code></td>
<td>
<p>an object of class &quot;sarma&quot; or &quot;sfarima&quot;, usually a result of a
call to the estimation functions <code><a href="#topic+sarma.est">sarma.est</a></code>, 
<code><a href="#topic+sfarima.est">sfarima.est</a></code> or to the corresponding simulation functions 
<code><a href="#topic+sarma.sim">sarma.sim</a></code> and <code><a href="#topic+sfarima.sim">sfarima.sim</a></code>.</p>
</td></tr>
<tr><td><code id="summary.sarma_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>summary.sarma</code>/
<code>summary.sfarima</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.sarma</code>/<code>summary.sfarima</code> returns an 
object of class <code>summary_sarma</code> including </p>

<table>
<tr>
 <td style="text-align: left;">
 <code>model</code> </td><td style="text-align: left;"> estimated or simulated model parameters including 
 coefficient matrices <code>ar</code>, <code>ma</code>, the error term standard deviation
 <code>sigma</code> and the vector of long memory parameters <code>d</code> 
 (<code>summary.sarma</code> only)  </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>model_order</code> </td><td style="text-align: left;"> order of the estimated/simulated model computed from 
 the matrices <code>ar</code>, <code>ma</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>stnry</code> </td><td style="text-align: left;"> a flag for stationarity of the short memory part. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>subclass</code> </td><td style="text-align: left;"> a flag indicating whether the object inherits from an
 estimation (<code>subclass = "est"</code>) or simulation procedure 
 (<code>subclass = "sim"</code>). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p><code>summary.sarma</code>/<code>summary.sfarima</code> strips an object of class
&quot;sarma&quot;/&quot;sfarima&quot; from all large matrices (<code>Y</code>, <code>innov</code>), allowing
for easier handling of meta-statistics of the bandwidth selection procedure.
</p>
<p><code>print.summary_sarma</code>/<code>print.summary_sarma</code> returns a list of 
summary statistics from the estimation or simulation procedure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sarma.est">sarma.est</a>, <a href="#topic+sfarima.est">sfarima.est</a>, <a href="#topic+sarma.sim">sarma.sim</a>,
 <a href="#topic+sfarima.sim">sfarima.sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># SARMA Simulation and Estimation
ma = matrix(c(1, 0.2, 0.4, 0.1), nrow = 2, ncol = 2)
ar = matrix(c(1, 0.5, -0.1, 0.1), nrow = 2, ncol = 2)
sigma = 0.5
sarma_model = list(ar = ar, ma = ma, sigma = sigma)
sarma_sim = sarma.sim(100, 100, model = sarma_model)
summary(sarma_sim)
sarma_est = sarma.est(sarma_sim$Y)
summary(sarma_est)

# SFARIMA Simulation and Estimation
ma = matrix(c(1, 0.2, 0.4, 0.1), nrow = 2, ncol = 2)
ar = matrix(c(1, 0.5, -0.1, 0.1), nrow = 2, ncol = 2)
d = c(0.1, 0.1)
sigma = 0.5
sfarima_model = list(ar = ar, ma = ma, d = d, sigma = sigma)
sfarima_sim = sfarima.sim(100, 100, model = sfarima_model)
summary(sfarima_sim)
sfarima_est = sfarima.est(sfarima_sim$Y)
summary(sfarima_est)

</code></pre>

<hr>
<h2 id='surface.dcs'>3D Surface Plot of &quot;dcs&quot;-object or numeric matrix</h2><span id='topic+surface.dcs'></span>

<h3>Description</h3>

<p>3D Surface Plot of &quot;dcs&quot;-object or numeric matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface.dcs(Y, trim = c(0, 0), plot_choice = "choice", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surface.dcs_+3A_y">Y</code></td>
<td>
<p>an object of class <code>"dcs"</code> or a numeric matrix that contains the
values to be plotted.</p>
</td></tr>
<tr><td><code id="surface.dcs_+3A_trim">trim</code></td>
<td>
<p>a numeric vector with two values specifying the percentage of
trimming applied to the boundaries of the surface to plot. Useful for
derivative estimation.</p>
</td></tr>
<tr><td><code id="surface.dcs_+3A_plot_choice">plot_choice</code></td>
<td>
<p>override the prompt to specify a plot, can be 
<code>c(1, 2, 3)</code>.</p>
</td></tr>
<tr><td><code id="surface.dcs_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dcs.3d</code> returns an object of class &quot;plotly&quot; and &quot;htmlwidget&quot;.
</p>


<h3>Details</h3>

<p><code>surface.dcs</code> uses the plotly device to plot the 3D surface of the given
<code>"dcs"</code>-object or matrix. If a &quot;dcs&quot;-object is passed to the function, 
it can be chosen between plots of the original data (1), smoothed surface 
(2) and residuals (3).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.dcs">plot.dcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("DCSmooth") for examples and explanation

smth &lt;-  dcs(y.norm1 + rnorm(101^2))
surface.dcs(smth, trim = c(0.05, 0.05), plot_choice = 2)

</code></pre>

<hr>
<h2 id='temp.nunn'>Temperatures from Nunn, CO</h2><span id='topic+temp.nunn'></span>

<h3>Description</h3>

<p>This dataset contains the 5-minute observations of the 2020 temperature in
Nunn, CO. The data is from the U.S. Climate Reference Network database at 
<a href="https://www.ncdc.noaa.gov/crn/qcdatasets.html">www.ncdc.noaa.gov</a>. 
(see Diamond et al., 2013). The observations were adjusted matrix form for 
direct use with the <code>DCSmooth</code>-functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp.nunn
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 366 rows and 288 columns containing the
temperatures in Celsius.
</p>

<hr>
<h2 id='temp.yuma'>Temperatures from Yuma, AZ</h2><span id='topic+temp.yuma'></span>

<h3>Description</h3>

<p>This dataset contains the 5-minute observations of the 2020 temperature in
Yuma, AZ. The data is from the U.S. Climate Reference Network database at 
<a href="https://www.ncdc.noaa.gov/crn/qcdatasets.html">www.ncdc.noaa.gov</a>. 
(see Diamond et al., 2013). The observations were adjusted matrix form for 
direct use with the <code>DCSmooth</code>-functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp.yuma
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 366 rows and 288 columns containing the
temperatures in Celsius.
</p>

<hr>
<h2 id='volumes.alv'>Volumes of Allianz SE</h2><span id='topic+volumes.alv'></span>

<h3>Description</h3>

<p>The trading volumes of the shares of the German insurance company Allianz SE
from 2007-01-02 to 2010-09-30 aggregated to 5-minute observations. The data
is adjusted to matrix form for direct use with the <code>DCSmooth</code>-functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volumes.alv
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 1016 rows representing the days and 102 columns
representing the intraday time points.
</p>

<hr>
<h2 id='wind.nunn'>Wind Speed from Nunn, CO</h2><span id='topic+wind.nunn'></span>

<h3>Description</h3>

<p>This dataset contains the 5-minute observations of the 2020 wind speed in
Nunn, CO. The data is from the U.S. Climate Reference Network database at 
<a href="https://www.ncdc.noaa.gov/crn/qcdatasets.html">www.ncdc.noaa.gov</a>. 
(see Diamond et al., 2013). The observations were adjusted matrix form for 
direct use with the <code>DCSmooth</code>-functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind.nunn
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 366 rows and 288 columns containing the
wind speed in <code class="reqn">m/s</code>.
</p>

<hr>
<h2 id='wind.yuma'>Wind Speed from Yuma, AZ</h2><span id='topic+wind.yuma'></span>

<h3>Description</h3>

<p>This dataset contains the 5-minute observations of the 2020 wind speed in
Yuma, AZ. The data is from the U.S. Climate Reference Network database at 
<a href="https://www.ncdc.noaa.gov/crn/qcdatasets.html">www.ncdc.noaa.gov</a>. 
(see Diamond et al., 2013). The observations were adjusted matrix form for 
direct use with the <code>DCSmooth</code>-functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind.yuma
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 366 rows and 288 columns containing the
wind speeds in <code class="reqn">m/s</code>.
</p>

<hr>
<h2 id='y.norm1'>Single Gaussian Peak</h2><span id='topic+y.norm1'></span>

<h3>Description</h3>

<p>Example data for using the DCSmooth functions. Data resembles a single
gaussian peak on the interval <code class="reqn">[0,1] \times [0,1]</code>
with maximum at <code class="reqn">(0.5, 0.5)</code> and variance matrix <code class="reqn">0.1 \cdot
 {\bf I}</code>, where 
<code class="reqn">{\bf I}</code> represents the <code class="reqn">2 \times 2</code> identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y.norm1
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 101 rows and 101 columns.
</p>

<hr>
<h2 id='y.norm2'>Double Gaussian Peak</h2><span id='topic+y.norm2'></span>

<h3>Description</h3>

<p>Example data for using the DCSmooth functions. Data resembles two gaussian
peaks on the interval <code class="reqn">[0,1] \times [0,1]</code> with maxima
at <code class="reqn">(0.5, 0.3)</code> with variance matrix <code class="reqn">0.1 \cdot {\bf I}</code>
and at <code class="reqn">(0.2, 0.8)</code> with variance matrix <code class="reqn">0.05 \cdot {\bf I}</code>, where <code class="reqn">{\bf I}</code> represents the <code class="reqn">2 \times 2</code>
identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y.norm2
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 101 rows and 101 columns.
</p>

<hr>
<h2 id='y.norm3'>Double Gaussian Ridges</h2><span id='topic+y.norm3'></span>

<h3>Description</h3>

<p>Example data for using the DCSmooth functions. Data resembles two gaussian
ridges on the interval <code class="reqn">[0,1] \times [0,1]</code> with maxima
at <code class="reqn">(0.25, 0.75)</code> with variance matrix
<code class="reqn">(0.01, -0.1) \cdot {\bf I}</code> and at
<code class="reqn">(0.75, 0.5)</code> with variance matrix
<code class="reqn">(0.01, -0.1) \cdot {\bf I}</code>, where 
<code class="reqn">{\bf I}</code> represents the <code class="reqn">2 \times 2</code> identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y.norm3
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 101 rows and 101 columns.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
