<!DOCTYPE html><html><head><title>Help for package mixedCCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mixedCCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CorrStructure'><p>Construct a correlation matrix</p></a></li>
<li><a href='#estimateR'><p>Estimate latent correlation matrix</p></a></li>
<li><a href='#find_w12bic'><p>Internal mixedCCA function finding w1 and w2 given R1, R2 and R12</p></a></li>
<li><a href='#GenerateData'><p>Mixed type simulation data generator for sparse CCA</p></a></li>
<li><a href='#KendallTau'><p>Kendall's tau correlation</p></a></li>
<li><a href='#lambdaseq_generate'><p>Internal data-driven lambda sequence generating function.</p></a></li>
<li><a href='#mixedCCA'><p>Sparse CCA for data of mixed types with BIC criterion</p></a></li>
<li><a href='#myrcc'><p>Internal RidgeCCA function</p></a></li>
<li><a href='#standardCCA'><p>Internal standard CCA function.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Canonical Correlation Analysis for High-Dimensional Mixed
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-09</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Irina Gaynanova &lt;irinag@stat.tamu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Semi-parametric approach for sparse canonical correlation analysis 
    which can handle mixed data types: continuous, binary and truncated continuous.
    Bridge functions are provided to connect Kendall's tau to latent correlation
    under the Gaussian copula model. The methods are described in 
    Yoon, Carroll and Gaynanova (2020) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasaa007">doi:10.1093/biomet/asaa007</a>&gt; and 
    Yoon, Mueller and Gaynanova (2021) &lt;<a href="https://doi.org/10.1080%2F10618600.2021.1882468">doi:10.1080/10618600.2021.1882468</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1), stats, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, pcaPP, Matrix, fMultivar, mnormt, irlba, latentcor (&ge;
2.0.1)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-09 21:19:49 UTC; irinag</td>
</tr>
<tr>
<td>Author:</td>
<td>Grace Yoon <a href="https://orcid.org/0000-0003-3263-1352"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mingze Huang <a href="https://orcid.org/0000-0003-3919-1564"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Irina Gaynanova <a href="https://orcid.org/0000-0002-4116-0268"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-09 21:50:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='CorrStructure'>Construct a correlation matrix</h2><span id='topic+CorrStructure'></span><span id='topic+autocor'></span><span id='topic+blockcor'></span>

<h3>Description</h3>

<p>Functions to create autocorrelation matrix (p by p) with parameter rho and block correlation matrix (p by p) using group index (of length p) and (possibly) different parameter rho for each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocor(p, rho)

blockcor(blockind, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CorrStructure_+3A_p">p</code></td>
<td>
<p>Specified matrix dimension.</p>
</td></tr>
<tr><td><code id="CorrStructure_+3A_rho">rho</code></td>
<td>
<p>Correlation value(s), must be between -0.99 and 0.99. Should be a scalar for <code>autocor</code>, and either a scalar or a vector of the same length as the maximal <code>blockind</code> K for <code>blockcor</code>.</p>
</td></tr>
<tr><td><code id="CorrStructure_+3A_blockind">blockind</code></td>
<td>
<p>Block index 1,..., K for a positive integer K specifying which variable belongs to which block, the matrix dimension is equal to <code>length(blockind)</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># For p = 8,
# auto correlation matrix
autocor(8, 0.8)
# block correlation matrix: two blocks with the same correlation within each block
blockcor(c(rep(1,3), rep(2,5)), 0.8)
# block correlation matrix: two blocks with different correlation within each block
blockcor(c(rep(1,3), rep(2,5)), c(0.8, 0.3))

</code></pre>

<hr>
<h2 id='estimateR'>Estimate latent correlation matrix</h2><span id='topic+estimateR'></span><span id='topic+estimateR_mixed'></span>

<h3>Description</h3>

<p>Estimation of latent correlation matrix from observed data of (possibly) mixed types (continuous/binary/truncated continuous) based on the latent Gaussian copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateR(
  X,
  type = "trunc",
  method = "original",
  use.nearPD = TRUE,
  nu = 0.01,
  tol = 0.001,
  verbose = FALSE
)

estimateR_mixed(
  X1,
  X2,
  type1 = "trunc",
  type2 = "continuous",
  method = "original",
  use.nearPD = TRUE,
  nu = 0.01,
  tol = 0.001,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateR_+3A_x">X</code></td>
<td>
<p>A numeric data matrix (n by p), n is the sample size and p is the number of variables.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_type">type</code></td>
<td>
<p>A type of variables in <code>X</code>, must be one of &quot;continuous&quot;, &quot;binary&quot; or &quot;trunc&quot;.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_method">method</code></td>
<td>
<p>The calculation method of latent correlation. Either &quot;original&quot; method or &quot;approx&quot;. If <code>method = "approx"</code>, multilinear approximation method is used, which is much faster than the original method (requires <code>chebpol</code> R package). If <code>method = "original"</code>, optimization of the bridge inverse function is used. The default is &quot;original&quot;.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_use.nearpd">use.nearPD</code></td>
<td>
<p>A logical value indicating whether to use <a href="Matrix.html#topic+nearPD">nearPD</a> or not when the resulting correlation estimator is not positive definite (have at least one negative eigenvalue).</p>
</td></tr>
<tr><td><code id="estimateR_+3A_nu">nu</code></td>
<td>
<p>Shrinkage parameter for correlation matrix, must be between 0 and 1, the default value is 0.01.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_tol">tol</code></td>
<td>
<p>Desired accuracy when calculating the solution of bridge function.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = FALSE</code>, printing information whether nearPD is used or not is disabled. The default value is FALSE.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_x1">X1</code></td>
<td>
<p>A numeric data matrix (n by p1).</p>
</td></tr>
<tr><td><code id="estimateR_+3A_x2">X2</code></td>
<td>
<p>A numeric data matrix (n by p2).</p>
</td></tr>
<tr><td><code id="estimateR_+3A_type1">type1</code></td>
<td>
<p>A type of variables in <code>X1</code>, must be one of &quot;continuous&quot;, &quot;binary&quot; or &quot;trunc&quot;.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_type2">type2</code></td>
<td>
<p>A type of variables in <code>X2</code>, must be one of &quot;continuous&quot;, &quot;binary&quot; or &quot;trunc&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>estimateR</code> returns
</p>

<ul>
<li><p>type: Type of the data matrix <code>X</code>
</p>
</li>
<li><p>R: Estimated p by p latent correlation matrix of <code>X</code>
</p>
</li></ul>

<p><code>estimateR_mixed</code> returns
</p>

<ul>
<li><p>type1: Type of the data matrix <code>X1</code>
</p>
</li>
<li><p>type2: Type of the data matrix <code>X2</code>
</p>
</li>
<li><p>R: Estimated latent correlation matrix of whole <code>X</code> = (<code>X1</code>, <code>X2</code>) (p1+p2 by p1+p2)
</p>
</li>
<li><p>R1: Estimated latent correlation matrix of <code>X1</code> (p1 by p1)
</p>
</li>
<li><p>R2: Estimated latent correlation matrix of <code>X2</code> (p2 by p2)
</p>
</li>
<li><p>R12: Estimated latent correlation matrix between <code>X1</code> and <code>X2</code> (p1 by p2)
</p>
</li></ul>



<h3>References</h3>

<p>Fan J., Liu H., Ning Y. and Zou H. (2017) &quot;High dimensional semiparametric latent graphicalmodel for mixed data&quot; &lt;doi:10.1111/rssb.12168&gt;.
</p>
<p>Yoon G., Carroll R.J. and Gaynanova I. (2020) &quot;Sparse semiparametric canonical correlation analysis for data of mixed types&quot; &lt;doi:10.1093/biomet/asaa007&gt;.
</p>
<p>Yoon G., Mueller C.L., Gaynanova I. (2020) &quot;Fast computation of latent correlations&quot; &lt;arXiv:2006.13875&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Data setting
n &lt;- 100; p1 &lt;- 15; p2 &lt;- 10 # sample size and dimensions for two datasets.
maxcancor &lt;- 0.9 # true canonical correlation

### Correlation structure within each data set
set.seed(0)
perm1 &lt;- sample(1:p1, size = p1);
Sigma1 &lt;- autocor(p1, 0.7)[perm1, perm1]
blockind &lt;- sample(1:3, size = p2, replace = TRUE);
Sigma2 &lt;- blockcor(blockind, 0.7)
mu &lt;- rbinom(p1+p2, 1, 0.5)

### true variable indices for each dataset
trueidx1 &lt;- c(rep(1, 3), rep(0, p1-3))
trueidx2 &lt;- c(rep(1, 2), rep(0, p2-2))

### Data generation
simdata &lt;- GenerateData(n=n, trueidx1 = trueidx1, trueidx2 = trueidx2, maxcancor = maxcancor,
                        Sigma1 = Sigma1, Sigma2 = Sigma2,
                        copula1 = "exp", copula2 = "cube",
                        muZ = mu,
                        type1 = "trunc", type2 = "continuous",
                        c1 = rep(1, p1), c2 =  rep(0, p2)
)
X1 &lt;- simdata$X1
X2 &lt;- simdata$X2

### Check the range of truncation levels of variables
range(colMeans(X1 == 0))
range(colMeans(X2 == 0))

### Estimate latent correlation matrix
# with original method
R1_org &lt;- estimateR(X1, type = "trunc", method = "original")$R
# with faster approximation method
R1_approx &lt;- estimateR(X1, type = "trunc", method = "approx")$R
R12_approx &lt;- estimateR_mixed(X1, X2, type1 = "trunc", type2 = "continuous", method = "approx")$R12


</code></pre>

<hr>
<h2 id='find_w12bic'>Internal mixedCCA function finding w1 and w2 given R1, R2 and R12</h2><span id='topic+find_w12bic'></span>

<h3>Description</h3>

<p>Internal mixedCCA function finding w1 and w2 given R1, R2 and R12
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_w12bic(
  n,
  R1,
  R2,
  R12,
  lamseq1,
  lamseq2,
  w1init,
  w2init,
  BICtype,
  maxiter = 100,
  tol = 0.01,
  trace = FALSE,
  lassoverbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_w12bic_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_r1">R1</code></td>
<td>
<p>Correlation matrix of dataset <code>X1</code> (p1 by p1)</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_r2">R2</code></td>
<td>
<p>Correlation matrix of dataset <code>X2</code> (p2 by p2)</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_r12">R12</code></td>
<td>
<p>Correlation matrix between the dataset <code>X1</code> and the dataset <code>X2</code> (p1 by p2)</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_lamseq1">lamseq1</code></td>
<td>
<p>A sequence of lambda values for the datasets <code>X1</code>. It can be a scalar (a vector of one value). should be the same length with lamseq2.</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_lamseq2">lamseq2</code></td>
<td>
<p>A sequence of lambda values for the datasets <code>X2</code>. It can be a scalar (a vector of one value). should be the same length with lamseq1.</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_w1init">w1init</code></td>
<td>
<p>An initial vector of length p1 for canonical direction <code class="reqn">w1</code>.</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_w2init">w2init</code></td>
<td>
<p>An initial vector of length p1 for canonical direction <code class="reqn">w2</code>.</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_bictype">BICtype</code></td>
<td>
<p>Either 1 or 2: For more details for two options, see the reference.</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_tol">tol</code></td>
<td>
<p>The desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_trace">trace</code></td>
<td>
<p>If <code>trace = TRUE</code>, progress per each iteration will be printed. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="find_w12bic_+3A_lassoverbose">lassoverbose</code></td>
<td>
<p>If <code>lassoverbose = TRUE</code>, all warnings from lassobic optimization regarding convergence will be printed. The default value is <code>lassoverbose = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>find_w12bic</code> returns a data.frame containing
</p>

<ul>
<li><p>w1: estimated canonical direction <code class="reqn">w1</code>.
</p>
</li>
<li><p>w2: estimated canonical direction <code class="reqn">w2</code>.
</p>
</li>
<li><p>w1trace: a matrix, of which column is the estimated canonical direction <code class="reqn">w1</code> at each iteration. The number of columns is the number of iteration until the convergence.
</p>
</li>
<li><p>w2trace: a matrix, of which column is the estimated canonical direction <code class="reqn">w2</code> at each iteration. The number of columns is the number of iteration until the convergence.
</p>
</li>
<li><p>lam1.iter: For each iteration, what lambda value is selected for <code class="reqn">w1</code> is stored.
</p>
</li>
<li><p>lam2.iter: For each iteration, what lambda value is selected for <code class="reqn">w2</code> is stored.
</p>
</li>
<li><p>obj: objective function value without penalty: <code class="reqn">w1^T * R12 * w2</code>. If lamseq1 and lamseq2 are scalar, then original objective function including penalty part will be used.
</p>
</li></ul>



<h3>References</h3>

<p>Yoon G., Carroll R.J. and Gaynanova I. (2020) &quot;Sparse semiparametric canonical correlation analysis for data of mixed types&quot; &lt;doi:10.1093/biomet/asaa007&gt;.
</p>

<hr>
<h2 id='GenerateData'>Mixed type simulation data generator for sparse CCA</h2><span id='topic+GenerateData'></span>

<h3>Description</h3>

<p><code>GenerateData</code> is used to generate two sets of data of mixed types for sparse CCA under the Gaussian copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateData(
  n,
  trueidx1,
  trueidx2,
  Sigma1,
  Sigma2,
  maxcancor,
  copula1 = "no",
  copula2 = "no",
  type1 = "continuous",
  type2 = "continuous",
  muZ = NULL,
  c1 = NULL,
  c2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateData_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_trueidx1">trueidx1</code></td>
<td>
<p>True canonical direction of length p1 for <code>X1</code>. It will be automatically normalized such that <code class="reqn">w_1^T \Sigma_1 w_1 = 1</code>.</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_trueidx2">trueidx2</code></td>
<td>
<p>True canonical direction of length p2 for <code>X2</code>. It will be automatically normalized such that <code class="reqn">w_2^T \Sigma_2 w_2 = 1</code>.</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_sigma1">Sigma1</code></td>
<td>
<p>True correlation matrix of latent variable <code>Z1</code> (p1 by p1).</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_sigma2">Sigma2</code></td>
<td>
<p>True correlation matrix of latent variable <code>Z2</code> (p2 by p2).</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_maxcancor">maxcancor</code></td>
<td>
<p>True canonical correlation between <code>Z1</code> and <code>Z2</code>.</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_copula1">copula1</code></td>
<td>
<p>Copula type for the first dataset. U1 = f(Z1), which could be either &quot;exp&quot;, &quot;cube&quot;.</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_copula2">copula2</code></td>
<td>
<p>Copula type for the second dataset. U2 = f(Z2), which could be either &quot;exp&quot;, &quot;cube&quot;.</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_type1">type1</code></td>
<td>
<p>Type of the first dataset <code>X1</code>. Could be &quot;continuous&quot;, &quot;trunc&quot; or &quot;binary&quot;.</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_type2">type2</code></td>
<td>
<p>Type of the second dataset <code>X2</code>. Could be &quot;continuous&quot;, &quot;trunc&quot; or &quot;binary&quot;.</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_muz">muZ</code></td>
<td>
<p>Mean of latent multivariate normal.</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_c1">c1</code></td>
<td>
<p>Constant threshold for <code>X1</code> needed for &quot;trunc&quot; and &quot;binary&quot; data type - the default is NULL.</p>
</td></tr>
<tr><td><code id="GenerateData_+3A_c2">c2</code></td>
<td>
<p>Constant threshold for <code>X2</code> needed for &quot;trunc&quot; and &quot;binary&quot; data type - the default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>GenerateData</code> returns a list containing
</p>

<ul>
<li><p>Z1: latent numeric data matrix (n by p1).
</p>
</li>
<li><p>Z2: latent numeric data matrix (n by p2).
</p>
</li>
<li><p>X1: observed numeric data matrix (n by p1).
</p>
</li>
<li><p>X2: observed numeric data matrix (n by p2).
</p>
</li>
<li><p>true_w1: normalized true canonical direction of length p1 for <code>X1</code>.
</p>
</li>
<li><p>true_w2: normalized true canonical direction of length p2 for <code>X2</code>.
</p>
</li>
<li><p>type: a vector containing types of two datasets.
</p>
</li>
<li><p>maxcancor: true canonical correlation between <code>Z1</code> and <code>Z2</code>.
</p>
</li>
<li><p>c1: constant threshold for <code>X1</code> for &quot;trunc&quot; and &quot;binary&quot; data type.
</p>
</li>
<li><p>c2: constant threshold for <code>X2</code> for &quot;trunc&quot; and &quot;binary&quot; data type.
</p>
</li>
<li><p>Sigma: true latent correlation matrix of <code>Z1</code> and <code>Z2</code> ((p1+p2) by (p1+p2)).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>### Simple example

# Data setting
n &lt;- 100; p1 &lt;- 15; p2 &lt;- 10 # sample size and dimensions for two datasets.
maxcancor &lt;- 0.9 # true canonical correlation

# Correlation structure within each data set
set.seed(0)
perm1 &lt;- sample(1:p1, size = p1);
Sigma1 &lt;- autocor(p1, 0.7)[perm1, perm1]
blockind &lt;- sample(1:3, size = p2, replace = TRUE);
Sigma2 &lt;- blockcor(blockind, 0.7)
mu &lt;- rbinom(p1+p2, 1, 0.5)

# true variable indices for each dataset
trueidx1 &lt;- c(rep(1, 3), rep(0, p1-3))
trueidx2 &lt;- c(rep(1, 2), rep(0, p2-2))

# Data generation
simdata &lt;- GenerateData(n=n, trueidx1 = trueidx1, trueidx2 = trueidx2, maxcancor = maxcancor,
                        Sigma1 = Sigma1, Sigma2 = Sigma2,
                        copula1 = "exp", copula2 = "cube",
                        muZ = mu,
                        type1 = "trunc", type2 = "trunc",
                        c1 = rep(1, p1), c2 =  rep(0, p2)
)
X1 &lt;- simdata$X1
X2 &lt;- simdata$X2

# Check the range of truncation levels of variables
range(colMeans(X1 == 0))
range(colMeans(X2 == 0))
</code></pre>

<hr>
<h2 id='KendallTau'>Kendall's tau correlation</h2><span id='topic+KendallTau'></span><span id='topic+Kendall_matrix'></span>

<h3>Description</h3>

<p>Calculate Kendall's tau correlation.
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\tau}_{jk} = \frac{2}{n(n-1)}\sum_{1\le i&lt;i'\le n} sign(X_{ji}-X_{ji'}) sign(X_{ki}-X_{ki'}) </code>
</p>

<p>The function <code>KendallTau</code> calculates Kendall's tau correlation between two variables, returning a single correlation value. The function <code>Kendall_matrix</code> returns a correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KendallTau(x, y)

Kendall_matrix(X, Y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KendallTau_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="KendallTau_+3A_y">y</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="KendallTau_+3A_x">X</code></td>
<td>
<p>A numeric matrix (n by p1).</p>
</td></tr>
<tr><td><code id="KendallTau_+3A_y">Y</code></td>
<td>
<p>A numeric matrix (n by p2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>KendallTau(x, y)</code> returns one Kendall's tau correlation value between two vectors, <code>x</code> and <code>y</code>.
</p>
<p><code>Kendall_matrix(X)</code> returns a p1 by p1 matrix of Kendall's tau correlation coefficients. <code>Kendall_matrix(X, Y)</code> returns a p1 by p2 matrix of Kendall's tau correlation coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 100 # sample size
r &lt;- 0.8 # true correlation

### vector input
# Data generation (X1: truncated continuous, X2: continuous)
Z &lt;- mvrnorm(n, mu = c(0, 0), Sigma = matrix(c(1, r, r, 1), nrow = 2))
X1 &lt;- Z[,1]
X1[Z[,1] &lt; 1] &lt;- 0
X2 &lt;- Z[,2]

KendallTau(X1, X2)
Kendall_matrix(X1, X2)

### matrix data input
p1 &lt;- 3; p2 &lt;- 4 # dimension of X1 and X2
JSigma &lt;- matrix(r, nrow = p1+p2, ncol = p1+p2); diag(JSigma) &lt;- 1
Z &lt;- mvrnorm(n, mu = rep(0, p1+p2), Sigma = JSigma)
X1 &lt;- Z[,1:p1]
X1[Z[,1:p1] &lt; 0] &lt;- 0
X2 &lt;- Z[,(p1+1):(p1+p2)]

Kendall_matrix(X1, X2)

</code></pre>

<hr>
<h2 id='lambdaseq_generate'>Internal data-driven lambda sequence generating function.</h2><span id='topic+lambdaseq_generate'></span>

<h3>Description</h3>

<p>This internal function generates lambda sequence of length <code>nlamseq</code> equally spaced on a logarithmic scale. Since this is for sparse CCA, it returns a list of two vectors. Each vector will be used for each data set <code class="reqn">X1</code> and <code class="reqn">X2</code>. And <code class="reqn">w1</code> and <code class="reqn">w2</code> denote canonical vector for each data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdaseq_generate(
  nlamseq = 20,
  lam.eps = 0.01,
  Sigma1,
  Sigma2,
  Sigma12,
  w1init = NULL,
  w2init = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaseq_generate_+3A_nlamseq">nlamseq</code></td>
<td>
<p>The length of lambda sequence</p>
</td></tr>
<tr><td><code id="lambdaseq_generate_+3A_lam.eps">lam.eps</code></td>
<td>
<p>The smallest value for lambda as a fraction of maximum lambda value</p>
</td></tr>
<tr><td><code id="lambdaseq_generate_+3A_sigma1">Sigma1</code></td>
<td>
<p>Covariance/correlation matrix of <code class="reqn">X1</code> (p1 by p1)</p>
</td></tr>
<tr><td><code id="lambdaseq_generate_+3A_sigma2">Sigma2</code></td>
<td>
<p>Covariance/correlation matrix of <code class="reqn">X2</code> (p2 by p2)</p>
</td></tr>
<tr><td><code id="lambdaseq_generate_+3A_sigma12">Sigma12</code></td>
<td>
<p>Covariance/correlation matrix between <code class="reqn">X1</code> and <code class="reqn">X2</code></p>
</td></tr>
<tr><td><code id="lambdaseq_generate_+3A_w1init">w1init</code></td>
<td>
<p>Initial value for canonical vector <code class="reqn">w1</code></p>
</td></tr>
<tr><td><code id="lambdaseq_generate_+3A_w2init">w2init</code></td>
<td>
<p>Initial value for canonical vector <code class="reqn">w2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lambdaseq_generate</code> returns a list of length 2. Each vector is of the same length <code>nlamseq</code> and will be used for each data set separately.
</p>

<hr>
<h2 id='mixedCCA'>Sparse CCA for data of mixed types with BIC criterion</h2><span id='topic+mixedCCA'></span>

<h3>Description</h3>

<p>Applies sparse canonical correlation analysis (CCA) for high-dimensional data of mixed types (continuous/binary/truncated continuous). Derived rank-based estimator instead of sample correlation matrix is implemented. There are two types of BIC criteria for variable selection. We found that BIC1 works best for variable selection, whereas BIC2 works best for prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixedCCA(
  X1,
  X2,
  type1,
  type2,
  lamseq1 = NULL,
  lamseq2 = NULL,
  nlamseq = 20,
  lam.eps = 0.01,
  w1init = NULL,
  w2init = NULL,
  BICtype,
  KendallR = NULL,
  maxiter = 100,
  tol = 0.01,
  trace = FALSE,
  lassoverbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixedCCA_+3A_x1">X1</code></td>
<td>
<p>A numeric data matrix (n by p1).</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_x2">X2</code></td>
<td>
<p>A numeric data matrix (n by p2).</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_type1">type1</code></td>
<td>
<p>A type of data <code>X1</code> among &quot;continuous&quot;, &quot;binary&quot;, &quot;trunc&quot;.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_type2">type2</code></td>
<td>
<p>A type of data <code>X2</code> among &quot;continuous&quot;, &quot;binary&quot;, &quot;trunc&quot;.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_lamseq1">lamseq1</code></td>
<td>
<p>A tuning parameter sequence for <code>X1</code>. The length should be the same as <code>lamseq2</code>.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_lamseq2">lamseq2</code></td>
<td>
<p>A tuning parameter sequence for <code>X2</code>. The length should be the same as <code>lamseq1</code>.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_nlamseq">nlamseq</code></td>
<td>
<p>The number of tuning parameter sequence lambda - default is 20.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_lam.eps">lam.eps</code></td>
<td>
<p>A ratio of the smallest value for lambda to the maximum value of lambda.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_w1init">w1init</code></td>
<td>
<p>An initial vector of length p1 for canonical direction <code class="reqn">w1</code>.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_w2init">w2init</code></td>
<td>
<p>An initial vector of length p2 for canonical direction <code class="reqn">w2</code>.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_bictype">BICtype</code></td>
<td>
<p>Either 1 or 2: For more details for two options, see the reference.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_kendallr">KendallR</code></td>
<td>
<p>An estimated Kendall <code class="reqn">\tau</code> matrix. The default is NULL, which means that it will be automatically estimated by Kendall's <code class="reqn">\tau</code> estimator unless the user supplies.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_tol">tol</code></td>
<td>
<p>The desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_trace">trace</code></td>
<td>
<p>If <code>trace = TRUE</code>, progress per each iteration will be printed. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mixedCCA_+3A_lassoverbose">lassoverbose</code></td>
<td>
<p>If <code>lassoverbose = TRUE</code>, all warnings from lassobic optimization regarding convergence will be printed. The default value is <code>lassoverbose = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mixedCCA</code> returns a data.frame containing
</p>

<ul>
<li><p>KendallR: estimated Kendall's <code class="reqn">\tau</code> matrix estimator.
</p>
</li>
<li><p>lambda_seq: the values of <code>lamseq</code> used for sparse CCA.
</p>
</li>
<li><p>w1: estimated canonical direction <code class="reqn">w1</code>.
</p>
</li>
<li><p>w2: estimated canonical direction <code class="reqn">w2</code>.
</p>
</li>
<li><p>cancor: estimated canonical correlation.
</p>
</li>
<li><p>fitresult: more details regarding the progress at each iteration.
</p>
</li></ul>



<h3>References</h3>

<p>Yoon G., Carroll R.J. and Gaynanova I. (2020) &quot;Sparse semiparametric canonical correlation analysis for data of mixed types&quot; &lt;doi:10.1093/biomet/asaa007&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simple example

# Data setting
n &lt;- 100; p1 &lt;- 15; p2 &lt;- 10 # sample size and dimensions for two datasets.
maxcancor &lt;- 0.9 # true canonical correlation

# Correlation structure within each data set
set.seed(0)
perm1 &lt;- sample(1:p1, size = p1);
Sigma1 &lt;- autocor(p1, 0.7)[perm1, perm1]
blockind &lt;- sample(1:3, size = p2, replace = TRUE);
Sigma2 &lt;- blockcor(blockind, 0.7)
mu &lt;- rbinom(p1+p2, 1, 0.5)

# true variable indices for each dataset
trueidx1 &lt;- c(rep(1, 3), rep(0, p1-3))
trueidx2 &lt;- c(rep(1, 2), rep(0, p2-2))

# Data generation
simdata &lt;- GenerateData(n=n, trueidx1 = trueidx1, trueidx2 = trueidx2, maxcancor = maxcancor,
                        Sigma1 = Sigma1, Sigma2 = Sigma2,
                        copula1 = "exp", copula2 = "cube",
                        muZ = mu,
                        type1 = "trunc", type2 = "trunc",
                        c1 = rep(1, p1), c2 =  rep(0, p2)
)
X1 &lt;- simdata$X1
X2 &lt;- simdata$X2

# Check the range of truncation levels of variables
range(colMeans(X1 == 0))
range(colMeans(X2 == 0))

# Kendall CCA with BIC1
kendallcca1 &lt;- mixedCCA(X1, X2, type1 = "trunc", type2 = "trunc", BICtype = 1, nlamseq = 10)

# Kendall CCA with BIC2. Estimated correlation matrix is plugged in from the above result.
R &lt;- kendallcca1$KendallR
kendallcca2 &lt;- mixedCCA(X1, X2, type1 = "trunc", type2 = "trunc",
                        KendallR = R, BICtype = 2, nlamseq = 10)
</code></pre>

<hr>
<h2 id='myrcc'>Internal RidgeCCA function</h2><span id='topic+myrcc'></span>

<h3>Description</h3>

<p>This function is modified from CCA package rcc function. This function is used for simulation. Inputs should be correlation or covariance matrices of each data set and between datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myrcc(R1, R2, R12, lambda1, lambda2, tol = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myrcc_+3A_r1">R1</code></td>
<td>
<p>correlation/covariance/rank-based correlation matrix of dataset <code>X1</code>.</p>
</td></tr>
<tr><td><code id="myrcc_+3A_r2">R2</code></td>
<td>
<p>correlation/covariance/rank-based correlation matrix of dataset <code>X2</code>.</p>
</td></tr>
<tr><td><code id="myrcc_+3A_r12">R12</code></td>
<td>
<p>correlation/covariance/rank-based correlation matrix between dataset <code>X1</code> and dataset <code>X2</code>.</p>
</td></tr>
<tr><td><code id="myrcc_+3A_lambda1">lambda1</code></td>
<td>
<p>tuning parameter (a scalar value) for dataset <code>X1</code>.</p>
</td></tr>
<tr><td><code id="myrcc_+3A_lambda2">lambda2</code></td>
<td>
<p>tuning parameter (a scalar value) for dataset <code>X2</code>.</p>
</td></tr>
<tr><td><code id="myrcc_+3A_tol">tol</code></td>
<td>
<p>tolerance for eigenvalues. Refer to <code>standardCCA</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>myrcc</code> returns a data.frame containing
</p>

<ul>
<li><p>cancor: estimated canonical correlation.
</p>
</li>
<li><p>w1: estimated canonical direction <code class="reqn">w1</code>.
</p>
</li>
<li><p>w2: estimated canonical direction <code class="reqn">w2</code>.
</p>
</li></ul>


<hr>
<h2 id='standardCCA'>Internal standard CCA function.</h2><span id='topic+standardCCA'></span>

<h3>Description</h3>

<p>This function is modified from original CCA function for two reasons: to deal with only positive eigenvalues larger than the tolerance when calculating the inverse of the matrices and to compute Singular Value Decomposition using <code><a href="irlba.html#topic+irlba">irlba</a></code> algorithm. Inputs should be correlation or covariance matrices of each data set and between datasets. This function returns only the first pair of canonical covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardCCA(S1, S2, S12, tol = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardCCA_+3A_s1">S1</code></td>
<td>
<p>correlation/covariance matrix of dataset <code>X1</code>.</p>
</td></tr>
<tr><td><code id="standardCCA_+3A_s2">S2</code></td>
<td>
<p>correlation/covariance matrix of dataset <code>X2</code>.</p>
</td></tr>
<tr><td><code id="standardCCA_+3A_s12">S12</code></td>
<td>
<p>correlation/covariance matrix between dataset <code>X1</code> and dataset <code>X2</code>.</p>
</td></tr>
<tr><td><code id="standardCCA_+3A_tol">tol</code></td>
<td>
<p>tolerance for eigenvalues. <code>standardCCA</code> function only deals with positive eigenvalues larger than the tolerance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>standardCCA</code> returns a data.frame containing
</p>

<ul>
<li><p>cancor: estimated canonical correlation.
</p>
</li>
<li><p>w1: estimated canonical direction <code class="reqn">w1</code>.
</p>
</li>
<li><p>w2: estimated canonical direction <code class="reqn">w2</code>.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
