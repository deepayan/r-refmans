<!DOCTYPE html><html><head><title>Help for package DistatisR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DistatisR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DistatisR-package'><p>implements three way metric multidimensional scaling:</p>
DISTATIS and COVSTATIS.</a></li>
<li><a href='#amariSorting'><p>25 assessors twice sort and describe 12 amaris (i.e., bitter)</p></a></li>
<li><a href='#beersBlindSorting'><p>Novices and Experts sorted 3 types of beers from</p>
3 different brewers without and without seeing the beers.</a></li>
<li><a href='#BeersFlashProfile'><p>An example of an excel file</p>
storing the Flash Profile of 6 (fictitious) assessors
evaluating 7 (imaginary) beers.
This excel file can be read by
<code>read.df.excel</code>.</a></li>
<li><a href='#BeersProjectiveMapping'><p>7 (fictitious) assessors sort and verbally describe 7 Beers using</p>
<em>Projective Mapping</em>.</a></li>
<li><a href='#BeersProjectiveMapping_xlsx'><p>An example of an excel file</p>
with Projective Mapping data and vocabulary.
This excel file can be read by
<code>read.df.excel</code>.</a></li>
<li><a href='#BootFactorScores'><p>Computes observation</p>
factor scores
Bootstrap replicates from partial factor scores.</a></li>
<li><a href='#BootFromCompromise'><p><code>BootFromCompromise</code>: Computes  Bootstrap replicates</p>
of the (observation) factor scores by
creating bootstrapped compromises.</a></li>
<li><a href='#Chi2Dist'><p>Computes the <code class="reqn">\chi^2</code> distance between</p>
the rows of a rectangular matrix (with positive elements).</a></li>
<li><a href='#Chi2DistanceFromSort'><p><code>Chi2DistanceFromSort</code>:</p>
Creates a 3-dimensional <code class="reqn">\chi^2</code>
distance array from the results
of a sorting task.</a></li>
<li><a href='#computePartial4Groups'><p>Computes group alphas</p>
and group factor scores
for <code class="reqn">K</code> groups of observations
in <code>distatis</code>.</a></li>
<li><a href='#ComputeSplus'><p>ComputeSplus</p></a></li>
<li><a href='#CP2MFAnormedCP'><p>CP2MFAnormedCP</p></a></li>
<li><a href='#CP2NuclearNormedCP'><p>CP2NuclearNormedCP</p></a></li>
<li><a href='#CP2SUMPCAnormedCP'><p>CP2SUMPCAnormedCP</p></a></li>
<li><a href='#createCubeOfCovDis'><p>compute a cube of covariance and a cube of distance</p>
between the items (rows) of a brick of measurements
(when all blocks
have the same number of variables).</a></li>
<li><a href='#DblCenterDist'><p>Double Center a distance matrix</p></a></li>
<li><a href='#Dist2CP'><p>Dist2CP</p></a></li>
<li><a href='#DistAlgo'><p>Four computer algorithms evaluate the similarity of six faces for distatis</p>
analysis</a></li>
<li><a href='#DistanceFromRank'><p><code>DistanceFromRank</code>:</p>
Creates a 3-dimensional distance array from the results
of a ranking task.</a></li>
<li><a href='#DistanceFromSort'><p>Creates a 3-dimensional distance array from the results of a sorting task.</p></a></li>
<li><a href='#distatis'><p>3-Way MDS based on the  &quot;STATIS&quot; optimization</p>
procedure.</a></li>
<li><a href='#GetCmat'><p>GetCmat</p></a></li>
<li><a href='#GetRectCmat'><p>GetRectCmat</p></a></li>
<li><a href='#GraphDistatisAll'><p>This function combines the functionality of</p>
<code>GraphDistatisCompromise</code>, <code>GraphDistatisPartial</code>,
<code>GraphDistatisBoot</code>, and <code>GraphDistatisRv</code>.</a></li>
<li><a href='#GraphDistatisBoot'><p><code>GraphDistatisBoot</code> Plot maps of the factor scores</p>
of the observations and their bootstrapped
confidence intervals (as confidence ellipsoids or peeled hulls)
for a
<abbr><span class="acronym">DISTATIS</span></abbr> analysis.</a></li>
<li><a href='#GraphDistatisCompromise'><p>Plot maps of the factor scores of the observations for a <abbr><span class="acronym">DISTATIS</span></abbr></p>
analysis</a></li>
<li><a href='#GraphDistatisPartial'><p>Plot maps of the factor scores and partial factor scores of the observations</p>
for a <abbr><span class="acronym">DISTATIS</span></abbr> analysis.</a></li>
<li><a href='#GraphDistatisRv'><p>Plot maps of the factor scores (from the Rv matrix) of the distance matrices</p>
for a <abbr><span class="acronym">DISTATIS</span></abbr> analysis</a></li>
<li><a href='#ldiag'><p>Left (i.e., pre) Multiply a matrix by a diagonal matrix</p></a></li>
<li><a href='#list2CubeOfCovDis'><p>compute a cube of covariance and a cube of distance</p>
between the items (rows) of a matrix of measurements
comprising <code class="reqn">K</code> different blocks of possibly different
number of variables.</a></li>
<li><a href='#MFAnormCP'><p>MFAnormCP</p></a></li>
<li><a href='#mmds'><p>Metric (classical) Multidimensional Scaling</p>
(a.k.a Principal Coordinate
Analysis) of a (squared Euclidean) Distance Matrix.</a></li>
<li><a href='#multiculturalSortingSpices'><p>62 assessors from 5 countries sort 16 spice samples</p></a></li>
<li><a href='#NuclearNormedCP'><p>NuclearNormedCP</p></a></li>
<li><a href='#OrangeJuiceSortingRawData'><p><code>OrangeJuiceSortingRawData</code>: an example of an excel file</p>
with Sorting data and vocabulary. This excel file can be read by
<code>read.df.excel</code>.</a></li>
<li><a href='#print.beersBlind'><p>Change the print function for class 'beersBlind'</p></a></li>
<li><a href='#print.Cmat'><p>Print C matrix results</p></a></li>
<li><a href='#print.cubeOfCovDis'><p>Change the print function for the class <code>cubeOfCovDis</code></p></a></li>
<li><a href='#print.cubeSort'><p>Change the print function for cubeSort</p></a></li>
<li><a href='#print.dataAmari'><p>Change the print function for the data set:</p>
<code>dataAmari</code></a></li>
<li><a href='#print.dataSortingSpices'><p>Change the print function for the data set:</p>
<code>multiculturalSortingSpices</code></a></li>
<li><a href='#print.dataSortingWines'><p>Change the print function for the data set:</p>
<code>dataSortingWines</code></a></li>
<li><a href='#print.distatis.data'><p>Change the print function for objects of</p>
class <code>distatis.data</code> output of<code>read.df.excel</code></a></li>
<li><a href='#print.DistatisR'><p>Print DistatisR results</p></a></li>
<li><a href='#print.F_alpha_k'><p>Print F_alpha_k results</p></a></li>
<li><a href='#print.F4voc'><p>Change the print function for objects of the class</p>
<code>'F4voc'</code> (e.g., output from function
<code>projectVoc</code>).</a></li>
<li><a href='#print.Splus'><p>Print S+ matrix results</p></a></li>
<li><a href='#print.str_BeersProjectiveMapping'><p>Change the print function for the data set:</p>
<code>str_BeersProjectiveMapping</code></a></li>
<li><a href='#print.voc4distatis'><p>Change the print function for voc4distatis</p></a></li>
<li><a href='#projectVoc'><p>Compute barycentric projections for count-like</p>
description of the items of a <code>distatis</code>-type
of  analysis.</a></li>
<li><a href='#projMap2Cube'><p>\</p>
reshape a data matrix from projective mapping
into a brick of data for a <code>distatis</code> analysis.</a></li>
<li><a href='#rdiag'><p>right (i.e., post) Multiply a matrix by a diagonal matrix</p></a></li>
<li><a href='#read.df.excel'><p><code>read.df.excel</code> reads <code>distatis</code> formated</p>
ranking or sorting data from an excel file.</a></li>
<li><a href='#rv'><p>Function to compute the RV coefficient between to conformable matrices</p></a></li>
<li><a href='#scale1'><p>A variation over the base <code>R</code> scale function</p>
that avoids the &quot;divide by 0 = NA&quot;  problem.</a></li>
<li><a href='#SortingBeer'><p>Ten Assessors sorted eight beers for <code>distatis</code> analysis</p></a></li>
<li><a href='#SortingSpice'><p>21 French assessors sorted 16 blends of Spice for <code>distatis</code> analysis</p></a></li>
<li><a href='#sortingWines'><p>Novices and wines experts sort red, rosé, and white wines</p></a></li>
<li><a href='#SUMPCAnormCP'><p>SUMPCAnormCP</p></a></li>
<li><a href='#supplementalProjection4distatis'><p>Supplementary element(s) projection in DISTATIS</p></a></li>
<li><a href='#vocabulary2CT'><p>Transforms a data.frame of products by vocabulary</p>
of assessors into
a  products by words (from vocabulary) contingency table.</a></li>
<li><a href='#WinesRankingRawData'><p><code>WinesRankingRawData</code>: an example of an excel file</p>
with (simulated) ranking data. Can be read with the function
<code>read.df.excel()</code>.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>DiSTATIS Three Way Metric Multidimensional Scaling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Derek Beaton [aut, com, ctb],  Herve Abdi [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Herve Abdi &lt;herve@utdallas.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implement DiSTATIS and CovSTATIS  (three-way multidimensional scaling).  DiSTATIS and CovSTATIS are used to analyze multiple distance/covariance matrices collected on the same set of observations. These methods are based on Abdi, H., Williams, L.J., Valentin, D., &amp; Bennani-Dosse, M. (2012) &lt;<a href="https://doi.org/10.1002%2Fwics.198">doi:10.1002/wics.198</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>prettyGraphs, car, readxl, dplyr, tidytext</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-05 00:12:12 UTC; Derek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-05 08:32:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='DistatisR-package'>implements three way metric multidimensional scaling:
DISTATIS and COVSTATIS.</h2><span id='topic+DistatisR-package'></span><span id='topic+DistatisR'></span><span id='topic+DiSTATISR'></span>

<h3>Description</h3>

<p><code>DistatisR</code>: package implements three way 
metric multidimensional scaling:
DISTATIS and COVSTATIS.
</p>


<h3>Details</h3>

<p>Analyzes sets of distance (or covariance)
matrices collected on the same set
of observations and find common and specific metric spaces.
</p>

<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> DistatisR</td>
</tr>
<tr>
 <td style="text-align: left;"> 
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.1.0</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2022-09-28</td>
</tr>
<tr>
 <td style="text-align: left;"> 
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;"> Depends: </td><td style="text-align: left;">
prettyGraphs (&gt;= 2.0.0), car</td>
</tr>

</table>
 
<p>The example shown here comes from Abdi
<em>et al.</em> (2007), <code>distatis</code> 
paper on the sorting task.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton [aut, com, ctb], &amp; Herve Abdi
[aut, cre]
</p>
<p>Maintainer: Herve Abdi &lt;herve@utdallas.edu&gt;
</p>


<h3>References</h3>

<p><a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>
<p>Abdi, H., Valentin, D., O'Toole, A.J., &amp; Edelman, B. (2005). 
DISTATIS: The
analysis of multiple distance matrices. 
<em>Proceedings of the IEEE
Computer Society: International Conference 
on Computer Vision and Pattern
Recognition.</em> (San Diego, CA, USA). pp. 42-47.
</p>
<p>Abdi, H., Valentin, D., Chollet, S., &amp; Chrea, C. (2007).  
Analyzing
assessors and products in sorting tasks: 
DISTATIS, theory and applications.
<em>Food Quality and Preference</em>, <b>18</b>, 627&ndash;640.
</p>
<p>Abdi, H., &amp; Valentin, D., (2007).  
Some new and easy ways to describe,
compare, and evaluate products and assessors.  
In D., Valentin, D.Z. Nguyen,
L. Pelletier (Eds): 
<em>New trends in sensory evaluation of food and
non-food products</em>. 
Ho Chi Minh (Vietnam): Vietnam National University &amp; Ho
Chi Minh City Publishing House. pp. 5&ndash;18.
</p>
<p>Abdi, H., Dunlop, J.P., &amp; Williams, L.J. (2009).  
How to compute reliability
estimates and display confidence and tolerance 
intervals for pattern
classiffers using the Bootstrap 
and 3-way multidimensional scaling
(DISTATIS).  <em>NeuroImage</em>, <b>45</b>, 89&ndash;95.
</p>
<p>Abdi, H., Williams, L.J., Valentin, D., &amp; Bennani-Dosse, M. 
(2012).  STATIS
and DISTATIS: Optimum multi-table principal component 
analysis and three way
metric multidimensional scaling.  
<em>Wiley Interdisciplinary Reviews:
Computational Statistics</em>, <b>4</b>, 124&ndash;167.
</p>
<p>Chollet, S., Valentin, D., &amp; Abdi, H. (2014). 
The free sorting
task.  In. P.V. Tomasco &amp; G. Ares (Eds), 
<em>Novel Techniques in Sensory
Characterization and Consumer Profiling.</em> 
Boca Raton: Taylor and Francis.
</p>
<p>Valentin, D., Chollet, S., Nestrud, M., &amp; Abdi, H. (2018).
Sorting and similarity methodologies.  
In. S. Kemp, S., J. Hort, &amp; T.
Hollowood (Eds.), 
<em>Descriptive Analysis in Sensory Evaluation</em>.
London: Wiley-Blackwell.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distatis">distatis</a></code> <code><a href="#topic+BootFactorScores">BootFactorScores</a></code>
<code><a href="#topic+BootFromCompromise">BootFromCompromise</a></code> <code><a href="#topic+DistanceFromSort">DistanceFromSort</a></code>
<code><a href="#topic+distatis">distatis</a></code> <code><a href="#topic+GraphDistatisAll">GraphDistatisAll</a></code>
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code> <code><a href="#topic+GraphDistatisCompromise">GraphDistatisCompromise</a></code>
<code><a href="#topic+GraphDistatisPartial">GraphDistatisPartial</a></code> <code><a href="#topic+GraphDistatisRv">GraphDistatisRv</a></code>
<code><a href="#topic+mmds">mmds</a></code>
<code><a href="prettyGraphs.html#topic+prettyGraphs">prettyGraphs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Here we use the sorting task from Abdi et al.' (2007) paper.
# where 10 Assessors sorted 8 beers.

#-----------------------------------------------------------------------------
#  1. Get the data from the 2007 sorting example
#      this is the way they look from Table 1 of
#      Abdi et al. (2007).
#                       Assessors
#                  1 2 3 4 5 6 7 8 9 10
# Beer        Sex  f m f f m m m m f m
#            -----------------------------
#Affligen          1 4 3 4 1 1 2 2 1 3
#Budweiser         4 5 2 5 2 3 1 1 4 3
#Buckler_Blonde    3 1 2 3 2 4 3 1 1 2
#Killian           4 2 3 3 1 1 1 2 1 4
#St. Landelin      1 5 3 5 2 1 1 2 1 3
#Buckler_Highland  2 3 1 1 3 5 4 4 3 1
#Fruit Defendu     1 4 3 4 1 1 2 2 2 4
#EKU28             5 2 4 2 4 2 5 3 4 5


# 1.1. Create the
#     Name of the Beers
BeerName &lt;- c('Affligen', 'Budweiser','Buckler Blonde',
              'Killian','St.Landelin','Buckler Highland',
              'Fruit Defendu','EKU28')
# 1.2. Create the name of the Assessors
#      (F are females, M are males)
Juges &lt;- c('F1','M2', 'F3', 'F4', 'M5', 'M6', 'M7', 'M8', 'F9', 'M10')

# 1.3. Get the sorting data
SortData &lt;- c(1, 4, 3, 4, 1, 1, 2, 2, 1, 3,
              4, 5, 2, 5, 2, 3, 1, 1, 4, 3,
              3, 1, 2, 3, 2, 4, 3, 1, 1, 2,
              4, 2, 3, 3, 1, 1, 1, 2, 1, 4,
              1, 5, 3, 5, 2, 1, 1, 2, 1, 3,
              2, 3, 1, 1, 3, 5, 4, 4, 3, 1,
              1, 4, 3, 4, 1, 1, 2, 2, 2, 4,
              5, 2, 4, 2, 4, 2, 5, 3, 4, 5)
# 1.4 Create a data frame
Sort &lt;- matrix(SortData,ncol = 10, byrow= TRUE, dimnames = list(BeerName, Juges))
#     (alternatively we could have read a csv file)
# 1.5 Example of how to read a csv filw
# Sort &lt;- read.table("BeeerSortingTask.csv", header=TRUE,
#   sep=",", na.strings="NA", dec=".", row.names=1, strip.white=TRUE)

#------------------------------------------------------------------
# 2. Create the set of distance matrices 
#  (one distance matrix per assessor)
#    (uses the function DistanceFromSort)
DistanceCube &lt;- DistanceFromSort(Sort)
#------------------------------------------------------------------
# 3. Call the DISTATIS routine with the cube of distance as parameter
testDistatis &lt;- distatis(DistanceCube)
# The factor scores for the beers are in
# testDistatis$res4Splus$F
# the factor scores for the assessors are in (RV matrice)
#  testDistatis$res4Cmat$G

#------------------------------------------------------------------
# 4. Inferences on the beers obtained via bootstrap
#    here we use two different bootstraps:
#    1. Bootstrap on factors (very fast but could be too liberal
#         when the number of assessors is very large)
#    2. Complete bootstrap obtained by computing sets of compromises
#       and projecting them (could be significantly longer because a lot
#       of computations is required)
#
# 4.1 Get the bootstrap factor scores (with default 1000 iterations)
BootF &lt;- BootFactorScores(testDistatis$res4Splus$PartialF)
#
# 4.2 Get the boostrap from full bootstrap (default niter = 1000)
 F_fullBoot &lt;- BootFromCompromise(DistanceCube,niter=1000)


#------------------------------------------------------------------
# 5. Create the Graphics
# 5.1 an Rv map
 rv.graph.out &lt;- GraphDistatisRv(testDistatis$res4Cmat$G)
# 5.2 a compromise plot
 compromise.graph.out &lt;- GraphDistatisCompromise(testDistatis$res4Splus$F)
# 5.3 a partial factor score plot
 partial.scores.graph.out &lt;-
 	GraphDistatisPartial(testDistatis$res4Splus$F,testDistatis$res4Splus$PartialF)
# 5.4 a bootstrap confidence interval plot
 #5.4.1 with ellipses
 boot.graph.out.ell &lt;- GraphDistatisBoot(testDistatis$res4Splus$F,BootF)
 #or
 # boot.graph.out &lt;- GraphDistatisBoot(testDistatis$res4Splus$F,F_fullBoot)
 #5.4.2 with hulls
 boot.graph.out.hull &lt;- GraphDistatisBoot(testDistatis$res4Splus$F,BootF,ellipses=FALSE)
 #or
 # boot.graph.out &lt;- GraphDistatisBoot(testDistatis$res4Splus$F,F_fullBoot,ellipses=FALSE)
#5.5 all the plots at once
all.plots.out &lt;-
	GraphDistatisAll(testDistatis$res4Splus$F,testDistatis$res4Splus$PartialF,
		BootF,testDistatis$res4Cmat$G)



</code></pre>

<hr>
<h2 id='amariSorting'>25 assessors twice sort and describe 12 amaris (i.e., bitter)</h2><span id='topic+amariSorting'></span>

<h3>Description</h3>

<p><code>sortingAmari</code>: 25 assessors
twice sort and describe  12 amaris 
(i.e., bitter).
The data consist in
a list containing 3 objects:
1) <code>Sorting</code> a data frame with the 12 by 25*2 sorting data,
2) <code>cubeOfVocabulary</code>: an array of dimensions
a 12 products * 41 words  (vocabulary) * 50 assessors-repetition
(i.e., 25 assessors *2 repetitions), and 3)
a data frame:
<code>information4Amaris</code> storing the description of the amaris.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("amariSorting")
</code></pre>


<h3>Format</h3>

<p>a list containing 3 objects:
1) <code>Sorting</code> a data frame with the 12 by 25*2 sorting data,
2) <code>cubeOfVocabulary</code>: and array of dimensions
a 12 products * 41 words  (vocabulary) * 50 assessors-repetition
(i.e., 25 assessors *2 repetitions), and 3)
a data frame:
<code>information4Amaris</code> storing the description of the amaris.
</p>


<h3>Details</h3>

<p>The assessors are described by their 5 character
names with the following code: the first letter
m/f give the gender of the assessors (male versus female),
the second and third characters go from 01 to 25 and 
uniquely identify the assessor, 
the fourth and fifth characters
identify the repetition (r1 vs. r2).
</p>
<p>Some words of the vocabulary have been shortened for convenience;
here is the list of 
the short and long versions of the descriptors that have shortened:
'coffee_chocolate' &lt;- 'coffee',
fortified wine' &lt;- 'wine',
'red fruit' &lt;- 'red',
'soy sauce' &lt;- 'soy',
spirit (green)'  &lt;- 'spirit',
'vegetal_green'  &lt;- 'vegetal', and
'warm spice' &lt;- 'spice'.
</p>
<p>In the data sets, the amaris are identified with shortened
names, the whole names can be found in the data frame
<code>information4Amaris</code>.
</p>


<h3>Author(s)</h3>

<p>Jacob Lahne, Hervé Abdi, &amp; Hildegarde Heymann
</p>


<h3>Source</h3>

<p>Lahne, J., Abdi, H., &amp; Heymann, H. (2018). 
#' Rapid sensory profiles with DISTATIS 
and barycentric text projection: 
An example with amari, bitter herbal liqueurs. 
<em>Food Quality and Preference</em>, 66, 36-43. 
(available from 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>).
</p>


<h3>References</h3>

<p>Lahne, J., Abdi, H., &amp; Heymann, H. (2018). 
Rapid sensory profiles with DISTATIS 
and barycentric text projection: 
An example with amari, bitter herbal liqueurs. 
<em>Food Quality and Preference</em>, 66, 36-43.
</p>

<hr>
<h2 id='beersBlindSorting'>Novices and Experts sorted 3 types of beers from 
3 different brewers without and without seeing the beers.</h2><span id='topic+beersBlindSorting'></span>

<h3>Description</h3>

<p><code>beersBlindSorting</code>:  several different groups of
Novices and Beer-Experts sorted 9 beers with (Vision)
or without (Blind) visual information.
The 9 beers were
3 types of beers 
(blond, amber, and  dark) obtained from 
3 different brewers (Pelforth, Chti, &amp; Leffe).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beersBlindSorting
</code></pre>


<h3>Format</h3>

<p>A list with 11 lists
each storing a 9*9*<code class="reqn">N_k</code>  <code>cubeOfDistance</code> and
one 9*9 distance table. Specifically:
</p>

<dl>
<dt>$EV</dt><dd><p>9*9* 17 Experts, Vision</p>
</dd>
<dt>$EBr1</dt><dd><p>9*9* 13 Experts, Blind, rep 1</p>
</dd>
<dt>$EBr2</dt><dd><p>9*9* 13 Experts, Blind, rep 2</p>
</dd>
<dt>$EBr3</dt><dd><p>9*9* 13 Experts, Blind, rep 3</p>
</dd>
<dt>$EBr4</dt><dd><p>9*9* 13 Experts, Blind, rep 4</p>
</dd>
<dt>$NV</dt><dd><p>9*9* 21 Novices, Vision</p>
</dd>
<dt>$NBr1</dt><dd><p>9*9* 18 Novices, Blind, rep 1</p>
</dd>
<dt>$NBr2</dt><dd><p>9*9* 18 Novices, Blind, rep 2</p>
</dd>
<dt>$NBr3</dt><dd><p>9*9* 18 Novices, Blind, rep 3</p>
</dd>
<dt>$NBr4</dt><dd><p>9*9* 18 Novices, Blind, rep 4</p>
</dd>
<dt>$N2B</dt><dd><p>9*9* 37 Novices, Blind. (Group 2)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Nine different commercial beers (denoted
<code>PelfBL, PelfA, PelfBR, ChtiBL, ChtiA, ChtiBR, LeffBL,
 LeffA, and LeffBR</code>) were evaluated. 
These beers came from three different breweries:
Pelforth (noted <code>Pelf</code>), Chti, (<code>Chti</code>), 
and Leffe (<code>Leff</code>), 
and each brewery provided three types of beer:
blond (<code>BL</code>), amber (<code>A</code>), and dark (<code>BR</code>). 
</p>
<p>For each sorting task the data file gives 
the sorting distance matrix: A 9-beers by 9-beers distance matrix
in which at the intersection of a row (representing one beer)
and a column (representing another beer) a value 
of 0 indicates that these two beers were sorted
in the same group and
a value 
of 1 indicates that these two beers were sorted 
in different groups.
</p>
<p>Multiple groups of novices and experts participated to 
the experiments. In the blind condition, the group of experts
and one group of novices repeated four times  the sorting
taks (replication 1 to 4).
</p>


<h3>Author(s)</h3>

<p>Maud Lelièvre, 
Sylvie Chollet , Hervé Abdi,  and 
Dominique Valentin.
</p>


<h3>Source</h3>

<p>A longer description of the data, 
story, first analysis, etc. can be found in:
Lelièvre M., Chollet, S., Abdi, H., &amp; Valentin, B. (2009). 
Beer trained and untrained assessors rely more on vision 
than on taste when they categorize beers. 
<em>Chemosensory Perception, 2</em>, 143-153.
available from
<a href="https://personal.utdallas.edu/~herve/abdi-lcav09-inpress.pdf">https://personal.utdallas.edu/~herve/abdi-lcav09-inpress.pdf</a>
</p>

<hr>
<h2 id='BeersFlashProfile'>An example of an excel file
storing the Flash Profile of 6 (fictitious) assessors
evaluating 7 (imaginary) beers.
This excel file can be read by
<code>read.df.excel</code>.</h2><span id='topic+BeersFlashProfile'></span>

<h3>Description</h3>

<p><code>BeersFlashProfile</code>:
An example of an excel file
storing the Flash Profile of 6 (fictitious) assessors
evaluating 7 (imaginary) beers.
This excel file can be read by
<code>read.df.excel</code>.
</p>


<h3>Details</h3>

<p>In this example of Flash Profiling
6 (fictitious) assessors evaluated 7 (imaginery) beers. 
First, Each assessor chose a set of descriptors
suited to describe these beers and then ranked 
(or rated in variations of the technique) 
the beers for each dimension. Note that the descriptors 
as well as the number of descriptors vary with the judges.
</p>
<p>Note: 
The names of the variables starts with the Judges ID (J1- to J6-).
</p>
<p>Note: the data are stored in the 
Excel Sheet called <code>Rankings</code> of the excel 
file  <code>BeersFlashProfile.xlsx</code>.
</p>


<h3>FileName</h3>

<p>BeersFlashProfile.xlsx
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>


<h3>Source</h3>

<p>Abdi, H,  &amp; Valentin, D. (2007). 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>References</h3>

<p>Abdi, H., &amp; Valentin, D. (2007). 
Some new and easy ways to describe, compare, 
and evaluate products and assessors. 
In D., Valentin, D.Z. Nguyen, L. Pelletier (Eds) 
<em>New trends in sensory evaluation 
of food and non-food products</em>.
Ho Chi Minh (Vietnam): 
Vietnam National University &amp; Ho Chi Minh City Publishing House. 
pp. 5-18.
</p>


<h3>See Also</h3>

<p>BeersProjectiveMapping BeersProjectiveMapping_xlsx
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the path and file name
path2file &lt;- system.file("extdata",
                  "BeersFlashProfile.xlsx", package = 'DistatisR')
# read the data in excel file with read.df.excel
beerDataFlash  &lt;- read.df.excel(path = path2file,
                           sheet = 'Rankings')$df.data
 # the Flash Profiling data are now in the data.frame beerDataFlash                        
</code></pre>

<hr>
<h2 id='BeersProjectiveMapping'>7 (fictitious) assessors sort and verbally describe 7 Beers using
<em>Projective Mapping</em>.</h2><span id='topic+BeersProjectiveMapping'></span><span id='topic+BeersProjectiveNapping'></span>

<h3>Description</h3>

<p><code>BeersProjectiveMapping</code>:
7 (fictitious) assessors evaluated 7 Beers using
<em>Projective Mapping</em> (with verbal description).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BeersProjectiveMapping")
</code></pre>


<h3>Format</h3>

<p>a list with 3 elements:
1) <code>ProjectiveMapping</code>: 
a matrix of dimensions 7 beers by  7*2 
assessors-dimensions of the coordinates of the beers on the sheet
of paper;
2) <code>Vocabulary</code>: a Beers (rows) by Assessors (columns)
data.frame 
where each element of <code>Vocabulary</code>
stores
the words used by one assessor to describe a beer
(words are separated with spaces);
and 3) <code>CT.vocabulary</code> a matrix storing
the  <code class="reqn">I</code> Products by <code class="reqn">N</code> 
words (from the Vocabulary) contingency table,
in  <code>CT.vocabulary</code> the number at the intersection
of a row (beer) and a column (word) is the number
of assessors who used this word to describe that beer.
</p>


<h3>Details</h3>

<p>First, Each assessor positioned the 7 beers on a sheet
of paper according to the perceived similarity between the beers.
For each assessor, the position of the beers was recorded
from the <code class="reqn">X</code> and <code class="reqn">Y</code> coordinates. 
Second, the assessors were asked if they could describe each
beer with some freely chosen descriptors. 
These descriptors
are stored in a dataframe with 7 elements (one per assessor)
where each element of the dataframe
is a 7 component vector (one per beer) where each element stores
the words used to describe a beer 
(words are separated with spaces).
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>


<h3>Source</h3>

<p>Abdi, H,  &amp; Valentin, D. (2007). 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>References</h3>

<p>Abdi, H., &amp; Valentin, D., (2007). 
Some new and easy ways to describe, compare, 
and evaluate products and assessors. 
In D., Valentin, D.Z. Nguyen, L. Pelletier (Eds) 
<em>New trends in sensory evaluation 
of food and non-food products</em>.
Ho Chi Minh (Vietnam): 
Vietnam National University &amp; Ho Chi Minh City Publishing House. 
pp. 5-18.
</p>

<hr>
<h2 id='BeersProjectiveMapping_xlsx'>An example of an excel file
with Projective Mapping data and vocabulary. 
This excel file can be read by
<code>read.df.excel</code>.</h2><span id='topic+BeersProjectiveMapping_xlsx'></span><span id='topic+BeersProjectiveNapping_xlsx'></span>

<h3>Description</h3>

<p><code>BeersProjectiveMapping_xlsx</code>:
an example of an excel file
with Projective Mapping and vocabulary. 
This excel file can be read by
<code>read.df.excel</code>. In this example
7 (fictitious) assessors evaluated 7 Beers.
</p>


<h3>Details</h3>

<p>In this example of projective mapping with vocabulary,
7 (fictitious) assessors evaluated 7 Beers 
First, each assessor positionned the 7 beers on a sheet
of paper according  to the perceived similarity between the beers.
For each assessor, the position of the beers is recorded
from the <code class="reqn">X</code> and <code class="reqn">Y</code> coordinates. 
Second, the assessors are asked if they can describe the
beers with some freely chosen descriptors. These descriptors
are stored in a list with 7 elements (one per assessor)
where each element of the list
is a 7 component vector (one per beer) where each element stores
the words used to describe a beer 
(words are separated with spaces).
The coordinates of the beers on the sheet of paper
are stored in the sheet <code>Maps</code>, the Vocabulary generated
by the assessors is stored in the sheet
<code>Vocabulary</code>
</p>


<h3>FileName</h3>

<p>BeersProjectiveMapping_xlsx.xlsx
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>


<h3>Source</h3>

<p>Abdi, H,  &amp; Valentin, D. (2007). 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>References</h3>

<p>Abdi, H., &amp; Valentin, D., (2007). 
Some new and easy ways to describe, compare, 
and evaluate products and assessors. 
In D., Valentin, D.Z. Nguyen, L. Pelletier (Eds) 
<em>New trends in sensory evaluation 
of food and non-food products</em>.
Ho Chi Minh (Vietnam): 
Vietnam National University &amp; Ho Chi Minh City Publishing House. 
pp. 5-18.
</p>


<h3>See Also</h3>

<p>BeersProjectiveMapping
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the path and file name
path2file &lt;- system.file("extdata",
       "BeersProjectiveMapping_xlsx.xlsx", package = 'DistatisR')
# read the data in excel file with read.df.excel
beerDataPM  &lt;- read.df.excel(path = path2file,
                           sheet = 'Maps',
                       voc.sheet = 'Vocabulary')
</code></pre>

<hr>
<h2 id='BootFactorScores'>Computes observation
factor scores
Bootstrap replicates from partial factor scores.</h2><span id='topic+BootFactorScores'></span>

<h3>Description</h3>

<p><code>BootFactorScores</code>: Computes Bootstrap replicates
of the factor scores of
the observations from the partial factor scores.
<code>BootFactorScores</code> is typically
used to create confidence intervals and to compute
Bootstrap ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootFactorScores(PartialFS, niter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootFactorScores_+3A_partialfs">PartialFS</code></td>
<td>
<p>The partial factor scores (e.g., as obtained from
<code>distatis</code>).</p>
</td></tr>
<tr><td><code id="BootFactorScores_+3A_niter">niter</code></td>
<td>
<p>number of boostrap iterations (default = 1000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output is a 3-way array of dimensions
&quot;number of observations by
number of factors by number of replicates.&quot;
</p>


<h3>Technicalities</h3>

<p>The input of <code>BootFactorScores</code> is obtained from the
<code>distatis</code> function, the output is a 3-way array
of dimensions number
of observations by number of factors by number of replicates.
The output is
typically used to plot confidence intervals
(i.e., ellipsoids or convex
hulls) or to compute <code class="reqn">t</code>-like statistic
called <em>bootstrap ratios</em>.
To compute a bootstrapped sample a set of
<code class="reqn">K</code> distance matrices is
selected with replacement from the original set of <code class="reqn">K</code> distance
matrices.
The partial factors scores of the selected distance matrices are
then averaged to produce the bootstrapped estimate
of the factor scores of
the observations.
This approach is also called <em>partial boostrap</em> by
Lebart (2007, see also Chateau &amp; Lebart 1996).
It has the advantage of
being very fast even for very large data sets.
Recent work (Cadoret &amp; Husson,
2012), however, suggests that partial boostrap could lead
to optimistic
bootstrap estimates when the number of distance matrices
is large and that
it is preferable to use instead a <em>total boostrap</em>
approach (i.e.,
creating new compromises by
resampling and then projecting them on the
common solution see function
<code>BootFromCompromise</code>, and Cadoret &amp;
Husson, 2012 see also Abdi <em>et al</em>., 2009 for an example).
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>References</h3>

<p>Abdi, H., &amp; Valentin, D., (2007).
Some new and easy ways to
describe, compare, and evaluate products and assessors.
In D., Valentin,
D.Z. Nguyen, L. Pelletier (Eds)
<em>New trends in sensory evaluation of
food and non-food products</em>.
Ho Chi Minh (Vietnam): Vietnam National
University-Ho chi Minh City Publishing House. pp. 5-18.
</p>
<p>Abdi, H., Dunlop, J.P., &amp; Williams, L.J. (2009).
How to compute reliability
estimates and display confidence and tolerance intervals
for pattern
classiffers using the Bootstrap and
3-way multidimensional scaling
(DISTATIS). <em>NeuroImage</em>, <b>45</b>, 89&ndash;95.
</p>
<p>Abdi, H., Williams, L.J., Valentin, D., &amp; Bennani-Dosse, M. (2012).
STATIS
and DISTATIS: Optimum multi-table principal component
analysis and three way
metric multidimensional scaling.
<em>Wiley Interdisciplinary Reviews:
Computational Statistics</em>, <b>4</b>, 124&ndash;167.
</p>
<p>These papers are available from 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>
<p>Additional references:
</p>
<p>Cadoret, M., Husson, F. (2012) Construction and evaluation
of confidence
ellipses applied at sensory data.
<em>Food Quality and Preference</em>,
<b>28</b>, 106&ndash;115.
</p>
<p>Chateau, F., &amp; Lebart, L. (1996). Assessing sample variability
in the
visualization techniques related to principal component
analysis: Bootstrap
and alternative simulation methods. In A. Prats (Ed.),
<em>Proceedings of
COMPSTAT 2006.</em> Heidelberg: Physica Verlag.
</p>
<p>Lebart, L. (2007). Which bootstrap for principal
axes methods?  In
<em>Selected contributions in data analysis and classification,
COMPSTAT
2006</em>.  Heidelberg: Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootFromCompromise">BootFromCompromise</a></code>
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Load the Sort data set from the SortingBeer example
#    (available from the DistatisR package)
data(SortingBeer)
# Provide an 8 beers by 10 assessors set of
# results of a sorting task
#-----------------------------------------------------------------------------
# 2. Create the set of distance matrices (one distance matrix per assessor)
#    (ues the function DistanceFromSort)
DistanceCube &lt;- DistanceFromSort(Sort)

#-----------------------------------------------------------------------------
# 3. Call the DISTATIS routine with the cube of distance as parameter
testDistatis &lt;- distatis(DistanceCube)
# The factor scores for the beers are in
# testDistatis$res4Splus$F
# the partial factor score for the beers for the assessors are in
#  testDistatis$res4Splus$PartialF
#
# 4. Get the bootstraped factor scores (with default 1000 iterations)
BootF &lt;- BootFactorScores(testDistatis$res4Splus$PartialF)

</code></pre>

<hr>
<h2 id='BootFromCompromise'><code>BootFromCompromise</code>: Computes  Bootstrap replicates
of the (observation) factor scores by
creating bootstrapped compromises.</h2><span id='topic+BootFromCompromise'></span>

<h3>Description</h3>

<p><code>BootFromCompromise</code> Computes observation Bootstrap replicates
of the factor scores from
bootstrapped compromises.
<code>BootFromCompromise</code> is typically
used to create confidence intervals and to compute
Bootstrap ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootFromCompromise(
  LeCube2Distance,
  niter = 1000,
  Norm = "MFA",
  Distance = TRUE,
  RV = TRUE,
  nfact2keep = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootFromCompromise_+3A_lecube2distance">LeCube2Distance</code></td>
<td>
<p>The array of distance used to call <code>distatis</code></p>
</td></tr>
<tr><td><code id="BootFromCompromise_+3A_niter">niter</code></td>
<td>
<p>The number of bootstrap iterations (default = 1000)</p>
</td></tr>
<tr><td><code id="BootFromCompromise_+3A_norm">Norm</code></td>
<td>
<p>should be the same as for the original call
to <code>distatis</code></p>
</td></tr>
<tr><td><code id="BootFromCompromise_+3A_distance">Distance</code></td>
<td>
<p>should be the same as for the original call to
<code>distatis</code></p>
</td></tr>
<tr><td><code id="BootFromCompromise_+3A_rv">RV</code></td>
<td>
<p>should be the same
as for the original call to <code>distatis</code></p>
</td></tr>
<tr><td><code id="BootFromCompromise_+3A_nfact2keep">nfact2keep</code></td>
<td>
<p>number of factors to keep for the results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output is a 3-way array of dimensions
&quot;number of observations by
number of factors by number of replicates.&quot;
</p>


<h3>Technicalities</h3>

<p>The input of <code>BootFromCompromise</code> is the original
<code>cubeOfData</code> used to compute the compromise
by the function <code>distatis</code>.
<code>BootFromCompromise</code> computes Bootstrap replicates
of the observations by randomly selecting the observations
with replacement.
The output of <code>BootFromCompromise</code> is a 3-way
array of dimensions &quot;number of observations by number of
factors by number
of replicates.&quot;  The output is typically used to plot
confidence intervals
(i.e., ellipsoids or convex hulls)
or to compute <code class="reqn">t</code>-like statistic
called <em>bootstrap ratios</em>.
</p>
<p>To compute a bootstrapped sample,
a set of <code class="reqn">K</code> distance matrices is
selected with replacement from the original set of <code class="reqn">K</code> distance
matrices.
A <code>distatis</code> compromise is then computed and projected on
the factor space of the original solution to obtain
the bootstrapped factor
scores.
This approach is also called <em>total boostrap</em>
by Lebart (2007,
see also Chateau and Lebart 1996, see also Abdi <em>et al</em>.,
2009 for an
example).  Compared to the partial bootstrap (see help for
<code>BootFactorScores</code>).
This approach has the desadvantage of being slow especially for
large data sets, but recent work (Cadoret &amp; Husson, 2012)
suggests that
partial boostrap (i.e., computed from the partial
factor scores) could lead
to optimistic bootstrap estimates
when the number of distance matrices is
large and that it is preferable to use instead
the <em>total boostrap</em>.
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>References</h3>

<p>Abdi, H., &amp; Valentin, D., (2007).  Some new and easy ways to
describe, compare, and evaluate products and assessors.  In D., Valentin,
D.Z. Nguyen, L. Pelletier (Eds) <em>New trends in sensory evaluation of
food and non-food products</em>.  Ho Chi Minh (Vietnam): Vietnam National
University-Ho chi Minh City Publishing House. pp. 5-18.
</p>
<p>Abdi, H., Dunlop, J.P., &amp; Williams, L.J. (2009). How to compute reliability
estimates and display confidence and tolerance intervals for pattern
classiffers using the Bootstrap and 3-way multidimensional scaling
(DISTATIS). <em>NeuroImage</em>, <b>45</b>, 89&ndash;95.
</p>
<p>Abdi, H., Williams, L.J., Valentin, D., &amp; Bennani-Dosse, M. (2012). STATIS
and DISTATIS: Optimum multi-table principal component analysis and three way
metric multidimensional scaling. <em>Wiley Interdisciplinary Reviews:
Computational Statistics</em>, <b>4</b>, 124&ndash;167.
</p>
<p>These papers are available from 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>
<p>Additional references:
</p>
<p>Cadoret, M., Husson, F. (2012) Construction and evaluation of confidence
ellipses applied at sensory data. <em>Food Quality and Preference</em>,
<b>28</b>, 106&ndash;115.
</p>
<p>Chateau, F., &amp; Lebart, L. (1996). Assessing sample variability in the
visualization techniques related to principal component analysis: Bootstrap
and alternative simulation methods. In A. Prats (Ed.),<em>Proceedings of
COMPSTAT 2006.</em> Heidelberg: Physica Verlag.
</p>
<p>Lebart, L. (2007). Which bootstrap for principal axes methods?  In
<em>Selected contributions in data analysis and classification, COMPSTAT
2006</em>.  Heidelberg: Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootFactorScores">BootFactorScores</a></code>
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Load the Sort data set from the SortingBeer example
#    (available from the DistatisR package)
data(SortingBeer)
# Provide the "8 beers by 10 assessors" results of a sorting task
#-----------------------------------------------------------------------------
# 2. Create the set of distance matrices (one distance matrix per assessor)
#    (uses the function DistanceFromSort)
DistanceCube &lt;- DistanceFromSort(Sort)

#-----------------------------------------------------------------------------
# 3. Call the distatis function with the cube of distance as parameter
testDistatis &lt;- distatis(DistanceCube)
# The factor scores for the beers are in
# testDistatis$res4Splus$F
# the partial factor scores for the beers for the assessors are in
#  testDistatis$res4Splus$PartialF
#
# 4. Get the bootstraped factor scores (with default 1000 iterations)
#    Here we use the "total bootstrap"
 F_fullBoot &lt;- BootFromCompromise(DistanceCube,niter=1000)

</code></pre>

<hr>
<h2 id='Chi2Dist'>Computes the <code class="reqn">\chi^2</code> distance between 
the rows of a rectangular matrix (with positive elements).</h2><span id='topic+Chi2Dist'></span>

<h3>Description</h3>

<p><code>Chi2Dist</code>: 
Computes 
the <code class="reqn">I\times I</code> matrix <b>D</b> which is the
<code class="reqn">\chi^2</code> distance matrix between 
the rows of an <code class="reqn">I\times J</code> rectangular matrix <b>X</b> 
(with non-negative elements), and
provides the <code class="reqn">I\times 1</code> <b>m</b> 
vector of mass (where the mass of
a row is the sum of the entries of
this row divided by the grand total of
the matrix). 
When the distance matrix and the associated vector of masses
are used as input to the function <code><a href="#topic+mmds">mmds</a></code> 
the results will give
the factor scores of the correspondence analysis 
of the matrix <b>X</b>. The
<code>function</code> is used by the function 
<code>Chi2DistanceFromSort</code> that
computes the <code class="reqn">\chi^2</code> 
distance for the results of a sorting task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Chi2Dist(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Chi2Dist_+3A_x">X</code></td>
<td>
<p>A rectangle matrix with non-negative elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sends back a list: 
</p>
<table>
<tr><td><code>$Distance</code></td>
<td>
<p>the squared <code class="reqn">\chi^2</code>
distance matrix computed the rows of matrix <b>X</b>.</p>
</td></tr> 
<tr><td><code>masses</code></td>
<td>
<p>the
vector of masses of the rows of of matrix <b>X</b>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>References</h3>

<p>The procedure and references 
are detailled in (Paper available
from  
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>): 
Abdi, H. (2007). Distance.  In N.J.
Salkind (Ed.): <em>Encyclopedia 
of Measurement and Statistics</em>. Thousand
Oaks (CA): Sage. pp. 304&ndash;308.
</p>
<p>And in:<br /> Abdi, H., &amp; Valentin, D. (2006). 
<em>Mathematiques pour les
Sciences Cognitives (Mathematics for Cognitive Sciences).</em>
Grenoble: PUG.
</p>
<p>See also (for the example):
</p>
<p>Abdi, H., &amp; Williams, L.J. (2010). Principal component analysis.
<em>Wiley Interdisciplinary Reviews: Computational Statistics</em>,
<b>2</b>, 433&ndash;459.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Chi2DistanceFromSort">Chi2DistanceFromSort</a></code> <code><a href="#topic+distatis">distatis</a></code>
<code><a href="#topic+mmds">mmds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Here is a data matrix from Abdi &amp; Williams (2012)
# page 449, Table 15. Punctuation of 6 French authors
Punctuation = matrix(c(
  7836,   13112,   6026,
 53655,   102383, 42413, 
115615,   184541, 59226, 
161926,   340479, 62754, 
 38177,   105101, 12670, 
 46371,    58367, 14299),
     ncol =3,byrow = TRUE)
colnames(Punctuation) &lt;-c('Period','Comma','Other')
rownames(Punctuation) &lt;-c('Rousseau','Chateaubriand',
                   'Hugo','Zola','Proust','Giroudoux') 
# 1. Get the Chi2 distance matrix
#     between the rows of Punctuation 
Dres &lt;- Chi2Dist(Punctuation)
# check that the mds of the Chi2 distance matrix
# with CA-masses gives the CA factor scores for I 
# 2. Use function mmds from DistatisR 
#
testmds &lt;- mmds(Dres$Distance,masses=Dres$masses)
# Print the MDS factor scores from mmds
print('Factor Scores from mds')
print(testmds$FactorScores)
print('It matches CA on X (see Abdi &amp; Williams, 2010. Table 16, p. 449)')
# Et voila!

</code></pre>

<hr>
<h2 id='Chi2DistanceFromSort'><code>Chi2DistanceFromSort</code>:
Creates a 3-dimensional <code class="reqn">\chi^2</code>
distance array from the results
of a sorting task.</h2><span id='topic+Chi2DistanceFromSort'></span>

<h3>Description</h3>

<p><code>Chi2DistanceFromSort</code>:
Takes the results from a (plain) sorting task where
<code class="reqn">K</code> assessors sort
<code class="reqn">I</code> observations into (mutually exclusive) groups
(i.e., one object is
in one an only one group).
<code>Chi2DistanceFromSort</code> creates an 
<code class="reqn">I \times
I \times K</code> array of distance in which
each of the <code class="reqn">k</code> &quot;slices&quot;
stores the (sorting) distance matrix of the 
<code class="reqn">k</code>th assessor.  
In one of
these distance matrices,
the distance between rows is the <code class="reqn">\chi^2</code>
distance between rows when the results 
of the task are coded as 0/1 group
coding (i.e., the &quot;complete disjunctive coding&quot; 
as used in multiple
correspondence analysis, 
see Abdi &amp; Valentin, 2007, for more)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Chi2DistanceFromSort(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Chi2DistanceFromSort_+3A_x">X</code></td>
<td>
<p>gives the results of a sorting task
(see example below) as a
objects (row) by assessors (columns) matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ouput ot the function <code>Chi2DistanceFromSort</code> 
is used as input for the
function <code><a href="#topic+distatis">distatis</a></code>.
</p>
<p>The input should have assessors
as columns and observations as rows (see
example below)
</p>


<h3>Value</h3>

<p><code>Chi2DistanceFromSort</code> returns an
<code class="reqn">I\times I \times K</code>
array of <code class="reqn">K</code> distances matrices
(between the <code class="reqn">I</code> observations)
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>References</h3>

<p>See examples in
</p>
<p>Abdi, H., Valentin, D., Chollet, S., &amp; Chrea, C. (2007).  Analyzing
assessors and products in sorting tasks: DISTATIS, theory and applications.
<em>Food Quality and Preference</em>, <b>18</b>, 627&ndash;640.
</p>
<p>Abdi, H., &amp; Valentin, D., (2007).  Some new and easy ways to describe,
compare, and evaluate products and assessors.  In D., Valentin, D.Z. Nguyen,
L. Pelletier (Eds) <em>New trends in sensory evaluation of food and
non-food products.</em> Ho Chi Minh (Vietnam): Vietnam National University-Ho
chi Minh City Publishing House. pp. 5&ndash;18.
</p>
<p>Abdi, H., &amp; Valentin, D. (2007). Multiple correspondence analysis.  In N.J.
Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics.</em> Thousand
Oaks (CA): Sage. pp. 651-657.
</p>
<p>These papers are available from 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distatis">distatis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  1. Get the data from the 2007 sorting example
#      this is the eay they look from Table 1 of
#      Abdi et al. (2007).
#                       Assessors
#                  1 2 3 4 5 6 7 8 9 10
# Beer        Sex  f m f f m m m m f m
#            -----------------------------
#Affligen          1 4 3 4 1 1 2 2 1 3
#Budweiser         4 5 2 5 2 3 1 1 4 3
#Buckler_Blonde    3 1 2 3 2 4 3 1 1 2
#Killian           4 2 3 3 1 1 1 2 1 4
#St. Landelin      1 5 3 5 2 1 1 2 1 3
#Buckler_Highland  2 3 1 1 3 5 4 4 3 1
#Fruit Defendu     1 4 3 4 1 1 2 2 2 4
#EKU28             5 2 4 2 4 2 5 3 4 5

#
# 1.1. Create the
#     Name of the Beers
BeerName &lt;- c('Affligen', 'Budweiser','Buckler Blonde',
              'Killian','St.Landelin','Buckler Highland',
              'Fruit Defendu','EKU28')
# 1.2. Create the name of the Assessors
#      (F are females, M are males)
Juges &lt;- c('F1','M2', 'F3', 'F4', 'M5', 'M6', 'M7', 'M8', 'F9', 'M10')

# 1.3. Get the sorting data
SortData &lt;- c(1, 4, 3, 4, 1, 1, 2, 2, 1, 3,
              4, 5, 2, 5, 2, 3, 1, 1, 4, 3,
              3, 1, 2, 3, 2, 4, 3, 1, 1, 2,
              4, 2, 3, 3, 1, 1, 1, 2, 1, 4,
              1, 5, 3, 5, 2, 1, 1, 2, 1, 3,
              2, 3, 1, 1, 3, 5, 4, 4, 3, 1,
              1, 4, 3, 4, 1, 1, 2, 2, 2, 4,
              5, 2, 4, 2, 4, 2, 5, 3, 4, 5)
# 1.4 Create a data frame
Sort &lt;- matrix(SortData,ncol = 10, byrow= TRUE, dimnames = list(BeerName, Juges))
#
#-----------------------------------------------------------------------------
# 2. Create the set of distance matrices (one distance matrix per assessor)
#    (use the function DistanceFromSort)
DistanceCube &lt;- Chi2DistanceFromSort(Sort)
#-----------------------------------------------------------------------------
# 3. Call the DISTATIS routine with the cube of distance
#       obtained from DistanceFromSort as a parameter for the distatis function
testDistatis &lt;- distatis(DistanceCube)

</code></pre>

<hr>
<h2 id='computePartial4Groups'>Computes group alphas 
and group factor scores
for <code class="reqn">K</code> groups of observations 
in <code>distatis</code>.</h2><span id='topic+computePartial4Groups'></span>

<h3>Description</h3>

<p><code>computePartial4Groups</code>:
Computes group alphas and group factor scores
for <code class="reqn">K</code> groups of observations used to compute
the compromise (i.e., matrix **S**)
in a <code>distatis</code> analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePartial4Groups(resDistatis, DESIGN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computePartial4Groups_+3A_resdistatis">resDistatis</code></td>
<td>
<p>The results of
a Distatis analysis (as performed by
the <code>DistatisR::distatis</code>) function.</p>
</td></tr>
<tr><td><code id="computePartial4Groups_+3A_design">DESIGN</code></td>
<td>
<p>A Design vector describing
the groups of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In DISTATIS, the compromise
is computed as a weighted 
(with the alpha-coefficients) sum of the 
<code class="reqn">K</code> pseudo-covariance matrices 
**S**k,  <code>computePartial4Groups</code>
sums all the alpha coefficients of a group
to compute each group partial factor scores.
</p>


<h3>Value</h3>

<p>A list with
</p>
 
<ul>
<li><p>&quot;GroupFS: &quot;
The <code class="reqn">K</code> weighted mean coordinates
</p>
</li>
<li><p>&quot;groupAlpha: &quot;
The <code class="reqn">K</code> alpha weights
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Hervé Abdi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distatis">distatis</a></code>
</p>

<hr>
<h2 id='ComputeSplus'>ComputeSplus</h2><span id='topic+ComputeSplus'></span>

<h3>Description</h3>

<p>Compute the compromise matrix for STATIS/DISTATIS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeSplus(CubeCP, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeSplus_+3A_cubecp">CubeCP</code></td>
<td>
<p>A 3D array of cross-product matrices.</p>
</td></tr>
<tr><td><code id="ComputeSplus_+3A_alpha">alpha</code></td>
<td>
<p>The vector of weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The compromise matrix
computed as the alpha-weighted sum of the 
cross-product matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D3 &lt;- array(c(0, 1, 2, 1, 0, 1, 2, 1, 0, 
              0, 3, 3, 3, 0, 3, 3, 3, 0), 
            dim = c(3, 3, 2))
ComputeSplus(D3, alpha = c(1, 0.5))

</code></pre>

<hr>
<h2 id='CP2MFAnormedCP'>CP2MFAnormedCP</h2><span id='topic+CP2MFAnormedCP'></span>

<h3>Description</h3>

<p>MFA normalizes a cube of cross-product matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CP2MFAnormedCP(CP3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CP2MFAnormedCP_+3A_cp3">CP3</code></td>
<td>
<p>A 3D array of cross-product matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 3D array of the normalized cross-product matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D3 &lt;- array(c(0, 1, 2, 1, 0, 1, 2, 1, 0,
              0, 3, 3, 3, 0, 3, 3, 3, 0), 
           dim = c(3, 3, 2))
CP2MFAnormedCP(D3)         


</code></pre>

<hr>
<h2 id='CP2NuclearNormedCP'>CP2NuclearNormedCP</h2><span id='topic+CP2NuclearNormedCP'></span>

<h3>Description</h3>

<p>Nuclear Norm normalizes a cube of cross-product matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CP2NuclearNormedCP(CP3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CP2NuclearNormedCP_+3A_cp3">CP3</code></td>
<td>
<p>A 3D array of cross-product matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 3D array of the normalized cross-product matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D3 &lt;- array(c(0, 1, 2, 1, 0, 1, 2, 1, 0,
              0, 3, 3, 3, 0, 3, 3, 3, 0), 
           dim = c(3, 3, 2))
CP2NuclearNormedCP(D3)         


</code></pre>

<hr>
<h2 id='CP2SUMPCAnormedCP'>CP2SUMPCAnormedCP</h2><span id='topic+CP2SUMPCAnormedCP'></span>

<h3>Description</h3>

<p>SUMPCA normalizes a cube of cross-product matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CP2SUMPCAnormedCP(CP3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CP2SUMPCAnormedCP_+3A_cp3">CP3</code></td>
<td>
<p>A 3D array of cross-product matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 3D array of the normalized cross-product matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D3 &lt;- array(c(0, 1, 2, 1, 0, 1, 2, 1, 0,
              0, 3, 3, 3, 0, 3, 3, 3, 0), 
           dim = c(3, 3, 2))
CP2SUMPCAnormedCP(D3)         

</code></pre>

<hr>
<h2 id='createCubeOfCovDis'>compute a cube of covariance and a cube of distance
between the items (rows) of a brick of measurements 
(when all blocks
have the same number of variables).</h2><span id='topic+createCubeOfCovDis'></span>

<h3>Description</h3>

<p><code>createCubeOfCovDis</code>
compute a cube of covariance and a cube of 
(squared) Euclidean distance
between the items (rows) of a brick of measurements.
The variables describing the items can scaled to norm 1
and centered. The whole matrix 
can  be scaled by its first eigenvalue
(a la DISTATIS). All &quot;slices&quot; of the brick
should have the same number of variables.
For different number of variables per block,
see <code>list2CubeOfCov</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCubeOfCovDis(brickOfData, scale = TRUE, center = TRUE, ev.scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createCubeOfCovDis_+3A_brickofdata">brickOfData</code></td>
<td>
<p>a 
<code class="reqn">I</code> items by <code class="reqn">J</code> quantitative variables
by <code class="reqn">K</code> assessors.</p>
</td></tr>
<tr><td><code id="createCubeOfCovDis_+3A_scale">scale</code></td>
<td>
<p>(Default: <code>TRUE</code>), when <code>TRUE</code>
scale to norm 1 each column for each slice.</p>
</td></tr>
<tr><td><code id="createCubeOfCovDis_+3A_center">center</code></td>
<td>
<p>(Default: <code>TRUE</code>), when <code>TRUE</code>
centers each column.</p>
</td></tr>
<tr><td><code id="createCubeOfCovDis_+3A_ev.scale">ev.scale</code></td>
<td>
<p>(Default: <code>TRUE</code>), when <code>TRUE</code>
normalizes each slice 
(i.e., each <code class="reqn">I</code> items by <code class="reqn">J</code>  matrix) so that its first 
eigenvalue is equal to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input of  <code>createCubeOfCovDis</code> is a 
<code class="reqn">I</code> items by <code class="reqn">J</code> quantitative variables
by <code class="reqn">K</code> assessors (as obtained, e.g., from a projective
mapping task).
</p>
<p>By default  <code>createCubeOfCovDis</code>
centers and normalizes each column for each slice of the brick
and then normalize each covariance matrix such that
the first eigenvalue of each covariance matrix is equal to 1.
</p>
<p>A <code>distatis</code> analysis of the Distance matrices with
the option <code>Distance = TRUE</code> will give the same results
as the <code>distatis</code> analysis of the Covariance matrices with
the option <code>Distance = FALSE</code>.
</p>


<h3>Value</h3>

<p>a list with 1) <code>cubeOfCovariance</code>
a cube of <code class="reqn">K</code>  <code class="reqn">I</code> by <code class="reqn">I</code> covariance matrices;
and 2) codecubeOfDistance
a cube of <code class="reqn">K</code>  <code class="reqn">I</code> by <code class="reqn">I</code> 
(squared) Euclidean distance
matrices.
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>See Also</h3>

<p>list2CubeOfCov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use the data from the BeersProjectiveMapping dataset
data("BeersProjectiveMapping") 
# Create the I*J_k*K brick of data
zeBrickOfData &lt;- projMap2Cube(
                     BeersProjectiveMapping$ProjectiveMapping, 
                     shape = 'flat',  nVars = 2)
# Create the cubes of Covariance and Distance                     
cubes &lt;- createCubeOfCovDis(zeBrickOfData$cubeOfData)

</code></pre>

<hr>
<h2 id='DblCenterDist'>Double Center a distance matrix</h2><span id='topic+DblCenterDist'></span>

<h3>Description</h3>

<p>Double Center a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DblCenterDist(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DblCenterDist_+3A_y">Y</code></td>
<td>
<p>a &quot;distance&quot; matrix,</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cross-product matrix (if the distance is Euclidean)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- toeplitz(c(0, 3, 3))
DblCenterDist(Y)
</code></pre>

<hr>
<h2 id='Dist2CP'>Dist2CP</h2><span id='topic+Dist2CP'></span>

<h3>Description</h3>

<p>Transforms a cube of distance matrices 
into a cube of cross-product matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dist2CP(D3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dist2CP_+3A_d3">D3</code></td>
<td>
<p>the cube of distance matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the cube of cross-product matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D3 &lt;- array(c(0, 1, 2, 1, 0, 1, 2, 1, 0, 
              0, 3, 3, 3, 0, 3, 3, 3, 0), 
            dim = c(3, 3, 2))
Dist2CP(D3)

</code></pre>

<hr>
<h2 id='DistAlgo'>Four computer algorithms evaluate the similarity of six faces for distatis
analysis</h2><span id='topic+DistAlgo'></span>

<h3>Description</h3>

<p>Provide the data.frame <code>DistAlgo</code> Data set to be used 
to illustrated the use
of the package <code>DistatisR</code>. 
Four algorithms evaluate the similarity
(i.e., distance) between six faces (3 females and 3 males). 
Each algorithm
provides a <code class="reqn">6\times 6</code> 
distance matrix evaluating the distance
between each pair of faces.
</p>


<h3>Format</h3>

<p>an <code class="reqn">6\times6\times4</code> array. Each <code class="reqn">6\times 6</code>
matrix is a distance matrix
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>Source</h3>

<p>Abdi et al. (2005). 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>References</h3>

<p>Abdi, H., Valentin, D., O'Toole, A.J., 
&amp; Edelman, B. (2005).
DISTATIS: The analysis of multiple distance matrices.  
<em>Proceedings of
the IEEE Computer Society: International 
Conference on Computer Vision and
Pattern Recognition</em>. (San Diego, CA, USA). pp. 42&ndash;47.
</p>

<hr>
<h2 id='DistanceFromRank'><code>DistanceFromRank</code>:
Creates a 3-dimensional distance array from the results 
of a ranking task.</h2><span id='topic+DistanceFromRank'></span>

<h3>Description</h3>

<p><code>DistanceFromRank</code>:  
Takes the results from a (plain) ranking task 
where <code class="reqn">K</code> assessors rank (with possible ties)
<code class="reqn">I</code> observations on 
one dimension and transform it into a brick of data
to be used by <code>distatis</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistanceFromRank(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistanceFromRank_+3A_x">X</code></td>
<td>
<p>gives the results of a ranking task 
(see example below) as an
objects (rows) by assessors (columns) matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DistanceFromRank</code> creates an 
<code class="reqn">I \times I \times K</code> 
array of distance 
in which each of the <code class="reqn">K</code> &quot;slices&quot;
stores the (squared Euclidean ranking) 
distance matrix of the <code class="reqn">k</code>th assessor.  
In one of
these distance matrices, the distance 
between two objects is computed
from he Pythagorean theorem. 
The ouput ot the function <code>DistanceFromRank</code> 
is used as input for the
function <code><a href="#topic+distatis">distatis</a></code>.
</p>
<p>The input should have assessors as columns and observations 
as rows (see
example below).
</p>


<h3>Value</h3>

<p><code>DistanceFromRank</code> returns an
<code class="reqn">I\times I \times K</code>
array of distance.
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distatis">distatis</a></code> <code><a href="#topic+DistanceFromSort">DistanceFromSort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the data set WinesRankingRawData stored in an excel file.
path2file &lt;- system.file("extdata",
           "WinesRankingRawData.xlsx", package = 'DistatisR')
ranking6Wines &lt;- read.df.excel(path = path2file, sheet = 'Ranking')
aCubeOfDistance &lt;- DistanceFromRank(ranking6Wines$df.data)

</code></pre>

<hr>
<h2 id='DistanceFromSort'>Creates a 3-dimensional distance array from the results of a sorting task.</h2><span id='topic+DistanceFromSort'></span>

<h3>Description</h3>

<p><code>DistanceFromSort</code>:  
Takes the results from a (plain) sorting task 
where <code class="reqn">K</code> assessors sort
<code class="reqn">I</code> observations into (mutually exclusive) groups 
(i.e., one object is
in one and only one group).  <code>DistanceFromSort</code> 
creates an <code class="reqn">I \times
I \times K</code> array of distance 
in which each of the <code class="reqn">k</code> &quot;slices&quot;
stores the (sorting) distance matrix of the <code class="reqn">k</code>th assessor.  
In one of
these distance matrices, a value of 0 
at the intersection of a row and a
column means that the object represented by the row and the object
represented by the column were sorted together 
(i.e., they are a distance of 0), 
and a value of 1 means these two objects 
were put into different groups.
</p>
<p>The ouput ot the function <code>DistanceFromSort</code> 
is used as input for the
function <code><a href="#topic+distatis">distatis</a></code>.
</p>
<p>The input should have assessors as columns and observations 
as rows (see
example below)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistanceFromSort(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistanceFromSort_+3A_x">X</code></td>
<td>
<p>gives the results of a sorting task (see example below) as a
objects (row) by assessors (columns) matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DistanceFromSort</code>
returns an <code class="reqn">I\times I \times K</code>
array of distance.
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>References</h3>

<p>See examples in
</p>
<p>Abdi, H., Valentin, D., Chollet, S., &amp; Chrea, C. (2007).  Analyzing
assessors and products in sorting tasks: DISTATIS, theory and applications.
<em>Food Quality and Preference</em>, <b>18</b>, 627&ndash;640.
</p>
<p>Abdi, H., &amp; Valentin, D., (2007).  Some new and easy ways to describe,
compare, and evaluate products and assessors.  In D., Valentin, D.Z. Nguyen,
L. Pelletier (Eds) <em>New trends in sensory evaluation of food and
non-food products.</em> Ho Chi Minh (Vietnam): Vietnam National University-Ho
chi Minh City Publishing House. pp. 5&ndash;18.
</p>
<p>These papers are available from 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distatis">distatis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  1. Get the data from the 2007 sorting example
#      this is the eay they look from Table 1 of 
#      Abdi et al. (2007).
#                       Assessors
#                  1 2 3 4 5 6 7 8 9 10
# Beer        Sex  f m f f m m m m f m
#            -----------------------------                         
#Affligen          1 4 3 4 1 1 2 2 1 3
#Budweiser         4 5 2 5 2 3 1 1 4 3
#Buckler_Blonde    3 1 2 3 2 4 3 1 1 2
#Killian           4 2 3 3 1 1 1 2 1 4
#St. Landelin      1 5 3 5 2 1 1 2 1 3
#Buckler_Highland  2 3 1 1 3 5 4 4 3 1
#Fruit Defendu     1 4 3 4 1 1 2 2 2 4
#EKU28             5 2 4 2 4 2 5 3 4 5

#	
# 1.1. Create the
#     Name of the Beers
BeerName &lt;- c('Affligen', 'Budweiser','Buckler Blonde',
              'Killian','St.Landelin','Buckler Highland',
              'Fruit Defendu','EKU28')
# 1.2. Create the name of the Assessors 
#      (F are females, M are males)
Juges &lt;- c('F1','M2', 'F3', 'F4', 'M5', 'M6', 'M7', 'M8', 'F9', 'M10')

# 1.3. Get the sorting data
SortData &lt;- c(1, 4, 3, 4, 1, 1, 2, 2, 1, 3,
              4, 5, 2, 5, 2, 3, 1, 1, 4, 3,
              3, 1, 2, 3, 2, 4, 3, 1, 1, 2,
              4, 2, 3, 3, 1, 1, 1, 2, 1, 4,
              1, 5, 3, 5, 2, 1, 1, 2, 1, 3,
              2, 3, 1, 1, 3, 5, 4, 4, 3, 1,
              1, 4, 3, 4, 1, 1, 2, 2, 2, 4,
              5, 2, 4, 2, 4, 2, 5, 3, 4, 5)
# 1.4 Create a data frame            
Sort &lt;- matrix(SortData,ncol = 10, byrow= TRUE, dimnames = list(BeerName, Juges))
# 
#-----------------------------------------------------------------------------
# 2. Create the set of distance matrices (one distance matrix per assessor)
#    (use the function DistanceFromSort)
DistanceCube &lt;- DistanceFromSort(Sort)
#-----------------------------------------------------------------------------
# 3. Call the DISTATIS routine with the cube of distance 
#       obtained from DistanceFromSort as a parameter for the distatis function
testDistatis &lt;- distatis(DistanceCube)


</code></pre>

<hr>
<h2 id='distatis'>3-Way MDS based on the  &quot;STATIS&quot; optimization
procedure.</h2><span id='topic+distatis'></span><span id='topic+DiSTATIS'></span><span id='topic+CovSTATIS'></span><span id='topic+covstatis'></span>

<h3>Description</h3>

<p><code>distatis</code>: Implements the <abbr><span class="acronym">DISTATIS</span></abbr>
method which is a 3-way generalization of
metric multidimensional scaling
(<em>a.k.a.</em> classical MDS or principal coordinate analysis).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distatis(
  LeCube2Distance,
  Norm = "MFA",
  Distance = TRUE,
  double_centering = TRUE,
  RV = TRUE,
  nfact2keep = 3,
  compact = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distatis_+3A_lecube2distance">LeCube2Distance</code></td>
<td>
<p>an &quot;observations 
<code class="reqn">\times</code> observations
<code class="reqn">\times</code> distance matrices&quot; array of dimensions
<code class="reqn">I\times I \times  K</code>.
Each of the <code class="reqn">K</code> &quot;slices&quot; is a <code class="reqn">I\times I</code> square
distance (or covariance) matrix describing the 
<code class="reqn">I</code> observations.</p>
</td></tr>
<tr><td><code id="distatis_+3A_norm">Norm</code></td>
<td>
<p>Type of normalization 
used for each cross-product matrix derived
from the distance (or covariance) matrices.  
Current options are <code>NONE</code>
(do nothing), <code>SUMPCA</code> (normalize by the total inertia) 
or <code>MFA</code> (<code>default</code>) that normalizes each matrix so
that its first eigenvalue is equal to one
or <code>NUCLEAR</code> (i.e., the of the squarae root of the
eigenvalues).</p>
</td></tr>
<tr><td><code id="distatis_+3A_distance">Distance</code></td>
<td>
<p>if <code>TRUE</code> (<code>default</code>) 
the matrices are distance matrices, <code>FALSE</code>
the matrices are treated as positive semi-definite matrices
(e.g., scalar products,
covariance, or correlation matrices).</p>
</td></tr>
<tr><td><code id="distatis_+3A_double_centering">double_centering</code></td>
<td>
<p>if <code>TRUE</code> 
(<code>default</code>) the matrices are double-centered
(should always be used for distances).
if <code>FALSE</code> the matrices
will <em>not</em> be double centered 
(note that these matrices 
should be semi positive definite matrices such as,
for example,
covariance matrices).</p>
</td></tr>
<tr><td><code id="distatis_+3A_rv">RV</code></td>
<td>
<p>if <code>TRUE</code> (<code>default</code>) 
we use the <code class="reqn">R_V</code> coefficient to
compute the <code class="reqn">\alpha</code>, 
if <code>FALSE</code>
we use the matrix scalar product.</p>
</td></tr>
<tr><td><code id="distatis_+3A_nfact2keep">nfact2keep</code></td>
<td>
<p>(default: <code>3</code>) Number of factors 
to keep for the computation of the
factor scores of the observations.</p>
</td></tr>
<tr><td><code id="distatis_+3A_compact">compact</code></td>
<td>
<p>if <code>FALSE</code> (default),
<code>distatis</code> provides detailed output, if
<code>TRUE</code>,  <code>distatis</code> sends back
only the <code class="reqn">\alpha</code> weights
(this option is used to make the
bootstrap routine 
<code><a href="#topic+BootFromCompromise">BootFromCompromise</a></code> more 
computationally efficient).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>distatis</code> takes
as input a set of <code class="reqn">K</code> distance matrices
(or  positive semi-definite matrices such as scalar products,
covariance, or correlation matrices)
describing a set of <code class="reqn">I</code> observations.
From this set of matrices <code>distatis</code>    
computes: (1) a set of
factor scores that describes the similarity structure 
of the <code class="reqn">K</code> distance
matrices (e.g., what distance matrices describe the 
observations in the same
way, what distance matrices differ from each other) 
(2) a set of factor
scores (called the <em>compromise</em> factor scores) 
that best describes  
the similarity structure of the <code class="reqn">I</code> observations 
and (3)
<code class="reqn">I</code>
sets of
partial factor scores that show how 
each individual distance matrix &quot;sees&quot;
the compromise space.  
</p>
<p><code>distatis</code> computes the compromise as an optimum
linear combination of the cross-product matrices 
associated to each distance 
(or positive positive semi-definite)
matrix. 
</p>
<p><code>distatis</code> can also be applied to a set of 
scalar products, covariance, or correlation
matrices.
</p>
<p><abbr><span class="acronym">DISTATIS</span></abbr> is part of the 
<abbr><span class="acronym">STATIS</span></abbr> family.
It is often used to analyze
the results of sorting tasks.
</p>


<h3>Value</h3>

<p><code>distatis</code> sends back the results 
<em>via</em> two lists:
<code>res.Cmat</code>
and <code>res.Splus</code>.
Note that items with a * are the only ones sent back
when using the <code>compact = TRUE</code> option.
</p>
<table>
<tr><td><code>res.Cmat</code></td>
<td>
<p>Results for the between 
distance matrices analysis.</p>
</td></tr>
</table>
 
<ul>
<li> <p><code>res.Cmat$C</code>
The <code class="reqn">I\times I</code> <b>C</b> matrix
of scalar products (or <code class="reqn">R_V</code> between distance matrices).  
</p>
</li>
<li>
<p><code>res.Cmat$vectors</code> The eigenvectors of the <b>C</b> matrix 
</p>
</li>
<li>
<p><code>res.Cmat$alpha</code> * The <code class="reqn">\alpha</code> weights 
</p>
</li>
<li>
<p><code>res.Cmat$value</code> The eigenvalues of the <b>C</b> matrix 
</p>
</li>
<li>
<p><code>res.Cmat$G</code> The factor scores for the <b>C</b> matrix 
</p>
</li>
<li> 
<p><code>res.Cmat$ctr</code> The contributions for <code>res.Cmat$G</code>,
</p>
</li>
<li>
<p><code>res.Cmat$cos2</code> The squared cosines for <code>res.Cmat$G</code>
</p>
</li>
<li>
<p><code>res.Cmat$d2</code> The squared 
Euclidean distance  for <code>res.Cmat$G</code>.
</p>
</li></ul>

<table>
<tr><td><code>res.Splus</code></td>
<td>
<p>Results for the between observation analysis.</p>
</td></tr>
</table>

<ul>
<li> <p><code>res.Splus$SCP</code> an <code class="reqn">I\times I\times K</code> array.
Contains
the (normalized if needed)
cross product matrices corresponding to the
distance matrices.
</p>
</li>
<li> <p><code>res.Splus$Splus</code> * The compromise 
(optimal linear
combination of the SCP's').
</p>
</li>
<li> <p><code>res.Splus$eigValues</code> *
The eigenvalues of the compromise).
</p>
</li>
<li> <p><code>res.Splus$eigVectors</code> *
The eigenvectors of the compromise).
</p>
</li>
<li> <p><code>res.Splus$tau</code> * The percentage
of explained inertia of the eigenValues).
</p>
</li>
<li> <p><code>res.Splus$ProjectionMatrix</code> The
projection matrix used to compute factor
scores and partial factor scores.
</p>
</li>
<li> <p><code>res.Splus$F</code> The factor scores for the observations.
</p>
</li>
<li> 
<p><code>res.Splus$ctr</code> The contributions for <code>res.Cmat$F</code>.
</p>
</li>
<li>
<p><code>res.Splus$cos2</code> The squared cosines for <code>res.Cmat$F</code>.
</p>
</li>
<li>
<p><code>res.Splust$d2</code> The squared 
Euclidean distance  for <code>res.Cmat$F</code>.
</p>
</li>
<li> <p><code>res.Splus$PartialF</code> an
<code class="reqn">I \times \code{nf2keep} \times K</code> array.
Contains the partial factors for the distance
matrices.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Hervé Abdi
#@seealso <code><a href="#topic+GraphDistatisAll">GraphDistatisAll</a></code> 
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code>
#<code><a href="#topic+GraphDistatisCompromise">GraphDistatisCompromise</a></code> 
# <code><a href="#topic+GraphDistatisPartial">GraphDistatisPartial</a></code>
#<code><a href="#topic+GraphDistatisRv">GraphDistatisRv</a></code> <code><a href="#topic+DistanceFromSort">DistanceFromSort</a></code>
#<code><a href="#topic+BootFactorScores">BootFactorScores</a></code> <code><a href="#topic+BootFromCompromise">BootFromCompromise</a></code>
#as <code><a href="utils.html#topic+help">help</a></code>,
</p>


<h3>References</h3>

<p>Abdi, H., Valentin, D., O'Toole, A.J., &amp; Edelman, B.
(2005).
DISTATIS: The analysis of multiple distance matrices.  
<em>Proceedings of
the IEEE Computer Society: 
International Conference on Computer Vision and
Pattern Recognition</em>.  (San Diego, CA, USA). pp. 42&ndash;47.
</p>
<p>Abdi, H., Valentin, D., Chollet, S., &amp; Chrea, C. (2007). 
Analyzing
assessors and products in sorting tasks:
DISTATIS, theory and applications.
<em>Food Quality and Preference</em>, <b>18</b>, 627&ndash;640.
</p>
<p>Abdi, H., Dunlop, J.P., &amp; Williams, L.J. (2009).  
How to compute reliability
estimates and display confidence and tolerance 
intervals for pattern
classifiers using the Bootstrap and 3-way multidimensional scaling
(DISTATIS).  
<em>NeuroImage</em>, <b>45</b>, 89&ndash;95.
</p>
<p>Abdi, H., Williams, L.J., Valentin, D., &amp; 
Bennani-Dosse, M. (2012).
STATIS
and DISTATIS: Optimum multi-table principal component 
analysis and three way
metric multidimensional scaling.  
<em>Wiley Interdisciplinary Reviews:
Computational Statistics</em>, <b>4</b>, 124&ndash;167.
</p>
<p>The <code class="reqn">R_V</code> coefficient is described in
</p>
<p>Abdi, H. (2007). RV coefficient and congruence coefficient. 
In N.J. Salkind
(Ed.): <em>Encyclopedia of Measurement and Statistics</em>.  
Thousand Oaks
(CA): Sage. pp. 849&ndash;853.
</p>
<p>Abdi, H. (2010). Congruence: Congruence coefficient, 
RV coefficient, and
Mantel Coefficient.  In N.J. Salkind, D.M., Dougherty,
&amp; B. Frey (Eds.):
<em>Encyclopedia of Research Design.</em>
Thousand Oaks (CA): Sage. pp.
222&ndash;229.
</p>
<p>(These papers are available from 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. Load the DistAlgo data set 
# (available from the DistatisR package).
data(DistAlgo)
# DistAlgo is a 6*6*4 Array (face*face*Algorithm)
#------------------------------------------------------------------
# 2. Call the DISTATIS routine with the array 
#  of distance (DistAlgo) as parameter
DistatisAlgo &lt;- distatis(DistAlgo)
</code></pre>

<hr>
<h2 id='GetCmat'>GetCmat</h2><span id='topic+GetCmat'></span>

<h3>Description</h3>

<p>Computes the RV coefficient matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCmat(CubeCP, RV = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetCmat_+3A_cubecp">CubeCP</code></td>
<td>
<p>A 3D array of cross-product matrices</p>
</td></tr>
<tr><td><code id="GetCmat_+3A_rv">RV</code></td>
<td>
<p>Boolean, if TRUE, GetCmat computes the matrix of the RV coefficients between all the slices of the 3D array, otherwise, GetCmat computes a scalar product.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of either RV coefficients or scalar products.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D3 &lt;- array(c(0, 1, 2, 1, 0, 1, 2, 1, 0, 
              0, 3, 3, 3, 0, 3, 3, 3, 0), 
            dim = c(3, 3, 2))
GetCmat(D3)             

</code></pre>

<hr>
<h2 id='GetRectCmat'>GetRectCmat</h2><span id='topic+GetRectCmat'></span>

<h3>Description</h3>

<p>Computes the rectangular RV coefficient matrix between two arrays of conformable matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetRectCmat(CubeCP1, CubeCP2, RV = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetRectCmat_+3A_cubecp1">CubeCP1</code></td>
<td>
<p>A 3D array of cross-product matrices</p>
</td></tr>
<tr><td><code id="GetRectCmat_+3A_cubecp2">CubeCP2</code></td>
<td>
<p>A 3D array of cross-product matrices</p>
</td></tr>
<tr><td><code id="GetRectCmat_+3A_rv">RV</code></td>
<td>
<p>Boolean, if TRUE, GetCmat computes the matrix of the RV coefficients between all the slices of the 3D array, otherwise, GetCmat computes a scalar product.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rectangular matrix of either RV coefficients or scalar products.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D3.1 &lt;- array(c(0, 1, 2, 1, 0, 1, 2, 1, 0, 
              0, 3, 3, 3, 0, 3, 3, 3, 0), 
            dim = c(3, 3, 2))
D3.2 &lt;- array(c(1, 0, 0, 0, 1, 0, 0, 0, 1, 
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                 0, 0, 0, 0, 0, 0, 0, 0, 0), 
            dim = c(3, 3, 3))
GetRectCmat(D3.1, D3.2)             

</code></pre>

<hr>
<h2 id='GraphDistatisAll'>This function combines the functionality of
<code><a href="#topic+GraphDistatisCompromise">GraphDistatisCompromise</a></code>, <code><a href="#topic+GraphDistatisPartial">GraphDistatisPartial</a></code>,
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code>, and <code><a href="#topic+GraphDistatisRv">GraphDistatisRv</a></code>.</h2><span id='topic+GraphDistatisAll'></span>

<h3>Description</h3>

<p>This function produces 4 plots: (1) a compromise plot, (2) a partial factor
scores plot, (3) a bootstrap confidence intervals plot, and (4) an <code class="reqn">Rv</code> map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GraphDistatisAll(
  FS,
  PartialFS,
  FBoot,
  RvFS,
  axis1 = 1,
  axis2 = 2,
  constraints = NULL,
  item.colors = NULL,
  participant.colors = NULL,
  ZeTitleBase = NULL,
  nude = FALSE,
  Ctr = NULL,
  RvCtr = NULL,
  color.by.observations = TRUE,
  lines = TRUE,
  lwd = 3.5,
  ellipses = TRUE,
  fill = TRUE,
  fill.alpha = 0.27,
  percentage = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GraphDistatisAll_+3A_fs">FS</code></td>
<td>
<p>The factor scores of the observations
(<code>$res4Splus$F</code>from
<code>distatis</code>)</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_partialfs">PartialFS</code></td>
<td>
<p>The partial factor scores of the observations
(<code>$res4Splus$PartialF</code> from <code>distatis</code>)</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_fboot">FBoot</code></td>
<td>
<p>is the bootstrapped factor scores array 
(<code>FBoot</code> obtained
from <code><a href="#topic+BootFactorScores">BootFactorScores</a></code> or 
<code><a href="#topic+BootFromCompromise">BootFromCompromise</a></code>)</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_rvfs">RvFS</code></td>
<td>
<p>The factor scores
of the distance matrices (<code>$res4Cmat$G</code>
from <code>distatis</code>)</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_axis1">axis1</code></td>
<td>
<p>The dimension for the horizontal axis of the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_axis2">axis2</code></td>
<td>
<p>The dimension for the vertical axis of the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_constraints">constraints</code></td>
<td>
<p>constraints for the axes</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_item.colors">item.colors</code></td>
<td>
<p>A <code class="reqn">I\times 1</code> matrix (with <code class="reqn">I</code> = #
observations) of color names for the observations. 
If <code>NULL</code> (default),
<code>prettyGraphs</code> chooses.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_participant.colors">participant.colors</code></td>
<td>
<p>A <code class="reqn">I\times 1</code> matrix (with <code class="reqn">I</code> = #
participants) of color names for the observations. If NULL (default),
<code>prettyGraphs</code> chooses.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_zetitlebase">ZeTitleBase</code></td>
<td>
<p>General title for the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_nude">nude</code></td>
<td>
<p>When <code>nude</code> is <code>TRUE</code> the labels for the observations
are not plotted (useful when editing the graphs for publication).</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_ctr">Ctr</code></td>
<td>
<p>Contributions of each observation. If NULL (default), these are
computed from <code>FS</code></p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_rvctr">RvCtr</code></td>
<td>
<p>Contributions of each participant. If NULL (default), these are
computed from RvFS</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_color.by.observations">color.by.observations</code></td>
<td>
<p>if <code>TRUE</code> (default), the partial factor
scores are colored by <code>item.colors</code>. When <code>FALSE</code>,
<code>participant.colors</code> are used.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_lines">lines</code></td>
<td>
<p>If <code>TRUE</code> (default) then lines are drawn between the
partial factor score of an observation and the compromise factor score of
the observation.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_lwd">lwd</code></td>
<td>
<p>Thickness of the line plotting the ellipse or hull.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_ellipses">ellipses</code></td>
<td>
<p>a boolean. When <code>TRUE</code> will plot ellipses (from
<code>car</code> package). When <code>FALSE</code> (default) 
will plot peeled hulls (from
<code>prettyGraphs</code> package).</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_fill">fill</code></td>
<td>
<p>when <code>TRUE</code>, fill in the ellipse with color. 
Relevant for
ellipses only.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>transparency index when filling in the ellipses.
Relevant
to ellipses only.</p>
</td></tr>
<tr><td><code id="GraphDistatisAll_+3A_percentage">percentage</code></td>
<td>
<p>A value to determine the percent coverage of the bootstrap
partial factor scores to provide ellipse or hull confidence intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>constraints</code></td>
<td>
<p>A set of plot constraints that are returned.</p>
</td></tr>
<tr><td><code>item.colors</code></td>
<td>
<p>A set of colors for the observations are returned.</p>
</td></tr>
<tr><td><code>participant.colors</code></td>
<td>
<p>A set of colors for the participants are
returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Herve Abdi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GraphDistatisAll">GraphDistatisAll</a></code>
<code><a href="#topic+GraphDistatisCompromise">GraphDistatisCompromise</a></code> <code><a href="#topic+GraphDistatisPartial">GraphDistatisPartial</a></code>
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code> <code><a href="#topic+GraphDistatisRv">GraphDistatisRv</a></code>
<code><a href="#topic+distatis">distatis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. Load the Sort data set from the SortingBeer example  (available from the DistatisR package)
data(SortingBeer)
# Provide an 8 beers by 10 assessors results of a sorting task
#-----------------------------------------------------------------------------
# 2. Create the set of distance matrices (one distance matrix per assessor)
#    (ues the function DistanceFromSort)
DistanceCube &lt;- DistanceFromSort(Sort)

#-----------------------------------------------------------------------------
# 3. Call the DISTATIS routine with the cube of distance as parameter
testDistatis &lt;- distatis(DistanceCube)
# The factor scores for the beers are in
# testDistatis$res4Splus$F
# the partial factor score for the beers for the assessors are in
#  testDistatis$res4Splus$PartialF
#
# 4. Get the bootstraped factor scores (with default 1000 iterations)
BootF &lt;- BootFactorScores(testDistatis$res4Splus$PartialF)
#-----------------------------------------------------------------------------
# 5. Create the Graphics with GraphDistatisAll
#
GraphDistatisAll(testDistatis$res4Splus$F,testDistatis$res4Splus$PartialF,
	BootF,testDistatis$res4Cmat$G)

</code></pre>

<hr>
<h2 id='GraphDistatisBoot'><code>GraphDistatisBoot</code> Plot maps of the factor scores
of the observations and their bootstrapped
confidence intervals (as confidence ellipsoids or peeled hulls)
for a
<abbr><span class="acronym">DISTATIS</span></abbr> analysis.</h2><span id='topic+GraphDistatisBoot'></span>

<h3>Description</h3>

<p><code>GraphDistatisBoot</code> plots maps of the factor scores of the observations
from a <code><a href="#topic+distatis">distatis</a></code> analysis.
<code>GraphDistatisBoot</code> gives a
map of the factors scores of the observations plus the boostrapped
confidence intervals drawn as &quot;Confidence Ellipsoids&quot; at
the <code>percentage</code> level (see parameter <code>percentage</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GraphDistatisBoot(
  FS,
  FBoot,
  axis1 = 1,
  axis2 = 2,
  item.colors = NULL,
  ZeTitle = "Distatis-Bootstrap",
  constraints = NULL,
  nude = FALSE,
  Ctr = NULL,
  lwd = 3.5,
  ellipses = TRUE,
  fill = TRUE,
  fill.alpha = 0.27,
  percentage = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GraphDistatisBoot_+3A_fs">FS</code></td>
<td>
<p>The factor scores of the observations (<code>$res4Splus$F</code> from
<code><a href="#topic+distatis">distatis</a></code>)</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_fboot">FBoot</code></td>
<td>
<p>is the bootstrapped factor scores array (<code>FBoot</code> obtained
from <code><a href="#topic+BootFactorScores">BootFactorScores</a></code> or <code><a href="#topic+BootFromCompromise">BootFromCompromise</a></code>)</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_axis1">axis1</code></td>
<td>
<p>The dimension for the horizontal axis of the plots.
(default = 1).</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_axis2">axis2</code></td>
<td>
<p>The dimension for the vertical axis of the plots
(default = 2).</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_item.colors">item.colors</code></td>
<td>
<p>When present, 
should be a column matrix (dimensions of
observations and 1).  
Gives the color-names to be used to color the plots.
Can be obtained as the output of this or the other graph routine. 
If <code>NULL</code>,
<code>prettyGraphs</code> chooses.</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_zetitle">ZeTitle</code></td>
<td>
<p>General title for the plots (default is
'Distatis-Bootstrap').</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_constraints">constraints</code></td>
<td>
<p>constraints for the axes</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_nude">nude</code></td>
<td>
<p>When <code>TRUE</code> do not plot
the names of the observations (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_ctr">Ctr</code></td>
<td>
<p>Contributions of each observation.
If <code>NULL</code> (default), these are
computed from <code>FS</code>.</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_lwd">lwd</code></td>
<td>
<p>Thickness of the line plotting the ellipse or hull
(default = 3.5).</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_ellipses">ellipses</code></td>
<td>
<p>a boolean. When <code>TRUE</code> (default)
will plot ellipses (from the
<code>car</code> package).
When <code>FALSE</code> will plot peeled hulls (from
<code>prettyGraphs</code> package).</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_fill">fill</code></td>
<td>
<p>when <code>TRUE</code>, fill in the ellipse with color.
Relevant for
ellipses only.</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>transparency index
(a number between 0 and 1) when filling in the ellipses.
Relevant for
ellipses only (default = .27).</p>
</td></tr>
<tr><td><code id="GraphDistatisBoot_+3A_percentage">percentage</code></td>
<td>
<p>A value to determine the percent
coverage of the bootstrap
partial factor scores to provide ellipse
or hull confidence intervals (default = .95).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ellipses are plotted using the function <code>dataEllipse()</code> from the
package <code>car</code>. The peeled hulls are plotted using the function
<code>peeledHulls()</code> from the package <code>prettyGraphs</code>.
</p>
<p>Note that, in the current version, the graphs are plotted as R-plots and are
<em>not</em> passed back by the function.  So the graphs need to be saved &quot;by
hand&quot; from the R graphic windows.  We plan to improve this in a future
version.
See also package <code>PTCA4CATA</code> for <code>ggplot2</code> based graphs.
</p>


<h3>Value</h3>

<table>
<tr><td><code>constraints</code></td>
<td>
<p>A set of plot constraints that are returned.</p>
</td></tr>
<tr><td><code>item.colors</code></td>
<td>
<p>A set of colors for the observations are returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Herve Abdi
</p>


<h3>References</h3>

<p>The plots are similar to the graphs described in:
</p>
<p>Abdi, H., Williams, L.J., Valentin, D., &amp; Bennani-Dosse, M. (2012). STATIS
and DISTATIS: Optimum multi-table principal component analysis and three way
metric multidimensional scaling. <em>Wiley Interdisciplinary Reviews:
Computational Statistics</em>, <b>4</b>, 124&ndash;167.
</p>
<p>Abdi, H., Dunlop, J.P., &amp; Williams, L.J. (2009). How to compute reliability
estimates and display confidence and tolerance intervals for pattern
classiffers using the Bootstrap and 3-way multidimensional scaling
(DISTATIS). <em>NeuroImage</em>, <b>45</b>, 89&ndash;95.
</p>
<p>Abdi, H., &amp; Valentin, D., (2007). Some new and easy ways to describe,
compare, and evaluate products and assessors. In D., Valentin, D.Z. Nguyen,
L. Pelletier (Eds) <em>New trends in sensory evaluation of food and
non-food products</em>.  Ho Chi Minh (Vietnam): Vietnam National University-Ho
chi Minh City Publishing House. pp. 5&ndash;18.
</p>
<p>These papers are available from <a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GraphDistatisAll">GraphDistatisAll</a></code>
<code><a href="#topic+GraphDistatisCompromise">GraphDistatisCompromise</a></code> <code><a href="#topic+GraphDistatisPartial">GraphDistatisPartial</a></code>
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code> <code><a href="#topic+GraphDistatisRv">GraphDistatisRv</a></code>
<code><a href="#topic+distatis">distatis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. Load the Sort data set from the SortingBeer example
# (available from the DistatisR package)
data(SortingBeer)
# Provide an 8 beers by 10 assessors results of a sorting task
#-----------------------------------------------------------------------------
# 2. Create the set of distance matrices (one distance matrix per assessor)
#    (ues the function DistanceFromSort)
DistanceCube &lt;- DistanceFromSort(Sort)

#-----------------------------------------------------------------------------
# 3. Call the DISTATIS routine with the cube of distance as parameter
testDistatis &lt;- distatis(DistanceCube)
# The factor scores for the beers are in
# testDistatis$res4Splus$F
# the partial factor score for the beers for the assessors are in
#  testDistatis$res4Splus$PartialF
#
# 4. Get the bootstraped factor scores (with default 1000 iterations)
BootF &lt;- BootFactorScores(testDistatis$res4Splus$PartialF)
#-----------------------------------------------------------------------------
# 5. Create the Graphics with GraphDistatisBoot
#
GraphDistatisBoot(testDistatis$res4Splus$F,BootF)


</code></pre>

<hr>
<h2 id='GraphDistatisCompromise'>Plot maps of the factor scores of the observations for a <abbr><span class="acronym">DISTATIS</span></abbr>
analysis</h2><span id='topic+GraphDistatisCompromise'></span>

<h3>Description</h3>

<p>Plot maps of the factor scores of the observations for a <abbr><span class="acronym">distatis</span></abbr>
analysis. <code>GraphDistatis</code> gives a map of the factor scores for the
observations. The labels of the observations are plotted by defaults but can
be omitted (see the <code>nude=TRUE</code> option).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GraphDistatisCompromise(
  FS,
  axis1 = 1,
  axis2 = 2,
  constraints = NULL,
  item.colors = NULL,
  ZeTitle = "Distatis-Compromise",
  nude = FALSE,
  Ctr = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GraphDistatisCompromise_+3A_fs">FS</code></td>
<td>
<p>The factor scores of the observations (<code>$res4Splus$F</code>from
<code>distatis</code>).</p>
</td></tr>
<tr><td><code id="GraphDistatisCompromise_+3A_axis1">axis1</code></td>
<td>
<p>The dimension for the horizontal axis of the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisCompromise_+3A_axis2">axis2</code></td>
<td>
<p>The dimension for the vertical axis of the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisCompromise_+3A_constraints">constraints</code></td>
<td>
<p>constraints for the axes</p>
</td></tr>
<tr><td><code id="GraphDistatisCompromise_+3A_item.colors">item.colors</code></td>
<td>
<p>A <code class="reqn">I\times 1</code> matrix (with <code class="reqn">I</code> = #
observations) of color names for the observations. If <code>NULL</code> (default),
<code>prettyGraphs</code> chooses.</p>
</td></tr>
<tr><td><code id="GraphDistatisCompromise_+3A_zetitle">ZeTitle</code></td>
<td>
<p>General title for the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisCompromise_+3A_nude">nude</code></td>
<td>
<p>(default <code>FALSE</code>) 
When <code>nude</code> is <code>TRUE</code> the labels for the observations
are not plotted (useful when editing the graphs for publication).</p>
</td></tr>
<tr><td><code id="GraphDistatisCompromise_+3A_ctr">Ctr</code></td>
<td>
<p>Contributions of each observation. If NULL (default), these are
computed from FS</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, in the current version, the graphs are plotted as R-plots and are
<em>not</em> passed back by the routine.  So the graphs need to be saved &quot;by
hand&quot; from the R graphic windows.  We plan to improve this in a future
version.
</p>


<h3>Value</h3>

<table>
<tr><td><code>constraints</code></td>
<td>
<p>A set of plot constraints that are returned.</p>
</td></tr>
<tr><td><code>item.colors</code></td>
<td>
<p>A set of colors for the observations are returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Herve Abdi
</p>


<h3>References</h3>

<p>The plots are similar to the graphs from
</p>
<p>Abdi, H., Valentin, D., O'Toole, A.J., &amp; Edelman, B. (2005).  DISTATIS: The
analysis of multiple distance matrices.  <em>Proceedings of the IEEE
Computer Society: International Conference on Computer Vision and Pattern
Recognition</em>.  (San Diego, CA, USA). pp. 42-47.
</p>
<p>Paper available from:  <a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GraphDistatisAll">GraphDistatisAll</a></code>
<code><a href="#topic+GraphDistatisCompromise">GraphDistatisCompromise</a></code> <code><a href="#topic+GraphDistatisPartial">GraphDistatisPartial</a></code>
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code> <code><a href="#topic+GraphDistatisRv">GraphDistatisRv</a></code>
<code><a href="#topic+distatis">distatis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. Load the DistAlgo data set (available from the DistatisR package)
data(DistAlgo)
# DistAlgo is a 6*6*4 Array (face*face*Algorithm)
#-----------------------------------------------------------------------------
# 2. Call the DISTATIS routine with the array of distance (DistAlgo) as parameter
DistatisAlgo &lt;- distatis(DistAlgo)
# 3. Plot the compromise map with the labels for the first 2 dimensions
# DistatisAlgo$res4Splus$F are the factors scores for the 6 observations (i.e., faces)
# DistatisAlgo$res4Splus$PartialF are the partial factors scores
	##(i.e., one set of factor scores per algorithm)
 GraphDistatisCompromise(DistatisAlgo$res4Splus$F)

</code></pre>

<hr>
<h2 id='GraphDistatisPartial'>Plot maps of the factor scores and partial factor scores of the observations
for a <abbr><span class="acronym">DISTATIS</span></abbr> analysis.</h2><span id='topic+GraphDistatisPartial'></span>

<h3>Description</h3>

<p><code>GraphDistatisPartial</code> plots maps of the factor scores of the
observations from a <code><a href="#topic+distatis">distatis</a></code> analysis.
<code>GraphDistatisPartial</code> gives a map of the factors scores of the
observations plus partial factor scores, 
as &quot;seen&quot; by each of the matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GraphDistatisPartial(
  FS,
  PartialFS,
  axis1 = 1,
  axis2 = 2,
  constraints = NULL,
  item.colors = NULL,
  participant.colors = NULL,
  ZeTitle = "Distatis-Partial",
  Ctr = NULL,
  color.by.observations = TRUE,
  nude = FALSE,
  lines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GraphDistatisPartial_+3A_fs">FS</code></td>
<td>
<p>The factor scores of the observations
(<code>$res4Splus$F</code> from the output of
<code>distatis</code>).</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_partialfs">PartialFS</code></td>
<td>
<p>The partial factor scores of the observations
(<code>$res4Splus$PartialF</code> from <code>distatis</code>)</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_axis1">axis1</code></td>
<td>
<p>The dimension for the horizontal axis of the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_axis2">axis2</code></td>
<td>
<p>The dimension for the vertical axis of the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_constraints">constraints</code></td>
<td>
<p>constraints for the axes</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_item.colors">item.colors</code></td>
<td>
<p>A <code class="reqn">I\times 1</code> matrix (with <code class="reqn">I</code> = #
observations) of color names for the observations.
If <code>NULL</code> (default),
<code>prettyGraphs</code> chooses.</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_participant.colors">participant.colors</code></td>
<td>
<p>A <code class="reqn">I\times 1</code> matrix (with <code class="reqn">I</code> = #
participants) of color names for the observations.
If <code>NULL</code> (default),
<code>prettyGraphs</code> chooses (with function <code>prettyGraphs::</code>).</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_zetitle">ZeTitle</code></td>
<td>
<p>General title for the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_ctr">Ctr</code></td>
<td>
<p>Contributions of each observation. If NULL (default), these are
computed from FS</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_color.by.observations">color.by.observations</code></td>
<td>
<p>if <code>TRUE</code> (default), the partial factor
scores are colored by <code>item.colors</code>. When <code>FALSE</code>,
<code>participant.colors</code> are used.</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_nude">nude</code></td>
<td>
<p>When <code>nude</code> is <code>TRUE</code> the labels for the observations
are not plotted (useful when editing the graphs for publication).</p>
</td></tr>
<tr><td><code id="GraphDistatisPartial_+3A_lines">lines</code></td>
<td>
<p>If <code>TRUE</code> (default) then lines are drawn between the
partial factor score of an observation and the compromise factor score of
the observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, in the current version, the graphs are plotted as R-plots and are
<em>not</em> passed back by the routine.  So the graphs need to be saved &quot;by
hand&quot; from the R graphic windows.  We plan to improve this in a future
version.
</p>


<h3>Value</h3>

<table>
<tr><td><code>constraints</code></td>
<td>
<p>A set of plot constraints that are returned.</p>
</td></tr>
<tr><td><code>item.colors</code></td>
<td>
<p>A set of colors for the observations are returned.</p>
</td></tr>
<tr><td><code>participant.colors</code></td>
<td>
<p>A set of colors for the participants are
returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Herve Abdi
</p>


<h3>References</h3>

<p>The plots are similar to the graphs from
</p>
<p>Abdi, H., Valentin, D., O'Toole, A.J., &amp; Edelman, B. (2005).  DISTATIS: The
analysis of multiple distance matrices.  <em>Proceedings of the IEEE
Computer Society: International Conference on Computer Vision and Pattern
Recognition</em>.  (San Diego, CA, USA). pp. 42-47.
</p>
<p>Paper available from  <a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GraphDistatisAll">GraphDistatisAll</a></code>
<code><a href="#topic+GraphDistatisCompromise">GraphDistatisCompromise</a></code> <code><a href="#topic+GraphDistatisPartial">GraphDistatisPartial</a></code>
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code> <code><a href="#topic+GraphDistatisRv">GraphDistatisRv</a></code>
<code><a href="#topic+distatis">distatis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. Load the DistAlgo data set (available from the DistatisR package)
data(DistAlgo)
# DistAlgo is a 6*6*4 Array (face*face*Algorithm)
#-----------------------------------------------------------------------------
# 2. Call the DISTATIS routine with the array of distance (DistAlgo) as parameter
DistatisAlgo &lt;- distatis(DistAlgo)
# 3. Plot the compromise map with the labels for the first 2 dimensions
# DistatisAlgo$res4Splus$F are the factors scores for the 6 observations (i.e., faces)
# DistatisAlgo$res4Splus$PartialF are the partial factors scores
	##(i.e., one set of factor scores per algorithm)
 GraphDistatisPartial(DistatisAlgo$res4Splus$F,DistatisAlgo$res4Splus$PartialF)
</code></pre>

<hr>
<h2 id='GraphDistatisRv'>Plot maps of the factor scores (from the Rv matrix) of the distance matrices
for a <abbr><span class="acronym">DISTATIS</span></abbr> analysis</h2><span id='topic+GraphDistatisRv'></span>

<h3>Description</h3>

<p>Plot maps of the factor scores of the observations for a <abbr><span class="acronym">distatis</span></abbr>
analysis.  The factor scores are obtained from the eigen-decomposition of
the between distance matrices cosine matrix (often a matrix of Rv
coefficients). Note that the factor scores for the first dimension are
always positive. There are used to derive the <code class="reqn">\alpha</code> weights
for <abbr><span class="acronym">DISTATIS</span></abbr>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GraphDistatisRv(
  RvFS,
  axis1 = 1,
  axis2 = 2,
  ZeTitle = "Distatis-Rv Map",
  participant.colors = NULL,
  nude = FALSE,
  RvCtr = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GraphDistatisRv_+3A_rvfs">RvFS</code></td>
<td>
<p>The factor scores of the distance matrices (<code>$res4Cmat$G</code>
from <code>distatis</code>).</p>
</td></tr>
<tr><td><code id="GraphDistatisRv_+3A_axis1">axis1</code></td>
<td>
<p>The dimension for the horizontal axis of the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisRv_+3A_axis2">axis2</code></td>
<td>
<p>The dimension for the vertical axis of the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisRv_+3A_zetitle">ZeTitle</code></td>
<td>
<p>General title for the plots.</p>
</td></tr>
<tr><td><code id="GraphDistatisRv_+3A_participant.colors">participant.colors</code></td>
<td>
<p>A <code class="reqn">I\times 1</code> matrix (with <code class="reqn">I</code> = #
participants) of color names for the observations. If NULL (default),
<code>prettyGraphs</code> chooses.</p>
</td></tr>
<tr><td><code id="GraphDistatisRv_+3A_nude">nude</code></td>
<td>
<p>When <code>nude</code> is <code>TRUE</code> the labels for the observations
are not plotted (useful when editing the graphs for publication).</p>
</td></tr>
<tr><td><code id="GraphDistatisRv_+3A_rvctr">RvCtr</code></td>
<td>
<p>Contributions of each participant. 
If codeNULL (default), these are
computed from <code>RvFS</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, in the current version, the graphs are plotted as R-plots and are
<em>not</em> passed back by the routine.  So the graphs need to be saved &quot;by
hand&quot; from the R graphic windows.  We plan to improve this in a future
version.
</p>


<h3>Value</h3>

<table>
<tr><td><code>constraints</code></td>
<td>
<p>A set of plot constraints that are returned.</p>
</td></tr>
<tr><td><code>participant.colors</code></td>
<td>
<p>A set of colors for the participants are
returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Herve Abdi
</p>


<h3>References</h3>

<p>The plots are similar to the graphs described in:
</p>
<p>Abdi, H., Valentin, D., O'Toole, A.J., &amp; Edelman, B. (2005).  DISTATIS: The
analysis of multiple distance matrices.  <em>Proceedings of the IEEE
Computer Society: International Conference on Computer Vision and Pattern
Recognition</em>.  (San Diego, CA, USA). pp. 42-47.
</p>
<p>Abdi, H., Williams, L.J., Valentin, D., &amp; Bennani-Dosse, M. (2012). STATIS
and DISTATIS: Optimum multi-table principal component analysis and three way
metric multidimensional scaling. <em>Wiley Interdisciplinary Reviews:
Computational Statistics</em>, <b>4</b>, 124&ndash;167.
</p>
<p>Abdi, H., Dunlop, J.P., &amp; Williams, L.J. (2009). How to compute reliability
estimates and display confidence and tolerance intervals for pattern
classiffers using the Bootstrap and 3-way multidimensional scaling
(DISTATIS). <em>NeuroImage</em>, <b>45</b>, 89&ndash;95.
</p>
<p>Abdi, H., &amp; Valentin, D., (2007). Some new and easy ways to describe,
compare, and evaluate products and assessors. In D., Valentin, D.Z. Nguyen,
L. Pelletier (Eds) <em>New trends in sensory evaluation of food and
non-food products</em>.  Ho Chi Minh (Vietnam): Vietnam National University-Ho
chi Minh City Publishing House. pp. 5&ndash;18.
</p>
<p>The <code class="reqn">R_V</code> coefficient is described in
</p>
<p>Abdi, H. (2007). RV coefficient and congruence coefficient.  In N.J. Salkind
(Ed.): <em>Encyclopedia of Measurement and Statistics</em>. Thousand Oaks
(CA): Sage. pp. 849&ndash;853.
</p>
<p>Abdi, H. (2010). Congruence: Congruence coefficient, RV coefficient, and
Mantel Coefficient.  In N.J. Salkind, D.M., Dougherty, &amp; B. Frey (Eds.):
<em>Encyclopedia of Research Design.</em> Thousand Oaks (CA): Sage. pp.
222&ndash;229.
</p>
<p>These papers are available from 
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GraphDistatisAll">GraphDistatisAll</a></code>
<code><a href="#topic+GraphDistatisCompromise">GraphDistatisCompromise</a></code> <code><a href="#topic+GraphDistatisPartial">GraphDistatisPartial</a></code>
<code><a href="#topic+GraphDistatisBoot">GraphDistatisBoot</a></code> <code><a href="#topic+GraphDistatisRv">GraphDistatisRv</a></code>
<code><a href="#topic+distatis">distatis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. Load the DistAlgo data set (available from the DistatisR package)
data(DistAlgo)
# DistAlgo is a 6*6*4 Array (faces*faces*Algorithms)
#-----------------------------------------------------------------------------
# 2. Call the DISTATIS routine with the array of distance (DistAlgo) as parameter
DistatisAlgo &lt;- distatis(DistAlgo)
# 3. Plot the compromise map with the labels for the first 2 dimensions
# DistatisAlgo$res4Cmat$G are the factors scores
#  for the 4 distance matrices (i.e., algorithms)
 GraphDistatisRv(DistatisAlgo$res4Cmat$G,ZeTitle='Rv Mat')
# Et voila!

</code></pre>

<hr>
<h2 id='ldiag'>Left (i.e., pre) Multiply a matrix by a diagonal matrix</h2><span id='topic+ldiag'></span>

<h3>Description</h3>

<p><code>ldiag</code>: Left (i.e., pre) Multiply
a matrix by a diagonal matrix (with only
the diagonal elements being given).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldiag(y, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldiag_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">I</code> element
vector (of the diagonal elements of an <code class="reqn">I</code> by <code class="reqn">I</code> matrix)</p>
</td></tr>
<tr><td><code id="ldiag_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">I</code> by <code class="reqn">J</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">I</code> by <code class="reqn">J</code> matrix equal
to diag(<strong>y</strong>) 
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdiag">rdiag</a></code>
</p>

<hr>
<h2 id='list2CubeOfCovDis'>compute a cube of covariance and a cube of distance
between the items (rows) of a matrix of measurements 
comprising <code class="reqn">K</code> different blocks of possibly different
number of variables.</h2><span id='topic+list2CubeOfCovDis'></span>

<h3>Description</h3>

<p><code>list2CubeOfCovDis</code>
compute a cube of covariance and a cube of 
(squared) Euclidean distance
between the items (rows) a matrix of measurements 
comprising <code class="reqn">K</code> different blocks of possibly different
number of variables.
The variables describing the items can scaled to norm 1
and centered. The whole matrix for a block 
can  be scaled by its first eigenvalue
(a la DISTATIS). Blocks can have different number of variables and
when all blocks have same number
of variables <code>list2CubeOfCovDis</code> 
is a more efficient alternative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2CubeOfCovDis(Data, Judges, scale = TRUE, center = TRUE, ev.scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2CubeOfCovDis_+3A_data">Data</code></td>
<td>
<p>a matrix of dimensions
<code class="reqn">I</code> items by <code class="reqn">J</code> quantitative variables
(structured in <code class="reqn">K</code> blocks of <code class="reqn">J_k</code> variables
each). No Default.</p>
</td></tr>
<tr><td><code id="list2CubeOfCovDis_+3A_judges">Judges</code></td>
<td>
<p>a <code class="reqn">J</code> components character 
vector identifiying the
variables corresponding to each block of variables.
No Default.</p>
</td></tr>
<tr><td><code id="list2CubeOfCovDis_+3A_scale">scale</code></td>
<td>
<p>(Default: <code>TRUE</code>), when <code>TRUE</code>
scale to norm 1 each column for each slice.</p>
</td></tr>
<tr><td><code id="list2CubeOfCovDis_+3A_center">center</code></td>
<td>
<p>(Default: <code>TRUE</code>), when <code>TRUE</code>
centers each column.</p>
</td></tr>
<tr><td><code id="list2CubeOfCovDis_+3A_ev.scale">ev.scale</code></td>
<td>
<p>(Default: <code>TRUE</code>), when <code>TRUE</code>
normalizes each slice 
(i.e., each <code class="reqn">I</code> items by <code class="reqn">J</code>  matrix) so that its first 
eigenvalue is equal to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input of  <code>list2CubeOfCovDis</code> is a 
<code class="reqn">I</code> items by <code class="reqn">J</code> quantitative variables
that are organized in <code class="reqn">K</code> blocks (i.e., submatrices)
each comprising <code class="reqn">J_k</code> variables (with sum <code class="reqn">J_k = J</code>).
</p>
<p>By default  <code>list2CubeOfCovDis</code>
centers and normalizes each column for each block
and then normalize each covariance matrix such that
the first eigenvalue of each covariance matrix 
(for a given block) is equal to 1.
</p>
<p>A <code>distatis</code> analysis of the Distance matrices with
the option <code>Distance = TRUE</code> will give the same results
as the <code>distatis</code> analysis of the Covariance matrices with
the option <code>Distance = FALSE</code>.
</p>


<h3>Value</h3>

<p>a list with 1) <code>cubeOfCovariance</code>
a cube of <code class="reqn">K</code>  <code class="reqn">I</code> by <code class="reqn">I</code> covariance matrices;
and 2) codecubeOfDistance
a cube of <code class="reqn">K</code>  <code class="reqn">I</code> by <code class="reqn">I</code> 
(squared) Euclidean distance
matrices.
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>See Also</h3>

<p>list2CubeOfCov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path2file &lt;- system.file("extdata",
                        "BeersFlashProfile.xlsx", 
                        package = 'DistatisR')
# read the data in the excel file with read.df.excel
beerDataFlash  &lt;- read.df.excel(path = path2file,
                               sheet = 'Rankings')$df.data
# Extract the namers of the judges (first 2 characters)
JudgesVars &lt;- colnames(beerDataFlash)
zeJudges &lt;- substr(JudgesVars,1,2)
 # call list2CubeOfCovDis
test.list2 &lt;- list2CubeOfCovDis(Data = beerDataFlash ,
                               Judges =  zeJudges)
</code></pre>

<hr>
<h2 id='MFAnormCP'>MFAnormCP</h2><span id='topic+MFAnormCP'></span>

<h3>Description</h3>

<p>Normalizeq a positive semi-definite matrix matrix product such that its first eigenvalue is equal to one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFAnormCP(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MFAnormCP_+3A_y">Y</code></td>
<td>
<p>The matrix to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- toeplitz(c(1, 0.6))
MFAnormCP(A)

</code></pre>

<hr>
<h2 id='mmds'>Metric (classical) Multidimensional Scaling
(a.k.a Principal Coordinate
Analysis) of a (squared Euclidean) Distance Matrix.</h2><span id='topic+mmds'></span>

<h3>Description</h3>

<p><code>mmds</code>: Perform a Metric Multidimensional Scaling
(MMDS) of an (squared Euclidean) distance matrix 
measured between a set of
objects (with or without masses).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmds(DistanceMatrix, masses = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmds_+3A_distancematrix">DistanceMatrix</code></td>
<td>
<p>A squared (assumed to be Euclidean)
distance matrix</p>
</td></tr>
<tr><td><code id="mmds_+3A_masses">masses</code></td>
<td>
<p>A vector of masses
(i.e., a set of non-negative numbers with a sum of
1) of same dimensionality as the number
of rows of <code>DistanceMatrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mmds</code> gives factor scores that make it possible
to draw a map of the objects
such that the distances between objects
on the map best approximate the
original distances between objects.
</p>


<h3>Value</h3>

<p>Sends back a list 
</p>
<table>
<tr><td><code>LeF</code></td>
<td>
<p>factor scores for the objects.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>the eigenvalues for the factor scores
(i.e., a variance).</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>the percentage of 
explained variance by each dimension.</p>
</td></tr>
<tr><td><code>Contributions</code></td>
<td>
<p>give the proportion of explained
variance by an object
for a dimension.</p>
</td></tr>
</table>


<h3>Method</h3>

<p>MMDS transform the 
squared Euclidean distance matrix
into a (double centered)
covariance-like matrix which is then analyzed
via its eigen-decomposition.  
The
factor scores of each dimension are scaled
such that their variance (i.e.,
the sum of their weighted squared factor scores)
is equal to the eigen-value
of the corresponding dimension.
Note that if the <code>masses</code> vector is
absent, equal masses
(i.e., 1 divided by number of objects) are used.
</p>


<h3>Technicalities</h3>

<p>the distance matrix to be analyzed is supposed to be a
<code class="reqn">squared</code> Euclidean distance matrix.
Note also that a non Euclidean distance matrix
will have negative eigenvalues that will be ignored
by <code>mmds</code> which, therefore, gives the best Euclidean
approximation to this non-Euclidean distance matrix
(note that, non-metric MDS maybe a better 
method in these cases).
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>References</h3>

<p>The procedure and references are detailed in:
Abdi, H. (2007).
Metric multidimensional scaling.
In N.J. Salkind (Ed.): <em>Encyclopedia
of Measurement and Statistics</em>.
Thousand Oaks (CA): Sage. pp. 598&ndash;605.
</p>
<p>(Paper available from <a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GraphDistatisCompromise">GraphDistatisCompromise</a></code> 
<code><a href="#topic+distatis">distatis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# An example of MDS from Abdi (2007)
# Discriminability of Brain States
# Table 1.
# 1. Get the distance matrix
D &lt;- matrix(c(
0.00, 3.47, 1.79, 3.00, 2.67, 2.58, 2.22, 3.08,
3.47, 0.00, 3.39, 2.18, 2.86, 2.69, 2.89, 2.62,
1.79, 3.39, 0.00, 2.18, 2.34, 2.09, 2.31, 2.88,
3.00, 2.18, 2.18, 0.00, 1.73, 1.55, 1.23, 2.07,
2.67, 2.86, 2.34, 1.73, 0.00, 1.44, 1.29, 2.38,
2.58, 2.69, 2.09, 1.55, 1.44, 0.00, 1.19, 2.15,
2.22, 2.89, 2.31, 1.23, 1.29, 1.19, 0.00, 2.07,
3.08, 2.62, 2.88, 2.07, 2.38, 2.15, 2.07, 0.00),
ncol = 8, byrow=TRUE)
rownames(D) &lt;- c('Face','House','Cat','Chair','Shoe','Scissors','Bottle','Scramble')
colnames(D) &lt;- rownames(D)
# 2. Call mmds
BrainRes &lt;- mmds(D)
# Note that compared to Abdi (2007)
# the factor scores of mmds are equal to F / sqrt(nrow(D))
# the eigenvalues of mmds are equal to \Lambda *{1/nrow(D)}
# (ie., the normalization differs but the results are proportional)
# 3. Now a pretty plot with the prettyPlot function from prettyGraphs
prettyGraphs::prettyPlot(BrainRes$FactorScore,
           display_names = TRUE,
           display_points = TRUE,
           contributionCircles = TRUE,
           contributions = BrainRes$Contributions)
# 4. et Voila!
</code></pre>

<hr>
<h2 id='multiculturalSortingSpices'>62 assessors from 5 countries sort 16 spice samples</h2><span id='topic+multiculturalSortingSpices'></span>

<h3>Description</h3>

<p><code>multiculturalSortingSpices</code>: 
62 participants from 5 different countries
(USA, France, India, Spain, and Vietnam) for 16 different spices
(including 6 mixtures of spices).
</p>
<p>The data consist in
a list containing 7 objects
(for all sorting data the number 
at the intersection of a row and a colum
indicates the number of the pile in which the spice was sorted);):
: A data frame containing the
1) <code>sortAll</code>: A data frame containing the
results of the sorting task for
all 62 participants,
2) <code>sortAmerican</code>: A data frame containing the
results of the sorting task for
the 9 American participants,
3) <code>sortFrench</code>: A data frame containing the
results of the sorting task for
the 21 French participants,
4) <code>sortIndian</code>: A data frame containing the
results of the sorting task for
the 15 Indian participants,
5) <code>sortSpanish</code>: A data frame containing the
results of the sorting task for
the 11 Spanish participants,
6) <code>sortVietnamese</code>: A data frame containing the
results of the sorting task for
the 6 Vietnamese participants, and
7) <code>spicesDescription</code> A data frame containing the
description of the Spices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("multiculturalSortingSpices")
</code></pre>


<h3>Format</h3>

<p>A list containing 7 objects
(for all sorting data, the number 
at the intersection of a row and a colum
indicates the number of the pile in which the spice was sorted):
: A data frame containing the
1) <code>sortAll</code>: A data frame containing the
results of the sorting task for
all 62 participants,
2) <code>sortAmerican</code>: A data frame containing the
results of the sorting task for
the 9 American participants,
3) <code>sortFrench</code>: A data frame containing the
results of the sorting task for
the 21 French participants,
4) <code>sortIndian</code>: A data frame containing the
results of the sorting task for
the 15 Indian participants,
5) <code>sortSpanish</code>: A data frame containing the
results of the sorting task for
the 11 Spanish participants,
6) <code>sortVietnamese</code>: A data frame containing the
results of the sorting task for
the 6 Vietnamese participants, and
7) <code>spicesDescription</code> A data frame containing the
description of the Spices.
</p>


<h3>Details</h3>

<p>In the data frames, the spice blends are identifed
wiht acronyms that are expended in the data frame
<code>spicesDescription</code>.
</p>


<h3>Author(s)</h3>

<p>Chollet, S., Valentin, D., &amp; Abdi, H.
</p>


<h3>References</h3>

<p>Part of these data (i.e., the French sample) is described 
and analyzed in 
Chollet, S., Valentin, D., &amp; Abdi, H. (2014). 
Free sorting task. In P.V. Tomasco &amp; G. Ares (Eds), 
<em>Novel Techniques in Sensory Characterization 
and Consumer Profiling</em>. 
Boca Raton: Taylor and Francis. pp 207-227.
</p>

<hr>
<h2 id='NuclearNormedCP'>NuclearNormedCP</h2><span id='topic+NuclearNormedCP'></span>

<h3>Description</h3>

<p>Normalizes a positive 
semi-definite matrix by diving it by its
nuclear norm (i.e., the sum of the square root of
its eigen-values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NuclearNormedCP(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NuclearNormedCP_+3A_y">Y</code></td>
<td>
<p>The matrix to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- toeplitz(c(1, 0.6))
NuclearNormedCP(A)

</code></pre>

<hr>
<h2 id='OrangeJuiceSortingRawData'><code>OrangeJuiceSortingRawData</code>: an example of an excel file
with Sorting data and vocabulary. This excel file can be read by
<code>read.df.excel</code>.</h2><span id='topic+OrangeJuiceSortingRawData'></span>

<h3>Description</h3>

<p><code>OrangeJuiceSorting</code>: an example of an excel file
with sorting data (10 Orange Juices sorted by 44 Assessors)
and an an associated
vocabulary contingency table
(10 Orange Juices by 23 descriptors).
Can be read by
<code>read.df.excel</code>.
</p>


<h3>Details</h3>

<p>In this example of a &quot;sorting task&quot; with vocabulary,
44 assessors sorted 10 orange juices and freely described
each group of juices with a few words.
The data from the sorting task are in the sheet &quot;Sorting&quot;
and the contingency table
(10 Orange Juices by 23 descriptors) is in the sheet
&quot;Vocabulary&quot;.
To fetch this dataset use <code>system.file()</code>
(see example below).
</p>


<h3>FileName</h3>

<p>OrangeJuiceSortingRawData.xlsx
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path2file &lt;- system.file("extdata",
           "OrangeJuiceSortingRawData.xlsx", package = 'DistatisR')
OrangeDataSort &lt;- read.df.excel(path = path2file,
                           sheet = 'Sorting',
                       voc.sheet = 'Vocabulary')
</code></pre>

<hr>
<h2 id='print.beersBlind'>Change the print function for class 'beersBlind'</h2><span id='topic+print.beersBlind'></span>

<h3>Description</h3>

<p>Change the print function for class 'beersBlind'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'beersBlind'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.beersBlind_+3A_x">x</code></td>
<td>
<p>an object of the class 'beersBlind'</p>
</td></tr>
<tr><td><code id="print.beersBlind_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='print.Cmat'>Print C matrix results</h2><span id='topic+print.Cmat'></span>

<h3>Description</h3>

<p>Print C matrix results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cmat'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Cmat_+3A_x">x</code></td>
<td>
<p>a list that contains items to make into the Cmat class.</p>
</td></tr>
<tr><td><code id="print.Cmat_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with results from the analysis. prints to screen
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='print.cubeOfCovDis'>Change the print function for the class <code>cubeOfCovDis</code></h2><span id='topic+print.cubeOfCovDis'></span>

<h3>Description</h3>

<p>Change the print function for the class <code>cubeOfCovDis</code>: 
(output of <code>createCubeOfCovDis</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cubeOfCovDis'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cubeOfCovDis_+3A_x">x</code></td>
<td>
<p>a list objects of the class cubeOfCovDis</p>
</td></tr>
<tr><td><code id="print.cubeOfCovDis_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='print.cubeSort'>Change the print function for cubeSort</h2><span id='topic+print.cubeSort'></span>

<h3>Description</h3>

<p>Change the print function for cubeSort
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cubeSort'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cubeSort_+3A_x">x</code></td>
<td>
<p>an object of the class cubeSort</p>
</td></tr>
<tr><td><code id="print.cubeSort_+3A_...">...</code></td>
<td>
<p>dots to pass to the generic print function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>

<hr>
<h2 id='print.dataAmari'>Change the print function for the data set: 
<code>dataAmari</code></h2><span id='topic+print.dataAmari'></span>

<h3>Description</h3>

<p>Change the print function for the data set: 
<code>dataAmari</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dataAmari'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dataAmari_+3A_x">x</code></td>
<td>
<p>a list: the data set from  amariSorting</p>
</td></tr>
<tr><td><code id="print.dataAmari_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='print.dataSortingSpices'>Change the print function for the data set: 
<code>multiculturalSortingSpices</code></h2><span id='topic+print.dataSortingSpices'></span>

<h3>Description</h3>

<p>Change the print function for the data set: 
<code>multiculturalSortingSpices</code> 
(class <code>dataSortingSpices</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dataSortingSpices'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dataSortingSpices_+3A_x">x</code></td>
<td>
<p>a list: the data set: sortingSpices</p>
</td></tr>
<tr><td><code id="print.dataSortingSpices_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='print.dataSortingWines'>Change the print function for the data set: 
<code>dataSortingWines</code></h2><span id='topic+print.dataSortingWines'></span>

<h3>Description</h3>

<p>Change the print function for the data set: 
<code>dataSortingWines</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dataSortingWines'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dataSortingWines_+3A_x">x</code></td>
<td>
<p>a list: the data set: sortingWines</p>
</td></tr>
<tr><td><code id="print.dataSortingWines_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='print.distatis.data'>Change the print function for objects of 
class <code>distatis.data</code> output of<code>read.df.excel</code></h2><span id='topic+print.distatis.data'></span>

<h3>Description</h3>

<p>Change the print function for bootRatios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'distatis.data'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.distatis.data_+3A_x">x</code></td>
<td>
<p>a list: output of <code>distatis.data</code>;
class <code>distatis.data</code>.</p>
</td></tr>
<tr><td><code id="print.distatis.data_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='print.DistatisR'>Print DistatisR results</h2><span id='topic+print.DistatisR'></span>

<h3>Description</h3>

<p>Print DistatisR results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DistatisR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.DistatisR_+3A_x">x</code></td>
<td>
<p>a list that contains items to make into the DistatisR class.</p>
</td></tr>
<tr><td><code id="print.DistatisR_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with results from the analysis. prints to screen
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='print.F_alpha_k'>Print F_alpha_k results</h2><span id='topic+print.F_alpha_k'></span>

<h3>Description</h3>

<p>Print F_alpha_k results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'F_alpha_k'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.F_alpha_k_+3A_x">x</code></td>
<td>
<p>a list that contains items for
the function <code>computePartial4Groups</code>
output:
<code>F_alpha_k</code> class.</p>
</td></tr>
<tr><td><code id="print.F_alpha_k_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments 
for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='print.F4voc'>Change the print function for objects of the class 
<code>'F4voc'</code> (e.g., output from function 
<code>projectVoc</code>).</h2><span id='topic+print.F4voc'></span>

<h3>Description</h3>

<p>Change the print function for objects of the class 
<code>'F4voc'</code> (e.g., ooutput from function 
<code>projectVoc</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'F4voc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.F4voc_+3A_x">x</code></td>
<td>
<p>a list: the data set: str_BeersProjectiveMapping</p>
</td></tr>
<tr><td><code id="print.F4voc_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='print.Splus'>Print S+ matrix results</h2><span id='topic+print.Splus'></span>

<h3>Description</h3>

<p>Print S+ matrix results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Splus'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Splus_+3A_x">x</code></td>
<td>
<p>a list that contains items to make into the Splus class.</p>
</td></tr>
<tr><td><code id="print.Splus_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with results from the analysis. prints to screen
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='print.str_BeersProjectiveMapping'>Change the print function for the data set: 
<code>str_BeersProjectiveMapping</code></h2><span id='topic+print.str_BeersProjectiveMapping'></span>

<h3>Description</h3>

<p>Change the print function for the data set: 
<code>str_BeersProjectiveMapping</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'str_BeersProjectiveMapping'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.str_BeersProjectiveMapping_+3A_x">x</code></td>
<td>
<p>a list: the data set: str_BeersProjectiveMapping</p>
</td></tr>
<tr><td><code id="print.str_BeersProjectiveMapping_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='print.voc4distatis'>Change the print function for voc4distatis</h2><span id='topic+print.voc4distatis'></span>

<h3>Description</h3>

<p>Change the print function for voc4distatis class
objects
(e.g.,output of Rv).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voc4distatis'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.voc4distatis_+3A_x">x</code></td>
<td>
<p>a list: output of <code>vocabulary2CT</code></p>
</td></tr>
<tr><td><code id="print.voc4distatis_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible; contents are printed to screen
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='projectVoc'>Compute barycentric projections for count-like
description of the items of a <code>distatis</code>-type 
of  analysis.</h2><span id='topic+projectVoc'></span>

<h3>Description</h3>

<p><code>projectVoc</code>
Compute barycentric projection for count-like
description of the items of a <code>distatis</code>-type of  analysis.
The data need to be non-negative and typically represent
the vocabulary (i.e., words) used to describe the items
in a sorting/ranking/projective-mapping task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectVoc(CT.voc, Fi, namesOfFactors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectVoc_+3A_ct.voc">CT.voc</code></td>
<td>
<p>a matrix or data.frame
storing a
<code class="reqn">I</code> items by <code class="reqn">J</code> descriptors
contingency table where the <code class="reqn">i,j</code>-th cell 
gives the number of times
the <code class="reqn">j</code>-th descriptor (in the column) 
was used to describe the <code class="reqn">i</code>-th item
(in the row). <code>CT.voc</code> 
needs to contain only non-negative 
numbers.</p>
</td></tr>
<tr><td><code id="projectVoc_+3A_fi">Fi</code></td>
<td>
<p>a matrix or data.frame
storing the
<code class="reqn">I</code> items by <code class="reqn">L</code> factor scores obtained 
from the compromise of a <code>distatis</code> 
analysis or equivalent.</p>
</td></tr>
<tr><td><code id="projectVoc_+3A_namesoffactors">namesOfFactors</code></td>
<td>
<p>(Default: NULL), if <code>NULL</code>,
<code>projectVoc</code> uses the names of the columns of 
<code>Fi</code> for the names of the projected factors;
if <code>namesOfFactors</code> is one word then this word is used
to name the factors of the projections; 
if <code>namesOfFactors</code>
is a character vector, it is used to name the 
factors of
the projection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>two types of projection are computed: 1)
a plain barycentric (words are positioned at the 
barycenter&ndash;a.k.a. center of mass&ndash;of 
the items it describes) and
2) a correspondence analysis barycentric 
where the variance
of the projected words is equal to the variance
of the items (as for correspondence 
analysis when using the
&quot;symmetric&quot; representation).
</p>


<h3>Value</h3>

<p>a list with 
1) <code>Fvoca.bary</code>: the barycentric projections of
the words,
and 2) <code>Fvoca.normed</code>: the CA normalized 
(i.e., variance of projections equals eigenvalue)
barycentric projections of
the words.
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>Source</h3>

<p>Abdi, H,  &amp; Valentin, D. (2007). 
Papers available from
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>References</h3>

<p>Abdi, H., &amp; Valentin, D., (2007). 
Some new and easy ways to describe, compare, 
and evaluate products and assessors. 
In D., Valentin, D.Z. Nguyen, L. Pelletier (Eds) 
<em>New trends in sensory evaluation 
of food and non-food products</em>.
Ho Chi Minh (Vietnam): 
Vietnam National University &amp; Ho Chi Minh City Publishing House. 
pp. 5-18.
</p>
<p>and
</p>
<p>Lahne, J., Abdi, H., &amp; Heymann, H. (2018). 
Rapid sensory profiles with DISTATIS and 
barycentric text projection: An example with amari,
bitter herbal liqueurs. 
<em>Food Quality and Preference, 66</em>, 36-43.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use the data from the BeersProjectiveMapping dataset
data("BeersProjectiveMapping")
# Create the I*J*K brick of data
zeBrickOfData &lt;- projMap2Cube(
                  BeersProjectiveMapping$ProjectiveMapping, 
                  shape = 'flat',  nVars = 2)
# create the cube of covariance matrices between beers
cubeOfCov &lt;- createCubeOfCovDis(zeBrickOfData$cubeOfData)
# Call distatis
testDistatis &lt;- distatis(cubeOfCov$cubeOfCovariance, Distance = FALSE)
# Project the vocabulary onto the factor space
F4Voc &lt;- projectVoc(BeersProjectiveMapping$CT.vocabulary, 
                    testDistatis$res4Splus$F)
</code></pre>

<hr>
<h2 id='projMap2Cube'>\
reshape a data matrix from projective mapping
into a brick of data for a <code>distatis</code> analysis.</h2><span id='topic+projMap2Cube'></span>

<h3>Description</h3>

<p><code>projMap2Cube</code> 
reshapes a data matrix from projective mapping
into a brick of data for a <code>distatis</code> analysis.
With <code class="reqn">I</code> products, <code class="reqn">J</code> variables, and
<code class="reqn">K</code> blocks (assessors),
the original data can be 1) &quot;flat&quot; 
(e.g., <code class="reqn">I</code> rows as products,
columns as <code class="reqn">K</code> blocks of <code class="reqn">J</code> Variables) 
or 2) &quot;long&quot;
&quot;flat&quot; (e.g., <code class="reqn">K</code> blocks of 
<code class="reqn">I</code> rows as products by assessors,
columns as <code class="reqn">J</code> Variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projMap2Cube(Data, shape = "flat", nVars = 2, nBlocks = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projMap2Cube_+3A_data">Data</code></td>
<td>
<p>a data matrix that can be 
<code class="reqn">I</code> rows by <code class="reqn">J*K</code> columns (when <code>"flat"</code>) or
<code class="reqn">I*K</code> rows by <code class="reqn">J</code> columns when <code>"long"</code>.</p>
</td></tr>
<tr><td><code id="projMap2Cube_+3A_shape">shape</code></td>
<td>
<p>(Default: <code>flat</code> when <code>"flat"</code> the data 
matrix has dimensions <code class="reqn">I</code> rows by <code class="reqn">J*K</code> columns;
when <code>"long"</code> the data  matrix has dimensions
<code class="reqn">I*K</code> rows by <code class="reqn">J</code> columns.</p>
</td></tr>
<tr><td><code id="projMap2Cube_+3A_nvars">nVars</code></td>
<td>
<p>Number of variables (default = 2),
relevant only when <code>shape = "flat"</code>.</p>
</td></tr>
<tr><td><code id="projMap2Cube_+3A_nblocks">nBlocks</code></td>
<td>
<p>(Default = <code>NULL</code>) number
of Blocks (i.e., <code class="reqn">K</code>) of <code class="reqn">I</code> products.
Relevant only when    <code>shape = "long"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the output <code>projMap2Cube</code> (i.e., the brick of data)
is used as input to the function <code>cubeOfCov</code> that will
create the cubeOfDistance (or covariance) that will be used
as input of <code>distatis</code>. 
<code>projMap2Cube</code> guesses the 
names of the products and variables from the
rownames and columns of the data, but this guess
needs to be verified.
</p>


<h3>Value</h3>

<p>An <code class="reqn">I</code> by <code class="reqn">J</code> by <code class="reqn">K</code> array (i.e., a brick)
to be used to create a cube of distance or covariance.
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the data from the BeersProjectiveMapping dataset
data("BeersProjectiveMapping")
# Create the I*J_k*K brick of data
dataBrick &lt;- projMap2Cube(BeersProjectiveMapping$ProjectiveMapping, 
                        shape = 'flat',  nVars = 2)
</code></pre>

<hr>
<h2 id='rdiag'>right (i.e., post) Multiply a matrix by a diagonal matrix</h2><span id='topic+rdiag'></span>

<h3>Description</h3>

<p><code>rdiag</code>: right (i.e., post) Multiply
a matrix by a diagonal matrix (with only
the diagonal elements being given).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdiag(X, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdiag_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">I</code> by <code class="reqn">J</code> matrix.</p>
</td></tr>
<tr><td><code id="rdiag_+3A_y">y</code></td>
<td>
<p>a <code class="reqn">J</code> element
vector (of the diagonal elements of a <code class="reqn">J</code> by <code class="reqn">J</code> matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">I</code> by <code class="reqn">J</code> matrix equal to
<strong>X</strong> 
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ldiag">ldiag</a></code>
</p>

<hr>
<h2 id='read.df.excel'><code>read.df.excel</code> reads <code>distatis</code> formated
ranking or sorting data from an excel file.</h2><span id='topic+read.df.excel'></span>

<h3>Description</h3>

<p><code>read.df.excel</code> reads <code>distatis</code> formated
ranking or sorting data from an excel file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.df.excel(path, sheet, col_names = TRUE, voc.sheet = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.df.excel_+3A_path">path</code></td>
<td>
<p>the name of the <code>.xlsx</code> file (including
the path to the directory if needed, and
the <code>.xlsx</code> extension). No default.</p>
</td></tr>
<tr><td><code id="read.df.excel_+3A_sheet">sheet</code></td>
<td>
<p>the name of the sheet where the
(e.g., Sorting or Ranking) data are stored. No default.</p>
</td></tr>
<tr><td><code id="read.df.excel_+3A_col_names">col_names</code></td>
<td>
<p>(default <code>TRUE</code>)
parameter <code>col.names</code> from
<code>readxl::read_excel</code>:
&quot;<code>TRUE</code> to use the first row as column names,
<code>FALSE</code> to get default names, or a character vector giving
a name for each column.&quot;</p>
</td></tr>
<tr><td><code id="read.df.excel_+3A_voc.sheet">voc.sheet</code></td>
<td>
<p>If not <code>NULL</code>
(default) gives the name of the sheet where an optional
contingency table  (products by names) could be stored.
Needs to have the same row names as the sorting/ranking
data frame (df.data) to be useful (but he program does not check).
</p>
<p>@return 
a list with one data frame  '$df.data' (contains the data) 
when 'voc.sheet = NULL'
or if not: two data frames 
'$df.data' (contains the data) and 
'$df.voc' (contains the vocabulary).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>@details 
The data are read from an excel file in which the rows
are the Products to evaluate and the columns are the Assessors
(e.g., Judges, Participants, Subjects, Evaluators).
Depending upon the type of data, the numbers represent
a partition, a rank, or a score.
These data are used as input of
<code>DistanceFromSort</code> or
<code>DistanceFromRank</code>.
A contingency table for the vocabulary can also be read
in a different sheet. <code>read.df.excel</code> is a (small) shell
on top of <code>readxl::read_excel</code>, note however that
whereas <code>readxl::read_excel</code> returns a <code>tibble</code>,
<code>read.df.excel</code> returns a list with one or two
(depending upon the options) <em>dataframe(s)</em>.
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>

<hr>
<h2 id='rv'>Function to compute the RV coefficient between to conformable matrices</h2><span id='topic+rv'></span>

<h3>Description</h3>

<p>Function to compute the RV coefficient between to conformable matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rv(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rv_+3A_a">A</code></td>
<td>
<p>a matrix,</p>
</td></tr>
<tr><td><code id="rv_+3A_b">B</code></td>
<td>
<p>a second matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the RV coefficient between A and B.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- toeplitz(2:1)
B &lt;- diag(2)
rv(A, B)
</code></pre>

<hr>
<h2 id='scale1'>A variation over the base <code>R</code> scale function 
that avoids the &quot;divide by 0 = NA&quot;  problem.</h2><span id='topic+scale1'></span>

<h3>Description</h3>

<p><code>scale1</code>: A variation over the base 
<code>R</code> <code>scale</code> function.
The function <code>scale1</code>: 
centers (if needed) and scales a vector
to norm 1; if the vector contains values all equal to a
constant, <code>scale1</code> sets all values to 0
(in lieu of NA as <code>scale</code> does). 
Usefull when pre-processing tables
for PCA-like type of analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale1(x, scale = TRUE, center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale1_+3A_x">x</code></td>
<td>
<p>a vector to be scaled</p>
</td></tr>
<tr><td><code id="scale1_+3A_scale">scale</code></td>
<td>
<p>(default = <code>TRUE</code>), when <code>TRUE</code>
scale the vector to norm 1,
otherwise do nothing.</p>
</td></tr>
<tr><td><code id="scale1_+3A_center">center</code></td>
<td>
<p>(default = <code>TRUE</code>), when <code>TRUE</code>
center the vectors (i.e., substract the mean from all numbers),
otherwise do nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a centered (if required) and norm-1 
(if required) normalized
vector.
</p>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>


<h3>Examples</h3>

<pre><code class='language-R'> toto   &lt;- runif(10)     # 10 random numbers between 0 and 1
 tutu   &lt;- scale1(toto)  # toto centered and normalized
 toto0  &lt;- rep(1,10)     # 10 numbers all equal to 1
 tutu0  &lt;- scale1(toto0) # scaled to 0 # Compare with
 tutuNA &lt;- scale(toto0)  # all numbers set to NA

</code></pre>

<hr>
<h2 id='SortingBeer'>Ten Assessors sorted eight beers for <code>distatis</code> analysis</h2><span id='topic+SortingBeer'></span><span id='topic+Sort'></span>

<h3>Description</h3>

<p>Provide the data.frame <code>Sort</code>: 
Data set to be used to illustrated the
use of the package <code>DistatisR</code>. 
Ten assessors sorted eight beers.
These data come from the Abdi et al.' (2007) paper
in <em>Food Quality and
Preference</em>. 
Each column represents the results 
of the sorting task for one
assessor.  
Beers with the same number were sorted together.
</p>


<h3>Format</h3>

<p>a data frame file containing 10 columns, 8 rows plus the names of
the rows and the columns.
</p>


<h3>Source</h3>

<p>Abdi et al. (2007),
see  <a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>.
</p>


<h3>References</h3>

<p>Abdi, H., Valentin, D., Chollet, S., &amp; Chrea, C. (2007).
Analyzing assessors and products in sorting tasks: DISTATIS, theory and
applications.  <em>Food Quality and Preference</em>, <b>18</b>, 627&ndash;640.
</p>

<hr>
<h2 id='SortingSpice'>21 French assessors sorted 16 blends of Spice for <code>distatis</code> analysis</h2><span id='topic+SortingSpice'></span><span id='topic+SortSpice'></span>

<h3>Description</h3>

<p>Provide the data.frame SortSpice: Data set to illustrate the use of the
package <code>DistatisR</code>. 
Assessors are sorting spices.
Each column represents the results of the sorting task for one assessor.
Spices  with the same number were sorted together.
</p>


<h3>Format</h3>

<p>a data frame file containing 21 columns, 16 rows plus the names of
the rows and the columns.
</p>


<h3>Source</h3>

<p>Chollet et al. (2014). 
Paper available from  
<a href="https://personal.utdallas.edu/~herve/">https://personal.utdallas.edu/~herve/</a>
</p>


<h3>References</h3>

<p>Chollet, S., Valentin, D., &amp; Abdi, H. (2014).  The
free sorting task. In. P.V. Tomasco &amp; G. Ares (Eds), <em>Novel Techniques
in Sensory Characterization and Consumer Profiling</em>.  Boca Raton: Taylor and
Francis.
</p>

<hr>
<h2 id='sortingWines'>Novices and wines experts sort red, rosé, and white wines</h2><span id='topic+sortingWines'></span>

<h3>Description</h3>

<p><code>sortingWines</code>: 26 novices participants
and 19 wine experts sort (by smell alone, 
without visual information) 18 wines (6 red, 6 rosé, and 6 whites)
into three categories. The experts also performed a free
sorting task on the wines (i.e. with as many groups as the wished).
</p>
<p>The data consist in
a list containing 4 objects:
1) <code>freeSortExperts</code>:
a data frame with the 18 wines by 19 experts free sorting data
(the number at the intersection of a row and a colum
indicates the number of the pile in which the wine was sorted);
2) <code>ternarySortExperts</code>:
a data frame with the 18 wines by 19 experts ternary
(i.e., in three piles) sorting data
(the number at the intersection of a row and a colum
indicates the number of the pile in which the wine was sorted);
3) <code>$ternarySortNovices</code>:
a data frame with the 18 wines by 19 novices ternary
(i.e., in three piles) sorting data
(the number at the intersection of a row and a colum
indicates the number of the pile in which the wine was sorted);
and 4)
<code>vinesDescription</code> a data frame
storing the description of the 18 wines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("sortingWines")
</code></pre>


<h3>Format</h3>

<p>a list containing 4 objects:
1) <code>freeSortExperts</code>:
a data frame with the 18 wines by 19 experts free sorting data
(the number at the intersection of a row and a colum
indicates the number of the pile in which the wine was sorted);
2) <code>ternarySortExperts</code>:
a data frame with the 18 wines by 19 experts ternary
(i.e., in three piles) sorting data
(the number at the intersection of a row and a colum
indicates the number of the pile in which the wine was sorted);
3) <code>$ternarySortNovices</code>:
a data frame with the 18 wines by 19 nivices ternary
(i.e., in three piles) sorting data
(the number at the intersection of a row and a colum
indicates the number of the pile in which the wine was sorted);
and 4)
<code>vinesDescription</code> a data frame
storing the description of the 18 wines.
</p>


<h3>Details</h3>

<p>The wines were served in dark glasses and the sorting task
was performed with red light (this way 
all wines look black). In the experiment, 
the wines were labeled with three-digit codes, for more details 
see Ballester <em>et al.</em> (2009).
Only the experts performed the free sorting task.
</p>
<p>In the data sets, the wines are identified with shortened
names, the whole names can be found in the data frame.
All the wines were from the 2005 vintage 
(see Ballester <em>et al.</em>, 2009 for details)
</p>
<p>Compared to the original data, some missing data were added
to the set after imputation of the missing data 
(a total of 4 entries). The current data include 
only 19 experts out the original 27 experts.
<code>vinesDescription</code>.
</p>


<h3>Author(s)</h3>

<p>Ballester, J., Abdi, H., Langlois, J., 
Peyron, D., &amp; Valentin, D.
</p>


<h3>References</h3>

<p>For more details see:
</p>
<p>Ballester, J., Abdi, H., Langlois, J., Peyron, D., &amp; Valentin, D.
(2009). The odor of colors: Can wine experts and novices
distinguish the odors of white, red, and rosé wines?
<em>Chemosensory Perception, 2</em>, 203-213.
</p>

<hr>
<h2 id='SUMPCAnormCP'>SUMPCAnormCP</h2><span id='topic+SUMPCAnormCP'></span>

<h3>Description</h3>

<p>Normalizes a positive semi-definite matrix (i.e., total intertia=1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SUMPCAnormCP(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SUMPCAnormCP_+3A_y">Y</code></td>
<td>
<p>Matrix to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- toeplitz(c(1, 0.6))
SUMPCAnormCP(A)

</code></pre>

<hr>
<h2 id='supplementalProjection4distatis'>Supplementary element(s) projection in DISTATIS</h2><span id='topic+supplementalProjection4distatis'></span>

<h3>Description</h3>

<p><code>supplementalProjection4distatis</code>:
Computes for <code>distatis</code> 
the projection as supplementary element(s)
(a.k.a. &quot;out of sample&quot;)
of a set of squared matrices.
The matrices to be projected need to be
of the same type (e.g., distance, correlation) as the matrices 
used inn the original call to <code>distatis</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supplementalProjection4distatis(res.distatis, elsupp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supplementalProjection4distatis_+3A_res.distatis">res.distatis</code></td>
<td>
<p>the results of the function <code>distatis</code></p>
</td></tr>
<tr><td><code id="supplementalProjection4distatis_+3A_elsupp">elsupp</code></td>
<td>
<p>the supplementary elements (i.e., a 3D array).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the coordinates of the supplementary 
and active elements in the RV space.
*** HA comment: Maybe we also want to send the square cosines 
to give the quality of representation.
</p>


<h3>Author(s)</h3>

<p>Vincent Guillemot
</p>

<hr>
<h2 id='vocabulary2CT'>Transforms a data.frame of products by vocabulary 
of assessors into
a  products by words (from vocabulary) contingency table.</h2><span id='topic+vocabulary2CT'></span>

<h3>Description</h3>

<p><code>vocabulary2CT</code>
Transforms a data.frame of products by vocabulary 
of assessors into 1)
a cube of 0/1 contingency tables (one per assessor); and 2)
a  products by words (from vocabulary) contingency table.
In this contingency table, the number at the intersection
of a row (product) and a column (word) is the number
of assessors who used this word to describe that product.
</p>
<p>@details the cube of 0/1 contingency tables
(i.e., <code>cubeOfVocabulary</code>   can also be
analyzed with the package <code>PTCA4CATA</code> as a
pseudo <em>Check All That Apply</em>  (CATA) data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vocabulary2CT(df.voc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vocabulary2CT_+3A_df.voc">df.voc</code></td>
<td>
<p>a data frame with the vocabulary. In this 
data.frame 
each element 
stores
the words used by one assessor to describe a product 
(words are separated with spaces);</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 1) <code>cubeOfVocabulary</code>:
a 0/1 array of dimension
products by words (from the vocabulary) by assessors
where each &quot;products by vocabulary&quot; slice gives the vocabulary
chosen by the assessor to describe the products; and
2) 
<code>CT.vocabulary</code> a matrix storing the 
products by words contingency table.
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>See Also</h3>

<p><code><a href="tidytext.html#topic+unnest_tokens">unnest_tokens</a></code>
<code><a href="dplyr.html#topic+count">count</a></code>
<code><a href="#topic+BeersProjectiveMapping">BeersProjectiveMapping</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get the BeersProjectiveMapping example
data("BeersProjectiveMapping")
aContingenyTable &lt;- vocabulary2CT(BeersProjectiveMapping$Vocabulary)

</code></pre>

<hr>
<h2 id='WinesRankingRawData'><code>WinesRankingRawData</code>: an example of an excel file
with (simulated) ranking data. Can be read with the function
<code>read.df.excel()</code>.</h2><span id='topic+WinesRankingRawData'></span>

<h3>Description</h3>

<p><code>WinesRankingRawData</code>: an example of an excel file
with (simulated) ranking data (6 wines ranked by 80 Assessors).
Can be read by
<code>read.df.excel</code>.
</p>


<h3>Details</h3>

<p>In this example of a &quot;ranking task,&quot; 
80 (simulated or fictitious) 
assessors ranked 6 red wines from Burgundy (France). 
The assessor first chooses
the most relevant dimension for these wines and then
positions the wines on a scale from 1 to 9 for this dimension.
The names of the assessors is composed of 4 characters
of the general composition w/ma/f01 : 80.
The assessors were 40 men and 40 women (first character w/n)
and 40 American or 40 French (second character a/f).
The red wines that were tasted are Irancy, Saint-Brie,
Beaune, Nuits (Cote de Nuits), Beaujolais, and Beaujolais-Nouveau.
Irancy &amp; Saint-Brie are near the cities of Auxerre and Chablis,
Beaune &amp; Cote de Nuits are from central Burgundy, and
Beaujolais and Beaujolais Nouveau are from the south of Burgundy;
Beaujolais Nouveau is a young wine (a primeur) 
released in November of its year, 
after only a few weeks of fermentation.
</p>


<h3>Availability</h3>

<p>To fetch this dataset use <code>system.file()</code>
(see example below).
</p>


<h3>FileName</h3>

<p>WinesRankingRawData.xlsx
</p>


<h3>Author(s)</h3>

<p>Herve Abdi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path2file &lt;- system.file("extdata",
           "WinesRankingRawData.xlsx", package = 'DistatisR')
ranking6Wines &lt;- read.df.excel(path = path2file, sheet = 'Ranking')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
