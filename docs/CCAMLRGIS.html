<!DOCTYPE html><html><head><title>Help for package CCAMLRGIS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CCAMLRGIS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CCAMLRGIS-package'><p>Loads and creates spatial data, including layers and tools that are relevant to CCAMLR activities.</p>
All operations use the Lambert azimuthal equal-area projection (via EPSG:6932).</a></li>
<li><a href='#add_col'><p>Add colors</p></a></li>
<li><a href='#add_Cscale'><p>Add a color scale</p></a></li>
<li><a href='#add_labels'><p>Add labels</p></a></li>
<li><a href='#add_Legend'><p>Add Legend</p></a></li>
<li><a href='#add_PieLegend'><p>Add a legend to Pies</p></a></li>
<li><a href='#add_RefGrid'><p>Add a Reference grid</p></a></li>
<li><a href='#assign_areas'><p>Assign point locations to polygons</p></a></li>
<li><a href='#CCAMLRp'><p>CCAMLRGIS Projection</p></a></li>
<li><a href='#Clip2Coast'><p>Clip Polygons to a simplified Antarctic coastline</p></a></li>
<li><a href='#Coast'><p>Simplified and subsettable coastline</p></a></li>
<li><a href='#create_Arrow'><p>Create Arrow</p></a></li>
<li><a href='#create_Hashes'><p>Create Hashes</p></a></li>
<li><a href='#create_Lines'><p>Create Lines</p></a></li>
<li><a href='#create_Pies'><p>Create Pies</p></a></li>
<li><a href='#create_Points'><p>Create Points</p></a></li>
<li><a href='#create_PolyGrids'><p>Create a Polygon Grid</p></a></li>
<li><a href='#create_Polys'><p>Create Polygons</p></a></li>
<li><a href='#create_Stations'><p>Create Stations</p></a></li>
<li><a href='#Depth_cols'><p>Bathymetry colors</p></a></li>
<li><a href='#Depth_cols2'><p>Bathymetry colors with Fishable Depth range</p></a></li>
<li><a href='#Depth_cuts'><p>Bathymetry depth classes</p></a></li>
<li><a href='#Depth_cuts2'><p>Bathymetry depth classes with Fishable Depth range</p></a></li>
<li><a href='#get_C_intersection'><p>Get Cartesian coordinates of lines intersection in Euclidean space</p></a></li>
<li><a href='#get_depths'><p>Get depths of locations from a bathymetry raster</p></a></li>
<li><a href='#get_iso_polys'><p>Generate contour polygons from raster</p></a></li>
<li><a href='#GridData'><p>Example dataset for create_PolyGrids</p></a></li>
<li><a href='#Labels'><p>Polygon labels</p></a></li>
<li><a href='#LineData'><p>Example dataset for create_Lines</p></a></li>
<li><a href='#load_ASDs'><p>Load CCAMLR statistical Areas, Subareas and Divisions</p></a></li>
<li><a href='#load_Bathy'><p>Load Bathymetry data</p></a></li>
<li><a href='#load_Coastline'><p>Load the full CCAMLR Coastline</p></a></li>
<li><a href='#load_EEZs'><p>Load Exclusive Economic Zones</p></a></li>
<li><a href='#load_MAs'><p>Load CCAMLR Management Areas</p></a></li>
<li><a href='#load_MPAs'><p>Load CCAMLR Marine Protected Areas</p></a></li>
<li><a href='#load_RBs'><p>Load CCAMLR Research Blocks</p></a></li>
<li><a href='#load_SSMUs'><p>Load CCAMLR Small Scale Management Units</p></a></li>
<li><a href='#load_SSRUs'><p>Load CCAMLR Small Scale Research Units</p></a></li>
<li><a href='#PieData'><p>Example dataset for create_Pies</p></a></li>
<li><a href='#PieData2'><p>Example dataset for create_Pies</p></a></li>
<li><a href='#PointData'><p>Example dataset for create_Points</p></a></li>
<li><a href='#PolyData'><p>Example dataset for create_Polys</p></a></li>
<li><a href='#project_data'><p>Project user-supplied locations</p></a></li>
<li><a href='#Rotate_obj'><p>Rotate object</p></a></li>
<li><a href='#seabed_area'><p>Calculate planimetric seabed area</p></a></li>
<li><a href='#SmallBathy'><p>Small bathymetry dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Antarctic Spatial Data Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>4.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Loads and creates spatial data, including layers and tools that are relevant
    to the activities of the Commission for the Conservation of Antarctic Marine Living 
    Resources. Provides two categories of functions: load functions and create functions.
    Load functions are used to import existing spatial layers from the online CCAMLR GIS
    such as the ASD boundaries. Create functions are used to create layers from user data
    such as polygons and grids.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), sf</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ccamlr/CCAMLRGIS#ccamlrgis-r-package">https://github.com/ccamlr/CCAMLRGIS#ccamlrgis-r-package</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, terra, graphics, grDevices, magrittr, stars, bezier,
lwgeom</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-28 01:03:44 UTC; stephane</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephane Thanassekos [aut, cre],
  Keith Reid [aut],
  Lucy Robinson [aut],
  Michael D. Sumner [ctb],
  Roger Bivand [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephane Thanassekos &lt;stephane.thanassekos@ccamlr.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-28 02:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='CCAMLRGIS-package'>Loads and creates spatial data, including layers and tools that are relevant to CCAMLR activities.
All operations use the Lambert azimuthal equal-area projection (via EPSG:6932).</h2><span id='topic+CCAMLRGIS'></span><span id='topic+CCAMLRGIS-package'></span>

<h3>Description</h3>

<p>This package provides two broad categories of functions: load functions and create functions.
</p>


<h3>Load functions</h3>

<p>Load functions are used to import CCAMLR geo-referenced layers and include:
</p>

<ul>
<li> <p><a href="#topic+load_ASDs">load_ASDs</a>
</p>
</li>
<li> <p><a href="#topic+load_SSRUs">load_SSRUs</a>
</p>
</li>
<li> <p><a href="#topic+load_RBs">load_RBs</a>
</p>
</li>
<li> <p><a href="#topic+load_SSMUs">load_SSMUs</a>
</p>
</li>
<li> <p><a href="#topic+load_MAs">load_MAs</a>
</p>
</li>
<li> <p><a href="#topic+load_Coastline">load_Coastline</a>
</p>
</li>
<li> <p><a href="#topic+load_MPAs">load_MPAs</a>
</p>
</li>
<li> <p><a href="#topic+load_EEZs">load_EEZs</a>
</p>
</li>
<li> <p><a href="#topic+load_Bathy">load_Bathy</a>
</p>
</li></ul>



<h3>Create functions</h3>

<p>Create functions are used to create geo-referenced layers from user-generated data and include:
</p>

<ul>
<li> <p><a href="#topic+create_Points">create_Points</a>
</p>
</li>
<li> <p><a href="#topic+create_Lines">create_Lines</a>
</p>
</li>
<li> <p><a href="#topic+create_Polys">create_Polys</a>
</p>
</li>
<li> <p><a href="#topic+create_PolyGrids">create_PolyGrids</a>
</p>
</li>
<li> <p><a href="#topic+create_Stations">create_Stations</a>
</p>
</li>
<li> <p><a href="#topic+create_Pies">create_Pies</a>
</p>
</li>
<li> <p><a href="#topic+create_Arrow">create_Arrow</a>
</p>
</li>
<li> <p><a href="#topic+create_Hashes">create_Hashes</a>
</p>
</li></ul>



<h3>Vignette</h3>

<p>To learn more about CCAMLRGIS, start with the GitHub ReadMe (see <a href="https://github.com/ccamlr/CCAMLRGIS#ccamlrgis-r-package">https://github.com/ccamlr/CCAMLRGIS#ccamlrgis-r-package</a>).
Some basemaps are given here <a href="https://github.com/ccamlr/CCAMLRGIS/blob/master/Basemaps/Basemaps.md">https://github.com/ccamlr/CCAMLRGIS/blob/master/Basemaps/Basemaps.md</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stephane Thanassekos <a href="mailto:stephane.thanassekos@ccamlr.org">stephane.thanassekos@ccamlr.org</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Keith Reid
</p>
</li>
<li><p> Lucy Robinson
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Michael D. Sumner [contributor]
</p>
</li>
<li><p> Roger Bivand [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>The CCAMLRGIS package relies on several other package which users may want to familiarize themselves with,
namely sf (<a href="https://CRAN.R-project.org/package=sf">https://CRAN.R-project.org/package=sf</a>) and 
terra (<a href="https://CRAN.R-project.org/package=terra">https://CRAN.R-project.org/package=terra</a>).
</p>

<hr>
<h2 id='add_col'>Add colors</h2><span id='topic+add_col'></span>

<h3>Description</h3>

<p>Given an input variable, generates either a continuous color gradient or color classes.
To be used in conjunction with <code><a href="#topic+add_Cscale">add_Cscale</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_col(var, cuts = 100, cols = c("green", "yellow", "red"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_col_+3A_var">var</code></td>
<td>
<p>numeric vector of the variable to be colorized. Either all values (in which case all
values will be assigned to a color) or only two values (in which case these are considered to be
the range of values).</p>
</td></tr>
<tr><td><code id="add_col_+3A_cuts">cuts</code></td>
<td>
<p>numeric, controls color classes. Either one value (in which case <code>n=cuts</code> equally
spaced color classes are generated) or a vector (in which case irregular color classes are
generated e.g.: <code>c(-10,0,100,2000)</code>).</p>
</td></tr>
<tr><td><code id="add_col_+3A_cols">cols</code></td>
<td>
<p>character vector of colors (see R standard color names <a href="http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf">here</a>).
<code>cols</code> are interpolated along <code>cuts</code>. Color codes as those generated,
for example, by <code><a href="grDevices.html#topic+rgb">rgb</a></code> may also be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the colors for the variable <code>var</code> (given as <code>$varcol</code> in the output) as
well as the single <code>cols</code> and <code>cuts</code>, to be used as inputs in <code><a href="#topic+add_Cscale">add_Cscale</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_Cscale">add_Cscale</a></code>, <code><a href="#topic+create_PolyGrids">create_PolyGrids</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>,
<a href="http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf">R colors</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#52-adding-colors-to-data

MyPoints=create_Points(PointData)
MyCols=add_col(MyPoints$Nfishes)
plot(st_geometry(MyPoints),pch=21,bg=MyCols$varcol,cex=2)


</code></pre>

<hr>
<h2 id='add_Cscale'>Add a color scale</h2><span id='topic+add_Cscale'></span>

<h3>Description</h3>

<p>Adds a color scale to plots. Default behavior set for bathymetry. May also be used to 
place a <code><a href="graphics.html#topic+legend">legend</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_Cscale(
  pos = "1/1",
  title = "Depth (m)",
  width = 18,
  height = 70,
  cuts = Depth_cuts,
  cols = Depth_cols,
  minVal = NA,
  maxVal = NA,
  fontsize = 1,
  offset = 100,
  lwd = 1,
  Titlefontsize = 1.2 * fontsize,
  TitleVAdj = 0,
  BoxAdj = c(0, 0, 0, 0),
  BoxCol = "black",
  BoxBG = "white",
  Clwd = 0,
  Ccol = "black",
  Cwdth = 1,
  TckL = 1,
  Tcklwd = 1,
  Tdist = 1,
  mode = "Cscale"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_Cscale_+3A_pos">pos</code></td>
<td>
<p>character, fraction indicating the vertical position of the color scale (which, by default, is on the 
right side of plots). if <code>pos="1/1"</code>, the color scale will be centered. 
if <code>pos="1/2"</code>, the color scale will be centered on the top half of the plotting region.
if <code>pos="2/2"</code>, the color scale will be centered on the bottom half of the plotting region.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_title">title</code></td>
<td>
<p>character, title of the color scale.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_width">width</code></td>
<td>
<p>numeric, width of the color scale box, expressed in % of the width of the plotting region.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_height">height</code></td>
<td>
<p>numeric, height of the color scale box, expressed in % of the height of the plotting region.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_cuts">cuts</code></td>
<td>
<p>numeric, vector of color classes. May be generated via <code><a href="#topic+add_col">add_col</a></code>.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_cols">cols</code></td>
<td>
<p>character, vector of color names. May be generated via <code><a href="#topic+add_col">add_col</a></code>.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_minval">minVal</code></td>
<td>
<p>numeric, if desired, the color scale may be generated starting from the value <code>minVal</code>. See examples.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_maxval">maxVal</code></td>
<td>
<p>numeric, if desired, the color scale may be generated up to the value <code>maxVal</code>. See examples.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_fontsize">fontsize</code></td>
<td>
<p>numeric, size of the text in the color scale.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_offset">offset</code></td>
<td>
<p>numeric, controls the horizontal position of the color scale.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_lwd">lwd</code></td>
<td>
<p>numeric, thickness of lines.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_titlefontsize">Titlefontsize</code></td>
<td>
<p>numeric, size of the title text.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_titlevadj">TitleVAdj</code></td>
<td>
<p>numeric, vertical adjustment of the title.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_boxadj">BoxAdj</code></td>
<td>
<p>numeric vector of 4 values to adjust the sides of the box, given as <code>c(bottom,left,top,right)</code>.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_boxcol">BoxCol</code></td>
<td>
<p>Color of the legend box frame.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_boxbg">BoxBG</code></td>
<td>
<p>Color of the legend box background.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_clwd">Clwd</code></td>
<td>
<p>numeric, thickness of lines of cells.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_ccol">Ccol</code></td>
<td>
<p>character, color of lines of cells, set to NA for no border.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_cwdth">Cwdth</code></td>
<td>
<p>numeric, positive factor to adjust the width of cells.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_tckl">TckL</code></td>
<td>
<p>numeric, positive factor to adjust the length of tick lines.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_tcklwd">Tcklwd</code></td>
<td>
<p>numeric, thickness of tick lines.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_tdist">Tdist</code></td>
<td>
<p>numeric, horizontal adjustment of labels text.</p>
</td></tr>
<tr><td><code id="add_Cscale_+3A_mode">mode</code></td>
<td>
<p>character, if 'Cscale', the default, the function builds a color scale. if 'Legend', the function
gives you the location of a <code><a href="graphics.html#topic+legend">legend</a></code>, arguments <code>pos</code>, <code>offset</code> and <code>height</code>
may be used for adjustments. See examples.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+load_Bathy">load_Bathy</a></code>, <code><a href="#topic+SmallBathy">SmallBathy</a></code>, <code><a href="#topic+Depth_cuts">Depth_cuts</a></code>, <code><a href="#topic+Depth_cols">Depth_cols</a></code>, 
<code><a href="#topic+Depth_cuts2">Depth_cuts2</a></code>, <code><a href="#topic+Depth_cols2">Depth_cols2</a></code>, <code><a href="#topic+add_col">add_col</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>,
<a href="http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf">R colors</a>, <code><a href="graphics.html#topic+legend">legend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#5-adding-colors-legends-and-labels

library(terra)

#Example 1: Adding two color scales

plot(SmallBathy(),breaks=Depth_cuts,col=Depth_cols,legend=FALSE,axes=FALSE,box=FALSE)
add_Cscale(pos='1/2',height=45,maxVal=0,minVal=-4000,fontsize=0.8)
#Some gridded data
MyGrid=create_PolyGrids(GridData,dlon=2,dlat=1)
Gridcol=add_col(MyGrid$Catch_sum,cuts=10)
plot(st_geometry(MyGrid),col=Gridcol$varcol,add=TRUE)
#Add color scale using cuts and cols generated by add_col, note the use of 'round'
add_Cscale(pos='2/2',height=45,title='Catch (t)',
           cuts=round(Gridcol$cuts,1),cols=Gridcol$cols,fontsize=0.8)

#Example 2: Adding a color scale and a legend

#Create some point data
MyPoints=create_Points(PointData)

#Crop the bathymetry to match the extent of MyPoints 

BathyCr=crop(SmallBathy(),extend(ext(MyPoints),100000))
plot(BathyCr,breaks=Depth_cuts,col=Depth_cols,legend=FALSE,axes=FALSE,mar=c(0,0,0,7))
add_Cscale(pos='1/2',height=45,maxVal=0,minVal=-4000,fontsize=0.8)

#Plot points with different symbols and colors (see ?points)
Psymbols=c(21,22,23,24)
Pcolors=c('red','green','blue','yellow')
plot(st_geometry(MyPoints[MyPoints$name=='one',]),pch=Psymbols[1],bg=Pcolors[1],add=TRUE)
plot(st_geometry(MyPoints[MyPoints$name=='two',]),pch=Psymbols[2],bg=Pcolors[2],add=TRUE)
plot(st_geometry(MyPoints[MyPoints$name=='three',]),pch=Psymbols[3],bg=Pcolors[3],add=TRUE)
plot(st_geometry(MyPoints[MyPoints$name=='four',]),pch=Psymbols[4],bg=Pcolors[4],add=TRUE)

#Add legend with position determined by add_Cscale
Loc=add_Cscale(pos='2/2',height=45,mode='Legend')
legend(Loc,legend=c('one','two','three','four'),title='Vessel',pch=Psymbols,
pt.bg=Pcolors,xpd=TRUE)

</code></pre>

<hr>
<h2 id='add_labels'>Add labels</h2><span id='topic+add_labels'></span>

<h3>Description</h3>

<p>Adds labels to plots. Three modes are available:
In <code>'auto'</code> mode, labels are placed at the centres of polygon parts of spatial objects
loaded via the <code>load_</code> functions. Internally used in conjunction with <code><a href="#topic+Labels">Labels</a></code>.
In <code>'manual'</code> mode, users may click on their plot to position labels. An editable label table is generated
to allow fine-tuning of labels appearance, and may be saved for external use. To edit the label table,
double-click inside one of its cells, edit the value, then close the table.
In <code>'input'</code> mode, a label table that was generated in <code>'manual'</code> mode is re-used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_labels(
  mode = NULL,
  layer = NULL,
  fontsize = 1,
  fonttype = 1,
  angle = 0,
  col = "black",
  LabelTable = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_labels_+3A_mode">mode</code></td>
<td>
<p>character, either <code>'auto'</code>, <code>'manual'</code> or <code>'input'</code>. See Description above.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_layer">layer</code></td>
<td>
<p>character, in <code>'auto'</code> mode, single or vector of characters, may only be one, some or all of: 
<code>c("ASDs","SSRUs","RBs","SSMUs","MAs","MPAs","EEZs")</code>.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_fontsize">fontsize</code></td>
<td>
<p>numeric, in <code>'auto'</code> mode, size of the text.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_fonttype">fonttype</code></td>
<td>
<p>numeric, in <code>'auto'</code> mode, type of the text (1 to 4), where 1 corresponds to plain text, 
2 to bold face, 3 to italic and 4 to bold italic.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_angle">angle</code></td>
<td>
<p>numeric, in <code>'auto'</code> mode, rotation of the text in degrees.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_col">col</code></td>
<td>
<p>character, in <code>'auto'</code> mode, color of the text.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_labeltable">LabelTable</code></td>
<td>
<p>in <code>'input'</code> mode, name of the label table that was generated in <code>'manual'</code> mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds labels to plot. To save a label table generated in <code>'manual'</code> mode, use:
<code>MyLabelTable=add_labels(mode='auto')</code>. 
To re-use that label table, use: 
<code>add_labels(mode='input',LabelTable=MyLabelTable)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Labels">Labels</a></code>, <code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_SSRUs">load_SSRUs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_MAs">load_MAs</a></code>, <code><a href="#topic+load_EEZs">load_EEZs</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>,
<a href="http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf">R colors</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Example 1: 'auto' mode
#label ASDs in bold and red
ASDs=load_ASDs()
plot(st_geometry(ASDs))
add_labels(mode='auto',layer='ASDs',fontsize=1,fonttype=2,col='red')
#add EEZs and their labels in large, green and vertical text
EEZs=load_EEZs()
plot(st_geometry(EEZs),add=TRUE,border='green')
add_labels(mode='auto',layer='EEZs',fontsize=2,col='green',angle=90)


#Example 2: 'manual' mode (you will have to do it yourself)
#Examples 2 and 3 below are commented (remove the # to test)
#library(terra)
#plot(SmallBathy())
#ASDs=load_ASDs()
#plot(st_geometry(ASDs),add=TRUE)
#MyLabels=add_labels(mode='manual')


#Example 3: Re-use the label table generated in Example 2
#plot(SmallBathy())
#plot(st_geometry(ASDs),add=TRUE)
#add_labels(mode='input',LabelTable=MyLabels)





</code></pre>

<hr>
<h2 id='add_Legend'>Add Legend</h2><span id='topic+add_Legend'></span>

<h3>Description</h3>

<p>Add a legend to you map. Give the bounding box of your plot and lists of parameters as inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_Legend(bb, LegOpt, Items)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_Legend_+3A_bb">bb</code></td>
<td>
<p>bounding box of your plot area. for example, 
<code>bb=st_bbox(SmallBathy())</code> or <code>bb=st_bbox(MyPolys)</code>.</p>
</td></tr>
<tr><td><code id="add_Legend_+3A_legopt">LegOpt</code></td>
<td>
<p>list of general legend options. for example:
</p>
<p><code>LegOpt=list(Title="Speed",Subtitle="(km/h)")</code>.</p>
</td></tr>
<tr><td><code id="add_Legend_+3A_items">Items</code></td>
<td>
<p>list, or list of lists containing options for each item to be displayed in the legend. for example:
</p>
<p><code>item1=list(Text="one",Shape="rectangle")</code>
</p>
<p><code>item2=list(Text="two",Shape="circle")</code>
</p>
<p><code>Items=list(item1,item2)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Legend added to current plot.
</p>


<h3>LegOpt options</h3>


<ul>
<li><p> Title: character, title of the legend, set to NULL for no title.
</p>
</li>
<li><p> Subtitle: character, subtitle of the legend, set to NULL for no subtitle.
</p>
</li>
<li><p> Pos: character, general position of the legend. One of &quot;bottomright&quot; (default),
&quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; or &quot;center&quot;.
</p>
</li>
<li><p> BoxW: numeric, legend box width (see figure below).
</p>
</li>
<li><p> BoxH: numeric, legend box height (see figure below).
</p>
</li>
<li><p> PosX: numeric, horizontal adjustment of legend (see figure below).
</p>
</li>
<li><p> PosY: numeric, vertical adjustment of legend (see figure below). 
</p>
</li>
<li><p> Boxexp: numeric, vector of length 4 controlling the expansion of the legend box, 
given as c(xmin,xmax,ymin,ymax), see figure below.
</p>
</li>
<li><p> Boxbd: character, color of the background of the legend box. set to NA for no background.
</p>
</li>
<li><p> Boxcol: character, color of the border of the legend box. Set to NA for no box.
</p>
</li>
<li><p> Boxlwd: numeric, line thickness of the legend box. Set Boxcol to NA for no box.
</p>
</li>
<li><p> Titlefontsize: numeric, size of the legend title.
</p>
</li>
<li><p> Subtitlefontsize: numeric, size of the legend subtitle.
</p>
</li>
<li><p> TitleAdj: numeric vector of length 2, as c(x,y) to adjust title location (see figure below).
</p>
</li>
<li><p> SubtitleAdj: numeric vector of length 2, as c(x,y) to adjust subtitle location.
</p>
</li></ul>



<h3>Items options that are common to all items</h3>


<ul>
<li><p> Text: character, text of the item.
</p>
</li>
<li><p> Shape: character, shape description, one of &quot;rectangle&quot;, &quot;circle&quot;, &quot;line&quot;, 
&quot;arrow&quot; or &quot;none&quot;. Using &quot;none&quot; will leave a blank space that can be filled by a user-defined shape.
</p>
</li>
<li><p> ShpFill: character, fill color of shape, set to NA for no fill.
</p>
</li>
<li><p> ShpBord: character, border color of shape, set to NA for no border.
</p>
</li>
<li><p> ShpHash: logical (TRUE/FALSE) to add hashed lines to the shape (see <a href="#topic+create_Hashes">create_Hashes</a>).
</p>
</li>
<li><p> Shplwd: numeric, line thickness of the shape's border, set ShpBord to NA for no border.
</p>
</li>
<li><p> fontsize: numeric, size of the text.
</p>
</li>
<li><p> STSpace: numeric, space between the Shape and its Text (see figure below).
</p>
</li>
<li><p> ShiftX: numeric, shift Shape and Text left or right (see figure below).
</p>
</li>
<li><p> ShiftY: numeric, shift Shape and Text up or down (see figure below).
</p>
</li>
<li><p> Hashcol: character, color of hashes (if ShpHash is TRUE), see <a href="#topic+create_Hashes">create_Hashes</a> for details.
</p>
</li>
<li><p> Hashangle: numeric, angle of hashes (if ShpHash is TRUE), see <a href="#topic+create_Hashes">create_Hashes</a> for details.
</p>
</li>
<li><p> Hashspacing: numeric, spacing between hashes (if ShpHash is TRUE), see <a href="#topic+create_Hashes">create_Hashes</a> for details.
</p>
</li>
<li><p> Hashwidth: numeric, width of hashes (if ShpHash is TRUE), see see <a href="#topic+create_Hashes">create_Hashes</a> for details.
</p>
</li></ul>



<h3>Items options that are specific to the item's Shape</h3>


<ul>
<li><p> RectW: numeric, width of rectangle shape.
</p>
</li>
<li><p> RectH: numeric, height of rectangle shape.
</p>
</li>
<li><p> CircD: numeric, diameter of circle shape.
</p>
</li>
<li><p> LineTyp: numeric, type of line shape (0=blank, 1=solid, 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash).
</p>
</li>
<li><p> LineL: numeric, length of the line shape.
</p>
</li>
<li><p> ArrL: numeric, length of the arrow shape.
</p>
</li>
<li><p> ArrPwidth: numeric, width of arrow's path. see <a href="#topic+create_Arrow">create_Arrow</a> for details.
</p>
</li>
<li><p> ArrHlength: numeric, length of arrow's head. see <a href="#topic+create_Arrow">create_Arrow</a> for details.
</p>
</li>
<li><p> ArrHwidth: numeric, width of arrow's head. see <a href="#topic+create_Arrow">create_Arrow</a> for details.
</p>
</li>
<li><p> Arrdlength: numeric, length of dashes for dashed arrows. see <a href="#topic+create_Arrow">create_Arrow</a> for details.
</p>
</li>
<li><p> Arrtype: character, arrow type either &quot;normal&quot; or &quot;dashed&quot;. see <a href="#topic+create_Arrow">create_Arrow</a> for details. 
</p>
</li>
<li><p> Arrcol: character, color of the arrow. see <a href="#topic+create_Arrow">create_Arrow</a> for details.
</p>
</li>
<li><p> Arrtrans: numeric, transparency of the arrow. see <a href="#topic+create_Arrow">create_Arrow</a> for details.
</p>
</li></ul>

<p>The figure below shows some of the options used to customize the legend box and its items. 
Blue arrows represent location options and black arrows represent sizing options:
</p>
<p><img src="../help/figures/Addlegenddetails.png" width=800 alt="Addlegenddetails.png" />

</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Hashes">create_Hashes</a></code>, <code><a href="#topic+create_Arrow">create_Arrow</a></code>, <code><a href="#topic+add_labels">add_labels</a></code>,
<code><a href="#topic+add_Cscale">add_Cscale</a></code>, <code><a href="#topic+add_PieLegend">add_PieLegend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#53-adding-legends

# Set general options:

LegOpt=list( 
Title= "Title",
Subtitle="(Subtitle)",
Pos = "bottomright",
BoxW= 80,
BoxH= 140,
Boxexp = c(5,-2,-4,-4),
Titlefontsize = 2
)


#Create separate items, each with their own options:


Rectangle1=list(
  Text="Rectangle 1", 
  Shape="rectangle",
  ShpFill="cyan",
  ShpBord="blue",
  Shplwd=2,
  fontsize=1.2,
  STSpace=3,
  RectW=10,
  RectH=7
)

Rectangle2=list(
  Text="Rectangle 2", 
  Shape="rectangle",
  ShpFill="red",
  ShpBord="orange",
  ShpHash=TRUE,
  Shplwd=2,
  fontsize=1.2,
  STSpace=3,
  RectW=10,
  RectH=7,
  Hashcol="white",
  Hashangle=45,
  Hashspacing=1,
  Hashwidth=1
)

Circle1=list(
  Text="Circle 1", 
  Shape="circle",
  ShpFill="grey",
  ShpBord="yellow",
  Shplwd=2,
  fontsize=1.2,
  STSpace=3,
  CircD=10
)

Circle2=list(
  Text="Circle 2", 
  Shape="circle",
  ShpFill="white",
  ShpBord="red",
  ShpHash=TRUE,
  Shplwd=2,
  fontsize=1.2,
  STSpace=3,
  CircD=10,
  Hashcol="black",
  Hashangle=0,
  Hashspacing=2,
  Hashwidth=2
)

Line1=list(
  Text="Line 1", 
  Shape="line",
  ShpFill="black",
  Shplwd=5,
  fontsize=1.2,
  STSpace=3,
  LineL=10
)

Line2=list(
  Text="Line 2", 
  Shape="line",
  Shplwd=5,
  ShpFill="green",
  Shplwd=5,
  fontsize=1.2,
  STSpace=3,
  LineTyp=6, 
  LineL=10
)

Arrow1=list(
  Text="Arrow 1", 
  Shape="arrow",
  ShpBord="green",
  Shplwd=1,
  ArrL=10,
  ArrPwidth=5,
  ArrHlength=15, 
  ArrHwidth=10, 
  Arrcol="orange",
  fontsize=1.2,
  STSpace=3
)

Arrow2=list(
  Text="Arrow 2", 
  Shape="arrow",
  ShpBord=NA,
  ArrL=10,
  ArrPwidth=5,
  ArrHlength=15, 
  ArrHwidth=10, 
  Arrdlength=0, 
  Arrtype="dashed",
  Arrcol=c("red","green","blue"),
  fontsize=1.2,
  STSpace=3
)

Arrow3=list(
  Text="Arrow 3", 
  Shape="arrow",
  ShpBord=NA,
  ArrL=10,
  ArrPwidth=5,
  ArrHlength=15, 
  ArrHwidth=10, 
  Arrdlength=5, 
  Arrtype="dashed",
  Arrcol="darkgreen",
  fontsize=1.2,
  STSpace=3
)

Arrow4=list(
  Text="Arrow 4", 
  Shape="arrow",
  ShpBord="black",
  Shplwd=0.1,
  ArrL=10,
  ArrPwidth=5,
  ArrHlength=15, 
  ArrHwidth=10, 
  Arrcol="pink",
  ShpHash=TRUE,
  Hashcol="blue",
  Hashangle=-45,
  Hashspacing=1,
  Hashwidth=1,
  fontsize=1.2,
  STSpace=3
)

None=list(
  Text="None", 
  Shape="none",
  fontsize=1.2,
  STSpace=3,
  ShiftX=10
)


#Combine all items into a single list:

Items=list(Rectangle1,Rectangle2,Circle1,Circle2,Line1,Line2,Arrow1,Arrow2,Arrow3,Arrow4,None)

#manually build a bounding box (same as st_bbox(load_ASDs())):

bb=st_bbox(c(xmin=-3348556,xmax=4815055,ymax=4371127,ymin=-3329339),
           crs = st_crs(6932))
bx=st_as_sfc(bb) #Convert to polygon to plot it

#Plot and add legend

plot(bx,col="grey")
add_Legend(bb,LegOpt,Items)

</code></pre>

<hr>
<h2 id='add_PieLegend'>Add a legend to Pies</h2><span id='topic+add_PieLegend'></span>

<h3>Description</h3>

<p>Adds a legend to pies created using <a href="#topic+create_Pies">create_Pies</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_PieLegend(
  Pies = NULL,
  bb = NULL,
  PosX = 0,
  PosY = 0,
  Size = 25,
  lwd = 1,
  Boxexp = c(0.2, 0.2, 0.12, 0.3),
  Boxbd = "white",
  Boxlwd = 1,
  Labexp = 0.3,
  fontsize = 1,
  LegSp = 0.5,
  Horiz = TRUE,
  PieTitle = "Pie chart",
  SizeTitle = "Size chart",
  PieTitleVadj = 0.5,
  SizeTitleVadj = 0.3,
  nSizes = 3,
  SizeClasses = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_PieLegend_+3A_pies">Pies</code></td>
<td>
<p>Spatial object created using <a href="#topic+create_Pies">create_Pies</a>.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_bb">bb</code></td>
<td>
<p>Spatial object, sf bounding box created with <code>st_bbox()</code>. If provided,
the legend will be centered in that bb. Otherwise it is centered on the <code>min(Latitudes)</code>
and <code>median(Longitudes)</code> of coordinates found in the input <code>Pies</code>.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_posx">PosX</code></td>
<td>
<p>numeric, horizontal adjustment of legend.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_posy">PosY</code></td>
<td>
<p>numeric, vertical adjustment of legend.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_size">Size</code></td>
<td>
<p>numeric, controls the size of pies.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_lwd">lwd</code></td>
<td>
<p>numeric, line thickness of pies.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_boxexp">Boxexp</code></td>
<td>
<p>numeric, vector of length 4 controls the expansion of the legend box, given
as <code>c(xmin,xmax,ymin,ymax)</code>.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_boxbd">Boxbd</code></td>
<td>
<p>character, color of the background of the legend box.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_boxlwd">Boxlwd</code></td>
<td>
<p>numeric, line thickness of the legend box. Set to zero if no box is desired.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_labexp">Labexp</code></td>
<td>
<p>numeric, controls the distance of the pie labels to the center of the pie.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_fontsize">fontsize</code></td>
<td>
<p>numeric, size of the legend font.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_legsp">LegSp</code></td>
<td>
<p>numeric, spacing between the pie and the size chart (only used if <code>SizeVar</code>
was specified in <a href="#topic+create_Pies">create_Pies</a>).</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_horiz">Horiz</code></td>
<td>
<p>logical. Set to FALSE for vertical layout (only used if <code>SizeVar</code>
was specified in <a href="#topic+create_Pies">create_Pies</a>).</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_pietitle">PieTitle</code></td>
<td>
<p>character, title of the pie chart.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_sizetitle">SizeTitle</code></td>
<td>
<p>character, title of the size chart (only used if <code>SizeVar</code>
was specified in <a href="#topic+create_Pies">create_Pies</a>).</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_pietitlevadj">PieTitleVadj</code></td>
<td>
<p>numeric, vertical adjustment of the title of the pie chart.</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_sizetitlevadj">SizeTitleVadj</code></td>
<td>
<p>numeric, vertical adjustment of the title of the size chart (only used if <code>SizeVar</code>
was specified in <a href="#topic+create_Pies">create_Pies</a>).</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_nsizes">nSizes</code></td>
<td>
<p>integer, number of size classes to display in the size chart. Minimum and maximum sizes are
displayed by default. (only used if <code>SizeVar</code> was specified in <a href="#topic+create_Pies">create_Pies</a>).</p>
</td></tr>
<tr><td><code id="add_PieLegend_+3A_sizeclasses">SizeClasses</code></td>
<td>
<p>numeric, vector (e.g. c(1,10,100)) of size classes to display in the size chart
(only used if <code>SizeVar</code> was specified in <a href="#topic+create_Pies">create_Pies</a>). If set, overrides <code>nSizes</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds a legend to a pre-existing pie plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Pies">create_Pies</a></code>, <code><a href="#topic+PieData">PieData</a></code>, <code><a href="#topic+PieData2">PieData2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#23-create-pies

#Pies of constant size, all classes displayed:
#Create pies
MyPies=create_Pies(Input=PieData,
                   NamesIn=c("Lat","Lon","Sp","N"),
                   Size=50
                   )
#Plot Pies
plot(st_geometry(MyPies),col=MyPies$col)
#Add Pies legend
add_PieLegend(Pies=MyPies,PosX=-0.1,PosY=-1,Boxexp=c(0.5,0.45,0.12,0.45),
             PieTitle="Species")



</code></pre>

<hr>
<h2 id='add_RefGrid'>Add a Reference grid</h2><span id='topic+add_RefGrid'></span>

<h3>Description</h3>

<p>Add a Latitude/Longitude reference grid to maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_RefGrid(
  bb,
  ResLat = 1,
  ResLon = 2,
  LabLon = NA,
  LatR = c(-80, -45),
  lwd = 1,
  lcol = "black",
  fontsize = 1,
  fontcol = "black",
  offset = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_RefGrid_+3A_bb">bb</code></td>
<td>
<p>bounding box of the first plotted object. for example, <code>bb=st_bbox(SmallBathy())</code> or <code>bb=st_bbox(MyPolys)</code>.</p>
</td></tr>
<tr><td><code id="add_RefGrid_+3A_reslat">ResLat</code></td>
<td>
<p>numeric, latitude resolution in decimal degrees.</p>
</td></tr>
<tr><td><code id="add_RefGrid_+3A_reslon">ResLon</code></td>
<td>
<p>numeric, longitude resolution in decimal degrees.</p>
</td></tr>
<tr><td><code id="add_RefGrid_+3A_lablon">LabLon</code></td>
<td>
<p>numeric, longitude at which Latitude labels should appear. if set, the resulting Reference grid will be circumpolar.</p>
</td></tr>
<tr><td><code id="add_RefGrid_+3A_latr">LatR</code></td>
<td>
<p>numeric, range of latitudes of circumpolar grid.</p>
</td></tr>
<tr><td><code id="add_RefGrid_+3A_lwd">lwd</code></td>
<td>
<p>numeric, line thickness of the Reference grid.</p>
</td></tr>
<tr><td><code id="add_RefGrid_+3A_lcol">lcol</code></td>
<td>
<p>character, line color of the Reference grid.</p>
</td></tr>
<tr><td><code id="add_RefGrid_+3A_fontsize">fontsize</code></td>
<td>
<p>numeric, font size of the Reference grid's labels.</p>
</td></tr>
<tr><td><code id="add_RefGrid_+3A_fontcol">fontcol</code></td>
<td>
<p>character, font color of the Reference grid's labels.</p>
</td></tr>
<tr><td><code id="add_RefGrid_+3A_offset">offset</code></td>
<td>
<p>numeric, offset of the Reference grid's labels (distance to plot border).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+load_Bathy">load_Bathy</a></code>, <code><a href="#topic+SmallBathy">SmallBathy</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

#Example 1: Circumpolar grid with Latitude labels at Longitude 0

plot(SmallBathy(),breaks=Depth_cuts, col=Depth_cols, legend=FALSE,axes=FALSE,box=FALSE)
add_RefGrid(bb=st_bbox(SmallBathy()),ResLat=10,ResLon=20,LabLon = 0)

#Example 2: Local grid around created polygons

MyPolys=create_Polys(PolyData,Densify=TRUE)
BathyC=crop(SmallBathy(),ext(MyPolys))#crop the bathymetry to match the extent of MyPolys
Mypar=par(mai=c(0.5,0.5,0.5,0.5)) #Figure margins as c(bottom, left, top, right)
par(Mypar)
plot(BathyC,breaks=Depth_cuts, col=Depth_cols, legend=FALSE,axes=FALSE,box=FALSE)
add_RefGrid(bb=st_bbox(BathyC),ResLat=2,ResLon=6)
plot(st_geometry(MyPolys),add=TRUE,col='orange',border='brown',lwd=2)

</code></pre>

<hr>
<h2 id='assign_areas'>Assign point locations to polygons</h2><span id='topic+assign_areas'></span>

<h3>Description</h3>

<p>Given a set of polygons and a set of point locations (given in decimal degrees),
finds in which polygon those locations fall.
Finds, for example, in which Subarea the given fishing locations occurred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_areas(
  Input,
  Polys,
  AreaNameFormat = "GAR_Long_Label",
  Buffer = 0,
  NamesIn = NULL,
  NamesOut = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_areas_+3A_input">Input</code></td>
<td>
<p>dataframe containing - at the minimum - Latitudes and Longitudes to be assigned to polygons.
</p>
<p>If <code>NamesIn</code> is not provided, the columns in the <code>Input</code> must be in the following order:
Latitude, Longitude, Variable 1, Variable 2, ... Variable x..</p>
</td></tr>
<tr><td><code id="assign_areas_+3A_polys">Polys</code></td>
<td>
<p>character vector of polygon names (e.g., <code>Polys=c('ASDs','RBs')</code>).
</p>
<p>Must be matching the names of the pre-loaded spatial objects (loaded via e.g., <code>ASDs=load_ASDs()</code>).</p>
</td></tr>
<tr><td><code id="assign_areas_+3A_areanameformat">AreaNameFormat</code></td>
<td>
<p>dependent on the polygons loaded. For the Secretariat's spatial objects loaded via 'load_' functions,
we have the following:
</p>
<p><code>'GAR_Name'</code> e.g., <code>'Subarea 88.2'</code>
</p>
<p><code>'GAR_Short_Label'</code> e.g., <code>'882'</code>
</p>
<p><code>'GAR_Long_Label'</code> (default) e.g., <code>'88.2'</code>
</p>
<p>Several values may be entered if several <code>Polys</code> are used, e.g.:
</p>
<p><code>c('GAR_Short_Label','GAR_Name')</code>, in which case <code>AreaNameFormat</code> must be given in the same order as <code>Polys</code>.</p>
</td></tr>
<tr><td><code id="assign_areas_+3A_buffer">Buffer</code></td>
<td>
<p>numeric, distance in nautical miles to be added around the <code>Polys</code> of interest.
Can be specified for each of the <code>Polys</code> (e.g., <code>Buffer=c(2,5)</code>). Useful to determine whether locations are within
<code>Buffer</code> nautical miles of a polygon.</p>
</td></tr>
<tr><td><code id="assign_areas_+3A_namesin">NamesIn</code></td>
<td>
<p>character vector of length 2 specifying the column names of Latitude and Longitude fields in
the <code>Input</code>. Latitudes name must be given first, e.g.:
</p>
<p><code>NamesIn=c('MyLatitudes','MyLongitudes')</code>.</p>
</td></tr>
<tr><td><code id="assign_areas_+3A_namesout">NamesOut</code></td>
<td>
<p>character, names of the resulting column names in the output dataframe,
with order matching that of <code>Polys</code> (e.g., <code>NamesOut=c('Recapture_ASD','Recapture_RB')</code>).
If not provided will be set as equal to <code>Polys</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with the same structure as the <code>Input</code>, with additional columns corresponding
to the <code>Polys</code> used and named after <code>NamesOut</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_SSRUs">load_SSRUs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_MAs">load_MAs</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>, <code><a href="#topic+load_EEZs">load_EEZs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


#Generate a dataframe
MyData=data.frame(Lat=runif(100,min=-65,max=-50),
                  Lon=runif(100,min=20,max=40))

#Assign ASDs and SSRUs to these locations (first load ASDs and SSRUs)
ASDs=load_ASDs()
SSRUs=load_SSRUs()

MyData=assign_areas(Input=MyData,Polys=c('ASDs','SSRUs'),NamesOut=c('MyASDs','MySSRUs'))

#View(MyData)
table(MyData$MyASDs) #count of locations per ASD
table(MyData$MySSRUs) #count of locations per SSRU



</code></pre>

<hr>
<h2 id='CCAMLRp'>CCAMLRGIS Projection</h2><span id='topic+CCAMLRp'></span>

<h3>Description</h3>

<p>The CCAMLRGIS package uses the Lambert azimuthal equal-area projection (see <a href="https://en.wikipedia.org/wiki/Lambert_azimuthal_equal-area_projection">https://en.wikipedia.org/wiki/Lambert_azimuthal_equal-area_projection</a>).
Source: <a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>.
In order to align with recent developments within Geographic Information Software, this projection
will be accessed via EPSG code 6932 (see <a href="https://epsg.org/crs_6932/WGS-84-NSIDC-EASE-Grid-2-0-South.html">https://epsg.org/crs_6932/WGS-84-NSIDC-EASE-Grid-2-0-South.html</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CCAMLRp)
</code></pre>


<h3>Format</h3>

<p>character string
</p>


<h3>Value</h3>

<p>&quot;+proj=laea +lat_0=-90 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs&quot;
</p>

<hr>
<h2 id='Clip2Coast'>Clip Polygons to a simplified Antarctic coastline</h2><span id='topic+Clip2Coast'></span>

<h3>Description</h3>

<p>Clip Polygons to the <a href="#topic+Coast">Coast</a> (removes polygon parts that fall on land) and computes the area of the resulting polygon.
Uses an sf object as input which may be user-generated or created via buffered points (see <a href="#topic+create_Points">create_Points</a>),
buffered lines (see <a href="#topic+create_Lines">create_Lines</a>) or polygons (see <a href="#topic+create_Polys">create_Polys</a>). N.B.: this function uses a
simplified coastline. For more accurate results, load the high resolution coastline (see <a href="#topic+load_Coastline">load_Coastline</a>), and
use sf::st_difference().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Clip2Coast(Input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Clip2Coast_+3A_input">Input</code></td>
<td>
<p>sf polygon(s) to be clipped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf polygon carrying the same data as the <code>Input</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+Coast">Coast</a>, <code><a href="#topic+create_Points">create_Points</a></code>, <code><a href="#topic+create_Lines">create_Lines</a></code>, <code><a href="#topic+create_Polys">create_Polys</a></code>,
<code><a href="#topic+create_PolyGrids">create_PolyGrids</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MyPolys=create_Polys(PolyData,Densify=TRUE,Buffer=c(10,-15,120))
plot(st_geometry(MyPolys),col='red')
plot(st_geometry(Coast[Coast$ID=='All',]),add=TRUE)
MyPolysClipped=Clip2Coast(MyPolys)
plot(st_geometry(MyPolysClipped),col='blue',add=TRUE)
#View(MyPolysClipped)


</code></pre>

<hr>
<h2 id='Coast'>Simplified and subsettable coastline</h2><span id='topic+Coast'></span>

<h3>Description</h3>

<p>Coastline polygons generated from <a href="#topic+load_Coastline">load_Coastline</a> and sub-sampled to only contain data that falls
within the boundaries of the Convention Area. This spatial object may be subsetted to plot the coastline for selected
ASDs or EEZs (see examples). Source: <a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Coast)
</code></pre>


<h3>Format</h3>

<p>sf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Clip2Coast">Clip2Coast</a></code>, <code><a href="#topic+load_Coastline">load_Coastline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Complete coastline:
plot(st_geometry(Coast[Coast$ID=='All',]),col='grey')

#ASD 48.1 coastline:
plot(st_geometry(Coast[Coast$ID=='48.1',]),col='grey')
</code></pre>

<hr>
<h2 id='create_Arrow'>Create Arrow</h2><span id='topic+create_Arrow'></span>

<h3>Description</h3>

<p>Create an arrow which can be curved and/or segmented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_Arrow(
  Input,
  Np = 50,
  Pwidth = 5,
  Hlength = 15,
  Hwidth = 10,
  dlength = 0,
  Atype = "normal",
  Acol = "green",
  Atrans = 0,
  yx = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_Arrow_+3A_input">Input</code></td>
<td>
<p>input dataframe with at least two columns (Latitudes then Longitudes) and an
optional third column for weights. First row is the location of the start of the arrow,
Last row is the location of the end of the arrow (where the arrow will point to). Optional
intermediate rows are the locations of points towards which the arrow's path will bend. 
Weights (third column) can be added to the intermediate points to make the arrow's path
bend more towards them. Projected coordinates may be used (Y then X) instead of Latitudes
and Longitudes by setting <code>yx</code> to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="create_Arrow_+3A_np">Np</code></td>
<td>
<p>integer, number of additional points generated to create a curved path. If the 
arrow's path appears too segmented, increase <code>Np</code>.</p>
</td></tr>
<tr><td><code id="create_Arrow_+3A_pwidth">Pwidth</code></td>
<td>
<p>numeric, width of the arrow's path.</p>
</td></tr>
<tr><td><code id="create_Arrow_+3A_hlength">Hlength</code></td>
<td>
<p>numeric, length of the arrow's head.</p>
</td></tr>
<tr><td><code id="create_Arrow_+3A_hwidth">Hwidth</code></td>
<td>
<p>numeric, width of the arrow's head.</p>
</td></tr>
<tr><td><code id="create_Arrow_+3A_dlength">dlength</code></td>
<td>
<p>numeric, length of dashes for dashed arrows.</p>
</td></tr>
<tr><td><code id="create_Arrow_+3A_atype">Atype</code></td>
<td>
<p>character, arrow type either &quot;normal&quot; or &quot;dashed&quot;. A normal arrow is a single polygon,
with a single color (set by <code>Acol</code>) and transparency (set by <code>Atrans</code>). A dashed arrow
is a series of polygons which can be colored separately by setting two or more values as
<code>Acol=c("color start","color end")</code> and two or more transparency values as
<code>Atrans=c("transparency start","transparency end")</code>. The length of dashes is controlled
by <code>dlength</code>.</p>
</td></tr>
<tr><td><code id="create_Arrow_+3A_acol">Acol</code></td>
<td>
<p>Color of the arrow, see <code>Atype</code> above.</p>
</td></tr>
<tr><td><code id="create_Arrow_+3A_atrans">Atrans</code></td>
<td>
<p>Numeric, transparency of the arrow, see <code>Atype</code> above.</p>
</td></tr>
<tr><td><code id="create_Arrow_+3A_yx">yx</code></td>
<td>
<p>Logical, if set to <code>TRUE</code> the input coordinates are projected.
Give Y in the first column, X in the second.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment with colors included in the dataframe (see examples).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Points">create_Points</a></code>, <code><a href="#topic+create_Lines">create_Lines</a></code>, <code><a href="#topic+create_Polys">create_Polys</a></code>,
<code><a href="#topic+create_PolyGrids">create_PolyGrids</a></code>, <code><a href="#topic+create_Stations">create_Stations</a></code>, <code><a href="#topic+create_Pies">create_Pies</a></code>, 
<code><a href="#topic+add_Legend">add_Legend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#24-create-arrow

#Example 1: straight green arrow
myInput=data.frame(lat=c(-61,-52),
                   lon=c(-60,-40))
Arrow=create_Arrow(Input=myInput)
plot(st_geometry(Arrow),col=Arrow$col,main="Example 1")


#Example 2: blue arrow with one bend
myInput=data.frame(lat=c(-61,-65,-52),
                   lon=c(-60,-45,-40))
Arrow=create_Arrow(Input=myInput,Acol="lightblue")
plot(st_geometry(Arrow),col=Arrow$col,main="Example 2")

#Example 3: blue arrow with two bends
myInput=data.frame(lat=c(-61,-60,-65,-52),
                   lon=c(-60,-50,-45,-40))
Arrow=create_Arrow(Input=myInput,Acol="lightblue")
plot(st_geometry(Arrow),col=Arrow$col,main="Example 3")

#Example 4: blue arrow with two bends, with more weight on the second bend
#and a big head
myInput=data.frame(lat=c(-61,-60,-65,-52),
                   lon=c(-60,-50,-45,-40),
                   w=c(1,1,2,1))
Arrow=create_Arrow(Input=myInput,Acol="lightblue",Hlength=20,Hwidth=20)
plot(st_geometry(Arrow),col=Arrow$col,main="Example 4")

#Example 5: Dashed arrow, small dashes
myInput=data.frame(lat=c(-61,-60,-65,-52),
                   lon=c(-60,-50,-45,-40),
                   w=c(1,1,2,1))
Arrow=create_Arrow(Input=myInput,Acol="blue",Atype = "dashed",dlength = 1)
plot(st_geometry(Arrow),col=Arrow$col,main="Example 5",border=NA)

#Example 6: Dashed arrow, big dashes
myInput=data.frame(lat=c(-61,-60,-65,-52),
                   lon=c(-60,-50,-45,-40),
                   w=c(1,1,2,1))
Arrow=create_Arrow(Input=myInput,Acol="blue",Atype = "dashed",dlength = 2)
plot(st_geometry(Arrow),col=Arrow$col,main="Example 6",border=NA)

#Example 7: Dashed arrow, no dashes, 3 colors and transparency gradient
myInput=data.frame(lat=c(-61,-60,-65,-52),
                   lon=c(-60,-50,-45,-40),
                   w=c(1,1,2,1))
Arrow=create_Arrow(Input=myInput,Acol=c("red","green","blue"),
Atrans = c(0,0.9,0),Atype = "dashed",dlength = 0)
plot(st_geometry(Arrow),col=Arrow$col,main="Example 7",border=NA)

#Example 8: Same as example 7 but with more points, so smoother
myInput=data.frame(lat=c(-61,-60,-65,-52),
                   lon=c(-60,-50,-45,-40),
                   w=c(1,1,2,1))
Arrow=create_Arrow(Input=myInput,Np=200,Acol=c("red","green","blue"),
                   Atrans = c(0,0.9,0),Atype = "dashed",dlength = 0)
plot(st_geometry(Arrow),col=Arrow$col,main="Example 8",border=NA)

</code></pre>

<hr>
<h2 id='create_Hashes'>Create Hashes</h2><span id='topic+create_Hashes'></span>

<h3>Description</h3>

<p>Create hashed lines to fill a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_Hashes(pol, angle = 45, spacing = 1, width = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_Hashes_+3A_pol">pol</code></td>
<td>
<p>single polygon inside which hashed lines will be created.
May be created using <code><a href="#topic+create_Polys">create_Polys</a></code> or by subsetting an 
object obtained using one of the <code>load_</code> functions.</p>
</td></tr>
<tr><td><code id="create_Hashes_+3A_angle">angle</code></td>
<td>
<p>numeric, angle of the hashed lines in degrees (0-360), 
noting that the function might struggle with angles 0, 180, -180 or 360.</p>
</td></tr>
<tr><td><code id="create_Hashes_+3A_spacing">spacing</code></td>
<td>
<p>numeric, spacing between hashed lines.</p>
</td></tr>
<tr><td><code id="create_Hashes_+3A_width">width</code></td>
<td>
<p>numeric, width of hashed lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment, to be added to your plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Polys">create_Polys</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#25-create-hashes

#Create some polygons
MyPolys=create_Polys(Input=PolyData)
#Create hashes for each polygon
H1=create_Hashes(pol=MyPolys[1,],angle=45,spacing=1,width=1)
H2=create_Hashes(pol=MyPolys[2,],angle=90,spacing=2,width=2)
H3=create_Hashes(pol=MyPolys[3,],angle=0,spacing=3,width=3)

plot(st_geometry(MyPolys),col='cyan')
plot(st_geometry(H1),col='red',add=TRUE)
plot(st_geometry(H2),col='green',add=TRUE)
plot(st_geometry(H3),col='blue',add=TRUE)

</code></pre>

<hr>
<h2 id='create_Lines'>Create Lines</h2><span id='topic+create_Lines'></span>

<h3>Description</h3>

<p>Create lines to display, for example, fishing line locations or tagging data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_Lines(
  Input,
  NamesIn = NULL,
  Buffer = 0,
  Densify = FALSE,
  Clip = FALSE,
  SeparateBuf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_Lines_+3A_input">Input</code></td>
<td>
<p>input dataframe.
</p>
<p>If <code>NamesIn</code> is not provided, the columns in the <code>Input</code> must be in the following order:
</p>
<p>Line name, Latitude, Longitude.
</p>
<p>If a given line is made of more than two points, the locations of points
must be given in order, from one end of the line to the other.</p>
</td></tr>
<tr><td><code id="create_Lines_+3A_namesin">NamesIn</code></td>
<td>
<p>character vector of length 3 specifying the column names of line identifier, Latitude
and Longitude fields in the <code>Input</code>.
</p>
<p>Names must be given in that order, e.g.:
</p>
<p><code>NamesIn=c('Line ID','Line Latitudes','Line Longitudes')</code>.</p>
</td></tr>
<tr><td><code id="create_Lines_+3A_buffer">Buffer</code></td>
<td>
<p>numeric, distance in nautical miles by which to expand the lines. Can be specified for
each line (as a numeric vector).</p>
</td></tr>
<tr><td><code id="create_Lines_+3A_densify">Densify</code></td>
<td>
<p>logical, if set to TRUE, additional points between extremities of lines spanning more
than 0.1 degree longitude are added at every 0.1 degree of longitude prior to projection (see examples).</p>
</td></tr>
<tr><td><code id="create_Lines_+3A_clip">Clip</code></td>
<td>
<p>logical, if set to TRUE, polygon parts (from buffered lines) that fall on land are removed (see <a href="#topic+Clip2Coast">Clip2Coast</a>).</p>
</td></tr>
<tr><td><code id="create_Lines_+3A_separatebuf">SeparateBuf</code></td>
<td>
<p>logical, if set to FALSE when adding a <code>Buffer</code>,
all spatial objects are merged, resulting in a single spatial object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment.
Data within the resulting spatial object contains the data provided in the <code>Input</code> plus
additional &quot;LengthKm&quot; and &quot;LengthNm&quot; columns which corresponds to the lines lengths,
in kilometers and nautical miles respectively. If additional data was included in the <code>Input</code>,
any numerical values are summarized for each line (min, max, mean, median, sum, count and sd).
</p>
<p>To see the data contained in your spatial object, type: <code>View(MyLines)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Points">create_Points</a></code>, <code><a href="#topic+create_Polys">create_Polys</a></code>, <code><a href="#topic+create_PolyGrids">create_PolyGrids</a></code>,
<code><a href="#topic+create_Stations">create_Stations</a></code>, <code><a href="#topic+create_Pies">create_Pies</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#create-lines

#Densified lines (note the curvature of the lines)

MyLines=create_Lines(Input=LineData,Densify=TRUE)
plot(st_geometry(MyLines),lwd=2,col=rainbow(nrow(MyLines)))



</code></pre>

<hr>
<h2 id='create_Pies'>Create Pies</h2><span id='topic+create_Pies'></span>

<h3>Description</h3>

<p>Generates pie charts that can be overlaid on maps. The <code>Input</code> data must be a dataframe with, at least,
columns for latitude, longitude, class and value. For each location, a pie is created with pieces for each class,
and the size of each piece depends on the proportion of each class (the value of each class divided by the sum of values).
Optionally, the area of each pie can be proportional to a chosen variable (if that variable is different than the 
value mentioned above, the <code>Input</code> data must have a fifth column and that variable must be unique to each location).
If the <code>Input</code> data contains locations that are too close together, the data can be gridded by setting <code>GridKm</code>.
Once pie charts have been created, the function <a href="#topic+add_PieLegend">add_PieLegend</a> may be used to add a legend to the figure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_Pies(
  Input,
  NamesIn = NULL,
  Classes = NULL,
  cols = c("green", "red"),
  Size = 50,
  SizeVar = NULL,
  GridKm = NULL,
  Other = 0,
  Othercol = "grey"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_Pies_+3A_input">Input</code></td>
<td>
<p>input dataframe.</p>
</td></tr>
<tr><td><code id="create_Pies_+3A_namesin">NamesIn</code></td>
<td>
<p>character vector of length 4 specifying the column names of Latitude, Longitude,
Class and value fields in the <code>Input</code>.
</p>
<p>Names must be given in that order, e.g.:
</p>
<p><code>NamesIn=c('Latitude','Longitude','Class','Value')</code>.</p>
</td></tr>
<tr><td><code id="create_Pies_+3A_classes">Classes</code></td>
<td>
<p>character, optional vector of classes to be displayed. If this excludes classes that are in the <code>Input</code>,
those excluded classes will be pooled in a 'Other' class.</p>
</td></tr>
<tr><td><code id="create_Pies_+3A_cols">cols</code></td>
<td>
<p>character, vector of two or more color names to colorize pie pieces.</p>
</td></tr>
<tr><td><code id="create_Pies_+3A_size">Size</code></td>
<td>
<p>numeric, value controlling the size of pies.</p>
</td></tr>
<tr><td><code id="create_Pies_+3A_sizevar">SizeVar</code></td>
<td>
<p>numeric, optional, name of the field in the <code>Input</code> that should be used to scale the area of pies.
Must be unique to locations in the input.</p>
</td></tr>
<tr><td><code id="create_Pies_+3A_gridkm">GridKm</code></td>
<td>
<p>numeric, optional, cell size of the grid in kilometers. If provided, locations are pooled by grid
cell and values are summed for each class.</p>
</td></tr>
<tr><td><code id="create_Pies_+3A_other">Other</code></td>
<td>
<p>numeric, optional, percentage threshold below which classes are pooled in a 'Other' class.</p>
</td></tr>
<tr><td><code id="create_Pies_+3A_othercol">Othercol</code></td>
<td>
<p>character, optional, color of the pie piece for the 'Other' class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment, ready to be plotted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_PieLegend">add_PieLegend</a></code>, <code><a href="#topic+PieData">PieData</a></code>, <code><a href="#topic+PieData2">PieData2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#23-create-pies
  
#Pies of constant size, all classes displayed:
#Create pies
MyPies=create_Pies(Input=PieData,NamesIn=c("Lat","Lon","Sp","N"),Size=50)
#Plot Pies
plot(st_geometry(MyPies),col=MyPies$col)
#Add Pies legend
add_PieLegend(Pies=MyPies,PosX=-0.1,PosY=-1,Boxexp=c(0.5,0.45,0.12,0.45),
             PieTitle="Species")



</code></pre>

<hr>
<h2 id='create_Points'>Create Points</h2><span id='topic+create_Points'></span>

<h3>Description</h3>

<p>Create Points to display point locations. Buffering points may be used to produce bubble charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_Points(
  Input,
  NamesIn = NULL,
  Buffer = 0,
  Clip = FALSE,
  SeparateBuf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_Points_+3A_input">Input</code></td>
<td>
<p>input dataframe.
</p>
<p>If <code>NamesIn</code> is not provided, the columns in the <code>Input</code> must be in the following order:
</p>
<p>Latitude, Longitude, Variable 1, Variable 2, ... Variable x.</p>
</td></tr>
<tr><td><code id="create_Points_+3A_namesin">NamesIn</code></td>
<td>
<p>character vector of length 2 specifying the column names of Latitude and Longitude fields in
the <code>Input</code>. Latitudes name must be given first, e.g.:
</p>
<p><code>NamesIn=c('MyLatitudes','MyLongitudes')</code>.</p>
</td></tr>
<tr><td><code id="create_Points_+3A_buffer">Buffer</code></td>
<td>
<p>numeric, radius in nautical miles by which to expand the points. Can be specified for
each point (as a numeric vector).</p>
</td></tr>
<tr><td><code id="create_Points_+3A_clip">Clip</code></td>
<td>
<p>logical, if set to TRUE, polygon parts (from buffered points) that fall on land are removed (see <a href="#topic+Clip2Coast">Clip2Coast</a>).</p>
</td></tr>
<tr><td><code id="create_Points_+3A_separatebuf">SeparateBuf</code></td>
<td>
<p>logical, if set to FALSE when adding a <code>Buffer</code>,
all spatial objects are merged, resulting in a single spatial object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment.
Data within the resulting spatial object contains the data provided in the <code>Input</code> plus
additional &quot;x&quot; and &quot;y&quot; columns which corresponds to the projected points locations 
and may be used to label points (see examples).
</p>
<p>To see the data contained in your spatial object, type: <code>View(MyPoints)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Lines">create_Lines</a></code>, <code><a href="#topic+create_Polys">create_Polys</a></code>, <code><a href="#topic+create_PolyGrids">create_PolyGrids</a></code>,
<code><a href="#topic+create_Stations">create_Stations</a></code>, <code><a href="#topic+create_Pies">create_Pies</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#create-points

#Simple points with labels

MyPoints=create_Points(Input=PointData)
plot(st_geometry(MyPoints))
text(MyPoints$x,MyPoints$y,MyPoints$name,adj=c(0.5,-0.5),xpd=TRUE)





</code></pre>

<hr>
<h2 id='create_PolyGrids'>Create a Polygon Grid</h2><span id='topic+create_PolyGrids'></span>

<h3>Description</h3>

<p>Create a polygon grid to spatially aggregate data in cells of chosen size.
Cell size may be specified in degrees or as a desired area in square kilometers
(in which case cells are of equal area).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_PolyGrids(
  Input,
  NamesIn = NULL,
  dlon = NA,
  dlat = NA,
  Area = NA,
  cuts = 100,
  cols = c("green", "yellow", "red")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_PolyGrids_+3A_input">Input</code></td>
<td>
<p>input dataframe.
</p>
<p>If <code>NamesIn</code> is not provided, the columns in the <code>Input</code> must be in the following order:
</p>
<p>Latitude, Longitude, Variable 1, Variable 2 ... Variable x.</p>
</td></tr>
<tr><td><code id="create_PolyGrids_+3A_namesin">NamesIn</code></td>
<td>
<p>character vector of length 2 specifying the column names of Latitude and Longitude fields in
the <code>Input</code>. Latitudes name must be given first, e.g.:
</p>
<p><code>NamesIn=c('MyLatitudes','MyLongitudes')</code>.</p>
</td></tr>
<tr><td><code id="create_PolyGrids_+3A_dlon">dlon</code></td>
<td>
<p>numeric, width of the grid cells in decimal degrees of longitude.</p>
</td></tr>
<tr><td><code id="create_PolyGrids_+3A_dlat">dlat</code></td>
<td>
<p>numeric, height of the grid cells in decimal degrees of latitude.</p>
</td></tr>
<tr><td><code id="create_PolyGrids_+3A_area">Area</code></td>
<td>
<p>numeric, area in square kilometers of the grid cells. The smaller the <code>Area</code>, the longer it will take.</p>
</td></tr>
<tr><td><code id="create_PolyGrids_+3A_cuts">cuts</code></td>
<td>
<p>numeric, number of desired color classes.</p>
</td></tr>
<tr><td><code id="create_PolyGrids_+3A_cols">cols</code></td>
<td>
<p>character, desired colors. If more that one color is provided, a linear color gradient is generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment.
Data within the resulting spatial object contains the data provided in the <code>Input</code> after aggregation
within cells. For each Variable, the minimum, maximum, mean, sum, count, standard deviation, and, 
median of values in each cell is returned. In addition, for each cell, its area (AreaKm2), projected 
centroid (Centrex, Centrey) and unprojected centroid (Centrelon, Centrelat) is given.
</p>
<p>To see the data contained in your spatial object, type: <code>View(MyGrid)</code>.
</p>
<p>Also, colors are generated for each aggregated values according to the chosen <code>cuts</code> 
and <code>cols</code>.
</p>
<p>To generate a custom color scale after the grid creation, refer to <code><a href="#topic+add_col">add_col</a></code> and 
<code><a href="#topic+add_Cscale">add_Cscale</a></code>. See Example 4 below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Points">create_Points</a></code>, <code><a href="#topic+create_Lines">create_Lines</a></code>, <code><a href="#topic+create_Polys">create_Polys</a></code>,
<code><a href="#topic+create_Stations">create_Stations</a></code>, <code><a href="#topic+create_Pies">create_Pies</a></code>, <code><a href="#topic+add_col">add_col</a></code>,
<code><a href="#topic+add_Cscale">add_Cscale</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#create-grids
# And:
# https://github.com/ccamlr/CCAMLRGIS/blob/master/Advanced_Grids/Advanced_Grids.md

#Simple grid, using automatic colors

MyGrid=create_PolyGrids(Input=GridData,dlon=2,dlat=1)
#View(MyGrid)
plot(st_geometry(MyGrid),col=MyGrid$Col_Catch_sum)




</code></pre>

<hr>
<h2 id='create_Polys'>Create Polygons</h2><span id='topic+create_Polys'></span>

<h3>Description</h3>

<p>Create Polygons such as proposed Research Blocks or Marine Protected Areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_Polys(
  Input,
  NamesIn = NULL,
  Buffer = 0,
  Densify = TRUE,
  Clip = FALSE,
  SeparateBuf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_Polys_+3A_input">Input</code></td>
<td>
<p>input dataframe.
</p>
<p>If <code>NamesIn</code> is not provided, the columns in the <code>Input</code> must be in the following order:
</p>
<p>Polygon name, Latitude, Longitude.
</p>
<p>Latitudes and Longitudes must be given clockwise.</p>
</td></tr>
<tr><td><code id="create_Polys_+3A_namesin">NamesIn</code></td>
<td>
<p>character vector of length 3 specifying the column names of polygon identifier, Latitude
and Longitude fields in the <code>Input</code>.
</p>
<p>Names must be given in that order, e.g.:
</p>
<p><code>NamesIn=c('Polygon ID','Poly Latitudes','Poly Longitudes')</code>.</p>
</td></tr>
<tr><td><code id="create_Polys_+3A_buffer">Buffer</code></td>
<td>
<p>numeric, distance in nautical miles by which to expand the polygons. Can be specified for
each polygon (as a numeric vector).</p>
</td></tr>
<tr><td><code id="create_Polys_+3A_densify">Densify</code></td>
<td>
<p>logical, if set to TRUE, additional points between extremities of lines spanning more
than 0.1 degree longitude are added at every 0.1 degree of longitude prior to projection
(compare examples 1 and 2 below).</p>
</td></tr>
<tr><td><code id="create_Polys_+3A_clip">Clip</code></td>
<td>
<p>logical, if set to TRUE, polygon parts that fall on land are removed (see <a href="#topic+Clip2Coast">Clip2Coast</a>).</p>
</td></tr>
<tr><td><code id="create_Polys_+3A_separatebuf">SeparateBuf</code></td>
<td>
<p>logical, if set to FALSE when adding a <code>Buffer</code>,
all spatial objects are merged, resulting in a single spatial object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment.
Data within the resulting spatial object contains the data provided in the <code>Input</code> after aggregation
within polygons. For each numeric variable, the minimum, maximum, mean, sum, count, standard deviation, and, 
median of values in each polygon is returned. In addition, for each polygon, its area (AreaKm2) and projected 
centroid (Labx, Laby) are given (which may be used to add labels to polygons).
</p>
<p>To see the data contained in your spatial object, type: <code>View(MyPolygons)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Points">create_Points</a></code>, <code><a href="#topic+create_Lines">create_Lines</a></code>, <code><a href="#topic+create_PolyGrids">create_PolyGrids</a></code>,
<code><a href="#topic+create_Stations">create_Stations</a></code>, <code><a href="#topic+add_RefGrid">add_RefGrid</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#create-polygons


#Densified polygons (note the curvature of lines)

MyPolys=create_Polys(Input=PolyData)
plot(st_geometry(MyPolys),col='red')
text(MyPolys$Labx,MyPolys$Laby,MyPolys$ID,col='white')




</code></pre>

<hr>
<h2 id='create_Stations'>Create Stations</h2><span id='topic+create_Stations'></span>

<h3>Description</h3>

<p>Create random point locations inside a polygon and within bathymetry strata constraints.
A distance constraint between stations may also be used if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_Stations(
  Poly,
  Bathy,
  Depths,
  N = NA,
  Nauto = NA,
  dist = NA,
  Buf = 1000,
  ShowProgress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_Stations_+3A_poly">Poly</code></td>
<td>
<p>single polygon inside which stations will be generated. May be created using <code><a href="#topic+create_Polys">create_Polys</a></code>.</p>
</td></tr>
<tr><td><code id="create_Stations_+3A_bathy">Bathy</code></td>
<td>
<p>bathymetry raster with the appropriate <code><a href="#topic+CCAMLRp">projection</a></code>, such as <code><a href="#topic+SmallBathy">this one</a></code>.</p>
</td></tr>
<tr><td><code id="create_Stations_+3A_depths">Depths</code></td>
<td>
<p>numeric, vector of depths. For example, if the depth strata required are 600 to 1000 and 1000 to 2000,
<code>Depths=c(-600,-1000,-2000)</code>.</p>
</td></tr>
<tr><td><code id="create_Stations_+3A_n">N</code></td>
<td>
<p>numeric, vector of number of stations required in each depth strata,
therefore <code>length(N)</code> must equal <code>length(Depths)-1</code>.</p>
</td></tr>
<tr><td><code id="create_Stations_+3A_nauto">Nauto</code></td>
<td>
<p>numeric, instead of specifying <code>N</code>, a number of stations proportional to the areas of the depth strata
may be created. <code>Nauto</code> is the maximum number of stations required in any depth stratum.</p>
</td></tr>
<tr><td><code id="create_Stations_+3A_dist">dist</code></td>
<td>
<p>numeric, if desired, a distance constraint in nautical miles may be applied. For example, if <code>dist=2</code>,
stations will be at least 2 nautical miles apart.</p>
</td></tr>
<tr><td><code id="create_Stations_+3A_buf">Buf</code></td>
<td>
<p>numeric, distance in meters from isobaths. Useful to avoid stations falling on strata boundaries.</p>
</td></tr>
<tr><td><code id="create_Stations_+3A_showprogress">ShowProgress</code></td>
<td>
<p>logical, if set to <code>TRUE</code>, a progress bar is shown (<code>create_Stations</code> may take a while).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment. Data within the resulting object contains the strata and stations
locations in both projected space (&quot;x&quot; and &quot;y&quot;) and decimal degrees of Latitude/Longitude.
</p>
<p>To see the data contained in your spatial object, type: <code>View(MyStations)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Polys">create_Polys</a></code>, <code><a href="#topic+SmallBathy">SmallBathy</a></code>, <code><a href="#topic+add_Legend">add_Legend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#22-create-stations

#First, create a polygon within which stations will be created
MyPoly=create_Polys(
 data.frame(Name="mypol",
            Latitude=c(-75,-75,-70,-70),
            Longitude=c(-170,-180,-180,-170))
 ,Densify=TRUE)

par(mai=c(0,0,0,0))
plot(st_geometry(Coast[Coast$ID=='88.1',]),col='grey')
plot(st_geometry(MyPoly),col='green',add=TRUE)
text(MyPoly$Labx,MyPoly$Laby,MyPoly$ID)

#Create a set numbers of stations, without distance constraint:
library(terra)
#optional: crop your bathymetry raster to match the extent of your polygon
BathyCroped=crop(SmallBathy(),ext(MyPoly))

#Create stations
MyStations=create_Stations(MyPoly,BathyCroped,Depths=c(-2000,-1500,-1000,-550),N=c(20,15,10))

#add custom colors to the bathymetry to indicate the strata of interest
MyCols=add_col(var=c(-10000,10000),cuts=c(-2000,-1500,-1000,-550),cols=c('blue','cyan'))
plot(BathyCroped,breaks=MyCols$cuts,col=MyCols$cols,legend=FALSE,axes=FALSE)
add_Cscale(height=90,fontsize=0.75,width=16,lwd=0.5,
offset=-130,cuts=MyCols$cuts,cols=MyCols$cols)
plot(st_geometry(MyPoly),add=TRUE,border='red',lwd=2,xpd=TRUE)
plot(st_geometry(MyStations),add=TRUE,col='orange',cex=0.75,lwd=1.5,pch=3)




</code></pre>

<hr>
<h2 id='Depth_cols'>Bathymetry colors</h2><span id='topic+Depth_cols'></span>

<h3>Description</h3>

<p>Set of standard colors to plot bathymetry, to be used in conjunction with <a href="#topic+Depth_cuts">Depth_cuts</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Depth_cols)
</code></pre>


<h3>Format</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Depth_cols2">Depth_cols2</a></code>, <code><a href="#topic+add_col">add_col</a></code>, <code><a href="#topic+add_Cscale">add_Cscale</a></code>, <code><a href="#topic+SmallBathy">SmallBathy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>terra::plot(SmallBathy(),breaks=Depth_cuts,col=Depth_cols,axes=FALSE)
</code></pre>

<hr>
<h2 id='Depth_cols2'>Bathymetry colors with Fishable Depth range</h2><span id='topic+Depth_cols2'></span>

<h3>Description</h3>

<p>Set of colors to plot bathymetry and highlight Fishable Depth range (600-1800), to be used in conjunction with <a href="#topic+Depth_cuts2">Depth_cuts2</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Depth_cols2)
</code></pre>


<h3>Format</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Depth_cols">Depth_cols</a></code>, <code><a href="#topic+add_col">add_col</a></code>, <code><a href="#topic+add_Cscale">add_Cscale</a></code>, <code><a href="#topic+SmallBathy">SmallBathy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>terra::plot(SmallBathy(),breaks=Depth_cuts2,col=Depth_cols2,axes=FALSE,box=FALSE)
</code></pre>

<hr>
<h2 id='Depth_cuts'>Bathymetry depth classes</h2><span id='topic+Depth_cuts'></span>

<h3>Description</h3>

<p>Set of depth classes to plot bathymetry, to be used in conjunction with <a href="#topic+Depth_cols">Depth_cols</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Depth_cuts)
</code></pre>


<h3>Format</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Depth_cuts2">Depth_cuts2</a></code>, <code><a href="#topic+add_col">add_col</a></code>, <code><a href="#topic+add_Cscale">add_Cscale</a></code>, <code><a href="#topic+SmallBathy">SmallBathy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>terra::plot(SmallBathy(),breaks=Depth_cuts,col=Depth_cols,axes=FALSE,box=FALSE)
</code></pre>

<hr>
<h2 id='Depth_cuts2'>Bathymetry depth classes with Fishable Depth range</h2><span id='topic+Depth_cuts2'></span>

<h3>Description</h3>

<p>Set of depth classes to plot bathymetry and highlight Fishable Depth range (600-1800), to be used in conjunction with <a href="#topic+Depth_cols2">Depth_cols2</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Depth_cuts2)
</code></pre>


<h3>Format</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Depth_cuts">Depth_cuts</a></code>, <code><a href="#topic+add_col">add_col</a></code>, <code><a href="#topic+add_Cscale">add_Cscale</a></code>, <code><a href="#topic+SmallBathy">SmallBathy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>terra::plot(SmallBathy(),breaks=Depth_cuts2,col=Depth_cols2,axes=FALSE,box=FALSE)
</code></pre>

<hr>
<h2 id='get_C_intersection'>Get Cartesian coordinates of lines intersection in Euclidean space</h2><span id='topic+get_C_intersection'></span>

<h3>Description</h3>

<p>Given two lines defined by the Latitudes/Longitudes of their extremities, finds the location of their 
intersection, in Euclidean space, using 
this approach: <a href="https://en.wikipedia.org/wiki/Line-line_intersection">https://en.wikipedia.org/wiki/Line-line_intersection</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_C_intersection(Line1, Line2, Plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_C_intersection_+3A_line1">Line1</code></td>
<td>
<p>Vector of 4 coordinates, given in decimal degrees as: 
</p>
<p><code>c(Longitude_start,Latitude_start,Longitude_end,Latitude_end)</code>.</p>
</td></tr>
<tr><td><code id="get_C_intersection_+3A_line2">Line2</code></td>
<td>
<p>Same as <code>Line1</code>.</p>
</td></tr>
<tr><td><code id="get_C_intersection_+3A_plot">Plot</code></td>
<td>
<p>logical, if set to TRUE, plots a schematic of calculations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>


#Example 1 (Intersection beyond the range of segments)
get_C_intersection(Line1=c(-30,-55,-29,-50),Line2=c(-50,-60,-40,-60))

#Example 2 (Intersection on one of the segments)
get_C_intersection(Line1=c(-30,-65,-29,-50),Line2=c(-50,-60,-40,-60))

#Example 3 (Crossed segments)
get_C_intersection(Line1=c(-30,-65,-29,-50),Line2=c(-50,-60,-25,-60))

#Example 4 (Antimeridian crossed)
get_C_intersection(Line1=c(-179,-60,-150,-50),Line2=c(-120,-60,-130,-62))

#Example 5 (Parallel lines - uncomment to test as it will return an error)
#get_C_intersection(Line1=c(0,-60,10,-60),Line2=c(-10,-60,10,-60))




</code></pre>

<hr>
<h2 id='get_depths'>Get depths of locations from a bathymetry raster</h2><span id='topic+get_depths'></span>

<h3>Description</h3>

<p>Given a bathymetry raster and an input dataframe of point locations (given in decimal degrees),
computes the depths at these locations (values for the cell each point falls in). The accuracy is
dependent on the resolution of the bathymetry raster (see <code><a href="#topic+load_Bathy">load_Bathy</a></code> to get high resolution data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_depths(Input, Bathy, NamesIn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_depths_+3A_input">Input</code></td>
<td>
<p>dataframe with, at least, Latitudes and Longitudes.
If <code>NamesIn</code> is not provided, the columns in the <code>Input</code> must be in the following order:
</p>
<p>Latitude, Longitude, Variable 1, Variable 2, ... Variable x.</p>
</td></tr>
<tr><td><code id="get_depths_+3A_bathy">Bathy</code></td>
<td>
<p>bathymetry raster with the appropriate <code><a href="#topic+CCAMLRp">projection</a></code>,
such as <code><a href="#topic+SmallBathy">this one</a></code>. It is highly recommended to use a raster of higher
resolution than <code><a href="#topic+SmallBathy">SmallBathy</a></code> (see <code><a href="#topic+load_Bathy">load_Bathy</a></code>).</p>
</td></tr>
<tr><td><code id="get_depths_+3A_namesin">NamesIn</code></td>
<td>
<p>character vector of length 2 specifying the column names of Latitude and Longitude fields in
the <code>Input</code>. Latitudes name must be given first, e.g.:
</p>
<p><code>NamesIn=c('MyLatitudes','MyLongitudes')</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with the same structure as the <code>Input</code> with an additional depth column <code>'d'</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_Bathy">load_Bathy</a></code>, <code><a href="#topic+create_Points">create_Points</a></code>,
<code><a href="#topic+create_Stations">create_Stations</a></code>, <code><a href="#topic+get_iso_polys">get_iso_polys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Generate a dataframe
MyData=data.frame(Lat=PointData$Lat,
Lon=PointData$Lon,
Catch=PointData$Catch)

#get depths of locations
MyDataD=get_depths(Input=MyData,Bathy=SmallBathy())
#View(MyDataD)
plot(MyDataD$d,MyDataD$Catch,xlab='Depth',ylab='Catch',pch=21,bg='blue')



</code></pre>

<hr>
<h2 id='get_iso_polys'>Generate contour polygons from raster</h2><span id='topic+get_iso_polys'></span>

<h3>Description</h3>

<p>From an input raster and chosen cuts (classes), turns areas between contours into polygons.
An input polygon may optionally be given to constrain boundaries.
The accuracy is dependent on the resolution of the raster
(e.g., see <code><a href="#topic+load_Bathy">load_Bathy</a></code> to get high resolution bathymetry).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_iso_polys(
  Rast,
  Poly = NULL,
  Cuts,
  Cols = c("green", "yellow", "red"),
  Grp = FALSE,
  strict = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_iso_polys_+3A_rast">Rast</code></td>
<td>
<p>raster with the appropriate projection, such as
<code><a href="#topic+SmallBathy">SmallBathy</a></code>.
It is recommended to use a raster of higher resolution (see <code><a href="#topic+load_Bathy">load_Bathy</a></code>).</p>
</td></tr>
<tr><td><code id="get_iso_polys_+3A_poly">Poly</code></td>
<td>
<p>optional, single polygon inside which contour polygons will be generated.
May be created using <code><a href="#topic+create_Polys">create_Polys</a></code> or by subsetting an object obtained
using one of the <code>load_</code> functions.</p>
</td></tr>
<tr><td><code id="get_iso_polys_+3A_cuts">Cuts</code></td>
<td>
<p>numeric, vector of desired contours. For example,
<code>Cuts=c(-2000,-1000,-500)</code>.</p>
</td></tr>
<tr><td><code id="get_iso_polys_+3A_cols">Cols</code></td>
<td>
<p>character, vector of desired colors (see <code><a href="#topic+add_col">add_col</a></code>).</p>
</td></tr>
<tr><td><code id="get_iso_polys_+3A_grp">Grp</code></td>
<td>
<p>logical (TRUE/FALSE), if set to TRUE (slower), contour polygons that touch each other are
identified and grouped (a Grp column is added to the object). This can be used, for example, to
identify seamounts that are constituted of several isobaths.</p>
</td></tr>
<tr><td><code id="get_iso_polys_+3A_strict">strict</code></td>
<td>
<p>logical (TRUE/FALSE), if set to TRUE (default) polygons are created only between the
chosen <code>Cuts</code>. If set to FALSE, extra polygons are created beyond the bounds of <code>Cuts</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment. Data within the resulting object contains
a polygon in each row. Columns are as follows: <code>ID</code> is a unique polygon identifier;
<code>Iso</code> is a contour polygon identifier; <code>Min</code> and <code>Max</code> are the range of contour values;
<code>c</code> is the color of each contour polygon; if <code>Grp</code> was set to TRUE, additional columns are:
<code>Grp</code> is a group identifier (e.g., a seamount constituted of several isobaths); 
<code>AreaKm2</code> is the polygon area in square kilometers; <code>Labx</code> and <code>Laby</code> can be used
to label groups (see GitHub example).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_Bathy">load_Bathy</a></code>, <code><a href="#topic+create_Polys">create_Polys</a></code>, <code><a href="#topic+get_depths">get_depths</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#46-get_iso_polys

Poly=create_Polys(Input=data.frame(ID=1,Lat=c(-55,-55,-61,-61),Lon=c(-30,-25,-25,-30)))
IsoPols=get_iso_polys(Rast=SmallBathy(),Poly=Poly,Cuts=seq(-8000,0,length.out=10),Cols=rainbow(9))

plot(st_geometry(Poly))
plot(st_geometry(IsoPols),col=IsoPols$c,add=TRUE) 


</code></pre>

<hr>
<h2 id='GridData'>Example dataset for create_PolyGrids</h2><span id='topic+GridData'></span>

<h3>Description</h3>

<p>To be used in conjunction with <a href="#topic+create_PolyGrids">create_PolyGrids</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GridData)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_PolyGrids">create_PolyGrids</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#View(GridData)

MyGrid=create_PolyGrids(Input=GridData,dlon=2,dlat=1)
plot(st_geometry(MyGrid),col=MyGrid$Col_Catch_sum)
</code></pre>

<hr>
<h2 id='Labels'>Polygon labels</h2><span id='topic+Labels'></span>

<h3>Description</h3>

<p>Labels for the layers obtained via 'load_' functions. Positions correspond to the centroids
of polygon parts. Can be used in conjunction with <code><a href="#topic+add_labels">add_labels</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Labels)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_labels">add_labels</a></code>, <code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_SSRUs">load_SSRUs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_MAs">load_MAs</a></code>, <code><a href="#topic+load_EEZs">load_EEZs</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


#View(Labels)

ASDs=load_ASDs()
plot(st_geometry(ASDs))
add_labels(mode='auto',layer='ASDs',fontsize=1,fonttype=2)




</code></pre>

<hr>
<h2 id='LineData'>Example dataset for create_Lines</h2><span id='topic+LineData'></span>

<h3>Description</h3>

<p>To be used in conjunction with <a href="#topic+create_Lines">create_Lines</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LineData)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Lines">create_Lines</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
#View(LineData)

MyLines=create_Lines(LineData)
plot(st_geometry(MyLines),lwd=2,col=rainbow(5))
</code></pre>

<hr>
<h2 id='load_ASDs'>Load CCAMLR statistical Areas, Subareas and Divisions</h2><span id='topic+load_ASDs'></span>

<h3>Description</h3>

<p>Download the up-to-date spatial layer from the online CCAMLRGIS (<a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>) and load it to your environment.
See examples for offline use. All layers use the Lambert azimuthal equal-area projection
(<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_ASDs()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+load_SSRUs">load_SSRUs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_MAs">load_MAs</a></code>, <code><a href="#topic+load_Coastline">load_Coastline</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>, <code><a href="#topic+load_EEZs">load_EEZs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


#When online:
ASDs=load_ASDs()
plot(st_geometry(ASDs))

#For offline use, see:
#https://github.com/ccamlr/CCAMLRGIS#32-offline-use



</code></pre>

<hr>
<h2 id='load_Bathy'>Load Bathymetry data</h2><span id='topic+load_Bathy'></span>

<h3>Description</h3>

<p>Download the up-to-date projected GEBCO data from the online CCAMLRGIS (<a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>) and load it to your environment.
This functions can be used in two steps, to first download the data and then use it. If you keep the downloaded data, you can then
re-use it in all your scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_Bathy(LocalFile, Res = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_Bathy_+3A_localfile">LocalFile</code></td>
<td>
<p>To download the data, set to <code>FALSE</code>. To re-use a downloaded file, set to the full path of the file 
(e.g., <code>LocalFile="C:/Desktop/GEBCO2023_5000.tif"</code>).</p>
</td></tr>
<tr><td><code id="load_Bathy_+3A_res">Res</code></td>
<td>
<p>Desired resolution in meters. May only be one of: 500, 1000, 2500 or 5000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To download the data, you must either have set your working directory using <code><a href="base.html#topic+setwd">setwd</a></code>, or be working within an Rproject.
In any case, your file will be downloaded to the folder path given by <code><a href="base.html#topic+getwd">getwd</a></code>.
</p>
<p>It is strongly recommended to first download the lowest resolution data (set <code>Res=5000</code>) to ensure it is working as expected.
</p>
<p>To re-use the downloaded data, you must provide the full path to that file, for example:
</p>
<p><code>LocalFile="C:/Desktop/GEBCO2023_5000.tif"</code>.
</p>
<p>This data was reprojected from the original GEBCO Grid after cropping at 40 degrees South. Projection was made using the Lambert
azimuthal equal-area projection (<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>),
and the data was aggregated at several resolutions.
</p>


<h3>Value</h3>

<p>Bathymetry raster.
</p>


<h3>References</h3>

<p>GEBCO Compilation Group (2023) GEBCO 2023 Grid (doi:10.5285/f98b053b-0cbc-6c23-e053-6c86abc0af7b)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_col">add_col</a></code>, <code><a href="#topic+add_Cscale">add_Cscale</a></code>, <code><a href="#topic+Depth_cols">Depth_cols</a></code>, <code><a href="#topic+Depth_cuts">Depth_cuts</a></code>,
<code><a href="#topic+Depth_cols2">Depth_cols2</a></code>, <code><a href="#topic+Depth_cuts2">Depth_cuts2</a></code>, <code><a href="#topic+get_depths">get_depths</a></code>,
<code><a href="#topic+create_Stations">create_Stations</a></code>, <code><a href="#topic+get_iso_polys">get_iso_polys</a></code>,
<code><a href="#topic+SmallBathy">SmallBathy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


#The examples below are commented. To test, remove the '#'.

##Download the data. It will go in the folder given by getwd():
#Bathy=load_Bathy(LocalFile = FALSE,Res=5000)
#plot(Bathy, breaks=Depth_cuts,col=Depth_cols,axes=FALSE)

##Re-use the downloaded data (provided it's here: "C:/Desktop/GEBCO2023_5000.tif"):
#Bathy=load_Bathy(LocalFile = "C:/Desktop/GEBCO2023_5000.tif")
#plot(Bathy, breaks=Depth_cuts,col=Depth_cols,axes=FALSE)



</code></pre>

<hr>
<h2 id='load_Coastline'>Load the full CCAMLR Coastline</h2><span id='topic+load_Coastline'></span>

<h3>Description</h3>

<p>Download the up-to-date spatial layer from the online CCAMLRGIS (<a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>) and load it to your environment.
See examples for offline use. All layers use the Lambert azimuthal equal-area projection
(<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>).
Note that this coastline expands further north than <a href="#topic+Coast">Coast</a>.
Sources: UK Polar Data Centre/BAS and Natural Earth. Projection: EPSG 6932.
More details here: <a href="https://github.com/ccamlr/geospatial_operations">https://github.com/ccamlr/geospatial_operations</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_Coastline()
</code></pre>


<h3>References</h3>

<p>UK Polar Data Centre/BAS and Natural Earth.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_SSRUs">load_SSRUs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_MAs">load_MAs</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>, <code><a href="#topic+load_EEZs">load_EEZs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


#When online:
Coastline=load_Coastline()
plot(st_geometry(Coastline))

#For offline use, see:
#https://github.com/ccamlr/CCAMLRGIS#32-offline-use



</code></pre>

<hr>
<h2 id='load_EEZs'>Load Exclusive Economic Zones</h2><span id='topic+load_EEZs'></span>

<h3>Description</h3>

<p>Download the up-to-date spatial layer from the online CCAMLRGIS (<a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>) and load it to your environment.
See examples for offline use. All layers use the Lambert azimuthal equal-area projection
(<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_EEZs()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_SSRUs">load_SSRUs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_MAs">load_MAs</a></code>, <code><a href="#topic+load_Coastline">load_Coastline</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


#When online:
EEZs=load_EEZs()
plot(st_geometry(EEZs))

#For offline use, see:
#https://github.com/ccamlr/CCAMLRGIS#32-offline-use



</code></pre>

<hr>
<h2 id='load_MAs'>Load CCAMLR Management Areas</h2><span id='topic+load_MAs'></span>

<h3>Description</h3>

<p>Download the up-to-date spatial layer from the online CCAMLRGIS (<a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>) and load it to your environment.
See examples for offline use. All layers use the Lambert azimuthal equal-area projection
(<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_MAs()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_SSRUs">load_SSRUs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_Coastline">load_Coastline</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>, <code><a href="#topic+load_EEZs">load_EEZs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


#When online:
MAs=load_MAs()
plot(st_geometry(MAs))

#For offline use, see:
#https://github.com/ccamlr/CCAMLRGIS#32-offline-use



</code></pre>

<hr>
<h2 id='load_MPAs'>Load CCAMLR Marine Protected Areas</h2><span id='topic+load_MPAs'></span>

<h3>Description</h3>

<p>Download the up-to-date spatial layer from the online CCAMLRGIS (<a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>) and load it to your environment.
See examples for offline use. All layers use the Lambert azimuthal equal-area projection
(<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_MPAs()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_SSRUs">load_SSRUs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_MAs">load_MAs</a></code>, <code><a href="#topic+load_Coastline">load_Coastline</a></code>,
<code><a href="#topic+load_EEZs">load_EEZs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


#When online:
MPAs=load_MPAs()
plot(st_geometry(MPAs))

#For offline use, see:
#https://github.com/ccamlr/CCAMLRGIS#32-offline-use



</code></pre>

<hr>
<h2 id='load_RBs'>Load CCAMLR Research Blocks</h2><span id='topic+load_RBs'></span>

<h3>Description</h3>

<p>Download the up-to-date spatial layer from the online CCAMLRGIS (<a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>) and load it to your environment.
See examples for offline use. All layers use the Lambert azimuthal equal-area projection
(<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_RBs()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_SSRUs">load_SSRUs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_MAs">load_MAs</a></code>, <code><a href="#topic+load_Coastline">load_Coastline</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>, <code><a href="#topic+load_EEZs">load_EEZs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


#When online:
RBs=load_RBs()
plot(st_geometry(RBs))

#For offline use, see:
#https://github.com/ccamlr/CCAMLRGIS#32-offline-use



</code></pre>

<hr>
<h2 id='load_SSMUs'>Load CCAMLR Small Scale Management Units</h2><span id='topic+load_SSMUs'></span>

<h3>Description</h3>

<p>Download the up-to-date spatial layer from the online CCAMLRGIS (<a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>) and load it to your environment.
See examples for offline use. All layers use the Lambert azimuthal equal-area projection
(<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_SSMUs()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_SSRUs">load_SSRUs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_MAs">load_MAs</a></code>, <code><a href="#topic+load_Coastline">load_Coastline</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>, <code><a href="#topic+load_EEZs">load_EEZs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


#When online:
SSMUs=load_SSMUs()
plot(st_geometry(SSMUs))

#For offline use, see:
#https://github.com/ccamlr/CCAMLRGIS#32-offline-use



</code></pre>

<hr>
<h2 id='load_SSRUs'>Load CCAMLR Small Scale Research Units</h2><span id='topic+load_SSRUs'></span>

<h3>Description</h3>

<p>Download the up-to-date spatial layer from the online CCAMLRGIS (<a href="http://gis.ccamlr.org/">http://gis.ccamlr.org/</a>) and load it to your environment.
See examples for offline use. All layers use the Lambert azimuthal equal-area projection
(<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_SSRUs()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+load_ASDs">load_ASDs</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>,
<code><a href="#topic+load_SSMUs">load_SSMUs</a></code>, <code><a href="#topic+load_MAs">load_MAs</a></code>, <code><a href="#topic+load_Coastline">load_Coastline</a></code>,
<code><a href="#topic+load_MPAs">load_MPAs</a></code>, <code><a href="#topic+load_EEZs">load_EEZs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 


#When online:
SSRUs=load_SSRUs()
plot(st_geometry(SSRUs))

#For offline use, see:
#https://github.com/ccamlr/CCAMLRGIS#32-offline-use



</code></pre>

<hr>
<h2 id='PieData'>Example dataset for create_Pies</h2><span id='topic+PieData'></span>

<h3>Description</h3>

<p>To be used in conjunction with <a href="#topic+create_Pies">create_Pies</a>. Count and catch of species per location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PieData)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Pies">create_Pies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#View(PieData)

#Create pies
MyPies=create_Pies(Input=PieData,
                   NamesIn=c("Lat","Lon","Sp","N"),
                   Size=50
)
#Plot Pies
plot(st_geometry(MyPies),col=MyPies$col)
#Add Pies legend
add_PieLegend(Pies=MyPies,PosX=-0.1,PosY=-1.6,Boxexp=c(0.5,0.45,0.12,0.45),
              PieTitle="Species")

</code></pre>

<hr>
<h2 id='PieData2'>Example dataset for create_Pies</h2><span id='topic+PieData2'></span>

<h3>Description</h3>

<p>To be used in conjunction with <a href="#topic+create_Pies">create_Pies</a>. Count and catch of species per location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PieData2)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Pies">create_Pies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#View(PieData2)

MyPies=create_Pies(Input=PieData2,
                  NamesIn=c("Lat","Lon","Sp","N"),
                  Size=5,
                  GridKm=250
)
#Plot Pies
plot(st_geometry(MyPies),col=MyPies$col)
#Add Pies legend
add_PieLegend(Pies=MyPies,PosX=-0.8,PosY=-0.3,Boxexp=c(0.5,0.45,0.12,0.45),
             PieTitle="Species")

</code></pre>

<hr>
<h2 id='PointData'>Example dataset for create_Points</h2><span id='topic+PointData'></span>

<h3>Description</h3>

<p>To be used in conjunction with <a href="#topic+create_Points">create_Points</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PointData)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Points">create_Points</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#View(PointData)

MyPoints=create_Points(PointData)
plot(st_geometry(MyPoints))
text(MyPoints$x,MyPoints$y,MyPoints$name,adj=c(0.5,-0.5),xpd=TRUE)
plot(st_geometry(MyPoints[MyPoints$name=='four',]),bg='red',pch=21,cex=1.5,add=TRUE)
</code></pre>

<hr>
<h2 id='PolyData'>Example dataset for create_Polys</h2><span id='topic+PolyData'></span>

<h3>Description</h3>

<p>To be used in conjunction with <a href="#topic+create_Polys">create_Polys</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PolyData)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Polys">create_Polys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#View(PolyData)

MyPolys=create_Polys(PolyData,Densify=TRUE)
plot(st_geometry(MyPolys),col='green')
text(MyPolys$Labx,MyPolys$Laby,MyPolys$ID)
plot(st_geometry(MyPolys[MyPolys$ID=='three',]),border='red',lwd=3,add=TRUE)
</code></pre>

<hr>
<h2 id='project_data'>Project user-supplied locations</h2><span id='topic+project_data'></span>

<h3>Description</h3>

<p>Given an input dataframe containing locations given in decimal degrees or meters (if projected),
projects these locations and, if desired, appends them to the input dataframe.
May also be used to back-project to Latitudes/Longitudes provided the input was projected
using a Lambert azimuthal equal-area projection (<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_data(
  Input,
  NamesIn = NULL,
  NamesOut = NULL,
  append = TRUE,
  inv = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_data_+3A_input">Input</code></td>
<td>
<p>dataframe containing - at the minimum - Latitudes and Longitudes to be projected (or Y and X to be back-projected).</p>
</td></tr>
<tr><td><code id="project_data_+3A_namesin">NamesIn</code></td>
<td>
<p>character vector of length 2 specifying the column names of Latitude and Longitude fields in
the <code>Input</code>. Latitudes (or Y) name must be given first, e.g.:
</p>
<p><code>NamesIn=c('MyLatitudes','MyLongitudes')</code>.</p>
</td></tr>
<tr><td><code id="project_data_+3A_namesout">NamesOut</code></td>
<td>
<p>character vector of length 2, optional. Names of the resulting columns in the output dataframe,
with order matching that of <code>NamesIn</code> (e.g., <code>NamesOut=c('Y','X')</code>).</p>
</td></tr>
<tr><td><code id="project_data_+3A_append">append</code></td>
<td>
<p>logical (T/F). Should the projected locations be appended to the <code>Input</code>?</p>
</td></tr>
<tr><td><code id="project_data_+3A_inv">inv</code></td>
<td>
<p>logical (T/F). Should a back-projection be performed? In such case, locations must be given in meters
and have been projected using a Lambert azimuthal equal-area projection (<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+assign_areas">assign_areas</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Generate a dataframe
MyData=data.frame(Lat=runif(100,min=-65,max=-50),
                  Lon=runif(100,min=20,max=40))

#Project data using a Lambert azimuthal equal-area projection
MyData=project_data(Input=MyData,NamesIn=c("Lat","Lon"))
#View(MyData)

</code></pre>

<hr>
<h2 id='Rotate_obj'>Rotate object</h2><span id='topic+Rotate_obj'></span>

<h3>Description</h3>

<p>Rotate a spatial object by setting the longitude that should point up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rotate_obj(Input, Lon0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotate_obj_+3A_input">Input</code></td>
<td>
<p>Spatial object of class <code>sf</code>, <code>sfc</code> or <code>SpatRaster (terra)</code>.</p>
</td></tr>
<tr><td><code id="Rotate_obj_+3A_lon0">Lon0</code></td>
<td>
<p>numeric, longitude that will point up in the resulting map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spatial object in your environment to only be used for plotting, not for analysis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_Points">create_Points</a></code>, <code><a href="#topic+create_Lines">create_Lines</a></code>, <code><a href="#topic+create_Polys">create_Polys</a></code>,
<code><a href="#topic+create_PolyGrids">create_PolyGrids</a></code>, <code><a href="#topic+create_Stations">create_Stations</a></code>, <code><a href="#topic+create_Pies">create_Pies</a></code>,
<code><a href="#topic+create_Arrow">create_Arrow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For more examples, see:
# https://github.com/ccamlr/CCAMLRGIS#47-rotate_obj
# and:
# https://github.com/ccamlr/CCAMLRGIS/blob/master/Basemaps/Basemaps.md

RotB=Rotate_obj(SmallBathy(),Lon0=-180)
terra::plot(RotB,breaks=Depth_cuts,col=Depth_cols,axes=FALSE,box=FALSE,legend=FALSE)
add_RefGrid(bb=st_bbox(RotB),ResLat=10,ResLon=20,LabLon = -180,offset = 3)

</code></pre>

<hr>
<h2 id='seabed_area'>Calculate planimetric seabed area</h2><span id='topic+seabed_area'></span>

<h3>Description</h3>

<p>Calculate planimetric seabed area within polygons and depth strata in square kilometers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seabed_area(Bathy, Poly, PolyNames = NULL, depth_classes = c(-600, -1800))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seabed_area_+3A_bathy">Bathy</code></td>
<td>
<p>bathymetry raster with the appropriate <code><a href="#topic+CCAMLRp">projection</a></code>.
It is highly recommended to use a raster of higher
resolution than <code><a href="#topic+SmallBathy">SmallBathy</a></code>, see <code><a href="#topic+load_Bathy">load_Bathy</a></code>.</p>
</td></tr>
<tr><td><code id="seabed_area_+3A_poly">Poly</code></td>
<td>
<p>polygon(s) within which the areas of depth strata are computed.</p>
</td></tr>
<tr><td><code id="seabed_area_+3A_polynames">PolyNames</code></td>
<td>
<p>character, column name (from the polygon object) to be used in the output.</p>
</td></tr>
<tr><td><code id="seabed_area_+3A_depth_classes">depth_classes</code></td>
<td>
<p>numeric vector of strata depths. for example, <code>depth_classes=c(-600,-1000,-2000)</code>.
If the values <code>-600,-1800</code> are given within <code>depth_classes</code>, the computed area will be labelled as 'Fishable_area'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with the name of polygons in the first column and the area for each strata in the following columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_Bathy">load_Bathy</a></code>, <code><a href="#topic+SmallBathy">SmallBathy</a></code>, <code><a href="#topic+create_Polys">create_Polys</a></code>, <code><a href="#topic+load_RBs">load_RBs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#create some polygons
MyPolys=create_Polys(PolyData,Densify=TRUE)
#compute the seabed areas
FishDepth=seabed_area(SmallBathy(),MyPolys,PolyNames="ID",
depth_classes=c(0,-200,-600,-1800,-3000,-5000))
#Result looks like this (note that the 600-1800 stratum is renamed 'Fishable_area')
#View(FishDepth)




</code></pre>

<hr>
<h2 id='SmallBathy'>Small bathymetry dataset</h2><span id='topic+SmallBathy'></span>

<h3>Description</h3>

<p>Bathymetry dataset derived from the GEBCO 2023 (see <a href="https://www.gebco.net/">https://www.gebco.net/</a>) dataset.
Subsampled at a 10,000m resolution. Projected using the CCAMLR standard projection (<code><a href="#topic+CCAMLRp">CCAMLRp</a></code>).
To highlight the Fishable Depth range, use <code><a href="#topic+Depth_cols2">Depth_cols2</a></code> and <code><a href="#topic+Depth_cuts2">Depth_cuts2</a></code>.
To be only used for large scale illustrative purposes. Please refer to <code><a href="#topic+load_Bathy">load_Bathy</a></code>
to get higher resolution data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SmallBathy()
</code></pre>


<h3>Format</h3>

<p>raster
</p>


<h3>References</h3>

<p>GEBCO Compilation Group (2023) GEBCO 2023 Grid (doi:10.5285/f98b053b-0cbc-6c23-e053-6c86abc0af7b)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_Bathy">load_Bathy</a></code>, <code><a href="#topic+add_col">add_col</a></code>, <code><a href="#topic+add_Cscale">add_Cscale</a></code>, <code><a href="#topic+Depth_cols">Depth_cols</a></code>,
<code><a href="#topic+Depth_cuts">Depth_cuts</a></code>,
<code><a href="#topic+Depth_cols2">Depth_cols2</a></code>, <code><a href="#topic+Depth_cuts2">Depth_cuts2</a></code>, <code><a href="#topic+get_depths">get_depths</a></code>, <code><a href="#topic+create_Stations">create_Stations</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>terra::plot(SmallBathy(),breaks=Depth_cuts,col=Depth_cols,axes=FALSE,box=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
