<!DOCTYPE html><html lang="en"><head><title>Help for package SESraster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SESraster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.lyr.sample'><p>Internal function to resample a vector according to the observed frequency</p></a></li>
<li><a href='#.sample.not.NA'><p>Internal function to sample vectors with non-NA values</p></a></li>
<li><a href='#.str.sample'><p>Vectorized structured sample</p></a></li>
<li><a href='#algorithm_metrics'><p>Performance of randomization algorithms</p></a></li>
<li><a href='#bootspat_ff'><p>Spatially structured fixed-fixed sample</p></a></li>
<li><a href='#bootspat_naive'><p>Randomize a set of rasters according to the observed frequency.</p></a></li>
<li><a href='#bootspat_str'><p>Spatially structured sample</p></a></li>
<li><a href='#fit.memory'><p>Function to evaluate if the rasters generated in the function fit on RAM memory</p></a></li>
<li><a href='#fr2prob'><p>Adjust probability of sampling based on frequency of occurrences.</p></a></li>
<li><a href='#load_ext_data'><p>Load SESraster external datasets</p></a></li>
<li><a href='#plot_alg_metrics'><p>Plot performance of randomization algorithms</p></a></li>
<li><a href='#SESraster'><p>Standardized effect sizes for SpatRaster objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Raster Randomization for Null Hypothesis Testing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Randomization of presence/absence species distribution raster
    data with or without including spatial structure for calculating
    standardized effect sizes and testing null hypothesis. The
    randomization algorithms are based on classical algorithms for
    matrices (Gotelli 2000, &lt;<a href="https://doi.org/10.2307%2F177478">doi:10.2307/177478</a>&gt;) implemented for raster
    data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=SESraster">https://CRAN.R-project.org/package=SESraster</a>,
<a href="https://github.com/HemingNM/SESraster">https://github.com/HemingNM/SESraster</a>,
<a href="https://hemingnm.github.io/SESraster/">https://hemingnm.github.io/SESraster/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HemingNM/SESraster/issues">https://github.com/HemingNM/SESraster/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, methods, rlang, stats, terra, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>kableExtra, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-22 11:35:21 UTC; neander</td>
</tr>
<tr>
<td>Author:</td>
<td>Neander Marcel Heming
    <a href="https://orcid.org/0000-0003-2461-5045"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Flávio M. M. Mota <a href="https://orcid.org/0000-0002-0308-7151"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Gabriela Alves-Ferreira
    <a href="https://orcid.org/0000-0001-5661-3381"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Neander Marcel Heming &lt;neanderh@yahoo.com.br&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-22 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.lyr.sample'>Internal function to resample a vector according to the observed frequency</h2><span id='topic+.lyr.sample'></span>

<h3>Description</h3>

<p>Internal function to resample a vector according to the observed frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lyr.sample(x, fr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".lyr.sample_+3A_x">x</code></td>
<td>
<p>numeric. A vector containing values to resampling.</p>
</td></tr>
<tr><td><code id=".lyr.sample_+3A_fr">fr</code></td>
<td>
<p>data.frame A data.frame with 3 columns (layer, value, count).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Author(s)</h3>

<p>Neander Marcel Heming
</p>

<hr>
<h2 id='.sample.not.NA'>Internal function to sample vectors with non-NA values</h2><span id='topic+.sample.not.NA'></span>

<h3>Description</h3>

<p>Internal function to sample vectors with non-NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sample.not.NA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".sample.not.NA_+3A_x">x</code></td>
<td>
<p>numeric. A vector containing values to resampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Author(s)</h3>

<p>Neander Marcel Heming
</p>

<hr>
<h2 id='.str.sample'>Vectorized structured sample</h2><span id='topic+.str.sample'></span>

<h3>Description</h3>

<p>Vectorized structured sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.str.sample(x, sp, resu, fr_prob)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".str.sample_+3A_x">x</code></td>
<td>
<p>vector containing sample size (i.e. richness) in the first element
and probabilities on the remaining</p>
</td></tr>
<tr><td><code id=".str.sample_+3A_sp">sp</code></td>
<td>
<p>elements to be sampled</p>
</td></tr>
<tr><td><code id=".str.sample_+3A_resu">resu</code></td>
<td>
<p>vector of results, must be the same length of sp</p>
</td></tr>
<tr><td><code id=".str.sample_+3A_fr_prob">fr_prob</code></td>
<td>
<p>Frequency or probability of each sp element. This will be multiplied by the
probability vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of sampled sp elements
</p>


<h3>Author(s)</h3>

<p>Neander Marcel Heming
</p>

<hr>
<h2 id='algorithm_metrics'>Performance of randomization algorithms</h2><span id='topic+algorithm_metrics'></span>

<h3>Description</h3>

<p>Compares the richness and occurrence incidence across species
between actual and randomized species distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algorithm_metrics(
  x,
  spat_alg = NULL,
  spat_alg_args = NULL,
  aleats = 10,
  filename = "",
  force_wr_aleat_file = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="algorithm_metrics_+3A_x">x</code></td>
<td>
<p>SpatRaster. A SpatRaster containing presence-absence data (0 or 1)
for a set of species.</p>
</td></tr>
<tr><td><code id="algorithm_metrics_+3A_spat_alg">spat_alg</code></td>
<td>
<p>A function with the algorithm implementing the desired
randomization method. It must work with SpatRaster objects. See examples.
Example of functions that work are: <code><a href="#topic+bootspat_naive">bootspat_naive</a></code>,
<code><a href="#topic+bootspat_str">bootspat_str</a></code>, <code><a href="#topic+bootspat_ff">bootspat_ff</a></code>.</p>
</td></tr>
<tr><td><code id="algorithm_metrics_+3A_spat_alg_args">spat_alg_args</code></td>
<td>
<p>List of arguments passed to the randomization method
chosen in 'spat_alg'. See <code><a href="#topic+bootspat_naive">bootspat_naive</a></code>, <code><a href="#topic+bootspat_str">bootspat_str</a></code>,
<code><a href="#topic+bootspat_ff">bootspat_ff</a></code></p>
</td></tr>
<tr><td><code id="algorithm_metrics_+3A_aleats">aleats</code></td>
<td>
<p>positive integer. A positive integer indicating how many times
the calculation should be repeated.</p>
</td></tr>
<tr><td><code id="algorithm_metrics_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="algorithm_metrics_+3A_force_wr_aleat_file">force_wr_aleat_file</code></td>
<td>
<p>logical. Force writing bootstrapped rasters, even if
files fit in memory. Mostly used for internal test units.</p>
</td></tr>
<tr><td><code id="algorithm_metrics_+3A_...">...</code></td>
<td>
<p>additional arguments passed to 'terra::app()' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two components:
</p>

<ul>
<li><p>spp_metrics: a matrix with metrics comparing actual and randomized frequency
of species occurrence. Metrics are average, sd, min, and max frequency across
randomizations, sp_reldiff (average difference relative to species frequency),
global_reldiff (average difference relative to the number of available cells),
upper and lower confidence intervals for sp_reldiff and global_reldiff.
</p>
</li>
<li><p>spat_rich_diff: a SpatRaster with summary statistics about differences
between actual and bootstrapped site (cell) richness
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Neander M. Heming
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootspat_str">bootspat_str</a></code>, <code><a href="#topic+bootspat_naive">bootspat_naive</a></code>,
<code><a href="#topic+bootspat_ff">bootspat_ff</a></code>, <code><a href="#topic+SESraster">SESraster</a></code>, <code><a href="#topic+plot_alg_metrics">plot_alg_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SESraster)
library(terra)
r &lt;- load_ext_data()
algorithm_metrics(r, spat_alg = "bootspat_naive", spat_alg_args=list(random="species"), aleats = 3)
algorithm_metrics(r, spat_alg = "bootspat_naive", spat_alg_args=list(random="site"), aleats = 3)
# algorithm_metrics(r, spat_alg = "bootspat_naive", spat_alg_args=list(random="both"))

</code></pre>

<hr>
<h2 id='bootspat_ff'>Spatially structured fixed-fixed sample</h2><span id='topic+bootspat_ff'></span>

<h3>Description</h3>

<p>Randomizes a raster stack with fixed richness and species frequency of incidence.
Randomizations are based on frequencies (given or calculated from x)
and, optionally, a probability raster stack.
The probability raster stack controls the probability that a
given species is sampled in each cell raster. Frequency controls the number of cells
being sampled for each species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootspat_ff(
  x,
  rprob = NULL,
  rich = NULL,
  fr = NULL,
  glob_fr = NULL,
  cores = 1,
  filename = "",
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootspat_ff_+3A_x">x</code></td>
<td>
<p>SpatRaster. A presence-absence SpatRaster.</p>
</td></tr>
<tr><td><code id="bootspat_ff_+3A_rprob">rprob</code></td>
<td>
<p>SpatRaster. Stack of probability values. Structures the spatial
pattern of each randomized species.</p>
</td></tr>
<tr><td><code id="bootspat_ff_+3A_rich">rich</code></td>
<td>
<p>SpatRaster. Richness pattern structuring the sample size of
each cell randomization. Calculated if not provided.</p>
</td></tr>
<tr><td><code id="bootspat_ff_+3A_fr">fr</code></td>
<td>
<p>The observed frequency of incidence (i.e. number of occupied pixels)
of each species is across the study area.</p>
</td></tr>
<tr><td><code id="bootspat_ff_+3A_glob_fr">glob_fr</code></td>
<td>
<p>The size (i.e. number of pixels) of the study area.</p>
</td></tr>
<tr><td><code id="bootspat_ff_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used. You can also supply a cluster object. Ignored for functions that are implemented by terra in C++ (see under fun)</p>
</td></tr>
<tr><td><code id="bootspat_ff_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="bootspat_ff_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="bootspat_ff_+3A_...">...</code></td>
<td>
<p>additional parameters for terra::app</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is based on the algorithm of Connor &amp; Simberloff (1979).
It takes each species at a time and placed on Nj (species frequency of
incidence) randomly chosen sites (cells). The original algorithm randomly
chooses the sequence of species and fills sites (originally islands) until they
reach the observed species richness. However, as sites (cells) are filled with
species, some species do not have enough available sites to be placed, and
their sampled frequency is smaller than observed. Additionally, some sites cannot
be completely filled because duplicated species are not allowed in the same site.
Their solution was to increase the number of sites to place the species.
Here, we opted to order the sequence of species from the largest Nj to the
smallest. Also, the probability of occupying a site is given by cell
expected richness and on each round (i.e. species placement), the expected
richness of newly occupied sites is reduced. This ensures that there will be
available sites for all species and the randomized frequency of
incidence equals the observed frequency of incidence (Nj).
</p>


<h3>Value</h3>

<p>SpatRaster object
</p>


<h3>Author(s)</h3>

<p>Neander Marcel Heming
</p>


<h3>References</h3>

<p>Connor, E. F., &amp; Simberloff, D. (1979). The Assembly of Species Communities: Chance or Competition? Ecology, 60(6), 1132–1140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootspat_str">bootspat_str</a></code>, <code><a href="#topic+bootspat_naive">bootspat_naive</a></code>,
<code><a href="#topic+SESraster">SESraster</a></code>, <code><a href="#topic+algorithm_metrics">algorithm_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load random species distributions
library(SESraster)
library(terra)
r &lt;- load_ext_data()
plot(r)

# applying the function
rand.str &lt;- bootspat_str(r)
plot(rand.str)

# With null probability raster
rprobnull &lt;- terra::app(r,
                       function(x){
                       ifelse(is.na(x), NA, 1)
                       })
rand.str2 &lt;- bootspat_str(r, rprob = rprobnull)


library(SESraster)
library(terra)
# creating random species distributions
f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
set.seed(510)
r10 &lt;- rast(lapply(1:8,
                function(i, r, mn, mx){
                  app(r, function(x, t){
                    sapply(x, function(x, t){
                       x&lt;max(t) &amp; x&gt;min(t)
                    }, t=t)
                  }, t=sample(seq(mn, mx), 2))
                }, r=r, mn=minmax(r)[1]+10, mx=minmax(r)[2]-10))

names(r10) &lt;- paste("sp", 1:nlyr(r10))
plot(r10)

rprobnull &lt;- terra::app(r10,
                       function(x){
                       ifelse(is.na(x), NA, 1)
                       })

# bootstrapping once
randr10 &lt;- bootspat_ff(r10, rprobnull)
plot(randr10)
plot(c(sum(r10), sum(randr10)), main=c("observed", "randomized"))
plot(sum(r10)-sum(randr10))
cbind(observed=sapply(r10, function(x)freq(x)[2,3]),
      randomized=sapply(randr10, function(x)freq(x)[2,3]))

</code></pre>

<hr>
<h2 id='bootspat_naive'>Randomize a set of rasters according to the observed frequency.</h2><span id='topic+bootspat_naive'></span>

<h3>Description</h3>

<p>Randomize a set of rasters according to the observed frequency using the methods: sites (by cells), species (by layer) or both (layers and cells). The randomization not assign values to cells with nodata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootspat_naive(
  x,
  random = c("site", "species", "both"),
  filename = "",
  memory = NULL,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootspat_naive_+3A_x">x</code></td>
<td>
<p>SpatRaster. A presence-absence SpatRaster.</p>
</td></tr>
<tr><td><code id="bootspat_naive_+3A_random">random</code></td>
<td>
<p>character. Character indicating the type of randomization to be used. The available types are by &quot;site&quot;, &quot;specie&quot; or &quot;both&quot;. The first method (site) keeps species richness constant within each site (cell)pixel by randomizing the position (presence/absence) of the species within each cell of the stack.</p>
</td></tr>
<tr><td><code id="bootspat_naive_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="bootspat_naive_+3A_memory">memory</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="bootspat_naive_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used. You can also supply a cluster object. Ignored for functions that are implemented by terra in C++ (see under fun)</p>
</td></tr>
<tr><td><code id="bootspat_naive_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed passed down from a calling function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first method (site) is performed within each site (cell) by randomizing the position (presence/absence) of the species within each cell of the stack. This method keeps species richness constant at each cell but the size of the species distribution might change. The second method (species) is performed at each layer (species) of the stack by randomizing the position of species presences in space. This method changes the species richness at each cell but the size of the species distribution is held constant (except if randomization is performed by frequency). The third method (both) combines randomization by site and species at the same time. This method will shuffle all presences across cells and layers, changing site richness and species distribution sizes and location at the same time.
</p>


<h3>Value</h3>

<p>SpatRaster object
</p>


<h3>Author(s)</h3>

<p>Neander Marcel Heming and Gabriela Alves-Ferreira
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootspat_str">bootspat_str</a></code>, <code><a href="#topic+bootspat_ff">bootspat_ff</a></code>,
<code><a href="#topic+SESraster">SESraster</a></code>, <code><a href="#topic+algorithm_metrics">algorithm_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
# load random species distributions
r &lt;- load_ext_data()
plot(r)

# randomize pres/abs data by site
rn &lt;- bootspat_naive(r, "site")
plot(rn)


library(SESraster)
library(terra)
# creating random species distributions
f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
set.seed(510)
r10 &lt;- rast(lapply(1:18,
                function(i, r, mn, mx){
                  app(r, function(x, t){
                    sapply(x, function(x, t){
                       x&lt;max(t) &amp; x&gt;min(t)
                    }, t=t)
                  }, t=sample(seq(mn, mx), 2))
                }, r=r, mn=minmax(r)[1]+10, mx=minmax(r)[2]-10))

names(r10) &lt;- paste("sp", 1:nlyr(r10))
plot(r10)

# bootstrapping once
randr10 &lt;- bootspat_naive(r10, "site")
plot(randr10)

plot(c(sum(r10), sum(randr10)), main=c("observed", "randomized"))
cbind(observed=sapply(r10, function(x)freq(x)[2,3]),
      randomized=sapply(randr10, function(x)freq(x)[2,3]))

</code></pre>

<hr>
<h2 id='bootspat_str'>Spatially structured sample</h2><span id='topic+bootspat_str'></span>

<h3>Description</h3>

<p>Randomizes a raster stack with fixed richness.
Randomizations are based on frequencies (given or calculated from x)
and, optionally, a probability raster stack.
Both, frequencies and probability raster stack, control the probability that a
given species is sampled in each cell raster. Frequency controls the probability
of each species being sampled compared to all others. Probability raster stack
controls the probability that each species is sampled in a given raster cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootspat_str(
  x,
  rprob = NULL,
  rich = NULL,
  fr_prob = NULL,
  cores = 1,
  filename = "",
  memory = NULL,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootspat_str_+3A_x">x</code></td>
<td>
<p>SpatRaster. A presence-absence SpatRaster.</p>
</td></tr>
<tr><td><code id="bootspat_str_+3A_rprob">rprob</code></td>
<td>
<p>SpatRaster. Stack of probability values. Structures the spatial
pattern of each randomized species.</p>
</td></tr>
<tr><td><code id="bootspat_str_+3A_rich">rich</code></td>
<td>
<p>SpatRaster. Richness pattern structuring the sample size of
each cell randomization. Calculated if not provided.</p>
</td></tr>
<tr><td><code id="bootspat_str_+3A_fr_prob">fr_prob</code></td>
<td>
<p>Either frequency of pixels or probability that a species is
observed across the whole layer.</p>
</td></tr>
<tr><td><code id="bootspat_str_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used. You can also supply a cluster object. Ignored for functions that are implemented by terra in C++ (see under fun)</p>
</td></tr>
<tr><td><code id="bootspat_str_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="bootspat_str_+3A_memory">memory</code></td>
<td>
<p>logical. Checks if there is enough available RAM memory. Calculated if NULL</p>
</td></tr>
<tr><td><code id="bootspat_str_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="bootspat_str_+3A_...">...</code></td>
<td>
<p>additional parameters for terra::app</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster object
</p>


<h3>Author(s)</h3>

<p>Neander Marcel Heming
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootspat_naive">bootspat_naive</a></code>, <code><a href="#topic+bootspat_ff">bootspat_ff</a></code>,
<code><a href="#topic+SESraster">SESraster</a></code>, <code><a href="#topic+algorithm_metrics">algorithm_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load random species distributions
library(SESraster)
library(terra)
r &lt;- load_ext_data()
plot(r)

# applying the function
rand.str &lt;- bootspat_str(r)
plot(rand.str)

# With null probability raster
rprobnull &lt;- terra::app(r,
                       function(x){
                       ifelse(is.na(x), NA, 1)
                       })
rand.str2 &lt;- bootspat_str(r, rprob = rprobnull)


library(SESraster)
library(terra)
# creating random species distributions
f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
set.seed(510)
r10 &lt;- rast(lapply(1:18,
                function(i, r, mn, mx){
                  app(r, function(x, t){
                    sapply(x, function(x, t){
                       x&lt;max(t) &amp; x&gt;min(t)
                    }, t=t)
                  }, t=sample(seq(mn, mx), 2))
                }, r=r, mn=minmax(r)[1]+10, mx=minmax(r)[2]-10))

names(r10) &lt;- paste("sp", 1:nlyr(r10))
plot(r10)

rprobnull &lt;- terra::app(r10,
                       function(x){
                       ifelse(is.na(x), NA, 1)
                       })

# bootstrapping once
randr10 &lt;- bootspat_str(r10, rprobnull)
plot(randr10)
plot(c(sum(r10), sum(randr10)), main=c("observed", "randomized"))
cbind(observed=sapply(r10, function(x)freq(x)[2,3]),
      randomized=sapply(randr10, function(x)freq(x)[2,3]))

</code></pre>

<hr>
<h2 id='fit.memory'>Function to evaluate if the rasters generated in the function fit on RAM memory</h2><span id='topic+fit.memory'></span>

<h3>Description</h3>

<p>Function to evaluate if the rasters generated in the function fit on RAM memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.memory(x, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.memory_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="fit.memory_+3A_n">n</code></td>
<td>
<p>positive integer. The number of copies of <code>x</code> that are needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Author(s)</h3>

<p>Neander Marcel Heming and Gabriela Alves-Ferreira
</p>

<hr>
<h2 id='fr2prob'>Adjust probability of sampling based on frequency of occurrences.</h2><span id='topic+fr2prob'></span>

<h3>Description</h3>

<p>This function is used to adjust the probability of a species to be sampled
across the raster, so that the sampled frequency of occurrence of the
species is closer to the observed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fr2prob(x, rprob = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fr2prob_+3A_x">x</code></td>
<td>
<p>SpatRaster. A presence-absence raster (stack).</p>
</td></tr>
<tr><td><code id="fr2prob_+3A_rprob">rprob</code></td>
<td>
<p>SpatRaster. A raster (stack) of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SESraster)
library(terra)
# load random species distributions
r &lt;- load_ext_data()

# applying the function
fr2prob(r)


f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
set.seed(510)
r10 &lt;- rast(lapply(1:18,
                function(i, r, mn, mx){
                  app(r, function(x, t){
                    sapply(x, function(x, t){
                       x&lt;max(t) &amp; x&gt;min(t)
                    }, t=t)
                  }, t=sample(seq(mn, mx), 2))
                }, r=r, mn=minmax(r)[1]+10, mx=minmax(r)[2]-10))

names(r10) &lt;- paste("sp", 1:nlyr(r10))
fr2prob(r10)
# raw frequencies
unlist(terra::global(r10, function(x)sum(x, na.rm=TRUE)))

</code></pre>

<hr>
<h2 id='load_ext_data'>Load SESraster external datasets</h2><span id='topic+load_ext_data'></span>

<h3>Description</h3>

<p>This function loads external datasets available at extdata package folder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_ext_data(x = "spp_sites")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_ext_data_+3A_x">x</code></td>
<td>
<p>dataset to be loaded</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the available datasets:
</p>

<ul>
<li><p> spp_sites: a SpatRaster with randomly generated presence-absence data for five species.
</p>
</li></ul>



<h3>Value</h3>

<p>SpatRaster object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load random species distributions
library(SESraster)
library(terra)

r &lt;- load_ext_data()

plot(r)

</code></pre>

<hr>
<h2 id='plot_alg_metrics'>Plot performance of randomization algorithms</h2><span id='topic+plot_alg_metrics'></span>

<h3>Description</h3>

<p>Plots objects returned by <code><a href="#topic+algorithm_metrics">algorithm_metrics</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_alg_metrics(x, what = "spp", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_alg_metrics_+3A_x">x</code></td>
<td>
<p>list. Object returned by <code><a href="#topic+algorithm_metrics">algorithm_metrics</a></code></p>
</td></tr>
<tr><td><code id="plot_alg_metrics_+3A_what">what</code></td>
<td>
<p>What should be plotted, &quot;species&quot; or &quot;site&quot; metrics?</p>
</td></tr>
<tr><td><code id="plot_alg_metrics_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="terra.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Neander M. Heming
</p>


<h3>See Also</h3>

<p><code><a href="#topic+algorithm_metrics">algorithm_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SESraster)
library(terra)
r &lt;- load_ext_data()
am1 &lt;- algorithm_metrics(r, spat_alg = "bootspat_naive", spat_alg_args=list(random="species"))
am2 &lt;- algorithm_metrics(r, spat_alg = "bootspat_naive", spat_alg_args=list(random="site"))
plot_alg_metrics(am1)
plot_alg_metrics(am2)
plot_alg_metrics(am1, "site")

</code></pre>

<hr>
<h2 id='SESraster'>Standardized effect sizes for SpatRaster objects</h2><span id='topic+SESraster'></span>

<h3>Description</h3>

<p>Calculates the standardized effect sizes using a custom function
and a null model algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SESraster(
  x,
  FUN = NULL,
  FUN_args = list(),
  spat_alg = NULL,
  spat_alg_args = list(),
  Fa_sample = NULL,
  Fa_alg = NULL,
  Fa_alg_args = list(),
  aleats = 10,
  cores = 1,
  filename = "",
  overwrite = FALSE,
  force_wr_aleat_file = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SESraster_+3A_x">x</code></td>
<td>
<p>SpatRaster. A SpatRaster containing presence-absence data (0 or 1)
for a set of species.</p>
</td></tr>
<tr><td><code id="SESraster_+3A_fun">FUN</code></td>
<td>
<p>The function to be applied. It must work with SpatRaster objects.
See examples.</p>
</td></tr>
<tr><td><code id="SESraster_+3A_fun_args">FUN_args</code></td>
<td>
<p>Named list of arguments passed to the FUN</p>
</td></tr>
<tr><td><code id="SESraster_+3A_spat_alg">spat_alg</code></td>
<td>
<p>A function with the algorithm implementing the desired
randomization method. It must work with SpatRaster objects. See examples.
Example of functions that work are: <code><a href="#topic+bootspat_naive">bootspat_naive</a></code>,
<code><a href="#topic+bootspat_str">bootspat_str</a></code>, <code><a href="#topic+bootspat_ff">bootspat_ff</a></code>.</p>
</td></tr>
<tr><td><code id="SESraster_+3A_spat_alg_args">spat_alg_args</code></td>
<td>
<p>List of arguments passed to the randomization method
chosen in 'spat_alg'. See <code><a href="#topic+bootspat_naive">bootspat_naive</a></code>, <code><a href="#topic+bootspat_str">bootspat_str</a></code>,
<code><a href="#topic+bootspat_ff">bootspat_ff</a></code></p>
</td></tr>
<tr><td><code id="SESraster_+3A_fa_sample">Fa_sample</code></td>
<td>
<p>Named list of length 1 with a FUN argument (e.g. a vector)
to be randomized</p>
</td></tr>
<tr><td><code id="SESraster_+3A_fa_alg">Fa_alg</code></td>
<td>
<p>function to randomize any non spatial argument to be passed
to 'FUN'.</p>
</td></tr>
<tr><td><code id="SESraster_+3A_fa_alg_args">Fa_alg_args</code></td>
<td>
<p>Named list of arguments passed to the function in 'Fa_alg'</p>
</td></tr>
<tr><td><code id="SESraster_+3A_aleats">aleats</code></td>
<td>
<p>positive integer. A positive integer indicating how many times
the calculation should be repeated.</p>
</td></tr>
<tr><td><code id="SESraster_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used. You can also supply a cluster object. Ignored for functions that are implemented by terra in C++ (see under fun)</p>
</td></tr>
<tr><td><code id="SESraster_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="SESraster_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="SESraster_+3A_force_wr_aleat_file">force_wr_aleat_file</code></td>
<td>
<p>logical. Force writing bootstrapped rasters, even if
files fit in memory. Mostly used for internal test units.</p>
</td></tr>
<tr><td><code id="SESraster_+3A_...">...</code></td>
<td>
<p>additional arguments passed to 'terra::app()' function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform n=aleats spatial randomizations based on the randomization
method defined in 'spat_alg' argument and calculates the metric
defined in 'FUN' argument. The function (FUN) to calculate the desired metric
must work with any of <a href="terra.html#topic+app">app</a>, <a href="terra.html#topic+focal">focal</a>,
<a href="terra.html#topic+focal3D">focal3D</a> family of functions.
</p>


<h3>Value</h3>

<p>SpatRaster. The function returns the observed metric, the mean of the
simulations calculated over n=aleats times, the standard deviation of the
simulations, the standardized effect size (SES) for the metric defined in FUN,
and p values for the upper and lower tails.
</p>


<h3>Author(s)</h3>

<p>Neander M. Heming and Gabriela Alves-Ferreira
</p>


<h3>References</h3>

<p>Gotelli 2000
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootspat_str">bootspat_str</a></code>, <code><a href="#topic+bootspat_naive">bootspat_naive</a></code>,
<code><a href="#topic+bootspat_ff">bootspat_ff</a></code>, <code><a href="#topic+algorithm_metrics">algorithm_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SESraster)
library(terra)
r &lt;- load_ext_data()
appmean &lt;- function(x, ...){
                      terra::app(x, "mean", ...)
                    }
ses &lt;- SESraster(r, FUN=appmean, spat_alg = "bootspat_naive", spat_alg_args=list(random="species"),
                 aleats = 4)
plot(ses)
ses &lt;- SESraster(r, FUN=appmean, spat_alg = "bootspat_naive", spat_alg_args=list(random="site"),
                 aleats = 4)
plot(ses)

## example of how to use 'FUN_args'
r[7][1] &lt;- NA
plot(r)
set.seed(10)
sesNA &lt;- SESraster(r, FUN=appmean, FUN_args = list(na.rm = FALSE),
                 spat_alg = "bootspat_naive", spat_alg_args=list(random = "species"),
                 aleats = 4)
plot(sesNA)

set.seed(10)
ses &lt;- SESraster(r, FUN=appmean, FUN_args = list(na.rm = TRUE),
                spat_alg = "bootspat_naive", spat_alg_args=list(random = "species"),
                 aleats = 4)
plot(ses)

## example with 'Fa_alg'
appsv &lt;- function(x, lyrv, na.rm = FALSE, ...){
                      sumw &lt;- function(x, lyrv, na.rm, ...){
                            ifelse(all(is.na(x)), NA,
                                    sum(x*lyrv, na.rm=na.rm, ...))
                      }
                      stats::setNames(terra::app(x, sumw, lyrv = lyrv, na.rm=na.rm, ...), "sumw")
                    }
set.seed(10)
ses &lt;- SESraster(r, FUN=appsv,
                 FUN_args = list(lyrv = seq_len(nlyr(r)), na.rm = TRUE),
                    Fa_sample = "lyrv",
                    Fa_alg = "sample", Fa_alg_args = list(replace=FALSE),
                    aleats = 4)
plot(ses)

set.seed(10)
ses &lt;- SESraster(r, FUN=appsv,
                 FUN_args = list(lyrv = seq_len(nlyr(r)), na.rm = TRUE),
                    Fa_sample = "lyrv",
                    Fa_alg = "sample", Fa_alg_args = list(replace=TRUE),
                    aleats = 4)
plot(ses)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
