<!DOCTYPE html><html lang="en"><head><title>Help for package OSCV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OSCV}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ASE_reg'><p>The ASE function for the local linear estimator (LLE) in the regression context.</p></a></li>
<li><a href='#C_smooth'><p>The OSCV smooth rescaling constant.</p></a></li>
<li><a href='#CV_reg'><p>The cross-validation (CV) function in the regression context.</p></a></li>
<li><a href='#fstar'><p>Nonsmooth density function with seven cusps.</p></a></li>
<li><a href='#h_ASE_reg'><p>The ASE-optimal bandwidth in the regression context.</p></a></li>
<li><a href='#H_I'><p>The family of two-sided cross-validation kernels <code class="reqn">H_I</code>.</p></a></li>
<li><a href='#h_OSCV_dens'><p>The OSCV bandwidth in the density estimation context.</p></a></li>
<li><a href='#h_OSCV_reg'><p>The OSCV bandwidth in the regression context.</p></a></li>
<li><a href='#ISE_fstar'><p>The ISE function in the kernel density estimation (KDE) context in the case when the underlying density is <code>fstar</code>.</p></a></li>
<li><a href='#L_I'><p>The family of one-sided cross-validation kernels <code class="reqn">L_I</code>.</p></a></li>
<li><a href='#loclin'><p>Computing the local linear estimate (LLE).</p></a></li>
<li><a href='#OSCV_Epan_dens'><p>The OSCV function based on <code class="reqn">L_E</code>, the one-sided Epanechnikov kernel, in the kernel density estimation (KDE) context.</p></a></li>
<li><a href='#OSCV_Gauss_dens'><p>The OSCV function based on <code class="reqn">L_G</code>, the one-sided Gaussian kernel, in the kernel density estimation (KDE) context.</p></a></li>
<li><a href='#OSCV_LI_dens'><p>The OSCV function based on the kernel <code>L_I</code> in the density estimation (KDE) context.</p></a></li>
<li><a href='#OSCV_reg'><p>The OSCV function in the regression context.</p></a></li>
<li><a href='#reg3'><p>Nonsmooth regression function with six cusps.</p></a></li>
<li><a href='#sample_fstar'><p>Taking a random sample from <code>fstar</code>.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>One-Sided Cross-Validation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Olga Savchuk</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Olga Savchuk &lt;olga.y.savchuk@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for implementing different versions of the OSCV method in the kernel regression and density estimation frameworks. The package mainly supports the following articles: (1) Savchuk, O.Y., Hart, J.D. (2017). Fully robust one-sided cross-validation for regression functions. Computational Statistics, &lt;<a href="https://doi.org/10.1007%2Fs00180-017-0713-7">doi:10.1007/s00180-017-0713-7</a>&gt; and (2) Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth density functions, &lt;<a href="https://doi.org/10.48550/arXiv.1703.05157">doi:10.48550/arXiv.1703.05157</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1), mc2d</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-03-18 13:52:43 UTC; olgay</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-03-18 17:51:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='ASE_reg'>The ASE function for the local linear estimator (LLE) in the regression context.</h2><span id='topic+ASE_reg'></span>

<h3>Description</h3>

<p>Computing <code class="reqn">ASE(h)</code>, the value of the ASE function for the local linear estimator in the regression context, for the given vector of <code class="reqn">h</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASE_reg(h, desx, y, rx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ASE_reg_+3A_h">h</code></td>
<td>
<p>numerical vector of bandwidth values,</p>
</td></tr>
<tr><td><code id="ASE_reg_+3A_desx">desx</code></td>
<td>
<p>numerical vecror of design points,</p>
</td></tr>
<tr><td><code id="ASE_reg_+3A_y">y</code></td>
<td>
<p>numerical vecror of data points corresponding to the design points <code class="reqn">desx</code>,</p>
</td></tr>
<tr><td><code id="ASE_reg_+3A_rx">rx</code></td>
<td>
<p>numerical vecror of values of the regression function at <code class="reqn">desx</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average squared error (ASE) is used as a measure of performace of the local linear estimator based on the Gaussian kernel.
</p>


<h3>Value</h3>

<p>The vector of values of <code class="reqn">ASE(h)</code> for the correponsing vector of <code class="reqn">h</code> values.
</p>


<h3>References</h3>

<p>Hart, J.D. and Yi, S. (1998) One-sided cross-validation. <em>Journal of the American Statistical Association</em>, 93(442), 620-631.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loclin">loclin</a></code>, <code><a href="#topic+h_ASE_reg">h_ASE_reg</a></code>, <code><a href="#topic+CV_reg">CV_reg</a></code>, <code><a href="#topic+OSCV_reg">OSCV_reg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example (ASE function for a random sample of size n=100 generated from the function reg3 that
# has six cusps. The function originates from the article of Savchuk et al. (2013).
# The level of the added Gaussian noise is sigma=1/1000).
n=100
dx=(1:n-0.5)/n
regx=reg3(dx)
ydat=regx+rnorm(n,sd=1/1000)
harray=seq(0.003,0.05,len=300)
ASEarray=ASE_reg(harray,dx,ydat,regx)
hmin=round(h_ASE_reg(dx,ydat,regx),digits=4)
dev.new()
plot(harray,ASEarray,'l',lwd=3,xlab="h",ylab="ASE",main="ASE function for a random sample
from r3",cex.lab=1.7,cex.axis=1.7,cex.main=1.5)
legend(0.029,0.0000008,legend=c("n=100","sigma=1/1000"),cex=1.7,bty="n")
legend(0.005,0.000002,legend=paste("h_ASE=",hmin),cex=2,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='C_smooth'>The OSCV smooth rescaling constant.</h2><span id='topic+C_smooth'></span>

<h3>Description</h3>

<p>Computing the OSCV smooth rescaling constant that corresponds to using the two-sided kernel <code><a href="#topic+H_I">H_I</a></code> for the cross-validation purposes and the Gaussian kernel in the estimation stage. The constant is applicable for the OSCV versions in the regression and kernel density estimation contexts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_smooth(alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_smooth_+3A_alpha">alpha</code></td>
<td>
<p>first parameter of the two-sided cross-validation kernel <code><a href="#topic+H_I">H_I</a></code>,</p>
</td></tr>
<tr><td><code id="C_smooth_+3A_sigma">sigma</code></td>
<td>
<p>second parameter of the two-sided cross-validation kernel <code><a href="#topic+H_I">H_I</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of the OSCV rescaling constant <code class="reqn">C</code> (see (10) in Savchuk and Hart (2017) or (3) in Savchuk (2017)). The constant is a function of the parameters <code class="reqn">(\alpha,\sigma)</code> of the two-sided cross-validation kernel <code><a href="#topic+H_I">H_I</a></code> defined by expression (15) in Savchuk and Hart (2017). The Gaussian kernel is used for computing the ultimate (regression or density) estimate. The constant is used in the OSCV versions for kernel regression and density estimation. Notice that in the cases <code class="reqn">\alpha=0</code>, <code class="reqn">\sigma&gt;0</code> and <code class="reqn">\sigma=1</code>, <code class="reqn">-\infty&lt;\alpha&lt;\infty</code> the kernel <code><a href="#topic+H_I">H_I</a></code> reduces to the Gaussian kernel.
</p>


<h3>Value</h3>

<p>The OSCV smooth rescaling constant <code class="reqn">C</code> for the given values of the parameters <code class="reqn">\alpha</code> and <code class="reqn">\sigma</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Savchuk, O.Y., Hart, J.D. (2017). Fully robust one-sided cross-validation for regression functions. <em>Computational Statistics</em>, doi:10.1007/s00180-017-0713-7.
</p>
</li>
<li><p> Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth density functions, arXiv:1703.05157.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+L_I">L_I</a></code>, <code><a href="#topic+H_I">H_I</a></code>, <code><a href="#topic+OSCV_reg">OSCV_reg</a></code>, <code><a href="#topic+h_OSCV_reg">h_OSCV_reg</a></code>, <code><a href="#topic+OSCV_LI_dens">OSCV_LI_dens</a></code>, <code><a href="#topic+OSCV_Gauss_dens">OSCV_Gauss_dens</a></code>, <code><a href="#topic+h_OSCV_dens">h_OSCV_dens</a></code>, <code><a href="#topic+loclin">loclin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># OSCV rescaling constant for the robust cross-validation kernel with 
# (alpha,sigma)=(16.8954588,1.01).
C_smooth(16.8954588,1.01)
# OSCV smooth rescaling constant in the case when the kernel H_I is Gaussian.
C_smooth(1,1)
</code></pre>

<hr>
<h2 id='CV_reg'>The cross-validation (CV) function in the regression context.</h2><span id='topic+CV_reg'></span>

<h3>Description</h3>

<p>Computing <code class="reqn">CV(h)</code>, the value of the CV function in the regression context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CV_reg(h, desx, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CV_reg_+3A_h">h</code></td>
<td>
<p>numerical vector of bandwidth values,</p>
</td></tr>
<tr><td><code id="CV_reg_+3A_desx">desx</code></td>
<td>
<p>numerical vecror of design points,</p>
</td></tr>
<tr><td><code id="CV_reg_+3A_y">y</code></td>
<td>
<p>numerical vecror of data values corresponding to the design points <code class="reqn">desx</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CV function is a measure of fit of the regression estimate to the data. The local linear estimator based on the Gaussian kernel is used. The cross-validation bandwidth is the minimizer of the CV function.
</p>


<h3>Value</h3>

<p>The vector of values of <code class="reqn">CV(h)</code> for the correponsing vector of <code class="reqn">h</code> values.
</p>


<h3>References</h3>

<p>Stone, C.J. (1977) Consistent nonparametric regression. <em>Annals of Statistics</em>, 5(4), 595-645.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loclin">loclin</a></code>, <code><a href="#topic+h_ASE_reg">h_ASE_reg</a></code>, <code><a href="#topic+ASE_reg">ASE_reg</a></code>, <code><a href="#topic+OSCV_reg">OSCV_reg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example (Old Faithful geyser). Take x=waiting time; y=eruption duration. The sample size n=272.
xdat=faithful[[2]]
ydat=faithful[[1]]
harray=seq(0.5,10,len=100)
cv=CV_reg(harray,xdat,ydat)
R=range(xdat)
h_cv=round(optimize(CV_reg,c(0.01,(R[2]-R[1]/4)),desx=xdat,y=ydat)$minimum,digits=4)
dev.new()
plot(harray,cv,'l',lwd=3,xlab="h",ylab="CV(h)",main="CV function for the Old Faithful 
geyser data", cex.lab=1.7,cex.axis=1.7,cex.main=1.5)
legend(6,0.155,legend="n=272",cex=1.8,bty="n")
legend(1,0.18,legend=paste("h_CV=",h_cv),cex=2,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='fstar'>Nonsmooth density function with seven cusps.</h2><span id='topic+fstar'></span>

<h3>Description</h3>

<p>Nonsmooth density <code class="reqn">f^*</code> with seven cusps introduced in the article of Savchuk (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fstar(u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fstar_+3A_u">u</code></td>
<td>
<p>numerical vecror of argument values in the range [-3,3].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code class="reqn">f^*</code> consists of straight lines with different slopes connected together. The support of the density is [-3,3].
</p>


<h3>Value</h3>

<p>The vector of values of <code class="reqn">f^*</code> corresponding to the values of the vector <code class="reqn">u</code>.
</p>


<h3>References</h3>

<p>Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth density functions, arXiv:1703.05157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_fstar">sample_fstar</a></code>, <code><a href="#topic+ISE_fstar">ISE_fstar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dev.new()
plot(seq(-3.5,3.5,len=1000),fstar(seq(-3.5,3.5,len=1000)),'l',lwd=3,
main="Nonsmooth density fstar with seven cusps", xlab="argument", ylab="density",cex.main=1.5,
cex.axis=1.7,cex.lab=1.7)

## End(Not run)
</code></pre>

<hr>
<h2 id='h_ASE_reg'>The ASE-optimal bandwidth in the regression context.</h2><span id='topic+h_ASE_reg'></span>

<h3>Description</h3>

<p>Computing the ASE-optimal bandwidth for the Gaussian local linear regression estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_ASE_reg(desx, y, rx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_ASE_reg_+3A_desx">desx</code></td>
<td>
<p>numerical vecror of design points,</p>
</td></tr>
<tr><td><code id="h_ASE_reg_+3A_y">y</code></td>
<td>
<p>numerical vecror of data points corresponding to the design points <code class="reqn">desx</code>,</p>
</td></tr>
<tr><td><code id="h_ASE_reg_+3A_rx">rx</code></td>
<td>
<p>numerical vecror of the regression function values at <code class="reqn">desx</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the ASE-optimal bandwidth for the local linear estimator in the regression context. The ASE-optimal bandwidth is the global minimizer of the ASE function <code><a href="#topic+ASE_reg">ASE_reg</a></code>. This bandwidth is optimal for the data set at hand.
</p>


<h3>Value</h3>

<p>The ASE-optimal bandwidth (scalar).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ASE_reg">ASE_reg</a></code>, <code><a href="#topic+loclin">loclin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulated example.
n=300
dx=runif(n)            #uniform design
regx=5*dx^10*(1-dx)^2+2.5*dx^2*(1-dx)^10
ydat=regx+rnorm(n,sd=1/250)
hase=round(h_ASE_reg(dx,ydat,regx),digits=4)
u=seq(0,1,len=1000)
fun=5*u^10*(1-u)^2+2.5*u^2*(1-u)^10
dev.new()
plot(dx,ydat,pch=20,cex=1.5,xlab="argument",ylab="function",cex.lab=1.7,cex.axis=1.7,
main="Function, data, and the ASE-optimal bandwidth",cex.main=1.5)
lines(u,fun,'l',lwd=3,col="blue")
legend(0,0.03,legend=paste("h_ASE=",hase),cex=1.8,bty="n")
legend(0.6,-0.002,legend=paste("n=",n),cex=2,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='H_I'>The family of two-sided cross-validation kernels <code class="reqn">H_I</code>.</h2><span id='topic+H_I'></span>

<h3>Description</h3>

<p>The family of two-sided cross-validation kernels <code class="reqn">H_I</code> defined by equation (15) of Savchuk and Hart (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H_I(u, alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="H_I_+3A_u">u</code></td>
<td>
<p>numerical vector of argument values,</p>
</td></tr>
<tr><td><code id="H_I_+3A_alpha">alpha</code></td>
<td>
<p>first parameter of the cross-validation kernel <code class="reqn">H_I</code>,</p>
</td></tr>
<tr><td><code id="H_I_+3A_sigma">sigma</code></td>
<td>
<p>second parameter of the cross-validation kernel <code class="reqn">H_I</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The family of the two-sided cross-validation kernels <code class="reqn">H_I(u;\alpha,\sigma)=(1+\alpha)\phi(u)-\alpha\phi(u/\sigma)/\sigma</code>, where <code class="reqn">\phi</code> denotes the Gaussian kernel, <code class="reqn">-\infty&lt;\alpha&lt;\infty</code> and <code class="reqn">\sigma&gt;0</code> are the parameters of the kernel. See expression (15) of Savchuk and Hart (2017). The robust kernel plotted in Figure 1 of Savchuk and Hart (2017) is obtained by setting <code class="reqn">\alpha=16.8954588</code> and <code class="reqn">\sigma=1.01</code>. Note that the kernels <code class="reqn">H_I</code> are also used for the bandwidth selection purposes in the indirect cross-validation (ICV) method (see expression (4) of Savchuk, Hart, and Sheather (2010)). The kernel <code class="reqn">H_I</code> is a two-sided analog of the one-sided kernel <code><a href="#topic+L_I">L_I</a></code>. The Gaussian kernel <code class="reqn">\phi</code> is the special case of <code class="reqn">H_I</code> obtained by either setting <code class="reqn">\alpha=0</code> or <code class="reqn">\sigma=1</code>.
</p>


<h3>Value</h3>

<p>The value of <code class="reqn">H_I(u;\alpha,\sigma)</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Savchuk, O.Y., Hart, J.D. (2017). Fully robust one-sided cross-validation for regression functions. <em>Computational Statistics</em>, doi:10.1007/s00180-017-0713-7.
</p>
</li>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2010). Indirect cross-validation for density estimation. <em>Journal of the American Statistical Association</em>, 105(489), 415-423.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+L_I">L_I</a></code>, <code><a href="#topic+C_smooth">C_smooth</a></code>, <code><a href="#topic+OSCV_reg">OSCV_reg</a></code>, <code><a href="#topic+loclin">loclin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Plotting the robust kernel from Savchuk and Hart (2017) with alpha=16.8954588 and sigma=1.01.
u=seq(-5,5,len=1000)
ker=H_I(u,16.8954588,1.01)
dev.new()
plot(u,ker,'l',lwd=3,cex.axis=1.7, cex.lab=1.7)
title(main="Robust kernel H_I along with the Gaussian kernel (phi)",cex=1.7)
lines(u,dnorm(u),lty="dashed",lwd=3)
legend(-4.85,0.3,lty=c("solid","dashed"),lwd=c(3,3),legend=c("H_I","phi"),cex=1.5)
legend(1,0.4,legend=c("alpha=16.8955","sigma=1.01"),cex=1.5,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='h_OSCV_dens'>The OSCV bandwidth in the density estimation context.</h2><span id='topic+h_OSCV_dens'></span>

<h3>Description</h3>

<p>Computing the OSCV bandwidth for the Gaussian density estimator. The one-sided Gaussian kernel <code class="reqn">L_G</code> is used in the bandwidth selection stage. The (anticipated) smoothness of the density function is to be specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_OSCV_dens(dat, stype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_OSCV_dens_+3A_dat">dat</code></td>
<td>
<p>numerical vecror of data values,</p>
</td></tr>
<tr><td><code id="h_OSCV_dens_+3A_stype">stype</code></td>
<td>
<p>specifies (anticipated) smoothness of the density function. Thus, <code class="reqn">stype=0</code> corresponds to the <em>smooth</em> density, whereas <code class="reqn">stype=1</code> corresponds to the <em>nonsmooth</em> density.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the OSCV bandwidth for the data vector <code class="reqn">dat</code>. The one-sided Gaussian kernel <code class="reqn">L_G</code> is used for the cross-validation purposes and the Gaussian kernel is used for computing the ultimate density estimate. The (anticipated) smoothness of the underlying density function is to be specified. Thus, </p>
<ul>
<li> <p><code class="reqn">stype=0</code> corresponds to the smooth density; </p>
</li>
<li> <p><code class="reqn">stype=1</code> corresponds to the nonsmooth density.</p>
</li></ul>
<p> It is usually assumed that the density is smooth if no preliminary information about its nonsmoothness is available. No additional rescaling of the computed bandwidth is needed. The smoothness of the density function <code class="reqn">stype</code>, essentially, determines the value of the bandwidth rescaling constant that is used in the body of the function. Thus, the constant is equal to 0.6168471 in the smooth case, whereas it is equal to 0.5730 in the nonsmooth case. See Savchuk (2017) for details. The OSCV bandwidth is the minimizer of the OSCV function <code><a href="#topic+OSCV_Gauss_dens">OSCV_Gauss_dens</a></code>.
</p>


<h3>Value</h3>

<p>The OSCV bandwidth (scalar).
</p>


<h3>References</h3>

<p>Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth densty functions, arXiv:1703.05157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+OSCV_Gauss_dens">OSCV_Gauss_dens</a></code>,  <code><a href="#topic+C_smooth">C_smooth</a></code>, <code><a href="#topic+h_OSCV_reg">h_OSCV_reg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data=faithful[,1]         # Data on n=272 eruption duration of the Old Faithful geyser.
harray=seq(0.025,0.6,len=100)
OSCV_array=OSCV_Gauss_dens(harray,data,0)
dev.new()
plot(harray,OSCV_array,lwd=3,'l',xlab="h",ylab="L_G-based OSCV",
main="OSCV_G(h) for the data on eruption duration",cex.main=1.5,cex.lab=1.7,cex.axis=1.7)
h_oscv=round(h_OSCV_dens(data,0),digits=4) #smoothness of the underlying density is assumed
legend(0.04,-0.25,legend=c("n=272",paste("h_OSCV=",h_oscv)),cex=2,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='h_OSCV_reg'>The OSCV bandwidth in the regression context.</h2><span id='topic+h_OSCV_reg'></span>

<h3>Description</h3>

<p>Computing the OSCV bandwidth for the Gaussian local linear regression estimator. The Gaussian kernel is used in the bandwidth selection stage. The smoothness of the regression function is to be specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_OSCV_reg(desx, y, stype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_OSCV_reg_+3A_desx">desx</code></td>
<td>
<p>numerical vecror of design points,</p>
</td></tr>
<tr><td><code id="h_OSCV_reg_+3A_y">y</code></td>
<td>
<p>numerical vecror of data points corresponding to the design points <code class="reqn">desx</code>,</p>
</td></tr>
<tr><td><code id="h_OSCV_reg_+3A_stype">stype</code></td>
<td>
<p>smoothness of the regression function: (<code class="reqn">stype=0</code>) smooth function; (<code class="reqn">stype=1</code>) nonsmooth function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the OSCV bandwidth for the data vector <code class="reqn">(desx,y)</code>. The Gaussian kernel is used for the cross-validation purposes and in the stage of computing the resulting local linear regression estimate. No additional rescaling of the computed bandwidth is needed. The smoothness of the regression function <code class="reqn">stype</code>, essentially, determines the value of the bandwidth rescaling constant that is chosen in the body of the function. Thus, the constant is equal to 0.6168471 in the smooth case, and 0.5730 in the nonsmooth case. See Savchuk, Hart and Sheather (2016). The OSCV bandwidth is the minimizer of the OSCV function <code><a href="#topic+OSCV_reg">OSCV_reg</a></code>.
</p>


<h3>Value</h3>

<p>The OSCV bandwidth (scalar).
</p>


<h3>References</h3>


<ul>
<li><p> Hart, J.D. and Yi, S. (1998). One-sided cross-validation. <em>Journal of the American Statistical Association</em>, 93(442), 620-631.
</p>
</li>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2013). One-sided cross-validation for nonsmooth regression functions. <em>Journal of Nonparametric Statistics</em>, 25(4), 889-904.
</p>
</li>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2016). Corrigendum to &quot;One-sided cross-validation for nonsmooth regression functions&quot;. <em>Journal of Nonparametric Statistics</em>, 28(4), 875-877.
</p>
</li>
<li><p> Savchuk, O.Y., Hart, J.D. (2017). Fully robust one-sided cross-validation for regression functions. <em>Computational Statistics</em>, doi:10.1007/s00180-017-0713-7.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+OSCV_reg">OSCV_reg</a></code>, <code><a href="#topic+loclin">loclin</a></code>, <code><a href="#topic+C_smooth">C_smooth</a></code>, <code><a href="#topic+h_OSCV_dens">h_OSCV_dens</a></code>, <code><a href="#topic+h_ASE_reg">h_ASE_reg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example (Old Faithful geyser)
xdat=faithful[[2]]     # waiting time
ydat=faithful[[1]]     # eruption duration
u=seq(40,100,len=1000)
h_oscv=round(h_OSCV_reg(xdat,ydat,0),digits=4)
l=loclin(u,xdat,ydat,h_oscv)
dev.new()
plot(xdat,ydat,pch=20,cex=1.5,cex.axis=1.7,cex.lab=1.7,xlab="waiting time",
ylab="eruption duration")
lines(u,l,'l',lwd=3)
title(main="Data and LLE",cex.main=1.7)
legend(35,5,legend=paste("h_OSCV=",h_oscv),cex=2,bty="n")
legend(80,3,legend="n=272",cex=2,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='ISE_fstar'>The ISE function in the kernel density estimation (KDE) context in the case when the underlying density is <code><a href="#topic+fstar">fstar</a></code>.</h2><span id='topic+ISE_fstar'></span>

<h3>Description</h3>

<p>Computing the ISE function for the Gaussian density estimator obtained from a random sample of size <code class="reqn">n</code> generated from <code><a href="#topic+fstar">fstar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISE_fstar(h, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISE_fstar_+3A_h">h</code></td>
<td>
<p>numerical vector of bandwidth values,</p>
</td></tr>
<tr><td><code id="ISE_fstar_+3A_n">n</code></td>
<td>
<p>sample size (number of data points generated from <code><a href="#topic+fstar">fstar</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The integrated squared error (ISE) is a measure of closeness of the Gaussian density estimate computed from a data set generated from <code><a href="#topic+fstar">fstar</a></code> to the true density.
</p>


<h3>Value</h3>

<p>The vector of values of the ISE function for the correponsing vector of <code class="reqn">h</code> values.
</p>


<h3>References</h3>

<p>Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth density functions, arXiv:1703.05157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fstar">fstar</a></code>, <code><a href="#topic+sample_fstar">sample_fstar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dev.new()
harray=seq(0.05,1.5,len=1000)
ISEarray=ISE_fstar(harray,100)
h_ISE=round(harray[which.min(ISEarray)],digits=4)
dev.new()
plot(harray,ISEarray,lwd=3,'l',xlab="h",ylab="ISE",main="ISE(h)",cex.main=2,cex.lab=1.7,
cex.axis=1.7)
legend(0.35,ISEarray[5],legend=c("n=100",paste("h_ISE=",h_ISE)),cex=1.8,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='L_I'>The family of one-sided cross-validation kernels <code class="reqn">L_I</code>.</h2><span id='topic+L_I'></span>

<h3>Description</h3>

<p>The one-sided counterpart of the kernel <code><a href="#topic+H_I">H_I</a></code>. See expressions (15) and (8) of Savchuk and Hart (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L_I(u, alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L_I_+3A_u">u</code></td>
<td>
<p>numerical vector of argument values,</p>
</td></tr>
<tr><td><code id="L_I_+3A_alpha">alpha</code></td>
<td>
<p>first parameter of the cross-validation kernel <code class="reqn">L_I</code>,</p>
</td></tr>
<tr><td><code id="L_I_+3A_sigma">sigma</code></td>
<td>
<p>second parameter of the cross-validation kernel <code class="reqn">L_I</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The family of the one-sided cross-validation kernels <code class="reqn">L_I</code> indexed by the parameters <code class="reqn">-\infty&lt;\alpha&lt;\infty</code> and <code class="reqn">\sigma&gt;0</code>. This family is used in the OSCV implementations in both regression context (see Savchuk and Hart (2017)) and density estimation context (see Savchuk (2017)). The special members of the family: </p>
<ul>
<li><p> The <em> robust</em> kernel used in Savchuk and Hart (2017) and Savchuk (2017) is obtained by setting  <code class="reqn">\alpha=16.8954588</code> and <code class="reqn">\sigma=1.01</code>; </p>
</li>
<li><p>  The one-sided Gaussian kernel <code class="reqn">L_G</code> is obtained by either setting <code class="reqn">\alpha=0</code> for any <code class="reqn">\sigma&gt;0</code> or by setting <code class="reqn">\sigma=1</code> for any <code class="reqn">-\infty&lt;\alpha&lt;\infty</code>.</p>
</li></ul>
<p> The bandwidth selected by <code class="reqn">L_I</code> should be multiplied by a reascaling constant before it is used in computing the ultimate Gaussian (regression or density) estimate. In the case of a smooth (regression or density) function the rescaling constant is <code><a href="#topic+C_smooth">C_smooth</a></code>.
</p>


<h3>Value</h3>

<p>The value of <code class="reqn">L_I(u;\alpha,\sigma)</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Savchuk, O.Y., Hart, J.D. (2017). Fully robust one-sided cross-validation for regression functions. <em>Computational Statistics</em>, doi:10.1007/s00180-017-0713-7.
</p>
</li>
<li><p> Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth density functions, arXiv:1703.05157.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+H_I">H_I</a></code>, <code><a href="#topic+C_smooth">C_smooth</a></code>, <code><a href="#topic+OSCV_LI_dens">OSCV_LI_dens</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Plotting the robust one-sided kernel from Savchuk and Hart (2017) with 
# alpha=16.8954588 and sigma=1.01.
u=seq(-1,5,len=1000)
rker=L_I(u,16.8954588,1.01)
Gker=L_I(u,0,1)
dev.new()
plot(u,rker,'l',lwd=3,cex.axis=1.7, cex.lab=1.7)
title(main="One-sided kernels: L_I (robust) and L_G",cex=1.7)
lines(u,Gker,lty="dashed",lwd=3)
legend(0.5,2.5,lty=c("solid","dashed"),lwd=c(3,3),legend=c("L_I","L_G"),cex=1.7)
legend(2,1.5,legend=c("alpha=16.8955","sigma=1.01"),cex=1.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='loclin'>Computing the local linear estimate (LLE).</h2><span id='topic+loclin'></span>

<h3>Description</h3>

<p>Computing the LLE based on data <code class="reqn">(desx,y)</code> over the given vector of the argument values <code class="reqn">u</code>. The Gausssian kernel is used. See expression (3) in Savchuk and Hart (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loclin(u, desx, y, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loclin_+3A_u">u</code></td>
<td>
<p>numerical vector of argument values,</p>
</td></tr>
<tr><td><code id="loclin_+3A_desx">desx</code></td>
<td>
<p>numerical vecror of design points,</p>
</td></tr>
<tr><td><code id="loclin_+3A_y">y</code></td>
<td>
<p>numerical vecror of data values (corresponding to the specified design points <code class="reqn">desx</code>),</p>
</td></tr>
<tr><td><code id="loclin_+3A_h">h</code></td>
<td>
<p>numerical bandwidth value (scalar).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the LLE based on the Gaussian kernel for the specified vector of the argument values <code class="reqn">u</code> and given vectors of design points <code class="reqn">desx</code> and the corresponding data values <code class="reqn">y</code>.
</p>


<h3>Value</h3>

<p>Numerical vector of the LLE values computed over the specified vector of <code class="reqn">u</code> points.
</p>


<h3>References</h3>


<ul>
<li><p> Clevelend, W.S. (1979). Robust locally weighted regression and smoothing scatterplots. <em>Journal of the American Statistical Association</em>, 74(368), 829-836.
</p>
</li>
<li><p>  Savchuk, O.Y., Hart, J.D. (2017). Fully robust one-sided cross-validation for regression functions. <em>Computational Statistics</em>, doi:10.1007/s00180-017-0713-7.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+OSCV_reg">OSCV_reg</a></code>, <code><a href="#topic+h_OSCV_reg">h_OSCV_reg</a></code>, <code><a href="#topic+ASE_reg">ASE_reg</a></code>, <code><a href="#topic+h_ASE_reg">h_ASE_reg</a></code>, <code><a href="#topic+CV_reg">CV_reg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example (simulated data).
n=200
dx=(1:n-0.5)/n
regf=2*dx^10*(1-dx)^2+dx^2*(1-dx)^10
u=seq(0,1,len=1000)
ydat=regf+rnorm(n,sd=0.002)
dev.new()
plot(dx,regf,'l',lty="dashed",lwd=3,xlim=c(0,1),ylim=c(1.1*min(ydat),1.1*max(ydat)),
cex.axis=1.7,cex.lab=1.7)
title(main="Function, generated data, and LLE",cex.main=1.5)
points(dx,ydat,pch=20,cex=1.5)
lines(u,loclin(u,dx,ydat,0.05),lwd=3,col="blue")
legend(0,1.1*max(ydat),legend=c("LLE based on h=0.05","true regression function"),
lwd=c(2,3),lty=c("solid","dashed"),col=c("blue","black"),cex=1.5,bty="n")
legend(0.7,0.5*min(ydat),legend="n=200",cex=1.7,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='OSCV_Epan_dens'>The OSCV function based on <code class="reqn">L_E</code>, the one-sided Epanechnikov kernel, in the kernel density estimation (KDE) context.</h2><span id='topic+OSCV_Epan_dens'></span>

<h3>Description</h3>

<p>Computing the values of the <code class="reqn">L_E</code>-based OSCV function in the density estimation context. See Martinez-Miranda et al. (2009) and Savchuk (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSCV_Epan_dens(h, dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OSCV_Epan_dens_+3A_h">h</code></td>
<td>
<p>numerical vector of bandwidth values,</p>
</td></tr>
<tr><td><code id="OSCV_Epan_dens_+3A_dat">dat</code></td>
<td>
<p>numerical vecror of data values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the values of the OSCV function for the given bandwidth vector <code class="reqn">h</code> and data vector <code class="reqn">dat</code>. The function is based on the one-sided Epanechnikov kernel <code class="reqn">L_E</code>. The function's minimizer is to be multiplied by the appropriate rescaling constant before it can be used to compute the ultimate kernel density estimate. The formula for the rescaling constant depends on <em>smothness</em> of the density and on the <em>kernel</em> used in computing the ultimate density estimate.
</p>


<h3>Value</h3>

<p>The vector of values of the OSCV function for the correponsing vector of <code class="reqn">h</code> values.
</p>


<h3>References</h3>


<ul>
<li><p> Martinez-Miranda, M.D., Nielsen, J. P., and Sperlich, S. (2009). One sided cross validation for density estimation. In <em>Operational Risk Towards Basel III: Best Practices and Issues in Modeling, Management and Regulation</em>, 177-196.
</p>
</li>
<li><p> Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth densty functions, arXiv:1703.05157.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+OSCV_Gauss_dens">OSCV_Gauss_dens</a></code>, <code><a href="#topic+OSCV_LI_dens">OSCV_LI_dens</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1 (Data on n=272 eruption duration of the Old Faithful geyser).
data=faithful[,1]
har=seq(0.05,1,len=1000)
dev.new()
plot(har,OSCV_Epan_dens(har,data),lwd=3,'l',xlab="h",ylab="L_E-based OSCV",
main="L_E_based OSCV for the data on eruption duration",cex.main=1.5,cex.lab=1.7,cex.axis=1.7)
h_min=round(optimize(OSCV_Epan_dens,c(0.001,1),tol=0.001,dat=data)$minimum, digits=4)
legend(0.1,-0.1,legend=c("n=272",paste("h_min=",h_min)),cex=2)
# The above graph appears in Savchuk (2017).

# Example 2 (Data set of size n=100 is generated from the standard normal density).
dat_norm=rnorm(100)
harray=seq(0.25,4.25,len=1000)
OSCVarray=OSCV_Epan_dens(harray,dat_norm)
dev.new()
plot(harray,OSCVarray,lwd=3,'l',xlab="h",ylab="L_E-based OSCV",
main="L_E-based OSCV for data generated from N(0,1)", cex.main=1.5,cex.lab=1.7,cex.axis=1.7)
h_min_norm=round(optimize(OSCV_Epan_dens,c(0.1,4),tol=0.001,dat=dat_norm)$minimum, digits=4)
legend(0.5,OSCVarray[1],legend=c("n=100",paste("h_min=",h_min_norm)),cex=2,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='OSCV_Gauss_dens'>The OSCV function based on <code class="reqn">L_G</code>, the one-sided Gaussian kernel, in the kernel density estimation (KDE) context.</h2><span id='topic+OSCV_Gauss_dens'></span>

<h3>Description</h3>

<p>Computing the values of the <code class="reqn">L_G</code>-based OSCV function in the density estimation context. See Savchuk (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSCV_Gauss_dens(h, dat, stype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OSCV_Gauss_dens_+3A_h">h</code></td>
<td>
<p>numerical vector of bandwidth values,</p>
</td></tr>
<tr><td><code id="OSCV_Gauss_dens_+3A_dat">dat</code></td>
<td>
<p>numerical vecror of data values,</p>
</td></tr>
<tr><td><code id="OSCV_Gauss_dens_+3A_stype">stype</code></td>
<td>
<p>specifies (anticipated) smoothness of the density function. Thus, <code class="reqn">stype=0</code> corresponds to the <em>smooth</em> density, whereas <code class="reqn">stype=1</code> corresponds to the <em>nonsmooth</em> density.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the values of the OSCV function for the given bandwidth vector <code class="reqn">h</code> and data vector <code class="reqn">dat</code>. The function is based on the one-sided Gaussian kernel <code class="reqn">L_G</code>. The (anticipated) smoothness of the underlying density function is to be specified. Thus, </p>
<ul>
<li> <p><code class="reqn">stype=0</code> corresponds to the smooth density; </p>
</li>
<li> <p><code class="reqn">stype=1</code> corresponds to the nonsmooth density.</p>
</li></ul>
<p> It is usually assumed that the density is smooth if no preliminary information about its nonsmoothness is available. The function's minimizer <code><a href="#topic+h_OSCV_dens">h_OSCV_dens</a></code> is to be used without additional rescaling to compute the ultimate Gaussian density estimate.
</p>


<h3>Value</h3>

<p>The vector of values of the OSCV function for the correponsing vector of <code class="reqn">h</code> values.
</p>


<h3>References</h3>

<p>Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth densty functions, arXiv:1703.05157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+h_OSCV_dens">h_OSCV_dens</a></code>, <code><a href="#topic+OSCV_Epan_dens">OSCV_Epan_dens</a></code>, <code><a href="#topic+OSCV_LI_dens">OSCV_LI_dens</a></code>, <code><a href="#topic+C_smooth">C_smooth</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat_norm=rnorm(300)   #generating random sample of size n=300 from the standard normal density.
h_oscv=round(h_OSCV_dens(dat_norm,0),digits=4)
y=density(dat_norm,bw=h_oscv)
dev.new()
plot(y,lwd=3,cex.lab=1.7,cex.axis=1.7,cex.main=1.7,xlab=paste("n=100, h_OSCV=",h_oscv),
main="Standard normal density estimate by OSCV",ylim=c(0,0.45),xlim=c(-4.5,4.5))
u=seq(-5,5,len=1000)
lines(u,dnorm(u),lwd=3,lty="dashed",col="blue")
legend(0.75,0.4,legend=c("OSCV estimate","N(0,1) density"),lwd=c(3,3),lty=c("solid","dashed"),
col=c("black","blue"),bty="n",cex=1.25)

## End(Not run)
</code></pre>

<hr>
<h2 id='OSCV_LI_dens'>The OSCV function based on the kernel <code><a href="#topic+L_I">L_I</a></code> in the density estimation (KDE) context.</h2><span id='topic+OSCV_LI_dens'></span>

<h3>Description</h3>

<p>Computing the values of the <code class="reqn">L_I</code>-based OSCV function in the density estimation context. See Savchuk (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSCV_LI_dens(h, dat, alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OSCV_LI_dens_+3A_h">h</code></td>
<td>
<p>numerical vector of bandwidth values,</p>
</td></tr>
<tr><td><code id="OSCV_LI_dens_+3A_dat">dat</code></td>
<td>
<p>numerical vecror of data values,</p>
</td></tr>
<tr><td><code id="OSCV_LI_dens_+3A_alpha">alpha</code></td>
<td>
<p>first parameter of the kernel <code class="reqn">L_I</code>,</p>
</td></tr>
<tr><td><code id="OSCV_LI_dens_+3A_sigma">sigma</code></td>
<td>
<p>second parameter of the kernel <code class="reqn">L_I</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the OSCV function for the given vector of bandwidth values <code class="reqn">h</code> and the data vector <code class="reqn">dat</code>. The function is based on the one-sided kernel <code><a href="#topic+L_I">L_I</a></code> that depends on the parameters <code class="reqn">\alpha</code> and <code class="reqn">\sigma</code>. The kernel <code class="reqn">L_I</code> is robust in the special case of <code class="reqn">\alpha=16.8954588</code> and <code class="reqn">\sigma=1.01</code>. The other special case is obtained when either of the following holds: </p>
<ul>
<li> <p><code class="reqn">\alpha=0</code> for any <code class="reqn">\sigma&gt;0</code>; </p>
</li>
<li> <p><code class="reqn">\sigma=1</code> for any <code class="reqn">-\infty&lt;\alpha&lt;\infty</code>.</p>
</li></ul>
<p> In the above cases the kernel <code class="reqn">L_I</code> reduces to the one-sided Gaussian kernel <code class="reqn">L_G</code>.  The function's minimizer is to be used without additional rescaling to compute the ultimate Gaussian density estimate under the assumption that the underlying density is smooth.
</p>


<h3>Value</h3>

<p>The vector of values of the OSCV function for the correponsing vector of <code class="reqn">h</code> values.
</p>


<h3>References</h3>

<p>Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth density functions, arXiv:1703.05157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+OSCV_Gauss_dens">OSCV_Gauss_dens</a></code>, <code><a href="#topic+OSCV_Epan_dens">OSCV_Epan_dens</a></code>, <code><a href="#topic+C_smooth">C_smooth</a></code>, <code><a href="#topic+L_I">L_I</a></code>, <code><a href="#topic+H_I">H_I</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1 (Old Faithful geyser data)
dev.new()
data=faithful[,1]         # Data on n=272 eruption duration of the Old Faithful geyser.
harray=seq(0.025,0.6,len=50)
alp=16.8954588
sig=1.01
plot(harray,OSCV_LI_dens(harray,data,alpha=alp,sigma=sig),lwd=3,'l',xlab="h",
ylab="L_I-based OSCV",main="OSCV_LI(h) for eruption duration",cex.main=1.5,cex.lab=1.7,
cex.axis=1.7)
h_OSCV_LI=round(optimize(OSCV_LI_dens,c(0.001,0.5),tol=0.001,dat=data,alpha=16.8954588,
sigma=1.01)$minimum,digits=4)
legend(0.01,-0.2,legend=c("n=272",paste("h_OSCV_LI=",h_OSCV_LI)),cex=1.8,bty="n")
legend(0.25,-0.33,legend=c("Parameters of L_I:", paste("alpha=",alp),
paste("sigma=",sig)),cex=1.7,bty="n")

# Example 2 (Simulated example)
dat_norm=rnorm(100)   #generating a random sample of size n=100 from the N(0,1) density
harray=seq(0.05,1.5,len=100)
OSCVarray=OSCV_LI_dens(harray,dat=dat_norm,16.8954588,1.01)
dev.new()
plot(harray,OSCVarray,lwd=3,'l',xlab="h",ylab="L_I-based OSCV",
main="OSCV_LI(h) for data generated from N(0,1)",cex.main=1.5,cex.lab=1.7,cex.axis=1.7)
h_OSCV_LI_norm=round(optimize(OSCV_LI_dens,c(0.001,1),tol=0.001,
dat=dat_norm,16.8954588,1.01)$minimum,digits=4)
legend(0,OSCVarray[1],legend=c("n=100",paste("h_OSCV_LI=",h_OSCV_LI_norm),
"Parameters of the robust kernel L_I:","alpha=16.8954588", "sigma=1.01"),cex=1.5,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='OSCV_reg'>The OSCV function in the regression context.</h2><span id='topic+OSCV_reg'></span>

<h3>Description</h3>

<p>Computing <code class="reqn">OSCV(b)</code>, the value of the OSCV function in the regression context, defined by expression (9) of Savchuk and Hart (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSCV_reg(b, desx, y, ktype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OSCV_reg_+3A_b">b</code></td>
<td>
<p>numerical vector of bandwidth values,</p>
</td></tr>
<tr><td><code id="OSCV_reg_+3A_desx">desx</code></td>
<td>
<p>numerical vecror of design points,</p>
</td></tr>
<tr><td><code id="OSCV_reg_+3A_y">y</code></td>
<td>
<p>numerical vecror of data points corresponding to the design points <code class="reqn">desx</code>,</p>
</td></tr>
<tr><td><code id="OSCV_reg_+3A_ktype">ktype</code></td>
<td>
<p>making choice between two cross-validation kernels:  (<code class="reqn">ktype=0</code>) corresponds to the Gaussian kernel; (<code class="reqn">ktype=1</code>) corresponds to the robust kernel <code><a href="#topic+H_I">H_I</a></code> with <code class="reqn">(\alpha,\sigma)=(16.8954588,1.01)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of  <code class="reqn">OSCV(b)</code> for given <code class="reqn">b</code> (bandwidth vector) and the data values <code class="reqn">y</code> corresponding to the design points <code class="reqn">desx</code>. No preliminary sorting of the data (according to the <code class="reqn">desx</code> variable) is needed. The value of <code class="reqn">m=4</code> is used. Two choices of the two-sided cross-validation kernel are available: </p>
<ul>
<li><p> (<code class="reqn">ktype=0</code>) Gaussian kernel; </p>
</li>
<li><p> (<code class="reqn">ktype=1</code>) robust kernel <code><a href="#topic+H_I">H_I</a></code> defined by expression (15) of Savchuk and Hart (2017) with <code class="reqn">(\alpha,\sigma)=(16.8954588,1.01)</code>.</p>
</li></ul>



<h3>Value</h3>

<p>The vector of values of <code class="reqn">OSCV(b)</code> for the correponsing vector of <code class="reqn">b</code> values.
</p>


<h3>References</h3>


<ul>
<li><p> Savchuk, O.Y., Hart, J.D. (2017). Fully robust one-sided cross-validation for regression functions. <em>Computational Statistics</em>, doi:10.1007/s00180-017-0713-7.
</p>
</li>
<li><p> Hart, J.D. and Yi, S. (1998) One-sided cross-validation. <em>Journal of the American Statistical Association</em>, 93(442), 620-631.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+h_OSCV_reg">h_OSCV_reg</a></code>, <code><a href="#topic+H_I">H_I</a></code>, <code><a href="#topic+loclin">loclin</a></code>, <code><a href="#topic+C_smooth">C_smooth</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The Old Faithful geyser data set "faithful" is used. The sample size n=272.
# The OSCV curves based on the Gaussian kernel and the robust kernel H_I (with 
# alpha=16.8954588 and sigma=1.01) are plotted. The horizontal scales of the curves
# are changed such that their global minimizers are to be used in computing the
# Gaussian local linear estimates of the regression function.
xdat=faithful[[2]] #waiting time
ydat=faithful[[1]] #eruption duration
barray=seq(0.5,10,len=250)
C_gauss=C_smooth(1,1)
OSCV_gauss=OSCV_reg(barray/C_gauss,xdat,ydat,0)
h_gauss=round(h_OSCV_reg(xdat,ydat,0),digits=4)
dev.new()
plot(barray,OSCV_gauss,'l',lwd=3,cex.lab=1.7,cex.axis=1.7,xlab="h",ylab="OSCV criterion")
title(main="OSCV based on the Gaussian kernel",cex.main=1.7)
legend(2.5,0.25,legend=paste("h_min=",h_gauss),cex=2,bty="n")
C_H_I=C_smooth(16.8954588,1.01)
OSCV_H_I=OSCV_reg(barray/C_H_I,xdat,ydat,1)
h_H_I=round(barray[which.min(OSCV_H_I)],digits=4)
dev.new()
plot(barray,OSCV_H_I,'l',lwd=3,cex.lab=1.7,cex.axis=1.7,xlab="h",ylab="OSCV criterion",
ylim=c(0.15,0.5))
title(main="OSCV based on the robust kernel H_I",cex.main=1.7)
legend(2.5,0.4,legend=paste("h_min=",h_H_I),cex=2,bty="n")

## End(Not run)
</code></pre>

<hr>
<h2 id='reg3'>Nonsmooth regression function with six cusps.</h2><span id='topic+reg3'></span>

<h3>Description</h3>

<p>Nonsmooth regression function <code class="reqn">r_3</code> with six cusps used in the simulation studies in Savchuk et al. (2013) and Savchuk et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg3(u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reg3_+3A_u">u</code></td>
<td>
<p>numerical vecror of argument values in the range [0,1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nonsmooth function <code class="reqn">r_3</code> can be used in simulation studies.
</p>


<h3>Value</h3>

<p>The vector of values of <code class="reqn">r_3</code> corresponding to the values of the vector <code class="reqn">u</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Savchuk, O.Y., Hart, J.D., Sheather, S.J. (2013). One-sided cross-validation for nonsmooth regression functions. <em>Journal of Nonparametric Statistics</em>, 25(4), 889-904.
</p>
</li>
<li><p> Savchuk, O.Y., Hart, J.D. (2017). Fully robust one-sided cross-validation for regression functions. <em>Computational Statistics</em>, doi:10.1007/s00180-017-0713-7.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# n=250 data points are generated from r3 by adding the Gaussian noise with sigma=1/500.
# The fixed evenly spaced design is used.
u=seq(0,1,len=1000)
n=250
xdat=(1:n-0.5)/n
ydat=reg3(xdat)+rnorm(n,sd=1/500)
h_oscv=round(h_OSCV_reg(xdat,ydat,1),digits=4) # L_G-based OSCV based on nonsmooth constant
l=loclin(u,xdat,ydat,h_oscv)
dev.new()
plot(xdat,ydat,pch=20,cex=1.5,cex.axis=1.5,cex.lab=1.5,xlab="x",ylab="y",
ylim=c(min(ydat),1.2*max(ydat)))
lines(u,l,'l',lwd=3,col="blue")
lines(u,reg3(u),lwd=3,lty="dashed")
title(main="Data, true regression function and LLE",cex.main=1.7)
legend(-0.05,0.003,legend=paste("h_OSCV=",h_oscv),cex=2,bty="n")
legend(0.65,0.025, legend="n=250",cex=2,bty="n")
legend(0,1.28*max(ydat),legend=c("LLE based on h_OSCV","true regression function"),lwd=c(3,3),
lty=c("solid","dashed"),col=c("blue","black"),bty="n",cex=1.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='sample_fstar'>Taking a random sample from <code><a href="#topic+fstar">fstar</a></code>.</h2><span id='topic+sample_fstar'></span>

<h3>Description</h3>

<p>Taking a random sample of size <code class="reqn">n</code> from the density <code class="reqn">f^*</code> with seven cusps introduced in the article of Savchuk (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fstar(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_fstar_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density <code class="reqn">f^*</code> can be used in simulation studies.
</p>


<h3>Value</h3>

<p>The numerical vector of size <code class="reqn">n</code> of the data values.
</p>


<h3>References</h3>

<p>Savchuk, O.Y. (2017). One-sided cross-validation for nonsmooth density functions, arXiv:1703.05157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fstar">fstar</a></code>, <code><a href="#topic+ISE_fstar">ISE_fstar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dev.new()
plot(density(sample_fstar(5000),bw=0.1),lwd=2,ylim=c(0,0.32),xlab="argument",ylab="density",
main="KDE and the true density fstar",cex.lab=1.7, cex.axis=1.7,cex.main=1.7)
lines(seq(-3.5,3.5,len=1000),fstar(seq(-3.5,3.5,len=1000)),lwd=3,lty="dashed")
legend(-3,0.3,legend=c("KDE","True density","h=0.1","n=5000"),lwd=c(2,3),
lty=c("solid","dashed"),col=c("black","black","white","white"))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
