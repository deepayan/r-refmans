<!DOCTYPE html><html lang="en"><head><title>Help for package geodiv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geodiv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.calculate_met_focal'><p>Calculate Texture Metric for Single Pixel</p></a></li>
<li><a href='#.deg2rad'><p>Degree to Radian Conversion</p></a></li>
<li><a href='#.maxdist'><p>Estimate Maximum Correlation Length</p></a></li>
<li><a href='#.mindist'><p>Estimate Minimum Correlation Length</p></a></li>
<li><a href='#.rad2deg'><p>Radian to Degree Conversion</p></a></li>
<li><a href='#aacf'><p>Estimate the Areal Autocorrelation Function</p></a></li>
<li><a href='#area_above'><p>Area Above the Bearing Area Curve</p></a></li>
<li><a href='#bearing_area'><p>Calculates the Rotated Bearing Area Curve</p></a></li>
<li><a href='#bestfitplane'><p>Finds the Best Fit Polynomial Surface</p></a></li>
<li><a href='#fftshift'><p>Fourier Transform Shift</p></a></li>
<li><a href='#find_flat'><p>Finds the Flattest Part of the Bearing Area Curve</p></a></li>
<li><a href='#findpeaks'><p>Find Local Peaks</p></a></li>
<li><a href='#findvalleys'><p>Find Local Valleys</p></a></li>
<li><a href='#fitplane'><p>Calculate a Least Squares Polynomial Surface</p></a></li>
<li><a href='#flatsa'><p>Flattened Surface Area</p></a></li>
<li><a href='#focal_metrics'><p>Calculate Texture Metrics per Pixel</p></a></li>
<li><a href='#height_ba'><p>Value of the Bearing Area Curve at a Specified Value</p></a></li>
<li><a href='#normforest'><p>NDVI errors for a portion of southwestern Oregon, USA.</p></a></li>
<li><a href='#orelevation'><p>SRTM elevation for a portion of southwestern Oregon, USA.</p></a></li>
<li><a href='#orforest'><p>NDVI for a portion of southwestern Oregon, USA.</p></a></li>
<li><a href='#pad_edges'><p>Extend edges of a matrix.</p></a></li>
<li><a href='#plot_ba_curve'><p>Plots the Bearing Area Curve</p></a></li>
<li><a href='#remove_plane'><p>Removes the Best Fit Polynomial Surface</p></a></li>
<li><a href='#rotate'><p>Rotates a matrix 180 degrees.</p></a></li>
<li><a href='#s10z'><p>Ten-Point Height</p></a></li>
<li><a href='#sa'><p>Calculates the Average Roughness of a Surface</p></a></li>
<li><a href='#sbi'><p>Surface Bearing Index</p></a></li>
<li><a href='#sci'><p>Core Fluid Retention Index</p></a></li>
<li><a href='#scl'><p>Calculate Correlation Length</p></a></li>
<li><a href='#sdc'><p>Height Intervals of the Bearing Area Curve</p></a></li>
<li><a href='#sdq'><p>Root Mean Square Slope of Surface</p></a></li>
<li><a href='#sdq6'><p>Root Area Mean Square Slope of Surface</p></a></li>
<li><a href='#sdr'><p>Surface Area Ratio</p></a></li>
<li><a href='#sds'><p>Summit Density</p></a></li>
<li><a href='#sfd'><p>Calculate the fractal dimension of a raster.</p></a></li>
<li><a href='#sfd_'><p>Calculate the fractal dimension of a raster (C function).</p></a></li>
<li><a href='#simpsons'><p>Simpson's Rule Empirical Area Under a Curve</p></a></li>
<li><a href='#sk'><p>Core Roughness Depth</p></a></li>
<li><a href='#sku'><p>Calculates the Kurtosis of Raster Values</p></a></li>
<li><a href='#slopecalc'><p>Determines the Slopes Along the Bearing Area Curve</p></a></li>
<li><a href='#slopemeans'><p>Determines the Average Slope Along Larger Segments of</p>
the Bearing Area Curve</a></li>
<li><a href='#smean'><p>Calculates the Mean Peak Height of a Surface Image</p></a></li>
<li><a href='#sph'><p>Calculates the Maximum Peak Height of a Surface Image</p></a></li>
<li><a href='#spk'><p>Reduced Peak Height</p></a></li>
<li><a href='#sq'><p>Calculates the Root Mean Square Roughness of a Surface</p></a></li>
<li><a href='#srw'><p>Radial Wavelength Metrics</p></a></li>
<li><a href='#ssc'><p>Mean Summit Curvature</p></a></li>
<li><a href='#ssk'><p>Calculates the Skewness of Raster Values</p></a></li>
<li><a href='#std'><p>Texture Direction Metrics</p></a></li>
<li><a href='#stxr'><p>Estimate Texture Aspect Ratio</p></a></li>
<li><a href='#surface_area'><p>Surface Area</p></a></li>
<li><a href='#sv'><p>Calculates the Maximum Valley Depth of a Surface Image</p></a></li>
<li><a href='#svi'><p>Valley Fluid Retention Index</p></a></li>
<li><a href='#svk'><p>Reduced Valley Depth</p></a></li>
<li><a href='#texture_image'><p>Calculate Texture Metrics per Pixel</p></a></li>
<li><a href='#window_metric'><p>Calculate Texture Metric for Single Pixel</p></a></li>
<li><a href='#zshift'><p>Offset Raster or Matrix Values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Calculating Gradient Surface Metrics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Annie C. Smith, Phoebe Zarnetske, Kyla Dahlin, Adam Wilson, Andrew Latimer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Annie C. Smith &lt;annie.smith@dnr.wa.gov&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for calculating gradient surface metrics for
    continuous analysis of landscape features. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bioXgeo/geodiv">https://github.com/bioXgeo/geodiv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bioXgeo/geodiv/issues">https://github.com/bioXgeo/geodiv/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.7.8), pracma (&ge; 2.2.2), spatial (&ge; 7.3-11),
e1071 (&ge; 1.7-0), parallel (&ge; 3.5.0), sf (&ge; 0.7-4), zoo (&ge;
1.8-5), Rcpp (&ge; 1.0.1), terra (&ge; 1.7), rlang</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, R.rsp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-05 17:26:31 UTC; dingbat</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-05 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.calculate_met_focal'>Calculate Texture Metric for Single Pixel</h2><span id='topic+.calculate_met_focal'></span>

<h3>Description</h3>

<p>Calculates the various texture metrics over a window centered
on an individual pixel. This function is modified slightly from the
<code>calculate_lsm_focal</code> function in the <em>landscapemetrics</em> package (Hesselbarth et al. 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.calculate_met_focal(landscape, n_row, n_col, points, what, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".calculate_met_focal_+3A_landscape">landscape</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id=".calculate_met_focal_+3A_n_row">n_row</code></td>
<td>
<p>Numeric. Number of rows in focal window.</p>
</td></tr>
<tr><td><code id=".calculate_met_focal_+3A_n_col">n_col</code></td>
<td>
<p>Numeric. Number of columns in focal window.</p>
</td></tr>
<tr><td><code id=".calculate_met_focal_+3A_points">points</code></td>
<td>
<p>Dataframe. Coordinates and values of cells, calculated with the *landscapemetrics*
<code>raster_to_points</code> function.</p>
</td></tr>
<tr><td><code id=".calculate_met_focal_+3A_what">what</code></td>
<td>
<p>Character. Metric to calculate for each window. Metrics
from the geodiv package are listed below.</p>
</td></tr>
<tr><td><code id=".calculate_met_focal_+3A_...">...</code></td>
<td>
<p>Additional arguments for the metric functions. All applicable arguments
will be applied to the entire list of metrics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Metrics from geodiv package:
</p>

<ol>
<li><p><code>'sa'</code>: average surface roughness
</p>
</li>
<li><p><code>'sq'</code>: root mean square roughness
</p>
</li>
<li><p><code>'s10z'</code>: ten-point height
</p>
</li>
<li><p><code>'sdq'</code>: root mean square slope of surface, 2-point method
</p>
</li>
<li><p><code>'sdq6'</code>: root mean square slope of surface, 7-point method
</p>
</li>
<li><p><code>'sdr'</code>: surface area ratio
</p>
</li>
<li><p><code>'sbi'</code>: surface bearing index
</p>
</li>
<li><p><code>'sci'</code>: core fluid retention index
</p>
</li>
<li><p><code>'ssk'</code>: skewness
</p>
</li>
<li><p><code>'sku'</code>: kurtosis
</p>
</li>
<li><p><code>'sds'</code>: summit density
</p>
</li>
<li><p><code>'sfd'</code>: 3d fractal dimension
</p>
</li>
<li><p><code>'srw'</code>: dominant radial wavelength, radial wavelength index, mean half wavelength
</p>
</li>
<li><p><code>'std'</code>: angle of dominating texture, texture direction index
</p>
</li>
<li><p><code>'svi'</code>: valley fluid retention index
</p>
</li>
<li><p><code>'stxr'</code>: texture aspect ratio
</p>
</li>
<li><p><code>'ssc'</code>: mean summit curvature
</p>
</li>
<li><p><code>'sv'</code>: maximum valley depth
</p>
</li>
<li><p><code>'sph'</code>: maximum peak height
</p>
</li>
<li><p><code>'sk'</code>: core roughness depth
</p>
</li>
<li><p><code>'smean'</code>: mean peak height
</p>
</li>
<li><p><code>'svk'</code>: reduced valley depth
</p>
</li>
<li><p><code>'spk'</code>: reduced peak height
</p>
</li>
<li><p><code>'scl'</code>: correlation length
</p>
</li>
<li><p><code>'sdc'</code>: bearing area curve height interval
</p>
</li></ol>



<h3>Value</h3>

<p>The metric value over the window.
</p>


<h3>References</h3>


<ol>
<li><p>Hesselbarth, M.H.K., Sciaini, M., With, K.A., Wiegand, K., Nowosad, J. 2019.
landscapemetrics: an open-source R tool to calculate landscape metrics. - Ecography 42:1648-1657(ver. 0).
</p>
</li></ol>


<hr>
<h2 id='.deg2rad'>Degree to Radian Conversion</h2><span id='topic+.deg2rad'></span>

<h3>Description</h3>

<p>Converts degree value(s) to radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.deg2rad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".deg2rad_+3A_x">x</code></td>
<td>
<p>Numeric. Degree value(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric of degree value(s).
</p>

<hr>
<h2 id='.maxdist'>Estimate Maximum Correlation Length</h2><span id='topic+.maxdist'></span>

<h3>Description</h3>

<p>Internal function to calculates the maximum distances to specified
autocorrelation values (e.g., 0.2) of the areal autocorrelation
function (AACF). All 180 degrees from the origin of the AACF image
are considered for the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.maxdist(threshold, aacfimg, distimg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".maxdist_+3A_threshold">threshold</code></td>
<td>
<p>A number with a value between 0 and 1. Indicates
the autocorrelation value to which the rates of decline are measured.</p>
</td></tr>
<tr><td><code id=".maxdist_+3A_aacfimg">aacfimg</code></td>
<td>
<p>A raster of the areal autocorrelation function. This
is the AACF raster split in two in terms of height.</p>
</td></tr>
<tr><td><code id=".maxdist_+3A_distimg">distimg</code></td>
<td>
<p>A raster of distances to all pixels from the center of the
original image. Distances are in meters if original raster was
unprojected, and are in map units (usually meters) if raster was projected
(see raster::distance documentation for more details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the maximum distances from an
autocorrelation value of 1 to the specified autocorrelation value &lt; 1.
Distances are meters if original raster was unprojected, and are in
map units (usually meters) if raster was projected (see
raster::distance documentation for more details).
</p>

<hr>
<h2 id='.mindist'>Estimate Minimum Correlation Length</h2><span id='topic+.mindist'></span>

<h3>Description</h3>

<p>Internal function to calculates the minimum distances to specified
autocorrelation values (e.g., 0.2) of the areal autocorrelation
function (AACF). All 180 degrees from the origin of the AACF image
are considered for the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mindist(threshold, aacfimg, distimg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".mindist_+3A_threshold">threshold</code></td>
<td>
<p>A number with a value between 0 and 1. Indicates
the autocorrelation value to which the rates of decline are measured.</p>
</td></tr>
<tr><td><code id=".mindist_+3A_aacfimg">aacfimg</code></td>
<td>
<p>A raster of the areal autocorrelation function. This
is the AACF raster split in two in terms of height.</p>
</td></tr>
<tr><td><code id=".mindist_+3A_distimg">distimg</code></td>
<td>
<p>A raster of distances to all pixels from the center of the
original image. Distances are in meters if original raster was
unprojected, and are in map units (usually meters) if raster was projected
(see raster::distance documentation for more details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the minimum distances from an
autocorrelation value of 1 to the specified autocorrelation value &lt; 1.
Distances are meters if original raster was unprojected, and are in
map units (usually meters) if raster was projected (see
raster::distance documentation for more details).
</p>

<hr>
<h2 id='.rad2deg'>Radian to Degree Conversion</h2><span id='topic+.rad2deg'></span>

<h3>Description</h3>

<p>Converts radian value(s) to degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rad2deg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rad2deg_+3A_x">x</code></td>
<td>
<p>Numeric. Radian value(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric of degree value(s).
</p>

<hr>
<h2 id='aacf'>Estimate the Areal Autocorrelation Function</h2><span id='topic+aacf'></span>

<h3>Description</h3>

<p>Calculates the areal autocorrelation function (AACF) as the
inverse of the Fourier power spectrum. <code>aacf(x)</code> returns
the AACF in both matrix and raster format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aacf(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aacf_+3A_x">x</code></td>
<td>
<p>An n x n raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster or matrix representation
of the AACF. Both raster and matrix values are normalized
so that the maximum is equal to 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate aacf img and matrix
aacf_out &lt;- aacf(normforest)

# plot resulting aacf image
terra::plot(aacf_out)
</code></pre>

<hr>
<h2 id='area_above'>Area Above the Bearing Area Curve</h2><span id='topic+area_above'></span>

<h3>Description</h3>

<p>Calculates the area above the bearing area curve from
points <code>a</code> to <code>b</code>. If a box is drawn around
a function with the upper-left at <code>a</code> and the
bottom-right at <code>b</code>, this function extracts the area
above the function within the box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area_above(f, a, b, n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="area_above_+3A_f">f</code></td>
<td>
<p>The function for the Bearing Area curve produced by
<code>stats::ecdf()</code>.</p>
</td></tr>
<tr><td><code id="area_above_+3A_a">a</code></td>
<td>
<p>Numeric. The left x boundary.</p>
</td></tr>
<tr><td><code id="area_above_+3A_b">b</code></td>
<td>
<p>Numeric. The right x boundary.</p>
</td></tr>
<tr><td><code id="area_above_+3A_n">n</code></td>
<td>
<p>Numeric. The number of subdivisions along the function
line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The area under the curve used to calculate area above the
curve is calculated as the numerical integral
of the Bearing Area function from <code>a</code> to <code>b</code>
using the trapezoid rule with n subdivisions. Assume
<code>a &lt; b</code> and <code>n</code> is a positive integer.
</p>


<h3>Value</h3>

<p>A numeric value representing the area above the curve with
x bounds <code>a</code> and <code>b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# basic values
z &lt;- terra::values(normforest)

# calculate cumulative probability density function of surface 'height' (= ndvi)
mod &lt;- ecdf((1 - z))

# valley fluid retention index = void volume in 'valley' zone
Svi &lt;- area_above(f = mod, b = 1, a = 0.8, n = 500)
</code></pre>

<hr>
<h2 id='bearing_area'>Calculates the Rotated Bearing Area Curve</h2><span id='topic+bearing_area'></span>

<h3>Description</h3>

<p>Finds a rotated version of the Bearing Area (Abbott-Firestone)
curve from a raster or matrix. The resulting function should be
rotated 90 degrees clockwise to get the actual Bearing
Area curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bearing_area(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bearing_area_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function describing the rotated Bearing Area curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# find the rotated Bearing Area curve.
ba_func &lt;- bearing_area(normforest)

# rotate the values and re-plot
xval &lt;- environment(ba_func)$y
yval &lt;- (1 - environment(ba_func)$x)
plot(yval ~ xval)
</code></pre>

<hr>
<h2 id='bestfitplane'>Finds the Best Fit Polynomial Surface</h2><span id='topic+bestfitplane'></span>

<h3>Description</h3>

<p>Finds the best fit polynomial surface for a raster or matrix. This
function tests least squares polynomial fits with orders of
0 - 3 and determines which order minimizes the error when the
fit is subtracted from the original image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestfitplane(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestfitplane_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster or matrix of the same size as the input with values
predicted from the best polynomial fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import raster image
data(orforest)
orforest &lt;- terra::unwrap(orforest)

# find the least squares polynomial surface
poly &lt;- bestfitplane(orforest)

# plot the fit
terra::plot(poly)
</code></pre>

<hr>
<h2 id='fftshift'>Fourier Transform Shift</h2><span id='topic+fftshift'></span>

<h3>Description</h3>

<p>This function serves to shift the zero-frequency component of the
Fourier transform to the center of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftshift(x, dim = -1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fftshift_+3A_x">x</code></td>
<td>
<p>An n x n Fourier transform matrix.</p>
</td></tr>
<tr><td><code id="fftshift_+3A_dim">dim</code></td>
<td>
<p>Which dimension to shift the matrix. -1 swaps up/down and
left/right. 1 swaps up/down. 2 swaps left/right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An n x n matrix with the zero-frequency component of
the Fourier transform in the center.
</p>


<h3>References</h3>

<p>#' This function was created from code posted by rayryeng at:
https://stackoverflow.com/questions/38230794/how-to-write-fftshift-and-ifftshift-in-r.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# convert to matrix form
M &lt;- ncol(normforest)
N &lt;- nrow(normforest)
zmat &lt;- matrix(terra::values(normforest), ncol = M, nrow = N, byrow = TRUE)

# calculate fourier transform and shift
ftmat &lt;- fft(zmat)
ftshift &lt;- fftshift(ftmat)

# plot real component
r &lt;- terra::setValues(normforest, Re(ftshift))
terra::plot(r)
</code></pre>

<hr>
<h2 id='find_flat'>Finds the Flattest Part of the Bearing Area Curve</h2><span id='topic+find_flat'></span>

<h3>Description</h3>

<p>Locates the flattest x percentage of the Bearing Area
curve. Meant to locate the flattest 40 percent of the
Bearing Area curve as used in several roughness parameter
calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_flat(x, perc = 0.4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_flat_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="find_flat_+3A_perc">perc</code></td>
<td>
<p>Numeric between 0 and 1. The percentage of
the curve over which to fit the line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the equation for the best fit
line, the predicted values from that line, the high
and low y-intercept values for the intersection points
of the line with the Bearing Area curve, and the high
and low x-intercept values for the intersection points
of the line with the Bearing Area curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# locate the flattest 40% of the bearing area curve
line_data &lt;- find_flat(normforest, perc = 0.4)

# extract the equation of the line
bf_line &lt;- line_data[[1]]
</code></pre>

<hr>
<h2 id='findpeaks'>Find Local Peaks</h2><span id='topic+findpeaks'></span>

<h3>Description</h3>

<p>Locates local peaks on a raster or matrix. A peak is defined as any pixel where
all 8 surrounding pixels have lower values, and the center pixel
has a positive value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findpeaks(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findpeaks_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of local peak locations (<code>x, y</code>) and
values (<code>val</code>). The raster or matrix location index (<code>ind</code>),
row (<code>row</code>), and column (<code>col</code>) are also listed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# locate peaks
peaks &lt;- findpeaks(normforest)

# calculate the summit density (# peaks/area)
N &lt;- ncol(normforest)
M &lt;- nrow(normforest)
Sds &lt;- nrow(peaks) / ((N - 1) * (M - 1))
</code></pre>

<hr>
<h2 id='findvalleys'>Find Local Valleys</h2><span id='topic+findvalleys'></span>

<h3>Description</h3>

<p>Locates local valleys on a raster or matrix. A valley is defined as any pixel where
all 8 surrounding pixels have higher values, and the center pixel
has a negative value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findvalleys(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findvalleys_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of local valley locations (<code>x, y</code>) and
values (<code>val</code>). The raster or matrix location index (<code>ind</code>),
row (<code>row</code>), and column (<code>col</code>) are also listed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# locate peaks and valleys
peaks &lt;- findpeaks(normforest)
valleys &lt;- findvalleys(normforest)

# find top 5 peaks, valleys
top_peaks &lt;- peaks[order(peaks$val, decreasing = TRUE)[1:5],]
bottom_valleys &lt;- valleys[order(valleys$val)[1:5],]

# calculate the ten-point height
S10z &lt;- (sum(top_peaks$val) + sum(abs(bottom_valleys$val))) / 5
</code></pre>

<hr>
<h2 id='fitplane'>Calculate a Least Squares Polynomial Surface</h2><span id='topic+fitplane'></span>

<h3>Description</h3>

<p>Fits a polynomial surface of order <code>n</code> to a raster
or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitplane(x, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitplane_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="fitplane_+3A_order">order</code></td>
<td>
<p>Numeric. Indicates the polynomial order to be fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with values predicted from the polynomial fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import raster image
data(orforest)
orforest &lt;- terra::unwrap(orforest)

# find the 2nd order least squares polynomial surface
polyfit &lt;- fitplane(orforest, order = 2)

# create raster of polyfit
x &lt;- terra::setValues(orforest, polyfit)

# plot the fit
terra::plot(x)
</code></pre>

<hr>
<h2 id='flatsa'>Flattened Surface Area</h2><span id='topic+flatsa'></span>

<h3>Description</h3>

<p>Calculates the surface area of a flat raster or matrix with the
same x, y bounds as the study surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatsa(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatsa_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function scales both x and y to between 0 and 1. This
is done because most satellite data have units where the x,
y units do not equal the z units and because the flat
surface area is usually compared to the actual surface area.
Surface area is calculated over the sample area (N-1, M-1).
</p>


<h3>Value</h3>

<p>A numeric value representing the scaled surface
area of a flattened surface with the same x, y bounds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate flattened surface area
flatsa(normforest)
</code></pre>

<hr>
<h2 id='focal_metrics'>Calculate Texture Metrics per Pixel</h2><span id='topic+focal_metrics'></span>

<h3>Description</h3>

<p>Calculates the various texture metrics over windows centered
on individual pixels. This creates a continuous surface of the
texture metric.
This function is a modified version of the <code>window_lsm</code> function from the
<em>landscapemetrics</em> package (Hesselbarth et al. 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focal_metrics(x, window, metrics, progress, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="focal_metrics_+3A_x">x</code></td>
<td>
<p>A raster or matrix. Image over which to apply focal window calculations.</p>
</td></tr>
<tr><td><code id="focal_metrics_+3A_window">window</code></td>
<td>
<p>Matrix. The focal window used to create the image.</p>
</td></tr>
<tr><td><code id="focal_metrics_+3A_metrics">metrics</code></td>
<td>
<p>List. List of metrics to apply. Function names must be strings.</p>
</td></tr>
<tr><td><code id="focal_metrics_+3A_progress">progress</code></td>
<td>
<p>Logical. Display progress through metrics list?</p>
</td></tr>
<tr><td><code id="focal_metrics_+3A_...">...</code></td>
<td>
<p>Additional arguments for the metric functions. All applicable arguments
will be applied to the entire list of metrics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Metrics available from geodiv package:
</p>

<ol>
<li><p><code>'sa'</code>: average surface roughness
</p>
</li>
<li><p><code>'sq'</code>: root mean square roughness
</p>
</li>
<li><p><code>'s10z'</code>: ten-point height
</p>
</li>
<li><p><code>'sdq'</code>: root mean square slope of surface, 2-point method
</p>
</li>
<li><p><code>'sdq6'</code>: root mean square slope of surface, 7-point method
</p>
</li>
<li><p><code>'sdr'</code>: surface area ratio
</p>
</li>
<li><p><code>'sbi'</code>: surface bearing index
</p>
</li>
<li><p><code>'sci'</code>: core fluid retention index
</p>
</li>
<li><p><code>'ssk'</code>: skewness
</p>
</li>
<li><p><code>'sku'</code>: kurtosis
</p>
</li>
<li><p><code>'sds'</code>: summit density
</p>
</li>
<li><p><code>'sfd'</code>: 3d fractal dimension
</p>
</li>
<li><p><code>'srw'</code>: dominant radial wavelength, radial wavelength index, mean half wavelength
</p>
</li>
<li><p><code>'std'</code>: angle of dominating texture, texture direction index
</p>
</li>
<li><p><code>'svi'</code>: valley fluid retention index
</p>
</li>
<li><p><code>'stxr'</code>: texture aspect ratio
</p>
</li>
<li><p><code>'ssc'</code>: mean summit curvature
</p>
</li>
<li><p><code>'sv'</code>: maximum valley depth
</p>
</li>
<li><p><code>'sph'</code>: maximum peak height
</p>
</li>
<li><p><code>'sk'</code>: core roughness depth
</p>
</li>
<li><p><code>'smean'</code>: mean peak height
</p>
</li>
<li><p><code>'svk'</code>: reduced valley depth
</p>
</li>
<li><p><code>'spk'</code>: reduced peak height
</p>
</li>
<li><p><code>'scl'</code>: correlation length
</p>
</li>
<li><p><code>'sdc'</code>: bearing area curve height interval
</p>
</li></ol>



<h3>Value</h3>

<p>A raster of the metric calculated in windows over the raster or matrix.
If the input was a matrix, the function will return a raster with an extent of [0, 1, 0, 1].
</p>


<h3>References</h3>


<ol>
<li><p>Hesselbarth, M.H.K., Sciaini, M., With, K.A., Wiegand, K., Nowosad, J. 2019.
landscapemetrics: an open-source R tool to calculate landscape metrics. - Ecography 42:1648-1657(ver. 0).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# crop raster to smaller area
x &lt;- terra::crop(normforest, terra::ext(normforest[1:100, 1:100, drop = FALSE]))

# get a surface of root mean square roughness
sa_img &lt;- focal_metrics(x = x, window = matrix(1, 5, 5),
                        metrics = list('sa'), progress = TRUE)

# plot the result
terra::plot(sa_img$sa)
</code></pre>

<hr>
<h2 id='height_ba'>Value of the Bearing Area Curve at a Specified Value</h2><span id='topic+height_ba'></span>

<h3>Description</h3>

<p>Determines the value of the bearing area curve for a
specific value along the x-axis (<code>xval</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>height_ba(x, xval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="height_ba_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="height_ba_+3A_xval">xval</code></td>
<td>
<p>Numeric value along the x-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of the bearing area function
corresponding to <code>xval</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# determine the bearing area function value
# corresponding to an x value of 0.4
val &lt;- height_ba(normforest, 0.4)
</code></pre>

<hr>
<h2 id='normforest'>NDVI errors for a portion of southwestern Oregon, USA.</h2><span id='topic+normforest'></span>

<h3>Description</h3>

<p>A raster image of Normalized Difference
Vegetation Index (NDVI) errors derived from Landsat
data for a small portion of SW Oregon state. This
raster was calculated by subtracting the best-fit polynomial
plane from the <code>orforest</code> values. The best-fit
polynomial plane was calculated using <code>bestfitplane</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normforest
</code></pre>


<h3>Format</h3>

<p>A raster image with 371 x 371 pixels
</p>

<dl>
<dt>range</dt><dd><p>-0.5854638 &ndash; 0.1585918</p>
</dd>
<dt>bounds</dt><dd><p>-123, -122.9, 43.0002, 43.1</p>
</dd>
<dt>resolution</dt><dd><p>30m x 30m (0.002694946 degrees)</p>
</dd>
<dt>projection</dt><dd><p>WGS84</p>
</dd>
<dt>scalar</dt><dd><p>1</p>
</dd>
</dl>
<p>...

</p>


<h3>Details</h3>

<p>NDVI values are derived from Landsat scene path 45,
row 30 summarized as the mean NDVI value between June
and August 2000 at roughly 30m resolution. Clouds
were removed from the Landsat scene before calculating
the mean. The image was created using Google Earth
Engine in August 2018.
</p>

<hr>
<h2 id='orelevation'>SRTM elevation for a portion of southwestern Oregon, USA.</h2><span id='topic+orelevation'></span>

<h3>Description</h3>

<p>A raster image of Shuttle Radar Topography Mission (SRTM)
elevation for a portion of southwestern Oregon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orelevation
</code></pre>


<h3>Format</h3>

<p>A raster image with 371 x 371 pixels
</p>

<dl>
<dt>range</dt><dd><p>433 &ndash; 1390</p>
</dd>
<dt>bounds</dt><dd><p>-123.0001, -122.9002, 43.00015, 43.10013</p>
</dd>
<dt>resolution</dt><dd><p>30m x 30m (0.002694946 degrees)</p>
</dd>
<dt>projection</dt><dd><p>WGS84</p>
</dd>
<dt>scalar</dt><dd><p>1</p>
</dd>
</dl>
<p>...

</p>


<h3>Details</h3>

<p>Elevation values are from the SRTM data for 2000 and are
at roughly 30m resolution. The image was created using
Google Earth Engine in October 2019.
</p>

<hr>
<h2 id='orforest'>NDVI for a portion of southwestern Oregon, USA.</h2><span id='topic+orforest'></span>

<h3>Description</h3>

<p>A raster image of Normalized Difference Vegetation Index (NDVI)
derived from Landsat data for a small portion of SW Oregon state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orforest
</code></pre>


<h3>Format</h3>

<p>A raster image with 371 x 371 pixels
</p>

<dl>
<dt>range</dt><dd><p>0 &ndash; 1</p>
</dd>
<dt>bounds</dt><dd><p>-123, -122.9, 43.0002, 43.1</p>
</dd>
<dt>resolution</dt><dd><p>30m x 30m (0.002694946 degrees)</p>
</dd>
<dt>projection</dt><dd><p>WGS84</p>
</dd>
<dt>scalar</dt><dd><p>1</p>
</dd>
</dl>
<p>...

</p>


<h3>Details</h3>

<p>NDVI values are derived from Landsat scene path 45,
row 30 summarized as the mean NDVI value between June
and August 2000 at roughly 30m resolution. Clouds
were removed from the Landsat scene before calculating
the mean. The image was created using Google Earth
Engine in August 2018.
</p>

<hr>
<h2 id='pad_edges'>Extend edges of a matrix.</h2><span id='topic+pad_edges'></span>

<h3>Description</h3>

<p>Extends edge values of a raster or matrix by a specified number of pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_edges(x, size, val = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pad_edges_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="pad_edges_+3A_size">size</code></td>
<td>
<p>Numeric. Number of pixels to add to each side.</p>
</td></tr>
<tr><td><code id="pad_edges_+3A_val">val</code></td>
<td>
<p>Numeric. If NULL (default), this extends the edge values
out. If not null, this value will be used for the extended cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster with edges padded <code>size</code> number of pixels on each edge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# crop raster to much smaller area
x &lt;- pad_edges(as.matrix(normforest), 3, val = NA)
</code></pre>

<hr>
<h2 id='plot_ba_curve'>Plots the Bearing Area Curve</h2><span id='topic+plot_ba_curve'></span>

<h3>Description</h3>

<p>Calculates and plots the Bearing Area curve for a raster
or matrix using the <code>bearing_area()</code> function (with correctly
rotated results).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ba_curve(x, divisions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ba_curve_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="plot_ba_curve_+3A_divisions">divisions</code></td>
<td>
<p>Logical, defaults to <code>FALSE</code>. If
<code>TRUE</code>, divisions of the curve will be plotted.
See details section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>divisions = TRUE</code>, the lines representing the
best fit line to the flattest 40 percent of the curve will be
shown, as well as both the x and y interception points
of that line.
</p>


<h3>Value</h3>

<p>Plots the Bearing Area curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# plot the bearing area curve
plot_ba_curve(normforest, divisions = TRUE)
</code></pre>

<hr>
<h2 id='remove_plane'>Removes the Best Fit Polynomial Surface</h2><span id='topic+remove_plane'></span>

<h3>Description</h3>

<p>Finds the best fit polynomial surface for a raster or matrix and
subtracts it from the actual values. The output image has positive values
where the actual values are higher than the surface and negative values
where the actual value are lower than the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_plane(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_plane_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster or matrix of the same size as the input with values
equal to the difference between the original and bestfit
plane.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(orforest)
orforest &lt;- terra::unwrap(orforest)

# remove the least squares polynomial surface
new_rast &lt;- remove_plane(orforest)

# plot
terra::plot(new_rast)
</code></pre>

<hr>
<h2 id='rotate'>Rotates a matrix 180 degrees.</h2><span id='topic+rotate'></span>

<h3>Description</h3>

<p>Rotates a matrix 180 degrees. Code is from https://stackoverflow.com/questions/16496210/rotate-a-matrix-in-r-by-90-degrees-clockwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix rotate 180 degrees.
</p>

<hr>
<h2 id='s10z'>Ten-Point Height</h2><span id='topic+s10z'></span>

<h3>Description</h3>

<p>Calculates the average height above the mean surface for the five highest local maxima
plus the average height below the mean surface for the five lowest local minima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s10z(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s10z_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the ten-point height.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate ten-point height.
S10z &lt;- s10z(normforest)
</code></pre>

<hr>
<h2 id='sa'>Calculates the Average Roughness of a Surface</h2><span id='topic+sa'></span>

<h3>Description</h3>

<p>Finds the average roughness of a surface (Sa) as the absolute
deviation of surface heights from the mean surface height.
Height is measured as the value of a raster and may not
necessarily represent actual height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sa(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sa_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value of average roughness in the units of the
original raster or matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# find the surface roughness
roughness &lt;- sa(normforest)
</code></pre>

<hr>
<h2 id='sbi'>Surface Bearing Index</h2><span id='topic+sbi'></span>

<h3>Description</h3>

<p>Determines the surface bearing index (Sbi), calculated as the ratio
of root mean square roughness (Sq) to height at 5%
of bearing area (z05).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbi(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sbi_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the surface bearing index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# determine the surface bearing index
Sbi &lt;- sbi(normforest)
</code></pre>

<hr>
<h2 id='sci'>Core Fluid Retention Index</h2><span id='topic+sci'></span>

<h3>Description</h3>

<p>Determines the core fluid retention index (Sci). This
value is the void volume (area under the bearing area
curve) in the 'core' zone. See Figure 2a from Kedron
et al. (2018) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sci(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sci_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the core fluid
retention index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# determine the core fluid retention index
Sci &lt;- sci(normforest)
</code></pre>

<hr>
<h2 id='scl'>Calculate Correlation Length</h2><span id='topic+scl'></span>

<h3>Description</h3>

<p>Calculates the smallest and largest distances to specified autocorrelation
values (e.g., 0.2) of the areal autocorrelation function (AACF). All 180
degrees from the origin of the AACF image are considered for the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scl(x, threshold = c(0.2, 1/exp(1)), create_plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scl_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="scl_+3A_threshold">threshold</code></td>
<td>
<p>A numeric vector containing values between 0 and 1. Indicates
the autocorrelation values to which the rates of decline are measured.</p>
</td></tr>
<tr><td><code id="scl_+3A_create_plot">create_plot</code></td>
<td>
<p>Logical. Defaults to <code>FALSE</code>. If <code>TRUE</code>, the AACF and
lines showing the considered directions of autocorrelation from the origin
will be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the minimum and maximum distances from an
autocorrelation value of 1 to the specified autocorrelation values &lt; 1.
Distances are in the units of the x, y coordinates of the raster image. If more
than one threshold value is specified, the order of this list will be
<code>[minval(t1), minval(t2), maxval(t1), maxval(t2)]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate Scl20, the minimum distance to an autocorrelation value of 0.2 in the AACF
Scl20 &lt;- scl(normforest)[1]
</code></pre>

<hr>
<h2 id='sdc'>Height Intervals of the Bearing Area Curve</h2><span id='topic+sdc'></span>

<h3>Description</h3>

<p>Determines the height interval (height distance) for
points along the bearing area curve as defined by
their x values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdc(x, low, high)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdc_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="sdc_+3A_low">low</code></td>
<td>
<p>Numeric value along the x-axis corresponding
to the lowest value of interest along the x-axis.</p>
</td></tr>
<tr><td><code id="sdc_+3A_high">high</code></td>
<td>
<p>Numeric value along the y-axis corresponding
to the highest value of interest along the x-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of the difference in height of
the y values along the bearing area curve corresponding
to the specified x values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# determine the 10-40% height interval of the
# bearing area curve
val &lt;- sdc(normforest, 0.1, 0.4)
</code></pre>

<hr>
<h2 id='sdq'>Root Mean Square Slope of Surface</h2><span id='topic+sdq'></span>

<h3>Description</h3>

<p>Calculates the root mean square slope of a raster or matrix
surface using the two-point method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdq(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdq_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the two-point root
mean square slope, Sdq. The units of the returned value
are change in z per one unit (pixel).
</p>


<h3>References</h3>

<p>This function is based
on the equations found at
https://www.ntmdt-si.ru/data/media/files/manuals/image_analisys_p9_nov12.e.pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate root mean square slope
Sdq &lt;- sdq(normforest)
</code></pre>

<hr>
<h2 id='sdq6'>Root Area Mean Square Slope of Surface</h2><span id='topic+sdq6'></span>

<h3>Description</h3>

<p>Calculates the area root mean square slope of a raster or matrix
surface using the seven-point method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdq6(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdq6_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the seven-point root
mean square slope, Sdq6. The units of the returned value
are change in z per one unit (pixel).
</p>


<h3>References</h3>

<p>This function is based
on the equations found at
https://www.ntmdt-si.ru/data/media/files/manuals/image_analisys_p9_nov12.e.pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate area root mean square slope
Sdq6 &lt;- sdq6(normforest)
</code></pre>

<hr>
<h2 id='sdr'>Surface Area Ratio</h2><span id='topic+sdr'></span>

<h3>Description</h3>

<p>Calculates the surface area ratio of a raster or matrix. This is the
ratio of a flat surface to the actual surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdr_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function scales both x and y, as well as the surface value (z),
to between 0 and 1 to best match their units. This is done because
most satellite data have units where the x, y units do not equal the
z units. Surface area is calculated over the sample area (N-1, M-1).
</p>


<h3>Value</h3>

<p>A numeric value representing the surface area ratio.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate the surface area ratio
Sdr &lt;- sdr(normforest)
</code></pre>

<hr>
<h2 id='sds'>Summit Density</h2><span id='topic+sds'></span>

<h3>Description</h3>

<p>Calculates the summit density of a raster or matrix. Summit density is the number of local
peaks per unit area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sds(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sds_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the summit density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate summit density.
Sds &lt;- sds(normforest)
</code></pre>

<hr>
<h2 id='sfd'>Calculate the fractal dimension of a raster.</h2><span id='topic+sfd'></span>

<h3>Description</h3>

<p>Calculates the 3D fractal dimension of a raster using the
triangular prism surface area method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfd(x, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfd_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="sfd_+3A_silent">silent</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), the function will
print warning messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the fractal dimension of
the image.
</p>


<h3>References</h3>

<p>Clarke, K.C., 1986. Computation of the fractal dimension
of topographic surfaces using the triangular prism surface area method.
Computers &amp; Geosciences, 12(5), pp.713-722.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate the fractal dimension
Sfd &lt;- sfd(normforest)
</code></pre>

<hr>
<h2 id='sfd_'>Calculate the fractal dimension of a raster (C function).</h2><span id='topic+sfd_'></span>

<h3>Description</h3>

<p>Calculates the 3D fractal dimension of a raster using the
triangular prism surface area method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfd_(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfd__+3A_mat">mat</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the fractal dimension of
the image.
</p>


<h3>References</h3>

<p>Clarke, K.C., 1986. Computation of the fractal dimension of topographic
surfaces using the triangular prism surface area method. Computers &amp; Geosciences,
12(5), pp.713-722.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# convert to matrix
mat &lt;- matrix(normforest[], ncol = ncol(normforest), nrow = nrow(normforest))

# calculate the fractal dimension
Sfd &lt;- sfd_(mat)
</code></pre>

<hr>
<h2 id='simpsons'>Simpson's Rule Empirical Area Under a Curve</h2><span id='topic+simpsons'></span>

<h3>Description</h3>

<p>Calculates the area below a curve from
points <code>a</code> to <code>b</code>. This function is provided
for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpsons(f, a, b, n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpsons_+3A_f">f</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="simpsons_+3A_a">a</code></td>
<td>
<p>Numeric. The left x boundary.</p>
</td></tr>
<tr><td><code id="simpsons_+3A_b">b</code></td>
<td>
<p>Numeric. The right x boundary.</p>
</td></tr>
<tr><td><code id="simpsons_+3A_n">n</code></td>
<td>
<p>Numeric. The number of subdivisions along the function
line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if y-values are negative, this returns the area
above the function line.
</p>


<h3>Value</h3>

<p>A numeric value representing the area under the curve with
x bounds <code>a</code> and <code>b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# basic values
z &lt;- terra::values(normforest)

# calculate cumulative probability density function of surface 'height' (= ndvi)
mod &lt;- ecdf((1 - z))

# calculate integral
int_area &lt;- simpsons(f = mod, b = 1, a = 0.8, n = 500)
</code></pre>

<hr>
<h2 id='sk'>Core Roughness Depth</h2><span id='topic+sk'></span>

<h3>Description</h3>

<p>Determines the core roughness depth (Sk), the
height difference between y values of the
intersection points of the least mean square line
fit to the flattest 40% of the bearing area curve.
See Figure 2a from Kedron et al. (2018) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sk(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sk_+3A_x">x</code></td>
<td>
<p>A raster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the core roughness
depth of the image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# determine the core roughness depth
Sk &lt;- sk(normforest)
</code></pre>

<hr>
<h2 id='sku'>Calculates the Kurtosis of Raster Values</h2><span id='topic+sku'></span>

<h3>Description</h3>

<p>Finds the kurtosis for a distribution of raster or matrix
values (Sku). Kurtosis represents the peakedness
of the raster surface height distribution. Height
is measured as the value of a raster/matrix and may not
necessarily represent actual height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sku(x, excess = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sku_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="sku_+3A_excess">excess</code></td>
<td>
<p>Logical, defaults to <code>TRUE</code>. If
<code>TRUE</code>, excess kurtosis is calculated. If <code>FALSE</code>,
kurtosis is calculated as the difference from the
normal distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing kurtosis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# find the excess kurtosis of the raster distribution
Sku &lt;- sku(normforest, excess = TRUE)
</code></pre>

<hr>
<h2 id='slopecalc'>Determines the Slopes Along the Bearing Area Curve</h2><span id='topic+slopecalc'></span>

<h3>Description</h3>

<p>Calculates the slopes along the bearing area curve
of a raster or matrix. Slopes are determined at points x,
from point x - h to x + h.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slopecalc(x, h, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slopecalc_+3A_x">x</code></td>
<td>
<p>A vector of x values.</p>
</td></tr>
<tr><td><code id="slopecalc_+3A_h">h</code></td>
<td>
<p>Spacing before and after each point.
2h is the distance over which slopes are calculated.</p>
</td></tr>
<tr><td><code id="slopecalc_+3A_f">f</code></td>
<td>
<p>Bearing area function as calculated with
bearing_area.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the slope for each segment
with centerpoint x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# find the slopes along the bearing area curve
ba &lt;- bearing_area(normforest)
x &lt;- seq(0, 1, length.out = 100000)
slopes &lt;- slopecalc(x = x, h = 0.01, f = ba)
</code></pre>

<hr>
<h2 id='slopemeans'>Determines the Average Slope Along Larger Segments of
the Bearing Area Curve</h2><span id='topic+slopemeans'></span>

<h3>Description</h3>

<p>Calculates the average slope over every segment
of a specified percentage length of the total bearing
area curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slopemeans(slopes, l = 0.4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slopemeans_+3A_slopes">slopes</code></td>
<td>
<p>A dataframe containing all slopes along
the bearing area curve, calculated using the slopecalc
function.</p>
</td></tr>
<tr><td><code id="slopemeans_+3A_l">l</code></td>
<td>
<p>Percentage of the curve over which to calculate
mean slope.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the average slope over segments
beginning at specified x locations along the bearing area
curve. 'slope' represents the mean slope over the segment,
'xstart' is the beginning x location of the segment, and
'xend' is the concluding x location of the segment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# find the average slope of segments of the bearing area
# curve.
ba &lt;- bearing_area(normforest)
x &lt;- seq(0, 1, length.out = 10000)
slopes &lt;- slopecalc(x = x, h = 0.01, f = ba)
slopes_forty &lt;- slopemeans(slopes = slopes, l = 0.4)
</code></pre>

<hr>
<h2 id='smean'>Calculates the Mean Peak Height of a Surface Image</h2><span id='topic+smean'></span>

<h3>Description</h3>

<p>Finds the mean height of positive values in the
landscape (mean peak height; Smean) for a raster or matrix
representing a surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smean(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smean_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of mean peak height.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# find the maximum peak height
Smean &lt;- smean(normforest)
</code></pre>

<hr>
<h2 id='sph'>Calculates the Maximum Peak Height of a Surface Image</h2><span id='topic+sph'></span>

<h3>Description</h3>

<p>Finds the absolute value of the highest value in the
landscape (maximum peak height; Sph) for a raster or matrix
representing a surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sph_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of maximum peak height.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# find the maximum peak height
Sph &lt;- sph(normforest)
</code></pre>

<hr>
<h2 id='spk'>Reduced Peak Height</h2><span id='topic+spk'></span>

<h3>Description</h3>

<p>Determines the reduced peak height (Spk), the
height difference between the maximum y value of the
bearing area curve and the y value of the highest
intersection point of the least mean square line
fit to the flattest 40% of the bearing area curve.
See Figure 2a from Kedron et al. (2018) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spk(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spk_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the reduced peak height.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# determine the reduced peak height
Spk &lt;- spk(normforest)
</code></pre>

<hr>
<h2 id='sq'>Calculates the Root Mean Square Roughness of a Surface</h2><span id='topic+sq'></span>

<h3>Description</h3>

<p>Finds the root mean square roughness of a surface
(Sq) as the standard deviation of surface heights
from the mean surface height. Height is measured as
the value of a raster and may not necessarily
represent actual height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sq(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sq_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value of root mean square roughness in
the units of the original raster or matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# find the surface roughness
roughness &lt;- sq(normforest)
</code></pre>

<hr>
<h2 id='srw'>Radial Wavelength Metrics</h2><span id='topic+srw'></span>

<h3>Description</h3>

<p>Calculates the dominant radial wavelength, radial wavelength
index, and mean half wavelength of the radial Fourier spectrum.
See Kedron et al. (2018) for more detailed description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srw(x, create_plot = FALSE, option = c(1, 2, 3))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srw_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="srw_+3A_create_plot">create_plot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, returns a plot of the
amplitude spectrum with lines showing the radii at which
Srw, Srwi, and Shw are calculated.</p>
</td></tr>
<tr><td><code id="srw_+3A_option">option</code></td>
<td>
<p>Numeric. Code for which output metric(s) to return. 1 = Srw, 2 = Srwi, 3 = Shw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing numeric values for the dominant
radial wavelength, radial wavelength index, and mean half
wavelength.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate metrics
srwvals &lt;- srw(normforest)

# extract each value
Srw &lt;- srwvals[1]
Srwi &lt;- srwvals[2]
Shw &lt;- srwvals[3]
</code></pre>

<hr>
<h2 id='ssc'>Mean Summit Curvature</h2><span id='topic+ssc'></span>

<h3>Description</h3>

<p>Calculates the mean summit curvature of a raster or matrix. Mean summit
curvature is the average principle curvature of local maximas
on the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssc_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the average curvature of
surface peaks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate mean summit curvature
Ssc &lt;- ssc(normforest)
</code></pre>

<hr>
<h2 id='ssk'>Calculates the Skewness of Raster Values</h2><span id='topic+ssk'></span>

<h3>Description</h3>

<p>Finds the Fisher-Pearson coefficient of skewness
for raster or matrix values (Ssk). Skewness represents the
asymmetry of the surface height distribution.
Height is measured as the value of a raster/matrix and
may not necessarily represent actual height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssk(x, adj = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssk_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="ssk_+3A_adj">adj</code></td>
<td>
<p>Logical, defaults to <code>TRUE</code>. If <code>TRUE</code>,
the adjusted Fisher-Pearson coefficient of skewness
is calculated. Otherwise, the standard coefficient is
calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing skewness.
# import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)
</p>
<p># find the adjusted coefficient of skewness
Ssk &lt;- ssk(normforest, adj = TRUE)
</p>

<hr>
<h2 id='std'>Texture Direction Metrics</h2><span id='topic+std'></span>

<h3>Description</h3>

<p>Calculates the angle of dominating texture and the texture
direction index of the Fourier spectrum image calculated
from a raster image (see Kedron et al. 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std(x, create_plot = FALSE, option = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="std_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="std_+3A_create_plot">create_plot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, returns a plot of the
amplitude spectrum with lines showing directions in which
amplitude is summed for the Std and Stdi calculations.
Plotting is not possible when input is a matrix.</p>
</td></tr>
<tr><td><code id="std_+3A_option">option</code></td>
<td>
<p>Numeric. Code for which output metric(s) to return. 1 = Std, 2 = Stdi.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing numeric values for the angle of
dominating texture and the texture direction index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate Std and Stdi
stdvals &lt;- std(normforest)

# extract each value
Std &lt;- stdvals[1]
Stdi &lt;- stdvals[2]
</code></pre>

<hr>
<h2 id='stxr'>Estimate Texture Aspect Ratio</h2><span id='topic+stxr'></span>

<h3>Description</h3>

<p>Calculates the texture aspect ratio (Str) at defined autocorrelation
values. The texture aspect ratio is the ratio of the fastest to
the slowest decay lengths of the autocorrelation function to the
defined autocorrelation values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stxr(x, threshold = c(0.2, 1/exp(1)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stxr_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="stxr_+3A_threshold">threshold</code></td>
<td>
<p>A vector of autocorrelation values with values
between 0 and 1. Indicates the autocorrelation value(s) to
which the rates of decline are measured.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with length equal to that of <code>threshold</code>
containing the texture aspect ratio(s) for the input autocorrelation
value(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# estimate the texture aspect ratio for autocorrelation
# thresholds of 0.20 and 0.37 (1/e)
strvals &lt;- stxr(normforest, threshold = c(0.20, 1 / exp(1)))

# calculate Str20, the texture aspect ratio for
# autocorrelation value of 0.2 in the AACF
Str20 &lt;- strvals[1]
</code></pre>

<hr>
<h2 id='surface_area'>Surface Area</h2><span id='topic+surface_area'></span>

<h3>Description</h3>

<p>Calculates the scaled surface area of a raster or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface_area(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surface_area_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function scales both x and y, as well as the surface value (z),
to between 0 and 1 to best match their units. This is done because
most satellite data have units where the x, y units do not equal the
z units. The surface area represents the surface area of the sample
area (N-1, M-1).
</p>
<p>Note that the surface object may have NA values around the edges,
but should not have any missing values within the main area.
</p>


<h3>Value</h3>

<p>A numeric value representing the scaled surface area.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# calculate surface area
surface_area(normforest)
</code></pre>

<hr>
<h2 id='sv'>Calculates the Maximum Valley Depth of a Surface Image</h2><span id='topic+sv'></span>

<h3>Description</h3>

<p>Finds the absolute value of the lowest value in the
landscape (maximum valley depth; Sv) for a raster or matrix
representing a surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sv_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of maximum valley depth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# find the maximum valley depth
Sv &lt;- sv(normforest)
</code></pre>

<hr>
<h2 id='svi'>Valley Fluid Retention Index</h2><span id='topic+svi'></span>

<h3>Description</h3>

<p>Determines the valley fluid retention index (Svi). This
value is the void volume (area under the bearing area
curve) in the 'valley' zone. See Figure 2a from Kedron
et al. (2018) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svi(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svi_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the valley fluid
retention index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# determine the valley fluid retention index
Svi &lt;- svi(normforest)
</code></pre>

<hr>
<h2 id='svk'>Reduced Valley Depth</h2><span id='topic+svk'></span>

<h3>Description</h3>

<p>Determines the reduced valley depth (Svk), the
height difference between y value of the lowest
intersection point of the least mean square line
fit to the flattest 40% of the bearing area curve and
the minimum y value of the bearing area curve.
See Figure 2a from Kedron et al. (2018) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svk(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svk_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the reduced valley depth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# determine the reduced valley depth
Svk &lt;- svk(normforest)
</code></pre>

<hr>
<h2 id='texture_image'>Calculate Texture Metrics per Pixel</h2><span id='topic+texture_image'></span>

<h3>Description</h3>

<p>Calculates the various texture metrics over windows centered
on individual pixels. This creates a continuous surface of the
texture metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>texture_image(
  x,
  window_type = "square",
  size = 5,
  in_meters = FALSE,
  metric,
  args = NULL,
  parallel = TRUE,
  ncores = NULL,
  nclumps = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="texture_image_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="texture_image_+3A_window_type">window_type</code></td>
<td>
<p>Character. Type of window, either circular or square.</p>
</td></tr>
<tr><td><code id="texture_image_+3A_size">size</code></td>
<td>
<p>Numeric. Size of window (edge length) or diameter (in meters).</p>
</td></tr>
<tr><td><code id="texture_image_+3A_in_meters">in_meters</code></td>
<td>
<p>Logical. Is the size given in meters?</p>
</td></tr>
<tr><td><code id="texture_image_+3A_metric">metric</code></td>
<td>
<p>Character. Metric to calculate for each window. Metrics
from the geodiv package are listed below.</p>
</td></tr>
<tr><td><code id="texture_image_+3A_args">args</code></td>
<td>
<p>List. Arguments from function to be applied over each window
(e.g., list(threshold = 0.2)).</p>
</td></tr>
<tr><td><code id="texture_image_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Option to run the calculations in
parallel on available cores.</p>
</td></tr>
<tr><td><code id="texture_image_+3A_ncores">ncores</code></td>
<td>
<p>Numeric. If parallel is TRUE, number of cores on which to
run the calculations. Defaults to all available, minus 1.</p>
</td></tr>
<tr><td><code id="texture_image_+3A_nclumps">nclumps</code></td>
<td>
<p>Numeric. Number of clumps to split the raster or matrix into.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function is meant to work on rasters with an equal area
projection.
</p>
<p>Metrics available from geodiv package:
</p>

<ol>
<li><p><code>'sa'</code>: average surface roughness
</p>
</li>
<li><p><code>'sq'</code>: root mean square roughness
</p>
</li>
<li><p><code>'s10z'</code>: ten-point height
</p>
</li>
<li><p><code>'sdq'</code>: root mean square slope of surface, 2-point method
</p>
</li>
<li><p><code>'sdq6'</code>: root mean square slope of surface, 7-point method
</p>
</li>
<li><p><code>'sdr'</code>: surface area ratio
</p>
</li>
<li><p><code>'sbi'</code>: surface bearing index
</p>
</li>
<li><p><code>'sci'</code>: core fluid retention index
</p>
</li>
<li><p><code>'ssk'</code>: skewness
</p>
</li>
<li><p><code>'sku'</code>: kurtosis
</p>
</li>
<li><p><code>'sds'</code>: summit density
</p>
</li>
<li><p><code>'sfd'</code>: 3d fractal dimension
</p>
</li>
<li><p><code>'srw'</code>: dominant radial wavelength, radial wavelength index, mean half wavelength
</p>
</li>
<li><p><code>'std'</code>: angle of dominating texture, texture direction index
</p>
</li>
<li><p><code>'svi'</code>: valley fluid retention index
</p>
</li>
<li><p><code>'stxr'</code>: texture aspect ratio
</p>
</li>
<li><p><code>'ssc'</code>: mean summit curvature
</p>
</li>
<li><p><code>'sv'</code>: maximum valley depth
</p>
</li>
<li><p><code>'sph'</code>: maximum peak height
</p>
</li>
<li><p><code>'sk'</code>: core roughness depth
</p>
</li>
<li><p><code>'smean'</code>: mean peak height
</p>
</li>
<li><p><code>'svk'</code>: reduced valley depth
</p>
</li>
<li><p><code>'spk'</code>: reduced peak height
</p>
</li>
<li><p><code>'scl'</code>: correlation length
</p>
</li>
<li><p><code>'sdc'</code>: bearing area curve height interval
</p>
</li></ol>



<h3>Value</h3>

<p>A raster or list of rasters (if function results in multiple outputs)
with pixel values representative of the metric value for the window
surrounding that pixel.
</p>


<h3>Note</h3>

<p>The total window size for square windows will be (size * 2) + 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# crop raster to smaller area
x &lt;- terra::crop(normforest, terra::ext(normforest[1:100, 1:100, drop = FALSE]))

# get a surface of root mean square roughness
sa_img &lt;- texture_image(x = x, window = 'square',
size = 5, metric = 'sa',
parallel = TRUE, ncores = 1, nclumps = 20)

# plot the result
terra::plot(sa_img)
</code></pre>

<hr>
<h2 id='window_metric'>Calculate Texture Metric for Single Pixel</h2><span id='topic+window_metric'></span>

<h3>Description</h3>

<p>Calculates the various texture metrics over a window centered
on an individual pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_metric(
  x,
  coords,
  window_type = "square",
  size = 11,
  metric,
  args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window_metric_+3A_x">x</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="window_metric_+3A_coords">coords</code></td>
<td>
<p>Dataframe. Coordinates of window edges.</p>
</td></tr>
<tr><td><code id="window_metric_+3A_window_type">window_type</code></td>
<td>
<p>Character. Type of window, either circular or square.</p>
</td></tr>
<tr><td><code id="window_metric_+3A_size">size</code></td>
<td>
<p>Numeric. Edge length or diameter of window in number of pixels.</p>
</td></tr>
<tr><td><code id="window_metric_+3A_metric">metric</code></td>
<td>
<p>Character. Metric to calculate for each window. Metrics
from the geodiv package are listed below.</p>
</td></tr>
<tr><td><code id="window_metric_+3A_args">args</code></td>
<td>
<p>List. Arguments from function to be applied over each window
(e.g., list(threshold = 0.2)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Metrics from geodiv package:
</p>

<ol>
<li><p><code>'sa'</code>: average surface roughness
</p>
</li>
<li><p><code>'sq'</code>: root mean square roughness
</p>
</li>
<li><p><code>'s10z'</code>: ten-point height
</p>
</li>
<li><p><code>'sdq'</code>: root mean square slope of surface, 2-point method
</p>
</li>
<li><p><code>'sdq6'</code>: root mean square slope of surface, 7-point method
</p>
</li>
<li><p><code>'sdr'</code>: surface area ratio
</p>
</li>
<li><p><code>'sbi'</code>: surface bearing index
</p>
</li>
<li><p><code>'sci'</code>: core fluid retention index
</p>
</li>
<li><p><code>'ssk'</code>: skewness
</p>
</li>
<li><p><code>'sku'</code>: kurtosis
</p>
</li>
<li><p><code>'sds'</code>: summit density
</p>
</li>
<li><p><code>'sfd'</code>: 3d fractal dimension
</p>
</li>
<li><p><code>'srw'</code>: dominant radial wavelength, radial wavelength index, mean half wavelength
</p>
</li>
<li><p><code>'std'</code>: angle of dominating texture, texture direction index
</p>
</li>
<li><p><code>'svi'</code>: valley fluid retention index
</p>
</li>
<li><p><code>'stxr'</code>: texture aspect ratio
</p>
</li>
<li><p><code>'ssc'</code>: mean summit curvature
</p>
</li>
<li><p><code>'sv'</code>: maximum valley depth
</p>
</li>
<li><p><code>'sph'</code>: maximum peak height
</p>
</li>
<li><p><code>'sk'</code>: core roughness depth
</p>
</li>
<li><p><code>'smean'</code>: mean peak height
</p>
</li>
<li><p><code>'svk'</code>: reduced valley depth
</p>
</li>
<li><p><code>'spk'</code>: reduced peak height
</p>
</li>
<li><p><code>'scl'</code>: correlation length
</p>
</li>
<li><p><code>'sdc'</code>: bearing area curve height interval
</p>
</li></ol>



<h3>Value</h3>

<p>A raster with pixel values representative of the metric
value for the window surrounding that pixel.
</p>


<h3>Note</h3>

<p>Note that if calculating the metric at the edge of a raster or matrix,
the input raster/matrix must be padded. This can be done using the <code>pad_edges</code>
function.
</p>

<hr>
<h2 id='zshift'>Offset Raster or Matrix Values</h2><span id='topic+zshift'></span>

<h3>Description</h3>

<p>Calculates a matrix of values with a negative
or positive, x or y, offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zshift(r, xdist = 0, ydist = 0, xrm, yrm, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zshift_+3A_r">r</code></td>
<td>
<p>A raster or matrix.</p>
</td></tr>
<tr><td><code id="zshift_+3A_xdist">xdist</code></td>
<td>
<p>Numeric indicating the number and direction (+, -)
of columns for the offset.</p>
</td></tr>
<tr><td><code id="zshift_+3A_ydist">ydist</code></td>
<td>
<p>Numeric indicating the number and direction (+, -)
of rows for the offset.</p>
</td></tr>
<tr><td><code id="zshift_+3A_xrm">xrm</code></td>
<td>
<p>Numeric value or vector indicating the number of
columns to be removed from the final matrix. If not set,
this value defaults to <code>xdist</code>. Positive values remove
columns from the right, while negative values remove columns
from the left. The absolute value of <code>xrm</code> must be
<code>&gt;= abs(xdist)</code>.</p>
</td></tr>
<tr><td><code id="zshift_+3A_yrm">yrm</code></td>
<td>
<p>Numeric value or vector indicating the number
of rows to be removed from the final matrix. If not set,
this value defaults to <code>ydist</code>. Positive values remove
rows from the bottom, while negative values remove rows from
the top. The absolute value must be <code>&gt;= abs(ydist)</code>.</p>
</td></tr>
<tr><td><code id="zshift_+3A_scale">scale</code></td>
<td>
<p>Logical. Indicates whether or not to scale the values of
the raster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of values created from a matrix of the values
with the specified offset. The vector is created from a matrix with
<code>xrm</code> fewer columns and <code>yrm</code> fewer rows than the original
raster value matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import raster image
data(normforest)
normforest &lt;- terra::unwrap(normforest)

# remove right and bottom borders 2 deep
noborder &lt;- zshift(normforest, xdist = 2, ydist = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
