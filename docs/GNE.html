<!DOCTYPE html><html lang="en"><head><title>Help for package GNE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GNE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bench.GNE'><p>Benchmark function</p></a></li>
<li><a href='#CER'><p>Constrained Equation Reformulation</p></a></li>
<li><a href='#compl'><p>Complementarity functions</p></a></li>
<li><a href='#eqsolve'><p>Solving non linear equations</p></a></li>
<li><a href='#GNE'><p>GNE package</p></a></li>
<li><a href='#GNE.ceq'><p>Constrained equation reformulation of the GNE problem.</p></a></li>
<li><a href='#GNE.fpeq'><p>Fixed point equation reformulation of the GNE problem.</p></a></li>
<li><a href='#GNE.minpb'><p>Non smooth equation reformulation of the GNE problem.</p></a></li>
<li><a href='#GNE.nseq'><p>Non smooth equation reformulation of the GNE problem.</p></a></li>
<li><a href='#NIR'><p>Nikaido Isoda Reformulation</p></a></li>
<li><a href='#potential.reduction'><p>Potential reduction algorithm utility functions</p></a></li>
<li><a href='#projector'><p>Projection of a point on a set</p></a></li>
<li><a href='#rejection'><p>Rejection method for random generation.</p></a></li>
<li><a href='#SSR'><p>SemiSmooth Reformulation</p></a></li>
<li><a href='#stepfunc'><p>Step functions</p></a></li>
<li><a href='#VIR'><p>Nikaido Isoda Reformulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computation of Generalized Nash Equilibria</td>
</tr>
<tr>
<td>Version:</td>
<td>0.99-6</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute standard and generalized Nash Equilibria of non-cooperative games. 
 Optimization methods available are nonsmooth reformulation, fixed-point formulation, 
 minimization problem and constrained-equation reformulation. 
 See e.g. Kanzow and Facchinei (2010), &lt;<a href="https://doi.org/10.1007%2Fs10479-009-0653-x">doi:10.1007/s10479-009-0653-x</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), alabama, nleqslv, BB, SQUAREM, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/optimizer/">https://r-forge.r-project.org/projects/optimizer/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-17 13:25:37 UTC; dutang</td>
</tr>
<tr>
<td>Author:</td>
<td>Christophe Dutang <a href="https://orcid.org/0000-0001-6732-1501"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christophe Dutang &lt;dutangc@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-17 14:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='bench.GNE'>Benchmark function</h2><span id='topic+bench.GNE'></span><span id='topic+bench.GNE.nseq'></span><span id='topic+bench.GNE.ceq'></span><span id='topic+bench.GNE.fpeq'></span><span id='topic+bench.GNE.minpb'></span>

<h3>Description</h3>

<p>Benchmark function to compare GNE computational methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bench.GNE.nseq(xinit, ..., echo=FALSE, control=list())
bench.GNE.ceq(xinit, ..., echo=FALSE, control=list())
bench.GNE.fpeq(xinit, ..., echo=FALSE, control.outer=list(), 
	control.inner=list())
bench.GNE.minpb(xinit, ..., echo=FALSE, control.outer=list(), 
	control.inner=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bench.GNE_+3A_xinit">xinit</code></td>
<td>
<p>a numeric vector for the initial point.</p>
</td></tr>
<tr><td><code id="bench.GNE_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>GNE.nseq</code>, 
<code>GNE.ceq</code>, <code>GNE.fpeq</code> or <code>GNE.minpb</code>. 
NOT to the functions <code>func1</code> and <code>func2</code>.</p>
</td></tr>
<tr><td><code id="bench.GNE_+3A_echo">echo</code></td>
<td>
<p>a logical to get some traces of the benchmark computation.</p>
</td></tr>
<tr><td><code id="bench.GNE_+3A_control">control</code>, <code id="bench.GNE_+3A_control.outer">control.outer</code>, <code id="bench.GNE_+3A_control.inner">control.inner</code></td>
<td>
<p>a list with control 
parameters to be passed to <code>GNE.xxx</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing generalized Nash Equilibrium can be done in three different approaches.
</p>

<dl>
<dt>(i) extended KKT system</dt><dd><p>It consists in solving the non smooth extended Karush-Kuhn-Tucker 
(KKT) system <code class="reqn">\Phi(z)=0</code>. <code>func1</code> is <code class="reqn">Phi</code> and <code>func2</code> is <code class="reqn">Jac Phi</code>.</p>
</dd>
<dt>(ii) fixed point approach</dt><dd><p>It consists in solving equation <code class="reqn">y(x)=x</code>. <code>func1</code> is <code class="reqn">y</code> and 
<code>func2</code> is ?</p>
</dd>
<dt>(iii) gap function minimization</dt><dd><p>It consists in minimizing a gap function <code class="reqn">min V(x)</code>. 
<code>func1</code> is <code class="reqn">V</code> and <code>func2</code> is <code class="reqn">Grad V</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>For <code>GNE.bench.ceq</code> and <code>GNE.bench.nseq</code>, a <code>data.frame</code> 
is returned with columns:
</p>

<dl>
<dt><code>method</code></dt><dd><p>the name of the method.</p>
</dd>	
<dt><code>fctcall</code></dt><dd><p>the number of calls of the function.</p>
</dd>	
<dt><code>jaccall</code></dt><dd><p>the number of calls of the Jacobian.</p>
</dd>	
<dt><code>comptime</code></dt><dd><p>the computation time.</p>
</dd>	
<dt><code>normFx</code></dt><dd><p>the norm of the merit function at the final iterate.</p>
</dd>	
<dt><code>code</code></dt><dd><p>the exit code.</p>
</dd>	
<dt><code>localmethods</code></dt><dd><p>the name of the local method.</p>
</dd>	
<dt><code>globalmethods</code></dt><dd><p>the name of the globalization method.</p>
</dd>	
<dt><code>x</code></dt><dd><p>the final iterate.</p>
</dd>	
</dl>

<p>For <code>GNE.bench.minpb</code>, a <code>data.frame</code> 
is returned with columns:
</p>

<dl>
<dt><code>method</code></dt><dd><p>the name of the method.</p>
</dd>	
<dt><code>minfncall.outer</code></dt><dd><p>the number of calls of the merit function.</p>
</dd>	
<dt><code>grminfncall.outer</code></dt><dd><p>the number of calls of the 
gradient of the merit function.</p>
</dd>	
<dt><code>gapfncall.inner</code></dt><dd><p>the number of calls of the gap function.</p>
</dd>				
<dt><code>grgapfncall.outer</code></dt><dd><p>the number of calls of the 
gradient of the gap function.</p>
</dd>	
<dt><code>comptime</code></dt><dd><p>the computation time.</p>
</dd>	
<dt><code>normFx</code></dt><dd><p>the norm of the merit function at the final iterate.</p>
</dd>	
<dt><code>code</code></dt><dd><p>the exit code.</p>
</dd>	
<dt><code>x</code></dt><dd><p>the final iterate.</p>
</dd>	
</dl>

<p>For <code>GNE.bench.fpeq</code>, a <code>data.frame</code> 
is returned with columns:
</p>

<dl>
<dt><code>method</code></dt><dd><p>the name of the method.</p>
</dd>	
<dt><code>fpfncall.outer</code></dt><dd><p>the number of calls of the fixed-point function.</p>
</dd>	
<dt><code>merfncall.outer</code></dt><dd><p>the number of calls of the merit function.</p>
</dd>	
<dt><code>gapfncall.inner</code></dt><dd><p>the number of calls of the gap function.</p>
</dd>				
<dt><code>grgapfncall.outer</code></dt><dd><p>the number of calls of the 
gradient of the gap function.</p>
</dd>	
<dt><code>comptime</code></dt><dd><p>the computation time.</p>
</dd>	
<dt><code>normFx</code></dt><dd><p>the norm of the merit function at the final iterate.</p>
</dd>	
<dt><code>code</code></dt><dd><p>the exit code.</p>
</dd>	
<dt><code>x</code></dt><dd><p>the final iterate.</p>
</dd>	
</dl>



<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>F. Facchinei, A. Fischer &amp; V. Piccialli (2009), 
<em>Generalized Nash equilibrium problems and Newton methods</em>,
Math. Program.
</p>
<p>A. von Heusinger (2009),
<em>Numerical Methods for the Solution of the Generalized Nash Equilibrium Problem</em>,
Ph. D. Thesis.
</p>
<p>A. von Heusinger &amp; J. Kanzow (2009),
<em>Optimization reformulations of the generalized Nash equilibrium problem using Nikaido-Isoda-type functions</em>,
Comput Optim Appl .
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+GNE.fpeq">GNE.fpeq</a></code>, <code><a href="#topic+GNE.minpb">GNE.minpb</a></code>, <code><a href="#topic+GNE.ceq">GNE.ceq</a></code> 
and <code><a href="#topic+GNE.nseq">GNE.nseq</a></code> for other approaches.
</p>

<hr>
<h2 id='CER'>Constrained Equation Reformulation</h2><span id='topic+CER'></span><span id='topic+funCER'></span><span id='topic+jacCER'></span>

<h3>Description</h3>

<p>functions of the Constrained Equation Reformulation of the GNEP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
funCER(z, dimx, dimlam, 
	grobj, arggrobj, 
	constr, argconstr,  
	grconstr, arggrconstr, 
	dimmu, joint, argjoint,
	grjoint, arggrjoint,
	echo=FALSE)

jacCER(z, dimx, dimlam,
	heobj, argheobj, 
	constr, argconstr,  
	grconstr, arggrconstr, 
	heconstr, argheconstr,
	dimmu, joint, argjoint,
	grjoint, arggrjoint,
	hejoint, arghejoint,
	echo=FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CER_+3A_z">z</code></td>
<td>
<p>a numeric vector z containing x then lambda values.</p>
</td></tr>
<tr><td><code id="CER_+3A_dimx">dimx</code></td>
<td>
<p>dimension of x.</p>
</td></tr>
<tr><td><code id="CER_+3A_dimlam">dimlam</code></td>
<td>
<p>dimension of lambda.</p>
</td></tr>
<tr><td><code id="CER_+3A_grobj">grobj</code></td>
<td>
<p>gradient of the objective function, see details.</p>
</td></tr>
<tr><td><code id="CER_+3A_arggrobj">arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td></tr>
<tr><td><code id="CER_+3A_constr">constr</code></td>
<td>
<p>constraint function, see details.</p>
</td></tr>
<tr><td><code id="CER_+3A_argconstr">argconstr</code></td>
<td>
<p>a list of additional arguments of the constraint function.</p>
</td></tr>
<tr><td><code id="CER_+3A_grconstr">grconstr</code></td>
<td>
<p>gradient of the constraint function, see details.</p>
</td></tr>
<tr><td><code id="CER_+3A_arggrconstr">arggrconstr</code></td>
<td>
<p>a list of additional arguments of the constraint gradient.</p>
</td></tr>
<tr><td><code id="CER_+3A_dimmu">dimmu</code></td>
<td>
<p>a vector of dimension for <code class="reqn">mu</code>.</p>
</td></tr>
<tr><td><code id="CER_+3A_joint">joint</code></td>
<td>
<p>joint function, see details.</p>
</td></tr>
<tr><td><code id="CER_+3A_argjoint">argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td></tr>
<tr><td><code id="CER_+3A_grjoint">grjoint</code></td>
<td>
<p>gradient of the joint function, see details.</p>
</td></tr>
<tr><td><code id="CER_+3A_arggrjoint">arggrjoint</code></td>
<td>
<p>a list of additional arguments of the joint gradient.</p>
</td></tr>
<tr><td><code id="CER_+3A_heobj">heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td></tr>
<tr><td><code id="CER_+3A_argheobj">argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td></tr>	
<tr><td><code id="CER_+3A_heconstr">heconstr</code></td>
<td>
<p>Hessian of the constraint function, see details.</p>
</td></tr>
<tr><td><code id="CER_+3A_argheconstr">argheconstr</code></td>
<td>
<p>a list of additional arguments of the constraint Hessian.</p>
</td></tr>
<tr><td><code id="CER_+3A_hejoint">hejoint</code></td>
<td>
<p>Hessian of the joint function, see details.</p>
</td></tr>
<tr><td><code id="CER_+3A_arghejoint">arghejoint</code></td>
<td>
<p>a list of additional arguments of the joint Hessian.</p>
</td></tr>
<tr><td><code id="CER_+3A_echo">echo</code></td>
<td>
<p>a logical to show some traces.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>Compute the H function or the Jacobian of the H function defined in Dreves et al.(2009).
</p>

<dl>
<dt><b>Arguments of the H function</b></dt><dd>	
<p>The arguments which are functions must respect the following features
</p>

<dl>
<dt><code>grobj</code></dt><dd>
<p>The gradient <code class="reqn">Grad Obj</code> of an objective function <code class="reqn">Obj</code> (to be minimized) must have 3 arguments for <code class="reqn">Grad Obj(z, playnum, ideriv)</code>: vector <code>z</code>, player number, derivative index
, and optionnally additional arguments in <code>arggrobj</code>.
</p>
</dd>
<dt><code>constr</code></dt><dd>
<p>The constraint function <code class="reqn">g</code> must have 2 arguments: vector <code>z</code>, player number,
such that <code class="reqn">g(z, playnum) &lt;= 0</code>. Optionnally, <code class="reqn">g</code> may have additional arguments in <code>argconstr</code>.
</p>
</dd>
<dt><code>grconstr</code></dt><dd>
<p>The gradient of the constraint function <code class="reqn">g</code>  must have 3 arguments: vector <code>z</code>, player number, derivative index,
and optionnally additional arguments in <code>arggrconstr</code>.
</p>
</dd>
</dl>

</dd>
<dt><b>Arguments of the Jacobian of H</b></dt><dd>	
<p>The arguments which are functions must respect the following features
</p>

<dl>
<dt><code>heobj</code></dt><dd><p>It must have 4 arguments: vector <code>z</code>, player number, two derivative indexes.</p>
</dd>
<dt><code>heconstr</code></dt><dd><p>It must have 4 arguments: vector <code>z</code>, player number, two derivative indexes.</p>
</dd>
</dl>

<p>Optionnally, <code>heobj</code> and <code>heconstr</code> can have additional arguments <code>argheobj</code> and <code>argheconstr</code>.
</p>
</dd>
</dl>

<p>See the example	below.
</p>


<h3>Value</h3>

<p>A vector for <code>funCER</code> or a matrix for <code>jacCER</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>Dreves, A., Facchinei, F., Kanzow, C. and Sagratella, S. (2011), 
<em>On the solutions of the KKT conditions of generalized Nash equilibrium problems</em>,
SIAM Journal on Optimization.
</p>
<p>F. Facchinei, A. Fischer and V. Piccialli (2009), 
<em>Generalized Nash equilibrium problems and Newton methods</em>,
Math. Program.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GNE.ceq">GNE.ceq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


#-------------------------------------------------------------------------------
# (1) Example 5 of von Facchinei et al. (2007)
#-------------------------------------------------------------------------------

dimx &lt;- c(1, 1)
#Gr_x_j O_i(x)
grobj &lt;- function(x, i, j)
{
	if(i == 1)
		res &lt;- c(2*(x[1]-1), 0)
	if(i == 2)
		res &lt;- c(0, 2*(x[2]-1/2))
	res[j]	
}
#Gr_x_k Gr_x_j O_i(x)
heobj &lt;- function(x, i, j, k)
	2 * (i == j &amp;&amp; j == k)

dimlam &lt;- c(1, 1)
#constraint function g_i(x)
g &lt;- function(x, i)
	sum(x[1:2]) - 1
#Gr_x_j g_i(x)
grg &lt;- function(x, i, j)
	1
#Gr_x_k Gr_x_j g_i(x)
heg &lt;- function(x, i, j, k)
	0


x0 &lt;- rep(0, sum(dimx))
z0 &lt;- c(x0, 2, 2, max(10, 5-g(x0, 1) ), max(10, 5-g(x0, 2) ) )

#true value is (3/4, 1/4, 1/2, 1/2)
funCER(z0, dimx, dimlam, grobj=grobj, 
	constr=g, grconstr=grg)

jacCER(z0, dimx, dimlam, heobj=heobj, 
	constr=g, grconstr=grg, heconstr=heg)



#-------------------------------------------------------------------------------
# (2) Duopoly game of Krawczyk and Stanislav Uryasev (2000)
#-------------------------------------------------------------------------------


#constants
myarg &lt;- list(d= 20, lambda= 4, rho= 1)

dimx &lt;- c(1, 1)
#Gr_x_j O_i(x)
grobj &lt;- function(x, i, j, arg)
{
	res &lt;- -arg$rho * x[i]
	if(i == j)
	res &lt;- res + arg$d - arg$lambda - arg$rho*(x[1]+x[2])
	-res
}
#Gr_x_k Gr_x_j O_i(x)
heobj &lt;- function(x, i, j, k, arg)
	arg$rho * (i == j) + arg$rho * (j == k)	


dimlam &lt;- c(1, 1)
#constraint function g_i(x)
g &lt;- function(x, i)
	-x[i]
#Gr_x_j g_i(x)
grg &lt;- function(x, i, j)
	-1*(i == j)
#Gr_x_k Gr_x_j g_i(x)
heg &lt;- function(x, i, j, k)
	0

#true value is (16/3, 16/3, 0, 0) 

x0 &lt;- rep(0, sum(dimx))
z0 &lt;- c(x0, 2, 2, max(10, 5-g(x0, 1) ), max(10, 5-g(x0, 2) ) )


funCER(z0, dimx, dimlam, grobj=grobj, arggrobj=myarg, 
	constr=g, grconstr=grg)

jacCER(z0, dimx, dimlam, heobj=heobj, 
	argheobj=myarg, constr=g, grconstr=grg, heconstr=heg)





</code></pre>

<hr>
<h2 id='compl'>Complementarity functions</h2><span id='topic+complementarity'></span><span id='topic+phiFB'></span><span id='topic+phipFB'></span><span id='topic+phirFB'></span><span id='topic+phiMin'></span><span id='topic+phiMan'></span><span id='topic+phiKK'></span><span id='topic+phiLT'></span><span id='topic+GrAphiFB'></span><span id='topic+GrBphiFB'></span><span id='topic+GrAphipFB'></span><span id='topic+GrBphipFB'></span><span id='topic+GrAphirFB'></span><span id='topic+GrBphirFB'></span><span id='topic+GrAphiMin'></span><span id='topic+GrBphiMin'></span><span id='topic+GrAphiMan'></span><span id='topic+GrBphiMan'></span><span id='topic+GrAphiKK'></span><span id='topic+GrBphiKK'></span><span id='topic+GrAphiLT'></span><span id='topic+GrBphiLT'></span><span id='topic+compl.par'></span><span id='topic+print.compl.par'></span><span id='topic+summary.compl.par'></span>

<h3>Description</h3>

<p>Classic Complementarity functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phiFB(a, b) 
GrAphiFB(a, b) 
GrBphiFB(a, b) 

phipFB(a, b, p) 
GrAphipFB(a, b, p) 
GrBphipFB(a, b, p) 

phirFB(a, b) 
GrAphirFB(a, b) 
GrBphirFB(a, b) 

phiMin(a, b) 
GrAphiMin(a, b) 
GrBphiMin(a, b)

phiMan(a, b, f, fprime)
GrAphiMan(a, b, f, fprime)
GrBphiMan(a, b, f, fprime)

phiKK(a, b, lambda)
GrAphiKK(a, b, lambda)
GrBphiKK(a, b, lambda)


phiLT(a, b, q)
GrAphiLT(a, b, q)
GrBphiLT(a, b, q)

compl.par(type=c("FB", "pFB", "rFB", "Min", "Man", "LT", "KK"), 
	p, f, fprime, q, lambda)

## S3 method for class 'compl.par'
print(x, ...)

## S3 method for class 'compl.par'
summary(object, ...)



</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compl_+3A_a">a</code></td>
<td>
<p>first parameter.</p>
</td></tr>
<tr><td><code id="compl_+3A_b">b</code></td>
<td>
<p>second parameter.</p>
</td></tr>
<tr><td><code id="compl_+3A_f">f</code>, <code id="compl_+3A_fprime">fprime</code></td>
<td>
<p>a univariate function and its derivative.</p>
</td></tr>
<tr><td><code id="compl_+3A_lambda">lambda</code></td>
<td>
<p>a parameter in [0, 2[.</p>
</td></tr>
<tr><td><code id="compl_+3A_q">q</code></td>
<td>
<p>a parameter &gt;1.</p>
</td></tr>
<tr><td><code id="compl_+3A_p">p</code></td>
<td>
<p>a parameter &gt;0.</p>
</td></tr>
<tr><td><code id="compl_+3A_type">type</code></td>
<td>
<p>a character string for the complementarity
function type: either <code>"FB"</code>, <code>"Min"</code>, <code>"Man"</code>, 
<code>"LT"</code> or <code>"KK"</code>.</p>
</td></tr>
<tr><td><code id="compl_+3A_x">x</code>, <code id="compl_+3A_object">object</code></td>
<td>
<p>an object of class <code>"compl.par"</code>.</p>
</td></tr>		
<tr><td><code id="compl_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>print</code>, 
or <code>summary</code>.</p>
</td></tr>			  
</table>


<h3>Details</h3>

<p>We implement 5 complementarity functions From Facchinei &amp; Pang (2003). 
</p>

<dl>
<dt>(i) <code>phiFB</code></dt><dd><p> the Fischer-Burmeister complementarity function 
<code class="reqn">\sqrt{a^2+b^2} - (a+b)</code>.
The penalized version is <code class="reqn">phiFB(a,b) - p*max(a,0)*max(b,0)</code>, whereas
the regularized version is <code class="reqn">phiFB(a,b) - epsilon</code>.</p>
</dd>
<dt>(ii) <code>phiMin</code></dt><dd><p> the minimum complementarity function <code class="reqn">\min(a,b)</code>.</p>
</dd>
<dt>(iii) <code>phiMan</code></dt><dd><p> the Mangasarian's family of complementarity function <code class="reqn">f(|a-b|) - f(a) - f(b)</code>, 
typically <code class="reqn">f(t)=t</code> or <code class="reqn">f(t)=t^3</code>.</p>
</dd>
<dt>(iv) <code>phiKK</code></dt><dd><p> the Kanzow-Kleinmichel complementarity function 
<code class="reqn">(\sqrt( (a-b)^2 + 2*\lambda*a*b ) - (a+b) ) / (2-\lambda)</code>.</p>
</dd>
<dt>(v) <code>phiLT</code></dt><dd><p> the Luo-Tseng complementarity function <code class="reqn">(a^q + b^q)^(1/q) - (a+b)</code>.</p>
</dd>
</dl>
				
<p><code>GrAXXX</code> and <code>GrBXXX</code> implements the derivative of the complementarity 
function <code>XXX</code> with respect to <code class="reqn">a</code> and <code class="reqn">b</code> respectively.
</p>
<p><code>compl.par</code> creates an object of class <code>"compl.par"</code> with attributes
<code>"type"</code> a character string and <code>"fun","grA","grB"</code> the corresponding 
functions for a given type. 
Optional arguments are also available, e.g. lambda for the KK complementarity 
function.
</p>


<h3>Value</h3>

<p>A numeric or an object of class <code>"compl.par"</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>F. Facchinei and J.S. Pang,
<em>Finite-Dimensional Variational Inequalities and Complementarity Problems</em>, 
Springer-Verlag (New York 2003).
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GNE.nseq">GNE.nseq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
phiFB(1, 2)
phiLT(1, 2, 2)
phiKK(1, 2, 1)

-2*phiMin(1, 2)
phiMan(1, 2, function(t) t)

complFB &lt;- compl.par("FB") 
summary(complFB)

complKK &lt;- compl.par("KK", lambda=1) 
summary(complKK)

complKK$fun(1, 1, complKK$lambda)
complFB$fun(1, 1)

</code></pre>

<hr>
<h2 id='eqsolve'>Solving non linear equations</h2><span id='topic+eqsolve'></span>

<h3>Description</h3>

<p>Non linear Solving methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqsolve(xinit, f, jac,
    method=c("Newton", "Levenberg-Marquardt", "Broyden"),
	global=c("line search", "none"), control=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eqsolve_+3A_xinit">xinit</code></td>
<td>
<p>initial point.</p>
</td></tr>
<tr><td><code id="eqsolve_+3A_f">f</code></td>
<td>
<p>the function for which we search roots.</p>
</td></tr>
<tr><td><code id="eqsolve_+3A_jac">jac</code></td>
<td>
<p>the Jacobian of the function <code>f</code>.</p>
</td></tr>
<tr><td><code id="eqsolve_+3A_method">method</code></td>
<td>
<p>a character string specifying the method to use: either 
<code>"Newton"</code>, <code>"Levenberg-Marquardt"</code>, or <code>"Broyden"</code>.</p>
</td></tr>	
<tr><td><code id="eqsolve_+3A_global">global</code></td>
<td>
<p>a character string for the globalization method to be used:
either <code>"line search"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="eqsolve_+3A_control">control</code></td>
<td>
<p>a list for the control parameters. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>control</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>tol</code></dt><dd><p>The absolute convergence tolerance. Default to 1e-6.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>The maximum number of iterations. Default to 100.</p>
</dd>
<dt><code>echo</code></dt><dd><p>A logical or an integer (0, 1, 2, 3, 4) to print traces. 
Default to <code>FALSE</code>, i.e. 0.</p>
</dd>
<dt><code>echofile</code></dt><dd><p>A character string to store the traces in that file. Default to <code>NULL</code>.</p>
</dd>	
<dt><code>echograph</code></dt><dd><p>A character string to plot iter-by-iter information. 
Either <code>"NULL"</code> (default), or <code>"line"</code> for line search plot 
or <code>"trust"</code> for trust region plots.</p>
</dd>	
<dt><code>sigma</code></dt><dd><p>Reduction factor for the geometric linesearch. Default to 0.5.</p>
</dd>
<dt><code>btol</code></dt><dd><p>The backtracking tolerance. Default to 0.01.</p>
</dd>	
<dt><code>delta</code></dt><dd><p>The exponent parameter for the LM parameter, should in <code class="reqn">[1,2]</code>. Default to 2.</p>
</dd>
<dt><code>initlnsrch</code></dt><dd><p>The initial integer for starting the line search. Default to 0.</p>
</dd>		
<dt><code>minstep</code></dt><dd><p>The minimal step. Default to 0.001.</p>
</dd>		
</dl>



<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt><code>par</code></dt><dd><p>The best set of parameters found.</p>
</dd>
<dt><code>counts</code></dt><dd><p>A two-element integer vector giving the number of calls to <code>phi</code> and <code>jacphi</code> respectively.</p>
</dd>			
<dt><code>iter</code></dt><dd><p>The iteration number.</p>
</dd>
<dt><code>code</code></dt><dd><p>0 if convergence, 1 if <code>maxit</code> is reached, 10 
if <code>tol</code> is not reached and 11 for both.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>See Also</h3>

<p>See <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> from the package of the same name.
</p>

<hr>
<h2 id='GNE'>GNE package</h2><span id='topic+GNE'></span>

<h3>Description</h3>

<p>Generalized Nash Equilibrium computational methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GNE(approach = 
	c("non smooth", "fixed point", "minimization", "constrained equation"), 
	method = "default", xinit, control=list(), ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GNE_+3A_approach">approach</code></td>
<td>
<p>a character string for the approach: either <code>"non smooth"</code>, 
<code>"fixed point"</code>, <code>"minimization"</code> or <code>"constrained equation"</code>.</p>
</td></tr>
<tr><td><code id="GNE_+3A_method">method</code></td>
<td>
<p>a character string for the computation method: either <code>"default"</code> or the name
of the method.</p>
</td></tr>
<tr><td><code id="GNE_+3A_xinit">xinit</code></td>
<td>
<p>a numeric vector for the initial point.</p>
</td></tr>
<tr><td><code id="GNE_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>GNE.nseq</code>, <code>GNE.fpeq</code> or <code>GNE.minpb</code>.</p>
</td></tr>
<tr><td><code id="GNE_+3A_control">control</code></td>
<td>
<p>a list with control parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing generalized Nash Equilibrium can be done in three different approaches.
</p>

<dl>
<dt>(i) extended KKT system</dt><dd><p>It consists in solving the non smooth extended Karush-Kuhn-Tucker 
(KKT) system <code class="reqn">\Phi(z)=0</code>.</p>
</dd>
<dt>(ii) fixed point approach</dt><dd><p>It consists in solving equation <code class="reqn">y(x)=x</code>.</p>
</dd>
<dt>(iii) gap function minimization</dt><dd><p>It consists in minimizing a gap function <code class="reqn">min V(x)</code>.</p>
</dd>
<dt>(iv) constrained equation</dt><dd><p>It consists in solving <code class="reqn">F(x)</code> such that <code class="reqn">x</code>
belongs to a specific set.</p>
</dd>
</dl>

<p>The <code>GNE</code> function is a global function calling the appropriate function <code><a href="#topic+GNE.nseq">GNE.nseq</a></code>, 
<code><a href="#topic+GNE.fpeq">GNE.fpeq</a></code>, <code><a href="#topic+GNE.ceq">GNE.ceq</a></code> or <code><a href="#topic+GNE.minpb">GNE.minpb</a></code>.
Benchmark functions comparing all methods for a given reformulation are 
available: see <code><a href="#topic+bench.GNE">bench.GNE</a></code>.
</p>
<p>Additionnal utitilty functions are also available:
<code><a href="#topic+rejection">rejection</a></code>, <code><a href="#topic+projector">projector</a></code>, <code><a href="#topic+stepfunc">stepfunc</a></code>,
<code><a href="#topic+complementarity">complementarity</a></code> and <code><a href="#topic+funSSR">funSSR</a></code>.
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt><code>par</code></dt><dd><p>The best set of parameters found.</p>
</dd>
<dt><code>value</code></dt><dd><p>The value of the merit function.</p>
</dd>
<dt><code>counts</code></dt><dd><p>A two-element integer vector giving the number of calls to 
<code>phi</code> and <code>jacphi</code> respectively.</p>
</dd>			
<dt><code>iter</code></dt><dd><p>The outer iteration number.</p>
</dd>
<dt><code>code</code></dt><dd>
<p>The values returned are
</p>

<dl>
<dt><code>1</code></dt><dd><p>Function criterion is near zero.
Convergence of function values has been achieved.</p>
</dd>
<dt><code>2</code></dt><dd><p>x-values within tolerance. This means that the relative distance between two
consecutive x-values is smaller than <code>xtol</code>.</p>
</dd>
<dt><code>3</code></dt><dd><p>No better point found.
This means that the algorithm has stalled and cannot find an acceptable new point.
This may or may not indicate acceptably small function values.</p>
</dd>
<dt><code>4</code></dt><dd><p>Iteration limit <code>maxit</code> exceeded.</p>
</dd>
<dt><code>5</code></dt><dd><p>Jacobian is too ill-conditioned.</p>
</dd>
<dt><code>6</code></dt><dd><p>Jacobian is singular.</p>
</dd>
<dt><code>100</code></dt><dd><p>an error in the execution.</p>
</dd>
</dl>

</dd>
<dt><code>message</code></dt><dd><p>a string describing the termination code</p>
</dd>	
<dt><code>fvec</code></dt><dd><p>a vector with function values.</p>
</dd>
<dt><code>approach</code></dt><dd><p>the name of the approach.</p>
</dd>	
</dl>



<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>F. Facchinei, A. Fischer and V. Piccialli (2009),
<em>Generalized Nash equilibrium problems and Newton methods</em>,
Math. Program.
</p>
<p>A. von Heusinger (2009),
<em>Numerical Methods for the Solution of the Generalized Nash Equilibrium Problem</em>,
Ph. D. Thesis.
</p>
<p>A. von Heusinger and C. Kanzow (2009),
<em>Optimization reformulations of the generalized Nash equilibrium problem using Nikaido-Isoda-type functions</em>,
Comput Optim Appl .
</p>
<p>F. Facchinei and C. Kanzow (2009),
<em>Generalized Nash Equilibrium problems.</em>
Preprint 290.
</p>
<p>C. Dutang (2013), 
<em>A survey of GNE computation methods: theory and algorithms</em>,
preprint on HAL, <a href="https://hal.science/hal-00813531">https://hal.science/hal-00813531</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+GNE.fpeq">GNE.fpeq</a></code>, <code><a href="#topic+GNE.minpb">GNE.minpb</a></code>, <code><a href="#topic+GNE.ceq">GNE.ceq</a></code> 
and <code><a href="#topic+GNE.nseq">GNE.nseq</a></code> for other approaches.
</p>

<hr>
<h2 id='GNE.ceq'>Constrained equation reformulation of the GNE problem.</h2><span id='topic+GNE.ceq'></span>

<h3>Description</h3>

<p>Constrained equation reformulation via the extended KKT system of the GNE problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GNE.ceq(init, dimx, dimlam, grobj, arggrobj, heobj, argheobj, 
	constr, argconstr, grconstr, arggrconstr, heconstr, argheconstr,
	dimmu, joint, argjoint, grjoint, arggrjoint, hejoint, arghejoint, 
	method="PR", control=list(), silent=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GNE.ceq_+3A_init">init</code></td>
<td>
<p>Initial values for the parameters to be optimized over: <code class="reqn">z=(x, lambda, mu)</code>.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_dimx">dimx</code></td>
<td>
<p>a vector of dimension for <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_dimlam">dimlam</code></td>
<td>
<p>a vector of dimension for <code class="reqn">lambda</code>.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_grobj">grobj</code></td>
<td>
<p>gradient of the objective function (to be minimized), see details.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_arggrobj">arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_heobj">heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_argheobj">argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td></tr>	
<tr><td><code id="GNE.ceq_+3A_constr">constr</code></td>
<td>
<p>constraint function (<code class="reqn">g^i(x)&lt;=0</code>), see details.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_argconstr">argconstr</code></td>
<td>
<p>a list of additional arguments of the constraint function.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_grconstr">grconstr</code></td>
<td>
<p>gradient of the constraint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_arggrconstr">arggrconstr</code></td>
<td>
<p>a list of additional arguments of the constraint gradient.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_heconstr">heconstr</code></td>
<td>
<p>Hessian of the constraint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_argheconstr">argheconstr</code></td>
<td>
<p>a list of additional arguments of the constraint Hessian.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_dimmu">dimmu</code></td>
<td>
<p>a vector of dimension for <code class="reqn">mu</code>.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_joint">joint</code></td>
<td>
<p>joint function (<code class="reqn">h(x)&lt;=0</code>), see details.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_argjoint">argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_grjoint">grjoint</code></td>
<td>
<p>gradient of the joint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_arggrjoint">arggrjoint</code></td>
<td>
<p>a list of additional arguments of the joint gradient.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_hejoint">hejoint</code></td>
<td>
<p>Hessian of the joint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_arghejoint">arghejoint</code></td>
<td>
<p>a list of additional arguments of the joint Hessian.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_method">method</code></td>
<td>
<p>a character string specifying the method 
<code>"PR"</code> or <code>"AS"</code>. </p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_control">control</code></td>
<td>
<p>a list with control parameters.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the optimization routine. 
NOT to the functions <code>H</code> and <code>jacH</code>.</p>
</td></tr>
<tr><td><code id="GNE.ceq_+3A_silent">silent</code></td>
<td>
<p>a logical to get some traces. Default to <code>FALSE</code>.</p>
</td></tr>	
</table>


<h3>Details</h3>

<p><code>GNE.ceq</code> solves the GNE problem via a constrained equation reformulation of the KKT system. 
</p>
<p>This approach consists in solving the extended Karush-Kuhn-Tucker 
(KKT) system denoted by <code class="reqn">H(z)=0</code>, for <code class="reqn">z \in \Omega</code> where <code class="reqn">z</code> is formed by the players strategy 
<code class="reqn">x</code>, the Lagrange multiplier <code class="reqn">\lambda</code> and the slate variable <code class="reqn">w</code>.
The root problem <code class="reqn">H(z)=0</code> is solved by an iterative scheme <code class="reqn">z_{n+1} = z_n + d_n</code>,
where the direction <code class="reqn">d_n</code> is computed in two different ways. Let <code class="reqn">J(x)=Jac H(x)</code>.
There are two possible methods either <code>"PR"</code> for potential reduction algorithm
or <code>"AS"</code> for affine scaled trust reduction algorithm.
</p>

<dl>
<dt>(a) potential reduction algorithm:</dt><dd><p>The direction solves the system 
<code class="reqn">H(z_n) + J(z_n) d = sigma_n a^T H(z_n) / ||a||_2^2 a</code>.
</p>
</dd>
<dt>(b) bound-constrained trust region algorithm:</dt><dd><p>The direction solves the system
<code class="reqn">\min_p ||J(z_n)^T p + H(z_n)||^2 </code>,
for <code class="reqn">p</code> such that <code class="reqn">||p|| &lt;= Delta_n||</code>.
</p>
</dd>
</dl>

<p><code>...</code> are further arguments to be passed to the optimization routine, 
that is <code>global</code>, <code>xscalm</code>, <code>silent</code>. 
A globalization scheme can be choosed using the <code>global</code> argument. 
Available schemes are 
</p>

<dl>
<dt>(1) Line search:</dt><dd><p> if <code>global</code> is set to <code>"qline"</code> or <code>"gline"</code>, a line search
is used with the merit function being half of the L2 norm of <code class="reqn">Phi</code>, respectively with a
quadratic or a geometric implementation.</p>
</dd>
<dt>(3) Trust-region:</dt><dd><p> if  <code>global</code> is set to <code>"pwldog"</code>, the Powell dogleg method
is used. </p>
</dd>
<dt>(2) None:</dt><dd><p> if  <code>global</code> is set to <code>"none"</code>, no globalization is done. </p>
</dd>
</dl>
	
<p>The default value of <code>global</code> is <code>"gline"</code> when <code>method="PR"</code> and 
<code>"pwldog"</code> when <code>method="AS"</code>.
The <code>xscalm</code> is a scaling parameter to used, either <code>"fixed"</code> (default)
or <code>"auto"</code>, for which scaling factors are calculated from the euclidean norms of the 
columns of the jacobian matrix. 
The <code>silent</code> argument is a logical to report or not the optimization process, default
to <code>FALSE</code>.
</p>
<p>The <code>control</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>xtol</code></dt><dd><p>The relative steplength tolerance.
When the relative  steplength of all scaled x values is smaller than this value
convergence is declared. The default value is <code class="reqn">10^{-8}</code>.
</p>
</dd>
<dt><code>ftol</code></dt><dd><p>The function value tolerance.
Convergence is declared when the largest absolute function value is smaller than <code>ftol</code>.
The	default value is <code class="reqn">10^{-8}</code>.
</p>
</dd>
<dt><code>btol</code></dt><dd><p>The backtracking tolerance.
The	default value is <code class="reqn">10^{-2}</code>.
</p>
</dd>	
<dt><code>maxit</code></dt><dd><p>The maximum number of major iterations. The default value is 100 if a 
global strategy has been specified.</p>
</dd>
<dt><code>trace</code></dt><dd><p>Non-negative integer. A value of 1 will give a detailed report of the
progress of the iteration, default 0.</p>
</dd>
<dt><code>sigma</code>, <code>delta</code>, <code>zeta</code></dt><dd><p>Parameters initialized to <code>1/2</code>, 
<code>1</code>, <code>length(init)/2</code>, respectively, when <code>method="PR"</code>.</p>
</dd>
<dt><code>forcingpar</code></dt><dd><p>Forcing parameter set to 0.1, when <code>method="PR"</code>.</p>
</dd>
<dt><code>theta</code>, <code>radiusmin</code>, <code>reducmin</code>, <code>radiusmax</code>, 
<code>radiusred</code>, <code>reducred</code>, <code>radiusexp</code>, <code>reducexp</code></dt><dd>
<p>Parameters initialized to <code>0.99995</code>, <code>1</code>, <code>0.1</code>, <code>1e10</code>, 
<code>1/2</code>, <code>1/4</code>, <code>2</code>, <code>3/4</code>, when <code>method="AS"</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>GNE.ceq</code> returns a list with components:
</p>

<dl>
<dt><code>par</code></dt><dd><p>The best set of parameters found.</p>
</dd>
<dt><code>value</code></dt><dd><p>The value of the merit function.</p>
</dd>
<dt><code>counts</code></dt><dd><p>A two-element integer vector giving the number of calls to 
<code>H</code> and <code>jacH</code> respectively.</p>
</dd>			
<dt><code>iter</code></dt><dd><p>The outer iteration number.</p>
</dd>
<dt><code>code</code></dt><dd>
<p>The values returned are
</p>

<dl>
<dt><code>1</code></dt><dd><p>Function criterion is near zero.
Convergence of function values has been achieved.</p>
</dd>
<dt><code>2</code></dt><dd><p>x-values within tolerance. This means that the relative distance between two
consecutive x-values is smaller than <code>xtol</code>.</p>
</dd>
<dt><code>3</code></dt><dd><p>No better point found.
This means that the algorithm has stalled and cannot find an acceptable new point.
This may or may not indicate acceptably small function values.</p>
</dd>
<dt><code>4</code></dt><dd><p>Iteration limit <code>maxit</code> exceeded.</p>
</dd>
<dt><code>5</code></dt><dd><p>Jacobian is too ill-conditioned.</p>
</dd>
<dt><code>6</code></dt><dd><p>Jacobian is singular.</p>
</dd>
<dt><code>100</code></dt><dd><p>an error in the execution.</p>
</dd>
</dl>

</dd>
<dt><code>message</code></dt><dd><p>a string describing the termination code.</p>
</dd>	
<dt><code>fvec</code></dt><dd><p>a vector with function values.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>J.E. Dennis and J.J. Moree (1977), 
<em>Quasi-Newton methods, Motivation and Theory</em>,
SIAM review.
</p>
<p>Monteiro, R. and Pang, J.-S. (1999), 
<em>A Potential Reduction Newton Method for Constrained equations</em>, 
SIAM Journal on Optimization 9(3), 729-754.
</p>
<p>S. Bellavia, M. Macconi and B. Morini (2003),
<em>An affine scaling trust-region approach to bound-constrained nonlinear systems</em>,
Applied Numerical Mathematics 44, 257-280
</p>
<p>A. Dreves, F. Facchinei, C. Kanzow and S. Sagratella (2011), 
<em>On the solutions of the KKT conditions of generalized Nash equilibrium problems</em>, 
SIAM Journal on Optimization 21(3), 1082-1108.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+GNE.fpeq">GNE.fpeq</a></code>, <code><a href="#topic+GNE.minpb">GNE.minpb</a></code> and <code><a href="#topic+GNE.nseq">GNE.nseq</a></code> 
for other approaches; <code><a href="#topic+funCER">funCER</a></code> and
<code><a href="#topic+jacCER">jacCER</a></code> for template functions of <code class="reqn">H</code> and <code class="reqn">Jac H</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#-------------------------------------------------------------------------------
# (1) Example 5 of von Facchinei et al. (2007)
#-------------------------------------------------------------------------------

dimx &lt;- c(1, 1)
#Gr_x_j O_i(x)
grobj &lt;- function(x, i, j)
{
	if(i == 1)
		res &lt;- c(2*(x[1]-1), 0)
	if(i == 2)
		res &lt;- c(0, 2*(x[2]-1/2))
	res[j]	
}
#Gr_x_k Gr_x_j O_i(x)
heobj &lt;- function(x, i, j, k)
	2 * (i == j &amp;&amp; j == k)

dimlam &lt;- c(1, 1)
#constraint function g_i(x)
g &lt;- function(x, i)
	sum(x[1:2]) - 1
#Gr_x_j g_i(x)
grg &lt;- function(x, i, j)
	1
#Gr_x_k Gr_x_j g_i(x)
heg &lt;- function(x, i, j, k)
	0


x0 &lt;- rep(0, sum(dimx))
z0 &lt;- c(x0, 2, 2, max(10, 5-g(x0, 1) ), max(10, 5-g(x0, 2) ) )

#true value is (3/4, 1/4, 1/2, 1/2)
GNE.ceq(z0, dimx, dimlam, grobj=grobj, heobj=heobj, 
	constr=g, grconstr=grg, heconstr=heg, method="PR", 
	control=list(trace=0, maxit=10))


GNE.ceq(z0, dimx, dimlam, grobj=grobj, heobj=heobj, 
	constr=g, grconstr=grg, heconstr=heg, method="AS", global="pwldog", 
	xscalm="auto", control=list(trace=0, maxit=100))


#-------------------------------------------------------------------------------
# (2) Duopoly game of Krawczyk and Stanislav Uryasev (2000)
#-------------------------------------------------------------------------------


#constants
myarg &lt;- list(d= 20, lambda= 4, rho= 1)

dimx &lt;- c(1, 1)
#Gr_x_j O_i(x)
grobj &lt;- function(x, i, j, arg)
{
	res &lt;- -arg$rho * x[i]
	if(i == j)
	res &lt;- res + arg$d - arg$lambda - arg$rho*(x[1]+x[2])
	-res
}
#Gr_x_k Gr_x_j O_i(x)
heobj &lt;- function(x, i, j, k, arg)
	arg$rho * (i == j) + arg$rho * (j == k)	


dimlam &lt;- c(1, 1)
#constraint function g_i(x)
g &lt;- function(x, i)
	-x[i]
#Gr_x_j g_i(x)
grg &lt;- function(x, i, j)
	-1*(i == j)
#Gr_x_k Gr_x_j g_i(x)
heg &lt;- function(x, i, j, k)
	0

#true value is (16/3, 16/3, 0, 0) 

x0 &lt;- rep(0, sum(dimx))
z0 &lt;- c(x0, 2, 2, max(10, 5-g(x0, 1) ), max(10, 5-g(x0, 2) ) )


GNE.ceq(z0, dimx, dimlam, grobj=grobj, heobj=heobj, arggrobj=myarg, 
	argheobj=myarg, constr=g, grconstr=grg, heconstr=heg,
	method="PR", control=list(trace=0, maxit=10))

GNE.ceq(z0, dimx, dimlam, grobj=grobj, heobj=heobj, arggrobj=myarg, 
	argheobj=myarg, constr=g, grconstr=grg, heconstr=heg, 
	method="AS", global="pwldog", xscalm="auto", control=list(trace=0, maxit=100))

	

</code></pre>

<hr>
<h2 id='GNE.fpeq'>Fixed point equation reformulation of the GNE problem.</h2><span id='topic+GNE.fpeq'></span>

<h3>Description</h3>

<p>Fixed point equation reformulation via the NI function of the GNE problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GNE.fpeq(init, dimx, obj, argobj, grobj, arggrobj, 
	heobj, argheobj, joint, argjoint, jacjoint, argjacjoint, 
	method = "default", problem = c("NIR", "VIR"), 
	merit = c("NI", "VI", "FP"), order.method=1, control.outer=list(), 
	control.inner=list(), silent=TRUE, param=list(), stepfunc, argstep, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GNE.fpeq_+3A_init">init</code></td>
<td>
<p>Initial values for the parameters to be optimized over: <code class="reqn">z=(x, lambda, mu)</code>.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_dimx">dimx</code></td>
<td>
<p>a vector of dimension for <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_obj">obj</code></td>
<td>
<p>objective function (to be minimized), see details.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_argobj">argobj</code></td>
<td>
<p>a list of additional arguments.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_grobj">grobj</code></td>
<td>
<p>gradient of the objective function, see details.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_arggrobj">arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_heobj">heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_argheobj">argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_joint">joint</code></td>
<td>
<p>joint function (<code class="reqn">h(x)&lt;=0</code>), see details.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_argjoint">argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_jacjoint">jacjoint</code></td>
<td>
<p>Jacobian of the joint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_argjacjoint">argjacjoint</code></td>
<td>
<p>a list of additional arguments of the Jacobian.</p>
</td></tr>  
<tr><td><code id="GNE.fpeq_+3A_method">method</code></td>
<td>
<p>either <code>"pure"</code>, <code>"UR"</code>, <code>"vH"</code>, <code>"RRE"</code>, <code>"MPE"</code>, 
<code>"SqRRE"</code> or <code>"SqMPE"</code> method, see details. <code>"default"</code> 
corresponds to <code>"MPE"</code>.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_problem">problem</code></td>
<td>
<p>either <code>"NIR"</code>, <code>"VIP"</code>, see details.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_merit">merit</code></td>
<td>
<p>either <code>"NI"</code>, <code>"VI"</code>, <code>"FP"</code>, see details.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_order.method">order.method</code></td>
<td>
<p>the order of the extrapolation method.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_control.outer">control.outer</code></td>
<td>
<p>a list with control parameters for the fixed point algorithm.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_control.inner">control.inner</code></td>
<td>
<p>a list with control parameters for the fixed point function.</p>
</td></tr>  
<tr><td><code id="GNE.fpeq_+3A_silent">silent</code></td>
<td>
<p>a logical to show some traces.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_param">param</code></td>
<td>
<p>a list of parameters for the computation of the fixed point function.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_stepfunc">stepfunc</code></td>
<td>
<p>the step function, only needed when <code>method="UR"</code>.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_argstep">argstep</code></td>
<td>
<p>additional arguments for the step function.</p>
</td></tr>
<tr><td><code id="GNE.fpeq_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the optimization routine. 
NOT to the functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions in argument must respect the following template:
</p>

<ul>
<li><p><code>obj</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code> 
and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>grobj</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>heobj</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative indexes <code>j</code>, <code>k</code> and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>joint</code> must have arguments the current iterate <code>z</code>
and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>jacjoint</code> must have arguments the current iterate <code>z</code>,
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li></ul>

<p>The fixed point approach consists in solving equation <code class="reqn">y(x)=x</code>.
</p>

<dl>
<dt>(a) Crude or pure fixed point method:</dt><dd>
<p>It simply consists in iterations <code class="reqn">x_{n+1} = y(x_n)</code>.</p>
</dd>
<dt>(b) Polynomial methods:</dt><dd>

<dl>
<dt>- relaxation algorithm (linear extrapolation):</dt><dd>
<p>The next iterate is computed as </p>
<p style="text-align: center;"><code class="reqn">x_{n+1} = (1-\alpha_n) x_n + \alpha_n y(x_n).</code>
</p>

<p>The step <code class="reqn">\alpha_n</code> can be computed in different ways: constant, decreasing
serie or a line search method. In the literature of game theory, the decreasing serie
refers to the method of Ursayev and Rubinstein (<code>method="UR"</code>) while the line search
method refers to the method of von Heusinger (<code>method="vH"</code>). Note that the constant
step can be done using the UR method.</p>
</dd>
<dt>- RRE and MPE method:</dt><dd>
<p>Reduced Rank Extrapolation and Minimal Polynomial Extrapolation 
methods are polynomial extrapolation methods, where the monomials are functional 
&ldquo;powers&rdquo; of the y function, i.e. function composition of y. Of order 1, RRE and MPE
consists of </p>
<p style="text-align: center;"><code class="reqn">x_{n+1} = x_n + t_n (y(x_n) - x_n),</code>
</p>
 
<p>where <code class="reqn">t_n</code> equals to
<code class="reqn">&lt;v_n, r_n&gt; / &lt;v_n, v_n&gt;</code> for RRE1 and <code class="reqn">&lt;r_n, r_n&gt; / &lt;v_n, r_n&gt;</code> for MPE1, where
<code class="reqn">r_n =y(x_n) - x_n </code> and <code class="reqn">v_n = y(y(x_n)) - 2y(x_n) + x_n</code>. 
To use RRE/MPE methods, set <code>method = "RRE"</code> or <code>method = "MPE"</code>.</p>
</dd>	
<dt>- squaring method:</dt><dd>
<p>It consists in using an extrapolation method (such as RRE and MPE)
after two iteration of the linear extrapolation, i.e. 
</p>
<p style="text-align: center;"><code class="reqn">x_{n+1} = x_n -2 t_n r_n + t_n^2 v_n.</code>
</p>
<p> The squared version of RRE/MPE methods are
available via setting <code>method = "SqRRE"</code> or <code>method = "SqMPE"</code>.</p>
</dd>	
</dl>

</dd>
<dt>(c) Epsilon algorithms:</dt><dd><p>Not implemented.</p>
</dd>
</dl>

<p>For details on fixed point methods, see Varadhan &amp; Roland (2004).
</p>
<p>The <code>control.outer</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>merit="FP"</code> and <code>method="pure"</code></dt><dd><p>see <code><a href="SQUAREM.html#topic+fpiter">fpiter</a></code>.
the default parameters are <code>list(tol=1e-6, maxiter=100, trace=TRUE)</code>.
</p>
</dd>
<dt><code>merit="FP"</code> and <code>method!="pure"</code></dt><dd><p>see <code><a href="SQUAREM.html#topic+squarem">squarem</a></code>.
the default parameters are <code>list(tol=1e-6, maxiter=100, trace=TRUE)</code>.
</p>
</dd>
<dt><code>merit!="FP"</code></dt><dd><p>parameters are 
</p>

<dl>
<dt><code>tol</code></dt><dd><p>The absolute convergence tolerance. Default to 1e-6.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>The maximum number of iterations. Default to 100.</p>
</dd>
<dt><code>echo</code></dt><dd><p>A logical or an integer (0, 1, 2, 3) to print traces. 
Default to <code>FALSE</code>, i.e. 0.</p>
</dd>
<dt><code>sigma, beta</code></dt><dd><p>parameters for von Heusinger algorithm. 
Default to 9/10 and 1/2 respectively.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt><code>par</code></dt><dd><p>The best set of parameters found.</p>
</dd>
<dt><code>value</code></dt><dd><p>The value of the merit function.</p>
</dd>
<dt><code>outer.counts</code></dt><dd><p>A two-element integer vector giving the number of 
calls to fixed-point and merit functions respectively.</p>
</dd>					
<dt><code>outer.iter</code></dt><dd><p>The outer iteration number.</p>
</dd>
<dt><code>code</code></dt><dd>
<p>The values returned are
</p>

<dl>
<dt><code>1</code></dt><dd><p>Function criterion is near zero.
Convergence of function values has been achieved.</p>
</dd>
<dt><code>4</code></dt><dd><p>Iteration limit <code>maxit</code> exceeded.</p>
</dd>
<dt><code>100</code></dt><dd><p>an error in the execution.</p>
</dd>
</dl>

</dd>
<dt><code>inner.iter</code></dt><dd><p>The iteration number when 
computing the fixed-point function.</p>
</dd>	
<dt><code>inner.counts</code></dt><dd><p>A two-element integer 
vector giving the number of calls to the gap function and its gradient 
when computing the fixed-point function.</p>
</dd>			
<dt><code>message</code></dt><dd><p>a string describing the termination code</p>
</dd>	
</dl>



<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>A. von Heusinger (2009),
<em>Numerical Methods for the Solution of the Generalized Nash Equilibrium Problem</em>,
Ph. D. Thesis.
</p>
<p>A. von Heusinger and C. Kanzow (2009),
<em>Optimization reformulations of the generalized Nash equilibrium problem using Nikaido-Isoda-type functions</em>,
Comput Optim Appl .
</p>
<p>S. Uryasev and R.Y. Rubinstein (1994),
<em>On relaxation algorithms in computation of noncooperative equilibria</em>, 
IEEE Transactions on Automatic Control.
</p>
<p>R. Varadhan and C. Roland (2004),
<em>Squared Extrapolation Methods (SQUAREM): A New Class of Simple and Efficient Numerical 
Schemes for Accelerating the Convergence of the EM Algorithm</em>,
Johns Hopkins University, Dept. of Biostatistics Working Papers.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+GNE.ceq">GNE.ceq</a></code>, <code><a href="#topic+GNE.minpb">GNE.minpb</a></code> and <code><a href="#topic+GNE.nseq">GNE.nseq</a></code> 
for other approaches.
</p>

<hr>
<h2 id='GNE.minpb'>Non smooth equation reformulation of the GNE problem.</h2><span id='topic+GNE.minpb'></span>

<h3>Description</h3>

<p>Non smooth equation reformulation via the extended KKT system of the GNE problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GNE.minpb(init, dimx, obj, argobj, grobj, arggrobj, 
	heobj, argheobj, joint, argjoint, jacjoint, argjacjoint, 
	method="default", problem = c("NIR", "VIR"), control.outer=list(), 
	control.inner=list(), silent=TRUE, param=list(), 
	optim.type=c("free","constr"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GNE.minpb_+3A_init">init</code></td>
<td>
<p>Initial values for the parameters to be optimized over: <code class="reqn">z=(x, lambda, mu)</code>.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_dimx">dimx</code></td>
<td>
<p>a vector of dimension for <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_obj">obj</code></td>
<td>
<p>objective function (to be minimized), see details.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_argobj">argobj</code></td>
<td>
<p>a list of additional arguments.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_grobj">grobj</code></td>
<td>
<p>gradient of the objective function, see details.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_arggrobj">arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_heobj">heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_argheobj">argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_joint">joint</code></td>
<td>
<p>joint function (<code class="reqn">h(x)&lt;=0</code>), see details.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_argjoint">argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_jacjoint">jacjoint</code></td>
<td>
<p>Jacobian of the joint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_argjacjoint">argjacjoint</code></td>
<td>
<p>a list of additional arguments of the Jacobian.</p>
</td></tr>  
<tr><td><code id="GNE.minpb_+3A_method">method</code></td>
<td>
<p>either <code>"BB"</code>, <code>"CG"</code> or <code>"BFGS"</code>, see details.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_problem">problem</code></td>
<td>
<p>either <code>"NIR"</code>, <code>"VIP"</code>, see details.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_optim.type">optim.type</code></td>
<td>
<p>either <code>"free"</code>, <code>"constr"</code>, see details.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_control.outer">control.outer</code></td>
<td>
<p>a list with control parameters for the minimization algorithm.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_control.inner">control.inner</code></td>
<td>
<p>a list with control parameters for the minimization function.</p>
</td></tr>  
<tr><td><code id="GNE.minpb_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the optimization routine. 
NOT to the functions <code>phi</code> and <code>jacphi</code>.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_silent">silent</code></td>
<td>
<p>a logical to show some traces.</p>
</td></tr>
<tr><td><code id="GNE.minpb_+3A_param">param</code></td>
<td>
<p>a list of parameters for the computation of the minimization function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions in argument must respect the following template:
</p>

<ul>
<li><p><code>obj</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code> 
and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>grobj</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>heobj</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative indexes <code>j</code>, <code>k</code> and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>joint</code> must have arguments the current iterate <code>z</code>
and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>jacjoint</code> must have arguments the current iterate <code>z</code>,
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li></ul>

<p>The gap function minimization consists in minimizing a gap function <code class="reqn">min V(x)</code>. The function <code>minGap</code>
provides two optimization methods to solve this minimization problem.
</p>

<dl>
<dt>Barzilai-Borwein algorithm</dt><dd><p>when <code>method = "BB"</code>, we use Barzilai-Borwein iterative scheme
to find the minimum.</p>
</dd>
<dt>Conjugate gradient algorithm</dt><dd><p>when <code>method = "CG"</code>, we use the CG iterative
scheme implemented in <code>R</code>, an Hessian-free method. </p>
</dd>	
<dt>Broyden-Fletcher-Goldfarb-Shanno algorithm</dt><dd><p>when <code>method = "BFGS"</code>, we use the BFGS iterative
scheme implemented in <code>R</code>, a quasi-Newton method with line search. </p>
</dd>	
</dl>

<p>In the game theory literature, there are two main gap functions: the regularized 
Nikaido-Isoda (NI) function and the regularized QVI gap function.
This correspond to <code>type="NI"</code> and <code>type="VI"</code>, respectively. 
See von Heusinger &amp; Kanzow (2009) for details on the NI function and 
Kubota &amp; Fukushima (2009) for the QVI regularized gap function.
</p>
<p>The <code>control.outer</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>tol</code></dt><dd><p>The absolute convergence tolerance. Default to 1e-6.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>The maximum number of iterations. Default to 100.</p>
</dd>
<dt><code>echo</code></dt><dd><p>A logical or an integer (0, 1, 2, 3) to print traces. 
Default to <code>FALSE</code>, i.e. 0.</p>
</dd>
<dt><code>stepinit</code></dt><dd><p>Initial step size for the BB method (should be 
small if gradient is &ldquo;big&rdquo;). Default to 1.</p>
</dd>
</dl>

<p>Note that the <code>Gap</code> function can return a numeric or a list with computation details. In the
latter case, the object return must be a list with the following components
<code>value</code>, <code>counts</code>, <code>iter</code>, see the example below.
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt><code>par</code></dt><dd><p>The best set of parameters found.</p>
</dd>
<dt><code>value</code></dt><dd><p>The value of the merit function.</p>
</dd>
<dt><code>outer.counts</code></dt><dd><p>A two-element integer vector giving the number of 
calls to <code>Gap</code> and <code>gradGap</code> respectively.</p>
</dd>				
<dt><code>outer.iter</code></dt><dd><p>The outer iteration number.</p>
</dd>
<dt><code>code</code></dt><dd>
<p>The values returned are
</p>

<dl>
<dt><code>1</code></dt><dd><p>Function criterion is near zero.
Convergence of function values has been achieved.</p>
</dd>
<dt><code>2</code></dt><dd><p>x-values within tolerance. This means that the relative distance between two
consecutive x-values is smaller than <code>xtol</code>.</p>
</dd>
<dt><code>3</code></dt><dd><p>No better point found.
This means that the algorithm has stalled and cannot find an acceptable new point.
This may or may not indicate acceptably small function values.</p>
</dd>
<dt><code>4</code></dt><dd><p>Iteration limit <code>maxit</code> exceeded.</p>
</dd>
<dt><code>5</code></dt><dd><p>Jacobian is too ill-conditioned.</p>
</dd>
<dt><code>6</code></dt><dd><p>Jacobian is singular.</p>
</dd>
<dt><code>100</code></dt><dd><p>an error in the execution.</p>
</dd>
</dl>

</dd>
<dt><code>inner.iter</code></dt><dd><p>The iteration number when 
computing the minimization function.</p>
</dd>	
<dt><code>inner.counts</code></dt><dd><p>A two-element integer 
vector giving the number of calls to the gap function and its gradient 
when computing the minimization function.</p>
</dd>			
<dt><code>message</code></dt><dd><p>a string describing the termination code</p>
</dd>	
</dl>



<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>A. von Heusinger (2009),
<em>Numerical Methods for the Solution of the Generalized Nash Equilibrium Problem</em>,
Ph. D. Thesis.
</p>
<p>A. von Heusinger and C. Kanzow (2009),
<em>Optimization reformulations of the generalized Nash equilibrium problem using Nikaido-Isoda-type functions</em>,
Comput Optim Appl .
</p>
<p>K. Kubota and M. Fukushima (2009), 
<em>Gap function approach to the generalized Nash Equilibrium problem</em>,
Journal of Optimization theory and applications.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+GNE.fpeq">GNE.fpeq</a></code>, <code><a href="#topic+GNE.ceq">GNE.ceq</a></code> and <code><a href="#topic+GNE.nseq">GNE.nseq</a></code> 
for other approaches.
</p>

<hr>
<h2 id='GNE.nseq'>Non smooth equation reformulation of the GNE problem.</h2><span id='topic+GNE.nseq'></span>

<h3>Description</h3>

<p>Non smooth equation reformulation via the extended KKT system of the GNE problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GNE.nseq(init, dimx, dimlam, grobj, arggrobj, heobj, argheobj, 
	constr, argconstr, grconstr, arggrconstr, heconstr, argheconstr,
	compl, gcompla, gcomplb, argcompl, 
	dimmu, joint, argjoint, grjoint, arggrjoint, hejoint, arghejoint, 
	method="default", control=list(), silent=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GNE.nseq_+3A_init">init</code></td>
<td>
<p>Initial values for the parameters to be optimized over: <code class="reqn">z=(x, lambda, mu)</code>.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_dimx">dimx</code></td>
<td>
<p>a vector of dimension for <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_dimlam">dimlam</code></td>
<td>
<p>a vector of dimension for <code class="reqn">lambda</code>.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_grobj">grobj</code></td>
<td>
<p>gradient of the objective function (to be minimized), see details.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_arggrobj">arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_heobj">heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_argheobj">argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td></tr>	
<tr><td><code id="GNE.nseq_+3A_constr">constr</code></td>
<td>
<p>constraint function (<code class="reqn">g^i(x)&lt;=0</code>), see details.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_argconstr">argconstr</code></td>
<td>
<p>a list of additional arguments of the constraint function.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_grconstr">grconstr</code></td>
<td>
<p>gradient of the constraint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_arggrconstr">arggrconstr</code></td>
<td>
<p>a list of additional arguments of the constraint gradient.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_heconstr">heconstr</code></td>
<td>
<p>Hessian of the constraint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_argheconstr">argheconstr</code></td>
<td>
<p>a list of additional arguments of the constraint Hessian.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_compl">compl</code></td>
<td>
<p>the complementarity function with (at least) two arguments: <code>compl(a,b)</code>.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_argcompl">argcompl</code></td>
<td>
<p>list of possible additional arguments for <code>compl</code>.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_gcompla">gcompla</code></td>
<td>
<p>derivative of the complementarity function w.r.t. the first argument.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_gcomplb">gcomplb</code></td>
<td>
<p>derivative of the complementarity function w.r.t. the second argument.</p>
</td></tr>   
<tr><td><code id="GNE.nseq_+3A_dimmu">dimmu</code></td>
<td>
<p>a vector of dimension for <code class="reqn">mu</code>.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_joint">joint</code></td>
<td>
<p>joint function (<code class="reqn">h(x)&lt;=0</code>), see details.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_argjoint">argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_grjoint">grjoint</code></td>
<td>
<p>gradient of the joint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_arggrjoint">arggrjoint</code></td>
<td>
<p>a list of additional arguments of the joint gradient.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_hejoint">hejoint</code></td>
<td>
<p>Hessian of the joint function, see details.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_arghejoint">arghejoint</code></td>
<td>
<p>a list of additional arguments of the joint Hessian.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_method">method</code></td>
<td>
<p>a character string specifying the method <code>"Newton"</code>,
<code>"Broyden"</code>, <code>"Levenberg-Marquardt"</code> or <code>"default"</code> 
which is <code>"Newton"</code>. </p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_control">control</code></td>
<td>
<p>a list with control parameters.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the optimization routine. 
NOT to the functions <code>phi</code> and <code>jacphi</code>.</p>
</td></tr>
<tr><td><code id="GNE.nseq_+3A_silent">silent</code></td>
<td>
<p>a logical to get some traces. Default to <code>FALSE</code>.</p>
</td></tr>	
</table>


<h3>Details</h3>

<p>Functions in argument must respect the following template:
</p>

<ul>
<li><p><code>constr</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code> 
and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>grobj</code>, <code>grconstr</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>heobj</code>, <code>heconstr</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative indexes <code>j</code>, <code>k</code> and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>compl</code>, <code>gcompla</code>, <code>gcomplb</code> must have two arguments <code>a</code>, <code>b</code> and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>joint</code> must have arguments the current iterate <code>z</code>
and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>grjoint</code> must have arguments the current iterate <code>z</code>,
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li>
<li><p><code>hejoint</code> must have arguments the current iterate <code>z</code>, 
the derivative indexes <code>j</code>, <code>k</code> and optionnally additional arguments given in a list.
</p>
</li></ul>

<p><code>GNE.nseq</code> solves the GNE problem via a non smooth reformulation of the KKT system. 
<code>bench.GNE.nseq</code> carries out a benchmark of the computation methods (Newton and Broyden 
direction with all possible global schemes) for a given initial point.
<code>bench.GNE.nseq.LM</code> carries out a benchmark of the Levenberg-Marquardt computation method.
</p>
<p>This approach consists in solving the extended Karush-Kuhn-Tucker 
(KKT) system denoted by <code class="reqn">\Phi(z)=0</code>, where <code class="reqn">z</code> is formed by the players strategy 
<code class="reqn">x</code> and the Lagrange multiplier <code class="reqn">\lambda</code>.
The root problem <code class="reqn">\Phi(z)=0</code> is solved by an iterative scheme <code class="reqn">z_{n+1} = z_n + d_n</code>,
where the direction <code class="reqn">d_n</code> is computed in three different ways. Let <code class="reqn">J(x)=Jac\Phi(x)</code>.
</p>

<dl>
<dt>(a) Newton:</dt><dd><p>The direction solves the system <code class="reqn">J(z_n) d = - \Phi(z_n)
		</code>, 
generally called the Newton equation.</p>
</dd>
<dt>(b) Broyden:</dt><dd><p>It is a quasi-Newton method aiming to solve an approximate version
of the Newton equation <code class="reqn">d = -\Phi(z_n) W_n</code> where <code class="reqn">W_n</code> is computed
by an iterative scheme. In the current implementation, <code class="reqn">W_n</code> is updated
by the Broyden method. </p>
</dd>
<dt>(c) Levenberg-Marquardt:</dt><dd><p>The direction solves the system 
</p>
<p style="text-align: center;"><code class="reqn"> \left[ J(z_n)^T J(z_n) + \lambda_n^\delta I \right] d = - J(z_n)^T\Phi(x_n)
			</code>
</p>

<p>where <code class="reqn">I</code> denotes the identity matrix, <code class="reqn">\delta</code> is a parameter in [1,2] 
and <code class="reqn">\lambda_n = ||\Phi(z_n)|| </code> if <code>LM.param="merit"</code>,
<code class="reqn">||J(z_n)^T \Phi(z_n)|| </code> if <code>LM.param="jacmerit"</code>,
the minimum of both preceding quantities if <code>LM.param="min"</code>, or an adatpive
parameter according to Fan(2003) if <code>LM.param="adaptive"</code>.
</p>
</dd>
</dl>

<p>In addition to the computation method, a globalization scheme can be choosed using the <code>global</code>
argument, via the <code>...</code> argument. Available schemes are 
</p>

<dl>
<dt>(1) Line search:</dt><dd><p> if <code>global</code> is set to <code>"qline"</code> or <code>"gline"</code>, a line search
is used with the merit function being half of the L2 norm of <code class="reqn">Phi</code>, respectively with a
quadratic or a geometric implementation.</p>
</dd>
<dt>(2) Trust region:</dt><dd><p> if <code>global</code> is set to <code>"dbldog"</code> or <code>"pwldog"</code>, a trust
region is used respectively with a double dogleg or a Powell (simple) dogleg implementation.
This global scheme is not available for the Levenberg-Marquardt direction.</p>
</dd>
<dt>(3) None:</dt><dd><p> if  <code>global</code> is set to <code>"none"</code>, no globalization is done. </p>
</dd>
</dl>
	
<p>The default value of <code>global</code> is <code>"gline"</code>. Note that in the special case of 
the Levenberg-Marquardt direction with adaptive parameter, the global scheme must be <code>"none"</code>.
</p>
<p>In the GNEP context, details on the methods can be found in Facchinei, Fischer &amp; Piccialli (2009), <code>"Newton"</code>
corresponds to method 1 and <code>"Levenberg-Marquardt"</code> to method 3. In a general nonlinear
equation framework, see Dennis &amp; Moree (1977), Dennis &amp; Schnabel (1996) or Nocedal &amp; Wright (2006), 
</p>
<p>The implementation relies heavily on the 
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> function of the package of the same name. So full details on the control parameters are
to be found in the help page of this function. We briefly recall here the main parameters.
The <code>control</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>xtol</code></dt><dd><p>The relative steplength tolerance.
When the relative  steplength of all scaled x values is smaller than this value
convergence is declared. The default value is <code class="reqn">10^{-8}</code>.
</p>
</dd>
<dt><code>ftol</code></dt><dd><p>The function value tolerance.
Convergence is declared when the largest absolute function value is smaller than <code>ftol</code>.
The	default value is <code class="reqn">10^{-8}</code>.
</p>
</dd>
<dt><code>delta</code></dt><dd><p>A numeric <code>delta</code> in [1, 2], default to 2, for
the Levenberg-Marquardt method only.
</p>
</dd>
<dt><code>LM.param</code></dt><dd><p>A character string, default to <code>"merit"</code>, for
the Levenberg-Marquardt method only.
</p>
</dd>
<dt><code>maxit</code></dt><dd><p>The maximum number of major iterations. The default value is 150 if a 
global strategy has been specified.</p>
</dd>
<dt><code>trace</code></dt><dd><p>Non-negative integer. A value of 1 will give a detailed report of the
progress of the iteration, default 0.</p>
</dd>
</dl>

<p><code>...</code> are further arguments to be passed to the optimization routine, 
that is <code>global</code>, <code>xscalm</code>, <code>silent</code>. See above for the globalization scheme. 
The <code>xscalm</code> is a scaling parameter to used, either <code>"fixed"</code> (default)
or <code>"auto"</code>, for which scaling factors are calculated from the euclidean norms of the 
columns of the jacobian matrix. See <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> for details.
The <code>silent</code> argument is a logical to report or not the optimization process, default
to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p><code>GNE.nseq</code> returns a list with components:
</p>

<dl>
<dt><code>par</code></dt><dd><p>The best set of parameters found.</p>
</dd>
<dt><code>value</code></dt><dd><p>The value of the merit function.</p>
</dd>
<dt><code>counts</code></dt><dd><p>A two-element integer vector giving the number of calls to 
<code>phi</code> and <code>jacphi</code> respectively.</p>
</dd>			
<dt><code>iter</code></dt><dd><p>The outer iteration number.</p>
</dd>
<dt><code>code</code></dt><dd>
<p>The values returned are
</p>

<dl>
<dt><code>1</code></dt><dd><p>Function criterion is near zero.
Convergence of function values has been achieved.</p>
</dd>
<dt><code>2</code></dt><dd><p>x-values within tolerance. This means that the relative distance between two
consecutive x-values is smaller than <code>xtol</code>.</p>
</dd>
<dt><code>3</code></dt><dd><p>No better point found.
This means that the algorithm has stalled and cannot find an acceptable new point.
This may or may not indicate acceptably small function values.</p>
</dd>
<dt><code>4</code></dt><dd><p>Iteration limit <code>maxit</code> exceeded.</p>
</dd>
<dt><code>5</code></dt><dd><p>Jacobian is too ill-conditioned.</p>
</dd>
<dt><code>6</code></dt><dd><p>Jacobian is singular.</p>
</dd>
<dt><code>100</code></dt><dd><p>an error in the execution.</p>
</dd>
</dl>

</dd>
<dt><code>message</code></dt><dd><p>a string describing the termination code.</p>
</dd>	
<dt><code>fvec</code></dt><dd><p>a vector with function values.</p>
</dd>
</dl>

<p><code>bench.GNE.nseq</code> returns a list with components:
</p>

<dl>
<dt><code>compres</code></dt><dd><p>a data.frame summarizing the different computations.</p>
</dd>
<dt><code>reslist</code></dt><dd><p>a list with the different results from <code>GNE.nseq</code>.</p>
</dd>
</dl>
 	


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>J.E. Dennis and J.J. Moree (1977), 
<em>Quasi-Newton methods, Motivation and Theory</em>,
SIAM review.
</p>
<p>J.E. Dennis and R.B. Schnabel (1996), 
<em>Numerical methods for unconstrained optimization and nonlinear equations</em>,
SIAM.
</p>
<p>F. Facchinei, A. Fischer and V. Piccialli (2009), 
<em>Generalized Nash equilibrium problems and Newton methods</em>,
Math. Program.
</p>
<p>J.-Y. Fan (2003),
<em>A modified Levenberg-Marquardt algorithm for singular 
system of nonlinear equations</em>,
Journal of Computational Mathematics.
</p>
<p>B. Hasselman (2011), 
<em>nleqslv: Solve systems of non linear equations</em>,
R package.
</p>
<p>A. von Heusinger and C. Kanzow (2009),
<em>Optimization reformulations of the generalized Nash equilibrium problem 
using Nikaido-Isoda-type functions</em>,
Comput Optim Appl .
</p>
<p>J. Nocedal and S.J. Wright (2006), 
<em>Numerical Optimization</em>, 
Springer Science+Business Media
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+GNE.fpeq">GNE.fpeq</a></code>, <code><a href="#topic+GNE.ceq">GNE.ceq</a></code> and <code><a href="#topic+GNE.minpb">GNE.minpb</a></code> 
for other approaches; <code><a href="#topic+funSSR">funSSR</a></code> and
<code><a href="#topic+jacSSR">jacSSR</a></code> for template functions of <code class="reqn">\Phi</code> and <code class="reqn">Jac\Phi</code> and
<code><a href="#topic+complementarity">complementarity</a></code> for complementarity functions.
</p>
<p>See also <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> for some optimization details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#-------------------------------------------------------------------------------
# (1) Example 5 of von Facchinei et al. (2007)
#-------------------------------------------------------------------------------

dimx &lt;- c(1, 1)
#Gr_x_j O_i(x)
grobj &lt;- function(x, i, j)
{
	if(i == 1)
		res &lt;- c(2*(x[1]-1), 0)
	if(i == 2)
		res &lt;- c(0, 2*(x[2]-1/2))
	res[j]	
}
#Gr_x_k Gr_x_j O_i(x)
heobj &lt;- function(x, i, j, k)
	2 * (i == j &amp;&amp; j == k)

dimlam &lt;- c(1, 1)
#constraint function g_i(x)
g &lt;- function(x, i)
	sum(x[1:2]) - 1
#Gr_x_j g_i(x)
grg &lt;- function(x, i, j)
	1
#Gr_x_k Gr_x_j g_i(x)
heg &lt;- function(x, i, j, k)
	0



#true value is (3/4, 1/4, 1/2, 1/2)

z0 &lt;- rep(0, sum(dimx)+sum(dimlam))

funSSR(z0, dimx, dimlam, grobj=grobj, constr=g, grconstr=grg, compl=phiFB, echo=FALSE)

	
jacSSR(z0, dimx, dimlam, heobj=heobj, constr=g, grconstr=grg, 
	heconstr=heg, gcompla=GrAphiFB, gcomplb=GrBphiFB)


GNE.nseq(z0, dimx, dimlam, grobj=grobj, NULL, heobj=heobj, NULL, 
	constr=g, NULL, grconstr=grg, NULL, heconstr=heg, NULL, 
	compl=phiFB, gcompla=GrAphiFB, gcomplb=GrBphiFB, method="Newton", 
	control=list(trace=1))

GNE.nseq(z0, dimx, dimlam, grobj=grobj, NULL, heobj=heobj, NULL, 
	constr=g, NULL, grconstr=grg, NULL, heconstr=heg, NULL, 
	compl=phiFB, gcompla=GrAphiFB, gcomplb=GrBphiFB, method="Broyden", 
	control=list(trace=1))



#-------------------------------------------------------------------------------
# (2) Duopoly game of Krawczyk and Stanislav Uryasev (2000)
#-------------------------------------------------------------------------------


#constants
myarg &lt;- list(d= 20, lambda= 4, rho= 1)

dimx &lt;- c(1, 1)
#Gr_x_j O_i(x)
grobj &lt;- function(x, i, j, arg)
{
	res &lt;- -arg$rho * x[i]
	if(i == j)
		res &lt;- res + arg$d - arg$lambda - arg$rho*(x[1]+x[2])
	-res
}
#Gr_x_k Gr_x_j O_i(x)
heobj &lt;- function(x, i, j, k, arg)
	arg$rho * (i == j) + arg$rho * (j == k)	


dimlam &lt;- c(1, 1)
#constraint function g_i(x)
g &lt;- function(x, i)
	-x[i]
#Gr_x_j g_i(x)
grg &lt;- function(x, i, j)
	-1*(i == j)
#Gr_x_k Gr_x_j g_i(x)
heg &lt;- function(x, i, j, k)
	0

#true value is (16/3, 16/3, 0, 0) 

z0 &lt;- rep(0, sum(dimx)+sum(dimlam))

funSSR(z0, dimx, dimlam, grobj=grobj, myarg, constr=g, grconstr=grg, compl=phiFB, echo=FALSE)

jacSSR(z0, dimx, dimlam, heobj=heobj, myarg, constr=g, grconstr=grg, 
	heconstr=heg, gcompla=GrAphiFB, gcomplb=GrBphiFB)


GNE.nseq(z0, dimx, dimlam, grobj=grobj, myarg, heobj=heobj, myarg, 
	constr=g, NULL, grconstr=grg, NULL, heconstr=heg, NULL, 
	compl=phiFB, gcompla=GrAphiFB, gcomplb=GrBphiFB, method="Newton", 
	control=list(trace=1))

GNE.nseq(z0, dimx, dimlam, grobj=grobj, myarg, heobj=heobj, myarg, 
	constr=g, NULL, grconstr=grg, NULL, heconstr=heg, NULL, 
	compl=phiFB, gcompla=GrAphiFB, gcomplb=GrBphiFB, method="Broyden", 
	control=list(trace=1))


	

</code></pre>

<hr>
<h2 id='NIR'>Nikaido Isoda Reformulation</h2><span id='topic+gapNIR'></span><span id='topic+gradxgapNIR'></span><span id='topic+gradygapNIR'></span><span id='topic+fpNIR'></span>

<h3>Description</h3>

<p>functions of the Nikaido Isoda Reformulation of the GNEP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
gapNIR(x, y, dimx, obj, argobj, param=list(), echo=FALSE)
gradxgapNIR(x, y, dimx, grobj, arggrobj, param=list(), echo=FALSE)
gradygapNIR(x, y, dimx, grobj, arggrobj, param=list(), echo=FALSE)
fpNIR(x, dimx, obj, argobj, joint, argjoint,  
	grobj, arggrobj, jacjoint, argjacjoint, param=list(), 
	echo=FALSE, control=list(), yinit=NULL, optim.method="default")


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NIR_+3A_x">x</code>, <code id="NIR_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NIR_+3A_dimx">dimx</code></td>
<td>
<p>a vector of dimension for <code>x</code>.</p>
</td></tr>
<tr><td><code id="NIR_+3A_obj">obj</code></td>
<td>
<p>objective function (to be minimized), see details.</p>
</td></tr>
<tr><td><code id="NIR_+3A_argobj">argobj</code></td>
<td>
<p>a list of additional arguments.</p>
</td></tr>
<tr><td><code id="NIR_+3A_grobj">grobj</code></td>
<td>
<p>gradient of the objective function, see details.</p>
</td></tr>
<tr><td><code id="NIR_+3A_arggrobj">arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td></tr>
<tr><td><code id="NIR_+3A_joint">joint</code></td>
<td>
<p>joint function, see details.</p>
</td></tr>
<tr><td><code id="NIR_+3A_argjoint">argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td></tr>
<tr><td><code id="NIR_+3A_jacjoint">jacjoint</code></td>
<td>
<p>gradient of the joint function, see details.</p>
</td></tr>
<tr><td><code id="NIR_+3A_argjacjoint">argjacjoint</code></td>
<td>
<p>a list of additional arguments of the joint Jacobian.</p>
</td></tr>
<tr><td><code id="NIR_+3A_param">param</code></td>
<td>
<p> a list of parameters.</p>
</td></tr>
<tr><td><code id="NIR_+3A_control">control</code></td>
<td>
<p>a list with control parameters for the fixed point algorithm.</p>
</td></tr>
<tr><td><code id="NIR_+3A_yinit">yinit</code></td>
<td>
<p>initial point when computing the fixed-point function.</p>
</td></tr>
<tr><td><code id="NIR_+3A_optim.method">optim.method</code></td>
<td>
<p>optimization method when computing the fixed-point function.</p>
</td></tr>
<tr><td><code id="NIR_+3A_echo">echo</code></td>
<td>
<p>a logical to show some traces.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p><code>gapNIR</code> computes the Nikaido Isoda function of the GNEP, while <code>gradxgapNIR</code> 
and <code>gradygapNIR</code> give its gradient with respect to <code class="reqn">x</code> and <code class="reqn">y</code>.
<code>fpNIR</code> computes the fixed-point function.
</p>


<h3>Value</h3>

<p>A vector for <code>funSSR</code> or a matrix for <code>jacSSR</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>A. von Heusinger &amp; J. Kanzow (2009),
<em>Optimization reformulations of the generalized Nash equilibrium problem using Nikaido-Isoda-type functions</em>,
Comput Optim Appl .
</p>
<p>F. Facchinei, A. Fischer and V. Piccialli (2009), 
<em>Generalized Nash equilibrium problems and Newton methods</em>,
Math. Program.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GNE.fpeq">GNE.fpeq</a></code>.
</p>

<hr>
<h2 id='potential.reduction'>Potential reduction algorithm utility functions</h2><span id='topic+potential.ce'></span><span id='topic+gradpotential.ce'></span><span id='topic+psi.ce'></span><span id='topic+gradpsi.ce'></span>

<h3>Description</h3>

<p>Functions for the potential reduction algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
potential.ce(u, n, zeta)

gradpotential.ce(u, n, zeta)	

psi.ce(z, dimx, dimlam, Hfinal, argfun, zeta)

gradpsi.ce(z, dimx, dimlam, Hfinal, jacHfinal, argfun, argjac, zeta)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="potential.reduction_+3A_u">u</code></td>
<td>
<p>a numeric vector : <code class="reqn">u=(u_1, u_2)</code> 
where <code class="reqn">u_1</code> is of size <code>n</code>.</p>
</td></tr>		  
<tr><td><code id="potential.reduction_+3A_n">n</code></td>
<td>
<p>a numeric for the size of <code class="reqn">u_1</code>.</p>
</td></tr>
<tr><td><code id="potential.reduction_+3A_zeta">zeta</code></td>
<td>
<p>a positive parameter.</p>
</td></tr>
<tr><td><code id="potential.reduction_+3A_z">z</code></td>
<td>
<p>a numeric vector : <code class="reqn">z=(x, lambda, w)</code> 
where <code>dimx</code> is the size of components of <code class="reqn">x</code>
and <code>dimlam</code> is the size of components of <code class="reqn">lambda</code> and <code class="reqn">w</code>.</p>
</td></tr>
<tr><td><code id="potential.reduction_+3A_dimx">dimx</code></td>
<td>
<p>a numeric vector with the size of each components of <code class="reqn">x</code>.</p>
</td></tr>	
<tr><td><code id="potential.reduction_+3A_dimlam">dimlam</code></td>
<td>
<p>a numeric vector with the size of each components of <code class="reqn">lambda</code>.
We must have <code>length(dimx) == length(dimlam)</code>.</p>
</td></tr>
<tr><td><code id="potential.reduction_+3A_hfinal">Hfinal</code></td>
<td>
<p>the root function.</p>
</td></tr>
<tr><td><code id="potential.reduction_+3A_argfun">argfun</code></td>
<td>
<p>a list of additionnals arguments for <code>Hfinal</code>.</p>
</td></tr>
<tr><td><code id="potential.reduction_+3A_jachfinal">jacHfinal</code></td>
<td>
<p>the Jacobian of the root function.</p>
</td></tr>
<tr><td><code id="potential.reduction_+3A_argjac">argjac</code></td>
<td>
<p>a list of additionnals arguments for <code>jacHfinal</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>potential.ce</code> is the potential function for the GNEP, and <code>gradpotential.ce</code> its gradient.
<code>psi.ce</code> is the application of the potential function for <code>Hfinal</code>, and <code>gradpsi.ce</code>
its gradient.
</p>


<h3>Value</h3>

<p>A numeric or a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>S. Bellavia, M. Macconi, B. Morini (2003),
<em>An affine scaling trust-region approach to bound-constrained nonlinear systems</em>,
Applied Numerical Mathematics 44, 257-280
</p>
<p>A. Dreves, F. Facchinei, C. Kanzow and S. Sagratella (2011), 
<em>On the solutions of the KKT conditions of generalized Nash equilibrium problems</em>, 
SIAM Journal on Optimization 21(3), 1082-1108.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GNE.ceq">GNE.ceq</a></code>.
</p>

<hr>
<h2 id='projector'>Projection of a point on a set</h2><span id='topic+projector'></span><span id='topic+Projector'></span>

<h3>Description</h3>

<p>Projection of a point <code>z</code> on the set defined by the constraints <code>g(x) &lt;= 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projector(z, g, jacg, bounds=c(0, 10), echo=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projector_+3A_z">z</code></td>
<td>
<p>The point to project.</p>
</td></tr>
<tr><td><code id="projector_+3A_g">g</code></td>
<td>
<p>The constraint function.</p>
</td></tr>
<tr><td><code id="projector_+3A_jacg">jacg</code></td>
<td>
<p>The jacobian of the constraint function.</p>
</td></tr>
<tr><td><code id="projector_+3A_bounds">bounds</code></td>
<td>
<p>bounds for the randomized initial iterate.</p>
</td></tr>
<tr><td><code id="projector_+3A_echo">echo</code></td>
<td>
<p>a logical to plot traces.</p>
</td></tr>
<tr><td><code id="projector_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>g</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Find a point <code>x</code> in the set <code class="reqn">K</code> which minimizes the Euclidean distance <code class="reqn">||z - x||^2</code>,
where the set <code class="reqn">K</code> is <code class="reqn">x, g(x) &lt;= 0</code>. The Optimization is carried out by the <code>constrOptim.nl</code>
function of the package alabama.
</p>


<h3>Value</h3>

<p>A vector <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GNE">GNE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. the rectangle set
#

g &lt;- function(x)
	c(x - 3, 1 - x)

jacg &lt;- function(x)
	rbind(
	diag( rep(1, length(x)) ),
	diag( rep(-1, length(x)) )
	)

z &lt;- runif(2, 3, 4)

#computation
projz &lt;- projector(z, g, jacg)

#plot
plot(c(1, 3), c(1, 1), xlim=c(0, 4), ylim=c(0,4), type="l", col="blue")
lines(c(3, 3), c(1, 3), col="blue")
lines(c(3, 1), c(3, 3), col="blue")
lines(c(1, 1), c(3, 1), col="blue")

points(z[1], z[2], col="red")
points(projz[1], projz[2], col="red", pch="+")

z &lt;- runif(2) + c(1, 0)
projz &lt;- projector(z, g, jacg)

points(z[1], z[2], col="green")
points(projz[1], projz[2], col="green", pch="+")



# 2. the circle set
#

g &lt;- function(x) sum((x-2)^2)-1
jacg &lt;- function(x) as.matrix( 2*(x-2) )

z &lt;- runif(2) + c(1, 0)

#computation
projz &lt;- projector(z, g, jacg)

#plot
plot(c(1, 3), c(1, 1), xlim=c(0, 4), ylim=c(0,4), type="n", col="blue")
symbols(2, 2, circles=1, fg="blue", add=TRUE, inches=FALSE)

points(z[1], z[2], col="red")
points(projz[1], projz[2], col="red", pch="+")

z &lt;- c(runif(1, 3, 4), runif(1, 1, 2))
projz &lt;- projector(z, g, jacg)

points(z[1], z[2], col="green")
points(projz[1], projz[2], col="green", pch="+")


</code></pre>

<hr>
<h2 id='rejection'>Rejection method for random generation.</h2><span id='topic+rejection'></span>

<h3>Description</h3>

<p>Generate random variate satisfying the constraint function by the Rejection algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rejection(constr, nvars, LB=0, UB=1, ..., echo=FALSE, 
	method=c("unif","norm", "normcap"), control=list())

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rejection_+3A_constr">constr</code></td>
<td>
<p>Constraint function</p>
</td></tr>
<tr><td><code id="rejection_+3A_nvars">nvars</code></td>
<td>
<p>Number of variables</p>
</td></tr>
<tr><td><code id="rejection_+3A_lb">LB</code></td>
<td>
<p>Lower bound</p>
</td></tr>
<tr><td><code id="rejection_+3A_ub">UB</code></td>
<td>
<p>Upper bound</p>
</td></tr>
<tr><td><code id="rejection_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>constr</code> function.</p>
</td></tr>
<tr><td><code id="rejection_+3A_echo">echo</code></td>
<td>
<p>a logical to plot traces.</p>
</td></tr>
<tr><td><code id="rejection_+3A_method">method</code></td>
<td>
<p>the distribution to draw random variates, either <code>"unif"</code>,
<code>"norm"</code>, <code>"normcap"</code>.</p>
</td></tr>
<tr><td><code id="rejection_+3A_control">control</code></td>
<td>
<p>a named list containing the mean and the standard deviation
of the normal distribution used if <code>method!="unif"</code>.</p>
</td></tr>	
</table>


<h3>Details</h3>

<p>Draw random variates <code>x</code> until all the components of <code>constr(x)</code> are negative. The distribution
to draw random variates can be the uniform distribution on the hypercube defined by <code>LB</code> and <code>UB</code>,
the normal distribution centered in <code>(LB + UB)/2</code> and standard deviation <code>(UB - LB) / (4*1.9600)</code> 
and the capped normal distribution (intended for debug use).
</p>


<h3>Value</h3>

<p>A vector <code>x</code> which verifies the constraints  <code>constr(x) &lt;= 0</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GNE">GNE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(x) x[1]^2 + x[2]^2 - 1

rejection(f, 2, -3, 3, method="unif")

rejection(f, 2, -3, 3, method="norm")

</code></pre>

<hr>
<h2 id='SSR'>SemiSmooth Reformulation</h2><span id='topic+SSR'></span><span id='topic+funSSR'></span><span id='topic+jacSSR'></span>

<h3>Description</h3>

<p>functions of the SemiSmooth Reformulation of the GNEP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funSSR(z, dimx, dimlam, grobj, arggrobj, constr, argconstr,  grconstr, arggrconstr, 
	compl, argcompl, dimmu, joint, argjoint, grjoint, arggrjoint, echo=FALSE)
jacSSR(z, dimx, dimlam, heobj, argheobj, constr, argconstr,  grconstr, arggrconstr, 
	heconstr, argheconstr, gcompla, gcomplb, argcompl, dimmu, joint, argjoint,
	grjoint, arggrjoint, hejoint, arghejoint, echo=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSR_+3A_z">z</code></td>
<td>
<p>a numeric vector <code>z</code> containing <code class="reqn">(x, lambda, mu)</code> values.</p>
</td></tr>
<tr><td><code id="SSR_+3A_dimx">dimx</code></td>
<td>
<p>a vector of dimension for <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="SSR_+3A_dimlam">dimlam</code></td>
<td>
<p>a vector of dimension for <code class="reqn">lambda</code>.</p>
</td></tr>
<tr><td><code id="SSR_+3A_grobj">grobj</code></td>
<td>
<p>gradient of the objective function, see details.</p>
</td></tr>
<tr><td><code id="SSR_+3A_arggrobj">arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td></tr>
<tr><td><code id="SSR_+3A_constr">constr</code></td>
<td>
<p>constraint function, see details.</p>
</td></tr>
<tr><td><code id="SSR_+3A_argconstr">argconstr</code></td>
<td>
<p>a list of additional arguments of the constraint function.</p>
</td></tr>
<tr><td><code id="SSR_+3A_grconstr">grconstr</code></td>
<td>
<p>gradient of the constraint function, see details.</p>
</td></tr>
<tr><td><code id="SSR_+3A_arggrconstr">arggrconstr</code></td>
<td>
<p>a list of additional arguments of the constraint gradient.</p>
</td></tr>
<tr><td><code id="SSR_+3A_compl">compl</code></td>
<td>
<p>the complementarity function with (at least) two arguments: <code>compl(a,b)</code>.</p>
</td></tr>
<tr><td><code id="SSR_+3A_argcompl">argcompl</code></td>
<td>
<p>list of possible additional arguments for <code>compl</code>.</p>
</td></tr>
<tr><td><code id="SSR_+3A_dimmu">dimmu</code></td>
<td>
<p>a vector of dimension for <code class="reqn">mu</code>.</p>
</td></tr>
<tr><td><code id="SSR_+3A_joint">joint</code></td>
<td>
<p>joint function, see details.</p>
</td></tr>
<tr><td><code id="SSR_+3A_argjoint">argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td></tr>
<tr><td><code id="SSR_+3A_grjoint">grjoint</code></td>
<td>
<p>gradient of the joint function, see details.</p>
</td></tr>
<tr><td><code id="SSR_+3A_arggrjoint">arggrjoint</code></td>
<td>
<p>a list of additional arguments of the joint gradient.</p>
</td></tr>
<tr><td><code id="SSR_+3A_heobj">heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td></tr>
<tr><td><code id="SSR_+3A_argheobj">argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td></tr>	
<tr><td><code id="SSR_+3A_heconstr">heconstr</code></td>
<td>
<p>Hessian of the constraint function, see details.</p>
</td></tr>
<tr><td><code id="SSR_+3A_argheconstr">argheconstr</code></td>
<td>
<p>a list of additional arguments of the constraint Hessian.</p>
</td></tr>
<tr><td><code id="SSR_+3A_gcompla">gcompla</code></td>
<td>
<p>derivative of the complementarity function w.r.t. the first argument.</p>
</td></tr>
<tr><td><code id="SSR_+3A_gcomplb">gcomplb</code></td>
<td>
<p>derivative of the complementarity function w.r.t. the second argument.</p>
</td></tr>
<tr><td><code id="SSR_+3A_hejoint">hejoint</code></td>
<td>
<p>Hessian of the joint function, see details.</p>
</td></tr>
<tr><td><code id="SSR_+3A_arghejoint">arghejoint</code></td>
<td>
<p>a list of additional arguments of the joint Hessian.</p>
</td></tr>
<tr><td><code id="SSR_+3A_echo">echo</code></td>
<td>
<p>a logical to show some traces.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>Compute the SemiSmooth Reformulation of the GNEP: the Generalized Nash equilibrium problem is defined
by objective functions <code class="reqn">Obj</code> with player variables <code class="reqn">x</code> defined in <code>dimx</code> and 
may have player-dependent constraint functions <code class="reqn">g</code> of dimension <code>dimlam</code> 
and/or a common shared joint function <code class="reqn">h</code> of dimension <code>dimmu</code>,
where the Lagrange multiplier are <code class="reqn">lambda</code> and <code class="reqn">mu</code>, respectively,
see F. Facchinei et al.(2009) where there is no joint function.
</p>

<dl>
<dt><b>Arguments of the Phi function</b></dt><dd>	
<p>The arguments which are functions must respect the following features
</p>

<dl>
<dt><code>grobj</code></dt><dd>
<p>The gradient <code class="reqn">Grad Obj</code> of an objective function <code class="reqn">Obj</code> (to be minimized) must have 3 arguments for <code class="reqn">Grad Obj(z, playnum, ideriv)</code>: vector <code>z</code>, player number, derivative index
, and optionnally additional arguments in <code>arggrobj</code>.
</p>
</dd>
<dt><code>constr</code></dt><dd>
<p>The constraint function <code class="reqn">g</code> must have 2 arguments: vector <code>z</code>, player number,
such that <code class="reqn">g(z, playnum) &lt;= 0</code>. Optionnally, <code class="reqn">g</code> may have additional arguments in <code>argconstr</code>.
</p>
</dd>
<dt><code>grconstr</code></dt><dd>
<p>The gradient of the constraint function <code class="reqn">g</code>  must have 3 arguments: vector <code>z</code>, player number, derivative index,
and optionnally additional arguments in <code>arggrconstr</code>.
</p>
</dd>
<dt><code>compl</code></dt><dd><p>It must have two arguments and optionnally additional arguments in <code>argcompl</code>. 
A typical example is the minimum function.</p>
</dd>
<dt><code>joint</code></dt><dd>
<p>The constraint function <code class="reqn">h</code> must have 1 argument: vector <code>z</code>,
such that <code class="reqn">h(z) &lt;= 0</code>. Optionnally, <code class="reqn">h</code> may have additional arguments in <code>argjoint</code>.
</p>
</dd>
<dt><code>grjoint</code></dt><dd>
<p>The gradient of the constraint function <code class="reqn">h</code>  must have 2 arguments: vector <code>z</code>, derivative index,
and optionnally additional arguments in <code>arggrjoint</code>.
</p>
</dd>		
</dl>

</dd>
<dt><b>Arguments of the Jacobian of Phi</b></dt><dd>	
<p>The arguments which are functions must respect the following features
</p>

<dl>
<dt><code>heobj</code></dt><dd><p>It must have 4 arguments: vector <code>z</code>, player number, two derivative indexes and optionnally additional arguments in <code>argheobj</code>.</p>
</dd>
<dt><code>heconstr</code></dt><dd><p>It must have 4 arguments: vector <code>z</code>, player number, two derivative indexes and optionnally additional arguments in <code>argheconstr</code>.</p>
</dd>
<dt><code>gcompla</code>,<code>gcomplb</code></dt><dd><p>It must have two arguments and optionnally additional arguments in <code>argcompl</code>.</p>
</dd>
<dt><code>hejoint</code></dt><dd><p>It must have 3 arguments: vector <code>z</code>, two derivative indexes and optionnally additional arguments in <code>arghejoint</code>.</p>
</dd>
</dl>

</dd>
</dl>

<p>See the example	below.
</p>


<h3>Value</h3>

<p>A vector for <code>funSSR</code> or a matrix for <code>jacSSR</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>F. Facchinei, A. Fischer and V. Piccialli (2009), 
<em>Generalized Nash equilibrium problems and Newton methods</em>,
Math. Program.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GNE.nseq">GNE.nseq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) associated objective functions
#

dimx &lt;- c(2, 2, 3)

#Gr_x_j O_i(x)
grfullob &lt;- function(x, i, j)
{
	x &lt;- x[1:7]	
	if(i == 1)
	{
		grad &lt;- 3*(x - 1:7)^2
	}
	if(i == 2)
	{
		grad &lt;- 1:7*(x - 1:7)^(0:6)
	}
	if(i == 3)
	{
		s &lt;- x[5]^2 + x[6]^2 + x[7]^2 - 5	
		grad &lt;- c(1, 0, 1, 0, 4*x[5]*s, 4*x[6]*s, 4*x[7]*s)
			
	}
	grad[j]	
}


#Gr_x_k Gr_x_j O_i(x)
hefullob &lt;- function(x, i, j, k)
{
	x &lt;- x[1:7]
	if(i == 1)
	{
		he &lt;- diag( 6*(x - 1:7) )
	}
	if(i == 2)
	{
		he &lt;- diag( c(0, 2, 6, 12, 20, 30, 42)*(x - 1:7)^c(0, 0:5) )
	}
	if(i == 3)
	{
		s &lt;- x[5]^2 + x[6]^2 + x[7]^2	
		
		he &lt;- rbind(rep(0, 7), rep(0, 7), rep(0, 7), rep(0, 7),
			c(0, 0, 0, 0, 4*s+8*x[5]^2, 8*x[5]*x[6], 8*x[5]*x[7]),
			c(0, 0, 0, 0, 8*x[5]*x[6], 4*s+8*x[6]^2, 8*x[6]*x[7]),
			c(0, 0, 0, 0,  8*x[5]*x[7], 8*x[6]*x[7], 4*s+8*x[7]^2) )
	}
	he[j,k]	
}



# (2) constraint linked functions
#

dimlam &lt;- c(1, 2, 2)

#constraint function g_i(x)
g &lt;- function(x, i)
{
	x &lt;- x[1:7]
	if(i == 1)
		res &lt;- sum( x^(1:7) ) -7
	if(i == 2)
		res &lt;- c(sum(x) + prod(x) - 14, 20 - sum(x))
	if(i == 3)
		res &lt;- c(sum(x^2) + 1, 100 - sum(x))
	res
}


#Gr_x_j g_i(x)
grfullg &lt;- function(x, i, j)
{
	x &lt;- x[1:7]	
	if(i == 1)
	{
		grad &lt;- (1:7) * x ^ (0:6)
	}
	if(i == 2)
	{
		grad &lt;- 1 + sapply(1:7, function(i) prod(x[-i]))
		grad &lt;- cbind(grad, -1)
	}
	if(i == 3)
	{
		grad &lt;- cbind(2*x, -1)
	}


	if(i == 1)
		res &lt;- grad[j]	
	if(i != 1)
		res &lt;- grad[j,]	
	as.numeric(res)
}



#Gr_x_k Gr_x_j g_i(x)
hefullg &lt;- function(x, i, j, k)
{
	x &lt;- x[1:7]
	if(i == 1)
	{
		he1 &lt;- diag( c(0, 2, 6, 12, 20, 30, 42) * x ^ c(0, 0, 1:5) )
	}
	if(i == 2)
	{
		he1 &lt;- matrix(0, 7, 7)
		he1[1, -1] &lt;- sapply(2:7, function(i) prod(x[-c(1, i)]))
		he1[2, -2] &lt;- sapply(c(1, 3:7), function(i) prod(x[-c(2, i)]))
		he1[3, -3] &lt;- sapply(c(1:2, 4:7), function(i) prod(x[-c(3, i)]))
		he1[4, -4] &lt;- sapply(c(1:3, 5:7), function(i) prod(x[-c(4, i)]))
		he1[5, -5] &lt;- sapply(c(1:4, 6:7), function(i) prod(x[-c(5, i)]))
		he1[6, -6] &lt;- sapply(c(1:5, 7:7), function(i) prod(x[-c(6, i)]))
		he1[7, -7] &lt;- sapply(1:6, function(i) prod(x[-c(7, i)]))
						
						
		he2 &lt;- matrix(0, 7, 7)
		
	}
	if(i == 3)
	{
		he1 &lt;- diag(rep(2, 7))
		he2 &lt;- matrix(0, 7, 7)
	}
	if(i != 1)
		return( c(he1[j, k], he2[j, k])	)
	else				
		return( he1[j, k] )
}


# (3) compute Phi
#

z &lt;- rexp(sum(dimx) + sum(dimlam))

n &lt;- sum(dimx)
m &lt;- sum(dimlam)
x &lt;- z[1:n]
lam &lt;- z[(n+1):(n+m)]

resphi &lt;- funSSR(z, dimx, dimlam, grobj=grfullob, constr=g, grconstr=grfullg, compl=phiFB)


check &lt;- c(grfullob(x, 1, 1) + lam[1] * grfullg(x, 1, 1), 
	grfullob(x, 1, 2) + lam[1] * grfullg(x, 1, 2), 
	grfullob(x, 2, 3) + lam[2:3] %*% grfullg(x, 2, 3),
	grfullob(x, 2, 4) + lam[2:3] %*% grfullg(x, 2, 4), 	
	grfullob(x, 3, 5) + lam[4:5] %*% grfullg(x, 3, 5),
	grfullob(x, 3, 6) + lam[4:5] %*% grfullg(x, 3, 6),
	grfullob(x, 3, 7) + lam[4:5] %*% grfullg(x, 3, 7),
	phiFB( -g(x, 1), lam[1]), 
	phiFB( -g(x, 2)[1], lam[2]), 
	phiFB( -g(x, 2)[2], lam[3]), 
	phiFB( -g(x, 3)[1], lam[4]), 
	phiFB( -g(x, 3)[2], lam[5]))
	
	

#check
cat("\n\n________________________________________\n\n")

#part A
print(cbind(check, res=as.numeric(resphi))[1:n, ])
#part B
print(cbind(check, res=as.numeric(resphi))[(n+1):(n+m), ])
	
# (4) compute Jac Phi
#
	
resjacphi &lt;- jacSSR(z, dimx, dimlam, heobj=hefullob, constr=g, grconstr=grfullg, 
	heconstr=hefullg, gcompla=GrAphiFB, gcomplb=GrBphiFB)

	
#check
cat("\n\n________________________________________\n\n")


cat("\n\npart A\n\n")	


checkA &lt;- 
rbind(
c(hefullob(x, 1, 1, 1) + lam[1]*hefullg(x, 1, 1, 1), 
hefullob(x, 1, 1, 2) + lam[1]*hefullg(x, 1, 1, 2),
hefullob(x, 1, 1, 3) + lam[1]*hefullg(x, 1, 1, 3),
hefullob(x, 1, 1, 4) + lam[1]*hefullg(x, 1, 1, 4),
hefullob(x, 1, 1, 5) + lam[1]*hefullg(x, 1, 1, 5),
hefullob(x, 1, 1, 6) + lam[1]*hefullg(x, 1, 1, 6),
hefullob(x, 1, 1, 7) + lam[1]*hefullg(x, 1, 1, 7)
),
c(hefullob(x, 1, 2, 1) + lam[1]*hefullg(x, 1, 2, 1), 
hefullob(x, 1, 2, 2) + lam[1]*hefullg(x, 1, 2, 2),
hefullob(x, 1, 2, 3) + lam[1]*hefullg(x, 1, 2, 3),
hefullob(x, 1, 2, 4) + lam[1]*hefullg(x, 1, 2, 4),
hefullob(x, 1, 2, 5) + lam[1]*hefullg(x, 1, 2, 5),
hefullob(x, 1, 2, 6) + lam[1]*hefullg(x, 1, 2, 6),
hefullob(x, 1, 2, 7) + lam[1]*hefullg(x, 1, 2, 7)
),
c(hefullob(x, 2, 3, 1) + lam[2:3] %*% hefullg(x, 2, 3, 1), 
hefullob(x, 2, 3, 2) + lam[2:3] %*% hefullg(x, 2, 3, 2),
hefullob(x, 2, 3, 3) + lam[2:3] %*% hefullg(x, 2, 3, 3),
hefullob(x, 2, 3, 4) + lam[2:3] %*% hefullg(x, 2, 3, 4),
hefullob(x, 2, 3, 5) + lam[2:3] %*% hefullg(x, 2, 3, 5),
hefullob(x, 2, 3, 6) + lam[2:3] %*% hefullg(x, 2, 3, 6),
hefullob(x, 2, 3, 7) + lam[2:3] %*% hefullg(x, 2, 3, 7)
),
c(hefullob(x, 2, 4, 1) + lam[2:3] %*% hefullg(x, 2, 4, 1), 
hefullob(x, 2, 4, 2) + lam[2:3] %*% hefullg(x, 2, 4, 2), 
hefullob(x, 2, 4, 3) + lam[2:3] %*% hefullg(x, 2, 4, 3), 
hefullob(x, 2, 4, 4) + lam[2:3] %*% hefullg(x, 2, 4, 4), 
hefullob(x, 2, 4, 5) + lam[2:3] %*% hefullg(x, 2, 4, 5), 
hefullob(x, 2, 4, 6) + lam[2:3] %*% hefullg(x, 2, 4, 6), 
hefullob(x, 2, 4, 7) + lam[2:3] %*% hefullg(x, 2, 4, 7)
),
c(hefullob(x, 3, 5, 1) + lam[4:5] %*% hefullg(x, 3, 5, 1),  
hefullob(x, 3, 5, 2) + lam[4:5] %*% hefullg(x, 3, 5, 2),  
hefullob(x, 3, 5, 3) + lam[4:5] %*% hefullg(x, 3, 5, 3),  
hefullob(x, 3, 5, 4) + lam[4:5] %*% hefullg(x, 3, 5, 4),  
hefullob(x, 3, 5, 5) + lam[4:5] %*% hefullg(x, 3, 5, 5),  
hefullob(x, 3, 5, 6) + lam[4:5] %*% hefullg(x, 3, 5, 6),  
hefullob(x, 3, 5, 7) + lam[4:5] %*% hefullg(x, 3, 5, 7)
),
c(hefullob(x, 3, 6, 1) + lam[4:5] %*% hefullg(x, 3, 6, 1),   
hefullob(x, 3, 6, 2) + lam[4:5] %*% hefullg(x, 3, 6, 2),  
hefullob(x, 3, 6, 3) + lam[4:5] %*% hefullg(x, 3, 6, 3),  
hefullob(x, 3, 6, 4) + lam[4:5] %*% hefullg(x, 3, 6, 4),  
hefullob(x, 3, 6, 5) + lam[4:5] %*% hefullg(x, 3, 6, 5),  
hefullob(x, 3, 6, 6) + lam[4:5] %*% hefullg(x, 3, 6, 6),  
hefullob(x, 3, 6, 7) + lam[4:5] %*% hefullg(x, 3, 6, 7)
),
c(hefullob(x, 3, 7, 1) + lam[4:5] %*% hefullg(x, 3, 7, 1),   
hefullob(x, 3, 7, 2) + lam[4:5] %*% hefullg(x, 3, 7, 2),  
hefullob(x, 3, 7, 3) + lam[4:5] %*% hefullg(x, 3, 7, 3),  
hefullob(x, 3, 7, 4) + lam[4:5] %*% hefullg(x, 3, 7, 4),  
hefullob(x, 3, 7, 5) + lam[4:5] %*% hefullg(x, 3, 7, 5),  
hefullob(x, 3, 7, 6) + lam[4:5] %*% hefullg(x, 3, 7, 6),  
hefullob(x, 3, 7, 7) + lam[4:5] %*% hefullg(x, 3, 7, 7)
)
)


print(resjacphi[1:n, 1:n] - checkA)


cat("\n\n________________________________________\n\n")


cat("\n\npart B\n\n")	


checkB &lt;- 
rbind(
cbind(c(grfullg(x, 1, 1), grfullg(x, 1, 2)), c(0, 0), c(0, 0), c(0, 0), c(0, 0)),
cbind(c(0, 0), rbind(grfullg(x, 2, 3), grfullg(x, 2, 4)), c(0, 0), c(0, 0)),
cbind(c(0, 0, 0), c(0, 0, 0), c(0, 0, 0), 
 rbind(grfullg(x, 3, 5), grfullg(x, 3, 6), grfullg(x, 3, 7)))
)


print(resjacphi[1:n, (n+1):(n+m)] - checkB)	


cat("\n\n________________________________________\n\n")
cat("\n\npart C\n\n")	


gx &lt;- c(g(x,1), g(x,2), g(x,3))

checkC &lt;- 
- t(
cbind(
rbind(
grfullg(x, 1, 1) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 2) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 3) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 4) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 5) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 6) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 7) * GrAphiFB(-gx, lam)[1]
),
rbind(
grfullg(x, 2, 1) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 2) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 3) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 4) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 5) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 6) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 7) * GrAphiFB(-gx, lam)[2:3]
),
rbind(
grfullg(x, 3, 1) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 2) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 3) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 4) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 5) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 6) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 7) * GrAphiFB(-gx, lam)[4:5]
)
)
)



print(resjacphi[(n+1):(n+m), 1:n] - checkC)


cat("\n\n________________________________________\n\n")

cat("\n\npart D\n\n")	


checkD &lt;- diag(GrBphiFB(-gx, lam)) 

print(resjacphi[(n+1):(n+m), (n+1):(n+m)] - checkD)

</code></pre>

<hr>
<h2 id='stepfunc'>Step functions</h2><span id='topic+stepfunc'></span><span id='topic+purestep'></span><span id='topic+decrstep'></span><span id='topic+decrstep5'></span><span id='topic+decrstep10'></span><span id='topic+decrstep20'></span>

<h3>Description</h3>

<p>Step functions for relaxation methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purestep(k)
decrstep(k, param)
decrstep5(k)
decrstep10(k)
decrstep20(k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepfunc_+3A_k">k</code></td>
<td>
<p>iteration number.</p>
</td></tr>
<tr><td><code id="stepfunc_+3A_param">param</code></td>
<td>
<p>parameter for the decreasing step function after which the step decreases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>decrstep</code> function is a decreasing step serie such that <code>decrstep(k)</code> 
equals to <code class="reqn">1/2/(k - param)</code> when <code class="reqn">k&gt;param</code>, 1/2, otherwise. 
Functions <code>decrstep5, decrstep10, decrstep20</code> are just wrappers of
<code>decrstep</code>. 
</p>
<p>The <code>purestep</code> function implements a constant step serie equaled to 1.
</p>


<h3>Value</h3>

<p>A numeric.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GNE">GNE</a></code> and <code><a href="#topic+GNE.fpeq">GNE.fpeq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cbind(
purestep(1:20),
decrstep(1:20, 7),
decrstep5(1:20),
decrstep10(1:20),
decrstep20(1:20)
)

</code></pre>

<hr>
<h2 id='VIR'>Nikaido Isoda Reformulation</h2><span id='topic+gapVIR'></span><span id='topic+gradxgapVIR'></span><span id='topic+gradygapVIR'></span><span id='topic+fpVIR'></span>

<h3>Description</h3>

<p>functions of the Nikaido Isoda Reformulation of the GNEP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
gapVIR(x, y, dimx, grobj, arggrobj, param=list(), echo=FALSE)
gradxgapVIR(x, y, dimx, grobj, arggrobj, heobj, argheobj, param=list(), echo=FALSE)
gradygapVIR(x, y, dimx, grobj, arggrobj, param=list(), echo=FALSE)
fpVIR(x, dimx, obj, argobj, joint, argjoint,  
	grobj, arggrobj, jacjoint, argjacjoint, param=list(), 
	echo=FALSE, control=list(), yinit=NULL, optim.method="default")


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VIR_+3A_x">x</code>, <code id="VIR_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="VIR_+3A_dimx">dimx</code></td>
<td>
<p>a vector of dimension for <code>x</code>.</p>
</td></tr>
<tr><td><code id="VIR_+3A_obj">obj</code></td>
<td>
<p>objective function (to be minimized), see details.</p>
</td></tr>
<tr><td><code id="VIR_+3A_argobj">argobj</code></td>
<td>
<p>a list of additional arguments.</p>
</td></tr>
<tr><td><code id="VIR_+3A_grobj">grobj</code></td>
<td>
<p>gradient of the objective function, see details.</p>
</td></tr>
<tr><td><code id="VIR_+3A_arggrobj">arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td></tr>
<tr><td><code id="VIR_+3A_heobj">heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td></tr>
<tr><td><code id="VIR_+3A_argheobj">argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td></tr>
<tr><td><code id="VIR_+3A_joint">joint</code></td>
<td>
<p>joint function, see details.</p>
</td></tr>
<tr><td><code id="VIR_+3A_argjoint">argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td></tr>
<tr><td><code id="VIR_+3A_jacjoint">jacjoint</code></td>
<td>
<p>gradient of the joint function, see details.</p>
</td></tr>
<tr><td><code id="VIR_+3A_argjacjoint">argjacjoint</code></td>
<td>
<p>a list of additional arguments of the joint Jacobian.</p>
</td></tr>
<tr><td><code id="VIR_+3A_param">param</code></td>
<td>
<p> a list of parameters.</p>
</td></tr>
<tr><td><code id="VIR_+3A_control">control</code></td>
<td>
<p>a list with control parameters for the fixed point algorithm.</p>
</td></tr>
<tr><td><code id="VIR_+3A_yinit">yinit</code></td>
<td>
<p>initial point when computing the fixed-point function.</p>
</td></tr>
<tr><td><code id="VIR_+3A_optim.method">optim.method</code></td>
<td>
<p>optimization method when computing the fixed-point function.</p>
</td></tr>
<tr><td><code id="VIR_+3A_echo">echo</code></td>
<td>
<p>a logical to show some traces.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p><code>gapVIR</code> computes the Nikaido Isoda function of the GNEP, while <code>gradxgapVIR</code> 
and <code>gradygapVIR</code> give its gradient with respect to <code class="reqn">x</code> and <code class="reqn">y</code>.
<code>fpVIR</code> computes the fixed-point function.
</p>


<h3>Value</h3>

<p>A vector for <code>funSSR</code> or a matrix for <code>jacSSR</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>A. von Heusinger &amp; J. Kanzow (2009),
<em>Optimization reformulations of the generalized Nash equilibrium problem using Nikaido-Isoda-type functions</em>,
Comput Optim Appl .
</p>
<p>F. Facchinei, A. Fischer and V. Piccialli (2009), 
<em>Generalized Nash equilibrium problems and Newton methods</em>,
Math. Program.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+GNE.fpeq">GNE.fpeq</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
