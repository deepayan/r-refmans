<!DOCTYPE html><html><head><title>Help for package TDCor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TDCor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TDCor-package'>
<p>TDCor algorithm for gene regulatory network inference</p></a></li>
<li><a href='#CalculateDPI'><p>Generate the DPI database to be used by the TDCOR main function</p></a></li>
<li><a href='#CalculateTPI'><p>Generate the TPI database to be used by the TDCOR main function</p></a></li>
<li><a href='#clean.at'>
<p>Elimininate from a vector of gene codes the genes for which no data is available.</p></a></li>
<li><a href='#draw.profile'>
<p>Plot the expression profile of a <code>gene</code> in <code>dataset</code></p></a></li>
<li><a href='#estimate.delay'>
<p>Estimate the time shift between two gene profiles and make a plot</p></a></li>
<li><a href='#l_genes'>
<p>l_genes</p></a></li>
<li><a href='#l_names'>
<p>l_names</p></a></li>
<li><a href='#l_prior'>
<p>l_prior</p></a></li>
<li><a href='#LR_dataset'>
<p>Lateral root transcriptomic dataset</p></a></li>
<li><a href='#shortest.path'>
<p>Calculate the shortest path linking every pairs of nodes in the network</p></a></li>
<li><a href='#TDCOR'>
<p>The TDCOR main function</p></a></li>
<li><a href='#TF'>
<p>Table of 1834 Arabidopsis Transcription factors</p></a></li>
<li><a href='#times'>
<p>The <code>times</code> vector to use with the lateral root dataset</p></a></li>
<li><a href='#UpdateDPI'>
<p>Update or check the DPI database</p></a></li>
<li><a href='#UpdateTPI'>
<p>Update or check the TPI database</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gene Network Inference from Time-Series Transcriptomic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-10-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Lavenus</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mikael Lucas &lt;mikael.lucas@ird.fr&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2), deSolve</td>
</tr>
<tr>
<td>Description:</td>
<td>The Time-Delay Correlation algorithm (TDCor) reconstructs the topology of a gene regulatory network (GRN) from time-series transcriptomic data.  The algorithm is described in details in Lavenus et al., Plant Cell, 2015.  It was initially developed to infer the topology of the GRN controlling lateral root formation in Arabidopsis thaliana.  The time-series transcriptomic dataset which was used in this study is included in the package to illustrate how to use it.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-10-05 10:11:17.744 UTC; root</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-10-26 15:58:36</td>
</tr>
</table>
<hr>
<h2 id='TDCor-package'>
TDCor algorithm for gene regulatory network inference
</h2><span id='topic+TDCor-package'></span>

<h3>Description</h3>

<p>TDCor (Time-Delay Correlation) is an algorithm designed to infer the topology of a gene regulatory network (GRN) from time-series transcriptomic data. The algorithm is described in details in Lavenus <em>et al.</em>, Plant Cell, 2015. It was initially developped to infer the topology of the GRN controlling lateral root formation in <em>Arabidopsis thaliana</em>. The time-series transcriptomic dataset analysed in this study is included in the package.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> TDCor</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-10-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: GNU General Public License Version 2
</td>
</tr>

</table>

<p>The reconstruction of a gene network using the TDCor package involves six steps.<br />
</p>

<ol>
<li>
<p>Load the averaged non-log2 time series transcriptomic data into the R workspace.

</p>
</li>
<li>
<p>Define the vector <code><a href="#topic+times">times</a></code> containing the times (in hours) at which the samples were collected.

</p>
</li>
<li>
<p>Define the vector containing the gene codes of the genes you want to reconstruct the network with (e.g. see <code><a href="#topic+l_genes">l_genes</a></code>), as well as the associated gene names (e.g. see <code><a href="#topic+l_names">l_names</a></code>) and the associated prior (e.g. see <code><a href="#topic+l_prior">l_prior</a></code>).

</p>
</li>
<li>
<p>Build or update the TPI database using the <code><a href="#topic+CalculateTPI">CalculateTPI</a></code> or <code><a href="#topic+UpdateTPI">UpdateTPI</a></code> functions.

</p>
</li>
<li>
<p>Build or update the DPI database using the <code><a href="#topic+CalculateDPI">CalculateDPI</a></code> or <code><a href="#topic+UpdateDPI">UpdateDPI</a></code> functions.

</p>
</li>
<li>
<p>Reconstruct the network using the <code><a href="#topic+TDCOR">TDCOR</a></code> main function.

</p>
</li></ol>

<p>See examples below.<br />
</p>
<p>Besides the functions of the TDCor algorithm, the package also contains the lateral root transcriptomic dataset (<code><a href="#topic+LR_dataset">LR_dataset</a></code>), the <code>times</code> vector to use with this dataset (<code><a href="#topic+times">times</a></code>), the vector of AGI gene codes used to reconstruct the network shown in the original paper (<code><a href="#topic+l_genes">l_genes</a></code>), the vector of the gene names (<code><a href="#topic+l_names">l_names</a></code>) and the prior (<code><a href="#topic+l_prior">l_prior</a></code>). The associated TPI and DPI databases (<code>TPI10</code> and <code>DPI15</code>) which were used to build the network shown in the original paper are not included. Hence to reconstruct the lateral root network, these first need to be generated. A database of about 1800 <em>Arabidopsis</em> transcription factors is also included (<code><a href="#topic+TF">TF</a></code>).
</p>
<p>Three side functions, <code><a href="#topic+estimate.delay">estimate.delay</a></code>, <code><a href="#topic+shortest.path">shortest.path</a></code> and <code><a href="#topic+draw.profile">draw.profile</a></code> are also available to the user. These can be used to visualize the transcriptomic data, optimize some of the TDCOR parameters, and analyze the networks.
</p>


<h3>Author(s)</h3>

<p>Author: Julien Lavenus  <a href="mailto:jl.tdcor@gmail.com">jl.tdcor@gmail.com</a><br />
Maintainer: Mikael Lucas <a href="mailto:mikael.lucas@ird.fr">mikael.lucas@ird.fr</a>
</p>


<h3>References</h3>

<p>Lavenus <em>et al.</em> (2015), <b>Inference of the Arabidopsis lateral root gene regulatory network suggests a bifurcation mechanism that defines primordia flanking and central zones.</b> The Plant Cell, <em>in press</em>.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+CalculateDPI">CalculateDPI</a></code>,  <code><a href="#topic+CalculateTPI">CalculateTPI</a></code>, <code><a href="#topic+UpdateDPI">UpdateDPI</a></code>,  <code><a href="#topic+UpdateTPI">UpdateTPI</a></code>, <code><a href="#topic+TDCOR">TDCOR</a></code>, <code><a href="#topic+estimate.delay">estimate.delay</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the LR transcriptomic dataset
data(LR_dataset)

# Load the vectors of genes codes, gene names and prior
data(l_genes)
data(l_names)
data(l_prior)

# Load the vector of time points for the LR_dataset
data(times)

# Generate the TPI database (this may take several hours) 

TPI10=CalculateTPI(dataset=LR_dataset,l_genes=l_genes,l_prior=l_prior, 
times=times,time_step=1,N=10000,ks_int=c(0.5,3),kd_int=c(0.5,3), 
delta_int=c(0.5,3),noise=0.1,delay=3)

# Generate the DPI database (this may take several hours) 

DPI15=CalculateDPI(dataset=LR_dataset,l_genes=l_genes,l_prior=l_prior, 
times=times,time_step=1,N=10000,ks_int=c(0.5,3),kd_int=c(0.5,3), 
delta_int=c(0.5,3), noise=0.15, delay=3)

# Check/update if necessary the databases

TPI10=UpdateTPI(TPI10,LR_dataset,l_genes,l_prior)
DPI15=UpdateDPI(DPI15,LR_dataset,l_genes,l_prior)

# Choose your parameters 

ptime_step=1			
ptol=0.13			
pdelayspan=12			
pthr_cor=c(0.65,0.8)	
pdelaymax=c(2.5,3.5)		
pdelaymin=0			
pdelay=3			
pthrpTPI=c(0.55,0.8)		
pthrpDPI=c(0.65,0.8)		
pthr_overlap=c(0.4,0.6)		
pthr_ind1=0.65			
pthr_ind2=3.5			
pn0=1000			
pn1=10				
pregmax=5					
pthr_isr=c(4,6)			
pTPI=TPI10			
pDPI=DPI15			
pMinTarNumber=5			
pMinProp=0.6			
poutfile_name="TDCor_output.txt"	


# Reconstruct the network

tdcor_out= TDCOR(dataset=LR_dataset, l_genes=l_genes,l_names=l_names,n0=pn0,n1=pn1,
l_prior=l_prior, thr_ind1=pthr_ind1,thr_ind2=pthr_ind2,regmax=pregmax,thr_cor=pthr_cor,
delayspan=pdelayspan,delaymax=pdelaymax,delaymin=pdelaymin,delay=pdelay,thrpTPI=pthrpTPI,
thrpDPI=pthrpDPI,TPI=pTPI,DPI=pDPI,thr_isr=pthr_isr,time_step=ptime_step,thr_overlap=pthr_overlap,
tol=ptol,MinProp=pMinProp,MinTarNumber=pMinTarNumber,outfile_name=poutfile_name)


## End(Not run)
</code></pre>

<hr>
<h2 id='CalculateDPI'>Generate the DPI database to be used by the TDCOR main function</h2><span id='topic+CalculateDPI'></span>

<h3>Description</h3>

<p><code>CalculateDPI</code> builds a DPI database for the TDCOR main function to prune diamond motifs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateDPI(dataset,l_genes, l_prior, times, time_step, N, ks_int, kd_int, 
delta_int, noise, delay)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateDPI_+3A_dataset">dataset</code></td>
<td>

<p>Numerical matrix storing the transcriptomic data. The rows of this matrix must be named by gene codes (like AGI gene codes for Arabidopsis data).
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_l_genes">l_genes</code></td>
<td>

<p>A character vector containing the gene codes of the genes included in the analysis (i.e. to be used to build the network)
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_l_prior">l_prior</code></td>
<td>

<p>A numerical vector containing the prior information on the genes included in the network recontruction. By defining the <code>l_prior</code> vector, the user defines which genes should be regarded as positive regulators, which others as negative regulators and which can only be targets. The prior code is defined as follow: -1 for negative regulator; 0 for non-regulator (target only); 1 for positive regulator; 2 for both positive and negative regulator. The i-th element of the vector is the prior to associate to the i-th gene in <code>l_genes</code>.
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_times">times</code></td>
<td>

<p>A numerical vector containing the successive times at which the samples were collected to generate the time-series transcriptomic dataset.
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_time_step">time_step</code></td>
<td>

<p>A positive number corresponding to the time step (in hours) i.e. the temporal resolution at which the gene profiles are analysed. 
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_n">N</code></td>
<td>

<p>An integer corresponding to the number of iterations that are carried out in order to estimate the DPI distributions. <code>N</code> should be &gt;5000.
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_ks_int">ks_int</code></td>
<td>

<p>A numerical vector containing two positive elements in increasing order. The first (second) element is the lower (upper) boundary of the interval into which the equation parameters corresponding to the regulation strength of the targets by their regulators are randomly sampled.
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_kd_int">kd_int</code></td>
<td>

<p>A numerical vector containing two positive elements in increasing order. The first (second) element is the lower (upper) boundary of the interval into which the equation parameters corresponding to the transcripts degradation rates
are randomly sampled.
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_delta_int">delta_int</code></td>
<td>

<p>A numerical vector containing two positive elements in increasing order and expressed in hours. The first (second) element is the lower (upper) boundary of the sampling interval for the equation parameters corresponding to the time needed for the transcripts of the regulator to mature, to get exported out of the nucleus, to get translated and for the regulator protein to get imported into the nucleus and to bind its target promoter.
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_noise">noise</code></td>
<td>

<p>A positive number between 0 and 1 corresponding to the noisiness of the system. (0 = no noise, 1 = very strong noise).  <code>noise</code> should not be too high (for instance below 0.2).
</p>
</td></tr>
<tr><td><code id="CalculateDPI_+3A_delay">delay</code></td>
<td>

<p>A positive number corresponding to the time shift (in hours) that is expected between the profile of a regulator and its direct target. This parameter is used to generate a reference target profile from the profile of the regulator and calculate the DPI index.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CalculateDPI</code> models two 4-genes networks showing slightly different topologies. Each network topology is modelled using a specific system of delay differential equations. For all genes listed in <code>l_genes</code> whose corresponding prior in <code>l_prior</code> is not null (i.e. the genes that are regarded as transcriptional regulators), the two systems of differential equations are solved <code>N</code> times with <code>N</code> different sets of random parameters. The Diamond Pruning Index (DPI) is calculated for all of these <code>2N</code> networks. From these in silico data the conditional probability distribution of the DPI index given the regulator and the topology can be estimated. The probability distribution of the topology given DPI and the regulator is next calculated using Bayes' theorem and returned by the function. These shall be used when reconstructing the network to prune the &quot;diamond&quot; motifs. <br />
</p>
<p><code>CalculateDPI</code> returns a list object which works as a database. It not only stores the conditional probability distributions but also all the necessary information for <code>TDCOR</code> to access the data, and the input parameters. The latter are read by the <code>UpdateDPI</code> function to update the database.
</p>


<h3>Value</h3>

<p><code>CalculateDPI</code> returns a list object.
</p>
<table>
<tr><td><code>prob_DPI_ind</code></td>
<td>
<p>A numerical vector whose elements are named by the vector <code>l_genes</code>; The element named gene i contains 0 if no probability distribution has been
calculated for this gene (because its prior is 0) or a positive integer if this has been done. This positive integer then correponds to the number of the element in the list 
<code>prob_DPI</code> that stores the spline functions of the calculated conditional probability distributions associated with this particular regulator.</p>
</td></tr>
<tr><td><code>prob_DPI</code></td>
<td>
<p>A list storing lists of 3 spline functions of probability distributions. Each of the spline functions corresponds to the probability distribution of one topology given a regulator and a DPI value. The information about which regulator was used to generate the distributions stored in the i-th element of <code>prob_DPI</code> is stored in the <code>prob_DPI_ind</code> vector.</p>
</td></tr>
<tr><td><code>prob_DPI_domain</code></td>
<td>
<p>A list storing vectors of two elements. The first (second) element of element i is the lowest (greatest) DPI value obtained during the simulation with the regulator i.</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>A list that stores the input parameters used to generate the database.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The computation of the TPI and DPI databases is time-consuming as it requires many systems of differential equations to be solved. It may take several hours to build a database for a hundred genes.
</p>


<h3>Author(s)</h3>

<p>Julien Lavenus <a href="mailto:jl.tdcor@gmail.com">jl.tdcor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+UpdateDPI">UpdateDPI</a></code>, <code><a href="#topic+TDCor-package">TDCor-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Load the LR transcriptomic dataset
data(LR_dataset)

# Load the vector of gene codes, gene names and prior
data(l_genes)
data(l_names)
data(l_prior)

# Load the vector of time points for the LR_dataset
data(times)

# Generate a small DPI database (3 genes)
DPI_example=CalculateDPI(dataset=LR_dataset,l_genes=l_genes[4:6],l_prior=l_prior[4:6],
times=times,time_step=1,N=5000,ks_int=c(0.5,3),kd_int=c(0.5,3),delta_int=c(0.5,3),
noise=0.15,delay=3)


## End(Not run)
</code></pre>

<hr>
<h2 id='CalculateTPI'>Generate the TPI database to be used by the TDCOR main function </h2><span id='topic+CalculateTPI'></span>

<h3>Description</h3>

<p><code>CalculateTPI</code> builds a TPI database for the TDCOR main function to prune triangle motifs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateTPI(dataset,l_genes, l_prior, times, time_step, N, ks_int, kd_int, 
delta_int, noise, delay)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateTPI_+3A_dataset">dataset</code></td>
<td>

<p>Numerical matrix storing the transcriptomic data. The rows of this matrix must be named by gene codes (AGI gene codes for Arabidospis data).
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_l_genes">l_genes</code></td>
<td>

<p>A character vector containing the gene codes of the genes included in the analysis (i.e. to be used to build the network)
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_l_prior">l_prior</code></td>
<td>

<p>A numerical vector containing the prior information on the genes included in the network recontruction. By defining the <code>l_prior</code> vector, the user defines which genes should be regarded as positive regulators, which others as negative regulators and which can only be targets. The prior code is defined as follow: -1 for negative regulator; 0 for non-regulator (target only); 1 for positive regulator; 2 for both positive and negative regulator. The i-th element of the vector is the prior to associate to the i-th gene in <code>l_genes</code>.
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_times">times</code></td>
<td>

<p>A numerical vector containing the successive times at which the samples were collected to generate the time-series transcriptomic dataset.
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_time_step">time_step</code></td>
<td>

<p>A positive number corresponding to the time step (in hours) i.e. the temporal resolution at which the gene profiles are analysed. 
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_n">N</code></td>
<td>

<p>An integer corresponding to the number of iterations that are carried out in order to estimate the TPI distributions. <code>N</code> should be &gt;5000.
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_ks_int">ks_int</code></td>
<td>

<p>A numerical vector containing two positive elements in increasing order. The first (second) element is the lower (upper) boundary of the interval into which the equation parameters corresponding to the regulation strength of the targets
by their regulators are randomly sampled.
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_kd_int">kd_int</code></td>
<td>

<p>A numerical vector containing two positive elements in increasing order. The first (second) element is the lower (upper) boundary of the interval into which the equation parameters corresponding to the transcripts degradation rates
are randomly sampled.
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_delta_int">delta_int</code></td>
<td>

<p>A numerical vector containing two positive elements in increasing order and expressed in hours. The first (second) element is the lower (upper) boundary of the sampling interval for the equation parameters corresponding to the time needed for the transcripts of the regulator to mature,
to get exported out of the nucleus, to get translated and for the regulator protein to get imported into the nucleus and to bind its target promoter.
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_noise">noise</code></td>
<td>

<p>A positive number between 0 and 1 corresponding to the noisiness of the system. (0 = no noise, 1 = very strong noise).  <code>noise</code> should not be too high (for instance below 0.2).
</p>
</td></tr>
<tr><td><code id="CalculateTPI_+3A_delay">delay</code></td>
<td>

<p>A positive number corresponding to the time shift (in hours) that is expected between the profile of a regulator and its direct target. This parameter is used to generate a reference target profile from the profile of the regulator and calculate the TPI index.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CalculateTPI</code> models three 3-genes networks showing slightly different topologies. Each network topology is modelled using a specific system of delay differential equations. For all genes listed in <code>l_genes</code> whose corresponding prior in <code>l_prior</code> is not null (i.e. the genes that are regarded as transcriptional regulators), the three systems of differential equations are solved <code>N</code> times with <code>N</code> different sets of random parameters. The Triangle Pruning Index (TPI) is calculated for all of 
these <code>3N</code> networks. From these in silico data the conditional probability distribution of the TPI index given the regulator and the topology can be estimated. The probability distribution of the topology given TPI and the regulator is next calculated using Bayes' theorem and returned by the function. These shall be used when reconstructing the network to prune the &quot;triangle&quot; motifs. <br />
</p>
<p><code>CalculateTPI</code> returns a list object which works as a database. It not only stores the calculated probability distributions but also information on how to access the data, and the input parameters. The latter are read by the <code>UpdateTPI</code> function to update the database.
</p>


<h3>Value</h3>

<p><code>CalculateTPI</code> returns a list object.
</p>
<table>
<tr><td><code>prob_TPI_ind</code></td>
<td>
<p>A numerical vector whose elements are named by the vector <code>l_genes</code>; The element named gene i contains 0 if no probability distribution has been
calculated for this gene (because its prior is 0) or a positive integer if this has been done. This positive integer then correponds to the number of the element in the list 
<code>prob_TPI</code> that stores the spline functions of the calculated conditional probability distributions associated with this particular regulator.</p>
</td></tr>
<tr><td><code>prob_TPI</code></td>
<td>
<p>A list storing lists of 3 spline functions of probability distributions. Each of the spline functions corresponds to the probability distribution of one topology given a regulator and a TPI value. The information about which regulator was used to generate the distributions stored in the i-th element of <code>prob_TPI</code> is stored in the <code>prob_TPI_ind</code> vector.</p>
</td></tr>
<tr><td><code>prob_TPI_domain</code></td>
<td>
<p>A list storing vectors of two elements. he first (second) element of element i is the lowest (greatest) TPI value obtained during the simulation with the regulator i.</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>A list that stores the input parameters used to generate the database.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The computation of the TPI and DPI databases is time-consuming as it requires many systems of differential equations to be solved. It may take several hours to build a database for a hundred genes.
</p>


<h3>Author(s)</h3>

<p>Julien Lavenus  <a href="mailto:jl.tdcor@gmail.com">jl.tdcor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+UpdateTPI">UpdateTPI</a></code>, <code><a href="#topic+TDCor-package">TDCor-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Load the lateral root transcriptomic dataset
data(LR_dataset)

# Load the vectors of gene codes, gene names and prior
data(l_genes)
data(l_names)
data(l_prior)

# Load the vector of time points for the the lateral root dataset
data(times)

# Generate a small TPI database (3 genes)

TPI_example=CalculateTPI(dataset=LR_dataset,l_genes=l_genes[4:6],
l_prior=l_prior[4:6],times=times,time_step=1,N=5000,ks_int=c(0.5,3),
kd_int=c(0.5,3),delta_int=c(0.5,3),noise=0.1,delay=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='clean.at'>
Elimininate from a vector of gene codes the genes for which no data is available.
</h2><span id='topic+clean.at'></span>

<h3>Description</h3>

<p><code>clean.at</code> removes from a vector of gene codes <code>l_genes</code> all the elements for which no data is present in the
matrix <code>dataset</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean.at(dataset,l_genes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean.at_+3A_dataset">dataset</code></td>
<td>

<p>A matrix containing the time-series transcriptomic data whose rows must be named by gene codes (like AGI gene codes).
</p>
</td></tr>
<tr><td><code id="clean.at_+3A_l_genes">l_genes</code></td>
<td>

<p>A character vector which contains gene codes (AGI gene codes in the case of the lateral root dataset).
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Load lateral root transcriptomic dataset and the l_genes vector
data(LR_dataset)
data(l_genes)

# Clean the l_gene vector 
clean.at(LR_dataset,l_genes)

</code></pre>

<hr>
<h2 id='draw.profile'>
Plot the expression profile of a <code>gene</code> in <code>dataset</code>
</h2><span id='topic+draw.profile'></span>

<h3>Description</h3>

<p><code>draw.profile</code> plots the expression profile of <code>gene</code> in <code>dataset</code> with respect to <code>times</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.profile(dataset, gene, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.profile_+3A_dataset">dataset</code></td>
<td>

<p>The matrix storing the time-serie transcriptomic data.
</p>
</td></tr>
<tr><td><code id="draw.profile_+3A_gene">gene</code></td>
<td>

<p>The AGI code of the gene of interest.
</p>
</td></tr>
<tr><td><code id="draw.profile_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the function:
</p>

<ul>
<li><p><code>col</code>: String. Color of the curve.
</p>
</li>
<li><p><code>type</code>: String. Type of curve. &quot;l&quot;, lines; &quot;p&quot;, points; &quot;b&quot;, both etc... For more information see the help file of the <code>plot</code> R function.
</p>
</li>
<li><p><code>main</code>: String. Title of the graph.
</p>
</li></ul>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien Lavenus (<a href="mailto:jl.tdcor@gmail.com">jl.tdcor@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># draw the profile of GATA23 in the LR dataset

data(LR_dataset)
data(times)
draw.profile(LR_dataset,"AT5G26930",col="blue",main="GATA23")
</code></pre>

<hr>
<h2 id='estimate.delay'>
Estimate the time shift between two gene profiles and make a plot
</h2><span id='topic+estimate.delay'></span>

<h3>Description</h3>

<p><code>estimate.delay</code> computes the delay/time shift between two gene expression profiles contained in <code>dataset</code>. It returns a list with one or two estimated time shifts and their associated correlation. By default the function also returns a plot composed of four panels which show in more details how these estimate were obtained. This can help the user finding the appropriate parameter values to be used with the TDCOR main function. For more details see below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.delay(dataset, tar, reg, times, time_step, thr_cor, tol, 
delaymax, delayspan, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.delay_+3A_dataset">dataset</code></td>
<td>

<p>Numerical matrix storing the non-log2 transcriptomic data (average of replicates). The rows of this matrix must be named by gene codes (e.g. the AGI gene code for Arabidopsis datasets). The columns must be organized in chronological order from the left to the right.
</p>
</td></tr>
<tr><td><code id="estimate.delay_+3A_tar">tar</code></td>
<td>

<p>The gene code of the gene to be regarded as the target.
</p>
</td></tr>
<tr><td><code id="estimate.delay_+3A_reg">reg</code></td>
<td>

<p>The gene code of the gene to be regarded as the regulator.
</p>
</td></tr>
<tr><td><code id="estimate.delay_+3A_times">times</code></td>
<td>
 
<p>A numerical vector containing the successive times (in hours) at which the samples were collected to generate the time-series transcriptomic dataset.
</p>
</td></tr>
<tr><td><code id="estimate.delay_+3A_time_step">time_step</code></td>
<td>

<p>A positive number corresponding to the time step (in hours) i.e. the temporal resolution at which the gene profiles are analysed. 
</p>
</td></tr>
<tr><td><code id="estimate.delay_+3A_thr_cor">thr_cor</code></td>
<td>
 
<p>A number between 0 and 1 corresponding to the threshold on Pearson's correlation. The delay will be computed only if the absolute correlation between the profiles is higher than this threshold. Otherwise the genes are considered to have profiles that are too dissimilar, and computing the time shift would not make any sense.
</p>
</td></tr>
<tr><td><code id="estimate.delay_+3A_tol">tol</code></td>
<td>

<p>The tolerance threshold for the score. The score is a positive number used to rank the time shift estimates. The best score possible for a time shift estimate is 0. If the score is above the tolerance threshold, the time shift estimate will be ignored. 
</p>
</td></tr>
<tr><td><code id="estimate.delay_+3A_delaymax">delaymax</code></td>
<td>

<p>The maximum time shift possible for a direct interaction (in hours).
</p>
</td></tr>
<tr><td><code id="estimate.delay_+3A_delayspan">delayspan</code></td>
<td>
 
<p>The maximum time shift (in hours) which will be analysed. It should be high enough for the time shift estimation process to be successful but relatively small in comparison to the overall duration of the time series. (e.g. for the LR dataset which has data spanning over 54 hours, <code>delayspan</code> was set to 12 hours).
</p>
</td></tr>
<tr><td><code id="estimate.delay_+3A_...">...</code></td>
<td>
<p> Additional optional arguments.
</p>

<ul>
<li><p><code>make.graph</code>: A boolean. Set to FALSE to prevent the function from generating a graph.
</p>
</li>
<li><p><code>tar.name</code>: A string. &quot;Everyday name&quot; of the target. This name will be used in the plots instead of the default value (gene code).
</p>
</li>
<li><p><code>reg.name</code>: A string. &quot;Everyday name&quot; of the regulator. This name will be used in the plots instead of the default value (gene code).
</p>
</li>
<li><p><code>main</code>: A string. Main title of the plot. By default the title of the plot is automatically generated from <code>tar.name</code> and <code>reg.name</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>Negative time shifts occur when the gene which the user set as being the regulator could actually be the target. When two time shifts are returned, one is necessarily positive and the other is negative. When the only time shift estimate is zero, the function does not return any estimate.<br />
</p>
<p>The function automatically guess the sign of the potential interaction (stimulatory or inhibitory) and adapt the analysis based on it. The sign of the potential interaction is indicated in the main title of the graph by (+) or (-). When both types of interaction are possible, the function generates two graphs (one for each sign).<br />
</p>
<p>The function returns by default a graph composed of four panels.  The top panel shows the spline functions of the two normalised expression profiles with respect to time. The second panel consists of the plots of the F1 and F2 functions with respect to the time shift (mu). The third one is for the F3 and F4 functions. All of these four functions aim at estimating the time shift between the two expression profiles by minimizing a distance-like measurement. But they each do it in a slightly different manner. F1 and F3 use Pearson's correlation as a measure of distance while F2 and F4 use the sum of squares. Moreover F1 and F2 measure the distances directly between the spline functions while F3 and F4 do it between the first derivatives of these functions. The vertical red and purple lines in the second and third panel indicate the position of the respective maximum or minimum of the functions. In the fourth and last panel, the final score function is plotted. This score is computed for each  possible time shift analysed by combining the four above-mentionned functions. The green horizontal line indicate the position of the tolerance threshold (<code>tol</code>) above which time shift estimates are rejected. The vertical dark grey line(s) represent(s) the position of the final estimated time shift(s). All these lines necessarily fall into regions where the score function is below the threshold (painted in light green). Other vertical light grey line(s) may indicate other time shift estimate(s) that have a score above the tolerance threshold and were therefore rejected.
</p>


<h3>Value</h3>

<p>The function returns a list. The first element (delay) is a numerical vector containing the time-shift estimate(s). The second element (correlation) is another numerical vector containing the associated correlation. The function also returns a graph as explained above.
</p>


<h3>Author(s)</h3>

<p>Julien Lavenus <a href="mailto:jl.tdcor@gmail.com">jl.tdcor@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data

data(LR_dataset)
data(l_genes)
data(l_names)
data(times)

# Estimate the time shift between LBD16 and PUCHI (one time shift estimate returned)

estimate.delay(dataset=LR_dataset, tar=l_genes[which(l_names=="PUCHI")], 
reg=l_genes[which(l_names=="LBD16")], times=times, time_step=1, thr_cor=0.7, 
tol=0.15, delaymax=3, delayspan=12, reg.name="LBD16",tar.name="PUCHI")

# Estimate the time shift between ARF8 and PLT1 (two time shift estimates returned)

estimate.delay(dataset=LR_dataset, tar=l_genes[which(l_names=="PLT1")], 
reg=l_genes[which(l_names=="ARF8")], times=times, time_step=1, thr_cor=0.7, 
tol=0.15, delaymax=3, delayspan=12, reg.name="ARF8",tar.name="PLT1")


</code></pre>

<hr>
<h2 id='l_genes'>
l_genes
</h2><span id='topic+l_genes'></span>

<h3>Description</h3>

<p>Character vector containing the AGI gene codes of the genes used to reconstruct the network in Lavenus et al. 2015, Plant Cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("l_genes")</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Load the vector
data(l_genes)

# Have a look at it
l_genes
</code></pre>

<hr>
<h2 id='l_names'>
l_names
</h2><span id='topic+l_names'></span>

<h3>Description</h3>

<p>Character vector containing the 'everyday names' of the genes used to reconstruct the network in Lavenus et al. 2015, Plant Cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("l_names")</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Load the vector
data(l_names)

# Have a look at it
l_names
</code></pre>

<hr>
<h2 id='l_prior'>
l_prior
</h2><span id='topic+l_prior'></span>

<h3>Description</h3>

<p>Vector containing the prior associated with the genes included in the network reconstruction in Lavenus et al. 2015, Plant Cell.<br />
</p>
<p>By defining the <code>l_prior</code> vector, the user defines which genes should be regarded as positive regulators, which others as negative regulators and which can only be targets. The prior code is defined as follow: -1 for negative regulator; 0 for non-regulator (target only); 1 for positive regulator; 2 for both positive and negative regulator. The i-th element of the vector is the prior to associate to the i-th gene in <code>l_genes</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("l_prior")</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Load the vector
data(l_prior)

# Have a look at it
l_prior
</code></pre>

<hr>
<h2 id='LR_dataset'>
Lateral root transcriptomic dataset
</h2><span id='topic+LR_dataset'></span>

<h3>Description</h3>

<p>LR_dataset is a matrix of dimension 15240 lines x 18 columns. It stores a time-series transcriptomic dataset following the changes occuring in a young Arabidopsis root during the formation of a lateral root. To generate this dataset, lateral root formation was locally induced by a gravistimulus at t=0 and the stimulated part of the roots was collected 
every 3 hours from 6 hours to 54 hours. The transcriptomes were analyzed using the ATH1 affymetrix chip.  
For time point 0, unstimulated young primary root was taken as a control. Importantly, the transcript accumulation levels stored in this dataset are non-log2 values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LR_dataset")</code></pre>


<h3>Details</h3>

<p>The experiment spanned 54 hours in order to cover all aspects of lateral root development. Using this method, 
lateral root initiation (the first pericycle divisions) occurs synchroneously in all stimulated roots around 12 hours after stimulation 
and the fully formed lateral root emerges from the parental root around 45 hours. The dataset contains data for all significantly differentially 
expressed genes. <br />
</p>
<p>Each column is the average of 4 independent replicates. The columns are organized in the following order: 0, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51 and 54 hours. Each line of the matrix is labbelled with an AGI gene code (Arabidopsis Genome Initiative gene code).
</p>


<h3>Source</h3>

<p>Voss <em>et al.</em>, Lateral root organ initiation re-phases the circadian clock in Arabidopsis thaliana. Nature communication, <em>in revision</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the dataset
data(LR_dataset)

# Have a look at the first rows
head(LR_dataset)
</code></pre>

<hr>
<h2 id='shortest.path'>
Calculate the shortest path linking every pairs of nodes in the network
</h2><span id='topic+shortest.path'></span>

<h3>Description</h3>

<p><code>shortest.path</code> computes the shortest influence path (in number of edges) linking every possible regulator/target pairs in the network. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortest.path(bootstrap, BS_thr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortest.path_+3A_bootstrap">bootstrap</code></td>
<td>

<p>A square numerical matrix representing a network. The element [i,j] of this matrix is the signed bootstrap value for the edge 'gene j to gene i'. The sign of this element indicates the sign of the predicted interation (i.e. whether it is inhibitory or stimulatory) and the absolute value of the element is the bootstrap.
</p>
</td></tr>
<tr><td><code id="shortest.path_+3A_bs_thr">BS_thr</code></td>
<td>

<p>Minimum bootstrap threshold for an edge to be taken into consideration in the analysis. The edges with bootstrap values below this threshold are ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The paths are signed in order to keep track of the type of influence that the genes have on each other. If a path leads to the inhibition of a gene by another,
<code>shortest.path</code> will return a negative number for this &quot;pair&quot; (Note that the (i,j) pair is not regarded as being the same than the (j,i) pair). Because the network is directed, edges can only be followed in one direction: from the regulator to the target. Hence if the network contains an edge
from gene i to gene j, the length of the shortest path from i to j is 1 edge and therefore the function returns either 1 or -1  (depending on the sign of the interaction) for the length of i to j path. In absence of feedback loops between i and j, the network does not contain any path from gene j to gene i. In this case <code>shortest.path</code> shall return 0 for the length of the j to i path. Otherwise it will return the minimum number of edges to follow to go from j to i.
</p>


<h3>Value</h3>

<p><code>shortest.path</code> returns a list containing two matrices.
</p>
<table>
<tr><td><code>SP</code></td>
<td>
<p> A square numerical matrix. The element [i,j] stores the signed shortest path from gene j to gene i. The sign indicates of the type of regulatory influence (stimulatory or inhitory) that gene j has on gene i through the shortest path.</p>
</td></tr>
<tr><td><code>BS</code></td>
<td>
<p>A square numerical matrix. The element [i,j] stores the geometric mean of the bootstrap values of the edges located on the shortest path from gene j to gene i.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien Lavenus <a href="mailto:jl.tdcor@gmail.com">jl.tdcor@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Example with a 3-genes network where gene A upregulates B which upregulates A; and C represses B.
## the three edges have different bootstrap values (100, 60 and 55)

network=data.frame(matrix(c(0,100,0,0,60,0,0,-55,0),3,3))
names(network)=c("gene A","gene B","gene C")
rownames(network)=c("gene A","gene B","gene C")

shortest.path(as.matrix(network),1)

</code></pre>

<hr>
<h2 id='TDCOR'>
The TDCOR main function
</h2><span id='topic+TDCOR'></span>

<h3>Description</h3>

<p>This is the main function to run the TDCOR algorithm and reconstruct the gene network topology. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TDCOR(dataset,l_genes, TPI, DPI, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TDCOR_+3A_dataset">dataset</code></td>
<td>

<p>Numerical matrix storing the non-log2 transcriptomic data (average of replicates). The rows of this matrix must be named by gene codes (e.g. the AGI gene code for Arabidopsis datasets). The columns must be organized in chronological order from the left to the right.
</p>
</td></tr>
<tr><td><code id="TDCOR_+3A_l_genes">l_genes</code></td>
<td>

<p>A character vector containing the (AGI) gene codes of the genes one wishes to build the network with (gene codes -e.g. &quot;AT5G26930&quot;- by opposed to gene names -e.g.&quot;GATA23&quot;- which are provided by the optional <code>l_names</code> argument).
</p>
</td></tr>
<tr><td><code id="TDCOR_+3A_tpi">TPI</code></td>
<td>

<p>A TPI database generated by <code><a href="#topic+CalculateTPI">CalculateTPI</a></code> which contains some necessary statistical information for triangle motifs pruning. In particular it must have an entry for all the regulators included in the network analysis. The TPI database may also contain data for genes that are not included in <code>l_genes</code>.
</p>
</td></tr>
<tr><td><code id="TDCOR_+3A_dpi">DPI</code></td>
<td>

<p>A DPI database generated by <code><a href="#topic+CalculateDPI">CalculateDPI</a></code> which contains some necessary statistical information for diamond motifs pruning. In particular it must have an entry for all the regulators included in the network analysis. The DPI database may also contain data for genes that are not included in <code>l_genes</code>.
</p>
</td></tr>
<tr><td><code id="TDCOR_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the TDCOR function (Some are necessary if <code>dataset</code> is not the LR dataset):
</p>

<ul>
<li><p><code>l_names</code>: 
A character vector containing the 'everyday names' of the genes included in the analysis (e.g. &quot;LBD16&quot;) . These are the names by which genes will be refered as to in the final network table. Gene names must be unique; repeats of the same name are not allowed. If no <code>l_names</code> parameter is given, it is by default equal to <code>l_genes</code>. The i-th element of the vector <code>l_names</code> contains the 'everyday name' of the i-th gene in <code>l_genes</code>.

</p>
</li>
<li><p><code>l_prior</code>: 
A numerical vector containing the prior information on the genes included in the analysis. By defining the <code>l_prior</code>, the user defines which genes are positive regulators, which are negative regulators and which can only be targets. The prior code is defined as follow: -1 for negative regulator; 0 for non-regulator (target only); 1 for positive regulator; 2 for genes that can act as both positive and negative regulators. If no <code>l_prior</code> parameter is provided, it is by default equal to a vector of 2s, meaning that all genes are regarded as being both potential activators and repressors. The i-th element of the vector <code>l_prior</code> contains the prior to associate to the i-th gene in <code>l_genes</code>.

</p>
</li>
<li><p><code>times</code>: 
A numerical vector containing the successive times (in hours) at which the samples were collected to generate the time-series transcriptomic dataset.If no <code>times</code> parameter is given, it is by default equal to the <code>times</code> parameter used for the lateral root transcriptomic dataset.

</p>
</li>
<li><p><code>n0</code>: 
An integer corresponding to the number of iterations to be performed in the external bootstrap loop. At the beginning of every iteration of this external loop, new random parameter values are sampled in the user-defined bootstrapping interval. If no <code>n0</code> parameter is given, it is by default equal to 1000.

</p>
</li>
<li><p><code>n1</code> :
An integer corresponding to the number of iterations to be performed in the internal bootstrap loop. In this loop parameter values are kept the same but the order of node analysis is randomized at each iteration. If no <code>n1</code> parameter is provided, it is by default equal to 10.

</p>
</li>
<li><p><code>time_step</code>:
A positive number corresponding to the time step (in hours) i.e. the temporal resolution at which the gene profiles are analysed.  If no <code>time_step</code> parameter is provided, it is by default equal to 1 hour.

</p>
</li>
<li><p><code>delayspan</code>: 
A positive number. It is the maximum time shift (in hours) which is analysed. It should be high enough for the time shift estimation process to be successful but argueably relatively small in comparison to the overall duration of the time series. (e.g. for the LR dataset which has data spanning over 54 hours, <code>delayspan</code> was set to 12 hours).

</p>
</li>
<li><p><code>tol</code>: 
A strictly positive number corresponding to the tolerance threshold on the final score of time shift estimates. The score is a  positive number that measures the &quot;level of disagreement&quot; between the four time shift estimators. A time shift estimate is regarded as meaningful if it scores lower than the <code>tol</code> threshold. If all four estimators agree on a certain value of time shift, the estimate obtains the best possible score, which is 0. Increasing <code>tol</code> make the time shift estimation process LESS stringent. For more information see <code><a href="#topic+estimate.delay">estimate.delay</a></code>.

</p>
</li>
<li><p><code>delaymin</code>: 
A numerical vector containing one or two positive elements corresponding to the boundaries of the boostrapping interval for the minimum time shift above which putative interactions are regarded as possible. If no <code>delaymin</code> parameter is provided, it is by default equal to 0 hour. Gene pairs with time shift lower than or equal to <code>delaymin</code> are regarded as co-regulation and are therefore not included in the network.

</p>
</li>
<li><p><code>delaymax</code>: 
A numerical vector containing one or two positive elements corresponding to the boundaries of the boostrapping interval for the maximum time shift above which putative interactions are regarded as indirect. If no <code>delaymax</code> parameter is provided, it is by default equal to 3 hours. Putative indirect interactions are included in the network only when the putative target is not predicted any direct regulator.

</p>
</li>
<li><p><code>thr_cor</code>: 
A numerical vector containing one or two positive elements between 0 and 1 corresponding to the boundaries of the boostrapping interval for the threshold of Pearson's correlation. A gene pair is included in the preliminary network only if the correlation between the profiles (with the time shift correction) is higher than or equal to the <code>thr_cor</code> threshold. If no <code>thr_cor</code> parameter is provided, it is by default equal to [0.7;0.9]. Note that increasing <code>thr_cor</code> makes the correlation filter MORE stringent.

</p>
</li>
<li><p><code>delay</code>:
A positive number corresponding to the most likely time shift (in hours) one could expect between the profile of a regulator and the profile of its direct targets. This parameter enables one to generate the reference profiles of the ideal regulator when calculating the index of directness (ID). If no <code>delay</code> parameter is provided, it is by default equal to 3 hours. Note that similar parameters serving the same purpose are also used to calculate the triangle pruning index and the diamond pruning index. But TDCOR reads the value to use for calculating those indices directly from the TPI and DPI databases (for consistency reasons).

</p>
</li>
<li><p><code>thr_ind1</code>: 
A numerical vector containing one or two positive elements corresponding to the boundaries of the boostrapping interval for the index of directness (ID) lower threshold. Gene pairs showing an ID below this threshold will be regarded as co-regulation and therefore eliminated from the network. If no <code>thr_ind1</code> parameter is provided, it is by default equal to 0.5. Reminder: For direct interaction one expects ID values around 1. For indirect interactions one expect values greater than 1. For co-regulated genes, ID should be smaller than 1. Note that increasing <code>thr_ind1</code> makes the ID-based &quot;anti-coregulation filter&quot; MORE stringent.

</p>
</li>
<li><p><code>thr_ind2</code>: 
A numerical vector containing one or two positive elements corresponding to the boundaries of the boostrapping interval for the index of directness (ID) upper threshold. Putative interactions showing an ID above this threshold are regarded as indirect. If no <code>thr_ind2</code> parameter is provided, it is by default equal to 4.5. Reminder: For direct interaction one expects ID values around 1. For indirect interactions one expect values greater than 1. For co-regulated genes, ID should be smaller than 1. Note that increasing <code>thr_ind2</code> makes the ID-based filter against indirect interactions LESS stringent.

</p>
</li>
<li><p><code>thr_overlap</code> :
A numerical vector containing one or two positive elements smaller than 1. These correspond to the boundaries of the boostrapping interval for the index of overlap. If no <code>thr_overlap</code> parameter is provided, it is by default equal to [0.5,0.6]. Note that increasing <code>thr_overlap</code> makes the overlap filter MORE stringent. This filter aims at removing unlikely negative interactions where the putative regulator switches on too late to downregulate the putative target. Keep in mind that the filter is sensitive to the noise level in the data. It should only be used if the data has a very low level of noise. To inactivate the filter set the <code>thr_overlap</code> parameter to 0.

</p>
</li>
<li><p><code>thrpTPI</code>:
A numerical vector containing one or two positive numbers smaller or equal to 1 in increasing order. These correspond to the boundaries of the boostrapping interval for the probability threshold used in the triangle filter. If no <code>thrpTPI</code> parameter is provided, it is by default equal to [0.5,0.75]. Note that increasing <code>thrpTPI</code> makes the triangle filter LESS stringent.

</p>
</li>
<li><p><code>thrpDPI</code>:
A numerical vector containing one or two positive numbers smaller or equal to 1 in increasing order. These correspond to the boundaries of the boostrapping interval for the probability threshold used in the diamond filter.  If no <code>thrpTPI</code> parameter is provided, it is by default equal to [0.8,0.9]. Note that increasing <code>thrpDPI</code> makes the diamond filter LESS stringent.

</p>
</li>
<li><p><code>thr_isr</code>:
A numerical vector containing one or two positive elements corresponding to the boundaries of the boostrapping interval for the threshold of the index of directness above which the gene is predicted to negatively self-regulate. Genes will be predicted to positively self-regulate if the index of directness is smaller than 1/<code>thr_isr</code>. If no <code>thr_isr</code> parameter is provided, it is by default equal to [3,6]. Note that increasing <code>thr_isr</code> makes the search for self-regulating genes MORE stringent.

</p>
</li>
<li><p><code>search.EP</code>:
A boolean to control whether Master-Regulator-Signal-Transducer (MRST) or signal Entry Point (EP) should be looked for or not. (If yes, set on TRUE which is the default value)

</p>
</li>
<li><p><code>thr_bool_EP</code>:
A number between 0 and 1 used as threshold to convert normalized expression profiles (values between 0 and 1) into boolean expression profiles  (values equal to 0 or 1). If no <code>thr_bool_EP</code> parameter is provided, it is by default equal to 0.8. The conversion of the continuous profiles into boolean profiles is part of the process of MRST analysis.

</p>
</li>
<li><p><code>MinTarNumber</code>:
An integer. Minimum number of targets a regulator should have in order to be regarded as a potential MRST. If no <code>MinTarNumber</code> parameter is provided, it is by default equal to 5. Note that increasing <code>MinTarNumber</code> makes the search for MRST genes MORE stringent.

</p>
</li>
<li><p><code>MinProp</code>:
A number between 0 and 1. Minimum proportion of targets which are not at steady state at t=0 that a regulator should have in order to be regarded as a potential MRST. If no <code>MinProp</code> parameter is provided, it is by default equal to 0.75. Note that increasing <code>MinProp</code> makes the search for MRST genes MORE stringent.

</p>
</li>
<li><p><code>MaxEPNumber</code>:
An integer. Maximum number of MRST that can be predicted at each iteration. If no <code>MaxEPNumber</code> parameter is provided, it is by default equal to 1.

</p>
</li>
<li><p><code>regmax</code>:
An integer. Maximum number of regulators that a target may have. If no <code>regmax</code> parameter is provided, it is by default equal to 6.

</p>
</li>
<li><p><code>outfile_name</code>:
A string. Name of the file to print the network table in. By default it is &quot;TDCor_output.txt&quot;.

</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>The default values are certainly not the best values to work with. The TDCOR parameters have to be optimized by the user based on its own knowledge of the network, the quality of the data etc... Because TDCOR works by pruning interactions, it is probably easier (as a first go) to optimize the parameter values following the order of the filters. 
</p>
<p>Before starting inactivate all the filters using the less stringent parameter values possible or for the MRST filter by setting <code>search.EP</code> to FALSE. You should as well set the bootstrap parameters to a relatively low value (e.g. <code>n0</code>=100 and <code>n1</code>=1). Hence the runs will be quick and you will be able to rapidly assess whether the changes you made in the parameter values were a good thing.
</p>
<p>Start by optimizing the parameters involved in time shifts estimation. That is to say, essentially <code>delayspan</code>, <code>time_step</code>, <code>tol</code> and <code>delaymax</code>. The latter (together with <code>delaymin</code>) is a biological parameters and the range of possible values is argueably limited. Though they ought to be adapted to the organism (e.g. in prokaryotes, the delays are extremely short since polysomes couple transcription and translation). Note that the <code><a href="#topic+estimate.delay">estimate.delay</a></code> function can be very helpful to optimize these various parameters thanks to the visual output. Use it with pairs of genes that have been shown to interact directly or indirectly in your system and for which the relationship in the dataset in clearly linear. For network reconstruction with TDCor, good time shift estimation is absolutely crucial. Once this is done, proceed with optimizing the threshold for correlation <code>thr_cor</code> and the thresholds on the index of directness (<code>thr_ind1</code>, <code>thr_ind2</code>). Then optimize the parameters of the triangle and diamond pruning filters (<code>thrpTPI</code> and <code>thrpDPI</code>). You may have to try a couple of different TPI and DPI databases (i.e. databases built with different input parameters). In particular increasing the <code>noise</code> level when generating these database enables one to decrease the stringency of the triangle and diamond filters, when increasing the <code>thrpTPI</code> and <code>thrpDPI</code> value is not sufficient. Subsequently fine-tune the parameters of the MRST filter (<code>thr_bool_EP</code>, <code>MinTarNumber</code>, <code>MinProp</code>, <code>MaxEPNumber</code>) if you want it on. Remember to set <code>search.EP</code> back to TRUE first. Next optimize <code>thr_isr</code> (self-regulation). Finally, restrict the number of maximum regulators if necessary (<code>regmax</code>).
</p>


<h3>Value</h3>

<p>The <code>TDCOR</code> main function returns a list containing 7 elements
</p>
<table>
<tr><td><code>input</code></td>
<td>
<p>A list containing the input parameters (as a reminder).</p>
</td></tr>
<tr><td><code>intermediate</code></td>
<td>
<p>A list containing three intermediate matrices. <code>mat_cor</code> is the matrix that stores the correlations, <code>mat_isr</code> stores the indices of self-regulations and <code>mat_overlap</code> contains the indices of overlap.</p>
</td></tr>
<tr><td><code>network</code></td>
<td>
<p>A matrix containing the network. The element [i,j] of this matrix contains the bootstrap value for the edge &quot;gene j to gene i&quot;. The sign indicates the sign of the predicted interaction.</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>A matrix containing the computed indices of directness (ID). The element [i,j] contains the ID for the edge &quot;gene j to gene i&quot;.</p>
</td></tr>
<tr><td><code>delay</code></td>
<td>
<p>A matrix containing the computed time shifts. The element [i,j] of this matrix contains the estimated time shift between the profile of gene j and the profile of gene i.</p>
</td></tr>
<tr><td><code>EP</code></td>
<td>
<p>A vector containing the bootstrap values for the MRST predictions.</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>The edge predictions in the form of a table. The columns are organized in following order: Regulator name, Type of interaction (+ or-), Target name, Bootstrap, Index of Directness, Estimated time shift between the target and regulator profiles.</p>
</td></tr>
</table>
<p>The table of predictions (without header) and the input parameters are printed at the end of the run in two separate text files located in the current R working directory (If you are not sure which directory this is, use the command <code>getwd()</code>).
</p>


<h3>Note</h3>

<p>For a parameter to be involved in the bootstrapping process, one must feed the function a vector containing two values as input. These two values are respectively the lower and upper boundaries of the bootstrapping interval. If one chooses not to use a parameter for bootstrapping, one can either feed the function an input vector containing twice the same value, or only one value.
</p>


<h3>Author(s)</h3>

<p>Julien Lavenus  <a href="mailto:jl.tdcor@gmail.com">jl.tdcor@gmail.com</a>
</p>


<h3>References</h3>

<p>Lavenus <em>et al.</em>, 2015, The Plant Cell
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+CalculateDPI">CalculateDPI</a></code>,  <code><a href="#topic+CalculateTPI">CalculateTPI</a></code>, <code><a href="#topic+UpdateDPI">UpdateDPI</a></code>,  <code><a href="#topic+UpdateTPI">UpdateTPI</a></code>, <code><a href="#topic+TDCor-package">TDCor-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the lateral root transcriptomic dataset
data(LR_dataset)

# Load the vectors of gene codes, gene names and prior
data(l_genes)
data(l_names)
data(l_prior)

# Load the vector of time points for the LR_dataset
data(times)

# Generate the DPI databases

DPI15=CalculateDPI(dataset=LR_dataset,l_genes=l_genes,l_prior=l_prior,
times=times,time_step=1,N=10000,ks_int=c(0.5,3),kd_int=c(0.5,3),delta_int=c(0.5,3),
noise=0.15,delay=3)

# Generate the TPI databases

TPI10=CalculateTPI(dataset=LR_dataset,l_genes=l_genes,
l_prior=l_prior,times=times,time_step=1,N=10000,ks_int=c(0.5,3),
kd_int=c(0.5,3),delta_int=c(0.5,3),noise=0.1,delay=3)

# Check/update if necessary the databases (Not necessary here though.
# This is just to illustrate how it would work.)

TPI10=UpdateTPI(TPI10,LR_dataset,l_genes,l_prior)
DPI15=UpdateDPI(DPI15,LR_dataset,l_genes,l_prior)


### Choose your TDCOR parameters ###
 
# Parameters for time shift estimatation 
# and filter on time shift value
ptime_step=1			
ptol=0.13			 
pdelayspan=12
pdelaymax=c(2.5,3.5)
pdelaymin=0

# Parameter of the correlation filter
pthr_cor=c(0.65,0.8)

# Parameters of the ID filter
pdelay=3		
pthr_ind1=0.65			
pthr_ind2=3.5

# Parameter of the overlap filter
pthr_overlap=c(0.4,0.6)

# Parameters of the triangle and diamond filters
pthrpTPI=c(0.55,0.8)
pthrpDPI=c(0.65,0.8)	
pTPI=TPI10			
pDPI=DPI15

# Parameter for identification of self-regulations				
pthr_isr=c(4,6)

# Parameters for MRST identification			
pMinTarNumber=5			
pMinProp=0.6

# Max number of regulators		
pregmax=5

# Bootstrap parameters
pn0=1000			
pn1=10

# Name of the file to print network in
poutfile_name="TDCor_output.txt"	

### Reconstruct the network ###

tdcor_out= TDCOR(dataset=LR_dataset,l_genes=l_genes,l_names=l_names,n0=pn0,n1=pn1,
l_prior=l_prior,thr_ind1=pthr_ind1,thr_ind2=pthr_ind2,regmax=pregmax,thr_cor=pthr_cor,
delayspan=pdelayspan,delaymax=pdelaymax,delaymin=pdelaymin,delay=pdelay,thrpTPI=pthrpTPI,
thrpDPI=pthrpDPI,TPI=pTPI,DPI=pDPI,thr_isr=pthr_isr,time_step=ptime_step,
thr_overlap=pthr_overlap,tol=ptol,MinProp=pMinProp,MinTarNumber=pMinTarNumber,
outfile_name=poutfile_name)


## End(Not run)
</code></pre>

<hr>
<h2 id='TF'>
Table of 1834 Arabidopsis Transcription factors
</h2><span id='topic+TF'></span>

<h3>Description</h3>

<p><code>TF</code> is a dataframe with two columns. The first column contains the AGI gene code of 1834 genes encoding Arabidopsis transcription factors. The second column contains the associated gene names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("TF")</code></pre>


<h3>Source</h3>

<p>Data published on the Agris database website (<a href="http://arabidopsis.med.ohio-state.edu/AtTFDB/">http://arabidopsis.med.ohio-state.edu/AtTFDB/</a>).
</p>


<h3>References</h3>

<p>Davuluri <em>et al.</em> (2003), <b>AGRIS: Arabidopsis Gene Regulatory Information Server, an information resource of Arabidopsis cis-regulatory elements and transcription factors</b>, BMC Bioinformatics, <b>4</b>:25
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the database
data(TF)

# Obtain the transcription factors for which data is available in the LR dataset
# i.e. present on ATH1 chip and differentially expressed.
data(LR_dataset)
clean.at(LR_dataset,TF[,1])
</code></pre>

<hr>
<h2 id='times'>
The <code>times</code> vector to use with the lateral root dataset
</h2><span id='topic+times'></span>

<h3>Description</h3>

<p>Contains the times (in hours) at which the samples were collected to generate the Lateral Root transcriptomic dataset (<code>data(LR_dataset)</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("times")</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Load the vector associated with the LR dataset
data(times)

# Have a look at it
times
</code></pre>

<hr>
<h2 id='UpdateDPI'>
Update or check the DPI database
</h2><span id='topic+UpdateDPI'></span>

<h3>Description</h3>

<p><code>UpdateDPI</code> analyzes the DPI database and add new entries into it if it does not contain all the necessary data for reconstructing the network with the genes listed in the vector <code>l_genes</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateDPI(DPI,dataset,l_genes, l_prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpdateDPI_+3A_dpi">DPI</code></td>
<td>

<p>The DPI database to update or check before reconstructing the network.
</p>
</td></tr>
<tr><td><code id="UpdateDPI_+3A_dataset">dataset</code></td>
<td>

<p>Numerical matrix storing the transcriptomic data. The rows of this matrix must be named by gene codes (like AGI gene codes for Arabidopsis data).
</p>
</td></tr>
<tr><td><code id="UpdateDPI_+3A_l_genes">l_genes</code></td>
<td>

<p>A character vector containing the gene codes of the genes we want to reconstruct the network with.
</p>
</td></tr>
<tr><td><code id="UpdateDPI_+3A_l_prior">l_prior</code></td>
<td>

<p>A numerical vector containing the prior information on the genes included in the network recontruction. By defining the <code>l_prior</code> vector, the user defines which genes should be regarded as positive regulators, which others as negative regulators and which can only be targets. The prior code is defined as follow: -1 for negative regulator; 0 for non-regulator (target only); 1 for positive regulator; 2 for both positive and negative regulator. The i-th element of the vector is the prior to associate to the i-th gene in <code>l_genes</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>UpdateDPI</code> returns an updated DPI database containing data for at least all the genes in <code>l_genes</code> whose
associated prior is not null.
</p>


<h3>Author(s)</h3>

<p>Julien Lavenus <a href="mailto:jl.tdcor@gmail.com">jl.tdcor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+CalculateDPI">CalculateDPI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the Lateral root transcriptomic dataset
data(LR_dataset)

# Load the vector of gene codes, gene names and prior
data(l_genes)
data(l_names)
data(l_prior)

# Load the vector of time points for the LR_dataset
data(times)

# Build a very small DPI database (3 genes)
DPI_example=CalculateDPI(dataset=LR_dataset,l_genes=l_genes[4:6],l_prior=l_prior[4:6],
times=times,time_step=1,N=5000,ks_int=c(0.5,3),kd_int=c(0.5,3),delta_int=c(0.5,3),
noise=0.15,delay=3)

# Add one gene in the database
DPI_example=UpdateDPI(DPI_example,dataset=LR_dataset,l_genes[4:7],l_prior[4:7])

## End(Not run)
</code></pre>

<hr>
<h2 id='UpdateTPI'>
Update or check the TPI database
</h2><span id='topic+UpdateTPI'></span>

<h3>Description</h3>

<p><code>UpdateTPI</code> analyzes the TPI database and add new entries into it if it does not contain all the necessary data for reconstructing the network with the genes listed in the vector <code>l_genes</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateTPI(TPI, dataset, l_genes, l_prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpdateTPI_+3A_tpi">TPI</code></td>
<td>

<p>The TPI database to update or check before reconstructing the network.
</p>
</td></tr>
<tr><td><code id="UpdateTPI_+3A_dataset">dataset</code></td>
<td>

<p>Numerical matrix storing the transcriptomic data. The rows of this matrix must be named by gene codes (like AGI gene codes for Arabidopsis data).
</p>
</td></tr>
<tr><td><code id="UpdateTPI_+3A_l_genes">l_genes</code></td>
<td>

<p>A character vector containing the gene codes of the genes we want to reconstruct the network with.
</p>
</td></tr>
<tr><td><code id="UpdateTPI_+3A_l_prior">l_prior</code></td>
<td>

<p>A numerical vector containing the prior information on the genes included in the network recontruction. By defining the <code>l_prior</code> vector, the user defines which genes should be regarded as positive regulators, which others as negative regulators and which can only be targets. The prior code is defined as follow: -1 for negative regulator; 0 for non-regulator (target only); 1 for positive regulator; 2 for both positive and negative regulator. The i-th element of the vector is the prior to associate to the i-th gene in <code>l_genes</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>UpdateTPI</code> returns an updated TPI database containing data for at least all the genes in <code>l_genes</code> whose
associated prior is not null.
</p>


<h3>Author(s)</h3>

<p>Julien Lavenus <a href="mailto:jl.tdcor@gmail.com">jl.tdcor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+CalculateTPI">CalculateTPI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the Lateral root transcriptomic dataset
data(LR_dataset)

# Load the vector of gene codes, gene names and prior
data(l_genes)
data(l_names)
data(l_prior)

# Load the vector of time points for the LR_dataset
data(times)

# Build a very small TPI database (3 genes)
TPI_example=CalculateTPI(dataset=LR_dataset,l_genes=l_genes[4:6],
l_prior=l_prior[4:6],times=times,time_step=1,N=5000,ks_int=c(0.5,3),
kd_int=c(0.5,3),delta_int=c(0.5,3),noise=0.1,delay=3)

# Add one gene in the database
TPI_example=UpdateTPI(TPI_example,dataset=LR_dataset,l_genes[4:7],l_prior[4:7])

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
