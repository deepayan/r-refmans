<!DOCTYPE html><html lang="en"><head><title>Help for package smoothROCtime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smoothROCtime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#smoothROCtime-package'><p>Smooth Time-Dependent ROC Curve Estimation</p></a></li>
<li><a href='#funcen'><p>Bivariate kernel density estimation under random censoring</p></a></li>
<li><a href='#plot.sROCt'><p>Plots of time-dependent ROC curve estimations</p></a></li>
<li><a href='#stRoc'><p>Smooth Time-dependent ROC curve estimations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Smooth Time-Dependent ROC Curve Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Susana Diaz-Coto &lt;UO266718@uniovi.es&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Susana Diaz-Coto &lt;UO266718@uniovi.es&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>ks</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KMsurv,lattice, survival</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes smooth estimations for the Cumulative/Dynamic and Incident/Dynamic ROC curves, in presence of right censorship, based on the bivariate kernel density estimation of the joint distribution function of the Marker and Time-to-event variables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-03 02:20:09 UTC; SUSANA</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-11-14 10:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='smoothROCtime-package'> Smooth Time-Dependent ROC Curve Estimation
</h2><span id='topic+smoothROCtime-package'></span><span id='topic+smoothROCtime'></span>

<h3>Description</h3>

<p>Computes smooth estimations for the Cumulative/Dynamic and Incident/Dynamic ROC curves, in presence of right censorship, based on the bivariate kernel density estimation of the joint distribution function of the Marker and Time-to-event variables.
</p>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+funcen">funcen</a></code>: Bivariate kernel density estimation of the joint density function of the <code class="reqn">(marker, time-to-event)</code> variable.
</p>
</li>
<li> <p><code><a href="#topic+stRoc">stRoc</a></code>: Smooth estimations for Cumulative/Dynamic and Incident/Dynamic ROC curves.
</p>
</li>
<li> <p><code><a href="#topic+plot.sROCt">plot.sROCt</a></code>: Plots of Cumulative/Dynamic and Incident/Dyanmic ROC curve estimations.
</p>
</li></ul>




<h3>Author(s)</h3>

<p>Susana Diaz-Coto &lt;UO266718@uniovi.es&gt;
</p>
<p>Maintainer: Susana Diaz-Coto &lt;UO266718@uniovi.es&gt;
</p>


<h3>References</h3>

<p>P. Martinez-Camblor and J. C. Pardo-Fernandez. Smooth time-dependent receiver operating characteristic
curve estimators. Statistical Methods in Medical Research, 27(3):651-674, 2018.
<a href="https://doi.org/10.1177/0962280217740786">https://doi.org/10.1177/0962280217740786</a>.
</p>
<p>P. Martinez-Camblor, G. F-Bayon, and S. Perez-Fernandez. Cumulative/dynamic ROC curve estimation.
JOURNAL of Statistical Computation and Simulation, 86(17):3582-3594, 2016.
<a href="https://doi.org/10.1080/00949655.2016.1175442">https://doi.org/10.1080/00949655.2016.1175442</a>.
</p>
<p>T. Duong. Bandwidth matrices for multivariate kernel density estimation. Ph.D. Thesis, University of
Western, Australia, 2004.
</p>
<p>L. Li, T. Green, and B. Hu. A simple method to estimate the time-dependent receiver operating
characteristic curve and the area under the curve with right censored data. Statistical Methods in
Medical Research, 27(8), 2016. <a href="https://doi.org/10.1177/0962280216680239">https://doi.org/10.1177/0962280216680239</a>.
</p>


<h3>See Also</h3>

<p>CRAN package <code><a href="ks.html#topic+ks">ks</a></code> is used in this package.
</p>

<hr>
<h2 id='funcen'>Bivariate kernel density estimation under random censoring</h2><span id='topic+funcen'></span>

<h3>Description</h3>

<p>Computes the kernel density estimation of the bivariate vector <code class="reqn">(marker, time-to-event)</code> with the time-to-event variable subject to right censorship, according to the procedure exposed in <a href="https://doi.org/10.1177/0962280217740786">https://doi.org/10.1177/0962280217740786</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcen(data, H, bw, adj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="funcen_+3A_data">data</code></td>
<td>
<p>matrix with three columns: time-to-event, censoring status (0=censored/1=uncensored) and marker.</p>
</td></tr>
<tr><td><code id="funcen_+3A_h">H</code></td>
<td>
<p>2x2 bandwidth matrix when it is specified in an explicit way.</p>
</td></tr>
<tr><td><code id="funcen_+3A_bw">bw</code></td>
<td>
<p>method for computing the bandwidth matrix. Most of the methods included in the <code><a href="ks.html#topic+kde">kde</a></code> function can be used: Hpi, Hpi.diag, Hlscv, Hlscv.diag, Hbcv, Hbcv.diag, Hscv, Hscv.diag, Hucv and Hucv.diag. Other considered methods are naive.pdf (diag(N^-1/5, N^-1/5)^2) and naive.cdf (diag(N^-1/3, N^-1/3)^2), where N is the sample size.</p>
</td></tr>
<tr><td><code id="funcen_+3A_adj">adj</code></td>
<td>
<p>adjusment parameter for calculating the bandwidth matrix. Default value 1.</p>
</td></tr>
<tr><td><code id="funcen_+3A_...">...</code></td>
<td>
<p><code><a href="ks.html#topic+kde">kde</a></code> function arguments can also be used for specifying the way in which the kernel density function estimation should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix of bandwidths can be defined by using H=matrix() or automatically selected by the method indicated in bw.
</p>
<p>Given the matrix of bandwidths, H, the argument adj modifies it and the final computed matrix is adj^2 H.
</p>
<p>If H is missing, the naive.pdf method is used for obtaining the kernel density estimation.
</p>
<p>Function <code>funcen</code> generates, from the original set of data, a collection of pseudodata through an iterative  weights allocation process, with two main goals: keep the information from the censored observations represented in the sample and prepare data so they can be used as incoming parameters in the <code><a href="ks.html#topic+kde">kde</a></code> function included in the <span class="pkg">ks</span> package. A weighted kernel density estimation is therefore finally computed.
</p>
<p>There should be at least two uncensored observations for computing the density estimation.
</p>
<p>Omitted parameters are considered to be the default ones in the <code><a href="ks.html#topic+kde">kde</a></code> function.</p>


<h3>Value</h3>

<p>An object  of class <code><a href="ks.html#topic+kde">kde</a></code> is returned. It is a list where the most relevant values are:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>matrix containing the pseudodata values. It has two columns: marker and time-to-event.</p>
</td></tr>
<tr><td><code>eval.points</code></td>
<td>
<p>list of points where the bivariate kernel estimation is calculated.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>values of the density estimation.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>bandwidth matrix.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>variable names.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>weights calculated by the function and allocated to pseudodata.</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Martinez-Camblor and J. C. Pardo-Fernandez. Smooth time-dependent receiver operating characteristic
curve estimators. Statistical Methods in Medical Research, 27(3):651-674, 2018. <a href="https://doi.org/10.1177/0962280217740786">https://doi.org/10.1177/0962280217740786</a>.

</p>
<p>T. Duong. Bandwidth matrices for multivariate kernel density estimation. Ph.D. Thesis, University of
Western, Australia, 2004. <a href="http://www.mvstat.net/tduong">http://www.mvstat.net/tduong</a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(smoothROCtime)
require(KMsurv)
require(lattice)

data(kidtran)

# Preparing data: a logarithmic transformationof the time-to-event variable is made
  DT &lt;- cbind(log(kidtran$time),kidtran$delta,kidtran$age)
  n  &lt;-length(log(kidtran$time))

# Directly definition of the bandwidth matrix
  H  &lt;- diag((c(sd(kidtran$age),sd(log(kidtran$time)))*n^(-0.2))^2)

# Kernel density function estimation
  density &lt;- funcen(data=DT,H=H)

# Plot graphics
  wireframe(density$estimate, row.values=density$eval.points[[1]],
            column.values=density$eval.points[[1]],zlab="density")
  contour(x=density$eval.points[[1]],
          y=density$eval.points[[2]],
          z=density$estimate,
          ylim=c(6,10))
</code></pre>

<hr>
<h2 id='plot.sROCt'>Plots of time-dependent ROC curve estimations</h2><span id='topic+plot.sROCt'></span>

<h3>Description</h3>

<p>Plots of both Cumulative and Incident/Dynamic ROC curve estimations, provided by function <code><a href="#topic+stRoc">stRoc</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sROCt'
plot(x, tcr, xlab, ylab, type = "l", lwd = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sROCt_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+stRoc">sROCt</a> generated with <code><a href="#topic+stRoc">stRoc</a></code> function and containing the estimations of the time-dependent ROC curves for one single point or a vector of points.</p>
</td></tr>
<tr><td><code id="plot.sROCt_+3A_tcr">tcr</code></td>
<td>
<p>type of time-dependent ROC curve estimation that will be plotted:</p>

<ul>
<li> <p>&ldquo;C&rdquo; for <b>C</b>umulative/Dynamic,
</p>
</li>
<li> <p>&ldquo;I&rdquo; for <b>I</b>ncident/Dynamic,
</p>
</li>
<li> <p>&ldquo;B&rdquo; for <b>B</b>oth time-dependent ROC curve estimations.</p>
</li></ul>

</td></tr>
<tr><td><code id="plot.sROCt_+3A_xlab">xlab</code></td>
<td>
<p>a tittle for the x axis. The default value is &quot;False - Positive Rate&quot;.</p>
</td></tr>
<tr><td><code id="plot.sROCt_+3A_ylab">ylab</code></td>
<td>
<p>a tittle for the y axis. The default value is &quot;True - Negative Rate&quot;.</p>
</td></tr>
<tr><td><code id="plot.sROCt_+3A_type">type</code></td>
<td>
<p>what type of plot is going to be drawn. The default value is &quot;l&quot; and a line will be plotted.</p>
</td></tr>
<tr><td><code id="plot.sROCt_+3A_lwd">lwd</code></td>
<td>
<p>line width. As a default value &quot;5&quot; is taken.</p>
</td></tr>
<tr><td><code id="plot.sROCt_+3A_...">...</code></td>
<td>
<p><a href="base.html#topic+plot">plot</a> function arguments can also be used for customizing the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameter <code>tcr</code> is mandatory with no default values. If a &quot;B&quot; is indicated and the <a href="#topic+stRoc">sROCt</a> object placed as <code>x</code> parameter contains only one type of time-dependent ROC curve estimation, an error message will be returned. Another error message will appear in case of placing either &quot;C&quot; or &quot;I&quot; when the <a href="#topic+stRoc">sROCt</a> object does not contain the suitable ROC curve estimation.
</p>
<p>When one single type of ROC curve estimation is chosen, one graphic will be drawn for each point of time in the <a href="#topic+stRoc">sROCt</a> object, having as many independent plots as number of points of time. Graphic parameters like axis labels or line width will be the same for all the plots.
</p>
<p>In case of choosing both time-dependent ROC curve estimations, they will be plotted in a single graphic for each point of time in <a href="#topic+stRoc">sROCt</a> object. As before, we will have as many independent plots as points of time and the graphic parameters will be the same in all plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(smoothROCtime)
require(survival)

# Monoclonal Gammapothy of Undetermined Significance dataset
  data(mgus)

# Time-to-event
  time   &lt;- ifelse(is.na(mgus$pctime), mgus$futime,mgus$pctime)

# Status
  status &lt;- ifelse(is.na(mgus$pctime), 0, 1)

# Preparing data
  DT &lt;-as.data.frame(cbind(log(time), status, mgus$alb))
  colnames(DT) &lt;- c("futime", "pcm", "alb")
  dta &lt;-  na.omit(cbind(DT$futime, DT$pcm, -DT$alb))

# Point of Time
  t10 &lt;- log(10*365.25) # ten years in logarithm scale

# Cumulative/Dynamic and Incident dynamic ROC curve estimations at t=10 years
  rcu &lt;- stRoc(data=dta, t=t10, tcr="B", meth = "1", verbose=TRUE)

# Plots of both ROC curve estimations
  plot(rcu, tcr="B", frame=FALSE)
</code></pre>

<hr>
<h2 id='stRoc'>Smooth Time-dependent ROC curve estimations</h2><span id='topic+stRoc'></span>

<h3>Description</h3>

<p>Provides smooth estimations of <b>Cumulative/Dynamic (C/D)</b> and <b>Incident/Dynamic (I/D)</b> ROC curves in presence of rigth censorship and the corresponding Areas Under the Curves (AUCs), at a single point of time or a vector of points.
</p>

<ul>
<li> <p>The function computes two different procedures to obtain smooth estimations of the <b>C/D ROC curve</b>. Both are based on the kernel density estimation of the joint distribution function of the marker and time-to-event variables, provided by <code><a href="#topic+funcen">funcen</a></code> function. The first method, to which we will refere as <b>smooth method</b>, is carried out according to the methodology proposed in <a href="https://doi.org/10.1177/0962280217740786">https://doi.org/10.1177/0962280217740786</a>. The second one uses this estimation of the joint density function of the variables marker and time-to-event for computing the weights or probabilities allocated to censored observations (undefined individuals) in <a href="https://doi.org/10.1080/00949655.2016.1175442">https://doi.org/10.1080/00949655.2016.1175442</a> and <a href="https://doi.org/10.1177/0962280216680239">https://doi.org/10.1177/0962280216680239</a>. It will be referred as <b>p-kernel</b> method.
</p>
</li>
<li> <p>In case of the <b>I/D ROC curve</b>, a smooth approximation procedure (<b>smooth method</b>) is computed based as well on the kernel density estimation of the joint distribution function of the marker and time-to-event variables proposed in <a href="https://doi.org/10.1177/0962280217740786">https://doi.org/10.1177/0962280217740786</a> </p>
</li></ul>


<h3>Usage</h3>

<pre><code class='language-R'>stRoc(data, t, H, bw, adj, tcr, meth, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stRoc_+3A_data">data</code></td>
<td>
<p>matrix of data values with three columns: time-to-event, censoring status (0=censored/1=uncensored) and marker.</p>
</td></tr>
<tr><td><code id="stRoc_+3A_t">t</code></td>
<td>
<p>point of time or vector of points where the time-dependent ROC curve is estimated.</p>
</td></tr>
<tr><td><code id="stRoc_+3A_h">H</code></td>
<td>
<p>2x2 bandwidth matrix.</p>
</td></tr>
<tr><td><code id="stRoc_+3A_bw">bw</code></td>
<td>
<p>procedure for computing the bandwidth matrix. Most of the methods included at the <code>kde</code> function can be used: Hpi, Hpi.diag, Hlscv, Hlscv.diag, Hbcv, Hbcv.diag, Hscv, Hscv.diag, Hucv and Hucv.diag. Other considered methods are naive.pdf (diag(N^-1/5, N^-1/5)^2) and naive.cdf (diag(N^-1/3, N^-1/3)^2), where N is the sample size.</p>
</td></tr>
<tr><td><code id="stRoc_+3A_adj">adj</code></td>
<td>
<p>adjusment parameter for calculating the bandwidth matrix. Default value 1.</p>
</td></tr>
<tr><td><code id="stRoc_+3A_tcr">tcr</code></td>
<td>
<p>type of time-dependent ROC curve estimation that will be estimated:
</p>

<ul>
<li> <p>&ldquo;C&rdquo; for <b>C</b>umulative/Dynamic,
</p>
</li>
<li> <p>&ldquo;I&rdquo; for <b>I</b>ncident/Dynamic,
</p>
</li>
<li> <p>&ldquo;B&rdquo; for <b>B</b>oth time-dependent ROC curve estimations.</p>
</li></ul>

</td></tr>
<tr><td><code id="stRoc_+3A_meth">meth</code></td>
<td>
<p>method for computing the estimation of the C/D ROC curve.The suitable values are:
</p>

<ul>
<li> <p>&ldquo;1&rdquo; for the smooth method,
</p>
</li>
<li> <p>&ldquo;2&rdquo; for the p-kernel method.</p>
</li></ul>

<p>As default value the smooth method is taken.</p>
</td></tr>
<tr><td><code id="stRoc_+3A_...">...</code></td>
<td>
<p><code><a href="ks.html#topic+kde">kde</a></code> function arguments can be used for estimating the bivariate kernel density function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+funcen">funcen</a></code> is called from each execution of function <code>stRoc</code>, in order to compute the kernel
density estimation of the joint distribution of the (Marker, Time-to-event) variable, therefore, the input
parameters in <code><a href="#topic+funcen">funcen</a></code> are input parameters as well in <code>stRoc</code> and the same considerations apply.
</p>
<p>The matrix of bandwidths can be defined by using H=matrix() or automatically selected by the method indicated in <code>bw</code>.
</p>
<p>Given the matrix of bandwidths, H, the argument <code>adj</code> modifies it and the final matrix is adj^2 H.
</p>
<p>If <code>H</code> is missing, the naive.pdf method is used.
</p>
<p>If <code>tcr</code> is missing the C/D ROC curve estimation will be computed with the method indicated in <code>meth</code>.
</p>
<p>If no value has been placed in <code>meth</code> the smooth method will be used. The I/D ROC curve estimation will be always computed with the smooth method.
</p>


<h3>Value</h3>

<p>An object of class <code>sROCt</code> is returned. It is a list with the following values:
</p>
<table role = "presentation">
<tr><td><code>th</code></td>
<td>
<p>considered thresholds for the marker.</p>
</td></tr>
<tr><td><code>FP</code></td>
<td>
<p>false-positive rate calculated at each point in <code>th</code>.</p>
</td></tr>
<tr><td><code>TP</code></td>
<td>
<p>true-positive rate estimated at each point in <code>th</code>.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>points where the time-dependent ROC curve is evaluated.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>time-dependent ROC curve values computed at <code>p</code>.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>time/s at which each time-dependent ROC curve estimation is computed. Each point ot time will appear as many times as the length of the vector of points <code>p</code>.</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>area under the corresponding time-dependent ROC curve estimation. As in the previous case, each value appears as many times as the length of the vector of points <code>p</code>.</p>
</td></tr>
<tr><td><code>tcr</code></td>
<td>
<p>type of time-dependent ROC curve estimation computed,
</p>

<ul>
<li> <p>&ldquo;C&rdquo; - <b>C</b>umulative/Dynamic.
</p>
</li>
<li> <p>&ldquo;I&rdquo; - <b>I</b>ncident/Dynamic.
</p>
</li></ul>

<p>For each computed time-dependent ROC curve estimation this value is repeated as many times as the length of <code>p</code>.
</p>
</td></tr>
<tr><td><code>Pi</code></td>
<td>
<p>probabilities calculated for the individuals in the sample if the p-kernel method has been used for the estimation of the C/D ROC curve. This element is a matrix with the following columns:
</p>

<ul>
<li> <p><code>time</code> - single point of time at which the estimation each the C/D ROC curve has been computed.
</p>
</li>
<li> <p><code>obvt</code> - observed times for the individuals in the sample.
</p>
</li>
<li> <p><code>p</code> - estimations of the probabilities computed and allocated to each subject.
</p>
</li></ul>

</td></tr>
</table>


<h3>References</h3>

<p>P. Martinez-Camblor and J. C. Pardo-Fernandez. Smooth time-dependent receiver operating characteristic
curve estimators. Statistical Methods in Medical Research, 27(3):651-674, 2018.<a href="https://doi.org/10.1177/0962280217740786">https://doi.org/10.1177/0962280217740786</a>.

</p>
<p>P. Martinez-Camblor, G. F-Bay?n, and S. P?rez-Fern?ndez. Cumulative/dynamic ROC curve estimation.
JOURNAL of Statistical Computation and Simulation, 86(17):3582-3594, 2016. <a href="https://doi.org/10.1080/00949655.2016.1175442">https://doi.org/10.1080/00949655.2016.1175442</a>.

</p>
<p>L. Li, T. Green, and B. Hu. A simple method to estimate the time-dependent receiver operating
characteristic curve and the area under the curve with right censored data. Statistical Methods in
Medical Research, 27(8), 2016. <a href="https://doi.org/10.1177/0962280216680239">https://doi.org/10.1177/0962280216680239</a>.

</p>
<p>T. Duong. Bandwidth matrices for multivariate kernel density estimation. Ph.D. Thesis, University of
Western, Australia, 2004. <a href="http://www.mvstat.net/tduong">http://www.mvstat.net/tduong</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(smoothROCtime)
require(KMsurv)

data(kidtran)

# Preparing data: a logarithmic transformation of the time-to-event variable is made
  DT &lt;- cbind(log(kidtran$time),kidtran$delta,kidtran$age)

# Point of Time
  t5 &lt;- log(5*365.25) # five years in logarithm scale

# Cumulative/dynamic ROC curve estimation
  rcd &lt;- stRoc(data=DT, t=t5, bw="Hpi", tcr="C", meth=2)

# Plot graphic
  plot(rcd$p, rcd$ROC, type="l", lwd=5, main="C/D ROC",xlab="FPR",ylab="TPR")
  lines(c(0,1),c(0,1),lty=2,col="gray")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
