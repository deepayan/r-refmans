<!DOCTYPE html><html><head><title>Help for package mice</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mice}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.pmm.match'><p>Finds an imputed value from matches in the predictive metric (deprecated)</p></a></li>
<li><a href='#ampute'><p>Generate missing data for simulation purposes</p></a></li>
<li><a href='#ampute.continuous'><p>Multivariate amputation based on continuous probability functions</p></a></li>
<li><a href='#ampute.default.freq'><p>Default <code>freq</code> in <code>ampute</code></p></a></li>
<li><a href='#ampute.default.odds'><p>Default <code>odds</code> in <code>ampute()</code></p></a></li>
<li><a href='#ampute.default.patterns'><p>Default <code>patterns</code> in <code>ampute</code></p></a></li>
<li><a href='#ampute.default.type'><p>Default <code>type</code> in <code>ampute()</code></p></a></li>
<li><a href='#ampute.default.weights'><p>Default <code>weights</code> in <code>ampute</code></p></a></li>
<li><a href='#ampute.discrete'><p>Multivariate amputation based on discrete probability functions</p></a></li>
<li><a href='#ampute.mcar'><p>Multivariate amputation under a MCAR mechanism</p></a></li>
<li><a href='#anova.mira'><p>Compare several nested models</p></a></li>
<li><a href='#appendbreak'><p>Appends specified break to the data</p></a></li>
<li><a href='#as.mids'><p>Converts an imputed dataset (long format) into a <code>mids</code> object</p></a></li>
<li><a href='#as.mira'><p>Create a <code>mira</code> object from repeated analyses</p></a></li>
<li><a href='#as.mitml.result'><p>Converts into a <code>mitml.result</code> object</p></a></li>
<li><a href='#boys'><p>Growth of Dutch boys</p></a></li>
<li><a href='#brandsma'><p>Brandsma school data used Snijders and Bosker (2012)</p></a></li>
<li><a href='#bwplot.mads'><p>Box-and-whisker plot of amputed and non-amputed data</p></a></li>
<li><a href='#bwplot.mids'><p>Box-and-whisker plot of observed and imputed data</p></a></li>
<li><a href='#cbind'><p>Combine R objects by rows and columns</p></a></li>
<li><a href='#cc'><p>Select complete cases</p></a></li>
<li><a href='#cci'><p>Complete case indicator</p></a></li>
<li><a href='#complete.mids'><p>Extracts the completed data from a <code>mids</code> object</p></a></li>
<li><a href='#construct.blocks'><p>Construct blocks from <code>formulas</code> and <code>predictorMatrix</code></p></a></li>
<li><a href='#convergence'><p>Computes convergence diagnostics for a <code>mids</code> object</p></a></li>
<li><a href='#D1'><p>Compare two nested models using D1-statistic</p></a></li>
<li><a href='#D2'><p>Compare two nested models using D2-statistic</p></a></li>
<li><a href='#D3'><p>Compare two nested models using D3-statistic</p></a></li>
<li><a href='#densityplot.mids'><p>Density plot of observed and imputed data</p></a></li>
<li><a href='#employee'><p>Employee selection data</p></a></li>
<li><a href='#estimice'><p>Computes least squares parameters</p></a></li>
<li><a href='#extend.formula'><p>Extends a formula with predictors</p></a></li>
<li><a href='#extend.formulas'><p>Extends formula's with predictor matrix settings</p></a></li>
<li><a href='#extractBS'><p>Extract broken stick estimates from a <code>lmer</code> object</p></a></li>
<li><a href='#fdd'><p>SE Fireworks disaster data</p></a></li>
<li><a href='#fdgs'><p>Fifth Dutch growth study 2009</p></a></li>
<li><a href='#fico'><p>Fraction of incomplete cases among cases with observed</p></a></li>
<li><a href='#filter.mids'><p>Subset rows of a <code>mids</code> object</p></a></li>
<li><a href='#fix.coef'><p>Fix coefficients and update model</p></a></li>
<li><a href='#flux'><p>Influx and outflux of multivariate missing data patterns</p></a></li>
<li><a href='#fluxplot'><p>Fluxplot of the missing data pattern</p></a></li>
<li><a href='#futuremice'><p>Wrapper function that runs MICE in parallel</p></a></li>
<li><a href='#getfit'><p>Extract list of fitted models</p></a></li>
<li><a href='#getqbar'><p>Extract estimate from <code>mipo</code> object</p></a></li>
<li><a href='#glance.mipo'><p>Glance method to extract information from a 'mipo' object</p></a></li>
<li><a href='#glm.mids'><p>Generalized linear model for <code>mids</code> object</p></a></li>
<li><a href='#ibind'><p>Enlarge number of imputations by combining <code>mids</code> objects</p></a></li>
<li><a href='#ic'><p>Select incomplete cases</p></a></li>
<li><a href='#ici'><p>Incomplete case indicator</p></a></li>
<li><a href='#ifdo'><p>Conditional imputation helper</p></a></li>
<li><a href='#is.mads'><p>Check for <code>mads</code> object</p></a></li>
<li><a href='#is.mids'><p>Check for <code>mids</code> object</p></a></li>
<li><a href='#is.mipo'><p>Check for <code>mipo</code> object</p></a></li>
<li><a href='#is.mira'><p>Check for <code>mira</code> object</p></a></li>
<li><a href='#is.mitml.result'><p>Check for <code>mitml.result</code> object</p></a></li>
<li><a href='#leiden85'><p>Leiden 85+ study</p></a></li>
<li><a href='#lm.mids'><p>Linear regression for <code>mids</code> object</p></a></li>
<li><a href='#mads-class'><p>Multivariate amputed data set (<code>mads</code>)</p></a></li>
<li><a href='#make.blocks'><p>Creates a <code>blocks</code> argument</p></a></li>
<li><a href='#make.blots'><p>Creates a <code>blots</code> argument</p></a></li>
<li><a href='#make.formulas'><p>Creates a <code>formulas</code> argument</p></a></li>
<li><a href='#make.method'><p>Creates a <code>method</code> argument</p></a></li>
<li><a href='#make.post'><p>Creates a <code>post</code> argument</p></a></li>
<li><a href='#make.predictorMatrix'><p>Creates a <code>predictorMatrix</code> argument</p></a></li>
<li><a href='#make.visitSequence'><p>Creates a <code>visitSequence</code> argument</p></a></li>
<li><a href='#make.where'><p>Creates a <code>where</code> argument</p></a></li>
<li><a href='#mammalsleep'><p>Mammal sleep data</p></a></li>
<li><a href='#matchindex'><p>Find index of matched donor units</p></a></li>
<li><a href='#mcar'><p>Jamshidian and Jalal's Non-Parametric MCAR Test</p></a></li>
<li><a href='#md.pairs'><p>Missing data pattern by variable pairs</p></a></li>
<li><a href='#md.pattern'><p>Missing data pattern</p></a></li>
<li><a href='#mdc'><p>Graphical parameter for missing data plots</p></a></li>
<li><a href='#mice'><p><span class="pkg">mice</span>: Multivariate Imputation by Chained Equations</p></a></li>
<li><a href='#mice.impute.2l.bin'><p>Imputation by a two-level logistic model using <code>glmer</code></p></a></li>
<li><a href='#mice.impute.2l.lmer'><p>Imputation by a two-level normal model using <code>lmer</code></p></a></li>
<li><a href='#mice.impute.2l.norm'><p>Imputation by a two-level normal model</p></a></li>
<li><a href='#mice.impute.2l.pan'><p>Imputation by a two-level normal model using <code>pan</code></p></a></li>
<li><a href='#mice.impute.2lonly.mean'><p>Imputation of most likely value within the class</p></a></li>
<li><a href='#mice.impute.2lonly.norm'><p>Imputation at level 2 by Bayesian linear regression</p></a></li>
<li><a href='#mice.impute.2lonly.pmm'><p>Imputation at level 2 by predictive mean matching</p></a></li>
<li><a href='#mice.impute.cart'><p>Imputation by classification and regression trees</p></a></li>
<li><a href='#mice.impute.jomoImpute'><p>Multivariate multilevel imputation using <code>jomo</code></p></a></li>
<li><a href='#mice.impute.lasso.logreg'><p>Imputation by direct use of lasso logistic regression</p></a></li>
<li><a href='#mice.impute.lasso.norm'><p>Imputation by direct use of lasso linear regression</p></a></li>
<li><a href='#mice.impute.lasso.select.logreg'><p>Imputation by indirect use of lasso logistic regression</p></a></li>
<li><a href='#mice.impute.lasso.select.norm'><p>Imputation by indirect use of lasso linear regression</p></a></li>
<li><a href='#mice.impute.lda'><p>Imputation by linear discriminant analysis</p></a></li>
<li><a href='#mice.impute.logreg'><p>Imputation by logistic regression</p></a></li>
<li><a href='#mice.impute.logreg.boot'><p>Imputation by logistic regression using the bootstrap</p></a></li>
<li><a href='#mice.impute.mean'><p>Imputation by the mean</p></a></li>
<li><a href='#mice.impute.midastouch'><p>Imputation by predictive mean matching with distance aided donor selection</p></a></li>
<li><a href='#mice.impute.mnar.logreg'><p>Imputation under MNAR mechanism by NARFCS</p></a></li>
<li><a href='#mice.impute.mpmm'><p>Imputation by multivariate predictive mean matching</p></a></li>
<li><a href='#mice.impute.norm'><p>Imputation by Bayesian linear regression</p></a></li>
<li><a href='#mice.impute.norm.boot'><p>Imputation by linear regression, bootstrap method</p></a></li>
<li><a href='#mice.impute.norm.nob'><p>Imputation by linear regression without parameter uncertainty</p></a></li>
<li><a href='#mice.impute.norm.predict'><p>Imputation by linear regression through prediction</p></a></li>
<li><a href='#mice.impute.panImpute'><p>Impute multilevel missing data using <code>pan</code></p></a></li>
<li><a href='#mice.impute.passive'><p>Passive imputation</p></a></li>
<li><a href='#mice.impute.pmm'><p>Imputation by predictive mean matching</p></a></li>
<li><a href='#mice.impute.polr'><p>Imputation of ordered data by polytomous regression</p></a></li>
<li><a href='#mice.impute.polyreg'><p>Imputation of unordered data by polytomous regression</p></a></li>
<li><a href='#mice.impute.quadratic'><p>Imputation of quadratic terms</p></a></li>
<li><a href='#mice.impute.rf'><p>Imputation by random forests</p></a></li>
<li><a href='#mice.impute.ri'><p>Imputation by the random indicator method for nonignorable data</p></a></li>
<li><a href='#mice.impute.sample'><p>Imputation by simple random sampling</p></a></li>
<li><a href='#mice.mids'><p>Multivariate Imputation by Chained Equations (Iteration Step)</p></a></li>
<li><a href='#mice.theme'><p>Set the theme for the plotting Trellis functions</p></a></li>
<li><a href='#mids-class'><p>Multiply imputed data set (<code>mids</code>)</p></a></li>
<li><a href='#mids2mplus'><p>Export <code>mids</code> object to Mplus</p></a></li>
<li><a href='#mids2spss'><p>Export <code>mids</code> object to SPSS</p></a></li>
<li><a href='#mipo'><p><code>mipo</code>: Multiple imputation pooled object</p></a></li>
<li><a href='#mira-class'><p>Multiply imputed repeated analyses (<code>mira</code>)</p></a></li>
<li><a href='#mnar_demo_data'><p>MNAR demo data</p></a></li>
<li><a href='#name.blocks'><p>Name imputation blocks</p></a></li>
<li><a href='#name.formulas'><p>Name formula list elements</p></a></li>
<li><a href='#ncc'><p>Number of complete cases</p></a></li>
<li><a href='#nelsonaalen'><p>Cumulative hazard rate or Nelson-Aalen estimator</p></a></li>
<li><a href='#nhanes'><p>NHANES example - all variables numerical</p></a></li>
<li><a href='#nhanes2'><p>NHANES example - mixed numerical and discrete variables</p></a></li>
<li><a href='#nic'><p>Number of incomplete cases</p></a></li>
<li><a href='#nimp'><p>Number of imputations per block</p></a></li>
<li><a href='#norm.draw'><p>Draws values of beta and sigma by Bayesian linear regression</p></a></li>
<li><a href='#parlmice'><p>Wrapper function that runs MICE in parallel</p></a></li>
<li><a href='#pattern'><p>Datasets with various missing data patterns</p></a></li>
<li><a href='#plot.mids'><p>Plot the trace lines of the MICE algorithm</p></a></li>
<li><a href='#pool'><p>Combine estimates by pooling rules</p></a></li>
<li><a href='#pool.compare'><p>Compare two nested models fitted to imputed data</p></a></li>
<li><a href='#pool.r.squared'><p>Pools R^2 of m models fitted to multiply-imputed data</p></a></li>
<li><a href='#pool.scalar'><p>Multiple imputation pooling: univariate version</p></a></li>
<li><a href='#popmis'><p>Hox pupil popularity data with missing popularity scores</p></a></li>
<li><a href='#pops'><p>Project on preterm and small for gestational age infants (POPS)</p></a></li>
<li><a href='#potthoffroy'><p>Potthoff-Roy data</p></a></li>
<li><a href='#print.mads'><p>Print a <code>mads</code> object</p></a></li>
<li><a href='#print.mids'><p>Print a <code>mids</code> object</p></a></li>
<li><a href='#quickpred'><p>Quick selection of predictors from the data</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#selfreport'><p>Self-reported and measured BMI</p></a></li>
<li><a href='#squeeze'><p>Squeeze the imputed values to be within specified boundaries.</p></a></li>
<li><a href='#stripplot.mids'><p>Stripplot of observed and imputed data</p></a></li>
<li><a href='#summary.mira'><p>Summary of a <code>mira</code> object</p></a></li>
<li><a href='#supports.transparent'><p>Supports semi-transparent foreground colors?</p></a></li>
<li><a href='#tbc'><p>Terneuzen birth cohort</p></a></li>
<li><a href='#tidy.mipo'><p>Tidy method to extract results from a 'mipo' object</p></a></li>
<li><a href='#toenail'><p>Toenail data</p></a></li>
<li><a href='#toenail2'><p>Toenail data</p></a></li>
<li><a href='#version'><p>Echoes the package version number</p></a></li>
<li><a href='#walking'><p>Walking disability data</p></a></li>
<li><a href='#windspeed'><p>Subset of Irish wind speed data</p></a></li>
<li><a href='#with.mids'><p>Evaluate an expression in multiple imputed datasets</p></a></li>
<li><a href='#xyplot.mads'><p>Scatterplot of amputed and non-amputed data against weighted sum scores</p></a></li>
<li><a href='#xyplot.mids'><p>Scatterplot of observed and imputed data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>3.16.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Imputation by Chained Equations</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-24</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stef van Buuren &lt;stef.vanbuuren@tno.nl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, dplyr, generics, glmnet, graphics, grDevices, lattice,
methods, mitml, nnet, Rcpp, rpart, rlang, stats, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom.mixed, future, furrr, haven, knitr, lme4, MASS,
miceadds, pan, parallelly, purrr, ranger, randomForest,
rmarkdown, rstan, survival, testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple imputation using Fully Conditional Specification (FCS)
    implemented by the MICE algorithm as described in Van Buuren and
    Groothuis-Oudshoorn (2011) &lt;<a href="https://doi.org/10.18637%2Fjss.v045.i03">doi:10.18637/jss.v045.i03</a>&gt;. Each variable has
    its own imputation model. Built-in imputation models are provided for
    continuous data (predictive mean matching, normal), binary data (logistic
    regression), unordered categorical data (polytomous logistic regression)
    and ordered categorical data (proportional odds). MICE can also impute
    continuous two-level data (normal model, pan, second-level variables).
    Passive imputation can be used to maintain consistency between variables.
    Various diagnostic plots are available to inspect the quality of the
    imputations.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/amices/mice">https://github.com/amices/mice</a>, <a href="https://amices.org/mice/">https://amices.org/mice/</a>,
<a href="https://stefvanbuuren.name/fimd/">https://stefvanbuuren.name/fimd/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/amices/mice/issues">https://github.com/amices/mice/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11, Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-04 21:03:06 UTC; buurensv</td>
</tr>
<tr>
<td>Author:</td>
<td>Stef van Buuren [aut, cre],
  Karin Groothuis-Oudshoorn [aut],
  Gerko Vink [ctb],
  Rianne Schouten [ctb],
  Alexander Robitzsch [ctb],
  Patrick Rockenschaub [ctb],
  Lisa Doove [ctb],
  Shahab Jolani [ctb],
  Margarita Moreno-Betancur [ctb],
  Ian White [ctb],
  Philipp Gaffert [ctb],
  Florian Meinfelder [ctb],
  Bernie Gray [ctb],
  Vincent Arel-Bundock [ctb],
  Mingyang Cai [ctb],
  Thom Volker [ctb],
  Edoardo Costantini [ctb],
  Caspar van Lissa [ctb],
  Hanne Oberman [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-05 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.pmm.match'>Finds an imputed value from matches in the predictive metric (deprecated)</h2><span id='topic+.pmm.match'></span>

<h3>Description</h3>

<p>This function finds matches among the observed data in the predictive
mean metric. It selects the <code>donors</code> closest matches, randomly
samples one of the donors, and returns the observed value of the
match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pmm.match(z, yhat = yhat, y = y, donors = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pmm.match_+3A_z">z</code></td>
<td>
<p>A scalar containing the predicted value for the current case
to be imputed.</p>
</td></tr>
<tr><td><code id=".pmm.match_+3A_yhat">yhat</code></td>
<td>
<p>A vector containing the predicted values for all cases with an observed
outcome.</p>
</td></tr>
<tr><td><code id=".pmm.match_+3A_y">y</code></td>
<td>
<p>A vector of <code>length(yhat)</code> elements containing the observed outcome</p>
</td></tr>
<tr><td><code id=".pmm.match_+3A_donors">donors</code></td>
<td>
<p>The size of the donor pool among which a draw is made. The default is
<code>donors = 5</code>. Setting <code>donors = 1</code> always selects the closest match. Values
between 3 and 10 provide the best results. Note: This setting was changed from
3 to 5 in version 2.19, based on simulation work by Tim Morris (UCL).</p>
</td></tr>
<tr><td><code id=".pmm.match_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is included for backward compatibility. It was
used up to <code>mice 2.21</code>. The current <code>mice.impute.pmm()</code>
function calls the faster <code>C</code> function <code>matcher</code> instead of
<code>.pmm.match()</code>.
</p>


<h3>Value</h3>

<p>A scalar containing the observed value of the selected donor.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren
</p>


<h3>References</h3>

<p>Schenker N &amp; Taylor JMG (1996) Partially parametric techniques
for multiple imputation. <em>Computational Statistics and Data Analysis</em>, 22, 425-446.
</p>
<p>Little RJA (1988) Missing-data adjustments in large surveys (with discussion).
<em>Journal of Business Economics and Statistics</em>, 6, 287-301.
</p>

<hr>
<h2 id='ampute'>Generate missing data for simulation purposes</h2><span id='topic+ampute'></span>

<h3>Description</h3>

<p>This function generates multivariate missing data under a MCAR, MAR or MNAR
missing data mechanism. Imputation of data sets containing missing values can
be performed with <code><a href="#topic+mice">mice</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampute(
  data,
  prop = 0.5,
  patterns = NULL,
  freq = NULL,
  mech = "MAR",
  weights = NULL,
  std = TRUE,
  cont = TRUE,
  type = NULL,
  odds = NULL,
  bycases = TRUE,
  run = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampute_+3A_data">data</code></td>
<td>
<p>A complete data matrix or data frame. Values should be numeric.
Categorical variables should have been transformed to dummies.</p>
</td></tr>
<tr><td><code id="ampute_+3A_prop">prop</code></td>
<td>
<p>A scalar specifying the proportion of missingness. Should be a value
between 0 and 1. Default is a missingness proportion of 0.5.</p>
</td></tr>
<tr><td><code id="ampute_+3A_patterns">patterns</code></td>
<td>
<p>A matrix or data frame of size #patterns by #variables where
<code>0</code> indicates that a variable should have missing values and <code>1</code> indicates
that a variable should remain complete. The user may specify as many patterns as
desired. One pattern (a vector) is possible as well. Default
is a square matrix of size #variables where each pattern has missingness on one
variable only (created with <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>). After the
amputation procedure, <code><a href="#topic+md.pattern">md.pattern</a></code> can be used to investigate the
missing data patterns in the data.</p>
</td></tr>
<tr><td><code id="ampute_+3A_freq">freq</code></td>
<td>
<p>A vector of length #patterns containing the relative frequency with
which the patterns should occur. For example, for three missing data patterns,
the vector could be <code>c(0.4, 0.4, 0.2)</code>, meaning that of all cases with
missing values, 40 percent should have pattern 1, 40 percent pattern 2 and 20
percent pattern 3. The vector should sum to 1. Default is an equal probability
for each pattern, created with <code><a href="#topic+ampute.default.freq">ampute.default.freq</a></code>.</p>
</td></tr>
<tr><td><code id="ampute_+3A_mech">mech</code></td>
<td>
<p>A string specifying the missingness mechanism, either &quot;MCAR&quot;
(Missing Completely At Random), &quot;MAR&quot; (Missing At Random) or &quot;MNAR&quot; (Missing Not At
Random). Default is a MAR missingness mechanism.</p>
</td></tr>
<tr><td><code id="ampute_+3A_weights">weights</code></td>
<td>
<p>A matrix or data frame of size #patterns by #variables. The matrix
contains the weights that will be used to calculate the weighted sum scores. For
a MAR mechanism, the weights of the variables that will be made incomplete should be
zero. For a MNAR mechanism, these weights could have any possible value. Furthermore,
the weights may differ between patterns and between variables. They may be negative
as well. Within each pattern, the relative size of the values are of importance.
The default weights matrix is made with <code><a href="#topic+ampute.default.weights">ampute.default.weights</a></code> and
returns a matrix with equal weights for all variables. In case of MAR, variables
that will be amputed will be weighted with <code>0</code>. For MNAR, variables
that will be observed will be weighted with <code>0</code>. If the mechanism is MCAR, the
weights matrix will not be used.</p>
</td></tr>
<tr><td><code id="ampute_+3A_std">std</code></td>
<td>
<p>Logical. Whether the weighted sum scores should be calculated with
standardized data or with non-standardized data. The latter is especially advised when
making use of train and test sets in order to prevent leakage.</p>
</td></tr>
<tr><td><code id="ampute_+3A_cont">cont</code></td>
<td>
<p>Logical. Whether the probabilities should be based on a continuous
or a discrete distribution. If TRUE, the probabilities of being missing are based
on a continuous logistic distribution function. <code><a href="#topic+ampute.continuous">ampute.continuous</a></code>
will be used to calculate and assign the probabilities. These probabilities will then
be based on the argument <code>type</code>. If FALSE, the probabilities of being missing are
based on a discrete distribution (<code><a href="#topic+ampute.discrete">ampute.discrete</a></code>) based on the <code>odds</code>
argument. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ampute_+3A_type">type</code></td>
<td>
<p>A string or vector of strings containing the type of missingness for each
pattern. Either <code>"LEFT"</code>, <code>"MID"</code>, <code>"TAIL"</code> or '<code>"RIGHT"</code>.
If a single missingness type is given, all patterns will be created with the same
type. If the missingness types should differ between patterns, a vector of missingness
types should be given. Default is RIGHT for all patterns and is the result of
<code><a href="#topic+ampute.default.type">ampute.default.type</a></code>.</p>
</td></tr>
<tr><td><code id="ampute_+3A_odds">odds</code></td>
<td>
<p>A matrix where #patterns defines the #rows. Each row should contain
the odds of being missing for the corresponding pattern. The number of odds values
defines in how many quantiles the sum scores will be divided. The odds values are
relative probabilities: a quantile with odds value 4 will have a probability of
being missing that is four times higher than a quantile with odds 1. The
number of quantiles may differ between the patterns, specify NA for cells remaining empty.
Default is 4 quantiles with odds values 1, 2, 3 and 4 and is created by
<code><a href="#topic+ampute.default.odds">ampute.default.odds</a></code>.</p>
</td></tr>
<tr><td><code id="ampute_+3A_bycases">bycases</code></td>
<td>
<p>Logical. If TRUE, the proportion of missingness is defined in
terms of cases. If FALSE, the proportion of missingness is defined in terms of
cells. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ampute_+3A_run">run</code></td>
<td>
<p>Logical. If TRUE, the amputations are implemented. If FALSE, the
return object will contain everything except for the amputed data set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates missing values in complete data sets. Amputation of complete
data sets is useful for the evaluation of imputation techniques, such as multiple
imputation (performed with function <code><a href="#topic+mice">mice</a></code> in this package).
</p>
<p>The basic strategy underlying multivariate imputation was suggested by
Don Rubin during discussions in the 90's. Brand (1997) created one particular
implementation, and his method found its way into the FCS paper
(Van Buuren et al, 2006).
</p>
<p>Until recently, univariate amputation procedures were used to generate missing
data in complete, simulated data sets. With this approach, variables are made
incomplete one variable at a time. When more than one variable needs to be amputed,
the procedure is repeated multiple times.
</p>
<p>With the univariate approach, it is difficult to relate the missingness on one
variable to the missingness on another variable. A multivariate amputation procedure
solves this issue and moreover, it does justice to the multivariate nature of
data sets. Hence, <code>ampute</code> is developed to perform multivariate amputation.
</p>
<p>The idea behind the function is the specification of several missingness
patterns. Each pattern is a combination of variables with and without missing
values (denoted by <code>0</code> and <code>1</code> respectively). For example, one might
want to create two missingness patterns on a data set with four variables. The
patterns could be something like: <code>0,0,1,1</code> and <code>1,0,1,0</code>.
Each combination of zeros and ones may occur.
</p>
<p>Furthermore, the researcher specifies the proportion of missingness, either the
proportion of missing cases or the proportion of missing cells, and the relative
frequency each pattern occurs. Consequently, the data is split into multiple subsets,
one subset per pattern. Now, each case is candidate for a certain missingness pattern,
but whether the case will have missing values eventually depends on other specifications.
</p>
<p>The first of these specifications is the missing mechanism. There are three possible
mechanisms: the missingness depends completely on chance (MCAR), the missingness
depends on the values of the observed variables (i.e. the variables that remain
complete) (MAR) or on the values of the variables that will be made incomplete (MNAR).
For a discussion on how missingness mechanisms are related to the observed data,
we refer to <a href="https://doi.org/10.1177/0049124118799376">doi:10.1177/0049124118799376</a>Schouten and Vink, 2018.
</p>
<p>When the user specifies the missingness mechanism to be <code>"MCAR"</code>, the candidates
have an equal probability of becoming incomplete. For a <code>"MAR"</code> or <code>"MNAR"</code> mechanism,
weighted sum scores are calculated. These scores are a linear combination of the
variables.
</p>
<p>In order to calculate the weighted sum scores, the data is standardized. For this reason,
the data has to be numeric. Second, for each case, the values in
the data set are multiplied with the weights, specified by argument <code>weights</code>.
These weighted scores will be summed, resulting in a weighted sum score for each case.
</p>
<p>The weights may differ between patterns and they may be negative or zero as well.
Naturally, in case of a MAR mechanism, the weights corresponding to the
variables that will be made incomplete, have a 0. Note that this may be
different for each pattern. In case of MNAR missingness, especially
the weights of the variables that will be made incomplete are of importance. However,
the other variables may be weighted as well.
</p>
<p>It is the relative difference between the weights that will result in an effect
in the sum scores. For example, for the first missing data
pattern mentioned above, the weights for the third and fourth variables could
be set to 2 and 4. However, weight values of 0.2 and 0.4 will have the exact
same effect on the weighted sum score: the fourth variable is weighted twice as
much as variable 3.
</p>
<p>Based on the weighted sum scores, either a discrete or continuous distribution
of probabilities is used to calculate whether a candidate will have missing values.
</p>
<p>For a discrete distribution of probabilities, the weighted sum scores are
divided into subgroups of equal size (quantiles). Thereafter, the user
specifies for each subgroup the odds of being missing. Both the number of
subgroups and the odds values are important for the generation of missing data.
For example, for a RIGHT-like mechanism, scoring in one of the
higher quantiles should have high missingness odds, whereas for a MID-like
mechanism, the central groups should have higher odds. Again, not the size of
the odds values are of importance, but the relative distance between the values.
</p>
<p>The continuous distributions of probabilities are based on the logistic distribution function.
The user can specify the type of missingness, which, again, may differ between patterns.
</p>
<p>For an example and more explanation about how the arguments interact with each other,
we refer to the vignette
<a href="https://rianneschouten.github.io/mice_ampute/vignette/ampute.html">Generate missing values with ampute</a>
The amputation methodology is published in
<a href="https://doi.org/10.1080/00949655.2018.1491577">doi:10.1080/00949655.2018.1491577</a>Schouten, Lugtig and Vink, 2018.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code><a href="#topic+mads-class">mads-class</a></code> (multivariate
amputed data set)
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten [aut, cre], Gerko Vink [aut], Peter Lugtig [ctb], 2016
</p>


<h3>References</h3>

<p>Brand, J.P.L. (1999) <em>Development, implementation and
evaluation of multiple imputation strategies for the statistical analysis of
incomplete data sets.</em> pp. 110-113. Dissertation. Rotterdam: Erasmus University.
</p>
<p>Schouten, R.M., Lugtig, P and Vink, G. (2018)
Generating missing values for simulation purposes: A multivariate amputation procedure..
<em>Journal of Statistical Computation and Simulation</em>, 88(15): 1909-1930.
<a href="https://doi.org/10.1080/00949655.2018.1491577">doi:10.1080/00949655.2018.1491577</a>
</p>
<p>Schouten, R.M. and Vink, G. (2018)The Dance of the Mechanisms: How Observed Information Influences the Validity of Missingness Assumptions.
<em>Sociological Methods and Research</em>, 50(3): 1243-1258.
<a href="https://doi.org/10.1177/0049124118799376">doi:10.1177/0049124118799376</a>
</p>
<p>Van Buuren, S., Brand, J.P.L., Groothuis-Oudshoorn, C.G.M., Rubin, D.B. (2006)
Fully conditional specification in multivariate imputation.
<em>Journal of Statistical Computation and Simulation</em>, 76(12): 1049-1064.
<a href="https://doi.org/10.1080/10629360600810434">doi:10.1080/10629360600810434</a>
</p>
<p>Van Buuren, S. (2018) <a href="https://stefvanbuuren.name/fimd/sec-FCS.html#sec:MICE"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>Vink, G. (2016) Towards a standardized evaluation of multiple imputation routines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mads-class">mads-class</a></code>, <code><a href="#topic+bwplot">bwplot</a></code>, <code><a href="#topic+xyplot">xyplot</a></code>,
<code><a href="#topic+mice">mice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start with a complete data set
compl_boys &lt;- cc(boys)[1:3]

# Perform amputation with default settings
mads_boys &lt;- ampute(data = compl_boys)
mads_boys$amp

# Change default matrices as desired
my_patterns &lt;- mads_boys$patterns
my_patterns[1:3, 2] &lt;- 0

my_weights &lt;- mads_boys$weights
my_weights[2, 1] &lt;- 2
my_weights[3, 1] &lt;- 0.5

# Rerun amputation
my_mads_boys &lt;- ampute(
  data = compl_boys, patterns = my_patterns, freq =
    c(0.3, 0.3, 0.4), weights = my_weights, type = c("RIGHT", "TAIL", "LEFT")
)
my_mads_boys$amp
</code></pre>

<hr>
<h2 id='ampute.continuous'>Multivariate amputation based on continuous probability functions</h2><span id='topic+ampute.continuous'></span>

<h3>Description</h3>

<p>This function creates a missing data indicator for each pattern. The continuous
probability distributions (Van Buuren, 2012, pp. 63, 64) will be induced on the
weighted sum scores, calculated earlier in the multivariate amputation function
<code><a href="#topic+ampute">ampute</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampute.continuous(P, scores, prop, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampute.continuous_+3A_p">P</code></td>
<td>
<p>A vector containing the pattern numbers of the cases's candidacies.
For each case, a value between 1 and #patterns is given. For example, a
case with value 2 is candidate for missing data pattern 2.</p>
</td></tr>
<tr><td><code id="ampute.continuous_+3A_scores">scores</code></td>
<td>
<p>A list containing vectors with the candidates's weighted sum scores,
the result of an underlying function in <code><a href="#topic+ampute">ampute</a></code>.</p>
</td></tr>
<tr><td><code id="ampute.continuous_+3A_prop">prop</code></td>
<td>
<p>A scalar specifying the proportion of missingness. Should be a value
between 0 and 1. Default is a missingness proportion of 0.5.</p>
</td></tr>
<tr><td><code id="ampute.continuous_+3A_type">type</code></td>
<td>
<p>A vector of strings containing the type of missingness for each
pattern. Either <code>"LEFT"</code>, <code>"MID"</code>, <code>"TAIL"</code> or '<code>"RIGHT"</code>.
If a single missingness type is entered, all patterns will be created by the same
type. If missingness types should differ over patterns, a vector of missingness
types should be entered. Default is RIGHT for all patterns and is the result of
<code><a href="#topic+ampute.default.type">ampute.default.type</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing vectors with <code>0</code> if a case should be made missing
and <code>1</code> if a case should remain complete. The first vector refers to the
first pattern, the second vector to the second pattern, etcetera.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten [aut, cre], Gerko Vink [aut], Peter Lugtig [ctb], 2016
</p>


<h3>References</h3>

<p>#'Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-linearnormal.html#sec:generateuni"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, <code><a href="#topic+ampute.default.type">ampute.default.type</a></code>
</p>

<hr>
<h2 id='ampute.default.freq'>Default <code>freq</code> in <code>ampute</code></h2><span id='topic+ampute.default.freq'></span>

<h3>Description</h3>

<p>Defines the default relative frequency vector for the multivariate
amputation function <code>ampute</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampute.default.freq(patterns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampute.default.freq_+3A_patterns">patterns</code></td>
<td>
<p>A matrix of size #patterns by #variables where <code>0</code> indicates
a variable should have missing values and <code>1</code> indicates a variable should
remain complete. Could be the result of <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length #patterns containing the relative frequencies with
which the patterns should occur. An equal probability is given to each pattern.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>
</p>

<hr>
<h2 id='ampute.default.odds'>Default <code>odds</code> in <code>ampute()</code></h2><span id='topic+ampute.default.odds'></span>

<h3>Description</h3>

<p>Defines the default odds matrix for the multivariate amputation function
<code>ampute</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampute.default.odds(patterns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampute.default.odds_+3A_patterns">patterns</code></td>
<td>
<p>A matrix of size #patterns by #variables where 0 indicates a
variable should have missing values and 1 indicates a variable should remain
complete. Could be the result of <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where #rows equals #patterns. Default is 4 quantiles with odds
values 1, 2, 3 and 4, for each pattern, imitating a RIGHT type of missingness.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>
</p>

<hr>
<h2 id='ampute.default.patterns'>Default <code>patterns</code> in <code>ampute</code></h2><span id='topic+ampute.default.patterns'></span>

<h3>Description</h3>

<p>This function creates a default pattern matrix for the multivariate
amputation function <code>ampute()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampute.default.patterns(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampute.default.patterns_+3A_n">n</code></td>
<td>
<p>A scalar specifying the number of variables in the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix of size <code>n</code> where <code>0</code> indicates a variable
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, <code><a href="#topic+md.pattern">md.pattern</a></code>
</p>

<hr>
<h2 id='ampute.default.type'>Default <code>type</code> in <code>ampute()</code></h2><span id='topic+ampute.default.type'></span>

<h3>Description</h3>

<p>Defines the default type vector for the multivariate amputation function
<code>ampute</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampute.default.type(patterns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampute.default.type_+3A_patterns">patterns</code></td>
<td>
<p>A matrix of size #patterns by #variables where 0 indicates a
variable should have missing values and 1 indicates a variable should remain
complete. Could be the result of <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string vector of length #patterns containing the missingness types.
Each pattern will be amputed with a &quot;RIGHT&quot; missingness.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>
</p>

<hr>
<h2 id='ampute.default.weights'>Default <code>weights</code> in <code>ampute</code></h2><span id='topic+ampute.default.weights'></span>

<h3>Description</h3>

<p>Defines the default weights matrix for the multivariate amputation function
<code>ampute</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampute.default.weights(patterns, mech)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampute.default.weights_+3A_patterns">patterns</code></td>
<td>
<p>A matrix of size #patterns by #variables where <code>0</code> indicates
a variable should have missing values and <code>1</code> indicates a variable should
remain complete. Could be the result of <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>.</p>
</td></tr>
<tr><td><code id="ampute.default.weights_+3A_mech">mech</code></td>
<td>
<p>A string specifying the missingness mechanism.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size #patterns by #variables containing the weights that
will be used to calculate the weighted sum scores. Equal weights are given to
all variables. When mechanism is MAR, variables that will be amputed will be
weighted with <code>0</code>. If it is MNAR, variables that will be observed
will be weighted with <code>0</code>. If mechanism is MCAR, the weights matrix will
not be used. A default MAR matrix will be returned.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>
</p>

<hr>
<h2 id='ampute.discrete'>Multivariate amputation based on discrete probability functions</h2><span id='topic+ampute.discrete'></span>

<h3>Description</h3>

<p>This function creates a missing data indicator for each pattern. Odds probabilities
(Brand, 1999, pp. 110-113) will be induced on the weighted sum scores, calculated earlier
in the multivariate amputation function <code><a href="#topic+ampute">ampute</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampute.discrete(P, scores, prop, odds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampute.discrete_+3A_p">P</code></td>
<td>
<p>A vector containing the pattern numbers of candidates.
For each case, a value between 1 and #patterns is given. For example, a
case with value 2 is candidate for missing data pattern 2.</p>
</td></tr>
<tr><td><code id="ampute.discrete_+3A_scores">scores</code></td>
<td>
<p>A list containing vectors with the candidates's weighted sum scores,
the result of an underlying function in <code><a href="#topic+ampute">ampute</a></code>.</p>
</td></tr>
<tr><td><code id="ampute.discrete_+3A_prop">prop</code></td>
<td>
<p>A scalar specifying the proportion of missingness. Should be a value
between 0 and 1. Default is a missingness proportion of 0.5.</p>
</td></tr>
<tr><td><code id="ampute.discrete_+3A_odds">odds</code></td>
<td>
<p>A matrix where #patterns defines the #rows. Each row should contain
the odds of being missing for the corresponding pattern. The amount of odds values
defines in how many quantiles the sum scores will be divided. The values are
relative probabilities: a quantile with odds value 4 will have a probability of
being missing that is four times higher than a quantile with odds 1. The
#quantiles may differ between the patterns, specify NA for cells remaining empty.
Default is 4 quantiles with odds values 1, 2, 3 and 4, the result of
<code><a href="#topic+ampute.default.odds">ampute.default.odds</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing vectors with <code>0</code> if a case should be made missing
and <code>1</code> if a case should remain complete. The first vector refers to the
first pattern, the second vector to the second pattern, etcetera.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>References</h3>

<p>Brand, J.P.L. (1999). <em>Development, implementation and
evaluation of multiple imputation strategies for the statistical analysis of
incomplete data sets.</em> Dissertation. Rotterdam: Erasmus University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, <code><a href="#topic+ampute.default.odds">ampute.default.odds</a></code>
</p>

<hr>
<h2 id='ampute.mcar'>Multivariate amputation under a MCAR mechanism</h2><span id='topic+ampute.mcar'></span>

<h3>Description</h3>

<p>This function creates a missing data indicator for each pattern, based on a MCAR
missingness mechanism. The function is used in the multivariate amputation function
<code><a href="#topic+ampute">ampute</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampute.mcar(P, patterns, prop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampute.mcar_+3A_p">P</code></td>
<td>
<p>A vector containing the pattern numbers of the cases' candidates.
For each case, a value between 1 and #patterns is given. For example, a
case with value 2 is candidate for missing data pattern 2.</p>
</td></tr>
<tr><td><code id="ampute.mcar_+3A_patterns">patterns</code></td>
<td>
<p>A matrix of size #patterns by #variables where <code>0</code> indicates
a variable should have missing values and <code>1</code> indicates a variable should
remain complete. The user may specify as many patterns as desired. One pattern
(a vector) is also possible. Could be the result of <code><a href="#topic+ampute.default.patterns">ampute.default.patterns</a></code>,
default will be a square matrix of size #variables where each pattern has missingness
on one variable only.</p>
</td></tr>
<tr><td><code id="ampute.mcar_+3A_prop">prop</code></td>
<td>
<p>A scalar specifying the proportion of missingness. Should be a value
between 0 and 1. Default is a missingness proportion of 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing vectors with <code>0</code> if a case should be made missing
and <code>1</code> if a case should remain complete. The first vector refers to the
first pattern, the second vector to the second pattern, etcetera.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>
</p>

<hr>
<h2 id='anova.mira'>Compare several nested models</h2><span id='topic+anova.mira'></span>

<h3>Description</h3>

<p>Compare several nested models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mira'
anova(object, ..., method = "D1", use = "wald")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.mira_+3A_object">object</code></td>
<td>
<p>Two or more objects of class <code>mira</code></p>
</td></tr>
<tr><td><code id="anova.mira_+3A_...">...</code></td>
<td>
<p>Other parameters passed down to <code>D1()</code>, <code>D2()</code>,
<code>D3()</code> and <code>mitml::testModels</code>.</p>
</td></tr>
<tr><td><code id="anova.mira_+3A_method">method</code></td>
<td>
<p>Either <code>"D1"</code>, <code>"D2"</code> or <code>"D3"</code></p>
</td></tr>
<tr><td><code id="anova.mira_+3A_use">use</code></td>
<td>
<p>An character indicating the test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>mice.anova</code>
</p>

<hr>
<h2 id='appendbreak'>Appends specified break to the data</h2><span id='topic+appendbreak'></span>

<h3>Description</h3>

<p>A custom function to insert rows in long data with new pseudo-observations
that are being done on the specified break ages. There should be a
column called <code>first</code> in <code>data</code> with logical data that codes whether
the current row is the first for subject <code>id</code>. Furthermore,
the function assumes that columns <code>age</code>, <code>occ</code>,
<code>hgt.z</code>, <code>wgt.z</code> and
<code>bmi.z</code> are available. This function is used on the <code>tbc</code>
data in FIMD chapter 9. Check that out to see it in action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendbreak(data, brk, warp.model = warp.model, id = NULL, typ = "pred")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendbreak_+3A_data">data</code></td>
<td>
<p>A data frame in the long long format</p>
</td></tr>
<tr><td><code id="appendbreak_+3A_brk">brk</code></td>
<td>
<p>A vector of break ages</p>
</td></tr>
<tr><td><code id="appendbreak_+3A_warp.model">warp.model</code></td>
<td>
<p>A time warping model</p>
</td></tr>
<tr><td><code id="appendbreak_+3A_id">id</code></td>
<td>
<p>The subject identifier</p>
</td></tr>
<tr><td><code id="appendbreak_+3A_typ">typ</code></td>
<td>
<p>Label to signal that this is a newly added observation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A long data frame with additional rows for the break ages
</p>

<hr>
<h2 id='as.mids'>Converts an imputed dataset (long format) into a <code>mids</code> object</h2><span id='topic+as.mids'></span>

<h3>Description</h3>

<p>This function converts imputed data stored in long format into
an object of class <code>mids</code>. The original incomplete dataset
needs to be available so that we know where the missing data are.
The function is useful to convert back operations applied to
the imputed data back in a <code>mids</code> object. It may also be
used to store multiply imputed data sets from other software
into the format used by <code>mice</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mids(long, where = NULL, .imp = ".imp", .id = ".id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mids_+3A_long">long</code></td>
<td>
<p>A multiply imputed data set in long format, for example
produced by a call to <code>complete(..., action = 'long', include = TRUE)</code>,
or by other software.</p>
</td></tr>
<tr><td><code id="as.mids_+3A_where">where</code></td>
<td>
<p>A data frame or matrix with logicals of the same dimensions
as <code>data</code> indicating where in the data the imputations should be
created. The default, <code>where = is.na(data)</code>, specifies that the
missing data should be imputed. The <code>where</code> argument may be used to
overimpute observed data, or to skip imputations for selected missing values.
Note: Imputation methods that generate imptutations outside of
<code>mice</code>, like <code>mice.impute.panImpute()</code> may depend on a complete
predictor space. In that case, a custom <code>where</code> matrix can not be
specified.</p>
</td></tr>
<tr><td><code id="as.mids_+3A_.imp">.imp</code></td>
<td>
<p>An optional column number or column name in <code>long</code>,
indicating the imputation index. The values are assumed to be consecutive
integers between 0 and <code>m</code>. Values <code>1</code> through <code>m</code>
correspond to the imputation index, value <code>0</code> indicates
the original data (with missings).
By default, the procedure will search for a variable named <code>".imp"</code>.</p>
</td></tr>
<tr><td><code id="as.mids_+3A_.id">.id</code></td>
<td>
<p>An optional column number or column name in <code>long</code>,
indicating the subject identification. If not specified, then the
function searches for a variable named <code>".id"</code>. If this variable
is found, the values in the column will define the row names in
the <code>data</code> element of the resulting <code>mids</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mids</code>
</p>


<h3>Note</h3>

<p>The function expects the input data <code>long</code> to be sorted by
imputation number (variable <code>".imp"</code> by default), and in the
same sequence within each imputation block.
</p>


<h3>Author(s)</h3>

<p>Gerko Vink
</p>


<h3>Examples</h3>

<pre><code class='language-R'># impute the nhanes dataset
imp &lt;- mice(nhanes, print = FALSE)
# extract the data in long format
X &lt;- complete(imp, action = "long", include = TRUE)
# create dataset with .imp variable as numeric
X2 &lt;- X

# nhanes example without .id
test1 &lt;- as.mids(X)
is.mids(test1)
identical(complete(test1, action = "long", include = TRUE), X)

# nhanes example without .id where .imp is numeric
test2 &lt;- as.mids(X2)
is.mids(test2)
identical(complete(test2, action = "long", include = TRUE), X)

# nhanes example, where we explicitly specify .id as column 2
test3 &lt;- as.mids(X, .id = ".id")
is.mids(test3)
identical(complete(test3, action = "long", include = TRUE), X)

# nhanes example with .id where .imp is numeric
test4 &lt;- as.mids(X2, .id = 2)
is.mids(test4)
identical(complete(test4, action = "long", include = TRUE), X)

# example without an .id variable
# variable .id not preserved
X3 &lt;- X[, -2]
test5 &lt;- as.mids(X3)
is.mids(test5)
identical(complete(test5, action = "long", include = TRUE)[, -2], X[, -2])

# as() syntax has fewer options
test7 &lt;- as(X, "mids")
test8 &lt;- as(X2, "mids")
test9 &lt;- as(X2[, -2], "mids")
rev &lt;- ncol(X):1
test10 &lt;- as(X[, rev], "mids")

# where argument copies also observed data into $imp element
where &lt;- matrix(TRUE, nrow = nrow(nhanes), ncol = ncol(nhanes))
colnames(where) &lt;- colnames(nhanes)
test11 &lt;- as.mids(X, where = where)
identical(complete(test11, action = "long", include = TRUE), X)
</code></pre>

<hr>
<h2 id='as.mira'>Create a <code>mira</code> object from repeated analyses</h2><span id='topic+as.mira'></span>

<h3>Description</h3>

<p>The <code>as.mira()</code> function takes the results of repeated
complete-data analysis stored as a list, and turns it
into a <code>mira</code> object that can be pooled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mira(fitlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mira_+3A_fitlist">fitlist</code></td>
<td>
<p>A list containing $m$ fitted analysis objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>mira</code>.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mira-class">mira</a></code>
</p>

<hr>
<h2 id='as.mitml.result'>Converts into a <code>mitml.result</code> object</h2><span id='topic+as.mitml.result'></span>

<h3>Description</h3>

<p>The <code>as.mitml.result()</code> function takes the results of repeated
complete-data analysis stored as a list, and turns it
into an object of class <code>mitml.result</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mitml.result(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mitml.result_+3A_x">x</code></td>
<td>
<p>An object of class <code>mira</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>mitml.result</code>, a list
containing $m$ fitted analysis objects.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren
</p>


<h3>See Also</h3>

<p><code><a href="mitml.html#topic+with.mitml.list">with.mitml.list</a></code>
</p>

<hr>
<h2 id='boys'>Growth of Dutch boys</h2><span id='topic+boys'></span>

<h3>Description</h3>

<p>Height, weight, head circumference and puberty of 748 Dutch boys.
</p>


<h3>Format</h3>

<p>A data frame with 748 rows on the following 9 variables: </p>

<dl>
<dt>age</dt><dd><p>Decimal age (0-21 years)</p>
</dd>
<dt>hgt</dt><dd><p>Height (cm)</p>
</dd>
<dt>wgt</dt><dd><p>Weight (kg)</p>
</dd>
<dt>bmi</dt><dd><p>Body mass index</p>
</dd>
<dt>hc</dt><dd><p>Head circumference (cm)</p>
</dd>
<dt>gen</dt><dd><p>Genital Tanner stage (G1-G5)</p>
</dd>
<dt>phb</dt><dd><p>Pubic hair (Tanner P1-P6)</p>
</dd>
<dt>tv</dt><dd><p>Testicular volume (ml)</p>
</dd>
<dt>reg</dt><dd><p>Region (north, east, west, south, city)</p>
</dd> </dl>



<h3>Details</h3>

<p>Random sample of 10% from the cross-sectional data used to construct the
Dutch growth references 1997. Variables <code>gen</code> and <code>phb</code> are ordered
factors. <code>reg</code> is a factor.
</p>


<h3>Source</h3>

<p>Fredriks, A.M,, van Buuren, S., Burgmeijer, R.J., Meulmeester JF,
Beuker, R.J., Brugman, E., Roede, M.J., Verloove-Vanhorick, S.P., Wit, J.M.
(2000) Continuing positive secular growth change in The Netherlands
1955-1997.  <em>Pediatric Research</em>, <b>47</b>, 316-323.
</p>
<p>Fredriks, A.M., van Buuren, S., Wit, J.M., Verloove-Vanhorick, S.P. (2000).
Body index measurements in 1996-7 compared with 1980.  <em>Archives of
Disease in Childhood</em>, <b>82</b>, 107-112.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create two imputed data sets
imp &lt;- mice(boys, m = 1, maxit = 2)
z &lt;- complete(imp, 1)

# create imputations for age &lt;8yrs
plot(z$age, z$gen,
  col = mdc(1:2)[1 + is.na(boys$gen)],
  xlab = "Age (years)", ylab = "Tanner Stage Genital"
)

# figure to show that the default imputation method does not impute BMI
# consistently
plot(z$bmi, z$wgt / (z$hgt / 100)^2,
  col = mdc(1:2)[1 + is.na(boys$bmi)],
  xlab = "Imputed BMI", ylab = "Calculated BMI"
)

# also, BMI distributions are somewhat different
oldpar &lt;- par(mfrow = c(1, 2))
MASS::truehist(z$bmi[!is.na(boys$bmi)],
  h = 1, xlim = c(10, 30), ymax = 0.25,
  col = mdc(1), xlab = "BMI observed"
)
MASS::truehist(z$bmi[is.na(boys$bmi)],
  h = 1, xlim = c(10, 30), ymax = 0.25,
  col = mdc(2), xlab = "BMI imputed"
)
par(oldpar)

# repair the inconsistency problem by passive imputation
meth &lt;- imp$meth
meth["bmi"] &lt;- "~I(wgt/(hgt/100)^2)"
pred &lt;- imp$predictorMatrix
pred["hgt", "bmi"] &lt;- 0
pred["wgt", "bmi"] &lt;- 0
imp2 &lt;- mice(boys, m = 1, maxit = 2, meth = meth, pred = pred)
z2 &lt;- complete(imp2, 1)

# show that new imputations are consistent
plot(z2$bmi, z2$wgt / (z2$hgt / 100)^2,
  col = mdc(1:2)[1 + is.na(boys$bmi)],
  ylab = "Calculated BMI"
)

# and compare distributions
oldpar &lt;- par(mfrow = c(1, 2))
MASS::truehist(z2$bmi[!is.na(boys$bmi)],
  h = 1, xlim = c(10, 30), ymax = 0.25, col = mdc(1),
  xlab = "BMI observed"
)
MASS::truehist(z2$bmi[is.na(boys$bmi)],
  h = 1, xlim = c(10, 30), ymax = 0.25, col = mdc(2),
  xlab = "BMI imputed"
)
par(oldpar)
</code></pre>

<hr>
<h2 id='brandsma'>Brandsma school data used Snijders and Bosker (2012)</h2><span id='topic+brandsma'></span>

<h3>Description</h3>

<p>Dataset with raw data from Snijders and Bosker (2012) containing
data from 4106 pupils attending 216 schools. This dataset
includes all pupils and schools with missing data.
</p>


<h3>Format</h3>

<p><code>brandsma</code> is a data frame with 4106 rows and 14 columns:
</p>

<dl>
<dt><code>sch</code></dt><dd><p>School number</p>
</dd>
<dt><code>pup</code></dt><dd><p>Pupil ID</p>
</dd>
<dt><code>iqv</code></dt><dd><p>IQ verbal</p>
</dd>
<dt><code>iqp</code></dt><dd><p>IQ performal</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex of pupil</p>
</dd>
<dt><code>ses</code></dt><dd><p>SES score of pupil</p>
</dd>
<dt><code>min</code></dt><dd><p>Minority member 0/1</p>
</dd>
<dt><code>rpg</code></dt><dd><p>Number of repeated groups, 0, 1, 2</p>
</dd>
<dt><code>lpr</code></dt><dd><p>language score PRE</p>
</dd>
<dt><code>lpo</code></dt><dd><p>language score POST</p>
</dd>
<dt><code>apr</code></dt><dd><p>Arithmetic score PRE</p>
</dd>
<dt><code>apo</code></dt><dd><p>Arithmetic score POST</p>
</dd>
<dt><code>den</code></dt><dd><p>Denomination classification 1-4 - at school level</p>
</dd>
<dt><code>ssi</code></dt><dd><p>School SES indicator - at school level</p>
</dd>
</dl>



<h3>Note</h3>

<p>This dataset is constructed from the raw data. There are
a few differences with the data set used in Chapter 4 and 5
of Snijders and Bosker:
</p>

<ol>
<li><p> All schools are included, including the five school with
missing values on <code>langpost</code>.
</p>
</li>
<li><p> Missing <code>denomina</code> codes are left as missing.
</p>
</li>
<li><p> Aggregates are undefined in the presence of missing data
in the underlying values.
Variables <code>ses</code>, <code>iqv</code> and <code>iqp</code> are in their
original scale, and not globally centered.
No aggregate variables at the school level are included.
</p>
</li>
<li><p> There is a wider selection of original variables. Note
however that the source data contain an even wider set of
variables.
</p>
</li></ol>



<h3>Source</h3>

<p>Constructed from <code>MLbook_2nded_total_4106-99.sav</code> from
<a href="https://www.stats.ox.ac.uk/~snijders/mlbook.htm">https://www.stats.ox.ac.uk/~snijders/mlbook.htm</a> by function
<code>data-raw/R/brandsma.R</code>
</p>


<h3>References</h3>

<p>Brandsma, HP and Knuver, JWM (1989), Effects of school and
classroom characteristics on pupil progress in language and arithmetic.
International Journal of Educational Research, 13(7), 777 - 788.
</p>
<p>Snijders, TAB and Bosker RJ (2012). Multilevel Analysis, 2nd Ed. Sage,
Los Angeles, 2012.
</p>

<hr>
<h2 id='bwplot.mads'>Box-and-whisker plot of amputed and non-amputed data</h2><span id='topic+bwplot.mads'></span>

<h3>Description</h3>

<p>Plotting method to investigate the relation between the data variables and
the amputed data. The function shows how the amputed values are related
to the variable values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mads'
bwplot(
  x,
  data,
  which.pat = NULL,
  standardized = TRUE,
  descriptives = TRUE,
  layout = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwplot.mads_+3A_x">x</code></td>
<td>
<p>A <code>mads</code> (<code><a href="#topic+mads-class">mads-class</a></code>) object, typically created by
<code><a href="#topic+ampute">ampute</a></code>.</p>
</td></tr>
<tr><td><code id="bwplot.mads_+3A_data">data</code></td>
<td>
<p>A string or vector of variable names that needs to be plotted. As
a default, all variables will be plotted.</p>
</td></tr>
<tr><td><code id="bwplot.mads_+3A_which.pat">which.pat</code></td>
<td>
<p>A scalar or vector indicating which patterns need to be plotted.
As a default, all patterns are plotted.</p>
</td></tr>
<tr><td><code id="bwplot.mads_+3A_standardized">standardized</code></td>
<td>
<p>Logical. Whether the box-and-whisker plots need to be created
from standardized data or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="bwplot.mads_+3A_descriptives">descriptives</code></td>
<td>
<p>Logical. Whether the mean, variance and n of the variables
need to be printed. This is useful to examine the effect of the amputation.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="bwplot.mads_+3A_layout">layout</code></td>
<td>
<p>A vector of two values indicating how the boxplots of one pattern
should be divided over the plot. For example, <code>c(2, 3)</code> indicates that the
boxplots of six variables need to be placed on 3 rows and 2 columns. Default
is 1 row and an amount of columns equal to #variables. Note that for more than
6 variables, multiple plots will be created automatically.</p>
</td></tr>
<tr><td><code id="bwplot.mads_+3A_...">...</code></td>
<td>
<p>Not used, but for consistency with generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the box-and-whisker plots. Note that a new pattern
will always be shown in a new plot.
</p>


<h3>Note</h3>

<p>The <code>mads</code> object contains all the information you need to
make any desired plots. Check <code><a href="#topic+mads-class">mads-class</a></code> or the vignette <em>Multivariate
Amputation using Ampute</em> to understand the contents of class object <code>mads</code>.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, <code><a href="#topic+bwplot">bwplot</a></code>, <code><a href="lattice.html#topic+Lattice">Lattice</a></code> for
an overview of the package, <code><a href="#topic+mads-class">mads-class</a></code>
</p>

<hr>
<h2 id='bwplot.mids'>Box-and-whisker plot of observed and imputed data</h2><span id='topic+bwplot.mids'></span><span id='topic+bwplot'></span>

<h3>Description</h3>

<p>Plotting methods for imputed data using <span class="pkg">lattice</span>. <code>bwplot</code>
produces box-and-whisker plots. The function
automatically separates the observed and imputed data. The
functions extend the usual features of <span class="pkg">lattice</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids'
bwplot(
  x,
  data,
  na.groups = NULL,
  groups = NULL,
  as.table = TRUE,
  theme = mice.theme(),
  mayreplicate = TRUE,
  allow.multiple = TRUE,
  outer = TRUE,
  drop.unused.levels = lattice::lattice.getOption("drop.unused.levels"),
  ...,
  subscripts = TRUE,
  subset = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwplot.mids_+3A_x">x</code></td>
<td>
<p>A <code>mids</code> object, typically created by <code>mice()</code> or
<code>mice.mids()</code>.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_data">data</code></td>
<td>
<p>Formula that selects the data to be plotted.  This argument
follows the <span class="pkg">lattice</span> rules for <em>formulas</em>, describing the primary
variables (used for the per-panel display) and the optional conditioning
variables (which define the subsets plotted in different panels) to be used
in the plot.
</p>
<p>The formula is evaluated on the complete data set in the <code>long</code> form.
Legal variable names for the formula include <code>names(x$data)</code> plus the
two administrative factors <code>.imp</code> and <code>.id</code>.
</p>
<p><b>Extended formula interface:</b> The primary variable terms (both the LHS
<code>y</code> and RHS <code>x</code>) may consist of multiple terms separated by a
&lsquo;+&rsquo; sign, e.g., <code>y1 + y2 ~ x | a * b</code>.  This formula would be
taken to mean that the user wants to plot both <code>y1 ~ x | a * b</code> and
<code>y2 ~ x | a * b</code>, but with the <code>y1 ~ x</code> and <code>y2 ~ x</code> in
<em>separate panels</em>. This behavior differs from standard <span class="pkg">lattice</span>.
<em>Only combine terms of the same type</em>, i.e. only factors or only
numerical variables. Mixing numerical and categorical data occasionally
produces odds labeling of vertical axis.
</p>
<p>For convenience, in <code>stripplot()</code> and <code>bwplot</code> the formula
<code>y~.imp</code> may be abbreviated as <code>y</code>. This applies only to a single
<code>y</code>, and does not (yet) work for <code>y1+y2~.imp</code>.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_na.groups">na.groups</code></td>
<td>
<p>An expression evaluating to a logical vector indicating
which two groups are distinguished (e.g. using different colors) in the
display. The environment in which this expression is evaluated in the
response indicator <code>is.na(x$data)</code>.
</p>
<p>The default <code>na.group = NULL</code> contrasts the observed and missing data
in the LHS <code>y</code> variable of the display, i.e. groups created by
<code>is.na(y)</code>. The expression <code>y</code> creates the groups according to
<code>is.na(y)</code>. The expression <code>y1 &amp; y2</code> creates groups by
<code>is.na(y1) &amp; is.na(y2)</code>, and <code>y1 | y2</code> creates groups as
<code>is.na(y1) | is.na(y2)</code>, and so on.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_groups">groups</code></td>
<td>
<p>This is the usual <code>groups</code> arguments in <span class="pkg">lattice</span>. It
differs from <code>na.groups</code> because it evaluates in the completed data
<code>data.frame(complete(x, "long", inc=TRUE))</code> (as usual), whereas
<code>na.groups</code> evaluates in the response indicator. See
<code><a href="#topic+xyplot">xyplot</a></code> for more details. When both <code>na.groups</code> and
<code>groups</code> are specified, <code>na.groups</code> takes precedence, and
<code>groups</code> is ignored.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_as.table">as.table</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_theme">theme</code></td>
<td>
<p>A named list containing the graphical parameters. The default
function <code>mice.theme</code> produces a short list of default colors, line
width, and so on. The extensive list may be obtained from
<code>trellis.par.get()</code>. Global graphical parameters like <code>col</code> or
<code>cex</code> in high-level calls are still honored, so first experiment with
the global parameters. Many setting consists of a pair. For example,
<code>mice.theme</code> defines two symbol colors. The first is for the observed
data, the second for the imputed data. The theme settings only exist during
the call, and do not affect the trellis graphical parameters.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_mayreplicate">mayreplicate</code></td>
<td>
<p>A logical indicating whether color, line widths, and so
on, may be replicated. The graphical functions attempt to choose
&quot;intelligent&quot; graphical parameters. For example, the same color can be
replicated for different element, e.g. use all reds for the imputed data.
Replication may be switched off by setting the flag to <code>FALSE</code>, in order
to allow the user to gain full control.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_allow.multiple">allow.multiple</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_outer">outer</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_...">...</code></td>
<td>
<p>Further arguments, usually not directly processed by the
high-level functions documented here, but instead passed on to other
functions.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_subscripts">subscripts</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="bwplot.mids_+3A_subset">subset</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>na.groups</code> may be used to specify (combinations of)
missingness in any of the variables. The argument <code>groups</code> can be used
to specify groups based on the variable values themselves. Only one of both
may be active at the same time. When both are specified, <code>na.groups</code>
takes precedence over <code>groups</code>.
</p>
<p>Use the <code>subset</code> and <code>na.groups</code> together to plots parts of the
data. For example, select the first imputed data set by by
<code>subset=.imp==1</code>.
</p>
<p>Graphical parameters like <code>col</code>, <code>pch</code> and <code>cex</code> can be
specified in the arguments list to alter the plotting symbols. If
<code>length(col)==2</code>, the color specification to define the observed and
missing groups. <code>col[1]</code> is the color of the 'observed' data,
<code>col[2]</code> is the color of the missing or imputed data. A convenient color
choice is <code>col=mdc(1:2)</code>, a transparent blue color for the observed
data, and a transparent red color for the imputed data. A good choice is
<code>col=mdc(1:2), pch=20, cex=1.5</code>. These choices can be set for the
duration of the session by running <code>mice.theme()</code>.
</p>


<h3>Value</h3>

<p>The high-level functions documented here, as well as other high-level
Lattice functions, return an object of class <code>"trellis"</code>.  The
<code><a href="lattice.html#topic+update.trellis">update</a></code> method can be used to
subsequently update components of the object, and the
<code><a href="lattice.html#topic+print.trellis">print</a></code> method (usually called by default)
will plot it on an appropriate plotting device.
</p>


<h3>Note</h3>

<p>The first two arguments (<code>x</code> and <code>data</code>) are reversed
compared to the standard Trellis syntax implemented in <span class="pkg">lattice</span>. This
reversal was necessary in order to benefit from automatic method dispatch.
</p>
<p>In <span class="pkg">mice</span> the argument <code>x</code> is always a <code>mids</code> object, whereas
in <span class="pkg">lattice</span> the argument <code>x</code> is always a formula.
</p>
<p>In <span class="pkg">mice</span> the argument <code>data</code> is always a formula object, whereas in
<span class="pkg">lattice</span> the argument <code>data</code> is usually a data frame.
</p>
<p>All other arguments have identical interpretation.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren
</p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
</p>
<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+densityplot">densityplot</a></code>,
<code><a href="#topic+stripplot">stripplot</a></code>, <code><a href="lattice.html#topic+lattice">lattice</a></code> for an overview of the
package, as well as <code><a href="lattice.html#topic+xyplot">bwplot</a></code>,
<code><a href="lattice.html#topic+panel.xyplot">panel.bwplot</a></code>,
<code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>,
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
imp &lt;- mice(boys, maxit = 1)

### box-and-whisker plot per imputation of all numerical variables
bwplot(imp)

### tv (testicular volume), conditional on region
bwplot(imp, tv ~ .imp | reg)

### same data, organized in a different way
bwplot(imp, tv ~ reg | .imp, theme = list())
</code></pre>

<hr>
<h2 id='cbind'>Combine R objects by rows and columns</h2><span id='topic+cbind'></span><span id='topic+rbind'></span>

<h3>Description</h3>

<p>Functions <code>cbind()</code> and <code>rbind()</code> are defined in
the <code>mice</code> package in order to
enable dispatch to <code>cbind.mids()</code> and <code>rbind.mids()</code>
when one of the arguments is a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind(...)

rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+cbind">base::cbind</a></code>
</p>

<dl>
<dt><code>deparse.level</code></dt><dd><p>integer controlling the construction of labels in
the case of non-matrix-like arguments (for the default method):<br />
<code>deparse.level = 0</code> constructs no labels;<br />
the default <code>deparse.level = 1</code> typically and
<code>deparse.level = 2</code> always construct labels from the argument
names, see the &lsquo;Value&rsquo; section below.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard <code>base::cbind()</code> and <code>base::rbind()</code>
always dispatch to
<code>base::cbind.data.frame()</code> or <code>base::rbind.data.frame()</code>
if one of the arguments is a
<code>data.frame</code>. The versions defined in the <code>mice</code>
package intercept the user command
and test whether the first argument has class <code>"mids"</code>. If so,
function calls <code>cbind.mids()</code>, respectively <code>rbind.mids()</code>. In
all other cases, the call is forwarded to standard functions in the
<code>base</code> package.
</p>
<p>The <code>cbind.mids()</code> function combines two <code>mids</code> objects
columnwise into a single
object of class <code>mids</code>, or combines a single <code>mids</code> object with
a <code>vector</code>, <code>matrix</code>, <code>factor</code> or <code>data.frame</code>
columnwise into a <code>mids</code> object.
</p>
<p>If both arguments of <code>cbind.mids()</code> are <code>mids</code>-objects, the
<code>data</code> list components should have the same number of rows. Also, the
number of imputations (<code>m</code>) should be identical.
If the second argument is a <code>matrix</code>,
<code>factor</code> or <code>vector</code>, it is transformed into a
<code>data.frame</code>. The number of rows should match with the <code>data</code>
component of the first argument.
</p>
<p>The  <code>cbind.mids()</code> function renames any duplicated variable or block names by
appending <code>".1"</code>, <code>".2"</code> to duplicated names.
</p>
<p>The <code>rbind.mids()</code> function combines two <code>mids</code> objects rowwise into a single
<code>mids</code> object, or combines a <code>mids</code> object with a vector, matrix,
factor or data frame rowwise into a <code>mids</code> object.
</p>
<p>If both arguments of <code>rbind.mids()</code> are <code>mids</code> objects,
then <code>rbind.mids()</code> requires that both have the same number of multiple
imputations. In addition, their <code>data</code> components should match.
</p>
<p>If the second argument of <code>rbind.mids()</code> is not a <code>mids</code> object,
the columns of the arguments should match. The <code>where</code> matrix for the
second argument is set to <code>FALSE</code>, signalling that any missing values in
that argument were not imputed. The <code>ignore</code> vector for the second argument is
set to <code>FALSE</code>. Rows inherited from the second argument will therefore
influence the parameter estimation of the imputation model in any future
iterations.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>mids</code>
</p>


<h3>Note</h3>

<p>The <code>cbind.mids()</code> function constructs the elements of the new <code>mids</code> object as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>data</code>     </td><td style="text-align: left;"> Columnwise combination of the data in <code>x</code> and <code>y</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>imp</code>      </td><td style="text-align: left;"> Combines the imputed values from <code>x</code> and <code>y</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>m</code>        </td><td style="text-align: left;"> Taken from <code>x$m</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>where</code>    </td><td style="text-align: left;"> Columnwise combination of <code>x$where</code> and <code>y$where</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>blocks</code>   </td><td style="text-align: left;"> Combines <code>x$blocks</code> and <code>y$blocks</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>call</code>     </td><td style="text-align: left;"> Vector, <code>call[1]</code> creates <code>x</code>, <code>call[2]</code>
is call to <code>cbind.mids()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nmis</code>     </td><td style="text-align: left;"> Equals <code>c(x$nmis, y$nmis)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>method</code>   </td><td style="text-align: left;"> Combines <code>x$method</code> and <code>y$method</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>predictorMatrix</code> </td><td style="text-align: left;"> Combination with zeroes on the off-diagonal blocks</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>visitSequence</code>   </td><td style="text-align: left;"> Combined as <code>c(x$visitSequence, y$visitSequence)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>formulas</code>  </td><td style="text-align: left;"> Combined as <code>c(x$formulas, y$formulas)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>post</code>      </td><td style="text-align: left;"> Combined as <code>c(x$post, y$post)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>blots</code>     </td><td style="text-align: left;"> Combined as <code>c(x$blots, y$blots)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ignore</code>    </td><td style="text-align: left;"> Taken from <code>x$ignore</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>seed</code>            </td><td style="text-align: left;"> Taken from <code>x$seed</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>iteration</code>       </td><td style="text-align: left;"> Taken from <code>x$iteration</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lastSeedValue</code>   </td><td style="text-align: left;"> Taken from <code>x$lastSeedValue</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>chainMean</code>       </td><td style="text-align: left;"> Combined from <code>x$chainMean</code> and <code>y$chainMean</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>chainVar</code>        </td><td style="text-align: left;"> Combined from <code>x$chainVar</code> and <code>y$chainVar</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>loggedEvents</code>    </td><td style="text-align: left;"> Taken from <code>x$loggedEvents</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>version</code>    </td><td style="text-align: left;"> Current package version</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>date</code>       </td><td style="text-align: left;"> Current date</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The  <code>rbind.mids()</code> function constructs the elements of the new <code>mids</code> object as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>data</code>     </td><td style="text-align: left;"> Rowwise combination of the (incomplete) data in <code>x</code> and <code>y</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>imp</code>      </td><td style="text-align: left;"> Equals <code>rbind(x$imp[[j]], y$imp[[j]])</code> if <code>y</code> is <code>mids</code> object; otherwise
the data of <code>y</code> will be copied</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>m</code>        </td><td style="text-align: left;"> Equals <code>x$m</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>where</code>    </td><td style="text-align: left;"> Rowwise combination of <code>where</code> arguments</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>blocks</code>   </td><td style="text-align: left;"> Equals <code>x$blocks</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>call</code>     </td><td style="text-align: left;"> Vector, <code>call[1]</code> creates <code>x</code>, <code>call[2]</code> is call to <code>rbind.mids</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nmis</code>     </td><td style="text-align: left;"> <code>x$nmis</code> + <code>y$nmis</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>method</code>   </td><td style="text-align: left;"> Taken from <code>x$method</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>predictorMatrix</code> </td><td style="text-align: left;"> Taken from <code>x$predictorMatrix</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>visitSequence</code>   </td><td style="text-align: left;"> Taken from <code>x$visitSequence</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>formulas</code>  </td><td style="text-align: left;"> Taken from <code>x$formulas</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>post</code>      </td><td style="text-align: left;"> Taken from <code>x$post</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>blots</code>     </td><td style="text-align: left;"> Taken from <code>x$blots</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ignore</code>    </td><td style="text-align: left;"> Concatenate <code>x$ignore</code> and <code>y$ignore</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>seed</code>            </td><td style="text-align: left;"> Taken from <code>x$seed</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>iteration</code>       </td><td style="text-align: left;"> Taken from <code>x$iteration</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lastSeedValue</code>   </td><td style="text-align: left;"> Taken from <code>x$lastSeedValue</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>chainMean</code>       </td><td style="text-align: left;"> Set to <code>NA</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>chainVar</code>        </td><td style="text-align: left;"> Set to <code>NA</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>loggedEvents</code>    </td><td style="text-align: left;"> Taken from <code>x$loggedEvents</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>version</code>    </td><td style="text-align: left;"> Taken from <code>x$version</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>date</code>       </td><td style="text-align: left;"> Taken from <code>x$date</code>
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Karin Groothuis-Oudshoorn, Stef van Buuren
</p>


<h3>References</h3>

<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cbind">cbind</a></code>, <code><a href="#topic+ibind">ibind</a></code>,
<code><a href="#topic+mids-class">mids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># --- cbind ---
# impute four variables at once (default)
imp &lt;- mice(nhanes, m = 1, maxit = 1, print = FALSE)
imp$predictorMatrix

# impute two by two
data1 &lt;- nhanes[, c("age", "bmi")]
data2 &lt;- nhanes[, c("hyp", "chl")]
imp1 &lt;- mice(data1, m = 2, maxit = 1, print = FALSE)
imp2 &lt;- mice(data2, m = 2, maxit = 1, print = FALSE)

# Append two solutions
imp12 &lt;- cbind(imp1, imp2)

# This is a different imputation model
imp12$predictorMatrix

# Append the other way around
imp21 &lt;- cbind(imp2, imp1)
imp21$predictorMatrix

# Append 'forgotten' variable chl
data3 &lt;- nhanes[, 1:3]
imp3 &lt;- mice(data3, maxit = 1, m = 2, print = FALSE)
imp4 &lt;- cbind(imp3, chl = nhanes$chl)

# Of course, chl was not imputed
head(complete(imp4))

# Combine mids object with data frame
imp5 &lt;- cbind(imp3, nhanes2)
head(complete(imp5))

# --- rbind ---
imp1 &lt;- mice(nhanes[1:13, ], m = 2, maxit = 1, print = FALSE)
imp5 &lt;- mice(nhanes[1:13, ], m = 2, maxit = 2, print = FALSE)
mylist &lt;- list(age = NA, bmi = NA, hyp = NA, chl = NA)

nrow(complete(rbind(imp1, imp5)))
nrow(complete(rbind(imp1, mylist)))

nrow(complete(rbind(imp1, data.frame(mylist))))
nrow(complete(rbind(imp1, complete(imp5))))
</code></pre>

<hr>
<h2 id='cc'>Select complete cases</h2><span id='topic+cc'></span>

<h3>Description</h3>

<p>Extracts the complete cases, also known as <em>listwise deletion</em>.
<code>cc(x)</code> is similar to
<code>na.omit(x)</code>, but returns an object of the same class
as the input data. Dimensions are not dropped. For extracting
incomplete cases, use <code><a href="#topic+ici">ici</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object. Methods are available for classes
<code>mids</code>, <code>data.frame</code> and <code>matrix</code>. Also, <code>x</code>
could be a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code>, <code>matrix</code> or <code>data.frame</code> containing the data of the complete cases.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+na.omit">na.omit</a></code>, <code><a href="#topic+cci">cci</a></code>, <code><a href="#topic+ici">ici</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cc(nhanes)   # get the 13 complete cases
# cc(nhanes$bmi) # extract complete bmi
</code></pre>

<hr>
<h2 id='cci'>Complete case indicator</h2><span id='topic+cci'></span>

<h3>Description</h3>

<p>The complete case indicator is useful for extracting the subset of complete cases. The function
<code>cci(x)</code> calls <code>complete.cases(x)</code>.
The companion function <code>ici()</code> selects the incomplete cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cci(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cci_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object. Currently supported are methods for the
following classes: <code>mids</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector indicating the complete cases.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+complete.cases">complete.cases</a></code>, <code><a href="#topic+ici">ici</a></code>, <code><a href="#topic+cc">cc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cci(nhanes) # indicator for 13 complete cases
cci(mice(nhanes, maxit = 0))
f &lt;- cci(nhanes[, c("bmi", "hyp")]) # complete data for bmi and hyp
nhanes[f, ] # obtain all data from those with complete bmi and hyp
</code></pre>

<hr>
<h2 id='complete.mids'>Extracts the completed data from a <code>mids</code> object</h2><span id='topic+complete.mids'></span><span id='topic+complete'></span>

<h3>Description</h3>

<p>Takes an object of class <code>mids</code>, fills in the missing data, and returns
the completed data in a specified format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids'
complete(data, action = 1L, include = FALSE, mild = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete.mids_+3A_data">data</code></td>
<td>
<p>An object of class <code>mids</code> as created by the function
<code>mice()</code>.</p>
</td></tr>
<tr><td><code id="complete.mids_+3A_action">action</code></td>
<td>
<p>A numeric vector or a keyword. Numeric
values between 1 and <code>data$m</code> return the data with
imputation number <code>action</code> filled in. The value of <code>action = 0</code>
return the original data, with missing values. <code>action</code> can
also be one of the following keywords: <code>"all"</code>, <code>"long"</code>,
<code>"broad"</code> and <code>"repeated"</code>. See the Details section
for the interpretation.
The default is <code>action = 1L</code> returns the first imputed data set.</p>
</td></tr>
<tr><td><code id="complete.mids_+3A_include">include</code></td>
<td>
<p>A logical to indicate whether the original data with the missing
values should be included.</p>
</td></tr>
<tr><td><code id="complete.mids_+3A_mild">mild</code></td>
<td>
<p>A logical indicating whether the return value should
always be an object of class <code>mild</code>. Setting <code>mild = TRUE</code>
overrides <code>action</code> keywords <code>"long"</code>, <code>"broad"</code>
and <code>"repeated"</code>. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="complete.mids_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>action</code> can be length-1 character, which is
matched to one of the following keywords:
</p>

<dl>
<dt><code>"all"</code></dt><dd><p>produces a <code>mild</code> object of imputed data sets. When
<code>include = TRUE</code>, then the original data are appended as the first list
element;</p>
</dd>
<dt><code>"long"</code></dt><dd><p> produces a data set where imputed data sets
are stacked vertically. The columns are added: 1) <code>.imp</code>, integer,
referring the imputation number, and 2) <code>.id</code>, character, the row
names of <code>data$data</code>;</p>
</dd>
<dt><code>"stacked"</code></dt><dd><p> same as <code>"long"</code> but without the two
additional columns;</p>
</dd>
<dt><code>"broad"</code></dt><dd><p> produces a data set with where imputed data sets
are stacked horizontally. Columns are ordered as in the original data.
The imputation number is appended to each column name;</p>
</dd>
<dt><code>"repeated"</code></dt><dd><p> same as <code>"broad"</code>, but with
columns in a different order.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Complete data set with missing values replaced by imputations.
A <code>data.frame</code>, or a list of data frames of class <code>mild</code>.
</p>


<h3>Note</h3>

<p>Technical note: <code>mice 3.7.5</code> renamed the <code>complete()</code> function
to <code>complete.mids()</code> and exported it as an S3 method of the
generic <code>tidyr::complete()</code>. Name clashes between
<code>mice::complete()</code> and <code>tidyr::complete()</code> should no
longer occur.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mids-class">mids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# obtain first imputed data set
sum(is.na(nhanes2))
imp &lt;- mice(nhanes2, print = FALSE, maxit = 1)
dat &lt;- complete(imp)
sum(is.na(dat))

# obtain stacked third and fifth imputation
dat &lt;- complete(imp, c(3, 5))

# obtain all datasets, with additional identifiers
head(complete(imp, "long"))

# same, but now as list, mild object
dslist &lt;- complete(imp, "all")
length(dslist)

# same, but also include the original data
dslist &lt;- complete(imp, "all", include = TRUE)
length(dslist)

# select original + 3 + 5, store as mild
dslist &lt;- complete(imp, c(0, 3, 5), mild = TRUE)
names(dslist)
</code></pre>

<hr>
<h2 id='construct.blocks'>Construct blocks from <code>formulas</code> and <code>predictorMatrix</code></h2><span id='topic+construct.blocks'></span>

<h3>Description</h3>

<p>This helper function attempts to find blocks of variables in the
specification of the <code>formulas</code> and/or <code>predictorMatrix</code>
objects. Blocks specified by <code>formulas</code> may consist of
multiple variables. Blocks specified by <code>predictorMatrix</code> are
assumed to consist of single variables. Any duplicates in names are
removed, and the formula specification is preferred.
<code>predictorMatrix</code> and <code>formulas</code>. When both arguments
specify models for the same block, the model for the
<code>predictMatrix</code> is removed, and priority is given to the
specification given in <code>formulas</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.blocks(formulas = NULL, predictorMatrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct.blocks_+3A_formulas">formulas</code></td>
<td>
<p>A named list of formula's, or expressions that
can be converted into formula's by <code>as.formula</code>. List elements
correspond to blocks. The block to which the list element applies is
identified by its name, so list names must correspond to block names.
The <code>formulas</code> argument is an alternative to the
<code>predictorMatrix</code> argument that allows for more flexibility in
specifying imputation models, e.g., for specifying interaction terms.</p>
</td></tr>
<tr><td><code id="construct.blocks_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>A numeric matrix of <code>length(blocks)</code> rows
and <code>ncol(data)</code> columns, containing 0/1 data specifying
the set of predictors to be used for each target column.
Each row corresponds to a variable block, i.e., a set of variables
to be imputed. A value of <code>1</code> means that the column
variable is used as a predictor for the target block (in the rows).
By default, the <code>predictorMatrix</code> is a square matrix of <code>ncol(data)</code>
rows and columns with all 1's, except for the diagonal.
Note: For two-level imputation models (which have <code>"2l"</code> in their names)
other codes (e.g, <code>2</code> or <code>-2</code>) are also allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>blocks</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.blocks">make.blocks</a></code>, <code><a href="#topic+name.blocks">name.blocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>form &lt;- name.formulas(list(bmi + hyp ~ chl + age, chl ~ bmi))
pred &lt;- make.predictorMatrix(nhanes[, c("age", "chl")])
construct.blocks(formulas = form, pred = pred)
</code></pre>

<hr>
<h2 id='convergence'>Computes convergence diagnostics for a <code>mids</code> object</h2><span id='topic+convergence'></span>

<h3>Description</h3>

<p>Takes an object of class <code>mids</code>, computes the autocorrelation
and/or potential scale reduction factor, and returns a <code>data.frame</code>
with the specified diagnostic(s) per iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convergence(data, diagnostic = "all", parameter = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convergence_+3A_data">data</code></td>
<td>
<p>An object of class <code>mids</code> as created by the function
<code>mice()</code>.</p>
</td></tr>
<tr><td><code id="convergence_+3A_diagnostic">diagnostic</code></td>
<td>
<p>A keyword. One of the following keywords: <code>"ac"</code>,
<code>"all"</code>, <code>"gr"</code> and <code>"psrf"</code>. See the Details section
for the interpretation.
The default is <code>diagnostic = "all"</code> which returns both the
autocorrelation and potential scale reduction factor per iteration.</p>
</td></tr>
<tr><td><code id="convergence_+3A_parameter">parameter</code></td>
<td>
<p>A keyword. One of the following keywords: <code>"mean"</code>
or <code>"sd"</code> to evaluate chain means or chain standard deviations,
respectively.</p>
</td></tr>
<tr><td><code id="convergence_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>diagnostic</code> can be length-1 character, which is
matched to one of the following keywords:
</p>

<dl>
<dt><code>"all"</code></dt><dd><p>computes both the lag-1 autocorrelation as well as
the potential scale reduction factor (cf. Vehtari et al., 2021) per
iteration of the MICE algorithm;</p>
</dd>
<dt><code>"ac"</code></dt><dd><p>computes only the autocorrelation per iteration;</p>
</dd>
<dt><code>"psrf"</code></dt><dd><p>computes only the potential scale reduction factor
per iteration;</p>
</dd>
<dt><code>"gr"</code></dt><dd><p>same as <code>psrf</code>, the potential scale reduction
factor is colloquially called the Gelman-Rubin diagnostic.</p>
</dd>
</dl>

<p>In the unlikely event of perfect convergence, the autocorrelation equals
zero and the potential scale reduction factor equals one. To interpret
the convergence diagnostic(s) in the output of the function, it is
recommended to plot the diagnostics (ac and/or psrf) against the
iteration number (.it) per imputed variable (vrb). A persistently
decreasing trend across iterations indicates potential non-convergence.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the autocorrelation and/or potential
scale reduction factor per iteration of the MICE algorithm.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., Simpson, D., Carpenter, B., &amp; Burkner,
P.-C. (2021). Rank-Normalization, Folding, and Localization: An Improved
R for Assessing Convergence of MCMC. Bayesian Analysis, 1(1), 1-38.
https://doi.org/10.1214/20-BA1221
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mids-class">mids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# obtain imputed data set
imp &lt;- mice(nhanes2, print = FALSE)
# compute convergence diagnostics
convergence(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='D1'>Compare two nested models using D1-statistic</h2><span id='topic+D1'></span>

<h3>Description</h3>

<p>The D1-statistics is the multivariate Wald test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D1(fit1, fit0 = NULL, dfcom = NULL, df.com = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D1_+3A_fit1">fit1</code></td>
<td>
<p>An object of class <code>mira</code>, produced by <code>with()</code>.</p>
</td></tr>
<tr><td><code id="D1_+3A_fit0">fit0</code></td>
<td>
<p>An object of class <code>mira</code>, produced by <code>with()</code>. The
model in <code>fit0</code> is a nested within <code>fit1</code>. The default null
model <code>fit0 = NULL</code> compares <code>fit1</code> to the intercept-only model.</p>
</td></tr>
<tr><td><code id="D1_+3A_dfcom">dfcom</code></td>
<td>
<p>A single number denoting the
complete-data degrees of freedom of model <code>fit1</code>. If not specified,
it is set equal to <code>df.residual</code> of model <code>fit1</code>. If that cannot
be done, the procedure assumes (perhaps incorrectly) a large sample.</p>
</td></tr>
<tr><td><code id="D1_+3A_df.com">df.com</code></td>
<td>
<p>Deprecated</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Warning: 'D1()' assumes that the order of the variables is the
same in different models. See
<a href="https://github.com/amices/mice/issues/420">https://github.com/amices/mice/issues/420</a> for details.
</p>


<h3>References</h3>

<p>Li, K. H., T. E. Raghunathan, and D. B. Rubin. 1991.
Large-Sample Significance Levels from Multiply Imputed Data Using
Moment-Based Statistics and an F Reference Distribution.
<em>Journal of the American Statistical Association</em>, 86(416): 1065–73.
</p>
<p><a href="https://stefvanbuuren.name/fimd/sec-multiparameter.html#sec:wald">https://stefvanbuuren.name/fimd/sec-multiparameter.html#sec:wald</a>
</p>


<h3>See Also</h3>

<p><code><a href="mitml.html#topic+testModels">testModels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare two linear models:
imp &lt;- mice(nhanes2, seed = 51009, print = FALSE)
mi1 &lt;- with(data = imp, expr = lm(bmi ~ age + hyp + chl))
mi0 &lt;- with(data = imp, expr = lm(bmi ~ age + hyp))
D1(mi1, mi0)
## Not run: 
# Compare two logistic regression models
imp &lt;- mice(boys, maxit = 2, print = FALSE)
fit1 &lt;- with(imp, glm(gen &gt; levels(gen)[1] ~ hgt + hc + reg, family = binomial))
fit0 &lt;- with(imp, glm(gen &gt; levels(gen)[1] ~ hgt + hc, family = binomial))
D1(fit1, fit0)

## End(Not run)
</code></pre>

<hr>
<h2 id='D2'>Compare two nested models using D2-statistic</h2><span id='topic+D2'></span>

<h3>Description</h3>

<p>The D2-statistic pools test statistics from the repeated analyses.
The method is less powerful than the D1- and D3-statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D2(fit1, fit0 = NULL, use = "wald")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D2_+3A_fit1">fit1</code></td>
<td>
<p>An object of class <code>mira</code>, produced by <code>with()</code>.</p>
</td></tr>
<tr><td><code id="D2_+3A_fit0">fit0</code></td>
<td>
<p>An object of class <code>mira</code>, produced by <code>with()</code>. The
model in <code>fit0</code> is a nested within <code>fit1</code>. The default null
model <code>fit0 = NULL</code> compares <code>fit1</code> to the intercept-only model.</p>
</td></tr>
<tr><td><code id="D2_+3A_use">use</code></td>
<td>
<p>A character string denoting Wald- or likelihood-based based tests. Can be either <code>"wald"</code> or <code>"likelihood"</code>. Only used if <code>method = "D2"</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Warning: 'D2()' assumes that the order of the variables is the
same in different models. See
<a href="https://github.com/amices/mice/issues/420">https://github.com/amices/mice/issues/420</a> for details.
</p>


<h3>References</h3>

<p>Li, K. H., X. L. Meng, T. E. Raghunathan, and D. B. Rubin. 1991.
Significance Levels from Repeated p-Values with Multiply-Imputed Data.
<em>Statistica Sinica</em> 1 (1): 65–92.
</p>
<p><a href="https://stefvanbuuren.name/fimd/sec-multiparameter.html#sec:chi">https://stefvanbuuren.name/fimd/sec-multiparameter.html#sec:chi</a>
</p>


<h3>See Also</h3>

<p><code><a href="mitml.html#topic+testModels">testModels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare two linear models:
imp &lt;- mice(nhanes2, seed = 51009, print = FALSE)
mi1 &lt;- with(data = imp, expr = lm(bmi ~ age + hyp + chl))
mi0 &lt;- with(data = imp, expr = lm(bmi ~ age + hyp))
D2(mi1, mi0)
## Not run: 
# Compare two logistic regression models
imp &lt;- mice(boys, maxit = 2, print = FALSE)
fit1 &lt;- with(imp, glm(gen &gt; levels(gen)[1] ~ hgt + hc + reg, family = binomial))
fit0 &lt;- with(imp, glm(gen &gt; levels(gen)[1] ~ hgt + hc, family = binomial))
D2(fit1, fit0)

## End(Not run)
</code></pre>

<hr>
<h2 id='D3'>Compare two nested models using D3-statistic</h2><span id='topic+D3'></span>

<h3>Description</h3>

<p>The D3-statistic is a likelihood-ratio test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D3(fit1, fit0 = NULL, dfcom = NULL, df.com = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D3_+3A_fit1">fit1</code></td>
<td>
<p>An object of class <code>mira</code>, produced by <code>with()</code>.</p>
</td></tr>
<tr><td><code id="D3_+3A_fit0">fit0</code></td>
<td>
<p>An object of class <code>mira</code>, produced by <code>with()</code>. The
model in <code>fit0</code> is a nested within <code>fit1</code>. The default null
model <code>fit0 = NULL</code> compares <code>fit1</code> to the intercept-only model.</p>
</td></tr>
<tr><td><code id="D3_+3A_dfcom">dfcom</code></td>
<td>
<p>A single number denoting the
complete-data degrees of freedom of model <code>fit1</code>. If not specified,
it is set equal to <code>df.residual</code> of model <code>fit1</code>. If that cannot
be done, the procedure assumes (perhaps incorrectly) a large sample.</p>
</td></tr>
<tr><td><code id="D3_+3A_df.com">df.com</code></td>
<td>
<p>Deprecated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>D3()</code> function implement the LR-method by
Meng and Rubin (1992). The implementation of the method relies
on the <code>broom</code> package, the standard <code>update</code> mechanism
for statistical models in <code>R</code> and the <code>offset</code> function.
</p>
<p>The function calculates <code>m</code> repetitions of the full
(or null) models, calculates the mean of the estimates of the
(fixed) parameter coefficients <code class="reqn">\beta</code>. For each imputed
imputed dataset, it calculates the likelihood for the model with
the parameters constrained to <code class="reqn">\beta</code>.
</p>
<p>The <code>mitml::testModels()</code> function offers similar functionality
for a subset of statistical models. Results of <code>mice::D3()</code> and
<code>mitml::testModels()</code> differ in multilevel models because the
<code>testModels()</code> also constrains the variance components parameters.
For more details on
</p>


<h3>Value</h3>

<p>An object of class <code>mice.anova</code>
</p>


<h3>References</h3>

<p>Meng, X. L., and D. B. Rubin. 1992.
Performing Likelihood Ratio Tests with Multiply-Imputed Data Sets.
<em>Biometrika</em>, 79 (1): 103–11.
</p>
<p><a href="https://stefvanbuuren.name/fimd/sec-multiparameter.html#sec:likelihoodratio">https://stefvanbuuren.name/fimd/sec-multiparameter.html#sec:likelihoodratio</a>
</p>
<p><a href="http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#setting-residual-variances-to-a-fixed-value-zero-or-other">http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#setting-residual-variances-to-a-fixed-value-zero-or-other</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fix.coef">fix.coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare two linear models:
imp &lt;- mice(nhanes2, seed = 51009, print = FALSE)
mi1 &lt;- with(data = imp, expr = lm(bmi ~ age + hyp + chl))
mi0 &lt;- with(data = imp, expr = lm(bmi ~ age + hyp))
D3(mi1, mi0)
## Not run: 
# Compare two logistic regression models
imp &lt;- mice(boys, maxit = 2, print = FALSE)
fit1 &lt;- with(imp, glm(gen &gt; levels(gen)[1] ~ hgt + hc + reg, family = binomial))
fit0 &lt;- with(imp, glm(gen &gt; levels(gen)[1] ~ hgt + hc, family = binomial))
D3(fit1, fit0)

## End(Not run)
</code></pre>

<hr>
<h2 id='densityplot.mids'>Density plot of observed and imputed data</h2><span id='topic+densityplot.mids'></span><span id='topic+densityplot'></span>

<h3>Description</h3>

<p>Plotting methods for imputed data using <span class="pkg">lattice</span>. <code>densityplot</code>
produces plots of the densities. The function
automatically separates the observed and imputed data. The
functions extend the usual features of <span class="pkg">lattice</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids'
densityplot(
  x,
  data,
  na.groups = NULL,
  groups = NULL,
  as.table = TRUE,
  plot.points = FALSE,
  theme = mice.theme(),
  mayreplicate = TRUE,
  thicker = 2.5,
  allow.multiple = TRUE,
  outer = TRUE,
  drop.unused.levels = lattice::lattice.getOption("drop.unused.levels"),
  panel = lattice::lattice.getOption("panel.densityplot"),
  default.prepanel = lattice::lattice.getOption("prepanel.default.densityplot"),
  ...,
  subscripts = TRUE,
  subset = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityplot.mids_+3A_x">x</code></td>
<td>
<p>A <code>mids</code> object, typically created by <code>mice()</code> or
<code>mice.mids()</code>.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_data">data</code></td>
<td>
<p>Formula that selects the data to be plotted.  This argument
follows the <span class="pkg">lattice</span> rules for <em>formulas</em>, describing the primary
variables (used for the per-panel display) and the optional conditioning
variables (which define the subsets plotted in different panels) to be used
in the plot.
</p>
<p>The formula is evaluated on the complete data set in the <code>long</code> form.
Legal variable names for the formula include <code>names(x$data)</code> plus the
two administrative factors <code>.imp</code> and <code>.id</code>.
</p>
<p><b>Extended formula interface:</b> The primary variable terms (both the LHS
<code>y</code> and RHS <code>x</code>) may consist of multiple terms separated by a
&lsquo;+&rsquo; sign, e.g., <code>y1 + y2 ~ x | a * b</code>.  This formula would be
taken to mean that the user wants to plot both <code>y1 ~ x | a * b</code> and
<code>y2 ~ x | a * b</code>, but with the <code>y1 ~ x</code> and <code>y2 ~ x</code> in
<em>separate panels</em>. This behavior differs from standard <span class="pkg">lattice</span>.
<em>Only combine terms of the same type</em>, i.e. only factors or only
numerical variables. Mixing numerical and categorical data occasionally
produces odds labeling of vertical axis.
</p>
<p>The function <code>densityplot</code> does not use the <code>y</code> terms in the
formula. Density plots for <code>x1</code> and <code>x2</code> are requested as <code>~
x1 + x2</code>.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_na.groups">na.groups</code></td>
<td>
<p>An expression evaluating to a logical vector indicating
which two groups are distinguished (e.g. using different colors) in the
display. The environment in which this expression is evaluated in the
response indicator <code>is.na(x$data)</code>.
</p>
<p>The default <code>na.group = NULL</code> contrasts the observed and missing data
in the LHS <code>y</code> variable of the display, i.e. groups created by
<code>is.na(y)</code>. The expression <code>y</code> creates the groups according to
<code>is.na(y)</code>. The expression <code>y1 &amp; y2</code> creates groups by
<code>is.na(y1) &amp; is.na(y2)</code>, and <code>y1 | y2</code> creates groups as
<code>is.na(y1) | is.na(y2)</code>, and so on.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_groups">groups</code></td>
<td>
<p>This is the usual <code>groups</code> arguments in <span class="pkg">lattice</span>. It
differs from <code>na.groups</code> because it evaluates in the completed data
<code>data.frame(complete(x, "long", inc=TRUE))</code> (as usual), whereas
<code>na.groups</code> evaluates in the response indicator. See
<code><a href="#topic+xyplot">xyplot</a></code> for more details. When both <code>na.groups</code> and
<code>groups</code> are specified, <code>na.groups</code> takes precedence, and
<code>groups</code> is ignored.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_as.table">as.table</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_plot.points">plot.points</code></td>
<td>
<p>A logical used in <code>densityplot</code> that signals whether
the points should be plotted.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_theme">theme</code></td>
<td>
<p>A named list containing the graphical parameters. The default
function <code>mice.theme</code> produces a short list of default colors, line
width, and so on. The extensive list may be obtained from
<code>trellis.par.get()</code>. Global graphical parameters like <code>col</code> or
<code>cex</code> in high-level calls are still honored, so first experiment with
the global parameters. Many setting consists of a pair. For example,
<code>mice.theme</code> defines two symbol colors. The first is for the observed
data, the second for the imputed data. The theme settings only exist during
the call, and do not affect the trellis graphical parameters.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_mayreplicate">mayreplicate</code></td>
<td>
<p>A logical indicating whether color, line widths, and so
on, may be replicated. The graphical functions attempt to choose
&quot;intelligent&quot; graphical parameters. For example, the same color can be
replicated for different element, e.g. use all reds for the imputed data.
Replication may be switched off by setting the flag to <code>FALSE</code>, in order
to allow the user to gain full control.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_thicker">thicker</code></td>
<td>
<p>Used in <code>densityplot</code>. Multiplication factor of the line
width of the observed density. <code>thicker=1</code> uses the same thickness for
the observed and imputed data.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_allow.multiple">allow.multiple</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_outer">outer</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_panel">panel</code></td>
<td>
<p>See <code><a href="#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_default.prepanel">default.prepanel</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_...">...</code></td>
<td>
<p>Further arguments, usually not directly processed by the
high-level functions documented here, but instead passed on to other
functions.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_subscripts">subscripts</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="densityplot.mids_+3A_subset">subset</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>na.groups</code> may be used to specify (combinations of)
missingness in any of the variables. The argument <code>groups</code> can be used
to specify groups based on the variable values themselves. Only one of both
may be active at the same time. When both are specified, <code>na.groups</code>
takes precedence over <code>groups</code>.
</p>
<p>Use the <code>subset</code> and <code>na.groups</code> together to plots parts of the
data. For example, select the first imputed data set by by
<code>subset=.imp==1</code>.
</p>
<p>Graphical parameters like <code>col</code>, <code>pch</code> and <code>cex</code> can be
specified in the arguments list to alter the plotting symbols. If
<code>length(col)==2</code>, the color specification to define the observed and
missing groups. <code>col[1]</code> is the color of the 'observed' data,
<code>col[2]</code> is the color of the missing or imputed data. A convenient color
choice is <code>col=mdc(1:2)</code>, a transparent blue color for the observed
data, and a transparent red color for the imputed data. A good choice is
<code>col=mdc(1:2), pch=20, cex=1.5</code>. These choices can be set for the
duration of the session by running <code>mice.theme()</code>.
</p>


<h3>Value</h3>

<p>The high-level functions documented here, as well as other high-level
Lattice functions, return an object of class <code>"trellis"</code>.  The
<code><a href="lattice.html#topic+update.trellis">update</a></code> method can be used to
subsequently update components of the object, and the
<code><a href="lattice.html#topic+print.trellis">print</a></code> method (usually called by default)
will plot it on an appropriate plotting device.
</p>


<h3>Note</h3>

<p>The first two arguments (<code>x</code> and <code>data</code>) are reversed
compared to the standard Trellis syntax implemented in <span class="pkg">lattice</span>. This
reversal was necessary in order to benefit from automatic method dispatch.
</p>
<p>In <span class="pkg">mice</span> the argument <code>x</code> is always a <code>mids</code> object, whereas
in <span class="pkg">lattice</span> the argument <code>x</code> is always a formula.
</p>
<p>In <span class="pkg">mice</span> the argument <code>data</code> is always a formula object, whereas in
<span class="pkg">lattice</span> the argument <code>data</code> is usually a data frame.
</p>
<p>All other arguments have identical interpretation.
</p>
<p><code>densityplot</code> errs on empty groups, which occurs if all observations in
the subgroup contain <code>NA</code>. The relevant error message is: <code>Error in
density.default: ... need at least 2 points to select a bandwidth
automatically</code>. There is yet no workaround for this problem. Use the more
robust <code>bwplot</code> or <code>stripplot</code> as a replacement.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren
</p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
</p>
<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+stripplot">stripplot</a></code>,
<code><a href="#topic+bwplot">bwplot</a></code>, <code><a href="lattice.html#topic+lattice">lattice</a></code> for an overview of the
package, as well as <code><a href="lattice.html#topic+histogram">densityplot</a></code>,
<code><a href="lattice.html#topic+panel.densityplot">panel.densityplot</a></code>,
<code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>,
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(boys, maxit = 1)

### density plot of head circumference per imputation
### blue is observed, red is imputed
densityplot(imp, ~ hc | .imp)

### All combined in one panel.
densityplot(imp, ~hc)
</code></pre>

<hr>
<h2 id='employee'>Employee selection data</h2><span id='topic+employee'></span>

<h3>Description</h3>

<p>A toy example from Craig Enders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>employee
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 3 variables:
</p>

<dl>
<dt>IQ</dt><dd><p>candidate IQ score</p>
</dd>
<dt>wbeing</dt><dd><p>candidate well-being score</p>
</dd>
<dt>jobperf</dt><dd><p>candidate job performance score</p>
</dd>
</dl>



<h3>Details</h3>

<p>Enders describes these data as follows:
I designed these data to mimic an employee selection scenario in
which prospective employees complete an IQ test and a
psychological well-being questionnaire during their interview.
The company subsequently hires the applications that score in the
upper half of the IQ distribution, and a supervisor rates their
job performance following a 6-month probationary period.
Note that the job performance scores are missing at random (MAR)
(i.e. individuals in the lower half of the IQ distribution were
never hired, and thus have no performance rating). In addition,
I randomly deleted three of the well-being scores in order to
mimic a situation where the applicant's well-being questionnaire
is inadvertently lost.
</p>
<p>A larger version of this data set in present as
<code><a href="miceadds.html#topic+data.enders">data.enders.employee</a></code>.
</p>


<h3>Source</h3>

<p>Enders (2010), Applied Missing Data Analysis, p. 218
</p>

<hr>
<h2 id='estimice'>Computes least squares parameters</h2><span id='topic+estimice'></span>

<h3>Description</h3>

<p>This function computes least squares estimates, variance/covariance matrices,
residuals and degrees of freedom according to ridge regression, QR decomposition
or Singular Value Decomposition. This function is internally called by .norm.draw(),
but can be called by any user-specified imputation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimice(x, y, ls.meth = "qr", ridge = 1e-05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimice_+3A_x">x</code></td>
<td>
<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.</p>
</td></tr>
<tr><td><code id="estimice_+3A_y">y</code></td>
<td>
<p>Incomplete data vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="estimice_+3A_ls.meth">ls.meth</code></td>
<td>
<p>the method to use for obtaining the least squares estimates. By
default parameters are drawn by means of QR decomposition.</p>
</td></tr>
<tr><td><code id="estimice_+3A_ridge">ridge</code></td>
<td>
<p>A small numerical value specifying the size of the ridge used.
The default value <code>ridge = 1e-05</code> represents a compromise between stability
and unbiasedness. Decrease <code>ridge</code> if the data contain many junk variables.
Increase <code>ridge</code> for highly collinear data.</p>
</td></tr>
<tr><td><code id="estimice_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When calculating the inverse of the crossproduct of the predictor matrix,
problems may arise. For example, taking the inverse is not possible when the
predictor matrix is rank deficient, or when the estimation problem is
computationally singular. This function detects such error cases and
automatically falls back to adding a ridge penalty to the diagonal of the
crossproduct to allow for proper calculation of the inverse.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing components <code>c</code> (least squares estimate),
<code>r</code> (residuals), <code>v</code> (variance/covariance matrix) and <code>df</code>
(degrees of freedom).
</p>


<h3>Note</h3>

<p>This functions adds a star to variable names in the mice iteration
history to signal that a ridge penalty was added. In that case, it
also adds an entry to <code>loggedEvents</code>.
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, 2018
</p>

<hr>
<h2 id='extend.formula'>Extends a formula with predictors</h2><span id='topic+extend.formula'></span>

<h3>Description</h3>

<p>Extends a formula with predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend.formula(
  formula = ~0,
  predictors = NULL,
  auxiliary = TRUE,
  include.intercept = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend.formula_+3A_formula">formula</code></td>
<td>
<p>A formula. If it is
not a formula, the formula is internally reset to <code>~0</code>.</p>
</td></tr>
<tr><td><code id="extend.formula_+3A_predictors">predictors</code></td>
<td>
<p>A character vector of variable names.</p>
</td></tr>
<tr><td><code id="extend.formula_+3A_auxiliary">auxiliary</code></td>
<td>
<p>A logical that indicates whether the variables
listed in <code>predictors</code> should be added to the formula as main
effects. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="extend.formula_+3A_include.intercept">include.intercept</code></td>
<td>
<p>A logical that indicated whether the intercept
should be included in the result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula
</p>

<hr>
<h2 id='extend.formulas'>Extends formula's with predictor matrix settings</h2><span id='topic+extend.formulas'></span>

<h3>Description</h3>

<p>Extends formula's with predictor matrix settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend.formulas(
  formulas,
  data,
  blocks,
  predictorMatrix = NULL,
  auxiliary = TRUE,
  include.intercept = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend.formulas_+3A_formulas">formulas</code></td>
<td>
<p>A named list of formula's, or expressions that
can be converted into formula's by <code>as.formula</code>. List elements
correspond to blocks. The block to which the list element applies is
identified by its name, so list names must correspond to block names.
The <code>formulas</code> argument is an alternative to the
<code>predictorMatrix</code> argument that allows for more flexibility in
specifying imputation models, e.g., for specifying interaction terms.</p>
</td></tr>
<tr><td><code id="extend.formulas_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="extend.formulas_+3A_blocks">blocks</code></td>
<td>
<p>List of vectors with variable names per block. List elements
may be named to identify blocks. Variables within a block are
imputed by a multivariate imputation method
(see <code>method</code> argument). By default each variable is placed
into its own block, which is effectively
fully conditional specification (FCS) by univariate models
(variable-by-variable imputation). Only variables whose names appear in
<code>blocks</code> are imputed. The relevant columns in the <code>where</code>
matrix are set to <code>FALSE</code> of variables that are not block members.
A variable may appear in multiple blocks. In that case, it is
effectively re-imputed each time that it is visited.</p>
</td></tr>
<tr><td><code id="extend.formulas_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>A numeric matrix of <code>length(blocks)</code> rows
and <code>ncol(data)</code> columns, containing 0/1 data specifying
the set of predictors to be used for each target column.
Each row corresponds to a variable block, i.e., a set of variables
to be imputed. A value of <code>1</code> means that the column
variable is used as a predictor for the target block (in the rows).
By default, the <code>predictorMatrix</code> is a square matrix of <code>ncol(data)</code>
rows and columns with all 1's, except for the diagonal.
Note: For two-level imputation models (which have <code>"2l"</code> in their names)
other codes (e.g, <code>2</code> or <code>-2</code>) are also allowed.</p>
</td></tr>
<tr><td><code id="extend.formulas_+3A_auxiliary">auxiliary</code></td>
<td>
<p>A logical that indicates whether the variables
listed in <code>predictors</code> should be added to the formula as main
effects. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="extend.formulas_+3A_include.intercept">include.intercept</code></td>
<td>
<p>A logical that indicated whether the intercept
should be included in the result.</p>
</td></tr>
<tr><td><code id="extend.formulas_+3A_...">...</code></td>
<td>
<p>Named arguments that are passed down to the univariate imputation
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of formula's
</p>

<hr>
<h2 id='extractBS'>Extract broken stick estimates from a <code>lmer</code> object</h2><span id='topic+extractBS'></span>

<h3>Description</h3>

<p>Extract broken stick estimates from a <code>lmer</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractBS(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractBS_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>lmer</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing broken stick estimates
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2012
</p>

<hr>
<h2 id='fdd'>SE Fireworks disaster data</h2><span id='topic+fdd'></span><span id='topic+fdd.pred'></span>

<h3>Description</h3>

<p>Multiple outcomes of a randomized study to reduce post-traumatic stress.
</p>


<h3>Format</h3>

<p><code>fdd</code> is a data frame with 52 rows and 65 columns:
</p>

<dl>
<dt>id</dt><dd><p>Client number</p>
</dd>
<dt>trt</dt><dd><p>Treatment (E=EMDR, C=CBT)</p>
</dd>
<dt>pp</dt><dd><p>Per protocol (Y/N)</p>
</dd>
<dt>trtp</dt><dd><p>Number of parental treatments</p>
</dd>
<dt>sex</dt><dd><p>Sex: M/F</p>
</dd>
<dt>etn</dt><dd><p>Ethnicity: NL/OTHER</p>
</dd>
<dt>age</dt><dd><p>Age (years)</p>
</dd>
<dt>trauma</dt><dd><p>Trauma count (1-5)</p>
</dd>
<dt>prop1</dt><dd><p>PROPS total score T1</p>
</dd>
<dt>prop2</dt><dd><p>PROPS total score T2</p>
</dd>
<dt>prop3</dt><dd><p>PROPS total score T3</p>
</dd>
<dt>crop1</dt><dd><p>CROPS total score T1</p>
</dd>
<dt>crop2</dt><dd><p>CROPS total score T2</p>
</dd>
<dt>crop3</dt><dd><p>CROPS total score T3</p>
</dd>
<dt>masc1</dt><dd><p>MASC score T1</p>
</dd>
<dt>masc2</dt><dd><p>MASC score T2</p>
</dd>
<dt>masc3</dt><dd><p>MASC score T3</p>
</dd>
<dt>cbcl1</dt><dd><p>CBCL T1</p>
</dd>
<dt>cbcl3</dt><dd><p>CBCL T3</p>
</dd>
<dt>prs1</dt><dd><p>PRS total score T1</p>
</dd>
<dt>prs2</dt><dd><p>PRS total score T2</p>
</dd>
<dt>prs3</dt><dd><p>PRS total score T3</p>
</dd>
<dt>ypa1</dt><dd><p>PTSD-RI B intrusive recollection parent T1</p>
</dd>
<dt>ypb1</dt><dd><p>PTSD-RI C avoidant/numbing parent T1</p>
</dd>
<dt>ypc1</dt><dd><p>PTSD-RI D hyper-arousal parent T1</p>
</dd>
<dt>yp1</dt><dd><p>PTSD-RI B+C+D parent T1</p>
</dd>
<dt>ypa2</dt><dd><p>PTSD-RI B intrusive recollection parent T2</p>
</dd>
<dt>ypb2</dt><dd><p>PTSD-RI C avoidant/numbing parent T2</p>
</dd>
<dt>ypc2</dt><dd><p>PTSD-RI D hyper-arousal parent T2</p>
</dd>
<dt>yp2</dt><dd><p>PTSD-RI B+C+D parent T1</p>
</dd>
<dt>ypa3</dt><dd><p>PTSD-RI B intrusive recollection parent T3</p>
</dd>
<dt>ypb3</dt><dd><p>PTSD-RI C avoidant/numbing parent T3</p>
</dd>
<dt>ypc3</dt><dd><p>PTSD-RI D hyper-arousal parent T3</p>
</dd>
<dt>yp3</dt><dd><p>PTSD-RI B+C+D parent T3</p>
</dd>
<dt>yca1</dt><dd><p>PTSD-RI B intrusive recollection child T1</p>
</dd>
<dt>ycb1</dt><dd><p>PTSD-RI C avoidant/numbing child T1</p>
</dd>
<dt>ycc1</dt><dd><p>PTSD-RI D hyper-arousal child T1</p>
</dd>
<dt>yc1</dt><dd><p>PTSD-RI B+C+D child T1</p>
</dd>
<dt>yca2</dt><dd><p>PTSD-RI B intrusive recollection child T2</p>
</dd>
<dt>ycb2</dt><dd><p>PTSD-RI C avoidant/numbing child T2</p>
</dd>
<dt>ycc2</dt><dd><p>PTSD-RI D hyper-arousal child T2</p>
</dd>
<dt>yc2</dt><dd><p>PTSD-RI B+C+D child T2</p>
</dd>
<dt>yca3</dt><dd><p>PTSD-RI B intrusive recollection child T3</p>
</dd>
<dt>ycb3</dt><dd><p>PTSD-RI C avoidant/numbing child T3</p>
</dd>
<dt>ycc3</dt><dd><p>PTSD-RI D hyper-arousal child T3</p>
</dd>
<dt>yc3</dt><dd><p>PTSD-RI B+C+D child T3</p>
</dd>
<dt>ypf1</dt><dd><p>PTSD-RI parent full T1</p>
</dd>
<dt>ypf2</dt><dd><p>PTSD-RI parent full T2</p>
</dd>
<dt>ypf3</dt><dd><p>PTSD-RI parent full T3</p>
</dd>
<dt>ypp1</dt><dd><p>PTSD parent partial T1</p>
</dd>
<dt>ypp2</dt><dd><p>PTSD parent partial T2</p>
</dd>
<dt>ypp3</dt><dd><p>PTSD parent partial T3</p>
</dd>
<dt>ycf1</dt><dd><p>PTSD child full T1</p>
</dd>
<dt>ycf2</dt><dd><p>PTSD child full T2</p>
</dd>
<dt>ycf3</dt><dd><p>PTSD child full T3</p>
</dd>
<dt>ycp1</dt><dd><p>PTSD child partial T1</p>
</dd>
<dt>ycp2</dt><dd><p>PTSD child partial T2</p>
</dd>
<dt>ycp3</dt><dd><p>PTSD child partial T3</p>
</dd>
<dt>cbin1</dt><dd><p>CBCL Internalizing T1</p>
</dd>
<dt>cbin3</dt><dd><p>CBCL Internalizing T3</p>
</dd>
<dt>cbex1</dt><dd><p>CBCL Externalizing T1</p>
</dd>
<dt>cbex3</dt><dd><p>CBCL Externalizing T3</p>
</dd>
<dt>bir1</dt><dd><p>Birlison T1</p>
</dd>
<dt>bir2</dt><dd><p>Birlison T2</p>
</dd>
<dt>bir3</dt><dd><p>Birlison T3</p>
</dd>
</dl>

<p><code>fdd.pred</code> is the 65 by 65 binary
predictor matrix used to impute <code>fdd</code>.
</p>


<h3>Details</h3>

<p>Data from a randomized experiment to reduce post-traumatic stress by two
treatments: Eye Movement Desensitization and Reprocessing (EMDR)
(experimental treatment), and cognitive behavioral therapy (CBT) (control
treatment). 52 children were randomized to one of these two treatments.
Outcomes were measured at three time points: at baseline (pre-treatment, T1),
post-treatment (T2, 4-8 weeks), and at follow-up (T3, 3 months). For more
details, see de Roos et al (2011).  Some person covariates were reshuffled.
The imputation methodology is explained in Chapter 9 of van Buuren (2012).
</p>


<h3>Source</h3>

<p>de Roos, C., Greenwald, R., den Hollander-Gijsman, M., Noorthoorn,
E., van Buuren, S., de Jong, A. (2011). A Randomised Comparison of Cognitive
Behavioral Therapy (CBT) and Eye Movement Desensitisation and Reprocessing
(EMDR) in disaster-exposed children. <em>European Journal of
Psychotraumatology</em>, <em>2</em>, 5694.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-fdd.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
Boca Raton, FL.: Chapman &amp; Hall/CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data &lt;- fdd
md.pattern(fdd)
</code></pre>

<hr>
<h2 id='fdgs'>Fifth Dutch growth study 2009</h2><span id='topic+fdgs'></span>

<h3>Description</h3>

<p>Age, height, weight and region of 10030 children measured within the Fifth
Dutch Growth Study 2009
</p>


<h3>Format</h3>

<p><code>fdgs</code> is a data frame with 10030 rows and 8 columns:
</p>

<dl>
<dt>id</dt><dd><p>Person number</p>
</dd>
<dt>reg</dt><dd><p>Region (factor, 5 levels)</p>
</dd>
<dt>age</dt><dd><p>Age (years)</p>
</dd>
<dt>sex</dt><dd><p>Sex (boy, girl)</p>
</dd>
<dt>hgt</dt><dd><p>Height (cm)</p>
</dd>
<dt>wgt</dt><dd><p>Weight (kg)</p>
</dd>
<dt>hgt.z</dt><dd><p>Height Z-score</p>
</dd>
<dt>wgt.z</dt><dd><p>Weight Z-score</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data set contains data from children of Dutch descent (biological parents
are born in the Netherlands). Children with growth-related diseases were
excluded. The data were used to construct new growth charts of children of
Dutch descent (Schonbeck 2013), and to calculate overweight and obesity
prevalence (Schonbeck 2011).
</p>
<p>Some groups were underrepresented.  Multiple imputation was used to create
synthetic cases that were used to correct for the nonresponse. See Van Buuren
(2012), chapter 8 for details.
</p>


<h3>Source</h3>

<p>Schonbeck, Y., Talma, H., van Dommelen, P., Bakker, B., Buitendijk,
S. E., Hirasing, R. A., van Buuren, S. (2011).  Increase in prevalence of
overweight in Dutch children and adolescents: A comparison of nationwide
growth studies in 1980, 1997 and 2009.  <em>PLoS ONE</em>, <em>6</em>(11),
e27608.
</p>
<p>Schonbeck, Y., Talma, H., van Dommelen, P., Bakker, B., Buitendijk, S. E.,
Hirasing, R. A., van Buuren, S. (2013). The world's tallest nation has
stopped growing taller: the height of Dutch children from 1955 to 2009.
<em>Pediatric Research</em>, <em>73</em>(3), 371-377.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-nonresponse.html#fifth-dutch-growth-study"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Boca Raton, FL.: Chapman &amp; Hall/CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data &lt;- data(fdgs)
summary(data)
</code></pre>

<hr>
<h2 id='fico'>Fraction of incomplete cases among cases with observed</h2><span id='topic+fico'></span>

<h3>Description</h3>

<p>FICO is an outbound statistic defined by the fraction of incomplete cases
among cases with <code>Yj</code> observed (White and Carlin, 2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fico(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fico_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as NA's.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>ncol(data)</code> of FICO statistics.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2012
</p>


<h3>References</h3>

<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/missing-data-pattern.html#sec:flux"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>White, I.R., Carlin, J.B. (2010). Bias and efficiency of multiple imputation
compared with complete-case analysis for missing covariate values.
<em>Statistics in Medicine</em>, <em>29</em>, 2920-2931.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fluxplot">fluxplot</a></code>, <code><a href="#topic+flux">flux</a></code>, <code><a href="#topic+md.pattern">md.pattern</a></code>
</p>

<hr>
<h2 id='filter.mids'>Subset rows of a <code>mids</code> object</h2><span id='topic+filter.mids'></span>

<h3>Description</h3>

<p>This function takes a <code>mids</code> object and returns a new
<code>mids</code> object that pertains to the subset of the data
identified by the expression in .... The expression may use
column values from the incomplete data in <code>.data$data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids'
filter(.data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.mids_+3A_.data">.data</code></td>
<td>
<p>A <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="filter.mids_+3A_...">...</code></td>
<td>
<p>Expressions that return a
logical value, and are defined in terms of the variables in <code>.data$data</code>.
If multiple expressions are specified, they are combined with the <code>&amp;</code> operator.
Only rows for which all conditions evaluate to <code>TRUE</code> are kept.</p>
</td></tr>
<tr><td><code id="filter.mids_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>mids</code>
</p>


<h3>Note</h3>

<p>The function calculates a logical vector <code>include</code> of length <code>nrow(.data$data)</code>.
The function constructs the elements of the filtered <code>mids</code> object as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>data</code>     </td><td style="text-align: left;"> Select rows in <code>.data$data</code> for which <code>include == TRUE</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>imp</code>      </td><td style="text-align: left;"> Select rows each imputation <code>data.frame</code> in <code>.data$imp</code> for which <code>include == TRUE</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>m</code>        </td><td style="text-align: left;"> Equals <code>.data$m</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>where</code>    </td><td style="text-align: left;"> Select rows in <code>.data$where</code> for which <code>include == TRUE</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>blocks</code>   </td><td style="text-align: left;"> Equals <code>.data$blocks</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>call</code>     </td><td style="text-align: left;"> Equals <code>.data$call</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nmis</code>     </td><td style="text-align: left;"> Recalculate <code>nmis</code> based on the selected <code>data</code> rows</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>method</code>   </td><td style="text-align: left;"> Equals <code>.data$method</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>predictorMatrix</code> </td><td style="text-align: left;"> Equals <code>.data$predictorMatrix</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>visitSequence</code>   </td><td style="text-align: left;"> Equals <code>.data$visitSequence</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>formulas</code>  </td><td style="text-align: left;"> Equals <code>.data$formulas</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>post</code>      </td><td style="text-align: left;"> Equals <code>.data$post</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>blots</code>     </td><td style="text-align: left;"> Equals <code>.data$blots</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ignore</code>    </td><td style="text-align: left;"> Select positions in <code>.data$ignore</code> for which <code>include == TRUE</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>seed</code>            </td><td style="text-align: left;"> Equals <code>.data$seed</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>iteration</code>       </td><td style="text-align: left;"> Equals <code>.data$iteration</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lastSeedValue</code>   </td><td style="text-align: left;"> Equals <code>.data$lastSeedValue</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>chainMean</code>       </td><td style="text-align: left;"> Set to <code>NULL</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>chainVar</code>        </td><td style="text-align: left;"> Set to <code>NULL</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>loggedEvents</code>    </td><td style="text-align: left;"> Equals <code>.data$loggedEvents</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>version</code>    </td><td style="text-align: left;"> Replaced with current version</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>date</code>       </td><td style="text-align: left;"> Replaced with current date
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Patrick Rockenschaub
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(nhanes, m = 2, maxit = 1, print = FALSE)

# example with external logical vector
imp_f &lt;- filter(imp, c(rep(TRUE, 13), rep(FALSE, 12)))

nrow(complete(imp))
nrow(complete(imp_f))

# example with calculated include vector
imp_f2 &lt;- filter(imp, age &gt;= 2 &amp; hyp == 1)
nrow(complete(imp_f2)) # should be 5
</code></pre>

<hr>
<h2 id='fix.coef'>Fix coefficients and update model</h2><span id='topic+fix.coef'></span>

<h3>Description</h3>

<p>Refits a model with a specified set of coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.coef(model, beta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.coef_+3A_model">model</code></td>
<td>
<p>An R model, e.g., produced by <code>lm</code> or <code>glm</code></p>
</td></tr>
<tr><td><code id="fix.coef_+3A_beta">beta</code></td>
<td>
<p>A numeric vector with <code>length(coef)</code> model coefficients.
If the vector is not named, the coefficients should be
given in the same order as in <code>coef(model)</code>. If the vector is named,
the procedure attempts to match on names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the linear predictor using the new coefficients,
and reformulates the model using the <code>offset</code>
argument. The linear predictor is called
<code>offset</code>, and its coefficient will be <code>1</code> by definition.
The new model only fits the intercept, which should be <code>0</code>
if we set <code>beta = coef(model)</code>.
</p>


<h3>Value</h3>

<p>An updated R model object
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2018
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model0 &lt;- lm(Volume ~ Girth + Height, data = trees)
formula(model0)
coef(model0)
deviance(model0)

# refit same model
model1 &lt;- fix.coef(model0)
formula(model1)
coef(model1)
deviance(model1)

# change the beta's
model2 &lt;- fix.coef(model0, beta = c(-50, 5, 1))
coef(model2)
deviance(model2)

# compare predictions
plot(predict(model0), predict(model1))
abline(0, 1)
plot(predict(model0), predict(model2))
abline(0, 1)

# compare proportion explained variance
cor(predict(model0), predict(model0) + residuals(model0))^2
cor(predict(model1), predict(model1) + residuals(model1))^2
cor(predict(model2), predict(model2) + residuals(model2))^2

# extract offset from constrained model
summary(model2$offset)

# it also works with factors and missing data
model0 &lt;- lm(bmi ~ age + hyp + chl, data = nhanes2)
model1 &lt;- fix.coef(model0)
model2 &lt;- fix.coef(model0, beta = c(15, -8, -8, 2, 0.2))
</code></pre>

<hr>
<h2 id='flux'>Influx and outflux of multivariate missing data patterns</h2><span id='topic+flux'></span>

<h3>Description</h3>

<p>Influx and outflux are statistics of the missing data pattern. These
statistics are useful in selecting predictors that should go into the
imputation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flux(data, local = names(data))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flux_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as NA's.</p>
</td></tr>
<tr><td><code id="flux_+3A_local">local</code></td>
<td>
<p>A vector of names of columns of <code>data</code>. The default is to
include all columns in the calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Infux and outflux have been proposed by Van Buuren (2018), chapter 4.
</p>
<p>Influx is equal to the number of variable pairs <code>(Yj , Yk)</code> with
<code>Yj</code> missing and <code>Yk</code> observed, divided by the total number of
observed data cells. Influx depends on the proportion of missing data of the
variable. Influx of a completely observed variable is equal to 0, whereas for
completely missing variables we have influx = 1. For two variables with the
same proportion of missing data, the variable with higher influx is better
connected to the observed data, and might thus be easier to impute.
</p>
<p>Outflux is equal to the number of variable pairs with <code>Yj</code> observed and
<code>Yk</code> missing, divided by the total number of incomplete data cells.
Outflux is an indicator of the potential usefulness of <code>Yj</code> for imputing
other variables. Outflux depends on the proportion of missing data of the
variable. Outflux of a completely observed variable is equal to 1, whereas
outflux of a completely missing variable is equal to 0. For two variables
having the same proportion of missing data, the variable with higher outflux
is better connected to the missing data, and thus potentially more useful for
imputing other variables.
</p>
<p>FICO is an outbound statistic defined by the fraction of incomplete cases
among cases with <code>Yj</code> observed (White and Carlin, 2010).
</p>


<h3>Value</h3>

<p>A data frame with <code>ncol(data)</code> rows and six columns:
pobs = Proportion observed,
influx = Influx
outflux = Outflux
ainb = Average inbound statistic
aout = Average outbound statistic
fico = Fraction of incomplete cases among cases with <code>Yj</code> observed
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2012
</p>


<h3>References</h3>

<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/missing-data-pattern.html#sec:flux"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>White, I.R., Carlin, J.B. (2010). Bias and efficiency of multiple imputation
compared with complete-case analysis for missing covariate values.
<em>Statistics in Medicine</em>, <em>29</em>, 2920-2931.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fluxplot">fluxplot</a></code>, <code><a href="#topic+md.pattern">md.pattern</a></code>, <code><a href="#topic+fico">fico</a></code>
</p>

<hr>
<h2 id='fluxplot'>Fluxplot of the missing data pattern</h2><span id='topic+fluxplot'></span>

<h3>Description</h3>

<p>Influx and outflux are statistics of the missing data pattern. These
statistics are useful in selecting predictors that should go into the
imputation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluxplot(
  data,
  local = names(data),
  plot = TRUE,
  labels = TRUE,
  xlim = c(0, 1),
  ylim = c(0, 1),
  las = 1,
  xlab = "Influx",
  ylab = "Outflux",
  main = paste("Influx-outflux pattern for", deparse(substitute(data))),
  eqscplot = TRUE,
  pty = "s",
  lwd = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluxplot_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as NA's.</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_local">local</code></td>
<td>
<p>A vector of names of columns of <code>data</code>. The default is to
include all columns in the calculations.</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_plot">plot</code></td>
<td>
<p>Should a graph be produced?</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_labels">labels</code></td>
<td>
<p>Should the points be labeled?</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_xlim">xlim</code></td>
<td>
<p>See <code>par</code>.</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_ylim">ylim</code></td>
<td>
<p>See <code>par</code>.</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_las">las</code></td>
<td>
<p>See <code>par</code>.</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_xlab">xlab</code></td>
<td>
<p>See <code>par</code>.</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_ylab">ylab</code></td>
<td>
<p>See <code>par</code>.</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_main">main</code></td>
<td>
<p>See <code>par</code>.</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_eqscplot">eqscplot</code></td>
<td>
<p>Should a square plot be produced?</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_pty">pty</code></td>
<td>
<p>See <code>par</code>.</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_lwd">lwd</code></td>
<td>
<p>See <code>par</code>. Controls axis line thickness and diagonal</p>
</td></tr>
<tr><td><code id="fluxplot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plot()</code> or <code>eqscplot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Infux and outflux have been proposed by Van Buuren (2012), chapter 4.
</p>
<p>Influx is equal to the number of variable pairs <code>(Yj , Yk)</code> with
<code>Yj</code> missing and <code>Yk</code> observed, divided by the total number of
observed data cells. Influx depends on the proportion of missing data of the
variable. Influx of a completely observed variable is equal to 0, whereas for
completely missing variables we have influx = 1. For two variables with the
same proportion of missing data, the variable with higher influx is better
connected to the observed data, and might thus be easier to impute.
</p>
<p>Outflux is equal to the number of variable pairs with <code>Yj</code> observed and
<code>Yk</code> missing, divided by the total number of incomplete data cells.
Outflux is an indicator of the potential usefulness of <code>Yj</code> for imputing
other variables. Outflux depends on the proportion of missing data of the
variable. Outflux of a completely observed variable is equal to 1, whereas
outflux of a completely missing variable is equal to 0. For two variables
having the same proportion of missing data, the variable with higher outflux
is better connected to the missing data, and thus potentially more useful for
imputing other variables.
</p>


<h3>Value</h3>

<p>An invisible data frame with <code>ncol(data)</code> rows and six columns:
pobs = Proportion observed,
influx = Influx
outflux = Outflux
ainb = Average inbound statistic
aout = Average outbound statistic
fico = Fraction of incomplete cases among cases with <code>Yj</code> observed
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2012
</p>


<h3>References</h3>

<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/missing-data-pattern.html#sec:flux"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>White, I.R., Carlin, J.B. (2010). Bias and efficiency of multiple imputation
compared with complete-case analysis for missing covariate values.
<em>Statistics in Medicine</em>, <em>29</em>, 2920-2931.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flux">flux</a></code>, <code><a href="#topic+md.pattern">md.pattern</a></code>, <code><a href="#topic+fico">fico</a></code>
</p>

<hr>
<h2 id='futuremice'>Wrapper function that runs MICE in parallel</h2><span id='topic+futuremice'></span>

<h3>Description</h3>

<p>This is a wrapper function for <code><a href="#topic+mice">mice</a></code>, using multiple cores to
execute <code><a href="#topic+mice">mice</a></code> in parallel. As a result, the imputation
procedure can be sped up, which may be useful in general. By default,
<code><a href="#topic+futuremice">futuremice</a></code> distributes the number of imputations <code>m</code>
about equally over the cores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>futuremice(
  data,
  m = 5,
  parallelseed = NA,
  n.core = NULL,
  seed = NA,
  use.logical = TRUE,
  future.plan = "multisession",
  packages = NULL,
  globals = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="futuremice_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the incomplete data. Similar to
the first argument of <code><a href="#topic+mice">mice</a></code>.</p>
</td></tr>
<tr><td><code id="futuremice_+3A_m">m</code></td>
<td>
<p>The number of desired imputated datasets. By default $m=5$ as with
<code>mice</code></p>
</td></tr>
<tr><td><code id="futuremice_+3A_parallelseed">parallelseed</code></td>
<td>
<p>A scalar to be used to obtain reproducible results over
the futures. The default <code>parallelseed = NA</code> will result in a seed value
that is randomly drawn between -999999999 and 999999999.</p>
</td></tr>
<tr><td><code id="futuremice_+3A_n.core">n.core</code></td>
<td>
<p>A scalar indicating the number of cores that should be used.</p>
</td></tr>
<tr><td><code id="futuremice_+3A_seed">seed</code></td>
<td>
<p>A scalar to be used as the seed value for the mice algorithm
within each parallel stream. Please note that the imputations will be the
same for all streams and, hence, this should be used if and only if
<code>n.core = 1</code> and if it is desired to obtain the same output as under
<code>mice</code>.</p>
</td></tr>
<tr><td><code id="futuremice_+3A_use.logical">use.logical</code></td>
<td>
<p>A logical indicating whether logical (<code>TRUE</code>) or
physical (<code>FALSE</code>) CPU's on machine should be used.</p>
</td></tr>
<tr><td><code id="futuremice_+3A_future.plan">future.plan</code></td>
<td>
<p>A character indicating how <code>future</code>s are resolved.
The default <code>multisession</code> resolves futures asynchronously (in parallel)
in separate <code>R</code> sessions running in the background. See
<code><a href="future.html#topic+plan">plan</a></code> for more information on future plans.</p>
</td></tr>
<tr><td><code id="futuremice_+3A_packages">packages</code></td>
<td>
<p>A character vector with additional packages to be used in 
<code>mice</code> (e.g., for using external imputation functions).</p>
</td></tr>
<tr><td><code id="futuremice_+3A_globals">globals</code></td>
<td>
<p>A character string with additional functions to be exported to
each future (e.g., user-written imputation functions).</p>
</td></tr>
<tr><td><code id="futuremice_+3A_...">...</code></td>
<td>
<p>Named arguments that are passed down to function <code><a href="#topic+mice">mice</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies on package <code><a href="furrr.html#topic+furrr">furrr</a></code>, which is a
package for R versions 3.2.0 and later. We have chosen to use furrr function
<code>future_map</code> to allow the use of <code>futuremice</code> on Mac, Linux and
Windows systems.
</p>
<p>This wrapper function combines the output of <code><a href="furrr.html#topic+future_map">future_map</a></code> with
function <code><a href="#topic+ibind">ibind</a></code> from the <code><a href="#topic+mice">mice</a></code> package. A
<code>mids</code> object is returned and can be used for further analyses.
</p>
<p>A seed value can be specified in the global environment, which will yield
reproducible results. A seed value can also be specified within the
<code><a href="#topic+futuremice">futuremice</a></code> call, through specifying the argument
<code>parallelseed</code>. If <code>parallelseed</code> is not specified, a seed value is
drawn randomly by default, and accessible through <code>$parallelseed</code> in the
output object. Hence, results will always be reproducible, regardless of
whether the seed is specified in the global environment, or by setting the
same seed within the function (potentially by extracting the seed from the
<code>futuremice</code> output object.
</p>


<h3>Value</h3>

<p>A mids object as defined by <code><a href="#topic+mids-class">mids-class</a></code>
</p>


<h3>Author(s)</h3>

<p>Thom Benjamin Volker, Gerko Vink
</p>


<h3>References</h3>

<p>Volker, T.B. and Vink, G. (2022). futuremice: The future starts today.
<a href="https://www.gerkovink.com/miceVignettes/futuremice/Vignette_futuremice.html">https://www.gerkovink.com/miceVignettes/futuremice/Vignette_futuremice.html</a>
</p>
<p>#'Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/parallel-computation.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="future.html#topic+future">future</a></code>, <code><a href="furrr.html#topic+furrr">furrr</a></code>, <code><a href="furrr.html#topic+future_map">future_map</a></code>,
<code><a href="future.html#topic+plan">plan</a></code>, <code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mids-class">mids-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 150 imputations in dataset nhanes, performed by 3 cores
## Not run: 
imp1 &lt;- futuremice(data = nhanes, m = 150, n.core = 3)
# Making use of arguments in mice.
imp2 &lt;- futuremice(data = nhanes, m = 100, method = "norm.nob")
imp2$method
fit &lt;- with(imp2, lm(bmi ~ hyp))
pool(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='getfit'>Extract list of fitted models</h2><span id='topic+getfit'></span>

<h3>Description</h3>

<p>Function <code>getfit()</code> returns the list of objects containing the repeated analysis
results, or optionally, one of these fitted objects. The function looks for
a list element called <code>analyses</code>, and return this component as a list with
<code>mira</code> class. If element <code>analyses</code> is not found in <code>x</code>, then
it returns <code>x</code> as a <code>mira</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getfit(x, i = -1L, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>mira</code>, typically produced by a call
to <code>with()</code>.</p>
</td></tr>
<tr><td><code id="getfit_+3A_i">i</code></td>
<td>
<p>An integer between 1 and <code>x$m</code> signalling the index of the
repeated analysis. The default <code>i= -1</code> return a list with all analyses.</p>
</td></tr>
<tr><td><code id="getfit_+3A_simplify">simplify</code></td>
<td>
<p>Should the return value be unlisted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No checking is done for validity of objects. The function also processes
objects of class <code>mitml.result</code> from the <code>mitml</code> package.
</p>


<h3>Value</h3>

<p>If <code>i = -1</code> an object of class <code>mira</code> containing
all analyses. If <code>i</code> selects one of the analyses, then it return
an object whose with class inherited from that element.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2012, 2020
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mira-class">mira</a></code>, <code><a href="#topic+with.mids">with.mids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(nhanes, print = FALSE, seed = 21443)
fit &lt;- with(imp, lm(bmi ~ chl + hyp))
f1 &lt;- getfit(fit)
class(f1)
f2 &lt;- getfit(fit, 2)
class(f2)
</code></pre>

<hr>
<h2 id='getqbar'>Extract estimate from <code>mipo</code> object</h2><span id='topic+getqbar'></span>

<h3>Description</h3>

<p><code>getqbar</code> returns a named vector of pooled estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getqbar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getqbar_+3A_x">x</code></td>
<td>
<p>An object of class <code>mipo</code></p>
</td></tr>
</table>

<hr>
<h2 id='glance.mipo'>Glance method to extract information from a 'mipo' object</h2><span id='topic+glance.mipo'></span>

<h3>Description</h3>

<p>Glance method to extract information from a 'mipo' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mipo'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.mipo_+3A_x">x</code></td>
<td>
<p>An object with multiply-imputed models from 'mice' (class: 'mipo')</p>
</td></tr>
<tr><td><code id="glance.mipo_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with one row and the following columns:
</p>

<ul>
<li><p> nimp
</p>
</li>
<li><p> nobs
</p>
</li></ul>



<h3>Note</h3>

<p>If x contains 'lm' models, R2 and Adj.R2 are included in the output
</p>

<hr>
<h2 id='glm.mids'>Generalized linear model for <code>mids</code> object</h2><span id='topic+glm.mids'></span>

<h3>Description</h3>

<p>Applies <code>glm()</code> to a multiply imputed data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.mids(formula, family = gaussian, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.mids_+3A_formula">formula</code></td>
<td>
<p>a formula expression as for other regression models, of the
form response ~ predictors. See the documentation of <code><a href="stats.html#topic+lm">lm</a></code> and
<code><a href="stats.html#topic+formula">formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="glm.mids_+3A_family">family</code></td>
<td>
<p>The family of the glm model</p>
</td></tr>
<tr><td><code id="glm.mids_+3A_data">data</code></td>
<td>
<p>An object of type <code>mids</code>, which stands for 'multiply imputed
data set', typically created by function <code>mice()</code>.</p>
</td></tr>
<tr><td><code id="glm.mids_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is included for backward compatibility with V1.0. The function
is superseded by <code><a href="#topic+with.mids">with.mids</a></code>.
</p>


<h3>Value</h3>

<p>An objects of class <code>mira</code>, which stands for 'multiply imputed
repeated analysis'.  This object contains <code>data$m</code> distinct
<code>glm.objects</code>, plus some descriptive information.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, C.G.M. (2000)
<em>Multivariate Imputation by Chained Equations: MICE V1.0 User's manual.</em>
Leiden: TNO Quality of Life.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with.mids">with.mids</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+mids-class">mids</a></code>,
<code><a href="#topic+mira-class">mira</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
imp &lt;- mice(nhanes)

# logistic regression on the imputed data
fit &lt;- glm.mids((hyp == 2) ~ bmi + chl, data = imp, family = binomial)
fit
</code></pre>

<hr>
<h2 id='ibind'>Enlarge number of imputations by combining <code>mids</code> objects</h2><span id='topic+ibind'></span>

<h3>Description</h3>

<p>This function combines two <code>mids</code> objects <code>x</code> and <code>y</code> into a
single <code>mids</code> object, with the objective of increasing the number of
imputed data sets. If the number of imputations in <code>x</code> and <code>y</code> are
<code>m(x)</code> and <code>m(y)</code>, then the combined object will have
<code>m(x)+m(y)</code> imputations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibind(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibind_+3A_x">x</code></td>
<td>
<p>A <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="ibind_+3A_y">y</code></td>
<td>
<p>A <code>mids</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two <code>mids</code> objects are required to
have the same underlying multiple imputation model and should
be fitted on the same data.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>mids</code>
</p>


<h3>Author(s)</h3>

<p>Karin Groothuis-Oudshoorn, Stef van Buuren
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mids-class">mids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nhanes)
imp1 &lt;- mice(nhanes, m = 1, maxit = 2, print = FALSE)
imp1$m

imp2 &lt;- mice(nhanes, m = 3, maxit = 3, print = FALSE)
imp2$m

imp12 &lt;- ibind(imp1, imp2)
imp12$m
plot(imp12)
</code></pre>

<hr>
<h2 id='ic'>Select incomplete cases</h2><span id='topic+ic'></span>

<h3>Description</h3>

<p>Extracts incomplete cases from a data set.
The companion function for selecting the complete cases is <code><a href="#topic+cc">cc</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object. Methods are available for classes
<code>mids</code>, <code>data.frame</code> and <code>matrix</code>. Also, <code>x</code>
could be a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code>, <code>matrix</code> or <code>data.frame</code> containing the data of the complete cases.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cc">cc</a></code>, <code><a href="#topic+ici">ici</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ic(nhanes) # get the 12 rows with incomplete cases
ic(nhanes[1:10, ]) # incomplete cases within the first ten rows
ic(nhanes[, c("bmi", "hyp")]) # restrict extraction to variables bmi and hyp
</code></pre>

<hr>
<h2 id='ici'>Incomplete case indicator</h2><span id='topic+ici'></span><span id='topic+ici+2Cdata.frame-method'></span><span id='topic+ici+2Cmatrix-method'></span><span id='topic+ici+2Cmids-method'></span>

<h3>Description</h3>

<p>This array is useful for extracting the subset of incomplete cases.
The companion function  <code>cci()</code> selects the complete cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ici(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ici_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object. Currently supported are methods for the
following classes: <code>mids</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector indicating the incomplete cases,
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cci">cci</a></code>, <code><a href="#topic+ic">ic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ici(nhanes) # indicator for 12 rows with incomplete cases
</code></pre>

<hr>
<h2 id='ifdo'>Conditional imputation helper</h2><span id='topic+ifdo'></span>

<h3>Description</h3>

<p>Sorry, the <code>ifdo()</code> function is not yet implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifdo(cond, action)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifdo_+3A_cond">cond</code></td>
<td>
<p>a condition</p>
</td></tr>
<tr><td><code id="ifdo_+3A_action">action</code></td>
<td>
<p>the action to do</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Currently returns an error message.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2012
</p>

<hr>
<h2 id='is.mads'>Check for <code>mads</code> object</h2><span id='topic+is.mads'></span>

<h3>Description</h3>

<p>Check for <code>mads</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mads(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mads_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether <code>x</code> is an object of class <code>mads</code>
</p>

<hr>
<h2 id='is.mids'>Check for <code>mids</code> object</h2><span id='topic+is.mids'></span>

<h3>Description</h3>

<p>Check for <code>mids</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mids(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mids_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether <code>x</code> is an object of class <code>mids</code>
</p>

<hr>
<h2 id='is.mipo'>Check for <code>mipo</code> object</h2><span id='topic+is.mipo'></span>

<h3>Description</h3>

<p>Check for <code>mipo</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mipo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mipo_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether <code>x</code> is an object of class <code>mipo</code>
</p>

<hr>
<h2 id='is.mira'>Check for <code>mira</code> object</h2><span id='topic+is.mira'></span>

<h3>Description</h3>

<p>Check for <code>mira</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mira(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mira_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether <code>x</code> is an object of class <code>mira</code>
</p>

<hr>
<h2 id='is.mitml.result'>Check for <code>mitml.result</code> object</h2><span id='topic+is.mitml.result'></span>

<h3>Description</h3>

<p>Check for <code>mitml.result</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mitml.result(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mitml.result_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether <code>x</code> is an object of class <code>mitml.result</code>
</p>

<hr>
<h2 id='leiden85'>Leiden 85+ study</h2><span id='topic+leiden85'></span>

<h3>Description</h3>

<p>Subset of data from the Leiden 85+ study
</p>


<h3>Format</h3>

<p><code>leiden85</code> is a data frame with 956 rows and 336 columns.
</p>


<h3>Details</h3>

<p>The data set concerns of subset of 956 members of a very old (85+) cohort in
Leiden.
</p>
<p>Multiple imputation of this data set has been described in Boshuizen et al
(1998), Van Buuren et al (1999) and Van Buuren (2012), chapter 7.
</p>
<p>The data set is not available as part of <code>mice</code>.
</p>


<h3>Source</h3>

<p>Lagaay, A. M., van der Meij, J. C., Hijmans, W. (1992).  Validation of
medical history taking as part of a population based survey in subjects aged
85 and over. <em>Brit. Med. J.</em>, <em>304</em>(6834), 1091-1092.
</p>
<p>Izaks, G. J., van Houwelingen, H. C., Schreuder, G. M., Ligthart, G. J.
(1997).  The association between human leucocyte antigens (HLA) and mortality
in community residents aged 85 and older.  <em>Journal of the American
Geriatrics Society</em>, <em>45</em>(1), 56-60.
</p>
<p>Boshuizen, H. C., Izaks, G. J., van Buuren, S., Ligthart, G. J. (1998).
Blood pressure and mortality in elderly people aged 85 and older: Community
based study.  <em>Brit. Med. J.</em>, <em>316</em>(7147), 1780-1784.
</p>
<p>Van Buuren, S., Boshuizen, H.C., Knook, D.L. (1999) Multiple imputation of
missing blood pressure covariates in survival analysis.  <em>Statistics in
Medicine</em>, <b>18</b>, 681&ndash;694.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-toomany.html#sec:leiden85cohort"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>

<hr>
<h2 id='lm.mids'>Linear regression for <code>mids</code> object</h2><span id='topic+lm.mids'></span>

<h3>Description</h3>

<p>Applies <code>lm()</code> to multiply imputed data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.mids(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.mids_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~
operator, and the terms, separated by + operators, on the right. See the
documentation of <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+formula">formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="lm.mids_+3A_data">data</code></td>
<td>
<p>An object of type 'mids', which stands for 'multiply imputed data
set', typically created by a call to function <code>mice()</code>.</p>
</td></tr>
<tr><td><code id="lm.mids_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is included for backward compatibility with V1.0. The function
is superseded by <code><a href="#topic+with.mids">with.mids</a></code>.
</p>


<h3>Value</h3>

<p>An objects of class <code>mira</code>, which stands for 'multiply imputed
repeated analysis'.  This object contains <code>data$m</code> distinct
<code>lm.objects</code>, plus some descriptive information.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+mids-class">mids</a></code>, <code><a href="#topic+mira-class">mira</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(nhanes)
fit &lt;- lm.mids(bmi ~ hyp + chl, data = imp)
fit
</code></pre>

<hr>
<h2 id='mads-class'>Multivariate amputed data set (<code>mads</code>)</h2><span id='topic+mads-class'></span>

<h3>Description</h3>

<p>The <code>mads</code> object contains an amputed data set. The <code>mads</code> object is
generated by the <code>ampute</code> function. The <code>mads</code> class of objects has
methods for the following generic functions: <code>print</code>, <code>summary</code>,
<code>bwplot</code> and <code>xyplot</code>.
</p>


<h3>Contents</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>The function call.</p>
</dd>
<dt><code>prop</code>:</dt><dd><p>Proportion of cases with missing values. Note: even when
the proportion is entered as the proportion of missing cells (when
<code>bycases == TRUE</code>), this object contains the proportion of missing cases.</p>
</dd>
<dt><code>patterns</code>:</dt><dd><p>A data frame of size #patterns by #variables where <code>0</code>
indicates a variable has missing values and <code>1</code> indicates a variable remains
complete.</p>
</dd>
<dt><code>freq</code>:</dt><dd><p>A vector of length #patterns containing the relative
frequency with which the patterns occur. For example, if the vector is
<code>c(0.4, 0.4, 0.2)</code>, this means that of all cases with missing values,
40 percent is candidate for pattern 1, 40 percent for pattern 2 and 20
percent for pattern 3. The vector sums to 1.</p>
</dd>
<dt><code>mech</code>:</dt><dd><p>A string specifying the missingness mechanism, either
<code>"MCAR"</code>, <code>"MAR"</code> or <code>"MNAR"</code>.</p>
</dd>
<dt><code>weights</code>:</dt><dd><p>A data frame of size #patterns by #variables. It contains
the weights that were used to calculate the weighted sum scores. The weights
may differ between patterns and between variables.</p>
</dd>
<dt><code>cont</code>:</dt><dd><p>Logical, whether probabilities are based on continuous logit
functions or on discrete odds distributions.</p>
</dd>
<dt><code>type</code>:</dt><dd><p>A vector of strings containing the type of missingness
for each pattern. Either <code>"LEFT"</code>, <code>"MID"</code>, <code>"TAIL"</code> or
<code>"RIGHT"</code>. The first type refers to the first pattern, the second type
to the second pattern, etc.</p>
</dd>
<dt><code>odds</code>:</dt><dd><p>A matrix where #patterns defines the #rows. Each row contains
the odds of being missing for the corresponding pattern. The amount of odds values
defines in how many quantiles the sum scores were divided. The values are
relative probabilities: a quantile with odds value 4 will have a probability of
being missing that is four times higher than a quantile with odds 1. The
#quantiles may differ between patterns, NA is used for cells remaining empty.</p>
</dd>
<dt><code>amp</code>:</dt><dd><p>A data frame containing the input data with NAs for the
amputed values.</p>
</dd>
<dt><code>cand</code>:</dt><dd><p>A vector that contains the pattern number for each case.
A value between 1 and #patterns is given. For example, a case with value 2 is
candidate for missing data pattern 2.</p>
</dd>
<dt><code>scores</code>:</dt><dd><p>A list containing vectors with weighted sum scores of the
candidates. The first vector refers to the candidates of the first pattern, the
second vector refers to the candidates of the second pattern, etc. The length
of the vectors differ because the number of candidates is different for each
pattern.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>The complete data set that was entered in <code>ampute</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Many of the functions of the <code>mice</code> package do not use the S4 class
definitions, and instead rely on the S3 list equivalent
<code>oldClass(obj) &lt;- "mads"</code>.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, Vignette titled &quot;Multivariate Amputation using
Ampute&quot;.
</p>

<hr>
<h2 id='make.blocks'>Creates a <code>blocks</code> argument</h2><span id='topic+make.blocks'></span>

<h3>Description</h3>

<p>This helper function generates a list of the type needed for
<code>blocks</code> argument in the <code>[=mice]{mice}</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.blocks(
  data,
  partition = c("scatter", "collect", "void"),
  calltype = "type"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.blocks_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>, character vector with
variable names, or <code>list</code> with variable names.</p>
</td></tr>
<tr><td><code id="make.blocks_+3A_partition">partition</code></td>
<td>
<p>A character vector of length 1 used to assign
variables to blocks when <code>data</code> is a <code>data.frame</code>. Value
<code>"scatter"</code> (default) will assign each column to it own
block. Value <code>"collect"</code> assigns all variables to one block,
whereas <code>"void"</code> produces an empty list.</p>
</td></tr>
<tr><td><code id="make.blocks_+3A_calltype">calltype</code></td>
<td>
<p>A character vector of <code>length(block)</code> elements
that indicates how the imputation model is specified. If
<code>calltype = "type"</code> (the default), the underlying imputation
model is called by means of the <code>type</code> argument. The
<code>type</code> argument for block <code>h</code> is equivalent to
row <code>h</code> in the <code>predictorMatrix</code>.
The alternative is <code>calltype = "formula"</code>. This will pass
<code>formulas[[h]]</code> to the underlying imputation
function for block <code>h</code>, together with the current data.
The <code>calltype</code> of a block is set automatically during
initialization. Where a choice is possible, calltype
<code>"formula"</code> is preferred over <code>"type"</code> since this is
more flexible and extendable. However, what precisely happens
depends also on the capabilities of the imputation
function that is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Choices <code>"scatter"</code> and <code>"collect"</code> represent to two
extreme scenarios for assigning variables to imputation blocks.
Use <code>"scatter"</code> to create an imputation model based on
<em>fully conditionally specification</em> (FCS). Use <code>"collect"</code> to
gather all variables to be imputed by a <em>joint model</em> (JM).
Scenario's in-between these two extremes represent
<em>hybrid</em> imputation models that combine FCS and JM.
</p>
<p>Any variable not listed in will not be imputed.
Specification <code>"void"</code> represents the extreme scenario that
skips imputation of all variables.
</p>
<p>A variable may be a member of multiple blocks. The variable will be
re-imputed in each block, so the final imputations for variable
will come from the last block that was executed. This scenario
may be useful where the same complete background factors appear in
multiple imputation blocks.
</p>
<p>A variable may appear multiple times within a given block. If a univariate
imputation model is applied to such a block, then the variable is
re-imputed each time as it appears in the block.
</p>


<h3>Value</h3>

<p>A named list of character vectors with variables names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.blocks(nhanes)
make.blocks(c("age", "sex", "edu"))
</code></pre>

<hr>
<h2 id='make.blots'>Creates a <code>blots</code> argument</h2><span id='topic+make.blots'></span>

<h3>Description</h3>

<p>This helper function creates a valid <code>blots</code> object. The
<code>blots</code> object is an argument to the <code>mice</code> function.
The name <code>blots</code> is a contraction of blocks-dots.
Through <code>blots</code>, the user can specify any additional
arguments that are specifically passed down to the lowest level
imputation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.blots(data, blocks = make.blocks(data))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.blots_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with the source data</p>
</td></tr>
<tr><td><code id="make.blots_+3A_blocks">blocks</code></td>
<td>
<p>An optional specification for blocks of variables in
the rows. The default assigns each variable in its own block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.blocks">make.blocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.predictorMatrix(nhanes)
make.blots(nhanes, blocks = name.blocks(c("age", "hyp"), "xxx"))
</code></pre>

<hr>
<h2 id='make.formulas'>Creates a <code>formulas</code> argument</h2><span id='topic+make.formulas'></span>

<h3>Description</h3>

<p>This helper function creates a valid <code>formulas</code> object. The
<code>formulas</code> object is an argument to the <code>mice</code> function.
It is a list of formula's that specifies the target variables and
the predictors by means of the standard <code>~</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.formulas(data, blocks = make.blocks(data), predictorMatrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.formulas_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with the source data</p>
</td></tr>
<tr><td><code id="make.formulas_+3A_blocks">blocks</code></td>
<td>
<p>An optional specification for blocks of variables in
the rows. The default assigns each variable in its own block.</p>
</td></tr>
<tr><td><code id="make.formulas_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>A <code>predictorMatrix</code> specified by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of formula's.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.blocks">make.blocks</a></code>, <code><a href="#topic+make.predictorMatrix">make.predictorMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- make.formulas(nhanes)
f1
f2 &lt;- make.formulas(nhanes, blocks = make.blocks(nhanes, "collect"))
f2

# for editing, it may be easier to work with the character vector
c1 &lt;- as.character(f1)
c1

# fold it back into a formula list
f3 &lt;- name.formulas(lapply(c1, as.formula))
f3
</code></pre>

<hr>
<h2 id='make.method'>Creates a <code>method</code> argument</h2><span id='topic+make.method'></span>

<h3>Description</h3>

<p>This helper function creates a valid <code>method</code> vector. The
<code>method</code> vector is an argument to the <code>mice</code> function that
specifies the method for each block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.method(
  data,
  where = make.where(data),
  blocks = make.blocks(data),
  defaultMethod = c("pmm", "logreg", "polyreg", "polr")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.method_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="make.method_+3A_where">where</code></td>
<td>
<p>A data frame or matrix with logicals of the same dimensions
as <code>data</code> indicating where in the data the imputations should be
created. The default, <code>where = is.na(data)</code>, specifies that the
missing data should be imputed. The <code>where</code> argument may be used to
overimpute observed data, or to skip imputations for selected missing values.
Note: Imputation methods that generate imptutations outside of
<code>mice</code>, like <code>mice.impute.panImpute()</code> may depend on a complete
predictor space. In that case, a custom <code>where</code> matrix can not be
specified.</p>
</td></tr>
<tr><td><code id="make.method_+3A_blocks">blocks</code></td>
<td>
<p>List of vectors with variable names per block. List elements
may be named to identify blocks. Variables within a block are
imputed by a multivariate imputation method
(see <code>method</code> argument). By default each variable is placed
into its own block, which is effectively
fully conditional specification (FCS) by univariate models
(variable-by-variable imputation). Only variables whose names appear in
<code>blocks</code> are imputed. The relevant columns in the <code>where</code>
matrix are set to <code>FALSE</code> of variables that are not block members.
A variable may appear in multiple blocks. In that case, it is
effectively re-imputed each time that it is visited.</p>
</td></tr>
<tr><td><code id="make.method_+3A_defaultmethod">defaultMethod</code></td>
<td>
<p>A vector of length 4 containing the default
imputation methods for 1) numeric data, 2) factor data with 2 levels, 3)
factor data with &gt; 2 unordered levels, and 4) factor data with &gt; 2
ordered levels. By default, the method uses
<code>pmm</code>, predictive mean matching (numeric data) <code>logreg</code>, logistic
regression imputation (binary data, factor with 2 levels) <code>polyreg</code>,
polytomous regression imputation for unordered categorical data (factor &gt; 2
levels) <code>polr</code>, proportional odds model for (ordered, &gt; 2 levels).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of <code>length(blocks)</code> element with method names
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.method(nhanes2)
</code></pre>

<hr>
<h2 id='make.post'>Creates a <code>post</code> argument</h2><span id='topic+make.post'></span>

<h3>Description</h3>

<p>This helper function creates a valid <code>post</code> vector. The
<code>post</code> vector is an argument to the <code>mice</code> function that
specifies post-processing for a variable after each iteration of imputation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.post(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.post_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of <code>ncol(data)</code> element
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.post(nhanes2)
</code></pre>

<hr>
<h2 id='make.predictorMatrix'>Creates a <code>predictorMatrix</code> argument</h2><span id='topic+make.predictorMatrix'></span>

<h3>Description</h3>

<p>This helper function creates a valid <code>predictMatrix</code>. The
<code>predictorMatrix</code> is an argument to the <code>mice</code> function.
It specifies the target variable or block in the rows, and the
predictor variables on the columns. An entry of <code>0</code> means that
the column variable is NOT used to impute the row variable or block.
A nonzero value indicates that it is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.predictorMatrix(data, blocks = make.blocks(data), predictorMatrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.predictorMatrix_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with the source data</p>
</td></tr>
<tr><td><code id="make.predictorMatrix_+3A_blocks">blocks</code></td>
<td>
<p>An optional specification for blocks of variables in
the rows. The default assigns each variable in its own block.</p>
</td></tr>
<tr><td><code id="make.predictorMatrix_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>A predictor matrix from which rows with the same
names are copied into the output predictor matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.blocks">make.blocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.predictorMatrix(nhanes)
make.predictorMatrix(nhanes, blocks = make.blocks(nhanes, "collect"))
</code></pre>

<hr>
<h2 id='make.visitSequence'>Creates a <code>visitSequence</code> argument</h2><span id='topic+make.visitSequence'></span>

<h3>Description</h3>

<p>This helper function creates a valid <code>visitSequence</code>. The
<code>visitSequence</code> is an argument to the <code>mice</code> function that
specifies the sequence in which blocks are imputed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.visitSequence(data = NULL, blocks = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.visitSequence_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="make.visitSequence_+3A_blocks">blocks</code></td>
<td>
<p>List of vectors with variable names per block. List elements
may be named to identify blocks. Variables within a block are
imputed by a multivariate imputation method
(see <code>method</code> argument). By default each variable is placed
into its own block, which is effectively
fully conditional specification (FCS) by univariate models
(variable-by-variable imputation). Only variables whose names appear in
<code>blocks</code> are imputed. The relevant columns in the <code>where</code>
matrix are set to <code>FALSE</code> of variables that are not block members.
A variable may appear in multiple blocks. In that case, it is
effectively re-imputed each time that it is visited.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing block names
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.visitSequence(nhanes)
</code></pre>

<hr>
<h2 id='make.where'>Creates a <code>where</code> argument</h2><span id='topic+make.where'></span>

<h3>Description</h3>

<p>This helper function creates a valid <code>where</code> matrix. The
<code>where</code> matrix is an argument to the <code>mice</code> function.
It has the same size as <code>data</code> and specifies which values
are to be imputed (<code>TRUE</code>) or nor (<code>FALSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.where(data, keyword = c("missing", "all", "none", "observed"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.where_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with the source data</p>
</td></tr>
<tr><td><code id="make.where_+3A_keyword">keyword</code></td>
<td>
<p>An optional keyword, one of <code>"missing"</code> (missing
values are imputed), <code>"observed"</code> (observed values are imputed),
<code>"all"</code> and <code>"none"</code>. The default
is <code>keyword = "missing"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with logical
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.blocks">make.blocks</a></code>, <code><a href="#topic+make.predictorMatrix">make.predictorMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(make.where(nhanes), 3)

# create &amp; analyse synthetic data
where &lt;- make.where(nhanes2, "all")
imp &lt;- mice(nhanes2,
  m = 10, where = where,
  print = FALSE, seed = 123
)
fit &lt;- with(imp, lm(chl ~ bmi + age + hyp))
summary(pool.syn(fit))
</code></pre>

<hr>
<h2 id='mammalsleep'>Mammal sleep data</h2><span id='topic+mammalsleep'></span><span id='topic+sleep'></span>

<h3>Description</h3>

<p>Dataset from Allison and Cicchetti (1976) of 62 mammal species on the
interrelationship between sleep, ecological, and constitutional variables.
The dataset contains missing values on five variables.
</p>


<h3>Format</h3>

<p><code>mammalsleep</code> is a data frame with 62 rows and 11 columns:
</p>

<dl>
<dt>species</dt><dd><p>Species of animal</p>
</dd>
<dt>bw</dt><dd><p>Body weight (kg)</p>
</dd>
<dt>brw</dt><dd><p>Brain weight (g)</p>
</dd>
<dt>sws</dt><dd><p>Slow wave (&quot;nondreaming&quot;) sleep (hrs/day)</p>
</dd>
<dt>ps</dt><dd><p>Paradoxical (&quot;dreaming&quot;) sleep (hrs/day)</p>
</dd>
<dt>ts</dt><dd><p>Total sleep (hrs/day) (sum of slow wave and paradoxical sleep)</p>
</dd>
<dt>mls</dt><dd><p>Maximum life span (years)</p>
</dd>
<dt>gt</dt><dd><p>Gestation time (days)</p>
</dd>
<dt>pi</dt><dd><p>Predation index (1-5), 1 = least likely to be preyed upon</p>
</dd>
<dt>sei</dt><dd><p>Sleep exposure index (1-5), 1 = least exposed (e.g. animal sleeps in a
well-protected den), 5 = most exposed</p>
</dd>
<dt>odi</dt><dd><p>Overall danger index (1-5) based on the above two indices and other information, 1 = least
danger (from other animals), 5 = most danger (from other animals)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Allison and Cicchetti (1976) investigated the interrelationship between
sleep, ecological, and constitutional variables.  They assessed these
variables for 39 mammalian species. The authors concluded that slow-wave
sleep is negatively associated with a factor related to body size. This
suggests that large amounts of this sleep phase are disadvantageous in large
species.  Also, paradoxical sleep (REM sleep) was associated with a factor
related to predatory danger, suggesting that large amounts of this sleep
phase are disadvantageous in prey species.
</p>


<h3>Source</h3>

<p>Allison, T., Cicchetti, D.V. (1976). Sleep in Mammals: Ecological and
Constitutional Correlates. Science, 194(4266), 732-734.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sleep &lt;- data(mammalsleep)
</code></pre>

<hr>
<h2 id='matchindex'>Find index of matched donor units</h2><span id='topic+matchindex'></span>

<h3>Description</h3>

<p>Find index of matched donor units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchindex(d, t, k = 5L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchindex_+3A_d">d</code></td>
<td>
<p>Numeric vector with values from donor cases.</p>
</td></tr>
<tr><td><code id="matchindex_+3A_t">t</code></td>
<td>
<p>Numeric vector with values from target cases.</p>
</td></tr>
<tr><td><code id="matchindex_+3A_k">k</code></td>
<td>
<p>Integer, number of unique donors from which a random draw is made.
For <code>k = 1</code> the function returns the index in <code>d</code> corresponding
to the closest unit. For multiple imputation, the
advice is to set values in the range of <code>k = 5</code> to <code>k = 10</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each element in <code>t</code>, the method finds the <code>k</code> nearest
neighbours in <code>d</code>, randomly draws one of these neighbours, and
returns its position in vector <code>d</code>.
</p>
<p>Fast predictive mean matching algorithm in seven steps:
</p>
<p>1. Shuffle records to remove effects of ties
</p>
<p>2. Obtain sorting order on shuffled data
</p>
<p>3. Calculate index on input data and sort it
</p>
<p>4. Pre-sample vector <code>h</code> with values between 1 and <code>k</code>
</p>
<p>For each of the <code>n0</code> elements in <code>t</code>:
</p>
<p>5. find the two adjacent neighbours
</p>
<p>6. find the <code>h_i</code>'th nearest neighbour
</p>
<p>7. store the index of that neighbour
</p>
<p>Return vector of <code>n0</code> positions in <code>d</code>.
</p>
<p>We may use the function to perform predictive mean matching under a given
predictive model. To do so, specify both <code>d</code> and <code>t</code> as
predictions from the same model. Suppose that <code>y</code> contains the observed
outcomes of the donor cases (in the same sequence as <code>d</code>), then
<code>y[matchindex(d, t)]</code> returns one matched outcome for every
target case.
</p>
<p>See <a href="https://github.com/amices/mice/issues/236">https://github.com/amices/mice/issues/236</a>.
This function is a replacement for the <code>matcher()</code> function that has
been in default in <code>mice</code> since version <code>2.22</code> (June 2014).
</p>


<h3>Value</h3>

<p>An integer vector with <code>length(t)</code> elements. Each
element is an index in the array <code>d</code>.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Nasinski Maciej, Alexander Robitzsch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

# Inputs need not be sorted
d &lt;- c(-5, 5, 0, 10, 12)
t &lt;- c(-6, -4, 0, 2, 4, -2, 6)

# Index (in vector a) of closest match
idx &lt;- matchindex(d, t, 1)
idx

# To check: show values of closest match

# Random draw among indices of the 5 closest predictors
matchindex(d, t)

# An example
train &lt;- mtcars[1:20, ]
test &lt;- mtcars[21:32, ]
fit &lt;- lm(mpg ~ disp + cyl, data = train)
d &lt;- fitted.values(fit)
t &lt;- predict(fit, newdata = test)  # note: not using mpg
idx &lt;- matchindex(d, t)

# Borrow values from train to produce 12 synthetic values for mpg in test.
# Synthetic values are plausible values that could have been observed if
# they had been measured.
train$mpg[idx]

# Exercise: Create a distribution of 1000 plausible values for each of the
# twelve mpg entries in test, and count how many times the true value
# (which we know here) is located within the inter-quartile range of each
# distribution. Is your count anywhere close to 500? Why? Why not?
</code></pre>

<hr>
<h2 id='mcar'>Jamshidian and Jalal's Non-Parametric MCAR Test</h2><span id='topic+mcar'></span>

<h3>Description</h3>

<p>Test whether missingness is contingent upon the observed variables,
according to the methodology developed by Jamshidian and Jalal (2010) (see
Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcar(
  x,
  imputed = mice(x, method = "norm"),
  min_n = 6,
  method = "auto",
  replications = 10000,
  use_chisq = 30,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcar_+3A_x">x</code></td>
<td>
<p>An object for which a method exists; usually a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="mcar_+3A_imputed">imputed</code></td>
<td>
<p>Either an object of class <code>mids</code>, as returned by
<code><a href="#topic+mice">mice()</a></code>, or a list of <code>data.frame</code>s.</p>
</td></tr>
<tr><td><code id="mcar_+3A_min_n">min_n</code></td>
<td>
<p>Atomic numeric, must be greater than 1. When there are missing
data patterns with fewer than <code>min_n</code> cases, all cases with that pattern will
be removed from <code>x</code> and <code>imputed</code>.</p>
</td></tr>
<tr><td><code id="mcar_+3A_method">method</code></td>
<td>
<p>Atomic character. If it is known (or assumed) that data are
either multivariate normally distributed or not, then use either
<code>method = "hawkins"</code> or <code>method = "nonparametric"</code>, respectively.
The default argument <code>method = "auto"</code> follows the procedure outlined in the
Details section, and in Figure 7 of Jamshidian and Jalal (2010).</p>
</td></tr>
<tr><td><code id="mcar_+3A_replications">replications</code></td>
<td>
<p>Number of replications used to simulate the Neyman
distribution when performing Hawkins' test. As this method is based on random
sampling, use a high number of <code>replications</code> (and optionally,
<code><a href="base.html#topic+set.seed">set.seed()</a></code>) to minimize Monte Carlo error and ensure reproducibility.</p>
</td></tr>
<tr><td><code id="mcar_+3A_use_chisq">use_chisq</code></td>
<td>
<p>Atomic integer, indicating the minimum number of cases
within a group <em>k</em> that triggers the use of asymptotic Chi-square
distribution instead of the emprical distribution in the Neyman uniformity
test, which is performed as part of Hawkins' test.</p>
</td></tr>
<tr><td><code id="mcar_+3A_alpha">alpha</code></td>
<td>
<p>Atomic numeric, indicating the significance level of tests.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three types of missingness have been distinguished in the literature
(Rubin, 1976):
Missing completely at random (MCAR), which means that missingness is random;
missing at random (MAR), which means that missingness is contingent on the
<em>observed</em>;
and missing not at random (MNAR), which means that missingness is related to
unobserved data.
</p>
<p>Jamshidian and Jalal's non-parametric MCAR test assumes that the missing data
are either MCAR or MAR, and tests whether the missingness is independent of
the observed values. If so, the covariance matrices of the imputed data will
be equal accross groups with different patterns of missingness. This test
consists of the following procedure:
</p>

<ol>
<li><p> Data are imputed.
</p>
</li>
<li><p> The imputed data are split into <em>k</em> groups according to the
<em>k</em> missing data patterns in the original data (see
<code><a href="#topic+md.pattern">md.pattern()</a></code>).
</p>
</li>
<li><p> Perform Hawkins' test for equality of covariances across the <em>k</em>
groups.
</p>
</li>
<li><p> If the test is <em>not significant</em>, conclude that there is no evidence
against multivariate normality of the data, nor against MCAR.
</p>
</li>
<li><p> If the test <em>is significant</em>, and multivariate normality of the data
can be assumed, then it can be concluded that missingness is MAR.
</p>
</li>
<li><p> If multivariate normality cannot be assumed, then perform the
Anderson-Darling non-parametric test for equality of covariances across the
<em>k</em> groups.
</p>
</li>
<li><p> If the Anderson-Darling test is <em>not significant</em>, this is evidence
against multivariate normality - but no evidence against MCAR.
</p>
</li>
<li><p> If the Anderson-Darling test <em>is significant</em>, this is evidence
it can be concluded that missingness is MAR.
</p>
</li></ol>

<p>Note that, despite its name in common parlance, an MCAR test can only
indicate whether missingness is MCAR or MAR. The procedure cannot distinguish
MCAR from MNAR, so a non-significant result does not rule out MNAR.
</p>
<p>This is a re-implementation of the function <code>TestMCARNormality</code>, which was
originally published in the R-packgage <code>MissMech</code>, which has been removed
from CRAN. This new implementation is faster, as its backend is written in
C++. It also enhances the functionality of the original:
</p>

<ul>
<li><p> Multiply imputed data can now be used; the median p-value and test
statistic across replications is then reported, as suggested by
Eekhout, Wiel, and Heymans (2017).
</p>
</li>
<li><p> The printing method for an <code>mcar_object</code> gives a warning when at
least one p-value of either test was significant. In this case, it is
recommended to inspect the range of p-values, and consider potential
violations of MCAR.
</p>
</li>
<li><p> A plotting method for an <code>mcar_object</code> is provided.
</p>
</li>
<li><p> A plotting method for the <code style="white-space: pre;">&#8288;$md.pattern&#8288;</code> element of an <code>mcar_object</code>
is provided.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>mcar_object</code>.
</p>


<h3>Author(s)</h3>

<p>Caspar J. Van Lissa
</p>


<h3>References</h3>

<p>Rubin, D. B. (1976). Inference and Missing Data. Biometrika, Vol. 63, No. 3,
pp. 581-592. <a href="https://doi.org/10.2307/2335739">doi:10.2307/2335739</a>
</p>
<p>Eekhout, I., M. A. Wiel, &amp; M. W. Heymans (2017). Methods for Significance
Testing of Categorical Covariates in Logistic Regression Models After
Multiple Imputation: Power and Applicability Analysis. BMC Medical Research
Methodology 17 (1): 129.
</p>
<p>Jamshidian, M., &amp; Jalal, S. (2010). Tests of homoscedasticity, normality, and
missing completely at random for incomplete multivariate data. Psychometrika,
75(4), 649–674. <a href="https://doi.org/10.1007/s11336-010-9175-3">doi:10.1007/s11336-010-9175-3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- mcar(nhanes)
# Examine test results
res
# Plot p-values across imputed data sets
plot(res)
# Plot md patterns used for the test
plot(res, type = "md.pattern")
# Note difference with the raw md.patterns:
md.pattern(nhanes)
</code></pre>

<hr>
<h2 id='md.pairs'>Missing data pattern by variable pairs</h2><span id='topic+md.pairs'></span>

<h3>Description</h3>

<p>Number of observations per variable pair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md.pairs(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="md.pairs_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The four components in the output value is have the following interpretation:
</p>
 <dl>
<dt>list('rr')</dt><dd><p>response-response, both variables are observed</p>
</dd>
<dt>list('rm')</dt><dd><p>response-missing, row observed, column missing</p>
</dd>
<dt>list('mr')</dt><dd><p>missing -response, row missing, column observed</p>
</dd>
<dt>list('mm')</dt><dd><p>missing -missing, both variables are missing</p>
</dd> </dl>



<h3>Value</h3>

<p>A list of four components named <code>rr</code>, <code>rm</code>, <code>mr</code> and
<code>mm</code>.  Each component is square numerical matrix containing the number
observations within four missing data pattern.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2009
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pat &lt;- md.pairs(nhanes)
pat

# show that these four matrices decompose the total sample size
# for each pair
pat$rr + pat$rm + pat$mr + pat$mm

# percentage of usable cases to impute row variable from column variable
round(100 * pat$mr / (pat$mr + pat$mm))
</code></pre>

<hr>
<h2 id='md.pattern'>Missing data pattern</h2><span id='topic+md.pattern'></span>

<h3>Description</h3>

<p>Display missing-data patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md.pattern(x, plot = TRUE, rotate.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="md.pattern_+3A_x">x</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as NA's.</p>
</td></tr>
<tr><td><code id="md.pattern_+3A_plot">plot</code></td>
<td>
<p>Should the missing data pattern be made into a plot. Default is
'plot = TRUE'.</p>
</td></tr>
<tr><td><code id="md.pattern_+3A_rotate.names">rotate.names</code></td>
<td>
<p>Whether the variable names in the plot should be placed
horizontally or vertically. Default is 'rotate.names = FALSE'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for investigating any structure of missing
observations in the data. In specific case, the missing data pattern could be
(nearly) monotone. Monotonicity can be used to simplify the imputation model.
See Schafer (1997) for details. Also, the missing pattern could suggest which
variables could potentially be useful for imputation of missing entries.
</p>


<h3>Value</h3>

<p>A matrix with <code>ncol(x)+1</code> columns, in which each row corresponds
to a missing data pattern (1=observed, 0=missing).  Rows and columns are
sorted in increasing amounts of missing information. The last column and row
contain row and column counts, respectively.
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, 2018, based on an earlier version of the same function by
Stef van Buuren, Karin Groothuis-Oudshoorn, 2000
</p>


<h3>References</h3>

<p>Schafer, J.L. (1997), Analysis of multivariate incomplete data.
London: Chapman&amp;Hall.
</p>
<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>md.pattern(nhanes)
#     age hyp bmi chl
#  13   1   1   1   1  0
#   1   1   1   0   1  1
#   3   1   1   1   0  1
#   1   1   0   0   1  2
#   7   1   0   0   0  3
#   0   8   9  10 27
</code></pre>

<hr>
<h2 id='mdc'>Graphical parameter for missing data plots</h2><span id='topic+mdc'></span>

<h3>Description</h3>

<p><code>mdc</code> returns colors used to distinguish observed, missing and combined
data in plotting. <code>mice.theme</code> return a partial list of named objects
that can be used as a theme in <code>stripplot</code>, <code>bwplot</code>,
<code>densityplot</code> and <code>xyplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdc(
  r = "observed",
  s = "symbol",
  transparent = TRUE,
  cso = grDevices::hcl(240, 100, 40, 0.7),
  csi = grDevices::hcl(0, 100, 40, 0.7),
  csc = "gray50",
  clo = grDevices::hcl(240, 100, 40, 0.8),
  cli = grDevices::hcl(0, 100, 40, 0.8),
  clc = "gray50"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdc_+3A_r">r</code></td>
<td>
<p>A numerical or character vector. The numbers 1-6 request colors as
follows: 1=<code>cso</code>, 2=<code>csi</code>, 3=<code>csc</code>, 4=<code>clo</code>, 5=<code>cli</code>
and 6=<code>clc</code>. Alternatively, <code>r</code> may contain the strings
' <code>observed</code>', '<code>missing</code>', or '<code>both</code>', or abbreviations
thereof.</p>
</td></tr>
<tr><td><code id="mdc_+3A_s">s</code></td>
<td>
<p>A character vector containing the strings '<code>symbol</code>' or
' <code>line</code>', or abbreviations thereof.</p>
</td></tr>
<tr><td><code id="mdc_+3A_transparent">transparent</code></td>
<td>
<p>A logical indicating whether alpha-transparency is
allowed. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mdc_+3A_cso">cso</code></td>
<td>
<p>The symbol color for the observed data. The default is a
transparent blue.</p>
</td></tr>
<tr><td><code id="mdc_+3A_csi">csi</code></td>
<td>
<p>The symbol color for the missing or imputed data. The default is a
transparent red.</p>
</td></tr>
<tr><td><code id="mdc_+3A_csc">csc</code></td>
<td>
<p>The symbol color for the combined observed and imputed data. The
default is a grey color.</p>
</td></tr>
<tr><td><code id="mdc_+3A_clo">clo</code></td>
<td>
<p>The line color for the observed data. The default is a slightly
darker transparent blue.</p>
</td></tr>
<tr><td><code id="mdc_+3A_cli">cli</code></td>
<td>
<p>The line color for the missing or imputed data. The default is a
slightly darker transparent red.</p>
</td></tr>
<tr><td><code id="mdc_+3A_clc">clc</code></td>
<td>
<p>The line color for the combined observed and imputed data. The
default is a grey color.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function eases consistent use of colors in plots. The default follows
the Abayomi convention, which uses blue for observed data, red for missing or
imputed data, and black for combined data.
</p>


<h3>Value</h3>

<p><code>mdc()</code> returns a vector containing color definitions. The length
of the output vector is calculate from the length of <code>r</code> and <code>s</code>.
Elements of the input vectors are repeated if needed.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, sept 2012.
</p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+hcl">hcl</a></code>, <code><a href="grDevices.html#topic+rgb">rgb</a></code>,
<code><a href="#topic+xyplot.mids">xyplot.mids</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all six colors
mdc(1:6)

# lines color for observed and missing data
mdc(c("obs", "mis"), "lin")
</code></pre>

<hr>
<h2 id='mice'><span class="pkg">mice</span>: Multivariate Imputation by Chained Equations</h2><span id='topic+mice'></span>

<h3>Description</h3>

<p>The <span class="pkg">mice</span> package implements a method to deal with missing data.
The package creates multiple imputations (replacement values) for
multivariate missing data. The method is based on Fully Conditional
Specification, where each incomplete variable is imputed by a separate
model. The MICE algorithm can impute mixes of continuous, binary,
unordered categorical and ordered categorical data. In addition, MICE
can impute continuous two-level data, and maintain consistency between
imputations by means of passive imputation. Many diagnostic plots are
implemented to inspect the quality of the imputations.
</p>
<p>Generates Multivariate Imputations by Chained Equations (MICE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice(
  data,
  m = 5,
  method = NULL,
  predictorMatrix,
  ignore = NULL,
  where = NULL,
  blocks,
  visitSequence = NULL,
  formulas,
  blots = NULL,
  post = NULL,
  defaultMethod = c("pmm", "logreg", "polyreg", "polr"),
  maxit = 5,
  printFlag = TRUE,
  seed = NA,
  data.init = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_m">m</code></td>
<td>
<p>Number of multiple imputations. The default is <code>m=5</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_method">method</code></td>
<td>
<p>Can be either a single string, or a vector of strings with
length <code>length(blocks)</code>, specifying the imputation method to be
used for each column in data. If specified as a single string, the same
method will be used for all blocks. The default imputation method (when no
argument is specified) depends on the measurement level of the target column,
as regulated by the <code>defaultMethod</code> argument. Columns that need
not be imputed have the empty method <code>""</code>. See details.</p>
</td></tr>
<tr><td><code id="mice_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>A numeric matrix of <code>length(blocks)</code> rows
and <code>ncol(data)</code> columns, containing 0/1 data specifying
the set of predictors to be used for each target column.
Each row corresponds to a variable block, i.e., a set of variables
to be imputed. A value of <code>1</code> means that the column
variable is used as a predictor for the target block (in the rows).
By default, the <code>predictorMatrix</code> is a square matrix of <code>ncol(data)</code>
rows and columns with all 1's, except for the diagonal.
Note: For two-level imputation models (which have <code>"2l"</code> in their names)
other codes (e.g, <code>2</code> or <code>-2</code>) are also allowed.</p>
</td></tr>
<tr><td><code id="mice_+3A_ignore">ignore</code></td>
<td>
<p>A logical vector of <code>nrow(data)</code> elements indicating
which rows are ignored when creating the imputation model. The default
<code>NULL</code> includes all rows that have an observed value of the variable
to imputed. Rows with <code>ignore</code> set to <code>TRUE</code> do not influence the
parameters of the imputation model, but are still imputed. We may use the
<code>ignore</code> argument to split <code>data</code> into a training set (on which the
imputation model is built) and a test set (that does not influence the
imputation model estimates).
Note: Multivariate imputation methods, like <code>mice.impute.jomoImpute()</code>
or <code>mice.impute.panImpute()</code>, do not honour the <code>ignore</code> argument.</p>
</td></tr>
<tr><td><code id="mice_+3A_where">where</code></td>
<td>
<p>A data frame or matrix with logicals of the same dimensions
as <code>data</code> indicating where in the data the imputations should be
created. The default, <code>where = is.na(data)</code>, specifies that the
missing data should be imputed. The <code>where</code> argument may be used to
overimpute observed data, or to skip imputations for selected missing values.
Note: Imputation methods that generate imptutations outside of
<code>mice</code>, like <code>mice.impute.panImpute()</code> may depend on a complete
predictor space. In that case, a custom <code>where</code> matrix can not be
specified.</p>
</td></tr>
<tr><td><code id="mice_+3A_blocks">blocks</code></td>
<td>
<p>List of vectors with variable names per block. List elements
may be named to identify blocks. Variables within a block are
imputed by a multivariate imputation method
(see <code>method</code> argument). By default each variable is placed
into its own block, which is effectively
fully conditional specification (FCS) by univariate models
(variable-by-variable imputation). Only variables whose names appear in
<code>blocks</code> are imputed. The relevant columns in the <code>where</code>
matrix are set to <code>FALSE</code> of variables that are not block members.
A variable may appear in multiple blocks. In that case, it is
effectively re-imputed each time that it is visited.</p>
</td></tr>
<tr><td><code id="mice_+3A_visitsequence">visitSequence</code></td>
<td>
<p>A vector of block names of arbitrary length, specifying the
sequence of blocks that are imputed during one iteration of the Gibbs
sampler. A block is a collection of variables. All variables that are
members of the same block are imputed
when the block is visited. A variable that is a member of multiple blocks
is re-imputed within the same iteration.
The default <code>visitSequence = "roman"</code> visits the blocks (left to right)
in the order in which they appear in <code>blocks</code>.
One may also use one of the following keywords: <code>"arabic"</code>
(right to left), <code>"monotone"</code> (ordered low to high proportion
of missing data) and <code>"revmonotone"</code> (reverse of monotone).
<em>Special case</em>: If you specify both <code>visitSequence = "monotone"</code> and
<code>maxit = 1</code>, then the procedure will edit the <code>predictorMatrix</code>
to conform to the monotone pattern. Realize that convergence in one
iteration is only guaranteed if the missing data pattern is actually
monotone. The procedure does not check this.</p>
</td></tr>
<tr><td><code id="mice_+3A_formulas">formulas</code></td>
<td>
<p>A named list of formula's, or expressions that
can be converted into formula's by <code>as.formula</code>. List elements
correspond to blocks. The block to which the list element applies is
identified by its name, so list names must correspond to block names.
The <code>formulas</code> argument is an alternative to the
<code>predictorMatrix</code> argument that allows for more flexibility in
specifying imputation models, e.g., for specifying interaction terms.</p>
</td></tr>
<tr><td><code id="mice_+3A_blots">blots</code></td>
<td>
<p>A named <code>list</code> of <code>alist</code>'s that can be used
to pass down arguments to lower level imputation function. The entries
of element <code>blots[[blockname]]</code> are passed down to the function
called for block <code>blockname</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_post">post</code></td>
<td>
<p>A vector of strings with length <code>ncol(data)</code> specifying
expressions as strings. Each string is parsed and
executed within the <code>sampler()</code> function to post-process
imputed values during the iterations.
The default is a vector of empty strings, indicating no post-processing.
Multivariate (block) imputation methods ignore the <code>post</code> parameter.</p>
</td></tr>
<tr><td><code id="mice_+3A_defaultmethod">defaultMethod</code></td>
<td>
<p>A vector of length 4 containing the default
imputation methods for 1) numeric data, 2) factor data with 2 levels, 3)
factor data with &gt; 2 unordered levels, and 4) factor data with &gt; 2
ordered levels. By default, the method uses
<code>pmm</code>, predictive mean matching (numeric data) <code>logreg</code>, logistic
regression imputation (binary data, factor with 2 levels) <code>polyreg</code>,
polytomous regression imputation for unordered categorical data (factor &gt; 2
levels) <code>polr</code>, proportional odds model for (ordered, &gt; 2 levels).</p>
</td></tr>
<tr><td><code id="mice_+3A_maxit">maxit</code></td>
<td>
<p>A scalar giving the number of iterations. The default is 5.</p>
</td></tr>
<tr><td><code id="mice_+3A_printflag">printFlag</code></td>
<td>
<p>If <code>TRUE</code>, <code>mice</code> will print history on console.
Use <code>print=FALSE</code> for silent computation.</p>
</td></tr>
<tr><td><code id="mice_+3A_seed">seed</code></td>
<td>
<p>An integer that is used as argument by the <code>set.seed()</code> for
offsetting the random number generator. Default is to leave the random number
generator alone.</p>
</td></tr>
<tr><td><code id="mice_+3A_data.init">data.init</code></td>
<td>
<p>A data frame of the same size and type as <code>data</code>,
without missing data, used to initialize imputations before the start of the
iterative process.  The default <code>NULL</code> implies that starting imputation
are created by a simple random draw from the data. Note that specification of
<code>data.init</code> will start all <code>m</code> Gibbs sampling streams from the same
imputation.</p>
</td></tr>
<tr><td><code id="mice_+3A_...">...</code></td>
<td>
<p>Named arguments that are passed down to the univariate imputation
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <span class="pkg">mice</span> package contains functions to
</p>

<ul>
<li><p> Inspect the missing data pattern
</p>
</li>
<li><p> Impute the missing data <em>m</em> times, resulting in <em>m</em> completed data sets
</p>
</li>
<li><p> Diagnose the quality of the imputed values
</p>
</li>
<li><p> Analyze each completed data set
</p>
</li>
<li><p> Pool the results of the repeated analyses
</p>
</li>
<li><p> Store and export the imputed data in various formats
</p>
</li>
<li><p> Generate simulated incomplete data
</p>
</li>
<li><p> Incorporate custom imputation methods
</p>
</li></ul>

<p>Generates multiple imputations for incomplete multivariate data by Gibbs
sampling. Missing data can occur anywhere in the data. The algorithm imputes
an incomplete column (the target column) by generating 'plausible' synthetic
values given other columns in the data. Each incomplete column must act as a
target column, and has its own specific set of predictors. The default set of
predictors for a given target consists of all other columns in the data. For
predictors that are incomplete themselves, the most recently generated
imputations are used to complete the predictors prior to imputation of the
target column.
</p>
<p>A separate univariate imputation model can be specified for each column. The
default imputation method depends on the measurement level of the target
column. In addition to these, several other methods are provided. You can
also write their own imputation functions, and call these from within the
algorithm.
</p>
<p>The data may contain categorical variables that are used in a regressions on
other variables. The algorithm creates dummy variables for the categories of
these variables, and imputes these from the corresponding categorical
variable.
</p>
<p>Built-in univariate imputation methods are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>pmm</code>               </td><td style="text-align: left;"> any     </td><td style="text-align: left;"> Predictive mean matching</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>midastouch</code>        </td><td style="text-align: left;"> any     </td><td style="text-align: left;"> Weighted predictive mean matching</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>sample</code>            </td><td style="text-align: left;"> any     </td><td style="text-align: left;"> Random sample from observed values</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cart</code>              </td><td style="text-align: left;"> any     </td><td style="text-align: left;"> Classification and regression trees</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rf</code>                </td><td style="text-align: left;"> any     </td><td style="text-align: left;"> Random forest imputations</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mean</code>              </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Unconditional mean imputation</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>norm</code>              </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Bayesian linear regression</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>norm.nob</code>          </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Linear regression ignoring model error</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>norm.boot</code>         </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Linear regression using bootstrap</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>norm.predict</code>      </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Linear regression, predicted values</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lasso.norm</code>        </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Lasso linear regression</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lasso.select.norm</code> </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Lasso select + linear regression</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>quadratic</code>         </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Imputation of quadratic terms</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ri</code>                </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Random indicator for nonignorable data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>logreg</code>            </td><td style="text-align: left;"> binary  </td><td style="text-align: left;"> Logistic regression</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>logreg.boot</code>       </td><td style="text-align: left;"> binary  </td><td style="text-align: left;"> Logistic regression with bootstrap</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lasso.logreg</code>      </td><td style="text-align: left;"> binary  </td><td style="text-align: left;"> Lasso logistic regression</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lasso.select.logreg</code></td><td style="text-align: left;"> binary  </td><td style="text-align: left;"> Lasso select + logistic regression</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>polr</code>              </td><td style="text-align: left;"> ordered </td><td style="text-align: left;"> Proportional odds model</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>polyreg</code>           </td><td style="text-align: left;"> unordered</td><td style="text-align: left;"> Polytomous logistic regression</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lda</code>               </td><td style="text-align: left;"> unordered</td><td style="text-align: left;"> Linear discriminant analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>2l.norm</code>           </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> Level-1 normal heteroscedastic</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>2l.lmer</code>           </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> Level-1 normal homoscedastic, lmer</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>2l.pan</code>            </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> Level-1 normal homoscedastic, pan</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>2l.bin</code>            </td><td style="text-align: left;"> binary   </td><td style="text-align: left;"> Level-1 logistic, glmer</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>2lonly.mean</code>       </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> Level-2 class mean</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>2lonly.norm</code>       </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> Level-2 class normal</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>2lonly.pmm</code>        </td><td style="text-align: left;"> any      </td><td style="text-align: left;"> Level-2 class predictive mean matching
</td>
</tr>

</table>

<p>These corresponding functions are coded in the <code>mice</code> library under
names <code>mice.impute.method</code>, where <code>method</code> is a string with the
name of the univariate imputation method name, for example <code>norm</code>. The
<code>method</code> argument specifies the methods to be used.  For the <code>j</code>'th
column, <code>mice()</code> calls the first occurrence of
<code>paste('mice.impute.', method[j], sep = '')</code> in the search path.  The
mechanism allows uses to write customized imputation function,
<code>mice.impute.myfunc</code>. To call it for all columns specify
<code>method='myfunc'</code>.  To call it only for, say, column 2 specify
<code>method=c('norm','myfunc','logreg',...{})</code>.
</p>
<p><em>Skipping imputation:</em> The user may skip imputation of a column by
setting its entry to the empty method: <code>""</code>. For complete columns without
missing data <code>mice</code> will automatically set the empty method. Setting t
he empty method does not produce imputations for the column, so any missing
cells remain <code>NA</code>. If column A contains <code>NA</code>'s and is used as
predictor in the imputation model for column B, then <code>mice</code> produces no
imputations for the rows in B where A is missing. The imputed data
for B may thus contain <code>NA</code>'s. The remedy is to remove column A from
the imputation model for the other columns in the data. This can be done
by setting the entire column for variable A in the <code>predictorMatrix</code>
equal to zero.
</p>
<p><em>Passive imputation:</em> <code>mice()</code> supports a special built-in method,
called passive imputation. This method can be used to ensure that a data
transform always depends on the most recently generated imputations.  In some
cases, an imputation model may need transformed data in addition to the
original data (e.g. log, quadratic, recodes, interaction, sum scores, and so
on).
</p>
<p>Passive imputation maintains consistency among different transformations of
the same data. Passive imputation is invoked if <code>~</code> is specified as the
first character of the string that specifies the univariate method.
<code>mice()</code> interprets the entire string, including the <code>~</code> character,
as the formula argument in a call to <code>model.frame(formula,
data[!r[,j],])</code>. This provides a simple mechanism for specifying deterministic
dependencies among the columns. For example, suppose that the missing entries
in variables <code>data$height</code> and <code>data$weight</code> are imputed. The body
mass index (BMI) can be calculated within <code>mice</code> by specifying the
string <code>'~I(weight/height^2)'</code> as the univariate imputation method for
the target column <code>data$bmi</code>.  Note that the <code>~</code> mechanism works
only on those entries which have missing values in the target column. You
should make sure that the combined observed and imputed parts of the target
column make sense. An easy way to create consistency is by coding all entries
in the target as <code>NA</code>, but for large data sets, this could be
inefficient.  Note that you may also need to adapt the default
<code>predictorMatrix</code> to evade linear dependencies among the predictors that
could cause errors like <code>Error in solve.default()</code> or <code>Error:
system is exactly singular</code>. Though not strictly needed, it is often useful
to specify <code>visitSequence</code> such that the column that is imputed by the
<code>~</code> mechanism is visited each time after one of its predictors was
visited. In that way, deterministic relation between columns will always be
synchronized.
</p>
<p>#'A new argument <code>ls.meth</code> can be parsed to the lower level
<code>.norm.draw</code> to specify the method for generating the least squares
estimates and any subsequently derived estimates. Argument <code>ls.meth</code>
takes one of three inputs: <code>"qr"</code> for QR-decomposition, <code>"svd"</code> for
singular value decomposition and <code>"ridge"</code> for ridge regression.
<code>ls.meth</code> defaults to <code>ls.meth = "qr"</code>.
</p>
<p><em>Auxiliary predictors in formulas specification: </em>
For a given block, the <code>formulas</code> specification takes precedence over
the corresponding row in the <code>predictMatrix</code> argument. This
precedence is, however, restricted to the subset of variables
specified in the terms of the block formula. Any
variables not specified by <code>formulas</code> are imputed
according to the <code>predictMatrix</code> specification. Variables with
non-zero <code>type</code> values in the <code>predictMatrix</code> will
be added as main effects to the <code>formulas</code>, which will
act as supplementary covariates in the imputation model. It is possible
to turn off this behavior by specifying the
argument <code>auxiliary = FALSE</code>.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code><a href="#topic+mids-class">mids</a></code>
(multiply imputed data set)
</p>


<h3>Functions</h3>

<p>The main functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>mice()</code> </td><td style="text-align: left;"> Impute the missing data *m* times</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>with()</code> </td><td style="text-align: left;"> Analyze completed data sets</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pool()</code> </td><td style="text-align: left;"> Combine parameter estimates</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>complete()</code> </td><td style="text-align: left;"> Export imputed data</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>ampute()</code> </td><td style="text-align: left;"> Generate missing data</td>
</tr>

</table>



<h3>Vignettes</h3>

<p>There is a detailed series of
six online vignettes that walk you through solving realistic inference
problems with mice.
</p>
<p>We suggest going through these vignettes in the following order
</p>

<ol>
<li> <p><a href="https://www.gerkovink.com/miceVignettes/Ad_hoc_and_mice/Ad_hoc_methods.html">Ad hoc methods and the MICE algorithm</a>
</p>
</li>
<li> <p><a href="https://www.gerkovink.com/miceVignettes/Convergence_pooling/Convergence_and_pooling.html">Convergence and pooling</a>
</p>
</li>
<li> <p><a href="https://www.gerkovink.com/miceVignettes/Missingness_inspection/Missingness_inspection.html">Inspecting how the observed data and missingness are related</a>
</p>
</li>
<li> <p><a href="https://www.gerkovink.com/miceVignettes/Passive_Post_processing/Passive_imputation_post_processing.html">Passive imputation and post-processing</a>
</p>
</li>
<li> <p><a href="https://www.gerkovink.com/miceVignettes/Multi_level/Multi_level_data.html">Imputing multilevel data</a>
</p>
</li>
<li> <p><a href="https://www.gerkovink.com/miceVignettes/Sensitivity_analysis/Sensitivity_analysis.html">Sensitivity analysis with <span class="pkg">mice</span></a>
</p>
</li></ol>

<p>#'Van Buuren, S. (2018).
Boca Raton, FL.: Chapman &amp; Hall/CRC Press.
The book
<a href="https://stefvanbuuren.name/fimd/"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
contains a lot of <a href="https://github.com/stefvanbuuren/fimdbook/tree/master/R">example code</a>.
</p>


<h3>Methodology</h3>

<p>The <span class="pkg">mice</span> software was published in the Journal of Statistical Software (Van Buuren and Groothuis-Oudshoorn, 2011). <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
The first application of the method
concerned missing blood pressure data (Van Buuren et. al., 1999).
The term <em>Fully Conditional Specification</em> was introduced in 2006 to describe a general class of methods that specify imputations model for multivariate data as a set of conditional distributions (Van Buuren et. al., 2006). Further details on mixes of variables and applications can be found in the book
<a href="https://stefvanbuuren.name/fimd/"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>Enhanced linear algebra</h3>

<p>Updating the BLAS can improve speed of R, sometime considerably. The details
depend on the operating system. See the discussion in the
&quot;R Installation and Administration&quot; guide for further information.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren <a href="mailto:stef.vanbuuren@tno.nl">stef.vanbuuren@tno.nl</a>, Karin
Groothuis-Oudshoorn <a href="mailto:c.g.m.oudshoorn@utwente.nl">c.g.m.oudshoorn@utwente.nl</a>, 2000-2010, with
contributions of Alexander Robitzsch, Gerko Vink, Shahab Jolani,
Roel de Jong, Jason Turner, Lisa Doove,
John Fox, Frank E. Harrell, and Peter Malewski.
</p>


<h3>References</h3>

<p>van Buuren, S., Boshuizen, H.C., Knook, D.L. (1999) Multiple
imputation of missing blood pressure covariates in survival analysis.
<em>Statistics in Medicine</em>, <b>18</b>, 681&ndash;694.
</p>
<p>van Buuren, S., Brand, J.P.L., Groothuis-Oudshoorn C.G.M., Rubin, D.B. (2006)
Fully conditional specification in multivariate imputation.  <em>Journal of
Statistical Computation and Simulation</em>, <b>76</b>, 12, 1049&ndash;1064.
</p>
<p>van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1&ndash;67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-FCS.html#sec:MICE"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>Van Buuren, S., Brand, J.P.L., Groothuis-Oudshoorn C.G.M., Rubin, D.B. (2006)
Fully conditional specification in multivariate imputation.  <em>Journal of
Statistical Computation and Simulation</em>, <b>76</b>, 12, 1049&ndash;1064.
</p>
<p>Van Buuren, S. (2007) Multiple imputation of discrete and continuous data by
fully conditional specification.  <em>Statistical Methods in Medical
Research</em>, <b>16</b>, 3, 219&ndash;242.
</p>
<p>Van Buuren, S., Boshuizen, H.C., Knook, D.L. (1999) Multiple imputation of
missing blood pressure covariates in survival analysis.  <em>Statistics in
Medicine</em>, <b>18</b>, 681&ndash;694.
</p>
<p>Brand, J.P.L. (1999) <em>Development, implementation and evaluation of
multiple imputation strategies for the statistical analysis of incomplete
data sets.</em> Dissertation. Rotterdam: Erasmus University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+with.mids">with.mids</a></code>,
<code><a href="#topic+pool">pool</a></code>, <code><a href="#topic+complete">complete</a></code>, <code><a href="#topic+ampute">ampute</a></code>
</p>
<p><code><a href="#topic+mids-class">mids</a></code>, <code><a href="#topic+with.mids">with.mids</a></code>,
<code><a href="base.html#topic+set.seed">set.seed</a></code>, <code><a href="#topic+complete">complete</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># do default multiple imputation on a numeric matrix
imp &lt;- mice(nhanes)
imp

# list the actual imputations for BMI
imp$imp$bmi

# first completed data matrix
complete(imp)

# imputation on mixed data with a different method per column
mice(nhanes2, meth = c("sample", "pmm", "logreg", "norm"))

## Not run: 
# example where we fit the imputation model on the train data
# and apply the model to impute the test data
set.seed(123)
ignore &lt;- sample(c(TRUE, FALSE), size = 25, replace = TRUE, prob = c(0.3, 0.7))

# scenario 1: train and test in the same dataset
imp &lt;- mice(nhanes2, m = 2, ignore = ignore, print = FALSE, seed = 22112)
imp.test1 &lt;- filter(imp, ignore)
imp.test1$data
complete(imp.test1, 1)
complete(imp.test1, 2)

# scenario 2: train and test in separate datasets
traindata &lt;- nhanes2[!ignore, ]
testdata &lt;- nhanes2[ignore, ]
imp.train &lt;- mice(traindata, m = 2, print = FALSE, seed = 22112)
imp.test2 &lt;- mice.mids(imp.train, newdata = testdata)
complete(imp.test2, 1)
complete(imp.test2, 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.2l.bin'>Imputation by a two-level logistic model using <code>glmer</code></h2><span id='topic+mice.impute.2l.bin'></span>

<h3>Description</h3>

<p>Imputes univariate systematically and sporadically missing data
using a two-level logistic model using <code>lme4::glmer()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2l.bin(y, ry, x, type, wy = NULL, intercept = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2l.bin_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.2l.bin_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.bin_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.bin_+3A_type">type</code></td>
<td>
<p>Vector of length <code>ncol(x)</code> identifying random and class
variables.  Random variables are identified by a '2'. The class variable
(only one is allowed) is coded as '-2'. Fixed effects are indicated by
a '1'.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.bin_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.bin_+3A_intercept">intercept</code></td>
<td>
<p>Logical determining whether the intercept is automatically
added.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.bin_+3A_...">...</code></td>
<td>
<p>Arguments passed down to <code>glmer</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are missing systematically if they have not been measured, e.g., in the
case where we combine data from different sources. Data are missing sporadically
if they have been partially observed.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Shahab Jolani, 2015; adapted to mice, SvB, 2018
</p>


<h3>References</h3>

<p>Jolani S., Debray T.P.A., Koffijberg H., van Buuren S., Moons K.G.M. (2015).
Imputation of systematically missing predictors in an individual
participant data meta-analysis: a generalized approach using MICE.
<em>Statistics in Medicine</em>, 34:1841-1863.
</p>


<h3>See Also</h3>

<p>Other univariate-2l: 
<code><a href="#topic+mice.impute.2l.lmer">mice.impute.2l.lmer</a>()</code>,
<code><a href="#topic+mice.impute.2l.norm">mice.impute.2l.norm</a>()</code>,
<code><a href="#topic+mice.impute.2l.pan">mice.impute.2l.pan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)
library(dplyr)
data("toenail2")
data &lt;- tidyr::complete(toenail2, patientID, visit) %&gt;%
  tidyr::fill(treatment) %&gt;%
  dplyr::select(-time) %&gt;%
  dplyr::mutate(patientID = as.integer(patientID))
## Not run: 
pred &lt;- mice(data, print = FALSE, maxit = 0, seed = 1)$pred
pred["outcome", "patientID"] &lt;- -2
imp &lt;- mice(data, method = "2l.bin", pred = pred, maxit = 1, m = 1, seed = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.2l.lmer'>Imputation by a two-level normal model using <code>lmer</code></h2><span id='topic+mice.impute.2l.lmer'></span>

<h3>Description</h3>

<p>Imputes univariate systematically and sporadically missing data using a
two-level normal model using <code>lme4::lmer()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2l.lmer(y, ry, x, type, wy = NULL, intercept = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2l.lmer_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.2l.lmer_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.lmer_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.lmer_+3A_type">type</code></td>
<td>
<p>Vector of length <code>ncol(x)</code> identifying random and class
variables.  Random variables are identified by a '2'. The class variable
(only one is allowed) is coded as '-2'. Fixed effects are indicated by
a '1'.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.lmer_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.lmer_+3A_intercept">intercept</code></td>
<td>
<p>Logical determining whether the intercept is automatically
added.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.lmer_+3A_...">...</code></td>
<td>
<p>Arguments passed down to <code>lmer</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are missing systematically if they have not been measured, e.g., in the
case where we combine data from different sources. Data are missing sporadically
if they have been partially observed.
</p>
<p>While the method is fully Bayesian, it may fix parameters of the
variance-covariance matrix or the random effects to their estimated
value in cases where creating draws from the posterior is not
possible. The procedure throws a warning when this happens.
</p>
<p>If <code>lme4::lmer()</code> fails, the procedure prints the warning
<code>"lmer does not run. Simplify imputation model"</code> and returns the
current imputation.  If that happens we see flat lines in the
trace line plots. Thus, the appearance of flat trace lines should be taken
as an additional alert to a problem with imputation model fitting.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Shahab Jolani, 2017
</p>


<h3>References</h3>

<p>Jolani S. (2017) Hierarchical imputation of systematically and
sporadically missing data: An approximate Bayesian approach using
chained equations. Forthcoming.
</p>
<p>Jolani S., Debray T.P.A., Koffijberg H., van Buuren S., Moons K.G.M. (2015).
Imputation of systematically missing predictors in an individual
participant data meta-analysis: a generalized approach using MICE.
<em>Statistics in Medicine</em>, 34:1841-1863.
</p>
<p>Van Buuren, S. (2011) Multiple imputation of multilevel data. In Hox, J.J.
and and Roberts, J.K. (Eds.), <em>The Handbook of Advanced Multilevel
Analysis</em>, Chapter 10, pp. 173&ndash;196. Milton Park, UK: Routledge.
</p>


<h3>See Also</h3>

<p>Other univariate-2l: 
<code><a href="#topic+mice.impute.2l.bin">mice.impute.2l.bin</a>()</code>,
<code><a href="#topic+mice.impute.2l.norm">mice.impute.2l.norm</a>()</code>,
<code><a href="#topic+mice.impute.2l.pan">mice.impute.2l.pan</a>()</code>
</p>

<hr>
<h2 id='mice.impute.2l.norm'>Imputation by a two-level normal model</h2><span id='topic+mice.impute.2l.norm'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using a two-level normal model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2l.norm(y, ry, x, type, wy = NULL, intercept = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2l.norm_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.2l.norm_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.norm_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.norm_+3A_type">type</code></td>
<td>
<p>Vector of length <code>ncol(x)</code> identifying random and class
variables.  Random variables are identified by a '2'. The class variable
(only one is allowed) is coded as '-2'. Random variables also include the
fixed effect.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.norm_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.norm_+3A_intercept">intercept</code></td>
<td>
<p>Logical determining whether the intercept is automatically
added.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.norm_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the Gibbs sampler for the linear multilevel model with
heterogeneous with-class variance (Kasim and Raudenbush, 1998). Imputations
are drawn as an extra step to the algorithm. For simulation work see Van
Buuren (2011).
</p>
<p>The random intercept is automatically added in <code>mice.impute.2L.norm()</code>.
A model within a random intercept can be specified by <code>mice(...,
intercept = FALSE)</code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Note</h3>

<p>Added June 25, 2012: The currently implemented algorithm does not
handle predictors that are specified as fixed effects (type=1). When using
<code>mice.impute.2l.norm()</code>, the current advice is to specify all predictors
as random effects (type=2).
</p>
<p>Warning: The assumption of heterogeneous variances requires that in every
class at least one observation has a response in <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Roel de Jong, 2008
</p>


<h3>References</h3>

<p>Kasim RM, Raudenbush SW. (1998). Application of Gibbs sampling to nested
variance components models with heterogeneous within-group variance. Journal
of Educational and Behavioral Statistics, 23(2), 93&ndash;116.
</p>
<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Van Buuren, S. (2011) Multiple imputation of multilevel data. In Hox, J.J.
and and Roberts, J.K. (Eds.), <em>The Handbook of Advanced Multilevel
Analysis</em>, Chapter 10, pp. 173&ndash;196. Milton Park, UK: Routledge.
</p>


<h3>See Also</h3>

<p>Other univariate-2l: 
<code><a href="#topic+mice.impute.2l.bin">mice.impute.2l.bin</a>()</code>,
<code><a href="#topic+mice.impute.2l.lmer">mice.impute.2l.lmer</a>()</code>,
<code><a href="#topic+mice.impute.2l.pan">mice.impute.2l.pan</a>()</code>
</p>

<hr>
<h2 id='mice.impute.2l.pan'>Imputation by a two-level normal model using <code>pan</code></h2><span id='topic+mice.impute.2l.pan'></span><span id='topic+2l.pan'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using a two-level normal model with
homogeneous within group variances. Aggregated group effects (i.e. group
means) can be automatically created and included as predictors in the
two-level regression (see argument <code>type</code>). This function needs the
<code>pan</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2l.pan(
  y,
  ry,
  x,
  type,
  intercept = TRUE,
  paniter = 500,
  groupcenter.slope = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2l.pan_+3A_y">y</code></td>
<td>
<p>Incomplete data vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="mice.impute.2l.pan_+3A_ry">ry</code></td>
<td>
<p>Vector of missing data pattern (<code>FALSE</code>=missing,
<code>TRUE</code>=observed)</p>
</td></tr>
<tr><td><code id="mice.impute.2l.pan_+3A_x">x</code></td>
<td>
<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.pan_+3A_type">type</code></td>
<td>
<p>Vector of length <code>ncol(x)</code> identifying random and class
variables.  Random effects are identified by a '2'. The group variable (only
one is allowed) is coded as '-2'. Random effects also include the fixed
effect. If for a covariates X1 group means shall be calculated and included
as further fixed effects choose '3'. In addition to the effects in '3',
specification '4' also includes random effects of X1.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.pan_+3A_intercept">intercept</code></td>
<td>
<p>Logical determining whether the intercept is automatically
added.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.pan_+3A_paniter">paniter</code></td>
<td>
<p>Number of iterations in <code>pan</code>. Default is 500.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.pan_+3A_groupcenter.slope">groupcenter.slope</code></td>
<td>
<p>If <code>TRUE</code>, in case of group means (<code>type</code>
is '3' or'4') group mean centering for these predictors are conducted before
doing imputations. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.pan_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the Gibbs sampler for the linear two-level model with homogeneous
within group variances which is a special case of a multivariate linear mixed
effects model (Schafer &amp; Yucel, 2002).  For a two-level imputation with
heterogeneous within-group variances see <code><a href="#topic+mice.impute.2l.norm">mice.impute.2l.norm</a></code>. 
The random intercept is automatically added in 
<code>mice.impute.2l.norm()</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>nmis</code> with imputations.
</p>


<h3>Note</h3>

<p>This function does not implement the <code>where</code> functionality. It
always produces <code>nmis</code> imputation, irrespective of the <code>where</code>
argument of the <code>mice</code> function.
</p>


<h3>Author(s)</h3>

<p>Alexander Robitzsch (IPN - Leibniz Institute for Science and
Mathematics Education, Kiel, Germany), <a href="mailto:robitzsch@ipn.uni-kiel.de">robitzsch@ipn.uni-kiel.de</a>
</p>
<p>Alexander Robitzsch (IPN - Leibniz Institute for Science and
Mathematics Education, Kiel, Germany), <a href="mailto:robitzsch@ipn.uni-kiel.de">robitzsch@ipn.uni-kiel.de</a>.
</p>


<h3>References</h3>

<p>Schafer J L, Yucel RM (2002). Computational strategies for multivariate
linear mixed-effects models with missing values.  <em>Journal of
Computational and Graphical Statistics</em>. <b>11</b>, 437-457.
</p>
<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p>Other univariate-2l: 
<code><a href="#topic+mice.impute.2l.bin">mice.impute.2l.bin</a>()</code>,
<code><a href="#topic+mice.impute.2l.lmer">mice.impute.2l.lmer</a>()</code>,
<code><a href="#topic+mice.impute.2l.norm">mice.impute.2l.norm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
# two-level regression model with fixed slope

# number of groups
G &lt;- 250
# number of persons
n &lt;- 20
# regression parameter
beta &lt;- .3
# intraclass correlation
rho &lt;- .30
# correlation with missing response
rho.miss &lt;- .10
# missing proportion
missrate &lt;- .50
y1 &lt;- rep(rnorm(G, sd = sqrt(rho)), each = n) + rnorm(G * n, sd = sqrt(1 - rho))
x &lt;- rnorm(G * n)
y &lt;- y1 + beta * x
dfr0 &lt;- dfr &lt;- data.frame("group" = rep(1:G, each = n), "x" = x, "y" = y)
dfr[rho.miss * x + rnorm(G * n, sd = sqrt(1 - rho.miss)) &lt; qnorm(missrate), "y"] &lt;- NA

# empty imputation in mice
imp0 &lt;- mice(as.matrix(dfr), maxit = 0)
predM &lt;- imp0$predictorMatrix
impM &lt;- imp0$method

# specify predictor matrix and method
predM1 &lt;- predM
predM1["y", "group"] &lt;- -2
predM1["y", "x"] &lt;- 1 # fixed x effects imputation
impM1 &lt;- impM
impM1["y"] &lt;- "2l.pan"

# multilevel imputation
imp1 &lt;- mice(as.matrix(dfr),
  m = 1, predictorMatrix = predM1,
  method = impM1, maxit = 1
)

# multilevel analysis
library(lme4)
mod &lt;- lmer(y ~ (1 + x | group) + x, data = complete(imp1))
summary(mod)

# Examples of predictorMatrix specification

# random x effects
# predM1["y","x"] &lt;- 2

# fixed x effects and group mean of x
# predM1["y","x"] &lt;- 3

# random x effects and group mean of x
# predM1["y","x"] &lt;- 4
</code></pre>

<hr>
<h2 id='mice.impute.2lonly.mean'>Imputation of most likely value within the class</h2><span id='topic+mice.impute.2lonly.mean'></span><span id='topic+2lonly.mean'></span>

<h3>Description</h3>

<p>Method <code>2lonly.mean</code> replicates the most likely value within
a class of a second-level variable. It works for numeric and
factor data. The function is primarily useful as a quick fixup for
data in which the second-level variable is inconsistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2lonly.mean(y, ry, x, type, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2lonly.mean_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.mean_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.mean_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.mean_+3A_type">type</code></td>
<td>
<p>Vector of length <code>ncol(x)</code> identifying random and class
variables.  The class variable (only one is allowed) is coded as <code>-2</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.mean_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.mean_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observed values in <code>y</code> are averaged within the class, and
replicated to the missing <code>y</code> within that class.
This function is primarily useful for repairing incomplete data
that are constant within the class, but vary over classes.
</p>
<p>For numeric variables, <code>mice.impute.2lonly.mean()</code> imputes the
class mean of <code>y</code>. If <code>y</code> is a second-level variable, then
conventionally all observed <code>y</code> will be identical within the
class, and the function just provides a quick fix for any
missing <code>y</code> by filling in the class mean.
</p>
<p>For factor variables, <code>mice.impute.2lonly.mean()</code> imputes the
most frequently occuring category within the class.
</p>
<p>If there are no observed <code>y</code> in the class, all entries of the
class are set to <code>NA</code>. Note that this may produce problems
later on in <code>mice</code> if imputation routines are called that
expects predictor data to be complete. Methods designed for
imputing this type of second-level variables include
<code><a href="#topic+mice.impute.2lonly.norm">mice.impute.2lonly.norm</a></code> and
<code><a href="#topic+mice.impute.2lonly.pmm">mice.impute.2lonly.pmm</a></code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, Stef van Buuren, 2019
</p>


<h3>References</h3>

<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-level2pred.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Boca Raton, FL.: Chapman &amp; Hall/CRC Press.
</p>


<h3>See Also</h3>

<p>Other univariate-2lonly: 
<code><a href="#topic+mice.impute.2lonly.norm">mice.impute.2lonly.norm</a>()</code>,
<code><a href="#topic+mice.impute.2lonly.pmm">mice.impute.2lonly.pmm</a>()</code>
</p>

<hr>
<h2 id='mice.impute.2lonly.norm'>Imputation at level 2 by Bayesian linear regression</h2><span id='topic+mice.impute.2lonly.norm'></span><span id='topic+2lonly.norm'></span>

<h3>Description</h3>

<p>Imputes univariate missing data at level 2 using Bayesian linear regression
analysis.  Variables are level 1 are aggregated at level 2. The group
identifier at level 2 must be indicated by <code>type = -2</code> in the
<code>predictorMatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2lonly.norm(y, ry, x, type, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2lonly.norm_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.norm_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.norm_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.norm_+3A_type">type</code></td>
<td>
<p>Group identifier must be specified by '-2'. Predictors must be
specified by '1'.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.norm_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.norm_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows in combination with <code><a href="#topic+mice.impute.2l.pan">mice.impute.2l.pan</a></code>
switching regression imputation between level 1 and level 2 as described in
Yucel (2008) or Gelman and Hill (2007, p. 541).
</p>
<p>The function checks for partial missing level-2 data. Level-2 data
are assumed to be constant within the same cluster. If one or more
entries are missing, then the procedure aborts with an error
message that identifies the cluster with incomplete level-2 data.
In such cases, one may first fill in the cluster mean (or mode) by
the <code>2lonly.mean</code> method to remove inconsistencies.
</p>


<h3>Value</h3>

<p>A vector of length <code>nmis</code> with imputations.
</p>


<h3>Note</h3>

<p>For a more general approach, see
<code>miceadds::mice.impute.2lonly.function()</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Robitzsch (IPN - Leibniz Institute for Science and
Mathematics Education, Kiel, Germany), <a href="mailto:robitzsch@ipn.uni-kiel.de">robitzsch@ipn.uni-kiel.de</a>
</p>


<h3>References</h3>

<p>Gelman, A. and Hill, J. (2007). <em>Data analysis using
regression and multilevel/hierarchical models</em>. Cambridge, Cambridge
University Press.
</p>
<p>Yucel, RM (2008). Multiple imputation inference for multivariate multilevel
continuous data with ignorable non-response.  <em>Philosophical
Transactions of the Royal Society A</em>, <b>366</b>, 2389-2404.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-level2pred.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice.impute.norm">mice.impute.norm</a></code>,
<code><a href="#topic+mice.impute.2lonly.pmm">mice.impute.2lonly.pmm</a></code>, <code><a href="#topic+mice.impute.2l.pan">mice.impute.2l.pan</a></code>,
<code><a href="#topic+mice.impute.2lonly.mean">mice.impute.2lonly.mean</a></code>
</p>
<p>Other univariate-2lonly: 
<code><a href="#topic+mice.impute.2lonly.mean">mice.impute.2lonly.mean</a>()</code>,
<code><a href="#topic+mice.impute.2lonly.pmm">mice.impute.2lonly.pmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
# x,y ... level 1 variables
# v,w ... level 2 variables

G &lt;- 250 # number of groups
n &lt;- 20 # number of persons
beta &lt;- .3 # regression coefficient
rho &lt;- .30 # residual intraclass correlation
rho.miss &lt;- .10 # correlation with missing response
missrate &lt;- .50 # missing proportion
y1 &lt;- rep(rnorm(G, sd = sqrt(rho)), each = n) + rnorm(G * n, sd = sqrt(1 - rho))
w &lt;- rep(round(rnorm(G), 2), each = n)
v &lt;- rep(round(runif(G, 0, 3)), each = n)
x &lt;- rnorm(G * n)
y &lt;- y1 + beta * x + .2 * w + .1 * v
dfr0 &lt;- dfr &lt;- data.frame("group" = rep(1:G, each = n), "x" = x, "y" = y, "w" = w, "v" = v)
dfr[rho.miss * x + rnorm(G * n, sd = sqrt(1 - rho.miss)) &lt; qnorm(missrate), "y"] &lt;- NA
dfr[rep(rnorm(G), each = n) &lt; qnorm(missrate), "w"] &lt;- NA
dfr[rep(rnorm(G), each = n) &lt; qnorm(missrate), "v"] &lt;- NA

# empty mice imputation
imp0 &lt;- mice(as.matrix(dfr), maxit = 0)
predM &lt;- imp0$predictorMatrix
impM &lt;- imp0$method

# multilevel imputation
predM1 &lt;- predM
predM1[c("w", "y", "v"), "group"] &lt;- -2
predM1["y", "x"] &lt;- 1 # fixed x effects imputation
impM1 &lt;- impM
impM1[c("y", "w", "v")] &lt;- c("2l.pan", "2lonly.norm", "2lonly.pmm")

# y ... imputation using pan
# w ... imputation at level 2 using norm
# v ... imputation at level 2 using pmm

imp1 &lt;- mice(as.matrix(dfr),
  m = 1, predictorMatrix = predM1,
  method = impM1, maxit = 1, paniter = 500
)

# Demonstration that 2lonly.norm aborts for partial missing data.
# Better use 2lonly.mean for repair.
data &lt;- data.frame(
  patid = rep(1:4, each = 5),
  sex = rep(c(1, 2, 1, 2), each = 5),
  crp = c(
    68, 78, 93, NA, 143,
    5, 7, 9, 13, NA,
    97, NA, 56, 52, 34,
    22, 30, NA, NA, 45
  )
)
pred &lt;- make.predictorMatrix(data)
pred[, "patid"] &lt;- -2
# only missing value (out of five) for patid == 1
data[3, "sex"] &lt;- NA
## Not run: 
# The following fails because 2lonly.norm found partially missing
# level-2 data
# imp &lt;- mice(data, method = c("", "2lonly.norm", "2l.pan"),
#             predictorMatrix = pred, maxit = 1, m = 2)
# &gt; iter imp variable
# &gt; 1   1  sex  crpError in .imputation.level2(y = y, ... :
# &gt;   Method 2lonly.norm found the following clusters with partially missing
# &gt;    level-2 data: 1
# &gt; Method 2lonly.mean can fix such inconsistencies.

## End(Not run)

# In contrast, if all sex values are missing for patid == 1, it runs fine,
# except on r-patched-solaris-x86. I used dontrun to evade CRAN errors.
## Not run: 
data[1:5, "sex"] &lt;- NA
imp &lt;- mice(data,
  method = c("", "2lonly.norm", "2l.pan"),
  predictorMatrix = pred, maxit = 1, m = 2
)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.2lonly.pmm'>Imputation at level 2 by predictive mean matching</h2><span id='topic+mice.impute.2lonly.pmm'></span><span id='topic+2lonly.pmm'></span>

<h3>Description</h3>

<p>Imputes univariate missing data at level 2 using predictive mean matching.
Variables are level 1 are aggregated at level 2. The group identifier at
level 2 must be indicated by <code>type = -2</code> in the <code>predictorMatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2lonly.pmm(y, ry, x, type, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2lonly.pmm_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.pmm_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.pmm_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.pmm_+3A_type">type</code></td>
<td>
<p>Group identifier must be specified by '-2'. Predictors must be
specified by '1'.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.pmm_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.pmm_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows in combination with <code><a href="#topic+mice.impute.2l.pan">mice.impute.2l.pan</a></code>
switching regression imputation between level 1 and level 2 as described in
Yucel (2008) or Gelman and Hill (2007, p. 541).
</p>
<p>The function checks for partial missing level-2 data. Level-2 data
are assumed to be constant within the same cluster. If one or more
entries are missing, then the procedure aborts with an error
message that identifies the cluster with incomplete level-2 data.
In such cases, one may first fill in the cluster mean (or mode) by
the <code>2lonly.mean</code> method to remove inconsistencies.
</p>


<h3>Value</h3>

<p>A vector of length <code>nmis</code> with imputations.
</p>


<h3>Note</h3>

<p>The extension to categorical variables transforms
a dependent factor variable by means of the <code>as.integer()</code>
function. This may make sense for categories that are
approximately ordered, but less so for pure nominal measures.
</p>
<p>For a more general approach, see
<code>miceadds::mice.impute.2lonly.function()</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Robitzsch (IPN - Leibniz Institute for Science and
Mathematics Education, Kiel, Germany), <a href="mailto:robitzsch@ipn.uni-kiel.de">robitzsch@ipn.uni-kiel.de</a>
</p>


<h3>References</h3>

<p>Gelman, A. and Hill, J. (2007). <em>Data analysis using
regression and multilevel/hierarchical models</em>. Cambridge, Cambridge
University Press.
</p>
<p>Yucel, RM (2008). Multiple imputation inference for multivariate multilevel
continuous data with ignorable non-response.  <em>Philosophical
Transactions of the Royal Society A</em>, <b>366</b>, 2389-2404.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-level2pred.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a></code>,
<code><a href="#topic+mice.impute.2lonly.norm">mice.impute.2lonly.norm</a></code>, <code><a href="#topic+mice.impute.2l.pan">mice.impute.2l.pan</a></code>,
<code><a href="#topic+mice.impute.2lonly.mean">mice.impute.2lonly.mean</a></code>
</p>
<p>Other univariate-2lonly: 
<code><a href="#topic+mice.impute.2lonly.mean">mice.impute.2lonly.mean</a>()</code>,
<code><a href="#topic+mice.impute.2lonly.norm">mice.impute.2lonly.norm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
# x,y ... level 1 variables
# v,w ... level 2 variables

G &lt;- 250 # number of groups
n &lt;- 20 # number of persons
beta &lt;- .3 # regression coefficient
rho &lt;- .30 # residual intraclass correlation
rho.miss &lt;- .10 # correlation with missing response
missrate &lt;- .50 # missing proportion
y1 &lt;- rep(rnorm(G, sd = sqrt(rho)), each = n) + rnorm(G * n, sd = sqrt(1 - rho))
w &lt;- rep(round(rnorm(G), 2), each = n)
v &lt;- rep(round(runif(G, 0, 3)), each = n)
x &lt;- rnorm(G * n)
y &lt;- y1 + beta * x + .2 * w + .1 * v
dfr0 &lt;- dfr &lt;- data.frame("group" = rep(1:G, each = n), "x" = x, "y" = y, "w" = w, "v" = v)
dfr[rho.miss * x + rnorm(G * n, sd = sqrt(1 - rho.miss)) &lt; qnorm(missrate), "y"] &lt;- NA
dfr[rep(rnorm(G), each = n) &lt; qnorm(missrate), "w"] &lt;- NA
dfr[rep(rnorm(G), each = n) &lt; qnorm(missrate), "v"] &lt;- NA

# empty mice imputation
imp0 &lt;- mice(as.matrix(dfr), maxit = 0)
predM &lt;- imp0$predictorMatrix
impM &lt;- imp0$method

# multilevel imputation
predM1 &lt;- predM
predM1[c("w", "y", "v"), "group"] &lt;- -2
predM1["y", "x"] &lt;- 1 # fixed x effects imputation
impM1 &lt;- impM
impM1[c("y", "w", "v")] &lt;- c("2l.pan", "2lonly.norm", "2lonly.pmm")

# turn v into a categorical variable
dfr$v &lt;- as.factor(dfr$v)
levels(dfr$v) &lt;- LETTERS[1:4]

# y ... imputation using pan
# w ... imputation at level 2 using norm
# v ... imputation at level 2 using pmm

# skip imputation on solaris
is.solaris &lt;- function() grepl("SunOS", Sys.info()["sysname"])
if (!is.solaris()) {
  imp &lt;- mice(dfr,
    m = 1, predictorMatrix = predM1,
    method = impM1, maxit = 1, paniter = 500
  )
}
</code></pre>

<hr>
<h2 id='mice.impute.cart'>Imputation by classification and regression trees</h2><span id='topic+mice.impute.cart'></span><span id='topic+cart'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using classification and regression trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.cart(y, ry, x, wy = NULL, minbucket = 5, cp = 1e-04, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.cart_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.cart_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.cart_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.cart_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.cart_+3A_minbucket">minbucket</code></td>
<td>
<p>The minimum number of observations in any terminal node used.
See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="mice.impute.cart_+3A_cp">cp</code></td>
<td>
<p>Complexity parameter. Any split that does not decrease the overall
lack of fit by a factor of cp is not attempted. See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code>
for details.</p>
</td></tr>
<tr><td><code id="mice.impute.cart_+3A_...">...</code></td>
<td>
<p>Other named arguments passed down to <code>rpart()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputation of <code>y</code> by classification and regression trees. The procedure
is as follows:
</p>

<ol>
<li><p> Fit a classification or regression tree by recursive partitioning;
</p>
</li>
<li><p> For each <code>ymis</code>, find the terminal node they end up according to the fitted tree;
</p>
</li>
<li><p> Make a random draw among the member in the node, and take the observed value from that
draw as the imputation.
</p>
</li></ol>



<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>
<p>Numeric vector of length <code>sum(!ry)</code> with imputations
</p>


<h3>Author(s)</h3>

<p>Lisa Doove, Stef van Buuren, Elise Dusseldorp, 2012
</p>


<h3>References</h3>

<p>Doove, L.L., van Buuren, S., Dusseldorp, E. (2014), Recursive partitioning
for missing data imputation in the presence of interaction Effects.
Computational Statistics &amp; Data Analysis, 72, 92-104.
</p>
<p>Breiman, L., Friedman, J. H., Olshen, R. A., and Stone, C. J.
(1984), Classification and regression trees, Monterey, CA: Wadsworth &amp;
Brooks/Cole Advanced Books &amp; Software.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-cart.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mice.impute.rf">mice.impute.rf</a></code>,
<code><a href="rpart.html#topic+rpart">rpart</a></code>, <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code>
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(nhanes2, meth = "cart", minbucket = 4)
plot(imp)
</code></pre>

<hr>
<h2 id='mice.impute.jomoImpute'>Multivariate multilevel imputation using <code>jomo</code></h2><span id='topic+mice.impute.jomoImpute'></span>

<h3>Description</h3>

<p>This function is a wrapper around the <code>jomoImpute</code> function
from the <code>mitml</code> package so that it can be called to
impute blocks of variables in <code>mice</code>. The <code>mitml::jomoImpute</code>
function provides an interface to the <code>jomo</code> package for
multiple imputation of multilevel data
<a href="https://CRAN.R-project.org/package=jomo">https://CRAN.R-project.org/package=jomo</a>.
Imputations can be generated using <code>type</code> or <code>formula</code>,
which offer different options for model specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.jomoImpute(
  data,
  formula,
  type,
  m = 1,
  silent = TRUE,
  format = "imputes",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.jomoImpute_+3A_data">data</code></td>
<td>
<p>A data frame containing incomplete and auxiliary variables,
the cluster indicator variable, and any other variables that should be
present in the imputed datasets.</p>
</td></tr>
<tr><td><code id="mice.impute.jomoImpute_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the role of each variable
in the imputation model. The basic model is constructed
by <code>model.matrix</code>, thus allowing to include derived variables
in the imputation model using <code>I()</code>. See
<code><a href="mitml.html#topic+jomoImpute">jomoImpute</a></code>.</p>
</td></tr>
<tr><td><code id="mice.impute.jomoImpute_+3A_type">type</code></td>
<td>
<p>An integer vector specifying the role of each variable
in the imputation model (see <code><a href="mitml.html#topic+jomoImpute">jomoImpute</a></code>)</p>
</td></tr>
<tr><td><code id="mice.impute.jomoImpute_+3A_m">m</code></td>
<td>
<p>The number of imputed data sets to generate. Default is 10.</p>
</td></tr>
<tr><td><code id="mice.impute.jomoImpute_+3A_silent">silent</code></td>
<td>
<p>(optional) Logical flag indicating if console output should be suppressed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.jomoImpute_+3A_format">format</code></td>
<td>
<p>A character vector specifying the type of object that should
be returned. The default is <code>format = "list"</code>. No other formats are
currently supported.</p>
</td></tr>
<tr><td><code id="mice.impute.jomoImpute_+3A_...">...</code></td>
<td>
<p>Other named arguments: <code>n.burn</code>, <code>n.iter</code>,
<code>group</code>, <code>prior</code>, <code>silent</code> and others.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of imputations for all incomplete variables in the model,
that can be stored in the the <code>imp</code> component of the <code>mids</code>
object.
</p>


<h3>Note</h3>

<p>The number of imputations <code>m</code> is set to 1, and the function
is called <code>m</code> times so that it fits within the <code>mice</code>
iteration scheme.
</p>
<p>This is a multivariate imputation function using a joint model.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2018, building on work of Simon Grund,
Alexander Robitzsch and Oliver Luedtke (authors of <code>mitml</code> package)
and Quartagno and Carpenter (authors of <code>jomo</code> package).
</p>


<h3>References</h3>

<p>Grund S, Luedtke O, Robitzsch A (2016). Multiple
Imputation of Multilevel Missing Data: An Introduction to the R
Package <code>pan</code>. SAGE Open.
</p>
<p>Quartagno M and Carpenter JR (2015).
Multiple imputation for IPD meta-analysis: allowing for heterogeneity
and studies with missing covariates. Statistics in Medicine,
35:2938-2954, 2015.
</p>


<h3>See Also</h3>

<p><code><a href="mitml.html#topic+jomoImpute">jomoImpute</a></code>
</p>
<p>Other multivariate-2l: 
<code><a href="#topic+mice.impute.panImpute">mice.impute.panImpute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Note: Requires mitml 0.3-5.7
blocks &lt;- list(c("bmi", "chl", "hyp"), "age")
method &lt;- c("jomoImpute", "pmm")
ini &lt;- mice(nhanes, blocks = blocks, method = method, maxit = 0)
pred &lt;- ini$pred
pred["B1", "hyp"] &lt;- -2
imp &lt;- mice(nhanes, blocks = blocks, method = method, pred = pred, maxit = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.lasso.logreg'>Imputation by direct use of lasso logistic regression</h2><span id='topic+mice.impute.lasso.logreg'></span><span id='topic+lasso.logreg'></span>

<h3>Description</h3>

<p>Imputes univariate missing binary data using lasso logistic regression with bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.lasso.logreg(y, ry, x, wy = NULL, nfolds = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.lasso.logreg_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.logreg_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.logreg_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.logreg_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.logreg_+3A_nfolds">nfolds</code></td>
<td>
<p>The number of folds for the cross-validation of the lasso penalty.
The default is 10.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.logreg_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method consists of the following steps:
</p>

<ol>
<li><p> For a given y variable under imputation, draw a bootstrap version y*
with replacement from the observed cases <code>y[ry]</code>, and stores in x* the
corresponding values from <code>x[ry, ]</code>.
</p>
</li>
<li><p> Fit a regularised (lasso) logistic regression with y* as the outcome,
and x* as predictors.
A vector of regression coefficients bhat is obtained.
All of these coefficients are considered random draws from the imputation model
parameters posterior distribution.
Same of these coefficients will be shrunken to 0.
</p>
</li>
<li><p> Compute predicted scores for m.d., i.e. logit-1(X bhat)
</p>
</li>
<li><p> Compare the score to a random (0,1) deviate, and impute.
</p>
</li></ol>

<p>The method is based on the Direct Use of Regularized Regression (DURR) proposed by
Zhao &amp; Long (2016) and Deng et al (2016).
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Edoardo Costantini, 2021
</p>


<h3>References</h3>

<p>Deng, Y., Chang, C., Ido, M. S., &amp; Long, Q. (2016). Multiple imputation for
general missing data patterns in the presence of high-dimensional data.
Scientific reports, 6(1), 1-10.
</p>
<p>Zhao, Y., &amp; Long, Q. (2016). Multiple imputation in the presence of
high-dimensional data. Statistical Methods in Medical Research, 25(5),
2021-2035.
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.lasso.norm'>Imputation by direct use of lasso linear regression</h2><span id='topic+mice.impute.lasso.norm'></span><span id='topic+lasso.norm'></span>

<h3>Description</h3>

<p>Imputes univariate missing normal data using lasso linear regression with bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.lasso.norm(y, ry, x, wy = NULL, nfolds = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.lasso.norm_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.norm_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.norm_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.norm_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.norm_+3A_nfolds">nfolds</code></td>
<td>
<p>The number of folds for the cross-validation of the lasso penalty.
The default is 10.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.norm_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method consists of the following steps:
</p>

<ol>
<li><p> For a given y variable under imputation, draw a bootstrap version y*
with replacement from the observed cases <code>y[ry]</code>, and stores in x* the
corresponding values from <code>x[ry, ]</code>.
</p>
</li>
<li><p> Fit a regularised (lasso) linear regression with y* as the outcome,
and x* as predictors.
A vector of regression coefficients bhat is obtained.
All of these coefficients are considered random draws from the imputation model
parameters posterior distribution.
Same of these coefficients will be shrunken to 0.
</p>
</li>
<li><p> Draw the imputed values from the predictive distribution defined by
the original (non-bootstrap) data, bhat, and estimated error variance.
</p>
</li></ol>

<p>The method is based on the Direct Use of Regularized Regression (DURR) proposed by
Zhao &amp; Long (2016) and Deng et al (2016).
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Edoardo Costantini, 2021
</p>


<h3>References</h3>

<p>Deng, Y., Chang, C., Ido, M. S., &amp; Long, Q. (2016). Multiple imputation for
general missing data patterns in the presence of high-dimensional data.
Scientific reports, 6(1), 1-10.
</p>
<p>Zhao, Y., &amp; Long, Q. (2016). Multiple imputation in the presence of
high-dimensional data. Statistical Methods in Medical Research, 25(5),
2021-2035.
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.lasso.select.logreg'>Imputation by indirect use of lasso logistic regression</h2><span id='topic+mice.impute.lasso.select.logreg'></span><span id='topic+lasso.select.logreg'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using logistic regression following a
preprocessing lasso variable selection step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.lasso.select.logreg(y, ry, x, wy = NULL, nfolds = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.lasso.select.logreg_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.logreg_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.logreg_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.logreg_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.logreg_+3A_nfolds">nfolds</code></td>
<td>
<p>The number of folds for the cross-validation of the lasso penalty.
The default is 10.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.logreg_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method consists of the following steps:
</p>

<ol>
<li><p> For a given <code>y</code> variable under imputation, fit a linear regression with lasso
penalty using <code>y[ry]</code> as dependent variable and <code>x[ry, ]</code> as predictors.
The coefficients that are not shrunk to 0 define the active set of predictors
that will be used for imputation.
</p>
</li>
<li><p> Fit a logit with the active set of predictors, and find (bhat, V(bhat))
</p>
</li>
<li><p> Draw BETA from N(bhat, V(bhat))
</p>
</li>
<li><p> Compute predicted scores for m.d., i.e. logit-1(X BETA)
</p>
</li>
<li><p> Compare the score to a random (0,1) deviate, and impute.
</p>
</li></ol>

<p>The user can specify a <code>predictorMatrix</code> in the <code>mice</code> call
to define which predictors are provided to this univariate imputation method.
The lasso regularization will select, among the variables indicated by
the user, the ones that are important for imputation at any given iteration.
Therefore, users may force the exclusion of a predictor from a given
imputation model by speficing a <code>0</code> entry.
However, a non-zero entry does not guarantee the variable will be used,
as this decision is ultimately made by the lasso variable selection
procedure.
</p>
<p>The method is based on the Indirect Use of Regularized Regression (IURR) proposed by
Zhao &amp; Long (2016) and Deng et al (2016).
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Edoardo Costantini, 2021
</p>


<h3>References</h3>

<p>Deng, Y., Chang, C., Ido, M. S., &amp; Long, Q. (2016). Multiple imputation for
general missing data patterns in the presence of high-dimensional data.
Scientific reports, 6(1), 1-10.
</p>
<p>Zhao, Y., &amp; Long, Q. (2016). Multiple imputation in the presence of
high-dimensional data. Statistical Methods in Medical Research, 25(5),
2021-2035.
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.lasso.select.norm'>Imputation by indirect use of lasso linear regression</h2><span id='topic+mice.impute.lasso.select.norm'></span><span id='topic+lasso.select.norm'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using Bayesian linear regression following a
preprocessing lasso variable selection step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.lasso.select.norm(y, ry, x, wy = NULL, nfolds = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.lasso.select.norm_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.norm_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.norm_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.norm_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.norm_+3A_nfolds">nfolds</code></td>
<td>
<p>The number of folds for the cross-validation of the lasso penalty.
The default is 10.</p>
</td></tr>
<tr><td><code id="mice.impute.lasso.select.norm_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method consists of the following steps:
</p>

<ol>
<li><p> For a given <code>y</code> variable under imputation, fit a linear regression with lasso
penalty using <code>y[ry]</code> as dependent variable and <code>x[ry, ]</code> as predictors.
Coefficients that are not shrunk to 0 define an active set of predictors
that will be used for imputation
</p>
</li>
<li><p> Define a Bayesian linear model using <code>y[ry]</code> as the
dependent variable, the active set of <code>x[ry, ]</code> as predictors, and standard
non-informative priors
</p>
</li>
<li><p> Draw parameter values for the intercept, regression weights, and error
variance from their posterior distribution
</p>
</li>
<li><p> Draw imputations from the posterior predictive distribution
</p>
</li></ol>

<p>The user can specify a <code>predictorMatrix</code> in the <code>mice</code> call
to define which predictors are provided to this univariate imputation method.
The lasso regularization will select, among the variables indicated by
the user, the ones that are important for imputation at any given iteration.
Therefore, users may force the exclusion of a predictor from a given
imputation model by specifying a <code>0</code> entry.
However, a non-zero entry does not guarantee the variable will be used,
as this decision is ultimately made by the lasso variable selection
procedure.
</p>
<p>The method is based on the Indirect Use of Regularized Regression (IURR) proposed by
Zhao &amp; Long (2016) and Deng et al (2016).
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Edoardo Costantini, 2021
</p>


<h3>References</h3>

<p>Deng, Y., Chang, C., Ido, M. S., &amp; Long, Q. (2016). Multiple imputation for
general missing data patterns in the presence of high-dimensional data.
Scientific reports, 6(1), 1-10.
</p>
<p>Zhao, Y., &amp; Long, Q. (2016). Multiple imputation in the presence of
high-dimensional data. Statistical Methods in Medical Research, 25(5),
2021-2035.
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.lda'>Imputation by linear discriminant analysis</h2><span id='topic+mice.impute.lda'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using linear discriminant analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.lda(y, ry, x, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.lda_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.lda_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.lda_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.lda_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.lda_+3A_...">...</code></td>
<td>
<p>Other named arguments. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputation of categorical response variables by linear discriminant analysis.
This function uses the Venables/Ripley functions <code>lda()</code> and
<code>predict.lda()</code> to compute posterior probabilities for each incomplete
case, and draws the imputations from this posterior.
</p>
<p>This function can be called from within the Gibbs sampler by specifying
<code>"lda"</code> in the <code>method</code> argument of <code>mice()</code>. This method is usually
faster and uses fewer resources than calling the function, but the statistical
properties may not be as good (Brand, 1999).
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a></code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, of type factor, and of length
<code>sum(wy)</code>
</p>


<h3>Warning</h3>

<p>The function does not incorporate the variability of the
discriminant weight, so it is not 'proper' in the sense of Rubin. For small
samples and rare categories in the <code>y</code>, variability of the imputed data
could therefore be underestimated.
</p>
<p>Added: SvB June 2009 Tried to include bootstrap, but disabled since
bootstrapping may easily lead to constant variables within groups.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Brand, J.P.L. (1999). Development, Implementation and Evaluation of Multiple
Imputation Strategies for the Statistical Analysis of Incomplete Data Sets.
Ph.D. Thesis, TNO Prevention and Health/Erasmus University Rotterdam. ISBN
90-74479-08-1.
</p>
<p>Venables, W.N. &amp; Ripley, B.D. (1997). Modern applied statistics with S-PLUS
(2nd ed). Springer, Berlin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code>link{mice.impute.polyreg}</code>,
<code><a href="MASS.html#topic+lda">lda</a></code>
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.logreg'>Imputation by logistic regression</h2><span id='topic+mice.impute.logreg'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.logreg(y, ry, x, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.logreg_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.logreg_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.logreg_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.logreg_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.logreg_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputation for binary response variables by the Bayesian logistic regression
model (Rubin 1987, p. 169-170).  The
Bayesian method consists of the following steps:
</p>

<ol>
<li><p> Fit a logit, and find (bhat, V(bhat))
</p>
</li>
<li><p> Draw BETA from N(bhat, V(bhat))
</p>
</li>
<li><p> Compute predicted scores for m.d., i.e. logit-1(X BETA)
</p>
</li>
<li><p> Compare the score to a random (0,1) deviate, and impute.
</p>
</li></ol>

<p>The method relies on the
standard <code>glm.fit</code> function. Warnings from <code>glm.fit</code> are
suppressed. Perfect prediction is handled by the data augmentation
method.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Brand, J.P.L. (1999). Development, Implementation and Evaluation of Multiple
Imputation Strategies for the Statistical Analysis of Incomplete Data Sets.
Ph.D. Thesis, TNO Prevention and Health/Erasmus University Rotterdam. ISBN
90-74479-08-1.
</p>
<p>Venables, W.N. &amp; Ripley, B.D. (1997). Modern applied statistics with S-Plus
(2nd ed). Springer, Berlin.
</p>
<p>White, I., Daniel, R. and Royston, P (2010). Avoiding bias due to perfect
prediction in multiple imputation of incomplete categorical variables.
Computational Statistics and Data Analysis, 54:22672275.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.logreg.boot'>Imputation by logistic regression using the bootstrap</h2><span id='topic+mice.impute.logreg.boot'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using logistic regression
by a bootstrapped logistic regression model.
The bootstrap method draws a simple bootstrap sample with replacement
from the observed data <code>y[ry]</code> and <code>x[ry, ]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.logreg.boot(y, ry, x, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.logreg.boot_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.logreg.boot_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.logreg.boot_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.logreg.boot_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.logreg.boot_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000, 2011
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-categorical.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.mean'>Imputation by the mean</h2><span id='topic+mice.impute.mean'></span>

<h3>Description</h3>

<p>Imputes the arithmetic mean of the observed data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.mean(y, ry, x = NULL, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.mean_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.mean_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.mean_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.mean_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.mean_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Warning</h3>

<p>Imputing the mean of a variable is almost never
appropriate.  See Little and Rubin (2002, p. 61-62) or
Van Buuren (2012, p. 10-11)
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Little, R.J.A. and Rubin, D.B. (2002). Statistical Analysis with Missing
Data.  New York: John Wiley and Sons.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-simplesolutions.html#sec:meanimp"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="base.html#topic+mean">mean</a></code>
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.midastouch'>Imputation by predictive mean matching with distance aided donor selection</h2><span id='topic+mice.impute.midastouch'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using predictive mean matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.midastouch(
  y,
  ry,
  x,
  wy = NULL,
  ridge = 1e-05,
  midas.kappa = NULL,
  outout = TRUE,
  neff = NULL,
  debug = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.midastouch_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.midastouch_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.midastouch_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.midastouch_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.midastouch_+3A_ridge">ridge</code></td>
<td>
<p>The ridge penalty used in <code>.norm.draw()</code> to prevent
problems with multicollinearity. The default is <code>ridge = 1e-05</code>,
which means that 0.01 percent of the diagonal is added to the cross-product.
Larger ridges may result in more biased estimates. For highly noisy data
(e.g. many junk variables), set <code>ridge = 1e-06</code> or even lower to
reduce bias. For highly collinear data, set <code>ridge = 1e-04</code> or higher.</p>
</td></tr>
<tr><td><code id="mice.impute.midastouch_+3A_midas.kappa">midas.kappa</code></td>
<td>
<p>Scalar. If <code>NULL</code> (default) then the
optimal <code>kappa</code> gets selected automatically. Alternatively, the user
may specify a scalar. Siddique and Belin 2008 find <code>midas.kappa = 3</code>
to be sensible.</p>
</td></tr>
<tr><td><code id="mice.impute.midastouch_+3A_outout">outout</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default) one model is estimated
for each donor (leave-one-out principle). For speedup choose
<code>outout = FALSE</code>, which estimates one model for all observations
leading to in-sample predictions for the donors and out-of-sample
predictions for the recipients. Mind the inappropriateness, though.</p>
</td></tr>
<tr><td><code id="mice.impute.midastouch_+3A_neff">neff</code></td>
<td>
<p>FOR EXPERTS. Null or character string. The name of an existing
environment in which the effective sample size of the donors for each
loop (CE iterations times multiple imputations) is supposed to be written.
The effective sample size is necessary to compute the correction for the
total variance as originally suggested by Parzen, Lipsitz and
Fitzmaurice 2005. The objectname is <code>midastouch.neff</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.midastouch_+3A_debug">debug</code></td>
<td>
<p>FOR EXPERTS. Null or character string. The name of an existing
environment in which the input is supposed to be written. The objectname
is <code>midastouch.inputlist</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.midastouch_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputation of <code>y</code> by predictive mean matching, based on
Rubin (1987, p. 168, formulas a and b) and Siddique and Belin 2008.
The procedure is as follows:
</p>

<ol>
<li><p> Draw a bootstrap sample from the donor pool.
</p>
</li>
<li><p> Estimate a beta matrix on the bootstrap sample by the leave one out principle.
</p>
</li>
<li><p> Compute type II predicted values for <code>yobs</code> (nobs x 1) and <code>ymis</code> (nmis x nobs).
</p>
</li>
<li><p> Calculate the distance between all <code>yobs</code> and the corresponding <code>ymis</code>.
</p>
</li>
<li><p> Convert the distances in drawing probabilities.
</p>
</li>
<li><p> For each recipient draw a donor from the entire pool while considering the probabilities from the model.
</p>
</li>
<li><p> Take its observed value in <code>y</code> as the imputation.
</p>
</li></ol>



<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of
length <code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Philipp Gaffert, Florian Meinfelder, Volker Bosch 2015
</p>


<h3>References</h3>

<p>Gaffert, P., Meinfelder, F., Bosch V. (2015) Towards an MI-proper
Predictive Mean Matching, Discussion Paper.
<a href="https://www.uni-bamberg.de/fileadmin/uni/fakultaeten/sowi_lehrstuehle/statistik/Personen/Dateien_Florian/properPMM.pdf">https://www.uni-bamberg.de/fileadmin/uni/fakultaeten/sowi_lehrstuehle/statistik/Personen/Dateien_Florian/properPMM.pdf</a>
</p>
<p>Little, R.J.A. (1988), Missing data adjustments in large
surveys (with discussion), Journal of Business Economics and
Statistics, 6, 287&ndash;301.
</p>
<p>Parzen, M., Lipsitz, S. R., Fitzmaurice, G. M. (2005), A note on reducing
the bias of the approximate Bayesian bootstrap imputation variance estimator.
Biometrika <b>92</b>, 4, 971&ndash;974.
</p>
<p>Rubin, D.B. (1987), Multiple imputation for nonresponse in surveys. New York: Wiley.
</p>
<p>Siddique, J., Belin, T.R. (2008), Multiple imputation using an iterative
hot-deck with distance-based donor selection. Statistics in medicine,
<b>27</b>, 1, 83&ndash;102
</p>
<p>Van Buuren, S., Brand, J.P.L., Groothuis-Oudshoorn C.G.M., Rubin, D.B. (2006),
Fully conditional specification in multivariate imputation.
<em>Journal of Statistical Computation and Simulation</em>, <b>76</b>, 12,
1049&ndash;1064.
</p>
<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011), <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>, 3, 1&ndash;67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># do default multiple imputation on a numeric matrix
imp &lt;- mice(nhanes, method = "midastouch")
imp

# list the actual imputations for BMI
imp$imp$bmi

# first completed data matrix
complete(imp)

# imputation on mixed data with a different method per column
mice(nhanes2, method = c("sample", "midastouch", "logreg", "norm"))
</code></pre>

<hr>
<h2 id='mice.impute.mnar.logreg'>Imputation under MNAR mechanism by NARFCS</h2><span id='topic+mice.impute.mnar.logreg'></span><span id='topic+mice.impute.mnar.norm'></span><span id='topic+mnar.norm'></span><span id='topic+mnar.logreg'></span>

<h3>Description</h3>

<p>Imputes univariate data under a user-specified MNAR mechanism by
linear or logistic regression and NARFCS. Sensitivity analysis under
different model specifications may shed light on the impact of
different MNAR assumptions on the conclusions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.mnar.logreg(y, ry, x, wy = NULL, ums = NULL, umx = NULL, ...)

mice.impute.mnar.norm(y, ry, x, wy = NULL, ums = NULL, umx = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.mnar.logreg_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.mnar.logreg_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.mnar.logreg_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.mnar.logreg_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.mnar.logreg_+3A_ums">ums</code></td>
<td>
<p>A string containing the specification of the
unidentifiable part of the imputation model (the *unidentifiable
model specification&quot;), that is, the desired <code class="reqn">\delta</code>-adjustment
(offset) as a function of other variables and values for the
corresponding deltas (sensitivity parameters). See details.</p>
</td></tr>
<tr><td><code id="mice.impute.mnar.logreg_+3A_umx">umx</code></td>
<td>
<p>An auxiliary data matrix containing variables that do
not appear in the identifiable part of the imputation procedure
but that have been specified via <code>ums</code> as being predictors
in the unidentifiable part of the imputation model. See details.</p>
</td></tr>
<tr><td><code id="mice.impute.mnar.logreg_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imputes data that are thought to be Missing Not at
Random (MNAR) by the NARFCS method. The NARFCS procedure
(Tompsett et al, 2018) generalises the so-called
<code class="reqn">\delta</code>-adjustment sensitivity analysis method of Van Buuren,
Boshuizen &amp; Knook (1999) to the case with multiple incomplete
variables within the FCS framework. In practical terms, the
NARFCS procedure shifts the imputations drawn at each
iteration of <code>mice</code> by a user-specified quantity that can
vary across subjects, to reflect systematic departures of the
missing data from the data distribution imputed under MAR.
</p>
<p>Specification of the NARFCS model is done by the <code>blots</code>
argument of <code>mice()</code>. The <code>blots</code> parameter is a named
list. For each variable to be imputed by
<code>mice.impute.mnar.norm()</code> or <code>mice.impute.mnar.logreg()</code>
the corresponding element in <code>blots</code> is a list with
at least one argument <code>ums</code> and, optionally, a second
argument <code>umx</code>.
For example, the high-level call might like something like
<code>mice(nhanes[, c(2, 4)], method = c("pmm", "mnar.norm"),
blots = list(chl = list(ums = "-3+2*bmi")))</code>.
</p>
<p>The <code>ums</code> parameter is required, and might look like this:
<code>"-4+1*Y"</code>. The <code>ums</code> specifcation must have the
following characteristics:
</p>

<ol>
<li><p>A single term corresponding to the intercept (constant) term,
not multiplied by any variable name, must be included in the
expression;
</p>
</li>
<li><p>Each term in the expression (corresponding to the intercept
or a predictor variable) must be separated by either a <code>"+"</code>
or <code>"-"</code> sign, depending on the sign of the sensitivity
parameter;
</p>
</li>
<li><p>Within each non-intercept term, the sensitivity parameter
value comes first and the predictor variable comes second, and these
must be separated by a <code>"*"</code> sign;
</p>
</li>
<li><p>For categorical predictors, for example a variable <code>Z</code>
with K + 1 categories <code>("Cat0","Cat1", ...,"CatK")</code>, K
category-specific terms are needed, and those not in <code>umx</code>
(see below) must be specified by concatenating the variable name
with the name of the category (e.g. <code>ZCat1</code>) as this is how
they are named in the design matrix (argument <code>x</code>) passed
to the univariate imputation function. An example is
<code>"2+1*ZCat1-3*ZCat2"</code>.
</p>
</li></ol>

<p>If given, the <code>umx</code> specification must have the following
characteristics:
</p>

<ol>
<li><p>It contains only complete variables, with no missing values;
</p>
</li>
<li><p>It is a numeric matrix. In particular, categorical variables
must be represented as dummy indicators with names corresponding
to what is used in <code>ums</code> to refer to the category-specific terms
(see above);
</p>
</li>
<li><p>It has the same number of rows as the <code>data</code> argument
passed on to the main <code>mice</code> function;
</p>
</li>
<li><p>It does not contain variables that were already predictors
in the identifiable part of the model for the variable under
imputation.
</p>
</li></ol>

<p>Limitation: The present implementation can only condition on variables
that appear in the identifiable part of the imputation model (<code>x</code>) or
in complete auxiliary variables passed on via the <code>umx</code> argument.
It is not possible to specify models where the offset depends on
incomplete auxiliary variables.
</p>
<p>For an MNAR alternative see also <code><a href="#topic+mice.impute.ri">mice.impute.ri</a></code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Margarita Moreno-Betancur, Stef van Buuren, Ian R. White, 2020.
</p>


<h3>References</h3>

<p>Tompsett, D. M., Leacy, F., Moreno-Betancur, M., Heron, J., &amp;
White, I. R. (2018). On the use of the not-at-random fully
conditional specification (NARFCS) procedure in practice.
<em>Statistics in Medicine</em>, <b>37</b>(15), 2338-2353.
<a href="https://doi.org/10.1002/sim.7643">doi:10.1002/sim.7643</a>.
</p>
<p>Van Buuren, S., Boshuizen, H.C., Knook, D.L. (1999) Multiple
imputation of missing blood pressure covariates in survival analysis.
<em>Statistics in Medicine</em>, <b>18</b>, 681&ndash;694.
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1: Example with no auxiliary data: only pass unidentifiable model specification (ums)

# Specify argument to pass on to mnar imputation functions via "blots" argument
mnar.blot &lt;- list(X = list(ums = "-4"), Y = list(ums = "2+1*ZCat1-3*ZCat2"))

# Run NARFCS by using mnar imputation methods and passing argument via blots
impNARFCS &lt;- mice(mnar_demo_data,
  method = c("mnar.logreg", "mnar.norm", ""),
  blots = mnar.blot, seed = 234235, print = FALSE
)

# Obtain MI results: Note they coincide with those from old version at
# https://github.com/moreno-betancur/NARFCS
pool(with(impNARFCS, lm(Y ~ X + Z)))$pooled$estimate

# 2: Example passing also auxiliary data to MNAR procedure (umx)
# Assumptions:
# - Auxiliary data are complete, no missing values
# - Auxiliary data are a numeric matrix
# - Auxiliary data have same number of rows as x
# - Auxiliary data have no overlapping variable names with x

# Specify argument to pass on to mnar imputation functions via "blots" argument
aux &lt;- matrix(0:1, nrow = nrow(mnar_demo_data))
dimnames(aux) &lt;- list(NULL, "even")
mnar.blot &lt;- list(
  X = list(ums = "-4"),
  Y = list(ums = "2+1*ZCat1-3*ZCat2+0.5*even", umx = aux)
)

# Run NARFCS by using mnar imputation methods and passing argument via blots
impNARFCS &lt;- mice(mnar_demo_data,
  method = c("mnar.logreg", "mnar.norm", ""),
  blots = mnar.blot, seed = 234235, print = FALSE
)

# Obtain MI results: As expected they differ (slightly) from those
# from old version at https://github.com/moreno-betancur/NARFCS
pool(with(impNARFCS, lm(Y ~ X + Z)))$pooled$estimate
</code></pre>

<hr>
<h2 id='mice.impute.mpmm'>Imputation by multivariate predictive mean matching</h2><span id='topic+mice.impute.mpmm'></span><span id='topic+mpmm'></span>

<h3>Description</h3>

<p>Imputes multivariate incomplete data among which there are specific relations,
for instance, polynomials, interactions, range restrictions and sum scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.mpmm(data, format = "imputes", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.mpmm_+3A_data">data</code></td>
<td>
<p>matrix with exactly two missing data patterns</p>
</td></tr>
<tr><td><code id="mice.impute.mpmm_+3A_format">format</code></td>
<td>
<p>A character vector specifying the type of object that should
be returned. The default is <code>format = "imputes"</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.mpmm_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the predictive mean matching and applies canonical
regression analysis to select donors fora set of missing variables. In general,
canonical regressionanalysis looks for a linear combination of covariates that
predicts a linear combination of outcomes (a set of missing variables)
optimally in a least-square sense (Israels, 1987). The predicted
value of the linear combination of the set of missing variables
would be applied to perform predictive mean matching.
</p>


<h3>Value</h3>

<p>A matrix with imputed data, which has <code>ncol(y)</code> columns and
<code>sum(wy)</code> rows.
</p>


<h3>Note</h3>

<p>The function requires variables in the block have the same missingness pattern.
If there are more than one missingness pattern, the function will return
a warning.
</p>


<h3>Author(s)</h3>

<p>Mingyang Cai and Gerko Vink
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a></code>
Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-knowledge.html#sec:quadratic"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate data
beta2 &lt;- beta1 &lt;- .5
x &lt;- rnorm(1000)
e &lt;- rnorm(1000, 0, 1)
y &lt;- beta1 * x + beta2 * x^2 + e
dat &lt;- data.frame(y = y, x = x, x2 = x^2)
m &lt;- as.logical(rbinom(1000, 1, 0.25))
dat[m, c("x", "x2")] &lt;- NA

# impute
blk &lt;- list("y", c("x", "x2"))
meth &lt;- c("", "mpmm")
imp &lt;- mice(dat, blocks = blk, method = meth, print = FALSE,
    m = 2, maxit = 2)

# analyse and check
summary(pool(with(imp, lm(y ~ x + x2))))
with(dat, plot(x, x2, col = mdc(1)))
with(complete(imp), points(x[m], x2[m], col = mdc(2)))
</code></pre>

<hr>
<h2 id='mice.impute.norm'>Imputation by Bayesian linear regression</h2><span id='topic+mice.impute.norm'></span><span id='topic+norm'></span>

<h3>Description</h3>

<p>Calculates imputations for univariate missing data by Bayesian linear
regression, also known as the normal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.norm(y, ry, x, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.norm_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.norm_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.norm_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.norm_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.norm_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputation of <code>y</code> by the normal model by the method defined by
Rubin (1987, p. 167). The procedure is as follows:
</p>

<ol>
<li><p>Calculate the cross-product matrix <code class="reqn">S=X_{obs}'X_{obs}</code>.
</p>
</li>
<li><p>Calculate <code class="reqn">V = (S+{diag}(S)\kappa)^{-1}</code>, with some small ridge
parameter <code class="reqn">\kappa</code>.
</p>
</li>
<li><p>Calculate regression weights <code class="reqn">\hat\beta = VX_{obs}'y_{obs}.</code>
</p>
</li>
<li><p>Draw a random variable <code class="reqn">\dot g \sim \chi^2_\nu</code> with <code class="reqn">\nu=n_1 - q</code>.
</p>
</li>
<li><p>Calculate <code class="reqn">\dot\sigma^2 = (y_{obs} - X_{obs}\hat\beta)'(y_{obs} - X_{obs}\hat\beta)/\dot g.</code>
</p>
</li>
<li><p>Draw <code class="reqn">q</code> independent <code class="reqn">N(0,1)</code> variates in vector <code class="reqn">\dot z_1</code>.
</p>
</li>
<li><p>Calculate <code class="reqn">V^{1/2}</code> by Cholesky decomposition.
</p>
</li>
<li><p>Calculate <code class="reqn">\dot\beta = \hat\beta + \dot\sigma\dot z_1 V^{1/2}</code>.
</p>
</li>
<li><p>Draw <code class="reqn">n_0</code> independent <code class="reqn">N(0,1)</code> variates in vector <code class="reqn">\dot z_2</code>.
</p>
</li>
<li><p>Calculate the <code class="reqn">n_0</code> values <code class="reqn">y_{imp} = X_{mis}\dot\beta + \dot z_2\dot\sigma</code>.
</p>
</li></ol>

<p>Using <code>mice.impute.norm</code> for all columns emulates Schafer's NORM method (Schafer, 1997).
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn
</p>


<h3>References</h3>

<p>Rubin, D.B (1987). Multiple Imputation for Nonresponse in Surveys. New York: John Wiley &amp; Sons.
</p>
<p>Schafer, J.L. (1997). Analysis of incomplete multivariate data. London: Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.norm.boot'>Imputation by linear regression, bootstrap method</h2><span id='topic+mice.impute.norm.boot'></span><span id='topic+norm.boot'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using linear regression with bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.norm.boot(y, ry, x, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.norm.boot_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.norm.boot_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.norm.boot_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.norm.boot_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.norm.boot_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a bootstrap sample from <code>x[ry,]</code> and <code>y[ry]</code>, calculates
regression weights and imputes with normal residuals.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, Stef van Buuren, 2018
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.norm.nob'>Imputation by linear regression without parameter uncertainty</h2><span id='topic+mice.impute.norm.nob'></span><span id='topic+norm.nob'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using linear regression analysis without
accounting for the uncertainty of the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.norm.nob(y, ry, x, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.norm.nob_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.norm.nob_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.norm.nob_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.norm.nob_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.norm.nob_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates imputations using the spread around the
fitted linear regression line of <code>y</code> given <code>x</code>, as
fitted on the observed data.
</p>
<p>This function is provided mainly to allow comparison between proper (e.g.,
as implemented in <code>mice.impute.norm</code> and improper (this function)
normal imputation methods.
</p>
<p>For large data, having many rows, differences between proper and improper
methods are small, and in those cases one may opt for speed by using
<code>mice.impute.norm.nob</code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Warning</h3>

<p>The function does not incorporate the variability of the
regression weights, so it is not 'proper' in the sense of Rubin. For small
samples, variability of the imputed data is therefore underestimated.
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, Stef van Buuren, Karin Groothuis-Oudshoorn, 2018
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Brand, J.P.L. (1999). Development, Implementation and Evaluation of Multiple
Imputation Strategies for the Statistical Analysis of Incomplete Data Sets.
Ph.D. Thesis, TNO Prevention and Health/Erasmus University Rotterdam.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mice.impute.norm">mice.impute.norm</a></code>
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.norm.predict'>Imputation by linear regression through prediction</h2><span id='topic+mice.impute.norm.predict'></span><span id='topic+norm.predict'></span>

<h3>Description</h3>

<p>Imputes the &quot;best value&quot; according to the linear regression model, also
known as <em>regression imputation</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.norm.predict(y, ry, x, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.norm.predict_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.norm.predict_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.norm.predict_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.norm.predict_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.norm.predict_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates regression weights from the observed data and returns predicted
values to as imputations. This
method is known as <em>regression imputation</em>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Warning</h3>

<p>THIS METHOD SHOULD NOT BE USED FOR DATA ANALYSIS.
This method is seductive because it imputes the most
likely value according to the model. However, it ignores the uncertainty
of the missing values and artificially
amplifies the relations between the columns of the data. Application of
richer models having more parameters does not help to evade these issues.
Stochastic regression methods, like <code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a></code> or
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a></code>, are generally preferred.
</p>
<p>At best, prediction can give reasonable estimates of the mean, especially
if normality assumptions are plausible. See Little and Rubin (2002, p. 62-64)
or Van Buuren (2012, p. 11-13, p. 45-46) for a discussion of this method.
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, Stef van Buuren, 2018
</p>


<h3>References</h3>

<p>Little, R.J.A. and Rubin, D.B. (2002). Statistical Analysis with Missing
Data.  New York: John Wiley and Sons.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-linearnormal.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.panImpute'>Impute multilevel missing data using <code>pan</code></h2><span id='topic+mice.impute.panImpute'></span>

<h3>Description</h3>

<p>This function is a wrapper around the <code>panImpute</code> function
from the <code>mitml</code> package so that it can be called to
impute blocks of variables in <code>mice</code>. The <code>mitml::panImpute</code>
function provides an interface to the <code>pan</code> package for
multiple imputation of multilevel data (Schafer &amp; Yucel, 2002).
Imputations can be generated using <code>type</code> or <code>formula</code>,
which offer different options for model specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.panImpute(
  data,
  formula,
  type,
  m = 1,
  silent = TRUE,
  format = "imputes",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.panImpute_+3A_data">data</code></td>
<td>
<p>A data frame containing incomplete and auxiliary variables,
the cluster indicator variable, and any other variables that should be
present in the imputed datasets.</p>
</td></tr>
<tr><td><code id="mice.impute.panImpute_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the role of each variable
in the imputation model. The basic model is constructed
by <code>model.matrix</code>, thus allowing to include derived variables
in the imputation model using <code>I()</code>. See
<code><a href="mitml.html#topic+panImpute">panImpute</a></code>.</p>
</td></tr>
<tr><td><code id="mice.impute.panImpute_+3A_type">type</code></td>
<td>
<p>An integer vector specifying the role of each variable
in the imputation model (see <code><a href="mitml.html#topic+panImpute">panImpute</a></code>)</p>
</td></tr>
<tr><td><code id="mice.impute.panImpute_+3A_m">m</code></td>
<td>
<p>The number of imputed data sets to generate.</p>
</td></tr>
<tr><td><code id="mice.impute.panImpute_+3A_silent">silent</code></td>
<td>
<p>(optional) Logical flag indicating if console output should be suppressed. Default is to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.panImpute_+3A_format">format</code></td>
<td>
<p>A character vector specifying the type of object that should
be returned. The default is <code>format = "list"</code>. No other formats are
currently supported.</p>
</td></tr>
<tr><td><code id="mice.impute.panImpute_+3A_...">...</code></td>
<td>
<p>Other named arguments: <code>n.burn</code>, <code>n.iter</code>,
<code>group</code>, <code>prior</code>, <code>silent</code> and others.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of imputations for all incomplete variables in the model,
that can be stored in the the <code>imp</code> component of the <code>mids</code>
object.
</p>


<h3>Note</h3>

<p>The number of imputations <code>m</code> is set to 1, and the function
is called <code>m</code> times so that it fits within the <code>mice</code>
iteration scheme.
</p>
<p>This is a multivariate imputation function using a joint model.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2018, building on work of Simon Grund,
Alexander Robitzsch and Oliver Luedtke (authors of <code>mitml</code> package)
and Joe Schafer (author of <code>pan</code> package).
</p>


<h3>References</h3>

<p>Grund S, Luedtke O, Robitzsch A (2016). Multiple
Imputation of Multilevel Missing Data: An Introduction to the R
Package <code>pan</code>. SAGE Open.
</p>
<p>Schafer JL (1997). Analysis of Incomplete Multivariate Data. London:
Chapman &amp; Hall.
</p>
<p>Schafer JL, and Yucel RM (2002). Computational strategies for
multivariate linear mixed-effects models with missing values.
Journal of Computational and Graphical Statistics, 11, 437-457.
</p>


<h3>See Also</h3>

<p><code><a href="mitml.html#topic+panImpute">panImpute</a></code>
</p>
<p>Other multivariate-2l: 
<code><a href="#topic+mice.impute.jomoImpute">mice.impute.jomoImpute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>blocks &lt;- list(c("bmi", "chl", "hyp"), "age")
method &lt;- c("panImpute", "pmm")
ini &lt;- mice(nhanes, blocks = blocks, method = method, maxit = 0)
pred &lt;- ini$pred
pred["B1", "hyp"] &lt;- -2
imp &lt;- mice(nhanes, blocks = blocks, method = method, pred = pred, maxit = 1)
</code></pre>

<hr>
<h2 id='mice.impute.passive'>Passive imputation</h2><span id='topic+mice.impute.passive'></span>

<h3>Description</h3>

<p>Calculate new variable during imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.passive(data, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.passive_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="mice.impute.passive_+3A_func">func</code></td>
<td>
<p>A <code>formula</code> specifying the transformations on data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Passive imputation is a special internal imputation function.  Using this
facility, the user can specify, at any point in the <code>mice</code> Gibbs
sampling algorithm, a function on the imputed data.  This is useful, for
example, to compute a cubic version of a variable, a transformation like
<code>Q = W/H^2</code> based on two variables, or a mean variable like
<code>(x_1+x_2+x_3)/3</code>. The so derived variables might be used in other
places in the imputation model. The function allows to dynamically derive
virtually any function of the imputed data at virtually any time.
</p>


<h3>Value</h3>

<p>The result of applying <code>formula</code>
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>
</p>

<hr>
<h2 id='mice.impute.pmm'>Imputation by predictive mean matching</h2><span id='topic+mice.impute.pmm'></span><span id='topic+pmm'></span>

<h3>Description</h3>

<p>Imputation by predictive mean matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.pmm(
  y,
  ry,
  x,
  wy = NULL,
  donors = 5L,
  matchtype = 1L,
  exclude = -99999999,
  ridge = 1e-05,
  use.matcher = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.pmm_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.pmm_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.pmm_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.pmm_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.pmm_+3A_donors">donors</code></td>
<td>
<p>The size of the donor pool among which a draw is made.
The default is <code>donors = 5L</code>. Setting <code>donors = 1L</code> always selects
the closest match, but is not recommended. Values between 3L and 10L
provide the best results in most cases (Morris et al, 2015).</p>
</td></tr>
<tr><td><code id="mice.impute.pmm_+3A_matchtype">matchtype</code></td>
<td>
<p>Type of matching distance. The default choice
(<code>matchtype = 1L</code>) calculates the distance between
the <em>predicted</em> value of <code>yobs</code> and
the <em>drawn</em> values of <code>ymis</code> (called type-1 matching).
Other choices are <code>matchtype = 0L</code>
(distance between predicted values) and <code>matchtype = 2L</code>
(distance between drawn values).</p>
</td></tr>
<tr><td><code id="mice.impute.pmm_+3A_exclude">exclude</code></td>
<td>
<p>Value or vector of values to exclude from the imputation donor pool in <code>y</code></p>
</td></tr>
<tr><td><code id="mice.impute.pmm_+3A_ridge">ridge</code></td>
<td>
<p>The ridge penalty used in <code>.norm.draw()</code> to prevent
problems with multicollinearity. The default is <code>ridge = 1e-05</code>,
which means that 0.01 percent of the diagonal is added to the cross-product.
Larger ridges may result in more biased estimates. For highly noisy data
(e.g. many junk variables), set <code>ridge = 1e-06</code> or even lower to
reduce bias. For highly collinear data, set <code>ridge = 1e-04</code> or higher.</p>
</td></tr>
<tr><td><code id="mice.impute.pmm_+3A_use.matcher">use.matcher</code></td>
<td>
<p>Logical. Set <code>use.matcher = TRUE</code> to specify
the C function <code>matcher()</code>, the now deprecated matching function that
was default in versions
<code>2.22</code> (June 2014) to <code>3.11.7</code> (Oct 2020). Since version <code>3.12.0</code>
<code>mice()</code> uses the much faster <code>matchindex</code> C function. Use
the deprecated <code>matcher</code> function only for exact reproduction.</p>
</td></tr>
<tr><td><code id="mice.impute.pmm_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputation of <code>y</code> by predictive mean matching, based on
van Buuren (2012, p. 73). The procedure is as follows:
</p>

<ol>
<li><p>Calculate the cross-product matrix <code class="reqn">S=X_{obs}'X_{obs}</code>.
</p>
</li>
<li><p>Calculate <code class="reqn">V = (S+{diag}(S)\kappa)^{-1}</code>, with some small ridge
parameter <code class="reqn">\kappa</code>.
</p>
</li>
<li><p>Calculate regression weights <code class="reqn">\hat\beta = VX_{obs}'y_{obs}.</code>
</p>
</li>
<li><p>Draw <code class="reqn">q</code> independent <code class="reqn">N(0,1)</code> variates in vector <code class="reqn">\dot z_1</code>.
</p>
</li>
<li><p>Calculate <code class="reqn">V^{1/2}</code> by Cholesky decomposition.
</p>
</li>
<li><p>Calculate <code class="reqn">\dot\beta = \hat\beta + \dot\sigma\dot z_1 V^{1/2}</code>.
</p>
</li>
<li><p>Calculate <code class="reqn">\dot\eta(i,j)=|X_{{obs},[i]|}\hat\beta-X_{{mis},[j]}\dot\beta</code>
with <code class="reqn">i=1,\dots,n_1</code> and <code class="reqn">j=1,\dots,n_0</code>.
</p>
</li>
<li><p>Construct <code class="reqn">n_0</code> sets <code class="reqn">Z_j</code>, each containing <code class="reqn">d</code> candidate donors, from Y_obs such that <code class="reqn">\sum_d\dot\eta(i,j)</code> is minimum for all <code class="reqn">j=1,\dots,n_0</code>. Break ties randomly.
</p>
</li>
<li><p>Draw one donor <code class="reqn">i_j</code> from <code class="reqn">Z_j</code> randomly for <code class="reqn">j=1,\dots,n_0</code>.
</p>
</li>
<li><p>Calculate imputations <code class="reqn">\dot y_j = y_{i_j}</code> for <code class="reqn">j=1,\dots,n_0</code>.
</p>
</li></ol>

<p>The name <em>predictive mean matching</em> was proposed by Little (1988).
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, Stef van Buuren, Karin Groothuis-Oudshoorn
</p>


<h3>References</h3>

<p>Little, R.J.A. (1988), Missing data adjustments in large surveys
(with discussion), Journal of Business Economics and Statistics, 6, 287&ndash;301.
</p>
<p>Morris TP, White IR, Royston P (2015). Tuning multiple imputation by predictive
mean matching and local residual draws. BMC Med Res Methodol. ;14:75.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-pmm.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We normally call mice.impute.pmm() from within mice()
# But we may call it directly as follows (not recommended)

set.seed(53177)
xname &lt;- c("age", "hgt", "wgt")
r &lt;- stats::complete.cases(boys[, xname])
x &lt;- boys[r, xname]
y &lt;- boys[r, "tv"]
ry &lt;- !is.na(y)
table(ry)

# percentage of missing data in tv
sum(!ry) / length(ry)

# Impute missing tv data
yimp &lt;- mice.impute.pmm(y, ry, x)
length(yimp)
hist(yimp, xlab = "Imputed missing tv")

# Impute all tv data
yimp &lt;- mice.impute.pmm(y, ry, x, wy = rep(TRUE, length(y)))
length(yimp)
hist(yimp, xlab = "Imputed missing and observed tv")
plot(jitter(y), jitter(yimp),
  main = "Predictive mean matching on age, height and weight",
  xlab = "Observed tv (n = 224)",
  ylab = "Imputed tv (n = 224)"
)
abline(0, 1)
cor(y, yimp, use = "pair")

# Use blots to exclude different values per column
# Create blots object
blots &lt;- make.blots(boys)
# Exclude ml 1 through 5 from tv donor pool
blots$tv$exclude &lt;- c(1:5)
# Exclude 100 random observed heights from tv donor pool
blots$hgt$exclude &lt;- sample(unique(boys$hgt), 100)
imp &lt;- mice(boys, method = "pmm", print = FALSE, blots = blots, seed=123)
blots$hgt$exclude %in% unlist(c(imp$imp$hgt)) # MUST be all FALSE
blots$tv$exclude %in% unlist(c(imp$imp$tv)) # MUST be all FALSE
</code></pre>

<hr>
<h2 id='mice.impute.polr'>Imputation of ordered data by polytomous regression</h2><span id='topic+mice.impute.polr'></span>

<h3>Description</h3>

<p>Imputes missing data in a categorical variable using polytomous regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.polr(
  y,
  ry,
  x,
  wy = NULL,
  nnet.maxit = 100,
  nnet.trace = FALSE,
  nnet.MaxNWts = 1500,
  polr.to.loggedEvents = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.polr_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.polr_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.polr_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.polr_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.polr_+3A_nnet.maxit">nnet.maxit</code></td>
<td>
<p>Tuning parameter for <code>nnet()</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.polr_+3A_nnet.trace">nnet.trace</code></td>
<td>
<p>Tuning parameter for <code>nnet()</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.polr_+3A_nnet.maxnwts">nnet.MaxNWts</code></td>
<td>
<p>Tuning parameter for <code>nnet()</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.polr_+3A_polr.to.loggedevents">polr.to.loggedEvents</code></td>
<td>
<p>A logical indicating whether each fallback
to the <code>multinom()</code> function should be written to <code>loggedEvents</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.polr_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mice.impute.polr()</code> imputes for ordered categorical response
variables by the proportional odds logistic regression (polr) model. The
function repeatedly applies logistic regression on the successive splits. The
model is also known as the cumulative link model.
</p>
<p>By default, ordered factors with more than two levels are imputed by
<code>mice.impute.polr</code>.
</p>
<p>The algorithm of <code>mice.impute.polr</code> uses the function <code>polr()</code> from
the <code>MASS</code> package.
</p>
<p>In order to avoid bias due to perfect prediction, the algorithm augment the
data according to the method of White, Daniel and Royston (2010).
</p>
<p>The call to <code>polr</code> might fail, usually because the data are very sparse.
In that case, <code>multinom</code> is tried as a fallback.
If the local flag <code>polr.to.loggedEvents</code> is set to TRUE,
a record is written
to the <code>loggedEvents</code> component of the <code><a href="#topic+mids">mids</a></code> object.
Use <code>mice(data, polr.to.loggedEvents = TRUE)</code> to set the flag.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Note</h3>

<p>In December 2019 Simon White alerted that the
<code>polr</code> could always fail silently. I can confirm this behaviour for
versions <code>mice 3.0.0 - mice 3.6.6</code>, so any method requests
for <code>polr</code> in these versions were in fact handled by <code>multinom</code>.
See <a href="https://github.com/amices/mice/issues/206">https://github.com/amices/mice/issues/206</a> for details.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000-2010
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Brand, J.P.L. (1999) <em>Development, implementation and evaluation of
multiple imputation strategies for the statistical analysis of incomplete
data sets.</em> Dissertation. Rotterdam: Erasmus University.
</p>
<p>White, I.R., Daniel, R. Royston, P. (2010). Avoiding bias due to perfect
prediction in multiple imputation of incomplete categorical variables.
<em>Computational Statistics and Data Analysis</em>, 54, 2267-2275.
</p>
<p>Venables, W.N. &amp; Ripley, B.D. (2002). <em>Modern applied statistics with
S-Plus (4th ed)</em>. Springer, Berlin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="nnet.html#topic+multinom">multinom</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.polyreg'>Imputation of unordered data by polytomous regression</h2><span id='topic+mice.impute.polyreg'></span>

<h3>Description</h3>

<p>Imputes missing data in a categorical variable using polytomous regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.polyreg(
  y,
  ry,
  x,
  wy = NULL,
  nnet.maxit = 100,
  nnet.trace = FALSE,
  nnet.MaxNWts = 1500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.polyreg_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.polyreg_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.polyreg_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.polyreg_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.polyreg_+3A_nnet.maxit">nnet.maxit</code></td>
<td>
<p>Tuning parameter for <code>nnet()</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.polyreg_+3A_nnet.trace">nnet.trace</code></td>
<td>
<p>Tuning parameter for <code>nnet()</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.polyreg_+3A_nnet.maxnwts">nnet.MaxNWts</code></td>
<td>
<p>Tuning parameter for <code>nnet()</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.polyreg_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mice.impute.polyreg()</code> imputes categorical response
variables by the Bayesian polytomous regression model. See J.P.L. Brand
(1999), Chapter 4, Appendix B.
</p>
<p>By default, unordered factors with more than two levels are imputed by
<code>mice.impute.polyreg()</code>.
</p>
<p>The method consists of the following steps:
</p>

<ol>
<li><p> Fit categorical response as a multinomial model
</p>
</li>
<li><p> Compute predicted categories
</p>
</li>
<li><p> Add appropriate noise to predictions
</p>
</li></ol>

<p>The algorithm of <code>mice.impute.polyreg</code> uses the function
<code>multinom()</code> from the <code>nnet</code> package.
</p>
<p>In order to avoid bias due to perfect prediction, the algorithm augment the
data according to the method of White, Daniel and Royston (2010).
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000-2010
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Brand, J.P.L. (1999) <em>Development, implementation and evaluation of
multiple imputation strategies for the statistical analysis of incomplete
data sets.</em> Dissertation. Rotterdam: Erasmus University.
</p>
<p>White, I.R., Daniel, R. Royston, P. (2010). Avoiding bias due to perfect
prediction in multiple imputation of incomplete categorical variables.
<em>Computational Statistics and Data Analysis</em>, 54, 2267-2275.
</p>
<p>Venables, W.N. &amp; Ripley, B.D. (2002). <em>Modern applied statistics with
S-Plus (4th ed)</em>. Springer, Berlin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="nnet.html#topic+multinom">multinom</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>

<hr>
<h2 id='mice.impute.quadratic'>Imputation of quadratic terms</h2><span id='topic+mice.impute.quadratic'></span><span id='topic+quadratic'></span>

<h3>Description</h3>

<p>Imputes incomplete variable that appears as both
main effect and quadratic effect in the complete-data model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.quadratic(y, ry, x, wy = NULL, quad.outcome = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.quadratic_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.quadratic_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.quadratic_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.quadratic_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.quadratic_+3A_quad.outcome">quad.outcome</code></td>
<td>
<p>The name of the outcome in the quadratic analysis as a
character string. For example, if the substantive model of interest is
<code>y ~ x + xx</code>, then <code>"y"</code> would be the <code>quad.outcome</code></p>
</td></tr>
<tr><td><code id="mice.impute.quadratic_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the &quot;polynomial combination&quot; method.
First, the polynomial
combination <code class="reqn">Z = Y \beta_1 + Y^2 \beta_2</code> is formed.
<code class="reqn">Z</code> is imputed by
predictive mean matching, followed by a decomposition of the imputed
data <code class="reqn">Z</code>
into components <code class="reqn">Y</code> and <code class="reqn">Y^2</code>.
See Van Buuren (2012, pp. 139-141) and Vink
et al (2012) for more details. The method ensures that 1) the imputed data
for <code class="reqn">Y</code> and <code class="reqn">Y^2</code> are mutually consistent, and 2) that provides unbiased
estimates of the regression weights in a complete-data linear regression that
use both <code class="reqn">Y</code> and <code class="reqn">Y^2</code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Note</h3>

<p>There are two situations to consider. If only the linear term <code>Y</code>
is present in the data, calculate the quadratic term <code>YY</code> after
imputation. If both the linear term <code>Y</code> and the the quadratic term
<code>YY</code> are variables in the data, then first impute <code>Y</code> by calling
<code>mice.impute.quadratic()</code> on <code>Y</code>, and then impute <code>YY</code> by
passive imputation as <code>meth["YY"] &lt;- "~I(Y^2)"</code>.  See example section
for details.  Generally, we would like <code>YY</code> to be present in the data if
we need to preserve quadratic relations between <code>YY</code> and any third
variables in the multivariate incomplete data that we might wish to impute.
</p>


<h3>Author(s)</h3>

<p>Mingyang Cai and Gerko Vink
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a></code>
Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-knowledge.html#sec:quadratic"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>Vink, G., van Buuren, S. (2013). Multiple Imputation of Squared Terms.
<em>Sociological Methods &amp; Research</em>, 42:598-607.
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create Data
B1 &lt;- .5
B2 &lt;- .5
X &lt;- rnorm(1000)
XX &lt;- X^2
e &lt;- rnorm(1000, 0, 1)
Y &lt;- B1 * X + B2 * XX + e
dat &lt;- data.frame(x = X, xx = XX, y = Y)

# Impose 25 percent MCAR Missingness
dat[0 == rbinom(1000, 1, 1 - .25), 1:2] &lt;- NA

# Prepare data for imputation
ini &lt;- mice(dat, maxit = 0)
meth &lt;- c("quadratic", "~I(x^2)", "")
pred &lt;- ini$pred
pred[, "xx"] &lt;- 0

# Impute data
imp &lt;- mice(dat, meth = meth, pred = pred, quad.outcome = "y")

# Pool results
pool(with(imp, lm(y ~ x + xx)))

# Plot results
stripplot(imp)
plot(dat$x, dat$xx, col = mdc(1), xlab = "x", ylab = "xx")
cmp &lt;- complete(imp)
points(cmp$x[is.na(dat$x)], cmp$xx[is.na(dat$x)], col = mdc(2))
</code></pre>

<hr>
<h2 id='mice.impute.rf'>Imputation by random forests</h2><span id='topic+mice.impute.rf'></span>

<h3>Description</h3>

<p>Imputes univariate missing data using random forests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.rf(
  y,
  ry,
  x,
  wy = NULL,
  ntree = 10,
  rfPackage = c("ranger", "randomForest"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.rf_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.rf_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.rf_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.rf_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.rf_+3A_ntree">ntree</code></td>
<td>
<p>The number of trees to grow. The default is 10.</p>
</td></tr>
<tr><td><code id="mice.impute.rf_+3A_rfpackage">rfPackage</code></td>
<td>
<p>A single string specifying the backend for estimating the
random forest. The default backend is the <code>ranger</code> package. The only
alternative currently implemented is the <code>randomForest</code> package, which
used to be the default in mice 3.13.10 and earlier.</p>
</td></tr>
<tr><td><code id="mice.impute.rf_+3A_...">...</code></td>
<td>
<p>Other named arguments passed down to
<code>mice:::install.on.demand()</code>, <code>randomForest::randomForest()</code> and
<code>randomForest:::randomForest.default()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputation of <code>y</code> by random forests. The method
calls <code>randomForrest()</code> which implements Breiman's random forest
algorithm (based on Breiman and Cutler's original Fortran code)
for classification and regression. See Appendix A.1 of Doove et al.
(2014) for the definition of the algorithm used.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Note</h3>

<p>An alternative implementation was independently
developed by Shah et al (2014). This were available as
functions <code>CALIBERrfimpute::mice.impute.rfcat</code> and
<code>CALIBERrfimpute::mice.impute.rfcont</code> (now archived).
Simulations by Shah (Feb 13, 2014) suggested that
the quality of the imputation for 10 and 100 trees was identical,
so mice 2.22 changed the default number of trees from <code>ntree = 100</code> to
<code>ntree = 10</code>.
</p>


<h3>Author(s)</h3>

<p>Lisa Doove, Stef van Buuren, Elise Dusseldorp, 2012; Patrick Rockenschaub, 2021
</p>


<h3>References</h3>

<p>Doove, L.L., van Buuren, S., Dusseldorp, E. (2014), Recursive partitioning
for missing data imputation in the presence of interaction Effects.
Computational Statistics &amp; Data Analysis, 72, 92-104.
</p>
<p>Shah, A.D., Bartlett, J.W., Carpenter, J., Nicholas, O., Hemingway, H. (2014),
Comparison of random forest and parametric imputation models for
imputing missing data using MICE: A CALIBER study. American Journal
of Epidemiology, <a href="https://doi.org/10.1093/aje/kwt312">doi:10.1093/aje/kwt312</a>.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-cart.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mice.impute.cart">mice.impute.cart</a></code>,
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code>
<code><a href="ranger.html#topic+ranger">ranger</a></code>
</p>
<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.ri">mice.impute.ri</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
imp &lt;- mice(nhanes2, meth = "rf", ntree = 3)
plot(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.ri'>Imputation by the random indicator method for nonignorable data</h2><span id='topic+mice.impute.ri'></span><span id='topic+ri'></span>

<h3>Description</h3>

<p>Imputes nonignorable missing data by the random indicator method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.ri(y, ry, x, wy = NULL, ri.maxit = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.ri_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.ri_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.ri_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.ri_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.ri_+3A_ri.maxit">ri.maxit</code></td>
<td>
<p>Number of inner iterations</p>
</td></tr>
<tr><td><code id="mice.impute.ri_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random indicator method estimates an offset between the
distribution of the observed and missing data using an algorithm
that iterates over the response and imputation models.
</p>
<p>This routine assumes that the response model and imputation model
have same predictors.
</p>
<p>For an MNAR alternative see also <code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a></code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Shahab Jolani (University of Utrecht)
</p>


<h3>References</h3>

<p>Jolani, S. (2012).
<em>Dual Imputation Strategies for Analyzing Incomplete Data</em>.
Dissertation. University of Utrecht, Dec 7 2012.
</p>


<h3>See Also</h3>

<p>Other univariate imputation functions: 
<code><a href="#topic+mice.impute.cart">mice.impute.cart</a>()</code>,
<code><a href="#topic+mice.impute.lasso.logreg">mice.impute.lasso.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.norm">mice.impute.lasso.norm</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.logreg">mice.impute.lasso.select.logreg</a>()</code>,
<code><a href="#topic+mice.impute.lasso.select.norm">mice.impute.lasso.select.norm</a>()</code>,
<code><a href="#topic+mice.impute.lda">mice.impute.lda</a>()</code>,
<code><a href="#topic+mice.impute.logreg.boot">mice.impute.logreg.boot</a>()</code>,
<code><a href="#topic+mice.impute.logreg">mice.impute.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mean">mice.impute.mean</a>()</code>,
<code><a href="#topic+mice.impute.midastouch">mice.impute.midastouch</a>()</code>,
<code><a href="#topic+mice.impute.mnar.logreg">mice.impute.mnar.logreg</a>()</code>,
<code><a href="#topic+mice.impute.mpmm">mice.impute.mpmm</a>()</code>,
<code><a href="#topic+mice.impute.norm.boot">mice.impute.norm.boot</a>()</code>,
<code><a href="#topic+mice.impute.norm.nob">mice.impute.norm.nob</a>()</code>,
<code><a href="#topic+mice.impute.norm.predict">mice.impute.norm.predict</a>()</code>,
<code><a href="#topic+mice.impute.norm">mice.impute.norm</a>()</code>,
<code><a href="#topic+mice.impute.pmm">mice.impute.pmm</a>()</code>,
<code><a href="#topic+mice.impute.polr">mice.impute.polr</a>()</code>,
<code><a href="#topic+mice.impute.polyreg">mice.impute.polyreg</a>()</code>,
<code><a href="#topic+mice.impute.quadratic">mice.impute.quadratic</a>()</code>,
<code><a href="#topic+mice.impute.rf">mice.impute.rf</a>()</code>
</p>

<hr>
<h2 id='mice.impute.sample'>Imputation by simple random sampling</h2><span id='topic+mice.impute.sample'></span>

<h3>Description</h3>

<p>Imputes a random sample from the observed <code>y</code> data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.sample(y, ry, x = NULL, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.sample_+3A_y">y</code></td>
<td>
<p>Vector to be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.sample_+3A_ry">ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.sample_+3A_x">x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td></tr>
<tr><td><code id="mice.impute.sample_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.sample_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a simple random sample from the observed values in
<code>y</code>, and returns these as imputations.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000, 2017
</p>


<h3>References</h3>

<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>

<hr>
<h2 id='mice.mids'>Multivariate Imputation by Chained Equations (Iteration Step)</h2><span id='topic+mice.mids'></span>

<h3>Description</h3>

<p>Takes a <code>mids</code> object, and produces a new object of class <code>mids</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.mids(obj, newdata = NULL, maxit = 1, printFlag = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.mids_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>mids</code>, typically produces by a previous
call to <code>mice()</code> or <code>mice.mids()</code></p>
</td></tr>
<tr><td><code id="mice.mids_+3A_newdata">newdata</code></td>
<td>
<p>An optional <code>data.frame</code> for which multiple imputations
are generated according to the model in <code>obj</code>.</p>
</td></tr>
<tr><td><code id="mice.mids_+3A_maxit">maxit</code></td>
<td>
<p>The number of additional Gibbs sampling iterations.</p>
</td></tr>
<tr><td><code id="mice.mids_+3A_printflag">printFlag</code></td>
<td>
<p>A Boolean flag. If <code>TRUE</code>, diagnostic information
during the Gibbs sampling iterations will be written to the command window.
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mice.mids_+3A_...">...</code></td>
<td>
<p>Named arguments that are passed down to the univariate imputation
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables the user to split up the computations of the Gibbs
sampler into smaller parts. This is useful for the following reasons:
</p>
 <ul>
<li><p> RAM memory may become easily exhausted if the number of
iterations is large. Returning to prompt/session level may alleviate these
problems.  </p>
</li>
<li><p> The user can compute customized convergence statistics at
specific points, e.g. after each iteration, for monitoring convergence.  -
For computing a 'few extra iterations'.  </p>
</li></ul>
<p> Note: The imputation model itself
is specified in the <code>mice()</code> function and cannot be changed with
<code>mice.mids</code>.  The state of the random generator is saved with the
<code>mids</code> object.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+complete">complete</a></code>, <code><a href="#topic+mice">mice</a></code>, <code><a href="base.html#topic+set.seed">set.seed</a></code>,
<code><a href="#topic+mids-class">mids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp1 &lt;- mice(nhanes, maxit = 1, seed = 123)
imp2 &lt;- mice.mids(imp1)

# yields the same result as
imp &lt;- mice(nhanes, maxit = 2, seed = 123)

# verification
identical(imp$imp, imp2$imp)
#
</code></pre>

<hr>
<h2 id='mice.theme'>Set the theme for the plotting Trellis functions</h2><span id='topic+mice.theme'></span>

<h3>Description</h3>

<p>The <code>mice.theme()</code> function sets default choices for
Trellis plots that are built into <span class="pkg">mice</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.theme(transparent = TRUE, alpha.fill = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.theme_+3A_transparent">transparent</code></td>
<td>
<p>A logical indicating whether alpha-transparency is
allowed. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mice.theme_+3A_alpha.fill">alpha.fill</code></td>
<td>
<p>A numerical values between 0 and 1 that indicates the
default alpha value for fills.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mice.theme()</code> returns a named list that can be used as a theme in the functions in
<span class="pkg">lattice</span>. By default, the <code>mice.theme()</code> function sets
<code>transparent &lt;- TRUE</code> if the current device <code>.Device</code> supports
semi-transparent colors.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren 2011
</p>

<hr>
<h2 id='mids-class'>Multiply imputed data set (<code>mids</code>)</h2><span id='topic+mids-class'></span><span id='topic+mids'></span>

<h3>Description</h3>

<p>The <code>mids</code> object contains a multiply imputed data set. The <code>mids</code> object is
generated by functions <code>mice()</code>, <code>mice.mids()</code>, <code>cbind.mids()</code>,
<code>rbind.mids()</code> and <code>ibind.mids()</code>.
</p>


<h3>Details</h3>

<p>The <code>mids</code>
class of objects has methods for the following generic functions:
<code>print</code>, <code>summary</code>, <code>plot</code>.
</p>
<p>The <code>loggedEvents</code> entry is a matrix with five columns containing a
record of automatic removal actions. It is <code>NULL</code> is no action was
made.  At initialization the program does the following three actions:
</p>

<dl>
<dt>1</dt><dd><p>A variable that contains missing values, that is not imputed
and that is used as a predictor is removed</p>
</dd>
<dt>2</dt><dd><p>A constant variable is removed</p>
</dd>
<dt>3</dt><dd><p>A collinear variable is removed.</p>
</dd>
</dl>

<p>During iteration, the program does the following
actions:
</p>

<dl>
<dt>1</dt><dd><p>One or more variables that are linearly dependent are removed
(for categorical data, a 'variable' corresponds to a dummy variable)</p>
</dd>
<dt>2</dt><dd><p>Proportional odds regression imputation that does not converge
and is replaced by <code>polyreg</code>.</p>
</dd>
</dl>

<p>Explanation of elements in <code>loggedEvents</code>:
</p>

<dl>
<dt><code>it</code></dt><dd><p>iteration number at which the record was added,</p>
</dd>
<dt><code>im</code></dt><dd><p>imputation number,</p>
</dd>
<dt><code>dep</code></dt><dd><p>name of the dependent variable,</p>
</dd>
<dt><code>meth</code></dt><dd><p>imputation method used,</p>
</dd>
<dt><code>out</code></dt><dd><p>a (possibly long) character vector with the
names of the altered or removed predictors.</p>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code> containing the
following slots:</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Original (incomplete) data set.</p>
</dd>
<dt><code>imp</code>:</dt><dd><p>A list of <code>ncol(data)</code> components with
the generated multiple imputations. Each list components is a
<code>data.frame</code> (<code>nmis[j]</code> by <code>m</code>) of imputed values
for variable <code>j</code>.</p>
</dd>
<dt><code>m</code>:</dt><dd><p>Number of imputations.</p>
</dd>
<dt><code>where</code>:</dt><dd><p>The <code>where</code> argument of the
<code>mice()</code> function.</p>
</dd>
<dt><code>blocks</code>:</dt><dd><p>The <code>blocks</code> argument of the
<code>mice()</code> function.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>Call that created the object.</p>
</dd>
<dt><code>nmis</code>:</dt><dd><p>An array containing the number of missing
observations per column.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>A vector of strings of <code>length(blocks</code>
specifying the imputation method per block.</p>
</dd>
<dt><code>predictorMatrix</code>:</dt><dd><p>A numerical matrix of containing
integers specifying the predictor set.</p>
</dd>
<dt><code>visitSequence</code>:</dt><dd><p>The sequence in which columns are visited.</p>
</dd>
<dt><code>formulas</code>:</dt><dd><p>A named list of formula's, or expressions that
can be converted into formula's by <code>as.formula</code>. List elements
correspond to blocks. The block to which the list element applies is
identified by its name, so list names must correspond to block names.</p>
</dd>
<dt><code>post</code>:</dt><dd><p>A vector of strings of length <code>length(blocks)</code>
with commands for post-processing.</p>
</dd>
<dt><code>blots</code>:</dt><dd><p>&quot;Block dots&quot;. The <code>blots</code> argument to the <code>mice()</code>
function.</p>
</dd>
<dt><code>ignore</code>:</dt><dd><p>A logical vector of length <code>nrow(data)</code> indicating
the rows in <code>data</code> used to build the imputation model. (new in <code>mice 3.12.0</code>)</p>
</dd>
<dt><code>seed</code>:</dt><dd><p>The seed value of the solution.</p>
</dd>
<dt><code>iteration</code>:</dt><dd><p>Last Gibbs sampling iteration number.</p>
</dd>
<dt><code>lastSeedValue</code>:</dt><dd><p>The most recent seed value.</p>
</dd>
<dt><code>chainMean</code>:</dt><dd><p>A list of <code>m</code> components. Each
component is a <code>length(visitSequence)</code> by <code>maxit</code> matrix
containing the mean of the generated multiple imputations.
The array can be used for monitoring convergence.
Note that observed data are not present in this mean.</p>
</dd>
<dt><code>chainVar</code>:</dt><dd><p>A list with similar structure of <code>chainMean</code>,
containing the covariances of the imputed values.</p>
</dd>
<dt><code>loggedEvents</code>:</dt><dd><p>A <code>data.frame</code> with five columns
containing warnings, corrective actions, and other inside info.</p>
</dd>
<dt><code>version</code>:</dt><dd><p>Version number of <code>mice</code> package that
created the object.</p>
</dd>
<dt><code>date</code>:</dt><dd><p>Date at which the object was created.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>mice</code> package does not use
the S4 class definitions, and instead relies on the S3 list
equivalent <code>oldClass(obj) &lt;- "mids"</code>.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000
</p>


<h3>References</h3>

<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mira-class">mira</a></code>,
<code><a href="#topic+mipo">mipo</a></code>
</p>

<hr>
<h2 id='mids2mplus'>Export <code>mids</code> object to Mplus</h2><span id='topic+mids2mplus'></span>

<h3>Description</h3>

<p>Converts a <code>mids</code> object into a format recognized by Mplus, and writes
the data and the Mplus input files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mids2mplus(
  imp,
  file.prefix = "imp",
  path = getwd(),
  sep = "\t",
  dec = ".",
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mids2mplus_+3A_imp">imp</code></td>
<td>
<p>The <code>imp</code> argument is an object of class <code>mids</code>,
typically produced by the <code>mice()</code> function.</p>
</td></tr>
<tr><td><code id="mids2mplus_+3A_file.prefix">file.prefix</code></td>
<td>
<p>A character string describing the prefix of the output
data files.</p>
</td></tr>
<tr><td><code id="mids2mplus_+3A_path">path</code></td>
<td>
<p>A character string containing the path of the output file.  By
default, files are written to the current <code>R</code> working directory.</p>
</td></tr>
<tr><td><code id="mids2mplus_+3A_sep">sep</code></td>
<td>
<p>The separator between the data fields.</p>
</td></tr>
<tr><td><code id="mids2mplus_+3A_dec">dec</code></td>
<td>
<p>The decimal separator for numerical data.</p>
</td></tr>
<tr><td><code id="mids2mplus_+3A_silent">silent</code></td>
<td>
<p>A logical flag stating whether the names of the files should be
printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automates most of the work needed to export a <code>mids</code>
object to <code>Mplus</code>. The function writes the multiple imputation datasets,
the file that contains the names of the multiple imputation data sets and an
<code>Mplus</code> input file. The <code>Mplus</code> input file has the proper file
names, so in principle it should run and read the data without alteration.
<code>Mplus</code> will recognize the data set as a multiply imputed data set, and
do automatic pooling in procedures where that is supported.
</p>


<h3>Value</h3>

<p>The return value is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, 2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mids-class">mids</a></code>, <code><a href="#topic+mids2spss">mids2spss</a></code>
</p>

<hr>
<h2 id='mids2spss'>Export <code>mids</code> object to SPSS</h2><span id='topic+mids2spss'></span>

<h3>Description</h3>

<p>Converts a <code>mids</code> object into a format recognized by SPSS, and writes
the data and the SPSS syntax files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mids2spss(
  imp,
  filename = "midsdata",
  path = getwd(),
  compress = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mids2spss_+3A_imp">imp</code></td>
<td>
<p>The <code>imp</code> argument is an object of class <code>mids</code>,
typically produced by the <code>mice()</code> function.</p>
</td></tr>
<tr><td><code id="mids2spss_+3A_filename">filename</code></td>
<td>
<p>A character string describing the name of the output data
file and its extension.</p>
</td></tr>
<tr><td><code id="mids2spss_+3A_path">path</code></td>
<td>
<p>A character string containing the path of the output file. The
value in <code>path</code> is appended to <code>filedat</code>. By
default, files are written to the current <code>R</code> working directory. If
<code>path=NULL</code> then no file path appending is done.</p>
</td></tr>
<tr><td><code id="mids2spss_+3A_compress">compress</code></td>
<td>
<p>A logical flag stating whether the resulting SPSS set should
be a compressed <code>.zsav</code> file.</p>
</td></tr>
<tr><td><code id="mids2spss_+3A_silent">silent</code></td>
<td>
<p>A logical flag stating whether the location of the saved file should be
printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automates most of the work needed to export a <code>mids</code>
object to SPSS. It uses <code>haven::write_sav()</code> to facilitate the export to an
SPSS <code>.sav</code> or <code>.zsav</code> file.
</p>
<p>Below are some things to pay attention to.
</p>
<p>The <code>SPSS</code> syntax file has the proper file names and separators set, so
in principle it should run and read the data without alteration. <code>SPSS</code>
is more strict than <code>R</code> with respect to the paths. Always use the full
path, otherwise <code>SPSS</code> may not be able to find the data file.
</p>
<p>Factors in <code>R</code> translate into categorical variables in <code>SPSS</code>. The
internal coding of factor levels used in <code>R</code> is exported. This is
generally acceptable for <code>SPSS</code>. However, when the data are to be
combined with existing <code>SPSS</code> data, watch out for any changes in the
factor levels codes.
</p>
<p><code>SPSS</code> will recognize the data set as a multiply imputed data set, and
do automatic pooling in procedures where that is supported. Note however that
pooling is an extra option only available to those who license the
<code>MISSING VALUES</code> module. Without this license, <code>SPSS</code> will still
recognize the structure of the data, but it will not pool the multiply imputed
estimates into a single inference.
</p>


<h3>Value</h3>

<p>The return value is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, dec 2020.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mids-class">mids</a></code>
</p>

<hr>
<h2 id='mipo'><code>mipo</code>: Multiple imputation pooled object</h2><span id='topic+mipo'></span><span id='topic+summary.mipo'></span><span id='topic+print.mipo'></span><span id='topic+print.mipo.summary'></span><span id='topic+process_mipo'></span>

<h3>Description</h3>

<p>The <code>mipo</code> object contains the results of the pooling step.
The function <code><a href="#topic+pool">pool</a></code> generates an object of class <code>mipo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mipo(mira.obj, ...)

## S3 method for class 'mipo'
summary(
  object,
  type = c("tests", "all"),
  conf.int = FALSE,
  conf.level = 0.95,
  exponentiate = FALSE,
  ...
)

## S3 method for class 'mipo'
print(x, ...)

## S3 method for class 'mipo.summary'
print(x, ...)

process_mipo(z, x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mipo_+3A_mira.obj">mira.obj</code></td>
<td>
<p>An object of class <code>mira</code></p>
</td></tr>
<tr><td><code id="mipo_+3A_...">...</code></td>
<td>
<p>Arguments passed down</p>
</td></tr>
<tr><td><code id="mipo_+3A_object">object</code></td>
<td>
<p>An object of class <code>mipo</code></p>
</td></tr>
<tr><td><code id="mipo_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether to include
a confidence interval. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mipo_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level of the interval, used only if
<code>conf.int = TRUE</code>. Number between 0 and 1.</p>
</td></tr>
<tr><td><code id="mipo_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Flag indicating whether to exponentiate the
coefficient estimates and confidence intervals (typical for
logistic regression).</p>
</td></tr>
<tr><td><code id="mipo_+3A_x">x</code></td>
<td>
<p>An object of class <code>mipo</code></p>
</td></tr>
<tr><td><code id="mipo_+3A_z">z</code></td>
<td>
<p>Data frame with a tidied version of a coefficient matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object class <code>mipo</code> is a <code>list</code> with
elements: <code>call</code>, <code>m</code>, <code>pooled</code> and <code>glanced</code>.
</p>
<p>The <code>pooled</code> elements is a data frame with columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>estimate</code></td><td style="text-align: left;"> Pooled complete data estimate</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ubar</code>    </td><td style="text-align: left;"> Within-imputation variance of <code>estimate</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>b</code>       </td><td style="text-align: left;"> Between-imputation variance of <code>estimate</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>t</code>       </td><td style="text-align: left;"> Total variance, of <code>estimate</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>dfcom</code>   </td><td style="text-align: left;"> Degrees of freedom in complete data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>df</code>      </td><td style="text-align: left;"> Degrees of freedom of $t$-statistic</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>riv</code>     </td><td style="text-align: left;"> Relative increase in variance</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lambda</code>  </td><td style="text-align: left;"> Proportion attributable to the missingness</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>fmi</code>     </td><td style="text-align: left;"> Fraction of missing information</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The names of the terms are stored as <code>row.names(pooled)</code>.
</p>
<p>The <code>glanced</code> elements is a <code>data.frame</code> with <code>m</code> rows.
The precise composition depends on the class of the complete-data analysis.
At least field <code>nobs</code> is expected to be present.
</p>
<p>The <code>process_mipo</code> is a helper function to process a
tidied mipo object, and is normally not called directly.
It adds a confidence interval, and optionally exponentiates, the result.
</p>


<h3>Value</h3>

<p>The <code>summary</code> method returns a data frame with summary statistics of the pooled analysis.
</p>


<h3>References</h3>

<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool">pool</a></code>,
<code><a href="#topic+mids-class">mids</a></code>, <code><a href="#topic+mira-class">mira</a></code>
</p>

<hr>
<h2 id='mira-class'>Multiply imputed repeated analyses (<code>mira</code>)</h2><span id='topic+mira-class'></span><span id='topic+mira'></span>

<h3>Description</h3>

<p>The <code>mira</code> object is generated by the <code>with.mids()</code> function.
The <code>as.mira()</code>
function takes the results of repeated complete-data analysis stored as a
list, and turns it into a <code>mira</code> object that can be pooled.
</p>


<h3>Details</h3>

<p>In versions prior to <code>mice 3.0</code> pooling required only that
<code>coef()</code> and <code>vcov()</code> methods were available for fitted
objects. <em>This feature is no longer supported</em>. The reason is that <code>vcov()</code>
methods are inconsistent across packages, leading to buggy behaviour
of the <code>pool()</code> function. Since <code>mice 3.0+</code>, the <code>broom</code>
package takes care of filtering out the relevant parts of the
complete-data analysis. It may happen that you'll see the messages
like <code>No method for tidying an S3 object of class ...</code> or
<code>Error: No glance method for objects of class ...</code>. The royal
way to solve this problem is to write your own <code>glance()</code> and <code>tidy()</code>
methods and add these to <code>broom</code> according to the specifications
given in <a href="https://broom.tidymodels.org">https://broom.tidymodels.org</a>.
</p>
<p>#'The <code>mira</code> class of objects has methods for the
following generic functions: <code>print</code>, <code>summary</code>.
</p>
<p>Many of the functions of the <code>mice</code> package do not use the
S4 class definitions, and instead rely on the S3 list equivalent
<code>oldClass(obj) &lt;- "mira"</code>.
</p>


<h3>Slots</h3>


<p>#'    </p>
<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code> containing the
following slots:</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The call that created the object.</p>
</dd>
<dt><code>call1</code>:</dt><dd><p>The call that created the <code>mids</code> object that was used
in <code>call</code>.</p>
</dd>
<dt><code>nmis</code>:</dt><dd><p>An array containing the number of missing observations per
column.</p>
</dd>
<dt><code>analyses</code>:</dt><dd><p>A list of <code>m</code> components containing the individual
fit objects from each of the <code>m</code> complete data analyses.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stef van Buuren, Karin Groothuis-Oudshoorn, 2000
</p>


<h3>References</h3>

<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with.mids">with.mids</a></code>, <code><a href="#topic+mids-class">mids</a></code>, <code><a href="#topic+mipo">mipo</a></code>
</p>

<hr>
<h2 id='mnar_demo_data'>MNAR demo data</h2><span id='topic+mnar_demo_data'></span>

<h3>Description</h3>

<p>A toy example from Margarita Moreno-Betancur for checking NARFCS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mnar_demo_data
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 500 rows and 3 columns.
</p>


<h3>Details</h3>

<p>A small dataset with just three columns.
</p>


<h3>Source</h3>

<p><a href="https://github.com/moreno-betancur/NARFCS/blob/master/datmis.csv">https://github.com/moreno-betancur/NARFCS/blob/master/datmis.csv</a>
</p>

<hr>
<h2 id='name.blocks'>Name imputation blocks</h2><span id='topic+name.blocks'></span>

<h3>Description</h3>

<p>This helper function names any unnamed elements in the <code>blocks</code>
specification. This is a convenience function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.blocks(blocks, prefix = "B")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name.blocks_+3A_blocks">blocks</code></td>
<td>
<p>List of vectors with variable names per block. List elements
may be named to identify blocks. Variables within a block are
imputed by a multivariate imputation method
(see <code>method</code> argument). By default each variable is placed
into its own block, which is effectively
fully conditional specification (FCS) by univariate models
(variable-by-variable imputation). Only variables whose names appear in
<code>blocks</code> are imputed. The relevant columns in the <code>where</code>
matrix are set to <code>FALSE</code> of variables that are not block members.
A variable may appear in multiple blocks. In that case, it is
effectively re-imputed each time that it is visited.</p>
</td></tr>
<tr><td><code id="name.blocks_+3A_prefix">prefix</code></td>
<td>
<p>A character vector of length 1 with the prefix to
be using for naming any unnamed blocks with two or more variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will name any unnamed list elements specified in
the optional argument <code>blocks</code>. Unnamed blocks
consisting of just one variable will be named after this variable.
Unnamed blocks containing more than one variables will be named
by the <code>prefix</code> argument, padded by an integer sequence
stating at 1.
</p>


<h3>Value</h3>

<p>A named list of character vectors with variables names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>blocks &lt;- list(c("hyp", "chl"), AGE = "age", c("bmi", "hyp"), "edu")
name.blocks(blocks)
</code></pre>

<hr>
<h2 id='name.formulas'>Name formula list elements</h2><span id='topic+name.formulas'></span>

<h3>Description</h3>

<p>This helper function names any unnamed elements in the <code>formula</code>
list. This is a convenience function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.formulas(formulas, prefix = "F")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name.formulas_+3A_formulas">formulas</code></td>
<td>
<p>A named list of formula's, or expressions that
can be converted into formula's by <code>as.formula</code>. List elements
correspond to blocks. The block to which the list element applies is
identified by its name, so list names must correspond to block names.
The <code>formulas</code> argument is an alternative to the
<code>predictorMatrix</code> argument that allows for more flexibility in
specifying imputation models, e.g., for specifying interaction terms.</p>
</td></tr>
<tr><td><code id="name.formulas_+3A_prefix">prefix</code></td>
<td>
<p>A character vector of length 1 with the prefix to
be using for naming any unnamed blocks with two or more variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will name any unnamed list elements specified in
the optional argument <code>formula</code>. Unnamed formula's
consisting with just one response variable will be named
after this variable. Unnamed formula's containing more
than one variable will be named by the <code>prefix</code>
argument, padded by an integer sequence stating at 1.
</p>


<h3>Value</h3>

<p>Named list of formulas
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fully conditionally specified main effects model
form1 &lt;- list(
  bmi ~ age + chl + hyp,
  hyp ~ age + bmi + chl,
  chl ~ age + bmi + hyp
)
form1 &lt;- name.formulas(form1)
imp1 &lt;- mice(nhanes, formulas = form1, print = FALSE, m = 1, seed = 12199)

# same model using dot notation
form2 &lt;- list(bmi ~ ., hyp ~ ., chl ~ .)
form2 &lt;- name.formulas(form2)
imp2 &lt;- mice(nhanes, formulas = form2, print = FALSE, m = 1, seed = 12199)
identical(complete(imp1), complete(imp2))

# same model using repeated multivariate imputation
form3 &lt;- name.blocks(list(all = bmi + hyp + chl ~ .))
imp3 &lt;- mice(nhanes, formulas = form3, print = FALSE, m = 1, seed = 12199)
cmp3 &lt;- complete(imp3)
identical(complete(imp1), complete(imp3))

# same model using predictorMatrix
imp4 &lt;- mice(nhanes, print = FALSE, m = 1, seed = 12199, auxiliary = TRUE)
identical(complete(imp1), complete(imp4))

# different model: multivariate imputation for chl and bmi
form5 &lt;- list(chl + bmi ~ ., hyp ~ bmi + age)
form5 &lt;- name.formulas(form5)
imp5 &lt;- mice(nhanes, formulas = form5, print = FALSE, m = 1, seed = 71712)
</code></pre>

<hr>
<h2 id='ncc'>Number of complete cases</h2><span id='topic+ncc'></span>

<h3>Description</h3>

<p>Calculates the number of complete cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncc_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object. Currently supported are methods for the
following classes: <code>mids</code>, <code>data.frame</code> and <code>matrix</code>. Also,
<code>x</code> can be a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of elements in <code>x</code> with complete data.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2017
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nic">nic</a></code>, <code><a href="#topic+cci">cci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ncc(nhanes) # 13 complete cases
</code></pre>

<hr>
<h2 id='nelsonaalen'>Cumulative hazard rate or Nelson-Aalen estimator</h2><span id='topic+nelsonaalen'></span><span id='topic+hazard'></span>

<h3>Description</h3>

<p>Calculates the cumulative hazard rate (Nelson-Aalen estimator)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nelsonaalen(data, timevar, statusvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nelsonaalen_+3A_data">data</code></td>
<td>
<p>A data frame containing the data.</p>
</td></tr>
<tr><td><code id="nelsonaalen_+3A_timevar">timevar</code></td>
<td>
<p>The name of the time variable in <code>data</code>.</p>
</td></tr>
<tr><td><code id="nelsonaalen_+3A_statusvar">statusvar</code></td>
<td>
<p>The name of the event variable, e.g. death in <code>data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for imputing variables that depend on survival time.
White and Royston (2009) suggested using the cumulative hazard to the
survival time H0(T) rather than T or log(T) as a predictor in imputation
models.  See section 7.1 of Van Buuren (2012) for an example.
</p>


<h3>Value</h3>

<p>A vector with <code>nrow(data)</code> elements containing the Nelson-Aalen
estimates of the cumulative hazard function.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2012
</p>


<h3>References</h3>

<p>White, I. R., Royston, P. (2009). Imputing missing covariate
values for the Cox model.  <em>Statistics in Medicine</em>, <em>28</em>(15),
1982-1998.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-toomany.html#a-further-improvement-survival-as-predictor-variable"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)

leuk$status &lt;- 1 ## no censoring occurs in leuk data (MASS)
ch &lt;- nelsonaalen(leuk, time, status)
plot(x = leuk$time, y = ch, ylab = "Cumulative hazard", xlab = "Time")

### See example on http://www.engineeredsoftware.com/lmar/pe_cum_hazard_function.htm
time &lt;- c(43, 67, 92, 94, 149, rep(149, 7))
status &lt;- c(rep(1, 5), rep(0, 7))
eng &lt;- data.frame(time, status)
ch &lt;- nelsonaalen(eng, time, status)
plot(x = time, y = ch, ylab = "Cumulative hazard", xlab = "Time")
</code></pre>

<hr>
<h2 id='nhanes'>NHANES example - all variables numerical</h2><span id='topic+nhanes'></span>

<h3>Description</h3>

<p>A small data set with non-monotone missing values.
</p>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 4 variables.
</p>

<dl>
<dt>age</dt><dd><p>Age group (1=20-39, 2=40-59, 3=60+)</p>
</dd>
<dt>bmi</dt><dd><p>Body mass index (kg/m**2)</p>
</dd>
<dt>hyp</dt><dd><p>Hypertensive (1=no,2=yes)</p>
</dd>
<dt>chl</dt><dd><p>Total serum cholesterol (mg/dL)</p>
</dd> </dl>



<h3>Details</h3>

<p>A small data set with all numerical variables. The data set <code>nhanes2</code> is
the same data set, but with <code>age</code> and <code>hyp</code> treated as factors.
</p>


<h3>Source</h3>

<p>Schafer, J.L. (1997).  <em>Analysis of Incomplete Multivariate
Data.</em> London: Chapman &amp; Hall. Table 6.14.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nhanes2">nhanes2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create 5 imputed data sets
imp &lt;- mice(nhanes)

# print the first imputed data set
complete(imp)
</code></pre>

<hr>
<h2 id='nhanes2'>NHANES example - mixed numerical and discrete variables</h2><span id='topic+nhanes2'></span>

<h3>Description</h3>

<p>A small data set with non-monotone missing values.
</p>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 4 variables.
</p>

<dl>
<dt>age</dt><dd><p>Age group (1=20-39, 2=40-59, 3=60+)</p>
</dd>
<dt>bmi</dt><dd><p>Body mass index (kg/m**2)</p>
</dd>
<dt>hyp</dt><dd><p>Hypertensive (1=no,2=yes)</p>
</dd>
<dt>chl</dt><dd><p>Total serum cholesterol (mg/dL)</p>
</dd> </dl>



<h3>Details</h3>

<p>A small data set with missing data and mixed numerical and discrete
variables. The data set <code>nhanes</code> is the same data set, but with all data
treated as numerical.
</p>


<h3>Source</h3>

<p>Schafer, J.L. (1997).  <em>Analysis of Incomplete Multivariate
Data.</em> London: Chapman &amp; Hall. Table 6.14.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nhanes">nhanes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create 5 imputed data sets
imp &lt;- mice(nhanes2)

# print the first imputed data set
complete(imp)
</code></pre>

<hr>
<h2 id='nic'>Number of incomplete cases</h2><span id='topic+nic'></span>

<h3>Description</h3>

<p>Calculates the number of incomplete cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nic_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object. Currently supported are methods for the
following classes: <code>mids</code>, <code>data.frame</code> and <code>matrix</code>. Also,
<code>x</code> can be a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of elements in <code>x</code> with incomplete data.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2017
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ncc">ncc</a></code>, <code><a href="#topic+cci">cci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nic(nhanes) # the remaining 12 rows
nic(nhanes[, c("bmi", "hyp")]) # number of cases with incomplete bmi and hyp
</code></pre>

<hr>
<h2 id='nimp'>Number of imputations per block</h2><span id='topic+nimp'></span>

<h3>Description</h3>

<p>Calculates the number of cells within a block for which imputation
is requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimp(where, blocks = make.blocks(where))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nimp_+3A_where">where</code></td>
<td>
<p>A data frame or matrix with logicals of the same dimensions
as <code>data</code> indicating where in the data the imputations should be
created. The default, <code>where = is.na(data)</code>, specifies that the
missing data should be imputed. The <code>where</code> argument may be used to
overimpute observed data, or to skip imputations for selected missing values.
Note: Imputation methods that generate imptutations outside of
<code>mice</code>, like <code>mice.impute.panImpute()</code> may depend on a complete
predictor space. In that case, a custom <code>where</code> matrix can not be
specified.</p>
</td></tr>
<tr><td><code id="nimp_+3A_blocks">blocks</code></td>
<td>
<p>List of vectors with variable names per block. List elements
may be named to identify blocks. Variables within a block are
imputed by a multivariate imputation method
(see <code>method</code> argument). By default each variable is placed
into its own block, which is effectively
fully conditional specification (FCS) by univariate models
(variable-by-variable imputation). Only variables whose names appear in
<code>blocks</code> are imputed. The relevant columns in the <code>where</code>
matrix are set to <code>FALSE</code> of variables that are not block members.
A variable may appear in multiple blocks. In that case, it is
effectively re-imputed each time that it is visited.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>length(blocks)</code> containing
the number of cells that need to be imputed within a block.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>where &lt;- is.na(nhanes)

# standard FCS
nimp(where)

# user-defined blocks
nimp(where, blocks = name.blocks(list(c("bmi", "hyp"), "age", "chl")))
</code></pre>

<hr>
<h2 id='norm.draw'>Draws values of beta and sigma by Bayesian linear regression</h2><span id='topic+norm.draw'></span><span id='topic+.norm.draw'></span>

<h3>Description</h3>

<p>This function draws random values of beta and sigma under the Bayesian
linear regression model as described in Rubin (1987, p. 167). This function
can be called by user-specified imputation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.draw(y, ry, x, rank.adjust = TRUE, ...)

.norm.draw(y, ry, x, rank.adjust = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm.draw_+3A_y">y</code></td>
<td>
<p>Incomplete data vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="norm.draw_+3A_ry">ry</code></td>
<td>
<p>Vector of missing data pattern (<code>FALSE</code>=missing,
<code>TRUE</code>=observed)</p>
</td></tr>
<tr><td><code id="norm.draw_+3A_x">x</code></td>
<td>
<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.</p>
</td></tr>
<tr><td><code id="norm.draw_+3A_rank.adjust">rank.adjust</code></td>
<td>
<p>Argument that specifies whether <code>NA</code>'s in the
coefficients need to be set to zero. Only relevant when <code>ls.meth = "qr"</code>
AND the predictor matrix is rank-deficient.</p>
</td></tr>
<tr><td><code id="norm.draw_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing components <code>coef</code> (least squares estimate),
<code>beta</code> (drawn regression weights) and <code>sigma</code> (drawn value of the
residual standard deviation).
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, 2018, for this version, based on earlier versions written
by Stef van Buuren, Karin Groothuis-Oudshoorn, 2017
</p>


<h3>References</h3>

<p>Rubin, D.B. (1987). <em>Multiple imputation for nonresponse in surveys</em>. New York: Wiley.
</p>

<hr>
<h2 id='parlmice'>Wrapper function that runs MICE in parallel</h2><span id='topic+parlmice'></span>

<h3>Description</h3>

<p>This function is included for backward compatibility. The function
is superseded by <code><a href="#topic+futuremice">futuremice</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parlmice(
  data,
  m = 5,
  seed = NA,
  cluster.seed = NA,
  n.core = NULL,
  n.imp.core = NULL,
  cl.type = "PSOCK",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parlmice_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the incomplete data. Similar to
the first argument of <code><a href="#topic+mice">mice</a></code>.</p>
</td></tr>
<tr><td><code id="parlmice_+3A_m">m</code></td>
<td>
<p>The number of desired imputated datasets. By default $m=5$ as with <code>mice</code></p>
</td></tr>
<tr><td><code id="parlmice_+3A_seed">seed</code></td>
<td>
<p>A scalar to be used as the seed value for the mice algorithm within
each parallel stream. Please note that the imputations will be the same for all
streams and, hence, this should be used if and only if <code>n.core = 1</code> and
if it is desired to obtain the same output as under <code>mice</code>.</p>
</td></tr>
<tr><td><code id="parlmice_+3A_cluster.seed">cluster.seed</code></td>
<td>
<p>A scalar to be used as the seed value. It is recommended to put the
seed value here and not outside this function, as otherwise the parallel processes
will be performed with separate, random seeds.</p>
</td></tr>
<tr><td><code id="parlmice_+3A_n.core">n.core</code></td>
<td>
<p>A scalar indicating the number of cores that should be used.</p>
</td></tr>
<tr><td><code id="parlmice_+3A_n.imp.core">n.imp.core</code></td>
<td>
<p>A scalar indicating the number of imputations per core.</p>
</td></tr>
<tr><td><code id="parlmice_+3A_cl.type">cl.type</code></td>
<td>
<p>The cluster type. Default value is <code>"PSOCK"</code>. Posix machines (linux, Mac)
generally benefit from much faster cluster computation if <code>type</code> is set to <code>type = "FORK"</code>.</p>
</td></tr>
<tr><td><code id="parlmice_+3A_...">...</code></td>
<td>
<p>Named arguments that are passed down to function <code><a href="#topic+mice">mice</a></code> or
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies on package <code><a href="lattice.html#topic+parallel">parallel</a></code>, which is a base
package for R versions 2.14.0 and later. We have chosen to use parallel function
<code>parLapply</code> to allow the use of <code>parlmice</code> on Mac, Linux and Windows
systems. For the same reason, we use the Parallel Socket Cluster (PSOCK) type by default.
</p>
<p>On systems other than Windows, it can be hugely beneficial to change the cluster type to
<code>FORK</code>, as it generally results in improved memory handling. When memory issues
arise on a Windows system, we advise to store the multiply imputed datasets,
clean the memory by using <code><a href="base.html#topic+rm">rm</a></code> and <code><a href="base.html#topic+gc">gc</a></code> and make another
run using the same settings.
</p>
<p>This wrapper function combines the output of <code><a href="parallel.html#topic+parLapply">parLapply</a></code> with
function <code><a href="#topic+ibind">ibind</a></code> in <code><a href="#topic+mice">mice</a></code>. A <code>mids</code> object is returned
and can be used for further analyses.
</p>
<p>Note that if a seed value is desired, the seed should be entered to this function
with argument <code>seed</code>. Seed values outside the wrapper function (in an
R-script or passed to <code><a href="#topic+mice">mice</a></code>) will not result to reproducible results.
We refer to the manual of <code><a href="lattice.html#topic+parallel">parallel</a></code> for an explanation on this matter.
</p>


<h3>Value</h3>

<p>A mids object as defined by <code><a href="#topic+mids-class">mids-class</a></code>
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, Rianne Schouten
</p>


<h3>References</h3>

<p>Schouten, R. and Vink, G. (2017). parlmice: faster, paraleller, micer.
<a href="https://www.gerkovink.com/parlMICE/Vignette_parlMICE.html">https://www.gerkovink.com/parlMICE/Vignette_parlMICE.html</a>
</p>
<p>#'Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/parallel-computation.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+parallel">parallel</a></code>, <code><a href="parallel.html#topic+parLapply">parLapply</a></code>, <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
<code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mids-class">mids-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 150 imputations in dataset nhanes, performed by 3 cores
## Not run: 
imp1 &lt;- parlmice(data = nhanes, n.core = 3, n.imp.core = 50)
# Making use of arguments in mice.
imp2 &lt;- parlmice(data = nhanes, method = "norm.nob", m = 100)
imp2$method
fit &lt;- with(imp2, lm(bmi ~ hyp))
pool(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='pattern'>Datasets with various missing data patterns</h2><span id='topic+pattern'></span><span id='topic+pattern1'></span><span id='topic+pattern2'></span><span id='topic+pattern3'></span><span id='topic+pattern4'></span>

<h3>Description</h3>

<p>Four simple datasets with various missing data patterns
</p>


<h3>Format</h3>

 <dl>
<dt>list(&quot;pattern1&quot;)</dt><dd><p>Data with a univariate missing
data pattern</p>
</dd> <dt>list(&quot;pattern2&quot;)</dt><dd><p>Data with a monotone missing data
pattern</p>
</dd> <dt>list(&quot;pattern3&quot;)</dt><dd><p>Data with a file matching missing data
pattern</p>
</dd> <dt>list(&quot;pattern4&quot;)</dt><dd><p>Data with a general missing data pattern</p>
</dd> </dl>

<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/missing-data-pattern.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>Details</h3>

<p>Van Buuren (2012) uses these four artificial datasets to illustrate various
missing data patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pattern4

data &lt;- rbind(pattern1, pattern2, pattern3, pattern4)
mdpat &lt;- cbind(expand.grid(rec = 8:1, pat = 1:4, var = 1:3), r = as.numeric(as.vector(is.na(data))))

types &lt;- c("Univariate", "Monotone", "File matching", "General")
tp41 &lt;- lattice::levelplot(r ~ var + rec | as.factor(pat),
  data = mdpat,
  as.table = TRUE, aspect = "iso",
  shrink = c(0.9),
  col.regions = mdc(1:2),
  colorkey = FALSE,
  scales = list(draw = FALSE),
  xlab = "", ylab = "",
  between = list(x = 1, y = 0),
  strip = lattice::strip.custom(
    bg = "grey95", style = 1,
    factor.levels = types
  )
)
print(tp41)

md.pattern(pattern4)
p &lt;- md.pairs(pattern4)
p

### proportion of usable cases
p$mr / (p$mr + p$mm)

### outbound statistics
p$rm / (p$rm + p$rr)


fluxplot(pattern2)
</code></pre>

<hr>
<h2 id='plot.mids'>Plot the trace lines of the MICE algorithm</h2><span id='topic+plot.mids'></span>

<h3>Description</h3>

<p>Trace line plots portray the value of an estimate
against the iteration number. The estimate can be anything that you can calculate, but
typically are chosen as parameter of scientific interest. The <code>plot</code> method for
a <code>mids</code> object plots the mean and standard deviation of the imputed (not observed)
values against the iteration number for each of the $m$ replications. By default,
the function plot the development of the mean and standard deviation for each incomplete
variable. On convergence, the streams should intermingle and be free of any trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids'
plot(
  x,
  y = NULL,
  theme = mice.theme(),
  layout = c(2, 3),
  type = "l",
  col = 1:10,
  lty = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mids_+3A_x">x</code></td>
<td>
<p>An object of class <code>mids</code></p>
</td></tr>
<tr><td><code id="plot.mids_+3A_y">y</code></td>
<td>
<p>A formula that specifies which variables, stream and iterations are plotted.
If omitted, all streams, variables and iterations are plotted.</p>
</td></tr>
<tr><td><code id="plot.mids_+3A_theme">theme</code></td>
<td>
<p>The trellis theme to applied to the graphs. The default is <code>mice.theme()</code>.</p>
</td></tr>
<tr><td><code id="plot.mids_+3A_layout">layout</code></td>
<td>
<p>A vector of length 2 given the number of columns and rows in the plot.
The default is <code>c(2, 3)</code>.</p>
</td></tr>
<tr><td><code id="plot.mids_+3A_type">type</code></td>
<td>
<p>Parameter <code>type</code> of <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mids_+3A_col">col</code></td>
<td>
<p>Parameter <code>col</code> of <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mids_+3A_lty">lty</code></td>
<td>
<p>Parameter <code>lty</code> of <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mids_+3A_...">...</code></td>
<td>
<p>Extra arguments for <code><a href="#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren 2011
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mids-class">mids</a></code>,
<code><a href="#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(nhanes, print = FALSE)
plot(imp, bmi + chl ~ .it | .ms, layout = c(2, 1))
</code></pre>

<hr>
<h2 id='pool'>Combine estimates by pooling rules</h2><span id='topic+pool'></span><span id='topic+pool.syn'></span>

<h3>Description</h3>

<p>The <code>pool()</code> function combines the estimates from <code>m</code>
repeated complete data analyses. The typical sequence of steps to
perform a multiple imputation analysis is:
</p>

<ol>
<li><p> Impute the missing data by the <code>mice()</code> function, resulting in
a multiple imputed data set (class <code>mids</code>);
</p>
</li>
<li><p> Fit the model of interest (scientific model) on each imputed data set
by the <code>with()</code> function, resulting an object of class <code>mira</code>;
</p>
</li>
<li><p> Pool the estimates from each model into a single set of estimates
and standard errors, resulting in an object of class <code>mipo</code>;
</p>
</li>
<li><p> Optionally, compare pooled estimates from different scientific models
by the <code>D1()</code> or <code>D3()</code> functions.
</p>
</li></ol>

<p>A common error is to reverse steps 2 and 3, i.e., to pool the
multiply-imputed data instead of the estimates. Doing so may severely bias
the estimates of scientific interest and yield incorrect statistical
intervals and p-values. The <code>pool()</code> function will detect
this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool(object, dfcom = NULL, rule = NULL, custom.t = NULL)

pool.syn(object, dfcom = NULL, rule = "reiter2003")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_+3A_object">object</code></td>
<td>
<p>An object of class <code>mira</code> (produced by <code>with.mids()</code>
or <code>as.mira()</code>), or a <code>list</code> with model fits.</p>
</td></tr>
<tr><td><code id="pool_+3A_dfcom">dfcom</code></td>
<td>
<p>A positive number representing the degrees of freedom in the
complete-data analysis. Normally, this would be the number of independent
observation minus the number of fitted parameters. The default
(<code>dfcom = NULL</code>) extract this information in the following
order: 1) the component
<code>residual.df</code> returned by <code>glance()</code> if a <code>glance()</code>
function is found, 2) the result of <code>df.residual(</code> applied to
the first fitted model, and 3) as <code>999999</code>.
In the last case, the warning <code>"Large sample assumed"</code> is printed.
If the degrees of freedom is incorrect, specify the appropriate value
manually.</p>
</td></tr>
<tr><td><code id="pool_+3A_rule">rule</code></td>
<td>
<p>A string indicating the pooling rule. Currently supported are
<code>"rubin1987"</code> (default, for missing data) and <code>"reiter2003"</code>
(for synthetic data created from a complete data set).</p>
</td></tr>
<tr><td><code id="pool_+3A_custom.t">custom.t</code></td>
<td>
<p>A custom character string to be parsed as a calculation rule
for the total variance <code>t</code>. The custom rule  can use the other calculated
pooling statistics where the dimensions must come from <code>.data$</code>. The
default <code>t</code> calculation would have the form
<code>".data$ubar + (1 + 1 / .data$m) * .data$b"</code>.
See examples for an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pool()</code> function averages the estimates of the complete
data model, computes the total variance over the repeated analyses
by Rubin's rules (Rubin, 1987, p. 76), and computes the following
diagnostic statistics per estimate:
</p>

<ol>
<li><p> Relative increase in variance due to nonresponse <code>r</code>;
</p>
</li>
<li><p> Residual degrees of freedom for hypothesis testing <code>df</code>;
</p>
</li>
<li><p> Proportion of total variance due to missingness <code>lambda</code>;
</p>
</li>
<li><p> Fraction of missing information <code>fmi</code>.
</p>
</li></ol>

<p>The degrees of freedom calculation for the pooled estimates uses the
Barnard-Rubin adjustment for small samples (Barnard and Rubin, 1999).
</p>
<p>The <code>pool.syn()</code> function combines estimates by Reiter's partially
synthetic data pooling rules (Reiter, 2003). This combination rule
assumes that the data that is synthesised is completely observed.
Pooling differs from Rubin's method in the calculation of the total
variance and the degrees of freedom.
</p>
<p>Pooling requires the following input from each fitted model:
</p>

<ol>
<li><p> the estimates of the model;
</p>
</li>
<li><p> the standard error of each estimate;
</p>
</li>
<li><p> the residual degrees of freedom of the model.
</p>
</li></ol>

<p>The <code>pool()</code> and <code>pool.syn()</code> functions rely on the
<code>broom::tidy</code> and <code>broom::glance</code> for extracting these
parameters.
</p>
<p>Since <code>mice 3.0+</code>, the <code>broom</code>
package takes care of filtering out the relevant parts of the
complete-data analysis. It may happen that you'll see the messages
like <code>Error: No tidy method for objects of class ...</code> or
<code>Error: No glance method for objects of class ...</code>. The message
means that your complete-data method used in <code>with(imp, ...)</code> has
no <code>tidy</code> or <code>glance</code> method defined in the <code>broom</code> package.
</p>
<p>The <code>broom.mixed</code> package contains <code>tidy</code> and <code>glance</code> methods
for mixed models. If you are using a mixed model, first run
<code>library(broom.mixed)</code> before calling <code>pool()</code>.
</p>
<p>If no <code>tidy</code> or <code>glance</code> methods are defined for your analysis
tabulate the <code>m</code> parameter estimates and their variance
estimates (the square of the standard errors) from the <code>m</code> fitted
models stored in <code>fit$analyses</code>. For each parameter, run
<code><a href="#topic+pool.scalar">pool.scalar</a></code> to obtain the pooled parameters estimate, its variance, the
degrees of freedom, the relative increase in variance and the fraction of missing
information.
</p>
<p>An alternative is to write your own <code>glance()</code> and <code>tidy()</code>
methods and add these to <code>broom</code> according to the specifications
given in <a href="https://broom.tidymodels.org">https://broom.tidymodels.org</a>.
In versions prior to <code>mice 3.0</code> pooling required that
<code>coef()</code> and <code>vcov()</code> methods were available for fitted
objects. <em>This feature is no longer supported</em>. The reason is that
<code>vcov()</code> methods are inconsistent across packages, leading to
buggy behaviour of the <code>pool()</code> function.
</p>
<p>Since <code>mice 3.13.2</code> function <code>pool()</code> uses the robust
the standard error estimate for pooling when it can extract
<code>robust.se</code> from the <code>tidy()</code> object.
</p>


<h3>Value</h3>

<p>An object of class <code>mipo</code>, which stands for 'multiple imputation
pooled outcome'.
For rule <code>"reiter2003"</code> values for <code>lambda</code> and <code>fmi</code> are
set to 'NA', as these statistics do not apply for data synthesised from
fully observed data.
</p>


<h3>References</h3>

<p>Barnard, J. and Rubin, D.B. (1999). Small sample degrees of
freedom with multiple imputation. <em>Biometrika</em>, 86, 948-955.
</p>
<p>Rubin, D.B. (1987). <em>Multiple Imputation for Nonresponse in Surveys</em>.
New York: John Wiley and Sons.
</p>
<p>Reiter, J.P. (2003). Inference for Partially Synthetic,
Public Use Microdata Sets. <em>Survey Methodology</em>, <b>29</b>, 181-189.
</p>
<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with.mids">with.mids</a></code>, <code><a href="#topic+as.mira">as.mira</a></code>, <code><a href="#topic+pool.scalar">pool.scalar</a></code>,
<code><a href="broom.html#topic+reexports">glance</a></code>, <code><a href="broom.html#topic+reexports">tidy</a></code>
<a href="https://github.com/amices/mice/issues/142">https://github.com/amices/mice/issues/142</a>,
<a href="https://github.com/amices/mice/issues/274">https://github.com/amices/mice/issues/274</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># impute missing data, analyse and pool using the classic MICE workflow
imp &lt;- mice(nhanes, maxit = 2, m = 2)
fit &lt;- with(data = imp, exp = lm(bmi ~ hyp + chl))
summary(pool(fit))

# generate fully synthetic data, analyse and pool
imp &lt;- mice(cars,
  maxit = 2, m = 2,
  where = matrix(TRUE, nrow(cars), ncol(cars))
)
fit &lt;- with(data = imp, exp = lm(speed ~ dist))
summary(pool.syn(fit))

# use a custom pooling rule for the total variance about the estimate
# e.g. use t = b + b/m instead of t = ubar + b + b/m
imp &lt;- mice(nhanes, maxit = 2, m = 2)
fit &lt;- with(data = imp, exp = lm(bmi ~ hyp + chl))
pool(fit, custom.t = ".data$b + .data$b / .data$m")

</code></pre>

<hr>
<h2 id='pool.compare'>Compare two nested models fitted to imputed data</h2><span id='topic+pool.compare'></span>

<h3>Description</h3>

<p>This function is deprecated in V3. Use <code><a href="#topic+D1">D1</a></code> or
<code><a href="#topic+D3">D3</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool.compare(fit1, fit0, method = c("wald", "likelihood"), data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.compare_+3A_fit1">fit1</code></td>
<td>
<p>An object of class 'mira', produced by <code>with.mids()</code>.</p>
</td></tr>
<tr><td><code id="pool.compare_+3A_fit0">fit0</code></td>
<td>
<p>An object of class 'mira', produced by <code>with.mids()</code>. The
model in <code>fit0</code> is a nested fit0 of <code>fit1</code>.</p>
</td></tr>
<tr><td><code id="pool.compare_+3A_method">method</code></td>
<td>
<p>Either <code>"wald"</code> or <code>"likelihood"</code> specifying
the type of comparison. The default is <code>"wald"</code>.</p>
</td></tr>
<tr><td><code id="pool.compare_+3A_data">data</code></td>
<td>
<p>No longer used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compares two nested models after m repeated complete data analysis
</p>
<p>The function is based on the article of Meng and Rubin (1992). The
Wald-method can be found in paragraph 2.2 and the likelihood method can be
found in paragraph 3.  One could use the Wald method for comparison of linear
models obtained with e.g. <code>lm</code> (in <code>with.mids()</code>).  The likelihood
method should be used in case of logistic regression models obtained with
<code>glm()</code> in <code>with.mids()</code>.
</p>
<p>The function assumes that <code>fit1</code> is the
larger model, and that model <code>fit0</code> is fully contained in <code>fit1</code>.
In case of <code>method='wald'</code>, the null hypothesis is tested that the extra
parameters are all zero.
</p>


<h3>Value</h3>

<p>A list containing several components. Component <code>call</code> is
the call to the <code>pool.compare</code> function. Component <code>call11</code> is
the call that created <code>fit1</code>. Component <code>call12</code> is the
call that created the imputations. Component <code>call01</code> is the
call that created <code>fit0</code>. Component <code>call02</code> is the
call that created the imputations. Components <code>method</code> is the
method used to compare two models: 'Wald' or 'likelihood'. Component
<code>nmis</code> is the number of missing entries for each variable.
Component <code>m</code> is the number of imputations.
Component <code>qhat1</code> is a matrix, containing the estimated coefficients of the
<em>m</em> repeated complete data analyses from <code>fit1</code>.
Component <code>qhat0</code> is a matrix, containing the estimated coefficients of the
<em>m</em> repeated complete data analyses from <code>fit0</code>.
Component <code>ubar1</code> is the mean of the variances of <code>fit1</code>,
formula (3.1.3), Rubin (1987).
Component <code>ubar0</code> is the mean of the variances of <code>fit0</code>,
formula (3.1.3), Rubin (1987).
Component <code>qbar1</code> is the pooled estimate of <code>fit1</code>, formula (3.1.2) Rubin
(1987).
Component <code>qbar0</code> is the pooled estimate of <code>fit0</code>, formula (3.1.2) Rubin
(1987).
Component <code>Dm</code> is the test statistic.
Component <code>rm</code> is the relative increase in variance due to nonresponse, formula
(3.1.7), Rubin (1987).
Component <code>df1</code>: df1 = under the null hypothesis it is assumed that <code>Dm</code> has an F
distribution with (df1,df2) degrees of freedom.
Component <code>df2</code>: df2.
Component <code>pvalue</code> is the P-value of testing whether the model <code>fit1</code> is
statistically different from the smaller <code>fit0</code>.
</p>


<h3>Author(s)</h3>

<p>Karin Groothuis-Oudshoorn and Stef van Buuren, 2009
</p>


<h3>References</h3>

<p>Li, K.H., Meng, X.L., Raghunathan, T.E. and Rubin, D. B. (1991).
Significance levels from repeated p-values with multiply-imputed data.
Statistica Sinica, 1, 65-92.
</p>
<p>Meng, X.L. and Rubin, D.B. (1992). Performing likelihood ratio tests with
multiple-imputed data sets.  Biometrika, 79, 103-111.
</p>
<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm.mids">lm.mids</a></code>, <code><a href="#topic+glm.mids">glm.mids</a></code>
</p>

<hr>
<h2 id='pool.r.squared'>Pools R^2 of m models fitted to multiply-imputed data</h2><span id='topic+pool.r.squared'></span>

<h3>Description</h3>

<p>The function pools the coefficients of determination R^2 or the adjusted
coefficients of determination (R^2_a) obtained with the <code>lm</code> modeling
function. For pooling it uses the Fisher <em>z</em>-transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool.r.squared(object, adjusted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.r.squared_+3A_object">object</code></td>
<td>
<p>An object of class 'mira' or 'mipo', produced by <code>lm.mids</code>,
<code>with.mids</code>, or <code>pool</code> with <code>lm</code> as modeling function.</p>
</td></tr>
<tr><td><code id="pool.r.squared_+3A_adjusted">adjusted</code></td>
<td>
<p>A logical value. If adjusted=TRUE then the adjusted R^2 is
calculated.  The default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 1x4 table with components. Component <code>est</code> is the
pooled R^2 estimate. Component <code>lo95</code> is the 95 % lower bound of the pooled R^2.
Component <code>hi95</code> is the 95 % upper bound of the pooled R^2.
Component <code>fmi</code> is the fraction of missing information due to nonresponse.
</p>


<h3>Author(s)</h3>

<p>Karin Groothuis-Oudshoorn and Stef van Buuren, 2009
</p>


<h3>References</h3>

<p>Harel, O (2009). The estimation of R^2 and adjusted R^2 in
incomplete data sets using multiple imputation, Journal of Applied Statistics,
36:1109-1118.
</p>
<p>Rubin, D.B. (1987). Multiple Imputation for Nonresponse in Surveys.  New
York: John Wiley and Sons.
</p>
<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool">pool</a></code>,<code><a href="#topic+pool.scalar">pool.scalar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(nhanes, print = FALSE, seed = 16117)
fit &lt;- with(imp, lm(chl ~ age + hyp + bmi))

# input: mira object
pool.r.squared(fit)
pool.r.squared(fit, adjusted = TRUE)

# input: mipo object
est &lt;- pool(fit)
pool.r.squared(est)
pool.r.squared(est, adjusted = TRUE)
</code></pre>

<hr>
<h2 id='pool.scalar'>Multiple imputation pooling: univariate version</h2><span id='topic+pool.scalar'></span><span id='topic+pool.scalar.syn'></span>

<h3>Description</h3>

<p>Pools univariate estimates of m repeated complete data analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool.scalar(Q, U, n = Inf, k = 1, rule = c("rubin1987", "reiter2003"))

pool.scalar.syn(Q, U, n = Inf, k = 1, rule = "reiter2003")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.scalar_+3A_q">Q</code></td>
<td>
<p>A vector of univariate estimates of <code>m</code> repeated complete data
analyses.</p>
</td></tr>
<tr><td><code id="pool.scalar_+3A_u">U</code></td>
<td>
<p>A vector containing the corresponding <code>m</code> variances of the univariate
estimates.</p>
</td></tr>
<tr><td><code id="pool.scalar_+3A_n">n</code></td>
<td>
<p>A number providing the sample size. If nothing is specified,
an infinite sample <code>n = Inf</code> is assumed.</p>
</td></tr>
<tr><td><code id="pool.scalar_+3A_k">k</code></td>
<td>
<p>A number indicating the number of parameters to be estimated.
By default, <code>k = 1</code> is assumed.</p>
</td></tr>
<tr><td><code id="pool.scalar_+3A_rule">rule</code></td>
<td>
<p>A string indicating the pooling rule. Currently supported are
<code>"rubin1987"</code> (default, for missing data) and <code>"reiter2003"</code>
(for synthetic data created from a complete data set).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function averages the univariate estimates of the complete data model,
computes the total variance over the repeated analyses, and computes the
relative increase in variance due to missing data or data synthesisation
and the fraction of missing information.
</p>


<h3>Value</h3>

<p>Returns a list with components.
</p>

<dl>
<dt><code>m</code>:</dt><dd><p>Number of imputations.</p>
</dd>
<dt><code>qhat</code>:</dt><dd><p>The <code>m</code> univariate estimates of repeated complete-data analyses.</p>
</dd>
<dt><code>u</code>:</dt><dd><p>The corresponding <code>m</code> variances of the univariate estimates.</p>
</dd>
<dt><code>qbar</code>:</dt><dd><p>The pooled univariate estimate, formula (3.1.2) Rubin (1987).</p>
</dd>
<dt><code>ubar</code>:</dt><dd><p>The mean of the variances (i.e. the pooled within-imputation variance),
formula (3.1.3) Rubin (1987).</p>
</dd>
<dt><code>b</code>:</dt><dd><p>The between-imputation variance, formula (3.1.4) Rubin (1987).</p>
</dd>
<dt><code>t</code>:</dt><dd><p>The total variance of the pooled estimated, formula (3.1.5)
Rubin (1987).</p>
</dd>
<dt><code>r</code>:</dt><dd><p>The relative increase in variance due to nonresponse, formula
(3.1.7) Rubin (1987).</p>
</dd>
<dt><code>df</code>:</dt><dd><p>The degrees of freedom for t reference distribution by the
method of Barnard-Rubin (1999).</p>
</dd>
<dt><code>fmi</code>:</dt><dd><p>The fraction missing information due to nonresponse,
formula (3.1.10) Rubin (1987). (Not defined for synthetic data.)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Karin Groothuis-Oudshoorn and Stef van Buuren, 2009; Thom Volker, 2021
</p>


<h3>References</h3>

<p>Rubin, D.B. (1987). Multiple Imputation for Nonresponse in
Surveys.  New York: John Wiley and Sons.
</p>
<p>Reiter, J.P. (2003). Inference for Partially Synthetic,
Public Use Microdata Sets. <em>Survey Methodology</em>, <b>29</b>, 181-189.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool">pool</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># missing data imputation with with manual pooling
imp &lt;- mice(nhanes, maxit = 2, m = 2, print = FALSE, seed = 18210)
fit &lt;- with(data = imp, lm(bmi ~ age))

# manual pooling
summary(fit$analyses[[1]])
summary(fit$analyses[[2]])
pool.scalar(Q = c(-1.5457, -1.428), U = c(0.9723^2, 1.041^2), n = 25, k = 2)

# check: automatic pooling using broom
pool(fit)

# manual pooling for synthetic data created from complete data
imp &lt;- mice(cars,
  maxit = 2, m = 2, print = FALSE, seed = 18210,
  where = matrix(TRUE, nrow(cars), ncol(cars))
)
fit &lt;- with(data = imp, lm(speed ~ dist))

# manual pooling: extract Q and U
summary(fit$analyses[[1]])
summary(fit$analyses[[2]])
pool.scalar.syn(Q = c(0.12182, 0.13209), U = c(0.02121^2, 0.02516^2), n = 50, k = 2)

# check: automatic pooling using broom
pool.syn(fit)
</code></pre>

<hr>
<h2 id='popmis'>Hox pupil popularity data with missing popularity scores</h2><span id='topic+popmis'></span>

<h3>Description</h3>

<p>Hox pupil popularity data with some missing popularity scores
</p>


<h3>Format</h3>

<p>A data frame with 2000 rows and 7 columns:
</p>

<dl>
<dt>pupil</dt><dd><p>Pupil number within school</p>
</dd>
<dt>school</dt><dd><p>School number</p>
</dd>
<dt>popular</dt><dd><p>Pupil popularity with 848 missing entries</p>
</dd>
<dt>sex</dt><dd><p>Pupil gender</p>
</dd>
<dt>texp</dt><dd><p>Teacher experience (years)</p>
</dd>
<dt>const</dt><dd><p>Constant intercept term</p>
</dd>
<dt>teachpop</dt><dd><p>Teacher popularity</p>
</dd> </dl>



<h3>Details</h3>

<p>The original, complete dataset was generated by Joop Hox as an example of
well-behaved multilevel data set. The distributed data contains missing data
in pupil popularity.
</p>


<h3>Source</h3>

<p>Hox, J. J. (2002) <em>Multilevel analysis. Techniques and
applications.</em> Mahwah, NJ: Lawrence Erlbaum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
popmis[1:3, ]
</code></pre>

<hr>
<h2 id='pops'>Project on preterm and small for gestational age infants (POPS)</h2><span id='topic+pops'></span><span id='topic+pops.pred'></span>

<h3>Description</h3>

<p>Subset of data from the POPS study, a national, prospective study on preterm
children, including all liveborn infants &lt;32 weeks gestational age and/or &lt;1500
g from 1983 (n = 1338).
</p>


<h3>Format</h3>

<p><code>pops</code> is a data frame with 959 rows and 86 columns.
<code>pops.pred</code> is the 86 by 86 binary predictor matrix used for specifying
the multiple imputation model.
</p>


<h3>Details</h3>

<p>The data set concerns of subset of 959 children that survived up to the age
of 19 years.
</p>
<p>Hille et al (2005) divided the 959 survivors into three groups: Full
responders (examined at an outpatient clinic and completed the
questionnaires, n = 596), postal responders (only completed the mailed
questionnaires, n = 109), non-responders (did not respond to any of the
mailed requests or telephone calls, or could not be traced, n = 254).
</p>
<p>Compared to the postal and non-responders, the full response group consists
of more girls, contains more Dutch children, has higher educational and
social economic levels and has fewer handicaps. The responders form a highly
selective subgroup in the total cohort.
</p>
<p>Multiple imputation of this data set has been described in Hille et al (2007)
and Van Buuren (2012), chapter 8.
</p>


<h3>Note</h3>

<p>This dataset is not part of <code>mice</code>.
</p>


<h3>Source</h3>

<p>Hille, E. T. M., Elbertse, L., Bennebroek Gravenhorst, J., Brand, R.,
Verloove-Vanhorick, S. P. (2005).  Nonresponse bias in a follow-up study of
19-year-old adolescents born as preterm infants. Pediatrics, 116(5):662666.
</p>
<p>Hille, E. T. M., Weisglas-Kuperus, N., Van Goudoever, J. B., Jacobusse, G.
W., Ens-Dokkum, M. H., De Groot, L., Wit, J. M., Geven, W. B., Kok, J. H., De
Kleine, M. J. K., Kollee, L. A. A., Mulder, A. L. M., Van Straaten, H. L. M.,
De Vries, L. S., Van Weissenbruch, M. M., Verloove-Vanhorick, S. P. (2007).
Functional outcomes and participation in young adulthood for very preterm and
very low birth weight infants: The Dutch project on preterm and small for
gestational age infants at 19 years of age. Pediatrics, 120(3):587595.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-selective.html#pops-study-19-years-follow-up"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pops &lt;- data(pops)
</code></pre>

<hr>
<h2 id='potthoffroy'>Potthoff-Roy data</h2><span id='topic+potthoffroy'></span>

<h3>Description</h3>

<p>Data from Potthoff-Roy (1964) with repeated measures on dental fissures.
</p>


<h3>Format</h3>

<p><code>tbs</code> is a data frame with 27 rows and 6 columns:
</p>

<dl>
<dt>id</dt><dd><p>Person number</p>
</dd>
<dt>sex</dt><dd><p>Sex M/F</p>
</dd>
<dt>d8</dt><dd><p>Distance at age 8 years</p>
</dd>
<dt>d10</dt><dd><p>Distance at age 10 years</p>
</dd>
<dt>d12</dt><dd><p>Distance at age 12 years</p>
</dd>
<dt>d14</dt><dd><p>Distance at age 14 years</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set is the famous Potthoff-Roy data, used to demonstrate MANOVA on
repeated measure data. Potthoff and Roy (1964) published classic data on a
study in 16 boys and 11 girls, who at ages 8, 10, 12, and 14 had the distance
(mm) from the center of the pituitary gland to the pteryomaxillary fissure
measured. Changes in pituitary-pteryomaxillary distances during growth is
important in orthodontic therapy. The goals of the study were to describe the
distance in boys and girls as simple functions of age, and then to compare
the functions for boys and girls. The data have been reanalyzed by many
authors including Jennrich and Schluchter (1986), Little and Rubin (1987),
Pinheiro and Bates (2000), Verbeke and Molenberghs (2000) and Molenberghs and
Kenward (2007). See Chapter 9 of Van Buuren (2012) for a challenging
exercise using these data.
</p>


<h3>Source</h3>

<p>Potthoff, R. F., Roy, S. N. (1964).  A generalized multivariate
analysis of variance model usefully especially for growth curve problems.
<em>Biometrika</em>, <em>51</em>(3), 313-326.
</p>
<p>Little, R. J. A., Rubin, D. B. (1987).  <em>Statistical Analysis with
Missing Data.</em> New York: John Wiley &amp; Sons.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/ex-ch-longitudinal.html"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### create missing values at age 10 as in Little and Rubin (1987)

phr &lt;- potthoffroy
idmis &lt;- c(3, 6, 9, 10, 13, 16, 23, 24, 27)
phr[idmis, 4] &lt;- NA
phr

md.pattern(phr)
</code></pre>

<hr>
<h2 id='print.mads'>Print a <code>mads</code> object</h2><span id='topic+print.mads'></span>

<h3>Description</h3>

<p>Print a <code>mads</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mads'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mads_+3A_x">x</code></td>
<td>
<p>Object of class <code>mads</code></p>
</td></tr>
<tr><td><code id="print.mads_+3A_...">...</code></td>
<td>
<p>Other parameters passed down to <code>print.default()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mads-class">mads</a></code>
</p>

<hr>
<h2 id='print.mids'>Print a <code>mids</code> object</h2><span id='topic+print.mids'></span><span id='topic+print.mira'></span><span id='topic+print.mice.anova'></span><span id='topic+print.mice.anova.summary'></span>

<h3>Description</h3>

<p>Print a <code>mids</code> object
</p>
<p>Print a <code>mira</code> object
</p>
<p>Print a <code>mice.anova</code> object
</p>
<p>Print a <code>summary.mice.anova</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids'
print(x, ...)

## S3 method for class 'mira'
print(x, ...)

## S3 method for class 'mice.anova'
print(x, ...)

## S3 method for class 'mice.anova.summary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mids_+3A_x">x</code></td>
<td>
<p>Object of class <code>mids</code>, <code>mira</code> or <code>mipo</code></p>
</td></tr>
<tr><td><code id="print.mids_+3A_...">...</code></td>
<td>
<p>Other parameters passed down to <code>print.default()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>
<p><code>NULL</code>
</p>
<p><code>NULL</code>
</p>
<p><code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mids-class">mids</a></code>
</p>
<p><code><a href="#topic+mira-class">mira</a></code>
</p>
<p><code><a href="#topic+mipo">mipo</a></code>
</p>
<p><code><a href="#topic+mipo">mipo</a></code>
</p>

<hr>
<h2 id='quickpred'>Quick selection of predictors from the data</h2><span id='topic+quickpred'></span>

<h3>Description</h3>

<p>Selects predictors according to simple statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickpred(
  data,
  mincor = 0.1,
  minpuc = 0,
  include = "",
  exclude = "",
  method = "pearson"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickpred_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with incomplete data.</p>
</td></tr>
<tr><td><code id="quickpred_+3A_mincor">mincor</code></td>
<td>
<p>A scalar, numeric vector (of size <code>ncol(data))</code> or numeric
matrix (square, of size <code>ncol(data)</code> specifying the minimum
threshold(s) against which the absolute correlation in the data is compared.</p>
</td></tr>
<tr><td><code id="quickpred_+3A_minpuc">minpuc</code></td>
<td>
<p>A scalar, vector (of size <code>ncol(data))</code> or matrix (square,
of size <code>ncol(data)</code> specifying the minimum threshold(s) for the
proportion of usable cases.</p>
</td></tr>
<tr><td><code id="quickpred_+3A_include">include</code></td>
<td>
<p>A string or a vector of strings containing one or more
variable names from <code>names(data)</code>. Variables specified are always
included as a predictor.</p>
</td></tr>
<tr><td><code id="quickpred_+3A_exclude">exclude</code></td>
<td>
<p>A string or a vector of strings containing one or more
variable names from <code>names(data)</code>. Variables specified are always
excluded as a predictor.</p>
</td></tr>
<tr><td><code id="quickpred_+3A_method">method</code></td>
<td>
<p>A string specifying the type of correlation. Use
<code>'pearson'</code> (default), <code>'kendall'</code> or <code>'spearman'</code>. Can be
abbreviated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a predictor matrix using the variable selection
procedure described in Van Buuren et al.~(1999, p.~687&ndash;688). The function is
designed to aid in setting up a good imputation model for data with many
variables.
</p>
<p>Basic workings: The procedure calculates for each variable pair (i.e.
target-predictor pair) two correlations using all available cases per pair.
The first correlation uses the values of the target and the predictor
directly. The second correlation uses the (binary) response indicator of the
target and the values of the predictor. If the largest (in absolute value) of
these correlations exceeds <code>mincor</code>, the predictor will be added to the
imputation set.  The default value for <code>mincor</code> is 0.1.
</p>
<p>In addition, the procedure eliminates predictors whose proportion of usable
cases fails to meet the minimum specified by <code>minpuc</code>. The default value
is 0, so predictors are retained even if they have no usable case.
</p>
<p>Finally, the procedure includes any predictors named in the <code>include</code>
argument (which is useful for background variables like age and sex) and
eliminates any predictor named in the <code>exclude</code> argument. If a variable
is listed in both <code>include</code> and <code>exclude</code> arguments, the
<code>include</code> argument takes precedence.
</p>
<p>Advanced topic: <code>mincor</code> and <code>minpuc</code> are typically specified as
scalars, but vectors and squares matrices of appropriate size will also work.
Each element of the vector corresponds to a row of the predictor matrix, so
the procedure can effectively differentiate between different target
variables. Setting a high values for can be useful for auxiliary, less
important, variables. The set of predictor for those variables can remain
relatively small. Using a square matrix extends the idea to the columns, so
that one can also apply cellwise thresholds.
</p>


<h3>Value</h3>

<p>A square binary matrix of size <code>ncol(data)</code>.
</p>


<h3>Note</h3>

<p><code>quickpred()</code> uses <code><a href="base.html#topic+data.matrix">data.matrix</a></code> to convert
factors to numbers through their internal codes. Especially for unordered
factors the resulting quantification may not make sense.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Aug 2009
</p>


<h3>References</h3>

<p>van Buuren, S., Boshuizen, H.C., Knook, D.L. (1999) Multiple
imputation of missing blood pressure covariates in survival analysis.
<em>Statistics in Medicine</em>, <b>18</b>, 681&ndash;694.
</p>
<p>van Buuren, S. and Groothuis-Oudshoorn, K. (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+mids-class">mids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default: include all predictors with absolute correlation over 0.1
quickpred(nhanes)

# all predictors with absolute correlation over 0.4
quickpred(nhanes, mincor = 0.4)

# include age and bmi, exclude chl
quickpred(nhanes, mincor = 0.4, inc = c("age", "bmi"), exc = "chl")

# only include predictors with at least 30% usable cases
quickpred(nhanes, minpuc = 0.3)

# use low threshold for bmi, and high thresholds for hyp and chl
pred &lt;- quickpred(nhanes, mincor = c(0, 0.1, 0.5, 0.5))
pred

# use it directly from mice
imp &lt;- mice(nhanes, pred = quickpred(nhanes, minpuc = 0.25, include = "age"))
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span><span id='topic+tidy'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='selfreport'>Self-reported and measured BMI</h2><span id='topic+selfreport'></span><span id='topic+mgg'></span>

<h3>Description</h3>

<p>Dataset containing height and weight data (measured, self-reported) from two
studies.
</p>


<h3>Format</h3>

<p>A data frame with 2060 rows and 15 variables:
</p>

<dl>
<dt>src</dt><dd><p>Study, either <code>krul</code> or <code>mgg</code> (factor)</p>
</dd>
<dt>id</dt><dd><p>Person identification number</p>
</dd>
<dt>pop</dt><dd><p>Population, all <code>NL</code> (factor)</p>
</dd>
<dt>age</dt><dd><p>Age of respondent in years</p>
</dd>
<dt>sex</dt><dd><p>Sex of respondent (factor)</p>
</dd>
<dt>hm</dt><dd><p>Height measured (cm)</p>
</dd>
<dt>wm</dt><dd><p>Weight measured (kg)</p>
</dd>
<dt>hr</dt><dd><p>Height reported (cm)</p>
</dd>
<dt>wr</dt><dd><p>Weight reported (kg)</p>
</dd>
<dt>prg</dt><dd><p>Pregnancy (factor), all <code>Not pregnant</code></p>
</dd>
<dt>edu</dt><dd><p>Educational level (factor)</p>
</dd>
<dt>etn</dt><dd><p>Ethnicity (factor)</p>
</dd>
<dt>web</dt><dd><p>Obtained through web survey (factor)</p>
</dd>
<dt>bm</dt><dd><p>BMI measured (kg/m2)</p>
</dd>
<dt>br</dt><dd><p>BMI reported (kg/m2)</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset combines two datasets: <code>krul</code> data (Krul, 2010) (1257
persons) and the <code>mgg</code> data (Van Keulen 2011; Van der Klauw 2011) (803
persons). The <code>krul</code> dataset contains height and weight (both measures
and self-reported) from 1257 Dutch adults, whereas the <code>mgg</code> dataset
contains self-reported height and weight for 803 Dutch adults. Section 7.3 in
Van Buuren (2012) shows how the missing measured data can be imputed in the
<code>mgg</code> data, so corrected prevalence estimates can be calculated.
</p>


<h3>Source</h3>

<p>Krul, A., Daanen, H. A. M., Choi, H. (2010). Self-reported and
measured weight, height and body mass index (BMI) in Italy, The Netherlands
and North America. <em>European Journal of Public Health</em>, <em>21</em>(4),
414-419.
</p>
<p>Van Keulen, H.M.,, Chorus, A.M.J., Verheijden, M.W. (2011).  <em>Monitor
Convenant Gezond Gewicht Nulmeting (determinanten van) beweeg- en eetgedrag
van kinderen (4-11 jaar), jongeren (12-17 jaar) en volwassenen (18+ jaar)</em>.
TNO/LS 2011.016. Leiden: TNO.
</p>
<p>Van der Klauw, M., Van Keulen, H.M., Verheijden, M.W. (2011).  <em>Monitor
Convenant Gezond Gewicht Beweeg- en eetgedrag van kinderen (4-11 jaar),
jongeren (12-17 jaar) en volwassenen (18+ jaar) in 2010 en 2011.</em> TNO/LS
2011.055. Leiden: TNO. (in Dutch)
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-prevalence.html#sec:srcdata"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>md.pattern(selfreport[, c("age", "sex", "hm", "hr", "wm", "wr")])

### FIMD Section 7.3.5 Application

bmi &lt;- function(h, w) {
  return(w / (h / 100)^2)
}
init &lt;- mice(selfreport, maxit = 0)
meth &lt;- init$meth
meth["bm"] &lt;- "~bmi(hm,wm)"
pred &lt;- init$pred
pred[, c("src", "id", "web", "bm", "br")] &lt;- 0
imp &lt;- mice(selfreport, pred = pred, meth = meth, seed = 66573, maxit = 2, m = 1)
## imp &lt;- mice(selfreport, pred=pred, meth=meth, seed=66573, maxit=20, m=10)

### Like FIMD Figure 7.6

cd &lt;- complete(imp, 1)
xy &lt;- xy.coords(cd$bm, cd$br - cd$bm)
plot(xy,
  col = mdc(2), xlab = "Measured BMI", ylab = "Reported - Measured BMI",
  xlim = c(17, 45), ylim = c(-5, 5), type = "n", lwd = 0.7
)
polygon(x = c(30, 20, 30), y = c(0, 10, 10), col = "grey95", border = NA)
polygon(x = c(30, 40, 30), y = c(0, -10, -10), col = "grey95", border = NA)
abline(0, 0, lty = 2, lwd = 0.7)

idx &lt;- cd$src == "krul"
xyc &lt;- xy
xyc$x &lt;- xy$x[idx]
xyc$y &lt;- xy$y[idx]
xys &lt;- xy
xys$x &lt;- xy$x[!idx]
xys$y &lt;- xy$y[!idx]
points(xyc, col = mdc(1), cex = 0.7)
points(xys, col = mdc(2), cex = 0.7)
lines(lowess(xyc), col = mdc(4), lwd = 2)
lines(lowess(xys), col = mdc(5), lwd = 2)
text(1:4, x = c(40, 28, 20, 32), y = c(4, 4, -4, -4), cex = 3)
box(lwd = 1)
</code></pre>

<hr>
<h2 id='squeeze'>Squeeze the imputed values to be within specified boundaries.</h2><span id='topic+squeeze'></span>

<h3>Description</h3>

<p>This function replaces any values in <code>x</code> that are lower than
<code>bounds[1]</code> by <code>bounds[1]</code>, and replaces any values higher
than <code>bounds[2]</code> by <code>bounds[2]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squeeze(x, bounds = c(min(x[r]), max(x[r])), r = rep.int(TRUE, length(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squeeze_+3A_x">x</code></td>
<td>
<p>A numerical vector with values</p>
</td></tr>
<tr><td><code id="squeeze_+3A_bounds">bounds</code></td>
<td>
<p>A numerical vector of length 2 containing the lower and upper bounds.
By default, the bounds are to the minimum and maximum values in <code>x</code>.</p>
</td></tr>
<tr><td><code id="squeeze_+3A_r">r</code></td>
<td>
<p>A logical vector of length <code>length(x)</code> that is used to select a
subset in <code>x</code> before calculating automatic bounds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>length(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, 2011.
</p>

<hr>
<h2 id='stripplot.mids'>Stripplot of observed and imputed data</h2><span id='topic+stripplot.mids'></span><span id='topic+stripplot'></span>

<h3>Description</h3>

<p>Plotting methods for imputed data using <span class="pkg">lattice</span>.
<code>stripplot</code> produces one-dimensional
scatterplots. The function
automatically separates the observed and imputed data. The
functions extend the usual features of <span class="pkg">lattice</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids'
stripplot(
  x,
  data,
  na.groups = NULL,
  groups = NULL,
  as.table = TRUE,
  theme = mice.theme(),
  allow.multiple = TRUE,
  outer = TRUE,
  drop.unused.levels = lattice::lattice.getOption("drop.unused.levels"),
  panel = lattice::lattice.getOption("panel.stripplot"),
  default.prepanel = lattice::lattice.getOption("prepanel.default.stripplot"),
  jitter.data = TRUE,
  horizontal = FALSE,
  ...,
  subscripts = TRUE,
  subset = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stripplot.mids_+3A_x">x</code></td>
<td>
<p>A <code>mids</code> object, typically created by <code>mice()</code> or
<code>mice.mids()</code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_data">data</code></td>
<td>
<p>Formula that selects the data to be plotted.  This argument
follows the <span class="pkg">lattice</span> rules for <em>formulas</em>, describing the primary
variables (used for the per-panel display) and the optional conditioning
variables (which define the subsets plotted in different panels) to be used
in the plot.
</p>
<p>The formula is evaluated on the complete data set in the <code>long</code> form.
Legal variable names for the formula include <code>names(x$data)</code> plus the
two administrative factors <code>.imp</code> and <code>.id</code>.
</p>
<p><b>Extended formula interface:</b> The primary variable terms (both the LHS
<code>y</code> and RHS <code>x</code>) may consist of multiple terms separated by a
&lsquo;+&rsquo; sign, e.g., <code>y1 + y2 ~ x | a * b</code>.  This formula would be
taken to mean that the user wants to plot both <code>y1 ~ x | a * b</code> and
<code>y2 ~ x | a * b</code>, but with the <code>y1 ~ x</code> and <code>y2 ~ x</code> in
<em>separate panels</em>. This behavior differs from standard <span class="pkg">lattice</span>.
<em>Only combine terms of the same type</em>, i.e. only factors or only
numerical variables. Mixing numerical and categorical data occasionally
produces odds labeling of vertical axis.
</p>
<p>For convenience, in <code>stripplot()</code> and <code>bwplot</code> the formula
<code>y~.imp</code> may be abbreviated as <code>y</code>. This applies only to a single
<code>y</code>, and does not (yet) work for <code>y1+y2~.imp</code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_na.groups">na.groups</code></td>
<td>
<p>An expression evaluating to a logical vector indicating
which two groups are distinguished (e.g. using different colors) in the
display. The environment in which this expression is evaluated in the
response indicator <code>is.na(x$data)</code>.
</p>
<p>The default <code>na.group = NULL</code> contrasts the observed and missing data
in the LHS <code>y</code> variable of the display, i.e. groups created by
<code>is.na(y)</code>. The expression <code>y</code> creates the groups according to
<code>is.na(y)</code>. The expression <code>y1 &amp; y2</code> creates groups by
<code>is.na(y1) &amp; is.na(y2)</code>, and <code>y1 | y2</code> creates groups as
<code>is.na(y1) | is.na(y2)</code>, and so on.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_groups">groups</code></td>
<td>
<p>This is the usual <code>groups</code> arguments in <span class="pkg">lattice</span>. It
differs from <code>na.groups</code> because it evaluates in the completed data
<code>data.frame(complete(x, "long", inc=TRUE))</code> (as usual), whereas
<code>na.groups</code> evaluates in the response indicator. See
<code><a href="#topic+xyplot">xyplot</a></code> for more details. When both <code>na.groups</code> and
<code>groups</code> are specified, <code>na.groups</code> takes precedence, and
<code>groups</code> is ignored.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_as.table">as.table</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_theme">theme</code></td>
<td>
<p>A named list containing the graphical parameters. The default
function <code>mice.theme</code> produces a short list of default colors, line
width, and so on. The extensive list may be obtained from
<code>trellis.par.get()</code>. Global graphical parameters like <code>col</code> or
<code>cex</code> in high-level calls are still honored, so first experiment with
the global parameters. Many setting consists of a pair. For example,
<code>mice.theme</code> defines two symbol colors. The first is for the observed
data, the second for the imputed data. The theme settings only exist during
the call, and do not affect the trellis graphical parameters.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_allow.multiple">allow.multiple</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_outer">outer</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_panel">panel</code></td>
<td>
<p>See <code><a href="#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_default.prepanel">default.prepanel</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_jitter.data">jitter.data</code></td>
<td>
<p>See <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_horizontal">horizontal</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_...">...</code></td>
<td>
<p>Further arguments, usually not directly processed by the
high-level functions documented here, but instead passed on to other
functions.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_subscripts">subscripts</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="stripplot.mids_+3A_subset">subset</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>na.groups</code> may be used to specify (combinations of)
missingness in any of the variables. The argument <code>groups</code> can be used
to specify groups based on the variable values themselves. Only one of both
may be active at the same time. When both are specified, <code>na.groups</code>
takes precedence over <code>groups</code>.
</p>
<p>Use the <code>subset</code> and <code>na.groups</code> together to plots parts of the
data. For example, select the first imputed data set by by
<code>subset=.imp==1</code>.
</p>
<p>Graphical parameters like <code>col</code>, <code>pch</code> and <code>cex</code> can be
specified in the arguments list to alter the plotting symbols. If
<code>length(col)==2</code>, the color specification to define the observed and
missing groups. <code>col[1]</code> is the color of the 'observed' data,
<code>col[2]</code> is the color of the missing or imputed data. A convenient color
choice is <code>col=mdc(1:2)</code>, a transparent blue color for the observed
data, and a transparent red color for the imputed data. A good choice is
<code>col=mdc(1:2), pch=20, cex=1.5</code>. These choices can be set for the
duration of the session by running <code>mice.theme()</code>.
</p>


<h3>Value</h3>

<p>The high-level functions documented here, as well as other high-level
Lattice functions, return an object of class <code>"trellis"</code>.  The
<code><a href="lattice.html#topic+update.trellis">update</a></code> method can be used to
subsequently update components of the object, and the
<code><a href="lattice.html#topic+print.trellis">print</a></code> method (usually called by default)
will plot it on an appropriate plotting device.
</p>


<h3>Note</h3>

<p>The first two arguments (<code>x</code> and <code>data</code>) are reversed
compared to the standard Trellis syntax implemented in <span class="pkg">lattice</span>. This
reversal was necessary in order to benefit from automatic method dispatch.
</p>
<p>In <span class="pkg">mice</span> the argument <code>x</code> is always a <code>mids</code> object, whereas
in <span class="pkg">lattice</span> the argument <code>x</code> is always a formula.
</p>
<p>In <span class="pkg">mice</span> the argument <code>data</code> is always a formula object, whereas in
<span class="pkg">lattice</span> the argument <code>data</code> is usually a data frame.
</p>
<p>All other arguments have identical interpretation.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren
</p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
</p>
<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+densityplot">densityplot</a></code>,
<code><a href="#topic+bwplot">bwplot</a></code>, <code><a href="lattice.html#topic+lattice">lattice</a></code> for an overview of the
package, as well as <code><a href="lattice.html#topic+xyplot">stripplot</a></code>,
<code><a href="lattice.html#topic+panel.stripplot">panel.stripplot</a></code>,
<code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>,
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(boys, maxit = 1)

### stripplot, all numerical variables
## Not run: 
stripplot(imp)

## End(Not run)

### same, but with improved display
## Not run: 
stripplot(imp, col = c("grey", mdc(2)), pch = c(1, 20))

## End(Not run)

### distribution per imputation of height, weight and bmi
### labeled by their own missingness
## Not run: 
stripplot(imp, hgt + wgt + bmi ~ .imp,
  cex = c(2, 4), pch = c(1, 20), jitter = FALSE,
  layout = c(3, 1)
)

## End(Not run)

### same, but labeled with the missingness of wgt (just four cases)
## Not run: 
stripplot(imp, hgt + wgt + bmi ~ .imp,
  na = wgt, cex = c(2, 4), pch = c(1, 20), jitter = FALSE,
  layout = c(3, 1)
)

## End(Not run)

### distribution of age and height, labeled by missingness in height
### most height values are missing for those around
### the age of two years
### some additional missings occur in region WEST
## Not run: 
stripplot(imp, age + hgt ~ .imp | reg, hgt,
  col = c(grDevices::hcl(0, 0, 40, 0.2), mdc(2)), pch = c(1, 20)
)

## End(Not run)

### heavily jitted relation between two categorical variables
### labeled by missingness of gen
### aggregated over all imputed data sets
## Not run: 
stripplot(imp, gen ~ phb, factor = 2, cex = c(8, 1), hor = TRUE)

## End(Not run)

### circle fun
stripplot(imp, gen ~ .imp,
  na = wgt, factor = 2, cex = c(8.6),
  hor = FALSE, outer = TRUE, scales = "free", pch = c(1, 19)
)
</code></pre>

<hr>
<h2 id='summary.mira'>Summary of a <code>mira</code> object</h2><span id='topic+summary.mira'></span><span id='topic+summary.mids'></span><span id='topic+summary.mads'></span><span id='topic+summary.mice.anova'></span>

<h3>Description</h3>

<p>Summary of a <code>mira</code> object
</p>
<p>Summary of a <code>mids</code> object
</p>
<p>Summary of a <code>mads</code> object
</p>
<p>Print a <code>mice.anova</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mira'
summary(object, type = c("tidy", "glance", "summary"), ...)

## S3 method for class 'mids'
summary(object, ...)

## S3 method for class 'mads'
summary(object, ...)

## S3 method for class 'mice.anova'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mira_+3A_object">object</code></td>
<td>
<p>A <code>mira</code> object</p>
</td></tr>
<tr><td><code id="summary.mira_+3A_type">type</code></td>
<td>
<p>A length-1 character vector indicating the
type of summary. There are three choices: <code>type = "tidy"</code>
return the parameters estimates of each analyses as a data frame.
<code>type = "glance"</code> return the fit statistics of each analysis
as a data frame. <code>type = "summary"</code> returns a list of
length <code>m</code> with the analysis results. The default is
<code>"tidy"</code>.</p>
</td></tr>
<tr><td><code id="summary.mira_+3A_...">...</code></td>
<td>
<p>Other parameters passed down to <code>print()</code> and <code>summary()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>
<p><code>NULL</code>
</p>
<p><code>NULL</code>
</p>
<p><code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mira-class">mira</a></code>
</p>
<p><code><a href="#topic+mids-class">mids</a></code>
</p>
<p><code><a href="#topic+mads-class">mads</a></code>
</p>
<p><code><a href="#topic+mipo">mipo</a></code>
</p>

<hr>
<h2 id='supports.transparent'>Supports semi-transparent foreground colors?</h2><span id='topic+supports.transparent'></span><span id='topic+transparent'></span>

<h3>Description</h3>

<p>This function is used by <code>mdc()</code> to find out whether the current device
supports semi-transparent foreground colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supports.transparent()
</code></pre>


<h3>Details</h3>

<p>The function calls the function <code>dev.capabilities()</code> from the package
<code>grDevices</code>. The function return <code>FALSE</code> if the status of the
current device is unknown.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mdc">mdc</a></code> <code><a href="grDevices.html#topic+dev.capabilities">dev.capabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
supports.transparent()
</code></pre>

<hr>
<h2 id='tbc'>Terneuzen birth cohort</h2><span id='topic+tbc'></span><span id='topic+tbc.target'></span><span id='topic+terneuzen'></span>

<h3>Description</h3>

<p>Data of subset of the Terneuzen Birth Cohort data on child growth.
</p>


<h3>Format</h3>

<p><code>tbs</code> is a data frame with 3951 rows and 11 columns:
</p>

<dl>
<dt>id</dt><dd><p>Person number</p>
</dd>
<dt>occ</dt><dd><p>Occasion number</p>
</dd>
<dt>nocc</dt><dd><p>Number of occasions</p>
</dd>
<dt>first</dt><dd><p>Is this the first record for this person? (TRUE/FALSE)</p>
</dd>
<dt>typ</dt><dd><p>Type of data (all observed)</p>
</dd>
<dt>age</dt><dd><p>Age (years)</p>
</dd>
<dt>sex</dt><dd><p>Sex 1=M, 2=F</p>
</dd>
<dt>hgt.z</dt><dd><p>Height Z-score</p>
</dd>
<dt>wgt.z</dt><dd><p>Weight Z-score</p>
</dd>
<dt>bmi.z</dt><dd><p>BMI Z-score</p>
</dd>
<dt>ao</dt><dd><p>Adult overweight (0=no, 1=yes)</p>
</dd>
</dl>

<p><code>tbc.target</code> is a data frame with 2612 rows and 3 columns:
</p>

<dl>
<dt>id</dt><dd><p>Person number</p>
</dd>
<dt>ao</dt><dd><p>Adult overweight (0=no, 1=yes)</p>
</dd>
<dt>bmi.z.jv</dt><dd><p>BMI Z-score as young adult (18-29 years)</p>
</dd>
</dl>



<h3>Details</h3>

<p>This <code>tbc</code> data set is a random subset of persons from a much larger
collection of data from the Terneuzen Birth Cohort. The total cohort
comprises of 2604 unique persons, whereas the subset in <code>tbc</code> covers 306
persons. The <code>tbc.target</code> is an auxiliary data set containing two
outcomes at adult age. For more details, see De Kroon et al (2008, 2010,
2011).  The imputation methodology is explained in Chapter 9 of Van Buuren
(2012).
</p>


<h3>Source</h3>

<p>De Kroon, M. L. A., Renders, C. M., Kuipers, E. C., van Wouwe, J. P.,
van Buuren, S., de Jonge, G. A., Hirasing, R. A. (2008). Identifying
metabolic syndrome without blood tests in young adults - The Terneuzen birth
cohort. <em>European Journal of Public Health</em>, <em>18</em>(6), 656-660.
</p>
<p>De Kroon, M. L. A., Renders, C. M., Van Wouwe, J. P., Van Buuren, S.,
Hirasing, R. A. (2010).  The Terneuzen birth cohort: BMI changes between 2
and 6 years correlate strongest with adult overweight.  <em>PLoS ONE</em>,
<em>5</em>(2), e9155.
</p>
<p>De Kroon, M. L. A. (2011).  <em>The Terneuzen Birth Cohort. Detection and
Prevention of Overweight and Cardiometabolic Risk from Infancy Onward.</em>
Dissertation, Vrije Universiteit, Amsterdam.
<a href="https://research.vu.nl/en/publications/the-terneuzen-birth-cohort-detection-and-prevention-of-overweight">https://research.vu.nl/en/publications/the-terneuzen-birth-cohort-detection-and-prevention-of-overweight</a>
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-rastering.html#terneuzen-birth-cohort"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tbc
md.pattern(data)
</code></pre>

<hr>
<h2 id='tidy.mipo'>Tidy method to extract results from a 'mipo' object</h2><span id='topic+tidy.mipo'></span>

<h3>Description</h3>

<p>Tidy method to extract results from a 'mipo' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mipo'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.mipo_+3A_x">x</code></td>
<td>
<p>An object of class <code>mipo</code></p>
</td></tr>
<tr><td><code id="tidy.mipo_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. Should confidence intervals be returned?</p>
</td></tr>
<tr><td><code id="tidy.mipo_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level for intervals. Defaults to .95</p>
</td></tr>
<tr><td><code id="tidy.mipo_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe withh these columns:
</p>

<ul>
<li><p> term
</p>
</li>
<li><p> estimate
</p>
</li>
<li><p> ubar
</p>
</li>
<li><p> b
</p>
</li>
<li><p> t
</p>
</li>
<li><p> dfcom
</p>
</li>
<li><p> df
</p>
</li>
<li><p> riv
</p>
</li>
<li><p> lambda
</p>
</li>
<li><p> fmi
</p>
</li>
<li><p> p.value
</p>
</li>
<li><p> conf.low (if called with conf.int = TRUE)
</p>
</li>
<li><p> conf.high (if called with conf.int = TRUE)
</p>
</li></ul>


<hr>
<h2 id='toenail'>Toenail data</h2><span id='topic+toenail'></span>

<h3>Description</h3>

<p>The toenail data come from a Multicenter study comparing two oral
treatments for toenail infection. Patients were evaluated for the
degree of separation of the nail. Patients were randomized into two
treatments and were followed over seven visits - four in the first
year and yearly thereafter. The patients have not been treated
prior to the first visit so this should be regarded as the
baseline.
</p>


<h3>Format</h3>

<p>A data frame with 1908 observations on the following 5 variables:
</p>

<dl>
<dt><code>ID</code></dt><dd><p>a numeric vector giving the ID of patient</p>
</dd>
<dt><code>outcome</code></dt><dd><p>a numeric vector giving the response
(0=none or mild seperation, 1=moderate or severe)</p>
</dd>
<dt><code>treatment</code></dt><dd><p>a numeric vector giving the treatment group</p>
</dd>
<dt><code>month</code></dt><dd><p>a numeric vector giving the time of the visit
(not exactly monthly intervals hence not round numbers)</p>
</dd>
<dt><code>visit</code></dt><dd><p>a numeric vector giving the number of the visit</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset was copied from the <code>DPpackage</code>, which is
scheduled to be discontinued from CRAN in August 2019.
</p>


<h3>Source</h3>

<p>De Backer, M., De Vroey, C., Lesaffre, E., Scheys, I., and De
Keyser, P. (1998). Twelve weeks of continuous oral therapy for
toenail onychomycosis caused by dermatophytes: A double-blind
comparative trial of terbinafine 250 mg/day versus itraconazole 200
mg/day. Journal of the American Academy of Dermatology, 38, 57-63.
</p>


<h3>References</h3>

<p>Lesaffre, E. and Spiessens, B. (2001). On the effect of the number of
quadrature points in a logistic random-effects model: An example.
Journal of the Royal Statistical Society, Series C, 50, 325-335.
</p>
<p>G. Fitzmaurice, N. Laird and J. Ware (2004) Applied Longitudinal Analysis,
Wiley and Sons, New York, USA.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-catoutcome.html#example"><em>Flexible
Imputation of Missing Data. Second Edition.</em></a> Chapman &amp; Hall/CRC.
Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toenail2">toenail2</a></code>
</p>

<hr>
<h2 id='toenail2'>Toenail data</h2><span id='topic+toenail2'></span>

<h3>Description</h3>

<p>The toenail data come from a Multicenter study comparing two oral
treatments for toenail infection. Patients were evaluated for the
degree of separation of the nail. Patients were randomized into two
treatments and were followed over seven visits - four in the first
year and yearly thereafter. The patients have not been treated
prior to the first visit so this should be regarded as the
baseline.
</p>


<h3>Format</h3>

<p>A data frame with 1908 observations on the following 5 variables:
</p>

<dl>
<dt><code>patientID</code></dt><dd><p>a numeric vector giving the ID of patient</p>
</dd>
<dt><code>outcome</code></dt><dd><p>a factor with 2 levels giving the response</p>
</dd>
<dt><code>treatment</code></dt><dd><p>a factor with 2 levels giving the treatment group</p>
</dd>
<dt><code>time</code></dt><dd><p>a numeric vector giving the time of the visit
(not exactly monthly intervals hence not round numbers)</p>
</dd>
<dt><code>visit</code></dt><dd><p>an integer giving the number of the visit</p>
</dd>
</dl>



<h3>Details</h3>

<p>Apart from formatting, this dataset is identical to
<code>toenail</code>. The formatting is taken identical to
<code>data("toenail", package = "HSAUR3")</code>.
</p>


<h3>Source</h3>

<p>De Backer, M., De Vroey, C., Lesaffre, E., Scheys, I., and De
Keyser, P. (1998). Twelve weeks of continuous oral therapy for
toenail onychomycosis caused by dermatophytes: A double-blind
comparative trial of terbinafine 250 mg/day versus itraconazole 200
mg/day. Journal of the American Academy of Dermatology, 38, 57-63.
</p>


<h3>References</h3>

<p>Lesaffre, E. and Spiessens, B. (2001). On the effect of the number of
quadrature points in a logistic random-effects model: An example.
Journal of the Royal Statistical Society, Series C, 50, 325-335.
</p>
<p>G. Fitzmaurice, N. Laird and J. Ware (2004) Applied Longitudinal Analysis,
Wiley and Sons, New York, USA.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-catoutcome.html#example"><em>Flexible
Imputation of Missing Data. Second Edition.</em></a> Chapman &amp; Hall/CRC.
Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toenail">toenail</a></code>
</p>

<hr>
<h2 id='version'>Echoes the package version number</h2><span id='topic+version'></span>

<h3>Description</h3>

<p>Echoes the package version number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version(pkg = "mice")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="version_+3A_pkg">pkg</code></td>
<td>
<p>A character vector with the package name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the package name, version number and
installed directory.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, Oct 2010
</p>


<h3>Examples</h3>

<pre><code class='language-R'>version()
version("base")
</code></pre>

<hr>
<h2 id='walking'>Walking disability data</h2><span id='topic+walking'></span>

<h3>Description</h3>

<p>Two items YA and YB measuring walking disability in samples A, B and E.
</p>


<h3>Format</h3>

<p>A data frame with 890 rows on the following 5 variables:
</p>

<dl>
<dt>sex</dt><dd><p>Sex of respondent (factor)</p>
</dd>
<dt>age</dt><dd><p>Age of respondent</p>
</dd>
<dt>YA</dt><dd><p>Item administered in samples A and E (factor)</p>
</dd>
<dt>YB</dt><dd><p>Item administered in samples B and E (factor)</p>
</dd>
<dt>src</dt><dd><p>Source: Sample A, B or E (factor)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Example dataset to demonstrate imputation of two items (YA and YB). Item YA
is administered to sample A and sample E, item YB is administered to sample B
and sample E, so sample E acts as a bridge study. Imputation using a bridge
study is better than simple equating or than imputation under independence.
</p>
<p>Item YA corresponds to the HAQ8 item, and item YB corresponds to the GAR9
items from Van Buuren et al (2005).  Sample E (as well as sample B) is the
Euridiss study (n=292), sample A is the ERGOPLUS study (n=306).
</p>
<p>See Van Buuren (2018) section 9.4 for more details on the imputation
methodology.
</p>


<h3>References</h3>

<p>van Buuren, S., Eyres, S., Tennant, A., Hopman-Rock, M. (2005).
Improving comparability of existing data by Response Conversion.
<em>Journal of Official Statistics</em>, <b>21</b>(1), 53-72.
</p>
<p>Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-codingsystems.html#sec:impbridge"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>md.pattern(walking)

micemill &lt;- function(n) {
  for (i in 1:n) {
    imp &lt;&lt;- mice.mids(imp) # global assignment
    cors &lt;- with(imp, cor(as.numeric(YA),
      as.numeric(YB),
      method = "kendall"
    ))
    tau &lt;&lt;- rbind(tau, getfit(cors, s = TRUE)) # global assignment
  }
}

plotit &lt;- function() {
  matplot(
    x = 1:nrow(tau), y = tau,
    ylab = expression(paste("Kendall's ", tau)),
    xlab = "Iteration", type = "l", lwd = 1,
    lty = 1:10, col = "black"
  )
}

tau &lt;- NULL
imp &lt;- mice(walking, max = 0, m = 10, seed = 92786)
pred &lt;- imp$pred
pred[, c("src", "age", "sex")] &lt;- 0
imp &lt;- mice(walking, max = 0, m = 3, seed = 92786, pred = pred)
micemill(5)
plotit()

### to get figure 9.8 van Buuren (2018) use m=10 and micemill(20)
</code></pre>

<hr>
<h2 id='windspeed'>Subset of Irish wind speed data</h2><span id='topic+windspeed'></span>

<h3>Description</h3>

<p>Subset of Irish wind speed data
</p>


<h3>Format</h3>

<p>A data frame with 433 rows and 6 columns containing the daily average
wind speeds within the period 1961-1978 at meteorological stations in the
Republic of Ireland. The data are a random sample from a larger data set.
</p>

<dl>
<dt>RochePt</dt><dd><p>Roche Point</p>
</dd>
<dt>Rosslare</dt><dd><p>Rosslare</p>
</dd>
<dt>Shannon</dt><dd><p>Shannon</p>
</dd>
<dt>Dublin</dt><dd><p>Dublin</p>
</dd>
<dt>Clones</dt><dd><p>Clones</p>
</dd>
<dt>MalinHead</dt><dd><p>Malin Head</p>
</dd> </dl>



<h3>Details</h3>

<p>The original data set is much larger and was analyzed in detail by Haslett
and Raftery (1989). Van Buuren et al (2006) used this subset to investigate
the influence of extreme MAR mechanisms on the quality of imputation.
</p>


<h3>References</h3>

<p>Haslett, J. and Raftery, A. E. (1989).  <em>Space-time
Modeling with Long-memory Dependence: Assessing Ireland's Wind Power
Resource (with Discussion)</em>. Applied Statistics 38, 1-50.
<a href="http://lib.stat.cmu.edu/datasets/wind.desc">http://lib.stat.cmu.edu/datasets/wind.desc</a> and
<a href="http://lib.stat.cmu.edu/datasets/wind.data">http://lib.stat.cmu.edu/datasets/wind.data</a>
</p>
<p>van Buuren, S., Brand, J.P.L., Groothuis-Oudshoorn C.G.M., Rubin, D.B. (2006)
Fully conditional specification in multivariate imputation.  <em>Journal of
Statistical Computation and Simulation</em>, <b>76</b>, 12, 1049&ndash;1064.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
windspeed[1:3, ]
</code></pre>

<hr>
<h2 id='with.mids'>Evaluate an expression in multiple imputed datasets</h2><span id='topic+with.mids'></span>

<h3>Description</h3>

<p>Performs a computation of each of imputed datasets in data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids'
with(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.mids_+3A_data">data</code></td>
<td>
<p>An object of type <code>mids</code>, which stands for 'multiply imputed
data set', typically created by a call to function <code>mice()</code>.</p>
</td></tr>
<tr><td><code id="with.mids_+3A_expr">expr</code></td>
<td>
<p>An expression to evaluate for each imputed data set. Formula's
containing a dot (notation for &quot;all other variables&quot;) do not work.</p>
</td></tr>
<tr><td><code id="with.mids_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S3 class <code><a href="#topic+mira-class">mira</a></code>
</p>


<h3>Note</h3>

<p>Version 3.11.10 changed to tidy evaluation on a quosure. This change
should not affect any code that worked on previous versions.
It turned out that the latter statement was not true (#292).
Version 3.12.2 reverts to the old <code>with()</code> function.
</p>


<h3>Author(s)</h3>

<p>Karin Oudshoorn, Stef van Buuren 2009, 2012, 2020
</p>


<h3>References</h3>

<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mids-class">mids</a></code>, <code><a href="#topic+mira-class">mira</a></code>, <code><a href="#topic+pool">pool</a></code>,
<code><a href="#topic+D1">D1</a></code>, <code><a href="#topic+D3">D3</a></code>, <code><a href="#topic+pool.r.squared">pool.r.squared</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(nhanes2, m = 2, print = FALSE, seed = 14221)

# descriptive statistics
getfit(with(imp, table(hyp, age)))

# model fitting and testing
fit1 &lt;- with(imp, lm(bmi ~ age + hyp + chl))
fit2 &lt;- with(imp, glm(hyp ~ age + chl, family = binomial))
fit3 &lt;- with(imp, anova(lm(bmi ~ age + chl)))
</code></pre>

<hr>
<h2 id='xyplot.mads'>Scatterplot of amputed and non-amputed data against weighted sum scores</h2><span id='topic+xyplot.mads'></span>

<h3>Description</h3>

<p>Plotting method to investigate relation between amputed data and the weighted sum
scores. Based on <code><a href="lattice.html#topic+lattice">lattice</a></code>. <code>xyplot</code> produces scatterplots.
The function plots the variables against the weighted sum scores. The function
automatically separates the amputed and non-amputed data to see the relation between
the amputation and the weighted sum scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mads'
xyplot(
  x,
  data,
  which.pat = NULL,
  standardized = TRUE,
  layout = NULL,
  colors = mdc(1:2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyplot.mads_+3A_x">x</code></td>
<td>
<p>A <code>mads</code> object, typically created by <code><a href="#topic+ampute">ampute</a></code>.</p>
</td></tr>
<tr><td><code id="xyplot.mads_+3A_data">data</code></td>
<td>
<p>A string or vector of variable names that needs to be plotted. As
a default, all variables will be plotted.</p>
</td></tr>
<tr><td><code id="xyplot.mads_+3A_which.pat">which.pat</code></td>
<td>
<p>A scalar or vector indicating which patterns need to be plotted.
As a default, all patterns are plotted.</p>
</td></tr>
<tr><td><code id="xyplot.mads_+3A_standardized">standardized</code></td>
<td>
<p>Logical. Whether the scatterplots need to be created
from standardized data or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="xyplot.mads_+3A_layout">layout</code></td>
<td>
<p>A vector of two values indicating how the scatterplots of one
pattern should be divided over the plot. For example, <code>c(2, 3)</code> indicates
that the scatterplots of six variables need to be placed on 3 rows and 2 columns.
There are several defaults for different #variables. Note that for more than
9 variables, multiple plots will be created automatically.</p>
</td></tr>
<tr><td><code id="xyplot.mads_+3A_colors">colors</code></td>
<td>
<p>A vector of two RGB values defining the colors of the non-amputed and
amputed data respectively. RGB values can be obtained with <code><a href="grDevices.html#topic+hcl">hcl</a></code>.</p>
</td></tr>
<tr><td><code id="xyplot.mads_+3A_...">...</code></td>
<td>
<p>Not used, but for consistency with generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the scatterplots. Note that a new pattern
will always be shown in a new plot.
</p>


<h3>Note</h3>

<p>The <code>mads</code> object contains all the information you need to
make any desired plots. Check <code><a href="#topic+mads-class">mads-class</a></code> or the vignette <em>Multivariate
Amputation using Ampute</em> to understand the contents of class object <code>mads</code>.
</p>


<h3>Author(s)</h3>

<p>Rianne Schouten, 2016
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ampute">ampute</a></code>, <code><a href="#topic+bwplot">bwplot</a></code>, <code><a href="lattice.html#topic+Lattice">Lattice</a></code> for
an overview of the package, <code><a href="#topic+mads-class">mads-class</a></code>
</p>

<hr>
<h2 id='xyplot.mids'>Scatterplot of observed and imputed data</h2><span id='topic+xyplot.mids'></span><span id='topic+xyplot'></span>

<h3>Description</h3>

<p>Plotting methods for imputed data using <span class="pkg">lattice</span>.
<code>xyplot()</code> produces a conditional scatterplots. The function
automatically separates the observed (blue) and imputed (red) data. The
function extends the usual features of <span class="pkg">lattice</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids'
xyplot(
  x,
  data,
  na.groups = NULL,
  groups = NULL,
  as.table = TRUE,
  theme = mice.theme(),
  allow.multiple = TRUE,
  outer = TRUE,
  drop.unused.levels = lattice::lattice.getOption("drop.unused.levels"),
  ...,
  subscripts = TRUE,
  subset = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyplot.mids_+3A_x">x</code></td>
<td>
<p>A <code>mids</code> object, typically created by <code>mice()</code> or
<code>mice.mids()</code>.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_data">data</code></td>
<td>
<p>Formula that selects the data to be plotted.  This argument
follows the <span class="pkg">lattice</span> rules for <em>formulas</em>, describing the primary
variables (used for the per-panel display) and the optional conditioning
variables (which define the subsets plotted in different panels) to be used
in the plot.
</p>
<p>The formula is evaluated on the complete data set in the <code>long</code> form.
Legal variable names for the formula include <code>names(x$data)</code> plus the
two administrative factors <code>.imp</code> and <code>.id</code>.
</p>
<p><b>Extended formula interface:</b> The primary variable terms (both the LHS
<code>y</code> and RHS <code>x</code>) may consist of multiple terms separated by a
&lsquo;+&rsquo; sign, e.g., <code>y1 + y2 ~ x | a * b</code>.  This formula would be
taken to mean that the user wants to plot both <code>y1 ~ x | a * b</code> and
<code>y2 ~ x | a * b</code>, but with the <code>y1 ~ x</code> and <code>y2 ~ x</code> in
<em>separate panels</em>. This behavior differs from standard <span class="pkg">lattice</span>.
<em>Only combine terms of the same type</em>, i.e. only factors or only
numerical variables. Mixing numerical and categorical data occasionally
produces odds labeling of vertical axis.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_na.groups">na.groups</code></td>
<td>
<p>An expression evaluating to a logical vector indicating
which two groups are distinguished (e.g. using different colors) in the
display. The environment in which this expression is evaluated in the
response indicator <code>is.na(x$data)</code>.
</p>
<p>The default <code>na.group = NULL</code> contrasts the observed and missing data
in the LHS <code>y</code> variable of the display, i.e. groups created by
<code>is.na(y)</code>. The expression <code>y</code> creates the groups according to
<code>is.na(y)</code>. The expression <code>y1 &amp; y2</code> creates groups by
<code>is.na(y1) &amp; is.na(y2)</code>, and <code>y1 | y2</code> creates groups as
<code>is.na(y1) | is.na(y2)</code>, and so on.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_groups">groups</code></td>
<td>
<p>This is the usual <code>groups</code> arguments in <span class="pkg">lattice</span>. It
differs from <code>na.groups</code> because it evaluates in the completed data
<code>data.frame(complete(x, "long", inc=TRUE))</code> (as usual), whereas
<code>na.groups</code> evaluates in the response indicator. See
<code><a href="#topic+xyplot">xyplot</a></code> for more details. When both <code>na.groups</code> and
<code>groups</code> are specified, <code>na.groups</code> takes precedence, and
<code>groups</code> is ignored.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_as.table">as.table</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_theme">theme</code></td>
<td>
<p>A named list containing the graphical parameters. The default
function <code>mice.theme</code> produces a short list of default colors, line
width, and so on. The extensive list may be obtained from
<code>trellis.par.get()</code>. Global graphical parameters like <code>col</code> or
<code>cex</code> in high-level calls are still honored, so first experiment with
the global parameters. Many setting consists of a pair. For example,
<code>mice.theme</code> defines two symbol colors. The first is for the observed
data, the second for the imputed data. The theme settings only exist during
the call, and do not affect the trellis graphical parameters.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_allow.multiple">allow.multiple</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_outer">outer</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_...">...</code></td>
<td>
<p>Further arguments, usually not directly processed by the
high-level functions documented here, but instead passed on to other
functions.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_subscripts">subscripts</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="xyplot.mids_+3A_subset">subset</code></td>
<td>
<p>See <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>na.groups</code> may be used to specify (combinations of)
missingness in any of the variables. The argument <code>groups</code> can be used
to specify groups based on the variable values themselves. Only one of both
may be active at the same time. When both are specified, <code>na.groups</code>
takes precedence over <code>groups</code>.
</p>
<p>Use the <code>subset</code> and <code>na.groups</code> together to plots parts of the
data. For example, select the first imputed data set by by
<code>subset=.imp==1</code>.
</p>
<p>Graphical parameters like <code>col</code>, <code>pch</code> and <code>cex</code> can be
specified in the arguments list to alter the plotting symbols. If
<code>length(col)==2</code>, the color specification to define the observed and
missing groups. <code>col[1]</code> is the color of the 'observed' data,
<code>col[2]</code> is the color of the missing or imputed data. A convenient color
choice is <code>col=mdc(1:2)</code>, a transparent blue color for the observed
data, and a transparent red color for the imputed data. A good choice is
<code>col=mdc(1:2), pch=20, cex=1.5</code>. These choices can be set for the
duration of the session by running <code>mice.theme()</code>.
</p>


<h3>Value</h3>

<p>The high-level functions documented here, as well as other high-level
Lattice functions, return an object of class <code>"trellis"</code>.  The
<code><a href="lattice.html#topic+update.trellis">update</a></code> method can be used to
subsequently update components of the object, and the
<code><a href="lattice.html#topic+print.trellis">print</a></code> method (usually called by default)
will plot it on an appropriate plotting device.
</p>


<h3>Note</h3>

<p>The first two arguments (<code>x</code> and <code>data</code>) are reversed
compared to the standard Trellis syntax implemented in <span class="pkg">lattice</span>. This
reversal was necessary in order to benefit from automatic method dispatch.
</p>
<p>In <span class="pkg">mice</span> the argument <code>x</code> is always a <code>mids</code> object, whereas
in <span class="pkg">lattice</span> the argument <code>x</code> is always a formula.
</p>
<p>In <span class="pkg">mice</span> the argument <code>data</code> is always a formula object, whereas in
<span class="pkg">lattice</span> the argument <code>data</code> is usually a data frame.
</p>
<p>All other arguments have identical interpretation.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren
</p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
</p>
<p>van Buuren S and Groothuis-Oudshoorn K (2011). <code>mice</code>: Multivariate
Imputation by Chained Equations in <code>R</code>. <em>Journal of Statistical
Software</em>, <b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mice">mice</a></code>, <code><a href="#topic+stripplot">stripplot</a></code>, <code><a href="#topic+densityplot">densityplot</a></code>,
<code><a href="#topic+bwplot">bwplot</a></code>, <code><a href="lattice.html#topic+lattice">lattice</a></code> for an overview of the
package, as well as <code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>,
<code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>,
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- mice(boys, maxit = 1)

# xyplot: scatterplot by imputation number
# observe the erroneous outlying imputed values
# (caused by imputing hgt from bmi)
xyplot(imp, hgt ~ age | .imp, pch = c(1, 20), cex = c(1, 1.5))

# same, but label with missingness of wgt (four cases)
xyplot(imp, hgt ~ age | .imp, na.group = wgt, pch = c(1, 20), cex = c(1, 1.5))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
