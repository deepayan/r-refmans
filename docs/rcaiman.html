<!DOCTYPE html><html lang="en"><head><title>Help for package rcaiman</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rcaiman}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rcaiman-package'><p>rcaiman: CAnopy IMage ANalysis</p></a></li>
<li><a href='#apply_thr'><p>Apply threshold</p></a></li>
<li><a href='#azimuth_image'><p>Build azimuth image</p></a></li>
<li><a href='#calc_co'><p>Calculate canopy openness</p></a></li>
<li><a href='#calc_diameter'><p>Calculate diameter</p></a></li>
<li><a href='#calc_relative_radius'><p>Calculate relative radius</p></a></li>
<li><a href='#calc_zenith_colrow'><p>Calculate zenith raster coordinates</p></a></li>
<li><a href='#calibrate_lens'><p>Calibrate lens</p></a></li>
<li><a href='#chessboard'><p>Do chessboard segmentation</p></a></li>
<li><a href='#cie_sky_model_raster'><p>CIE sky model raster</p></a></li>
<li><a href='#colorfulness'><p>Quantify colorfulness</p></a></li>
<li><a href='#correct_vignetting'><p>Correct vignetting effect</p></a></li>
<li><a href='#crop_caim'><p>Crop a canopy image from a file</p></a></li>
<li><a href='#crosscalibrate_lens'><p>Cross-calibrate lens</p></a></li>
<li><a href='#defuzzify'><p>Defuzzify a fuzzy classification</p></a></li>
<li><a href='#enhance_caim'><p>Enhance canopy image</p></a></li>
<li><a href='#expand_noncircular'><p>Expand non-circular</p></a></li>
<li><a href='#extract_dn'><p>Extract digital numbers</p></a></li>
<li><a href='#extract_feature'><p>Extract feature</p></a></li>
<li><a href='#extract_radiometry'><p>Extract radiometry data</p></a></li>
<li><a href='#extract_rl'><p>Extract relative luminance</p></a></li>
<li><a href='#extract_sky_points'><p>Extract sky points</p></a></li>
<li><a href='#extract_sky_points_simple'><p>Extract sky points</p></a></li>
<li><a href='#extract_sun_coord'><p>Extract sun coordinates</p></a></li>
<li><a href='#find_sky_pixels'><p>Find sky pixels</p></a></li>
<li><a href='#find_sky_pixels_nonnull'><p>Find sky pixels following the non-null criteria</p></a></li>
<li><a href='#fisheye_to_equidistant'><p>Fisheye to equidistant</p></a></li>
<li><a href='#fisheye_to_pano'><p>Fisheye to panoramic</p></a></li>
<li><a href='#fit_cie_sky_model'><p>Fit CIE sky model</p></a></li>
<li><a href='#fit_coneshaped_model'><p>Fit cone-shaped model</p></a></li>
<li><a href='#fit_trend_surface'><p>Fit a trend surface to sky digital numbers</p></a></li>
<li><a href='#fix_reconstructed_sky'><p>Fix reconstructed sky</p></a></li>
<li><a href='#gbc'><p>Gamma back correction</p></a></li>
<li><a href='#interpolate_sky_points'><p>Interpolate sky points</p></a></li>
<li><a href='#lens'><p>Access the lens database</p></a></li>
<li><a href='#local_fuzzy_thresholding'><p>Local fuzzy thresholding</p></a></li>
<li><a href='#mask_hs'><p>Mask hemisphere</p></a></li>
<li><a href='#mask_sunlit_canopy'><p>Mask sunlit canopy</p></a></li>
<li><a href='#masking'><p>Image masking</p></a></li>
<li><a href='#membership_to_color'><p>Compute the membership to a target color</p></a></li>
<li><a href='#normalize'><p>Normalize data</p></a></li>
<li><a href='#obia'><p>Do object-based image analysis of canopy photographs</p></a></li>
<li><a href='#ootb_mblt'><p>Out-of-the-box model-based local thresholding</p></a></li>
<li><a href='#ootb_obia'><p>Out-of-the-box object-based image analysis of canopy photographs</p></a></li>
<li><a href='#ootb_sky_reconstruction'><p>Out-of-the-box sky reconstruction</p></a></li>
<li><a href='#optim_normalize'><p>Optimize normalize parameters</p></a></li>
<li><a href='#percentage_of_clipped_highlights'><p>Percentage of clipped highlights</p></a></li>
<li><a href='#polar_qtree'><p>Do quad-tree segmentation in the polar space</p></a></li>
<li><a href='#qtree'><p>Do quad-tree segmentation</p></a></li>
<li><a href='#read_bin'><p>Read binarized images</p></a></li>
<li><a href='#read_caim'><p>Read a canopy image from a file</p></a></li>
<li><a href='#read_caim_raw'><p>Read a canopy image from a raw file</p></a></li>
<li><a href='#read_manual_input'><p>Read manual input</p></a></li>
<li><a href='#read_opt_sky_coef'><p>Read optimized sky coefficients</p></a></li>
<li><a href='#regional_thresholding'><p>Regional thresholding</p></a></li>
<li><a href='#rings_segmentation'><p>Do rings segmentation</p></a></li>
<li><a href='#row_col_from_zenith_azimuth'><p>Obtain row and col numbers from zenith and azimuth angles</p></a></li>
<li><a href='#sectors_segmentation'><p>Do sectors segmentation</p></a></li>
<li><a href='#sky_grid_segmentation'><p>Do sky grid segmentation</p></a></li>
<li><a href='#test_lens_coef'><p>Test lens projection functions</p></a></li>
<li><a href='#thr_isodata'><p>Calculate a threshold with the isodata method</p></a></li>
<li><a href='#thr_mblt'><p>Calculate thresholds with the model-based method</p></a></li>
<li><a href='#write_bin'><p>Write binarized images</p></a></li>
<li><a href='#write_caim'><p>Write canopy image</p></a></li>
<li><a href='#write_sky_points'><p>Write sky points</p></a></li>
<li><a href='#write_sun_coord'><p>Write sun coordinates</p></a></li>
<li><a href='#zenith_azimuth_from_row_col'><p>Obtain zenith and azimuth angles from row and col numbers</p></a></li>
<li><a href='#zenith_image'><p>Build Zenith image</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>CAnopy IMage ANalysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Classify hemispherical 
    photographs of the plant canopy with algorithms specially developed for 
    such a task and well documented in 
    Díaz and Lencinas (2015) &lt;<a href="https://doi.org/10.1109%2Flgrs.2015.2425931">doi:10.1109/lgrs.2015.2425931</a>&gt; and 
    Díaz and Lencinas (2018) &lt;<a href="https://doi.org/10.1139%2Fcjfr-2018-0006">doi:10.1139/cjfr-2018-0006</a>&gt;. It supports 
    non-circular hemispherical photography, such as those acquired with  
    15mm lenses or with auxiliary fish-eye lenses attached to mobile devices. 
    For smartphone-based hemispherical photography see 
    Díaz (2023) &lt;<a href="https://doi.org/10.1111%2F2041-210x.14059">doi:10.1111/2041-210x.14059</a>&gt;. Most of the functions also 
    support restricted view photography.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GastonMauroDiaz/rcaiman/issues">https://github.com/GastonMauroDiaz/rcaiman/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>filenamer, magrittr, colorspace, terra</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, testthat, pracma, stats, utils, Rdpack, spatial,
lidR, tcltk</td>
</tr>
<tr>
<td>Suggests:</td>
<td>autothresholdr, conicfit, EBImage, bbmle, imager, reticulate</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-14 17:50:43 UTC; gdiaz</td>
</tr>
<tr>
<td>Author:</td>
<td>Gastón Mauro Díaz <a href="https://orcid.org/0000-0002-0362-8616"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gastón Mauro Díaz &lt;gastonmaurodiaz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-14 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rcaiman-package'>rcaiman: CAnopy IMage ANalysis</h2><span id='topic+rcaiman'></span><span id='topic+rcaiman-package'></span>

<h3>Description</h3>

<p>Classify hemispherical photographs of the plant canopy with algorithms specially developed for such a task and well documented in Díaz and Lencinas (2015) <a href="https://doi.org/10.1109/lgrs.2015.2425931">doi:10.1109/lgrs.2015.2425931</a> and Díaz and Lencinas (2018) <a href="https://doi.org/10.1139/cjfr-2018-0006">doi:10.1139/cjfr-2018-0006</a>. It supports non-circular hemispherical photography, such as those acquired with 15mm lenses or with auxiliary fish-eye lenses attached to mobile devices. For smartphone-based hemispherical photography see Díaz (2023) <a href="https://doi.org/10.1111/2041-210x.14059">doi:10.1111/2041-210x.14059</a>. Most of the functions also support restricted view photography.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gastón Mauro Díaz <a href="mailto:gastonmaurodiaz@gmail.com">gastonmaurodiaz@gmail.com</a> (<a href="https://orcid.org/0000-0002-0362-8616">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/GastonMauroDiaz/rcaiman/issues">https://github.com/GastonMauroDiaz/rcaiman/issues</a>
</p>
</li></ul>


<hr>
<h2 id='apply_thr'>Apply threshold</h2><span id='topic+apply_thr'></span>

<h3>Description</h3>

<p>Global or local thresholding of images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_thr(r, thr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_thr_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A greyscale image.</p>
</td></tr>
<tr><td><code id="apply_thr_+3A_thr">thr</code></td>
<td>
<p>Numeric vector of length one or a single-layer raster from the
class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. Threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a wrapper function around the operator <code>&gt;</code> from the <code>terra</code> package. If
a single threshold value is provided as the <code>thr</code> argument, it is applied to
every pixel of the object <code>r</code>. If instead a <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> is provided,
a particular threshold is applied to each particular pixel.
</p>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with values <code>0</code> and <code>1</code>.
</p>


<h3>See Also</h3>

<p>Other Binarization Functions: 
<code><a href="#topic+obia">obia</a>()</code>,
<code><a href="#topic+ootb_mblt">ootb_mblt</a>()</code>,
<code><a href="#topic+ootb_obia">ootb_obia</a>()</code>,
<code><a href="#topic+regional_thresholding">regional_thresholding</a>()</code>,
<code><a href="#topic+thr_isodata">thr_isodata</a>()</code>,
<code><a href="#topic+thr_mblt">thr_mblt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- read_caim()
bin &lt;- apply_thr(r$Blue, thr_isodata(r$Blue[]))
plot(bin)
## Not run: 
# This function is useful in combination with the ‘autothresholdr’
# package. For example:
require(autothresholdr)
thr &lt;- auto_thresh(r$Blue[], "IsoData")[1]
bin &lt;- apply_thr(r$Blue, thr)
plot(bin)

## End(Not run)
</code></pre>

<hr>
<h2 id='azimuth_image'>Build azimuth image</h2><span id='topic+azimuth_image'></span>

<h3>Description</h3>

<p>Build a single-layer image with azimuth angles as pixel values, assuming
upwards-looking hemispherical photography with the optical axis vertically
aligned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azimuth_image(z, orientation = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="azimuth_image_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="azimuth_image_+3A_orientation">orientation</code></td>
<td>
<p>Azimuth angle (degrees) at which the top of the image was
pointing at the moment of taking the picture. This design decision was made
because the usual field protocol is recording the angle at which the top of
the camera points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with azimuth angles in degrees.
If the <code>orientation</code> argument is zero, North (0º) is pointing up as in
maps, but East (90º) and West (270º) are flipped regarding to maps. To
understand why, take two flash-card size pieces of paper; put one on a
table in front of you and draw on it a compass rose; take the other and
hold it with your arms extended over your head and, following the
directions of the compass rose in front of you, draw another one in the
paper side that is facing down&mdash;it will be an awkward position, like if
you were taking an upward-looking photo with a mobile device while looking
at the screen&mdash;; finally, put it down and compare both compass roses.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zenith_image(600, lens("Nikon_FCE9"))
a &lt;- azimuth_image(z)
plot(a)
## Not run: 
a &lt;- azimuth_image(z, 45)
plot(a)

## End(Not run)
</code></pre>

<hr>
<h2 id='calc_co'>Calculate canopy openness</h2><span id='topic+calc_co'></span>

<h3>Description</h3>

<p>Calculate canopy openness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_co(bin, m = NULL, z, a, angle_width)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_co_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. Binarized hemispherical canopy image.</p>
</td></tr>
<tr><td><code id="calc_co_+3A_m">m</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A mask. For hemispherical photographs,
check <code><a href="#topic+mask_hs">mask_hs()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_co_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_co_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_co_+3A_angle_width">angle_width</code></td>
<td>
<p>Numeric vector of length one. It should be <code style="white-space: pre;">&#8288;30, 15, 10, 7.5, 6, 5, 3.75, 3, 2.5, 1.875, 1&#8288;</code> or <code>0.5</code> degrees. This
constrain is rooted in the requirement of a value able to divide both the
<code>0</code> to <code>360</code> and <code>0</code> to <code>90</code> ranges into a whole number
of segments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Canopy openness calculated as in the equation from
Gonsamo et al. (2011):
</p>
<p><code class="reqn">CO = \sum_{i = 1}^{N} GF(\phi_i, \theta_i) \cdot [(cos(\theta_1) -
cos(\theta_2))/n]</code>,
</p>
<p>where <code class="reqn">GF(\phi_i, \theta_i)</code> is the gap fraction of the cell <code class="reqn">i</code>,
<code class="reqn">\theta_1</code> and <code class="reqn">\theta_2</code> are the minimum and maximum zenith angle of
the cell <code class="reqn">i</code>, <code class="reqn">n</code> is the number of cells on the ring delimited by
<code class="reqn">\theta_1</code> and <code class="reqn">\theta_2</code>, and <code class="reqn">N</code> is the total number of cells.
</p>
<p>When a mask is provided through the <code>m</code> argument, the equation is modified as
follow:
</p>
<p><code class="reqn">
\frac{
CO = \sum_{i = 1}^{N} GF(\phi_i, \theta_i) \cdot [(cos(\theta_1) -
cos(\theta_2))/n]
}{ \sum_{i = 1}^{N} (cos(\theta_1) - cos(\theta_2))/n}
</code>.
</p>
<p>This allows the masking of any individual cell.
</p>


<h3>Value</h3>

<p>Numeric vector of length one.
</p>


<h3>References</h3>

<p>Gonsamo A, Walter JN, Pellikka P (2011).
&ldquo;CIMES: A package of programs for determining canopy geometry and solar radiation regimes through hemispherical photographs.&rdquo;
<em>Computers and Electronics in Agriculture</em>, <b>79</b>(2), 207&ndash;215.
<a href="https://doi.org/10.1016/j.compag.2011.10.001">doi:10.1016/j.compag.2011.10.001</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caim &lt;- read_caim()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- mask_hs(z, 0, 70)
bin &lt;- apply_thr(caim$Blue, thr_isodata(caim$Blue[m]))
plot(bin)
calc_co(bin, m, z, a, 10)

</code></pre>

<hr>
<h2 id='calc_diameter'>Calculate diameter</h2><span id='topic+calc_diameter'></span>

<h3>Description</h3>

<p>Calculate the diameter in pixels of a 180º fisheye image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_diameter(lens_coef, radius, angle)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_diameter_+3A_lens_coef">lens_coef</code></td>
<td>
<p>Numeric vector. Polynomial coefficients of the lens
projection function. See <code><a href="#topic+calibrate_lens">calibrate_lens()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_diameter_+3A_radius">radius</code></td>
<td>
<p>Numeric vector. Distance in pixels from the zenith.</p>
</td></tr>
<tr><td><code id="calc_diameter_+3A_angle">angle</code></td>
<td>
<p>Numeric vector. Zenith angle in degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps handle devices with a field of view different than 180º.
Given a lens projection function and data points consisting of radii
(pixels) and their correspondent zenith angle (<code class="reqn">\theta</code>), it returns the
horizon radius (i.e., the radius for <code class="reqn">\theta</code> equal to 90º).
</p>
<p>When working with non-circular hemispherical photography, this function will
help to find the diameter that a circular image would have if the equipment
would record the whole hemisphere.
</p>
<p>The required data (radius-angle data pairs) can be obtained following the
instructions given in the
<a href="https://www.schleppi.ch/patrick/hemisfer/help/en/lens.htm">user manual of Hemisfer software</a>.
The following is a slightly simpler alternative:
</p>

<ul>
<li><p> Find a vertical wall and a leveled floor, both well-constructed.
</p>
</li>
<li><p> Draw a triangle of <code class="reqn">5 \times 4 \times 3</code> meters on the floor, with
the 4-meter side over the wall.
</p>
</li>
<li><p> Locate the camera over the vertex that is 3 meters away from the wall.
Place it at a given height above the floor, 1.3 meters for instance.
</p>
</li>
<li><p> Make a mark on the wall at the chosen height over the wall-vertex nearest
to the camera-vertex. Make four more marks with one meter of spacing and
following a horizontal line. This will create marks for 0º, 18º, 34º, 45º,
and 54º <code class="reqn">\theta</code>.
</p>
</li>
<li><p> Before taking the photograph, do not forget to align the zenith
coordinates with the 0º <code class="reqn">\theta</code> mark and check if the optical axis is
leveled.
</p>
</li></ul>

<p>The <a href="https://imagej.net/ij/docs/guide/146-19.html#toc-Subsection-19.2">line selection tool</a>
of <a href="https://imagej.net/ij/">ImageJ</a> can be used to measure
the distance in pixels between points on the image. Draw a line, and use the
dropdown menu Analyze&gt;Measure to obtain its length.
</p>
<p>For obtaining the projection of a new lens, refer to
<code><a href="#topic+calibrate_lens">calibrate_lens()</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector of length one. Diameter adjusted to a whole number
(see <code><a href="#topic+zenith_image">zenith_image()</a></code> for details about that constrain).
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Nikon D50 and Fisheye Nikkor 10.5mm lens
calc_diameter(lens("Nikkor_10.5mm"), 1202, 54)
</code></pre>

<hr>
<h2 id='calc_relative_radius'>Calculate relative radius</h2><span id='topic+calc_relative_radius'></span>

<h3>Description</h3>

<p>Calculate the relative radius given a zenith angle and lens function. This is
known as the projection function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_relative_radius(angle, lens_coef)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_relative_radius_+3A_angle">angle</code></td>
<td>
<p>Numeric vector. Zenith angles in degrees.</p>
</td></tr>
<tr><td><code id="calc_relative_radius_+3A_lens_coef">lens_coef</code></td>
<td>
<p>Numeric vector. Polynomial coefficients of the lens
projection function. See <code><a href="#topic+calibrate_lens">calibrate_lens()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>

<hr>
<h2 id='calc_zenith_colrow'>Calculate zenith raster coordinates</h2><span id='topic+calc_zenith_colrow'></span>

<h3>Description</h3>

<p>Calculate zenith raster coordinates from points digitized with the
open-source software package ‘ImageJ’. The zenith is the point on the image
that represents the zenith when upward-looking photographs are taken with the
optical axis vertically aligned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_zenith_colrow(path_to_csv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_zenith_colrow_+3A_path_to_csv">path_to_csv</code></td>
<td>
<p>Character vector. Path to a CSV file created with the
<a href="https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool">point selection tool of ‘ImageJ’ software</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The technique described under the headline ‘Optical center characterization’
of the <a href="https://www6.paca.inrae.fr/can-eye/content/download/3052/30819/version/4/file/CAN_EYE_User_Manual.pdf">user manual of the software Can-Eye</a>
can be used to acquire the data for determining the zenith coordinates. This
technique was used by Pekin and Macfarlane (2009), among others.
Briefly, it consists in drilling a small hole in the cap of the fisheye lens
(it must be away from the center of the cap), and taking about ten
photographs without removing the cap. The cap must be rotated about 30º
before taking each photograph.(<strong>NOTE:</strong>
The method implemented here does not support multiple holes).
</p>
<p>The <a href="https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool">point selection tool of ‘ImageJ’ software</a>
should be used to manually digitize the white dots and create a CSV file to
feed this function. After digitizing the points on the image, use the
dropdown menu Analyze&gt;Measure to open the Results window. To obtain the CSV
file, use File&gt;Save As...
</p>
<p>Another method&ndash;only valid when enough of the circle perimeter is depicted in
the image&ndash; is taking a very bright picture (for example, a picture of the
corner of a room with walls painted in light colors) with the lens completely
free (do not use any mount). Then, digitize points over the circle perimeter.
This was the method used for producing the example file (see Examples). It is
worth noting that the perimeter of the circle depicted in a circular
hemispherical photograph is not necessarily the horizon.
</p>


<h3>Value</h3>

<p>Numeric vector of length two. Raster coordinates of the zenith,
assuming a lens facing up with its optical axis parallel to the vertical
line. It is important to note the difference between the raster coordinates
and the Cartesian coordinates. In the latter,  the vertical axis value
decreases downward, but the opposite is true for the raster coordinates,
which works like a spreadsheet.
</p>


<h3>References</h3>

<p>Pekin B, Macfarlane C (2009).
&ldquo;Measurement of crown cover and leaf area index using digital cover photography and its application to remote sensing.&rdquo;
<em>Remote Sensing</em>, <b>1</b>(4), 1298&ndash;1320.
<a href="https://doi.org/10.3390/rs1041298">doi:10.3390/rs1041298</a>.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- system.file("external/points_over_perimeter.csv",
                    package = "rcaiman")
calc_zenith_colrow(path)

## End(Not run)
</code></pre>

<hr>
<h2 id='calibrate_lens'>Calibrate lens</h2><span id='topic+calibrate_lens'></span>

<h3>Description</h3>

<p>Calibrate a fisheye lens
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_lens(path_to_csv, degree = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrate_lens_+3A_path_to_csv">path_to_csv</code></td>
<td>
<p>Character vector. Path to a CSV file created with the
<a href="https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool">point selection tool of ‘ImageJ’ software</a>.</p>
</td></tr>
<tr><td><code id="calibrate_lens_+3A_degree">degree</code></td>
<td>
<p>Numeric vector of length one. Polynomial model degree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fisheye lenses have a wide field of view and the same distortion in all
directions running orthogonally to the optical axis. The latter property
allows fitting a precise mathematical relationship between distances to the
zenith on the image space and zenith angles on the hemispherical space
(assuming upward-looking hemispherical photography with the optical axis
vertically aligned).
</p>
<p>The method
outlined here, known as the simple method, is explained in details in
Díaz and et al. (2024). Next explanation might serve mostly
as a handbook.
</p>


<h4>Step-by-step guide for producing a CSV file to feed this function</h4>



<h5>Materials</h5>


<ul>
<li><p> this package and <a href="https://imagej.net/ij/download.html">ImageJ</a>
</p>
</li>
<li><p> camera and lens
</p>
</li>
<li><p> tripod
</p>
</li>
<li><p> standard yoga mat
</p>
</li>
<li><p> table at least as wide as the yoga mat width
</p>
</li>
<li><p> twenty two push pins of different colors
</p>
</li>
<li><p> one print of this <a href="https://osf.io/tudzc">sheet</a> (A1 size,
almost like a research poster).
</p>
</li>
<li><p> scissors
</p>
</li>
<li><p> some patience
</p>
</li></ul>




<h5>Instructions</h5>

<p>Cut the sheet by the dashed line. Place the yoga mat extended on top of the
table. Place the sheet on top of the yoga mat. Align the dashed line with the
yoga mat border closest to you. Place push pins on each cross. If you are
gentle, the yoga mat will allow you to do that without damaging the table. Of
course, other materials could be used to obtain the same result, such as
cardboard, foam, nails, etc.
</p>
<p><img src="../help/figures/calibrationBoard.jpg" alt="Calibration board" />
</p>
<p>Place the camera on the tripod. Align its optical axis with the table while
looking for getting an image showing the overlapping of the three pairs of
push pins, as instructed in the print. In order to take care of the line of
pins at 90º relative to the optical axis, it may be of help to use the naked
eye to align the entrance pupil of the lens with the pins. The alignment of
the push pins only guarantees the position of the lens entrance pupil, the
leveling should be cheeked with an instrument, and the alignment between the
optical axis and the radius of the zenith push pin should be taken into
account. In practice, the latter is achieved by aligning the camera body with
the orthogonal frame made by the quarter circle.
</p>
<p>Take a photo and transfer it to the computer, open it with ImageJ, and use
the <a href="https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool">point selection tool</a>
to digitize the push pins, starting from the zenith push pin and not skipping
any shown push pin. End with an additional point where the image meets the
surrounding black (or the last pixel in case there is not blackness because
it is not a circular hemispherical image. There is no need to follow the line
formed by the push pins). Then, use the dropdown menu Analyze&gt;Measure to open
the window Results. To obtain the CSV, use File&gt;Save As...
</p>
<p><img src="../help/figures/pushpinsImageJ.jpg" alt="Points digitization with ImageJ" />
</p>
<p>Use <code><a href="#topic+test_lens_coef">test_lens_coef()</a></code> to test if coefficients are OK.
</p>




<h3>Value</h3>

<p>An object of class <em>list</em> with named elements. <em>ds</em> is the dataset
used to fit the model, <em>model</em> is the fitted model (class <code>lm</code>, see
<code><a href="stats.html#topic+lm">stats::lm()</a></code>), <em>horizon_radius</em> is the radius at 90º, <em>lens_coef</em> is a
numeric vector of length equal to the <code>degree</code> argument containing the
polynomial model coefficients for predicting relative radius
(<code>coefficients(model)/horizon_radius</code>),
<em>zenith_colrow</em> are the raster coordinates of the zenith push pin,
<em>max_theta</em> is the maximum zenith angle in degrees, and <em>max_theta_px</em> is
the distance in pixels between the zenith and the maximum zenith angle in
pixels units.
</p>


<h3>Note</h3>

<p>If we imagine the fisheye image as an analog clock, it is possible to
calibrate 3 o'clock by attaching the camera to the tripod in landscape mode
while leaving the quarter-circle at the lens's right side. To calibrate 9
o'clock, it will be necessary to rotate the camera to put the quarter-circle
at the lens's left side. To calibrate 12 and 6 o'clock, it will be necessary
to do the same but with the camera in portrait mode. If several directions
are sampled with this procedure, a character vector of length greater than
one in which each element is a path to a CSV files could be provided as the
<code>path_to_csv</code> argument.
</p>


<h3>References</h3>

<p>Díaz GM, et al. (2024).
&ldquo;Simple calibration of fisheye lenses for hemipherical photography of the forest canopy.&rdquo;
<em>Manuscript in preparation</em>.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("external/Results_calibration.csv", package = "rcaiman")
calibration &lt;- calibrate_lens(path)
coefficients(calibration$model)
calibration$lens_coef %&gt;% signif(3)
calibration$horizon_radius

## Not run: 
test_lens_coef(calibration$lens_coef) #MacOS and Windows tend to differ here
test_lens_coef(c(0.628, 0.0399, -0.0217))

## End(Not run)

.fp &lt;- function(theta, lens_coef) {
  x &lt;- lens_coef[1:5]
  x[is.na(x)] &lt;- 0
  for (i in 1:5) assign(letters[i], x[i])
  a * theta + b * theta^2 + c * theta^3 + d * theta^4 + e * theta^5
}

plot(calibration$ds)
theta &lt;- seq(0, pi/2, pi/180)
lines(theta, .fp(theta, coefficients(calibration$model)))
</code></pre>

<hr>
<h2 id='chessboard'>Do chessboard segmentation</h2><span id='topic+chessboard'></span>

<h3>Description</h3>

<p>Do chessboard segmentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chessboard(r, size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chessboard_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>.</p>
</td></tr>
<tr><td><code id="chessboard_+3A_size">size</code></td>
<td>
<p>Numeric vector of length one. Size of the square segments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single layer image of the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with integer
values.
</p>


<h3>See Also</h3>

<p>Other Segmentation Functions: 
<code><a href="#topic+mask_hs">mask_hs</a>()</code>,
<code><a href="#topic+mask_sunlit_canopy">mask_sunlit_canopy</a>()</code>,
<code><a href="#topic+polar_qtree">polar_qtree</a>()</code>,
<code><a href="#topic+qtree">qtree</a>()</code>,
<code><a href="#topic+rings_segmentation">rings_segmentation</a>()</code>,
<code><a href="#topic+sectors_segmentation">sectors_segmentation</a>()</code>,
<code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caim &lt;- read_caim()
seg &lt;- chessboard(caim, 20)
plot(caim$Blue)
plot(extract_feature(caim$Blue, seg))
</code></pre>

<hr>
<h2 id='cie_sky_model_raster'>CIE sky model raster</h2><span id='topic+cie_sky_model_raster'></span>

<h3>Description</h3>

<p>CIE sky model raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cie_sky_model_raster(z, a, sun_coord, sky_coef)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cie_sky_model_raster_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="cie_sky_model_raster_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="cie_sky_model_raster_+3A_sun_coord">sun_coord</code></td>
<td>
<p>Numeric vector of length two. The solar disk
center represented with zenith and azimuth angles in degrees.</p>
</td></tr>
<tr><td><code id="cie_sky_model_raster_+3A_sky_coef">sky_coef</code></td>
<td>
<p>Numeric vector of length five. Parameters of the sky model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Sky Reconstruction Functions: 
<code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model</a>()</code>,
<code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model</a>()</code>,
<code><a href="#topic+fit_trend_surface">fit_trend_surface</a>()</code>,
<code><a href="#topic+fix_reconstructed_sky">fix_reconstructed_sky</a>()</code>,
<code><a href="#topic+interpolate_sky_points">interpolate_sky_points</a>()</code>,
<code><a href="#topic+ootb_sky_reconstruction">ootb_sky_reconstruction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zenith_image(50, lens())
a &lt;- azimuth_image(z)
path &lt;- system.file("external", package = "rcaiman")
skies &lt;- read.csv(file.path(path, "15_CIE_standard_skies.csv"))
# parameters are from http://dx.doi.org/10.1016/j.energy.2016.02.054
sky_coef &lt;- skies[4,1:5]
sun_coord &lt;- c(45, 0)
plot(cie_sky_model_raster(z, a, sun_coord, sky_coef))
</code></pre>

<hr>
<h2 id='colorfulness'>Quantify colorfulness</h2><span id='topic+colorfulness'></span>

<h3>Description</h3>

<p>Quantify the colorfulness of an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorfulness(caim, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colorfulness_+3A_caim">caim</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The return of a call to <code><a href="#topic+read_caim">read_caim()</a></code> or
<code><a href="#topic+read_caim_raw">read_caim_raw()</a></code>.</p>
</td></tr>
<tr><td><code id="colorfulness_+3A_m">m</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A mask. For hemispherical photographs, check
<code><a href="#topic+mask_hs">mask_hs()</a></code>. Default (<code>NULL</code>) is the equivalent to enter
<code>!is.na(caim$Red)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantify the colorfulness of an sRGB image using a bidimensional space formed
by the green/red and the blue/yellow axes of the <em>CIE LAB</em> space,
symbolized with <em>A</em> and <em>B</em>, respectively. The colorfulness index
(CI) is defined as
</p>
<p><code class="reqn">CI = \dfrac{A_o}{A_p} \cdot 100</code>,
</p>
<p>where <code class="reqn">A_o</code> and <code class="reqn">A_p</code> are the observed and potential area of the
<em>AB</em> plane. <code class="reqn">A_o</code> refers to the colors from the image while
<code class="reqn">A_p</code> to the colors from the whole sRGB cube.
</p>


<h3>Value</h3>

<p>A numeric vector of length one.
</p>


<h3>Note</h3>

<p>An early version of this function was used in
Martin et al. (2020).
</p>


<h3>References</h3>

<p>Martin DA, Wurz A, Osen K, Grass I, Hölscher D, Rabemanantsoa T, Tscharntke T, Kreft H (2020).
&ldquo;Shade-Tree Rehabilitation in Vanilla Agroforests is Yield Neutral and May Translate into Landscape-Scale Canopy Cover Gains.&rdquo;
<em>Ecosystems</em>, <b>24</b>(5), 1253&ndash;1267.
<a href="https://doi.org/10.1007/s10021-020-00586-5">doi:10.1007/s10021-020-00586-5</a>.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caim &lt;- read_caim() %&gt;% normalize()
colorfulness(caim)
</code></pre>

<hr>
<h2 id='correct_vignetting'>Correct vignetting effect</h2><span id='topic+correct_vignetting'></span>

<h3>Description</h3>

<p>Correct vignetting effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_vignetting(r, z, lens_coef_v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_vignetting_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A fish-eye image.</p>
</td></tr>
<tr><td><code id="correct_vignetting_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="correct_vignetting_+3A_lens_coef_v">lens_coef_v</code></td>
<td>
<p>Numeric vector. Coefficients of a vignetting
function (<code class="reqn">f_v</code>) of the type <code class="reqn">f_v = 1 + a \cdot \theta +
  b \cdot \theta^2 + ... + m \cdot \theta^n</code>, where <code class="reqn">\theta</code> is the
zenith angle, <code class="reqn">a, b, c</code> and <code class="reqn">m</code> are the coefficients. The maximum
polynomial degree supported is fifth. See <code><a href="#topic+extract_radiometry">extract_radiometry()</a></code> for
additional details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The argument <code>r</code> but with corrected values.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("external/DSCN4500.JPG", package = "rcaiman")
caim &lt;- read_caim(path, c(1250, 1020) - 745, 745 * 2, 745 * 2)
z &lt;- zenith_image(ncol(caim), lens("Nikon_FCE9"))
r &lt;- gbc(caim$Blue)
r
r &lt;- correct_vignetting(r, z, c(0.0638, -0.101))
r
</code></pre>

<hr>
<h2 id='crop_caim'>Crop a canopy image from a file</h2><span id='topic+crop_caim'></span>

<h3>Description</h3>

<p>Function that complements <code><a href="#topic+read_caim">read_caim()</a></code> and <code><a href="#topic+read_caim_raw">read_caim_raw()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_caim(r, upper_left = NULL, width = NULL, height = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crop_caim_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></p>
</td></tr>
<tr><td><code id="crop_caim_+3A_upper_left">upper_left</code></td>
<td>
<p>An integer vector of length two. The pixels coordinates of
the upper left corner of a region of interest (ROI). These coordinates
should be in the raster coordinates system. This system works like a
spreadsheet, i.e, when going down through the vertical axis, the <em>row</em>
number increases (<strong>IMPORTANT</strong>: column and row must be provided instead of
row and column, as is the norm for objects from the class <em>data.frame</em> and
others alike)</p>
</td></tr>
<tr><td><code id="crop_caim_+3A_width">width</code>, <code id="crop_caim_+3A_height">height</code></td>
<td>
<p>An integer vector of length one. The size of the boxy ROI
whose upper left corner is the <code>upper_left</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caim &lt;- read_caim()
ncell(caim)
caim &lt;- crop_caim(caim, c(231,334), 15, 10)
ncell(caim)
</code></pre>

<hr>
<h2 id='crosscalibrate_lens'>Cross-calibrate lens</h2><span id='topic+crosscalibrate_lens'></span>

<h3>Description</h3>

<p>Cross-calibrate lens
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosscalibrate_lens(
  path_to_csv_uncal,
  path_to_csv_cal,
  zenith_colrow_uncal,
  zenith_colrow_cal,
  diameter_cal,
  lens_coef,
  degree = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crosscalibrate_lens_+3A_path_to_csv_uncal">path_to_csv_uncal</code>, <code id="crosscalibrate_lens_+3A_path_to_csv_cal">path_to_csv_cal</code></td>
<td>
<p>Character vector of length one. Path
to a CSV file created with the
<a href="https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool">point selection tool of ‘ImageJ’ software</a>
(<em>cal</em> and <em>uncal</em> stand for calibrated and uncalibrated, respectively).</p>
</td></tr>
<tr><td><code id="crosscalibrate_lens_+3A_zenith_colrow_uncal">zenith_colrow_uncal</code>, <code id="crosscalibrate_lens_+3A_zenith_colrow_cal">zenith_colrow_cal</code></td>
<td>
<p>Numeric vector of length two.
Raster coordinates of the zenith. See
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow()</a></code> (<em>cal</em> and <em>uncal</em> stand
for calibrated and uncalibrated, respectively).</p>
</td></tr>
<tr><td><code id="crosscalibrate_lens_+3A_diameter_cal">diameter_cal</code></td>
<td>
<p>Numeric vector of length one. Diameter in pixels of the
image taken with the calibrated camera.</p>
</td></tr>
<tr><td><code id="crosscalibrate_lens_+3A_lens_coef">lens_coef</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="crosscalibrate_lens_+3A_degree">degree</code></td>
<td>
<p>Numeric vector of length one. Polynomial model degree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read the help page of <code><a href="#topic+calibrate_lens">calibrate_lens()</a></code> for understanding the theory
being this function.
</p>
<p>This function is intended to be used when a camera calibrated with a method
of higher accuracy than the one proposed in <code><a href="#topic+calibrate_lens">calibrate_lens()</a></code> is
available or there is a main camera to which all other devices should be
adjusted.
</p>
<p>It requires two photographs taken from the exact same location with the
calibrated and uncalibrated camera. This means that the lens entrance pupils
should match and the optical axes should be aligned.
</p>
<p>Points should be digitized in tandem with ImageJ and saved as CSV files.
</p>


<h3>Value</h3>

<p>An object of class <em>list</em> with named elements. <em>ds</em> is the dataset
used to fit the model, <em>model</em> is the fitted model (class <code>lm</code>, see
<code><a href="stats.html#topic+lm">stats::lm()</a></code>), <em>horizon_radius</em> is the radius at 90º, <em>lens_coef</em> is a
numeric vector of length equal to the <code>degree</code> argument containing the
polynomial model coefficients for predicting relative radius
(<code>coefficients(model)/horizon_radius</code>).
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>

<hr>
<h2 id='defuzzify'>Defuzzify a fuzzy classification</h2><span id='topic+defuzzify'></span>

<h3>Description</h3>

<p>This function translates degree of membership into Boolean logic using a
regional approach. The result will ensure that the fuzzy and Boolean version
will agree at the chosen level of aggregation (controlled by the argument
<code>segmentation</code>). This method makes perfect sense to translate a subpixel
classification of gap fraction (or a linear ratio) into a binary product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defuzzify(mem, segmentation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defuzzify_+3A_mem">mem</code></td>
<td>
<p>An object of the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. Degree of
membership.</p>
</td></tr>
<tr><td><code id="defuzzify_+3A_segmentation">segmentation</code></td>
<td>
<p>An object of the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> such as
the result of a call to <code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> containing binary
information.
</p>


<h3>Note</h3>

<p>This method is also available in the HSP software package
(Lang et al. 2013).
</p>


<h3>References</h3>

<p>Lang M, Kodar A, Arumäe T (2013).
&ldquo;Restoration of above canopy reference hemispherical image from below canopy measurements for plant area index estimation in forests.&rdquo;
<em>Forestry Studies</em>, <b>59</b>(1), 13&ndash;27.
<a href="https://doi.org/10.2478/fsmu-2013-0008">doi:10.2478/fsmu-2013-0008</a>.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- system.file("external/DSCN4500.JPG", package = "rcaiman")
caim &lt;- read_caim(path, c(1250, 1020) - 745, 745 * 2, 745 * 2)
z &lt;- zenith_image(ncol(caim), lens("Nikon_FCE9"))
a &lt;- azimuth_image(z)
r &lt;- gbc(caim$Blue)
r &lt;- correct_vignetting(r, z, c(0.0638, -0.101)) %&gt;% normalize()
bin &lt;- find_sky_pixels(r, z, a)
bin &lt;- ootb_mblt(r, z, a, bin)
plot(bin$bin)
ratio &lt;- r / bin$sky_s
ratio &lt;- normalize(ratio, 0, 1, TRUE)
plot(ratio)
g &lt;- sky_grid_segmentation(z, a, 10)
bin2 &lt;- defuzzify(ratio, g)
plot(bin2)
plot(abs(bin$bin - bin2))

## End(Not run)
</code></pre>

<hr>
<h2 id='enhance_caim'>Enhance canopy image</h2><span id='topic+enhance_caim'></span>

<h3>Description</h3>

<p>This function was first proposed in Díaz and Lencinas (2015).
It uses the color perceptual attributes (hue, lightness, and chroma) to
enhance the contrast between the sky and plants through fuzzy classification.
It applies the next classification rules (here expressed in natural
language): clear sky is blue and clouds decrease its chroma; if clouds are
highly dense, then the sky is achromatic, and, in such cases, it can be light
or dark; everything that does not match this description is not sky. These
linguistic rules were translated to math language by means of fuzzy logic.
This translation was thoughtfully explained in the aforementioned article.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enhance_caim(
  caim,
  m = NULL,
  sky_blue = NULL,
  sigma = NULL,
  w_red = 0,
  thr = NULL,
  fuzziness = NULL,
  gamma = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enhance_caim_+3A_caim">caim</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The return of a call to <code><a href="#topic+read_caim">read_caim()</a></code> or
<code><a href="#topic+read_caim_raw">read_caim_raw()</a></code>.</p>
</td></tr>
<tr><td><code id="enhance_caim_+3A_m">m</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A mask. For hemispherical photographs, check
<code><a href="#topic+mask_hs">mask_hs()</a></code>.</p>
</td></tr>
<tr><td><code id="enhance_caim_+3A_sky_blue">sky_blue</code></td>
<td>
<p><a href="colorspace.html#topic+color-class">color</a>. Is the <code>target_color</code> argument to be passed to
<code><a href="#topic+membership_to_color">membership_to_color()</a></code>. Default (<code>NULL</code>) is the equivalent to enter
<code>sRGB(0.1, 0.4, 0.8)</code>&ndash;the HEX color code is #1A66CC, it can be entered
into a search engine (such as Mozilla Firefox) to see a color swatch.</p>
</td></tr>
<tr><td><code id="enhance_caim_+3A_sigma">sigma</code></td>
<td>
<p>Numeric vector of length one. Use <code>NULL</code> (default) to estimate
it automatically as the euclidean distance between <code>target_color</code> and grey
in the <em>CIE LAB</em> color space.</p>
</td></tr>
<tr><td><code id="enhance_caim_+3A_w_red">w_red</code></td>
<td>
<p>Numeric vector of length one. Weight of the red channel. A
single layer image is calculated as a weighted average of the blue and red
channels. This layer is used as lightness information. The weight of the
blue is the complement of <code>w_red</code>.</p>
</td></tr>
<tr><td><code id="enhance_caim_+3A_thr">thr</code></td>
<td>
<p>Numeric vector of length one. Location parameter of the logistic
membership function. Use <code>NULL</code> to estimate it automatically with
<code><a href="#topic+thr_isodata">thr_isodata()</a></code>.</p>
</td></tr>
<tr><td><code id="enhance_caim_+3A_fuzziness">fuzziness</code></td>
<td>
<p>Numeric vector of length one. This number is a constant
value that scales <code>mem</code>. Use <code>NULL</code> to estimate it automatically as the
midpoint between the maximum and minimum values of <code>lightness</code>.</p>
</td></tr>
<tr><td><code id="enhance_caim_+3A_gamma">gamma</code></td>
<td>
<p>Numeric vector of length one. This is for applying a gamma back
correction to the lightness information (see Details and argument <code>w_red</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a pixel-wise methodology that evaluates the possibility for a pixel
to be member of the class <em>Gap</em>. High score could mean either high membership
to <code>sky_blue</code> or, in the case of achromatic pixels, a high membership to
values above <code>thr</code>. The algorithm internally uses <code><a href="#topic+membership_to_color">membership_to_color()</a></code> and
<code><a href="#topic+local_fuzzy_thresholding">local_fuzzy_thresholding()</a></code>. The argument <code>sky_blue</code> is the <code>target_color</code>
of the former function and its output is the argument <code>mem</code> of the latter
function.
</p>
<p>The argument <code>sky_blue</code> can be obtained from a photograph that clearly shows
the sky. Then, it can be used to process all the others photograph taken with
the same equipment, configuration, and protocol.
</p>
<p>Via the <code>gamma</code> argument, <code><a href="#topic+gbc">gbc()</a></code> can be internally used to back-correct the
values passed to <code><a href="#topic+local_fuzzy_thresholding">local_fuzzy_thresholding()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> (with same pixel dimensions
than <code>caim</code>) that should show more contrast between the sky and plant
pixels than any of the individual bands from <code>caim</code>; if not, different
parameters should be tested.
</p>


<h3>Note</h3>

<p>If you use this function in your research, please cite
Díaz and Lencinas (2015) in addition to this package
(<code style="white-space: pre;">&#8288;citation("rcaiman"&#8288;</code>).
</p>
<p>The default value of argument <code>m</code> is the equivalent to enter
<code>!is.na(caim$Red)</code>. See the Details section in <code><a href="#topic+local_fuzzy_thresholding">local_fuzzy_thresholding()</a></code>
to understand how this argument can modify the output.
</p>


<h3>References</h3>

<p>Díaz GM, Lencinas JD (2015).
&ldquo;Enhanced gap fraction extraction from hemispherical photography.&rdquo;
<em>IEEE Geoscience and Remote Sensing Letters</em>, <b>12</b>(8), 1785&ndash;1789.
<a href="https://doi.org/10.1109/lgrs.2015.2425931">doi:10.1109/lgrs.2015.2425931</a>.
</p>


<h3>See Also</h3>

<p>Other Pre-processing Functions: 
<code><a href="#topic+gbc">gbc</a>()</code>,
<code><a href="#topic+local_fuzzy_thresholding">local_fuzzy_thresholding</a>()</code>,
<code><a href="#topic+membership_to_color">membership_to_color</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)

mn &lt;- quantile(caim$Blue[m], 0.01)
mx &lt;- quantile(caim$Blue[m], 0.99)
r &lt;- normalize(caim$Blue, mn, mx, TRUE)

bin &lt;- find_sky_pixels(r, z, a)
mblt &lt;- ootb_mblt(r, z, a, bin)

mx &lt;- optim_normalize(caim, mblt$bin)
mn &lt;- min(caim[m])

sky_blue_sample &lt;- crop_caim(caim, c(327, 239), 41, 89)
plotRGB(normalize(sky_blue_sample, mn, mx, TRUE)*255)
sky_blue &lt;- apply(sky_blue_sample[], 2, median) %&gt;%
  normalize(., mn, mx) %&gt;%
  as.numeric() %&gt;%
  matrix(., ncol = 3) %&gt;%
  sRGB()
hex(sky_blue)
# Use hex() to obtain the HEX color code. To see a color swatch, enter the
# HEX code into a search engine (such as Mozilla Firefox).
# NOTE: see extract_dn() for an alternative method to obtain sky_blue

as(sky_blue, "HSV") #saturatio (S) is low
# To obtain same hue (H) but greater saturation
sky_blue &lt;- HSV(239, 0.85, 0.5) %&gt;% as(., "sRGB") %&gt;% as(., "LAB")
hex(sky_blue)

caim &lt;- normalize(caim, mx = mx, force_range = TRUE)
ecaim &lt;- enhance_caim(caim, m, sky_blue = sky_blue)
plot(ecaim)
plot(caim$Blue)

## to compare
plot(apply_thr(ecaim, thr_isodata(ecaim[m])))
plot(apply_thr(caim$Blue, thr_isodata(caim$Blue[m])))

## End(Not run)
</code></pre>

<hr>
<h2 id='expand_noncircular'>Expand non-circular</h2><span id='topic+expand_noncircular'></span>

<h3>Description</h3>

<p>Expand a non-circular hemispherical photograph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_noncircular(caim, z, zenith_colrow)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_noncircular_+3A_caim">caim</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The return of a call to <code><a href="#topic+read_caim">read_caim()</a></code> or
<code><a href="#topic+read_caim_raw">read_caim_raw()</a></code>.</p>
</td></tr>
<tr><td><code id="expand_noncircular_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="expand_noncircular_+3A_zenith_colrow">zenith_colrow</code></td>
<td>
<p>Numeric vector of length two. Raster coordinates of the
zenith. See <code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> that is the result of adding
margins (<code>NA</code> pixels) to <code>caim</code>. The zenith point depicted in the picture
should be in the center of the image or very close to it.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

 # ====================================================================
 # Non-circular Fisheye images from a Smartphone with an Auxiliary Lens
 # (Also applicable to Non-circular images from DSLR cameras)
 # ====================================================================

 path &lt;- system.file("external/APC_0581.jpg", package = "rcaiman")
 caim &lt;- read_caim(path)
 z &lt;- zenith_image(2132/2,  c(0.7836, 0.1512, -0.1558))
 a &lt;- azimuth_image(z)
 zenith_colrow &lt;- c(1063, 771)/2
 caim &lt;- expand_noncircular(caim, z, zenith_colrow)
 plot(caim$Blue, col = seq(0,1,1/255) %&gt;% grey())
 m &lt;- !is.na(caim$Red) &amp; !is.na(z)
 plot(m, add = TRUE, alpha = 0.3, legend = FALSE)


 # ============================
 # Restricted View Canopy Photo
 # ============================

 path &lt;- system.file("external/APC_0020.jpg", package = "rcaiman")
 caim &lt;- read_caim(path)
 plot(caim)
 caim &lt;- normalize(caim)
 diameter &lt;- calc_diameter(lens(), sqrt(nrow(caim)^2 + ncol(caim)^2)/2, 90)
 z &lt;- zenith_image(diameter, lens())
 caim &lt;- expand_noncircular(caim, z, c(ncol(caim)/2, nrow(caim)/2))
 m &lt;- !is.na(caim$Red)
 a &lt;- azimuth_image(z)
 caim[!m] &lt;- 0
 z &lt;- normalize(z, 0, 90) * 30.15 #60.3º diagonal FOV according to metadata
 plot(caim$Blue, col = seq(0,1,1/255) %&gt;% grey())
 m &lt;- !is.na(caim$Red) &amp; !is.na(z)
 plot(m, add = TRUE, alpha = 0.3, legend = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_dn'>Extract digital numbers</h2><span id='topic+extract_dn'></span>

<h3>Description</h3>

<p>Wrapper function around <code><a href="terra.html#topic+extract">terra::extract()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_dn(r, img_points, use_window = TRUE, fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_dn_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A fish-eye image.</p>
</td></tr>
<tr><td><code id="extract_dn_+3A_img_points">img_points</code></td>
<td>
<p>The result of a call to <code><a href="#topic+extract_sky_points">extract_sky_points()</a></code>,
or an object of the same class and structure.</p>
</td></tr>
<tr><td><code id="extract_dn_+3A_use_window">use_window</code></td>
<td>
<p>Logical vector of length one. If <code>TRUE</code>, a <code class="reqn">3
 \times 3</code> window will be used to extract the digital number from
<code>r</code>.</p>
</td></tr>
<tr><td><code id="extract_dn_+3A_fun">fun</code></td>
<td>
<p>A <code>function</code> that takes a vector as input and returns a
one-length numeric or logical vector as output (e.g. mean).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <em>data.frame</em>. It is the argument
<code>img_points</code> with an added column per each layer from <code>r</code>. The
layer names are used to name the new columns. If a function is provided as
the <code>fun</code> argument, the result will be summarized per column using the
provided function, and the <em>row</em> and <em>col</em> information will be
omitted. Moreover, if <code>r</code> is an RGB image, a <a href="colorspace.html#topic+color-class">color</a> will
be returned instead of a <em>data.frame</em>. The latter feature is useful
for obtaining  the <code>sky_blue</code> argument for <code><a href="#topic+enhance_caim">enhance_caim()</a></code>.
</p>


<h3>Note</h3>

<p>The <a href="https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool">point selection tool of ‘ImageJ’ software</a>
can be used to manually digitize points and create a CSV file from which to read
coordinates (see Examples). After digitizing the points on the image, use the
dropdown menu Analyze&gt;Measure to open the Results window. To obtain the CSV
file, use File&gt;Save As...
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
r &lt;- caim$Blue
bin &lt;- apply_thr(r, thr_isodata(r[]))
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
g &lt;- sky_grid_segmentation(z, a, 10)
sky_points &lt;- extract_sky_points(r, bin, g)
sky_points &lt;- extract_dn(caim, sky_points)
head(sky_points)

# ImageJ can be used to digitize points
path &lt;- system.file("external/sky_points.csv",
                    package = "rcaiman")
sky_points &lt;- read.csv(path)
sky_points &lt;- sky_points[c("Y", "X")]
colnames(sky_points) &lt;- c("row", "col")
head(sky_points)
plot(bin)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)
extract_dn(caim, sky_points, fun = median)

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_feature'>Extract feature</h2><span id='topic+extract_feature'></span>

<h3>Description</h3>

<p>Extract features from raster images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_feature(
  r,
  segmentation,
  fun = mean,
  return_raster = TRUE,
  ignore_label_0 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_feature_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. Single layer raster.</p>
</td></tr>
<tr><td><code id="extract_feature_+3A_segmentation">segmentation</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The segmentation of <code>r</code>.</p>
</td></tr>
<tr><td><code id="extract_feature_+3A_fun">fun</code></td>
<td>
<p>A <code>function</code> that takes a vector as input and returns a
one-length numeric or logical vector as output (e.g. mean).</p>
</td></tr>
<tr><td><code id="extract_feature_+3A_return_raster">return_raster</code></td>
<td>
<p>Logical vector of length one, see details.</p>
</td></tr>
<tr><td><code id="extract_feature_+3A_ignore_label_0">ignore_label_0</code></td>
<td>
<p>Logical vector of length one. If this is <code>TRUE</code>,
the segment labeled with <code>0</code> will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a single-layer raster, a segmentation, and a function,
<code>extract_features</code> will return a numeric vector or a <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>
depending on whether the parameter <code>return_raster</code> is <code>TRUE</code> or <code>FALSE</code>. For
the first case, each pixel of each segment will adopt the respective
extracted feature value. For the second case, the return will be a vector of
length equal to the total number of segments. Each value will be obtained by
processing all pixels that belong to a segment with the provided function.
</p>


<h3>Value</h3>

<p>If <code>return_raster</code> is set to <code>TRUE</code>, then an object of
class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with the same pixel dimensions than <code>r</code>
will be returned. Otherwise, the return is a numeric vector of length equal
to the number of segments found in <code>segmentation</code>.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- read_caim()
z &lt;- zenith_image(ncol(r),lens())
a &lt;- azimuth_image(z)
g &lt;- sky_grid_segmentation(z, a, 10)
print(extract_feature(r$Blue, g, return_raster = FALSE))
# plot(extract_feature(r$Blue, g, return_raster = TRUE))
</code></pre>

<hr>
<h2 id='extract_radiometry'>Extract radiometry data</h2><span id='topic+extract_radiometry'></span>

<h3>Description</h3>

<p>Extract radiometry from images taken with the aid of a portable light source
and the calibration board detailed in <code><a href="#topic+calibrate_lens">calibrate_lens()</a></code>. The end goal is to
obtain the data required to model the vignetting effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_radiometry(l, size_px = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_radiometry_+3A_l">l</code></td>
<td>
<p>List of prepossessed images (<a href="terra.html#topic+SpatRaster-class">SpatRaster</a>) for radiometry
sampling. These images must comply with the equidistant projection.</p>
</td></tr>
<tr><td><code id="extract_radiometry_+3A_size_px">size_px</code></td>
<td>
<p>Numeric vector of length one. Diameter in pixels of the
circular sampling area at the image center. This area is modified
considering the equidistant projection distortion. Therefore, it will be
visualized as an ellipse at any other place but the image center.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lenses have the inconvenient property of increasingly attenuating light in
the direction orthogonal to the optical axis. This phenomenon is known as the
vignetting effect and varies with lens model and aperture setting. The method
outlined here, known as the simple method, is explained in details in
Díaz and et al. (2024). Next explanation might serve mostly
as a quick recap of it.
</p>
<p>The development of the simple method was done with a Kindle Paperwhite eBooks
reader of 6&quot; with built-in light. However, an iPhone 6 plus was also tested
in the early stages of development and no substantial differences were
observed. A metal bookends desk book holder was used to fasten the eBook
reader upright and a semi-transparent paper to favor a Lambertian light
distribution. In addition, the latter was used to draw on in order to
guide pixel sampling. The book holder also facilitated the alignment of the
screen with the dotted lines of the printed quarter-circle.
</p>
<p><img src="../help/figures/lightSource.jpg" alt="Portable light source" />
</p>
<p>As a general guideline, a wide variety of mobile devices could be used as
light sources, but if scattered data points are obtained with it, then other
light sources should be tested in order to double check that the light
quality is not the reason for points scattering.
</p>
<p>With the room only illuminated by the portable light source, nine photographs
should be taken with the light source located in the equivalent to 0, 10, 20,
30, 40, 50, 60, 70, and 80 degrees of zenith angle, respectively. Camera
configuration should be in manual mode and set with the aperture (f/number)
for which a vignetting function is required. The shutter speed should be
regulated to obtain light-source pixels with middle grey values. The nine
photographs should be taken <strong>without changing the camera configuration or
the light conditions</strong>.
</p>
<p><img src="../help/figures/calibrationBoardVignetting.jpg" alt="Obtaining radiometric data" />
</p>
<p>This code exemplify how to use the function to obtain the data and base R
functions to obtain the vignetting function (<code class="reqn">f_v</code>).
</p>
<div class="sourceCode"><pre>.read_raw &lt;- function(path_to_raw_file) {
  r &lt;- read_caim_raw(path_to_raw_file, z, a, zenith_colrow,
                     radius = 500, only_blue = TRUE)
  r
}

l &lt;- Map(.read_raw, dir("raw/up/", full.names = TRUE))
up_data &lt;- extract_radiometry(l)
l &lt;- Map(.read_raw, dir("raw/down/", full.names = TRUE))
down_data &lt;- extract_radiometry(l)
l &lt;- Map(.read_raw, dir("raw/right/", full.names = TRUE))
right_data &lt;- extract_radiometry(l)
l &lt;- Map(.read_raw, dir("raw/left/", full.names = TRUE))
left_data &lt;- extract_radiometry(l)

ds &lt;- rbind(up_data, down_data, right_data, left_data)

plot(ds, xlim = c(0, pi/2), ylim= c(0.5,1.05),
      col = c(rep(1,9),rep(2,9),rep(3,9),rep(4,9)))
legend("bottomleft", legend = c("up", "down", "right", "left"),
       col = 1:4, pch = 1)

fit &lt;- lm((1 - ds$radiometry) ~ poly(ds$theta, 3, raw = TRUE) - 1)
summary(fit)
coef &lt;- -fit$coefficients #did you notice the minus sign?
.fv &lt;- function(x) 1 + coef[1] * x + coef[2] * x^2 + coef[3] * x^3
curve(.fv, add = TRUE, col = 2)
coef

</pre></div>
<p>Once one of the aperture settings is calibrated, it can be used to calibrate
all the rest. To do so,  the equipment should be used to take photographs in
all desired exposition and without moving the camera, including the aperture
already calibrated and preferably under an open sky in stable diffuse light
conditions. The same procedure, which minor adaptations, is applicable to
cross-camera calibration. Below code could be used as a template.
</p>
<div class="sourceCode"><pre>zenith_colrow &lt;- c(1500, 997)*2
diameter &lt;- 947*4
z &lt;- zenith_image(diameter, c(0.689, 0.0131, -0.0295))
a &lt;- azimuth_image(z)

files &lt;- dir("raw/", full.names = TRUE)
l &lt;- list()
for (i in seq_along(files)) {
  if (i == 1) {
    # because the first aperture was the one already calibrated
    lens_coef_v &lt;- c(0.0302, -0.320, 0.0908)
  } else {
    lens_coef_v &lt;- NULL
  }
  l[[i]] &lt;- read_caim_raw(files[i], z, a, zenith_colrow,
                          radius = 500,
                          only_blue = TRUE,
                          lens_coef_v = lens_coef_v)
}

ref &lt;- l[[1]]
rings &lt;- rings_segmentation(zenith_image(ncol(ref), lens()), 3)
theta &lt;- seq(1.5, 90 - 1.5, 3) * pi/180

.fun &lt;- function(r) {
  r &lt;- extract_feature(r, rings, return_raster = FALSE)
  r/r[1]
}

l &lt;- Map(.fun, l)

.fun &lt;- function(x) {
  x / l[[1]][] # because the first is the one already calibrated
}
radiometry &lt;- Map(.fun, l)

l &lt;- list()
for (i in 2:length(radiometry)) {
  l[[i-1]] &lt;- data.frame(theta = theta, radiometry = radiometry[[i]][])
}
ds &lt;- l[[1]]
head(ds)
# The result is one dataset (ds) for each file. This is all what it is needed
# before using base R functions to fit a vignetting function

</pre></div>


<h3>Value</h3>

<p>An object from the class <code>data.frame</code> with columns <em>theta</em> (zenith
angle in radians) and <em>radiometry</em> (digital number (DN) or relative digital
number (RDN), depending on argument <code>z_thr</code>.
</p>


<h3>References</h3>

<p>Díaz GM, et al. (2024).
&ldquo;Simple calibration of fisheye lenses for hemipherical photography of the forest canopy.&rdquo;
<em>Manuscript in preparation</em>.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>

<hr>
<h2 id='extract_rl'>Extract relative luminance</h2><span id='topic+extract_rl'></span>

<h3>Description</h3>

<p>Extract the luminance relative to the zenith digital number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_rl(r, z, a, sky_points, no_of_points = 3, z_thr = 5, use_window = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_rl_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_rl_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_rl_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_rl_+3A_sky_points">sky_points</code></td>
<td>
<p>An object of class <em>data.frame</em>. The result of a call
to <code><a href="#topic+extract_sky_points">extract_sky_points()</a></code>. As an alternative, both
<a href="https://imagej.net/ij/">ImageJ</a> and HSP software
package (Lang et al. 2013) can be used to manually digitize
points. See <code><a href="#topic+extract_dn">extract_dn()</a></code> and
<code><a href="#topic+read_manual_input">read_manual_input()</a></code> for details.</p>
</td></tr>
<tr><td><code id="extract_rl_+3A_no_of_points">no_of_points</code></td>
<td>
<p>Numeric vector of length one. The number of near-zenith
points required for the estimation of the zenith DN.</p>
</td></tr>
<tr><td><code id="extract_rl_+3A_z_thr">z_thr</code></td>
<td>
<p>Numeric vector on length one. The starting maximum zenith angle
used to search for near-zenith points.</p>
</td></tr>
<tr><td><code id="extract_rl_+3A_use_window">use_window</code></td>
<td>
<p>Logical vector of length one. If <code>TRUE</code>, a <code class="reqn">3
 \times 3</code> window will be used to extract the digital number from
<code>r</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The search for near-zenith points starts in the region  ranged between
<code>0</code> and <code>z_thr</code>. If the number of near-zenith points is less than
<code>no_of_points</code>, the region increases by steps of <code>2</code> degrees of
zenith angle till the required number of points is reached.
</p>


<h3>Value</h3>

<p>A list of three objects, <em>zenith_dn</em> and <em>max_zenith_angle</em>
from the class <em>numeric</em>, and <em>sky_points</em> from the class
<em>data.frame</em>; <em>zenith_dn</em> is the estimated zenith digital number,
<em>max_zenith_angle</em> is the maximum zenith angle reached in the search
for near-zenith sky points, and <em>sky_points</em> is the input argument
<code>sky_points</code> with the additional columns: <em>a</em>, <em>z</em>,
<em>dn</em>, and <em>rl</em>, which stand for azimuth and zenith angle in
degrees, digital number, and relative luminance, respectively. If
<code>NULL</code> is provided as <code>no_of_points</code>, then <em>zenith_dn</em> is
forced to one and, therefore, <em>dn</em> and <em>rl</em> will be identical.
</p>


<h3>Note</h3>

<p>The <a href="https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool">point selection tool of ‘ImageJ’ software</a>
can be used to manually digitize points and create a CSV file from which to
read coordinates (see Examples). After digitizing the points on the image,
use the dropdown menu Analyze&gt;Measure to open the Results window. To obtain
the CSV file, use File&gt;Save As...
</p>


<h3>References</h3>

<p>Lang M, Kodar A, Arumäe T (2013).
&ldquo;Restoration of above canopy reference hemispherical image from below canopy measurements for plant area index estimation in forests.&rdquo;
<em>Forestry Studies</em>, <b>59</b>(1), 13&ndash;27.
<a href="https://doi.org/10.2478/fsmu-2013-0008">doi:10.2478/fsmu-2013-0008</a>.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim() %&gt;% normalize(., 0, 20847)
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
plotRGB(caim*255)

path &lt;- system.file("external/sky_points.csv",
                    package = "rcaiman")
sky_points &lt;- read.csv(path)
sky_points &lt;- sky_points[c("Y", "X")]
colnames(sky_points) &lt;- c("row", "col")
head(sky_points)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)
extract_rl(caim$Blue, z, a, sky_points, 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_sky_points'>Extract sky points</h2><span id='topic+extract_sky_points'></span>

<h3>Description</h3>

<p>Extract sky points for model fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_sky_points(r, bin, g, dist_to_plant = 3, min_raster_dist = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_sky_points_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_sky_points_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. This should be a preliminary binarization of
<code>r</code> useful for masking pixels that are very likely pure sky pixels.</p>
</td></tr>
<tr><td><code id="extract_sky_points_+3A_g">g</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation()</a></code> or
<code><a href="#topic+chessboard">chessboard()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_sky_points_+3A_dist_to_plant">dist_to_plant</code>, <code id="extract_sky_points_+3A_min_raster_dist">min_raster_dist</code></td>
<td>
<p>Numeric vector of length one or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will automatically sample sky pixels from the sky regions
delimited by <code>bin</code>. The density and distribution of the sampling points is
controlled by the arguments <code>g</code>, <code>dist_to_plant</code>, and <code>min_raster_dist</code>.
</p>
<p>As the first step, sky pixels from <code>r</code> are evaluated to find the pixel with
maximum digital value (local maximum) per cell of the <code>g</code> argument. The
<code>dist_to_plant</code> argument allows users to establish a buffer zone for <code>bin</code>,
meaning a size reduction of the original sky regions.
</p>
<p>The final step is filtering these local maximum values by evaluating the
Euclidean distances between them on the raster space. Any new point with a
distance from existing points minor than <code>min_raster_dist</code> is discarded. Cell
labels determine the order in which the points are evaluated.
</p>
<p>To skip a given filtering step, use code <code>NULL</code> as argument input. For
instance, <code>min_raster_dist = NULL</code> will return points omitting
the final step.
</p>


<h3>Value</h3>

<p>An object of the class <em>data.frame</em> with two columns named
<em>row</em> and <em>col</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model()</a></code>
</p>
<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
r &lt;- caim$Blue
caim &lt;- normalize(caim, 0, 20847, TRUE)
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
plotRGB(caim*255)
bin &lt;- ootb_obia(caim, z, a, HSV(239, 0.85, 0.5), gamma = NULL)
g &lt;- sky_grid_segmentation(z, a, 10)
sky_points &lt;- extract_sky_points(r, bin, g,
                                 dist_to_plant = 3,
                                 min_raster_dist = 10)
plot(bin)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_sky_points_simple'>Extract sky points</h2><span id='topic+extract_sky_points_simple'></span>

<h3>Description</h3>

<p>Extract sky points for model fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_sky_points_simple(r, z, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_sky_points_simple_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_sky_points_simple_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_sky_points_simple_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will automatically sample sky pixels following this simple
strategy:
</p>

<ul>
<li><p> mask out the region of <code>r</code> above 15 and below 75 degrees of zenith angle,
</p>
</li>
<li><p> divide the hemisphere into sectors of 15 degrees each
(see <code><a href="#topic+sectors_segmentation">sectors_segmentation()</a></code>),
</p>
</li>
<li><p> search for the maximum digital value in each sector (n = 24),
</p>
</li>
<li><p> divide the hemisphere into rings of 5 degrees each
(see <code><a href="#topic+rings_segmentation">rings_segmentation()</a></code>,
</p>
</li>
<li><p> search for the maximum digital value in each ring (n = 12)
</p>
</li>
<li><p> combine these local maxima (n = 36).
</p>
</li></ul>



<h3>Value</h3>

<p>An object of the class <em>data.frame</em> with two columns named
<em>col</em> and <em>row</em>.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- system.file("external/DSCN4500.JPG", package = "rcaiman")
caim &lt;- read_caim(path, c(1250, 1020) - 745, 745 * 2, 745 * 2)
z &lt;- zenith_image(ncol(caim), lens("Nikon_FCE9"))
a &lt;- azimuth_image(z)
r &lt;- gbc(caim$Blue)
sky_points &lt;- extract_sky_points_simple(r, z, a)
plot(r)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)

## End(Not run)

</code></pre>

<hr>
<h2 id='extract_sun_coord'>Extract sun coordinates</h2><span id='topic+extract_sun_coord'></span>

<h3>Description</h3>

<p>Extract the sun coordinates for CIE sky model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_sun_coord(r, z, a, bin, g, max_angular_dist = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_sun_coord_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_sun_coord_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_sun_coord_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_sun_coord_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. This should be a preliminary binarization of
<code>r</code> useful for masking pixels that are very likely pure sky pixels.</p>
</td></tr>
<tr><td><code id="extract_sun_coord_+3A_g">g</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation()</a></code> or
<code><a href="#topic+chessboard">chessboard()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_sun_coord_+3A_max_angular_dist">max_angular_dist</code></td>
<td>
<p>Numeric vector of length one. Angle in degrees to
control the potential maximum size of the solar corona.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses an object-based image analyze framework. The segmentation
is given by <code>g</code> and <code>bin</code>. For every cell of <code>g</code>, the pixels
from <code>r</code> that are equal to one on <code>bin</code> are selected and its
maximum value is calculated. Then, the 95th percentile of these maximum
values is computed and used to filter out cells below that threshold; i.e,
only the cells with at least one extremely bright sky pixel is selected.
</p>
<p>The selected cells are grouped based on adjacency, and new bigger segments
are created from these groups. The degree of membership to the class
<em>Sun</em> is calculated for every new segment by computing the number of
cells that constitute the segment and its mean digital number (values taken
from <code>r</code>). In other words, the  largest and brightest segments are the
ones that score higher. The one with the highest score is selected as the
<em>sun seed</em>.
</p>
<p>The angular distance from the sun seed to every other segments are computed,
and only the segments not farther than <code>max_angular_dist</code> are classified
as part of the sun corona. A multi-part segment is created by merging the
sun-corona segments and, finally, the center of its bounding box is
considered as the sun location.
</p>


<h3>Value</h3>

<p>Object of class <em>list</em> with two numeric vectors of length two
named <em>row_col</em> and <em>zenith_azimuth</em>. The former is the raster
coordinates of the solar disk (row and column), and the other is the
angular coordinates (zenith and azimuth angles in degrees).
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
r &lt;- caim$Blue
caim &lt;- normalize(caim, 0, 20847, TRUE)
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)
plotRGB(caim*255)
bin &lt;- ootb_obia(caim, z, a, m, HSV(239, 0.85, 0.5), gamma = NULL)
g &lt;- sky_grid_segmentation(z, a, 10)
sun_coord &lt;- extract_sun_coord(r, z, a, bin, g, max_angular_dist = 30)
points(sun_coord$row_col[2], nrow(caim) - sun_coord$row_col[1],
        col = 3, pch = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='find_sky_pixels'>Find sky pixels</h2><span id='topic+find_sky_pixels'></span>

<h3>Description</h3>

<p>Find sky pixels automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_sky_pixels(r, z, a, sample_size_pct = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_sky_pixels_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="find_sky_pixels_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="find_sky_pixels_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="find_sky_pixels_+3A_sample_size_pct">sample_size_pct</code></td>
<td>
<p>Numeric vector of length one. Minimum percentage of
cells to sample. The population is comprised of 1296 cells of <code class="reqn">5 \times
  5</code> degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that:
</p>

<ul>
<li><p> there is at least one pure sky pixel at the level of cells of <code class="reqn">30
\times 30</code> degrees, and
</p>
</li>
<li><p> sky pixels have a digital number (DN) greater than canopy pixels have.
</p>
</li></ul>

<p>For each <code class="reqn">30 \times 30</code> cell, this method computes a quantile value and
uses it as a threshold to select the pure sky pixels from the given cell. As
a result, a binarized image is produced in a regional binarization fashion
(<code><a href="#topic+regional_thresholding">regional_thresholding()</a></code>). This process starts with a quantile
probability of 0.99. After producing the binarized image, this function uses
a search grid with cells of <code class="reqn">5 \times 5</code> degrees to count how many of
these cells have at least one sky pixel (pixels equal to one in the binarized
image). If the percentage of  cells with sky pixels does not reach argument
<code>sample_size_pct</code>, it goes back to the binarization step but decreasing
the probability by 0.01 points.
</p>
<p>If probability reach 0.9 and the <code>sample_size_pct</code> criterion were not
yet satisfied, the <code>sample_size_pct</code> is decreased one percent and the
process starts all over again.
</p>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with values <code>0</code> and
<code>1</code>. This layer masks pixels that are very likely pure sky pixels.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim() %&gt;% normalize(., 0, 20847)
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
r &lt;- caim$Blue
r[is.na(r)] &lt;- 0
bin &lt;- find_sky_pixels(r, z, a)
plot(bin)

## End(Not run)
</code></pre>

<hr>
<h2 id='find_sky_pixels_nonnull'>Find sky pixels following the non-null criteria</h2><span id='topic+find_sky_pixels_nonnull'></span>

<h3>Description</h3>

<p>Cells without sky pixels are the so-called null cells. This type of cells are
mathematically intractable by models typically used to obtain canopy metrics.
This function find sky pixels using increase in number of null cells as the
stopping criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_sky_pixels_nonnull(r, sky, g, intercept = 0, slope = 1, w = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_sky_pixels_nonnull_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="find_sky_pixels_nonnull_+3A_sky">sky</code></td>
<td>
<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> produced with
<code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model()</a></code>, <code><a href="#topic+fit_trend_surface">fit_trend_surface()</a></code>, <code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model()</a></code>, or
<code><a href="#topic+ootb_sky_reconstruction">ootb_sky_reconstruction()</a></code>. It also support a numeric vector of length
one. For instance, it could be a value obtained with a combination of
<code><a href="#topic+extract_sky_points">extract_sky_points()</a></code> and <code><a href="#topic+extract_dn">extract_dn()</a></code>. The latter can be understood as
modelling the sky with a plane.</p>
</td></tr>
<tr><td><code id="find_sky_pixels_nonnull_+3A_g">g</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation()</a></code> or
<code><a href="#topic+chessboard">chessboard()</a></code>.</p>
</td></tr>
<tr><td><code id="find_sky_pixels_nonnull_+3A_intercept">intercept</code>, <code id="find_sky_pixels_nonnull_+3A_slope">slope</code></td>
<td>
<p>Numeric vector of length one. These are linear
function coefficients.</p>
</td></tr>
<tr><td><code id="find_sky_pixels_nonnull_+3A_w">w</code></td>
<td>
<p>Numeric vector of length one. Weighting parameter from
Díaz and Lencinas (2018)'s Equation 1. See <code><a href="#topic+thr_mblt">thr_mblt()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>sky</code>, <code>intercept</code>, <code>slope</code>, and <code>w</code> are passed to <code><a href="#topic+thr_mblt">thr_mblt()</a></code>
whose output is in turn passed to <code><a href="#topic+apply_thr">apply_thr()</a></code> along with <code>r</code>. As a result,
<code>r</code> is binarized and used along with <code>g</code> to compute the number of null cells.
The process is repeated but increasing <code>w</code> in steps of 0.05 as long as
the number of null cells remains constant.
</p>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with values <code>0</code> and <code>1</code>.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
r &lt;- caim$Blue %&gt;% normalize()
caim &lt;- normalize(caim, 0, 20847, TRUE)
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)
bin &lt;- ootb_obia(caim, z, a, m, HSV(239, 0.85, 0.5), gamma = NULL)
g &lt;- sky_grid_segmentation(z, a, 3)
sky_points &lt;- extract_sky_points(r, bin, g,
                                 dist_to_plant = 5,
                                 min_raster_dist = 5)
rl &lt;- extract_rl(r, z, a, sky_points)
model &lt;- fit_coneshaped_model(rl$sky_points)
summary(model$model)

sky &lt;- model$fun(z, a)
sky &lt;- fit_trend_surface(sky, z, a, !is.na(z))$image
plot(r/sky)

x &lt;- predict(model$model)
y &lt;- predict(model$model) + model$model$residuals
mblt &lt;- coefficients(lm(x~y))

g &lt;- sky_grid_segmentation(z, a, 10)
bin &lt;- find_sky_pixels_nonnull(r, sky, g, mblt[1], mblt[2], w = 0.1)
plot(bin)

## End(Not run)
</code></pre>

<hr>
<h2 id='fisheye_to_equidistant'>Fisheye to equidistant</h2><span id='topic+fisheye_to_equidistant'></span>

<h3>Description</h3>

<p>Fisheye to equidistant projection (also known as polar projection).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisheye_to_equidistant(
  r,
  z,
  a,
  m = NULL,
  radius = NULL,
  k = NULL,
  p = NULL,
  rmax = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisheye_to_equidistant_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A fish-eye image.</p>
</td></tr>
<tr><td><code id="fisheye_to_equidistant_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="fisheye_to_equidistant_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="fisheye_to_equidistant_+3A_m">m</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A mask. For hemispherical photographs,
check <code><a href="#topic+mask_hs">mask_hs()</a></code>.</p>
</td></tr>
<tr><td><code id="fisheye_to_equidistant_+3A_radius">radius</code></td>
<td>
<p>Numeric integer of length one. Radius of the reprojected
hemispherical image (i.e., the output).</p>
</td></tr>
<tr><td><code id="fisheye_to_equidistant_+3A_k">k</code></td>
<td>
<p>Numeric vector of length one. Number of k-nearest neighbors.</p>
</td></tr>
<tr><td><code id="fisheye_to_equidistant_+3A_p">p</code></td>
<td>
<p>Numeric vector of length one. Power for inverse-distance weighting.</p>
</td></tr>
<tr><td><code id="fisheye_to_equidistant_+3A_rmax">rmax</code></td>
<td>
<p>Numeric vector of length one. Maximum radius where to search for
<em>knn</em>. Increase this value if pixels with value <code>0</code> or
<code>FALSE</code> appears where other values are expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pixel values and their image coordinates are treated as points to be
reprojected and interpolated. To that end, this function use <code><a href="lidR.html#topic+dtm_idw">lidR::knnidw()</a></code>
as workhorse function, so arguments <code>k</code>, <code>p</code>, and <code>rmax</code> are passed to it. If
the user does not input values to these arguments, both <code>k</code> and <code>p</code> are
automatically defined by default as follow: when a binarized image is
provided as argument <code>r</code>, both parameters are set to <code>1</code>; otherwise, they are
set to <code>9</code> and <code>2</code>, respectively.
</p>


<h3>Note</h3>

<p>Default value for the <code>radius</code> argument is equivalent to input the
radius of the <code>r</code> argument.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- system.file("external/DSCN4500.JPG", package = "rcaiman")
caim &lt;- read_caim(path, c(1250, 1020) - 745, 745 * 2, 745 * 2)
z &lt;- zenith_image(ncol(caim), lens("Nikon_FCE9"))
a &lt;- azimuth_image(z)
r &lt;- gbc(caim$Blue)
r &lt;- correct_vignetting(r, z, c(0.0638, -0.101)) %&gt;% normalize()
bin &lt;- ootb_mblt(r, z, a)$bin
bin_equi &lt;- fisheye_to_equidistant(bin, z, a)
plot(bin)
plot(bin_equi)
# Use write_bin(bin, "path/file_name") to have a file ready
# to calcute LAI with CIMES, GLA, CAN-EYE, etc.

# It can be used to reproject RGB photographs
plotRGB(caim)
caim &lt;- fisheye_to_equidistant(caim, z, a)
plotRGB(caim)

## End(Not run)
</code></pre>

<hr>
<h2 id='fisheye_to_pano'>Fisheye to panoramic</h2><span id='topic+fisheye_to_pano'></span>

<h3>Description</h3>

<p>Fisheye to panoramic (cylindrical projection)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisheye_to_pano(r, z, a, fun = mean, angle_width = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisheye_to_pano_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A fish-eye image.</p>
</td></tr>
<tr><td><code id="fisheye_to_pano_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="fisheye_to_pano_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="fisheye_to_pano_+3A_fun">fun</code></td>
<td>
<p>A <code>function</code> that takes a vector as input and returns a
one-length numeric or logical vector as output (e.g. mean).</p>
</td></tr>
<tr><td><code id="fisheye_to_pano_+3A_angle_width">angle_width</code></td>
<td>
<p>Numeric vector of length one. It should be <code style="white-space: pre;">&#8288;30, 15, 10, 7.5, 6, 5, 3.75, 3, 2.5, 1.875, 1&#8288;</code> or <code>0.5</code> degrees. This
constrain is rooted in the requirement of a value able to divide both the
<code>0</code> to <code>360</code> and <code>0</code> to <code>90</code> ranges into a whole number
of segments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An early version of this function was used in
Díaz et al. (2021).
</p>


<h3>References</h3>

<p>Díaz GM, Negri PA, Lencinas JD (2021).
&ldquo;Toward making canopy hemispherical photography independent of illumination conditions: A deep-learning-based approach.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>296</b>, 108234.
<a href="https://doi.org/10.1016/j.agrformet.2020.108234">doi:10.1016/j.agrformet.2020.108234</a>.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
pano &lt;- fisheye_to_pano(caim, z, a)
plotRGB(pano %&gt;% normalize() %&gt;% multiply_by(255))

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_cie_sky_model'>Fit CIE sky model</h2><span id='topic+fit_cie_sky_model'></span>

<h3>Description</h3>

<p>Use maximum likelihood to estimate the coefficients of the CIE sky model that
best fit to data sampled from a canopy photograph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_cie_sky_model(
  r,
  z,
  a,
  sky_points,
  zenith_dn,
  sun_coord,
  custom_sky_coef = NULL,
  std_sky_no = NULL,
  general_sky_type = NULL,
  twilight = TRUE,
  rmse = FALSE,
  method = "BFGS"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_cie_sky_model_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_sky_points">sky_points</code></td>
<td>
<p>The <em>data.frame</em> returned by <code><a href="#topic+extract_rl">extract_rl()</a></code> or a
<em>data.frame</em> with same structure and names.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_zenith_dn">zenith_dn</code></td>
<td>
<p>Numeric vector of length one. Zenith digital number, see
<code><a href="#topic+extract_rl">extract_rl()</a></code> for how to obtain it.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_sun_coord">sun_coord</code></td>
<td>
<p>An object of class <em>list</em>. The result of a call to
<code><a href="#topic+extract_sun_coord">extract_sun_coord()</a></code> or an object with same structure and names. See also
<code><a href="#topic+row_col_from_zenith_azimuth">row_col_from_zenith_azimuth()</a></code> in case you want to provide values based on
date and time of acquisition and the <code>suncalc</code> package.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_custom_sky_coef">custom_sky_coef</code></td>
<td>
<p>Numeric vector of length five. Custom starting
coefficients of the sky model. By default, they are drawn from standard
skies.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_std_sky_no">std_sky_no</code></td>
<td>
<p>Numeric vector. Standard sky number from
Li et al. (2016)'s Table 1.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_general_sky_type">general_sky_type</code></td>
<td>
<p>Character vector of length one. It could be any of
these: &quot;Overcast&quot;, &quot;Clear&quot;, or &quot;Partly cloudy&quot;. See Table 1 from
Li et al. (2016) for additional details.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_twilight">twilight</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code> and the initial
standard parameters belong to the &quot;Clear&quot; general sky type, sun zenith
angles from 90 to 96 degrees will be tested (civic twilight). This is
necessary since <code><a href="#topic+extract_sun_coord">extract_sun_coord()</a></code> would mistakenly recognize the center
of what can be seen of the solar corona as the solar disk.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_rmse">rmse</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code>, the criteria for
selecting the best sky model is to choose the one with the lowest <strong>root
mean square error (RMSE)</strong> calculated by using the <code>sky_points</code> argument as
the source of reference values. Otherwise, the criteria is to evaluate the
whole image by calculating the <strong>out-of-range index</strong> as <code class="reqn">\sum_{i =
  1}^{N}(r_i/sky_i)^2</code>, where <code class="reqn">r</code> is the <code>r</code> argument, <code class="reqn">sky</code> is the
raster obtained from the fitted model with <code><a href="#topic+cie_sky_model_raster">cie_sky_model_raster()</a></code> and
<code>zenith_dn</code>, <code class="reqn">i</code> is the index that represents the position of a given
pixel on the raster grid, and <code class="reqn">N</code> is the total number of pixels that
satisfy either of these inequalities: <code class="reqn">r_i/sky_i&lt;0</code> and
<code class="reqn">r_i/sky_i&gt;1</code>.</p>
</td></tr>
<tr><td><code id="fit_cie_sky_model_+3A_method">method</code></td>
<td>
<p>Optimization method to use. See <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on Lang et al. (2010). In theory,
the best result would be obtained with data showing a linear relation between
digital numbers and the amount of light reaching the sensor. See
<code><a href="#topic+extract_radiometry">extract_radiometry()</a></code> and <code><a href="#topic+read_caim_raw">read_caim_raw()</a></code> for further details. As a
compromise solution, <code><a href="#topic+gbc">gbc()</a></code> can be used.
</p>
<p>The following code exemplifies how this package can be used to compare the
manually-guided fitting provided by HSP (Lang et al. 2013)
against the automatic fitting provided by this package. The code assumes that
the user is working within an RStudio project located in the HSP project
folder.
</p>
<div class="sourceCode"><pre>r &lt;- read_caim("manipulate/IMG_1013.pgm") %&gt;% normalize()
z &lt;- zenith_image(ncol(r), lens())
a &lt;- azimuth_image(z)
manual_input &lt;- read_manual_input(".", "IMG_1013" )
sun_coord &lt;- manual_input$sun_coord$row_col
sun_coord &lt;- zenith_azimuth_from_row_col(z, sun_coord, lens())
sky_points &lt;- manual_input$sky_points
rl &lt;- extract_rl(r, z, a, sky_points)
model &lt;- fit_cie_sky_model(r, z, a, rl$sky_points, rl$zenith_dn, sun_coord)
cie_sky &lt;- model$relative_luminance * model$zenith_dn
plot(r/cie_sky)

r &lt;- read_caim("manipulate/IMG_1013.pgm")
sky_coef &lt;- read_opt_sky_coef(".", "IMG_1013")
cie_sky_manual &lt;- cie_sky_model_raster(z, a, sun_coord$zenith_azimuth, sky_coef)
cie_sky_manual &lt;- cie_sky_manual * manual_input$zenith_dn
plot(r/cie_sky_manual)
</pre></div>


<h3>Value</h3>

<p>object from the class <em>list</em>. The result includes the following: (1)
the output produced by <code><a href="bbmle.html#topic+mle2">bbmle::mle2()</a></code>, (2) the 5 coefficients, (3 and 4)
observed and predicted values, (5) the digital number at the zenith, (6)
the sun coordinates &ndash;zenith and azimuth angle in degrees&ndash;, and (7) the
description of the standard sky from which the initial coefficients were
drawn. See Li et al. (2016) to know more about these
coefficients.
</p>


<h3>Note</h3>

<p>If you use this function in your research, please cite
Lang et al. (2010) in addition to this package
(<code style="white-space: pre;">&#8288;citation("rcaiman"&#8288;</code>).
</p>


<h3>References</h3>

<p>Lang M, Kodar A, Arumäe T (2013).
&ldquo;Restoration of above canopy reference hemispherical image from below canopy measurements for plant area index estimation in forests.&rdquo;
<em>Forestry Studies</em>, <b>59</b>(1), 13&ndash;27.
<a href="https://doi.org/10.2478/fsmu-2013-0008">doi:10.2478/fsmu-2013-0008</a>.<br /><br /> Lang M, Kuusk A, M~ottus M, Rautiainen M, Nilson T (2010).
&ldquo;Canopy gap fraction estimation from digital hemispherical images using sky radiance models and a linear conversion method.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>150</b>(1), 20&ndash;29.
<a href="https://doi.org/10.1016/j.agrformet.2009.08.001">doi:10.1016/j.agrformet.2009.08.001</a>.<br /><br /> Li DH, Lou S, Lam JC, Wu RH (2016).
&ldquo;Determining solar irradiance on inclined planes from classified CIE (International Commission on Illumination) standard skies.&rdquo;
<em>Energy</em>, <b>101</b>, 462&ndash;470.
<a href="https://doi.org/10.1016/j.energy.2016.02.054">doi:10.1016/j.energy.2016.02.054</a>.
</p>


<h3>See Also</h3>

<p>Other Sky Reconstruction Functions: 
<code><a href="#topic+cie_sky_model_raster">cie_sky_model_raster</a>()</code>,
<code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model</a>()</code>,
<code><a href="#topic+fit_trend_surface">fit_trend_surface</a>()</code>,
<code><a href="#topic+fix_reconstructed_sky">fix_reconstructed_sky</a>()</code>,
<code><a href="#topic+interpolate_sky_points">interpolate_sky_points</a>()</code>,
<code><a href="#topic+ootb_sky_reconstruction">ootb_sky_reconstruction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim() %&gt;% normalize()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)

# Manual method after Lang et al. (2010)
# ImageJ can be used to digitize points
path &lt;- system.file("external/sky_points.csv",
                    package = "rcaiman")
sky_points &lt;- read.csv(path)
sky_points &lt;- sky_points[c("Y", "X")]
colnames(sky_points) &lt;- c("row", "col")
head(sky_points)
plot(caim$Blue)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)

xy &lt;- c(210, 451) #originally captured with click() after x11()
sun_coord &lt;- zenith_azimuth_from_row_col(z, z, c(nrow(z) - xy[2],xy[1]))
points(sun_coord$row_col[2], nrow(caim) - sun_coord$row_col[1],
       col = 3, pch = 1)

rl &lt;- extract_rl(caim$Blue, z, a, sky_points)

set.seed(7)
model &lt;- fit_cie_sky_model(caim$Blue, z, a, rl$sky_points,
                           rl$zenith_dn, sun_coord,
                           general_sky_type = "Clear",
                           rmse = FALSE,
                           twilight = FALSE,
                           method = "SANN")
summary(model$mle2_output)
plot(model$obs, model$pred)
abline(0,1)
r2 &lt;- lm(model$pred~model$obs) %&gt;% summary(.) %&gt;% .$r.squared
r2
sky_cie &lt;- cie_sky_model_raster(z, a,
                                model$sun_coord$zenith_azimuth,
                                model$coef) * model$zenith_dn
plot(sky_cie)
plot(caim$Blue/sky_cie)

# A quick demonstration of how to use interpolation to improve sky modelling
# after Lang et al. (2010)
sky &lt;- interpolate_sky_points(rl$sky_points, caim$Blue, rmax = ncol(caim)/7)
plot(sky)
sky &lt;- sky * rl$zenith_dn * (1 - r2) + sky_cie * r2
sky &lt;- terra::cover(sky, sky_cie)
plot(sky)
plot(caim$Blue/sky)

# how to provide a custom starting coefficient
model &lt;- fit_cie_sky_model(caim$Blue, z, a, rl$sky_points,
                           rl$zenith_dn, sun_coord,
                           custom_sky_coef = model$coef,
                           method = "SANN")
plot(model$obs, model$pred, ylim = range(model$obs))
abline(0,1)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_coneshaped_model'>Fit cone-shaped model</h2><span id='topic+fit_coneshaped_model'></span>

<h3>Description</h3>

<p>Statistical modeling for predicting digital numbers from spherical
coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_coneshaped_model(sky_points, use_azimuth_angle = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_coneshaped_model_+3A_sky_points">sky_points</code></td>
<td>
<p>The <em>data.frame</em> returned by <code><a href="#topic+extract_rl">extract_rl()</a></code> or a
<em>data.frame</em> with same structure and names.</p>
</td></tr>
<tr><td><code id="fit_coneshaped_model_+3A_use_azimuth_angle">use_azimuth_angle</code></td>
<td>
<p>Logical vector of length one. If <code>TRUE</code>, the
Equation 4 from Díaz and Lencinas (2018)) is used: <code class="reqn">sDN =
  a + b \cdot \theta + c  \cdot \theta^2 + d  \cdot sin(\phi) + e  \cdot
  cos(\phi)</code>, where <code class="reqn">sDN</code> is sky digital number, <code class="reqn">a,b,c,d</code> and
<code class="reqn">e</code> are coefficients, <code class="reqn">\theta</code> is zenith angle, and <code class="reqn">\phi</code> is
azimuth angle. If <code>FALSE</code>, the next simplified version based on
Wagner (2001) is used: <code class="reqn">sDN = a + b \cdot
  \theta + c  \cdot \theta^2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method was presented in Díaz and Lencinas (2018), under the
heading <em>Estimation of the sky DN as a previous step for our method</em>. If you
use this function in your research, please cite that paper in addition to
this package (<code style="white-space: pre;">&#8288;citation("rcaiman"&#8288;</code>).
</p>


<h3>Value</h3>

<p>A list of two objects, one of class <code>function</code> and the other of class
<code>lm</code> (see <code><a href="stats.html#topic+lm">stats::lm()</a></code>). If the fitting fails, it returns <code>NULL</code>. The
function requires two arguments&ndash;zenith and azimuth in degrees&ndash;to return
relative luminance.
</p>


<h3>References</h3>

<p>Díaz GM, Lencinas JD (2018).
&ldquo;Model-based local thresholding for canopy hemispherical photography.&rdquo;
<em>Canadian Journal of Forest Research</em>, <b>48</b>(10), 1204&ndash;1216.
<a href="https://doi.org/10.1139/cjfr-2018-0006">doi:10.1139/cjfr-2018-0006</a>.<br /><br /> Wagner S (2001).
&ldquo;Relative radiance measurements and zenith angle dependent segmentation in hemispherical photography.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>107</b>(2), 103&ndash;115.
<a href="https://doi.org/10.1016/s0168-1923%2800%2900232-x">doi:10.1016/s0168-1923(00)00232-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thr_mblt">thr_mblt()</a></code>
</p>
<p>Other Sky Reconstruction Functions: 
<code><a href="#topic+cie_sky_model_raster">cie_sky_model_raster</a>()</code>,
<code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model</a>()</code>,
<code><a href="#topic+fit_trend_surface">fit_trend_surface</a>()</code>,
<code><a href="#topic+fix_reconstructed_sky">fix_reconstructed_sky</a>()</code>,
<code><a href="#topic+interpolate_sky_points">interpolate_sky_points</a>()</code>,
<code><a href="#topic+ootb_sky_reconstruction">ootb_sky_reconstruction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- system.file("external/DSCN4500.JPG", package = "rcaiman")
caim &lt;- read_caim(path, c(1250, 1020) - 745, 745 * 2, 745 * 2)
z &lt;- zenith_image(ncol(caim), lens("Nikon_FCE9"))
a &lt;- azimuth_image(z)
r &lt;- gbc(caim$Blue)

sky_points &lt;- extract_rl(r, z, a, extract_sky_points_simple(r, z, a),
                         NULL,
                         use_window = FALSE)#this is important when
                                            #extract_sky_points_simple()
                                            #is used
model &lt;- fit_coneshaped_model(sky_points$sky_points)
summary(model$model)
sky_cs &lt;- model$fun(z, a)
plot(r/sky_cs)
plot(sky_cs)

z &lt;- zenith_image(50, lens())
a &lt;- azimuth_image(z)
sky_cs &lt;- model$fun(z, a)
persp(sky_cs, theta = 90, phi = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_trend_surface'>Fit a trend surface to sky digital numbers</h2><span id='topic+fit_trend_surface'></span>

<h3>Description</h3>

<p>Fit a trend surface using <code><a href="spatial.html#topic+surf.ls">spatial::surf.ls()</a></code> as workhorse function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_trend_surface(r, z, a, bin, filling_source = NULL, np = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_trend_surface_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_trend_surface_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_trend_surface_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_trend_surface_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. This should be a preliminary binarization of
<code>r</code> useful for masking pixels that are very likely pure sky pixels.</p>
</td></tr>
<tr><td><code id="fit_trend_surface_+3A_filling_source">filling_source</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. An actual or reconstructed
above-canopy image to complement the sky pixels detected through the gaps
of <code>r</code>. A photograph taken immediately after or before taking <code>r</code> under the
open sky with the same equipment and configuration is a very good option
but not recommended under fleeting clouds. The orientation relative to the
North must be the same as for <code>r</code>. If it is set to <code>NULL</code> (default), only
sky pixels from <code>r</code> will be used as input.</p>
</td></tr>
<tr><td><code id="fit_trend_surface_+3A_np">np</code></td>
<td>

<p>degree of polynomial surface
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be used after <code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model()</a></code>.
</p>
<p>This method was presented in Díaz and Lencinas (2018), under
the heading <em>Estimation of the sky DN as a previous step for our method</em>. If
you use this function in your research, please cite that paper in addition to
this package (<code style="white-space: pre;">&#8288;citation("rcaiman"&#8288;</code>).
</p>


<h3>Value</h3>

<p>A list with an object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> and of class <code>trls</code>
(see <code><a href="spatial.html#topic+surf.ls">spatial::surf.ls()</a></code>).
</p>


<h3>Note</h3>

<p>If an incomplete above-canopy image is available as filling source,
non-sky pixels should be turned <code>NA</code> or they will be erroneously considered
as sky pixels.
</p>


<h3>References</h3>

<p>Díaz GM, Lencinas JD (2018).
&ldquo;Model-based local thresholding for canopy hemispherical photography.&rdquo;
<em>Canadian Journal of Forest Research</em>, <b>48</b>(10), 1204&ndash;1216.
<a href="https://doi.org/10.1139/cjfr-2018-0006">doi:10.1139/cjfr-2018-0006</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thr_mblt">thr_mblt()</a></code>
</p>
<p>Other Sky Reconstruction Functions: 
<code><a href="#topic+cie_sky_model_raster">cie_sky_model_raster</a>()</code>,
<code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model</a>()</code>,
<code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model</a>()</code>,
<code><a href="#topic+fix_reconstructed_sky">fix_reconstructed_sky</a>()</code>,
<code><a href="#topic+interpolate_sky_points">interpolate_sky_points</a>()</code>,
<code><a href="#topic+ootb_sky_reconstruction">ootb_sky_reconstruction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
r &lt;- caim$Blue
caim &lt;- normalize(caim, 0, 20847, TRUE)
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)

bin &lt;- ootb_obia(caim, z, a, m, HSV(239, 0.85, 0.5), gamma = NULL)

g &lt;- sky_grid_segmentation(z, a, 10)
sky_points &lt;- extract_sky_points(r, bin, g, dist_to_plant = 5)
plot(bin)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)
rl &lt;- extract_rl(r, z, a, sky_points)

model &lt;- fit_coneshaped_model(rl$sky_points)
summary(model$model)
sky_cs &lt;- model$fun(z, a)
persp(terra::aggregate(sky_cs, 10), theta = 90, phi = 45)

sky_s &lt;- fit_trend_surface(r, z, a, bin, sky_cs)
persp(terra::aggregate(sky_s$image, 10), theta = 90, phi = 45)

## End(Not run)
</code></pre>

<hr>
<h2 id='fix_reconstructed_sky'>Fix reconstructed sky</h2><span id='topic+fix_reconstructed_sky'></span>

<h3>Description</h3>

<p>Automatically edit a raster image of sky digital numbers (DNs) reconstructed
with functions such as <code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model()</a></code> and
<code><a href="#topic+fit_trend_surface">fit_trend_surface()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_reconstructed_sky(sky, z, r, bin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_reconstructed_sky_+3A_sky">sky</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. Sky DNs predicted with functions such as
<code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model()</a></code> and <code><a href="#topic+fit_trend_surface">fit_trend_surface()</a></code>.</p>
</td></tr>
<tr><td><code id="fix_reconstructed_sky_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="fix_reconstructed_sky_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The source of the sky DNs used to build
<code>sky</code> (the data source).</p>
</td></tr>
<tr><td><code id="fix_reconstructed_sky_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The binarization of <code>r</code> used to
select the sky DNs for building the <code>sky</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predicted sky DNs are usually erroneous near the horizon because either
they are a misleading extrapolation or are based on corrupted data (non-pure
sky DNs).
</p>
<p>The proposed automatic edition consists of:
</p>

<ul>
<li><p> flattening the values below
the minimum value from the data source defined by <code>r</code> and
<code>bin</code>and
</p>
</li>
<li><p> forcing the values toward the horizon to become gradually
the median value from the data source.
</p>
</li></ul>

<p>The latter is achieved by calculating
the weighted average of the median value and the predicted sky DNs, using the
ratio of <code>z</code> to <code>90</code> to determine the weights.
</p>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The argument <code>sky</code>
with dimensions unchanged but values edited.
</p>


<h3>See Also</h3>

<p>Other Sky Reconstruction Functions: 
<code><a href="#topic+cie_sky_model_raster">cie_sky_model_raster</a>()</code>,
<code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model</a>()</code>,
<code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model</a>()</code>,
<code><a href="#topic+fit_trend_surface">fit_trend_surface</a>()</code>,
<code><a href="#topic+interpolate_sky_points">interpolate_sky_points</a>()</code>,
<code><a href="#topic+ootb_sky_reconstruction">ootb_sky_reconstruction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
r &lt;- caim$Blue
caim &lt;- normalize(caim, 0, 20847, TRUE)
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
bin &lt;- find_sky_pixels(r, z, a)
sky &lt;- fit_trend_surface(r, z, a, bin)$image
sky &lt;- fix_reconstructed_sky(sky, z, r, bin)
plot(sky)

## End(Not run)
</code></pre>

<hr>
<h2 id='gbc'>Gamma back correction</h2><span id='topic+gbc'></span>

<h3>Description</h3>

<p>Gamma back correction of JPEG images
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbc(DN_from_JPEG, gamma = 2.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbc_+3A_dn_from_jpeg">DN_from_JPEG</code></td>
<td>
<p>Numeric vector or object of the <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>
class. Digital numbers from a JPEG file (0 to 255, i.e., the standard 8-bit
encoded).</p>
</td></tr>
<tr><td><code id="gbc_+3A_gamma">gamma</code></td>
<td>
<p>Numeric vector of length one. Gamma value. Please see
Díaz and Lencinas (2018) for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Digital cameras usually use sRGB as color space. It is a standard
developed to ensure accurate color and tone management. The transfer function
of sRGB, known as gamma correction, is very close to a power function with
the exponent 1/2.2. This is why a DN of a born-digital photograph that was
encoded in sRGB has a non-linear relationship with luminance despite
having the sensor a linear response.
</p>


<h3>Value</h3>

<p>The same class as <code>DN_from_JPEG</code>, with dimension unchanged but values
rescaled between <code>0</code> and <code>1</code> in a non-linear fashion.
</p>


<h3>References</h3>

<p>Díaz GM, Lencinas JD (2018).
&ldquo;Model-based local thresholding for canopy hemispherical photography.&rdquo;
<em>Canadian Journal of Forest Research</em>, <b>48</b>(10), 1204&ndash;1216.
<a href="https://doi.org/10.1139/cjfr-2018-0006">doi:10.1139/cjfr-2018-0006</a>.
</p>


<h3>See Also</h3>

<p>Other Pre-processing Functions: 
<code><a href="#topic+enhance_caim">enhance_caim</a>()</code>,
<code><a href="#topic+local_fuzzy_thresholding">local_fuzzy_thresholding</a>()</code>,
<code><a href="#topic+membership_to_color">membership_to_color</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("external/DSCN4500.JPG", package = "rcaiman")
r &lt;- read_caim(path, c(1250, 1020) - 745, 745 * 2, 745 * 2)
r
gbc(r)
</code></pre>

<hr>
<h2 id='interpolate_sky_points'>Interpolate sky points</h2><span id='topic+interpolate_sky_points'></span>

<h3>Description</h3>

<p>Interpolate values from canopy photographs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_sky_points(sky_points, r, k = 3, p = 2, rmax = 200, col_id = "rl")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate_sky_points_+3A_sky_points">sky_points</code></td>
<td>
<p>An object of class <em>data.frame</em>. The data.frame returned by
<code><a href="#topic+extract_rl">extract_rl()</a></code> or <code><a href="#topic+extract_dn">extract_dn()</a></code>, or a
<em>data.frame</em> with same basic structure and names.</p>
</td></tr>
<tr><td><code id="interpolate_sky_points_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The image from which <code>sky_points</code>
was obtained.</p>
</td></tr>
<tr><td><code id="interpolate_sky_points_+3A_k">k</code></td>
<td>
<p>Numeric vector of length one. Number of k-nearest neighbors.</p>
</td></tr>
<tr><td><code id="interpolate_sky_points_+3A_p">p</code></td>
<td>
<p>Numeric vector of length one. Power for inverse-distance weighting.</p>
</td></tr>
<tr><td><code id="interpolate_sky_points_+3A_rmax">rmax</code></td>
<td>
<p>Numeric vector of length one. Maximum radius where to search for
<em>knn</em>.</p>
</td></tr>
<tr><td><code id="interpolate_sky_points_+3A_col_id">col_id</code></td>
<td>
<p>Numeric vector of length one. ID of the column with the values
to interpolate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function use <code><a href="lidR.html#topic+dtm_idw">lidR::knnidw()</a></code> as workhorse function, so
arguments <code>k</code>, <code>p</code>, and <code>rmax</code> are passed to it.
</p>
<p>This function is based on Lang et al. (2010). In theory,
the best result would be obtained with data showing a linear relation between
digital numbers and the amount of light reaching the sensor. See
<code><a href="#topic+extract_radiometry">extract_radiometry()</a></code> and <code><a href="#topic+read_caim_raw">read_caim_raw()</a></code> for further details. As a
compromise solution, <code><a href="#topic+gbc">gbc()</a></code> can be used.
</p>
<p>Default parameters are the ones used by
Lang et al. (2010). The argument <code>rmax</code> should
account for between 15 to 20 degrees, but it is expressed in pixels units.
So, image resolution and lens projections should be taken into account to set
this argument properly.
</p>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>.
</p>


<h3>References</h3>

<p>Lang M, Kuusk A, M~ottus M, Rautiainen M, Nilson T (2010).
&ldquo;Canopy gap fraction estimation from digital hemispherical images using sky radiance models and a linear conversion method.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>150</b>(1), 20&ndash;29.
<a href="https://doi.org/10.1016/j.agrformet.2009.08.001">doi:10.1016/j.agrformet.2009.08.001</a>.
</p>


<h3>See Also</h3>

<p>Other Sky Reconstruction Functions: 
<code><a href="#topic+cie_sky_model_raster">cie_sky_model_raster</a>()</code>,
<code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model</a>()</code>,
<code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model</a>()</code>,
<code><a href="#topic+fit_trend_surface">fit_trend_surface</a>()</code>,
<code><a href="#topic+fix_reconstructed_sky">fix_reconstructed_sky</a>()</code>,
<code><a href="#topic+ootb_sky_reconstruction">ootb_sky_reconstruction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
r &lt;- caim$Blue
caim &lt;- normalize(caim, 0, 20847, TRUE)
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)

bin &lt;- ootb_obia(caim, z, a, m, HSV(239, 0.85, 0.5), gamma = NULL)

g &lt;- sky_grid_segmentation(z, a, 10)
sky_points &lt;- extract_sky_points(r, bin, g, dist_to_plant = 3)
plot(bin)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)
sky_points &lt;- extract_dn(r, sky_points)

sky &lt;- interpolate_sky_points(sky_points, r, col_id = 3)
plot(sky)
plot(r/sky)

# A quick demonstration of how to use trend surface fitting to smooth the
# interpolation
persp(terra::aggregate(sky, 10), theta = 45, phi = 30)
sky_s &lt;- fit_trend_surface(sky, z, a, !is.na(z))
persp(terra::aggregate(sky_s$image, 10), theta = 45, phi = 30)
plot(sky_s$image)
plot(r)
plot(r/sky_s$image)
plot(apply_thr(r/sky_s$image, 0.5))

## End(Not run)
</code></pre>

<hr>
<h2 id='lens'>Access the lens database</h2><span id='topic+lens'></span>

<h3>Description</h3>

<p>Database of lens projection functions and field of views.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lens(type = "equidistant", max_fov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lens_+3A_type">type</code></td>
<td>
<p>Character vector of length one. The name of the lens.</p>
</td></tr>
<tr><td><code id="lens_+3A_max_fov">max_fov</code></td>
<td>
<p>Logical vector of length one. Use <code>TRUE</code> to return the maximum
field of view in degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In upward-looking leveled hemispherical photography, the zenith is the center
of a circle whose perimeter is the horizon. This is true only if the lens
field of view is 180º. The relative radius is the radius of concentric
circles expressed as a fraction of the radius that belongs to the circle that
has the horizon as perimeter. The equidistant model, also called polar, is
the most widely used as a standard reference. Real lenses can approximate the
projection models, but they always have some kind of distortion. In the
equidistant model, the relation between zenith angle and relative radius is
modeled with a straight line. Following <a href="https://www.schleppi.ch/patrick/hemisfer/">Hemisfer software</a>, this package uses a
polynomial curve to model lens distortion. A third-order polynomial is
sufficient in most cases (Frazer et al. 2001). Equations should
be fitted with angles in radians.
</p>
<p>Eventually, this will be a large database, but only the following lenses are
available at the moment:
</p>

<ul>
<li><p> equidistant: standard equidistant projection
(Schneider et al. 2009).
</p>
</li>
<li><p> Nikkor_10.5mm: AF DX Fisheye Nikkor 10.5mm f/2.8G ED
(Pekin and Macfarlane 2009)
</p>
</li>
<li><p> Nikon_FCE9: Nikon FC-E9 converter
(Díaz and et al. 2024)
</p>
</li>
<li><p> Olloclip: Auxiliary lens for mobile devices made by Olloclip
(Díaz and et al. 2024)
</p>
</li>
<li><p> Nikkor_8mm: AF–S Fisheye Nikkor 8–15mm f/3.5–4.5E ED
(Díaz and et al. 2024)
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>max_fov</code> is set to <code>TRUE</code>, it returns a numeric vector of length
one, which is the lens maximum field of view in degrees. Otherwise, it
returns a numeric vector with the coefficients of the lens function.
</p>


<h3>References</h3>

<p>Díaz GM, et al. (2024).
&ldquo;Simple calibration of fisheye lenses for hemipherical photography of the forest canopy.&rdquo;
<em>Manuscript in preparation</em>.<br /><br /> Frazer GW, Fournier RA, Trofymow JA, Hall RJ (2001).
&ldquo;A comparison of digital and film fisheye photography for analysis of forest canopy structure and gap light transmission.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>109</b>(4), 249&ndash;263.
<a href="https://doi.org/10.1016/s0168-1923%2801%2900274-x">doi:10.1016/s0168-1923(01)00274-x</a>.<br /><br /> Pekin B, Macfarlane C (2009).
&ldquo;Measurement of crown cover and leaf area index using digital cover photography and its application to remote sensing.&rdquo;
<em>Remote Sensing</em>, <b>1</b>(4), 1298&ndash;1320.
<a href="https://doi.org/10.3390/rs1041298">doi:10.3390/rs1041298</a>.<br /><br /> Schneider D, Schwalbe E, Maas H (2009).
&ldquo;Validation of geometric models for fisheye lenses.&rdquo;
<em>ISPRS Journal of Photogrammetry and Remote Sensing</em>, <b>64</b>(3), 259&ndash;266.
<a href="https://doi.org/10.1016/j.isprsjprs.2009.01.001">doi:10.1016/j.isprsjprs.2009.01.001</a>.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lens("Nikon_FCE9")
lens("Nikon_FCE9", max_fov = TRUE)

.fp &lt;- function(theta, lens_coef) {
  x &lt;- lens_coef[1:5]
  x[is.na(x)] &lt;- 0
  for (i in 1:5) assign(letters[i], x[i])
  a * theta + b * theta^2 + c * theta^3 + d * theta^4 + e * theta^5
}

theta &lt;- seq(0, pi/2, pi/180)
plot(theta, .fp(theta, lens()), type = "l", lty = 2,
      ylab = "relative radius")
lines(theta, .fp(theta, lens("Nikon_FCE9")))

</code></pre>

<hr>
<h2 id='local_fuzzy_thresholding'>Local fuzzy thresholding</h2><span id='topic+local_fuzzy_thresholding'></span>

<h3>Description</h3>

<p>This function was first presented in Díaz and Lencinas (2015).
It uses a threshold value as the location parameter of a logistic membership
function whose scale parameter depends on a variable, here named <code>mem</code>. This
dependence can be explained as follows: if the variable is equal to <code>1</code>, then
the membership function is same as a threshold function because the scale
parameter is <code>0</code>; lowering the variable increases the scale parameter, thus
blurring the threshold because it decreases the steepness of the curve. Since
the variable is defined pixel by pixel, this should be considered as a
<strong>local</strong> fuzzy thresholding method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_fuzzy_thresholding(lightness, m, mem, thr = NULL, fuzziness = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_fuzzy_thresholding_+3A_lightness">lightness</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image (see
<code><a href="#topic+normalize">normalize()</a></code>).</p>
</td></tr>
<tr><td><code id="local_fuzzy_thresholding_+3A_m">m</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A mask. For hemispherical photographs,
check <code><a href="#topic+mask_hs">mask_hs()</a></code>.</p>
</td></tr>
<tr><td><code id="local_fuzzy_thresholding_+3A_mem">mem</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. It is the scale parameter of the logistic
membership function. Typically it is obtained with <code><a href="#topic+membership_to_color">membership_to_color()</a></code>.</p>
</td></tr>
<tr><td><code id="local_fuzzy_thresholding_+3A_thr">thr</code></td>
<td>
<p>Numeric vector of length one. Location parameter of the logistic
membership function. Use <code>NULL</code> to estimate it automatically with
<code><a href="#topic+thr_isodata">thr_isodata()</a></code>.</p>
</td></tr>
<tr><td><code id="local_fuzzy_thresholding_+3A_fuzziness">fuzziness</code></td>
<td>
<p>Numeric vector of length one. This number is a constant
value that scales <code>mem</code>. Use <code>NULL</code> to estimate it automatically as the
midpoint between the maximum and minimum values of <code>lightness</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>m</code> can be used to affect the automatic estimation of <code>thr</code> and
<code>fuzziness</code>.
</p>
<p>If you use this function in your research, please cite
Díaz and Lencinas (2015) in addition to this package
(<code style="white-space: pre;">&#8288;citation("rcaiman"&#8288;</code>).
</p>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with same pixel dimensions than
<code>caim</code>. Depending on <code>mem</code>, changes could be subtle.
</p>


<h3>References</h3>

<p>Díaz GM, Lencinas JD (2015).
&ldquo;Enhanced gap fraction extraction from hemispherical photography.&rdquo;
<em>IEEE Geoscience and Remote Sensing Letters</em>, <b>12</b>(8), 1785&ndash;1789.
<a href="https://doi.org/10.1109/lgrs.2015.2425931">doi:10.1109/lgrs.2015.2425931</a>.
</p>


<h3>See Also</h3>

<p>Other Pre-processing Functions: 
<code><a href="#topic+enhance_caim">enhance_caim</a>()</code>,
<code><a href="#topic+gbc">gbc</a>()</code>,
<code><a href="#topic+membership_to_color">membership_to_color</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)

caim &lt;- normalize(caim)

# ImageJ can be used to digitize points
path &lt;- system.file("external/sky_points.csv",
                    package = "rcaiman")
img_points &lt;- read.csv(path)
img_points &lt;- img_points[c("Y", "X")]
colnames(img_points) &lt;- c("row", "col")
head(img_points)
target_color &lt;- extract_dn(caim, img_points, fun = median)
as(target_color, "HSV")
target_color &lt;- HSV(240, 0.85, 0.5) #to increase saturation

mem &lt;- membership_to_color(caim, target_color)
mem_thr &lt;- local_fuzzy_thresholding(mean(caim), m,  mem$membership_to_grey)
plot(mem_thr)

## End(Not run)
</code></pre>

<hr>
<h2 id='mask_hs'>Mask hemisphere</h2><span id='topic+mask_hs'></span>

<h3>Description</h3>

<p>Given a zenith or azimuth image and angle restrictions, this function
produces a mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_hs(r, from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mask_hs_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code> or
<code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="mask_hs_+3A_from">from</code>, <code id="mask_hs_+3A_to">to</code></td>
<td>
<p>angle in degrees, inclusive limits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with values <code>0</code> and
<code>1</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+masking">masking()</a></code>
</p>
<p>Other Segmentation Functions: 
<code><a href="#topic+chessboard">chessboard</a>()</code>,
<code><a href="#topic+mask_sunlit_canopy">mask_sunlit_canopy</a>()</code>,
<code><a href="#topic+polar_qtree">polar_qtree</a>()</code>,
<code><a href="#topic+qtree">qtree</a>()</code>,
<code><a href="#topic+rings_segmentation">rings_segmentation</a>()</code>,
<code><a href="#topic+sectors_segmentation">sectors_segmentation</a>()</code>,
<code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
z &lt;- zenith_image(1000, lens())
a &lt;- azimuth_image(z)
m1 &lt;- mask_hs(z, 20, 70)
plot(m1)
m2 &lt;- mask_hs(a, 330,360)
plot(m2)
plot(m1 &amp; m2)
plot(m1 | m2)

# 15 degrees at each side of 0
m1 &lt;- mask_hs(a, 0, 15)
m2 &lt;- mask_hs(a, 345, 360)
plot(m1 | m2)

# better use this
plot(!is.na(z))
# instead of this
plot(mask_hs(z, 0, 90))

## End(Not run)
</code></pre>

<hr>
<h2 id='mask_sunlit_canopy'>Mask sunlit canopy</h2><span id='topic+mask_sunlit_canopy'></span>

<h3>Description</h3>

<p>It is a wrapper function around <code><a href="#topic+membership_to_color">membership_to_color()</a></code>. It was developed
with images in sRGB color space (Díaz 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_sunlit_canopy(caim, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mask_sunlit_canopy_+3A_caim">caim</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The return of a call to <code><a href="#topic+read_caim">read_caim()</a></code> or
<code><a href="#topic+read_caim_raw">read_caim_raw()</a></code>.</p>
</td></tr>
<tr><td><code id="mask_sunlit_canopy_+3A_m">m</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A mask. For hemispherical photographs, check
<code><a href="#topic+mask_hs">mask_hs()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with values <code>0</code> and <code>1</code>.
</p>


<h3>References</h3>

<p>Díaz GM (2023).
&ldquo;Optimizing forest canopy structure retrieval from smartphone-based hemispherical photography.&rdquo;
<em>Methods in Ecology and Evolution</em>, <b>14</b>(3), 875&ndash;884.
<a href="https://doi.org/10.1111/2041-210x.14059">doi:10.1111/2041-210x.14059</a>.
</p>


<h3>See Also</h3>

<p>Other Segmentation Functions: 
<code><a href="#topic+chessboard">chessboard</a>()</code>,
<code><a href="#topic+mask_hs">mask_hs</a>()</code>,
<code><a href="#topic+polar_qtree">polar_qtree</a>()</code>,
<code><a href="#topic+qtree">qtree</a>()</code>,
<code><a href="#topic+rings_segmentation">rings_segmentation</a>()</code>,
<code><a href="#topic+sectors_segmentation">sectors_segmentation</a>()</code>,
<code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- system.file("external/APC_0020.jpg", package = "rcaiman")
caim &lt;- read_caim(path)
plotRGB(caim)
caim &lt;- normalize(caim)
m &lt;- mask_sunlit_canopy(caim)
plot(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='masking'>Image masking</h2><span id='topic+masking'></span>

<h3>Description</h3>

<p>Image masking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>masking(r, m, RGB = c(1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="masking_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The image. Values should be normalized,
see <code><a href="#topic+normalize">normalize()</a></code>. Only methods for images with one or three
layers have been implemented.</p>
</td></tr>
<tr><td><code id="masking_+3A_m">m</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A mask. For hemispherical photographs,
check <code><a href="#topic+mask_hs">mask_hs()</a></code>.</p>
</td></tr>
<tr><td><code id="masking_+3A_rgb">RGB</code></td>
<td>
<p>Numeric vector of length three. RGB color code. Red is the default
color.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> that essentially is
<code>r</code> with areas where <code>m</code> is equal to zero painted in a solid
color. If <code>r</code> is a single layer image, then the layer is triplicated
to allow the use of color.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mask_hs">mask_hs()</a></code>
</p>
<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 r &lt;- read_caim()
 z &lt;- zenith_image(ncol(r), lens())
 a &lt;- azimuth_image(z)
 m &lt;- mask_hs(z, 20, 70) &amp; mask_hs(a, 90, 180)

 masked_caim &lt;-  masking(normalize(r), m)
 plotRGB(masked_caim * 255)

 masked_bin &lt;- masking(apply_thr(r$Blue, 125), m)
 plotRGB(masked_bin * 255)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='membership_to_color'>Compute the membership to a target color</h2><span id='topic+membership_to_color'></span>

<h3>Description</h3>

<p>This function was first presented in Díaz and Lencinas (2015).
It computes the degree of membership to a color using two Gaussian membership
functions and the axes <em>A</em> and <em>B</em> from the
<em>CIE LAB</em> color space. The lightness dimension is not
considered in the calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>membership_to_color(caim, target_color, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="membership_to_color_+3A_caim">caim</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The return of a call to <code><a href="#topic+read_caim">read_caim()</a></code> or
<code><a href="#topic+read_caim_raw">read_caim_raw()</a></code>.</p>
</td></tr>
<tr><td><code id="membership_to_color_+3A_target_color">target_color</code></td>
<td>
<p><a href="colorspace.html#topic+color-class">color</a>.</p>
</td></tr>
<tr><td><code id="membership_to_color_+3A_sigma">sigma</code></td>
<td>
<p>Numeric vector of length one. Use <code>NULL</code> (default) to estimate
it automatically as the euclidean distance between <code>target_color</code> and grey
in the <em>CIE LAB</em> color space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you use this function in your research, please cite
Díaz and Lencinas (2015) in addition to this package
(<code style="white-space: pre;">&#8288;citation("rcaiman"&#8288;</code>).
</p>


<h3>Value</h3>

<p>It returns an object from the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. First layer
is the membership to the target color. Second layer is the membership to
grey. Both memberships are calculated with same <code>sigma</code>.
</p>


<h3>References</h3>

<p>Díaz GM, Lencinas JD (2015).
&ldquo;Enhanced gap fraction extraction from hemispherical photography.&rdquo;
<em>IEEE Geoscience and Remote Sensing Letters</em>, <b>12</b>(8), 1785&ndash;1789.
<a href="https://doi.org/10.1109/lgrs.2015.2425931">doi:10.1109/lgrs.2015.2425931</a>.
</p>


<h3>See Also</h3>

<p>Other Pre-processing Functions: 
<code><a href="#topic+enhance_caim">enhance_caim</a>()</code>,
<code><a href="#topic+gbc">gbc</a>()</code>,
<code><a href="#topic+local_fuzzy_thresholding">local_fuzzy_thresholding</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim() %&gt;% normalize
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)

sky_blue &lt;- HSV(239, 0.85, 0.5)
mem &lt;- membership_to_color(caim, sky_blue)
plot(mem)

## End(Not run)
</code></pre>

<hr>
<h2 id='normalize'>Normalize data</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Normalize numeric and raster data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(r, mn = NULL, mx = NULL, force_range = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> or numeric vector.</p>
</td></tr>
<tr><td><code id="normalize_+3A_mn">mn</code></td>
<td>
<p>Numeric vector of length one. Minimum expected value. Default is
equivalent to enter the minimum value from <code>r</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_mx">mx</code></td>
<td>
<p>Numeric vector of length one. Maximum expected value. Default is
equivalent to enter the maximum value from <code>r</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_force_range">force_range</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code>, the
range is forced to be between <code>0</code> and <code>1</code> by flattening values
found below and above those limits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normalize data laying between <code>mn</code> and <code>mx</code> to the range <code>0</code>
to <code>1</code>. Data greater than <code>mx</code> get values greater than <code>1</code> in
a proportional fashion. Conversely, data less than <code>mn</code> get values less
than <code>0</code>.This function can be used for linear stretching of the
histogram.
</p>


<h3>Value</h3>

<p>An object from the same class as <code>r</code> with values from <code>r</code>
linearly rescaled to make <code>mn</code> equal to zero and <code>mx</code> equal to
one. Therefore, if <code>mn</code> and <code>mx</code> do not match the actual minimum
and maximum from <code>r</code>, then the output will not cover the 0-to-1 range
and may be outside that range if <code>force_range</code> is set to <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p>Other Pre-processing Functions: 
<code><a href="#topic+enhance_caim">enhance_caim</a>()</code>,
<code><a href="#topic+gbc">gbc</a>()</code>,
<code><a href="#topic+local_fuzzy_thresholding">local_fuzzy_thresholding</a>()</code>,
<code><a href="#topic+membership_to_color">membership_to_color</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalize(read_caim())
</code></pre>

<hr>
<h2 id='obia'>Do object-based image analysis of canopy photographs</h2><span id='topic+obia'></span>

<h3>Description</h3>

<p>Object-based image analysis targeting the canopy  silhouette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obia(r, z = NULL, a = NULL, bin, segmentation, gf_mn = 0.2, gf_mx = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obia_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="obia_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="obia_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="obia_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. This should be a working binarization of <code>r</code>
without gross errors.</p>
</td></tr>
<tr><td><code id="obia_+3A_segmentation">segmentation</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+polar_qtree">polar_qtree()</a></code> or
<code><a href="#topic+qtree">qtree()</a></code>.</p>
</td></tr>
<tr><td><code id="obia_+3A_gf_mn">gf_mn</code>, <code id="obia_+3A_gf_mx">gf_mx</code></td>
<td>
<p>Numeric vector of length one. The minimum/maximum gap
fraction that a segment should comply with to be considered as one
containing foliage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method was first presented in Díaz and Lencinas (2015).
This version is simpler since it relies on a better working binarized image.
The version from 2015 uses an automatic selection of samples followed by a
<em>knn</em> classification of segments containing foliage. This version uses
de gap fraction extracted from <code>bin</code> to classify <em>foliage</em> by defining upper
and lower limits through the arguments <code>gf_mx</code> and <code>gf_mn</code>.
</p>
<p>This method produces a synthetic layer by computing the ratio of <code>r</code> to the
maximum value of <code>r</code> at the segment level. This process is carried out only
on the pixels covered by the classes <em>foliage</em> and <em>sky</em>. The latter is
defined by <code>bin</code> equal to one. To avoid spurious values, the quantile <code>0.9</code>
is computed instead of the maximum. Pixels not belonging to the class
<em>foliage</em> return as <code>NA</code>.
</p>
<p>Default values of <code>z</code> and <code>a</code> allows the processing of restricted view
photographs.
</p>
<p>If you use this function in your research, please cite
Díaz and Lencinas (2015) in addition to this package
(<code style="white-space: pre;">&#8288;citation("rcaiman"&#8288;</code>).
</p>


<h3>Value</h3>

<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>.
</p>


<h3>References</h3>

<p>Díaz GM, Lencinas JD (2015).
&ldquo;Enhanced gap fraction extraction from hemispherical photography.&rdquo;
<em>IEEE Geoscience and Remote Sensing Letters</em>, <b>12</b>(8), 1785&ndash;1789.
<a href="https://doi.org/10.1109/lgrs.2015.2425931">doi:10.1109/lgrs.2015.2425931</a>.
</p>


<h3>See Also</h3>

<p>Other Binarization Functions: 
<code><a href="#topic+apply_thr">apply_thr</a>()</code>,
<code><a href="#topic+ootb_mblt">ootb_mblt</a>()</code>,
<code><a href="#topic+ootb_obia">ootb_obia</a>()</code>,
<code><a href="#topic+regional_thresholding">regional_thresholding</a>()</code>,
<code><a href="#topic+thr_isodata">thr_isodata</a>()</code>,
<code><a href="#topic+thr_mblt">thr_mblt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim() %&gt;% normalize()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)
ecaim &lt;- enhance_caim(caim, m)
bin &lt;- apply_thr(ecaim, thr_isodata(ecaim[m]))
plot(bin)

seg &lt;- polar_qtree(caim, z, a)
synth &lt;- obia(caim$Blue, z, a, bin, seg)
plot(synth)
foliage &lt;- !is.na(synth)
hist(synth[foliage])
synth &lt;- terra::cover(synth, bin)
plot(synth)
hist(synth[foliage])

## End(Not run)
</code></pre>

<hr>
<h2 id='ootb_mblt'>Out-of-the-box model-based local thresholding</h2><span id='topic+ootb_mblt'></span>

<h3>Description</h3>

<p>Out-of-the-box version of the model-based local thresholding (MBLT) algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ootb_mblt(r, z, a, bin = NULL, fix_cs_sky = FALSE, w = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ootb_mblt_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_mblt_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_mblt_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_mblt_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. This should be a preliminary binarization of
<code>r</code> useful for masking pixels that are very likely pure sky pixels.</p>
</td></tr>
<tr><td><code id="ootb_mblt_+3A_fix_cs_sky">fix_cs_sky</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code>,
<code><a href="#topic+fix_reconstructed_sky">fix_reconstructed_sky()</a></code> is used to fix the cone-shaped sky.</p>
</td></tr>
<tr><td><code id="ootb_mblt_+3A_w">w</code></td>
<td>
<p>Numeric vector of length one. Weighting parameter from
Díaz and Lencinas (2018)'s Equation 1. See <code><a href="#topic+thr_mblt">thr_mblt()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a hard-coded version of a MBLT pipeline. The MBLT approach
proposes a linear relationship between background value and optimal threshold
value. This function uses statistical models for sky reconstruction that are
able to explain smooth changes in sky brightness, so this function works best
under clear skies or overcast conditions. After the reconstruction, local
thresholds are linearly predicted from sky brightness values (see
<code><a href="#topic+thr_mblt">thr_mblt()</a></code>).
</p>
<p>As a high-level summary, the function starts producing a working binarized
image and ends with a refined binarized image.
</p>
<p>The pipeline combines these main functions <code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple()</a></code> or
<code><a href="#topic+extract_sky_points">extract_sky_points()</a></code>, <code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model()</a></code>, and <code><a href="#topic+fit_trend_surface">fit_trend_surface()</a></code>.
The code can be easily inspected by calling <code>ootb_mblt</code> without parenthesis.
Advanced users can use that code as a template.
</p>
<p>The MBLT algorithm was first presented in
Díaz and Lencinas (2018). The version presented here differs
from the original in the following main aspects:
</p>

<ul>
<li><p> The original version used a global thresholding method to provide sky
points to the cone-shaped model. This one uses <code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple()</a></code>.
Nevertheless, a binarized image can be provided through the <code>bin</code> argument,
triggering the use of <code><a href="#topic+extract_sky_points">extract_sky_points()</a></code> instead of
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple()</a></code>.
</p>
</li>
<li> <p><code>intercept</code> and <code>slope</code> are automatically obtained using data from sky
points and a linear model for accuracy evaluation after
Piñeiro et al. (2008). This approach handles inaccuracies
in background reconstruction (see <code><a href="#topic+thr_mblt">thr_mblt()</a></code> for additional details).
</p>
</li>
<li><p> This version does not use asynchronous acquisition under the open sky, as
the original method did. The cone-shaped model (<code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model()</a></code>) run
without a filling source and the cone-shaped sky is used as filling source
for trend surface fitting (<code><a href="#topic+fit_trend_surface">fit_trend_surface()</a></code>).
</p>
</li></ul>

<p>This function searches for black objects against a light background. When
regular canopy hemispherical images are provided as input, the algorithm will
find dark canopy elements against a bright sky almost everywhere in the
picture and, therefore, the result will fit user expectations. However, if a
hemispherical photograph taken under the open sky is provided, this algorithm
would be still searching black objects against a light background, so the
darker portions of the sky will be taken as objects, i.e., canopy. As a
consequence, this will not fit users expectations since they are looking for
the classes <em>Gap</em> and <em>No-gap</em>, no matter if one of those are not in the
picture itself. This kind of error could happen with photographs of open
forests for the same working principle.
</p>
<p>If you use this function in your research, please cite
Díaz and Lencinas (2018) in addition to this package
(<code style="white-space: pre;">&#8288;citation("rcaiman"&#8288;</code>).
</p>


<h3>Value</h3>

<p>Object from class list containing the binarized image (named
<em>bin</em>) and the reconstructed skies (named <em>sky_cs</em> and
<em>sky_s</em>).
</p>


<h3>Note</h3>

<p>If <code>NULL</code> is provided as the <code>w</code> argument, the weight is calculated as the
coefficient of determination (<code class="reqn">R^2</code>) of linear model for accuracy
evaluation (Piñeiro et al. 2008).
</p>


<h3>References</h3>

<p>Díaz GM, Lencinas JD (2018).
&ldquo;Model-based local thresholding for canopy hemispherical photography.&rdquo;
<em>Canadian Journal of Forest Research</em>, <b>48</b>(10), 1204&ndash;1216.
<a href="https://doi.org/10.1139/cjfr-2018-0006">doi:10.1139/cjfr-2018-0006</a>.<br /><br /> Piñeiro G, Perelman S, Guerschman JP, Paruelo JM (2008).
&ldquo;How to evaluate models: Observed vs. predicted or predicted vs. observed?&rdquo;
<em>Ecological Modelling</em>, <b>216</b>(3-4), 316&ndash;322.
<a href="https://doi.org/10.1016/j.ecolmodel.2008.05.006">doi:10.1016/j.ecolmodel.2008.05.006</a>.
</p>


<h3>See Also</h3>

<p>Other Binarization Functions: 
<code><a href="#topic+apply_thr">apply_thr</a>()</code>,
<code><a href="#topic+obia">obia</a>()</code>,
<code><a href="#topic+ootb_obia">ootb_obia</a>()</code>,
<code><a href="#topic+regional_thresholding">regional_thresholding</a>()</code>,
<code><a href="#topic+thr_isodata">thr_isodata</a>()</code>,
<code><a href="#topic+thr_mblt">thr_mblt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- system.file("external/DSCN4500.JPG", package = "rcaiman")
caim &lt;- read_caim(path, c(1250, 1020) - 745, 745 * 2, 745 * 2)
z &lt;- zenith_image(ncol(caim), lens("Nikon_FCE9"))
a &lt;- azimuth_image(z)
r &lt;- gbc(caim$Blue)
r &lt;- correct_vignetting(r, z, c(0.0638, -0.101)) %&gt;% normalize()
bin &lt;- find_sky_pixels(r, z, a)
bin &lt;- ootb_mblt(r, z, a, bin)
plot(bin$bin)


## End(Not run)
</code></pre>

<hr>
<h2 id='ootb_obia'>Out-of-the-box object-based image analysis of canopy photographs</h2><span id='topic+ootb_obia'></span>

<h3>Description</h3>

<p>Out-of-the-box version of methods first presented in
Díaz and Lencinas (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ootb_obia(
  caim,
  z = NULL,
  a = NULL,
  m = NULL,
  sky_blue = NULL,
  w_red = 0,
  gamma = 2.2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ootb_obia_+3A_caim">caim</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The return of a call to <code><a href="#topic+read_caim">read_caim()</a></code> or
<code><a href="#topic+read_caim_raw">read_caim_raw()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_obia_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_obia_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_obia_+3A_m">m</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. Default (<code>NULL</code>) is the equivalent to enter
<code>!is.na(z)</code> for hemispherical photography, or enter <code>!is.na(caim$Red)</code> for
restricted view photography.</p>
</td></tr>
<tr><td><code id="ootb_obia_+3A_sky_blue">sky_blue</code></td>
<td>
<p><a href="colorspace.html#topic+color-class">color</a>. Is the <code>target_color</code> argument to be passed to
<code><a href="#topic+membership_to_color">membership_to_color()</a></code>. Default (<code>NULL</code>) is the equivalent to enter
<code>sRGB(0.1, 0.4, 0.8)</code>&ndash;the HEX color code is #1A66CC, it can be entered
into a search engine (such as Mozilla Firefox) to see a color swatch.</p>
</td></tr>
<tr><td><code id="ootb_obia_+3A_w_red">w_red</code></td>
<td>
<p>Numeric vector of length one. Weight of the red channel. A
single layer image is calculated as a weighted average of the blue and red
channels. This layer is used as lightness information. The weight of the
blue is the complement of <code>w_red</code>.</p>
</td></tr>
<tr><td><code id="ootb_obia_+3A_gamma">gamma</code></td>
<td>
<p>Numeric vector of length one. This is for applying a gamma back
correction to the lightness information (see Details and argument <code>w_red</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a hard-coded version of a pipeline that combines these main
functions <code><a href="#topic+mask_sunlit_canopy">mask_sunlit_canopy()</a></code>, <code><a href="#topic+enhance_caim">enhance_caim()</a></code>,
<code><a href="#topic+polar_qtree">polar_qtree()</a></code>/<code><a href="#topic+qtree">qtree()</a></code>, and <code><a href="#topic+obia">obia()</a></code>. The code can be easily inspected by
calling <code>ootb_obia</code> &ndash;no parenthesis. Advanced users can use that code as a
template.
</p>
<p>Pixels from the synthetic layer returned by <code><a href="#topic+obia">obia()</a></code> that lay between <code>0</code> and
<code>1</code> are assigned to the class <em>plant</em> only if they comply with the following
conditions:
</p>

<ul>
<li><p> Their values are equal to <code>0</code> after <code><a href="#topic+defuzzify">defuzzify()</a></code> with a
sky grid segmentation of <code>10</code> degrees.
</p>
</li>
<li><p> Their values are equal to <code>0</code> after <code><a href="#topic+apply_thr">apply_thr()</a></code> with a
threshold computed with <code><a href="#topic+thr_isodata">thr_isodata()</a></code>.
</p>
</li>
<li><p> They are not exclusively surrounded by sky pixels.
</p>
</li></ul>

<p>Use the default values of <code>z</code> and <code>a</code> to process restricted view photographs.
</p>
<p>If you use this function in your research, please cite
Díaz and Lencinas (2015) or
Díaz (2023) in addition to this package
(<code style="white-space: pre;">&#8288;citation("rcaiman"&#8288;</code>).
</p>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with values <code>0</code> and <code>1</code>.
</p>


<h3>References</h3>

<p>Díaz GM (2023).
&ldquo;Optimizing forest canopy structure retrieval from smartphone-based hemispherical photography.&rdquo;
<em>Methods in Ecology and Evolution</em>, <b>14</b>(3), 875&ndash;884.
<a href="https://doi.org/10.1111/2041-210x.14059">doi:10.1111/2041-210x.14059</a>.<br /><br /> Díaz GM, Lencinas JD (2015).
&ldquo;Enhanced gap fraction extraction from hemispherical photography.&rdquo;
<em>IEEE Geoscience and Remote Sensing Letters</em>, <b>12</b>(8), 1785&ndash;1789.
<a href="https://doi.org/10.1109/lgrs.2015.2425931">doi:10.1109/lgrs.2015.2425931</a>.
</p>


<h3>See Also</h3>

<p>Other Binarization Functions: 
<code><a href="#topic+apply_thr">apply_thr</a>()</code>,
<code><a href="#topic+obia">obia</a>()</code>,
<code><a href="#topic+ootb_mblt">ootb_mblt</a>()</code>,
<code><a href="#topic+regional_thresholding">regional_thresholding</a>()</code>,
<code><a href="#topic+thr_isodata">thr_isodata</a>()</code>,
<code><a href="#topic+thr_mblt">thr_mblt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# ==============================================
# Circular Hemispherical Photo (from a raw file)
# ==============================================

caim &lt;- read_caim()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)

mn &lt;- quantile(caim$Blue[m], 0.01)
mx &lt;- quantile(caim$Blue[m], 0.99)
r &lt;- normalize(caim$Blue, mn, mx, TRUE)

bin &lt;- find_sky_pixels(r, z, a)
mblt &lt;- ootb_mblt(r, z, a, bin)
plot(mblt$bin)

mx &lt;- optim_normalize(caim, mblt$bin)
ncaim &lt;- normalize(caim, mx = mx, force_range = TRUE)
plotRGB(ncaim*255)
plotRGB(normalize(caim)*255)
percentage_of_clipped_highlights(ncaim$Blue, m)

bin2 &lt;- ootb_obia(ncaim, z, a, gamma = NULL)
plot(bin2)

# =====================================
# Hemispherical Photo from a Smartphone
# =====================================

path &lt;- system.file("external/APC_0581.jpg", package = "rcaiman")
caim &lt;- read_caim(path) %&gt;% normalize()
z &lt;- zenith_image(2132/2, c(0.7836, 0.1512, -0.1558))
a &lt;- azimuth_image(z)
zenith_colrow &lt;- c(1063, 771)/2
caim &lt;- expand_noncircular(caim, z, zenith_colrow) %&gt;% normalize()
m &lt;- !is.na(caim$Red) &amp; !is.na(z)
caim[!m] &lt;- 0

bin &lt;- ootb_obia(caim, z, a)
plot(bin)

# ============================
# Restricted View Canopy Photo
# ============================

path &lt;- system.file("external/APC_0020.jpg", package = "rcaiman")
caim &lt;- read_caim(path) %&gt;% normalize()

bin &lt;- ootb_obia(caim)
plot(bin)

## End(Not run)
</code></pre>

<hr>
<h2 id='ootb_sky_reconstruction'>Out-of-the-box sky reconstruction</h2><span id='topic+ootb_sky_reconstruction'></span>

<h3>Description</h3>

<p>Build an above canopy image from a single below canopy image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ootb_sky_reconstruction(
  r,
  z,
  a,
  bin,
  filling_source = NULL,
  dist_to_plant = 3,
  sun_coord = NULL,
  general_sky_type = NULL,
  twilight = TRUE,
  rmse = TRUE,
  method = "BFGS",
  try_grids = TRUE,
  thin_points = TRUE,
  refine_sun_coord = TRUE,
  try_optims = TRUE,
  force_sampling = TRUE,
  interpolate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ootb_sky_reconstruction_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. This should be a preliminary binarization of
<code>r</code> useful for masking pixels that are very likely pure sky pixels.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_filling_source">filling_source</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. An actual or reconstructed
above-canopy image to complement the sky pixels detected through the gaps
of <code>r</code>. A photograph taken immediately after or before taking <code>r</code> under the
open sky with the same equipment and configuration is a very good option
but not recommended under fleeting clouds. The orientation relative to the
North must be the same as for <code>r</code>. If it is set to <code>NULL</code> (default), only
sky pixels from <code>r</code> will be used as input.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_dist_to_plant">dist_to_plant</code></td>
<td>
<p>Numeric vector of length one or <code>NULL</code>. See
<code><a href="#topic+extract_sky_points">extract_sky_points()</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_sun_coord">sun_coord</code></td>
<td>
<p>An object of class <em>list</em>. The result of a call to
<code><a href="#topic+extract_sun_coord">extract_sun_coord()</a></code> or an object with same structure and names. See also
<code><a href="#topic+row_col_from_zenith_azimuth">row_col_from_zenith_azimuth()</a></code> in case you want to provide values based on
date and time of acquisition and the <code>suncalc</code> package.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_general_sky_type">general_sky_type</code></td>
<td>
<p>Character vector of length one. It could be any of
these: &quot;Overcast&quot;, &quot;Clear&quot;, or &quot;Partly cloudy&quot;. See Table 1 from
Li et al. (2016) for additional details.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_twilight">twilight</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code> and the initial
standard parameters belong to the &quot;Clear&quot; general sky type, sun zenith
angles from 90 to 96 degrees will be tested (civic twilight). This is
necessary since <code><a href="#topic+extract_sun_coord">extract_sun_coord()</a></code> would mistakenly recognize the center
of what can be seen of the solar corona as the solar disk.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_rmse">rmse</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code>, the criteria for
selecting the best sky model is to choose the one with the lowest <strong>root
mean square error (RMSE)</strong> calculated by using the <code>sky_points</code> argument as
the source of reference values. Otherwise, the criteria is to evaluate the
whole image by calculating the <strong>out-of-range index</strong> as <code class="reqn">\sum_{i =
  1}^{N}(r_i/sky_i)^2</code>, where <code class="reqn">r</code> is the <code>r</code> argument, <code class="reqn">sky</code> is the
raster obtained from the fitted model with <code><a href="#topic+cie_sky_model_raster">cie_sky_model_raster()</a></code> and
<code>zenith_dn</code>, <code class="reqn">i</code> is the index that represents the position of a given
pixel on the raster grid, and <code class="reqn">N</code> is the total number of pixels that
satisfy either of these inequalities: <code class="reqn">r_i/sky_i&lt;0</code> and
<code class="reqn">r_i/sky_i&gt;1</code>.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_method">method</code></td>
<td>
<p>Optimization method to use. See <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_try_grids">try_grids</code></td>
<td>
<p>Logical vector of length one.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_thin_points">thin_points</code></td>
<td>
<p>Logical vector of length one.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_refine_sun_coord">refine_sun_coord</code></td>
<td>
<p>Logical vector of length one.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_try_optims">try_optims</code></td>
<td>
<p>Logical vector of length one.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_force_sampling">force_sampling</code></td>
<td>
<p>Logical vector of length one.</p>
</td></tr>
<tr><td><code id="ootb_sky_reconstruction_+3A_interpolate">interpolate</code></td>
<td>
<p>Logical vector of length one. If <code>TRUE</code>,
<code><a href="#topic+interpolate_sky_points">interpolate_sky_points()</a></code> will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a hard-coded version of a pipeline that uses these main
functions <code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model()</a></code> and <code><a href="#topic+interpolate_sky_points">interpolate_sky_points()</a></code>.
</p>
<p>The pipeline is an automatic version of the
Lang et al. (2010) method.
</p>
<p>Providing a <code style="white-space: pre;">&#8288;filling source&#8288;</code> triggers an alternative pipeline in which the
sky is fully reconstructed with <code><a href="#topic+interpolate_sky_points">interpolate_sky_points()</a></code> after a dense
sampling (<code class="reqn">1 \times 1</code> degree cells), which is supported by the fact that
sky digital numbers will be available for every pixel, either from <code>r</code> gaps
or from the filling source.
</p>


<h3>Value</h3>

<p>If a filling source is not provided, the result is an object from the
class <em>list</em> that includes the following: (1) the reconstructed sky
(<a href="terra.html#topic+SpatRaster-class">SpatRaster</a>), (2) the output produced by <code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model()</a></code>, (3)
the out-of-range index (see <code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model()</a></code>), (4) sky points that
were not involved in obtaining (2), (5) an object from the class <code>lm</code> (see
<code><a href="stats.html#topic+lm">stats::lm()</a></code>) that is the result of validating (1) with (4) and the method
recommended by Piñeiro et al. (2008), and (6) a
binarized image produced with (1), the coefficients from (4) and
<code><a href="#topic+thr_mblt">thr_mblt()</a></code> with <code><a href="#topic+apply_thr">apply_thr()</a></code>, using 'w=0.95'. If a filling source is
provided, only a reconstructed sky (<a href="terra.html#topic+SpatRaster-class">SpatRaster</a>) is returned.
</p>


<h3>References</h3>

<p>Lang M, Kuusk A, M~ottus M, Rautiainen M, Nilson T (2010).
&ldquo;Canopy gap fraction estimation from digital hemispherical images using sky radiance models and a linear conversion method.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>150</b>(1), 20&ndash;29.
<a href="https://doi.org/10.1016/j.agrformet.2009.08.001">doi:10.1016/j.agrformet.2009.08.001</a>.<br /><br /> Li DH, Lou S, Lam JC, Wu RH (2016).
&ldquo;Determining solar irradiance on inclined planes from classified CIE (International Commission on Illumination) standard skies.&rdquo;
<em>Energy</em>, <b>101</b>, 462&ndash;470.
<a href="https://doi.org/10.1016/j.energy.2016.02.054">doi:10.1016/j.energy.2016.02.054</a>.<br /><br /> Piñeiro G, Perelman S, Guerschman JP, Paruelo JM (2008).
&ldquo;How to evaluate models: Observed vs. predicted or predicted vs. observed?&rdquo;
<em>Ecological Modelling</em>, <b>216</b>(3-4), 316&ndash;322.
<a href="https://doi.org/10.1016/j.ecolmodel.2008.05.006">doi:10.1016/j.ecolmodel.2008.05.006</a>.
</p>


<h3>See Also</h3>

<p>Other Sky Reconstruction Functions: 
<code><a href="#topic+cie_sky_model_raster">cie_sky_model_raster</a>()</code>,
<code><a href="#topic+fit_cie_sky_model">fit_cie_sky_model</a>()</code>,
<code><a href="#topic+fit_coneshaped_model">fit_coneshaped_model</a>()</code>,
<code><a href="#topic+fit_trend_surface">fit_trend_surface</a>()</code>,
<code><a href="#topic+fix_reconstructed_sky">fix_reconstructed_sky</a>()</code>,
<code><a href="#topic+interpolate_sky_points">interpolate_sky_points</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)

m &lt;- !is.na(z)
mn &lt;- quantile(caim$Blue[m], 0.01)
mx &lt;- quantile(caim$Blue[m], 0.99)
r &lt;- normalize(caim$Blue, mn, mx, TRUE)

bin &lt;- find_sky_pixels(r, z, a)
bin &lt;- ootb_mblt(r, z, a, bin)
plot(bin$bin)

mx &lt;- optim_normalize(caim, m)

r &lt;- normalize(caim$Blue)
caim &lt;- normalize(caim, mx = mx, force_range = TRUE)

bin &lt;- ootb_obia(caim, z, a, m, HSV(239, 0.85, 0.5), gamma = NULL)
plot(bin)
bin &lt;- ootb_mblt(r, z, a, bin)$bin
plot(bin)

set.seed(7)
sky &lt;- ootb_sky_reconstruction(r, z, a, bin)

sky$sky
sky$validation %&gt;% summary()
plot(sky$sky)
plot(r/sky$sky)
hist(r/sky$sky, xlim = c(0, 2), breaks = 255)
hist((r/sky$sky)[bin], xlim = c(0, 2), breaks = 255)
plot((r/sky$sky)&gt;1.1)

plot(sky$bin)

sky2 &lt;- ootb_sky_reconstruction(r, z, a, sky$bin, sky$sky)
plot(sky2)
plot(r/sky2)
hist(r/sky2, xlim = c(0, 2), breaks = 255)
hist((r/sky2)[sky$bin], xlim = c(0, 2), breaks = 255)
plot((r/sky2)&gt;1.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='optim_normalize'>Optimize normalize parameters</h2><span id='topic+optim_normalize'></span>

<h3>Description</h3>

<p>Wrapper function for <code><a href="bbmle.html#topic+mle2">bbmle::mle2()</a></code>. Optimize normalize parameters by
maximizing <code><a href="#topic+colorfulness">colorfulness()</a></code> and minimizing saturation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_normalize(caim, bin, method = "BFGS")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optim_normalize_+3A_caim">caim</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The return of a call to <code><a href="#topic+read_caim">read_caim()</a></code> or
<code><a href="#topic+read_caim_raw">read_caim_raw()</a></code>.</p>
</td></tr>
<tr><td><code id="optim_normalize_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. This should be a preliminary binarization of
<code>r</code> useful for masking pixels that are very likely pure sky pixels.</p>
</td></tr>
<tr><td><code id="optim_normalize_+3A_method">method</code></td>
<td>
<p>Optimization method to use. See <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length one. The values for using as <code>mx</code> argument
with <code><a href="#topic+normalize">normalize()</a></code>.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)

mn &lt;- quantile(caim$Blue[m], 0.01)
mx &lt;- quantile(caim$Blue[m], 0.99)
r &lt;- normalize(caim$Blue, mn, mx, TRUE)

bin &lt;- find_sky_pixels(r, z, a)
mblt &lt;- ootb_mblt(r, z, a, bin)
plot(mblt$bin)

mx &lt;- optim_normalize(caim, mblt$bin)
ncaim &lt;- normalize(caim, mx = mx, force_range = TRUE)
plotRGB(ncaim*255)
plotRGB(normalize(caim)*255)
percentage_of_clipped_highlights(ncaim$Blue, m)

## End(Not run)
</code></pre>

<hr>
<h2 id='percentage_of_clipped_highlights'>Percentage of clipped highlights</h2><span id='topic+percentage_of_clipped_highlights'></span>

<h3>Description</h3>

<p>Wrapper function for <code><a href="terra.html#topic+freq">terra::freq()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentage_of_clipped_highlights(r, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="percentage_of_clipped_highlights_+3A_r">r</code></td>
<td>
<p>Single-layer object from the <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>.</p>
</td></tr>
<tr><td><code id="percentage_of_clipped_highlights_+3A_m">m</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A mask. For hemispherical photographs,
check <code><a href="#topic+mask_hs">mask_hs()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of lenght one.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- read_caim()$Blue
z &lt;- zenith_image(ncol(r), lens())
m &lt;- !is.na(z)
percentage_of_clipped_highlights(r, m)
r &lt;- normalize(r, 0, 1000, TRUE)
percentage_of_clipped_highlights(r, m)
</code></pre>

<hr>
<h2 id='polar_qtree'>Do quad-tree segmentation in the polar space</h2><span id='topic+polar_qtree'></span>

<h3>Description</h3>

<p>The quad-tree segmentation algorithm is a top-down process that makes
recursive divisions in four equal parts until a condition is satisfied and
stops locally. The usual implementation of the quad-tree algorithm is
based on the raster structure and this is why the result are squares of
different sizes. This method implements the quad-tree segmentation in a polar
space, so the segments are shaped like windshields, though some of them will
look elongated in height. The pattern is two opposite and converging straight
sides and two opposite and parallel curvy sides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polar_qtree(r, z, a, scale_parameter = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polar_qtree_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>.</p>
</td></tr>
<tr><td><code id="polar_qtree_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="polar_qtree_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="polar_qtree_+3A_scale_parameter">scale_parameter</code></td>
<td>
<p>Numeric vector of length one. Quad-tree is a top-down
method. This parameter controls the stopping condition. Therefore, it
allows controlling the size of the resulting segments. Ultimately, segments
sizes will depend on both this parameter and the heterogeneity of <code>r</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm splits segments of 30 degrees resolution into four sub-segments
and calculates the standard deviation of the pixels from <code>r</code> delimited
by each of those segments. The splitting process stops locally if the sum of
the standard deviation of the sub-segments minus the standard deviation of
the parent segment (named <em>delta</em>) is less or equal than the
<code>scale_parameter</code>. If <code>r</code> has more than one layer, <em>delta</em> is
calculated separately and <em>delta</em> mean is used to evaluate the stopping
condition.
</p>


<h3>Value</h3>

<p>A single layer image of the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with
integer values.
</p>


<h3>See Also</h3>

<p>Other Segmentation Functions: 
<code><a href="#topic+chessboard">chessboard</a>()</code>,
<code><a href="#topic+mask_hs">mask_hs</a>()</code>,
<code><a href="#topic+mask_sunlit_canopy">mask_sunlit_canopy</a>()</code>,
<code><a href="#topic+qtree">qtree</a>()</code>,
<code><a href="#topic+rings_segmentation">rings_segmentation</a>()</code>,
<code><a href="#topic+sectors_segmentation">sectors_segmentation</a>()</code>,
<code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim() %&gt;% normalize()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
seg &lt;- polar_qtree(caim, z, a)
plot(seg)
plot(extract_feature(caim$Blue, seg))

## End(Not run)
</code></pre>

<hr>
<h2 id='qtree'>Do quad-tree segmentation</h2><span id='topic+qtree'></span>

<h3>Description</h3>

<p>The quad-tree segmentation algorithm is a top-down process that makes
recursive divisions in four equal parts until a condition is satisfied and
stops locally. This is the usual implementation of the quad-tree algorithm,
so it produces squared segments of different sizes. This particular
implementation allows up to five sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtree(r, scale_parameter = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtree_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>.</p>
</td></tr>
<tr><td><code id="qtree_+3A_scale_parameter">scale_parameter</code></td>
<td>
<p>Numeric vector of length one. Quad-tree is a top-down
method. This parameter controls the stopping condition. Therefore, it
allows controlling the size of the resulting segments. Ultimately, segments
sizes will depend on both this parameter and the heterogeneity of <code>r</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm starts splitting the entire image into large squared segments.
Depending on the aspect ratio, starting grids will going from <code class="reqn">4 \times
4</code> to <code class="reqn">1 \times 4</code> or <code class="reqn">4 \times 1</code>. Then, it splits each segment into
four sub-segments and calculates the standard deviation of the pixels from
<code>r</code> delimited by each of those sub-segments and segment. The splitting
process stops locally if <em>delta</em>, the sum of the standard deviation of the
sub-segments minus the standard deviation of the parent segment, is less or
equal than the <code>scale_parameter</code>. If <code>r</code> has more than one layer,
<em>delta</em> is calculated separately and <em>delta</em> mean is used to
evaluate the stopping condition.
</p>


<h3>Value</h3>

<p>A single layer image of the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with integer
values.
</p>


<h3>See Also</h3>

<p>Other Segmentation Functions: 
<code><a href="#topic+chessboard">chessboard</a>()</code>,
<code><a href="#topic+mask_hs">mask_hs</a>()</code>,
<code><a href="#topic+mask_sunlit_canopy">mask_sunlit_canopy</a>()</code>,
<code><a href="#topic+polar_qtree">polar_qtree</a>()</code>,
<code><a href="#topic+rings_segmentation">rings_segmentation</a>()</code>,
<code><a href="#topic+sectors_segmentation">sectors_segmentation</a>()</code>,
<code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim() %&gt;% normalize()
seg &lt;- qtree(caim, scale_parameter = 0.05)
plot(caim$Blue)
plot(extract_feature(caim$Blue, seg))
plot(extract_feature(seg, seg, length))

## End(Not run)
</code></pre>

<hr>
<h2 id='read_bin'>Read binarized images</h2><span id='topic+read_bin'></span>

<h3>Description</h3>

<p>Wrapper functions for <code><a href="terra.html#topic+rast">terra::rast()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bin(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_bin_+3A_path">path</code></td>
<td>
<p>Character vector of length one. Path to a binarized image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object from class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
z &lt;- zenith_image(1000, lens())
m &lt;- !is.na(z)
my_file &lt;- file.path(tempdir(), "mask.tif")
write_bin(m, my_file)
m_from_disk &lt;- read_bin(my_file)
plot(m - m_from_disk)

## End(Not run)
</code></pre>

<hr>
<h2 id='read_caim'>Read a canopy image from a file</h2><span id='topic+read_caim'></span>

<h3>Description</h3>

<p>Wrapper function for <code><a href="terra.html#topic+rast">terra::rast()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_caim(path = NULL, upper_left = NULL, width = NULL, height = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_caim_+3A_path">path</code></td>
<td>
<p>Character vector of length one. Path to an image, including file
extension. The function will return a data example if no arguments are
provided.</p>
</td></tr>
<tr><td><code id="read_caim_+3A_upper_left">upper_left</code></td>
<td>
<p>An integer vector of length two. The pixels coordinates of
the upper left corner of a region of interest (ROI). These coordinates
should be in the raster coordinates system. This system works like a
spreadsheet, i.e, when going down through the vertical axis, the <em>row</em>
number increases (<strong>IMPORTANT</strong>: column and row must be provided instead of
row and column, as is the norm for objects from the class <em>data.frame</em> and
others alike)</p>
</td></tr>
<tr><td><code id="read_caim_+3A_width">width</code>, <code id="read_caim_+3A_height">height</code></td>
<td>
<p>An integer vector of length one. The size of the boxy ROI
whose upper left corner is the <code>upper_left</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Run <code>read_caim()</code> to obtain an example of a hemispherical photo taken in
non-diffuse light conditions in a <em>Nothofagus pumilio</em> forest with a FC-E9
auxiliary lens attached to a Nikon Coolpix 5700.
</p>
<p>Since this function aims to read born-digital color photographs, RGB-JPEG and
RGB-TIFF are the expected input. However, since this function is a wrapper
for <code><a href="terra.html#topic+rast">terra::rast()</a></code>, format compatibility is heritages from it.
</p>
<p>Use <code>upper_left</code>, <code>width</code>, and <code>height</code> to read a particular region from the
file. Although any image editor can be used to obtain those parameters, this
function was tested with <a href="https://imagej.net/ij/">‘ImageJ’</a>, so it might
be wise to use it.
</p>
<p><strong>TIP</strong>: For obtaining <code>upper_left</code>, <code>width</code>, and
<code>height</code>, open the image on the Fiji distro of ImageJ, draw a rectangular
selection, and go to Edit&gt;Selection&gt;Specify. The same workflow may work with
other distros.
</p>


<h3>Value</h3>

<p>An object from class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with its layers named
<em>Red</em>, <em>Green</em>, and <em>Blue</em> when a born-digital color
photographs is provided as input.
</p>


<h3>Note</h3>

<p>The example image was obtained with this code:
</p>
<div class="sourceCode"><pre>zenith_colrow &lt;- c(1290, 988)
z &lt;- zenith_image(745*2, lens("Nikon_FCE9"))
a &lt;- azimuth_image(z)
r &lt;- read_caim_raw("DSCN4606.NEF", z, a, zenith_colrow, radius = 300)
z &lt;- zenith_image(ncol(r), lens())
r &lt;- correct_vignetting(r, z, c(0.0638, -0.101))
r &lt;- c(mean(r$Y, r$M), r$G, r$C)
r &lt;- normalize(r, -1)
write_caim(r*2^16-2, "example.tif", 16)
</pre></div>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("external/DSCN4500.JPG", package = "rcaiman")
zenith_colrow &lt;- c(1250, 1020)
diameter &lt;- 745*2
caim &lt;- read_caim(path, zenith_colrow - diameter/2, diameter, diameter)
plot(caim$Blue)
</code></pre>

<hr>
<h2 id='read_caim_raw'>Read a canopy image from a raw file</h2><span id='topic+read_caim_raw'></span>

<h3>Description</h3>

<p>Function that complements <code><a href="#topic+read_caim">read_caim()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_caim_raw(
  path = NULL,
  z = NULL,
  a = NULL,
  zenith_colrow = NULL,
  radius = 700,
  rmax = 100,
  k = 1,
  p = 1,
  only_blue = FALSE,
  offset_value = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_caim_raw_+3A_path">path</code></td>
<td>
<p>Character vector of length one.Path to a raw file, including file
extension.</p>
</td></tr>
<tr><td><code id="read_caim_raw_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="read_caim_raw_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="read_caim_raw_+3A_zenith_colrow">zenith_colrow</code></td>
<td>
<p>Numeric vector of length two. Raster coordinates of the
zenith. See <code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow()</a></code>.</p>
</td></tr>
<tr><td><code id="read_caim_raw_+3A_radius">radius</code></td>
<td>
<p>Numeric integer of length one. Radius of the reprojected
hemispherical image (i.e., the output).</p>
</td></tr>
<tr><td><code id="read_caim_raw_+3A_rmax">rmax</code></td>
<td>
<p>Numeric vector of length one. Maximum radius where to search for
<em>knn</em>. Increase this value if pixels with value <code>0</code> or
<code>FALSE</code> appears where other values are expected.</p>
</td></tr>
<tr><td><code id="read_caim_raw_+3A_k">k</code></td>
<td>
<p>Numeric vector of length one. Number of k-nearest neighbors.</p>
</td></tr>
<tr><td><code id="read_caim_raw_+3A_p">p</code></td>
<td>
<p>Numeric vector of length one. Power for inverse-distance weighting.</p>
</td></tr>
<tr><td><code id="read_caim_raw_+3A_only_blue">only_blue</code></td>
<td>
<p>Logical vector of length one. If <code>TRUE</code>, only values from
the blue or cyan wavelength will be processed.</p>
</td></tr>
<tr><td><code id="read_caim_raw_+3A_offset_value">offset_value</code></td>
<td>
<p>numeric vector. This values will replace the
<code>black_level_per_channel</code> metadata obtained with <code>rawpy</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function facilitates the integration of the <code>rawpy</code> Python package into
the R environment via the <code>reticulate</code> package. This integration allows
<code>rcaiman</code> to access and pre-process raw data.
</p>
<p>Here is a step-by-step guide to assist users in setting up the environment
for efficient processing:
</p>


<h4>Check Python Accessibility:</h4>

<p>To ensure that R can access a Python installation, run the following test:
</p>
<div class="sourceCode"><pre>reticulate::py_eval("1+1")

</pre></div>
<p>If R can access Python successfully, you will see <code>2</code> in the console. If not,
you will receive instructions on how to install Python.
</p>



<h4>Create a Virtual Environment:</h4>

<p>After passing the Python accessibility test, create a virtual environment
using the following command:
</p>
<div class="sourceCode"><pre>reticulate::virtualenv_create()

</pre></div>



<h4>Install <code>rawpy</code>:</h4>

<p>Install the rawpy package within the virtual environment:
</p>
<div class="sourceCode"><pre>reticulate::py_install("rawpy")

</pre></div>



<h4>For RStudio Users:</h4>

<p>If you are an RStudio user who works with projects, you will need a
<em>.Renviron</em> file in the root of each project. To create a <em>.Renviron</em> file,
follow these steps:
</p>

<ul>
<li><p> Create a &quot;New Blank File&quot; named &quot;.Renviron&quot; (without an extension) in the
project's root directory.
</p>
</li>
<li><p> Run bellow code:
</p>
</li></ul>

<div class="sourceCode"><pre>path &lt;- file.path(reticulate::virtualenv_root(),
reticulate::virtualenv_list(), "Scripts", "python.exe")
paste("RETICULATE_PYTHON =", path)

</pre></div>

<ul>
<li><p> Copy/paste the line from the console (the string between the quotes) into
the .Renviron file. This is an example <code style="white-space: pre;">&#8288;RETICULATE_PYTHON = ~/.virtualenvs/r-reticulate/Scripts/python.exe&#8288;</code>
</p>
</li>
<li><p> Do not forget to save the changes
</p>
</li></ul>

<p>By following these steps, users can easily set up their environment to access
raw data efficiently, but it is not the only way of doing it.
</p>



<h3>Value</h3>

<p>An object from class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. Single-layer raster if
<code>only_blue</code> is equal to <code>TRUE</code>. Otherwise, a raster with as many layers as
there are distinct colors in the Color Filter Array. Layer names are taken
from the color description metadata.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>

<hr>
<h2 id='read_manual_input'>Read manual input</h2><span id='topic+read_manual_input'></span>

<h3>Description</h3>

<p>Read manual input stored in an HSP project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_manual_input(path_to_HSP_project, img_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_manual_input_+3A_path_to_hsp_project">path_to_HSP_project</code></td>
<td>
<p>Character vector of length one. Path to the HSP
project folder. For instance,
&quot;C:/Users/johndoe/Documents/HSP/Projects/my_prj/&quot;.</p>
</td></tr>
<tr><td><code id="read_manual_input_+3A_img_name">img_name</code></td>
<td>
<p>Character vector of length one. For instance, &quot;DSCN6342.pgm&quot;
or &quot;DSCN6342&quot;. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to the Details section of function
<code><a href="#topic+write_sky_points">write_sky_points()</a></code>.
</p>


<h3>Value</h3>

<p>A list of numeric vectors named <em>weight</em>, <em>max_points</em>,
<em>angle</em>, <em>point_radius</em>, <em>sun_coord</em>, <em>sky_points</em> and
<em>zenith_dn.</em>
</p>


<h3>See Also</h3>

<p>Other HSP Functions: 
<code><a href="#topic+read_opt_sky_coef">read_opt_sky_coef</a>()</code>,
<code><a href="#topic+row_col_from_zenith_azimuth">row_col_from_zenith_azimuth</a>()</code>,
<code><a href="#topic+write_sky_points">write_sky_points</a>()</code>,
<code><a href="#topic+write_sun_coord">write_sun_coord</a>()</code>,
<code><a href="#topic+zenith_azimuth_from_row_col">zenith_azimuth_from_row_col</a>()</code>
</p>

<hr>
<h2 id='read_opt_sky_coef'>Read optimized sky coefficients</h2><span id='topic+read_opt_sky_coef'></span>

<h3>Description</h3>

<p>Read optimized CIE sky coefficients stored in an HSP project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_opt_sky_coef(path_to_HSP_project, img_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_opt_sky_coef_+3A_path_to_hsp_project">path_to_HSP_project</code></td>
<td>
<p>Character vector of length one. Path to the HSP
project folder. For instance,
&quot;C:/Users/johndoe/Documents/HSP/Projects/my_prj/&quot;.</p>
</td></tr>
<tr><td><code id="read_opt_sky_coef_+3A_img_name">img_name</code></td>
<td>
<p>Character vector of length one. For instance, &quot;DSCN6342.pgm&quot;
or &quot;DSCN6342&quot;. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to the Details section of function
<code><a href="#topic+write_sky_points">write_sky_points()</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector of length five.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cie_sky_model_raster">cie_sky_model_raster()</a></code>
</p>
<p>Other HSP Functions: 
<code><a href="#topic+read_manual_input">read_manual_input</a>()</code>,
<code><a href="#topic+row_col_from_zenith_azimuth">row_col_from_zenith_azimuth</a>()</code>,
<code><a href="#topic+write_sky_points">write_sky_points</a>()</code>,
<code><a href="#topic+write_sun_coord">write_sun_coord</a>()</code>,
<code><a href="#topic+zenith_azimuth_from_row_col">zenith_azimuth_from_row_col</a>()</code>
</p>

<hr>
<h2 id='regional_thresholding'>Regional thresholding</h2><span id='topic+regional_thresholding'></span>

<h3>Description</h3>

<p>Regional thresholding of greyscale images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regional_thresholding(
  r,
  segmentation,
  method,
  intercept = NULL,
  slope = NULL,
  prob = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regional_thresholding_+3A_r">r</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code><a href="#topic+read_caim">read_caim()</a></code>
and <code><a href="#topic+normalize">normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="regional_thresholding_+3A_segmentation">segmentation</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. The result of segmenting <code>r</code>.
Arguably, the result of a call to <code><a href="#topic+rings_segmentation">rings_segmentation()</a></code> will be the
preferred choice for fisheye images.</p>
</td></tr>
<tr><td><code id="regional_thresholding_+3A_method">method</code></td>
<td>
<p>Character vector of length one. See details for current
options.</p>
</td></tr>
<tr><td><code id="regional_thresholding_+3A_intercept">intercept</code>, <code id="regional_thresholding_+3A_slope">slope</code></td>
<td>
<p>Numeric vector of length one. These are linear
function coefficients.</p>
</td></tr>
<tr><td><code id="regional_thresholding_+3A_prob">prob</code></td>
<td>
<p>Numeric vector of length one. Probability for <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>
calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods currently implemented are:
</p>

<ul>
<li> <p><strong>Diaz2018</strong>: method presented in
Díaz and Lencinas (2018) applied regionally. If this method is
selected, the arguments <code>intercept</code>, <code>slope</code>, and <code>prob</code> should be provided.
It works segment-wise extracting the digital numbers per segment and passing
them to <code><a href="stats.html#topic+quantile">stats::quantile()</a></code> along with <code>prob</code>, which aggregated result is in
turn passed to <code><a href="#topic+thr_mblt">thr_mblt()</a></code> along with <code>intercept</code> and <code>slope</code>. Finally, this
threshold image is applied to obtain a binarized image.
</p>
</li>
<li> <p><strong>Methods from autothresholdr package</strong>: this function can call
methods from <code><a href="autothresholdr.html#topic+auto_thresh">autothresholdr::auto_thresh()</a></code>. For instance, use <code>"IsoData"</code>
to use the algorithm by Ridler and Calvard (1978), which was
recommended by Jonckheere et al. (2005).
</p>
</li>
<li> <p><strong>Method isodata from this package</strong>: Use <code>"thr_isodata"</code> to
use <code><a href="#topic+thr_isodata">thr_isodata()</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with values <code>0</code> and <code>1</code>.
</p>


<h3>References</h3>

<p>Díaz GM, Lencinas JD (2018).
&ldquo;Model-based local thresholding for canopy hemispherical photography.&rdquo;
<em>Canadian Journal of Forest Research</em>, <b>48</b>(10), 1204&ndash;1216.
<a href="https://doi.org/10.1139/cjfr-2018-0006">doi:10.1139/cjfr-2018-0006</a>.<br /><br /> Jonckheere I, Nackaerts K, Muys B, Coppin P (2005).
&ldquo;Assessment of automatic gap fraction estimation of forests from digital hemispherical photography.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>132</b>(1-2), 96&ndash;114.
<a href="https://doi.org/10.1016/j.agrformet.2005.06.003">doi:10.1016/j.agrformet.2005.06.003</a>.<br /><br /> Ridler TW, Calvard S (1978).
&ldquo;Picture thresholding using an iterative selection method.&rdquo;
<em>IEEE Transactions on Systems, Man, and Cybernetics</em>, <b>8</b>(8), 630&ndash;632.
<a href="https://doi.org/10.1109/tsmc.1978.4310039">doi:10.1109/tsmc.1978.4310039</a>.
</p>


<h3>See Also</h3>

<p>Other Binarization Functions: 
<code><a href="#topic+apply_thr">apply_thr</a>()</code>,
<code><a href="#topic+obia">obia</a>()</code>,
<code><a href="#topic+ootb_mblt">ootb_mblt</a>()</code>,
<code><a href="#topic+ootb_obia">ootb_obia</a>()</code>,
<code><a href="#topic+thr_isodata">thr_isodata</a>()</code>,
<code><a href="#topic+thr_mblt">thr_mblt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- system.file("external/DSCN4500.JPG", package = "rcaiman")
caim &lt;- read_caim(path, c(1250, 1020) - 745, 745 * 2, 745 * 2)
z &lt;- zenith_image(ncol(caim), lens("Nikon_FCE9"))
r &lt;- gbc(caim$Blue)
r &lt;- correct_vignetting(r, z, c(0.0638, -0.101)) %&gt;% normalize()
rings &lt;- rings_segmentation(z, 15)
bin &lt;- regional_thresholding(r, rings, "Diaz2018", -7.8, 0.95 * 0.5, 0.99)
plot(bin)
bin &lt;- regional_thresholding(r, rings, "thr_isodata")
plot(bin)
#' 
## End(Not run)
</code></pre>

<hr>
<h2 id='rings_segmentation'>Do rings segmentation</h2><span id='topic+rings_segmentation'></span>

<h3>Description</h3>

<p>Segment an hemispherical view by slicing the zenith angle from zero to 90º
in equals intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rings_segmentation(z, angle_width, return_angle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rings_segmentation_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="rings_segmentation_+3A_angle_width">angle_width</code></td>
<td>
<p>Numeric vector of length one. Angle in degrees able to
divide the angle range into a whole number of segments.</p>
</td></tr>
<tr><td><code id="rings_segmentation_+3A_return_angle">return_angle</code></td>
<td>
<p>Logical vector of length one. If it is <code>FALSE</code>, all
the pixels that belong to a segment are labeled with an ID number.
Otherwise, the angle mean of the segment is assigned to the pixels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object from the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with segments
shaped like concentric rings.
</p>


<h3>See Also</h3>

<p>Other Segmentation Functions: 
<code><a href="#topic+chessboard">chessboard</a>()</code>,
<code><a href="#topic+mask_hs">mask_hs</a>()</code>,
<code><a href="#topic+mask_sunlit_canopy">mask_sunlit_canopy</a>()</code>,
<code><a href="#topic+polar_qtree">polar_qtree</a>()</code>,
<code><a href="#topic+qtree">qtree</a>()</code>,
<code><a href="#topic+sectors_segmentation">sectors_segmentation</a>()</code>,
<code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zenith_image(600, lens())
rings &lt;- rings_segmentation(z, 15)
plot(rings == 1)
</code></pre>

<hr>
<h2 id='row_col_from_zenith_azimuth'>Obtain row and col numbers from zenith and azimuth angles</h2><span id='topic+row_col_from_zenith_azimuth'></span>

<h3>Description</h3>

<p>Obtain row and col numbers from zenith and azimuth angles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_col_from_zenith_azimuth(z, a, za, lens_coef = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row_col_from_zenith_azimuth_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="row_col_from_zenith_azimuth_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="row_col_from_zenith_azimuth_+3A_za">za</code></td>
<td>
<p>Numeric vector of length two. Zenith and azimuth angles in degrees.</p>
</td></tr>
<tr><td><code id="row_col_from_zenith_azimuth_+3A_lens_coef">lens_coef</code></td>
<td>
<p>Numeric vector. Polynomial coefficients of the lens
projection function. See <code><a href="#topic+calibrate_lens">calibrate_lens()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length two.
</p>


<h3>Note</h3>

<p>Use the <code>lens_coef</code> argument to calculate coordinates below the horizon.
</p>


<h3>See Also</h3>

<p>Other HSP Functions: 
<code><a href="#topic+read_manual_input">read_manual_input</a>()</code>,
<code><a href="#topic+read_opt_sky_coef">read_opt_sky_coef</a>()</code>,
<code><a href="#topic+write_sky_points">write_sky_points</a>()</code>,
<code><a href="#topic+write_sun_coord">write_sun_coord</a>()</code>,
<code><a href="#topic+zenith_azimuth_from_row_col">zenith_azimuth_from_row_col</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zenith_image(1000, lens())
a &lt;- azimuth_image(z)
row_col_from_zenith_azimuth(z, a, c(45, 270))
</code></pre>

<hr>
<h2 id='sectors_segmentation'>Do sectors segmentation</h2><span id='topic+sectors_segmentation'></span>

<h3>Description</h3>

<p>Segment a hemispherical view by slicing the azimuth angle from zero
to 360º in equals intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sectors_segmentation(a, angle_width, return_angle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sectors_segmentation_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="sectors_segmentation_+3A_angle_width">angle_width</code></td>
<td>
<p>Numeric vector of length one. Angle in degrees able to
divide the angle range into a whole number of segments.</p>
</td></tr>
<tr><td><code id="sectors_segmentation_+3A_return_angle">return_angle</code></td>
<td>
<p>Logical vector of length one. If it is <code>FALSE</code>, all
the pixels that belong to a segment are labeled with an ID number.
Otherwise, the angle mean of the segment is assigned to the pixels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object from the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with segments
shaped like pizza slices.
</p>


<h3>See Also</h3>

<p>Other Segmentation Functions: 
<code><a href="#topic+chessboard">chessboard</a>()</code>,
<code><a href="#topic+mask_hs">mask_hs</a>()</code>,
<code><a href="#topic+mask_sunlit_canopy">mask_sunlit_canopy</a>()</code>,
<code><a href="#topic+polar_qtree">polar_qtree</a>()</code>,
<code><a href="#topic+qtree">qtree</a>()</code>,
<code><a href="#topic+rings_segmentation">rings_segmentation</a>()</code>,
<code><a href="#topic+sky_grid_segmentation">sky_grid_segmentation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zenith_image(600, lens())
a &lt;- azimuth_image(z)
sectors &lt;- sectors_segmentation(a, 15)
plot(sectors == 1)
</code></pre>

<hr>
<h2 id='sky_grid_segmentation'>Do sky grid segmentation</h2><span id='topic+sky_grid_segmentation'></span>

<h3>Description</h3>

<p>Segment the hemisphere view into segments of equal angular resolution for
both zenith and azimuth angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sky_grid_segmentation(z, a, angle_width, sequential = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sky_grid_segmentation_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="sky_grid_segmentation_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="sky_grid_segmentation_+3A_angle_width">angle_width</code></td>
<td>
<p>Numeric vector of length one. It should be <code style="white-space: pre;">&#8288;30, 15, 10, 7.5, 6, 5, 3.75, 3, 2.5, 1.875, 1&#8288;</code> or <code>0.5</code> degrees. This
constrain is rooted in the requirement of a value able to divide both the
<code>0</code> to <code>360</code> and <code>0</code> to <code>90</code> ranges into a whole number
of segments.</p>
</td></tr>
<tr><td><code id="sky_grid_segmentation_+3A_sequential">sequential</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code>, the
segments are labeled with sequential numbers. By default (<code>FALSE</code>),
labeling numbers are not sequential (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intersecting rings with sectors makes a grid in which each cell is a
portion of the hemisphere. Each pixel of the grid is labeled with an ID that
codify both ring and sector IDs. For example, a grid with a regular interval
of one degree has segment from <code>1001</code> to <code>360090</code>. This numbers are
calculated with: <code class="reqn">sectorID \times 1000 + ringID</code>, where <code class="reqn">sectorID</code> is
the ID number of the sector and <code class="reqn">ringID</code> is the ID number of the ring.
</p>


<h3>Value</h3>

<p>An object from the class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> with segments
shaped like windshields, though some of them will look elongated in
height. The pattern is two opposite and converging straight sides and two
opposite and parallel curvy sides.
</p>


<h3>See Also</h3>

<p>Other Segmentation Functions: 
<code><a href="#topic+chessboard">chessboard</a>()</code>,
<code><a href="#topic+mask_hs">mask_hs</a>()</code>,
<code><a href="#topic+mask_sunlit_canopy">mask_sunlit_canopy</a>()</code>,
<code><a href="#topic+polar_qtree">polar_qtree</a>()</code>,
<code><a href="#topic+qtree">qtree</a>()</code>,
<code><a href="#topic+rings_segmentation">rings_segmentation</a>()</code>,
<code><a href="#topic+sectors_segmentation">sectors_segmentation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zenith_image(600, lens())
a &lt;- azimuth_image(z)
g &lt;- sky_grid_segmentation(z, a, 15)
plot(g == 24005)
## Not run: 
g &lt;- sky_grid_segmentation(z, a, 15, sequential = TRUE)
col &lt;- terra::unique(g) %&gt;% nrow() %&gt;% rainbow() %&gt;% sample()
plot(g, col = col)

## End(Not run)
</code></pre>

<hr>
<h2 id='test_lens_coef'>Test lens projection functions</h2><span id='topic+test_lens_coef'></span>

<h3>Description</h3>

<p>Test if a lens projection function will work between the 0-to-1 range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_lens_coef(lens_coef)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_lens_coef_+3A_lens_coef">lens_coef</code></td>
<td>
<p>Numeric vector. Polynomial coefficients of the lens
projection function. See <code><a href="#topic+calibrate_lens">calibrate_lens()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package tolerate a number very close to 1 but not exactly 1 as long as it
is greater than 1. Therefore, when the test fails at this <em>&quot;Test that
lens projection function does not predict values barely below one&quot;</em>, the best
practice is to manually edit the last coefficient. For instance, changing it
from -0.0296 to -0.0295. See <code><a href="testthat.html#topic+equality-expectations">testthat::expect_equal()</a></code> for further details.
</p>
<p>If it fails in <em>&quot;Test that lens projection function works between the
0-to-1 range&quot;</em>, collecting data again might be necessary.
</p>


<h3>Value</h3>

<p>Returns <code>invisible(TRUE)</code> and print &quot;Test passed&quot; if all tests
pass, otherwise throws an error.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+zenith_image">zenith_image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_lens_coef(lens("Nikon_FCE9"))
test_lens_coef(2/pi)
</code></pre>

<hr>
<h2 id='thr_isodata'>Calculate a threshold with the isodata method</h2><span id='topic+thr_isodata'></span>

<h3>Description</h3>

<p>Threshold calculated with the algorithm by
Ridler and Calvard (1978), which was recommended by
Jonckheere et al. (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thr_isodata(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thr_isodata_+3A_x">x</code></td>
<td>
<p>Numeric vector or a single-column <em>matrix</em> or <em>data.frame</em>
able to be coerced to numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation is based on
<a href="https://imagej.net/plugins/auto-threshold#IsoData">the IsoData method of Auto Threshold ImageJ plugin by Gabriel Landini</a>, which is now available
in the <code>autothresholdr</code> package (<code><a href="autothresholdr.html#topic+auto_thresh">autothresholdr::auto_thresh()</a></code>).
However, I found this implementarion more versatile since it is not
restricted to an 8-bit input.
</p>


<h3>Value</h3>

<p>Numeric vector of length one.
</p>


<h3>References</h3>

<p>Jonckheere I, Nackaerts K, Muys B, Coppin P (2005).
&ldquo;Assessment of automatic gap fraction estimation of forests from digital hemispherical photography.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>132</b>(1-2), 96&ndash;114.
<a href="https://doi.org/10.1016/j.agrformet.2005.06.003">doi:10.1016/j.agrformet.2005.06.003</a>.<br /><br /> Ridler TW, Calvard S (1978).
&ldquo;Picture thresholding using an iterative selection method.&rdquo;
<em>IEEE Transactions on Systems, Man, and Cybernetics</em>, <b>8</b>(8), 630&ndash;632.
<a href="https://doi.org/10.1109/tsmc.1978.4310039">doi:10.1109/tsmc.1978.4310039</a>.
</p>


<h3>See Also</h3>

<p>Other Binarization Functions: 
<code><a href="#topic+apply_thr">apply_thr</a>()</code>,
<code><a href="#topic+obia">obia</a>()</code>,
<code><a href="#topic+ootb_mblt">ootb_mblt</a>()</code>,
<code><a href="#topic+ootb_obia">ootb_obia</a>()</code>,
<code><a href="#topic+regional_thresholding">regional_thresholding</a>()</code>,
<code><a href="#topic+thr_mblt">thr_mblt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caim &lt;- read_caim()
r &lt;- gbc(caim$Blue)
thr &lt;- thr_isodata(values(r))
bin &lt;- apply_thr(r, thr)
plot(bin)
</code></pre>

<hr>
<h2 id='thr_mblt'>Calculate thresholds with the model-based method</h2><span id='topic+thr_mblt'></span>

<h3>Description</h3>

<p>Transform background digital number into threshold values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thr_mblt(dn, intercept, slope)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thr_mblt_+3A_dn">dn</code></td>
<td>
<p>Numeric vector or <a href="terra.html#topic+SpatRaster-class">SpatRaster</a>. Digital number of the
background. These values should be normalized and, if they are extracted
from a JPEG image, gamma back corrected.</p>
</td></tr>
<tr><td><code id="thr_mblt_+3A_intercept">intercept</code>, <code id="thr_mblt_+3A_slope">slope</code></td>
<td>
<p>Numeric vector of length one. These are linear
function coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function transforms background digital numbers into threshold values by
means of the Equation 1 from Díaz and Lencinas (2018), which is
a linear function with the slope modified by a weighting parameter. This
simple function was found by studying canopy models, also known as targets,
which are perforated surfaces made of a rigid and dark material . These
models were backlighted with homogeneous lighting, photographed with a Nikon
Coolpix 5700 set to acquire in JPEG format, and those images were gamma back
corrected with a default gamma value equal to 2.2 (see <code><a href="#topic+gbc">gbc()</a></code>). Results
shown that the optimal threshold value was linearly related with the
background digital number (see Figure 1 and Figure 7 from
Díaz and Lencinas (2018)). This shifted the aim from finding
the optimal threshold, following Song et al. (2014)
method, to obtaining the background DN as if the canopy was not there, as
Lang et al. (2010) proposed.
</p>


<h4>Working principle</h4>

<p>Díaz and Lencinas (2018) observed the following linear
relationship between the background value, usually the sky digital number
(SDN), and the optimal threshold value (OTV):</p>

<table>
<tr>
 <td style="text-align: left;">
   <code class="reqn">IV = a + b \cdot SDN</code> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: right;"> (Equation 1a) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;">
   <code class="reqn">OTV = a + b \cdot w \cdot SDN</code> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: right;"> (Equation 1b) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>were IV is the initial value (Wagner 2001), which is the
boundary between SDN and the mixed pixels, i.e, the pixels that are neither
<em>Gap</em> or <em>Non-gap</em> (Macfarlane 2011), <code class="reqn">a</code> and <code class="reqn">b</code>
are the intercept and slope coefficients, respectively, and <code class="reqn">w</code> is a
weighting parameter that takes into account that OTV is always lower than IV.
If SDN is calculated at the pixel level, a local thresholding method can be
applied by evaluating, pixel by pixel, if the below canopy digital number
(CDN) is greater than the OTV. Formally, If <code class="reqn">CDN&gt;OTV</code>, then assign <em>Gap</em>
class, else assign <em>Non-gap</em> class.
</p>
<p>This conclusion drawn from an image processing point of view matches with
previous findings drawn from a radiometric measurement paradigm, which are
introduced next.
</p>
<p>Cescatti (2007) posed that cameras can be used as
a radiation measurement device if they are properly calibrated. This method,
denominated by the author as LinearRatio, seeks to obtain the transmittance
(T) as the ratio of below to above canopy radiation:</p>

<table>
<tr>
 <td style="text-align: left;">
   <code class="reqn">T = CDN/SDN</code> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: right;"> (Equation 2) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>were CDN is below canopy digital number (DN), i.e., the DN extracted from a
canopy hemispherical photograph.
</p>
<p>The LinearRatio method uses T as a proxy for gap fraction. It
requires twin cameras, one below and the other above the canopy. In contrast,
Lang et al. (2010) proposed to obtain SDN by manually
selecting pure sky pixels from canopy hemispherical photographs and
reconstructing the whole sky by subsequent modeling and interpolating&mdash;this
method is often referred to as LinearRatio single camera or LinearRatioSC.
</p>
<p>Equation 2 can be seen as a standardization of the distance between CDN and
SDN. With that in mind, it is useful to rewrite Equation 1b as an inequality
that can be evaluated to return a logical statement that is directly
translated into the desired binary classification:</p>

<table>
<tr>
 <td style="text-align: left;">
   <code class="reqn">CDN &gt; a + b \cdot w \cdot SDN</code> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: right;"> (Equation 3) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Then, combining Equation 2 and 3, we find that
Díaz and Lencinas (2018) parameters can be applied to T:</p>

<table>
<tr>
 <td style="text-align: left;">
   <code class="reqn">CDN/SDN &gt; a + b \cdot w \cdot SDN/SDN</code> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: right;"> (Equation 4a) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;">
   <code class="reqn">T &gt; a + b \cdot w</code> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: right;"> (Equation 4b) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>From Equation 2 it is evident that any bias introduced by the camera optical
and electronic system will be canceled during the calculation of T as long as
only one camera is involved. Therefore, After examining Equation 4b, we can
conclude that intercept 0 and slope 1 are theoretically correct.In addition,
the w parameter can be used to filter out mixed pixels. The greater w, the
greater the possibility of selecting pure sky pixels.
</p>



<h3>Value</h3>

<p>An object of the same class and dimensions than <code>dn</code>.
</p>


<h3>Note</h3>

<p>It is worth noting that Equation 1 was developed with 8-bit images, so
calibration of new coefficient should be done in the 0 to 255 domain since
that is what <code><a href="#topic+thr_mblt">thr_mblt()</a></code> expect, although the <code>dn</code> argument should be
normalized. The latter, in spite of sounding counter intuitive, was a design
decision aiming to harmonize the whole package.
</p>
<p>Nevertheless, new empirical calibration on JPEG files may be unnecessary
since the values -7.8 <code>intercept</code> and 0.95 <code>slope</code> that had been observed
with back-gamma corrected JPEG files produced with the Nikon Coolpix 5700
camera are sufficiently close to the theoretical values that it sounds
reasonable to interpret them as a confirmation of the theory.
</p>
<p>Users are encouraged to adopt raw file acquisition (<code><a href="#topic+read_caim_raw">read_caim_raw()</a></code>).
</p>
<p>To apply the weighting parameter (w) from Equation 1, just provide the
argument <code>slope</code> as <code class="reqn">slope \times w</code>.
</p>


<h3>References</h3>

<p>Cescatti A (2007).
&ldquo;Indirect estimates of canopy gap fraction based on the linear conversion of hemispherical photographs.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>143</b>(1-2), 1&ndash;12.
<a href="https://doi.org/10.1016/j.agrformet.2006.04.009">doi:10.1016/j.agrformet.2006.04.009</a>.<br /><br /> Díaz GM, Lencinas JD (2018).
&ldquo;Model-based local thresholding for canopy hemispherical photography.&rdquo;
<em>Canadian Journal of Forest Research</em>, <b>48</b>(10), 1204&ndash;1216.
<a href="https://doi.org/10.1139/cjfr-2018-0006">doi:10.1139/cjfr-2018-0006</a>.<br /><br /> Lang M, Kuusk A, M~ottus M, Rautiainen M, Nilson T (2010).
&ldquo;Canopy gap fraction estimation from digital hemispherical images using sky radiance models and a linear conversion method.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>150</b>(1), 20&ndash;29.
<a href="https://doi.org/10.1016/j.agrformet.2009.08.001">doi:10.1016/j.agrformet.2009.08.001</a>.<br /><br /> Macfarlane C (2011).
&ldquo;Classification method of mixed pixels does not affect canopy metrics from digital images of forest overstorey.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>151</b>(7), 833&ndash;840.
<a href="https://doi.org/10.1016/j.agrformet.2011.01.019">doi:10.1016/j.agrformet.2011.01.019</a>.<br /><br /> Song GM, Doley D, Yates D, Chao K, Hsieh C (2014).
&ldquo;Improving accuracy of canopy hemispherical photography by a constant threshold value derived from an unobscured overcast sky.&rdquo;
<em>Canadian Journal of Forest Research</em>, <b>44</b>(1), 17&ndash;27.
<a href="https://doi.org/10.1139/cjfr-2013-0082">doi:10.1139/cjfr-2013-0082</a>.<br /><br /> Wagner S (2001).
&ldquo;Relative radiance measurements and zenith angle dependent segmentation in hemispherical photography.&rdquo;
<em>Agricultural and Forest Meteorology</em>, <b>107</b>(2), 103&ndash;115.
<a href="https://doi.org/10.1016/s0168-1923%2800%2900232-x">doi:10.1016/s0168-1923(00)00232-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+gbc">gbc()</a></code>, <code><a href="#topic+apply_thr">apply_thr()</a></code> and <code><a href="#topic+regional_thresholding">regional_thresholding()</a></code>.
</p>
<p>Other Binarization Functions: 
<code><a href="#topic+apply_thr">apply_thr</a>()</code>,
<code><a href="#topic+obia">obia</a>()</code>,
<code><a href="#topic+ootb_mblt">ootb_mblt</a>()</code>,
<code><a href="#topic+ootb_obia">ootb_obia</a>()</code>,
<code><a href="#topic+regional_thresholding">regional_thresholding</a>()</code>,
<code><a href="#topic+thr_isodata">thr_isodata</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>thr_mblt(gbc(125), -7.8, 0.95 * 0.5)
</code></pre>

<hr>
<h2 id='write_bin'>Write binarized images</h2><span id='topic+write_bin'></span>

<h3>Description</h3>

<p>Wrapper functions for <code><a href="terra.html#topic+writeRaster">terra::writeRaster()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_bin(bin, path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_bin_+3A_bin">bin</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>.</p>
</td></tr>
<tr><td><code id="write_bin_+3A_path">path</code></td>
<td>
<p>Character vector of length one. Path for writing the image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Called for side effects.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_caim">write_caim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
z &lt;- zenith_image(1000, lens())
m &lt;- !is.na(z)
my_file &lt;- file.path(tempdir(), "mask")
write_bin(m, my_file)
my_file &lt;- as.filename(my_file) %&gt;%
  insert(., ext = "tif", replace = TRUE) %&gt;%
  as.character()
m_from_disk &lt;- read_bin(my_file)
plot(m - m_from_disk)

## End(Not run)
</code></pre>

<hr>
<h2 id='write_caim'>Write canopy image</h2><span id='topic+write_caim'></span>

<h3>Description</h3>

<p>Wrapper function for <code><a href="terra.html#topic+writeRaster">terra::writeRaster()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_caim(caim, path, bit_depth)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_caim_+3A_caim">caim</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a>.</p>
</td></tr>
<tr><td><code id="write_caim_+3A_path">path</code></td>
<td>
<p>Character vector of length one. Path for writing the image.</p>
</td></tr>
<tr><td><code id="write_caim_+3A_bit_depth">bit_depth</code></td>
<td>
<p>Numeric vector of length one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Called for side effects.
</p>


<h3>See Also</h3>

<p>Other Tool Functions: 
<code><a href="#topic+colorfulness">colorfulness</a>()</code>,
<code><a href="#topic+correct_vignetting">correct_vignetting</a>()</code>,
<code><a href="#topic+defuzzify">defuzzify</a>()</code>,
<code><a href="#topic+extract_dn">extract_dn</a>()</code>,
<code><a href="#topic+extract_feature">extract_feature</a>()</code>,
<code><a href="#topic+extract_rl">extract_rl</a>()</code>,
<code><a href="#topic+extract_sky_points_simple">extract_sky_points_simple</a>()</code>,
<code><a href="#topic+extract_sky_points">extract_sky_points</a>()</code>,
<code><a href="#topic+extract_sun_coord">extract_sun_coord</a>()</code>,
<code><a href="#topic+find_sky_pixels_nonnull">find_sky_pixels_nonnull</a>()</code>,
<code><a href="#topic+find_sky_pixels">find_sky_pixels</a>()</code>,
<code><a href="#topic+masking">masking</a>()</code>,
<code><a href="#topic+optim_normalize">optim_normalize</a>()</code>,
<code><a href="#topic+percentage_of_clipped_highlights">percentage_of_clipped_highlights</a>()</code>,
<code><a href="#topic+read_bin">read_bin</a>()</code>,
<code><a href="#topic+read_caim_raw">read_caim_raw</a>()</code>,
<code><a href="#topic+read_caim">read_caim</a>()</code>,
<code><a href="#topic+write_bin">write_bin</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
caim &lt;- read_caim() %&gt;% normalize(., 0, 255)
write_caim(caim * 2^8-2, file.path(tempdir(), "test_8bit"), 8)
write_caim(caim * 2^16-2, file.path(tempdir(), "test_16bit"), 16)
# Note: the normalized values are scaled by multiplying by 2^bit_depth-2
# to avoid storing in the maximum bin because those values will be
# interpreted as NA by read_caim(), and that is undesired.

## End(Not run)
</code></pre>

<hr>
<h2 id='write_sky_points'>Write sky points</h2><span id='topic+write_sky_points'></span>

<h3>Description</h3>

<p>Create a special file to interface with the HSP software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_sky_points(sky_points, path_to_HSP_project, img_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_sky_points_+3A_sky_points">sky_points</code></td>
<td>
<p>An object of the class <em>data.frame</em>. The result of a
calling to <code><a href="#topic+extract_sky_points">extract_sky_points()</a></code>.</p>
</td></tr>
<tr><td><code id="write_sky_points_+3A_path_to_hsp_project">path_to_HSP_project</code></td>
<td>
<p>Character vector of length one. Path to the HSP
project folder. For instance,
&quot;C:/Users/johndoe/Documents/HSP/Projects/my_prj/&quot;.</p>
</td></tr>
<tr><td><code id="write_sky_points_+3A_img_name">img_name</code></td>
<td>
<p>Character vector of length one. For instance, &quot;DSCN6342.pgm&quot;
or &quot;DSCN6342&quot;. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is part of a workflow that connects this package with the HSP
software package (Lang et al. 2013).
</p>
<p>This function was designed to be called after
<code><a href="#topic+extract_sky_points">extract_sky_points()</a></code>. The <code>r</code> argument provided to
<code><a href="#topic+extract_sky_points">extract_sky_points()</a></code> should be an image pre-processed by the HSP
software. Those images are stored as PGM files in the subfolder &quot;manipulate&quot;
of the project folder (which will be in turn a subfolder of the
&quot;project<strong>s</strong>&quot; folder). Those PGM files can be read with
<code><a href="#topic+read_caim">read_caim()</a></code>.
</p>
<p>The <code>img_name</code> argument of <code>write_sky_points()</code> should be the name
of the file associated to the aforementioned <code>r</code> argument.
</p>
<p>The following code exemplifies how this package can be used in conjunction
with the HSP software. The code assumes that the user is working within an
RStudio project located in the HSP project folder.
</p>
<pre>
r &lt;- read_caim("manipulate/IMG_1014.pgm") 
plot(r)
z &lt;- zenith_image(ncol(r), lens())
a &lt;- azimuth_image(z)
g &lt;- sky_grid_segmentation(z, a, 10)
mblt &lt;- ootb_mblt(r, z, a)$bin
bin &lt;- mask_hs(z, 0, 85) &amp; bin

sun_coord &lt;- extract_sun_coord(r, z, a, bin, g)
write_sun_coord(sun_coord$row_col, ".", "IMG_1014")

sky_points &lt;- extract_sky_points(r, bin, g)
write_sky_points(sky_points, ".", "IMG_1014")
</pre>


<h3>Value</h3>

<p>None. A file will be written in the HSP project folder.
</p>


<h3>References</h3>

<p>Lang M, Kodar A, Arumäe T (2013).
&ldquo;Restoration of above canopy reference hemispherical image from below canopy measurements for plant area index estimation in forests.&rdquo;
<em>Forestry Studies</em>, <b>59</b>(1), 13&ndash;27.
<a href="https://doi.org/10.2478/fsmu-2013-0008">doi:10.2478/fsmu-2013-0008</a>.
</p>


<h3>See Also</h3>

<p>Other HSP Functions: 
<code><a href="#topic+read_manual_input">read_manual_input</a>()</code>,
<code><a href="#topic+read_opt_sky_coef">read_opt_sky_coef</a>()</code>,
<code><a href="#topic+row_col_from_zenith_azimuth">row_col_from_zenith_azimuth</a>()</code>,
<code><a href="#topic+write_sun_coord">write_sun_coord</a>()</code>,
<code><a href="#topic+zenith_azimuth_from_row_col">zenith_azimuth_from_row_col</a>()</code>
</p>

<hr>
<h2 id='write_sun_coord'>Write sun coordinates</h2><span id='topic+write_sun_coord'></span>

<h3>Description</h3>

<p>Create a special file to interface with the HSP software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_sun_coord(sun_coord, path_to_HSP_project, img_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_sun_coord_+3A_sun_coord">sun_coord</code></td>
<td>
<p>Numeric vector of length two. Raster coordinates of the
solar disk that can be obtained by calling to
<code><a href="#topic+extract_sun_coord">extract_sun_coord()</a></code>. <strong>TIP</strong>: if the output of
<code>extrac_sun_coord()</code> is <code>sun_coord</code>, then you should provide here
this: <code>sun_coord$row_col</code>. See also
<code><a href="#topic+row_col_from_zenith_azimuth">row_col_from_zenith_azimuth()</a></code> in case you want to provide
values based on date and time of acquisition and the <code>suncalc</code> package.</p>
</td></tr>
<tr><td><code id="write_sun_coord_+3A_path_to_hsp_project">path_to_HSP_project</code></td>
<td>
<p>Character vector of length one. Path to the HSP
project folder. For instance,
&quot;C:/Users/johndoe/Documents/HSP/Projects/my_prj/&quot;.</p>
</td></tr>
<tr><td><code id="write_sun_coord_+3A_img_name">img_name</code></td>
<td>
<p>Character vector of length one. For instance, &quot;DSCN6342.pgm&quot;
or &quot;DSCN6342&quot;. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to the Details section of function <code><a href="#topic+write_sky_points">write_sky_points()</a></code>.
</p>


<h3>Value</h3>

<p>None. A file will be written in the HSP project folder.
</p>


<h3>See Also</h3>

<p>Other HSP Functions: 
<code><a href="#topic+read_manual_input">read_manual_input</a>()</code>,
<code><a href="#topic+read_opt_sky_coef">read_opt_sky_coef</a>()</code>,
<code><a href="#topic+row_col_from_zenith_azimuth">row_col_from_zenith_azimuth</a>()</code>,
<code><a href="#topic+write_sky_points">write_sky_points</a>()</code>,
<code><a href="#topic+zenith_azimuth_from_row_col">zenith_azimuth_from_row_col</a>()</code>
</p>

<hr>
<h2 id='zenith_azimuth_from_row_col'>Obtain zenith and azimuth angles from row and col numbers</h2><span id='topic+zenith_azimuth_from_row_col'></span>

<h3>Description</h3>

<p>Obtain zenith and azimuth angles from row and col numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zenith_azimuth_from_row_col(z, a, row_col, lens_coef = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zenith_azimuth_from_row_col_+3A_z">z</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+zenith_image">zenith_image()</a></code>.</p>
</td></tr>
<tr><td><code id="zenith_azimuth_from_row_col_+3A_a">a</code></td>
<td>
<p><a href="terra.html#topic+SpatRaster-class">SpatRaster</a> built with <code><a href="#topic+azimuth_image">azimuth_image()</a></code>.</p>
</td></tr>
<tr><td><code id="zenith_azimuth_from_row_col_+3A_row_col">row_col</code></td>
<td>
<p>Numeric vector of length two. Row and col numbers.</p>
</td></tr>
<tr><td><code id="zenith_azimuth_from_row_col_+3A_lens_coef">lens_coef</code></td>
<td>
<p>Numeric vector. Polynomial coefficients of the lens
projection function. See <code><a href="#topic+calibrate_lens">calibrate_lens()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length two.
</p>


<h3>Note</h3>

<p>Use the <code>lens_coef</code> argument to calculate coordinates below the horizon.
</p>


<h3>See Also</h3>

<p>Other HSP Functions: 
<code><a href="#topic+read_manual_input">read_manual_input</a>()</code>,
<code><a href="#topic+read_opt_sky_coef">read_opt_sky_coef</a>()</code>,
<code><a href="#topic+row_col_from_zenith_azimuth">row_col_from_zenith_azimuth</a>()</code>,
<code><a href="#topic+write_sky_points">write_sky_points</a>()</code>,
<code><a href="#topic+write_sun_coord">write_sun_coord</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zenith_image(1000, lens())
a &lt;- azimuth_image(z)
zenith_azimuth_from_row_col(z, a, c(501, 750))
</code></pre>

<hr>
<h2 id='zenith_image'>Build Zenith image</h2><span id='topic+zenith_image'></span>

<h3>Description</h3>

<p>Build a single layer-image with zenith angle values, assuming upwards-looking
hemispherical photography with the optical axis vertically aligned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zenith_image(diameter, lens_coef)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zenith_image_+3A_diameter">diameter</code></td>
<td>
<p>Numeric vector of length one. Diameter in pixels expressed as
an even integer. The latter is to simplify calculations by having the
zenith point located between pixels. Snapping the zenith point between
pixels does not affect accuracy because half-pixel is less than the
uncertainty in localizing the circle within the picture.</p>
</td></tr>
<tr><td><code id="zenith_image_+3A_lens_coef">lens_coef</code></td>
<td>
<p>Numeric vector. Polynomial coefficients of the lens
projection function. See <code><a href="#topic+calibrate_lens">calibrate_lens()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="terra.html#topic+SpatRaster-class">SpatRaster</a> of zenith angles in degrees,
showing a complete hemispherical view with the zenith on the center.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code><a href="#topic+azimuth_image">azimuth_image</a>()</code>,
<code><a href="#topic+calc_diameter">calc_diameter</a>()</code>,
<code><a href="#topic+calc_relative_radius">calc_relative_radius</a>()</code>,
<code><a href="#topic+calc_zenith_colrow">calc_zenith_colrow</a>()</code>,
<code><a href="#topic+calibrate_lens">calibrate_lens</a>()</code>,
<code><a href="#topic+crosscalibrate_lens">crosscalibrate_lens</a>()</code>,
<code><a href="#topic+expand_noncircular">expand_noncircular</a>()</code>,
<code><a href="#topic+extract_radiometry">extract_radiometry</a>()</code>,
<code><a href="#topic+fisheye_to_equidistant">fisheye_to_equidistant</a>()</code>,
<code><a href="#topic+fisheye_to_pano">fisheye_to_pano</a>()</code>,
<code><a href="#topic+lens">lens</a>()</code>,
<code><a href="#topic+test_lens_coef">test_lens_coef</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- zenith_image(600, lens("Nikon_FCE9"))
plot(z)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
