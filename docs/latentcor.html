<!DOCTYPE html><html lang="en"><head><title>Help for package latentcor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {latentcor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#evaluation'><p>Numerical evaluation for different estimation methods.</p></a></li>
<li><a href='#gen_data'><p>Mixed type simulation data generator</p></a></li>
<li><a href='#get_types'><p>Automatically determine types of each variable (continuous/binary/ternary/truncated) in a data matrix.</p></a></li>
<li><a href='#interpolant'><p>Evaluate an interpolant in a point</p></a></li>
<li><a href='#interpolation'><p>Parallel version of multilinear interpolation generator for function approximation</p></a></li>
<li><a href='#ipol'><p>Create an interpolating function from given values. Several interpolation methods are</p>
supported.</a></li>
<li><a href='#latentcor'><p>Estimate latent correlation for mixed types.</p></a></li>
<li><a href='#mlappx.real'><p>Multilinear interpolation on a grid</p></a></li>
<li><a href='#r_ml_wrapper'><p>Port function to call multilinear interpolants for continuous developers.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Computation of Latent Correlations for Mixed Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mingze Huang &lt;mingzehuang@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The first stand-alone R package for computation of latent correlation that takes into account all variable types (continuous/binary/ordinal/zero-inflated),
             comes with an optimized memory footprint, and is computationally efficient, essentially making latent correlation estimation almost as fast as rank-based correlation estimation.
             The estimation is based on latent copula Gaussian models.
             For continuous/binary types, see Fan, J., Liu, H., Ning, Y., and Zou, H. (2017).
             For ternary type, see Quan X., Booth J.G. and Wells M.T. (2018) &lt;<a href="https://doi.org/10.48550/arXiv.1809.06255">doi:10.48550/arXiv.1809.06255</a>&gt;.
             For truncated type or zero-inflated type, see Yoon G., Carroll R.J. and Gaynanova I. (2020) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasaa007">doi:10.1093/biomet/asaa007</a>&gt;.
             For approximation method of computation, see Yoon G., MÃ¼ller C.L. and Gaynanova I. (2021) &lt;<a href="https://doi.org/10.1080%2F10618600.2021.1882468">doi:10.1080/10618600.2021.1882468</a>&gt;. The latter method uses multi-linear interpolation originally implemented in the R package <a href="https://cran.r-project.org/package=chebpol">https://cran.r-project.org/package=chebpol</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, pcaPP, fMultivar, mnormt, Matrix, MASS, heatmaply,
ggplot2, plotly, graphics, geometry, doFuture, foreach, future,
doRNG, microbenchmark</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, markdown, knitr, testthat (&ge; 3.0.0), lattice,
cubature, plot3D, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-05 20:16:14 UTC; mingz</td>
</tr>
<tr>
<td>Author:</td>
<td>Mingze Huang <a href="https://orcid.org/0000-0003-3919-1564"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Grace Yoon <a href="https://orcid.org/0000-0003-3263-1352"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Christian M&amp;uuml;ller
    <a href="https://orcid.org/0000-0002-3821-7083"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Irina Gaynanova <a href="https://orcid.org/0000-0002-4116-0268"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-05 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='evaluation'>Numerical evaluation for different estimation methods.</h2><span id='topic+evaluation'></span>

<h3>Description</h3>

<p>Speed and accuracy comparison of two different estimation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluation(
  genfun,
  estfun_1,
  estfun_2,
  grid_list,
  nrep = 100,
  showplot = FALSE,
  cores = detectCores(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluation_+3A_genfun">genfun</code></td>
<td>
<p>A data generation function.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_estfun_1">estfun_1</code></td>
<td>
<p>A function for first estimation method.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_estfun_2">estfun_2</code></td>
<td>
<p>A function for second estimation method.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_grid_list">grid_list</code></td>
<td>
<p>A list for grid points to be evaluated (each element of list is a vector represents ticklabels on a dimension). The number of list elements are the dimension of function inputs.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_nrep">nrep</code></td>
<td>
<p>Number of replications in simulation.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_showplot">showplot</code></td>
<td>
<p>Logical indicator. <code>showplot = TRUE</code> generates the heatmaps of output arrays. NULL if <code>showplot = FALSE</code>.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_cores">cores</code></td>
<td>
<p>The numbers of cores (threads) of your machine to conduct parallel computing.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_...">...</code></td>
<td>
<p>Other inputs for data generation or estimation functions to be passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>evaluation</code> returns
</p>

<ul>
<li><p>meanAE_1: An array for mean absolute error of first estimation method.
</p>
</li>
<li><p>meanAE_2: An array for mean absolute error of second estimation method.
</p>
</li>
<li><p>medianAE_1: An array for median absolute error of first estimation method.
</p>
</li>
<li><p>medianAE_2: An array for median absolute error of second estimation method.
</p>
</li>
<li><p>maxAE_1: An array for maximum absolute error of first estimation method.
</p>
</li>
<li><p>maxAE_2: An array for maximum absolute error of second estimation method.
</p>
</li>
<li><p>meanAE_diff: An array for mean absolute error of difference between two estimations.
</p>
</li>
<li><p>medianAE_diff: An array for median absolute error of difference between two estimations.
</p>
</li>
<li><p>maxAE_diff: An array for maximum absolute error of difference between two estimations.
</p>
</li>
<li><p>mediantime_1: An array for median time of first estimation method.
</p>
</li>
<li><p>mediantime_2: An array for median time of second estimation method.
</p>
</li>
<li><p>plot_meanAE_1: A plot for mean absolute error of first estimation method.
</p>
</li>
<li><p>plot_meanAE_2: A plot for mean absolute error of second estimation method.
</p>
</li>
<li><p>plot_medianAE_1: A plot for median absolute error of first estimation method.
</p>
</li>
<li><p>plot_medianAE_2: A plot for median absolute error of second estimation method.
</p>
</li>
<li><p>plot_maxAE_1: A plot for maximum absolute error of first estimation method.
</p>
</li>
<li><p>plot_maxAE_2: A plot for maximum absolute error of second estimation method.
</p>
</li>
<li><p>plot_meanAE_diff: A plot for mean absolute error of difference between two estimations.
</p>
</li>
<li><p>plot_medianAE_diff: A plot for median absolute error of difference between two estimations.
</p>
</li>
<li><p>plot_maxAE_diff: A plot for maximum absolute error of difference between two estimations.
</p>
</li>
<li><p>plot_mediantime_1: A plot for median time of first estimation method.
</p>
</li>
<li><p>plot_mediantime_2: A plot for median time of second estimation method.
</p>
</li></ul>


<hr>
<h2 id='gen_data'>Mixed type simulation data generator</h2><span id='topic+gen_data'></span>

<h3>Description</h3>

<p>Generates data of mixed types from the latent Gaussian copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_data(
  n = 100,
  types = c("ter", "con"),
  rhos = 0.5,
  copulas = "no",
  XP = NULL,
  showplot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_data_+3A_n">n</code></td>
<td>
<p>A positive integer indicating the sample size. The default value is 100.</p>
</td></tr>
<tr><td><code id="gen_data_+3A_types">types</code></td>
<td>
<p>A vector indicating the type of each variable, could be <code>"con"</code> (continuous), <code>"bin"</code> (binary), <code>"tru"</code> (truncated) or <code>"ter"</code> (ternary). The number of variables is determined based on the length of types, that is <code>p = length(types)</code>. The default value is <code>c("ter", "con")</code> which creates two variables: the first one is ternary, the second one is continuous.</p>
</td></tr>
<tr><td><code id="gen_data_+3A_rhos">rhos</code></td>
<td>
<p>A vector with lower-triangular elements of desired correlation matrix, e.g. <code>rhos = c(.3, .5, .7)</code> means the correlation matrix is <code>matrix(c(1, .3, .5, .3, 1, .7, .5, .7, 1), 3, 3)</code>. If only a scalar is supplied (<code>length(rhos) = 1</code>), then equi-correlation matrix is assumed with all pairwise correlations being equal to <code>rhos</code>. The default value is 0.5 which means correlations between any two variables are 0.5.</p>
</td></tr>
<tr><td><code id="gen_data_+3A_copulas">copulas</code></td>
<td>
<p>A vector indicating the copula transformation f for each of the p variables, e.g. U = f(Z). Each element can take value <code>"no"</code> (f is identity), <code>"expo"</code> (exponential transformation) or <code>"cube"</code> (cubic transformation). If the vector has length 1, then the same transformation is applied to all p variables. The default value is <code>"no"</code>: no copula transformation for any of the variables.</p>
</td></tr>
<tr><td><code id="gen_data_+3A_xp">XP</code></td>
<td>
<p>A list of length p indicating proportion of zeros (for binary and truncated), and proportions of zeros and ones (for ternary) for each of the variables. For continuous variable, NA should be supplied. If <code>NULL</code>, the following values are automatically generated as elements of <code>XP</code> list for the corresponding data types:
For continuous variable, the corresponding value is NA;
for binary or truncated variable, the corresponding value is a number between 0 and 1 representing the proportion of zeros, the default value is 0.5;
for ternary variable, the corresponding value is a pair of numbers between 0 and 1, the first number indicates the the proportion of zeros, the second number indicates the proportion of ones. The sum of a pair of numbers should be between 0 and 1, the default value is <code>c(0.3, 0.5)</code>.</p>
</td></tr>
<tr><td><code id="gen_data_+3A_showplot">showplot</code></td>
<td>
<p>Logical indicator. If TRUE, generates the plot of the data when number of variables p is no more than 3. The default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gen_data</code> returns a list containing
</p>

<ul>
<li><p>X: Generated data matrix (n by p) of observed variables.
</p>
</li>
<li><p>plotX: Visualization of the data matrix X.
Histogram if <code>p=1</code>. 2D Scatter plot if <code>p=2</code>. 3D scatter plot if <code>p=3</code>. Returns NULL if <code>showplot = FALSE</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Fan J., Liu H., Ning Y. and Zou H. (2017) &quot;High dimensional semiparametric latent graphicalmodel for mixed data&quot; <a href="https://doi.org/10.1111/rssb.12168">doi:10.1111/rssb.12168</a>.
</p>
<p>Yoon G., Carroll R.J. and Gaynanova I. (2020) &quot;Sparse semiparametric canonical correlation analysis for data of mixed types&quot; <a href="https://doi.org/10.1093/biomet/asaa007">doi:10.1093/biomet/asaa007</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate single continuous variable with exponential transformation (always greater than 0)
# and show histogram.
simdata = gen_data(n = 100, copulas = "expo", types = "con", showplot = FALSE)
X = simdata$X; plotX = simdata$plotX
# Generate a pair of variables (ternary and continuous) with default proportions
# and without copula transformation.
simdata = gen_data()
X = simdata$X
# Generate 3 variables (binary, ternary and truncated)
# corresponding copulas for each variables are "no" (no transformation),
# "cube" (cube transformation) and "cube" (cube transformation).
# binary variable has 30% of zeros, ternary variable has 20% of zeros
# and 40% of ones, truncated variable has 50% of zeros.
# Then show the 3D scatter plot (data points project on either 0 or 1 on Axis X1;
# on 0, 1 or 2 on Axas X2; on positive domain on Axis X3)
simdata = gen_data(n = 100, rhos = c(.3, .4, .5), copulas = c("no", "cube", "cube"),
          types = c("bin", "ter", "tru"), XP = list(.3, c(.2, .4), .5), showplot = TRUE)
X = simdata$X; plotX = simdata$plotX
# Check the proportion of zeros for the binary variable.
sum(simdata$X[ , 1] == 0)
# Check the proportion of zeros and ones for the ternary variable.
sum(simdata$X[ , 2] == 0); sum(simdata$X[ , 2] == 1)
# Check the proportion of zeros for the truncated variable.
sum(simdata$X[ , 3] == 0)
</code></pre>

<hr>
<h2 id='get_types'>Automatically determine types of each variable (continuous/binary/ternary/truncated) in a data matrix.</h2><span id='topic+get_types'></span>

<h3>Description</h3>

<p>Automatically determine types of each variable (continuous/binary/ternary/truncated) in a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_types(X, tru_prop = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_types_+3A_x">X</code></td>
<td>
<p>A numeric data matrix (n by p), where n is number of samples, and p is number of variables. Missing values (NA) are allowed.</p>
</td></tr>
<tr><td><code id="get_types_+3A_tru_prop">tru_prop</code></td>
<td>
<p>A scalar between 0 and 1 indicating the minimal proportion of zeros that should be present in a variable to be treated as <code>"tru"</code> (truncated type or zero-inflated) rather than as <code>"con"</code> (continuous type). The default value is 0.05 (any variable with more than 5% of zero values among n samples is treated as truncated or zero-inflated)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_types</code> returns
</p>

<ul>
<li><p>types: A vector of length p indicating the type of each of the p variables in <code>X</code>. Each element is one of <code>"con"</code> (continuous), <code>"bin"</code> (binary), <code>"ter"</code> (ternary) or <code>"tru"</code> (truncated).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>X = gen_data(types = c("ter", "con"))$X
get_types(X)

</code></pre>

<hr>
<h2 id='interpolant'>Evaluate an interpolant in a point</h2><span id='topic+interpolant'></span>

<h3>Description</h3>

<p>An interpolant is a function returned by <code><a href="#topic+ipol">ipol</a></code> which has prespecified values in some
points, and which fills in between with some reasonable values.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolant_+3A_x">x</code></td>
<td>
<p>The argument of the function. A function of more then one variable takes a
vector. <code>x</code> can also be a matrix of column vectors.</p>
</td></tr>
<tr><td><code id="interpolant_+3A_threads">threads</code></td>
<td>
<p>The number of threads to use for evaluation. All  interpolants created by
<code>ipol</code> are parallelized. If given a matrix argument <code>x</code>, the vectors can
be evaluated in parallel.</p>
</td></tr>
<tr><td><code id="interpolant_+3A_...">...</code></td>
<td>
<p>Other parameters. Currently used for simplex linear interpolants with the logical argument
The <code>"multilinear"</code> interpolant also has the argument <code>blend=c("linear","cubic","sigmoid")</code> where a
blending function can be chosen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric. If more than one point was evaluated, a vector.
</p>


<h3>Author(s)</h3>

<p>Simen Gaure
</p>

<hr>
<h2 id='interpolation'>Parallel version of multilinear interpolation generator for function approximation</h2><span id='topic+interpolation'></span>

<h3>Description</h3>

<p>Parallel version of multilinear interpolation generator for function approximation
</p>
<p>The primary method is <code><a href="#topic+ipol">ipol</a></code> which
dispatches to some other method.  All the generated
<a href="#topic+interpolant">interpolant</a>s accept as an argument a matrix of column
vectors. The generated functions also accept an argument
<code>threads=getOption('ipol.threads')</code> to utilize more than
one CPU if a matrix of column vectors is evaluated.  The option
<code>ipol.threads</code> is initialized from the environment variable
<code>IPOL_THREADS</code> upon loading of the package. It defaults to <code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolation(evalfun, grid_list, cores = detectCores(), int = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolation_+3A_evalfun">evalfun</code></td>
<td>
<p>The objective function to be approximated.</p>
</td></tr>
<tr><td><code id="interpolation_+3A_grid_list">grid_list</code></td>
<td>
<p>A list for grid points (each element of list is a vector represents ticklabels on a dimension). The number of list elements are the dimension of function inputs.</p>
</td></tr>
<tr><td><code id="interpolation_+3A_cores">cores</code></td>
<td>
<p>The numbers of cores (threads) of your machine to conduct parallel computing.</p>
</td></tr>
<tr><td><code id="interpolation_+3A_int">int</code></td>
<td>
<p>Logical indicator. <code>int = TRUE</code> interpolant value multiplied by 10^7 then convert to interger to save memory. Original interpolant if <code>int = FALSE</code>.</p>
</td></tr>
<tr><td><code id="interpolation_+3A_...">...</code></td>
<td>
<p>Other inputs for objective functions to be passed through.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interpolants are ordinary R-objects and can be saved with <code>save()</code> and loaded
later with <code>load()</code> or serialized/unserialized with other tools, just like any R-object.
However, they contain calls to functions in the package, and while the author will make efforts
to ensure that generated interpolants are compatible with future versions of <span class="pkg">ipol</span>,
I can issue no such absolute guarantee.
</p>


<h3>Value</h3>

<p><code>interpolation</code> returns
</p>

<ul>
<li><p>value: A list of of length p corresponding to each variable. Returns NA for continuous variable; proportion of zeros for binary/truncated variables; the cumulative proportions of zeros and ones (e.g. first value is proportion of zeros, second value is proportion of zeros and ones) for ternary variable.
</p>
</li>
<li><p>interpolant: An interpolant function generated by <code>chebpol::chebpol</code> for interplation.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+ipol">ipol</a>, <a href="#topic+interpolant">interpolant</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: grid_list = list(seq(-0.5, 0.5, by = 0.5), seq(-0.5, 0.5, by = 0.5))
objfun = function(x, y) {x^2 + sqrt(y)}
evalfun = function(X) {objfun(X[1], X[2])}
value = interpolation(evalfun = evalfun, grid_list = grid_list)$value
interpolant = interpolation(evalfun = evalfun, grid_list = grid_list)$interpolant
## End(Not run)
</code></pre>

<hr>
<h2 id='ipol'>Create an interpolating function from given values. Several interpolation methods are
supported.</h2><span id='topic+ipol'></span>

<h3>Description</h3>

<p>Create an interpolating function from given values. Several interpolation methods are
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipol(val, grid = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ipol_+3A_val">val</code></td>
<td>
<p>array or function. Function values on a grid.</p>
</td></tr>
<tr><td><code id="ipol_+3A_grid">grid</code></td>
<td>
<p>list. Each element is a vector of ordered grid-points for a
dimension.</p>
</td></tr>
<tr><td><code id="ipol_+3A_...">...</code></td>
<td>
<p>Further arguments to the function, if <code>is.function(val)</code>. And some
extra arguments for interpolant creation described in section Details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>function(x, threads=getOption('chebpol.threads'))</code> defined on a hypercube, an <a href="#topic+interpolant">interpolant</a>
for the given function. The argument <code>x</code> can be a matrix of column
vectors which are evaluated in parallel in a number of threads.  The
function yields values for arguments outside the hypercube as well, though
it will typically be a poor approximation.  <code>threads</code> is an integer
specifying the number of parallel threads which should be used when
evaluating a matrix of column vectors.
</p>


<h3>Author(s)</h3>

<p>Simen Gaure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## evenly spaced grid-points
su &lt;- seq(0,1,length.out=10)
## irregularly spaced grid-points
s &lt;- su^3
## create approximation on the irregularly spaced grid
ml1 &lt;- ipol(exp(s), grid=list(s))
## test it, since exp is convex, the linear approximation lies above
## the exp between the grid points
ml1(su) - exp(su)

## multi dimensional approximation
f &lt;- function(x) 10/(1+25*mean(x^2))
# a 3-dimensional 10x10x10 grid, first and third coordinate are non-uniform
grid &lt;- list(s, su, sort(1-s))

# make multilinear spline.
ml2 &lt;- ipol(array(apply(expand.grid(grid), 1, f), c(10, 10, 10)), grid=grid)
# make 7 points in R3 to test them on
m &lt;- matrix(runif(3*7),3)
rbind(true=apply(m,2,f), ml=ml2(m))

</code></pre>

<hr>
<h2 id='latentcor'>Estimate latent correlation for mixed types.</h2><span id='topic+latentcor'></span>

<h3>Description</h3>

<p>Estimation of latent correlation matrix from observed data of (possibly) mixed types (continuous/binary/truncated/ternary) based on the latent Gaussian copula model. Missing values (NA) are allowed. The estimation is based on pairwise complete observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latentcor(
  X,
  types = NULL,
  method = c("approx", "original"),
  use.nearPD = TRUE,
  nu = 0.001,
  tol = 1e-08,
  ratio = 0.9,
  showplot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latentcor_+3A_x">X</code></td>
<td>
<p>A numeric matrix or numeric data frame (n by p), where n is number of samples, and p is number of variables. Missing values (NA) are allowed, in which case the estimation is based on pairwise complete observations.</p>
</td></tr>
<tr><td><code id="latentcor_+3A_types">types</code></td>
<td>
<p>A vector of length p indicating the type of each of the p variables in <code>X</code>. Each element must be one of <code>"con"</code> (continuous), <code>"bin"</code> (binary), <code>"ter"</code> (ternary) or <code>"tru"</code> (truncated). If the vector has length 1, then all p variables are assumed to be of the same type that is supplied. The default value is <code>NULL</code>, and the variable types are determined automatically using function <code><a href="#topic+get_types">get_types</a></code>. As automatic determination of variable types takes extra time, it is recommended to supply the types explicitly when they are known in advance.</p>
</td></tr>
<tr><td><code id="latentcor_+3A_method">method</code></td>
<td>
<p>The calculation method for latent correlations. Either <code>"original"</code> or <code>"approx"</code>. If <code>method = "approx"</code>, multilinear approximation method is used, which is much faster than the original method, see Yoon et al. (2021) for timing comparisons for various variable types. If <code>method = "original"</code>, optimization of the bridge inverse function is used. The default is <code>"approx"</code>.</p>
</td></tr>
<tr><td><code id="latentcor_+3A_use.nearpd">use.nearPD</code></td>
<td>
<p>Logical indicator. <code>use.nearPD = TRUE</code> gets nearest positive definite matrix for the estimated latent correlation matrix with shrinkage adjustment by <code>nu</code>. Output <code>R</code> is the same as <code>Rpointwise</code> if <code>use.nearPD = FALSE</code>. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="latentcor_+3A_nu">nu</code></td>
<td>
<p>Shrinkage parameter for the correlation matrix, must be between 0 and 1. Guarantees that the minimal eigenvalue of returned correlation matrix is greater or equal to <code>nu</code>. When <code>nu = 0</code>, no shrinkage is performed, the returned correlation matrix will be semi-positive definite but not necessarily strictly positive definite. When <code>nu = 1</code>, the identity matrix is returned (not recommended).  The default (recommended) value is 0.001.</p>
</td></tr>
<tr><td><code id="latentcor_+3A_tol">tol</code></td>
<td>
<p>When <code>method = "original"</code>, specifies the desired accuracy of the bridge function inversion via uniroot optimization and is passed to <code><a href="stats.html#topic+optimize">optimize</a></code>. The default value is 1e-8. When <code>method = "approx"</code>, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="latentcor_+3A_ratio">ratio</code></td>
<td>
<p>When <code>method = "approx"</code>, specifies the boundary value for multilinear interpolation, must be between 0 and 1. When <code>ratio = 0</code>, no linear interpolation is performed (the slowest execution) which is equivalent to <code>method = "original"</code>. When <code>ratio = 1</code>, linear interpolation is always performed (the fastest execution) but may lead to high approximation errors. The default (recommended) value is 0.9 which controls the approximation error and has fast execution, see Yoon et al. (2021) for details. When <code>method = "original"</code>, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="latentcor_+3A_showplot">showplot</code></td>
<td>
<p>Logical indicator. <code>showplot = TRUE</code> generates a ggplot object <code>plotR</code> with the heatmap of latent correlation matrix <code>R</code>. <code>plotR = NULL</code> if <code>showplot = FALSE</code>. Default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates latent correlation by calculating inverse bridge function (Fan et al., 2017) evaluated at the value of sample Kendall's tau (<code class="reqn">\hat \tau</code>). The bridge function F connects Kendall's tau to latent correlation r so that <code class="reqn">F(r) = E(\hat \tau)</code>. The form of function F depends on the variable types (continuous/binary/truncated/ternary), but is exact. The exact form of inverse is not available, so has to be evaluated numerically for each pair of variables leading to <code>Rpointwise</code>.
</p>
<p>When <code>method = "original"</code>, the inversion is done numerically by solving </p>
<p style="text-align: center;"><code class="reqn">minimize_r (F(r) - \hat \tau)^2</code>
</p>
<p> using <code><a href="stats.html#topic+optimize">optimize</a></code>. The parameter <code>tol</code> is used to control the accuracy of the solution.
</p>
<p>When <code>method = "approx"</code>, the inversion is done approximately by interpolating previously calculated and stored values of <code class="reqn">F^{-1}(\hat \tau)</code>. This is significantly faster than the original method (Yoon et al., 2021) for binary/ternary/truncated cases, however the approximation errors may be non-negligible on some regions of the space. The parameter <code>ratio</code> controls the region where the interpolation is performed with default recommended value of 0.9 giving a good balance of accuracy and computational speed . Increasing the value of ratio may improve speed (but possibly sacrifice the accuracy), whereas decreasing the value of ratio my improve accuracy (but possibly sacrifice the speed). See Yoon et al. 2021 and vignette for more details.
</p>
<p>In case the pointwise estimator <code>Rpointwise</code> is has negative eigenvalues, it is projected onto the space of positive semi-definite matrices using <code><a href="Matrix.html#topic+nearPD">nearPD</a></code>. The parameter <code>nu</code> further allows to perform additional shrinkage towards identity matrix (desirable in cases where the number of variables p is very large) as
</p>
<p style="text-align: center;"><code class="reqn">R = (1 - \nu) \tilde R + \nu I,</code>
</p>

<p>where <code class="reqn">\tilde R</code> is <code>Rpointwise</code> after projection by <code><a href="Matrix.html#topic+nearPD">nearPD</a></code>.
</p>


<h3>Value</h3>

<p><code>latentcor</code> returns
</p>

<ul>
<li><p>zratios: A list of of length p corresponding to each variable. Returns NA for continuous variable; proportion of zeros for binary/truncated variables; the cumulative proportions of zeros and ones (e.g. first value is proportion of zeros, second value is proportion of zeros and ones) for ternary variable. 
</p>
</li>
<li><p>K: (p x p) Kendall Tau (Tau-a) Matrix for <code>X</code> 
</p>
</li>
<li><p>R: (p x p) Estimated latent correlation matrix for <code>X</code> 
</p>
</li>
<li><p>Rpointwise: (p x p) Point-wise estimates of latent correlations for <code>X</code>. This matrix is not guaranteed to be semi-positive definite. This is the original estimated latent correlation matrix without adjustment for positive-definiteness.
</p>
</li>
<li><p>plotR: Heatmap plot of latent correlation matrix <code>R</code>, NULL if <code>showplot = FALSE</code>
</p>
</li></ul>



<h3>References</h3>

<p>Fan J., Liu H., Ning Y. and Zou H. (2017) &quot;High dimensional semiparametric latent graphical model for mixed data&quot; <a href="https://doi.org/10.1111/rssb.12168">doi:10.1111/rssb.12168</a>.
</p>
<p>Yoon G., Carroll R.J. and Gaynanova I. (2020) &quot;Sparse semiparametric canonical correlation analysis for data of mixed types&quot; <a href="https://doi.org/10.1093/biomet/asaa007">doi:10.1093/biomet/asaa007</a>.
</p>
<p>Yoon G., MÃ¼ller C.L., Gaynanova I. (2021) &quot;Fast computation of latent correlations&quot; <a href="https://doi.org/10.1080/10618600.2021.1882468">doi:10.1080/10618600.2021.1882468</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 - truncated data type, same type for all variables
# Generate data
X = gen_data(n = 300, types = rep("tru", 5))$X
# Estimate latent correlation matrix with original method and check the timing
start_time = proc.time()
R_org = latentcor(X = X, types = "tru", method = "original")$R
proc.time() - start_time
# Estimate latent correlation matrix with approximation method and check the timing
start_time = proc.time()
R_approx = latentcor(X = X, types = "tru", method = "approx")$R
proc.time() - start_time
# Heatmap for latent correlation matrix.
Heatmap_R_approx = latentcor(X = X, types = "tru", method = "approx",
                             showplot = TRUE)$plotR

# Example 2 - ternary/continuous case
X = gen_data()$X
# Estimate latent correlation matrix with original method
R_nc_org = latentcor(X = X, types = c("ter", "con"), method = "original")$R
# Estimate latent correlation matrix with aprroximation method
R_nc_approx = latentcor(X = X, types = c("ter", "con"), method = "approx")$R
</code></pre>

<hr>
<h2 id='mlappx.real'>Multilinear interpolation on a grid</h2><span id='topic+mlappx.real'></span><span id='topic+mlappx'></span><span id='topic+mlappxf'></span>

<h3>Description</h3>

<p>Multilinear interpolation on an arbitrary Cartesian product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlappx.real(val, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlappx.real_+3A_val">val</code></td>
<td>
<p>Array or function. Function values on a grid, or the function
itself. If it is the values, the <code>dim</code>-attribute must be appropriately
set.</p>
</td></tr>
<tr><td><code id="mlappx.real_+3A_grid">grid</code></td>
<td>
<p>A list.  Each element is a vector of ordered grid-points for a
dimension.  These need not be Chebyshev-knots, nor evenly spaced.</p>
</td></tr>
<tr><td><code id="mlappx.real_+3A_...">...</code></td>
<td>
<p>Further arguments to the function, if <code>is.function(val)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A call <code>fun &lt;- mlappx(val,grid)</code> creates a multilinear interpolant on
the grid.  The value on the grid points will be exact, the value between the
grid points is a convex combination of the values in the corners of the
hypercube surrounding it.
</p>
<p>If <code>val</code> is a function it will be evaluated on the grid.
</p>


<h3>Value</h3>

<p>A <code>function(x)</code> defined on the hypercube, approximating the
given function.  The function yields values for arguments outside the
hypercube as well, as a linear extension.
</p>

<hr>
<h2 id='r_ml_wrapper'>Port function to call multilinear interpolants for continuous developers.</h2><span id='topic+r_ml_wrapper'></span>

<h3>Description</h3>

<p>Port function to call multilinear interpolants for continuous developers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_ml_wrapper(K, zratio1, zratio2, comb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_ml_wrapper_+3A_k">K</code></td>
<td>
<p>Kendall's tau, can be provided as a number or a vector for interpolation in batch.</p>
</td></tr>
<tr><td><code id="r_ml_wrapper_+3A_zratio1">zratio1</code></td>
<td>
<p>zratio for first variable. NA for continuous variables, zeros proportions for binary, truncated variables.
For ternary variables, a vector of proportion of zeros as first element, proportions of zeros and ones as second element.
It can be provided as a vector (matrix) for interpolation in batch. See vignettes for detail.</p>
</td></tr>
<tr><td><code id="r_ml_wrapper_+3A_zratio2">zratio2</code></td>
<td>
<p>zratio for second variable. NA for continuous variables, zeros proportions for binary, truncated variables.
For ternary variables, a vector of proportion of zeros as first element, proportions of zeros and ones as second element.
It can be provided as a vector (matrix) for interpolation in batch. See vignettes for detail.</p>
</td></tr>
<tr><td><code id="r_ml_wrapper_+3A_comb">comb</code></td>
<td>
<p>Numeric code for types: &quot;10&quot; for binary/continuous; &quot;11&quot; for binary/binary; &quot;20&quot; for truncated/continuous;
&quot;21&quot; for truncated/binary; &quot;22&quot; for truncated/truncated; &quot;30&quot; for ternary/continuous; &quot;31&quot; for ternary/binary;
&quot;32&quot; for ternary/truncated; &quot;33&quot; for ternary/ternary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number or vector of interpolation results.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
