<!DOCTYPE html><html><head><title>Help for package spatialsample</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatialsample}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spatialsample-package'><p>spatialsample: Spatial Resampling Infrastructure</p></a></li>
<li><a href='#autoplot.spatial_rset'><p>Create a ggplot for spatial resamples.</p></a></li>
<li><a href='#boston_canopy'><p>Boston tree canopy and heat index data.</p></a></li>
<li><a href='#buffer_indices'><p>Apply an inclusion radius and exclusion buffer to indices</p></a></li>
<li><a href='#check_v'><p>Check that &quot;v&quot; is sensible</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#spatial_block_cv'><p>Spatial block cross-validation</p></a></li>
<li><a href='#spatial_buffer_vfold_cv'><p>V-Fold Cross-Validation with Buffering</p></a></li>
<li><a href='#spatial_clustering_cv'><p>Spatial Clustering Cross-Validation</p></a></li>
<li><a href='#spatial_nndm_cv'><p>Nearest neighbor distance matching (NNDM) cross-validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Resampling Infrastructure</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and classes for spatial resampling to use with the
    'rsample' package, such as spatial cross-validation (Brenning, 2012)
    &lt;<a href="https://doi.org/10.1109%2FIGARSS.2012.6352393">doi:10.1109/IGARSS.2012.6352393</a>&gt;. The scope of 'rsample' and
    'spatialsample' is to provide the basic building blocks for creating
    and analyzing resamples of a spatial data set, but neither package
    includes functions for modeling or computing statistics. The resampled
    spatial data sets created by 'spatialsample' do not contain much
    overhead in memory.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tidymodels/spatialsample">https://github.com/tidymodels/spatialsample</a>,
<a href="https://spatialsample.tidymodels.org">https://spatialsample.tidymodels.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/spatialsample/issues">https://github.com/tidymodels/spatialsample/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.0), ggplot2, glue, purrr, rlang (&ge; 1.0.0),
rsample (&ge; 1.1.1), sf (&ge; 1.0-9), stats, tibble, tidyselect,
units, vctrs (&ge; 0.3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, gifski, knitr, lwgeom, modeldata, rmarkdown, testthat
(&ge; 3.0.0), tidyr, vdiffr, whisker, withr, yardstick</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-07 17:03:14 UTC; mikemahoney218</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Mahoney <a href="https://orcid.org/0000-0003-2402-304X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Julia Silge <a href="https://orcid.org/0000-0002-3671-836X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Mahoney &lt;mike.mahoney.218@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-08 00:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spatialsample-package'>spatialsample: Spatial Resampling Infrastructure</h2><span id='topic+spatialsample'></span><span id='topic+spatialsample-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Functions and classes for spatial resampling to use with the 'rsample' package, such as spatial cross-validation (Brenning, 2012) <a href="https://doi.org/10.1109/IGARSS.2012.6352393">doi:10.1109/IGARSS.2012.6352393</a>. The scope of 'rsample' and 'spatialsample' is to provide the basic building blocks for creating and analyzing resamples of a spatial data set, but neither package includes functions for modeling or computing statistics. The resampled spatial data sets created by 'spatialsample' do not contain much overhead in memory.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Mahoney <a href="mailto:mike.mahoney.218@gmail.com">mike.mahoney.218@gmail.com</a> (<a href="https://orcid.org/0000-0003-2402-304X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Julia Silge <a href="mailto:julia.silge@posit.co">julia.silge@posit.co</a> (<a href="https://orcid.org/0000-0002-3671-836X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tidymodels/spatialsample">https://github.com/tidymodels/spatialsample</a>
</p>
</li>
<li> <p><a href="https://spatialsample.tidymodels.org">https://spatialsample.tidymodels.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/spatialsample/issues">https://github.com/tidymodels/spatialsample/issues</a>
</p>
</li></ul>


<hr>
<h2 id='autoplot.spatial_rset'>Create a ggplot for spatial resamples.</h2><span id='topic+autoplot.spatial_rset'></span><span id='topic+autoplot.spatial_block_cv'></span>

<h3>Description</h3>

<p>This method provides a good visualization method for spatial resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatial_rset'
autoplot(object, ..., alpha = 0.6)

## S3 method for class 'spatial_block_cv'
autoplot(object, show_grid = TRUE, ..., alpha = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.spatial_rset_+3A_object">object</code></td>
<td>
<p>A <code>spatial_rset</code> object or a <code>spatial_rsplit</code> object.
Note that only resamples made from
<code>sf</code> objects create <code>spatial_rset</code> and <code>spatial_rsplit</code> objects;
this function will not work for
resamples made with non-spatial tibbles or data.frames.</p>
</td></tr>
<tr><td><code id="autoplot.spatial_rset_+3A_...">...</code></td>
<td>
<p>Options passed to <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.spatial_rset_+3A_alpha">alpha</code></td>
<td>
<p>Opacity, passed to <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code>.
Values of alpha range from 0 to 1, with lower values corresponding to more
transparent colors.</p>
</td></tr>
<tr><td><code id="autoplot.spatial_rset_+3A_show_grid">show_grid</code></td>
<td>
<p>When plotting <a href="#topic+spatial_block_cv">spatial_block_cv</a> objects, should the grid
itself be drawn on top of the data? Set to FALSE to remove the grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot method for <code>spatial_rset</code> displays which fold each observation
is assigned to. Note that if data is assigned to multiple folds
(which is common if resamples were created with a non-zero <code>radius</code>) only
the &quot;last&quot; fold for each observation will appear on the plot.
Consider adding <code>ggplot2::facet_wrap(~ fold)</code> to visualize all members of
each fold separately.
Alternatively, consider plotting each split using the <code>spatial_rsplit</code> method
(for example, via <code>lapply(object$splits, autoplot)</code>).
</p>


<h3>Value</h3>

<p>A ggplot object with each fold assigned a color, made using
<code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
boston_block &lt;- spatial_block_cv(boston_canopy, v = 2)
autoplot(boston_block)
autoplot(boston_block$splits[[1]])

</code></pre>

<hr>
<h2 id='boston_canopy'>Boston tree canopy and heat index data.</h2><span id='topic+boston_canopy'></span>

<h3>Description</h3>

<p>A dataset containing data on tree canopy coverage and change for the city of
Boston, Massachusetts from 2014-2019,
as well as temperature and heat index data for July 2019. Data is aggregated
to a grid of regular 25 hectare hexagons, clipped to city boundaries.
This data is made available under the Public Domain Dedication and License
v1.0 whose full text can be found at:
<a href="https://opendatacommons.org/licenses/pddl/1-0/">https://opendatacommons.org/licenses/pddl/1-0/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boston_canopy
</code></pre>


<h3>Format</h3>

<p>A data frame (of class <code>sf</code>, <code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>)
containing 682 records of 22 variables:
</p>

<dl>
<dt>grid_id</dt><dd><p>Unique identifier for each hexagon. Letters represent the hexagon's X position in the grid (ordered West to East), while numbers represent the Y position (ordered North to South).</p>
</dd>
<dt>land_area</dt><dd><p>Area excluding water bodies</p>
</dd>
<dt>canopy_gain</dt><dd><p>Area of canopy gain between the two years</p>
</dd>
<dt>canopy_loss</dt><dd><p>Area of canopy loss between the two years</p>
</dd>
<dt>canopy_no_change</dt><dd><p>Area of no canopy change between the two years</p>
</dd>
<dt>canopy_area_2014</dt><dd><p>2014 total canopy area (baseline)</p>
</dd>
<dt>canopy_area_2019</dt><dd><p>2019 total canopy area</p>
</dd>
<dt>change_canopy_area</dt><dd><p>The change in area of tree canopy between the two years</p>
</dd>
<dt>change_canopy_percentage</dt><dd><p>Relative change calculation used in economics is the gain or loss of tree canopy relative to the earlier time period: (2019 Canopy-2014 Canopy)/(2014 Canopy)</p>
</dd>
<dt>canopy_percentage_2014</dt><dd><p>2014 canopy percentage</p>
</dd>
<dt>canopy_percentage_2019</dt><dd><p>2019 canopy percentage</p>
</dd>
<dt>change_canopy_absolute</dt><dd><p>Absolute change. Magnitude of change in percent tree canopy from 2014 to 2019 (% 2019 Canopy - % 2014 Canopy)</p>
</dd>
<dt>mean_temp_morning</dt><dd><p>Mean temperature for July 2019 from 6am - 7am</p>
</dd>
<dt>mean_temp_evening</dt><dd><p>Mean temperature for July 2019 from 7pm - 8pm</p>
</dd>
<dt>mean_temp</dt><dd><p>Mean temperature for July 2019 from 6am - 7am, 3pm - 4pm, and 7pm - 8pm (combined)</p>
</dd>
<dt>mean_heat_index_morning</dt><dd><p>Mean heat index for July 2019 from 6am - 7am</p>
</dd>
<dt>mean_heat_index_evening</dt><dd><p>Mean heat index for July 2019 from 7pm - 8pm</p>
</dd>
<dt>mean_heat_index</dt><dd><p>Mean heat index for July 2019 from 6am - 7am, 3pm - 4pm, and 7pm - 8pm (combined)</p>
</dd>
<dt>geometry</dt><dd><p>Geometry of each hexagon, encoded using EPSG:2249 as a coordinate reference system (NAD83 / Massachusetts Mainland (ftUS)). Note that the linear units of this CRS are in US feet.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Note that this dataset is in the EPSG:2249
(NAD83 / Massachusetts Mainland (ftUS)) coordinate reference system (CRS),
which may not be installed by default on your computer. Before working with
<code>boston_canopy</code>, run:
</p>

<ul>
<li> <p><code>sf::sf_proj_network(TRUE)</code> to install the CRS itself
</p>
</li>
<li> <p><code><a href="sf.html#topic+sf_project">sf::sf_add_proj_units()</a></code> to add US customary units to your units
database
</p>
</li></ul>

<p>These steps only need to be taken once per computer (or per PROJ installation).
</p>


<h3>Source</h3>

<p>Canopy data is from <a href="https://data.boston.gov/dataset/hex-tree-canopy-change-metrics">https://data.boston.gov/dataset/hex-tree-canopy-change-metrics</a>.
Heat data is from <a href="https://data.boston.gov/dataset/hex-mean-heat-index">https://data.boston.gov/dataset/hex-mean-heat-index</a>.
Most field definitions are from <a href="https://data.boston.gov/dataset/canopy-change-assessment-data-dictionary">https://data.boston.gov/dataset/canopy-change-assessment-data-dictionary</a>.
</p>

<hr>
<h2 id='buffer_indices'>Apply an inclusion radius and exclusion buffer to indices</h2><span id='topic+buffer_indices'></span>

<h3>Description</h3>

<p>Apply an inclusion radius and exclusion buffer to indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buffer_indices(data, indices, radius, buffer, call = rlang::caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buffer_indices_+3A_data">data</code></td>
<td>
<p>An object of class <code>sf</code> or <code>sfc</code>.</p>
</td></tr>
<tr><td><code id="buffer_indices_+3A_indices">indices</code></td>
<td>
<p>List of indices in each fold generated by <code>split_unnamed()</code>.</p>
</td></tr>
<tr><td><code id="buffer_indices_+3A_radius">radius</code></td>
<td>
<p>Numeric: points within this distance of the initially-selected
test points will be assigned to the assessment set. If <code>NULL</code>, no radius is
applied.</p>
</td></tr>
<tr><td><code id="buffer_indices_+3A_buffer">buffer</code></td>
<td>
<p>Numeric: points within this distance of any point in the
test set (after <code>radius</code> is applied) will be assigned to neither the analysis
or assessment set. If <code>NULL</code>, no buffer is applied.</p>
</td></tr>
</table>

<hr>
<h2 id='check_v'>Check that &quot;v&quot; is sensible</h2><span id='topic+check_v'></span>

<h3>Description</h3>

<p>Check that &quot;v&quot; is sensible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_v(v, max_v, objects, allow_max_v = TRUE, call = rlang::caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_v_+3A_v">v</code></td>
<td>
<p>The number of partitions for the resampling. Set to <code>NULL</code> or <code>Inf</code>
for the maximum sensible value (for leave-one-X-out cross-validation).</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+analysis'></span><span id='topic+assessment'></span><span id='topic+get_rsplit'></span><span id='topic+autoplot'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
<dt>rsample</dt><dd><p><code><a href="rsample.html#topic+as.data.frame.rsplit">analysis</a></code>, <code><a href="rsample.html#topic+as.data.frame.rsplit">assessment</a></code>, <code><a href="rsample.html#topic+get_rsplit">get_rsplit</a></code></p>
</dd>
</dl>

<hr>
<h2 id='spatial_block_cv'>Spatial block cross-validation</h2><span id='topic+spatial_block_cv'></span>

<h3>Description</h3>

<p>Block cross-validation splits the area of your data into a number of
grid cells, or &quot;blocks&quot;, and then assigns all data into folds based on the
blocks their centroid falls into.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_block_cv(
  data,
  method = c("random", "snake", "continuous"),
  v = 10,
  relevant_only = TRUE,
  radius = NULL,
  buffer = NULL,
  ...,
  repeats = 1,
  expand_bbox = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_block_cv_+3A_data">data</code></td>
<td>
<p>An object of class <code>sf</code> or <code>sfc</code>.</p>
</td></tr>
<tr><td><code id="spatial_block_cv_+3A_method">method</code></td>
<td>
<p>The method used to sample blocks for cross validation folds.
Currently supports <code>"random"</code>, which randomly assigns blocks to folds,
<code>"snake"</code>, which labels the first row of blocks from left to right,
then the next from right to left, and repeats from there,
and <code>"continuous"</code>, which labels each row from left
to right, moving from the bottom row up.</p>
</td></tr>
<tr><td><code id="spatial_block_cv_+3A_v">v</code></td>
<td>
<p>The number of partitions for the resampling. Set to <code>NULL</code> or <code>Inf</code>
for the maximum sensible value (for leave-one-X-out cross-validation).</p>
</td></tr>
<tr><td><code id="spatial_block_cv_+3A_relevant_only">relevant_only</code></td>
<td>
<p>For systematic sampling, should only blocks containing
data be included in fold labeling?</p>
</td></tr>
<tr><td><code id="spatial_block_cv_+3A_radius">radius</code></td>
<td>
<p>Numeric: points within this distance of the initially-selected
test points will be assigned to the assessment set. If <code>NULL</code>, no radius is
applied.</p>
</td></tr>
<tr><td><code id="spatial_block_cv_+3A_buffer">buffer</code></td>
<td>
<p>Numeric: points within this distance of any point in the
test set (after <code>radius</code> is applied) will be assigned to neither the analysis
or assessment set. If <code>NULL</code>, no buffer is applied.</p>
</td></tr>
<tr><td><code id="spatial_block_cv_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="sf.html#topic+st_make_grid">sf::st_make_grid()</a></code>.</p>
</td></tr>
<tr><td><code id="spatial_block_cv_+3A_repeats">repeats</code></td>
<td>
<p>The number of times to repeat the V-fold partitioning.</p>
</td></tr>
<tr><td><code id="spatial_block_cv_+3A_expand_bbox">expand_bbox</code></td>
<td>
<p>A numeric of length 1, representing a proportion to expand
the bounding box of <code>data</code> by before building a grid. Without this expansion,
grids built from data in geographic coordinates may exclude observations and
grids built from regularly spaced data might have observations fall exactly
on the boundary between folds, duplicating them. In spatialsample &lt; 0.5.0,
this was 0.00001 for data in a geographic CRS and 0 for data in a planar CRS.
In spatialsample &gt;= 0.5.0, this is 0.00001 for all data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The grid blocks can be controlled by passing arguments to
<code><a href="sf.html#topic+st_make_grid">sf::st_make_grid()</a></code> via <code>...</code>. Some particularly useful arguments include:
</p>

<ul>
<li> <p><code>cellsize</code>: Target cellsize, expressed as the &quot;diameter&quot; (shortest
straight-line distance between opposing sides; two times the apothem)
of each block, in map units.
</p>
</li>
<li> <p><code>n</code>: The number of grid blocks in the x and y direction (columns, rows).
</p>
</li>
<li> <p><code>square</code>: A logical value indicating whether to create square (<code>TRUE</code>) or
hexagonal (<code>FALSE</code>) cells.
</p>
</li></ul>

<p>If both <code>cellsize</code> and <code>n</code> are provided, then the number of blocks requested
by <code>n</code> of sizes specified by <code>cellsize</code> will be returned, likely not
lining up with the bounding box of <code>data</code>. If only <code>cellsize</code>
is provided, this function will return as many blocks of size
<code>cellsize</code> as fit inside the bounding box of <code>data</code>. If only <code>n</code> is provided,
then <code>cellsize</code> will be automatically adjusted to create the requested
number of cells.
</p>


<h3>Value</h3>

<p>A tibble with classes <code>spatial_block_cv</code>,  <code>spatial_rset</code>, <code>rset</code>,
<code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>. The results include a column for the
data split objects and an identification variable <code>id</code>.
</p>


<h3>References</h3>

<p>D. R. Roberts, V. Bahn, S. Ciuti, M. S. Boyce, J. Elith, G. Guillera-Arroita,
S. Hauenstein, J. J. Lahoz-Monfort, B. Schröder, W. Thuiller, D. I. Warton,
B. A. Wintle, F. Hartig, and C. F. Dormann. &quot;Cross-validation strategies for
data with temporal, spatial, hierarchical, or phylogenetic structure,&quot; 2016,
Ecography 40(8), pp. 913-929, doi: 10.1111/ecog.02881.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spatial_block_cv(boston_canopy, v = 3)

</code></pre>

<hr>
<h2 id='spatial_buffer_vfold_cv'>V-Fold Cross-Validation with Buffering</h2><span id='topic+spatial_buffer_vfold_cv'></span><span id='topic+spatial_leave_location_out_cv'></span>

<h3>Description</h3>

<p>V-fold cross-validation (also known as k-fold cross-validation) randomly
splits the data into V groups of roughly equal size (called &quot;folds&quot;).
A resample of the analysis data consists of V-1 of the folds while the
assessment set contains the final fold.
These functions extend <code><a href="rsample.html#topic+vfold_cv">rsample::vfold_cv()</a></code> and <code><a href="rsample.html#topic+group_vfold_cv">rsample::group_vfold_cv()</a></code>
to also apply an inclusion radius and exclusion buffer to the assessment set,
ensuring that your analysis data is spatially separated from the assessment
set.
In basic V-fold cross-validation (i.e. no repeats), the number of resamples
is equal to V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_buffer_vfold_cv(
  data,
  radius,
  buffer,
  v = 10,
  repeats = 1,
  strata = NULL,
  breaks = 4,
  pool = 0.1,
  ...
)

spatial_leave_location_out_cv(
  data,
  group,
  v = NULL,
  radius = NULL,
  buffer = NULL,
  ...,
  repeats = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_radius">radius</code></td>
<td>
<p>Numeric: points within this distance of the initially-selected
test points will be assigned to the assessment set. If <code>NULL</code>, no radius is
applied.</p>
</td></tr>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_buffer">buffer</code></td>
<td>
<p>Numeric: points within this distance of any point in the
test set (after <code>radius</code> is applied) will be assigned to neither the analysis
or assessment set. If <code>NULL</code>, no buffer is applied.</p>
</td></tr>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_v">v</code></td>
<td>
<p>The number of partitions for the resampling. Set to <code>NULL</code> or <code>Inf</code>
for the maximum sensible value (for leave-one-X-out cross-validation).</p>
</td></tr>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_repeats">repeats</code></td>
<td>
<p>The number of times to repeat the V-fold partitioning.</p>
</td></tr>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="spatial_buffer_vfold_cv_+3A_group">group</code></td>
<td>
<p>A variable in data (single character or name) used to create
folds. For leave-location-out CV, this should be a variable containing
the locations to group observations by, for leave-time-out CV the
time blocks to group by, and for leave-location-and-time-out the
spatiotemporal blocks to group by.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>radius</code> and <code>buffer</code> are both <code>NULL</code>, <code>spatial_buffer_vfold_cv</code>
is equivalent to <code><a href="rsample.html#topic+vfold_cv">rsample::vfold_cv()</a></code> and <code>spatial_leave_location_out_cv</code>
is equivalent to <code><a href="rsample.html#topic+group_vfold_cv">rsample::group_vfold_cv()</a></code>.
</p>


<h3>References</h3>

<p>K. Le Rest, D. Pinaud, P. Monestiez, J. Chadoeuf, and C. Bretagnolle. 2014.
&quot;Spatial leave-one-out cross-validation for variable selection in the
presence of spatial autocorrelation,&quot; Global Ecology and Biogeography 23,
pp. 811-820, doi: 10.1111/geb.12161.
</p>
<p>H. Meyer, C. Reudenbach, T. Hengl, M. Katurji, and T. Nauss. 2018.
&quot;Improving performance of spatio-temporal machine learning models using
forward feature selection and target-oriented validation,&quot;
Environmental Modelling &amp; Software 101, pp. 1-9,
doi: 10.1016/j.envsoft.2017.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Smithsonian, package = "modeldata")
Smithsonian_sf &lt;- sf::st_as_sf(
  Smithsonian,
  coords = c("longitude", "latitude"),
  crs = 4326
)

spatial_buffer_vfold_cv(
  Smithsonian_sf,
  buffer = 500,
  radius = NULL
)

data(ames, package = "modeldata")
ames_sf &lt;- sf::st_as_sf(ames, coords = c("Longitude", "Latitude"), crs = 4326)
ames_neighborhoods &lt;- spatial_leave_location_out_cv(ames_sf, Neighborhood)

</code></pre>

<hr>
<h2 id='spatial_clustering_cv'>Spatial Clustering Cross-Validation</h2><span id='topic+spatial_clustering_cv'></span>

<h3>Description</h3>

<p>Spatial clustering cross-validation splits the data into V groups of
disjointed sets by clustering points based on their spatial coordinates.
A resample of the analysis data consists of V-1 of the folds/clusters
while the assessment set contains the final fold/cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_clustering_cv(
  data,
  v = 10,
  cluster_function = c("kmeans", "hclust"),
  radius = NULL,
  buffer = NULL,
  ...,
  repeats = 1,
  distance_function = function(x) as.dist(sf::st_distance(x))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_clustering_cv_+3A_data">data</code></td>
<td>
<p>An <code>sf</code> object (often from <code><a href="sf.html#topic+st_read">sf::read_sf()</a></code>
or <code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code>) to split into folds.</p>
</td></tr>
<tr><td><code id="spatial_clustering_cv_+3A_v">v</code></td>
<td>
<p>The number of partitions of the data set.</p>
</td></tr>
<tr><td><code id="spatial_clustering_cv_+3A_cluster_function">cluster_function</code></td>
<td>
<p>Which function should be used for clustering?
Options are either <code>"kmeans"</code> (to use <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>)
or <code>"hclust"</code> (to use <code><a href="stats.html#topic+hclust">stats::hclust()</a></code>). You can also provide your own
function; see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="spatial_clustering_cv_+3A_radius">radius</code></td>
<td>
<p>Numeric: points within this distance of the initially-selected
test points will be assigned to the assessment set. If <code>NULL</code>, no radius is
applied.</p>
</td></tr>
<tr><td><code id="spatial_clustering_cv_+3A_buffer">buffer</code></td>
<td>
<p>Numeric: points within this distance of any point in the
test set (after <code>radius</code> is applied) will be assigned to neither the analysis
or assessment set. If <code>NULL</code>, no buffer is applied.</p>
</td></tr>
<tr><td><code id="spatial_clustering_cv_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on to <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> or
<code><a href="stats.html#topic+hclust">stats::hclust()</a></code>.</p>
</td></tr>
<tr><td><code id="spatial_clustering_cv_+3A_repeats">repeats</code></td>
<td>
<p>The number of times to repeat the clustered partitioning.</p>
</td></tr>
<tr><td><code id="spatial_clustering_cv_+3A_distance_function">distance_function</code></td>
<td>
<p>Which function should be used for distance
calculations? Defaults to <code><a href="sf.html#topic+geos_measures">sf::st_distance()</a></code>, with the output matrix
converted to a <code><a href="stats.html#topic+dist">stats::dist()</a></code> object. You can also provide your own
function; see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clusters are created based on the distances between observations
if <code>data</code> is an <code>sf</code> object. Each cluster is used as a fold for
cross-validation. Depending on how the data are distributed spatially, there
may not be an equal number of observations in each fold.
</p>
<p>You can optionally provide a custom function to <code>distance_function.</code> The
function should take an <code>sf</code> object and return a <code><a href="stats.html#topic+dist">stats::dist()</a></code> object with
distances between data points.
</p>
<p>You can optionally provide a custom function to <code>cluster_function</code>. The
function must take three arguments:
</p>

<ul>
<li> <p><code>dists</code>, a <code><a href="stats.html#topic+dist">stats::dist()</a></code> object with distances between data points
</p>
</li>
<li> <p><code>v</code>, a length-1 numeric for the number of folds to create
</p>
</li>
<li> <p><code>...</code>, to pass any additional named arguments to your function
</p>
</li></ul>

<p>The function should return a vector of cluster assignments of length
<code>nrow(data)</code>, with each element of the vector corresponding to the matching
row of the data frame.
</p>


<h3>Value</h3>

<p>A tibble with classes <code>spatial_clustering_cv</code>, <code>spatial_rset</code>,
<code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>.
The results include a column for the data split objects and
an identification variable <code>id</code>.
Resamples created from non-<code>sf</code> objects will not have the
<code>spatial_rset</code> class.
</p>


<h3>Changes in spatialsample 0.3.0</h3>

<p>As of spatialsample version 0.3.0, this function no longer accepts non-<code>sf</code>
objects as arguments to <code>data</code>. In order to perform clustering with
non-spatial data, consider using <code><a href="rsample.html#topic+clustering_cv">rsample::clustering_cv()</a></code>.
</p>
<p>Also as of version 0.3.0, this function now calculates edge-to-edge distance
for non-point geometries, in line with the rest of the package. Earlier
versions relied upon between-centroid distances.
</p>


<h3>References</h3>

<p>A. Brenning, &quot;Spatial cross-validation and bootstrap for the assessment of
prediction rules in remote sensing: The R package sperrorest,&quot; 2012 IEEE
International Geoscience and Remote Sensing Symposium, Munich, 2012,
pp. 5372-5375, doi: 10.1109/IGARSS.2012.6352393.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Smithsonian, package = "modeldata")

smithsonian_sf &lt;- sf::st_as_sf(
  Smithsonian,
  coords = c("longitude", "latitude"),
  # Set CRS to WGS84
  crs = 4326
)

# When providing sf objects, coords are inferred automatically
spatial_clustering_cv(smithsonian_sf, v = 5)

# Can use hclust instead:
spatial_clustering_cv(smithsonian_sf, v = 5, cluster_function = "hclust")

</code></pre>

<hr>
<h2 id='spatial_nndm_cv'>Nearest neighbor distance matching (NNDM) cross-validation</h2><span id='topic+spatial_nndm_cv'></span>

<h3>Description</h3>

<p>NNDM is a variant of leave-one-out cross-validation which assigns each
observation to a single assessment fold, and then attempts to remove data
from each analysis fold until the nearest neighbor distance distribution
between assessment and analysis folds matches the nearest neighbor distance
distribution between training data and the locations a model will be used to
predict.
Proposed by Milà et al. (2022), this method aims to provide accurate
estimates of how well models will perform in the locations they will actually
be predicting. This method was originally implemented in the CAST package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_nndm_cv(
  data,
  prediction_sites,
  ...,
  autocorrelation_range = NULL,
  prediction_sample_size = 1000,
  min_analysis_proportion = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_nndm_cv_+3A_data">data</code></td>
<td>
<p>An object of class <code>sf</code> or <code>sfc</code>.</p>
</td></tr>
<tr><td><code id="spatial_nndm_cv_+3A_prediction_sites">prediction_sites</code></td>
<td>
<p>An <code>sf</code> or <code>sfc</code> object describing the areas to be
predicted. If <code>prediction_sites</code> are all points, then those points are
treated as the intended prediction points when calculating target nearest
neighbor distances. If <code>prediction_sites</code> is a single (multi-)polygon, then
points are sampled from within the boundaries of that polygon. Otherwise,
if <code>prediction_sites</code> is of length &gt; 1 and not made up of points,
then points are sampled from within the bounding box of <code>prediction_sites</code>
and used as the intended prediction points.</p>
</td></tr>
<tr><td><code id="spatial_nndm_cv_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="sf.html#topic+st_sample">sf::st_sample()</a></code>. Note that the
number of points to sample is controlled by <code>prediction_sample_size</code>; trying
to pass <code>size</code> via <code>...</code> will cause an error.</p>
</td></tr>
<tr><td><code id="spatial_nndm_cv_+3A_autocorrelation_range">autocorrelation_range</code></td>
<td>
<p>A numeric of length 1 representing the landscape
autocorrelation range (&quot;phi&quot; in the terminology of Milà et al. (2022)). If
<code>NULL</code>, the default, the autocorrelation range is assumed to be the distance
between the opposite corners of the bounding box of <code>prediction_sites</code>.</p>
</td></tr>
<tr><td><code id="spatial_nndm_cv_+3A_prediction_sample_size">prediction_sample_size</code></td>
<td>
<p>A numeric of length 1: the number of points to
sample when <code>prediction_sites</code> is not only composed of points. Note that this
argument is passed to <code>size</code> in <code><a href="sf.html#topic+st_sample">sf::st_sample()</a></code>, meaning that no elements
of <code>...</code> can be named <code>size</code>.</p>
</td></tr>
<tr><td><code id="spatial_nndm_cv_+3A_min_analysis_proportion">min_analysis_proportion</code></td>
<td>
<p>The minimum proportion of <code>data</code> that must
remain after removing points to match nearest neighbor distances. This
function will stop removing data from analysis sets once only
<code>min_analysis_proportion</code> of the original data remains in analysis sets, even
if the nearest neighbor distances between analysis and assessment sets are
still lower than those between training and prediction locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, as a form of leave-one-out cross-validation, this method can be
rather slow for larger data (and fitting models to these resamples will be
even slower).
</p>


<h3>Value</h3>

<p>A tibble with classes <code>spatial_nndm_cv</code>,  <code>spatial_rset</code>, <code>rset</code>,
<code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>. The results include a column for the
data split objects and an identification variable <code>id</code>.
</p>


<h3>References</h3>

<p>C. Milà, J. Mateu, E. Pebesma, and H. Meyer. 2022. &quot;Nearest Neighbour
Distance Matching Leave-One-Out Cross-Validation for map validation.&quot; Methods
in Ecology and Evolution 2022:13, pp 1304– 1316.
doi: 10.1111/2041-210X.13851.
</p>
<p>H. Meyer and E. Pebesma. 2022. &quot;Machine learning-based global maps of
ecological variables and the challenge of assessing them.&quot;
Nature Communications 13, pp 2208. doi: 10.1038/s41467-022-29838-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ames, package = "modeldata")
ames_sf &lt;- sf::st_as_sf(ames, coords = c("Longitude", "Latitude"), crs = 4326)

# Using a small subset of the data, to make the example run faster:
spatial_nndm_cv(ames_sf[1:100, ], ames_sf[2001:2100, ])

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
