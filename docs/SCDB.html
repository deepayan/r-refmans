<!DOCTYPE html><html><head><title>Help for package SCDB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SCDB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#close_connection'><p>Close connection to the database</p></a></li>
<li><a href='#create_logs_if_missing'><p>Create a table with the SCDB log structure if it does not exists</p></a></li>
<li><a href='#create_table'><p>Create a historical table from input data</p></a></li>
<li><a href='#db_locks'><p>Sets, queries and removes locks for database tables</p></a></li>
<li><a href='#db_timestamp'><p>Determine the type of timestamps the database supports</p></a></li>
<li><a href='#defer_db_cleanup'><p>Delete table at function exit</p></a></li>
<li><a href='#digest_to_checksum'><p>Computes an checksum from columns</p></a></li>
<li><a href='#filter_keys'><p>Filters .data according to all records in the filter</p></a></li>
<li><a href='#get_catalog'><p>Get the current schema/catalog of a database-related objects</p></a></li>
<li><a href='#get_connection'><p>Opens connection to the database</p></a></li>
<li><a href='#get_table'><p>Retrieves a named table from a given schema on the connection</p></a></li>
<li><a href='#get_tables'><p>List the available tables on the connection</p></a></li>
<li><a href='#id'><p>Convenience function for DBI::Id</p></a></li>
<li><a href='#interlace'><p>Combine any number of tables, where each has their own time axis of validity</p></a></li>
<li><a href='#is.historical'><p>Checks if table contains historical data</p></a></li>
<li><a href='#joins'><p>SQL Joins</p></a></li>
<li><a href='#Logger'><p>Logger: Complete logging to console, file and database</p></a></li>
<li><a href='#LoggerNull'><p>LoggerNull: The no-logging Logger</p></a></li>
<li><a href='#nrow'><p>nrow() but also works on remote tables</p></a></li>
<li><a href='#SCDB-package'><p>SCDB: Easily Access and Maintain Time-Based Versioned Data (Slowly-Changing-Dimension)</p></a></li>
<li><a href='#schema_exists'><p>Test if a schema exists in given connection</p></a></li>
<li><a href='#slice_time'><p>Slices a data object based on time / date</p></a></li>
<li><a href='#table_exists'><p>Test if a table exists in database</p></a></li>
<li><a href='#unique_table_name'><p>Create a name for a temporary table</p></a></li>
<li><a href='#unite.tbl_dbi'><p>tidyr::unite for tbl_dbi</p></a></li>
<li><a href='#update_snapshot'><p>Update a historical table</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Easily Access and Maintain Time-Based Versioned Data
(Slowly-Changing-Dimension)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions that enable easy access and updating of a database of data over time.
             More specifically, the package facilitates type-2 history for data-warehouses and provides a number
             of Quality of life improvements for working on SQL databases with R.
             For reference see Ralph Kimball and Margy Ross (2013, ISBN 9781118530801).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, DBI, dbplyr (&ge; 2.4.0), dplyr, glue, lifecycle,
methods, openssl, parallelly, purrr, rlang, R6, stringr, tidyr,
tidyselect, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>callr, conflicted, duckdb, jsonlite, knitr, lintr, odbc,
rmarkdown, roxygen2, pkgdown, RPostgres, RSQLite, spelling,
testthat (&ge; 3.0.0), tibble, tidyverse, withr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ssi-dk/SCDB">https://github.com/ssi-dk/SCDB</a>, <a href="https://ssi-dk.github.io/SCDB/">https://ssi-dk.github.io/SCDB/</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ssi-dk/SCDB/issues">https://github.com/ssi-dk/SCDB/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-21 09:06:53 UTC; B246705</td>
</tr>
<tr>
<td>Author:</td>
<td>Rasmus Skytte Randløv
    <a href="https://orcid.org/0000-0002-5860-3838"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    rev],
  Marcus Munch Grünewald
    <a href="https://orcid.org/0009-0006-8090-406X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Lasse Engbo Christiansen
    <a href="https://orcid.org/0000-0001-5019-1931"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Statens Serum Institut [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rasmus Skytte Randløv &lt;rske@ssi.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-21 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='close_connection'>Close connection to the database</h2><span id='topic+close_connection'></span>

<h3>Description</h3>

<p>Close connection to the database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>close_connection(conn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close_connection_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbDisconnect()</code> returns <code>TRUE</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  close_connection(conn)

</code></pre>

<hr>
<h2 id='create_logs_if_missing'>Create a table with the SCDB log structure if it does not exists</h2><span id='topic+create_logs_if_missing'></span>

<h3>Description</h3>

<p>Create a table with the SCDB log structure if it does not exists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_logs_if_missing(conn, log_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_logs_if_missing_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
<tr><td><code id="create_logs_if_missing_+3A_log_table">log_table</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;id-like object&#8288;</code>)<br />
A table specification where the logs should exist (coercible by <code>id()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the generated (or existing) log table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()
  log_table &lt;- id("test.logs", conn = conn, allow_table_only = TRUE)

  create_logs_if_missing(conn, log_table)

  close_connection(conn)

</code></pre>

<hr>
<h2 id='create_table'>Create a historical table from input data</h2><span id='topic+create_table'></span>

<h3>Description</h3>

<p>Create a historical table from input data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_table(.data, conn = NULL, db_table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_table_+3A_.data">.data</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br />
Data object.</p>
</td></tr>
<tr><td><code id="create_table_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
<tr><td><code id="create_table_+3A_db_table">db_table</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;id-like object(1)&#8288;</code>)<br />
A table specification (coercible by <code>id()</code>).</p>
</td></tr>
<tr><td><code id="create_table_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="DBI.html#topic+dbCreateTable">DBI::dbCreateTable()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the table as it looks on the destination (or locally if <code>conn</code> is <code>NULL</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  create_table(mtcars, conn = conn, db_table = "mtcars")

  close_connection(conn)

</code></pre>

<hr>
<h2 id='db_locks'>Sets, queries and removes locks for database tables</h2><span id='topic+db_locks'></span><span id='topic+lock_table'></span><span id='topic+unlock_table'></span>

<h3>Description</h3>

<p>This set of function adds a simple locking system to database tables.
</p>

<ul>
<li> <p><code>lock_table()</code> adds a record in the schema.locks table with the current time and R-session process id.
</p>
</li>
<li> <p><code>unlock_table()</code> removes records in the schema.locks table with the target table and the R-session process id.
</p>
</li></ul>

<p>When locking a table, the function will check for existing locks on the table and produce an error a lock is held
by a process which no longer exists.
In this case, the lock needs to be removed manually by removing the record from the lock table.
In addition, the error implies that a table may have partial updates that needs to be manually rolled back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lock_table(conn, db_table, schema = NULL)

unlock_table(conn, db_table, schema = NULL, pid = Sys.getpid())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_locks_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
<tr><td><code id="db_locks_+3A_db_table">db_table</code></td>
<td>
<p>(<code>character(1)</code>)<br />
A specification of &quot;schema.table&quot; to modify lock for.</p>
</td></tr>
<tr><td><code id="db_locks_+3A_schema">schema</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The schema where the &quot;locks&quot; table should be created.</p>
</td></tr>
<tr><td><code id="db_locks_+3A_pid">pid</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
The process id to remove the lock for.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>lock_table()</code> returns the <code>TRUE</code> (<code>FALSE</code>) if the lock was (un)successfully added.
If a lock exists for a non-active process, an error is thrown.
</p>
</li>
<li> <p><code>unlock_table()</code> returns <code>NULL</code> (called for side effects).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- DBI::dbConnect(RSQLite::SQLite())

  lock_table(conn, "test_table") # TRUE

  unlock_table(conn, "test_table")

  DBI::dbDisconnect(conn)

</code></pre>

<hr>
<h2 id='db_timestamp'>Determine the type of timestamps the database supports</h2><span id='topic+db_timestamp'></span>

<h3>Description</h3>

<p>Determine the type of timestamps the database supports
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_timestamp(timestamp, conn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_timestamp_+3A_timestamp">timestamp</code></td>
<td>
<p>(<code>POSIXct(1)</code> or <code>character(1)</code>)<br />
The timestamp to be transformed to the database type.</p>
</td></tr>
<tr><td><code id="db_timestamp_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The given timestamp converted to a SQL-backend dependent timestamp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  db_timestamp(Sys.time(), conn)

  close_connection(conn)

</code></pre>

<hr>
<h2 id='defer_db_cleanup'>Delete table at function exit</h2><span id='topic+defer_db_cleanup'></span>

<h3>Description</h3>

<p>This function marks a table for deletion once the current function exits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defer_db_cleanup(db_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defer_db_cleanup_+3A_db_table">db_table</code></td>
<td>
<p>(<code>tbl_sql</code>)<br />
A unmanipulated reference to a sql table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (called for side effects)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  mt &lt;- dplyr::copy_to(conn, mtcars)
  id_mt &lt;- id(mt)

  defer_db_cleanup(mt)

  DBI::dbExistsTable(conn, id_mt) # TRUE

  withr::deferred_run()

  DBI::dbExistsTable(conn, id_mt) # FALSE

  close_connection(conn)

</code></pre>

<hr>
<h2 id='digest_to_checksum'>Computes an checksum from columns</h2><span id='topic+digest_to_checksum'></span>

<h3>Description</h3>

<p>Computes an checksum from columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>digest_to_checksum(.data, col = "checksum", exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="digest_to_checksum_+3A_.data">.data</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br />
Data object.</p>
</td></tr>
<tr><td><code id="digest_to_checksum_+3A_col">col</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Name of the column to put the checksums in. Will be generated if missing.</p>
</td></tr>
<tr><td><code id="digest_to_checksum_+3A_exclude">exclude</code></td>
<td>
<p>(<code>character()</code>)<br />
Columns to exclude from the checksum generation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases, the md5 algorithm is used to compute the checksums.
For Microsoft SQL Server, the SHA-256 algorithm is used.
</p>


<h3>Value</h3>

<p>.data with a checksum column added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  digest_to_checksum(mtcars)
</code></pre>

<hr>
<h2 id='filter_keys'>Filters .data according to all records in the filter</h2><span id='topic+filter_keys'></span>

<h3>Description</h3>

<p>If <code>filters</code> is <code>NULL</code>, no filtering is done.
Otherwise, the <code>.data</code> object is filtered via an <code>inner_join()</code> using all columns of the filter:
<code>inner_join(.data, filter, by = colnames(filter))</code>
</p>
<p><code>by</code> and <code>na_by</code> can overwrite the <code>inner_join()</code> columns used in the filtering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_keys(.data, filters, by = NULL, na_by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_keys_+3A_.data">.data</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br />
Data object.</p>
</td></tr>
<tr><td><code id="filter_keys_+3A_filters">filters</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br />
A object subset data by.
If filters is <code>NULL</code>, no filtering occurs.
Otherwise, an <code>inner_join()</code> is performed using all columns of the filter object.</p>
</td></tr>
<tr><td><code id="filter_keys_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="filter_keys_+3A_na_by">na_by</code></td>
<td>
<p>(<code>character()</code>)<br />
Columns where NA should match with NA.</p>
</td></tr>
<tr><td><code id="filter_keys_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>dplyr::inner_join()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of same class as .data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Filtering with null means no filtering is done
  filter &lt;- NULL
  identical(filter_keys(mtcars, filter), mtcars) # TRUE

  # Filtering by vs = 0
  filter &lt;- data.frame(vs = 0)
  identical(filter_keys(mtcars, filter), dplyr::filter(mtcars, vs == 0)) # TRUE

  # Filtering by the specific combinations of vs = 0 and am = 1
  filter &lt;- dplyr::distinct(mtcars, vs, am)
  filter_keys(mtcars, filter)

</code></pre>

<hr>
<h2 id='get_catalog'>Get the current schema/catalog of a database-related objects</h2><span id='topic+get_catalog'></span><span id='topic+get_catalog.Microsoft+20SQL+20Server'></span><span id='topic+get_schema'></span><span id='topic+get_schema.PqConnection'></span><span id='topic+get_schema.SQLiteConnection'></span>

<h3>Description</h3>

<p>Get the current schema/catalog of a database-related objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_catalog(obj, ...)

## S3 method for class ''Microsoft SQL Server''
get_catalog(obj, temporary = FALSE, ...)

get_schema(obj, ...)

## S3 method for class 'PqConnection'
get_schema(obj, temporary = FALSE, ...)

## S3 method for class 'SQLiteConnection'
get_schema(obj, temporary = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_catalog_+3A_obj">obj</code></td>
<td>
<p>(<code>DBIConnection(1)</code>, <code>tbl_dbi(1)</code>, <code>Id(1)</code>)<br />
The object from which to retrieve a schema/catalog.</p>
</td></tr>
<tr><td><code id="get_catalog_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="get_catalog_+3A_temporary">temporary</code></td>
<td>
<p>(<code>logical(1)</code>) <br />
Should the reference be to the temporary schema/catalog?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The catalog is extracted from <code>obj</code> depending on the type of input:
</p>

<ul>
<li><p> For <code style="white-space: pre;">&#8288;get_catalog.Microsoft SQL Server&#8288;</code>, the current database context of the connection or &quot;tempdb&quot; if
<code>temporary = TRUE</code>.
</p>
</li>
<li><p> For <code>get_schema.tbl_dbi</code> the catalog is determined via <code>id()</code>.
</p>
</li>
<li><p> For <code style="white-space: pre;">&#8288;get_catalog.\\*&#8288;</code>, <code>NULL</code> is returned.
</p>
</li></ul>

<p>The schema is extracted from <code>obj</code> depending on the type of input:
</p>

<ul>
<li><p> For <code>get_schema.DBIConnection()</code>, the current schema of the connection if <code>temporary = FALSE</code>.
See &quot;Default schema&quot; for more.
If <code>temporary = TRUE</code>, the temporary schema of the connection is returned.
</p>
</li>
<li><p> For <code>get_schema.tbl_dbi()</code> the schema is determined via <code>id()</code>.
</p>
</li>
<li><p> For <code>get_schema.Id()</code>, the schema is extracted from the <code>Id</code> specification.
</p>
</li></ul>



<h3>Default schema</h3>

<p>In some backends, it is possible to modify settings so that when a schema is not explicitly stated in a query,
the backend searches for the table in this schema by default.
For Postgres databases, this can be shown with <code style="white-space: pre;">&#8288;SELECT CURRENT_SCHEMA()&#8288;</code> (defaults to <code>public</code>) and modified with
<code style="white-space: pre;">&#8288;SET search_path TO { schema }&#8288;</code>.
</p>
<p>For SQLite databases, a <code>temp</code> schema for temporary tables always exists as well as a <code>main</code> schema for permanent
tables. Additional databases may be attached to the connection with a named schema, but as the attachment must be
made after the connection is established, <code>get_schema</code> will never return any of these, as the default schema will
always be <code>main</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  dplyr::copy_to(conn, mtcars, name = "mtcars", temporary = FALSE)

  get_schema(conn)
  get_schema(get_table(conn, id("mtcars", conn = conn)))

  get_catalog(conn)
  get_catalog(get_table(conn, id("mtcars", conn = conn)))

  close_connection(conn)

</code></pre>

<hr>
<h2 id='get_connection'>Opens connection to the database</h2><span id='topic+get_connection'></span><span id='topic+get_connection.SQLiteDriver'></span><span id='topic+get_connection.PqDriver'></span><span id='topic+get_connection.OdbcDriver'></span><span id='topic+get_connection.duckdb_driver'></span><span id='topic+get_connection.default'></span>

<h3>Description</h3>

<p>This is a convenience wrapper for DBI::dbConnect() for different database backends.
</p>
<p>Connects to the specified dbname of host:port using user and password from given arguments (if applicable).
Certain drivers may use credentials stored in a file, such as ~/.pgpass (PostgreSQL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_connection(drv, ...)

## S3 method for class 'SQLiteDriver'
get_connection(
  drv,
  dbname = ":memory:",
  ...,
  bigint = c("integer", "bigint64", "numeric", "character")
)

## S3 method for class 'PqDriver'
get_connection(
  drv,
  dbname = NULL,
  host = NULL,
  port = NULL,
  password = NULL,
  user = NULL,
  ...,
  bigint = c("integer", "bigint64", "numeric", "character"),
  check_interrupts = TRUE,
  timezone = Sys.timezone(),
  timezone_out = Sys.timezone()
)

## S3 method for class 'OdbcDriver'
get_connection(
  drv,
  dsn = NULL,
  ...,
  bigint = c("integer", "bigint64", "numeric", "character"),
  timezone = Sys.timezone(),
  timezone_out = Sys.timezone()
)

## S3 method for class 'duckdb_driver'
get_connection(
  drv,
  dbdir = ":memory:",
  ...,
  bigint = c("numeric", "character"),
  timezone_out = Sys.timezone()
)

## Default S3 method:
get_connection(drv, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_connection_+3A_drv">drv</code></td>
<td>
<p>(<code>DBIDriver(1)</code> or <code>DBIConnection(1)</code>)<br />
The driver for the connection (defaults to <code>SQLiteDriver</code>).</p>
</td></tr>
<tr><td><code id="get_connection_+3A_...">...</code></td>
<td>
<p>Additional parameters sent to DBI::dbConnect().</p>
</td></tr>
<tr><td><code id="get_connection_+3A_dbname">dbname</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Name of the database located at the host.</p>
</td></tr>
<tr><td><code id="get_connection_+3A_bigint">bigint</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The datatype to convert integers to.
Support depends on the database backend.</p>
</td></tr>
<tr><td><code id="get_connection_+3A_host">host</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The ip of the host to connect to.</p>
</td></tr>
<tr><td><code id="get_connection_+3A_port">port</code></td>
<td>
<p>(<code>numeric(1)</code> or <code>character(1)</code>)<br />
Host port to connect to.</p>
</td></tr>
<tr><td><code id="get_connection_+3A_password">password</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Password to login with.</p>
</td></tr>
<tr><td><code id="get_connection_+3A_user">user</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Username to login with.</p>
</td></tr>
<tr><td><code id="get_connection_+3A_check_interrupts">check_interrupts</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Should user interrupts be checked during the query execution?</p>
</td></tr>
<tr><td><code id="get_connection_+3A_timezone">timezone</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Sets the timezone of DBI::dbConnect(). Must be in <code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code>.</p>
</td></tr>
<tr><td><code id="get_connection_+3A_timezone_out">timezone_out</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Sets the timezone_out of DBI::dbConnect(). Must be in <code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code>.</p>
</td></tr>
<tr><td><code id="get_connection_+3A_dsn">dsn</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The data source name to connect to.</p>
</td></tr>
<tr><td><code id="get_connection_+3A_dbdir">dbdir</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The directory where the database is located.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that inherits from <code>DBIConnection</code> driver specified in <code>drv</code>.
</p>


<h3>See Also</h3>

<p><a href="RSQLite.html#topic+SQLite">RSQLite::SQLite</a>
</p>
<p><a href="RPostgres.html#topic+Postgres">RPostgres::Postgres</a>
</p>
<p><a href="odbc.html#topic+dbConnect-OdbcDriver-method">odbc::odbc</a>
</p>
<p><a href="duckdb.html#topic+duckdb">duckdb::duckdb</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection(drv = RSQLite::SQLite(), dbname = ":memory:")

  DBI::dbIsValid(conn) # TRUE

  close_connection(conn)

  DBI::dbIsValid(conn) # FALSE

</code></pre>

<hr>
<h2 id='get_table'>Retrieves a named table from a given schema on the connection</h2><span id='topic+get_table'></span>

<h3>Description</h3>

<p>Retrieves a named table from a given schema on the connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_table(conn, db_table = NULL, slice_ts = NA, include_slice_info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_table_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
<tr><td><code id="get_table_+3A_db_table">db_table</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;id-like object(1)&#8288;</code>)<br />
A table specification (coercible by <code>id()</code>).
If missing, a list of available tables is printed.</p>
</td></tr>
<tr><td><code id="get_table_+3A_slice_ts">slice_ts</code></td>
<td>
<p>(<code>POSIXct(1)</code>, <code>Date(1)</code>, or <code>character(1)</code>)<br />
If set different from <code>NA</code> (default), the returned data looks as on the given date.
If set as <code>NULL</code>, all data is returned.</p>
</td></tr>
<tr><td><code id="get_table_+3A_include_slice_info">include_slice_info</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Should the history columns &quot;checksum&quot;, &quot;from_ts&quot;, &quot;until_ts&quot; are also be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;lazy&quot; data.frame (tbl_lazy) generated using dbplyr.
</p>
<p>Note that a temporary table will be preferred over ordinary tables in the default schema (see <code><a href="#topic+get_schema">get_schema()</a></code>) with
an identical name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  dplyr::copy_to(conn, mtcars, name = "mtcars", temporary = FALSE)

  get_table(conn)
  if (table_exists(conn, "mtcars")) {
    get_table(conn, "mtcars")
  }

  close_connection(conn)

</code></pre>

<hr>
<h2 id='get_tables'>List the available tables on the connection</h2><span id='topic+get_tables'></span>

<h3>Description</h3>

<p>List the available tables on the connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tables(conn, pattern = NULL, show_temporary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tables_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
<tr><td><code id="get_tables_+3A_pattern">pattern</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Regex pattern with which to subset the returned tables.</p>
</td></tr>
<tr><td><code id="get_tables_+3A_show_temporary">show_temporary</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Should temporary tables be listed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing table names including schema (and catalog when available) in the database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  dplyr::copy_to(conn, mtcars, name = "my_test_table_1", temporary = FALSE)
  dplyr::copy_to(conn, mtcars, name = "my_test_table_2")

  get_tables(conn, pattern = "my_[th]est")
  get_tables(conn, pattern = "my_[th]est", show_temporary = FALSE)

  close_connection(conn)

</code></pre>

<hr>
<h2 id='id'>Convenience function for DBI::Id</h2><span id='topic+id'></span><span id='topic+id.Id'></span><span id='topic+id.character'></span><span id='topic+id.data.frame'></span>

<h3>Description</h3>

<p>Convenience function for DBI::Id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id(db_table, ...)

## S3 method for class 'Id'
id(db_table, conn = NULL, ...)

## S3 method for class 'character'
id(db_table, conn = NULL, allow_table_only = TRUE, ...)

## S3 method for class 'data.frame'
id(db_table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_+3A_db_table">db_table</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;id-like object(1)&#8288;</code>)<br />
A table specification (coercible by <code>id()</code>).</p>
</td></tr>
<tr><td><code id="id_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="id_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
<tr><td><code id="id_+3A_allow_table_only">allow_table_only</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, allows for returning an <code>DBI::Id</code> with <code>table</code> = &quot;myschema.table&quot; if schema &quot;myschema&quot;
is not found in <code>conn</code>.
If <code>FALSE</code>, the function will raise an error if the implied schema cannot be found in <code>conn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The given <code>db_table</code> is parsed to a DBI::Id depending on the type of input:
</p>

<ul>
<li> <p><code>character</code>: db_table is parsed to a DBI::Id object using an assumption of &quot;schema.table&quot; syntax
with corresponding schema (if found in <code>conn</code>) and table values.
If no schema is implied, the default schema of <code>conn</code> will be used.
</p>
</li>
<li> <p><code>DBI::Id</code>: if schema is not specified in <code>Id</code>, the schema is set to the default schema for <code>conn</code> (if given).
</p>
</li>
<li> <p><code>tbl_sql</code>: the remote name is used to resolve the table identification.
</p>
</li>
<li> <p><code>data.frame</code>: A Id is built from the data.frame (columns <code>catalog</code>, <code>schema</code>, and <code>table</code>).
Can be used in conjunction with <code>get_tables(conn, pattern)</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>DBI::Id</code> object parsed from db_table (see details).
</p>


<h3>See Also</h3>

<p><a href="DBI.html#topic+Id">DBI::Id</a> which this function wraps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  id("schema.table")
</code></pre>

<hr>
<h2 id='interlace'>Combine any number of tables, where each has their own time axis of validity</h2><span id='topic+interlace'></span><span id='topic+interlace_sql'></span>

<h3>Description</h3>

<p>The function &quot;interlaces&quot; the queries and combines their validity time axes (valid_from and valid_until)
onto a single time axis.
</p>
<p><code>interlace_sql()</code> is deprecated in favor of <code>interlace()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interlace(tables, by = NULL, colnames = NULL)

interlace_sql(tables, by = NULL, colnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interlace_+3A_tables">tables</code></td>
<td>
<p>(<code>list</code>(<code>tbl_dbi(1)</code>))<br />
The historical tables to combine.</p>
</td></tr>
<tr><td><code id="interlace_+3A_by">by</code></td>
<td>
<p>(<code>character()</code>)<br />
The variable to merge by.</p>
</td></tr>
<tr><td><code id="interlace_+3A_colnames">colnames</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named list()&#8288;</code>)<br />
If the time axes of validity is not called &quot;valid_to&quot; and &quot;valid_until&quot; inside each <code>tbl_dbi</code>,
you can specify their names by supplying the arguments as a list:
e.g. c(t1.from = &quot;\&lt;colname\&gt;&quot;, t2.until = &quot;\&lt;colname\&gt;&quot;).
colnames must be named in same order as as given in tables (i.e. t1, t2, t3, ...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The combination of input queries with a single, interlaced valid_from / valid_until time axis.
</p>
<div class="sourceCode"><pre>     The combination of input queries with a single, interlaced
             valid_from / valid_until time axis
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  t1 &lt;- data.frame(key = c("A", "A", "B"),
                   obs_1   = c(1, 2, 2),
                   valid_from  = as.Date(c("2021-01-01", "2021-02-01", "2021-01-01")),
                   valid_until = as.Date(c("2021-02-01", "2021-03-01", NA))) |&gt;
    dplyr::copy_to(conn, df = _, name = "t1")

  t2 &lt;- data.frame(key = c("A", "B"),
                   obs_2 = c("a", "b"),
                   valid_from  = as.Date(c("2021-01-01", "2021-01-01")),
                   valid_until = as.Date(c("2021-04-01", NA))) |&gt;
    dplyr::copy_to(conn, df = _, name = "t2")

  interlace(list(t1, t2), by = "key")

  close_connection(conn)

</code></pre>

<hr>
<h2 id='is.historical'>Checks if table contains historical data</h2><span id='topic+is.historical'></span>

<h3>Description</h3>

<p>Checks if table contains historical data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.historical(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.historical_+3A_.data">.data</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br />
Data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>.data</code> contains the columns: &quot;checksum&quot;, &quot;from_ts&quot;, and &quot;until_ts&quot;. <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  dplyr::copy_to(conn, mtcars, name = "mtcars", temporary = FALSE)
  create_table(mtcars, conn, db_table = id("mtcars_historical", conn))

  is.historical(get_table(conn, "mtcars")) # FALSE
  is.historical(get_table(conn, "mtcars_historical")) # TRUE

  close_connection(conn)

</code></pre>

<hr>
<h2 id='joins'>SQL Joins</h2><span id='topic+joins'></span><span id='topic+inner_join.tbl_sql'></span><span id='topic+left_join.tbl_sql'></span><span id='topic+right_join.tbl_sql'></span><span id='topic+full_join.tbl_sql'></span><span id='topic+semi_join.tbl_sql'></span><span id='topic+anti_join.tbl_sql'></span>

<h3>Description</h3>

<p>Overloads the dplyr <code style="white-space: pre;">&#8288;*_join&#8288;</code> to accept an <code>na_by</code> argument.
By default, joining using SQL does not match on <code>NA</code> / <code>NULL</code>.
dbplyr <code style="white-space: pre;">&#8288;*_join&#8288;</code>s has the option &quot;na_matches = na&quot; to match on <code>NA</code> / <code>NULL</code> but this is very inefficient in some
cases.
This function does the matching more efficiently:
If a column contains <code>NA</code> / <code>NULL</code>, the names of these columns can be passed via the <code>na_by</code> argument and
efficiently match as if &quot;na_matches = na&quot;.
If no <code>na_by</code> argument is given is given, the function defaults to using <code style="white-space: pre;">&#8288;dplyr::*_join&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_sql'
inner_join(x, y, by = NULL, ...)

## S3 method for class 'tbl_sql'
left_join(x, y, by = NULL, ...)

## S3 method for class 'tbl_sql'
right_join(x, y, by = NULL, ...)

## S3 method for class 'tbl_sql'
full_join(x, y, by = NULL, ...)

## S3 method for class 'tbl_sql'
semi_join(x, y, by = NULL, ...)

## S3 method for class 'tbl_sql'
anti_join(x, y, by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joins_+3A_x">x</code>, <code id="joins_+3A_y">y</code></td>
<td>
<p>A pair of lazy data frames backed by database queries.</p>
</td></tr>
<tr><td><code id="joins_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="joins_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>See Also</h3>

<p><a href="dplyr.html#topic+mutate-joins">dplyr::mutate-joins</a> which this function wraps.
</p>
<p><a href="dbplyr.html#topic+join.tbl_sql">dbplyr::join.tbl_sql</a> which this function wraps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(dplyr, warn.conflicts = FALSE)
  library(dbplyr, warn.conflicts = FALSE)

  band_db &lt;- tbl_memdb(dplyr::band_members)
  instrument_db &lt;- tbl_memdb(dplyr::band_instruments)

  left_join(band_db, instrument_db) |&gt;
    show_query()

  # Can join with local data frames by setting copy = TRUE
  left_join(band_db, dplyr::band_instruments, copy = TRUE)

  # Unlike R, joins in SQL don't usually match NAs (NULLs)
  db &lt;- memdb_frame(x = c(1, 2, NA))
  label &lt;- memdb_frame(x = c(1, NA), label = c("one", "missing"))
  left_join(db, label, by = "x")

  # But you can activate R's usual behaviour with the na_matches argument
  left_join(db, label, by = "x", na_matches = "na")

  # By default, joins are equijoins, but you can use `sql_on` to
  # express richer relationships
  db1 &lt;- memdb_frame(x = 1:5)
  db2 &lt;- memdb_frame(x = 1:3, y = letters[1:3])

  left_join(db1, db2) |&gt; show_query()
  left_join(db1, db2, sql_on = "LHS.x &lt; RHS.x") |&gt; show_query()

</code></pre>

<hr>
<h2 id='Logger'>Logger: Complete logging to console, file and database</h2><span id='topic+Logger'></span>

<h3>Description</h3>

<p>The <code>Logger</code> class facilitates logging to a database and/or file and to console.
</p>
<p>A <code>Logger</code> is associated with a specific table and timestamp which must be supplied at initialization.
This information is used to create the log file (if a <code>log_path</code> is given) and the log entry in the database
(if a <code>log_table_id</code> and <code>log_conn</code> is given).
</p>
<p>Logging to the database must match the fields in the log table.
</p>


<h3>Value</h3>

<p>A new instance of the <code>Logger</code> <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>output_to_console</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the Logger output to console? Read only.
This can always be overridden by Logger$log_info(..., output_to_console = FALSE).</p>
</dd>
<dt><code>log_path</code></dt><dd><p>(<code>character(1)</code>)<br />
The location log files are written (if this is not NULL). Defaults to <code>getOption("SCDB.log_path")</code>. Read only.</p>
</dd>
<dt><code>log_tbl</code></dt><dd><p>(<code>tbl_dbi(1)</code>)<br />
The database table used for logging. Class is connection-specific, but inherits from <code>tbl_dbi</code>. Read only.</p>
</dd>
<dt><code>start_time</code></dt><dd><p>(<code>POSIXct(1)</code>)<br />
The time at which data processing was started. Read only.</p>
</dd>
<dt><code>log_filename</code></dt><dd><p>(<code>character(1)</code>)<br />
The filename (basename) of the file that the <code>Logger</code> instance will output to.  Read only.</p>
</dd>
<dt><code>log_realpath</code></dt><dd><p>(<code>character(1)</code>)<br />
The full path to the logger's log file. Read only.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Logger-new"><code>Logger$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Logger-finalize"><code>Logger$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-Logger-log_info"><code>Logger$log_info()</code></a>
</p>
</li>
<li> <p><a href="#method-Logger-log_warn"><code>Logger$log_warn()</code></a>
</p>
</li>
<li> <p><a href="#method-Logger-log_error"><code>Logger$log_error()</code></a>
</p>
</li>
<li> <p><a href="#method-Logger-log_to_db"><code>Logger$log_to_db()</code></a>
</p>
</li>
<li> <p><a href="#method-Logger-finalize_db_entry"><code>Logger$finalize_db_entry()</code></a>
</p>
</li>
<li> <p><a href="#method-Logger-clone"><code>Logger$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Logger-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Logger</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Logger$new(
  db_table = NULL,
  timestamp = NULL,
  output_to_console = TRUE,
  log_table_id = getOption("SCDB.log_table_id"),
  log_conn = NULL,
  log_path = getOption("SCDB.log_path"),
  start_time = Sys.time(),
  warn = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>db_table</code></dt><dd><p>(<code style="white-space: pre;">&#8288;id-like object(1)&#8288;</code>)<br />
A table specification (coercible by <code>id()</code>) specifying the table being updated.</p>
</dd>
<dt><code>timestamp</code></dt><dd><p>(<code>POSIXct(1)</code>, <code>Date(1)</code>, or <code>character(1)</code>)<br />
A timestamp describing the data being processed (not the current time).</p>
</dd>
<dt><code>output_to_console</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the Logger output to console?</p>
</dd>
<dt><code>log_table_id</code></dt><dd><p>(<code style="white-space: pre;">&#8288;id-like object(1)&#8288;</code>)<br />
A table specification (coercible by <code>id()</code>) specifying the location of the log table.</p>
</dd>
<dt><code>log_conn</code></dt><dd><p>(<code>DBIConnection(1)</code>)<br />
A database connection where log table should exist.</p>
</dd>
<dt><code>log_path</code></dt><dd><p>(<code>character(1)</code>)<br />
The path where logs are stored.
If <code>NULL</code>, no file logs are created.</p>
</dd>
<dt><code>start_time</code></dt><dd><p>(<code>POSIXct(1)</code>)<br />
The time at which data processing was started (defaults to <code><a href="base.html#topic+Sys.time">Sys.time()</a></code>).</p>
</dd>
<dt><code>warn</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should a warning be produced if no logging will be done?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Logger-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>Remove generated <code>log_name</code> from database if not writing to a file.
</p>


<h5>Usage</h5>

<div class="r"><pre>Logger$finalize()</pre></div>


<hr>
<a id="method-Logger-log_info"></a>



<h4>Method <code>log_info()</code></h4>

<p>Write a line to log (console / file).
</p>


<h5>Usage</h5>

<div class="r"><pre>Logger$log_info(
  ...,
  tic = Sys.time(),
  output_to_console = self$output_to_console,
  log_type = "INFO",
  timestamp_format = getOption("SCDB.log_timestamp_format", "%F %R:%OS3")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(<code>character()</code>)<br />
Character strings to be concatenated as log message.</p>
</dd>
<dt><code>tic</code></dt><dd><p>(<code>POSIXct(1)</code>)<br />
The timestamp used by the log entry.</p>
</dd>
<dt><code>output_to_console</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the line be written to console?</p>
</dd>
<dt><code>log_type</code></dt><dd><p>(<code>character(1)</code>)<br />
The severity of the log message.</p>
</dd>
<dt><code>timestamp_format</code></dt><dd><p>(<code>character(1)</code>)<br />
The format of the timestamp used in the log message (parsable by <code><a href="base.html#topic+strftime">strftime()</a></code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Returns the log message invisibly
</p>


<hr>
<a id="method-Logger-log_warn"></a>



<h4>Method <code>log_warn()</code></h4>

<p>Write a warning to log file and generate warning.
</p>


<h5>Usage</h5>

<div class="r"><pre>Logger$log_warn(..., log_type = "WARNING")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(<code>character()</code>)<br />
Character strings to be concatenated as log message.</p>
</dd>
<dt><code>log_type</code></dt><dd><p>(<code>character(1)</code>)<br />
The severity of the log message.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Logger-log_error"></a>



<h4>Method <code>log_error()</code></h4>

<p>Write an error to log file and stop execution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Logger$log_error(..., log_type = "ERROR")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(<code>character()</code>)<br />
Character strings to be concatenated as log message.</p>
</dd>
<dt><code>log_type</code></dt><dd><p>(<code>character(1)</code>)<br />
The severity of the log message.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Logger-log_to_db"></a>



<h4>Method <code>log_to_db()</code></h4>

<p>Write or update log table.
</p>


<h5>Usage</h5>

<div class="r"><pre>Logger$log_to_db(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(<code style="white-space: pre;">&#8288;Name-value pairs&#8288;</code>)<br />
Structured data written to database log table. Name indicates column and value indicates value to be written.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Logger-finalize_db_entry"></a>



<h4>Method <code>finalize_db_entry()</code></h4>

<p>Auto-fills &quot;end_time&quot; and &quot;duration&quot; for the log entry and clears the &quot;log_file&quot; field if no
file is being written.
</p>


<h5>Usage</h5>

<div class="r"><pre>Logger$finalize_db_entry(end_time = Sys.time())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>end_time</code></dt><dd><p>(<code>POSIXct(1)</code>, <code>Date(1)</code>, or <code>character(1)</code>)<br />
The end time for the log entry.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Logger-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Logger$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>  logger &lt;- Logger$new(
    db_table = "test.table",
    timestamp = "2020-01-01 09:00:00"
  )

  logger$log_info("This is an info message")
  logger$log_to_db(message = "This is a message")

  try(logger$log_warn("This is a warning!"))
  try(logger$log_error("This is an error!"))
</code></pre>

<hr>
<h2 id='LoggerNull'>LoggerNull: The no-logging Logger</h2><span id='topic+LoggerNull'></span>

<h3>Description</h3>

<p>The <code>LoggerNull</code> class overwrites the functions of the <code>Logger</code> so no logging is produced.
Errors and warnings are still produced.
</p>


<h3>Value</h3>

<p>A new instance of the <code>LoggerNull</code> <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Logger">SCDB::Logger</a></code> -&gt; <code>LoggerNull</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LoggerNull-new"><code>LoggerNull$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LoggerNull-log_to_db"><code>LoggerNull$log_to_db()</code></a>
</p>
</li>
<li> <p><a href="#method-LoggerNull-finalize_db_entry"><code>LoggerNull$finalize_db_entry()</code></a>
</p>
</li>
<li> <p><a href="#method-LoggerNull-clone"><code>LoggerNull$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="SCDB" data-topic="Logger" data-id="finalize"><a href='../../SCDB/html/Logger.html#method-Logger-finalize'><code>SCDB::Logger$finalize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SCDB" data-topic="Logger" data-id="log_error"><a href='../../SCDB/html/Logger.html#method-Logger-log_error'><code>SCDB::Logger$log_error()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SCDB" data-topic="Logger" data-id="log_info"><a href='../../SCDB/html/Logger.html#method-Logger-log_info'><code>SCDB::Logger$log_info()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SCDB" data-topic="Logger" data-id="log_warn"><a href='../../SCDB/html/Logger.html#method-Logger-log_warn'><code>SCDB::Logger$log_warn()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LoggerNull-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>LoggerNull</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>LoggerNull$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Captures arguments given, but does nothing</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LoggerNull-log_to_db"></a>



<h4>Method <code>log_to_db()</code></h4>

<p>Matches the signature of <code>Logger$log_to_db()</code>, but does nothing.
</p>


<h5>Usage</h5>

<div class="r"><pre>LoggerNull$log_to_db(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Captures arguments given, but does nothing</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LoggerNull-finalize_db_entry"></a>



<h4>Method <code>finalize_db_entry()</code></h4>

<p>Matches the signature of <code>Logger$finalize_db_entry()</code>, but does nothing.
</p>


<h5>Usage</h5>

<div class="r"><pre>LoggerNull$finalize_db_entry(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Captures arguments given, but does nothing</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LoggerNull-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LoggerNull$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>  logger &lt;- LoggerNull$new()

  logger$log_info("This message will not print!")
  logger$log_to_db(message = "This message will no be written in database!")
  try(logger$log_warn("This is a warning!"))
  try(logger$log_error("This is an error!"))
</code></pre>

<hr>
<h2 id='nrow'>nrow() but also works on remote tables</h2><span id='topic+nrow'></span>

<h3>Description</h3>

<p>nrow() but also works on remote tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrow(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrow_+3A_.data">.data</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br />
Data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of records in the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  m &lt;- dplyr::copy_to(conn, mtcars)
  nrow(m) == nrow(mtcars) # TRUE

  close_connection(conn)

</code></pre>

<hr>
<h2 id='SCDB-package'>SCDB: Easily Access and Maintain Time-Based Versioned Data (Slowly-Changing-Dimension)</h2><span id='topic+SCDB'></span><span id='topic+SCDB-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A collection of functions that enable easy access and updating of a database of data over time. More specifically, the package facilitates type-2 history for data-warehouses and provides a number of Quality of life improvements for working on SQL databases with R. For reference see Ralph Kimball and Margy Ross (2013, ISBN 9781118530801).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Rasmus Skytte Randløv <a href="mailto:rske@ssi.dk">rske@ssi.dk</a> (<a href="https://orcid.org/0000-0002-5860-3838">ORCID</a>) [reviewer]
</p>
<p>Authors:
</p>

<ul>
<li><p> Marcus Munch Grünewald (<a href="https://orcid.org/0009-0006-8090-406X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Lasse Engbo Christiansen <a href="mailto:lsec@ssi.dk">lsec@ssi.dk</a> (<a href="https://orcid.org/0000-0001-5019-1931">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Statens Serum Institut [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ssi-dk/SCDB">https://github.com/ssi-dk/SCDB</a>
</p>
</li>
<li> <p><a href="https://ssi-dk.github.io/SCDB/">https://ssi-dk.github.io/SCDB/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ssi-dk/SCDB/issues">https://github.com/ssi-dk/SCDB/issues</a>
</p>
</li></ul>


<hr>
<h2 id='schema_exists'>Test if a schema exists in given connection</h2><span id='topic+schema_exists'></span>

<h3>Description</h3>

<p>Test if a schema exists in given connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schema_exists(conn, schema)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schema_exists_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
<tr><td><code id="schema_exists_+3A_schema">schema</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The schema name to test existence for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the given schema is found on <code>conn</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  schema_exists(conn, "test")

  close_connection(conn)

</code></pre>

<hr>
<h2 id='slice_time'>Slices a data object based on time / date</h2><span id='topic+slice_time'></span>

<h3>Description</h3>

<p>Slices a data object based on time / date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_time(.data, slice_ts, from_ts = "from_ts", until_ts = "until_ts")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_time_+3A_.data">.data</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br />
Data object.</p>
</td></tr>
<tr><td><code id="slice_time_+3A_slice_ts">slice_ts</code></td>
<td>
<p>(<code>POSIXct(1)</code>, <code>Date(1)</code>, or <code>character(1)</code>)<br />
The time / date to slice by.</p>
</td></tr>
<tr><td><code id="slice_time_+3A_from_ts">from_ts</code>, <code id="slice_time_+3A_until_ts">until_ts</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The name of the columns in .data specifying valid from and valid until time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of same class as .data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  m &lt;- mtcars |&gt;
    dplyr::mutate(
      "from_ts" = dplyr::if_else(dplyr::row_number() &gt; 10,
                                 as.Date("2020-01-01"),
                                 as.Date("2021-01-01")),
      "until_ts" = as.Date(NA))

  dplyr::copy_to(conn, m, name = "mtcars", temporary = FALSE)

  q &lt;- dplyr::tbl(conn, id("mtcars", conn))

  nrow(slice_time(q, "2020-01-01")) # 10
  nrow(slice_time(q, "2021-01-01")) # nrow(mtcars)

  close_connection(conn)

</code></pre>

<hr>
<h2 id='table_exists'>Test if a table exists in database</h2><span id='topic+table_exists'></span><span id='topic+table_exists.DBIConnection'></span>

<h3>Description</h3>

<p>This functions attempts to determine the existence of a given table.
If a character input is given, matching is done heuristically assuming a &quot;schema.table&quot; notation.
If no schema is implied in this case, the default schema is assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_exists(conn, db_table)

## S3 method for class 'DBIConnection'
table_exists(conn, db_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_exists_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
<tr><td><code id="table_exists_+3A_db_table">db_table</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;id-like object(1)&#8288;</code>)<br />
A table specification (coercible by <code>id()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if db_table can be parsed to a table found in <code>conn</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  dplyr::copy_to(conn, mtcars, name = "mtcars", temporary = FALSE)
  dplyr::copy_to(conn, iris, name = "iris")

  table_exists(conn, "mtcars")    # TRUE
  table_exists(conn, "iris")      # FALSE
  table_exists(conn, "temp.iris") # TRUE

  close_connection(conn)

</code></pre>

<hr>
<h2 id='unique_table_name'>Create a name for a temporary table</h2><span id='topic+unique_table_name'></span>

<h3>Description</h3>

<p>This function is heavily inspired by the unexported dbplyr function unique_table_name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_table_name(scope = "SCDB")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_table_name_+3A_scope">scope</code></td>
<td>
<p>(<code>character(1)</code>)<br />
A naming scope to generate the table name within.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string for a table name based on the given scope parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  print(unique_table_name()) # SCDB_001
  print(unique_table_name()) # SCDB_002

  print(unique_table_name("test")) # test_001
  print(unique_table_name("test")) # test_002

</code></pre>

<hr>
<h2 id='unite.tbl_dbi'>tidyr::unite for tbl_dbi</h2><span id='topic+unite.tbl_dbi'></span>

<h3>Description</h3>

<p>Convenience function to paste together multiple columns into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite.tbl_dbi(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unite.tbl_dbi_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unite.tbl_dbi_+3A_col">col</code></td>
<td>
<p>The name of the new column, as a string or symbol.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote strings
and symbols). The name is captured from the expression with
<code><a href="rlang.html#topic+defusing-advanced">rlang::ensym()</a></code> (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).</p>
</td></tr>
<tr><td><code id="unite.tbl_dbi_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to unite</p>
</td></tr>
<tr><td><code id="unite.tbl_dbi_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="unite.tbl_dbi_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
<tr><td><code id="unite.tbl_dbi_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, missing values will be removed prior to uniting
each value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_dbi with the specified columns united into a new column named according to &quot;col&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+separate">separate()</a></code>, the complement.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(tidyr, warn.conflicts = FALSE)

  df &lt;- expand_grid(x = c("a", NA), y = c("b", NA))

  unite(df, "z", x:y, remove = FALSE)

  # To remove missing values:
  unite(df, "z", x:y, na.rm = TRUE, remove = FALSE)

  # Separate is almost the complement of unite
  unite(df, "xy", x:y) |&gt;
    separate(xy, c("x", "y"))
  # (but note `x` and `y` contain now "NA" not NA)
</code></pre>

<hr>
<h2 id='update_snapshot'>Update a historical table</h2><span id='topic+update_snapshot'></span>

<h3>Description</h3>

<p><code>update_snapshots</code> makes it easy to create and update a historical data table on a remote (SQL) server.
The function takes the data (<code>.data</code>) as it looks on a given point in time (<code>timestamp</code>) and then updates
(or creates) an remote table identified by <code>db_table</code>.
This update only stores the changes between the new data (<code>.data</code>) and the data currently stored on the remote.
This way, the data can be reconstructed as it looked at any point in time while taking as little space as possible.
</p>
<p>See <code>vignette("basic-principles")</code> for further introduction to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_snapshot(
  .data,
  conn,
  db_table,
  timestamp,
  filters = NULL,
  message = NULL,
  tic = Sys.time(),
  logger = NULL,
  enforce_chronological_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_snapshot_+3A_.data">.data</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br />
Data object.</p>
</td></tr>
<tr><td><code id="update_snapshot_+3A_conn">conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br />
Connection object.</p>
</td></tr>
<tr><td><code id="update_snapshot_+3A_db_table">db_table</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;id-like object(1)&#8288;</code>)<br />
A table specification (coercible by <code>id()</code>).</p>
</td></tr>
<tr><td><code id="update_snapshot_+3A_timestamp">timestamp</code></td>
<td>
<p>(<code>POSIXct(1)</code>, <code>Date(1)</code>, or <code>character(1)</code>)<br />
The timestamp describing the data being processed (not the current time).</p>
</td></tr>
<tr><td><code id="update_snapshot_+3A_filters">filters</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br />
A object subset data by.
If filters is <code>NULL</code>, no filtering occurs.
Otherwise, an <code>inner_join()</code> is performed using all columns of the filter object.</p>
</td></tr>
<tr><td><code id="update_snapshot_+3A_message">message</code></td>
<td>
<p>(<code>character(1)</code>)<br />
A message to add to the log-file (useful for supplying metadata to the log).</p>
</td></tr>
<tr><td><code id="update_snapshot_+3A_tic">tic</code></td>
<td>
<p>(<code>POSIXct(1)</code>)<br />
A timestamp when computation began. If not supplied, it will be created at call-time
(used to more accurately convey the runtime of the update process).</p>
</td></tr>
<tr><td><code id="update_snapshot_+3A_logger">logger</code></td>
<td>
<p>(<code>Logger(1)</code>)<br />
A configured logging object. If none is given, one is initialized with default arguments.</p>
</td></tr>
<tr><td><code id="update_snapshot_+3A_enforce_chronological_order">enforce_chronological_order</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Are updates allowed if they are chronologically earlier than latest update?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p>filter_keys
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  conn &lt;- get_connection()

  data &lt;- dplyr::copy_to(conn, mtcars)

  # Copy the first 3 records
  update_snapshot(
    head(data, 3),
    conn = conn,
    db_table = "test.mtcars",
    timestamp = Sys.time()
  )

  # Update with the first 5 records
  update_snapshot(
    head(data, 5),
    conn = conn,
    db_table = "test.mtcars",
    timestamp = Sys.time()
  )

  dplyr::tbl(conn, "test.mtcars")

  close_connection(conn)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
