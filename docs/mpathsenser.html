<!DOCTYPE html><html><head><title>Help for package mpathsenser</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mpathsenser}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#activity_duration'><p>Get a summary of physical activity (recognition)</p></a></li>
<li><a href='#add_gaps'><p>Add gap periods to sensor data</p></a></li>
<li><a href='#alias_column_names'><p>Alias column names of a data frame containing sensor data</p></a></li>
<li><a href='#app_category'><p>Find the category of an app on the Google Play Store</p></a></li>
<li><a href='#app_usage'><p>Get app usage per hour</p></a></li>
<li><a href='#bin_data'><p>Create bins in variable time series</p></a></li>
<li><a href='#ccopy'><p>Copy mpathsenser zip files to a new location</p></a></li>
<li><a href='#close_db'><p>Close a database connection</p></a></li>
<li><a href='#copy_db'><p>Copy (a subset of) a database to another database</p></a></li>
<li><a href='#coverage'><p>Create a coverage chart of the sampling rate</p></a></li>
<li><a href='#create_db'><p>Create a new mpathsenser database</p></a></li>
<li><a href='#decrypt_gps'><p>Decrypt GPS data from a curve25519 public key</p></a></li>
<li><a href='#device_info'><p>Get the device info for one or more participants</p></a></li>
<li><a href='#first_date'><p>Extract the date of the first entry</p></a></li>
<li><a href='#fix_jsons'><p>Fix the end of JSON files</p></a></li>
<li><a href='#freq'><p>Measurement frequencies per sensor</p></a></li>
<li><a href='#geocode_rev'><p>Reverse geocoding with latitude and longitude</p></a></li>
<li><a href='#get_data'><p>Extract data from an m-Path Sense database</p></a></li>
<li><a href='#get_nrows'><p>Get the number of rows per sensor in a mpathsenser database</p></a></li>
<li><a href='#get_participants'><p>Get all participants</p></a></li>
<li><a href='#get_processed_files'><p>Get all processed files from a database</p></a></li>
<li><a href='#get_studies'><p>Get all studies</p></a></li>
<li><a href='#haversine'><p>Calculate the Great-Circle Distance between two points in kilometers</p></a></li>
<li><a href='#identify_gaps'><p>Identify gaps in mpathsenser mobile sensing data</p></a></li>
<li><a href='#import'><p>Import m-Path Sense files into a database</p></a></li>
<li><a href='#index_db'><p>Create indexes for an mpathsenser database</p></a></li>
<li><a href='#installed_apps'><p>Get installed apps</p></a></li>
<li><a href='#last_date'><p>Extract the date of the last entry</p></a></li>
<li><a href='#link'><p>Link y to the time scale of x</p></a></li>
<li><a href='#link_db'><p>Link two sensors OR one sensor and an external data frame using an mpathsenser database</p></a></li>
<li><a href='#link_gaps'><p>Link gaps to (ESM) data</p></a></li>
<li><a href='#moving_average'><p>Moving average for values in an mpathsenser database</p></a></li>
<li><a href='#mpathsenser-package'><p>mpathsenser: Process and Analyse Data from m-Path Sense</p></a></li>
<li><a href='#n_screen_on'><p>Get number of times screen turned on</p></a></li>
<li><a href='#n_screen_unlocks'><p>Get number of screen unlocks</p></a></li>
<li><a href='#open_db'><p>Open an mpathsenser database.</p></a></li>
<li><a href='#plot.coverage'><p>Plot a coverage overview</p></a></li>
<li><a href='#screen_duration'><p>Screen duration by hour or day</p></a></li>
<li><a href='#sensors'><p>Available Sensors</p></a></li>
<li><a href='#step_count'><p>Get step count</p></a></li>
<li><a href='#test_jsons'><p>Test JSON files for being in the correct format.</p></a></li>
<li><a href='#unpack_sensor_data'><p>Unpack raw sensor data</p></a></li>
<li><a href='#unzip_data'><p>Unzip m-Path Sense output</p></a></li>
<li><a href='#vacuum_db'><p>Vacuum a database</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Process and Analyse Data from m-Path Sense</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Overcomes one of the major challenges in mobile (passive)
    sensing, namely being able to pre-process the raw data that comes from
    a mobile sensing app, specifically 'm-Path Sense' <a href="https://m-path.io">https://m-path.io</a>.
    The main task of 'mpathsenser' is therefore to read 'm-Path Sense'
    JSON files into a database and provide several convenience functions
    to aid in data processing.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.kuleuven.be/ppw-okpiv/researchers/u0134047/mpathsenser/">https://gitlab.kuleuven.be/ppw-okpiv/researchers/u0134047/mpathsenser/</a>,
<a href="https://ppw-okpiv.pages.gitlab.kuleuven.be/researchers/u0134047/mpathsenser/">https://ppw-okpiv.pages.gitlab.kuleuven.be/researchers/u0134047/mpathsenser/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.kuleuven.be/ppw-okpiv/researchers/u0134047/mpathsenser/-/issues/">https://gitlab.kuleuven.be/ppw-okpiv/researchers/u0134047/mpathsenser/-/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DBI, dbplyr, dplyr, furrr, jsonlite, lifecycle, lubridate,
purrr, rlang, RSQLite, stats, tibble, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cli, curl, ggplot2, httr, kableExtra, knitr, lintr,
progressr, rmarkdown, rvest, sodium, spelling, testthat (&ge;
3.0.0), vroom</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-29 15:47:37 UTC; u0134047</td>
</tr>
<tr>
<td>Author:</td>
<td>Koen Niemeijer <a href="https://orcid.org/0000-0002-0816-534X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kristof Meers <a href="https://orcid.org/0000-0002-9610-7712"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  KU Leuven [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Koen Niemeijer &lt;koen.niemeijer@kuleuven.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-29 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='activity_duration'>Get a summary of physical activity (recognition)</h2><span id='topic+activity_duration'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activity_duration(
  data = NULL,
  db = NULL,
  participant_id = NULL,
  confidence = 70,
  direction = "forward",
  start_date = NULL,
  end_date = NULL,
  by = c("Total", "Day", "Hour")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="activity_duration_+3A_data">data</code></td>
<td>
<p>A data frame containing the activity data. See <a href="#topic+get_data">get_data</a> for
retrieving activity data from an mpathsenser database.</p>
</td></tr>
<tr><td><code id="activity_duration_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="activity_duration_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
<tr><td><code id="activity_duration_+3A_confidence">confidence</code></td>
<td>
<p>The minimum confidence (0-100) that should be assigned to an observation by
Activity Recognition.</p>
</td></tr>
<tr><td><code id="activity_duration_+3A_direction">direction</code></td>
<td>
<p>The directionality of the duration calculation, i.e. <code class="reqn">t - t_{t-1}</code> or
<code class="reqn">t_{t+1} - t</code>.</p>
</td></tr>
<tr><td><code id="activity_duration_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+first_date">first_date</a> to find the
date of the first entry for a participant.</p>
</td></tr>
<tr><td><code id="activity_duration_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+last_date">last_date</a> to find the date of the
last entry for a participant.</p>
</td></tr>
<tr><td><code id="activity_duration_+3A_by">by</code></td>
<td>
<p>Either 'Total', 'Hour', or 'Day' indicating how to summarise the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing a column 'activity' and a column 'duration' for the hourly
activity duration.
</p>

<hr>
<h2 id='add_gaps'>Add gap periods to sensor data</h2><span id='topic+add_gaps'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Since there may be many gaps in mobile sensing data, it is pivotal to pay attention to them in
the analysis. This function adds known gaps to data as &quot;measurements&quot;, thereby allowing easier
calculations for, for example, finding the duration. For instance, consider a participant spent
30 minutes walking. However, if it is known there is gap of 15 minutes in this interval, we
should somehow account for it. <code>add_gaps</code> accounts for this by adding the gap data to
sensors data by splitting intervals where gaps occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_gaps(data, gaps, by = NULL, continue = FALSE, fill = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_gaps_+3A_data">data</code></td>
<td>
<p>A data frame containing the data. See <code><a href="#topic+get_data">get_data()</a></code> for retrieving data from an
mpathsenser database.</p>
</td></tr>
<tr><td><code id="add_gaps_+3A_gaps">gaps</code></td>
<td>
<p>A data frame (extension) containing the gap data. See <code><a href="#topic+identify_gaps">identify_gaps()</a></code> for
retrieving gap data from an mpathsenser database. It should at least contain the columns <code>from</code>
and <code>to</code> (both in a date-time format), as well as any specified columns in <code>by</code>.</p>
</td></tr>
<tr><td><code id="add_gaps_+3A_by">by</code></td>
<td>
<p>A character vector indicating the variable(s) to match by, typically the participant
IDs. If NULL, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all variables in
common across <code style="white-space: pre;">&#8288;x and &#8288;</code>y'.</p>
</td></tr>
<tr><td><code id="add_gaps_+3A_continue">continue</code></td>
<td>
<p>Whether to continue the measurement(s) prior to the gap once the gap ends.</p>
</td></tr>
<tr><td><code id="add_gaps_+3A_fill">fill</code></td>
<td>
<p>A named list of the columns to fill with default values for the extra measurements
that are added because of the gaps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the example of 30 minutes walking where a 15 minute gap occurred (say after 5
minutes), <code>add_gaps()</code> adds two rows: one after 5 minutes of the start of the interval
indicating the start of the gap(if needed containing values from <code>fill</code>), and one after 20
minutes of the start of the interval signalling the walking activity. Then, when calculating
time differences between subsequent measurements, the gap period is appropriately accounted
for. Note that if multiple measurements occurred before the gap, they will both be continued
after the gap.
</p>


<h3>Value</h3>

<p>A tibble containing the data and the added gaps.
</p>


<h3>Warning</h3>

<p>Depending on the sensor that is used to identify the gaps (though this is
typically the highest frequency sensor, such as the accelerometer or gyroscope), there may be a
small delay between the start of the gap and the <em>actual</em> start of the gap. For example, if the
accelerometer samples every 5 seconds, it may be after 4.99 seconds after the last
accelerometer measurement (so just before the next measurement), the app was killed. However,
within that time other measurements may still have taken place, thereby technically occurring
&quot;within&quot; the gap. This is especially important if you want to use these gaps in
<code><a href="#topic+add_gaps">add_gaps</a></code> since this issue may lead to erroneous results.
</p>
<p>An easy way to solve this problem is by taking into account all the sensors of interest when
identifying the gaps, thereby ensuring there are no measurements of these sensors within the
gap. One way to account for this is to (as in this example) search for gaps 5 seconds longer
than you want and then afterwards increasing the start time of the gaps by 5 seconds.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+identify_gaps">identify_gaps()</a></code> for finding gaps in the sampling; <code><a href="#topic+link_gaps">link_gaps()</a></code> for linking gaps to
ESM data, analogous to <code><a href="#topic+link">link()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define some data
dat &lt;- data.frame(
  participant_id = "12345",
  time = as.POSIXct(c("2022-05-10 10:00:00", "2022-05-10 10:30:00", "2022-05-10 11:30:00")),
  type = c("WALKING", "STILL", "RUNNING"),
  confidence = c(80, 100, 20)
)

# Get the gaps from identify_gaps, but in this example define them ourselves
gaps &lt;- data.frame(
  participant_id = "12345",
  from = as.POSIXct(c("2022-05-10 10:05:00", "2022-05-10 10:50:00")),
  to = as.POSIXct(c("2022-05-10 10:20:00", "2022-05-10 11:10:00"))
)

# Now add the gaps to the data
add_gaps(
  data = dat,
  gaps = gaps,
  by = "participant_id"
)

# You can use fill if you want to get rid of those pesky NA's
add_gaps(
  data = dat,
  gaps = gaps,
  by = "participant_id",
  fill = list(type = "GAP", confidence = 100)
)
</code></pre>

<hr>
<h2 id='alias_column_names'>Alias column names of a data frame containing sensor data</h2><span id='topic+alias_column_names'></span>

<h3>Description</h3>

<p>This function is used to remap the column names of a data frame containing sensor data to the
column names used in the database schema of mpathsenser. As the column names have already
changed several times over the year, we use these functions so we can easily add new aliases of
the existing columns. The function is generic and dispatches to the specific method for the
class of <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alias_column_names(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alias_column_names_+3A_data">data</code></td>
<td>
<p>A data frame for which the column names are remapped according to the specific method
for this data frame. As such, <code>data</code> should have a class attribute that corresponds to one of
the methods defined in this file.</p>
</td></tr>
<tr><td><code id="alias_column_names_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aliasing of the column names depends on the specific method, but column names are only changed
if they have an alias available. Otherwise, they are kept unchanged.
</p>


<h3>Value</h3>

<p>A data frame with the column names remapped according to the specific method for this
data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  id = 1:3,
  timestamp = as.POSIXct(c("2021-01-01 00:00:00", "2021-01-01 00:00:01", "2021-01-01 00:00:02")),
  xm = c(1, 2, 3),
  ym = c(4, 5, 6),
  zm = c(7, 8, 9)
)
class(x) &lt;- c("accelerometer", class(x))
mpathsenser:::alias_column_names(x)
</code></pre>

<hr>
<h2 id='app_category'>Find the category of an app on the Google Play Store</h2><span id='topic+app_category'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This function scrapes the Google Play Store by using <code>name</code> as the search term. From there
it selects the first result in the list and its corresponding category and package name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>app_category(name, num = 1, rate_limit = 5, exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="app_category_+3A_name">name</code></td>
<td>
<p>The name of the app to search for.</p>
</td></tr>
<tr><td><code id="app_category_+3A_num">num</code></td>
<td>
<p>Which result should be selected in the list of search results. Defaults to one.</p>
</td></tr>
<tr><td><code id="app_category_+3A_rate_limit">rate_limit</code></td>
<td>
<p>The time interval to keep between queries, in seconds. If the rate limit is too
low, the Google Play Store may reject further requests or even ban your entirely.</p>
</td></tr>
<tr><td><code id="app_category_+3A_exact">exact</code></td>
<td>
<p>In m-Path Sense, the app names of the AppUsage sensor are the last part of the app's
package names. When <code>exact</code>  is <code>TRUE</code>, the function guarantees that <code>name</code> is
exactly equal to the last part of the selected package from the search results. Note that when
<code>exact</code> is <code>TRUE</code>, it interacts with <code>num</code> in the sense that it no longer selects
the top search result but instead the top search result that matches the last part of the package
name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following fields:
</p>

<table>
<tr>
 <td style="text-align: left;">
package </td><td style="text-align: left;"> the package name that was selected from the Google Play search </td>
</tr>
<tr>
 <td style="text-align: left;">
genre   </td><td style="text-align: left;"> the corresponding genre of this package
</td>
</tr>

</table>



<h3>Warning</h3>

<p>Do not abuse this function or you will be banned by the Google Play Store. The minimum delay
between requests seems to be around 5 seconds, but this is untested. Also make sure not to do
batch lookups, as many subsequent requests will get you blocked as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app_category("whatsapp")

# Example of a generic app name where we can't find a specific app
app_category("weather") # Weather forecast channel

# Get OnePlus weather
app_category("net.oneplus.weather")
</code></pre>

<hr>
<h2 id='app_usage'>Get app usage per hour</h2><span id='topic+app_usage'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function extracts app usage per hour for either one or multiple participants. If multiple
days are selected, the app usage time is averaged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>app_usage(
  db,
  participant_id = NULL,
  start_date = NULL,
  end_date = NULL,
  by = c("Total", "Day", "Hour")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="app_usage_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="app_usage_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
<tr><td><code id="app_usage_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+first_date">first_date</a> to find the
date of the first entry for a participant.</p>
</td></tr>
<tr><td><code id="app_usage_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+last_date">last_date</a> to find the date of the
last entry for a participant.</p>
</td></tr>
<tr><td><code id="app_usage_+3A_by">by</code></td>
<td>
<p>Either 'Total', 'Hour', or 'Day' indicating how to summarise the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing a column 'app' and a column 'usage' for the hourly app usage.
</p>

<hr>
<h2 id='bin_data'>Create bins in variable time series</h2><span id='topic+bin_data'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>In time series with variable measurements, an often recurring task is calculating the total time
spent (i.e. the duration) in fixed bins, for example per hour or day. However, this may be
difficult when two subsequent measurements are in different bins or span over multiple bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_data(
  data,
  start_time,
  end_time,
  by = c("sec", "min", "hour", "day"),
  fixed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_data_+3A_data">data</code></td>
<td>
<p>A data frame or tibble containing the time series.</p>
</td></tr>
<tr><td><code id="bin_data_+3A_start_time">start_time</code></td>
<td>
<p>The column name of the start time of the interval, a POSIXt.</p>
</td></tr>
<tr><td><code id="bin_data_+3A_end_time">end_time</code></td>
<td>
<p>The column name of the end time of the interval, a POSIXt.</p>
</td></tr>
<tr><td><code id="bin_data_+3A_by">by</code></td>
<td>
<p>A binning specification.</p>
</td></tr>
<tr><td><code id="bin_data_+3A_fixed">fixed</code></td>
<td>
<p>Whether to create fixed bins. If <code>TRUE</code>, bins will be rounded to, for example,
whole hours or days (depending on <code>by</code>). If <code>FALSE</code>, bins will be created based on the
first timestamp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the group columns (if any), date, hour (if <code>by = "hour"</code>), and
the duration in seconds.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+link_gaps">link_gaps()</a></code> for linking gaps to data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

data &lt;- tibble(
  participant_id = 1,
  datetime = c(
    "2022-06-21 15:00:00", "2022-06-21 15:55:00",
    "2022-06-21 17:05:00", "2022-06-21 17:10:00"
  ),
  confidence = 100,
  type = "WALKING"
)

# get bins per hour, even if the interval is longer than one hour
data |&gt;
  mutate(datetime = as.POSIXct(datetime)) |&gt;
  mutate(lead = lead(datetime)) |&gt;
  bin_data(
    start_time = datetime,
    end_time = lead,
    by = "hour"
  )

# Alternatively, you can give an integer value to by to create custom-sized
# bins, but only if fixed = FALSE. Not that these bins are not rounded to,
# as in this example 30 minutes, but rather depends on the earliest time
# in the group.
data |&gt;
  mutate(datetime = as.POSIXct(datetime)) |&gt;
  mutate(lead = lead(datetime)) |&gt;
  bin_data(
    start_time = datetime,
    end_time = lead,
    by = 1800L,
    fixed = FALSE
  )

# More complicated data for showcasing grouping:
data &lt;- tibble(
  participant_id = 1,
  datetime = c(
    "2022-06-21 15:00:00", "2022-06-21 15:55:00",
    "2022-06-21 17:05:00", "2022-06-21 17:10:00"
  ),
  confidence = 100,
  type = c("STILL", "WALKING", "STILL", "WALKING")
)

# binned_intervals also takes into account the prior grouping structure
out &lt;- data |&gt;
  mutate(datetime = as.POSIXct(datetime)) |&gt;
  group_by(participant_id) |&gt;
  mutate(lead = lead(datetime)) |&gt;
  group_by(participant_id, type) |&gt;
  bin_data(
    start_time = datetime,
    end_time = lead,
    by = "hour"
  )
print(out)

# To get the duration for each bin (note to change the variable names in sum):
purrr::map_dbl(
  out$bin_data,
  ~ sum(as.double(.x$lead) - as.double(.x$datetime),
    na.rm = TRUE
  )
)

# Or:
out |&gt;
  tidyr::unnest(bin_data, keep_empty = TRUE) |&gt;
  mutate(duration = .data$lead - .data$datetime) |&gt;
  group_by(bin, .add = TRUE) |&gt;
  summarise(duration = sum(.data$duration, na.rm = TRUE), .groups = "drop")
</code></pre>

<hr>
<h2 id='ccopy'>Copy mpathsenser zip files to a new location</h2><span id='topic+ccopy'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Copy zip files from a source destination to an origin destination where they do not yet exist.
That is, it only updates the target folder from the source folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccopy(from, to, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccopy_+3A_from">from</code></td>
<td>
<p>A path to copy files from.</p>
</td></tr>
<tr><td><code id="ccopy_+3A_to">to</code></td>
<td>
<p>A path to copy files to.</p>
</td></tr>
<tr><td><code id="ccopy_+3A_recursive">recursive</code></td>
<td>
<p>Should files from subdirectories be copied?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A message indicating how many files were copied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ccopy("K:/data/myproject/", "~/myproject")

## End(Not run)
</code></pre>

<hr>
<h2 id='close_db'>Close a database connection</h2><span id='topic+close_db'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is a convenience function that is simply a wrapper around <code><a href="DBI.html#topic+dbDisconnect">DBI::dbDisconnect()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>close_db(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close_db_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly regardless of whether the database is active, valid,
or even exists.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+open_db">open_db()</a></code> for opening an mpathsenser database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First create a database in a temporary directory
db &lt;- create_db(tempdir(), "mydb.db")

# Then close it
close_db(db)

# You can even try to close a database that is already closed. This will not trigger an error.
close_db(db)

# Cleanup
file.remove(file.path(tempdir(), "mydb.db"))
</code></pre>

<hr>
<h2 id='copy_db'>Copy (a subset of) a database to another database</h2><span id='topic+copy_db'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_db(source_db, target_db, sensor = "All")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_db_+3A_source_db">source_db</code></td>
<td>
<p>A mpathsenser database connection from where the data will be transferred.</p>
</td></tr>
<tr><td><code id="copy_db_+3A_target_db">target_db</code></td>
<td>
<p>A mpathsenser database connection where the data will be transferred to.
<code><a href="#topic+create_db">create_db()</a></code> to create a new database.</p>
</td></tr>
<tr><td><code id="copy_db_+3A_sensor">sensor</code></td>
<td>
<p>A character vector containing one or multiple sensors. See
<code><a href="#topic+sensors">sensors</a></code> for a list of available sensors. Use &quot;All&quot; for all available
sensors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> invisibly, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First create two databases in a temporary directory
db1 &lt;- create_db(tempdir(), "mydb1.db")
db2 &lt;- create_db(tempdir(), "mydb2.db")

# Populate the first database with some data
DBI::dbExecute(db1, "INSERT INTO Study VALUES ('study_1', 'default')")
DBI::dbExecute(db1, "INSERT INTO Participant VALUES ('1', 'study_1')")
DBI::dbExecute(db1, "INSERT INTO Activity VALUES(
               '123', '1', '2024-01-01', '08:00:00', '100', 'WALKING')")

# Then copy the first database to the second database
copy_db(db1, db2)

# Check that the second database has the same data as the first database
get_data(db2, "Activity")

# Cleanup
close_db(db1)
close_db(db2)
file.remove(file.path(tempdir(), "mydb1.db"))
file.remove(file.path(tempdir(), "mydb2.db"))
</code></pre>

<hr>
<h2 id='coverage'>Create a coverage chart of the sampling rate</h2><span id='topic+coverage'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Only applicable to non-reactive sensors with 'continuous' sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage(
  db,
  participant_id,
  sensor = NULL,
  frequency = mpathsenser::freq,
  relative = TRUE,
  offset = "None",
  start_date = NULL,
  end_date = NULL,
  plot = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_+3A_db">db</code></td>
<td>
<p>A valid database connection. Schema must be that as it is created by
<a href="#topic+open_db">open_db</a>.</p>
</td></tr>
<tr><td><code id="coverage_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string of <em>one</em> participant ID.</p>
</td></tr>
<tr><td><code id="coverage_+3A_sensor">sensor</code></td>
<td>
<p>A character vector containing one or multiple sensors. See
<code><a href="#topic+sensors">sensors</a></code> for a list of available sensors. Use <code>NULL</code> for all
available sensors.</p>
</td></tr>
<tr><td><code id="coverage_+3A_frequency">frequency</code></td>
<td>
<p>A named numeric vector with sensors as names and the number of expected samples
per hour</p>
</td></tr>
<tr><td><code id="coverage_+3A_relative">relative</code></td>
<td>
<p>Show absolute number of measurements or relative to the expected number?
Logical value.</p>
</td></tr>
<tr><td><code id="coverage_+3A_offset">offset</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="coverage_+3A_start_date">start_date</code></td>
<td>
<p>A date (or convertible to a date using <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>) indicating
the earliest date to show. Leave empty for all data. Must be used with <code>end_date</code>.</p>
</td></tr>
<tr><td><code id="coverage_+3A_end_date">end_date</code></td>
<td>
<p>A date (or convertible to a date using <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>) indicating
the latest date to show.Leave empty for all data. Must be used with <code>start_date</code>.</p>
</td></tr>
<tr><td><code id="coverage_+3A_plot">plot</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Instead of built-in functionality, use
<code><a href="#topic+plot.coverage">plot.coverage()</a></code> to plot the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot of the coverage results if <code>plot</code> is <code>TRUE</code> or a tibble containing the
hour, type of measure (i.e. sensor), and (relative) coverage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
freq &lt;- c(
  Accelerometer = 720, # Once per 5 seconds. Can have multiple measurements.
  AirQuality = 1,
  AppUsage = 2, # Once every 30 minutes
  Bluetooth = 60, # Once per minute. Can have multiple measurements.
  Gyroscope = 720, # Once per 5 seconds. Can have multiple measurements.
  Light = 360, # Once per 10 seconds
  Location = 60, # Once per 60 seconds
  Memory = 60, # Once per minute
  Noise = 120,
  Pedometer = 1,
  Weather = 1,
  Wifi = 60 # once per minute
)

coverage(
  db = db,
  participant_id = "12345",
  sensor = c("Accelerometer", "Gyroscope"),
  frequency = mpathsenser::freq,
  start_date = "2021-01-01",
  end_date = "2021-05-01"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='create_db'>Create a new mpathsenser database</h2><span id='topic+create_db'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_db(path = getwd(), db_name = "sense.db", overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_db_+3A_path">path</code></td>
<td>
<p>The path to the database.</p>
</td></tr>
<tr><td><code id="create_db_+3A_db_name">db_name</code></td>
<td>
<p>The name of the database.</p>
</td></tr>
<tr><td><code id="create_db_+3A_overwrite">overwrite</code></td>
<td>
<p>In case a database with <code>db_name</code> already exists, indicate whether it should
be overwritten or not. Otherwise, this option is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A database connection using prepared database schemas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new database in a temporary directory
db &lt;- create_db(tempdir(), "mydb.db")

# You can also create an in-memory database
db2 &lt;- create_db(path = NULL, ":memory:")

# Cleanup
close_db(db)
close_db(db2)
file.remove(file.path(tempdir(), "mydb.db"))
</code></pre>

<hr>
<h2 id='decrypt_gps'>Decrypt GPS data from a curve25519 public key</h2><span id='topic+decrypt_gps'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>By default, the latitude and longitude of the GPS data collected by m-Path Sense are encrypted
using an asymmetric curve25519 key to provide extra protection for these highly sensitive data.
This function takes a character vector and decrypts its longitude and latitude columns using the
provided <code>key</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decrypt_gps(data, key, ignore = ":")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decrypt_gps_+3A_data">data</code></td>
<td>
<p>A character vector containing hexadecimal (i.e. encrypted) data.</p>
</td></tr>
<tr><td><code id="decrypt_gps_+3A_key">key</code></td>
<td>
<p>A curve25519 private key.</p>
</td></tr>
<tr><td><code id="decrypt_gps_+3A_ignore">ignore</code></td>
<td>
<p>A string with characters to ignore from <code>data</code>. See <code><a href="sodium.html#topic+helpers">sodium::hex2bin()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of doubles of the decrypted GPS coordinates.
</p>


<h3>Parallel</h3>

<p>This function supports parallel processing in the sense that it is able to
distribute it's computation load among multiple workers. To make use of this functionality, run
<a href="https://rdrr.io/cran/future/man/plan.html"><code>future::plan("multisession")</code></a> before
calling this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(sodium)
# Create some GPS  coordinates.
data &lt;- data.frame(
  participant_id = "12345",
  time = as.POSIXct(c(
    "2022-12-02 12:00:00",
    "2022-12-02 12:00:01",
    "2022-12-02 12:00:02"
  )),
  longitude = c("50.12345", "50.23456", "50.34567"),
  latitude = c("4.12345", "4.23456", "4.345678")
)

# Generate keypair
key &lt;- sodium::keygen()
pub &lt;- sodium::pubkey(key)

# Encrypt coordinates with pubkey
# You do not need to do this for m-Path Sense
# as this is already encrypted
encrypt &lt;- function(data, pub) {
  data &lt;- lapply(data, charToRaw)
  data &lt;- lapply(data, function(x) sodium::simple_encrypt(x, pub))
  data &lt;- lapply(data, sodium::bin2hex)
  data &lt;- unlist(data)
  data
}
data$longitude &lt;- encrypt(data$longitude, pub)
data$latitude &lt;- encrypt(data$latitude, pub)

# Once the data has been collected, decrypt it using decrypt_gps().
data |&gt;
  mutate(longitude = decrypt_gps(longitude, key)) |&gt;
  mutate(latitude = decrypt_gps(latitude, key))

</code></pre>

<hr>
<h2 id='device_info'>Get the device info for one or more participants</h2><span id='topic+device_info'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>device_info(db, participant_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="device_info_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="device_info_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing device info for each participant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open the database
db &lt;- open_db("path/to/db")

# Get device info for all participants
device_info(db)

# Get device info for a specific participant
device_info(db, participant_id = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='first_date'>Extract the date of the first entry</h2><span id='topic+first_date'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>A helper function for extracting the first date of entry of (of one or all participant) of one
sensor. Note that this function is specific to the first date of a sensor. After all, it
wouldn't make sense to extract the first date for a participant of the accelerometer, while the
first device measurement occurred a day later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_date(db, sensor, participant_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_date_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="first_date_+3A_sensor">sensor</code></td>
<td>
<p>The name of a sensor. See <a href="#topic+sensors">sensors</a> for a list of available
sensors.</p>
</td></tr>
<tr><td><code id="first_date_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string in the format 'YYYY-mm-dd' of the first entry date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
db &lt;- open_db()
first_date(db, "Accelerometer", "12345")

## End(Not run)
</code></pre>

<hr>
<h2 id='fix_jsons'>Fix the end of JSON files</h2><span id='topic+fix_jsons'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>When copying data directly coming from m-Path Sense, JSON files are sometimes corrupted due to
the app not properly closing them. This function attempts to fix the most common
problems associated with improper file closure by m-Path Sense.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_jsons(path = getwd(), files = NULL, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_jsons_+3A_path">path</code></td>
<td>
<p>The path name of the JSON files.</p>
</td></tr>
<tr><td><code id="fix_jsons_+3A_files">files</code></td>
<td>
<p>Alternatively, a character list of the input files</p>
</td></tr>
<tr><td><code id="fix_jsons_+3A_recursive">recursive</code></td>
<td>
<p>Should the listing recurse into directories?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two distinct problems this functions tries to tackle. First of all, there are often
bad file endings (e.g. no <code>]</code>) because the app was closed before it could properly close
the file. There are several cases that may be wrong (or even multiple), so it unclear what the
precise problems are. As this function is experimental, it may even make it worse by accidentally
inserting an incorrect file ending.
</p>
<p>Secondly, in rare scenarios there are illegal ASCII characters in the JSON files. Not often does
this happen, and it is likely because of an OS failure (such as a flush error), a disk failure,
or corrupted data during transmit. Nevertheless, these illegal characters make the file
completely unreadable. Fortunately, they are detected correctly by
<a href="#topic+test_jsons">test_jsons</a>, but they cannot be imported by <a href="#topic+import">import</a>. This
functions attempts to surgically remove lines with illegal characters, by removing that specific
line as well as the next line, as this is often a comma. It may therefore be too liberal in its
approach &ndash; cutting away more data than necessary &ndash; or not liberal enough when the corruption
has spread throughout multiple lines. Nevertheless, it is a first step in removing some
straightforward corruption from files so that only a small number may still need to be fixed by
hand.
</p>


<h3>Value</h3>

<p>A message indicating how many files were fixed, and the number of fixed files invisibly.
</p>


<h3>Parallel</h3>

<p>This function supports parallel processing in the sense that it is able to
distribute it's computation load among multiple workers. To make use of this functionality, run
<a href="https://rdrr.io/cran/future/man/plan.html"><code>future::plan("multisession")</code></a> before
calling this function.
</p>


<h3>Progress</h3>

<p>You can be updated of the progress of this function by using the
<code><a href="progressr.html#topic+progress">progressr::progress()</a></code> package. See <code>progressr</code>'s
<a href="https://cran.r-project.org/package=progressr/vignettes/progressr-intro.html">vignette</a> on
how to subscribe to these updates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
future::plan("multisession")
files &lt;- test_jsons()
fix_jsons(files = files)

## End(Not run)
</code></pre>

<hr>
<h2 id='freq'>Measurement frequencies per sensor</h2><span id='topic+freq'></span>

<h3>Description</h3>

<p>A numeric vector containing (an example) of example measurement frequencies per sensor.
Such input is needed for <code><a href="#topic+coverage">coverage()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 11.
</p>


<h3>Value</h3>

<p>This vector contains the following
information:</p>

<table>
<tr>
 <td style="text-align: left;">
   Sensor </td><td style="text-align: left;"> Frequency (per hour) </td><td style="text-align: left;"> Full text </td>
</tr>
<tr>
 <td style="text-align: left;">
   Accelerometer </td><td style="text-align: left;"> 720 </td><td style="text-align: left;"> Once per 5 seconds. Can have multiple instances. </td>
</tr>
<tr>
 <td style="text-align: left;">
   AirQuality </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> Once per hour. </td>
</tr>
<tr>
 <td style="text-align: left;">
   AppUsage </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> Once every 30 minutes. Can have multiple instances. </td>
</tr>
<tr>
 <td style="text-align: left;">
   Bluetooth </td><td style="text-align: left;"> 12 </td><td style="text-align: left;"> Once every 5 minutes. Can have multiple instances. </td>
</tr>
<tr>
 <td style="text-align: left;">
   Gyroscope </td><td style="text-align: left;"> 720 </td><td style="text-align: left;"> Once per 5 seconds. Can have multiple instances. </td>
</tr>
<tr>
 <td style="text-align: left;">
   Light </td><td style="text-align: left;"> 360 </td><td style="text-align: left;"> Once per 10 seconds. </td>
</tr>
<tr>
 <td style="text-align: left;">
   Location </td><td style="text-align: left;"> 60 </td><td style="text-align: left;"> Once every 60 seconds. </td>
</tr>
<tr>
 <td style="text-align: left;">
   Memory </td><td style="text-align: left;"> 60 </td><td style="text-align: left;"> Once per minute </td>
</tr>
<tr>
 <td style="text-align: left;">
   Noise </td><td style="text-align: left;"> 120 </td><td style="text-align: left;"> Once every 30 seconds. Microphone cannot be used in the background in Android 11. </td>
</tr>
<tr>
 <td style="text-align: left;">
   Weather </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> Once per hour. </td>
</tr>
<tr>
 <td style="text-align: left;">
   Wifi </td><td style="text-align: left;"> 60 </td><td style="text-align: left;"> Once per minute. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>freq
</code></pre>

<hr>
<h2 id='geocode_rev'>Reverse geocoding with latitude and longitude</h2><span id='topic+geocode_rev'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This functions allows you to extract information about a place based on the latitude and
longitude from the OpenStreetMaps nominatim API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocode_rev(lat, lon, zoom = 18, email = "", rate_limit = 1, format = "jsonv2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geocode_rev_+3A_lat">lat</code></td>
<td>
<p>The latitude of the location (in degrees)</p>
</td></tr>
<tr><td><code id="geocode_rev_+3A_lon">lon</code></td>
<td>
<p>The longitude of the location (in degrees)</p>
</td></tr>
<tr><td><code id="geocode_rev_+3A_zoom">zoom</code></td>
<td>
<p>The desired zoom level from 1-18. The lowest level, 18, is building level.</p>
</td></tr>
<tr><td><code id="geocode_rev_+3A_email">email</code></td>
<td>
<p>If you are making large numbers of request please include an appropriate email
address to identify your requests. See Nominatim's Usage Policy for more details.</p>
</td></tr>
<tr><td><code id="geocode_rev_+3A_rate_limit">rate_limit</code></td>
<td>
<p>The time interval to keep between queries, in seconds. If the rate limit is too
low, OpenStreetMaps may reject further requests or even ban your entirely.</p>
</td></tr>
<tr><td><code id="geocode_rev_+3A_format">format</code></td>
<td>
<p>The format of the response. Either &quot;jsonv2&quot;, &quot;geojson&quot;, or&quot;geocodejson&quot;. See
Nomatims documentation for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of information about the location. See <a href="https://nominatim.org/release-docs/develop/api/Reverse/#example-with-formatjsonv2">Nominatim's documentation</a>
for more details. The response may also be an error message in case of API errors, or <code>NA</code> if
the client or API is offline.
</p>


<h3>Warning</h3>

<p>Do not abuse this function or you will be banned by OpenStreetMap. The maximum
number of requests is around 1 per second. Also make sure not to do too many batch lookups, as
many subsequent requests will get you blocked as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Frankfurt Airport
geocode_rev(50.037936, 8.5599631)
</code></pre>

<hr>
<h2 id='get_data'>Extract data from an m-Path Sense database</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is a convenience function to help extract data from an m-Path sense database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(db, sensor, participant_id = NULL, start_date = NULL, end_date = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="get_data_+3A_sensor">sensor</code></td>
<td>
<p>The name of a sensor. See <a href="#topic+sensors">sensors</a> for a list of available
sensors.</p>
</td></tr>
<tr><td><code id="get_data_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
<tr><td><code id="get_data_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+first_date">first_date</a> to find the
date of the first entry for a participant.</p>
</td></tr>
<tr><td><code id="get_data_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+last_date">last_date</a> to find the date of the
last entry for a participant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function returns a lazy (also called remote) <code>tibble</code>. This means that
the data is not actually in R until you call a function that pulls the data from the database.
This is useful for various functions in this package that work with a lazy tibble, for example
<code><a href="#topic+identify_gaps">identify_gaps()</a></code>. You may manually want to modify this lazy <code>tibble</code> by using <code>dplyr</code>
functions such as <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> or <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> before pulling the data into R. These
functions will be executed in-database, and will therefore be much faster than having to first
pull all data into R and then possibly removing a large part of it. Importantly, data can
pulled into R using <code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code>.
</p>


<h3>Value</h3>

<p>A lazy <code><a href="dplyr.html#topic+tbl">tbl</a></code> containing the requested data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a database
db &lt;- open_db()

# Retrieve some data
get_data(db, "Accelerometer", "12345")

# Or within a specific window
get_data(db, "Accelerometer", "12345", "2021-01-01", "2021-01-05")

## End(Not run)

</code></pre>

<hr>
<h2 id='get_nrows'>Get the number of rows per sensor in a mpathsenser database</h2><span id='topic+get_nrows'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nrows(
  db,
  sensor = "All",
  participant_id = NULL,
  start_date = NULL,
  end_date = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nrows_+3A_db">db</code></td>
<td>
<p>db A database connection, as created by <code><a href="#topic+create_db">create_db()</a></code>.</p>
</td></tr>
<tr><td><code id="get_nrows_+3A_sensor">sensor</code></td>
<td>
<p>A character vector of one or multiple vectors. Use <code>sensor = "All"</code> for all
sensors. See <a href="#topic+sensors">sensors</a> for a list of all available sensors.</p>
</td></tr>
<tr><td><code id="get_nrows_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants()</a></code> to retrieve all participants from the database. Leave empty to get data
for all participants.</p>
</td></tr>
<tr><td><code id="get_nrows_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>. Use <code><a href="#topic+first_date">first_date()</a></code> to find the date of the first
entry for a participant.</p>
</td></tr>
<tr><td><code id="get_nrows_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>. Use <code><a href="#topic+last_date">last_date()</a></code> to find the date of the last entry for a
participant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector containing the number of rows for each sensor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a database connection
db &lt;- open_db("path/to/db")

# Get the number of rows for all sensors
get_nrows(db, sensor = NULL)

# Get the number of rows for the Accelerometer and Gyroscope sensors
get_nrows(db, c("Accelerometer", "Gyroscope"))

# Remember to close the connection
close_db(db)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_participants'>Get all participants</h2><span id='topic+get_participants'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_participants(db, lazy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_participants_+3A_db">db</code></td>
<td>
<p>db A database connection, as created by <code><a href="#topic+create_db">create_db()</a></code>.</p>
</td></tr>
<tr><td><code id="get_participants_+3A_lazy">lazy</code></td>
<td>
<p>Whether to evaluate lazily using <a href="dbplyr.html#topic+dbplyr">dbplyr</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing all <code>participant_id</code> and <code>study_id</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a database
db &lt;- create_db(tempdir(), "mydb.db")

# Add some participants
DBI::dbExecute(db, "INSERT INTO Study VALUES('study1', 'data_format1')")
DBI::dbExecute(db, "INSERT INTO Participant VALUES('participant1', 'study1')")

# Get the participants
get_participants(db)

# Cleanup
close_db(db)
file.remove(file.path(tempdir(), "mydb.db"))
</code></pre>

<hr>
<h2 id='get_processed_files'>Get all processed files from a database</h2><span id='topic+get_processed_files'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_processed_files(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_processed_files_+3A_db">db</code></td>
<td>
<p>A database connection, as created by <code><a href="#topic+create_db">create_db()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the <code>file_name</code>, <code>participant_id</code>, and <code>study_id</code> of the
processed files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a database
db &lt;- create_db(tempdir(), "mydb.db")

# Add some processed files
DBI::dbExecute(db, "INSERT INTO Study VALUES('study1', 'data_format1')")
DBI::dbExecute(db, "INSERT INTO Participant VALUES('participant1', 'study1')")
DBI::dbExecute(db, "INSERT INTO ProcessedFiles VALUES('file1', 'participant1', 'study1')")

# Get the processed files
get_processed_files(db)

# Cleanup
close_db(db)
file.remove(file.path(tempdir(), "mydb.db"))
</code></pre>

<hr>
<h2 id='get_studies'>Get all studies</h2><span id='topic+get_studies'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_studies(db, lazy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_studies_+3A_db">db</code></td>
<td>
<p>db A database connection, as created by <code><a href="#topic+create_db">create_db()</a></code>.</p>
</td></tr>
<tr><td><code id="get_studies_+3A_lazy">lazy</code></td>
<td>
<p>Whether to evaluate lazily using <a href="dbplyr.html#topic+dbplyr">dbplyr</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing all studies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a database
db &lt;- create_db(tempdir(), "mydb.db")

# Add some studies
DBI::dbExecute(db, "INSERT INTO Study VALUES('study1', 'data_format1')")

# Get the studies
get_studies(db)

# Cleanup
close_db(db)
file.remove(file.path(tempdir(), "mydb.db"))
</code></pre>

<hr>
<h2 id='haversine'>Calculate the Great-Circle Distance between two points in kilometers</h2><span id='topic+haversine'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Calculate the great-circle distance between two points using the Haversine function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haversine(lat1, lon1, lat2, lon2, r = 6371)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haversine_+3A_lat1">lat1</code></td>
<td>
<p>The latitude of point 1 in degrees.</p>
</td></tr>
<tr><td><code id="haversine_+3A_lon1">lon1</code></td>
<td>
<p>The longitude of point 1 in degrees.</p>
</td></tr>
<tr><td><code id="haversine_+3A_lat2">lat2</code></td>
<td>
<p>The latitude of point 2 in degrees.</p>
</td></tr>
<tr><td><code id="haversine_+3A_lon2">lon2</code></td>
<td>
<p>The longitude of point 2 in degrees.</p>
</td></tr>
<tr><td><code id="haversine_+3A_r">r</code></td>
<td>
<p>The average earth radius.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of the distance between point 1 and 2 in kilometers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fra &lt;- c(50.03333, 8.570556) # Frankfurt Airport
ord &lt;- c(41.97861, -87.90472) # Chicago O'Hare International Airport
haversine(fra[1], fra[2], ord[1], ord[2]) # 6971.059 km
</code></pre>

<hr>
<h2 id='identify_gaps'>Identify gaps in mpathsenser mobile sensing data</h2><span id='topic+identify_gaps'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Oftentimes in mobile sensing, gaps appear in the data as a result of the participant
accidentally closing the app or the operating system killing the app to save power. This can
lead to issues later on during data analysis when it becomes unclear whether there are no
measurements because no events occurred or because the app quit in that period. For example, if
no screen on/off event occur in a 6-hour period, it can either mean the participant did not
turn on their phone in that period or that the app simply quit and potential events were
missed. In the latter case, the 6-hour missing period has to be compensated by either removing
this interval altogether or by subtracting the gap from the interval itself (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_gaps(
  db,
  participant_id = NULL,
  min_gap = 60,
  sensor = "Accelerometer"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_gaps_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="identify_gaps_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
<tr><td><code id="identify_gaps_+3A_min_gap">min_gap</code></td>
<td>
<p>The minimum time (in seconds) passed between two subsequent measurements for it to
be considered a gap.</p>
</td></tr>
<tr><td><code id="identify_gaps_+3A_sensor">sensor</code></td>
<td>
<p>One or multiple sensors. See <a href="#topic+sensors">sensors</a> for a list of available
sensors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While any sensor can be used for identifying gaps, it is best to choose a sensor with a
very high, near-continuous sample rate such as the accelerometer or gyroscope. This function
then creates time between two subsequent measurements and returns the period in which this time
was larger than <code>min_gap</code>.
</p>
<p>Note that the <code>from</code> and <code>to</code> columns in the output are character vectors in UTC
time.
</p>


<h3>Value</h3>

<p>A tibble containing the time period of the gaps. The structure of this tibble is as
follows:
</p>

<table>
<tr>
 <td style="text-align: left;"> participant_id </td><td style="text-align: left;"> the <code>participant_id</code> of where the gap occurred </td>
</tr>
<tr>
 <td style="text-align: left;"> from
</td><td style="text-align: left;"> the time of the last measurement before the gap </td>
</tr>
<tr>
 <td style="text-align: left;"> to             </td><td style="text-align: left;"> the time of the
first measurement after the gap </td>
</tr>
<tr>
 <td style="text-align: left;"> gap            </td><td style="text-align: left;"> the time passed between from and to, in
seconds </td>
</tr>

</table>



<h3>Warning</h3>

<p>Depending on the sensor that is used to identify the gaps (though this is
typically the highest frequency sensor, such as the accelerometer or gyroscope), there may be a
small delay between the start of the gap and the <em>actual</em> start of the gap. For example, if the
accelerometer samples every 5 seconds, it may be after 4.99 seconds after the last
accelerometer measurement (so just before the next measurement), the app was killed. However,
within that time other measurements may still have taken place, thereby technically occurring
&quot;within&quot; the gap. This is especially important if you want to use these gaps in
<code><a href="#topic+add_gaps">add_gaps</a></code> since this issue may lead to erroneous results.
</p>
<p>An easy way to solve this problem is by taking into account all the sensors of interest when
identifying the gaps, thereby ensuring there are no measurements of these sensors within the
gap. One way to account for this is to (as in this example) search for gaps 5 seconds longer
than you want and then afterwards increasing the start time of the gaps by 5 seconds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Find the gaps for a participant and convert to datetime
gaps &lt;- identify_gaps(db, "12345", min_gap = 60) |&gt;
  mutate(across(c(to, from), ymd_hms)) |&gt;
  mutate(across(c(to, from), with_tz, "Europe/Brussels"))

# Get some sensor data and calculate a statistic, e.g. the time spent walking
# You can also do this with larger intervals, e.g. the time spent walking per hour
walking_time &lt;- get_data(db, "Activity", "12345") |&gt;
  collect() |&gt;
  mutate(datetime = ymd_hms(paste(date, time))) |&gt;
  mutate(datetime = with_tz(datetime, "Europe/Brussels")) |&gt;
  arrange(datetime) |&gt;
  mutate(prev_time = lag(datetime)) |&gt;
  mutate(duration = datetime - prev_time) |&gt;
  filter(type == "WALKING")

# Find out if a gap occurs in the time intervals
walking_time |&gt;
  rowwise() |&gt;
  mutate(gap = any(gaps$from &gt;= prev_time &amp; gaps$to &lt;= datetime))

## End(Not run)
</code></pre>

<hr>
<h2 id='import'>Import m-Path Sense files into a database</h2><span id='topic+import'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Import JSON files from m-Path Sense into a structured database. This function is the bread and
butter of this package, as it populates the database with data that most of the other functions
in this package use. It is recommend to first run <code><a href="#topic+test_jsons">test_jsons()</a></code> and, if necessary,
<code><a href="#topic+fix_jsons">fix_jsons()</a></code> to repair JSON files with problematic syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import(
  path = getwd(),
  db,
  sensors = NULL,
  batch_size = 24,
  backend = "RSQLite",
  recursive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_+3A_path">path</code></td>
<td>
<p>The path to the file directory</p>
</td></tr>
<tr><td><code id="import_+3A_db">db</code></td>
<td>
<p>Valid database connection, typically created by <code><a href="#topic+create_db">create_db()</a></code>.</p>
</td></tr>
<tr><td><code id="import_+3A_sensors">sensors</code></td>
<td>
<p>Select one or multiple sensors as in <code><a href="#topic+sensors">sensors</a></code>. Leave
NULL to extract all sensor data.</p>
</td></tr>
<tr><td><code id="import_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of files that are to be processed in a single batch.</p>
</td></tr>
<tr><td><code id="import_+3A_backend">backend</code></td>
<td>
<p>Name of the database backend that is used. Currently, only RSQLite is supported.</p>
</td></tr>
<tr><td><code id="import_+3A_recursive">recursive</code></td>
<td>
<p>Should the listing recurse into directories?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>import</code> allows you to specify which sensors to import (even though there may be more in
the files) and it also allows batching for a speedier writing process. If processing in
parallel is active, it is recommended that <code>batch_size</code> be a scalar multiple of the number of
CPU cores the parallel cluster can use. If a single JSON file in the batch causes and error,
the batch is terminated (but not the function) and it is up to the user to fix the file. This
means that if <code>batch_size</code> is large, many files will not be processed. Set <code>batch_size</code> to 1
for sequential (one-by-one) file processing.
</p>
<p>Currently, only SQLite is supported as a backend. Due to its concurrency restriction, parallel
processing works for cleaning the raw data, but not for importing it into the database. This is
because SQLite does not allow multiple processes to write to the same database at the same
time. This is a limitation of SQLite and not of this package. However, while files are
processing individually (and in parallel if specified), writing to the database happens for the
entire batch specified by <code>batch_size</code> at once. This means that if a single file in the batch
causes an error, the entire batch is skipped. This is to ensure that the database is not left
in an inconsistent state.
</p>


<h3>Value</h3>

<p>A message indicating how many files were imported. If all files were imported
successfully, this functions returns an empty string invisibly. Otherwise the file names of the
files that were not imported are returned visibly.
</p>


<h3>Parallel</h3>

<p>This function supports parallel processing in the sense that it is able to
distribute it's computation load among multiple workers. To make use of this functionality, run
<a href="https://rdrr.io/cran/future/man/plan.html"><code>future::plan("multisession")</code></a> before
calling this function.
</p>


<h3>Progress</h3>

<p>You can be updated of the progress of this function by using the
<code><a href="progressr.html#topic+progress">progressr::progress()</a></code> package. See <code>progressr</code>'s
<a href="https://cran.r-project.org/package=progressr/vignettes/progressr-intro.html">vignette</a> on
how to subscribe to these updates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_db">create_db()</a></code> for creating a database for <code>import()</code> to use, <code><a href="#topic+close_db">close_db()</a></code> for closing
this database; <code><a href="#topic+index_db">index_db()</a></code> to create indices on the database for faster future processing, and
<code><a href="#topic+vacuum_db">vacuum_db()</a></code> to shrink the database to its minimal size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- "some/path"
# Create a database
db &lt;- create_db(path = path, db_name = "my_db")

# Import all JSON files in the current directory
import(path = path, db = db)

# Import all JSON files in the current directory, but do so sequentially
import(path = path, db = db, batch_size = 1)

# Import all JSON files in the current directory, but only the accelerometer data
import(path = path, db = db, sensors = "accelerometer")

# Import all JSON files in the current directory, but only the accelerometer and gyroscope data
import(path = path, db = db, sensors = c("accelerometer", "gyroscope"))

# Remember to close the database
close_db(db)

## End(Not run)

</code></pre>

<hr>
<h2 id='index_db'>Create indexes for an mpathsenser database</h2><span id='topic+index_db'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Create indexes for an mpathsenser database on the <code>participant_id</code>, <code>date</code>, and a combination
of these variable for all the tables in the database. This will speed up queries that use these
variables in the <code>WHERE</code> clause.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_db(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_db_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> invisibly, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# First create a database in a temporary directory
db &lt;- create_db(tempdir(), "mydb.db")

# Import some files
import(path = "path/to/jsons", db = db)

# Then index it to speed up the database
index_db(db)

## End(Not run)
</code></pre>

<hr>
<h2 id='installed_apps'>Get installed apps</h2><span id='topic+installed_apps'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Extract installed apps for one or all participants. Contrarily to other get_* functions in
this package, start and end dates are not used since installed apps are assumed to be fixed
throughout the study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installed_apps(db, participant_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="installed_apps_+3A_db">db</code></td>
<td>
<p>A database connection to an mpathsenser database.</p>
</td></tr>
<tr><td><code id="installed_apps_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing app names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
db &lt;- open_db()

# Get installed apps for all participants
installed_apps(db)

# Get installed apps for a single participant
installed_apps(db, "12345")

## End(Not run)
</code></pre>

<hr>
<h2 id='last_date'>Extract the date of the last entry</h2><span id='topic+last_date'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>A helper function for extracting the last date of entry of (of one or all participant) of one
sensor. Note that this function is specific to the last date of a sensor. After all, it
wouldn't make sense to extract the last date for a participant of the device info, while the
last accelerometer measurement occurred a day later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_date(db, sensor, participant_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_date_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="last_date_+3A_sensor">sensor</code></td>
<td>
<p>The name of a sensor. See <a href="#topic+sensors">sensors</a> for a list of available
sensors.</p>
</td></tr>
<tr><td><code id="last_date_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string in the format 'YYYY-mm-dd' of the last entry date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
db &lt;- open_db()
first_date(db, "Accelerometer", "12345")

## End(Not run)
</code></pre>

<hr>
<h2 id='link'>Link y to the time scale of x</h2><span id='topic+link'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>One of the key tasks in analysing mobile sensing data is being able to link it to other data.
For example, when analysing physical activity data, it could be of interest to know how much
time a participant spent exercising before or after an ESM beep to evaluate their stress level.
<code><a href="#topic+link">link()</a></code> allows you to map two data frames to each other that are on different time scales,
based on a pre-specified offset before and/or after. This function assumes that both <code>x</code> and
<code>y</code> have a column called <code>time</code> containing <a href="base.html#topic+DateTimeClasses">DateTimeClasses</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link(
  x,
  y,
  by = NULL,
  time,
  end_time = NULL,
  y_time,
  offset_before = 0,
  offset_after = 0,
  add_before = FALSE,
  add_after = FALSE,
  name = "data",
  split = by
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_+3A_x">x</code>, <code id="link_+3A_y">y</code></td>
<td>
<p>A pair of data frames or data frame extensions (e.g. a tibble). Both <code>x</code> and <code>y</code> must
have a column called <code>time</code>.</p>
</td></tr>
<tr><td><code id="link_+3A_by">by</code></td>
<td>
<p>A character vector indicating the variable(s) to match by, typically the participant
IDs. If NULL, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all variables in
common across <code>x</code> and <code>y</code>. Therefore, all data will be mapped to each other based on the time
stamps of <code>x</code> and <code>y</code>. A message lists the variables so that you can check they're correct;
suppress the message by supplying by explicitly.
</p>
<p>To join by different variables on <code>x</code> and <code>y</code>, use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a vector with <code>length &gt; 1</code>. For example, <code>by = c('a', 'b')</code>
will match <code>x$a</code> to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. Use a named vector to match different variables
in <code>x</code> and <code>y</code>. For example, <code>by = c('a' = 'b', 'c' = 'd')</code> will match <code>x$a</code> to <code>y$b</code> and <code>x$c</code>
to <code>y$d</code>.
</p>
<p>To perform a cross-join (when <code>x</code> and <code>y</code> have no variables in common), use <code>by = character()</code>.
Note that the <code>split</code> argument will then be set to 1.</p>
</td></tr>
<tr><td><code id="link_+3A_time">time</code></td>
<td>
<p>The name of the column containing the timestamps in <code>x</code>.</p>
</td></tr>
<tr><td><code id="link_+3A_end_time">end_time</code></td>
<td>
<p>Optionally, the name of the column containing the end time in <code>x</code>. If specified,
it means <code>time</code> defines the start time of the interval and <code>end_time</code> the end time. Note that
this cannot be used at the same time as <code>offset_before</code> or <code>offset_after</code>.</p>
</td></tr>
<tr><td><code id="link_+3A_y_time">y_time</code></td>
<td>
<p>The name of the column containing the timestamps in <code>y</code>.</p>
</td></tr>
<tr><td><code id="link_+3A_offset_before">offset_before</code></td>
<td>
<p>The time before each measurement in <code>x</code> that denotes the period in which <code>y</code>
is matched. Must be convertible to a period by <code><a href="lubridate.html#topic+as.period">lubridate::as.period()</a></code>.</p>
</td></tr>
<tr><td><code id="link_+3A_offset_after">offset_after</code></td>
<td>
<p>The time after each measurement in <code>x</code> that denotes the period in which <code>y</code>
is matched. Must be convertible to a period by <code><a href="lubridate.html#topic+as.period">lubridate::as.period()</a></code>.</p>
</td></tr>
<tr><td><code id="link_+3A_add_before">add_before</code></td>
<td>
<p>Logical value. Do you want to add the last measurement before the start of each
interval?</p>
</td></tr>
<tr><td><code id="link_+3A_add_after">add_after</code></td>
<td>
<p>Logical value. Do you want to add the first measurement after the end of each
interval?</p>
</td></tr>
<tr><td><code id="link_+3A_name">name</code></td>
<td>
<p>The name of the column containing the nested <code>y</code> data.</p>
</td></tr>
<tr><td><code id="link_+3A_split">split</code></td>
<td>
<p>An optional grouping variable to split the computation by. When working with large
data sets, the computation can grow so large it no longer fits in your computer's working
memory (after which it will probably fall back on the swap file, which is very slow). Splitting
the computation trades some computational efficiency for a large decrease in RAM usage. This
argument defaults to <code>by</code> to automatically suppress some of its RAM usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y</code> is matched to the time scale of <code>x</code> by means of time windows. These time windows are
defined as the period between <code>x - offset_before</code> and <code>x + offset_after</code>. Note that either
<code>offset_before</code> or <code>offset_after</code> can be 0, but not both. The &quot;interval&quot; of the measurements is
therefore the associated time window for each measurement of <code>x</code> and the data of <code>y</code> that also
falls within this period. For example, an <code>offset_before</code>  of
<code><a href="lubridate.html#topic+minutes">minutes</a>(30)</code> means to match all data of <code>y</code> that occurred <em>before</em> each
measurement in <code>x</code>. An <code>offset_after</code> of 900 (i.e. 15 minutes) means to match all data of <code>y</code>
that occurred <em>after</em> each measurement in <code>x</code>. When both <code>offset_before</code> and <code>offset_after</code> are
specified, it means all data of <code>y</code> is matched in an interval of 30 minutes before and 15
minutes after each measurement of <code>x</code>, thus combining the two arguments.
</p>
<p>The arguments <code>add_before</code> and <code>add_after</code> let you decide whether you want to add the last
measurement before the interval and/or the first measurement after the interval respectively.
This could be useful when you want to know which type of event occurred right before or after
the interval of the measurement. For example, at <code>offset_before = "30 minutes"</code>, the data may
indicate that a participant was running 20 minutes before a measurement in <code>x</code>, However, with
just that information there is no way of knowing what the participant was doing the first 10
minutes of the interval. The same principle applies to after the interval. When <code>add_before</code> is
set to <code>TRUE</code>, the last measurement of <code>y</code> occurring before the interval of <code>x</code> is added to the
output data as the first row, having the <strong><code>time</code> of <code>x - offset_before</code></strong> (i.e. the start
of the interval). When <code>add_after</code> is set to <code>TRUE</code>, the first measurement of <code>y</code> occurring
after the interval of <code>x</code> is added to the output data as the last row, having the <strong><code>time</code> of
<code>x + offset_after</code></strong> (i.e. the end of the interval). This way, it is easier to calculate the
difference to other measurements of <code>y</code> later (within the same interval). Additionally, an
extra column (<code>original_time</code>) is added in the nested <code>data</code> column, which is the original time
of the <code>y</code> measurement and <code>NULL</code> for every other observation. This may be useful to check if
the added measurement isn't too distant (in time) from the others. Note that multiple rows may
be added if there were multiple measurements in <code>y</code> at exactly the same time. Also, if there
already is a row with a timestamp exactly equal to the start of the interval (for <code>add_before = TRUE</code>) or to the end of the interval <code style="white-space: pre;">&#8288;(add_after = TRUE&#8288;</code>), no extra row is added.
</p>


<h3>Value</h3>

<p>A tibble with the data of <code>x</code> with a new column <code>data</code> with the matched data of <code>y</code>
according to <code>offset_before</code> and <code>offset_after</code>.
</p>


<h3>Warning</h3>

<p>Note that setting <code>add_before</code> and <code>add_after</code> each add one row to each nested
<code>tibble</code> of the <code>data</code> column. Thus, if you are only interested in the total count (e.g.
the number of total screen changes), remember to set these arguments to FALSE or make sure to
filter out rows that do <em>not</em> have an <code>original_time</code>. Simply subtracting 1 or 2 does not work
as not all measurements in <code>x</code> may have a measurement in <code>y</code> before or after (and thus no row
is added).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define some data
x &lt;- data.frame(
  time = rep(seq.POSIXt(as.POSIXct("2021-11-14 13:00:00"), by = "1 hour", length.out = 3), 2),
  participant_id = c(rep("12345", 3), rep("23456", 3)),
  item_one = rep(c(40, 50, 60), 2)
)

# Define some data that we want to link to x
y &lt;- data.frame(
  time = rep(seq.POSIXt(as.POSIXct("2021-11-14 12:50:00"), by = "5 min", length.out = 30), 2),
  participant_id = c(rep("12345", 30), rep("23456", 30)),
  x = rep(1:30, 2)
)

# Now link y within 30 minutes before each row in x
# until the measurement itself:
link(
  x = x,
  y = y,
  by = "participant_id",
  time = time,
  y_time = time,
  offset_before = "30 minutes"
)

# We can also link y to a period both before and after
# each measurement in x.
# Also note that time, end_time and y_time accept both
# quoted names as well as character names.
link(
  x = x,
  y = y,
  by = "participant_id",
  time = "time",
  y_time = "time",
  offset_before = "15 minutes",
  offset_after = "15 minutes"
)

# It can be important to also know the measurements
# just preceding the interval or just after the interval.
# This adds an extra column called 'original_time' in the
# nested data, containing the original time stamp. The
# actual timestamp is set to the start time of the interval.
link(
  x = x,
  y = y,
  by = "participant_id",
  time = time,
  y_time = time,
  offset_before = "15 minutes",
  offset_after = "15 minutes",
  add_before = TRUE,
  add_after = TRUE
)

# If you participant_id is not important to you
# (i.e. the measurements are interchangeable),
# you can ignore them by leaving by empty.
# However, in this case we'll receive a warning
# since x and y have no other columns in common
# (except time, of course). Thus, we can perform
# a cross-join:
link(
  x = x,
  y = y,
  by = character(),
  time = time,
  y_time = time,
  offset_before = "30 minutes"
)

# Alternatively, we can specify custom intervals.
# That is, we can create variable intervals
# without using fixed offsets.
x &lt;- data.frame(
  start_time = rep(
    x = as.POSIXct(c(
      "2021-11-14 12:40:00",
      "2021-11-14 13:30:00",
      "2021-11-14 15:00:00"
    )),
    times = 2
  ),
  end_time = rep(
    x = as.POSIXct(c(
      "2021-11-14 13:20:00",
      "2021-11-14 14:10:00",
      "2021-11-14 15:30:00"
    )),
    times = 2
  ),
  participant_id = c(rep("12345", 3), rep("23456", 3)),
  item_one = rep(c(40, 50, 60), 2)
)
link(
  x = x,
  y = y,
  by = "participant_id",
  time = start_time,
  end_time = end_time,
  y_time = time,
  add_before = TRUE,
  add_after = TRUE
)
</code></pre>

<hr>
<h2 id='link_db'>Link two sensors OR one sensor and an external data frame using an mpathsenser database</h2><span id='topic+link_db'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function is specific to mpathsenser databases. It is a wrapper around <code><a href="#topic+link">link()</a></code> but
extracts data in the database for you. It is now soft deprecated as I feel this function's use
is limited in comparison to <code><a href="#topic+link">link()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_db(
  db,
  sensor_one,
  sensor_two = NULL,
  external = NULL,
  external_time = "time",
  offset_before = 0,
  offset_after = 0,
  add_before = FALSE,
  add_after = FALSE,
  participant_id = NULL,
  start_date = NULL,
  end_date = NULL,
  reverse = FALSE,
  ignore_large = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_db_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="link_db_+3A_sensor_one">sensor_one</code></td>
<td>
<p>The name of a primary sensor. See <a href="#topic+sensors">sensors</a> for a list of
available sensors.</p>
</td></tr>
<tr><td><code id="link_db_+3A_sensor_two">sensor_two</code></td>
<td>
<p>The name of a secondary sensor. See <a href="#topic+sensors">sensors</a> for a list of
available sensors. Cannot be used together with <code>external</code>.</p>
</td></tr>
<tr><td><code id="link_db_+3A_external">external</code></td>
<td>
<p>Optionally, specify an external data frame. Cannot be used at the same time as a
second sensor. This data frame must have a column called <code>time</code>.</p>
</td></tr>
<tr><td><code id="link_db_+3A_external_time">external_time</code></td>
<td>
<p>The name of the column containing the timestamps in <code>external</code>.</p>
</td></tr>
<tr><td><code id="link_db_+3A_offset_before">offset_before</code></td>
<td>
<p>The time before each measurement in <code>x</code> that denotes the period in which <code>y</code>
is matched. Must be convertible to a period by <code><a href="lubridate.html#topic+as.period">lubridate::as.period()</a></code>.</p>
</td></tr>
<tr><td><code id="link_db_+3A_offset_after">offset_after</code></td>
<td>
<p>The time after each measurement in <code>x</code> that denotes the period in which <code>y</code>
is matched. Must be convertible to a period by <code><a href="lubridate.html#topic+as.period">lubridate::as.period()</a></code>.</p>
</td></tr>
<tr><td><code id="link_db_+3A_add_before">add_before</code></td>
<td>
<p>Logical value. Do you want to add the last measurement before the start of each
interval?</p>
</td></tr>
<tr><td><code id="link_db_+3A_add_after">add_after</code></td>
<td>
<p>Logical value. Do you want to add the first measurement after the end of each
interval?</p>
</td></tr>
<tr><td><code id="link_db_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
<tr><td><code id="link_db_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+first_date">first_date</a> to find the
date of the first entry for a participant.</p>
</td></tr>
<tr><td><code id="link_db_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+last_date">last_date</a> to find the date of the
last entry for a participant.</p>
</td></tr>
<tr><td><code id="link_db_+3A_reverse">reverse</code></td>
<td>
<p>Switch <code>sensor_one</code> with either <code>sensor_two</code> or <code>external</code>? Particularly useful in
combination with <code>external</code>.</p>
</td></tr>
<tr><td><code id="link_db_+3A_ignore_large">ignore_large</code></td>
<td>
<p>Safety override to prevent long wait times. Set to <code>TRUE</code> to do this function
on lots of data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the data of <code>sensor_one</code> with a new column <code>data</code> with the matched data of
either <code>sensor_two</code> or <code>external</code> according to <code>offset_before</code> or <code>offset_after</code>. The other way
around when <code>reverse = TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+link">link()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a database
db &lt;- open_db("path/to/db")

# Link two sensors
link_db(db, "accelerometer", "gyroscope", offset_before = 300, offset_after = 300)

# Link a sensor with an external data frame
link_db(db, "accelerometer",
  external = my_external_data,
  external_time = "time", offset_before = 300, offset_after = 300
)

## End(Not run)
</code></pre>

<hr>
<h2 id='link_gaps'>Link gaps to (ESM) data</h2><span id='topic+link_gaps'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Gaps in mobile sensing data typically occur when the app is stopped by the operating system or
the user. While small gaps may not pose problems with analyses, greater gaps may cause bias or
skew your data. As a result, gap data should be considered in order to inspect and limit their
influence. This function, analogous to <code><a href="#topic+link">link()</a></code>, allows you to connect gaps to other data
(usually ESM/EMA data) within a user-specified time range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_gaps(
  data,
  gaps,
  by = NULL,
  offset_before = 0,
  offset_after = 0,
  raw_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_gaps_+3A_data">data</code></td>
<td>
<p>A data frame or an extension to a data frame (e.g. a tibble). While gap data can be
linked to any other type of data, ESM data is most commonly used.</p>
</td></tr>
<tr><td><code id="link_gaps_+3A_gaps">gaps</code></td>
<td>
<p>A data frame (extension) containing the gap data. See <code><a href="#topic+identify_gaps">identify_gaps()</a></code> for
retrieving gap data from an mpathsenser database. It should at least contain the columns <code>from</code>
and <code>to</code> (both in a date-time format), as well as any specified columns in <code>by</code>.</p>
</td></tr>
<tr><td><code id="link_gaps_+3A_by">by</code></td>
<td>
<p>A character vector indicating the variable(s) to match by, typically the participant
IDs. If NULL, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all variables in
common across <code>x</code> and <code>y</code>. Therefore, all data will be mapped to each other based on the time
stamps of <code>x</code> and <code>y</code>. A message lists the variables so that you can check they're correct;
suppress the message by supplying by explicitly.
</p>
<p>To join by different variables on <code>x</code> and <code>y</code>, use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a vector with <code>length &gt; 1</code>. For example, <code>by = c('a', 'b')</code>
will match <code>x$a</code> to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. Use a named vector to match different variables
in <code>x</code> and <code>y</code>. For example, <code>by = c('a' = 'b', 'c' = 'd')</code> will match <code>x$a</code> to <code>y$b</code> and <code>x$c</code>
to <code>y$d</code>.
</p>
<p>To perform a cross-join (when <code>x</code> and <code>y</code> have no variables in common), use <code>by = character()</code>.
Note that the <code>split</code> argument will then be set to 1.</p>
</td></tr>
<tr><td><code id="link_gaps_+3A_offset_before">offset_before</code></td>
<td>
<p>The time before each measurement in <code>x</code> that denotes the period in which <code>y</code>
is matched. Must be convertible to a period by <code><a href="lubridate.html#topic+as.period">lubridate::as.period()</a></code>.</p>
</td></tr>
<tr><td><code id="link_gaps_+3A_offset_after">offset_after</code></td>
<td>
<p>The time after each measurement in <code>x</code> that denotes the period in which <code>y</code>
is matched. Must be convertible to a period by <code><a href="lubridate.html#topic+as.period">lubridate::as.period()</a></code>.</p>
</td></tr>
<tr><td><code id="link_gaps_+3A_raw_data">raw_data</code></td>
<td>
<p>Whether to include the raw data (i.e. the matched gap data) to the output as
gap_data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>data</code> with an extra column <code>duration</code> indicating the gap during within the
interval in seconds (if <code>duration</code>  is <code>TRUE</code>), or an extra column called <code>gap_data</code> containing
the gaps within the interval. The function ensures all durations and gap time stamps are within
the range of the interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bin_data">bin_data()</a></code> for linking two sets of intervals to each other; <code><a href="#topic+identify_gaps">identify_gaps()</a></code> for
finding gaps in the sampling; <code><a href="#topic+add_gaps">add_gaps()</a></code> for adding gaps to sensor data;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some data
x &lt;- data.frame(
  time = rep(seq.POSIXt(as.POSIXct("2021-11-14 13:00:00"), by = "1 hour", length.out = 3), 2),
  participant_id = c(rep("12345", 3), rep("23456", 3)),
  item_one = rep(c(40, 50, 60), 2)
)

# Create some gaps
gaps &lt;- data.frame(
  from = as.POSIXct(c("2021-11-14 13:00:00", "2021-11-14 14:00:00")),
  to = as.POSIXct(c("2021-11-14 13:30:00", "2021-11-14 14:30:00")),
  participant_id = c("12345", "23456")
)

# Link the gaps to the data
link_gaps(x, gaps, by = "participant_id", offset_before = 0, offset_after = 1800)

# Link the gaps to the data and include the raw data
link_gaps(
  x,
  gaps,
  by = "participant_id",
  offset_before = 0,
  offset_after = 1800,
  raw_data = TRUE
)
</code></pre>

<hr>
<h2 id='moving_average'>Moving average for values in an mpathsenser database</h2><span id='topic+moving_average'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moving_average(
  db,
  sensor,
  cols,
  n,
  participant_id = NULL,
  start_date = NULL,
  end_date = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moving_average_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="moving_average_+3A_sensor">sensor</code></td>
<td>
<p>The name of a sensor. See <a href="#topic+sensors">sensors</a> for a list of available
sensors.</p>
</td></tr>
<tr><td><code id="moving_average_+3A_cols">cols</code></td>
<td>
<p>Character vectors of the columns in the <code>sensor</code> table to average over.</p>
</td></tr>
<tr><td><code id="moving_average_+3A_n">n</code></td>
<td>
<p>The number of seconds to average over. The index of the result will be centered compared
to the rolling window of observations.</p>
</td></tr>
<tr><td><code id="moving_average_+3A_participant_id">participant_id</code></td>
<td>
<p>A character vector identifying one or multiple participants.</p>
</td></tr>
<tr><td><code id="moving_average_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+first_date">first_date</a> to find the
date of the first entry for a participant.</p>
</td></tr>
<tr><td><code id="moving_average_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+last_date">last_date</a> to find the date of the
last entry for a participant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the same columns as the input, modified to be a moving average.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path &lt;- system.file("testdata", "test.db", package = "mpathsenser")
db &lt;- open_db(NULL, path)
moving_average(
  db = db,
  sensor = "Light",
  cols = c("mean_lux", "max_lux"),
  n = 5, # seconds
  participant_id = "12345"
)
close_db(db)

## End(Not run)
</code></pre>

<hr>
<h2 id='mpathsenser-package'>mpathsenser: Process and Analyse Data from m-Path Sense</h2><span id='topic+mpathsenser'></span><span id='topic+mpathsenser-package'></span>

<h3>Description</h3>

<p>Overcomes one of the major challenges in mobile (passive) sensing, namely
being able to pre-process the raw data that comes from a mobile sensing app,
specifically &quot;m-Path Sense&quot; <a href="https://m-path.io">https://m-path.io</a>. The main task of 'mpathsenser' is
therefore to read &quot;m-Path Sense&quot; JSON files into a database and provide several
convenience functions to aid in data processing.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Koen Niemeijer <a href="mailto:koen.niemeijer@kuleuven.be">koen.niemeijer@kuleuven.be</a> (<a href="https://orcid.org/0000-0002-0816-534X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Kristof Meers <a href="mailto:kristof.meers@kuleuven.be">kristof.meers@kuleuven.be</a> (<a href="https://orcid.org/0000-0002-9610-7712">ORCID</a>) [contributor]
</p>
</li>
<li><p> KU Leuven [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gitlab.kuleuven.be/ppw-okpiv/researchers/u0134047/mpathsenser/">https://gitlab.kuleuven.be/ppw-okpiv/researchers/u0134047/mpathsenser/</a>
</p>
</li>
<li> <p><a href="https://ppw-okpiv.pages.gitlab.kuleuven.be/researchers/u0134047/mpathsenser/">https://ppw-okpiv.pages.gitlab.kuleuven.be/researchers/u0134047/mpathsenser/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.kuleuven.be/ppw-okpiv/researchers/u0134047/mpathsenser/-/issues/">https://gitlab.kuleuven.be/ppw-okpiv/researchers/u0134047/mpathsenser/-/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='n_screen_on'>Get number of times screen turned on</h2><span id='topic+n_screen_on'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_screen_on(
  db,
  participant_id,
  start_date = NULL,
  end_date = NULL,
  by = c("Total", "Hour", "Day")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_screen_on_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="n_screen_on_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
<tr><td><code id="n_screen_on_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+first_date">first_date</a> to find the
date of the first entry for a participant.</p>
</td></tr>
<tr><td><code id="n_screen_on_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+last_date">last_date</a> to find the date of the
last entry for a participant.</p>
</td></tr>
<tr><td><code id="n_screen_on_+3A_by">by</code></td>
<td>
<p>Either 'Total', 'Hour', or 'Day' indicating how to summarise the results. Defaults to
total.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case grouping is by the total amount, returns a single numeric value. For date and
hour grouping returns a tibble with columns 'date' or 'hour' and the number of screen on's 'n'.
</p>

<hr>
<h2 id='n_screen_unlocks'>Get number of screen unlocks</h2><span id='topic+n_screen_unlocks'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_screen_unlocks(
  db,
  participant_id,
  start_date = NULL,
  end_date = NULL,
  by = c("Total", "Hour", "Day")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_screen_unlocks_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="n_screen_unlocks_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
<tr><td><code id="n_screen_unlocks_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+first_date">first_date</a> to find the
date of the first entry for a participant.</p>
</td></tr>
<tr><td><code id="n_screen_unlocks_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+last_date">last_date</a> to find the date of the
last entry for a participant.</p>
</td></tr>
<tr><td><code id="n_screen_unlocks_+3A_by">by</code></td>
<td>
<p>Either 'Total', 'Hour', or 'Day' indicating how to summarise the results. Defaults to
total.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case grouping is by the total amount, returns a single numeric value. For date and
hour grouping returns a tibble with columns 'date' or 'hour' and the number of screen unlocks
'n'.
</p>

<hr>
<h2 id='open_db'>Open an mpathsenser database.</h2><span id='topic+open_db'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>open_db(path = getwd(), db_name = "sense.db")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="open_db_+3A_path">path</code></td>
<td>
<p>The path to the database. Use NULL to use the full path name in db_name.</p>
</td></tr>
<tr><td><code id="open_db_+3A_db_name">db_name</code></td>
<td>
<p>The name of the database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A connection to an mpathsenser database.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+close_db">close_db()</a></code> for closing a database; <code><a href="#topic+copy_db">copy_db()</a></code> for copying (part of) a database;
<code><a href="#topic+index_db">index_db()</a></code> for indexing a database; <code><a href="#topic+get_data">get_data()</a></code> for extracting data from a database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First create a database in a temporary directory
db &lt;- create_db(tempdir(), "mydb.db")
close_db(db)
DBI::dbIsValid(db) # db is closed

# Then re-open it
db2 &lt;- open_db(tempdir(), "mydb.db")
DBI::dbIsValid(db2) # db is opened

# Cleanup
close_db(db2)
file.remove(file.path(tempdir(), "mydb.db"))
</code></pre>

<hr>
<h2 id='plot.coverage'>Plot a coverage overview</h2><span id='topic+plot.coverage'></span>

<h3>Description</h3>

<p>Plot a coverage overview
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coverage'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.coverage_+3A_x">x</code></td>
<td>
<p>A tibble with the coverage data coming from <code><a href="#topic+coverage">coverage()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.coverage_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coverage">coverage()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
freq &lt;- c(
  Accelerometer = 720, # Once per 5 seconds. Can have multiple measurements.
  AirQuality = 1,
  AppUsage = 2, # Once every 30 minutes
  Bluetooth = 60, # Once per minute. Can have multiple measurements.
  Gyroscope = 720, # Once per 5 seconds. Can have multiple measurements.
  Light = 360, # Once per 10 seconds
  Location = 60, # Once per 60 seconds
  Memory = 60, # Once per minute
  Noise = 120,
  Pedometer = 1,
  Weather = 1,
  Wifi = 60 # once per minute
)

data &lt;- coverage(
  db = db,
  participant_id = "12345",
  sensor = c("Accelerometer", "Gyroscope"),
  frequency = mpathsenser::freq,
  start_date = "2021-01-01",
  end_date = "2021-05-01"
)

plot(data)

## End(Not run)
</code></pre>

<hr>
<h2 id='screen_duration'>Screen duration by hour or day</h2><span id='topic+screen_duration'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Calculate the screen duration time where the screen was <em>unlocked</em> (i.e. not just on).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screen_duration(
  db,
  participant_id,
  start_date = NULL,
  end_date = NULL,
  by = c("Hour", "Day")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screen_duration_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="screen_duration_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
<tr><td><code id="screen_duration_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+first_date">first_date</a> to find the
date of the first entry for a participant.</p>
</td></tr>
<tr><td><code id="screen_duration_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+last_date">last_date</a> to find the date of the
last entry for a participant.</p>
</td></tr>
<tr><td><code id="screen_duration_+3A_by">by</code></td>
<td>
<p>Either 'Hour' or 'Day' indicating how to summarise the results. Leave empty to get raw
screen duration per measurement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with either 'hour' and 'duration' columns or 'date' and 'duration' columns
depending on the <code>by</code> argument. Alternatively, if no <code>by</code> is specified, a remote
tibble is returned with the date, time, and duration since the previous measurement.
</p>

<hr>
<h2 id='sensors'>Available Sensors</h2><span id='topic+sensors'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>A list containing all available sensors in this package you can work with. This variable was
created so it is easier to use in your own functions, e.g. to loop over sensors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 27.
</p>


<h3>Value</h3>

<p>A character vector containing all sensor names supported by <code>mpathsenser</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sensors
</code></pre>

<hr>
<h2 id='step_count'>Get step count</h2><span id='topic+step_count'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Extracts the number of steps per hour as sensed by the underlying operating system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_count(db, participant_id = NULL, start_date = NULL, end_date = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_count_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
<tr><td><code id="step_count_+3A_participant_id">participant_id</code></td>
<td>
<p>A character string identifying a single participant. Use
<code><a href="#topic+get_participants">get_participants</a></code> to retrieve all participants from the database.
Leave empty to get data for all participants.</p>
</td></tr>
<tr><td><code id="step_count_+3A_start_date">start_date</code></td>
<td>
<p>Optional search window specifying date where to begin search. Must be
convertible to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+first_date">first_date</a> to find the
date of the first entry for a participant.</p>
</td></tr>
<tr><td><code id="step_count_+3A_end_date">end_date</code></td>
<td>
<p>Optional search window specifying date where to end search. Must be convertible
to date using <a href="base.html#topic+as.Date">as.Date</a>. Use <a href="#topic+last_date">last_date</a> to find the date of the
last entry for a participant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the 'date', 'hour', and the number of 'steps'.
</p>

<hr>
<h2 id='test_jsons'>Test JSON files for being in the correct format.</h2><span id='topic+test_jsons'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_jsons(path = getwd(), files = NULL, db = NULL, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_jsons_+3A_path">path</code></td>
<td>
<p>The path name of the JSON files.</p>
</td></tr>
<tr><td><code id="test_jsons_+3A_files">files</code></td>
<td>
<p>Alternatively, a character list of the input files.</p>
</td></tr>
<tr><td><code id="test_jsons_+3A_db">db</code></td>
<td>
<p>A mpathsenser database connection (optional). If provided, will be used to check which
files are already in the database and check only those JSON files which are not.</p>
</td></tr>
<tr><td><code id="test_jsons_+3A_recursive">recursive</code></td>
<td>
<p>Should the listing recurse into directories?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A message indicating whether there were any issues and a character vector of the file
names that need to be fixed. If there were no issues, an invisible empty string is returned.
</p>


<h3>Parallel</h3>

<p>This function supports parallel processing in the sense that it is able to
distribute it's computation load among multiple workers. To make use of this functionality, run
<a href="https://rdrr.io/cran/future/man/plan.html"><code>future::plan("multisession")</code></a> before
calling this function.
</p>


<h3>Progress</h3>

<p>You can be updated of the progress of this function by using the
<code><a href="progressr.html#topic+progress">progressr::progress()</a></code> package. See <code>progressr</code>'s
<a href="https://cran.r-project.org/package=progressr/vignettes/progressr-intro.html">vignette</a> on
how to subscribe to these updates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Test all files in a directory
test_jsons(path = "path/to/jsons", recursive = FALSE)

# Test all files in a directory and its subdirectories
test_jsons(path = "path/to/jsons", recursive = TRUE)

# Test specific files
test_jsons(files = c("file1.json", "file2.json"))

# Test files in a directory, but skip those that are already in the database
test_jsons(path = "path/to/jsons", db = db)

## End(Not run)
</code></pre>

<hr>
<h2 id='unpack_sensor_data'>Unpack raw sensor data</h2><span id='topic+unpack_sensor_data'></span>

<h3>Description</h3>

<p>This function takes raw sensor data coming from <code><a href="#topic+import">import()</a></code> and unpacks it into tidy data frames
so that it can be written to the database. Note that this function is internal and should not
be used for other purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_sensor_data(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_sensor_data_+3A_data">data</code></td>
<td>
<p>A data frame containing the raw sensor data.</p>
</td></tr>
<tr><td><code id="unpack_sensor_data_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the sensor data unpacked.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tibble(
  study_id = "test-study",
  participant_id = "12345",
  data_format = "cams 1.0.0",
  start_time = "2021-11-14 16:40:00.123456",
  end_time = NULL,
  sensor = "Activity",
  data = list(list(
    confidence = 80,
    type = "WALKING"
  ))
)
class(x) &lt;- c("activity", class(x))
mpathsenser:::unpack_sensor_data(x)
</code></pre>

<hr>
<h2 id='unzip_data'>Unzip m-Path Sense output</h2><span id='topic+unzip_data'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Similar to <a href="utils.html#topic+unzip">unzip</a>, but makes it easier to unzip all files in a given path with one
function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unzip_data(path = getwd(), to = NULL, overwrite = FALSE, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unzip_data_+3A_path">path</code></td>
<td>
<p>The path to the directory containing the zip files.</p>
</td></tr>
<tr><td><code id="unzip_data_+3A_to">to</code></td>
<td>
<p>The output path.</p>
</td></tr>
<tr><td><code id="unzip_data_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical value whether you want to overwrite already existing zip files.</p>
</td></tr>
<tr><td><code id="unzip_data_+3A_recursive">recursive</code></td>
<td>
<p>Logical value indicating whether to unzip files in subdirectories as well. These
files will then be unzipped in their respective subdirectory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A message indicating how many files were unzipped.
</p>


<h3>Parallel</h3>

<p>This function supports parallel processing in the sense that it is able to
distribute it's computation load among multiple workers. To make use of this functionality, run
<a href="https://rdrr.io/cran/future/man/plan.html"><code>future::plan("multisession")</code></a> before
calling this function.
</p>


<h3>Progress</h3>

<p>You can be updated of the progress of this function by using the
<code><a href="progressr.html#topic+progress">progressr::progress()</a></code> package. See <code>progressr</code>'s
<a href="https://cran.r-project.org/package=progressr/vignettes/progressr-intro.html">vignette</a> on
how to subscribe to these updates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Unzip all files in a directory
unzip_data(path = "path/to/zipfiles", to = "path/to/unzipped", recursive = FALSE)

# Unzip all files in a directory and its subdirectories
unzip_data(path = "path/to/zipfiles", to = "path/to/unzipped", recursive = TRUE)

# Unzip specific files
unzip_data(
  path = "path/to/zipfiles",
  to = "path/to/unzipped",
  files = c("file1.zip", "file2.zip")
)

# Unzip files in a directory, but skip those that are already unzipped
unzip_data(path = "path/to/zipfiles", to = "path/to/unzipped", overwrite = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='vacuum_db'>Vacuum a database</h2><span id='topic+vacuum_db'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is a convenience function that calls the <code>VACUUM</code> command on a database. This command will
rebuild the database file, repacking it into a minimal amount of disk space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vacuum_db(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vacuum_db_+3A_db">db</code></td>
<td>
<p>A database connection to an m-Path Sense database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar numeric that specifies the number of rows affected by the vacuum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a database in a temporary directory
db &lt;- create_db(tempdir(), "mydb.db")

# Assuming that we have imported some data into the database, we can vacuum it
vacuum_db(db)

# Cleanup
close_db(db)
file.remove(file.path(tempdir(), "mydb.db"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
