<!DOCTYPE html><html lang="en"><head><title>Help for package limSolve</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {limSolve}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#limSolve-package'>
<p>Solving Linear Inverse Models</p></a></li>
<li><a href='#Blending'>
<p>A linear inverse blending problem</p></a></li>
<li><a href='#Chemtax'>
<p>An overdetermined linear inverse problem: estimating algal composition</p>
based on pigment biomarkers.</a></li>
<li><a href='#E_coli'>
<p>An underdetermined linear inverse problem: the Escherichia Coli</p>
Core Metabolism Model.</a></li>
<li><a href='#ldei'>
<p>Weighted Least Distance Programming with equality and inequality constraints.</p></a></li>
<li><a href='#ldp'>
<p>Least Distance Programming</p></a></li>
<li><a href='#linp'>
<p>Linear Programming.</p></a></li>
<li><a href='#lsei'>
<p>Least Squares with Equalities and Inequalities</p></a></li>
<li><a href='#Minkdiet'>
<p>An underdetermined linear inverse problem: estimating diet composition of</p>
Southeast Alaskan Mink.</a></li>
<li><a href='#nnls'>
<p>Nonnegative Least Squares</p></a></li>
<li><a href='#resolution'>
<p>Row and column resolution of a matrix.</p></a></li>
<li><a href='#RigaWeb'>
<p>An underdetermined linear inverse problem: the Gulf of Riga *spring*</p>
planktonic food web</a></li>
<li><a href='#Solve'>
<p>Generalised inverse solution of Ax = B</p></a></li>
<li><a href='#Solve.banded'>
<p>Solution of a banded system of linear equations</p></a></li>
<li><a href='#Solve.block'>
<p>Solution of an almost block diagonal system of linear equations</p></a></li>
<li><a href='#Solve.tridiag'>
<p>Solution of a tridiagonal system of linear equations</p></a></li>
<li><a href='#varranges'>
<p>Calculates ranges of inverse variables in a linear inverse problem</p></a></li>
<li><a href='#varsample'>
<p>Samples the probability density function of variables of linear inverse problems.</p></a></li>
<li><a href='#xranges'>
<p>Calculates ranges of the unknowns of a linear inverse problem</p></a></li>
<li><a href='#xsample'>
<p>Randomly samples an underdetermined problem with linear equality and</p>
inequality constraints</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.5.7.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Solving Linear Inverse Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Karline Soetaert [aut, cre],
  Karel Van den Meersche [aut],
  Dick van Oevelen [aut],
  Charles L. Lawson [ctb] (file inverse.f),
  Richard J. Hanson [ctb] (file inverse.f),
  Jack Dongarra [ctb] (files solve.f, inverse.f),
  Cleve Moler [ctb] (file solve.f)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>quadprog, lpSolve, MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions that (1) find the minimum/maximum of a linear or quadratic function:
  min or max (f(x)), where f(x) = ||Ax-b||^2 or f(x) = sum(a_i*x_i)
  subject to equality constraints Ex=f and/or inequality constraints Gx&gt;=h,
  (2) sample an underdetermined- or overdetermined system Ex=f subject to Gx&gt;=h, and if applicable Ax~=b,      
  (3) solve a linear system Ax=B for the unknown x. It includes banded and tridiagonal linear systems. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>inst/COPYRIGHTS</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 13:17:44 UTC; karlines</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='limSolve-package'>
Solving Linear Inverse Models
</h2><span id='topic+limSolve-package'></span><span id='topic+limSolve'></span>

<h3>Description</h3>

<p>Functions that:
</p>
<p>(1.) Find the minimum/maximum of a linear or quadratic function:
min or max (f(x)), where <code class="reqn">f(x) = ||Ax-b||^2</code> or <code class="reqn">f(x) = sum(ai*xi)</code>
subject to equality constraints <code class="reqn">Ex=f</code> and/or inequality constraints
<code class="reqn">Gx&gt;=h</code>.
</p>
<p>(2.) Sample an underdetermined- or overdetermined system <code class="reqn">Ex=f</code>
subject to <code class="reqn">Gx&gt;=h</code>, and if applicable <code class="reqn">Ax~=b</code>.
</p>
<p>(3.) Solve a linear system <code class="reqn">Ax=B</code> for the unknown x.
Includes banded and tridiagonal linear systems.
</p>
<p>The package calls Fortran functions from LINPACK
</p>


<h3>Details</h3>

<p>limSolve is designed for solving linear inverse models (LIM).
</p>
<p>These consist of linear equality and, or inequality conditions,
which can be solved either by least squares or by linear programming
techniques.
</p>
<p>Amongst the possible applications are: food web quantification,
flux balance analysis (e.g. metabolic networks),
compositional estimation, and operations research problems.
</p>
<p>The package contains several examples to exemplify its use
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert (Maintainer),
</p>
<p>Karel Van den Meersche
</p>
<p>Dick van Oevelen
</p>


<h3>References</h3>

<p>Van den Meersche K, Soetaert K, Van Oevelen D (2009). xsample(): An R Function for
Sampling Linear Inverse Problems.
Journal of Statistical Software, Code Snippets, 30(1), 1-15.
</p>
<p><a href="https://www.jstatsoft.org/v30/c01/">https://www.jstatsoft.org/v30/c01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Blending">Blending</a></code>, <code><a href="#topic+Chemtax">Chemtax</a></code>, <code><a href="#topic+RigaWeb">RigaWeb</a></code>,
<code><a href="#topic+E_coli">E_coli</a></code>, <code><a href="#topic+Minkdiet">Minkdiet</a></code> the examples.
</p>
<p><code><a href="#topic+ldei">ldei</a></code>, <code><a href="#topic+lsei">lsei</a></code>,<code><a href="#topic+linp">linp</a></code>, <code><a href="#topic+ldp">ldp</a></code>,
<code><a href="#topic+nnls">nnls</a></code> to solve LIM
</p>
<p><code><a href="#topic+xranges">xranges</a></code>, <code><a href="#topic+varranges">varranges</a></code>  to estimate ranges of
unknowns and variables
</p>
<p><code><a href="#topic+xsample">xsample</a></code>, <code><a href="#topic+varsample">varsample</a></code> to create a random sample
of unknowns and variables
</p>
<p><code><a href="#topic+Solve">Solve</a></code>, <code><a href="#topic+Solve.banded">Solve.banded</a></code>, <code><a href="#topic+Solve.tridiag">Solve.tridiag</a></code>,
to solve non-square, banded and tridiagonal linear systems of equations.
</p>
<p><code><a href="#topic+resolution">resolution</a></code> row and column resolution of a matrix
</p>
<p>package vignette <code>limSolve</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## show examples (see respective help pages for details)
example(Blending)
example(Chemtax)
example(E_coli)
example(Minkdiet)

## run demos
demo("limSolve")

## open the directory with original E_coli input file
browseURL(paste(system.file(package="limSolve"), "/doc", sep=""))

## show package vignette with tutorial about xsample
vignette("xsample")

## show main package vignette
vignette("limSolve")

## End(Not run)
</code></pre>

<hr>
<h2 id='Blending'>
A linear inverse blending problem
</h2><span id='topic+Blending'></span>

<h3>Description</h3>

<p>A manufacturer produces a feeding mix for pet animals.
</p>
<p>The feed mix contains two nutritive ingredients and one ingredient (filler)
to provide bulk.
</p>
<p>One kg of feed mix must contain a minimum quantity of each of four nutrients
as below:
</p>

<table>
<tr>
 <td style="text-align: right;">
     </td><td style="text-align: left;"> Nutrient  </td><td style="text-align: left;"> A  </td><td style="text-align: left;"> B  </td><td style="text-align: left;"> C  </td><td style="text-align: left;"> D </td>
</tr>
<tr>
 <td style="text-align: right;">
     </td><td style="text-align: left;"> gram      </td><td style="text-align: left;"> 80 </td><td style="text-align: left;"> 50 </td><td style="text-align: left;"> 25 </td><td style="text-align: left;"> 5 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>The ingredients have the following nutrient values and cost
</p>

<table>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;">  (gram/kg)    </td><td style="text-align: left;"> A   </td><td style="text-align: left;">   B </td><td style="text-align: left;"> C  </td><td style="text-align: left;"> D    </td><td style="text-align: left;"> Cost/kg </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> Ingredient 1  </td><td style="text-align: left;"> 100 </td><td style="text-align: left;">  50 </td><td style="text-align: left;"> 40 </td><td style="text-align: left;"> 10   </td><td style="text-align: left;"> 40  </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> Ingredient 2  </td><td style="text-align: left;"> 200 </td><td style="text-align: left;"> 150 </td><td style="text-align: left;"> 10 </td><td style="text-align: left;">  -   </td><td style="text-align: left;"> 60  </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> Filler        </td><td style="text-align: left;"> -   </td><td style="text-align: left;"> -   </td><td style="text-align: left;"> -  </td><td style="text-align: left;">  -   </td><td style="text-align: left;"> 0   </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>The problem is to find the composition of the feeding mix that minimises
the production costs subject to the constraints above.
</p>
<p>Stated otherwise: what is the optimal amount of ingredients in one kg of
feeding mix?
</p>
<p>Mathematically this can be estimated by solving a linear programming problem:
</p>
<p style="text-align: center;"><code class="reqn">\min(\sum {Cost_i*x_i})</code>
</p>
<p> subject to
</p>
<p style="text-align: center;"><code class="reqn">x_i&gt;=0</code>
</p>

<p style="text-align: center;"><code class="reqn">Ex=f</code>
</p>

<p style="text-align: center;"><code class="reqn">Gx&gt;=h</code>
</p>

<p>Where the <code>Cost</code> (to be minimised) is given by:
</p>
<p style="text-align: center;"><code class="reqn">x_1*40+x_2*60</code>
</p>

<p>The <code>equality</code> ensures that the sum of the three fractions equals 1:
</p>
<p style="text-align: center;"><code class="reqn">1 = x_1+x_2+x_3</code>
</p>

<p>And the <code>inequalities</code> enforce the nutritional constraints:
</p>
<p style="text-align: center;"><code class="reqn">100*x_1+200*x_2&gt;80</code>
</p>

<p style="text-align: center;"><code class="reqn">50*x_1+150*x_2&gt;50</code>
</p>

<p>and so on
</p>
<p>The solution is Ingredient1 (x1) = 0.5909, Ingredient2 (x2)=0.1364 and
Filler (x3)=0.2727.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Blending</code></pre>


<h3>Format</h3>

<p>A list with matrix <code>G</code> and vector <code>H</code> that contain the inequality
conditions and with vector <code>Cost</code>, defining the cost function.
</p>
<p>Columnnames of <code>G</code> or names of <code>Cost</code> are the names of the
ingredients, rownames of <code>G</code> and names of <code>H</code> are the nutrients.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linp">linp</a></code> to solve a linear programming problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate the equality condition (sum of ingredients = 1)
E &lt;- rep(1, 3)
F &lt;- 1

G &lt;- Blending$G
H &lt;- Blending$H

# add positivity requirement
G &lt;- rbind(G, diag(3))
H &lt;- c(H, rep(0, 3))

# 1. Solve the model with linear programming
res &lt;- linp(E = t(E), F = F, G = G, H = H, Cost = Blending$Cost)


# show results
print(c(res$X, Cost = res$solutionNorm))

dotchart(x = as.vector(res$X), labels = colnames(G),
         main = "Optimal blending with ranges",
         sub = "using linp and xranges", pch = 16, 
         xlim = c(0, 1))

# 2. Possible ranges of the three ingredients
(xr &lt;- xranges(E, F, G, H))
segments(xr[,1], 1:ncol(G), xr[,2], 1:ncol(G))
legend ("topright", pch = c(16, NA), lty = c(NA, 1),
        legend = c("Minimal cost", "range"))

# 3. Random sample of the three ingredients
# The inequality that all x &gt; 0 has to be added!
xs &lt;- xsample(E = E, F = F, G = G, H = H)$X

pairs(xs, main = "Blending, 3000 solutions with xsample")

# Cost associated to these random samples
Costs &lt;- as.vector(varsample(xs, EqA = Blending$Cost))
hist(Costs)
legend("topright", c("Optimal solution",
       format(res$solutionNorm, digits = 3)))
</code></pre>

<hr>
<h2 id='Chemtax'>
An overdetermined linear inverse problem: estimating algal composition
based on pigment biomarkers.
</h2><span id='topic+Chemtax'></span>

<h3>Description</h3>

<p>Input files for assessing the algal composition of a field sample,
based on the pigment composition of the algal groups (measured in the
laboratory) and the pigment composition of the field sample.
</p>
<p>In the example there are 8 types of <b>algae</b>:
</p>

<ul>
<li><p> Prasinophytes
</p>
</li>
<li><p> Dinoflagellates
</p>
</li>
<li><p> Cryptophytes
</p>
</li>
<li><p> Haptophytes type 3 (Hapto3s)
</p>
</li>
<li><p> Haptophytes type 4 (Hapto4s)
</p>
</li>
<li><p> Chlorophytes
</p>
</li>
<li><p> Cynechococcus
</p>
</li>
<li><p> Diatoms
</p>
</li></ul>

<p>and 12 <b>pigments</b>:
</p>
<p><code>Perid</code> = Peridinin,
<code>19But</code> = 19-butanoyloxyfucoxanthin,
<code>Fucox</code> = fucoxanthin,
</p>
<p><code>19Hex</code> = 19-hexanoyloxyfucoxanthin,
<code>Neo</code> = neoxanthin,
<code>Pras</code> = prasinoxanthin,
</p>
<p><code>Viol</code> = violaxanthin,
<code>Allox</code> = alloxanthin,
<code>Lutein</code> = lutein,
</p>
<p><code>Zeax</code> = zeaxanthin,
<code>Chlb</code> = chlorophyll b,
<code>Chla</code> = chlorophyll a
</p>
<p>The input data consist of:
</p>

<ol>
<li><p> the pigment composition of the various algal groups, for instance
determined from cultures (the Southern Ocean example -table 4- in
Mackey et al., 1996)
</p>
</li>
<li><p> the pigment composition of a field sample.
</p>
</li></ol>

<p>Based on these data, the algal composition of the field sample is estimated,
under the assumption that the pigment composition of the field sample is a
weighted avertage of the pigment composition of algae present in the sample,
where weighting is proportional to their biomass.
</p>
<p>As there are more measurements (12 pigments) than unknowns (8 algae),
the resulting linear system is overdetermined.
</p>
<p>It is thus solved in a least squares sense (using function <code>lsei</code>):
</p>
<p style="text-align: center;"><code class="reqn">\min(||Ax-b||^2)</code>
</p>
<p> subject to
</p>
<p style="text-align: center;"><code class="reqn">Ex=f</code>
</p>

<p style="text-align: center;"><code class="reqn">Gx&gt;=h</code>
</p>

<p>If there are 2 algae <code>A,B</code>, and 3 pigments <code>1,2,3</code> then the 3
approximate equalities (<code class="reqn">A*x=B</code>) would be:
</p>
<p style="text-align: center;"><code class="reqn">f_{1,S} = p_{A}*f_{A,1}+p_{B}*f_{B,1}</code>
</p>

<p style="text-align: center;"><code class="reqn">f_{2,S} = p_{A}*f_{A,2}+p_{B}*f_{B,3}</code>
</p>

<p style="text-align: center;"><code class="reqn">f_{3,S} = p_{A}*f_{A,3}+p_{B}*f_{B,3}</code>
</p>

<p>where <code class="reqn">p_{A}</code> and <code class="reqn">p_{b}</code> are the (unknown) proportions of algae
A and B in the field sample (S), and
<code class="reqn">f_{A,1}</code> is the relative amount of pigment 1 in alga A, etc...
</p>
<p>The equality ensures that the sum of fractions equals 1:
</p>
<p style="text-align: center;"><code class="reqn">1 = p_{A}+p_{b}</code>
</p>

<p>and the inequalities ensure that fractions are positive numbers
</p>
<p style="text-align: center;"><code class="reqn">p_{A} &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">p_{B} &gt; 0</code>
</p>

<p>It should be noted that in the actual <em>Chemtax</em> programme the problem
is solved in a more complex way. In Chemtoz, the A-coefficients are also
allowed to vary, while here they are taken as they are (constant).
Chemtax then finds the &quot;best fit&quot; by fitting both the fractions, and the
non-zero coefficients in A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Chemtax</code></pre>


<h3>Format</h3>

<p>A list with the input ratio matrix (<code>Ratio</code>) and a vector with the
field data (<code>Field</code>)
</p>

<ul>
<li><p> The input ratio matrix <code>Ratio</code> contains the pigment compositions
(columns) for each algal group (rows);
the compositions are scaled relative to <code>Chla</code> (last column).
</p>
</li>
<li><p> The vector with the <code>Field</code> data contains the pigment composition
of a sample in the field, also scaled relative to <code>Chla</code>;
the pigments are similarly ordened as for the input ratio matrix.
</p>
</li></ul>

<p>The rownames of matrix <code>Ratio</code> are the algal group names, columnames
of <code>Ratio</code> (=names of <code>Field</code>) are the pigments
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;.
</p>


<h3>References</h3>

<p>Mackey MD, Mackey DJ, Higgins HW, Wright SW, 1996.
CHEMTAX - A program for estimating class abundances from chemical markers:
Application to HPLC measurements of phytoplankton. Marine Ecology-Progress
Series 144 (1-3): 265-283.
</p>
<p>Van den Meersche, K., Soetaert, K., Middelburg, J., 2008.
A Bayesian compositional estimator for microbial taxonomy based on biomarkers.
Limnology and Oceanography Methods, 6, 190-199.
</p>
<p>R-package <code>BCE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsei">lsei</a></code>, the function to solve for the algal composition of the
field sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Graphical representation of the chemtax example input data
palette(rainbow(12, s = 0.6, v = 0.75))

mp     &lt;- apply(Chemtax$Ratio, MARGIN = 2, max)
pstars &lt;- rbind(t(t(Chemtax$Ratio)/mp) ,
                  sample = Chemtax$Field/max(Chemtax$Field))
stars(pstars, len = 0.9, key.loc = c(7.2, 1.7),scale=FALSE,ncol=4,
      main = "CHEMTAX pigment composition", draw.segments = TRUE,
      flip.labels=FALSE)

# 2. Estimating the algal composition of the field sample
Nx     &lt;-nrow(Chemtax$Ratio)

# equations that have to be met exactly Ex=f: 
# sum of all fraction must be equal to 1.
EE &lt;- rep(1, Nx)
FF &lt;- 1

# inequalities, Gx&gt;=h:
# all fractions must be positive numbers
GG &lt;- diag(nrow = Nx)
HH &lt;- rep(0, Nx)

# equations that must be reproduced as close as possible, Ax ~ b
# = the field data; the input ratio matrix and field data are rescaled
AA     &lt;- Chemtax$Ratio/rowSums(Chemtax$Ratio)
BB     &lt;- Chemtax$Field/sum(Chemtax$Field)

# 1. Solve with lsei method
X &lt;- lsei(t(AA), BB, EE, FF, GG, HH)$X
(Sample &lt;- data.frame(Algae = rownames(Chemtax$Ratio),
                      fraction = X))

# plot results
barplot(X, names = rownames(Chemtax$Ratio), col = heat.colors(8),
        cex.names = 0.8, main = "Chemtax example solved with lsei")

# 2. Bayesian sampling; 
# The standard deviation on the field data is assumed to be 0.01
# jump length not too large or NO solutions are found!
xs &lt;- xsample(t(AA), BB, EE, FF, GG, HH, sdB = 0.01, jmp = 0.025)$X
pairs(xs, main= "Chemtax, Bayesian sample")
</code></pre>

<hr>
<h2 id='E_coli'>
An underdetermined linear inverse problem: the Escherichia Coli
Core Metabolism Model.
</h2><span id='topic+E_coli'></span>

<h3>Description</h3>

<p>Input matrices and vectors for performing Flux Balance Analysis of the
E.coli metabolism
</p>
<p>(as from <code>http://gcrg.ucsd.edu/Downloads/Flux_Balance_Analysis</code>).
</p>
<p>The original input file can be found in the package subdirectory
<code>/inst/docs/E_coli.input</code>
</p>
<p>There are 53 substances:
</p>
<p>GLC, G6P, F6P, FDP, T3P2, T3P1, 13PDG, 3PG, 2PG, PEP, PYR, ACCOA, CIT, ICIT,
AKG, SUCCOA, SUCC, FUM, MAL, OA, ACTP, ETH, AC, LAC, FOR, D6PGL, D6PGC, RL5P,
X5P, R5P, S7P, E4P, RIB, GLX, NAD, NADH, NADP, NADPH, HEXT, Q, FAD, FADH,
AMP, ADP, ATP, GL3P, CO2, PI, PPI, O2, COA, GL, QH2
</p>
<p>and 13 externals:
</p>
<p>Biomass, GLCxt, GLxt, RIBxt, ACxt, LACxt, FORxt, ETHxt, SUCCxt, PYRxt,
PIxt, O2xt, CO2xt
</p>
<p>There are 70 unknown reactions (named by the gene encoding for it):
</p>
<p>GLK1,  PGI1,  PFKA,  FBP, FBA, TPIA, GAPA, PGK, GPMA, ENO, PPSA, PYKA,
ACEE, ZWF, PGL, GND, RPIA, RPE, TKTA1, TKTA2, TALA, GLTA, ACNA, ICDA,
SUCA, SUCC1, SDHA1, FRDA, FUMA, MDH, DLD1, ADHE2, PFLA, PTA, ACKA, ACS,
PCKA, PPC, MAEB, SFCA, ACEA, ACEB, PPA, GLPK, GPSA1, RBSK, NUOA, FDOH,
GLPD, CYOA, SDHA2, PNT1A, PNT2A, ATPA, GLCUP, GLCPTS, GLUP, RIBUP, ACUP,
LACUP, FORUP, ETHUP, SUCCUP, PYRUP, PIUP, O2TX, CO2TX, ATPM, ADK, Growth
</p>
<p>The <code>lsei</code> model contains:
</p>

<ul>
<li><p> 54 equalities (Ax=B): the 53 mass balances (one for each substance)
and one equation that sets the ATP drain flux for constant maintenance
requirements to a fixed value (5.87)
</p>
</li>
<li><p> 70 unknowns (x), the reaction rates
</p>
</li>
<li><p> 62 inequalities (Gx&gt;h). The first 28 inequalities impose bounds
on some reactions.
The last 34 inequalities impose that the reaction rates have to be
positive (for unidirectional reactions only).
</p>
</li>
<li><p> 1 function that has to be maximised, the biomass production (growth).
</p>
</li></ul>

<p>As there are more unknowns (70) than equations (54), there exist an
infinite amount of solutions (it is an underdetermined problem).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E_coli</code></pre>


<h3>Format</h3>

<p>A list with the matrices and vectors that constitute the mass balance problem:
<code>A</code>, <code>B</code>, <code>G</code> and <code>H</code> and
</p>
<p><code>Maximise</code>, with the function to maximise.
</p>
<p>The columnames of <code>A</code> and <code>G</code> are the names of the unknown
reaction rates;
The first 53 rownames of <code>A</code> give the names of the components
(these rows consitute the mass balance equations).
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>originated from the urlhttp://gcrg.ucsd.edu/Downloads/Flux_Balance_Analysis
</p>
<p>Edwards,J.S., Covert, M., and Palsson, B., (2002)
Metabolic Modeling of Microbes: the Flux Balance Approach,
Environmental Microbiology, 4(3): pp. 133-140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. parsimonious (simplest) solution
pars &lt;- lsei(E = E_coli$A, F = E_coli$B, G = E_coli$G, H = E_coli$H)$X

# 2. the optimal solution - solved with linear programming
#    some unknowns can be negative

LP &lt;- linp(E = E_coli$A, F = E_coli$B,G = E_coli$G, H = E_coli$H,
           Cost = -E_coli$Maximise, ispos = FALSE)
(Optimal &lt;- LP$X)

# 3.ranges of all unknowns, including the central value and all solutions
xr   &lt;- xranges(E = E_coli$A, F = E_coli$B, G = E_coli$G, H = E_coli$H,
                central = TRUE, full = TRUE)

# the central point is a valid solution:
X &lt;- xr[ ,"central"]
max(abs(E_coli$A%*%X - E_coli$B))
min(E_coli$G%*%X - E_coli$H)

# 4. Sample solution space; the central value is a good starting point
#   for algorithms cda and rda - but these need many iterations
## Not run: 
xs &lt;- xsample(E = E_coli$A, F = E_coli$B, G = E_coli$G,H = E_coli$H,
              iter = 50000, out = 5000, type = "rda", x0 = X)$X
pairs(xs[ ,10:20], pch = ".", cex = 2, main = "sampling, using rda")

## End(Not run)

# using mirror algorithm takes less iterations,
# but an iteration takes more time ; it is better to start in a corner...
# (i.e. no need to use X as starting value)
xs &lt;- xsample(E = E_coli$A, F = E_coli$B, G = E_coli$G, H = E_coli$H,
              iter = 2000, out = 500, jmp = 50, type = "mirror")$X
pairs(xs[ ,10:20], pch = ".", cex = 2, main = "sampling, using mirror")

# Print results:
data.frame(pars = pars, Optimal = Optimal, xr[ ,1:2],
           Mean = colMeans(xs), sd = apply(xs, 2, sd))

# Plot results
par(mfrow = c(1, 2))
nr &lt;- length(Optimal)/2

ii &lt;- 1:nr
dotchart(Optimal[ii], xlim = range(xr), pch = 16)
segments(xr[ii,1], 1:nr, xr[ii,2], 1:nr)

ii &lt;- (nr+1):length(Optimal)
dotchart(Optimal[ii], xlim = range(xr), pch = 16)
segments(xr[ii,1], 1:nr, xr[ii,2], 1:nr)
mtext(side = 3, cex = 1.5, outer = TRUE, line = -1.5,
      "E coli Core Metabolism, optimal solution and ranges")
</code></pre>

<hr>
<h2 id='ldei'>
Weighted Least Distance Programming with equality and inequality constraints.
</h2><span id='topic+ldei'></span>

<h3>Description</h3>

<p>Solves the following <b>underdetermined</b> inverse problem:
</p>
<p style="text-align: center;"><code class="reqn">\min(\sum {x_i}^2)</code>
</p>
<p> subject to
</p>
<p style="text-align: center;"><code class="reqn">Ex=f</code>
</p>

<p style="text-align: center;"><code class="reqn">Gx&gt;=h</code>
</p>

<p>uses least distance programming subroutine ldp (FORTRAN) from Linpack
</p>
<p>The model has to be UNDERdetermined, i.e. the number of independent
equations &lt; number of unknowns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldei(E, F, G = NULL, H = NULL,
     tol = sqrt(.Machine$double.eps), verbose = TRUE,
     lower = NULL, upper = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ldei_+3A_e">E</code></td>
<td>
<p>numeric matrix containing the coefficients of the equality
constraints <code class="reqn">Ex=F</code>; if the columns of <code>E</code> have a names attribute,
they will be used to label the output.
</p>
</td></tr>
<tr><td><code id="ldei_+3A_f">F</code></td>
<td>
<p>numeric vector containing the right-hand side of the
equality constraints.
</p>
</td></tr>
<tr><td><code id="ldei_+3A_g">G</code></td>
<td>
<p>numeric matrix containing the coefficients of the inequality
constraints <code class="reqn">Gx&gt;=H</code>; if the columns of <code>G</code> have a names attribute
and the columns of <code>E</code> do not, they will be used to label the output.
</p>
</td></tr>
<tr><td><code id="ldei_+3A_h">H</code></td>
<td>
<p>numeric vector containing the right-hand side of the inequality
constraints.
</p>
</td></tr>
<tr><td><code id="ldei_+3A_tol">tol</code></td>
<td>
<p>tolerance (for singular value decomposition, equality and
inequality constraints).
</p>
</td></tr>
<tr><td><code id="ldei_+3A_verbose">verbose</code></td>
<td>
<p>logical to print warnings and messages.
</p>
</td></tr>
<tr><td><code id="ldei_+3A_upper">upper</code>, <code id="ldei_+3A_lower">lower</code></td>
<td>
<p>vector containing upper and lower bounds 
on the unknowns. If one value, it is assumed to apply to all unknowns.
If a vector, it should have a length equal to the number of unknowns; this
vector can contain NA for unbounded variables. 
The upper and lower bounds are added to the inequality conditions G*x&gt;=H.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>vector containing the solution of the least distance with
equalities and inequalities problem.
</p>
</td></tr>
<tr><td><code>unconstrained.solution</code></td>
<td>
<p>vector containing the unconstrained solution
of the least distance problem, i.e. ignoring <code class="reqn">Gx&gt;=h</code>.
</p>
</td></tr>
<tr><td><code>residualNorm</code></td>
<td>
<p>scalar, the sum of absolute values of residuals of
equalities and violated inequalities; should be zero or very small if
the problem is feasible.
</p>
</td></tr>
<tr><td><code>solutionNorm</code></td>
<td>
<p>scalar, the value of the quadratic function at the
solution, i.e. the value of <code class="reqn">\sum {w_i*x_i}^2</code>.
</p>
</td></tr>
<tr><td><code>IsError</code></td>
<td>
<p>logical, <code>TRUE</code> if an error occurred.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the string &quot;ldei&quot;, such that how the solution was obtained
can be traced.
</p>
</td></tr>
<tr><td><code>numiter</code></td>
<td>
<p>the number of iterations.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>One of the steps in the ldei algorithm is the creation of an orthogonal basis, 
constructed by Singular Value Decomposition. As this makes use of random numbers, 
it may happen - for problems that are difficult to solve -
that ldei sometimes finds a solution or fails to find one for the same problem,
depending on the random numbers used to create the orthogonal basis. 
If it is suspected that this is happening, trying a few times may find a solution.
(example RigaWeb is such a problem).
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;.
</p>


<h3>References</h3>

<p>Lawson C.L.and Hanson R.J. 1974. Solving Least Squares Problems, Prentice-Hall
</p>
<p>Lawson C.L.and Hanson R.J. 1995. Solving Least Squares Problems.
SIAM classics in applied mathematics, Philadelphia.  (reprint of book)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Minkdiet">Minkdiet</a></code>, for a description of the Mink diet example.
</p>
<p><code><a href="#topic+lsei">lsei</a></code>, <code><a href="#topic+linp">linp</a></code>
</p>
<p><code><a href="#topic+ldp">ldp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------------------------------------------------------------------------------
# A simple problem
#-------------------------------------------------------------------------------
# minimise x1^2 + x2^2 + x3^2 + x4^2 + x5^2 + x6^2
# subject to:
#-x1            + x4 + x5      = 0
#    - x2       - x4      + x6 = 0
# x1 + x2 + x3                 &gt; 1
#           x3       + x5 + x6 &lt; 1
# xi &gt; 0

E &lt;- matrix(nrow = 2, byrow = TRUE, data = c(-1, 0, 0, 1, 1, 0,
                                              0,-1, 0, -1, 0, 1))
F &lt;- c(0, 0)
G &lt;- matrix(nrow = 2, byrow = TRUE, data = c(1, 1, 1, 0, 0, 0,
                                             0, 0, -1, 0, -1, -1))
H    &lt;- c(1, -1)
ldei(E, F, G, H)

#-------------------------------------------------------------------------------
# Imposing bounds
#-------------------------------------------------------------------------------

ldei(E, F, G, H, lower = 0.25)
ldei(E, F, G, H, lower = c(0.25, 0.25, 0.25, NA, NA, 0.5))

#-------------------------------------------------------------------------------
# parsimonious (simplest) solution of the mink diet problem
#-------------------------------------------------------------------------------
E &lt;- rbind(Minkdiet$Prey, rep(1, 7))
F &lt;- c(Minkdiet$Mink, 1)

parsimonious &lt;- ldei(E, F, G = diag(7), H = rep(0, 7))
data.frame(food = colnames(Minkdiet$Prey),
           fraction = parsimonious$X)
dotchart(x = as.vector(parsimonious$X),
         labels = colnames(Minkdiet$Prey),
         main = "Diet composition of Mink extimated using ldei",
         xlab = "fraction")
         
</code></pre>

<hr>
<h2 id='ldp'>
Least Distance Programming
</h2><span id='topic+ldp'></span>

<h3>Description</h3>

<p>Solves the following inverse problem:
</p>
<p style="text-align: center;"><code class="reqn">\min(\sum {x_i}^2)</code>
</p>
<p> subject to
</p>
<p style="text-align: center;"><code class="reqn">Gx&gt;=h</code>
</p>

<p>uses least distance programming subroutine ldp (FORTRAN) from Linpack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldp(G, H, tol = sqrt(.Machine$double.eps), verbose = TRUE, 
    lower = NULL, upper = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ldp_+3A_g">G</code></td>
<td>
<p>numeric matrix containing the coefficients of the inequality
constraints <code class="reqn">Gx&gt;=H</code>; if the columns of <code>G</code> have a names attribute,
they will be used to label the output.
</p>
</td></tr>
<tr><td><code id="ldp_+3A_h">H</code></td>
<td>
<p>numeric vector containing the right-hand side of the inequality
constraints.
</p>
</td></tr>
<tr><td><code id="ldp_+3A_tol">tol</code></td>
<td>
<p>tolerance (for inequality constraints).
</p>
</td></tr>
<tr><td><code id="ldp_+3A_verbose">verbose</code></td>
<td>
<p>logical to print warnings and messages.
</p>
</td></tr>
<tr><td><code id="ldp_+3A_upper">upper</code>, <code id="ldp_+3A_lower">lower</code></td>
<td>
<p>vector containing upper and lower bounds 
on the unknowns. If one value, it is assumed to apply to all unknowns.
If a vector, it should have a length equal to the number of unknowns; this
vector can contain NA for unbounded variables. 
The upper and lower bounds are added to the inequality conditions G*x&gt;=H.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>vector containing the solution of the least distance problem.
</p>
</td></tr>
<tr><td><code>residualNorm</code></td>
<td>
<p>scalar, the sum of absolute values of residuals of
violated inequalities; should be zero or very small if the problem is
feasible.
</p>
</td></tr>
<tr><td><code>solutionNorm</code></td>
<td>
<p>scalar, the value of the quadratic function at the
solution, i.e. the value of <code class="reqn">\sum {w_i*x_i}^2</code>.
</p>
</td></tr>
<tr><td><code>IsError</code></td>
<td>
<p>logical, <code>TRUE</code> if an error occurred.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the string &quot;ldp&quot;, such that how the solution was obtained
can be traced.
</p>
</td></tr>
<tr><td><code>numiter</code></td>
<td>
<p>the number of iterations.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Lawson C.L.and Hanson R.J. 1974. Solving Least Squares Problems, Prentice-Hall
</p>
<p>Lawson C.L.and Hanson R.J. 1995. Solving Least Squares Problems.
SIAM classics in applied mathematics, Philadelphia.        (reprint of book)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ldei">ldei</a></code>, which includes equalities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parsimonious (simplest) solution
G &lt;- matrix(nrow = 2, ncol = 2, data = c(3, 2, 2, 4))
H &lt;- c(3, 2)

ldp(G, H)

# imposing bounds on the first unknown
ldp(G, H, lower = c(1, NA))
</code></pre>

<hr>
<h2 id='linp'>
Linear Programming.
</h2><span id='topic+linp'></span>

<h3>Description</h3>

<p>Solves a linear programming problem,
</p>
<p style="text-align: center;"><code class="reqn">\min(\sum {Cost_i.x_i})</code>
</p>
<p> subject to
</p>
<p style="text-align: center;"><code class="reqn">Ex=f</code>
</p>

<p style="text-align: center;"><code class="reqn">Gx&gt;=h</code>
</p>

<p style="text-align: center;"><code class="reqn">x_i&gt;=0</code>
</p>
<p> (optional)
</p>
<p>This function provides a wrapper around <code><a href="lpSolve.html#topic+lp">lp</a></code> (see note)
from package lpSolve, written to be consistent with the functions
<code>lsei</code>, and <code>ldei</code>.
</p>
<p>It allows for the x's to be negative (not standard in lp).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linp(E = NULL, F = NULL, G = NULL, H = NULL, Cost,
     ispos = TRUE, int.vec = NULL, verbose = TRUE, 
     lower = NULL, upper = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linp_+3A_e">E</code></td>
<td>
<p>numeric matrix containing the coefficients of the equality
constraints <code class="reqn">Ex=F</code>; if the columns of <code>E</code> have a names attribute,
they will be used to label the output.
</p>
</td></tr>
<tr><td><code id="linp_+3A_f">F</code></td>
<td>
<p>numeric vector containing the right-hand side of the equality
constraints.
</p>
</td></tr>
<tr><td><code id="linp_+3A_g">G</code></td>
<td>
<p>numeric matrix containing the coefficients of the inequality
constraints <code class="reqn">Gx&gt;=H</code>; if the columns of <code>G</code> have a names attribute,
and the columns of <code>E</code> do not, they will be used to label the output.
</p>
</td></tr>
<tr><td><code id="linp_+3A_h">H</code></td>
<td>
<p>numeric vector containing the right-hand side of the inequality
constraints.
</p>
</td></tr>
<tr><td><code id="linp_+3A_cost">Cost</code></td>
<td>
<p>numeric vector containing the coefficients of the cost function;
if <code>Cost</code> has a names attribute, and neither the columns of <code>E</code>
nor <code>G</code> have a name, they will be used to label the output.
</p>
</td></tr>
<tr><td><code id="linp_+3A_ispos">ispos</code></td>
<td>
<p>logical, when <code>TRUE</code> then the unknowns (x) must be
positive (this is consistent with the original definition of a
linear programming problem).
</p>
</td></tr>
<tr><td><code id="linp_+3A_int.vec">int.vec</code></td>
<td>
<p>when not <code>NULL</code>, a numeric vector giving the indices
of variables that are required to be an integer. The length of this
vector will therefore be the number of integer variables.
</p>
</td></tr>
<tr><td><code id="linp_+3A_verbose">verbose</code></td>
<td>
<p>logical to print warnings and messages.
</p>
</td></tr>
<tr><td><code id="linp_+3A_upper">upper</code>, <code id="linp_+3A_lower">lower</code></td>
<td>
<p>vector containing upper and lower bounds 
on the unknowns. If one value, it is assumed to apply to all unknowns.
If a vector, it should have a length equal to the number of unknowns; this
vector can contain NA for unbounded variables. 
The upper and lower bounds are added to the inequality conditions G*x&gt;=H.
</p>
</td></tr>
<tr><td><code id="linp_+3A_...">...</code></td>
<td>
<p>extra arguments passed to R-function <code>lp</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>vector containing the solution of the linear programming problem.
</p>
</td></tr>
<tr><td><code>residualNorm</code></td>
<td>
<p>scalar, the sum of absolute values of residuals of
equalities and violated inequalities.
Should be very small or zero for a feasible linear programming problem.
</p>
</td></tr>
<tr><td><code>solutionNorm</code></td>
<td>
<p>scalar, the value of the minimised <code>Cost</code> function,
i.e. the value of <code class="reqn">\sum {Cost_i.x_i}</code>.
</p>
</td></tr>
<tr><td><code>IsError</code></td>
<td>
<p>logical, <code>TRUE</code> if an error occurred.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the string &quot;linp&quot;, such that how the solution was obtained can
be traced.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If the requirement of nonnegativity are relaxed, then strictly speaking the
problem is not a linear programming problem.
</p>
<p>The function <code>lp</code> may fail and terminate R for very small problems that
are repeated frequently...
</p>
<p>Also note that sometimes multiple solutions exist for the same problem.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Michel Berkelaar and others (2007).
lpSolve: Interface to Lpsolve v. 5.5 to solve linear or integer programs.
R package version 5.5.8.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ldei">ldei</a></code>,  <code><a href="#topic+lsei">lsei</a></code>,
</p>
<p><code><a href="lpSolve.html#topic+lp">lp</a></code> the original function from package lpSolve
</p>
<p><code><a href="#topic+Blending">Blending</a></code>, a linear programming problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------------------------------------------------------------------------------
# Linear programming problem 1, not feasible
#-------------------------------------------------------------------------------

# maximise x1 + 3*x2 
# subject to
#-x1 -x2    &lt; -3
#-x1 + x2   &lt;-1
# x1 + 2*x2 &lt; 2
# xi &gt; 0

G    &lt;- matrix(nrow = 3, data = c(-1, -1, 1, -1, 1, 2))
H    &lt;- c(3, -1, 2)
Cost &lt;- c(-1, -3)
(L &lt;- linp(E = NULL, F = NULL, Cost = Cost, G = G, H = H))
L$residualNorm

#-------------------------------------------------------------------------------
# Linear programming problem 2, feasible
#-------------------------------------------------------------------------------

# minimise x1 + 8*x2 + 9*x3 + 2*x4 + 7*x5 + 3*x6  
# subject to:
#-x1            + x4 + x5      = 0
#    - x2       - x4      + x6 = 0
# x1 + x2 + x3                 &gt; 1
#           x3       + x5 + x6 &lt; 1
# xi &gt; 0

E &lt;- matrix(nrow = 2, byrow = TRUE, data = c(-1, 0, 0, 1, 1, 0,
                                              0,-1, 0, -1, 0, 1))
F &lt;- c(0, 0)
G &lt;- matrix(nrow = 2, byrow = TRUE, data = c(1, 1, 1, 0, 0, 0,
                                             0, 0, -1, 0, -1, -1))
H    &lt;- c(1, -1)
Cost &lt;- c(1, 8, 9, 2, 7, 3)
(L &lt;- linp(E = E, F = F, Cost = Cost, G = G, H = H))
L$residualNorm

# Including a lower bound:
linp(E = E, F = F, Cost = Cost, G = G, H = H, lower = 0.25)

#-------------------------------------------------------------------------------
# Linear programming problem 3, no positivity
#-------------------------------------------------------------------------------
# minimise x1 + 2x2 -x3 +4 x4
# subject to:
# 3x1 + 2x2 + x3 + x4 = 2
#  x1 +  x2 + x3 + x4 = 2

# 2x1 +  x2 + x3 + x4 &gt;=-1
# -x1 + 3x2 +2x3 + x4 &gt;= 2
# -x1       + x3      &gt;= 1

E &lt;- matrix(ncol = 4, byrow = TRUE,
            data =c(3, 2, 1, 4, 1, 1, 1, 1))
F &lt;- c(2, 2)

G &lt;- matrix(ncol = 4, byrow = TRUE,
            data = c(2, 1, 1, 1, -1, 3, 2, 1, -1, 0, 1, 0))
H &lt;- c(-1, 2, 1)
Cost &lt;- c(1, 2, -1, 4)

linp(E = E, F = F, G = G, H = H, Cost, ispos = FALSE)
</code></pre>

<hr>
<h2 id='lsei'>
Least Squares with Equalities and Inequalities
</h2><span id='topic+lsei'></span>

<h3>Description</h3>

<p>Solves an lsei inverse problem (Least Squares with Equality and Inequality
Constraints)
</p>
<p style="text-align: center;"><code class="reqn">\min(||Ax-b||^2)</code>
</p>
<p> subject to
</p>
<p style="text-align: center;"><code class="reqn">Ex=f</code>
</p>

<p style="text-align: center;"><code class="reqn">Gx&gt;=h</code>
</p>

<p>Uses either subroutine lsei (FORTRAN) from the LINPACK package, or
<code>solve.QP</code> from <span class="rlang"><b>R</b></span>-package <code>quadprog</code>.
</p>
<p>In case the equality constraints <code class="reqn">Ex=f</code> cannot be satisfied, a
generalized inverse solution residual vector length is obtained for <code class="reqn">f-Ex</code>.
</p>
<p>This is the minimal length possible for <code class="reqn">||f-Ex||^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsei (A = NULL, B = NULL, E = NULL, F = NULL, G = NULL, H = NULL,
      Wx = NULL, Wa = NULL, type = 1, tol = sqrt(.Machine$double.eps),
      tolrank = NULL, fulloutput = FALSE, verbose = TRUE, 
      lower = NULL, upper = NULL)
      </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lsei_+3A_a">A</code></td>
<td>
<p>numeric matrix containing the coefficients of the quadratic
function to be minimised, <code class="reqn">||Ax-B||^2</code>; if the columns of <code>A</code> have
a names attribute, they will be used to label the output.
</p>
</td></tr>
<tr><td><code id="lsei_+3A_b">B</code></td>
<td>
<p>numeric vector containing the right-hand side of the quadratic
function to be minimised.
</p>
</td></tr>
<tr><td><code id="lsei_+3A_e">E</code></td>
<td>
<p>numeric matrix containing the coefficients of the equality
constraints, <code class="reqn">Ex=F</code>; if the columns of <code>E</code> have a names attribute,
and the columns of <code>A</code> do not, they will be used to label the output.
</p>
</td></tr>
<tr><td><code id="lsei_+3A_f">F</code></td>
<td>
<p>numeric vector containing the right-hand side of the equality
constraints.
</p>
</td></tr>
<tr><td><code id="lsei_+3A_g">G</code></td>
<td>
<p>numeric matrix containing the coefficients of the inequality
constraints, <code class="reqn">Gx&gt;=H</code>; if the columns of <code>G</code> have a names
attribute, and the columns of <code>A</code> and <code>E</code> do not, they will be
used to label the output.
</p>
</td></tr>
<tr><td><code id="lsei_+3A_h">H</code></td>
<td>
<p>numeric vector containing the right-hand side of the inequality
constraints.
</p>
</td></tr>
<tr><td><code id="lsei_+3A_wx">Wx</code></td>
<td>
<p>numeric vector with weighting coefficients of unknowns (length
= number of unknowns).
</p>
</td></tr>
<tr><td><code id="lsei_+3A_wa">Wa</code></td>
<td>
<p>numeric vector with weighting coefficients of the quadratic
function (Ax-B) to be minimised (length = number of number of rows of A).
</p>
</td></tr>
<tr><td><code id="lsei_+3A_type">type</code></td>
<td>
<p>integer code determining algorithm to use 1=<code>lsei</code>,
2=<code>solve.QP</code> from R-package <code>quadprog</code> (see note).
</p>
</td></tr>
<tr><td><code id="lsei_+3A_tol">tol</code></td>
<td>
<p>tolerance (for singular value decomposition, equality and
inequality constraints).
</p>
</td></tr>
<tr><td><code id="lsei_+3A_tolrank">tolrank</code></td>
<td>
<p>only used if <code>type</code> = 1; if not <code>NULL</code> then
<code>tolrank</code> should be a two-valued vector containing the rank
determination tolerance for the equality constraint equations
(1st value) and for the reduced least squares equations (2nd value).
</p>
</td></tr>
<tr><td><code id="lsei_+3A_fulloutput">fulloutput</code></td>
<td>
<p>if <code>TRUE</code>, also returns the covariance matrix of
the solution and the rank of the equality constraints - only used
if <code>type</code> = 1.
</p>
</td></tr>
<tr><td><code id="lsei_+3A_verbose">verbose</code></td>
<td>
<p>logical to print warnings and messages.
</p>
</td></tr>
<tr><td><code id="lsei_+3A_upper">upper</code>, <code id="lsei_+3A_lower">lower</code></td>
<td>
<p>vector containing upper and lower bounds 
on the unknowns. If one value, it is assumed to apply to all unknowns.
If a vector, it should have a length equal to the number of unknowns; this
vector can contain NA for unbounded variables. 
The upper and lower bounds are added to the inequality conditions G*x&gt;=H.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>vector containing the solution of the least squares problem.
</p>
</td></tr>
<tr><td><code>residualNorm</code></td>
<td>
<p>scalar, the sum of absolute values of residuals of
equalities and violated inequalities.
</p>
</td></tr>
<tr><td><code>solutionNorm</code></td>
<td>
<p>scalar, the value of the minimised quadratic function
at the solution, i.e. the value of <code class="reqn">||Ax-b||^2</code>.
</p>
</td></tr>
<tr><td><code>IsError</code></td>
<td>
<p>logical, <code>TRUE</code> if an error occurred.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the string &quot;lsei&quot;, such that how the solution was obtained
can be traced.
</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>covariance matrix of the solution; only returned if
<code>fulloutput</code> = <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>RankEq</code></td>
<td>
<p>rank of the equality constraint matrix.; only returned if
<code>fulloutput</code> = <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>RankApp</code></td>
<td>
<p>rank of the reduced least squares problem (approximate
equations); only returned if <code>fulloutput</code> = <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See comments in the original code for more details; these comments are
included in the &lsquo;<span class="file">docs</span>&rsquo; subroutine of the package.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>K. H. Haskell and R. J. Hanson, An algorithm for linear least squares problems
with equality and nonnegativity constraints, Report SAND77-0552,
Sandia Laboratories, June 1978.
</p>
<p>K. H. Haskell and R. J. Hanson, Selected algorithms for the linearly
constrained least squares problem - a users guide,
Report SAND78-1290, Sandia Laboratories,August 1979.
</p>
<p>K. H. Haskell and R. J. Hanson, An algorithm for linear least squares
problems with equality and nonnegativity constraints,
Mathematical Programming 21 (1981), pp. 98-118.
</p>
<p>R. J. Hanson and K. H. Haskell, Two algorithms for the linearly constrained
least squares problem, ACM Transactions on Mathematical Software,
September 1982.
</p>
<p>Berwin A. Turlach R and Andreas Weingessel (2007). quadprog: Functions to
solve Quadratic Programming Problems. R package version 1.4-11. S original
by Berwin A. Turlach R port by Andreas Weingessel.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ldei">ldei</a></code>, <code><a href="#topic+linp">linp</a></code>,
</p>
<p><code>solve.QR</code> the original function from package <code>quadprog</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ------------------------------------------------------------------------------
# example 1: polynomial fitting
# ------------------------------------------------------------------------------
x &lt;- 1:5
y &lt;- c(9, 8, 6, 7, 5)
plot(x, y, main = "Polynomial fitting, using lsei", cex = 1.5, 
     pch = 16, ylim = c(4, 10))

# 1-st order
A &lt;- cbind(rep(1, 5), x)
B &lt;- y
cf &lt;- lsei(A, B)$X
abline(coef = cf)

# 2-nd order
A &lt;- cbind(A, x^2)
cf &lt;- lsei(A, B)$X
curve(cf[1] + cf[2]*x + cf[3]*x^2, add = TRUE, lty = 2)

# 3-rd order
A &lt;- cbind(A, x^3)
cf &lt;- lsei(A, B)$X
curve(cf[1] + cf[2]*x + cf[3]*x^2 + cf[4]*x^3, add = TRUE, lty = 3)

# 4-th order
A &lt;- cbind(A, x^4)
cf &lt;- lsei(A, B)$X
curve(cf[1] + cf[2]*x + cf[3]*x^2 + cf[4]*x^3 + cf[5]*x^4, 
      add = TRUE, lty = 4)
legend("bottomleft", c("1st-order", "2nd-order","3rd-order","4th-order"),
       lty = 1:4)

# ------------------------------------------------------------------------------
# example 2: equalities, approximate equalities and inequalities
# ------------------------------------------------------------------------------

A &lt;- matrix(nrow = 4, ncol = 3,
            data = c(3, 1, 2, 0, 2, 0, 0, 1, 1, 0, 2, 0))
B &lt;- c(2, 1, 8, 3)
E &lt;- c(0, 1, 0)
F &lt;- 3
G &lt;- matrix(nrow = 2, ncol = 3, byrow = TRUE,
            data = c(-1, 2, 0, 1, 0, -1))
H &lt;- c(-3, 2)

lsei(E = E, F = F, A = A, B = B, G = G, H = H)

# ------------------------------------------------------------------------------
# example 3: bounds added
# ------------------------------------------------------------------------------

lsei(E = E, F = F, A = A, B = B, G = G, H = H, 
     lower = c(2, NA, 0))
lsei(E = E, F = F, A = A, B = B, G = G, H = H, 
     upper = 2)

</code></pre>

<hr>
<h2 id='Minkdiet'>
An underdetermined linear inverse problem: estimating diet composition of
Southeast Alaskan Mink.
</h2><span id='topic+Minkdiet'></span>

<h3>Description</h3>

<p>Input data for assessing the diet composition of mink in southeast Alaska,
using C and N isotope ratios (d13C and d15N).
</p>
<p>The data consist of
</p>

<ol>
<li><p> the input matrix <code>Prey</code>, which contains the C (1st row) and N
(2nd row) isotopic values of the prey items (columns), corrected for
fractionation.
</p>
</li>
<li><p> the input vector <code>Mink</code>, with the C and N isotopic value of
the predator, mink
</p>
</li></ol>

<p>There are seven prey items as food sources:
</p>

<ul>
<li><p> fish
</p>
</li>
<li><p> mussels
</p>
</li>
<li><p> crabs
</p>
</li>
<li><p> shrimp
</p>
</li>
<li><p> rodents
</p>
</li>
<li><p> amphipods
</p>
</li>
<li><p> ducks
</p>
</li></ul>

<p>The d13C and d15N for each of these prey items, and for mink (the predator)
was assessed. The isotopic values of the preys were corrected for
fractionation.
</p>
<p>The problem is to find the diet composition of mink, e.g. the fraction of
each of these food items in the diet.
</p>
<p>Mathematically this is by solving an lsei (least squares with equalities
and inequalities) problem: <code class="reqn">Ex=f</code> subject to <code class="reqn">Gx&gt;h</code>.
</p>
<p>The equalities <code class="reqn">Ex=f</code>:
</p>
<p style="text-align: center;"><code class="reqn">d13CMink = p1*d13Cfish+p2*d13Cmussels + .... + p7*d13Cducks</code>
</p>

<p style="text-align: center;"><code class="reqn">d15NMink = p1*d15Nfish+p2*d15Nmussels + .... + p7*d15Nducks</code>
</p>

<p style="text-align: center;"><code class="reqn">1 = p1+p2+p3+p4+p5+p6+p7</code>
</p>

<p>and inequalities <code class="reqn">Gx&gt;h</code>:
</p>
<p style="text-align: center;"><code class="reqn">pi &gt;= 0</code>
</p>

<p>are solved for p1,p2,...p7.
</p>
<p>The first two equations calculate the isotopic ratio of the consumer (Mink)
as a weighted average of the ratio of the food sources
</p>
<p>Equation 3 assures that the sum of all fraction equals 1.
</p>
<p>As there are 7 unknowns and only 3 equations, the model is UNDERdetermined,
i.e. there exist an infinite amount of solutions.
</p>
<p>This model can be solved by various techniques:
</p>

<ol>
<li><p> least distance programming will select the &quot;simplest&quot; solution.
See <code><a href="#topic+ldei">ldei</a></code>.
</p>
</li>
<li><p> the remaining uncertainty ranges of the fractions can be estimated
using linear programming. See <code><a href="#topic+xranges">xranges</a></code>
</p>
</li>
<li><p> the statistical distribution of the fractions can be estimated using
an MCMC algorithm which takes a sample of the solution space.
See <code><a href="#topic+xsample">xsample</a></code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>Minkdiet</code></pre>


<h3>Format</h3>

<p>a list with matrix <code>Prey</code> and vector <code>Mink</code>.
</p>

<ul>
<li> <p><code>Prey</code> contains the isotopic composition (13C and 15N) of the
7 possible food items of Mink
</p>
</li>
<li> <p><code>Mink</code> contains the isotopic composition (13C and 15N) of Mink
</p>
</li></ul>

<p>columnnames of <code>Prey</code> are the food items, rownames of <code>Prey</code>
(=names of Mink) are the names of the isotopic elements.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Ben-David M, Hanley TA, Klein DR, Schell DM (1997) Seasonal changes
in diets of coastal and riverine mink: the role of spawning Pacific salmon.
Canadian Journal of Zoology 75:803-811.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ldei">ldei</a></code> to solve for the parsimonious solution
</p>
<p><code><a href="#topic+xranges">xranges</a></code> to solve for the uncertainty ranges
</p>
<p><code><a href="#topic+xsample">xsample</a></code> to sample the solution space
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. visualisation of the data
plot(t(Minkdiet$Prey), xlim = c(-25, -13), xlab = "d13C", ylab = "d15N",
     main = "Minkdiet", sub = "Ben-David et al. (1979)")

text(t(Minkdiet$Prey)-0.1, colnames(Minkdiet$Prey))   

points(t(Minkdiet$Mink), pch = 16, cex = 2)
text(t(Minkdiet$Mink)-0.15, "MINK", cex = 1.2)   
legend("bottomright", pt.cex = c(1, 2), pch = c(1, 16),
       c("food", "predator"))

# 2. Generate the food web model input matrices
# the equalities: 
E &lt;- rbind(Minkdiet$Prey, rep(1, 7))
F &lt;- c(Minkdiet$Mink, 1)

# the inequalities (all pi&gt;0)
G &lt;- diag(7)
H &lt;- rep(0, 7)

# 3. Select the parsimonious (simplest) solution
parsimonious &lt;- ldei(E, F, G = G, H = H)

# 4. show results
data.frame(food = colnames(Minkdiet$Prey),
           fraction = parsimonious$X)

dotchart(x = as.vector(parsimonious$X), labels = colnames(Minkdiet$A),
         main = "Estimated diet composition of Mink",
         sub = "using ldei and xranges", pch = 16)

# 5. Ranges of diet composition
iso   &lt;- xranges(E, F, ispos = TRUE)
segments(iso[,1], 1:ncol(E), iso[,2], 1:ncol(E))
legend  ("topright", pch = c(16, NA), lty = c(NA, 1),
          legend = c("parsimonious", "range"))

pairs (xsample(E = E, F = F, G = diag(7), H = rep(0, 7), iter = 1000)$X,
       main = "Minkdiet 1000 solutions, using xsample")
</code></pre>

<hr>
<h2 id='nnls'>
Nonnegative Least Squares
</h2><span id='topic+nnls'></span>

<h3>Description</h3>

<p>Solves the following inverse problem:
</p>
<p style="text-align: center;"><code class="reqn">\min(||Ax-b||^2)</code>
</p>
<p> subject to
</p>
<p style="text-align: center;"><code class="reqn">x&gt;=0</code>
</p>

<p>Uses subroutine nnls (FORTRAN) from Linpack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnls(A, B, tol = sqrt(.Machine$double.eps), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nnls_+3A_a">A</code></td>
<td>
<p>numeric matrix containing the coefficients of the equality
constraints <code class="reqn">Ax~=B</code>; if the columns of <code>A</code> have a <code>names</code> 
attribute, the names will be used to label the output.
</p>
</td></tr>
<tr><td><code id="nnls_+3A_b">B</code></td>
<td>
<p>numeric vector containing the right-hand side of the
equality constraints.
</p>
</td></tr>
<tr><td><code id="nnls_+3A_tol">tol</code></td>
<td>
<p>tolerance (for singular value decomposition and for the
&quot;equality&quot; constraints).
</p>
</td></tr>
<tr><td><code id="nnls_+3A_verbose">verbose</code></td>
<td>
<p>logical to print <code>nnls</code> error messages.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>vector containing the solution of the nonnegative least
squares problem.
</p>
</td></tr>
<tr><td><code>residualNorm</code></td>
<td>
<p>scalar, the sum of absolute values of residuals of
violated inequalities (i.e. sumof x[&lt;0]); should be zero or very small
if the problem is feasible.
</p>
</td></tr>
<tr><td><code>solutionNorm</code></td>
<td>
<p>scalar, the value of the quadratic function at the
solution, i.e. the value of <code class="reqn">\min(||Ax-b||^2)</code>.
</p>
</td></tr>
<tr><td><code>IsError</code></td>
<td>
<p>logical, <code>TRUE</code> if an error occurred.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the string &quot;nnls&quot;, such that how the solution was obtained
can be traced.
</p>
</td></tr>
<tr><td><code>numiter</code></td>
<td>
<p>the number of iterations.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Lawson C.L.and Hanson R.J. 1974. Solving Least Squares Problems,
Prentice-Hall
</p>
<p>Lawson C.L.and Hanson R.J. 1995. Solving Least Squares Problems.
SIAM classics in applied mathematics, Philadelphia.  (reprint of book)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ldei">ldei</a></code>, which includes equalities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(nrow = 2, ncol = 3, data = c(3, 2, 2, 4, 2, 1))
B &lt;- c(-4, 3)
nnls(A, B)
</code></pre>

<hr>
<h2 id='resolution'>
Row and column resolution of a matrix.
</h2><span id='topic+resolution'></span>

<h3>Description</h3>

<p>Given an input matrix or its singular value decomposition,
</p>
<p>calculates the resolution of the equations (rows) and of the unknowns
(columns) of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolution (s, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolution_+3A_s">s</code></td>
<td>
<p>either a matrix or its singular value decomposition.
</p>
</td></tr>
<tr><td><code id="resolution_+3A_tol">tol</code></td>
<td>
<p>tolerance for the singular values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>row</code></td>
<td>
<p>resolution of the rows  (equations).
</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>resolution of the columns (variables).
</p>
</td></tr>
<tr><td><code>nsolvable</code></td>
<td>
<p>number of solvable unknowns - the rank of the matrix.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>
<p>Dick van Oevelen&lt;dick.vanoevelen@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Menke, W., 1989. Geophysical Data Analysis: Discrete Inverse Theory.
Revised edition. International Geophysics Series. Academic Press, London.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+svd">svd</a></code>, the singluar value decomposition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resolution (matrix(nrow = 3, runif(9)))  #3rows,3columns
resolution (matrix(nrow = 3, runif(12))) #3rows,4columns
resolution (matrix(nrow = 3, runif(6)))  #3rows,2columns
resolution (cbind(c(1, 2, 3), c(2, 3, 4), c(3, 5, 7))) # r3=r1+r2,c3=c1+c2
</code></pre>

<hr>
<h2 id='RigaWeb'>
An underdetermined linear inverse problem: the Gulf of Riga *spring*
planktonic food web
</h2><span id='topic+RigaWeb'></span>

<h3>Description</h3>

<p>Input matrices and vectors for estimating the flows in the planktonic food
web of the Gulf of Riga.
</p>
<p>(as in Donali et al. (1999)).
</p>
<p>The original input file can be found in the package subdirectory
<code>/inst/docs/RigaSpring.input</code>
</p>
<p>There are 7 functional compartments:
P1,P2,B,N,Z,D,OC
(two phytoplankton groups, Bacteria, Nanozooplankton, Zooplankton,
Detritus and DOC).
</p>
<p>and 2 externals: CO2 and SED (sedimentation)
</p>
<p>These are connected with 26 flows:
P1-&gt;CO2, P2-&gt;CO2, Z-&gt;CO2, N-&gt;CO2, B-&gt;CO2, CO2-&gt;P1, CO2-&gt;P2, P1-&gt;Z, P1-&gt;N,
P1-&gt;DOC, P1-&gt;SED, P2-&gt;DOC, P2-&gt;Z, P2-&gt;D, P2-&gt;SED, N-&gt;DOC, N-&gt;Z, Z-&gt;DOC,
Z-&gt;D, Z-&gt;SED, D-&gt;Z, D-&gt;DOC, D-&gt;SED, B-&gt;N, B-&gt;SED, DOC-&gt;B
</p>
<p>The lsei model contains:
</p>

<ul>
<li><p> 14 equalities (Ax=B): the 7 mass balances (one for each compartment)
and 7 measurement equations
</p>
</li>
<li><p> 26 unknowns (x), the flow values
</p>
</li>
<li><p> 45 inequalities (Gx&gt;h). The first 19 inequalities impose bounds
on some combinations of flows.
The last 26 inequalities impose that the flows have to be positive.
</p>
</li></ul>

<p>As there are more unknowns (26) than equations (14), there exist an
infinite amount of solutions (it is an underdetermined problem).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RigaWeb</code></pre>


<h3>Format</h3>

<p>A list with the matrices and vectors that constitute the mass balance problem:
<code>A</code>, <code>B</code>, <code>G</code> and <code>H</code>.
</p>
<p>The columnames of <code>A</code> and <code>G</code> are the names of the unknown
reaction rates;
The first 14 rownames of <code>A</code> give the names of the components
(these rows consitute the mass balance equations).
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Donali, E., Olli, K., Heiskanen, A.S., Andersen, T., 1999. Carbon flow
patterns in the planktonic food web of the Gulf of Riga, the Baltic Sea:
a reconstruction by the inverse method. Journal of Marine Systems 23,
251..268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- RigaWeb$A
F &lt;- RigaWeb$B
G &lt;- RigaWeb$G
H &lt;- RigaWeb$H

# 1. parsimonious (simplest) solution
pars &lt;- lsei(E = E, F = F, G = G, H = H)$X

# 2.ranges of all unknowns, including the central value
xr   &lt;- xranges(E = E, F = F, G = G, H = H, central = TRUE)

# the central point is a valid solution:
X &lt;- xr[,"central"]
max(abs(E%*%X - F))
min(G%*%X - H)

## Not run:    # this does not work on windows i386!
# 3. Sample solution space; the central value is a good starting point
#   for algorithms cda and rda - but these need many iterations   
xs  &lt;- xsample(E = E, F = F, G = G, H = H,
               iter = 10000, out = 1000, type = "rda", x0 = X)$X
# better convergence using 50000 iterations, but this takes a while
xs  &lt;- xsample(E = E, F = F, G = G, H = H,
               iter = 50000, out = 1000, type = "rda", x0 = X)$X

pairs(xs, pch = ".", cex = 2, gap = 0, upper.panel = NULL)


# using mirror algorithm takes less iterations,
# but an iteration takes more time ; it is better to start in a corner...
# (i.e. no need to use X as starting value)
xs  &lt;- xsample(E = E, F = F, G = G, H = H,
               iter = 1500, output = 500, type = "mirror")$X
pairs(xs, pch = ".", cex = 2, gap = 0, upper.panel = NULL, 
      yaxt = "n", xaxt = "n")

# Print results:
data.frame(pars = pars, xr[ ,1:2], Mean = colMeans(xs), sd = apply(xs, 2, sd))

## End(Not run)
</code></pre>

<hr>
<h2 id='Solve'>
Generalised inverse solution of Ax = B
</h2><span id='topic+Solve'></span>

<h3>Description</h3>

<p>Generalised inverse solution of </p>
<p style="text-align: center;"><code class="reqn">Ax=B</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Solve (A, B = diag(nrow = nrow(A)), tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Solve_+3A_a">A</code></td>
<td>
<p>numeric matrix containing the coefficients of the equations
<code class="reqn">Ax=B</code>.
</p>
</td></tr>
<tr><td><code id="Solve_+3A_b">B</code></td>
<td>
<p>numeric matrix containing the right-hand sides of the equations;
the default is the unity matrix, in which case the function will return
the Moore-Penrose generalized inverse of matrix A.
</p>
</td></tr>
<tr><td><code id="Solve_+3A_tol">tol</code></td>
<td>
<p>tolerance for selecting singular values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the generalised inverse solution.
</p>


<h3>Note</h3>

  
<p><code>Solve</code> uses the Moore-Penrose generalized inverse of matrix <code>A</code>
(function <code><a href="MASS.html#topic+ginv">ginv</a></code> from package MASS).
</p>
<p><code><a href="base.html#topic+solve">solve</a></code>, the <span class="rlang"><b>R</b></span> default requires a square, positive
definite A. <code>Solve</code> does not have this restriction.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>package <code>MASS</code>:
</p>
<p>Venables, W. N. &amp; Ripley, B. D. (2002) Modern Applied
Statistics with S. Fourth Edition. Springer, New
York. ISBN 0-387-95457-0
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code> to estimate the Moore-Penrose generalized inverse
of a matrix, in package <code>MASS</code>,
</p>
<p><code><a href="base.html#topic+solve">solve</a></code> the R default
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(nrow = 4, ncol = 3, data = c(1:8, 6, 8, 10, 12)) # col3 = col1+col2
B &lt;- 0:3
X &lt;- Solve(A, B)            # generalised inverse solution
A %*% X - B                 # should be zero (except for roundoff)
(gA &lt;- Solve(A))           # generalised inverse of A
</code></pre>

<hr>
<h2 id='Solve.banded'>
Solution of a banded system of linear equations
</h2><span id='topic+Solve.banded'></span>

<h3>Description</h3>

<p>Solves the linear system of equations </p>
<p style="text-align: center;"><code class="reqn">Ax = B</code>
</p>
<p> by Gaussion elimination
</p>
<p>where <code>A</code> has to be square, and <em>banded</em>, i.e. with the only nonzero
elements in bands near the diagonal.
</p>
<p>The matrix <code>A</code> is either inputted as a full square matrix or as the non-zero
bands.
</p>
<p>uses lapack subroutine dgbsv (FORTRAN)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Solve.banded(abd, nup, nlow, B = rep(0, times = ncol(abd)),
  full = (nrow(abd) == ncol(abd)))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Solve.banded_+3A_abd">abd</code></td>
<td>
<p>either a matrix containing the (nonzero) bands, rotated row-wise
(anti-clockwise) only, or a full square matrix.
</p>
</td></tr>
<tr><td><code id="Solve.banded_+3A_nup">nup</code></td>
<td>
<p>number of nonzero bands above the diagonal; ignored if <code>full</code>
matrix is inputted.
</p>
</td></tr>
<tr><td><code id="Solve.banded_+3A_nlow">nlow</code></td>
<td>
<p>number of nonzero bands below the diagonal; ignored if <code>full</code>
matrix is inputted.
</p>
</td></tr>
<tr><td><code id="Solve.banded_+3A_b">B</code></td>
<td>
<p>Right-hand side of the equations, a vector with length = number
of rows of <code>A</code>, or a matrix with number of rows = number of rows 
of <code>A</code>.
</p>
</td></tr>
<tr><td><code id="Solve.banded_+3A_full">full</code></td>
<td>
<p>if <code>TRUE</code>: full matrix is inputted,
if <code>FALSE</code>: banded matrix is input.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input matrix <code>abd</code> is square, it is assumed that the full,
square A is inputted, unless <code>full</code> is set to <code>FALSE</code>.
</p>
<p>If <code>abd</code> is not square, then the number of columns denote the
number of unknowns, while the number of rows equals the nonzero bands,
i.e. nup+nlow+1
</p>


<h3>Value</h3>

<p>matrix with the solution, <code>X</code>, of the banded system of equations A X =B,
the number of columns of this matrix = number of columns of <code>B</code>.
</p>


<h3>Note</h3>

<p>A similar function but that requires a totally different input can now 
also be found in the <code>Matrix</code> package
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>J.J. Dongarra, J.R. Bunch, C.B. Moler, G.W. Stewart,
LINPACK Users' Guide, SIAM, 1979.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Solve.tridiag">Solve.tridiag</a></code> to solve a tridiagonal system of linear equations.
</p>
<p><code><a href="#topic+Solve">Solve</a></code> the generalised inverse solution,
</p>
<p><code><a href="base.html#topic+solve">solve</a></code> the R default
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Generate a banded matrix of random numbers, full format
nup  &lt;- 2                         # nr nonzero bands above diagonal
ndwn &lt;- 3                         # nr nonzero bands below diagonal
nn   &lt;- 10                        # nr rows and columns of A
A &lt;- matrix(nrow = nn, ncol = nn, data = runif(1 : (nn*nn)))
A [row(A) &lt; col(A) - nup | row(A) &gt; col(A) + ndwn] &lt;- 0 
diag(A) &lt;- 1                      # 1 on diagonal is easily recognised 

# right hand side
B &lt;- runif(nrow(A))                

# solve it, using the default solver and banded (inputting full matrix)
Full  &lt;- solve(A, B)
Band1 &lt;- Solve.banded(A, nup, ndwn, B)

# 2. create banded form of matrix A
Aext &lt;- rbind(matrix(ncol = ncol(A), nrow = nup, 0),
              A, 
              matrix(ncol = ncol(A), nrow = ndwn, 0))
              
abd  &lt;- matrix(nrow = nup + ndwn + 1, ncol = nn,
               data = Aext[col(Aext) &lt;= row(Aext) &amp; 
                           col(Aext) &gt;= row(Aext) - ndwn - nup])

# print both to screen
A
abd

# solve problem with banded version
Band2 &lt;- Solve.banded(abd, nup, ndwn, B)

# compare 3 methods of solution
cbind(Full, Band1, Band2)

# same, now with 3 different right hand sides
B3 &lt;- cbind(B, B*2, B*3)
Solve.banded(abd, nup, ndwn, B3)

</code></pre>

<hr>
<h2 id='Solve.block'>
Solution of an almost block diagonal system of linear equations
</h2><span id='topic+Solve.block'></span>

<h3>Description</h3>

<p>Solves the linear system A*X=B where A is an almost block diagonal matrix of
the form:
</p>
<p>TopBlock
</p>
<p>...   Array(1)  ... ... ...
</p>
<p>... ...      Array(2)  ... ...
</p>
<p>...
</p>
<p>... ... ...  Array(Nblocks)...
</p>
<p>... ... ...  BotBlock
</p>
<p>The method is based on Gauss elimination with alternate row and column
elimination with partial pivoting, producing a stable decomposition of
the matrix A without introducing fill-in.
</p>
<p>uses FORTRAN subroutine colrow
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Solve.block(Top, AR, Bot, B, overlap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Solve.block_+3A_top">Top</code></td>
<td>
<p>the first block of the almost block diagonal matrix <code>A</code>.
</p>
</td></tr>
<tr><td><code id="Solve.block_+3A_ar">AR</code></td>
<td>
<p>intermediary blocks; <code>AR</code>(.,.,K) contains the kth block of
matrix <code>A</code>.
</p>
</td></tr>
<tr><td><code id="Solve.block_+3A_bot">Bot</code></td>
<td>
<p>the last block of the almost block diagonal matrix <code>A</code>.
</p>
</td></tr>
<tr><td><code id="Solve.block_+3A_b">B</code></td>
<td>
<p>Right-hand side of the equations, a vector with length = number
of rows of <code>A</code>, 
or a matrix with number of rows = number of rows of <code>A</code>.
</p>
</td></tr>
<tr><td><code id="Solve.block_+3A_overlap">overlap</code></td>
<td>
<p>the number of columns in which successive blocks
overlap, and where <code>overlap = nrow(Top) + nrow(Bot)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with the solution, X, of the block diagonal system of equations Ax=B,
the number of columns of this matrix = number of columns of B.
</p>


<h3>Note</h3>

<p>A similar function but that requires a totally different input can now 
also be found in the <code>Matrix</code> package
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>J. C. Diaz , G. Fairweather , P. Keast, 1983.
FORTRAN Packages for Solving Certain Almost Block Diagonal Linear
Systems by Modified Alternate Row and Column Elimination,
ACM Transactions on Mathematical Software (TOMS), v.9 n.3, p.358-375
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Solve.tridiag">Solve.tridiag</a></code> to solve a tridiagonal system of linear equations.
</p>
<p><code><a href="#topic+Solve.banded">Solve.banded</a></code> to solve a banded system of linear equations.
</p>
<p><code><a href="#topic+Solve">Solve</a></code> the generalised inverse solution,
</p>
<p><code><a href="base.html#topic+solve">solve</a></code> the R default
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Solve the following system: Ax=B, where A is block diagonal, and

#  0.0  -0.98 -0.79 -0.15                                                  Top
# -1.00  0.25 -0.87  0.35                                                  Top
#  0.78  0.31 -0.85  0.89 -0.69 -0.98 -0.76 -0.82                          blk1
#  0.12 -0.01  0.75  0.32 -1.00 -0.53 -0.83 -0.98
# -0.58  0.04  0.87  0.38 -1.00 -0.21 -0.93 -0.84
# -0.21 -0.91 -0.09 -0.62 -1.99 -1.12 -1.21  0.07
#                          0.78 -0.93 -0.76  0.48 -0.87 -0.14 -1.00 -0.59  blk2
#                         -0.99  0.21 -0.73 -0.48 -0.93 -0.91  0.10 -0.89
#                         -0.68 -0.09 -0.58 -0.21  0.85 -0.39  0.79 -0.71
#                          0.39 -0.99 -0.12 -0.75 -0.68 -0.99  0.50 -0.88
#                                                  0.71 -0.64  0.0   0.48  Bot
#                                                  0.08 100.0 50.00 15.00  Bot


B &lt;- c(-1.92, -1.27, -2.12, -2.16, -2.27,  -6.08,
       -3.03, -4.62, -1.02, -3.52,  0.55, 165.08)

AA         &lt;- matrix (nrow = 12, ncol = 12, 0)
AA[1,1:4]  &lt;- c( 0.0,  -0.98, -0.79, -0.15)
AA[2,1:4]  &lt;- c(-1.00,  0.25, -0.87,  0.35)
AA[3,1:8]  &lt;- c( 0.78,  0.31, -0.85,  0.89, -0.69, -0.98, -0.76, -0.82)
AA[4,1:8]  &lt;- c( 0.12, -0.01,  0.75,  0.32, -1.00, -0.53, -0.83, -0.98)
AA[5,1:8]  &lt;- c(-0.58,  0.04,  0.87,  0.38, -1.00, -0.21, -0.93, -0.84)
AA[6,1:8]  &lt;- c(-0.21, -0.91, -0.09, -0.62, -1.99, -1.12, -1.21,  0.07)
AA[7,5:12] &lt;- c( 0.78, -0.93, -0.76,  0.48, -0.87, -0.14, -1.00, -0.59)
AA[8,5:12] &lt;- c(-0.99,  0.21, -0.73, -0.48, -0.93, -0.91,  0.10, -0.89)
AA[9,5:12] &lt;- c(-0.68, -0.09, -0.58, -0.21,  0.85, -0.39,  0.79, -0.71)
AA[10,5:12]&lt;- c( 0.39, -0.99, -0.12, -0.75, -0.68, -0.99,  0.50, -0.88)
AA[11,9:12]&lt;- c( 0.71, -0.64,   0.0,  0.48)
AA[12,9:12]&lt;- c( 0.08, 100.0, 50.00, 15.00)

## Block diagonal input.
Top  &lt;- matrix(nrow = 2, ncol = 4, data = AA[1:2  , 1:4] )
Bot  &lt;- matrix(nrow = 2, ncol = 4, data = AA[11:12, 9:12])
Blk1 &lt;- matrix(nrow = 4, ncol = 8, data = AA[3:6  , 1:8] )
Blk2 &lt;- matrix(nrow = 4, ncol = 8, data = AA[7:10 , 5:12])

AR &lt;- array(dim = c(4, 8, 2), data = c(Blk1, Blk2))
overlap &lt;- 4

# answer = (1, 1,....1)
Solve.block(Top, AR, Bot, B, overlap = 4)

# Now with 3 different B values
B3 &lt;- cbind(B, 2*B, 3*B)
Solve.block(Top, AR, Bot, B3, overlap = 4)

</code></pre>

<hr>
<h2 id='Solve.tridiag'>
Solution of a tridiagonal system of linear equations
</h2><span id='topic+Solve.tridiag'></span>

<h3>Description</h3>

<p>Solves the linear system of equations </p>
<p style="text-align: center;"><code class="reqn">Ax=B</code>
</p>

<p>where A has to be square and <em>tridiagonal</em>, i.e with nonzero elements
only on, one band above, and one band below the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Solve.tridiag ( diam1, dia, diap1, B=rep(0,times=length(dia)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Solve.tridiag_+3A_diam1">diam1</code></td>
<td>
<p>a vector with (nonzero) elements below the diagonal.
</p>
</td></tr>
<tr><td><code id="Solve.tridiag_+3A_dia">dia</code></td>
<td>
<p>a vector with (nonzero) elements on the diagonal.
</p>
</td></tr>
<tr><td><code id="Solve.tridiag_+3A_diap1">diap1</code></td>
<td>
<p>a vector with (nonzero) elements above the diagonal.
</p>
</td></tr>
<tr><td><code id="Solve.tridiag_+3A_b">B</code></td>
<td>
<p>Right-hand side of the equations, a vector with length = number
of rows of A, or a matrix with number of rows = number of rows of A.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the length of the vector <code>dia</code> is equal to N, then the lengths of 
<code>diam1</code> and <code>diap1</code> should be equal to N-1
</p>


<h3>Value</h3>

<p>matrix with the solution, <code>X</code>, of the tridiagonal system of equations Ax=B.
The number of columns of this matrix equals the number of columns of B.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Solve.banded">Solve.banded</a></code>, the function to solve a banded system of
linear equations.
</p>
<p><code><a href="#topic+Solve.block">Solve.block</a></code>, the function to solve a block diagonal system of
linear equations.
</p>
<p><code><a href="#topic+Solve">Solve</a></code> the generalised inverse solution,
</p>
<p><code><a href="base.html#topic+solve">solve</a></code> the R default
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create tridagonal system: bands on diagonal, above and below
nn   &lt;- 20                          # nr rows and columns of A
aa   &lt;- runif(nn)
bb   &lt;- runif(nn)
cc   &lt;- runif(nn)

# full matrix
A                        &lt;- matrix(nrow = nn, ncol = nn, data = 0)
diag(A)                  &lt;- bb
A[cbind(1:(nn-1), 2:nn)] &lt;- cc[-nn]
A[cbind(2:nn, 1:(nn-1))] &lt;- aa[-1]
B &lt;- runif(nn)

# solve as full matrix
solve(A, B)                           

# same,  now using tridiagonal algorithm
as.vector(Solve.tridiag(aa[-1], bb, cc[-nn], B))

# same, now with 3 different right hand sides
B3 &lt;- cbind(B, B*2, B*3)
Solve.tridiag(aa[-1], bb, cc[-nn], B3)

</code></pre>

<hr>
<h2 id='varranges'>
Calculates ranges of inverse variables in a linear inverse problem
</h2><span id='topic+varranges'></span>

<h3>Description</h3>

<p>Given the linear constraints
</p>
<p style="text-align: center;"><code class="reqn">Ex=f</code>
</p>

<p style="text-align: center;"><code class="reqn">Gx&gt;=h</code>
</p>

<p>and a set of &quot;variables&quot; described by the linear equations
</p>
<p style="text-align: center;"><code class="reqn">Var = EqA.x+EqB</code>
</p>

<p>finds the minimum and maximum values of the variables
by successively minimising and maximising each variable equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varranges(E=NULL, F=NULL, G=NULL, H=NULL, EqA, EqB=NULL, 
  ispos=FALSE, tol=1e-8, verbose=TRUE, lower=NULL, upper=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varranges_+3A_e">E</code></td>
<td>
<p>numeric matrix containing the coefficients of the equalities
<code class="reqn">Ex=F</code>.
</p>
</td></tr>
<tr><td><code id="varranges_+3A_f">F</code></td>
<td>
<p>numeric vector containing the right-hand side of the
equalities.
</p>
</td></tr>
<tr><td><code id="varranges_+3A_g">G</code></td>
<td>
<p>numeric matrix containing the coefficients of the inequalities
<code class="reqn">Gx&gt;=H</code>.
</p>
</td></tr>
<tr><td><code id="varranges_+3A_h">H</code></td>
<td>
<p>numeric vector containing the right-hand side of the
inequalities.
</p>
</td></tr>
<tr><td><code id="varranges_+3A_eqa">EqA</code></td>
<td>
<p>numeric matrix containing the coefficients that define the
variable equations.
</p>
</td></tr>
<tr><td><code id="varranges_+3A_eqb">EqB</code></td>
<td>
<p>numeric vector containing the right-hand side of the variable
equations.
</p>
</td></tr>
<tr><td><code id="varranges_+3A_ispos">ispos</code></td>
<td>
<p>if <code>TRUE</code>, it is imposed that unknowns are positive
quantities.
</p>
</td></tr>
<tr><td><code id="varranges_+3A_tol">tol</code></td>
<td>
<p>tolerance for equality and inequality constraints.
</p>
</td></tr>
<tr><td><code id="varranges_+3A_verbose">verbose</code></td>
<td>
<p>logical to print warnings and messages.
</p>
</td></tr>
<tr><td><code id="varranges_+3A_upper">upper</code>, <code id="varranges_+3A_lower">lower</code></td>
<td>
<p>vector containing upper and lower bounds 
on the unknowns. If one value, it is assumed to apply to all unknowns.
If a vector, it should have a length equal to the number of unknowns; this
vector can contain NA for unbounded variables. 
The upper and lower bounds are added to the inequality conditions G*x&gt;=H.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2-column matrix with the minimum and maximum value of each equation
(variable)
</p>


<h3>Note</h3>

<p>uses linear programming function <code><a href="lpSolve.html#topic+lp">lp</a></code> from package
<code>lpSolve</code>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Michel Berkelaar and others (2010). lpSolve:
Interface to Lp_solve v. 5.5 to solve linear/integer
programs. R package version 5.6.5.
http://CRAN.R-project.org/package=lpSolve
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Minkdiet">Minkdiet</a></code>, for a description of the Mink diet example.
</p>
<p><code><a href="#topic+xranges">xranges</a></code>, to estimate ranges of inverse unknowns.
</p>
<p><code><a href="#topic+xsample">xsample</a></code>, to randomly sample the lsei problem
</p>
<p><code><a href="lpSolve.html#topic+lp">lp</a></code>: linear programming function from package lpSolve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ranges in the contribution of food 3+4+5 in the diet of Mink (try ?Minkdiet)

E     &lt;- rbind(Minkdiet$Prey, rep(1, 7))
F     &lt;- c(Minkdiet$Mink, 1)
EqA   &lt;- c(0, 0, 1, 1, 1, 0, 0)                    # sum of food 3,4,5
(isoA &lt;- varranges(E, F, EqA = EqA, ispos = TRUE)) # ranges of part of food 3+4+5

# The same, but explicitly imposing positivity
varranges(E, F, EqA = EqA, G = diag(7), H = rep(0, 7)) 

# The same, but shorter - using lower bound:
varranges(E, F, EqA = EqA, lower=0) 

</code></pre>

<hr>
<h2 id='varsample'>
Samples the probability density function of variables of linear inverse problems.
</h2><span id='topic+varsample'></span>

<h3>Description</h3>

<p>Uses random samples of an under- or overdetermined linear problem to
estimate the distribution of equations
</p>
<p>Based on a random sample of x (e.g. produced with <code><a href="#topic+xsample">xsample</a></code>),
produces the corresponding set of &quot;variables&quot; consisting of linear
equations in the unknowns.
</p>
<p style="text-align: center;"><code class="reqn">Var = EqA.x+EqB</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>varsample (X, EqA, EqB=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varsample_+3A_x">X</code></td>
<td>
<p>matrix whose rows contain the sampled values of the unknowns
<code>x</code> in <code class="reqn">EqA*x-EqB</code>.
</p>
</td></tr>
<tr><td><code id="varsample_+3A_eqa">EqA</code></td>
<td>
<p>numeric matrix containing the coefficients that define
the variables.
</p>
</td></tr>
<tr><td><code id="varsample_+3A_eqb">EqB</code></td>
<td>
<p>numeric vector containing the right-hand side of the variable
equation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix whose rows contain the sampled values of the variables.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Minkdiet">Minkdiet</a></code>, for a description of the Mink diet example.
</p>
<p><code><a href="#topic+varranges">varranges</a></code>, to estimate ranges of inverse variables.
</p>
<p><code><a href="#topic+xsample">xsample</a></code>, to randomly sample the lsei problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The probability distribution of vertebrate and invertebrate
# food in the diet of Mink
# food items of Mink are (in that order):

# fish mussels crabs shrimp rodents amphipods ducks
# V    I       I     I      V       I         V 
# V= vertebrate, I = invertebrate

# In matrix form:
VarA &lt;- matrix(ncol = 7, byrow = TRUE, data = c(
        0, 1, 1, 1, 0, 1, 0,   # invertebrates  
        1, 0, 0, 0, 1, 0, 1))  # vertebrates

# first sample the Minkdiet problem
E &lt;- rbind(Minkdiet$Prey, rep(1, 7))
F &lt;- c(Minkdiet$Mink, 1)
X &lt;- xsample(E = E, F = F, G = diag(7), H = rep(0, 7), iter = 1000)$X

#then determine Diet Composition in terms of vertebrate and invertebrate food
DC &lt;- varsample(X = X, EqA = VarA)
hist(DC[,1], freq = FALSE, xlab = "fraction",
     main = "invertebrate food in Mink diet", col = "lightblue")
</code></pre>

<hr>
<h2 id='xranges'>
Calculates ranges of the unknowns of a linear inverse problem
</h2><span id='topic+xranges'></span>

<h3>Description</h3>

<p>Given the linear constraints
</p>
<p style="text-align: center;"><code class="reqn">Ex=f</code>
</p>

<p style="text-align: center;"><code class="reqn">Gx&gt;=h</code>
</p>

<p>finds the minimum and maximum values of all elements of vector <code class="reqn">x</code>
</p>
<p>This is done by successively minimising and maximising each <code>x</code>, 
using linear programming. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xranges(E = NULL, F = NULL, G = NULL, H = NULL, 
        ispos = FALSE, tol = 1e-8, central = FALSE, full=FALSE,
        verbose = TRUE, lower = NULL, upper = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xranges_+3A_e">E</code></td>
<td>
<p>numeric matrix containing the coefficients of the equalities
<code class="reqn">Ex=F</code>.
</p>
</td></tr>
<tr><td><code id="xranges_+3A_f">F</code></td>
<td>
<p>numeric vector containing the right-hand side of the equalities.
</p>
</td></tr>
<tr><td><code id="xranges_+3A_g">G</code></td>
<td>
<p>numeric matrix containing the coefficients of the inequalities
<code class="reqn">Gx&gt;=H</code>.
</p>
</td></tr>
<tr><td><code id="xranges_+3A_h">H</code></td>
<td>
<p>numeric vector containing the right-hand side of the inequalities.
</p>
</td></tr>
<tr><td><code id="xranges_+3A_ispos">ispos</code></td>
<td>
<p>if <code>TRUE</code>, it is imposed that unknowns are positive
quantities.
</p>
</td></tr>
<tr><td><code id="xranges_+3A_tol">tol</code></td>
<td>
<p>tolerance for equality and inequality constraints.
</p>
</td></tr>
<tr><td><code id="xranges_+3A_central">central</code></td>
<td>
<p>if TRUE, the mean value of all range solutions is also
outputted.
</p>
</td></tr>
<tr><td><code id="xranges_+3A_full">full</code></td>
<td>
<p>if <code>TRUE</code>, all range solutions are also outputted.
</p>
</td></tr>
<tr><td><code id="xranges_+3A_verbose">verbose</code></td>
<td>
<p>logical to print warnings and messages.
</p>
</td></tr>
<tr><td><code id="xranges_+3A_upper">upper</code>, <code id="xranges_+3A_lower">lower</code></td>
<td>
<p>vector containing upper and lower bounds 
on the unknowns. If one value, it is assumed to apply to all unknowns.
If a vector, it should have a length equal to the number of unknowns; this
vector can contain NA for unbounded variables. 
The upper and lower bounds are added to the inequality conditions G*x&gt;=H.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ranges are estimated by successively minimising and maximising each
unknown, and using linear programming (based on function <code>lp</code> from 
R-package <code>lpSolve</code>.
</p>
<p>By default linear programming assumes that all unknowns are positive.
If all unknowns are indeed to be positive, then it will generally be faster
to set <code>ispos</code> equal to TRUE
If <code>ispos</code> is <code>FALSE</code>, then a system double the size of the 
original system must be solved.
</p>
<p><code>xranges</code> outputs only the minimum and maximum value of each flow unless:
</p>
<p><code>full</code> is <code>TRUE</code>. In this case, all the results of the successive
minimisation and maximisation will be outputted, i.e. for each linear
programming application, not just the value of the unknown being optimised
but also the corresponding values of the other unknowns will be outputted.
</p>
<p>If <code>central</code> is <code>TRUE</code>, then the mean of all the results of the
linear programming will be outputted.
This may be a good starting value for <code><a href="#topic+xsample">xsample</a></code>
</p>
<p>Note: the columns corresponding to the <code>central</code> value and the
<code>full</code> results are valid solutions of the equations <code class="reqn">Ex=F</code>
and <code class="reqn">Gx&gt;=H</code>. This is not the case for the first two columns (with
the minimal and maximal values).
</p>


<h3>Value</h3>

<p>a matrix with at least two columns:
</p>
<p>column 1 and 2: the minimum and maximum value of each <code>x</code>
</p>
<p>if <code>central</code> is TRUE: column 3 = the central value
</p>
<p>if <code>full</code> is TRUE: next columns contain all valid range solutions
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Michel Berkelaar and others (2010). lpSolve:
Interface to Lp_solve v. 5.5 to solve linear/integer
programs. R package version 5.6.5.
http://CRAN.R-project.org/package=lpSolve
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Minkdiet">Minkdiet</a></code>, for a description of the Mink diet example.
</p>
<p><code><a href="#topic+varranges">varranges</a></code>, for range estimation of variables,
</p>
<p><code><a href="#topic+xsample">xsample</a></code>, to randomly sample the lsei problem
</p>
<p><code><a href="lpSolve.html#topic+lp">lp</a></code>: linear programming from package lpSolve
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate the ranges in the Diet Composition of Mink
E &lt;- rbind(Minkdiet$Prey, rep(1, 7))
F &lt;- c(Minkdiet$Mink, 1)
(DC &lt;- xranges(E, F, ispos = TRUE))

# The same, but explicitly imposing positivity using G and H
xranges(E, F, G = diag(7), H = rep(0, 7))

# and using lower bound
xranges(E, F, lower = 0, verbose = FALSE)

</code></pre>

<hr>
<h2 id='xsample'>
Randomly samples an underdetermined problem with linear equality and
inequality constraints
</h2><span id='topic+xsample'></span>

<h3>Description</h3>

<p>Random sampling of inverse linear problems with linear equality and
inequality constraints.
Uses either a &quot;hit and run&quot; algorithm (random or coordinate directions)
or a mirroring technique for sampling.
</p>
<p>The Markov Chain Monte Carlo method produces a sample solution for
</p>
<p style="text-align: center;"><code class="reqn">Ex=f</code>
</p>

<p style="text-align: center;"><code class="reqn">Ax\simeq B</code>
</p>

<p style="text-align: center;"><code class="reqn">Gx&gt;=h</code>
</p>

<p>where <code class="reqn">Ex=F</code> have to be met exactly, and x is distributed
according to <code class="reqn"> p(\mathbf{x})\propto
  e^{-\frac{1}{2}(\mathbf{Ax-b})^T\mathbf{W}^2(\mathbf{Ax-b})}
  </code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xsample(A = NULL, B = NULL, E = NULL, F =NULL, 
        G = NULL, H = NULL, sdB = NULL, W = 1, 
        iter = 3000, outputlength = iter, burninlength = NULL, 
        type = "mirror", jmp = NULL, tol = sqrt(.Machine$double.eps), 
        x0 = NULL, fulloutput = FALSE, test = TRUE, verbose=TRUE,
        lower = NULL, upper = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xsample_+3A_a">A</code></td>
<td>
<p>numeric matrix containing the coefficients of the
(approximate) equality constraints, <code class="reqn">Ax\simeq B</code>.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_b">B</code></td>
<td>
<p>numeric vector containing the right-hand side of the
(approximate) equality constraints.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_e">E</code></td>
<td>
<p>numeric matrix containing the coefficients of the (exact)
equality constraints, <code class="reqn">Ex=F</code>.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_f">F</code></td>
<td>
<p>numeric vector containing the right-hand side of the
(exact) equality constraints.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_g">G</code></td>
<td>
<p>numeric matrix containing the coefficients of the inequality
constraints, <code class="reqn">Gx&gt;=H</code>.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_h">H</code></td>
<td>
<p>numeric vector containing the right-hand side of the inequality
constraints.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_sdb">sdB</code></td>
<td>
<p>vector with standard deviation on B. Defaults to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_w">W</code></td>
<td>
<p>weighting for <code class="reqn">Ax\simeq B</code>. Only used if
<code>sdB=NULL</code> and the problem is
overdetermined. In that case, the error of B around the model Ax is
estimated based on the residuals of <code class="reqn">Ax\simeq B</code>. This
error is made proportional to 1/W. If sdB is not NULL, <code class="reqn">W=diag(sdB^-1)</code>.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_iter">iter</code></td>
<td>
<p>integer determining the number of iterations.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_outputlength">outputlength</code></td>
<td>
<p> number of iterations kept in the output; at most
equal to <code>iter</code>.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_burninlength">burninlength</code></td>
<td>
<p>a number of extra iterations, performed at first, to
&quot;warm up&quot; the algorithm.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_type">type</code></td>
<td>
<p>type of algorithm: one of: &quot;mirror&quot;, (mirroring algorithm),
&quot;rda&quot; (random directions algorithm) or &quot;cda&quot; (coordinates directions
algorithm).
</p>
</td></tr>
<tr><td><code id="xsample_+3A_jmp">jmp</code></td>
<td>
<p>jump length of the transformed variables q: <code class="reqn">x=x0+Zq</code>
(only if <code>type</code>==&quot;mirror&quot;); if jmp is <code>NULL</code>, a reasonable
value is determined by xsample, depending on the size of the NULL space.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_tol">tol</code></td>
<td>
<p>tolerance for equality and inequality constraints; numbers
whose absolute value is smaller than <code>tol</code> are set to zero.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_x0">x0</code></td>
<td>
<p>initial (particular) solution.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_fulloutput">fulloutput</code></td>
<td>
<p>if <code>TRUE</code>, also outputs the transformed variables q.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_test">test</code></td>
<td>
<p>if <code>TRUE</code>, xsample will test for hidden equalities (see
details). This may be necessary for large problems, but slows down
execution a bit.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_verbose">verbose</code></td>
<td>
<p>logical to print warnings and messages.
</p>
</td></tr>
<tr><td><code id="xsample_+3A_upper">upper</code>, <code id="xsample_+3A_lower">lower</code></td>
<td>
<p>vector containing upper and lower bounds 
on the unknowns. If one value, it is assumed to apply to all unknowns.
If a vector, it should have a length equal to the number of unknowns; this
vector can contain NA for unbounded variables. 
The upper and lower bounds are added to the inequality conditions G*x&gt;=H.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm proceeds in two steps.
</p>

<ol>
<li><p>  the equality constraints <code class="reqn">Ex=F</code> are eliminated, and the
system <code class="reqn">Ex=f</code>, <code class="reqn">Gx&gt;=h</code> is rewritten as <code class="reqn">G(p+Zq)&gt;= h</code>,
i.e. containing only inequality constraints and where Z is a basis for
the null space of E.
</p>
</li>
<li><p>  the distribution of <code class="reqn">q</code> is sampled numerically
using a random walk (based on the Metropolis algorithm).
</p>
</li></ol>

<p>There are three algorithms for selecting new samples: <code>rda</code>,
<code>cda</code> (two hit-and-run algorithms) and a novel <code>mirror</code> algorithm.
</p>

<ul>
<li><p> In the <code>rda</code> algorithm first a random direction is selected,
and the new sample obtained by uniformly sampling the line
connecting the old sample and the intersection with the planes defined
by the inequality constraints.
</p>
</li>
<li><p> the <code>cda</code> algorithm is similar, except that the direction is
chosen along one of the coordinate axes.
</p>
</li>
<li><p> the <code>mirror</code> algorithm is yet unpublished; it uses the
inequality constraints as &quot;reflecting planes&quot; along which jumps are
reflected.
In contrast to <code>cda</code> and <code>rda</code>, this algorithm also works
with unbounded problems (i.e. for which some of the unknowns can attain
Inf).
</p>
</li></ul>

<p>For more information, see the package vignette <code>vignette(xsample)</code> or
the file xsample.pdf in the packages &lsquo;<span class="file">docs</span>&rsquo; subdirectory.
</p>
<p>Raftery and Lewis (1996) suggest a minimum of 3000 iterations to reach
the extremes.
</p>
<p>If provided, then <code>x0</code> should be a valid particular solution (i.e.
<code class="reqn">E*x0=b</code> and <code class="reqn">G*x0&gt;=h</code>), else the algorithm will fail.
</p>
<p>For larger problems, a central solution may be necessary as a starting
point for the <code>rda</code> and <code>cda</code> algorithms.  A good starting
value is provided by the &quot;central&quot; value when running the function
<code><a href="#topic+xranges">xranges</a></code> with option <code>central</code> equal to <code>TRUE</code>.
</p>
<p>If the particular solution (<code>x0</code>) is not provided, then the
parsimonious solution is sought, see <code><a href="#topic+ldei">ldei</a></code>.
</p>
<p>This may however not be the most efficient way to start the algorithm. The
parsimonious solution is usually located near the edges, and the
<code>rda</code> and <code>cda</code> algorithms may not get out of this corner.
The <code>mirror</code> algorithm is insensitive to that. Here it may be even
better to start in a corner (as this position will always never be
reached by random sampling).
</p>
<p>The algorithm will fail if there are hidden equalities. For instance, two
inequalities may together impose an equality on an unknown,
or, inequalities may impose equalities on a linear combination of two or
more unknowns.
</p>
<p>In this case, the basis of the null space Z will be deficient. Therefore,
<code>xsample</code> starts by checking if such hidden equalities exist.
If it is suspected that this is NOT the case, set <code>test</code> to
<code>FALSE</code>. This will speed up execution slightly.
</p>
<p>It is our experience that for small problems either the <code>rda</code> and
<code>cda</code> algorithms are often more efficient.
For really large problems, the <code>mirror</code> algorithm is usually much more
efficient; select a jump length (<code>jmp</code>) that ensures good random
coverage, while still keeping the number of reflections reasonable.
If unsure about the size of jmp, the default will do.
</p>
<p>See <code><a href="#topic+E_coli">E_coli</a></code> for an example where a relatively large problem
is sampled.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>matrix whose rows contain the sampled values of x.
</p>
</td></tr>
<tr><td><code>acceptedratio</code></td>
<td>
<p>ratio of acceptance (i.e. the ratio of the accepted
runs / total iterations).
</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>only returned if <code>fulloutput</code> is <code>TRUE</code>: the
transformed samples Q.
</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>only returned if <code>fulloutput</code> is <code>TRUE</code>: probability
vector for all samples (e.g. one value for each row of <code>X</code>).
</p>
</td></tr>
<tr><td><code>jmp</code></td>
<td>
<p>the jump length used for the random walk. Can be used to
check the automated jump length.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karel Van den Meersche
</p>
<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Van den Meersche K, Soetaert K, Van Oevelen D (2009). xsample(): An R
Function for Sampling Linear Inverse Problems.
Journal of Statistical Software, Code Snippets, 30(1), 1-15.
</p>
<p><a href="https://www.jstatsoft.org/v30/c01/">https://www.jstatsoft.org/v30/c01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Minkdiet">Minkdiet</a></code>, for a description of the Mink diet example.
</p>
<p><code><a href="#topic+ldei">ldei</a></code>, to find the least distance solution
</p>
<p><code><a href="#topic+lsei">lsei</a></code>, to find the least squares solution
</p>
<p><code><a href="#topic+varsample">varsample</a></code>, to randomly sample variables of an lsei problem.
</p>
<p><code><a href="#topic+varranges">varranges</a></code>, to estimate ranges of inverse variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------------------------------------------------------------------------------
# A simple problem
#-------------------------------------------------------------------------------
# Sample the probability density function of x1,...x4
# subject to:
# x1 + x2       + x4 = 3
#      x2  -x3  + x4 = -1
# xi   &gt; 0

E &lt;- matrix(nrow = 2, byrow = TRUE, data = c(1, 1, 0,  1,
                                             0, 1, -1, 1))
F   &lt;- c(3, -1)

xs  &lt;- xsample(E = E, F = F, lower = 0)
pairs(xs)

#-------------------------------------------------------------------------------
# Sample the underdetermined Mink diet problem
#-------------------------------------------------------------------------------
E &lt;- rbind(Minkdiet$Prey, rep(1, 7))
F &lt;- c(Minkdiet$Mink, 1)

# Here the Requirement x &gt; 0 is been inposed in G and H.
pairs(xsample(E = E, F = F, G = diag(7), H = rep(0, 7), iter = 5000,
      output = 1000, type = "cda")$X,
      main = "Minkdiet 1000 solutions, - cda")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
