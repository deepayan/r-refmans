<!DOCTYPE html><html><head><title>Help for package kohonen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kohonen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kohonen-package'>
<p>Supervised and Unsupervised Self-Organising Maps</p></a></li>
<li><a href='#check.whatmap'><p>Check the validity of a whatmap argument</p></a></li>
<li><a href='#classvec2classmat'><p>Convert a classification vector into a matrix or the other way around.</p></a></li>
<li><a href='#degelder'><p>Powder pattern data by Rene de Gelder</p></a></li>
<li><a href='#expandMap'><p>Expand a self-organising map</p></a></li>
<li><a href='#getCodes'><p>Extract codebook vectors from a kohonen object</p></a></li>
<li><a href='#layer.distances'><p>Assessing distances to winning units</p></a></li>
<li><a href='#map.kohonen'><p>Map data to a supervised or unsupervised SOM</p></a></li>
<li><a href='#nir'><p>Near-infrared data with temperature effects</p></a></li>
<li><a href='#object.distances'><p>Calculate distances between object vectors in a SOM</p></a></li>
<li><a href='#peppaPic'><p>Synthetic image of a pepper plant with peppers</p></a></li>
<li><a href='#plot.kohonen'><p>Plot kohonen object</p></a></li>
<li><a href='#predict.kohonen'><p>Predict properties using a trained Kohonen map</p></a></li>
<li><a href='#summary.kohonen'><p>Summary and print methods for kohonen objects</p></a></li>
<li><a href='#supersom'><p>Self- and super-organising maps</p></a></li>
<li><a href='#tricolor'><p>Provides smooth unit colors for SOMs</p></a></li>
<li><a href='#unit.distances'><p>SOM-grid related functions</p></a></li>
<li><a href='#wines'><p>Wine data</p></a></li>
<li><a href='#yeast'><p>Yeast cell-cycle data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.0.12</td>
</tr>
<tr>
<td>Title:</td>
<td>Supervised and Unsupervised Self-Organising Maps</td>
</tr>
<tr>
<td>Author:</td>
<td>Ron Wehrens and Johannes Kruisselbrink</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ron Wehrens &lt;ron.wehrens@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to train self-organising maps (SOMs). Also interrogation of the maps and prediction using trained maps are supported. The name of the package refers to Teuvo Kohonen, the inventor of the SOM.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.12)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-09 07:22:08 UTC; ron</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-09 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='kohonen-package'>
Supervised and Unsupervised Self-Organising Maps
</h2><span id='topic+kohonen-package'></span><span id='topic+kohonen'></span>

<h3>Description</h3>

<p>Functions to train self-organising maps (SOMs). Also interrogation of the maps and prediction using trained maps are supported. The name of the package refers to Teuvo Kohonen, the inventor of the SOM.
</p>


<h3>Details</h3>

<p>The kohonen package implements several forms of self-organising maps
(SOMs). Online and batch training algorithms are available; batch
training can also be done in parallel. Multiple data layers may be
presented to the training algorithm, with potentially different distance
measures for each layer. The overall distance is a weighted average of
the layer distances. Layers may be selected through the <code>whatmap</code>
argument, or by providing a weight of zero. The basic function is
<code>supersom</code>; <code>som</code> is simply a wrapper for SOMs using just one
layer (the classical form).
</p>
<p>New data may be mapped to a trained SOM using the <code>map.kohonen</code>
function. Function <code>predict.kohonen</code> will map data to the SOM, and
will return predictions (i.e., average values for winning units) for
those layers that are not in the new data object.
</p>
<p>Several visualisation methods are available in function
<code>plot.kohonen</code>. 
</p>

<p>Index of help topics:
</p>
<pre>
check.whatmap           Check the validity of a whatmap argument
classvec2classmat       Convert a classification vector into a matrix
                        or the other way around.
degelder                Powder pattern data by Rene de Gelder
expandMap               Expand a self-organising map
getCodes                Extract codebook vectors from a kohonen object
kohonen-package         Supervised and Unsupervised Self-Organising
                        Maps
layer.distances         Assessing distances to winning units
map.kohonen             Map data to a supervised or unsupervised SOM
nir                     Near-infrared data with temperature effects
object.distances        Calculate distances between object vectors in a
                        SOM
peppaPic                Synthetic image of a pepper plant with peppers
plot.kohonen            Plot kohonen object
predict.kohonen         Predict properties using a trained Kohonen map
summary.kohonen         Summary and print methods for kohonen objects
supersom                Self- and super-organising maps
tricolor                Provides smooth unit colors for SOMs
unit.distances          SOM-grid related functions
wines                   Wine data
yeast                   Yeast cell-cycle data
</pre>


<h3>Author(s)</h3>

<p>Ron Wehrens and Johannes Kruisselbrink
</p>
<p>Maintainer: Ron Wehrens &lt;ron.wehrens@gmail.com&gt;
</p>


<h3>References</h3>

<p>R. Wehrens and J. Kruisselbrink: Flexible Self-Organising Maps in
kohonen 3.0. Journal of Statistical Software, 87, 7 (2018).</p>

<hr>
<h2 id='check.whatmap'>Check the validity of a whatmap argument</h2><span id='topic+check.whatmap'></span>

<h3>Description</h3>

<p>Not meant to be called directly by the user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.whatmap(x, whatmap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.whatmap_+3A_x">x</code></td>
<td>
<p>A <code>kohonen</code> object, or a
list of data matrices that can be used as input data for SOM functions.</p>
</td></tr>
<tr><td><code id="check.whatmap_+3A_whatmap">whatmap</code></td>
<td>
<p>An indication of a subset of the data; either by naming
the elements, or giving indices. If <code>whatmap</code> equals NULL, the
selection of <code>x</code> is used if <code>x</code> is a <code>kohonen</code>
object, or else no selection is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numerical vector with the indices of the selected layers. An
invalid selection leads to an error.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>

<hr>
<h2 id='classvec2classmat'>Convert a classification vector into a matrix or the other way around.</h2><span id='topic+classvec2classmat'></span><span id='topic+classmat2classvec'></span>

<h3>Description</h3>

<p>Functions toggle between a matrix representation, where class
membership is indicated with one '1' and for the rest zeros at each
row, and a factor. The classification matrix contains one column per
class. Conversion from a class matrix to a class vector assigns each
row to the column with the highest value. An optional argument can be
used to assign only those objects that have a probability higher than
a certain threshold (default is 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classvec2classmat(yvec)
classmat2classvec(ymat, threshold=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classvec2classmat_+3A_yvec">yvec</code></td>
<td>
<p>class vector. Usually a factor; if it is a vector of
integer values, it will be converted to a factor.</p>
</td></tr>
<tr><td><code id="classvec2classmat_+3A_ymat">ymat</code></td>
<td>
<p>class matrix: every column corresponds to a class.</p>
</td></tr>
<tr><td><code id="classvec2classmat_+3A_threshold">threshold</code></td>
<td>
<p>only classify into a class if the probability is
larger than this threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>classvec2classmat</code> returns the classification matrix, where each
column consists of zeros and ones; <code>classmat2classvec</code> returns a
factor.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+som">som</a></code>,<code><a href="#topic+xyf">xyf</a></code>,<code><a href="#topic+supersom">supersom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>classes &lt;- c(rep(1, 5), rep(2, 7), rep(3, 9))
classmat &lt;- classvec2classmat(classes)
classmat
classmat2classvec(classmat)
</code></pre>

<hr>
<h2 id='degelder'>Powder pattern data by Rene de Gelder</h2><span id='topic+degelder'></span>

<h3>Description</h3>

<p>X-ray powder patterns of 131 crystallographic structures, contributed
by Rene de Gelder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(degelder)</code></pre>


<h3>Format</h3>

<p>This yields a list with three components: the first component,
'&quot;patterns&quot;', is a matrix of 131 rows and 441 variables, containing
the powder patterns; the second component is &quot;thetas&quot;, the 2theta values
at which intensities have been measured. The final component,
'&quot;properties&quot;', gives information on the crystallographic properties
of the structures.
</p>


<h3>Source</h3>

<p>Rene de Gelder, Institute of Molecules and Materials, Radboud
University Nijmegen.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(degelder)
mydata &lt;- list(patterns = degelder$patterns,
               CellVol = log(degelder$properties[,"cell.vol"]))

## custom distance function
require(Rcpp)
sourceCpp(system.file("Distances", "wcc.cpp", package = "kohonen"))
set.seed(7)
powsom &lt;- supersom(data = mydata, grid = somgrid(6, 4, "hexagonal"),
                   dist.fcts = c("WCCd", "sumofsquares"),
                   keep.data = TRUE)
summary(powsom)		   

## End(Not run)
</code></pre>

<hr>
<h2 id='expandMap'>Expand a self-organising map</h2><span id='topic+expandMap'></span>

<h3>Description</h3>

<p>Double the size of a map, imputing the codebookvectors of the new units
by averiging their immediate neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandMap(kohobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandMap_+3A_kohobj">kohobj</code></td>
<td>
<p>Object of class <code>"kohonen"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new kohonen object, with a double size.</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(yeast)
yeast.supersom &lt;- supersom(yeast, somgrid(4, 4, "hexagonal"),
                           whatmap = 3:6, maxNA.fraction = .5)
yeast.supersom2 &lt;- expandMap(yeast.supersom)
yeast.supersom3 &lt;- supersom(yeast, yeast.supersom2$grid,
                            whatmap = 3:6, maxNA.fraction = .5,
                            init = yeast.supersom2$codes[3:6])
</code></pre>

<hr>
<h2 id='getCodes'>Extract codebook vectors from a kohonen object</h2><span id='topic+getCodes'></span>

<h3>Description</h3>

<p>Utility function for extracting codebook vectors. These
are present as a list element in a <code>kohonen</code> object, and
themselves are a list as well, with one entry for each data
layer. This function returns either a list of codebook matrices (if
more layers are selected), or just one matrix (if one layer is
selected).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCodes(x, idx = 1:length(codes))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCodes_+3A_x">x</code></td>
<td>
<p>An object of class <code>kohonen</code>.</p>
</td></tr>
<tr><td><code id="getCodes_+3A_idx">idx</code></td>
<td>
<p>Indices of the layer(s) for which codebook vectors are
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>idx</code> is a single number, a matrix of codebook vectors;
if it is a vector of numbers, a list of codebook matrices.</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+supersom">supersom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)
set.seed(7)
som.wines &lt;- som(scale(wines), grid = somgrid(5, 5, "hexagonal"))
dim(getCodes(som.wines))
</code></pre>

<hr>
<h2 id='layer.distances'>Assessing distances to winning units</h2><span id='topic+layer.distances'></span><span id='topic+dist2WU'></span>

<h3>Description</h3>

<p>Given a trained SOM, distances of individual objects to their closest
units may be calculated with function <code>dist2WU</code>. Aggregation on
the unit level is obtained through the function
<code>layer.distances</code>. The latter function is the workhorse for the
&quot;quality&quot; plots in function <code>plot.kohonen</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer.distances(kohobj, whatmap, data, classif = NULL)
dist2WU(kohobj, whatmap, data, classif = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layer.distances_+3A_kohobj">kohobj</code></td>
<td>
<p>A trained <code>kohonen</code> object. Data and mapping
results should be included.</p>
</td></tr>
<tr><td><code id="layer.distances_+3A_whatmap">whatmap</code></td>
<td>
<p>What layers to take into account - default is to consider
all layers used in training. Also single layers may be chosen. Note
that although the underlying C code can also calculate results for
any subset, currently subsets larger than one are forbidden.</p>
</td></tr>
<tr><td><code id="layer.distances_+3A_data">data</code></td>
<td>
<p>Data to use - default is to use the data from the trained SOM.</p>
</td></tr>
<tr><td><code id="layer.distances_+3A_classif">classif</code></td>
<td>
<p>Classification vector, corresponding to the
<code>unit.classif</code> element of a <code>kohonen</code> object. It can also
be provided explicitly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results will be weighted using both the user weights and
distance weights. Summing all the results for individual layers
therefore would lead to the <code>unit.classif</code> vector of the
<code>kohonen</code> object.</p>


<h3>Value</h3>

<p>Function <code>dist2WU</code> returns a vector, representing for each
object the distance to its winning unit. Function
<code>layer.distances</code> returns (as a vector) for each unit the average
distance of objects for which it is the winning unit.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p>Quality plots from <code><a href="#topic+plot.kohonen">plot.kohonen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(kohonen)
data(wines)
wines.sc &lt;- scale(wines)
set.seed(7)
xyf.wines &lt;- xyf(wines.sc, vintages, grid = somgrid(5, 5, "hexagonal"))
dist2WU(xyf.wines, whatmap = 1)
plot(xyf.wines, "quality", whatmap = 1)
plot(xyf.wines, "property",
     property = layer.distances(xyf.wines, whatmap = 1))
</code></pre>

<hr>
<h2 id='map.kohonen'>Map data to a supervised or unsupervised SOM</h2><span id='topic+map.kohonen'></span><span id='topic+map'></span>

<h3>Description</h3>

<p>Map a data matrix onto a trained SOM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kohonen'
map(x, newdata, whatmap = NULL, user.weights = NULL,
                      maxNA.fraction = x$maxNA.fraction, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.kohonen_+3A_x">x</code></td>
<td>
<p>An object of class <code>kohonen</code>.</p>
</td></tr>
<tr><td><code id="map.kohonen_+3A_newdata">newdata</code></td>
<td>
<p>list of data matrices (numerical) of factors, equal to
the <code>data</code> argument of the <code>supersom</code> function. No
<code>data.frame</code> objects are allowed.</p>
</td></tr>
<tr><td><code id="map.kohonen_+3A_whatmap">whatmap</code>, <code id="map.kohonen_+3A_user.weights">user.weights</code>, <code id="map.kohonen_+3A_maxna.fraction">maxNA.fraction</code></td>
<td>
<p>parameters that usually will
be taken from the <code>x</code> object, but can be supplied by the user
as well. Note that it is not possible to change distance functions
from the ones used in training the map.
See <code><a href="#topic+supersom">supersom</a></code> for more information.</p>
</td></tr>
<tr><td><code id="map.kohonen_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>unit.classif</code></td>
<td>
<p>a vector of units that are closest to the objects
in the data matrix.</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>distances of the objects to the closest
units. Distance measures are the same ones used in training the map.</p>
</td></tr>
<tr><td><code>whatmap</code>, <code>user.weights</code></td>
<td>
<p>Values used for these arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.kohonen">predict.kohonen</a></code>, <code><a href="#topic+supersom">supersom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)
set.seed(7)

training &lt;- sample(nrow(wines), 150)
Xtraining &lt;- scale(wines[training, ])
somnet &lt;- som(Xtraining, somgrid(5, 5, "hexagonal"))

map(somnet,
    scale(wines[-training, ],
          center=attr(Xtraining, "scaled:center"),
          scale=attr(Xtraining, "scaled:scale")))
</code></pre>

<hr>
<h2 id='nir'>Near-infrared data with temperature effects</h2><span id='topic+nir'></span>

<h3>Description</h3>

<p>A data object containing near-infrared spectra of ternary
mixtures of ethanol, water and iso-propanol, measured at five
different temperatures (30, 40, ..., 70 degrees Centigrade). </p>


<h3>References</h3>

<p>F. Wulfert , W.Th. Kok, A.K. Smilde: Anal. Chem. 1998, 1761-1767</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(nir)

  set.seed(3)
  nirnet &lt;- xyf(X = nir$spectra[nir$training,],
                Y = nir$composition[nir$training,],
                user.weights = c(3,1),
                grid = somgrid(6, 6, "hexagonal"), rlen=500)
  plot(nirnet, "counts", main="Counts")

  ## Focus on compound 2 (water):
  par(mfrow = c(1,2))
  set.seed(13)
  nirnet &lt;- xyf(X = nir$spectra[nir$training,],
                Y = nir$composition[nir$training, 2, drop = FALSE],
                grid = somgrid(6, 6, "hexagonal"), rlen=500)
  water.xyf &lt;-
    predict(nirnet, newdata = nir$spectra[nir$training,],
            unit.predictions = getCodes(nirnet, 2),
            whatmap = 1)$prediction
  plot(nirnet, "property", property = water.xyf[[1]],
       main="Prediction of water content")
  ## Plot temperatures as circles
  symbols(nirnet$grid$pts[nirnet$unit.classif,] +
          matrix(rnorm(sum(nir$training)*2, sd=.1), ncol=2),
	  circles = (nir$temperature[nir$training] - 20)/250,
	  inches = FALSE, add = TRUE)

  ## Model temperatures
  set.seed(13)
  nirnet2 &lt;- xyf(X = nir$spectra[nir$training,],
                 Y = matrix(nir$temperature[nir$training], ncol = 1),
                 user.weights = c(1,3),
                 grid = somgrid(6, 6, "hexagonal"), rlen=500)
  temp.xyf &lt;- predict(nirnet2, newdata = nir$spectra[nir$training,],
                      unit.predictions = getCodes(nirnet2, 2),
                      whatmap = 1)$prediction

  plot(nirnet2, "property", property = temp.xyf[[1]],
       palette.name = rainbow,
       main="Prediction of temperatures")
  ## Plot concentrations of water as circles
  symbols(nirnet2$grid$pts[nirnet2$unit.classif,] +
          matrix(rnorm(sum(nir$training)*2, sd=.1), ncol=2),
	  circles = 0.05 + 0.4 * nir$composition[nir$training,2],
	  inches = FALSE, add = TRUE)
</code></pre>

<hr>
<h2 id='object.distances'>Calculate distances between object vectors in a SOM</h2><span id='topic+object.distances'></span>

<h3>Description</h3>

<p>This function calculates the distance between objects using the distance
functions, weights and other attributes of a trained SOM. This function
is used in the calculation of the U matrix in function
<code>plot.kohonen</code> using the <code>type = "dist.neighbours" argument.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object.distances(kohobj, type = c("data", "codes"), whatmap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object.distances_+3A_kohobj">kohobj</code></td>
<td>
<p>An object of class <code>kohonen</code>.</p>
</td></tr>
<tr><td><code id="object.distances_+3A_type">type</code></td>
<td>
<p>Whether to calculate distances between the data objects,
or the codebook vectors.</p>
</td></tr>
<tr><td><code id="object.distances_+3A_whatmap">whatmap</code></td>
<td>
<p>What data layers to use. If unspecified the data layers
defined in the kohonen object are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dist</code>, which can be directly fed into
(e.g.) a hierarchical clustering.</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>References</h3>

<p>R. Wehrens and J. Kruisselbrink, submitted, 2017.</p>


<h3>See Also</h3>

<p><code><a href="#topic+unit.distances">unit.distances</a></code>, <code><a href="#topic+supersom">supersom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)
set.seed(7)
sommap &lt;- supersom(list(measurements = scale(wines),
                        vintages = vintages),
                   grid = somgrid(6, 4, "hexagonal"))
obj.dists &lt;- object.distances(sommap, type = "data")
code.dists &lt;- object.distances(sommap, type = "codes")
</code></pre>

<hr>
<h2 id='peppaPic'>Synthetic image of a pepper plant with peppers</h2><span id='topic+peppaPic'></span>

<h3>Description</h3>

<p>A data matrix with four columns representing a 600 by 800
image of a pepper plant. Each row is a pixel in the image. The first
column is the class label; the other columns contain the RGB values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("peppaPic")</code></pre>


<h3>Source</h3>

<p>http://dx.doi.org/10.4121/uuid:884958f5-b868-46e1-b3d8-a0b5d91b02c0
</p>


<h3>References</h3>

<p>This is image 10039 from a set of 10,500 images described in
</p>
<p>Barth R, IJsselmuiden J, Hemming J, and van Henten E (2017). &quot;Data
Synthesis Methods for Semantic Segmentation in Agriculture. A Capsicum
annuum Dataset.&quot; Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(peppaPic)
head(peppaPic)
## show ground truth per pixel
image(t(matrix(peppaPic[,1], 600, 800))[,600:1], col = rainbow(10))
</code></pre>

<hr>
<h2 id='plot.kohonen'>Plot kohonen object</h2><span id='topic+plot.kohonen'></span><span id='topic+identify.kohonen'></span><span id='topic+add.cluster.boundaries'></span>

<h3>Description</h3>

<p>Plot objects of class <code>kohonen</code>. Several types
of plots are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kohonen'
plot(x, type = c("codes", "changes", "counts",
                       "dist.neighbours", "mapping", "property", "quality"),
                       whatmap = NULL, classif = NULL, labels = NULL,
                       pchs = NULL, main = NULL, palette.name = NULL,
                       ncolors, bgcol = NULL, zlim = NULL,
                       heatkey = TRUE, property, codeRendering = NULL,
                       keepMargins = FALSE, heatkeywidth = .2,
                       shape = c("round", "straight"), border = "black",
                       na.color = "gray", ...)
## S3 method for class 'kohonen'
identify(x, ...)
add.cluster.boundaries(x, clustering, lwd = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.kohonen_+3A_x">x</code></td>
<td>
<p>kohonen object.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_type">type</code></td>
<td>
<p>type of plot. (Wow!)</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_whatmap">whatmap</code></td>
<td>
<p>For a &quot;codes&quot; plot: what maps
to show; for the &quot;dist.neighbours&quot; plot: what maps to take into
account when calculating distances to neighbouring units.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_classif">classif</code></td>
<td>
<p>classification object, as returned by
<code>predict.kohonen</code>, or vector of unit numbers.
Only needed if <code>type</code> equals &quot;mapping&quot; and
&quot;counts&quot;.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_labels">labels</code></td>
<td>
<p>labels to plot when <code>type</code> equals
&quot;mapping&quot;.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_pchs">pchs</code></td>
<td>
<p>symbols to plot when <code>type</code> equals
&quot;mapping&quot;.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_main">main</code></td>
<td>
<p>title of the plot.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_palette.name">palette.name</code></td>
<td>
<p>colors to use as unit background for &quot;codes&quot;,
&quot;counts&quot;, &quot;prediction&quot;, &quot;property&quot;, and &quot;quality&quot; plotting types.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_ncolors">ncolors</code></td>
<td>
<p>number of colors to use for the unit
backgrounds. Default is 20 for continuous data, and the number of
distinct values (if less than 20) for categorical data.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_bgcol">bgcol</code></td>
<td>
<p>optional argument to colour the unit backgrounds for the
&quot;mapping&quot; and &quot;codes&quot; plotting type. Defaults to &quot;gray&quot; and
&quot;transparent&quot; in both types, respectively.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_zlim">zlim</code></td>
<td>
<p>optional range for color coding of unit backgrounds.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_heatkey">heatkey</code></td>
<td>
<p>whether or not to generate a heatkey at the left side
of the plot in the &quot;property&quot; and &quot;counts&quot; plotting types.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_property">property</code></td>
<td>
<p>values to use with the &quot;property&quot; plotting
type.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_coderendering">codeRendering</code></td>
<td>
<p>How to show the codes. Possible choices:
&quot;segments&quot;, &quot;stars&quot; and &quot;lines&quot;.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_keepmargins">keepMargins</code></td>
<td>
<p>if <code>FALSE</code> (the default), restore the original
graphical parameters after plotting the kohonen map. If <code>TRUE</code>,
one retains the map coordinate system so that one can add symbols to
the plot, or map unit numbers using the <code>identify</code> function.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_heatkeywidth">heatkeywidth</code></td>
<td>
<p>width of the colour key; the default of 0.2 should
work in most cases but in some cases, e.g. when plotting multiple
figures, it may need to be adjusted.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_shape">shape</code></td>
<td>
<p>kind shape to be drawn: &quot;round&quot; (circle) or &quot;straight&quot;.
Choosing &quot;straight&quot; produces a map of squares when the grid is
&quot;rectangular&quot;, and produces a map of hexagons when the grid is
&quot;hexagonal&quot;.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_border">border</code></td>
<td>
<p>color of the shape's border.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_na.color">na.color</code></td>
<td>
<p>background color matching NA - default &quot;gray&quot;.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_lwd">lwd</code>, <code id="plot.kohonen_+3A_...">...</code></td>
<td>
<p>other graphical parameters.</p>
</td></tr>
<tr><td><code id="plot.kohonen_+3A_clustering">clustering</code></td>
<td>
<p>cluster labels of the map units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several different types of plots are supported:
</p>

<dl>
<dt>&quot;changes&quot;</dt><dd><p>shows the mean distance to the closest codebook vector
during training.</p>
</dd>
<dt>&quot;codes&quot;</dt><dd><p>shows the codebook vectors.</p>
</dd>
<dt>&quot;counts&quot;</dt><dd><p>shows the number of objects mapped to the
individual units. Empty units are depicted in gray.</p>
</dd>
<dt>&quot;dist.neighbours&quot;</dt><dd><p>shows the sum of the distances to all
immediate neighbours. This kind of visualisation is also known as
a U-matrix plot. Units near a class boundary can be expected to
have higher average distances to their neighbours. Only available
for the &quot;som&quot; and &quot;supersom&quot; maps, for the moment.</p>
</dd>
<dt>&quot;mapping&quot;</dt><dd><p>shows where objects are mapped. It
needs the &quot;classif&quot; argument, and a &quot;labels&quot; or &quot;pchs&quot;
argument.</p>
</dd>
<dt>&quot;property&quot;</dt><dd><p>properties of each unit can be calculated and
shown in colour code. It can be used to visualise the similarity
of one particular object to all units in the map, to show the mean
similarity of all units and the objects mapped to them,
etcetera. The parameter <code>property</code> contains the numerical
values. See examples below.</p>
</dd>
<dt>&quot;quality&quot;</dt><dd><p>shows the mean distance of objects mapped to a
unit to the codebook vector of that unit. The smaller the
distances, the better the objects are represented by the codebook
vectors. It is possible to visualize this for the complete set of
layers used in training, or for individual layers only (using the
<code>whatmap</code> argument).</p>
</dd>
</dl>

<p>Function <code>identify.kohonen</code> shows the number of a unit that is
clicked on with the mouse. The tolerance is calculated from the ratio
of the plotting region and the user coordinates, so clicking at any
place within a unit should work.
</p>
<p>Function <code>add.cluster.boundaries</code> will add to an existing plot of
a map thick lines, visualizing which units would be clustered
together. In toroidal maps, boundaries at the edges will only be shown
on the top and right sides to avoid double boundaries.
</p>


<h3>Value</h3>

<p>Several types of plots return useful values (invisibly): the
<code>"counts"</code>, <code>"dist.neighbours"</code>, and <code>"quality"</code> return
vectors corresponding to the information visualized in the plot (unit
background colours and heatkey).
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+som">som</a></code>, <code><a href="#topic+supersom">supersom</a></code>, <code><a href="#topic+xyf">xyf</a></code>,
<code><a href="#topic+predict.kohonen">predict.kohonen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)
set.seed(7)

kohmap &lt;- xyf(scale(wines), vintages,
              grid = somgrid(5, 5, "hexagonal"), rlen=100)
plot(kohmap, type="changes")
counts &lt;- plot(kohmap, type="counts", shape = "straight")

## show both sets of codebook vectors in the map
par(mfrow = c(1,2))
plot(kohmap, type="codes", main = c("Codes X", "Codes Y"))

par(mfrow = c(1,1))
similarities &lt;- plot(kohmap, type="quality", palette.name = terrain.colors)
plot(kohmap, type="mapping",
     labels = as.integer(vintages), col = as.integer(vintages),
     main = "mapping plot")

## add background colors to units according to their predicted class labels
xyfpredictions &lt;- classmat2classvec(getCodes(kohmap, 2))
bgcols &lt;- c("gray", "pink", "lightgreen")
plot(kohmap, type="mapping", col = as.integer(vintages),
     pchs = as.integer(vintages), bgcol = bgcols[as.integer(xyfpredictions)],
     main = "another mapping plot", shape = "straight", border = NA)

## Show 'component planes'
set.seed(7)
sommap &lt;- som(scale(wines), grid = somgrid(6, 4, "hexagonal"))
plot(sommap, type = "property", property = getCodes(sommap, 1)[,1],
     main = colnames(getCodes(sommap, 1))[1])

## Show the U matrix
Umat &lt;- plot(sommap, type="dist.neighbours", main = "SOM neighbour distances")
## use hierarchical clustering to cluster the codebook vectors
som.hc &lt;- cutree(hclust(object.distances(sommap, "codes")), 5)
add.cluster.boundaries(sommap, som.hc)

## and the same for rectangular maps
set.seed(7)
sommap &lt;- som(scale(wines),grid = somgrid(6, 4, "rectangular"))
plot(sommap, type="dist.neighbours", main = "SOM neighbour distances")
## use hierarchical clustering to cluster the codebook vectors
som.hc &lt;- cutree(hclust(object.distances(sommap, "codes")), 5)
add.cluster.boundaries(sommap, som.hc)
</code></pre>

<hr>
<h2 id='predict.kohonen'>Predict properties using a trained Kohonen map</h2><span id='topic+predict.kohonen'></span>

<h3>Description</h3>

<p>Map objects to a trained Kohonen map, and return for each object the
desired property associated with the corresponding winning
unit. These properties may be provided explicitly (argument
<code>unit.predictions</code>) or implicitly (by providing
<code>trainingdata</code>, that will be mapped to the SOM - the averages of
the winning units for the trainingdata then will be used as
unit.predictions). If not given at all, the codebook vectors of the
map will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kohonen'
predict(object,
                          newdata = NULL,
                          unit.predictions = NULL,
                          trainingdata = NULL,
                          whatmap = NULL,
                          threshold = 0,
                          maxNA.fraction = object$maxNA.fraction,
                          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.kohonen_+3A_object">object</code></td>
<td>
<p>Trained network, containing one or more information layers.</p>
</td></tr>
<tr><td><code id="predict.kohonen_+3A_newdata">newdata</code></td>
<td>
<p>List of data matrices, or one single data matrix, for
which predictions are to be made. The data layers should match those
in the trained map. If not presented, the training data in the map
will be used. No <code>data.frame</code> objects are allowed.</p>
</td></tr>
<tr><td><code id="predict.kohonen_+3A_unit.predictions">unit.predictions</code></td>
<td>
<p>Explicit definition of the predictions for each
unit. Should be a list of matrices, vectors or factors, of the same
length as <code>object$codes</code>.</p>
</td></tr>
<tr><td><code id="predict.kohonen_+3A_trainingdata">trainingdata</code></td>
<td>
<p>List of data matrices, or one single data matrix,
determining the mapping of the training data. Normally, data stored
in the <code>kohonen</code> object will be used for this, but one can also
specify this argument explicitly. Layers should match the trained map.</p>
</td></tr>
<tr><td><code id="predict.kohonen_+3A_whatmap">whatmap</code>, <code id="predict.kohonen_+3A_maxna.fraction">maxNA.fraction</code></td>
<td>
<p>parameters that usually will
be taken from the <code>x</code> object, but can be supplied by the user
as well. See <code><a href="#topic+supersom">supersom</a></code> for more information.</p>
</td></tr>
<tr><td><code id="predict.kohonen_+3A_threshold">threshold</code></td>
<td>
<p>Used in converting class predictions back into
factors; see <code><a href="#topic+classmat2classvec">classmat2classvec</a></code>.</p>
</td></tr>
<tr><td><code id="predict.kohonen_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>map.kohonen</code>, in
particular <code>user.weights</code>. If not provided will be taken from
<code>object</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new data are mapped to the trained SOM using
the layers indicated by the <code>whatmap</code> argument. The predictions
correspond to the <code>unit.predictions</code>, normally corresponding to
the averages of the training data mapping to individual units. If no
<code>unit.predictions</code> are provided, the <code>trainingdata</code> will be
used to calculate them - if <code>trainingdata</code> is not provided by the
user and the <code>kohonen</code> object contains data, these will be used.
If no objects of the training data are mapping to a particular unit,
the prediction for that unit will be NA.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table>
<tr><td><code>prediction</code></td>
<td>
<p>predicted values for the properties of
interest. When multiple values are predicted, this element is a
list, otherwise a vector or a matrix.</p>
</td></tr>
<tr><td><code>unit.classif</code></td>
<td>
<p>vector of unit numbers to which objects in the newdata
object are mapped.</p>
</td></tr>
<tr><td><code>unit.predictions</code></td>
<td>
<p>prediction values associated with map
units. Again, when multiple properties are predicted, this is a
list.</p>
</td></tr>
<tr><td><code>whatmap</code></td>
<td>
<p>the numbers of the data layers in the kohonen object
used in the mapping on which the predictions are based.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+som">som</a></code>,<code><a href="#topic+xyf">xyf</a></code>,
<code><a href="#topic+supersom">supersom</a></code>, <code><a href="#topic+map">map</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)

training &lt;- sample(nrow(wines), 120)
Xtraining &lt;- scale(wines[training, ])
Xtest &lt;- scale(wines[-training, ],
               center = attr(Xtraining, "scaled:center"),
               scale = attr(Xtraining, "scaled:scale"))
trainingdata &lt;- list(measurements = Xtraining,
                     vintages = vintages[training])
testdata &lt;- list(measurements = Xtest, vintages = vintages[-training])

mygrid = somgrid(5, 5, "hexagonal")
som.wines &lt;- supersom(trainingdata, grid = mygrid)

## ################################################################
## Situation 0: obtain expected values for training data (all layers,
## also if not used in training) on the basis of the position in the map
som.prediction &lt;- predict(som.wines)

## ################################################################
## Situation 1: obtain predictions for all layers used in training

som.prediction &lt;- predict(som.wines, newdata = testdata)
table(vintages[-training], som.prediction$predictions[["vintages"]])


## ################################################################
## Situation 2: obtain predictions for the vintage based on the mapping
## of the sample characteristics only. There are several ways of doing this:

som.prediction &lt;- predict(som.wines, newdata = testdata,
                          whatmap = "measurements")
table(vintages[-training], som.prediction$predictions[["vintages"]])

## same, but now indicated implicitly
som.prediction &lt;- predict(som.wines, newdata = testdata[1])
table(vintages[-training], som.prediction$predictions[["vintages"]])

## if no names are present in the list elements whatmap needs to be
## given explicitly; note that the order of the data layers needs to be
## consistent with the kohonen object
som.prediction &lt;- predict(som.wines, newdata = list(Xtest), whatmap = 1)
table(vintages[-training], som.prediction$predictions[["vintages"]])

## for xyf: explicitly indicate which layer is to be used for the mapping
xyf.wines &lt;- xyf(Xtraining, vintages[training], grid = mygrid)
xyf.prediction &lt;- predict(xyf.wines, Xtest, whatmap = 1)
table(vintages[-training], xyf.prediction$predictions[[2]])

## ###############################################################
## Situation 3: predictions for layers not present in the original
## data. Training data need to be provided for those layers.
som.wines &lt;- supersom(Xtraining, grid = mygrid)
som.prediction &lt;- predict(som.wines, newdata = testdata,
                          trainingdata = trainingdata)
table(vintages[-training], som.prediction$predictions[["vintages"]])

## ################################################################
## yeast examples, including NA values

data(yeast)
training.indices &lt;- sample(nrow(yeast$alpha), 300)
training &lt;- rep(FALSE, nrow(yeast$alpha))
training[training.indices] &lt;- TRUE

## unsupervised mapping, based on the alpha layer only. Prediction
## for all layers including alpha
yeast.som &lt;- supersom(lapply(yeast, function(x) subset(x, training)),
                      somgrid(4, 6, "hexagonal"),
                      whatmap = "alpha", maxNA.fraction = .5)
yeast.som.prediction &lt;-
  predict(yeast.som,
          newdata = lapply(yeast, function(x) subset(x, !training)))

table(yeast$class[!training], yeast.som.prediction$prediction[["class"]])

## ################################################################
## supervised mapping - creating the map is now based on both
## alpha and class, prediction for class based on the mapping of alpha.
yeast.som2 &lt;- supersom(lapply(yeast, function(x) subset(x, training)),
                       grid = somgrid(4, 6, "hexagonal"),
                       whatmap = c("alpha", "class"), maxNA.fraction = .5)
yeast.som2.prediction &lt;-
  predict(yeast.som2,
          newdata = lapply(yeast, function(x) subset(x, !training)),
          whatmap = "alpha")
table(yeast$class[!training], yeast.som2.prediction$prediction[["class"]])
</code></pre>

<hr>
<h2 id='summary.kohonen'>Summary and print methods for kohonen objects</h2><span id='topic+summary.kohonen'></span><span id='topic+print.kohonen'></span>

<h3>Description</h3>

<p>Summary and print methods for <code>kohonen</code> objects. The <code>print</code>
method shows the dimensions and the topology of the map; if
information on the training data is included, the <code>summary</code>
method additionally prints information on the size of the data, the
distance functions used, and the
mean distance of an object to its closest codebookvector, which is an
indication of the quality of the mapping.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kohonen'
summary(object, ...)
## S3 method for class 'kohonen'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.kohonen_+3A_x">x</code>, <code id="summary.kohonen_+3A_object">object</code></td>
<td>
<p>a <code>kohonen</code> object</p>
</td></tr>
<tr><td><code id="summary.kohonen_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+som">som</a></code>, <code><a href="#topic+xyf">xyf</a></code>, <code><a href="#topic+supersom">supersom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)
xyf.wines &lt;- xyf(scale(wines), classvec2classmat(vintages),
                 grid = somgrid(5, 5, "hexagonal"))
xyf.wines
summary(xyf.wines)
</code></pre>

<hr>
<h2 id='supersom'>Self- and super-organising maps</h2><span id='topic+som'></span><span id='topic+xyf'></span><span id='topic+supersom'></span><span id='topic+nunits'></span>

<h3>Description</h3>

<p>A supersom is an extension of self-organising maps (SOMs) to multiple
data layers, possibly with different numbers and different types of
variables (though equal numbers of objects). NAs are allowed. A
weighted distance over all layers is calculated to determine the
winning units during training.
Functions <code>som</code> and <code>xyf</code> are simply wrappers for supersoms
with one and two layers, respectively. Function <code>nunits</code> is a
utility function returning the number of units in the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>som(X, ...)
xyf(X, Y, ...)
supersom(data, grid=somgrid(), rlen = 100, alpha = c(0.05, 0.01),
         radius = quantile(nhbrdist, 2/3), 
         whatmap = NULL, user.weights = 1, maxNA.fraction = 0L,
         keep.data = TRUE, dist.fcts = NULL,
         mode = c("online", "batch", "pbatch"), cores = -1, init,
         normalizeDataLayers = TRUE)
nunits(kohobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supersom_+3A_x">X</code>, <code id="supersom_+3A_y">Y</code></td>
<td>
<p>numerical data matrices, or factors. No <code>data.frame</code>
objects are allowed - convert them to matrices first.</p>
</td></tr>
<tr><td><code id="supersom_+3A_data">data</code></td>
<td>
<p>list of data matrices (numerical) of factors. If a vector
is entered, it will be converted to a one-column matrix. No
<code>data.frame</code> objectss are allowed.</p>
</td></tr>
<tr><td><code id="supersom_+3A_grid">grid</code></td>
<td>
<p>a grid for the codebook vectors:
see <code>somgrid</code>.</p>
</td></tr>
<tr><td><code id="supersom_+3A_rlen">rlen</code></td>
<td>
<p>the number of times the complete data set will be
presented to the network.</p>
</td></tr>
<tr><td><code id="supersom_+3A_alpha">alpha</code></td>
<td>
<p>learning rate, a vector of two numbers indicating the
amount of change. Default is to decline linearly from 0.05 to 0.01
over <code>rlen</code> updates. Not used for the batch algorithm.</p>
</td></tr>
<tr><td><code id="supersom_+3A_radius">radius</code></td>
<td>
<p>the radius of the neighbourhood, either given as a
single number or a vector (start, stop). If it is given as a single
number the radius will change linearly from <code>radius</code> to zero; as
soon as the neighbourhood gets smaller than one only the winning unit
will be updated. Note that the default before version 3.0 was to run
from <code>radius</code> to <code>-radius</code>. If nothing is supplied, the
default is to start with a value that covers 2/3 of all unit-to-unit
distances.</p>
</td></tr> 
<tr><td><code id="supersom_+3A_whatmap">whatmap</code></td>
<td>
<p>What data layers to use. If unspecified all layers are used.</p>
</td></tr>
<tr><td><code id="supersom_+3A_user.weights">user.weights</code></td>
<td>
<p>the weights given to individual layers. This can
be a single number (all layers have the same weight, the default), a
vector of the same length as the <code>whatmap</code> argument, or a vector
of the same length as the <code>data</code> argument. In xyf maps, this
argument provides the same functionality as the now-deprecated
<code>xweight</code> argument that was used prior to version 3.0.</p>
</td></tr>
<tr><td><code id="supersom_+3A_maxna.fraction">maxNA.fraction</code></td>
<td>
<p>the maximal fraction of values that may be NA to
prevent the row to be removed.</p>
</td></tr>
<tr><td><code id="supersom_+3A_keep.data">keep.data</code></td>
<td>
<p>if TRUE, return original data and mapping
information. If FALSE, only return the trained map (in essence the
codebook vectors).</p>
</td></tr>
<tr><td><code id="supersom_+3A_dist.fcts">dist.fcts</code></td>
<td>
<p>vector of distance functions to be used for the
individual data layers, of the same length as the <code>data</code>
argument, or the same length of the <code>whatmap</code> argument. If the
length of this vector is one, the  
same distance will be used for all layers. Admissable values
currently are &quot;sumofsquares&quot;, &quot;euclidean&quot;, &quot;manhattan&quot;, and
&quot;tanimoto&quot;. Default is to use &quot;sumofsquares&quot; for continuous data,
and &quot;tanimoto&quot; for factors.</p>
</td></tr>
<tr><td><code id="supersom_+3A_mode">mode</code></td>
<td>
<p>type of learning algorithm.</p>
</td></tr>
<tr><td><code id="supersom_+3A_cores">cores</code></td>
<td>
<p>number of cores to use in the &quot;pbatch&quot; learning mode. The
default, -1, corresponds to using all available cores.</p>
</td></tr>
<tr><td><code id="supersom_+3A_init">init</code></td>
<td>
<p>list of matrices, initial values for the
codebook vectors. The list should have the same length as the data
list, and corresponding numbers of variables (columns). Each list
element should have a number of rows corresponding to the number of
units in the map.</p>
</td></tr>
<tr><td><code id="supersom_+3A_normalizedatalayers">normalizeDataLayers</code></td>
<td>
<p>boolean, indicating whether
<code>distance.weights</code> should be calculated (see details section).
If <code>normalizeDataLayers == FALSE</code> the user weights 
are applied to the data immediately.</p>
</td></tr>
<tr><td><code id="supersom_+3A_kohobj">kohobj</code></td>
<td>
<p>an object of class <code>kohonen</code>.</p>
</td></tr>
<tr><td><code id="supersom_+3A_...">...</code></td>
<td>
<p>Further arguments for the <code>supersom</code> function
presented to the <code>som</code> or <code>xyf</code> wrappers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to avoid some layers to overwhelm others, simply
because of the scale of the data points, the <code>supersom</code> function
by default applies internal weights to balance this. The <code>user.weights</code>
argument is applied on top of that: the result is that when a user
specifies equal weights for all layers (the default), all layers
contribute equally to the global distance measure. For large data
sets (defined as containing more than 500 records), a sample of size
500 is used to calculate the mean distances in each data layer. If
<code>normalizeDataLayers == FALSE</code> the user weights are applied
directly to the data (<code>distance.weights</code> are set to 1).
</p>
<p>Various definitions of the Tanimoto distance exist in the
literature. The implementation here returns (for two binary vectors of
length n) the fraction of cases in which the two vectors
disagree. This is basically the Hamming distance divided by n - the
incorrect naming is retained (for the moment) to guarantee backwards
compatibility. If the vectors are not binary, they will be
converted to binary strings (with 0.5 as the class boundary). This
measure should not be used when variables are outside the range [0-1];
a check is done to make sure this is the case.
</p>


<h3>Value</h3>

<p>An object of class &quot;kohonen&quot; with components
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>data matrix, only returned if <code>keep.data == TRUE</code>.</p>
</td></tr>
<tr><td><code>unit.classif</code></td>
<td>
<p>winning units for all data objects,
only returned if <code>keep.data == TRUE</code>.</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>distances of objects to their corresponding winning
unit, only returned if <code>keep.data == TRUE</code>.</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>the grid, an object of class <code>somgrid</code>.</p>
</td></tr>
<tr><td><code>codes</code></td>
<td>
<p>a list of matrices containing codebook vectors.</p>
</td></tr>
<tr><td><code>changes</code></td>
<td>
<p>matrix of mean average deviations from code vectors;
every map corresponds with one column.</p>
</td></tr>
<tr><td><code>na.rows</code></td>
<td>
<p>vector of row numbers with too many NA values
(according to argument <code>maxNA.fraction</code>.</p>
</td></tr>
<tr><td><code>alpha</code>, <code>radius</code>, <code>user.weights</code>, <code>whatmap</code>, <code>maxNA.fraction</code></td>
<td>
<p>input arguments
presented to the function.</p>
</td></tr>
<tr><td><code>distance.weights</code></td>
<td>
<p>if <code>normalizeDataLayers</code> weights to
equalize the influence of the individual data layers, else a vector
of ones.</p>
</td></tr>
<tr><td><code>dist.fcts</code></td>
<td>
<p>distance functions corresponding to all layers of the
data, not just the ones indicated by the whatmap argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ron Wehrens and Johannes Kruisselbrink</p>


<h3>References</h3>

<p>R. Wehrens and L.M.C. Buydens, J. Stat. Softw. 21 (5), 2007;
R. Wehrens and J. Kruisselbrink, submitted, 2017.</p>


<h3>See Also</h3>

<p><code>somgrid</code>, <code><a href="#topic+plot.kohonen">plot.kohonen</a></code>,
<code><a href="#topic+predict.kohonen">predict.kohonen</a></code>, <code><a href="#topic+map.kohonen">map.kohonen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)

## som
som.wines &lt;- som(scale(wines), grid = somgrid(5, 5, "hexagonal"))
summary(som.wines)
nunits(som.wines)

## xyf
xyf.wines &lt;- xyf(scale(wines), vintages, grid = somgrid(5, 5, "hexagonal"))
summary(xyf.wines)

## supersom example
data(yeast)
yeast.supersom &lt;- supersom(yeast, somgrid(6, 6, "hexagonal"),
                           whatmap = c("alpha", "cdc15", "cdc28", "elu"),
                           maxNA.fraction = .5)

plot(yeast.supersom, "changes")

obj.classes &lt;- as.integer(yeast$class)
colors &lt;- c("yellow", "green", "blue", "red", "orange")
plot(yeast.supersom, type = "mapping", col = colors[obj.classes],
     pch = obj.classes, main = "yeast data")
</code></pre>

<hr>
<h2 id='tricolor'>Provides smooth unit colors for SOMs</h2><span id='topic+tricolor'></span>

<h3>Description</h3>

<p>Function provides colour values for SOM units in such a way that the
colour changes smoothly in every direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tricolor(grid, phis = c(0, 2 * pi/3, 4 * pi/3), offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tricolor_+3A_grid">grid</code></td>
<td>
<p>An object of class <code>somgrid</code>, such as the <code>grid</code>
element in a <code>kohonen</code> object.</p>
</td></tr>
<tr><td><code id="tricolor_+3A_phis">phis</code></td>
<td>
<p>A vector of three rotation angles. Values for red, green
and blue are given by the y-coordinate of the units after rotation
with these three angles, respectively. The default corresponds to
(approximate) red colour of the middle unit in the top row, and pure
green and blue colours in the bottom left and right units,
respectively. In case of a triangular map, the top unit is pure red.</p>
</td></tr>
<tr><td><code id="tricolor_+3A_offset">offset</code></td>
<td>
<p>Defines the minimal value in the RGB colour definition
(default is 0). By supplying a value in the range [0, .9],
pastel-like colours are provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with three columns corresponding to red, green and
blue. This can be used in the <code>rgb</code> function to provide colours
for the units.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.kohonen">plot.kohonen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)
som.wines &lt;- som(wines, grid = somgrid(5, 5, "hexagonal"))

colour1 &lt;- tricolor(som.wines$grid)
plot(som.wines, "mapping", bg = rgb(colour1))
colour2 &lt;- tricolor(som.wines$grid, phi = c(pi/6, 0, -pi/6))
plot(som.wines, "mapping", bg = rgb(colour2))
colour3 &lt;- tricolor(som.wines$grid, phi = c(pi/6, 0, -pi/6), offset = .5)
plot(som.wines, "mapping", bg = rgb(colour3))
</code></pre>

<hr>
<h2 id='unit.distances'>SOM-grid related functions</h2><span id='topic+unit.distances'></span><span id='topic+somgrid'></span>

<h3>Description</h3>

<p>Function <code>somgrid</code> (modified from the version in the class
package) sets up a grid of units, of a specified size 
and topology. Distances between grid units are calculated by function
<code>unit.distances</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>somgrid(xdim = 8, ydim = 6, topo = c("rectangular", "hexagonal"),
        neighbourhood.fct = c("bubble", "gaussian"), toroidal = FALSE)
unit.distances(grid, toroidal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit.distances_+3A_xdim">xdim</code>, <code id="unit.distances_+3A_ydim">ydim</code></td>
<td>
<p>dimensions of the grid.</p>
</td></tr>
<tr><td><code id="unit.distances_+3A_topo">topo</code></td>
<td>
<p>choose between a hexagonal or rectangular topology.</p>
</td></tr>
<tr><td><code id="unit.distances_+3A_neighbourhood.fct">neighbourhood.fct</code></td>
<td>
<p>choose between bubble and gaussian
neighbourhoods when training a SOM.</p>
</td></tr>
<tr><td><code id="unit.distances_+3A_toroidal">toroidal</code></td>
<td>
<p>logical, whether the grid is toroidal or not. If not
provided to the <code>unit.distances</code> function, the information in
the <code>grid</code> object will be used.</p>
</td></tr>
<tr><td><code id="unit.distances_+3A_grid">grid</code></td>
<td>
<p>an object of class <code>somgrid</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>somgrid</code> returns an object of class &quot;somgrid&quot;, with
elements <code>pts</code>, and the input arguments to the function.
</p>
<p>Function <code>unit.distances</code> returns a (symmetrical) matrix
containing distances. When <code>grid$n.hood</code> equals &quot;circular&quot;,
Euclidean distances are used; for <code>grid$n.hood</code> is &quot;square&quot;
maximum distances. For toroidal maps (joined at the edges) distances
are calculated for the shortest path.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>Examples</h3>

<pre><code class='language-R'>mygrid &lt;- somgrid(5, 5, "hexagonal")
fakesom &lt;- list(grid = mygrid)
class(fakesom) &lt;- "kohonen"

par(mfrow = c(2,1))
dists &lt;- unit.distances(mygrid)
plot(fakesom, type="property", property = dists[1,],
     main="Distances to unit 1", zlim=c(0,6),
     palette = rainbow, ncolors = 7)

dists &lt;- unit.distances(mygrid, toroidal=TRUE)
plot(fakesom, type="property", property = dists[1,],
     main="Distances to unit 1 (toroidal)", zlim=c(0,6),
     palette = rainbow, ncolors = 7)
</code></pre>

<hr>
<h2 id='wines'>Wine data</h2><span id='topic+wines'></span><span id='topic+vintages'></span>

<h3>Description</h3>

<p>A data frame containing 177 rows and thirteen columns; object
<code>vintages</code> contains the class labels. 
</p>
<p>These data are the results of chemical analyses of
wines grown in the same region in Italy (Piedmont) but derived from
three different cultivars: Nebbiolo, Barberas and Grignolino grapes. The
wine from the Nebbiolo grape is called Barolo.
The data contain the quantities of several
constituents found in each of the three types of wines, as well as
some spectroscopic variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wines)</code></pre>


<h3>Source</h3>

<p><a href="http://kdd.ics.uci.edu">http://kdd.ics.uci.edu</a>
</p>


<h3>References</h3>

<p>M. Forina, C. Armanino, M. Castino and M. Ubigli. Vitis,
25:189-201 (1986)</p>

<hr>
<h2 id='yeast'>Yeast cell-cycle data</h2><span id='topic+yeast'></span>

<h3>Description</h3>

<p>Microarray cell-cycle data for 800 yeast genes, arrested with six
different methods, arranged in a list. Additional class information is
present as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(yeast)</code></pre>


<h3>References</h3>

<p>P. Spellman et al., Mol. Biol. Cell 9, 3273-3297 (1998)</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
