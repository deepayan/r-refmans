<!DOCTYPE html><html><head><title>Help for package multimix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multimix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multimix-package'><p>multimix: Fit Mixture Models Using the Expectation Maximisation (EM) Algorithm</p></a></li>
<li><a href='#cancer.df'><p>Prostate cancer patient data</p></a></li>
<li><a href='#cmc.df'><p>Contraceptive Method Choice data</p></a></li>
<li><a href='#count.unique'><p>Count the number of unique items ion a vector x</p></a></li>
<li><a href='#data_organise'><p>Prepare data for use with multimix</p></a></li>
<li><a href='#eStep'><p>The E(xpectation) step</p></a></li>
<li><a href='#initParamList'><p>Initialise the parameter list.</p></a></li>
<li><a href='#left'><p>Map integer index N&gt;0 back to left member of generating pair.</p></a></li>
<li><a href='#make_Z_discrete'><p>Make initial Z matrix from initial assignment of observations to clusters</p></a></li>
<li><a href='#make_Z_fortran'><p>Read Z from FORTRAN output. Make into R matrix</p></a></li>
<li><a href='#make_Z_random'><p>Start from random groups of similar size.</p></a></li>
<li><a href='#mmain'><p>Title</p></a></li>
<li><a href='#mStep'><p>The M(aximisation) step</p></a></li>
<li><a href='#pair.index'><p>Maps integer pairs (u,v) with 0&lt;u&lt;v bijectively to positive integers.</p></a></li>
<li><a href='#plot.multimixResults'><p>S3 method for plotting multimix results objects</p></a></li>
<li><a href='#print.multimixParamList'><p>S3 printing method for for multimix parameter results</p></a></li>
<li><a href='#print.multimixResults'><p>S3 method for the printing of multimix results</p></a></li>
<li><a href='#right'><p>Map integer index N&gt;0 back to right member of generating pair.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit Mixture Models Using the Expectation Maximisation (EM)
Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-18</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions which use the Expectation Maximisation (EM) 
    algorithm (Dempster, A. P., Laird, N. M., and Rubin, D. B. (1977) 
    &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1977.tb01600.x">doi:10.1111/j.2517-6161.1977.tb01600.x</a>&gt; Maximum likelihood from 
    incomplete data via the EM algorithm, Journal of the Royal Statistical 
    Society, 39(1), 1&ndash;22) to take a finite mixture model approach to 
    clustering. The package is designed to cluster multivariate data that have 
    categorical and continuous variables and that possibly contain missing 
    values. The method is described in Hunt, L. and Jorgensen, M. (1999) 
    &lt;<a href="https://doi.org/10.1111%2F1467-842X.00071">doi:10.1111/1467-842X.00071</a>&gt; Australian &amp; New Zealand Journal of Statistics 
    41(2), 153&ndash;171 and Hunt, L. and Jorgensen, M. (2003) 
    &lt;<a href="https://doi.org/10.1016%2FS0167-9473%2802%2900190-1">doi:10.1016/S0167-9473(02)00190-1</a>&gt; Mixture model clustering for mixed data 
    with missing information, Computational Statistics &amp; Data Analysis, 41(3-4), 
    429&ndash;440.</td>
</tr>
<tr>
<td>Depends:</td>
<td>mvtnorm, R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmcurran/multimix">https://github.com/jmcurran/multimix</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmcurran/multimix/issues">https://github.com/jmcurran/multimix/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-18 00:26:06 UTC; james</td>
</tr>
<tr>
<td>Author:</td>
<td>Murray Jorgensen [aut],
  James Curran [cre, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Curran &lt;j.curran@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-18 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='multimix-package'>multimix: Fit Mixture Models Using the Expectation Maximisation (EM) Algorithm</h2><span id='topic+multimix'></span><span id='topic+multimix-package'></span>

<h3>Description</h3>

<p>A set of functions which use the Expectation Maximisation (EM) algorithm (Dempster, A. P., Laird, N. M., and Rubin, D. B. (1977) <a href="https://doi.org/10.1111/j.2517-6161.1977.tb01600.x">doi:10.1111/j.2517-6161.1977.tb01600.x</a> Maximum likelihood from incomplete data via the EM algorithm, Journal of the Royal Statistical Society, 39(1), 1&ndash;22) to take a finite mixture model approach to clustering. The package is designed to cluster multivariate data that have categorical and continuous variables and that possibly contain missing values. The method is described in Hunt, L. and Jorgensen, M. (1999) <a href="https://doi.org/10.1111/1467-842X.00071">doi:10.1111/1467-842X.00071</a> Australian &amp; New Zealand Journal of Statistics 41(2), 153&ndash;171 and Hunt, L. and Jorgensen, M. (2003) <a href="https://doi.org/10.1016/S0167-9473%2802%2900190-1">doi:10.1016/S0167-9473(02)00190-1</a> Mixture model clustering for mixed data with missing information, Computational Statistics &amp; Data Analysis, 41(3-4), 429&ndash;440.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: James Curran <a href="mailto:j.curran@auckland.ac.nz">j.curran@auckland.ac.nz</a> [contributor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Murray Jorgensen <a href="mailto:majmurr@gmail.com">majmurr@gmail.com</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jmcurran/multimix">https://github.com/jmcurran/multimix</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jmcurran/multimix/issues">https://github.com/jmcurran/multimix/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cancer.df'>Prostate cancer patient data</h2><span id='topic+cancer.df'></span>

<h3>Description</h3>

<p>Data on 475 prostate cancer patients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cancer.df)
</code></pre>


<h3>Format</h3>

<p>A data.frame with 475 rows and 12 columns:
</p>

<dl>
<dt>age</dt><dd><p>Age in years</p>
</dd>
<dt>wt</dt><dd><p>Weight in pounds</p>
</dd>
<dt>pf</dt><dd><p>Patient activity</p>
</dd>
<dt>hx</dt><dd><p>Family history of cancer</p>
</dd>
<dt>sbp</dt><dd><p>Systolic blood pressure</p>
</dd>
<dt>dbp</dt><dd><p>Diastolic blood pressure</p>
</dd>
<dt>ekg</dt><dd><p>Electrocardiogram code</p>
</dd>
<dt>hg</dt><dd><p>Serum haemoglobin</p>
</dd>
<dt>sz</dt><dd><p>Size of primary tumour</p>
</dd>
<dt>sg</dt><dd><p>Index of tumour stage and histolic grade</p>
</dd>
<dt>ap</dt><dd><p>Serum prostatic acid phosphatase</p>
</dd>
<dt>bm</dt><dd><p>Bone metastatses</p>
</dd>
</dl>



<h3>Details</h3>

<p>There are twelve pre-trial covariates measured on each patient,
seven may be taken to be continuous, four to be discrete, and one 
variable (SG) is an index nearly all of whose values lie between 
7 and 15, and which could be considered either discrete or continuous. 
We will treat SG as a continuous variable.
</p>
<p>A preliminary inspection of the data showed that the sizeof the 
primary tumour (SZ) and serum prostatic acid phosphatase (AP) were 
both skewed variables. These variables have therefore been transformed. 
A square root transformation was used for SZ, and a logarithmic
transformation was used for AP to achieve approximate normality. 
(As for correlation, skewness over the whole data set does not 
necessarily mean skewness within clusters. But when clusters were 
formed, within-cluster skewness was observed for these variables.) 
</p>
<p>Observations that had missing values in any of the twelve pretreatment 
covariates were omitted from furtheranalysis, leaving 475 out of the 
original 506 observations available. 
</p>
<p>The categorical variable <code>Patient activity</code> had 4 levels: 'Normally 
Active', 'Bed rest below 50
or more', and 'Confined to bed'. The numbers of the 475 in these groups were
428, 32, 12, and 3. The least active two groups are grouped in our data,
giving 3 groups of size 428, 32, and 15.
</p>


<h3>Source</h3>

<p>D.P. Byar and S.B. Green 'The choice of treatment for cancer patients
based on covariate information - application to prostate cancer', Bulletin
du Cancer 1980: 67:477&ndash;490, reproduced in D.A. Andrews and A.M. Herzberg
'Data: a collection of problems from many fields for the student and
research worker' p.261&ndash;274 Springer series in statistics, Springer-Verlag.
New York.
</p>

<hr>
<h2 id='cmc.df'>Contraceptive Method Choice data</h2><span id='topic+cmc.df'></span>

<h3>Description</h3>

<p>This dataset is a subset of the 1987 National Indonesia Contraceptive
Prevalence Survey. The cases are 1473 married women who were either not 
pregnant or do not know if they were at the time of interview.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cmc.df)
</code></pre>


<h3>Format</h3>

<p>A data.frame with 1473 rows and 10 columns:
</p>

<dl>
<dt>age</dt><dd><p>Wife's age</p>
</dd>
<dt>edu</dt><dd><p>Wife's education</p>
</dd>
<dt>eduh</dt><dd><p>Husband's education</p>
</dd>
<dt>nborn</dt><dd><p>Number of children ever born</p>
</dd>
<dt>islam</dt><dd><p>Wife's religion</p>
</dd>
<dt>working</dt><dd><p>Wife is now working?</p>
</dd>
<dt>husocc</dt><dd><p>Husband's occupation</p>
</dd>
<dt>sol</dt><dd><p>Standard-of-living index</p>
</dd>
<dt>medex</dt><dd><p>Media exposure</p>
</dd>
<dt>method</dt><dd><p>Contraceptive method used</p>
</dd>
</dl>



<h3>Details</h3>

<p>The variables 'age' (in years) and 'nborn' (ranging from 0 to 16) would
normally be treated as continuous; 'nborn' is skew and might well
be transformed. The remaining 8 variables are categorical. 
</p>
<p>The variables 'edu', 'eduh' and 'sol' take values '1,2,3,4', #' they are 
ordinal with 1 = low and 4 = high. The variable 'husocc' takes the
same 4 values, but it is not clear if the order has any significance.
</p>
<p>The variables 'islam', 'working', and 'medex' are binary-valued with
0=Non-Islam, 1=Islam for 'islam';  0=Yes, 1=No for 'working'; and 0=Good, 
1=Not good for 'medex'.
</p>
<p>The variable 'method' is ternary: 1=No-use, 2=Long-term, 3=Short-term.
</p>


<h3>Source</h3>

<p>Tjen-Sien Lim 'Contraceptive Method Choice' 1997,
UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. 
Irvine, CA: University of California, School of Information and Computer 
Science.
</p>

<hr>
<h2 id='count.unique'>Count the number of unique items ion a vector x</h2><span id='topic+count.unique'></span>

<h3>Description</h3>

<p>Count the number of unique items ion a vector x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.unique(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count.unique_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of unique items in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(1, 2, 3)
count.unique(x)

x = c(1, 1, 1, 2, 3)
count.unique(x)
</code></pre>

<hr>
<h2 id='data_organise'>Prepare data for use with multimix</h2><span id='topic+data_organise'></span>

<h3>Description</h3>

<p>Prepare data for use with multimix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_organise(
  dframe,
  numClusters,
  numIter = 1000,
  cdep = NULL,
  lcdep = NULL,
  minpstar = 1e-09
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_organise_+3A_dframe">dframe</code></td>
<td>
<p>a data frame containing the data set you wish to model.</p>
</td></tr>
<tr><td><code id="data_organise_+3A_numclusters">numClusters</code></td>
<td>
<p>the clusters you wish to fit.</p>
</td></tr>
<tr><td><code id="data_organise_+3A_numiter">numIter</code></td>
<td>
<p>the maximum number of steps to that the EM agorithm will run
before terminating.</p>
</td></tr>
<tr><td><code id="data_organise_+3A_cdep">cdep</code></td>
<td>
<p>a list of multivariate normal cells.</p>
</td></tr>
<tr><td><code id="data_organise_+3A_lcdep">lcdep</code></td>
<td>
<p>a list of location cells.</p>
</td></tr>
<tr><td><code id="data_organise_+3A_minpstar">minpstar</code></td>
<td>
<p>Minimum denominator for application of Bayes Rule.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>multimixSettings</code> which is a <code>list</code> 
with the following elements:
</p>

<ul>
<li><p><code>cdep</code> &mdash; a list of multivariate normal cells.
</p>
</li>
<li><p><code>clink</code> &mdash; column numbers of univariate normal variables.
</p>
</li>
<li><p><code>cprods</code> &mdash; a list over MVN cells containing a matrix of 
pair-wise products of columns in the cell, columns 
ordered by <code><a href="#topic+pair.index">pair.index</a></code>.
</p>
</li>
<li><p><code>cvals</code> &mdash; a list over MVN cells containing a matrix of columns of variables in the cell
</p>
</li>
<li><p><code>cvals2</code> &mdash; a list over MVN cells containing a matrix of squared columns of variables in the cell
</p>
</li>
<li><p><code>dframe</code> &mdash; the <code>data.frame</code> of variables
</p>
</li>
<li><p><code>discvar</code> &mdash; logical: the variable is takes values of either <code>TRUE</code> or <code>FALSE</code>
</p>
</li>
<li><p><code>dlevs</code> &mdash; for discrete cells: number of levels
</p>
</li>
<li><p><code>dlink</code> &mdash; column numbers of univariate discrete variables
</p>
</li>
<li><p><code>dvals</code> &mdash; a list over discrete cells of level indicator matrices
</p>
</li>
<li><p><code>lc</code> &mdash; logical: is continuous variable belonging to OT cell <code>TRUE</code>/<code>FALSE</code>
</p>
</li>
<li><p><code>lcdep</code> &mdash; a list of OT cells
</p>
</li>
<li><p><code>lcdisc</code> &mdash; column numbers of discrete variables in OT cells
</p>
</li>
<li><p><code>lclink</code> &mdash; column numbers of continuous variables in OT cells
</p>
</li>
<li><p><code>lcprods</code> &mdash; a list over OT cells containing a matrix of pair-wise products of continuous columns in the cell, columns ordered by <code>pair.index</code>
</p>
</li>
<li><p><code>lcvals</code> &mdash; a list over OT cells containing a matrix of continuous columns of variables in the cell
</p>
</li>
<li><p><code>lcvals2</code> &mdash; a list over OT cells containing a matrix of squared continuous columns of variables in the cell
</p>
</li>
<li><p><code>ld</code> &mdash; logical: is discrete variable belonging to OT cell <code>TRUE</code>/<code>FALSE</code>
</p>
</li>
<li><p><code>ldlevs</code> &mdash; for discrete variables in OT cells: number of levels
</p>
</li>
<li><p><code>ldlink</code> &mdash; a column numbers of OT discrete variables
</p>
</li>
<li><p><code>ldvals</code> &mdash; a list over OT cells of level indicator matrices
</p>
</li>
<li><p><code>ldxc</code> &mdash; a list over OT cells whose members are lists over levels of matrices of the cell continuous variables whose columns are multiplied by the level indicator column
</p>
</li>
<li><p><code>mc</code> &mdash; logical: is continuous variable not in OT cell <code>TRUE</code>/<code>FALSE</code>
</p>
</li>
<li><p><code>md</code> &mdash; logical: is discrete variable not in OT cell <code>TRUE</code>/<code>FALSE</code>
</p>
</li>
<li><p><code>minpstar</code> &mdash; minimum denominator for appliction of Bayes' Rule
</p>
</li>
<li><p><code>n</code> &mdash; number of observations
</p>
</li>
<li><p><code>numIter</code> &mdash; the maximum number of steps to that the EM agorithm will run before terminating
</p>
</li>
<li><p><code>oc</code> &mdash; logical: is continuous variable in univariate cell <code>TRUE</code>/<code>FALSE</code>
</p>
</li>
<li><p><code>olink</code> &mdash; column numbers of continuous univariate cells
</p>
</li>
<li><p><code>op</code> &mdash; <code>length(olink)</code>
</p>
</li>
<li><p><code>ovals</code> &mdash; <code>n</code> by <code>op</code> matrix of continuous univariate variables
</p>
</li>
<li><p><code>ovals2</code> &mdash; <code>n</code> by <code>op</code> matrix of squared continuous univariate variables
</p>
</li>
<li><p><code>numClusters</code> &mdash; the number of clusters in the model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cancer.df)
D = data_organise(cancer.df, numClusters = 2)
</code></pre>

<hr>
<h2 id='eStep'>The E(xpectation) step</h2><span id='topic+eStep'></span>

<h3>Description</h3>

<p>The E(xpectation) step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eStep(P, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eStep_+3A_p">P</code></td>
<td>
<p>an object of class <code>multimixParamList</code>&ndash;see 
<code><a href="#topic+initParamList">initParamList</a></code> for more information.</p>
</td></tr>
<tr><td><code id="eStep_+3A_d">D</code></td>
<td>
<p>an object of class <code>multimixSettings</code>&mdash;see
<code><a href="#topic+data_organise">data_organise</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing two elements: a <code>matrix</code> named 
<code>Z</code>&mdash;see <code><a href="#topic+mStep">mStep</a></code> for more information, and a scalar
<code>llik</code> containing the current value of the log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>

<hr>
<h2 id='initParamList'>Initialise the parameter list.</h2><span id='topic+initParamList'></span>

<h3>Description</h3>

<p>Although the starting parameter list <code>P</code> may be specified directly, 
Note also that any matrices specified must be positive definite.
This function calculates an initial <code>P</code> from <code>D</code> and a starting
value for <code>Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initParamList(D, Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initParamList_+3A_d">D</code></td>
<td>
<p>an object of class <code>multimixSettings</code>&mdash;see
<code><a href="#topic+data_organise">data_organise</a></code> for details.</p>
</td></tr>
<tr><td><code id="initParamList_+3A_z">Z</code></td>
<td>
<p>an <code class="reqn">n \times q</code> matrix, where <code class="reqn">n</code> is the number
of rows of <code>dframe</code> and <code class="reqn">q</code> is the number of components in the
mixture. During the fitting <code class="reqn">Z_{ij}</code> holds the currently estimated
probability that observation <code class="reqn">i</code> belongs to component <code class="reqn">j</code>.
Often <code>Z</code> is initialized to a matrix of indicator columns for a
partition of the data. It is also common to initialize <code>Z</code> to be the
final <code>Z</code> from the fitting of a simpler model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>multimixParamList</code> which is a <code>list</code> 
with the following elements:
</p>

<ul>
<li><p><code>dstat</code> &ndash; <code>list</code> of matrices for each discrete variable
not included in a location model. The matrix for each discrete variable 
is made up of a column of length <code class="reqn">q</code> for each level (value) of the 
variable giving the expected proportion of each level (column) for each 
mixture component (row). Rows sum to 1.
</p>
</li>
<li><p><code>ldstat</code> &ndash; <code>list</code> of matrices for each discrete 
variable within a location model. The matrix for each discrete variable is
made up of a column of length <code class="reqn">q</code> for each level (value) of the 
variable giving the expected proportion of each level (column) for each 
mixture component (row). Rows sum to 1. 
</p>
</li>
<li><p><code>ostat</code> &ndash; <code>matrix</code>  with a column for each continuous 
variable outside any location mode whose <code class="reqn">q</code> rows give the current 
estimated mean for each mixture component. 
</p>
</li>
<li><p><code>ostat2</code> &ndash; <code>matrix</code> with a column for each continuous 
variable outside any location mode whose <code class="reqn">q</code>rows give the current 
estimated mean square for each mixture component. 
</p>
</li>
<li><p><code>osvar</code> &ndash; <code>matrix</code> with a column for each continuous
variable outside any location mode whose <code class="reqn">q</code> rows give the current
estimated variance for each mixture component. 
</p>
</li>
<li><p><code>cstat</code> &ndash; <code>list</code> with a member for each nontrivial, 
fully continuous, partition cell, that is not including discrete cells or 
cells listed in lcdep, each member being a <code>matrix</code> with a column for each 
continuous variable in that cell, whose <code class="reqn">q</code> rows give the current 
estimated mean for each mixture component. 
</p>
</li>
<li><p><code>cstat2</code> &ndash; <code>list</code> with a member for each nontrivial, 
fully continuous, partition cell, each member being a <code>matrix</code> with a column
for each continuous variable in that cell, whose <code class="reqn">q</code> rows give the 
current estimated mean square for each mixture component. 
</p>
</li>
<li><p><code>cvar</code> &ndash; <code>list</code> with a member for each nontrivial, 
fully continuous, partition cell, each member being a <code>matrix</code> with a column
for each continuous variable in that cell, whose <code class="reqn">q</code> rows give the 
current estimated variance for each mixture component. 
</p>
</li>
<li><p><code>cpstat</code> &ndash; <code>list</code> with a member for each nontrivial, 
fully continuous, partition cell, each member being the <code>matrix</code> with rows 
for each of the <code class="reqn">q</code> mixture components and columns for each pair of 
continuous variables in that cell, as ordered by <code><a href="#topic+pair.index">pair.index</a></code>. 
The matrix 
elements are the currently expected products of the variable pairs 
arranged by component and pair. 
</p>
</li>
<li><p><code>ccov</code> &ndash; <code>list</code> with a member for each nontrivial, 
fully continuous, partition cell, each member being the <code>matrix</code> with rows 
for each of the <code class="reqn">q</code> mixture components and columns for each pair of 
continuous variables in that cell, as ordered by pair.index. The matrix 
elements are the currently expected covariances of the variable pairs 
arranged by component and pair.
</p>
</li>
<li><p><code>MVMV</code> &ndash; <code>list</code> with a member for each nontrivial, 
fully continuous, partition cell, each member being a list with members 
for each of the <code class="reqn">q</code> mixture components whose values are the 
covariance matrix estimates for that cell and component. 
</p>
</li>
<li><p><code>lcstat</code> &ndash; <code>list</code> with a member for location partition 
cell, each member being a <code>matrix</code> with a column for each continuous 
variable in that cell, whose <code class="reqn">q</code> rows give the current estimated
mean for each mixture component. 
</p>
</li>
<li><p><code>lcstat2</code> &ndash; <code>list</code> with a member for location partition
cell, each member being a <code>matrix</code> with a column for each continuous 
variable in that cell, whose <code class="reqn">q</code> rows give the current estimated 
mean square for each mixture component. 
</p>
</li>
<li><p><code>lcpstat</code> &ndash; <code>list</code> with a member for each location 
cell, each member being the <code>matrix</code> with rows for each of the 
<code class="reqn">q</code> mixture components and columns for each pair of continuous 
variables in that cell, as ordered by <code><a href="#topic+pair.index">pair.index</a></code>. The matrix 
elements are the currently expected products of the variable pairs 
arranged by component and pair. 
</p>
</li>
<li><p><code>lccov</code> &ndash; <code>list</code> with a member for each location cell, 
each member being the matrix with rows for each of the <code class="reqn">q</code> mixture 
components and columns for each pair of continuous variables in that cell,
as ordered by <code><a href="#topic+pair.index">pair.index</a></code>. The matrix elements are the 
currently estimated covariances of the variable pairs arranged by 
component and pair. 
</p>
</li>
<li><p><code>ldxcstat</code> &ndash; <code>list</code> with a member for each location 
partition cell, each member being a list with a member for each level of 
the cell's discrete variable that member being a matrix of mean values of 
the continuous variables for each level-class combination. 
</p>
</li>
<li><p><code>pistat</code> &ndash; <code>vector</code> containing estimates of population 
proportion in each cluster; column means of <code class="reqn">Z</code> matrix.
</p>
</li>
<li><p><code>W</code> &ndash; <code>matrix</code> of weights of observation <code class="reqn">i</code> in 
cluster <code class="reqn">j</code>; the columns of the <code class="reqn">Z</code> matrix are each 
multiplied by constant to give <code class="reqn">W</code> columns summing to 1.
</p>
</li></ul>


<hr>
<h2 id='left'>Map integer index N&gt;0 back to left member of generating pair.</h2><span id='topic+left'></span>

<h3>Description</h3>

<p>Map integer index N&gt;0 back to left member of generating pair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="left_+3A_n">N</code></td>
<td>
<p>positive integer scalar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>positive integer scalar
</p>


<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>left(131)
left(57)
</code></pre>

<hr>
<h2 id='make_Z_discrete'>Make initial Z matrix from initial assignment of observations to clusters</h2><span id='topic+make_Z_discrete'></span>

<h3>Description</h3>

<p>Z is an <code class="reqn">n</code> by <code class="reqn">numClusters</code> matrix of non-negative numbers whose rows
sum to 1. The <code class="reqn">ij^{\mathrm{th}}</code> element <code class="reqn">z_{ij}</code> is a
probability that observation <code class="reqn">i</code> belongs to cluster <code class="reqn">j</code>. Rather
than begin from an initial assignment Multimix allows for a weighted
assignment accross several clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Z_discrete(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Z_discrete_+3A_d">d</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function yields a 0/1 valued matrix.
</p>


<h3>Value</h3>

<p>a <code>matrix</code> whose entries are non-negative, and whose entries sum to 1.
</p>


<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stage = scan(file = system.file('extdata', 'Stage.txt', package = 'multimix'))
stage = stage - 2
Z = make_Z_discrete(stage)
</code></pre>

<hr>
<h2 id='make_Z_fortran'>Read Z from FORTRAN output. Make into R matrix</h2><span id='topic+make_Z_fortran'></span>

<h3>Description</h3>

<p>The FORTRAN version of Multimix produces two output files:
GENERAL.OUT and GROUPS.OUT. The latter mainly contains the Z matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Z_fortran(gr.out = "groups.out")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Z_fortran_+3A_gr.out">gr.out</code></td>
<td>
<p>string containing  a file name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function facilitates the obtaining of Multimix R output given
Multimix FORTRAN output.
</p>


<h3>Value</h3>

<p>a matrix containing a <code class="reqn">Z</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- make_Z_fortran(system.file('extdata', 'GROUPS-BP-Multimixf90.OUT', 
                    package = 'multimix'))
</code></pre>

<hr>
<h2 id='make_Z_random'>Start from random groups of similar size.</h2><span id='topic+make_Z_random'></span>

<h3>Description</h3>

<p>A large number (<code class="reqn">n</code>) of observations are assigned randomly into
(<code class="reqn">xq</code>) clusters. It is recommended to repeat Multimix runs with a
number of different seeds to search for a log-likelihood maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Z_random(D, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Z_random_+3A_d">D</code></td>
<td>
<p>an object of class <code>multimixSettings</code> &ndash; see 
<code><a href="#topic+data_organise">data_organise</a></code> for more information.</p>
</td></tr>
<tr><td><code id="make_Z_random_+3A_seed">seed</code></td>
<td>
<p>a positive integer to use as a random number seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Also consider making additional clusters from observations with low
probabilities of belonging to any cluster in a previous clustering.
</p>


<h3>Value</h3>

<p>a matrix of dimension <code class="reqn">n\times q</code> where 
<code class="reqn">n</code> is the number of observations in <code>D$dframe</code>
and <code class="reqn">q</code> is the number of clusters in the model as specified
by <code>D$numClusters</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cancer.df)
D = data_organise(cancer.df, numClusters = 2)
Z = make_Z_random(D)
table(Z)
</code></pre>

<hr>
<h2 id='mmain'>Title</h2><span id='topic+mmain'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmain(D, Z, P, eps = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmain_+3A_d">D</code></td>
<td>
<p>an object of class <code>multimixSettings</code> - see
<code><a href="#topic+data_organise">data_organise</a></code> for full description.</p>
</td></tr>
<tr><td><code id="mmain_+3A_z">Z</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="mmain_+3A_p">P</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="mmain_+3A_eps">eps</code></td>
<td>
<p>Minimum increase in loglikelihood per EM step. If this is not
exceeded the the algorithm will terminate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>multimix results</code> which is a a list
containing four elements: the <code>multmixSettings</code> object <code>D</code>,
the <code class="reqn">Z</code> matrix, the <code class="reqn">P</code> matrix,
and a results matrix, called <code>results</code>, with <code class="reqn">n</code> rows and
<code class="reqn">numClusters</code> columns.
</p>


<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cancer.df)
D &lt;- data_organise(cancer.df, numClusters = 2)
stage &lt;- scan(system.file('extdata', 'Stage.txt', package = 'multimix')) - 2
Z &lt;- make_Z_discrete(stage)
P &lt;- initParamList(D,Z) 
zpr &lt;- mmain(D,Z,P)
zpr
</code></pre>

<hr>
<h2 id='mStep'>The M(aximisation) step</h2><span id='topic+mStep'></span>

<h3>Description</h3>

<p>Uses the current group membership to estimate the probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mStep(Z, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mStep_+3A_z">Z</code></td>
<td>
<p>an <code class="reqn">n \times q</code> matrix, where <code class="reqn">n</code> is the number
of rows of <code>dframe</code> and <code class="reqn">q</code> is the number of components in the
mixture. During the fitting <code class="reqn">Z_{ij}</code> holds the currently estimated
probability that observation <code class="reqn">i</code> belongs to component <code class="reqn">j</code>.
Commonly <code>Z</code> is initialized to a matrix of indicator columns for a
partition of the data.</p>
</td></tr>
<tr><td><code id="mStep_+3A_d">D</code></td>
<td>
<p>an object of class <code>multimixSettings</code>&mdash;see
<code><a href="#topic+data_organise">data_organise</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>multimixParamList</code>&mdash;see 
<code><a href="#topic+initParamList">initParamList</a></code> for more information.
</p>


<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>

<hr>
<h2 id='pair.index'>Maps integer pairs (u,v) with 0&lt;u&lt;v bijectively to positive integers.</h2><span id='topic+pair.index'></span>

<h3>Description</h3>

<p>Used to reduce array dimensions by replacing
A(x,y,z) by A*(x,pair.index(y,z))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.index(u, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair.index_+3A_u">u</code></td>
<td>
<p>positive integer scalar</p>
</td></tr>
<tr><td><code id="pair.index_+3A_v">v</code></td>
<td>
<p>positive integer scalar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer scalar
</p>


<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pair.index(11,17)
pair.index(2,12)
</code></pre>

<hr>
<h2 id='plot.multimixResults'>S3 method for plotting multimix results objects</h2><span id='topic+plot.multimixResults'></span>

<h3>Description</h3>

<p>S3 method for plotting multimix results objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multimixResults'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.multimixResults_+3A_x">x</code></td>
<td>
<p>an object of class <code>multimixResults</code> &ndash; see
<code><a href="#topic+mmain">mmain</a></code> for more information.</p>
</td></tr>
<tr><td><code id="plot.multimixResults_+3A_...">...</code></td>
<td>
<p>any other arguments to be passed to <code>plot</code>. Note that
because there are two calls to plot, the ... arguments will be passed to 
each call, and it is unlikely that this will have the desired effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>

<hr>
<h2 id='print.multimixParamList'>S3 printing method for for multimix parameter results</h2><span id='topic+print.multimixParamList'></span>

<h3>Description</h3>

<p>S3 printing method for for multimix parameter results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multimixParamList'
print(
  x,
  type = c("means", "vars"),
  byLevel = FALSE,
  digits = c(4, 2, 3, 16),
  pedantic = FALSE,
  raw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.multimixParamList_+3A_x">x</code></td>
<td>
<p>an object of class <code>multimixParamResults</code> &ndash; see 
<code><a href="#topic+initParamList">initParamList</a></code> for more information.</p>
</td></tr>
<tr><td><code id="print.multimixParamList_+3A_type">type</code></td>
<td>
<p>the statistic you want displayed. If <code>means</code> then the cluster
means will be displayed for each univariate continuous variable, the cluster proportions
for each level of a categorical variable, and the mean vector for each cluster and each
multivariate normal variable.</p>
</td></tr>
<tr><td><code id="print.multimixParamList_+3A_bylevel">byLevel</code></td>
<td>
<p>if <code>TRUE</code> then location model summary stats will be printed by the 
level of the factor in the location model. Otheriwse (default), they will be printed cluster
by cluster.</p>
</td></tr>
<tr><td><code id="print.multimixParamList_+3A_digits">digits</code></td>
<td>
<p>a vector of length 4. The first value determines how many decimal places to 
round categorical proportions to. The second value determines how many significant digits to 
display means to, and the third how many siginificant digits to display variances to. By default
proportions are rounded to 4 decimal places, means 2 significant digits, and variances 3 significant 
digits. The fourth value is only used if <code>pedantic == TRUE</code>, and is set to 16 significant figures by
default.</p>
</td></tr>
<tr><td><code id="print.multimixParamList_+3A_pedantic">pedantic</code></td>
<td>
<p>if <code>TRUE</code> then the results are printed to high precision for checking purposes.
This means <code>digits[4]</code> which is 16 decimal places by default.</p>
</td></tr>
<tr><td><code id="print.multimixParamList_+3A_raw">raw</code></td>
<td>
<p>if <code>TRUE</code> then switches off all of the customised printing and uses the default
print methods for <code>list</code>s etc.</p>
</td></tr>
<tr><td><code id="print.multimixParamList_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>

<hr>
<h2 id='print.multimixResults'>S3 method for the printing of multimix results</h2><span id='topic+print.multimixResults'></span>

<h3>Description</h3>

<p>S3 method for the printing of multimix results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multimixResults'
print(x, n = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.multimixResults_+3A_x">x</code></td>
<td>
<p>an object of class <code>multimixResults</code>&mdash;see <code><a href="#topic+mmain">mmain</a></code>
for a description.</p>
</td></tr>
<tr><td><code id="print.multimixResults_+3A_n">n</code></td>
<td>
<p>display the last few iterations of the cluster probabilities. If 
<code>TRUE</code> then the last 5 iterations will be displayed by default.
Alternatively, a positive integer can be supplied. If this exceeds the 
number of actual iterations, the output will be truncated.</p>
</td></tr>
<tr><td><code id="print.multimixResults_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>print</code>. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>James Curran
</p>

<hr>
<h2 id='right'>Map integer index N&gt;0 back to right member of generating pair.</h2><span id='topic+right'></span>

<h3>Description</h3>

<p>Map integer index N&gt;0 back to right member of generating pair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>right(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="right_+3A_n">N</code></td>
<td>
<p>positive integer scalar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>positive integer scalar
</p>


<h3>Author(s)</h3>

<p>Murray Jorgensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>right(131)
right(57)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
