<!DOCTYPE html><html lang="en"><head><title>Help for package plmmr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plmmr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#plmmr-package'><p>plmmr: Penalized Linear Mixed Models for Correlated Data</p></a></li>
<li><a href='#add_predictors'><p>A helper function to add predictors to a filebacked matrix of data</p></a></li>
<li><a href='#admix'><p>Admix: Semi-simulated SNP data</p></a></li>
<li><a href='#align_ids'><p>A helper function to support <code>process_plink()</code></p></a></li>
<li><a href='#big_cbind'><p>a version of cbind() for file-backed matrices</p></a></li>
<li><a href='#check_for_file_extension'><p>check_for_file_extension: a function to make our package 'smart' enough to</p>
handle .rds file extensions</a></li>
<li><a href='#coef.cv_plmm'><p>Coef method for &quot;cv_plmm&quot; class</p></a></li>
<li><a href='#coef.plmm'><p>Coef method for &quot;plmm&quot; class</p></a></li>
<li><a href='#construct_variance'><p>a function to create the estimated variance matrix from a PLMM fit</p></a></li>
<li><a href='#count_constant_features'><p>A helper function to count constant features</p></a></li>
<li><a href='#count_cores'><p>A helper function to count the number of cores available on the current machine</p></a></li>
<li><a href='#create_design'><p>a function to create a design for PLMM modeling</p></a></li>
<li><a href='#create_design_filebacked'><p>A function to create a design matrix, outcome, and penalty factor to be passed to a model fitting function</p></a></li>
<li><a href='#create_design_in_memory'><p>A function to create a design with an in-memory X matrix</p></a></li>
<li><a href='#create_log'><p>create_log_file</p></a></li>
<li><a href='#cv_plmm'><p>Cross-validation for plmm</p></a></li>
<li><a href='#cvf'><p>Cross-validation internal function for cv_plmm</p></a></li>
<li><a href='#eigen_K'><p>A function to take the eigendecomposition of K</p>
Note: This is faster than taking SVD of X when p &gt;&gt; n</a></li>
<li><a href='#estimate_eta'><p>Estimate eta (to be used in rotating the data)</p>
This function is called internally by <code>plmm()</code></a></li>
<li><a href='#fbm2bm'><p>Functions to convert between FBM and big.matrix type objects</p></a></li>
<li><a href='#find_example_data'><p>A function to help with accessing example PLINK files</p></a></li>
<li><a href='#get_data'><p>Read in processed data</p>
This function is intended to be called after either <code>process_plink()</code> or <code>process_delim()</code> has been called once.</a></li>
<li><a href='#get_hostname'><p>a function to return the computer's host name</p></a></li>
<li><a href='#impute_snp_data'><p>A function to impute SNP data</p></a></li>
<li><a href='#index_samples'><p>A function to align genotype and phenotype data</p></a></li>
<li><a href='#lam_names'><p>Generate nicely formatted lambda vec</p></a></li>
<li><a href='#lasso'><p>helper function to implement lasso penalty</p></a></li>
<li><a href='#log_lik'><p>Evaluate the negative log-likelihood of an intercept-only Gaussian plmm model</p></a></li>
<li><a href='#MCP'><p>helper function to implement MCP penalty</p>
The helper functions to implement each penalty.</a></li>
<li><a href='#name_and_count_bigsnp'><p>A helper function to label and summarize the contents of a <code>bigSNP</code></p></a></li>
<li><a href='#plmm'><p>Fit a linear mixed model via penalized maximum likelihood.</p></a></li>
<li><a href='#plmm_checks'><p>plmm_checks</p></a></li>
<li><a href='#plmm_fit'><p>PLMM fit: a function that fits a PLMM using the values returned by plmm_prep()</p></a></li>
<li><a href='#plmm_format'><p>PLMM format: a function to format the output of a model constructed with <code>plmm_fit</code></p></a></li>
<li><a href='#plmm_loss'><p>Loss method for &quot;plmm&quot; class</p></a></li>
<li><a href='#plmm_prep'><p>PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model</p>
This is an internal function for <code>cv_plmm</code></a></li>
<li><a href='#plot.cv_plmm'><p>Plot method for cv_plmm class</p></a></li>
<li><a href='#plot.plmm'><p>Plot method for plmm class</p></a></li>
<li><a href='#predict_within_cv'><p>Predict method to use in cross-validation (within <code>cvf</code>)</p></a></li>
<li><a href='#predict.plmm'><p>Predict method for plmm class</p></a></li>
<li><a href='#pretty_time'><p>a function to format the time</p></a></li>
<li><a href='#print.summary.cv_plmm'><p>Print method for summary.cv_plmm objects</p></a></li>
<li><a href='#print.summary.plmm'><p>A function to print the summary of a <code>plmm</code> model</p></a></li>
<li><a href='#process_delim'><p>A function to read in large data files as an FBM</p></a></li>
<li><a href='#process_plink'><p>Preprocess PLINK files using the <code>bigsnpr</code> package</p></a></li>
<li><a href='#read_data_files'><p>A function to read in a large file as a numeric file-backed matrix (<code>FBM</code>)</p>
Note: this function is a wrapper for <code>bigstatsr::big_read()</code></a></li>
<li><a href='#read_plink_files'><p>A function to read in PLINK files using <code>bigsnpr</code> methods</p></a></li>
<li><a href='#relatedness_mat'><p>Calculate a relatedness matrix</p></a></li>
<li><a href='#rotate_filebacked'><p>A function to rotate filebacked data</p></a></li>
<li><a href='#SCAD'><p>helper function to implement SCAD penalty</p></a></li>
<li><a href='#setup_lambda'><p>Compute sequence of lambda values</p></a></li>
<li><a href='#standardize_filebacked'><p>A helper function to standardize a filebacked matrix</p></a></li>
<li><a href='#standardize_in_memory'><p>A helper function to standardize matrices</p></a></li>
<li><a href='#subset_filebacked'><p>A helper function to subset <code>big.matrix</code> objects</p></a></li>
<li><a href='#summary.cv_plmm'><p>A summary function for cv_plmm objects</p></a></li>
<li><a href='#summary.plmm'><p>A summary method for the plmm objects</p></a></li>
<li><a href='#untransform'><p>Untransform coefficient values back to the original scale</p></a></li>
<li><a href='#untransform_delim'><p>Untransform coefficient values back to the original scale for <strong>file-backed</strong> data</p></a></li>
<li><a href='#untransform_in_memory'><p>Untransform coefficient values back to the original scale <em>In memory</em></p></a></li>
<li><a href='#untransform_plink'><p>Untransform coefficient values back to the original scale for <strong>file-backed</strong> data</p></a></li>
<li><a href='#unzip_example_data'><p>For Linux/Unix and MacOS only, here is a companion function to unzip the .gz files that ship with the <code>plmmr</code> package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Penalized Linear Mixed Models for Correlated Data</td>
</tr>
<tr>
<td>Version:</td>
<td>4.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-03</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits penalized linear mixed models that correct for
    unobserved confounding factors. 'plmmr' infers and corrects for the
    presence of unobserved confounding effects such as population
    stratification and environmental heterogeneity. It then fits a linear
    model via penalized maximum likelihood. Originally designed for the
    multivariate analysis of single nucleotide polymorphisms (SNPs)
    measured in a genome-wide association study (GWAS), 'plmmr' eliminates
    the need for subpopulation-specific analyses and post-analysis p-value
    adjustments.  Functions for the appropriate processing of 'PLINK'
    files are also supplied. For examples, see the package homepage.
    <a href="https://pbreheny.github.io/plmmr/">https://pbreheny.github.io/plmmr/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pbreheny.github.io/plmmr/">https://pbreheny.github.io/plmmr/</a>,
<a href="https://github.com/pbreheny/plmmr/">https://github.com/pbreheny/plmmr/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>bigalgebra, bigmemory, R (&ge; 4.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>biglasso (&ge; 1.6.0), data.table, glmnet, Matrix, ncvreg,
parallel, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bigsnpr, bigstatsr, graphics, grDevices, knitr, MASS,
rmarkdown, tinytest</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, bigmemory, Rcpp, RcppArmadillo (&ge; 0.8.600)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-03 17:46:44 UTC; pbreheny</td>
</tr>
<tr>
<td>Author:</td>
<td>Tabitha K. Peter <a href="https://orcid.org/0009-0005-2524-4751"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Anna C. Reisetter <a href="https://orcid.org/0000-0001-8332-4585"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Patrick J. Breheny
    <a href="https://orcid.org/0000-0002-0650-1119"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Yujing Lu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick J. Breheny &lt;patrick-breheny@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-03 18:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='plmmr-package'>plmmr: Penalized Linear Mixed Models for Correlated Data</h2><span id='topic+plmmr'></span><span id='topic+plmmr-package'></span>

<h3>Description</h3>

<p>Fits penalized linear mixed models that correct for unobserved confounding factors. 'plmmr' infers and corrects for the presence of unobserved confounding effects such as population stratification and environmental heterogeneity. It then fits a linear model via penalized maximum likelihood. Originally designed for the multivariate analysis of single nucleotide polymorphisms (SNPs) measured in a genome-wide association study (GWAS), 'plmmr' eliminates the need for subpopulation-specific analyses and post-analysis p-value adjustments. Functions for the appropriate processing of 'PLINK' files are also supplied. For examples, see the package homepage. <a href="https://pbreheny.github.io/plmmr/">https://pbreheny.github.io/plmmr/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Patrick J. Breheny <a href="mailto:patrick-breheny@uiowa.edu">patrick-breheny@uiowa.edu</a> (<a href="https://orcid.org/0000-0002-0650-1119">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Tabitha K. Peter <a href="mailto:tabitha-peter@uiowa.edu">tabitha-peter@uiowa.edu</a> (<a href="https://orcid.org/0009-0005-2524-4751">ORCID</a>)
</p>
</li>
<li><p> Anna C. Reisetter <a href="mailto:anna-reisetter@uiowa.edu">anna-reisetter@uiowa.edu</a> (<a href="https://orcid.org/0000-0001-8332-4585">ORCID</a>)
</p>
</li>
<li><p> Yujing Lu
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://pbreheny.github.io/plmmr/">https://pbreheny.github.io/plmmr/</a>
</p>
</li>
<li> <p><a href="https://github.com/pbreheny/plmmr/">https://github.com/pbreheny/plmmr/</a>
</p>
</li></ul>


<hr>
<h2 id='add_predictors'>A helper function to add predictors to a filebacked matrix of data</h2><span id='topic+add_predictors'></span>

<h3>Description</h3>

<p>A helper function to add predictors to a filebacked matrix of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_predictors(obj, add_predictor, id_var, rds_dir, quiet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_predictors_+3A_obj">obj</code></td>
<td>
<p>A <code>bigSNP</code> object</p>
</td></tr>
<tr><td><code id="add_predictors_+3A_add_predictor">add_predictor</code></td>
<td>
<p>Optional: add additional covariates/predictors/features from an external file (i.e., not a PLINK file).</p>
</td></tr>
<tr><td><code id="add_predictors_+3A_id_var">id_var</code></td>
<td>
<p>String specifying which column of the PLINK <code>.fam</code> file has the unique sample identifiers.</p>
</td></tr>
<tr><td><code id="add_predictors_+3A_rds_dir">rds_dir</code></td>
<td>
<p>The path to the directory in which you want to create the new '.rds' and '.bk' files. Defaults to <code>data_dir</code>(from <code>process_plink()</code> call)</p>
</td></tr>
<tr><td><code id="add_predictors_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages be printed to the console? Defaults to FALSE (which leaves the print messages on...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 components:
</p>

<ul>
<li><p> 'obj' - a <code>bigSNP</code> object with an added element representing the matrix that includes the additional predictors as the first few columns
</p>
</li>
<li><p> 'non_gen' - an integer vector that ranges from 1 to the number of added predictors. Example: if 2 predictors are added, unpen= 1:2
</p>
</li></ul>


<hr>
<h2 id='admix'>Admix: Semi-simulated SNP data</h2><span id='topic+admix'></span>

<h3>Description</h3>

<p>A dataset containing the 100 SNPs, a demographic variable representing race,
and a simulated outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix
</code></pre>


<h3>Format</h3>

<p>A list with 3 components
</p>

<dl>
<dt>X</dt><dd><p>SNP matrix (197 observations of 100 SNPs)</p>
</dd>
<dt>y</dt><dd><p>vector of simulated (continuous) outcomes</p>
</dd>
<dt>race</dt><dd><p>vector with racial group categorization: # 0 = African, 1 = African American, 2 = European, 3 = Japanese</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://hastie.su.domains/CASI/">https://hastie.su.domains/CASI/</a>
</p>

<hr>
<h2 id='align_ids'>A helper function to support <code>process_plink()</code></h2><span id='topic+align_ids'></span>

<h3>Description</h3>

<p>A helper function to support <code>process_plink()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_ids(id_var, quiet, add_predictor, og_ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align_ids_+3A_id_var">id_var</code></td>
<td>
<p>String specifying the variable name of the ID column</p>
</td></tr>
<tr><td><code id="align_ids_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should a message be printed?</p>
</td></tr>
<tr><td><code id="align_ids_+3A_add_predictor">add_predictor</code></td>
<td>
<p>External data to include in design matrix. This is the add_predictors... arg in <code>process_plink()</code></p>
</td></tr>
<tr><td><code id="align_ids_+3A_og_ids">og_ids</code></td>
<td>
<p>Character vector with the PLINK ids (FID or IID) from the <em>original</em> data (i.e., the data before any subsetting from handling missing phenotypes)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the same dimensions as add_predictor
</p>

<hr>
<h2 id='big_cbind'>a version of cbind() for file-backed matrices</h2><span id='topic+big_cbind'></span>

<h3>Description</h3>

<p>a version of cbind() for file-backed matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>big_cbind(A, B, C, quiet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="big_cbind_+3A_a">A</code></td>
<td>
<p>in-memory data</p>
</td></tr>
<tr><td><code id="big_cbind_+3A_b">B</code></td>
<td>
<p>file-backed data</p>
</td></tr>
<tr><td><code id="big_cbind_+3A_c">C</code></td>
<td>
<p>file-backed placeholder for combined data</p>
</td></tr>
<tr><td><code id="big_cbind_+3A_quiet">quiet</code></td>
<td>
<p>Logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>C, filled in with all column values of A and B combined
</p>

<hr>
<h2 id='check_for_file_extension'>check_for_file_extension: a function to make our package 'smart' enough to
handle .rds file extensions</h2><span id='topic+check_for_file_extension'></span>

<h3>Description</h3>

<p>check_for_file_extension: a function to make our package 'smart' enough to
handle .rds file extensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_for_file_extension(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_for_file_extension_+3A_path">path</code></td>
<td>
<p>A string specifying a file path that ends in a file name, e.g. &quot;~/dir/my_file.rds&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string with a filepath <em>without</em> an extension, e.g. &quot;~/dir/my_file&quot;
</p>

<hr>
<h2 id='coef.cv_plmm'>Coef method for &quot;cv_plmm&quot; class</h2><span id='topic+coef.cv_plmm'></span>

<h3>Description</h3>

<p>Coef method for &quot;cv_plmm&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv_plmm'
coef(object, lambda, which = object$min, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv_plmm_+3A_object">object</code></td>
<td>
<p>An object of class &quot;cv_plmm.&quot;</p>
</td></tr>
<tr><td><code id="coef.cv_plmm_+3A_lambda">lambda</code></td>
<td>
<p>A numeric vector of lambda values.</p>
</td></tr>
<tr><td><code id="coef.cv_plmm_+3A_which">which</code></td>
<td>
<p>Vector of lambda indices for which coefficients to return. Defaults to lambda index with minimum CVE.</p>
</td></tr>
<tr><td><code id="coef.cv_plmm_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named numeric vector. Values are the coefficients of the
model at the specified value of either <code>lambda</code> or <code>which</code>. Names are the
values of <code>lambda</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>admix_design &lt;- create_design(X = admix$X, y = admix$y)
cv_fit &lt;- cv_plmm(design = admix_design, return_fit = TRUE)
head(coef(cv_fit))

</code></pre>

<hr>
<h2 id='coef.plmm'>Coef method for &quot;plmm&quot; class</h2><span id='topic+coef.plmm'></span>

<h3>Description</h3>

<p>Coef method for &quot;plmm&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plmm'
coef(object, lambda, which = 1:length(object$lambda), drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.plmm_+3A_object">object</code></td>
<td>
<p>An object of class &quot;plmm.&quot;</p>
</td></tr>
<tr><td><code id="coef.plmm_+3A_lambda">lambda</code></td>
<td>
<p>A numeric vector of lambda values.</p>
</td></tr>
<tr><td><code id="coef.plmm_+3A_which">which</code></td>
<td>
<p>Vector of lambda indices for which coefficients to return.</p>
</td></tr>
<tr><td><code id="coef.plmm_+3A_drop">drop</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="coef.plmm_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a numeric matrix (if model was fit on data stored in memory)
or a sparse matrix (if model was fit on data stored filebacked). Rownames are
feature names, columns are values of <code>lambda</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>admix_design &lt;- create_design(X = admix$X, y = admix$y)
fit &lt;- plmm(design = admix_design)
coef(fit)[1:10, 41:45]
</code></pre>

<hr>
<h2 id='construct_variance'>a function to create the estimated variance matrix from a PLMM fit</h2><span id='topic+construct_variance'></span>

<h3>Description</h3>

<p>a function to create the estimated variance matrix from a PLMM fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_variance(fit, K = NULL, eta = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_variance_+3A_fit">fit</code></td>
<td>
<p>An object returned by <code>plmm()</code></p>
</td></tr>
<tr><td><code id="construct_variance_+3A_k">K</code></td>
<td>
<p>An optional matrix</p>
</td></tr>
<tr><td><code id="construct_variance_+3A_eta">eta</code></td>
<td>
<p>An optional numeric value between 0 and 1; if <code>fit</code> is not supplied, then this option must be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sigma_hat, a matrix representing the estimated variance
</p>

<hr>
<h2 id='count_constant_features'>A helper function to count constant features</h2><span id='topic+count_constant_features'></span>

<h3>Description</h3>

<p>A helper function to count constant features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_constant_features(fbm, outfile, quiet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_constant_features_+3A_fbm">fbm</code></td>
<td>
<p>A filebacked <code>big.matrix</code></p>
</td></tr>
<tr><td><code id="count_constant_features_+3A_outfile">outfile</code></td>
<td>
<p>String specifying name of log file</p>
</td></tr>
<tr><td><code id="count_constant_features_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should a message be printed to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ns A numeric vector with the indices of the non-singular columns of the matrix associated with <code>counts</code>
</p>

<hr>
<h2 id='count_cores'>A helper function to count the number of cores available on the current machine</h2><span id='topic+count_cores'></span>

<h3>Description</h3>

<p>A helper function to count the number of cores available on the current machine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_cores()
</code></pre>


<h3>Value</h3>

<p>A number of cores to use; if <code>parallel</code> is installed, this will be <code>parallel::detectCores()</code>. Otherwise, this returns a 1.
</p>

<hr>
<h2 id='create_design'>a function to create a design for PLMM modeling</h2><span id='topic+create_design'></span>

<h3>Description</h3>

<p>a function to create a design for PLMM modeling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_design(data_file = NULL, rds_dir = NULL, X = NULL, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_design_+3A_data_file">data_file</code></td>
<td>
<p>For <strong>filebacked data</strong> (data from <code>process_plink()</code> or <code>process_delim()</code>), this is the
filepath to the processed data. Defaults to NULL (this argument does not apply for in-memory data).</p>
</td></tr>
<tr><td><code id="create_design_+3A_rds_dir">rds_dir</code></td>
<td>
<p>For <strong>filebacked data</strong>, this is the filepath to the directory/folder where you want the design to be saved.
<strong>Note</strong>: do not include/append the name you want for the to-be-created file &ndash; the name is the argument <code>new_file</code>,
passed to <code>create_design_filebacked()</code>. Defaults to NULL (this argument does not apply for in-memory data).</p>
</td></tr>
<tr><td><code id="create_design_+3A_x">X</code></td>
<td>
<p>For <strong>in-memory data (data in a matrix or data frame)</strong>, this is the design matrix. Defaults to NULL (this argument does not apply for filebacked data).</p>
</td></tr>
<tr><td><code id="create_design_+3A_y">y</code></td>
<td>
<p>For <strong>in-memory data</strong>, this is the numeric vector representing the outcome. Defaults to NULL (this argument does not apply for filebacked data).
<strong>Note</strong>: it is the responsibility of the user to ensure that the rows in X and the corresponding elements of y have the same row order,
i.e., observations must be in the same order in both the design matrix and in the outcome vector.</p>
</td></tr>
<tr><td><code id="create_design_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>create_design_filebacked()</code> or <code>create_design_in_memory()</code>.
See the documentation for those helper functions for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the other <code>create_design...()</code> inner functions; all arguments
included here are passed along to the <code>create_design...()</code> inner function that
matches the type of the data being supplied. Note which arguments are optional
and which ones are not.
</p>
<p>Additional arguments for <strong>all filebacked</strong> data:
</p>

<ul>
<li> <p><strong>new_file</strong>                User-specified filename (<em>without .bk/.rds extension</em>) for the to-be-created .rds/.bk files. Must be different from any existing .rds/.bk files in the same folder.
</p>
</li>
<li> <p><strong>feature_id</strong>              Optional: A string specifying the column in the data X (the feature data) with the row IDs (e.g., identifiers for each row/sample/participant/, etc.). No duplicates allowed.
- for PLINK data: a string specifying an ID column of the PLINK <code>.fam</code> file. Options are &quot;IID&quot; (default) and &quot;FID&quot;
- for all other filebacked data: a character vector of unique identifiers (IDs) for each row of the feature data (i.e., the data processed with <code>process_delim()</code>)
- if left NULL (default), X is assumed to have the same row-order as add_outcome.
<strong>Note</strong>: if this assumption is made in error, calculations downstream will be incorrect. Pay close attention here.
</p>
</li>
<li> <p><strong>add_outcome</strong>             A data frame or matrix with two columns: and ID column and a column with the outcome value (to be used as 'y' in the final design). IDs must be characters, outcome must be numeric.
</p>
</li>
<li> <p><strong>outcome_id</strong>              A string specifying the name of the ID column in 'add_outcome'
</p>
</li>
<li> <p><strong>outcome_col</strong>             A string specifying the name of the phenotype column in 'add_outcome'
</p>
</li>
<li> <p><strong>na_outcome_vals</strong>        Optional: a vector of numeric values used to code NA values in the outcome. Defaults to <code>c(-9, NA_integer)</code> (the -9 matches PLINK conventions).
</p>
</li>
<li> <p><strong>overwrite</strong>              Optional: logical - should existing .rds files be overwritten? Defaults to FALSE.
</p>
</li>
<li> <p><strong>logfile</strong>                Optional: name of the '.log' file to be written &ndash; <strong>Note:</strong> do not append a <code>.log</code> to the filename; this is done automatically.
</p>
</li>
<li> <p><strong>quiet</strong>                  Optional: logical - should messages to be printed to the console be silenced? Defaults to FALSE
</p>
</li></ul>

<p>Additional arguments specific to <strong>PLINK</strong> data:
</p>

<ul>
<li> <p><strong>add_predictor</strong>           Optional (for PLINK data only): a matrix or data frame to be used for adding additional <strong>unpenalized</strong> covariates/predictors/features from an external file (i.e., not a PLINK file).
This matrix must have one column that is an ID column; all other columns aside the ID will be used as covariates in the design matrix. Columns must be named.
</p>
</li>
<li> <p><strong>predictor_id</strong>            Optional (for PLINK data only): A string specifying the name of the column in 'add_predictor' with sample IDs. Required if 'add_predictor' is supplied.
The names will be used to subset and align this external covariate with the supplied PLINK data.
</p>
</li></ul>

<p>Additional arguments specific to <strong>delimited file</strong> data:
</p>

<ul>
<li> <p><strong>unpen</strong>         Optional: an character vector with the names of columns to mark as unpenalized (i.e., these features would always be included in a model).
<strong>Note</strong>: if you choose to use this option, your delimited file <strong>must</strong> have column names.
</p>
</li></ul>

<p>Additional arguments for <strong>in-memory</strong> data:
</p>

<ul>
<li> <p><strong>unpen</strong>         Optional: an character vector with the names of columns to mark as unpenalized (i.e., these features would always be included in a model).
<strong>Note</strong>: if you choose to use this option, X must have column names.
</p>
</li></ul>



<h3>Value</h3>

<p>A filepath to an object of class <code>plmm_design</code>, which is a named list with the design matrix,
outcome, penalty factor vector, and other details needed for fitting a model. This list is stored as an .rds
file for filebacked data, so in the filebacked case a string with the path to that file is returned. For in-memory data,
the list itself is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1: matrix data in-memory ##
admix_design &lt;- create_design(X = admix$X, y = admix$y, unpen = "Snp1")

## Example 2: delimited data ##
# process delimited data
temp_dir &lt;- tempdir()
colon_dat &lt;- process_delim(data_file = "colon2.txt",
 data_dir = find_example_data(parent = TRUE), overwrite = TRUE,
 rds_dir = temp_dir, rds_prefix = "processed_colon2", sep = "\t", header = TRUE)

# prepare outcome data
colon_outcome &lt;- read.delim(find_example_data(path = "colon2_outcome.txt"))

# create a design
colon_design &lt;- create_design(data_file = colon_dat, rds_dir = temp_dir, new_file = "std_colon2",
add_outcome = colon_outcome, outcome_id = "ID", outcome_col = "y", unpen = "sex",
overwrite = TRUE, logfile = "test.log")

# look at the results
colon_rds &lt;- readRDS(colon_design)
str(colon_rds)

## Example 3: PLINK data ##

# process PLINK data
temp_dir &lt;- tempdir()
unzip_example_data(outdir = temp_dir)

plink_data &lt;- process_plink(data_dir = temp_dir,
  data_prefix = "penncath_lite",
  rds_dir = temp_dir,
  rds_prefix = "imputed_penncath_lite",
  # imputing the mode to address missing values
  impute_method = "mode",
  # overwrite existing files in temp_dir
  # (you can turn this feature off if you need to)
  overwrite = TRUE,
  # turning off parallelization - leaving this on causes problems knitting this vignette
  parallel = FALSE)

# get outcome data
penncath_pheno &lt;- read.csv(find_example_data(path = 'penncath_clinical.csv'))

outcome &lt;- data.frame(FamID = as.character(penncath_pheno$FamID),
                  CAD = penncath_pheno$CAD)

unpen_predictors &lt;- data.frame(FamID = as.character(penncath_pheno$FamID),
                               sex = penncath_pheno$sex,
                               age = penncath_pheno$age)


# create design where sex and age are always included in the model
pen_design &lt;- create_design(data_file = plink_data,
  feature_id = "FID",
  rds_dir = temp_dir,
  new_file = "std_penncath_lite",
  add_outcome = outcome,
  outcome_id = "FamID",
  outcome_col = "CAD",
  add_predictor = unpen_predictors,
  predictor_id = "FamID",
  logfile = "design",
  # again, overwrite if needed; use with caution
  overwrite = TRUE)

# examine the design - notice the components of this object
pen_design_rds &lt;- readRDS(pen_design)




</code></pre>

<hr>
<h2 id='create_design_filebacked'>A function to create a design matrix, outcome, and penalty factor to be passed to a model fitting function</h2><span id='topic+create_design_filebacked'></span>

<h3>Description</h3>

<p>A function to create a design matrix, outcome, and penalty factor to be passed to a model fitting function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_design_filebacked(
  data_file,
  rds_dir,
  obj,
  new_file,
  feature_id = NULL,
  add_outcome,
  outcome_id,
  outcome_col,
  na_outcome_vals = c(-9, NA_integer_),
  add_predictor = NULL,
  predictor_id = NULL,
  unpen = NULL,
  logfile = NULL,
  overwrite = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_design_filebacked_+3A_data_file">data_file</code></td>
<td>
<p>A filepath to rds file of processed data (data from <code>process_plink()</code> or <code>process_delim()</code>)</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_rds_dir">rds_dir</code></td>
<td>
<p>The path to the directory in which you want to create the new '.rds' and '.bk' files.</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_obj">obj</code></td>
<td>
<p>The RDS object read in by <code>create_design()</code></p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_new_file">new_file</code></td>
<td>
<p>User-specified filename (<em>without .bk/.rds extension</em>) for the to-be-created .rds/.bk files. Must be different from any existing .rds/.bk files in the same folder.</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_feature_id">feature_id</code></td>
<td>
<p>A string specifying the column in the data X (the feature data) with the row IDs (e.g., identifiers for each row/sample/participant/, etc.). No duplicates allowed.
- for PLINK data: a string specifying an ID column of the PLINK <code>.fam</code> file. Options are &quot;IID&quot; (default) and &quot;FID&quot;
- for all other filebacked data: a character vector of unique identifiers (IDs) for each row of the feature data (i.e., the data processed with <code>process_delim()</code>)
- if left NULL (default), X is assumed to have the same row-order as add_outcome.
<strong>Note</strong>: if this assumption is made in error, calculations downstream will be incorrect. Pay close attention here.</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_add_outcome">add_outcome</code></td>
<td>
<p>A data frame or matrix with two columns: and ID column and a column with the outcome value (to be used as 'y' in the final design). IDs must be characters, outcome must be numeric.</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_outcome_id">outcome_id</code></td>
<td>
<p>A string specifying the name of the ID column in 'add_outcome'</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_outcome_col">outcome_col</code></td>
<td>
<p>A string specifying the name of the phenotype column in 'add_outcome'</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_na_outcome_vals">na_outcome_vals</code></td>
<td>
<p>A vector of numeric values used to code NA values in the outcome. Defaults to <code>c(-9, NA_integer)</code> (the -9 matches PLINK conventions).</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_add_predictor">add_predictor</code></td>
<td>
<p>Optional (for PLINK data only): a matrix or data frame to be used for adding additional <strong>unpenalized</strong> covariates/predictors/features from an external file (i.e., not a PLINK file).
This matrix must have one column that is an ID column; all other columns aside the ID will be used as covariates in the design matrix. Columns must be named.</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_predictor_id">predictor_id</code></td>
<td>
<p>Optional (for PLINK data only): A string specifying the name of the column in 'add_predictor' with sample IDs. <strong>Required</strong> if 'add_predictor' is supplied.
The names will be used to subset and align this external covariate with the supplied PLINK data.</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_unpen">unpen</code></td>
<td>
<p>Optional (for delimited file data only): an optional character vector with the names of columns to mark as unpenalized (i.e., these features would always be included in a model).
<strong>Note</strong>: if you choose to use this option, X must have column names.</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_logfile">logfile</code></td>
<td>
<p>Optional: name of the '.log' file to be written &ndash; <strong>Note:</strong> do not append a <code>.log</code> to the filename; this is done automatically.</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical: should existing .rds files be overwritten? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="create_design_filebacked_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages to be printed to the console be silenced? Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filepath to the created .rds file containing all the information
for model fitting, including a standardized X and model design information
</p>

<hr>
<h2 id='create_design_in_memory'>A function to create a design with an in-memory X matrix</h2><span id='topic+create_design_in_memory'></span>

<h3>Description</h3>

<p>A function to create a design with an in-memory X matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_design_in_memory(X, y, unpen = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_design_in_memory_+3A_x">X</code></td>
<td>
<p>A numeric matrix in which rows correspond to observations (e.g., samples) and columns correspond to features.</p>
</td></tr>
<tr><td><code id="create_design_in_memory_+3A_y">y</code></td>
<td>
<p>A numeric vector representing the outcome for the model.
<strong>Note</strong>: it is the responsibility of the user to ensure that the outcome_col and X have the same row order!</p>
</td></tr>
<tr><td><code id="create_design_in_memory_+3A_unpen">unpen</code></td>
<td>
<p>An optional character vector with the names of columns to mark as unpenalized (i.e., these features would always be included in a model).
<strong>Note</strong>: if you choose to use this option, X must have column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements including a standardized X and model design information
</p>

<hr>
<h2 id='create_log'>create_log_file</h2><span id='topic+create_log'></span>

<h3>Description</h3>

<p>create_log_file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_log(outfile, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_log_+3A_outfile">outfile</code></td>
<td>
<p>String specifying the name of the to-be-created file, <em>without</em> extension</p>
</td></tr>
<tr><td><code id="create_log_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned, intead a text file with the suffix .log is created.
</p>

<hr>
<h2 id='cv_plmm'>Cross-validation for plmm</h2><span id='topic+cv_plmm'></span>

<h3>Description</h3>

<p>Performs k-fold cross validation for lasso-, MCP-, or SCAD-penalized
linear mixed models over a grid of values for the regularization parameter <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_plmm(
  design,
  y = NULL,
  K = NULL,
  diag_K = NULL,
  eta_star = NULL,
  penalty = "lasso",
  type = "blup",
  gamma,
  alpha = 1,
  lambda_min,
  nlambda = 100,
  lambda,
  eps = 1e-04,
  max_iter = 10000,
  warn = TRUE,
  init = NULL,
  cluster,
  nfolds = 5,
  seed,
  fold = NULL,
  trace = FALSE,
  save_rds = NULL,
  return_fit = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv_plmm_+3A_design">design</code></td>
<td>
<p>The first argument must be one of three things:
(1) <code>plmm_design</code> object (as created by <code>create_design()</code>)
(2) a string with the file path to a design object (the file path must end in '.rds')
(3) a <code>matrix</code> or <code>data.frame</code> object representing the design matrix of interest</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_y">y</code></td>
<td>
<p>Optional: In the case where <code>design</code> is a <code>matrix</code> or <code>data.frame</code>, the user must also supply
a numeric outcome vector as the <code>y</code> argument. In this case, <code>design</code> and <code>y</code> will be passed
internally to <code>create_design(X = design, y = y)</code>.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_k">K</code></td>
<td>
<p>Similarity matrix used to rotate the data. This should either be (1) a known matrix that reflects the covariance of y, (2) an estimate (Default is <code class="reqn">\frac{1}{p}(XX^T)</code>), or (3) a list with components 'd' and 'u', as returned by choose_k().</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_diag_k">diag_K</code></td>
<td>
<p>Logical: should K be a diagonal matrix? This would reflect observations that are unrelated, or that can be treated as unrelated. Defaults to FALSE.
Note: plmm() does not check to see if a matrix is diagonal. If you want to use a diagonal K matrix, you must set diag_K = TRUE.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_eta_star">eta_star</code></td>
<td>
<p>Optional argument to input a specific eta term rather than estimate it from the data. If K is a known covariance matrix that is full rank, this should be 1.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_penalty">penalty</code></td>
<td>
<p>The penalty to be applied to the model. Either &quot;lasso&quot; (the default), &quot;SCAD&quot;, or &quot;MCP&quot;.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_type">type</code></td>
<td>
<p>A character argument indicating what should be returned from predict.plmm(). If type == 'lp', predictions are
based on the linear predictor, X beta. If type == 'blup', predictions are based on the sum of the linear predictor
and the estimated random effect (BLUP). Defaults to 'blup', as this has shown to be a superior prediction method
in many applications.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the MCP/SCAD penalty (see details). Default is 3 for MCP and 3.7 for SCAD.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_alpha">alpha</code></td>
<td>
<p>Tuning parameter for the Mnet estimator which controls the relative contributions from the MCP/SCAD penalty and the ridge, or L2 penalty. alpha=1 is equivalent to MCP/SCAD penalty, while alpha=0 would be equivalent to ridge regression. However, alpha=0 is not supported; alpha may be arbitrarily small, but not exactly 0.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_lambda_min">lambda_min</code></td>
<td>
<p>The smallest value for lambda, as a fraction of lambda.max. Default is .001 if the number of observations is larger than the number of covariates and .05 otherwise.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_nlambda">nlambda</code></td>
<td>
<p>Length of the sequence of lambda. Default is 100.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_lambda">lambda</code></td>
<td>
<p>A user-specified sequence of lambda values. By default, a sequence of values of length nlambda is computed, equally spaced on the log scale.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold. The algorithm iterates until the RMSD for the change in linear predictors for each coefficient is less than eps. Default is <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations (total across entire path). Default is 10000.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_warn">warn</code></td>
<td>
<p>Return warning messages for failures to converge and model saturation? Default is TRUE.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_init">init</code></td>
<td>
<p>Initial values for coefficients. Default is 0 for all columns of X.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_cluster">cluster</code></td>
<td>
<p>Option for <strong>in-memory data only</strong>: cv_plmm() can be run in parallel across a cluster using the parallel package.
The cluster must be set up in advance using parallel::makeCluster(). The cluster must then be passed to cv_plmm().
<strong>Note</strong>: this option is not yet implemented for filebacked data.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_nfolds">nfolds</code></td>
<td>
<p>The number of cross-validation folds. Default is 5.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_seed">seed</code></td>
<td>
<p>You may set the seed of the random number generator in order to obtain reproducible results.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_fold">fold</code></td>
<td>
<p>Which fold each observation belongs to. By default, the observations are randomly assigned.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_trace">trace</code></td>
<td>
<p>If set to TRUE, inform the user of progress by announcing the beginning of each CV fold. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_save_rds">save_rds</code></td>
<td>
<p>Optional: if a filepath and name <em>without</em> the '.rds' suffix is specified (e.g., <code>save_rds = "~/dir/my_results"</code>), then the model results are saved to the provided location (e.g., &quot;~/dir/my_results.rds&quot;).
Defaults to NULL, which does not save the result.
<strong>Note</strong>: Along with the model results, two '.rds' files ('loss' and 'yhat') will be created in the same directory as 'save_rds'.
These files contain the loss and predicted outcome values in each fold; both files will be updated during after prediction within each fold.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_return_fit">return_fit</code></td>
<td>
<p>Optional: a logical value indicating whether the fitted model should be returned as a <code>plmm</code> object in the current (assumed interactive) session. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="cv_plmm_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>plmm_fit</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 12 items:
</p>

<ul>
<li><p> type: the type of prediction used ('lp' or 'blup')
</p>
</li>
<li><p> cve: numeric vector with the cross validation error (CVE) at each value of <code>lambda</code>
</p>
</li>
<li><p> cvse: numeric vector with the estimated standard error associated with each value of for <code>cve</code>
</p>
</li>
<li><p> fold: numeric <code>n</code> length vector of integers indicating the fold to which each observation was assigned
</p>
</li>
<li><p> lambda: numeric vector of <code>lambda</code> values
</p>
</li>
<li><p> fit: the overall fit of the object, including all predictors; this is a
list as returned by <code>plmm()</code>
</p>
</li>
<li><p> min: The index corresponding to the value of <code>lambda</code> that minimizes <code>cve</code>
</p>
</li>
<li><p> lambda_min: The <code>lambda</code> value at which <code>cve</code> is minmized
</p>
</li>
<li><p> min1se: The index corresponding to the value of <code>lambda</code> within
standard error of that which minimizes <code>cve</code>
</p>
</li>
<li><p> lambda1se: largest value of lambda such that error is within 1 standard error of the minimum.
</p>
</li>
<li><p> null.dev: numeric value representing the deviance for the
intercept-only model. If you have supplied your own <code>lambda</code> sequence,
this quantity may not be meaningful.
</p>
</li>
<li><p> estimated_Sigma: an n x n matrix representing the estimated covariance matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>admix_design &lt;- create_design(X = admix$X, y = admix$y)
cv_fit &lt;- cv_plmm(design = admix_design)
print(summary(cv_fit))
plot(cv_fit)

# Note: for examples with filebacked data, see the filebacking vignette
# https://pbreheny.github.io/plmmr/articles/filebacking.html


</code></pre>

<hr>
<h2 id='cvf'>Cross-validation internal function for cv_plmm</h2><span id='topic+cvf'></span>

<h3>Description</h3>

<p>Internal function for cv_plmm which calls plmm on a fold subset of the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvf(i, fold, type, cv_args, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cvf_+3A_i">i</code></td>
<td>
<p>Fold number to be excluded from fit.</p>
</td></tr>
<tr><td><code id="cvf_+3A_fold">fold</code></td>
<td>
<p>n-length vector of fold-assignments.</p>
</td></tr>
<tr><td><code id="cvf_+3A_type">type</code></td>
<td>
<p>A character argument indicating what should be returned from predict.plmm. If <code>type == 'lp'</code> predictions are based on the linear predictor, <code>$X beta$</code>. If <code>type == 'individual'</code> predictions are based on the linear predictor plus the estimated random effect (BLUP).</p>
</td></tr>
<tr><td><code id="cvf_+3A_cv_args">cv_args</code></td>
<td>
<p>List of additional arguments to be passed to plmm.</p>
</td></tr>
<tr><td><code id="cvf_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>predict_within_cv</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements:
</p>

<ul>
<li><p> a numeric vector with the loss at each value of lambda
</p>
</li>
<li><p> a numeric value indicating the number of lambda values used
</p>
</li>
<li><p> a numeric value with the predicted outcome (y hat) values at each lambda
</p>
</li></ul>


<hr>
<h2 id='eigen_K'>A function to take the eigendecomposition of K
Note: This is faster than taking SVD of X when p &gt;&gt; n</h2><span id='topic+eigen_K'></span>

<h3>Description</h3>

<p>A function to take the eigendecomposition of K
Note: This is faster than taking SVD of X when p &gt;&gt; n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_K(std_X, fbm_flag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigen_K_+3A_std_x">std_X</code></td>
<td>
<p>The <em>standardized</em> design matrix, stored as big.matrix object.</p>
</td></tr>
<tr><td><code id="eigen_K_+3A_fbm_flag">fbm_flag</code></td>
<td>
<p>Logical: is std_X an FBM obejct? Passed from <code>plmm()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the eigenvectors and eigenvalues of K
</p>

<hr>
<h2 id='estimate_eta'>Estimate eta (to be used in rotating the data)
This function is called internally by <code>plmm()</code></h2><span id='topic+estimate_eta'></span>

<h3>Description</h3>

<p>Estimate eta (to be used in rotating the data)
This function is called internally by <code>plmm()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_eta(n, s, U, y, eta_star)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_eta_+3A_n">n</code></td>
<td>
<p>The number of observations</p>
</td></tr>
<tr><td><code id="estimate_eta_+3A_s">s</code></td>
<td>
<p>The singular values of K, the realized relationship matrix</p>
</td></tr>
<tr><td><code id="estimate_eta_+3A_u">U</code></td>
<td>
<p>The left-singular vectors of the <em>standardized</em> design matrix</p>
</td></tr>
<tr><td><code id="estimate_eta_+3A_y">y</code></td>
<td>
<p>Continuous outcome vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value with the estimated value of eta, the variance parameter
</p>

<hr>
<h2 id='fbm2bm'>Functions to convert between FBM and big.matrix type objects</h2><span id='topic+fbm2bm'></span>

<h3>Description</h3>

<p>Functions to convert between FBM and big.matrix type objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbm2bm(fbm, desc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbm2bm_+3A_fbm">fbm</code></td>
<td>
<p>An FBM object; see <code>bigstatsr::FBM()</code> for details</p>
</td></tr>
<tr><td><code id="fbm2bm_+3A_desc">desc</code></td>
<td>
<p>Logical: is the descriptor file desired (as opposed to the filebacked big matrix)? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>big.matrix</code> - see <code>bigmemory::filebacked.big.matrix()</code> for details
</p>

<hr>
<h2 id='find_example_data'>A function to help with accessing example PLINK files</h2><span id='topic+find_example_data'></span>

<h3>Description</h3>

<p>A function to help with accessing example PLINK files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_example_data(path, parent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_example_data_+3A_path">path</code></td>
<td>
<p>Argument (string) specifying a path (filename) for an external data file in <code>extdata/</code></p>
</td></tr>
<tr><td><code id="find_example_data_+3A_parent">parent</code></td>
<td>
<p>If <code>path=TRUE</code> and the user wants the name of the parent directory where that file is located, set <code>parent=TRUE</code>. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>path=NULL</code>, a character vector of file names is returned. If path is given, then a character string
with the full file path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_example_data(parent = TRUE)

</code></pre>

<hr>
<h2 id='get_data'>Read in processed data
This function is intended to be called after either <code>process_plink()</code> or <code>process_delim()</code> has been called once.</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p>Read in processed data
This function is intended to be called after either <code>process_plink()</code> or <code>process_delim()</code> has been called once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(path, returnX = FALSE, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_data_+3A_path">path</code></td>
<td>
<p>The file path to the RDS object containing the processed data. Do not add the '.rds' extension to the path.</p>
</td></tr>
<tr><td><code id="get_data_+3A_returnx">returnX</code></td>
<td>
<p>Logical: Should the design matrix be returned as a numeric matrix that will be stored in memory. By default, this will be FALSE.</p>
</td></tr>
<tr><td><code id="get_data_+3A_trace">trace</code></td>
<td>
<p>Logical: Should trace messages be shown? Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with these components:
</p>

<ul>
<li><p> std_X, the column-standardized design matrix as either (1) a numeric matrix or (2) a filebacked matrix (FBM). See <code>bigstatsr::FBM()</code> and <code>bigsnpr::bigSnp-class</code> documentation for details.
</p>
</li>
<li><p> (if PLINK data) fam, a data frame containing the pedigree information (like a .fam file in PLINK)
</p>
</li>
<li><p> (if PLINK data) map, a data frame containing the feature information (like a .bim file in PLINK)
</p>
</li>
<li><p> ns: A vector indicating the which columns of X contain nonsingular features (i.e., features with variance != 0.
</p>
</li>
<li><p> center: A vector of values for centering each column in X
</p>
</li>
<li><p> scale: A vector of values for scaling each column in X
</p>
</li></ul>


<hr>
<h2 id='get_hostname'>a function to return the computer's host name</h2><span id='topic+get_hostname'></span>

<h3>Description</h3>

<p>a function to return the computer's host name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hostname()
</code></pre>


<h3>Value</h3>

<p>String with hostname of current machine
</p>

<hr>
<h2 id='impute_snp_data'>A function to impute SNP data</h2><span id='topic+impute_snp_data'></span>

<h3>Description</h3>

<p>A function to impute SNP data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_snp_data(
  obj,
  X,
  impute,
  impute_method,
  parallel,
  outfile,
  quiet,
  seed = as.numeric(Sys.Date()),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute_snp_data_+3A_obj">obj</code></td>
<td>
<p>a <code>bigSNP</code> object (as created by <code>read_plink_files()</code>)</p>
</td></tr>
<tr><td><code id="impute_snp_data_+3A_x">X</code></td>
<td>
<p>A matrix of genotype data as  returned by <code>name_and_count_bigsnp</code></p>
</td></tr>
<tr><td><code id="impute_snp_data_+3A_impute">impute</code></td>
<td>
<p>Logical: should data be imputed? Default to TRUE.</p>
</td></tr>
<tr><td><code id="impute_snp_data_+3A_impute_method">impute_method</code></td>
<td>
<p>If 'impute' = TRUE, this argument will specify the kind of imputation desired. Options are:
</p>

<ul>
<li><p> mode (default): Imputes the most frequent call. See <code>bigsnpr::snp_fastImputeSimple()</code> for details.
</p>
</li>
<li><p> random: Imputes sampling according to allele frequencies.
</p>
</li>
<li><p> mean0: Imputes the rounded mean.
</p>
</li>
<li><p> mean2: Imputes the mean rounded to 2 decimal places.
</p>
</li>
<li><p> xgboost: Imputes using an algorithm based on local XGBoost models. See <code>bigsnpr::snp_fastImpute()</code> for details. Note: this can take several minutes, even for a relatively small data set.
</p>
</li></ul>
</td></tr>
<tr><td><code id="impute_snp_data_+3A_parallel">parallel</code></td>
<td>
<p>Logical: should the computations within this function be run in parallel? Defaults to TRUE. See <code>count_cores()</code> and <code>?bigparallelr::assert_cores</code> for more details.
In particular, the user should be aware that too much parallelization can make computations <em>slower</em>.</p>
</td></tr>
<tr><td><code id="impute_snp_data_+3A_outfile">outfile</code></td>
<td>
<p>Optional: the name (character string) of the prefix of the logfile to be written. Defaults to 'process_plink', i.e. you will get 'process_plink.log' as the outfile.</p>
</td></tr>
<tr><td><code id="impute_snp_data_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages be printed to the console? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="impute_snp_data_+3A_seed">seed</code></td>
<td>
<p>Numeric value to be passed as the seed for <code>impute_method = 'xgboost'</code>. Defaults to <code>as.numeric(Sys.Date())</code></p>
</td></tr>
<tr><td><code id="impute_snp_data_+3A_...">...</code></td>
<td>
<p>Optional: additional arguments to <code>bigsnpr::snp_fastImpute()</code> (relevant only if impute_method = &quot;xgboost&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned, but the <code>obj$genotypes</code> is overwritten with the imputed version of the data
</p>

<hr>
<h2 id='index_samples'>A function to align genotype and phenotype data</h2><span id='topic+index_samples'></span>

<h3>Description</h3>

<p>A function to align genotype and phenotype data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_samples(
  obj,
  rds_dir,
  indiv_id,
  add_outcome,
  outcome_id,
  outcome_col,
  na_outcome_vals,
  outfile,
  quiet
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index_samples_+3A_obj">obj</code></td>
<td>
<p>An object created by <code>process_plink()</code></p>
</td></tr>
<tr><td><code id="index_samples_+3A_rds_dir">rds_dir</code></td>
<td>
<p>The path to the directory in which you want to create the new '.rds' and '.bk' files.</p>
</td></tr>
<tr><td><code id="index_samples_+3A_indiv_id">indiv_id</code></td>
<td>
<p>A character string indicating the ID column name in the 'fam'
element of the genotype data list. Defaults to 'sample.ID', equivalent to 'IID' in PLINK. The other option is 'family.ID', equivalent to 'FID' in PLINK.</p>
</td></tr>
<tr><td><code id="index_samples_+3A_add_outcome">add_outcome</code></td>
<td>
<p>A data frame with at least two columns: and ID column and a phenotype column</p>
</td></tr>
<tr><td><code id="index_samples_+3A_outcome_id">outcome_id</code></td>
<td>
<p>A string specifying the name of the ID column in <code>pheno</code></p>
</td></tr>
<tr><td><code id="index_samples_+3A_outcome_col">outcome_col</code></td>
<td>
<p>A string specifying the name of the phenotype column in <code>pheno</code>. This column will be used as the default <code>y</code> argument to 'plmm()'.</p>
</td></tr>
<tr><td><code id="index_samples_+3A_na_outcome_vals">na_outcome_vals</code></td>
<td>
<p>A vector of numeric values used to code NA values in the outcome. Defaults to <code>c(-9, NA_integer)</code> (the -9 matches PLINK conventions).</p>
</td></tr>
<tr><td><code id="index_samples_+3A_outfile">outfile</code></td>
<td>
<p>A string with the name of the filepath for the log file</p>
</td></tr>
<tr><td><code id="index_samples_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages be printed to the console? Defaults to FALSE (which leaves the print messages on...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two items:
</p>

<ul>
<li><p> a data.table with rows corresponding to the samples for which both genotype and phenotype are available.
</p>
</li>
<li><p> a numeric vector with indices indicating which samples were 'complete' (i.e., which samples from add_outcome had corresponding data in the PLINK files)
</p>
</li></ul>


<hr>
<h2 id='lam_names'>Generate nicely formatted lambda vec</h2><span id='topic+lam_names'></span>

<h3>Description</h3>

<p>Generate nicely formatted lambda vec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lam_names(l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lam_names_+3A_l">l</code></td>
<td>
<p>Vector of lambda values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of formatted lambda value names
</p>

<hr>
<h2 id='lasso'>helper function to implement lasso penalty</h2><span id='topic+lasso'></span>

<h3>Description</h3>

<p>helper function to implement lasso penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso(z, l1, l2, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lasso_+3A_z">z</code></td>
<td>
<p>solution over active set at each feature</p>
</td></tr>
<tr><td><code id="lasso_+3A_l1">l1</code></td>
<td>
<p>upper bound</p>
</td></tr>
<tr><td><code id="lasso_+3A_l2">l2</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="lasso_+3A_v">v</code></td>
<td>
<p>the 'xtx' term</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of the lasso-penalized coefficient estimates within the given bounds
</p>

<hr>
<h2 id='log_lik'>Evaluate the negative log-likelihood of an intercept-only Gaussian plmm model</h2><span id='topic+log_lik'></span>

<h3>Description</h3>

<p>This function allows you to evaluate the negative log-likelihood of a linear mixed model under the assumption of a null model in order to estimate the variance parameter, eta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_lik(eta, n, s, U, y, rot_y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_lik_+3A_eta">eta</code></td>
<td>
<p>The proportion of variance in the outcome that is attributable to causal SNP effects. In other words, signal-to-noise ratio.</p>
</td></tr>
<tr><td><code id="log_lik_+3A_n">n</code></td>
<td>
<p>The number of observations</p>
</td></tr>
<tr><td><code id="log_lik_+3A_s">s</code></td>
<td>
<p>The singular values of K, the realized relationship matrix</p>
</td></tr>
<tr><td><code id="log_lik_+3A_u">U</code></td>
<td>
<p>The left-singular vectors of the <em>standardized</em> design matrix</p>
</td></tr>
<tr><td><code id="log_lik_+3A_y">y</code></td>
<td>
<p>Continuous outcome vector.</p>
</td></tr>
<tr><td><code id="log_lik_+3A_rot_y">rot_y</code></td>
<td>
<p>Optional: if y has already been rotated, then this can be supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the log-likelihood of the PLMM, evaluated with the supplied parameters
</p>

<hr>
<h2 id='MCP'>helper function to implement MCP penalty
The helper functions to implement each penalty.</h2><span id='topic+MCP'></span>

<h3>Description</h3>

<p>helper function to implement MCP penalty
The helper functions to implement each penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCP(z, l1, l2, gamma, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCP_+3A_z">z</code></td>
<td>
<p>a vector representing the solution over active set at each feature</p>
</td></tr>
<tr><td><code id="MCP_+3A_l1">l1</code></td>
<td>
<p>upper bound (on beta)</p>
</td></tr>
<tr><td><code id="MCP_+3A_l2">l2</code></td>
<td>
<p>lower bound (on beta)</p>
</td></tr>
<tr><td><code id="MCP_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the MCP penalty</p>
</td></tr>
<tr><td><code id="MCP_+3A_v">v</code></td>
<td>
<p>the 'xtx' term</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of the MCP-penalized coefficient estimates within the given bounds
</p>

<hr>
<h2 id='name_and_count_bigsnp'>A helper function to label and summarize the contents of a <code>bigSNP</code></h2><span id='topic+name_and_count_bigsnp'></span>

<h3>Description</h3>

<p>A helper function to label and summarize the contents of a <code>bigSNP</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_and_count_bigsnp(obj, id_var, quiet, outfile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_and_count_bigsnp_+3A_obj">obj</code></td>
<td>
<p>a <code>bigSNP</code> object, possibly subset by <code>add_external_phenotype()</code></p>
</td></tr>
<tr><td><code id="name_and_count_bigsnp_+3A_id_var">id_var</code></td>
<td>
<p>String specifying which column of the PLINK <code>.fam</code> file has the unique sample identifiers. Options are &quot;IID&quot; (default) and &quot;FID&quot;.</p>
</td></tr>
<tr><td><code id="name_and_count_bigsnp_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages be printed to the console? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="name_and_count_bigsnp_+3A_outfile">outfile</code></td>
<td>
<p>The string with the name of the .log file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>

<ul>
<li><p> counts: column-wise summary of the minor allele counts in 'genotypes'
</p>
</li>
<li><p> obj: a modified <code>bigSNP</code> list with additional components
</p>
</li>
<li><p> X: the <code>obj$genotypes</code> as its own FBM
</p>
</li>
<li><p> pos: the <code>obj$map$physical.pos</code> vector
</p>
</li></ul>


<hr>
<h2 id='plmm'>Fit a linear mixed model via penalized maximum likelihood.</h2><span id='topic+plmm'></span>

<h3>Description</h3>

<p>Fit a linear mixed model via penalized maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmm(
  design,
  y = NULL,
  K = NULL,
  diag_K = NULL,
  eta_star = NULL,
  penalty = "lasso",
  init = NULL,
  gamma,
  alpha = 1,
  lambda_min,
  nlambda = 100,
  lambda,
  eps = 1e-04,
  max_iter = 10000,
  warn = TRUE,
  trace = FALSE,
  save_rds = NULL,
  return_fit = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plmm_+3A_design">design</code></td>
<td>
<p>The first argument must be one of three things:
(1) <code>plmm_design</code> object (as created by <code>create_design()</code>)
(2) a string with the file path to a design object (the file path must end in '.rds')
(3) a <code>matrix</code> or <code>data.frame</code> object representing the design matrix of interest</p>
</td></tr>
<tr><td><code id="plmm_+3A_y">y</code></td>
<td>
<p>Optional: In the case where <code>design</code> is a <code>matrix</code> or <code>data.frame</code>, the user must also supply
a numeric outcome vector as the <code>y</code> argument. In this case, <code>design</code> and <code>y</code> will be passed
internally to <code>create_design(X = design, y = y)</code>.</p>
</td></tr>
<tr><td><code id="plmm_+3A_k">K</code></td>
<td>
<p>Similarity matrix used to rotate the data. This should either be:
(1) a known matrix that reflects the covariance of y,
(2) an estimate (Default is <code class="reqn">\frac{1}{p}(XX^T)</code>), or
(3) a list with components 'd' and 'U', as returned by a previous <code>plmm()</code> model fit on the same data.</p>
</td></tr>
<tr><td><code id="plmm_+3A_diag_k">diag_K</code></td>
<td>
<p>Logical: should K be a diagonal matrix? This would reflect observations that are unrelated, or that can be treated as unrelated. Defaults to FALSE.
Note: plmm() does not check to see if a matrix is diagonal. If you want to use a diagonal K matrix, you must set diag_K = TRUE.</p>
</td></tr>
<tr><td><code id="plmm_+3A_eta_star">eta_star</code></td>
<td>
<p>Optional argument to input a specific eta term rather than estimate it from the data. If K is a known covariance matrix that is full rank, this should be 1.</p>
</td></tr>
<tr><td><code id="plmm_+3A_penalty">penalty</code></td>
<td>
<p>The penalty to be applied to the model. Either &quot;lasso&quot; (the default), &quot;SCAD&quot;, or &quot;MCP&quot;.</p>
</td></tr>
<tr><td><code id="plmm_+3A_init">init</code></td>
<td>
<p>Initial values for coefficients. Default is 0 for all columns of X.</p>
</td></tr>
<tr><td><code id="plmm_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the MCP/SCAD penalty (see details). Default is 3 for MCP and 3.7 for SCAD.</p>
</td></tr>
<tr><td><code id="plmm_+3A_alpha">alpha</code></td>
<td>
<p>Tuning parameter for the Mnet estimator which controls the relative contributions from the MCP/SCAD penalty and the ridge, or L2 penalty. alpha=1 is equivalent to MCP/SCAD penalty, while alpha=0 would be equivalent to ridge regression. However, alpha=0 is not supported; alpha may be arbitrarily small, but not exactly 0.</p>
</td></tr>
<tr><td><code id="plmm_+3A_lambda_min">lambda_min</code></td>
<td>
<p>The smallest value for lambda, as a fraction of lambda.max. Default is .001 if the number of observations is larger than the number of covariates and .05 otherwise.</p>
</td></tr>
<tr><td><code id="plmm_+3A_nlambda">nlambda</code></td>
<td>
<p>Length of the sequence of lambda. Default is 100.</p>
</td></tr>
<tr><td><code id="plmm_+3A_lambda">lambda</code></td>
<td>
<p>A user-specified sequence of lambda values. By default, a sequence of values of length nlambda is computed, equally spaced on the log scale.</p>
</td></tr>
<tr><td><code id="plmm_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold. The algorithm iterates until the RMSD for the change in linear predictors for each coefficient is less than eps. Default is <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="plmm_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations (total across entire path). Default is 10000.</p>
</td></tr>
<tr><td><code id="plmm_+3A_warn">warn</code></td>
<td>
<p>Return warning messages for failures to converge and model saturation? Default is TRUE.</p>
</td></tr>
<tr><td><code id="plmm_+3A_trace">trace</code></td>
<td>
<p>If set to TRUE, inform the user of progress by announcing the beginning of each step of the modeling process. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plmm_+3A_save_rds">save_rds</code></td>
<td>
<p>Optional: if a filepath and name <em>without</em> the '.rds' suffix is specified (e.g., <code>save_rds = "~/dir/my_results"</code>), then the model results are saved to the provided location (e.g., &quot;~/dir/my_results.rds&quot;).
Accompanying the RDS file is a log file for documentation, e.g., &quot;~/dir/my_results.log&quot;.
Defaults to NULL, which does not save any RDS or log files.</p>
</td></tr>
<tr><td><code id="plmm_+3A_return_fit">return_fit</code></td>
<td>
<p>Optional: a logical value indicating whether the fitted model should be returned as a <code>plmm</code> object in the current (assumed interactive) session.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plmm_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to <code>plmm_checks()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list which includes 19 items:
</p>

<ul>
<li><p> beta_vals: The matrix of estimated coefficients. Rows are predictors (with the first row being the intercept), and columns are values of <code>lambda</code>.
</p>
</li>
<li><p> std_Xbeta: A matrix of the linear predictors on the scale of the standardized design matrix. Rows are predictors, columns are values of <code>lambda</code>.
<strong>Note</strong>: std_Xbeta will not include rows for the intercept or for constant features.
</p>
</li>
<li><p> std_X_details: A list with 9 items:
- center: The center values used to center the columns of the design matrix
- scale: The scaling values used to scale the columns of the design matrix
- ns: An integer vector of the nonsingular columns of the original data
- unpen: An integer vector of indices of the unpenalized features, if any were specified in the design
- unpen_colnames: A charater vector of the column names of ay unpenalized features.
- X_colnames: A character vector with the column names of all features in the original design matrix
- X_rownames: A character vector with the row names of all features in the original design matrix; if none were provided, these are named 'row1', 'row2', etc.
- std_X_colnames: A subset of X_colnames representing only nonsignular columns (i.e., the columns indexed by 'ns')
- std_X_rownames: A subset of X_rownames representing rows that passed QC filtering &amp; and are represented in both the genotype and phenotype data sets (this only applies to PLINK data)
</p>
</li>
<li><p> std_X: If design matrix is filebacked, the descriptor for the filebacked data is returned using <code>bigmemory::describe()</code>. If the the data were stored in-memory, nothing is returned (std_X is NULL).
</p>
</li>
<li><p> y: The outcome vector used in model fitting.
</p>
</li>
<li><p> p: The total number of columns in the design matrix (including any singular columns, excluding the intercept).
</p>
</li>
<li><p> plink_flag: Logical - did the data come from PLINK files?
</p>
</li>
<li><p> lambda: A numeric vector of the tuning parameter values used in model fitting.
</p>
</li>
<li><p> eta: A double between 0 and 1 representing the estimated proportion of the variance in the outcome attributable to population/correlation structure
</p>
</li>
<li><p> penalty: A character string indicating the penalty with which the model was fit (e.g., 'MCP')
</p>
</li>
<li><p> gamma: A numeric value indicating the tuning parameter used for the SCAD or lasso penalties was used. Not relevant for lasso models.
</p>
</li>
<li><p> alpha: A numeric value indicating the elastic net tuning parameter.
</p>
</li>
<li><p> loss: A vector with the numeric values of the loss at each value of <code>lambda</code> (calculated on the ~rotated~ scale)
</p>
</li>
<li><p> penalty_factor: A vector of indicators corresponding to each predictor, where 1 = predictor was penalized.
</p>
</li>
<li><p> ns_idx: An integer vector with the indices of predictors which were non-singular features (i.e., features which had variation), where feature 1 is the intercept.
</p>
</li>
<li><p> iter: An integer vector with the number of iterations needed in model fitting for each value of <code>lambda</code>
</p>
</li>
<li><p> converged: A vector of logical values indicating whether the model fitting converged at each value of <code>lambda</code>
</p>
</li>
<li><p> K: a list with 2 elements, <code>s</code> and <code>U</code> &mdash;
</p>

<ul>
<li><p> s: a vector of the eigenvalues of the relatedness matrix K (note: K is the kinship matrix for genetic/genomic data; see the article on notation for details)
</p>
</li>
<li><p> U: a matrix of the eigenvectors of the relatedness matrix
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># using admix data
admix_design &lt;- create_design(X = admix$X, y = admix$y)
fit &lt;- plmm(design = admix_design)
s &lt;- summary(fit, idx = 50)
print(s)
plot(fit)

# Note: for examples with large data that are too big to fit in memory,
# see the article "PLINK files/file-backed matrices" on our website
# https://pbreheny.github.io/plmmr/articles/filebacking.html

</code></pre>

<hr>
<h2 id='plmm_checks'>plmm_checks</h2><span id='topic+plmm_checks'></span>

<h3>Description</h3>

<p>plmm_checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmm_checks(
  design,
  K = NULL,
  diag_K = NULL,
  eta_star = NULL,
  penalty = "lasso",
  init = NULL,
  gamma,
  alpha = 1,
  trace = FALSE,
  save_rds = NULL,
  return_fit = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plmm_checks_+3A_design">design</code></td>
<td>
<p>The design object, as created by <code>create_design()</code></p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_k">K</code></td>
<td>
<p>Similarity matrix used to rotate the data. This should either be (1) a known matrix that reflects the covariance of y, (2) an estimate (Default is <code class="reqn">\frac{1}{p}(XX^T)</code>), or (3) a list with components 'd' and 'u', as returned by choose_k().</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_diag_k">diag_K</code></td>
<td>
<p>Logical: should K be a diagonal matrix? This would reflect observations that are unrelated, or that can be treated as unrelated. Defaults to FALSE.
Note: plmm() does not check to see if a matrix is diagonal. If you want to use a diagonal K matrix, you must set diag_K = TRUE.</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_eta_star">eta_star</code></td>
<td>
<p>Optional argument to input a specific eta term rather than estimate it from the data. If K is a known covariance matrix that is full rank, this should be 1.</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_penalty">penalty</code></td>
<td>
<p>The penalty to be applied to the model. Either &quot;MCP&quot; (the default), &quot;SCAD&quot;, or &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_init">init</code></td>
<td>
<p>Initial values for coefficients. Default is 0 for all columns of X.</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the MCP/SCAD penalty (see details). Default is 3 for MCP and 3.7 for SCAD.</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_alpha">alpha</code></td>
<td>
<p>Tuning parameter for the Mnet estimator which controls the relative contributions from the MCP/SCAD penalty and the ridge, or L2 penalty. alpha=1 is equivalent to MCP/SCAD penalty, while alpha=0 would be equivalent to ridge regression. However, alpha=0 is not supported; alpha may be arbitrarily small, but not exactly 0.</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_trace">trace</code></td>
<td>
<p>If set to TRUE, inform the user of progress by announcing the beginning of each step of the modeling process. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_save_rds">save_rds</code></td>
<td>
<p>Optional: if a filepath and name is specified (e.g., <code>save_rds = "~/dir/my_results.rds"</code>), then the model results are saved to the provided location. Defaults to NULL, which does not save the result.</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_return_fit">return_fit</code></td>
<td>
<p>Optional: a logical value indicating whether the fitted model should be returned as a <code>plmm</code> object in the current (assumed interactive) session. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plmm_checks_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>get_data()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters to pass on to model fitting. The list includes the standardized design matrix, the outcome, and meta-data
</p>

<hr>
<h2 id='plmm_fit'>PLMM fit: a function that fits a PLMM using the values returned by plmm_prep()</h2><span id='topic+plmm_fit'></span>

<h3>Description</h3>

<p>PLMM fit: a function that fits a PLMM using the values returned by plmm_prep()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmm_fit(
  prep,
  y,
  std_X_details,
  eta_star,
  penalty_factor,
  fbm_flag,
  penalty,
  gamma = 3,
  alpha = 1,
  lambda_min,
  nlambda = 100,
  lambda,
  eps = 1e-04,
  max_iter = 10000,
  init = NULL,
  warn = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plmm_fit_+3A_prep">prep</code></td>
<td>
<p>A list as returned from <code>plmm_prep</code></p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_y">y</code></td>
<td>
<p>The original (not centered) outcome vector. Need this for intercept estimate</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_std_x_details">std_X_details</code></td>
<td>
<p>A list with components 'center' (values used to center X), 'scale' (values used to scale X), and 'ns' (indices for nonsignular columns of X)</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_eta_star">eta_star</code></td>
<td>
<p>The ratio of variances (passed from plmm())</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_penalty_factor">penalty_factor</code></td>
<td>
<p>A multiplicative factor for the penalty applied to each coefficient. If supplied, penalty_factor must be a numeric vector of length equal to the number of columns of X. The purpose of penalty_factor is to apply differential penalization if some coefficients are thought to be more likely than others to be in the model. In particular, penalty_factor can be 0, in which case the coefficient is always in the model without shrinkage.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_fbm_flag">fbm_flag</code></td>
<td>
<p>Logical: is std_X an FBM object? Passed from <code>plmm()</code>.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_penalty">penalty</code></td>
<td>
<p>The penalty to be applied to the model. Either &quot;MCP&quot; (the default), &quot;SCAD&quot;, or &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the MCP/SCAD penalty (see details). Default is 3 for MCP and 3.7 for SCAD.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_alpha">alpha</code></td>
<td>
<p>Tuning parameter for the Mnet estimator which controls the relative contributions from the MCP/SCAD penalty and the ridge, or L2 penalty. alpha=1 is equivalent to MCP/SCAD penalty, while alpha=0 would be equivalent to ridge regression. However, alpha=0 is not supported; alpha may be arbitrarily small, but not exactly 0.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_lambda_min">lambda_min</code></td>
<td>
<p>The smallest value for lambda, as a fraction of lambda.max. Default is .001 if the number of observations is larger than the number of covariates and .05 otherwise.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_nlambda">nlambda</code></td>
<td>
<p>Length of the sequence of lambda. Default is 100.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_lambda">lambda</code></td>
<td>
<p>A user-specified sequence of lambda values. By default, a sequence of values of length nlambda is computed, equally spaced on the log scale.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_eps">eps</code></td>
<td>
<p>Convergence threshold. The algorithm iterates until the RMSD for the change in linear predictors for each coefficient is less than eps. Default is <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations (total across entire path). Default is 10000.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_init">init</code></td>
<td>
<p>Initial values for coefficients. Default is 0 for all columns of X.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_warn">warn</code></td>
<td>
<p>Return warning messages for failures to converge and model saturation? Default is TRUE.</p>
</td></tr>
<tr><td><code id="plmm_fit_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed to <code>biglasso::biglasso_simple_path()</code></p>
</td></tr>
</table>

<hr>
<h2 id='plmm_format'>PLMM format: a function to format the output of a model constructed with <code>plmm_fit</code></h2><span id='topic+plmm_format'></span>

<h3>Description</h3>

<p>PLMM format: a function to format the output of a model constructed with <code>plmm_fit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmm_format(fit, p, std_X_details, fbm_flag, plink_flag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plmm_format_+3A_fit">fit</code></td>
<td>
<p>A list of parameters describing the output of a model constructed with <code>plmm_fit</code></p>
</td></tr>
<tr><td><code id="plmm_format_+3A_p">p</code></td>
<td>
<p>The number of features in the original data (including constant features)</p>
</td></tr>
<tr><td><code id="plmm_format_+3A_std_x_details">std_X_details</code></td>
<td>
<p>A list with 3 items:
* 'center': the centering values for the columns of <code>X</code>
* 'scale': the scaling values for the non-singular columns of <code>X</code>
* 'ns': indicesof nonsingular columns in <code>std_X</code></p>
</td></tr>
<tr><td><code id="plmm_format_+3A_fbm_flag">fbm_flag</code></td>
<td>
<p>Logical: is the corresponding design matrix filebacked? Passed from <code>plmm()</code>.</p>
</td></tr>
<tr><td><code id="plmm_format_+3A_plink_flag">plink_flag</code></td>
<td>
<p>Logical: did these data come from PLINK files?
<strong>Note</strong>: This flag matters because of how non-genomic features
are handled for PLINK files &ndash; in data from PLINK files,
unpenalized columns are <em>not</em> counted in the <code>p</code> argument. For delimited
files, <code>p</code> does include unpenalized columns. This difference has
implications for how the <code>untransform()</code> function determines the
appropriate dimensions for the estimated coefficient matrix it returns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components:
</p>

<ul>
<li> <p><code>beta_vals</code>: the matrix of estimated coefficients on the original scale. Rows are predictors, columns are values of <code>lambda</code>
</p>
</li>
<li> <p><code>lambda</code>: a numeric vector of the lasso tuning parameter values used in model fitting.
</p>
</li>
<li> <p><code>eta</code>: a number (double) between 0 and 1 representing the estimated proportion of the variance in the outcome attributable to population/correlation structure.
</p>
</li>
<li> <p><code>s</code>: a vectof of the eigenvalues of relatedness matrix <code>K</code>; see <code>relatedness_mat()</code> for details.
</p>
</li>
<li> <p><code>U</code>: a matrix of the eigenvalues of relatedness matrix <code>K</code>
</p>
</li>
<li> <p><code>rot_y</code>: the vector of outcome values on the rotated scale. This is the scale on which the model was fit.
</p>
</li>
<li> <p><code>linear_predictors</code>: the matrix resulting from the product of <code>stdrot_X</code> and the estimated coefficients on the ~rotated~ scale.
</p>
</li>
<li> <p><code>penalty</code>: character string indicating the penalty with which the model was fit (e.g., 'MCP')
</p>
</li>
<li> <p><code>gamma</code>: numeric value indicating the tuning parameter used for the SCAD or lasso penalties was used. Not relevant for lasso models.
</p>
</li>
<li> <p><code>alpha</code>: numeric value indicating the elastic net tuning parameter.
</p>
</li>
<li> <p><code>loss</code>: vector with the numeric values of the loss at each value of <code>lambda</code> (calculated on the ~rotated~ scale)
</p>
</li>
<li> <p><code>penalty_factor</code>: vector of indicators corresponding to each predictor, where 1 = predictor was penalized.
</p>
</li>
<li> <p><code>ns_idx</code>: vector with the indices of predictors which were nonsingular features (i.e., had variation).
</p>
</li>
<li> <p><code>iter</code>: numeric vector with the number of iterations needed in model fitting for each value of <code>lambda</code>
</p>
</li>
<li> <p><code>converged</code>: vector of logical values indicating whether the model fitting converged at each value of <code>lambda</code>
</p>
</li></ul>


<hr>
<h2 id='plmm_loss'>Loss method for &quot;plmm&quot; class</h2><span id='topic+plmm_loss'></span>

<h3>Description</h3>

<p>Loss method for &quot;plmm&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmm_loss(y, yhat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plmm_loss_+3A_y">y</code></td>
<td>
<p>Observed outcomes (response) vector</p>
</td></tr>
<tr><td><code id="plmm_loss_+3A_yhat">yhat</code></td>
<td>
<p>Predicted outcomes (response) vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the squared-error loss values for the given
observed and predicted outcomes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>admix_design &lt;- create_design(X = admix$X, y = admix$y)
fit &lt;- plmm(design = admix_design, K = relatedness_mat(admix$X))
yhat &lt;- predict(object = fit, newX = admix$X, type = 'lp', lambda = 0.05)
head(plmm_loss(yhat = yhat, y = admix$y))

</code></pre>

<hr>
<h2 id='plmm_prep'>PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model
This is an internal function for <code>cv_plmm</code></h2><span id='topic+plmm_prep'></span>

<h3>Description</h3>

<p>PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model
This is an internal function for <code>cv_plmm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmm_prep(
  std_X,
  std_X_n,
  std_X_p,
  n,
  p,
  centered_y,
  K = NULL,
  diag_K = NULL,
  eta_star = NULL,
  fbm_flag,
  trace = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plmm_prep_+3A_std_x">std_X</code></td>
<td>
<p>Column standardized design matrix. May include clinical covariates and other non-SNP data.</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_std_x_n">std_X_n</code></td>
<td>
<p>The number of observations in std_X (integer)</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_std_x_p">std_X_p</code></td>
<td>
<p>The number of features in std_X (integer)</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_n">n</code></td>
<td>
<p>The number of instances in the <em>original</em> design matrix X. This should not be altered by standardization.</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_p">p</code></td>
<td>
<p>The number of features in the <em>original</em> design matrix X, including constant features</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_centered_y">centered_y</code></td>
<td>
<p>Continuous outcome vector, centered.</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_k">K</code></td>
<td>
<p>Similarity matrix used to rotate the data. This should either be a known matrix that reflects the covariance of y, or an estimate (Default is <code class="reqn">\frac{1}{p}(XX^T)</code>, where X is standardized). This can also be a list, with components d and u (as returned by choose_k)</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_diag_k">diag_K</code></td>
<td>
<p>Logical: should K be a diagonal matrix? This would reflect observations that are unrelated, or that can be treated as unrelated. Passed from <code>plmm()</code>.</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_eta_star">eta_star</code></td>
<td>
<p>Optional argument to input a specific eta term rather than estimate it from the data. If K is a known covariance matrix that is full rank, this should be 1.</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_fbm_flag">fbm_flag</code></td>
<td>
<p>Logical: is std_X an FBM type object? This is set internally by <code>plmm()</code>.</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_trace">trace</code></td>
<td>
<p>If set to TRUE, inform the user of progress by announcing the beginning of each step of the modeling process. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plmm_prep_+3A_...">...</code></td>
<td>
<p>Not used yet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with these components:
</p>

<ul>
<li><p> centered_y: The vector of centered outcomes
</p>
</li>
<li><p> std_X: standardized design matrix
</p>
</li>
<li><p> K: a list with 2 elements. (1) s: vector with the eigenvalues of K,
and (2) U: the eigenvectors of K (same as left singular values of X).
</p>
</li>
<li><p> eta: the numeric value of the estimated eta parameter
</p>
</li>
<li><p> trace: logical.
</p>
</li></ul>


<hr>
<h2 id='plot.cv_plmm'>Plot method for cv_plmm class</h2><span id='topic+plot.cv_plmm'></span>

<h3>Description</h3>

<p>Plot method for cv_plmm class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv_plmm'
plot(
  x,
  log.l = TRUE,
  type = c("cve", "rsq", "scale", "snr", "all"),
  selected = TRUE,
  vertical.line = TRUE,
  col = "red",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cv_plmm_+3A_x">x</code></td>
<td>
<p>An object of class cv_plmm</p>
</td></tr>
<tr><td><code id="plot.cv_plmm_+3A_log.l">log.l</code></td>
<td>
<p>Logical to indicate the plot should be returned on the natural log scale. Defaults to <code>log.l = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.cv_plmm_+3A_type">type</code></td>
<td>
<p>Type of plot to return. Defaults to &quot;cve.&quot;</p>
</td></tr>
<tr><td><code id="plot.cv_plmm_+3A_selected">selected</code></td>
<td>
<p>Logical to indicate which variables should be plotted. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.cv_plmm_+3A_vertical.line">vertical.line</code></td>
<td>
<p>Logical to indicate whether vertical line should be plotted at the minimum/maximum value. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.cv_plmm_+3A_col">col</code></td>
<td>
<p>Color for vertical line, if plotted. Defaults to &quot;red.&quot;</p>
</td></tr>
<tr><td><code id="plot.cv_plmm_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned; instead, a plot is drawn representing the relationship
between the tuning parameter 'lambda' value (x-axis) and the cross validation error (y-axis).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>admix_design &lt;- create_design(X = admix$X, y = admix$y)
cvfit &lt;- cv_plmm(design = admix_design)
plot(cvfit)

</code></pre>

<hr>
<h2 id='plot.plmm'>Plot method for plmm class</h2><span id='topic+plot.plmm'></span>

<h3>Description</h3>

<p>Plot method for plmm class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plmm'
plot(x, alpha = 1, log.l = FALSE, shade = TRUE, col, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.plmm_+3A_x">x</code></td>
<td>
<p>An object of class <code>plmm</code></p>
</td></tr>
<tr><td><code id="plot.plmm_+3A_alpha">alpha</code></td>
<td>
<p>Tuning parameter for the Mnet estimator which controls the relative contributions from the MCP/SCAD penalty and the ridge, or L2 penalty. <code>alpha=1</code> is equivalent to MCP/SCAD penalty, while <code>alpha=0</code> would be equivalent to ridge regression. However, <code>alpha=0</code> is not supported; alpha may be arbitrarily small, but not exactly 0.</p>
</td></tr>
<tr><td><code id="plot.plmm_+3A_log.l">log.l</code></td>
<td>
<p>Logical to indicate the plot should be returned on the natural log scale. Defaults to <code>log.l = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.plmm_+3A_shade">shade</code></td>
<td>
<p>Logical to indicate whether a local nonconvex region should be shaded. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.plmm_+3A_col">col</code></td>
<td>
<p>Vector of colors for coefficient lines.</p>
</td></tr>
<tr><td><code id="plot.plmm_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned; instead, a plot of the coefficient paths is drawn
at each value of lambda (one 'path' for each coefficient).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>admix_design &lt;- create_design(X = admix$X, y = admix$y)
fit &lt;- plmm(design = admix_design)
plot(fit)
plot(fit, log.l = TRUE)
</code></pre>

<hr>
<h2 id='predict_within_cv'>Predict method to use in cross-validation (within <code>cvf</code>)</h2><span id='topic+predict_within_cv'></span>

<h3>Description</h3>

<p>Predict method to use in cross-validation (within <code>cvf</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_within_cv(
  fit,
  testX,
  type,
  fbm = FALSE,
  Sigma_11 = NULL,
  Sigma_21 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_within_cv_+3A_fit">fit</code></td>
<td>
<p>A list with the components returned by <code>plmm_fit</code>.</p>
</td></tr>
<tr><td><code id="predict_within_cv_+3A_testx">testX</code></td>
<td>
<p>A design matrix used for computing predicted values (i.e, the test data).</p>
</td></tr>
<tr><td><code id="predict_within_cv_+3A_type">type</code></td>
<td>
<p>A character argument indicating what type of prediction should be returned. Passed from <code>cvf()</code>,
Options are &quot;lp,&quot; &quot;coefficients,&quot; &quot;vars,&quot; &quot;nvars,&quot; and &quot;blup.&quot; See details.</p>
</td></tr>
<tr><td><code id="predict_within_cv_+3A_fbm">fbm</code></td>
<td>
<p>Logical: is trainX an FBM object? If so, this function expects that testX is also an FBM. The two X matrices must be stored the same way.</p>
</td></tr>
<tr><td><code id="predict_within_cv_+3A_sigma_11">Sigma_11</code></td>
<td>
<p>Variance-covariance matrix of the training data. Extracted from <code>estimated_Sigma</code> that is generated using all observations. Required if <code>type == 'blup'</code>.</p>
</td></tr>
<tr><td><code id="predict_within_cv_+3A_sigma_21">Sigma_21</code></td>
<td>
<p>Covariance matrix between the training and the testing data. Extracted from <code>estimated_Sigma</code> that is generated using all observations. Required if <code>type == 'blup'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define beta-hat as the coefficients estimated at the value of lambda that minimizes cross-validation error (CVE). Then options for <code>type</code> are as follows:
</p>

<ul>
<li><p> 'lp' (default): uses the linear predictor (i.e., product of test data and estimated coefficients) to predict test values of the outcome.
Note that this approach does not incorporate the correlation structure of the data.
</p>
</li>
<li><p> 'blup' (acronym for Best Linear Unbiased Predictor): adds to the 'lp' a value that represents the estimated random effect.
This addition is a way of incorporating the estimated correlation structure of data into our prediction of the outcome.
</p>
</li></ul>

<p>Note: the main difference between this function and the <code>predict.plmm()</code> method is that
here in CV, the standardized testing data (std_test_X), Sigma_11, and Sigma_21 are calculated in <code>cvf()</code> instead of the function defined here.
</p>


<h3>Value</h3>

<p>A numeric vector of predicted values
</p>

<hr>
<h2 id='predict.plmm'>Predict method for plmm class</h2><span id='topic+predict.plmm'></span>

<h3>Description</h3>

<p>Predict method for plmm class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plmm'
predict(
  object,
  newX,
  type = c("blup", "coefficients", "vars", "nvars", "lp"),
  X = NULL,
  lambda,
  idx = 1:length(object$lambda),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.plmm_+3A_object">object</code></td>
<td>
<p>An object of class <code>plmm</code>.</p>
</td></tr>
<tr><td><code id="predict.plmm_+3A_newx">newX</code></td>
<td>
<p>Matrix of values at which predictions are to be made (not used for
<code>type="coefficients"</code> or for some of the <code>type</code> settings in <code>predict</code>).
This can be either a FBM object or a 'matrix' object.
<strong>Note</strong>: Columns of this argument must be named!</p>
</td></tr>
<tr><td><code id="predict.plmm_+3A_type">type</code></td>
<td>
<p>A character argument indicating what type of prediction should be
returned. Options are &quot;lp,&quot; &quot;coefficients,&quot; &quot;vars,&quot; &quot;nvars,&quot; and &quot;blup.&quot; See details.</p>
</td></tr>
<tr><td><code id="predict.plmm_+3A_x">X</code></td>
<td>
<p>Optional: if <code>type = 'blup'</code> and the model was fit in-memory, the design matrix used to fit the model represented in <code>object</code> must be supplied.
When supplied, this design matrix will be standardized using the center/scale values in <code>object$std_X_details</code>, so please <strong>do not</strong> standardize this matrix before supplying here.
<strong>Note</strong>: If the model was fit file-backed, then the filepath to the .bk file with this standardized design matrix is returned as 'std_X' in the fit supplied to 'object'.</p>
</td></tr>
<tr><td><code id="predict.plmm_+3A_lambda">lambda</code></td>
<td>
<p>A numeric vector of regularization parameter <code>lambda</code> values
at which predictions are requested.</p>
</td></tr>
<tr><td><code id="predict.plmm_+3A_idx">idx</code></td>
<td>
<p>Vector of indices of the penalty parameter <code>lambda</code> at which
predictions are required. By default, all indices are returned.</p>
</td></tr>
<tr><td><code id="predict.plmm_+3A_...">...</code></td>
<td>
<p>Additional optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define beta-hat as the coefficients estimated at the value of lambda that minimizes cross-validation error (CVE). Then options for <code>type</code> are as follows:
</p>

<ul>
<li><p> 'response' (default): uses the product of newX and beta-hat to predict new values of the outcome. This does not incorporate the correlation structure of the data.
For the stats folks out there, this is simply the linear predictor.
</p>
</li>
<li><p> 'blup' (acronym for Best Linear Unbiased Predictor): adds to the 'response' a value that represents the esetimated random effect. This addition is a way of incorporating
the estimated correlation structure of data into our prediction of the outcome.
</p>
</li>
<li><p> 'coefficients': returns the estimated beta-hat
</p>
</li>
<li><p> 'vars': returns the <em>indices</em> of variables (e.g., SNPs) with nonzero coefficients at each value of lambda. EXCLUDES intercept.
</p>
</li>
<li><p> 'nvars': returns the <em>number</em> of variables (e.g., SNPs) with nonzero coefficients at each value of lambda. EXCLUDES intercept.
</p>
</li></ul>



<h3>Value</h3>

<p>Depends on the <code>type</code> - see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
train_idx &lt;- sample(1:nrow(admix$X), 100)
# Note: ^ shuffling is important here! Keeps test and train groups comparable.
train &lt;- list(X = admix$X[train_idx,], y = admix$y[train_idx])
train_design &lt;- create_design(X = train$X, y = train$y)

test &lt;- list(X = admix$X[-train_idx,], y = admix$y[-train_idx])
fit &lt;- plmm(design = train_design)

# make predictions for all lambda values
 pred1 &lt;- predict(object = fit, newX = test$X, type = "lp")
 pred2 &lt;- predict(object = fit, newX = test$X, type = "blup", X = train$X)

# look at mean squared prediction error
mspe &lt;- apply(pred1, 2, function(c){crossprod(test$y - c)/length(c)})
min(mspe)

mspe_blup &lt;- apply(pred2, 2, function(c){crossprod(test$y - c)/length(c)})
min(mspe_blup) # BLUP is better

# compare the MSPE of our model to a null model, for reference
# null model = intercept only -&gt; y_hat is always mean(y)
crossprod(mean(test$y) - test$y)/length(test$y)


</code></pre>

<hr>
<h2 id='pretty_time'>a function to format the time</h2><span id='topic+pretty_time'></span>

<h3>Description</h3>

<p>a function to format the time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty_time()
</code></pre>


<h3>Value</h3>

<p>A string with the formatted current date and time
</p>

<hr>
<h2 id='print.summary.cv_plmm'>Print method for summary.cv_plmm objects</h2><span id='topic+print.summary.cv_plmm'></span>

<h3>Description</h3>

<p>Print method for summary.cv_plmm objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.cv_plmm'
print(x, digits, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.cv_plmm_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.cv_plmm</code></p>
</td></tr>
<tr><td><code id="print.summary.cv_plmm_+3A_digits">digits</code></td>
<td>
<p>The number of digits to use in formatting output</p>
</td></tr>
<tr><td><code id="print.summary.cv_plmm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned; instead, a message is printed to the console
summarizing the results of the cross-validated model fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>admix_design &lt;- create_design(X = admix$X, y = admix$y)
cv_fit &lt;- cv_plmm(design = admix_design)
print(summary(cv_fit))

</code></pre>

<hr>
<h2 id='print.summary.plmm'>A function to print the summary of a <code>plmm</code> model</h2><span id='topic+print.summary.plmm'></span>

<h3>Description</h3>

<p>A function to print the summary of a <code>plmm</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.plmm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.plmm_+3A_x">x</code></td>
<td>
<p>A <code>summary.plmm</code> object</p>
</td></tr>
<tr><td><code id="print.summary.plmm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned; instead, a message is printed to the console
summarizing the results of the model fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lam &lt;- rev(seq(0.01, 1, length.out=20)) |&gt; round(2) # for sake of example
admix_design &lt;- create_design(X = admix$X, y = admix$y)
fit &lt;- plmm(design = admix_design, lambda = lam)
fit2 &lt;- plmm(design = admix_design, penalty = "SCAD", lambda = lam)
print(summary(fit, idx = 18))
print(summary(fit2, idx = 18))
</code></pre>

<hr>
<h2 id='process_delim'>A function to read in large data files as an FBM</h2><span id='topic+process_delim'></span>

<h3>Description</h3>

<p>A function to read in large data files as an FBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_delim(
  data_dir,
  data_file,
  feature_id,
  rds_dir = data_dir,
  rds_prefix,
  logfile = NULL,
  overwrite = FALSE,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_delim_+3A_data_dir">data_dir</code></td>
<td>
<p>The directory to the file.</p>
</td></tr>
<tr><td><code id="process_delim_+3A_data_file">data_file</code></td>
<td>
<p>The file to be read in, without the filepath. This should be a file of numeric values.
Example: use <code>data_file = "myfile.txt"</code>, not <code>data_file = "~/mydirectory/myfile.txt"</code>
Note: if your file has headers/column names, set 'header = TRUE' &ndash; this will be passed into <code>bigmemory::read.big.matrix()</code>.</p>
</td></tr>
<tr><td><code id="process_delim_+3A_feature_id">feature_id</code></td>
<td>
<p>A string specifying the column in the data X (the feature data) with the row IDs (e.g., identifiers for each row/sample/participant/, etc.). No duplicates allowed.</p>
</td></tr>
<tr><td><code id="process_delim_+3A_rds_dir">rds_dir</code></td>
<td>
<p>The directory where the user wants to create the '.rds' and '.bk' files
Defaults to <code>data_dir</code></p>
</td></tr>
<tr><td><code id="process_delim_+3A_rds_prefix">rds_prefix</code></td>
<td>
<p>String specifying the user's preferred filename for the to-be-created .rds file (will be create insie <code>rds_dir</code> folder)
Note: 'rds_prefix' cannot be the same as 'data_prefix'</p>
</td></tr>
<tr><td><code id="process_delim_+3A_logfile">logfile</code></td>
<td>
<p>Optional: the name (character string) of the prefix of the
logfile to be written. Defaults to 'process_delim', i.e. you will get 'process_delim.log' as the outfile.</p>
</td></tr>
<tr><td><code id="process_delim_+3A_overwrite">overwrite</code></td>
<td>
<p>Optional: the name (character string) of the prefix of the logfile to be written.
Defaults to 'process_plink', i.e. you will get 'process_plink.log' as the outfile.
<strong>Note</strong>: If there are multiple <code>.rds</code> files with names that start with &quot;std_prefix_...&quot;, <strong>this will error out</strong>.
To protect users from accidentally deleting files with saved results, only one <code>.rds</code> file can be removed with this option.</p>
</td></tr>
<tr><td><code id="process_delim_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should the messages printed to the console be silenced? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="process_delim_+3A_...">...</code></td>
<td>
<p>Optional: other arguments to be passed to <code>bigmemory::read.big.matrix()</code>. Note: 'sep' is an option to pass here, as is 'header'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The file path to the newly created '.rds' file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temp_dir &lt;- tempdir()
colon_dat &lt;- process_delim(data_file = "colon2.txt",
 data_dir = find_example_data(parent = TRUE), overwrite = TRUE,
 rds_dir = temp_dir, rds_prefix = "processed_colon2", sep = "\t", header = TRUE)

colon2 &lt;- readRDS(colon_dat)
str(colon2)

</code></pre>

<hr>
<h2 id='process_plink'>Preprocess PLINK files using the <code>bigsnpr</code> package</h2><span id='topic+process_plink'></span>

<h3>Description</h3>

<p>Preprocess PLINK files using the <code>bigsnpr</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_plink(
  data_dir,
  data_prefix,
  rds_dir = data_dir,
  rds_prefix,
  logfile = NULL,
  impute = TRUE,
  impute_method = "mode",
  id_var = "IID",
  parallel = TRUE,
  quiet = FALSE,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_plink_+3A_data_dir">data_dir</code></td>
<td>
<p>The path to the bed/bim/fam data files, <em>without</em> a trailing &quot;/&quot; (e.g., use <code>data_dir = '~/my_dir'</code>, <strong>not</strong> <code>data_dir = '~/my_dir/'</code>)</p>
</td></tr>
<tr><td><code id="process_plink_+3A_data_prefix">data_prefix</code></td>
<td>
<p>The prefix (as a character string) of the bed/fam data files (e.g., <code>data_prefix = 'mydata'</code>)</p>
</td></tr>
<tr><td><code id="process_plink_+3A_rds_dir">rds_dir</code></td>
<td>
<p>The path to the directory in which you want to create the new '.rds' and '.bk' files. Defaults to <code>data_dir</code></p>
</td></tr>
<tr><td><code id="process_plink_+3A_rds_prefix">rds_prefix</code></td>
<td>
<p>String specifying the user's preferred filename for the to-be-created .rds file (will be create insie <code>rds_dir</code> folder)
Note: 'rds_prefix' cannot be the same as 'data_prefix'</p>
</td></tr>
<tr><td><code id="process_plink_+3A_logfile">logfile</code></td>
<td>
<p>Optional: the name (character string) of the prefix of the logfile to be written in 'rds_dir'. Default to NULL (no log file written).
Note: if you supply a file path in this argument, it will error out with a &quot;file not found&quot; error. Only supply the string; e.g., if you want my_log.log, supply 'my_log', the my_log.log file will appear in rds_dir.</p>
</td></tr>
<tr><td><code id="process_plink_+3A_impute">impute</code></td>
<td>
<p>Logical: should data be imputed? Default to TRUE.</p>
</td></tr>
<tr><td><code id="process_plink_+3A_impute_method">impute_method</code></td>
<td>
<p>If 'impute' = TRUE, this argument will specify the kind of imputation desired. Options are:
* mode (default): Imputes the most frequent call. See <code>bigsnpr::snp_fastImputeSimple()</code> for details.
* random: Imputes sampling according to allele frequencies.
* mean0: Imputes the rounded mean.
* mean2: Imputes the mean rounded to 2 decimal places.
* xgboost: Imputes using an algorithm based on local XGBoost models. See <code>bigsnpr::snp_fastImpute()</code> for details. Note: this can take several minutes, even for a relatively small data set.</p>
</td></tr>
<tr><td><code id="process_plink_+3A_id_var">id_var</code></td>
<td>
<p>String specifying which column of the PLINK <code>.fam</code> file has the unique sample identifiers. Options are &quot;IID&quot; (default) and &quot;FID&quot;</p>
</td></tr>
<tr><td><code id="process_plink_+3A_parallel">parallel</code></td>
<td>
<p>Logical: should the computations within this function be run in parallel? Defaults to TRUE. See <code>count_cores()</code> and <code>?bigparallelr::assert_cores</code> for more details.
In particular, the user should be aware that too much parallelization can make computations <em>slower</em>.</p>
</td></tr>
<tr><td><code id="process_plink_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages to be printed to the console be silenced? Defaults to FALSE</p>
</td></tr>
<tr><td><code id="process_plink_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical: if existing <code>.bk</code>/<code>.rds</code> files exist for the specified directory/prefix, should these be overwritten? Defaults to FALSE. Set to TRUE if you want to change the imputation method you're using, etc.
<strong>Note</strong>: If there are multiple <code>.rds</code> files with names that start with &quot;std_prefix_...&quot;, <strong>this will error out</strong>.
To protect users from accidentally deleting files with saved results, only one <code>.rds</code> file can be removed with this option.</p>
</td></tr>
<tr><td><code id="process_plink_+3A_...">...</code></td>
<td>
<p>Optional: additional arguments to <code>bigsnpr::snp_fastImpute()</code> (relevant only if impute_method = &quot;xgboost&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three files are created in the location specified by <code>rds_dir</code>:
</p>

<ul>
<li><p> 'rds_prefix.rds': This is a list with three items:
(1) <code>X</code>: the filebacked <code>bigmemory::big.matrix</code> object pointing to the imputed genotype data.
This matrix has type 'double', which is important for downstream operations in <code>create_design()</code>
(2) <code>map</code>: a data.frame with the PLINK 'bim' data (i.e., the variant information)
(3) <code>fam</code>: a data.frame with the PLINK 'fam' data (i.e., the pedigree information)
</p>
</li>
<li><p> 'prefix.bk': This is the
backingfile that stores the numeric data of the genotype matrix
</p>
</li>
<li><p> 'rds_prefix.desc'&quot; This is the description file, as needed by the
</p>
</li></ul>

<p>Note that <code>process_plink()</code> need only be run once for a given set of PLINK
files; in subsequent data analysis/scripts, <code>get_data()</code> will access the '.rds' file.
</p>
<p>For an example, see vignette on processing PLINK files
</p>


<h3>Value</h3>

<p>The filepath to the '.rds' object created; see details for explanation.
</p>

<hr>
<h2 id='read_data_files'>A function to read in a large file as a numeric file-backed matrix (<code>FBM</code>)
Note: this function is a wrapper for <code>bigstatsr::big_read()</code></h2><span id='topic+read_data_files'></span>

<h3>Description</h3>

<p>A function to read in a large file as a numeric file-backed matrix (<code>FBM</code>)
Note: this function is a wrapper for <code>bigstatsr::big_read()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_data_files(
  data_file,
  data_dir,
  rds_dir,
  rds_prefix,
  outfile,
  overwrite,
  quiet,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_data_files_+3A_data_file">data_file</code></td>
<td>
<p>The name of the file to read, not including its directory. Directory should be specified in <code>data_dir</code></p>
</td></tr>
<tr><td><code id="read_data_files_+3A_data_dir">data_dir</code></td>
<td>
<p>The path to the directory where 'file' is</p>
</td></tr>
<tr><td><code id="read_data_files_+3A_rds_dir">rds_dir</code></td>
<td>
<p>The path to the directory in which you want to create the new '.rds' and '.bk' files. Defaults to <code>data_dir</code></p>
</td></tr>
<tr><td><code id="read_data_files_+3A_rds_prefix">rds_prefix</code></td>
<td>
<p>String specifying the user's preferred filename for the to-be-created .rds/.bk files (will be create insie <code>rds_dir</code> folder)
Note: 'rds_prefix' cannot be the same as 'data_file'</p>
</td></tr>
<tr><td><code id="read_data_files_+3A_outfile">outfile</code></td>
<td>
<p>Optional: the name (character string) of the prefix of the logfile to be written. Defaults to 'process_plink', i.e. you will get 'process_plink.log' as the outfile.</p>
</td></tr>
<tr><td><code id="read_data_files_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical: if existing <code>.bk</code>/<code>.rds</code> files exist for the specified directory/prefix, should these be overwritten? Defaults to FALSE. Set to TRUE if you want to change the imputation method you're using, etc.</p>
</td></tr>
<tr><td><code id="read_data_files_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages be printed to the console? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="read_data_files_+3A_...">...</code></td>
<td>
<p>Optional: other arguments to be passed to <code>bigmemory::read.big.matrix()</code>. Note: 'sep' is an option to pass here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'.rds', '.bk', and '.desc' files are created in <code>data_dir</code>, and <code>obj</code> (a filebacked <code style="white-space: pre;">&#8288;bigmemory big.matrix&#8288;</code> object) is returned. See <code>bigmemory</code> documentation for more info on the <code>big.matrix</code> class.
</p>

<hr>
<h2 id='read_plink_files'>A function to read in PLINK files using <code>bigsnpr</code> methods</h2><span id='topic+read_plink_files'></span>

<h3>Description</h3>

<p>A function to read in PLINK files using <code>bigsnpr</code> methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_plink_files(
  data_dir,
  data_prefix,
  rds_dir,
  outfile,
  parallel,
  overwrite,
  quiet
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_plink_files_+3A_data_dir">data_dir</code></td>
<td>
<p>The path to the bed/bim/fam data files, <em>without</em> a trailing &quot;/&quot; (e.g., use <code>data_dir = '~/my_dir'</code>, <strong>not</strong> <code>data_dir = '~/my_dir/'</code>)</p>
</td></tr>
<tr><td><code id="read_plink_files_+3A_data_prefix">data_prefix</code></td>
<td>
<p>The prefix (as a character string) of the bed/fam data files (e.g., <code>prefix = 'mydata'</code>)</p>
</td></tr>
<tr><td><code id="read_plink_files_+3A_rds_dir">rds_dir</code></td>
<td>
<p>The path to the directory in which you want to create the new '.rds' and '.bk' files. Defaults to <code>data_dir</code></p>
</td></tr>
<tr><td><code id="read_plink_files_+3A_outfile">outfile</code></td>
<td>
<p>Optional: the name (character string) of the prefix of the logfile to be written. Defaults to 'process_plink', i.e. you will get 'process_plink.log' as the outfile.</p>
</td></tr>
<tr><td><code id="read_plink_files_+3A_parallel">parallel</code></td>
<td>
<p>Logical: should the computations within this function be run in parallel? Defaults to TRUE. See <code>count_cores()</code> and <code>?bigparallelr::assert_cores</code> for more details.
In particular, the user should be aware that too much parallelization can make computations <em>slower</em>.</p>
</td></tr>
<tr><td><code id="read_plink_files_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical: if existing <code>.bk</code>/<code>.rds</code> files exist for the specified directory/prefix, should these be overwritten? Defaults to FALSE. Set to TRUE if you want to change the imputation method you're using, etc.</p>
</td></tr>
<tr><td><code id="read_plink_files_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages be printed to the console? Defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'.rds' and '.bk' files are created in <code>data_dir</code>, and <code>obj</code> (a <code>bigSNP</code> object) is returned. See <code>bigsnpr</code> documentation for more info on the <code>bigSNP</code> class.
</p>

<hr>
<h2 id='relatedness_mat'>Calculate a relatedness matrix</h2><span id='topic+relatedness_mat'></span>

<h3>Description</h3>

<p>Given a matrix of genotypes, this function estimates the genetic relatedness matrix (GRM,
also known as the RRM, see Hayes et al. 2009, <a href="https://doi.org/10.1017/S0016672308009981">doi:10.1017/S0016672308009981</a>) among
the subjects: XX'/p, where X is standardized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedness_mat(X, std = TRUE, fbm = FALSE, ns = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relatedness_mat_+3A_x">X</code></td>
<td>
<p>An n x p numeric matrix of genotypes (from <em>fully-imputed</em> data).
Note: This matrix should <em>not</em> include non-genetic features.</p>
</td></tr>
<tr><td><code id="relatedness_mat_+3A_std">std</code></td>
<td>
<p>Logical: should X be standardized? If you set this to FALSE (which can only be done
if data are stored in memory), you should have a good reason for doing so, as standardization
is a best practice.</p>
</td></tr>
<tr><td><code id="relatedness_mat_+3A_fbm">fbm</code></td>
<td>
<p>Logical: is X stored as an FBM? Defaults to FALSE</p>
</td></tr>
<tr><td><code id="relatedness_mat_+3A_ns">ns</code></td>
<td>
<p>Optional vector of values indicating the indices of nonsingular features</p>
</td></tr>
<tr><td><code id="relatedness_mat_+3A_...">...</code></td>
<td>
<p>Other optional arguments to <code>bigstatsr::bigapply()</code> (like <code>ncores = ...</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An n x n numeric matrix capturing the genomic relatedness of the
samples represented in <code>X</code>. In our notation, we call this matrix K for 'kinship';
this is also known as the GRM or RRM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RRM &lt;- relatedness_mat(X = admix$X)
RRM[1:5, 1:5]
</code></pre>

<hr>
<h2 id='rotate_filebacked'>A function to rotate filebacked data</h2><span id='topic+rotate_filebacked'></span>

<h3>Description</h3>

<p>A function to rotate filebacked data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_filebacked(prep, ...)
</code></pre>


<h3>Value</h3>

<p>a list with 4 items:
</p>

<ul>
<li><p> stdrot_X: <code>X</code> on the rotated and re-standardized scale
</p>
</li>
<li><p> rot_y: <code>y</code> on the rotated scale (a numeric vector)
</p>
</li>
<li><p> stdrot_X_center: numeric vector of values used to center <code>rot_X</code>
</p>
</li>
<li><p> stdrot_X_scale: numeric vector of values used to scale <code>rot_X</code>
</p>
</li></ul>


<hr>
<h2 id='SCAD'>helper function to implement SCAD penalty</h2><span id='topic+SCAD'></span>

<h3>Description</h3>

<p>helper function to implement SCAD penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCAD(z, l1, l2, gamma, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SCAD_+3A_z">z</code></td>
<td>
<p>solution over active set at each feature</p>
</td></tr>
<tr><td><code id="SCAD_+3A_l1">l1</code></td>
<td>
<p>upper bound</p>
</td></tr>
<tr><td><code id="SCAD_+3A_l2">l2</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="SCAD_+3A_gamma">gamma</code></td>
<td>
<p>The tuning parameter of the SCAD penalty</p>
</td></tr>
<tr><td><code id="SCAD_+3A_v">v</code></td>
<td>
<p>the 'xtx' term</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of the SCAD-penalized coefficient estimates within the given bounds
</p>

<hr>
<h2 id='setup_lambda'>Compute sequence of lambda values</h2><span id='topic+setup_lambda'></span>

<h3>Description</h3>

<p>This function allows you compute a sequence of lambda values for plmm models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_lambda(
  X,
  y,
  alpha,
  lambda_min,
  nlambda,
  penalty_factor,
  intercept = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_lambda_+3A_x">X</code></td>
<td>
<p>Rotated and standardized design matrix which <em>includes</em> the intercept column if present. May include clinical covariates and other non-SNP data. This can be either a 'matrix' or 'FBM' object.</p>
</td></tr>
<tr><td><code id="setup_lambda_+3A_y">y</code></td>
<td>
<p>Continuous outcome vector.</p>
</td></tr>
<tr><td><code id="setup_lambda_+3A_alpha">alpha</code></td>
<td>
<p>Tuning parameter for the Mnet estimator which controls the relative contributions from the MCP/SCAD penalty and the ridge, or L2 penalty. alpha=1 is equivalent to MCP/SCAD penalty, while alpha=0 would be equivalent to ridge regression. However, alpha=0 is not supported; alpha may be arbitrarily small, but not exactly 0.</p>
</td></tr>
<tr><td><code id="setup_lambda_+3A_lambda_min">lambda_min</code></td>
<td>
<p>The smallest value for lambda, as a fraction of lambda.max. Default is .001 if the number of observations is larger than the number of covariates and .05 otherwise. A value of lambda_min = 0 is not supported.</p>
</td></tr>
<tr><td><code id="setup_lambda_+3A_nlambda">nlambda</code></td>
<td>
<p>The desired number of lambda values in the sequence to be generated.</p>
</td></tr>
<tr><td><code id="setup_lambda_+3A_penalty_factor">penalty_factor</code></td>
<td>
<p>A multiplicative factor for the penalty applied to each coefficient. If supplied, penalty_factor must be a numeric vector of length equal to the number of columns of X. The purpose of penalty_factor is to apply differential penalization if some coefficients are thought to be more likely than others to be in the model. In particular, penalty_factor can be 0, in which case the coefficient is always in the model without shrinkage.</p>
</td></tr>
<tr><td><code id="setup_lambda_+3A_intercept">intercept</code></td>
<td>
<p>Logical: does X contain an intercept column? Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of lambda values, equally spaced on the log scale
</p>

<hr>
<h2 id='standardize_filebacked'>A helper function to standardize a filebacked matrix</h2><span id='topic+standardize_filebacked'></span>

<h3>Description</h3>

<p>A helper function to standardize a filebacked matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_filebacked(
  X,
  new_file,
  rds_dir,
  non_gen,
  complete_outcome,
  id_var,
  outfile,
  quiet,
  overwrite
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_filebacked_+3A_x">X</code></td>
<td>
<p>A list that includes:
(1) subset_X: a <code>big.matrix</code> object that has been subset &amp;/or had any additional predictors appended as columns
(2) ns: a numeric vector indicating the indices of nonsingular columns in subset_X</p>
</td></tr>
<tr><td><code id="standardize_filebacked_+3A_new_file">new_file</code></td>
<td>
<p>The new_file (as a character string) of the bed/fam data files (e.g., <code>new_file = 'mydata'</code>)</p>
</td></tr>
<tr><td><code id="standardize_filebacked_+3A_rds_dir">rds_dir</code></td>
<td>
<p>The path to the directory in which you want to create the new '.rds' and '.bk' files. Defaults to <code>data_dir</code></p>
</td></tr>
<tr><td><code id="standardize_filebacked_+3A_outfile">outfile</code></td>
<td>
<p>Optional: the name (character string) of the new_file of the logfile to be written. Defaults to 'process_plink', i.e. you will get 'process_plink.log' as the outfile.</p>
</td></tr>
<tr><td><code id="standardize_filebacked_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages be printed to the console? Defaults to FALSE (which leaves the print messages on...)</p>
</td></tr>
<tr><td><code id="standardize_filebacked_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical: if existing <code>.bk</code>/<code>.rds</code> files exist for the specified directory/new_file, should these be overwritten?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a new component of <code>obj</code> called 'std_X' - this is an FBM with column-standardized data.
List also includes several other indices/meta-data on the standardized matrix
</p>

<hr>
<h2 id='standardize_in_memory'>A helper function to standardize matrices</h2><span id='topic+standardize_in_memory'></span>

<h3>Description</h3>

<p>A helper function to standardize matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_in_memory(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_in_memory_+3A_x">X</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is adapted from https://github.com/pbreheny/ncvreg/blob/master/R/std.R
NOTE: this function returns a matrix <strong>in memory</strong>. For standardizing filebacked
data, use <code>big_std()</code>  &ndash; see src/big_standardize.cpp
</p>


<h3>Value</h3>

<p>a list with the standardized matrix, vectors with the centering/scaling values, and a vector with the indices of nonsingular columns
</p>

<hr>
<h2 id='subset_filebacked'>A helper function to subset <code>big.matrix</code> objects</h2><span id='topic+subset_filebacked'></span>

<h3>Description</h3>

<p>A helper function to subset <code>big.matrix</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_filebacked(X, new_file, complete_samples, ns, rds_dir, outfile, quiet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_filebacked_+3A_x">X</code></td>
<td>
<p>A filebacked <code>big.matrix</code> with the to-be-standardized design matrix</p>
</td></tr>
<tr><td><code id="subset_filebacked_+3A_new_file">new_file</code></td>
<td>
<p>Optional user-specified new_file for the to-be-created .rds/.bk files.</p>
</td></tr>
<tr><td><code id="subset_filebacked_+3A_complete_samples">complete_samples</code></td>
<td>
<p>Numeric vector with indicesmarking the rows of the original data which have a non-missing entry in the 6th column of the <code>.fam</code> file</p>
</td></tr>
<tr><td><code id="subset_filebacked_+3A_ns">ns</code></td>
<td>
<p>Numeric vector with the indices of the non-singular columns
This vector is created in <code>handle_missingness()</code></p>
</td></tr>
<tr><td><code id="subset_filebacked_+3A_rds_dir">rds_dir</code></td>
<td>
<p>The path to the directory in which you want to create the new '.rds' and '.bk' files. Defaults to <code>data_dir</code></p>
</td></tr>
<tr><td><code id="subset_filebacked_+3A_outfile">outfile</code></td>
<td>
<p>Optional: the name (character string) of the new_file of the logfile to be written. Defaults to 'process_plink', i.e. you will get 'process_plink.log' as the outfile.</p>
</td></tr>
<tr><td><code id="subset_filebacked_+3A_quiet">quiet</code></td>
<td>
<p>Logical: should messages be printed to the console? Defaults to FALSE (which leaves the print messages on...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components. First, a <code>big.matrix</code> object, 'subset_X', representing a design matrix wherein:
</p>

<ul>
<li><p> rows are subset according to user's specification in <code>handle_missing_phen</code>
</p>
</li>
<li><p> columns are subset so that no constant features remain &ndash; this is important for standardization downstream
The list also includes the integer vector 'ns' which marks which columns of the original matrix were 'non-singular' (i.e. <em>not</em> constant features).
The 'ns' index plays an important role in <code>plmm_format()</code> and <code>untransform()</code> (both helper functions in model fitting)
</p>
</li></ul>


<hr>
<h2 id='summary.cv_plmm'>A summary function for cv_plmm objects</h2><span id='topic+summary.cv_plmm'></span>

<h3>Description</h3>

<p>A summary function for cv_plmm objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv_plmm'
summary(object, lambda = "min", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cv_plmm_+3A_object">object</code></td>
<td>
<p>A <code>cv_plmm</code> object</p>
</td></tr>
<tr><td><code id="summary.cv_plmm_+3A_lambda">lambda</code></td>
<td>
<p>The regularization parameter value at which inference should be reported. Can choose a numeric value, 'min', or '1se'. Defaults to 'min.'</p>
</td></tr>
<tr><td><code id="summary.cv_plmm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is an object with S3 class <code>summary.cv_plmm</code>. The class has its own print method and contains the following list elements:
</p>

<ul>
<li> <p><code>lambda_min</code>: The lambda value at the minimum cross validation error
</p>
</li>
<li> <p><code>lambda.1se</code>: The maximum lambda value within 1 standard error of the minimum cross validation error
</p>
</li>
<li> <p><code>penalty</code>: The penalty applied to the fitted model
</p>
</li>
<li> <p><code>nvars</code>: The number of non-zero coefficients at the selected lambda value
</p>
</li>
<li> <p><code>cve</code>: The cross validation error at all folds
</p>
</li>
<li> <p><code>min</code>: The minimum cross validation error
</p>
</li>
<li> <p><code>fit</code>: The <code>plmm</code> fit used in the cross validation
</p>
</li></ul>

<p>if <code>return_bias_details = TRUE</code>, two more items are returned:
</p>

<ul>
<li> <p><code>bias</code>: The mean bias of the cross validation
</p>
</li>
<li> <p><code>loss</code>: The loss at each value of <code>lambda</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>admix_design &lt;- create_design(X = admix$X, y = admix$y)
cv_fit &lt;- cv_plmm(design = admix_design)
summary(cv_fit)
</code></pre>

<hr>
<h2 id='summary.plmm'>A summary method for the plmm objects</h2><span id='topic+summary.plmm'></span>

<h3>Description</h3>

<p>A summary method for the plmm objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plmm'
summary(object, lambda, idx, eps = 1e-05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.plmm_+3A_object">object</code></td>
<td>
<p>An object of class <code>plmm</code></p>
</td></tr>
<tr><td><code id="summary.plmm_+3A_lambda">lambda</code></td>
<td>
<p>The regularization parameter value at which inference should be reported.</p>
</td></tr>
<tr><td><code id="summary.plmm_+3A_idx">idx</code></td>
<td>
<p>Alternatively, <code>lambda</code> may be specified by an index; <code>idx=10</code> means:
report inference for the 10th value of <code>lambda</code> along the regularization path. If both <code>lambda</code> and <code>idx</code> are specified, <code>lambda</code> takes precedence.</p>
</td></tr>
<tr><td><code id="summary.plmm_+3A_eps">eps</code></td>
<td>
<p>If lambda is given, eps is the tolerance for difference between the given lambda value and a lambda value from the object. Defaults to 0.0001 (1e-5)</p>
</td></tr>
<tr><td><code id="summary.plmm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is an object with S3 class <code>summary.plmm</code>. The class has its own print method and contains the following list elements:
</p>

<ul>
<li> <p><code>penalty</code>: The penalty used by <code>plmm</code> (e.g. SCAD, MCP, lasso)
</p>
</li>
<li> <p><code>n</code>: Number of instances/observations
</p>
</li>
<li> <p><code>std_X_n</code>: the number of observations in the standardized data;
the only time this would differ from 'n' is if data are from PLINK and the external data does not include all the same samples
</p>
</li>
<li> <p><code>p</code>: Number of regression coefficients (not including the intercept)
</p>
</li>
<li> <p><code>converged</code>: Logical indicator for whether the model converged
</p>
</li>
<li> <p><code>lambda</code>: The <code>lambda</code> value at which inference is being reported
</p>
</li>
<li> <p><code>lambda_char</code>: A formatted character string indicating the lambda value
</p>
</li>
<li> <p><code>nvars</code>: The number of nonzero coefficients (again, not including the intercept) at that value of <code>lambda</code>
</p>
</li>
<li> <p><code>nonzero</code>: The column names indicating the nonzero coefficients in the model at the specified value of <code>lambda</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>admix_design &lt;- create_design(X = admix$X, y = admix$y)
fit &lt;- plmm(design = admix_design)
summary(fit, idx = 97)
</code></pre>

<hr>
<h2 id='untransform'>Untransform coefficient values back to the original scale</h2><span id='topic+untransform'></span>

<h3>Description</h3>

<p>This function unwinds the initial standardization of the data to obtain
coefficient values on their original scale. It is called by plmm_format().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untransform(
  std_scale_beta,
  p,
  std_X_details,
  fbm_flag,
  plink_flag,
  use_names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="untransform_+3A_std_scale_beta">std_scale_beta</code></td>
<td>
<p>The estimated coefficients on the standardized scale</p>
</td></tr>
<tr><td><code id="untransform_+3A_p">p</code></td>
<td>
<p>The number of columns in the original design matrix</p>
</td></tr>
<tr><td><code id="untransform_+3A_std_x_details">std_X_details</code></td>
<td>
<p>A list with 3 elements describing the standardized design matrix BEFORE rotation; this should have elements 'scale', 'center', and 'ns'</p>
</td></tr>
<tr><td><code id="untransform_+3A_fbm_flag">fbm_flag</code></td>
<td>
<p>Logical: is the corresponding design matrix filebacked?</p>
</td></tr>
<tr><td><code id="untransform_+3A_plink_flag">plink_flag</code></td>
<td>
<p>Logical: did these data come from PLINK files?
<strong>Note</strong>: This flag matters because of how non-genomic features
are handled for PLINK files &ndash; in data from PLINK files,
unpenalized columns are <em>not</em> counted in the <code>p</code> argument. For delimited
files, <code>p</code> does include unpenalized columns. This difference has
implications for how the <code>untransform()</code> function determines the
appropriate dimensions for the estimated coefficient matrix it returns.</p>
</td></tr>
<tr><td><code id="untransform_+3A_use_names">use_names</code></td>
<td>
<p>Logical: should names be added? Defaults to TRUE. Set to FALSE inside of <code>cvf()</code> helper, as 'ns' will vary within CV folds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of estimated coeffcients, 'beta_vals', that is on the scale of the original data.
</p>

<hr>
<h2 id='untransform_delim'>Untransform coefficient values back to the original scale for <strong>file-backed</strong> data</h2><span id='topic+untransform_delim'></span>

<h3>Description</h3>

<p>This function unwinds the initial standardization of the data to obtain
coefficient values on their original scale. It is called by plmm_format().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untransform_delim(
  std_scale_beta,
  p,
  std_X_details,
  plink_flag,
  use_names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="untransform_delim_+3A_std_scale_beta">std_scale_beta</code></td>
<td>
<p>The estimated coefficients on the standardized scale</p>
</td></tr>
<tr><td><code id="untransform_delim_+3A_p">p</code></td>
<td>
<p>The number of columns in the original design matrix</p>
</td></tr>
<tr><td><code id="untransform_delim_+3A_std_x_details">std_X_details</code></td>
<td>
<p>A list with 3 elements describing the standardized design matrix BEFORE rotation; this should have elements 'scale', 'center', and 'ns'</p>
</td></tr>
<tr><td><code id="untransform_delim_+3A_use_names">use_names</code></td>
<td>
<p>Logical: should names be added? Defaults to TRUE. Set to FALSE inside of <code>cvf()</code> helper, as 'ns' will vary within CV folds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of estimated coeffcients, 'beta_vals', that is on the scale of the original data.
</p>

<hr>
<h2 id='untransform_in_memory'>Untransform coefficient values back to the original scale <em>In memory</em></h2><span id='topic+untransform_in_memory'></span>

<h3>Description</h3>

<p>This function unwinds the initial standardization of the data to obtain
coefficient values on their original scale. It is called by plmm_format().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untransform_in_memory(std_scale_beta, p, std_X_details, use_names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="untransform_in_memory_+3A_std_scale_beta">std_scale_beta</code></td>
<td>
<p>The estimated coefficients on the standardized scale</p>
</td></tr>
<tr><td><code id="untransform_in_memory_+3A_p">p</code></td>
<td>
<p>The number of columns in the original design matrix</p>
</td></tr>
<tr><td><code id="untransform_in_memory_+3A_std_x_details">std_X_details</code></td>
<td>
<p>A list with 3 elements describing the standardized design matrix BEFORE rotation; this should have elements 'scale', 'center', and 'ns'</p>
</td></tr>
<tr><td><code id="untransform_in_memory_+3A_use_names">use_names</code></td>
<td>
<p>Logical: should names be added? Defaults to TRUE. Set to FALSE inside of <code>cvf()</code> helper, as 'ns' will vary within CV folds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of estimated coeffcients, 'beta_vals', that is on the scale of the original data.
</p>

<hr>
<h2 id='untransform_plink'>Untransform coefficient values back to the original scale for <strong>file-backed</strong> data</h2><span id='topic+untransform_plink'></span>

<h3>Description</h3>

<p>This function unwinds the initial standardization of the data to obtain
coefficient values on their original scale. It is called by plmm_format().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untransform_plink(
  std_scale_beta,
  p,
  std_X_details,
  plink_flag,
  use_names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="untransform_plink_+3A_std_scale_beta">std_scale_beta</code></td>
<td>
<p>The estimated coefficients on the standardized scale</p>
</td></tr>
<tr><td><code id="untransform_plink_+3A_p">p</code></td>
<td>
<p>The number of columns in the original design matrix</p>
</td></tr>
<tr><td><code id="untransform_plink_+3A_std_x_details">std_X_details</code></td>
<td>
<p>A list with 3 elements describing the standardized design matrix BEFORE rotation; this should have elements 'scale', 'center', and 'ns'</p>
</td></tr>
<tr><td><code id="untransform_plink_+3A_use_names">use_names</code></td>
<td>
<p>Logical: should names be added? Defaults to TRUE. Set to FALSE inside of <code>cvf()</code> helper, as 'ns' will vary within CV folds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of estimated coeffcients, 'beta_vals', that is on the scale of the original data.
</p>

<hr>
<h2 id='unzip_example_data'>For Linux/Unix and MacOS only, here is a companion function to unzip the .gz files that ship with the <code>plmmr</code> package</h2><span id='topic+unzip_example_data'></span>

<h3>Description</h3>

<p>For Linux/Unix and MacOS only, here is a companion function to unzip the .gz files that ship with the <code>plmmr</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unzip_example_data(outdir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unzip_example_data_+3A_outdir">outdir</code></td>
<td>
<p>The file path to the directory to which the .gz files should be written</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an example of this function, look at <code>vignette('plink_files', package = "plmmr")</code>.
Note again: this function will not work on Windows systems - only for Linux/Unix and MacOS.
</p>


<h3>Value</h3>

<p>Nothing is returned; the PLINK files that ship with the <code>plmmr</code> package are stored in the directory specified by 'outdir'
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
