<!DOCTYPE html><html lang="en"><head><title>Help for package roots</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {roots}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#animPlot'><p>Animation plot</p></a></li>
<li><a href='#animPlotGif'><p>Generates a GIF animating</p></a></li>
<li><a href='#applyGaussianKernelwithVariableSigma'><p>Apply Gaussian Kernel using Laleh Haghverdi's variable sigma</p></a></li>
<li><a href='#bgGeneNorm'><p>Normalise by background gene set</p></a></li>
<li><a href='#calculateVariableSigmas'><p>Calculates sigmas for a distance matrix</p></a></li>
<li><a href='#colGrad'><p>Generates a smooth colour gradient</p></a></li>
<li><a href='#diffuseMat'><p>Generic diffusion function</p></a></li>
<li><a href='#diffuseProj'><p>Predicts diffusion map projection from new data points</p></a></li>
<li><a href='#fastDist'><p>Fast vectorised Euclidean distance calculator</p></a></li>
<li><a href='#filterGenes'><p>Filter genes</p></a></li>
<li><a href='#findLouvain'><p>Louvain clustering on transition matrix</p></a></li>
<li><a href='#fnc'><p>Find next cell function</p></a></li>
<li><a href='#getTraj'><p>Find a plausible developmental journey</p></a></li>
<li><a href='#goggles'><p>View single cell dataset</p></a></li>
<li><a href='#sparseMarkov'><p>Make markov matrix sparse</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Reconstructing Ordered Ontogenic Trajectories</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools to reconstruct ordered ontogenic trajectories from
    single cell RNAseq data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>animation (&ge; 2.4), rARPACK (&ge; 0.11-0), igraph (&ge; 1.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-11 15:11:38 UTC; wajid</td>
</tr>
<tr>
<td>Author:</td>
<td>Wajid Jawaid [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wajid Jawaid &lt;wj241@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-07-11 16:52:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='animPlot'>Animation plot</h2><span id='topic+animPlot'></span>

<h3>Description</h3>

<p>Animation plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animPlot(data, ccm, delay = 0.1, darken = 1, lwd = 1, c.cex = 1,
  main = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="animPlot_+3A_data">data</code></td>
<td>
<p>Dimensionality reduction plot</p>
</td></tr>
<tr><td><code id="animPlot_+3A_ccm">ccm</code></td>
<td>
<p>Dataframe of indices and momentums</p>
</td></tr>
<tr><td><code id="animPlot_+3A_delay">delay</code></td>
<td>
<p>Delay between frames in seconds</p>
</td></tr>
<tr><td><code id="animPlot_+3A_darken">darken</code></td>
<td>
<p>Passed to colGrad() function</p>
</td></tr>
<tr><td><code id="animPlot_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="animPlot_+3A_c.cex">c.cex</code></td>
<td>
<p>Size of poiints.</p>
</td></tr>
<tr><td><code id="animPlot_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="animPlot_+3A_...">...</code></td>
<td>
<p>Passed to plot() function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Animation plot
Generates plot in base R that gradually updates giving the impression of an animation
</p>


<h3>Value</h3>

<p>Generates plot
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xx &lt;- animPlot(x, ccm)

## End(Not run)
</code></pre>

<hr>
<h2 id='animPlotGif'>Generates a GIF animating</h2><span id='topic+animPlotGif'></span>

<h3>Description</h3>

<p>Generates a GIF animation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animPlotGif(data, ccm, delay = 0.1, darken = 1, lwd = 1, c.cex = 1,
  main = "", gif = "animation", img.name = "tempPlot", plot.par = NULL,
  point.col = "#333333", arrowLength = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="animPlotGif_+3A_data">data</code></td>
<td>
<p>Reduced dimensionality map to be used for visualisation</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_ccm">ccm</code></td>
<td>
<p>Dataframe of indices and momentums</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_delay">delay</code></td>
<td>
<p>Delay between frames in seconds</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_darken">darken</code></td>
<td>
<p>Passed to colGrad() function</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_c.cex">c.cex</code></td>
<td>
<p>Size of poiints.</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_main">main</code></td>
<td>
<p>Title</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_gif">gif</code></td>
<td>
<p>Name of movie</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_img.name">img.name</code></td>
<td>
<p>Name of temporary image files generated</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_plot.par">plot.par</code></td>
<td>
<p>Passed to R base par() function</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_point.col">point.col</code></td>
<td>
<p>Colour of background points</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_arrowlength">arrowLength</code></td>
<td>
<p>Modify length of arrow</p>
</td></tr>
<tr><td><code id="animPlotGif_+3A_...">...</code></td>
<td>
<p>Passed to plot() function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a GIF animation
</p>


<h3>Value</h3>

<p>Produces an animated GIF with given file name
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xx &lt;- animPlotGif(x, ccm, gif = "animation")

## End(Not run)
</code></pre>

<hr>
<h2 id='applyGaussianKernelwithVariableSigma'>Apply Gaussian Kernel using Laleh Haghverdi's variable sigma</h2><span id='topic+applyGaussianKernelwithVariableSigma'></span>

<h3>Description</h3>

<p>Apply Gaussian Kernel using Laleh Haghverdi's variable sigma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyGaussianKernelwithVariableSigma(d2, rsigmas, csigmas = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="applyGaussianKernelwithVariableSigma_+3A_d2">d2</code></td>
<td>
<p>Squared distance metric</p>
</td></tr>
<tr><td><code id="applyGaussianKernelwithVariableSigma_+3A_rsigmas">rsigmas</code></td>
<td>
<p>Sigmas for cells in the rows</p>
</td></tr>
<tr><td><code id="applyGaussianKernelwithVariableSigma_+3A_csigmas">csigmas</code></td>
<td>
<p>Sigmas for cells in the columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apply Gaussian Kernel using Laleh Haghverdi's variable sigma
</p>


<h3>Value</h3>

<p>Returns matrix of same size as d2.
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d &lt;- applyGaussianKernelwithVariableSigma(dist, sigmas)

## End(Not run)
</code></pre>

<hr>
<h2 id='bgGeneNorm'>Normalise by background gene set</h2><span id='topic+bgGeneNorm'></span>

<h3>Description</h3>

<p>Normalise by background gene set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgGeneNorm(x, threshold = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bgGeneNorm_+3A_x">x</code></td>
<td>
<p>Matrix to be normalised with cells in rows and
genes in columns</p>
</td></tr>
<tr><td><code id="bgGeneNorm_+3A_threshold">threshold</code></td>
<td>
<p>Default 0.05. The threshold below which a gene is
deemed background</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normalise by background gene set.
Find background genes that are expressed at a lower percentage of
the total library size per cell than 'threshold' parameter. These
genes are used to calculate a normalisation factor.
</p>


<h3>Value</h3>

<p>Returns a normalised matrix of same dimenions as 'x'
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
normGenes &lt;- bgGeneNorm(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='calculateVariableSigmas'>Calculates sigmas for a distance matrix</h2><span id='topic+calculateVariableSigmas'></span>

<h3>Description</h3>

<p>Calculates sigmas for a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateVariableSigmas(d, knn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateVariableSigmas_+3A_d">d</code></td>
<td>
<p>Square distance matrix with 0 diagonal</p>
</td></tr>
<tr><td><code id="calculateVariableSigmas_+3A_knn">knn</code></td>
<td>
<p>Number of nearest neighbours to use for calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates sigmas for a distance matrix
Using Laleh Hagherverdi's method
</p>


<h3>Value</h3>

<p>Returns a vector of sigmas
</p>


<h3>Author(s)</h3>

<p>wj241
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sigmas &lt;- calculateVariableSigmas(dist, 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='colGrad'>Generates a smooth colour gradient</h2><span id='topic+colGrad'></span>

<h3>Description</h3>

<p>Generates a smooth colour gradient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colGrad(x, darken = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colGrad_+3A_x">x</code></td>
<td>
<p>Number of colours required</p>
</td></tr>
<tr><td><code id="colGrad_+3A_darken">darken</code></td>
<td>
<p>Multiplication factor. Must be less than 1. Smaller the darker.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a smooth colour gradient
Goes from red to red/green to green to green/blue to blue to blu/red
</p>


<h3>Value</h3>

<p>Returns vector of RGB colours
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gradientColors &lt;- colGrad(10)
</code></pre>

<hr>
<h2 id='diffuseMat'>Generic diffusion function</h2><span id='topic+diffuseMat'></span>

<h3>Description</h3>

<p>Generic diffusion function using automated
individualised sigma calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffuseMat(data, ndims = 20, nsig = 5, removeFirst = TRUE,
  useARPACK = TRUE, distfun = NULL, sigmas = NULL, sqdistmat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffuseMat_+3A_data">data</code></td>
<td>
<p>Matrix of data with genes in rows and cells in columns.</p>
</td></tr>
<tr><td><code id="diffuseMat_+3A_ndims">ndims</code></td>
<td>
<p>Number of dimensions to return</p>
</td></tr>
<tr><td><code id="diffuseMat_+3A_nsig">nsig</code></td>
<td>
<p>For automatic sigma calculation</p>
</td></tr>
<tr><td><code id="diffuseMat_+3A_removefirst">removeFirst</code></td>
<td>
<p>Default TRUE. Removes the first eigenvector</p>
</td></tr>
<tr><td><code id="diffuseMat_+3A_usearpack">useARPACK</code></td>
<td>
<p>Default TRUE. Uses Arnoldi algorithm for eignvector calculations</p>
</td></tr>
<tr><td><code id="diffuseMat_+3A_distfun">distfun</code></td>
<td>
<p>A different distance function that returns the <strong>squared</strong>
distance</p>
</td></tr>
<tr><td><code id="diffuseMat_+3A_sigmas">sigmas</code></td>
<td>
<p>Manually provide sigma</p>
</td></tr>
<tr><td><code id="diffuseMat_+3A_sqdistmat">sqdistmat</code></td>
<td>
<p><strong>Squared</strong> distance matrix.
Give your own squared distance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic diffusion function using automated individualised sigma calculation.
</p>
<p>A Gaussian kernel is applied to the chosen distance metric producing
an <code class="reqn">n \times n</code> square unnormalised symmetric transition matrix, <code class="reqn">A</code>.
Let <code class="reqn">D</code> be an <code class="reqn">n \times n</code> diagonal matrix with row(column) sums of
<code class="reqn">A</code> as entries. The density corrected transition matrix will now
be:
</p>
<p style="text-align: center;"><code class="reqn">D^{-1} A D^{-1}</code>
</p>

<p>and can be normalised:
</p>
<p style="text-align: center;"><code class="reqn">B^{-1} D^{-1} A D^{-1}</code>
</p>

<p>where <code class="reqn">B</code> is an <code class="reqn">n \times n</code> diagonal matrix with row sums of
the density corrected transition matrix as entries. The eigen decomposition of
this matrix can be simplified by solving the symmetric system:
</p>
<p style="text-align: center;"><code class="reqn">B^{-\frac{1}{2}} D^{-1} A D^{-1} B^{-\frac{1}{2}} R^\prime = %
      R^\prime \lambda^\prime</code>
</p>

<p>where <code class="reqn">R^\prime</code> is a matrix of the right eigenvectors that solve
the system and <code class="reqn">\lambda^\prime</code> is the corresponding eigenvalue
diagonal matrix. Now the solution of:
</p>
<p style="text-align: center;"><code class="reqn">B^{-1} D^{-1} A D^{-1} R = R \lambda</code>
</p>

<p>in terms of <code class="reqn">R^\prime</code> and <code class="reqn">B^{-\frac{1}{2}}</code> is:
</p>
<p style="text-align: center;"><code class="reqn">B^{-1} D^{-1} A D^{-1} B^{-\frac{1}{2}} R^\prime = %
      B^{-\frac{1}{2}} R^\prime \lambda^\prime</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">R = B^{-\frac{1}{2}} R^\prime</code>
</p>

<p>This <code class="reqn">R</code> without the first eigen vector is returned as the diffusion map.
</p>


<h3>Value</h3>

<p>List output containing:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <em>values</em> </td><td style="text-align: left;"> Eigenvalues, excluding the first eigenvalue, which should
                      always be 1.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>vectors</em> </td><td style="text-align: left;"> Matrix of eigen vectors in columns, first eigen vector
                       removed.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>nconv</em> </td><td style="text-align: left;"> Number of eigen vectors/values that converged.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>niter</em> </td><td style="text-align: left;"> Iterations taken for Arnoldi algorithm to converge.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>nops</em> </td><td style="text-align: left;">  Number of operations. </td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>val0</em> </td><td style="text-align: left;"> 1st eigen value - should be 1. If not be suspicious!</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>vec0</em> </td><td style="text-align: left;"> 1st eigen vector - should be <code class="reqn">n^{-\frac{1}{2}}</code>,
                     where n is the number of cells/samples.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>usedARPACK</em> </td><td style="text-align: left;"> Predicates use of ARPACK for spectral decomposition.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>distfun</em> </td><td style="text-align: left;"> Function used to calculate the squared distance.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>nn</em> </td><td style="text-align: left;"> Number of nearest neighbours used for calculating <code>sigmas</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>d2</em> </td><td style="text-align: left;"> Matrix of squared distances, returned from <code>distfun</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>sigmas</em> </td><td style="text-align: left;"> Vector of sigmas. Same length as number of cells if individual</td>
</tr>
<tr>
 <td style="text-align: right;">
                 </td><td style="text-align: left;"> sigmas were calculated, otherwise a scalar if was supplied.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>gaussian</em> </td><td style="text-align: left;"> Unnormalised transition matrix after applying Gaussian.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>markov</em>  </td><td style="text-align: left;"> Normalised <code>gaussian</code> matrix.</td>
</tr>
<tr>
 <td style="text-align: right;">
   <em>densityCorrected</em> </td><td style="text-align: left;"> Matrix after applying density correction to 
                                <code>markov</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>References</h3>

<p>Haghverdi, L., Buettner, F., Theis, F.J., 2015. Diffusion maps for high-dimensional single-cell analysis of differentiation data. Bioinformatics 31, 2989–2998.
</p>
<p>Haghverdi, L., Büttner, M., Wolf, F.A., Buettner, F., Theis, F.J., 2016. Diffusion pseudotime robustly reconstructs lineage branching. Nat Meth 13, 845–848.
</p>
<p>Angerer, P., Haghverdi, L., Büttner, M., Theis, F.J., Marr, C., Buettner, F., 2016. destiny: diffusion maps for large-scale single-cell data in R. Bioinformatics 32, 1241–1243.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xx &lt;- diffuseMat(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='diffuseProj'>Predicts diffusion map projection from new data points</h2><span id='topic+diffuseProj'></span>

<h3>Description</h3>

<p>Predicts diffusion map projection from new data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffuseProj(dm, x, data, distfun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffuseProj_+3A_dm">dm</code></td>
<td>
<p>Output from diffuseMat2 function</p>
</td></tr>
<tr><td><code id="diffuseProj_+3A_x">x</code></td>
<td>
<p>Matrix of new data points. Features in rows and cells in
columns.</p>
</td></tr>
<tr><td><code id="diffuseProj_+3A_data">data</code></td>
<td>
<p>Original data used to generate diffusion map</p>
</td></tr>
<tr><td><code id="diffuseProj_+3A_distfun">distfun</code></td>
<td>
<p>A distance function that takes new data as first
paramter and previous data as second variable returning a squared
distance measure, with each sample in the rows and distance to
previous data points in columns, e.g. function(x, y) (1 - cor(x, y))^2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicts diffusion map projection from new data points
</p>


<h3>Value</h3>

<p>Returns a matrix with projected diffusion components.
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
y &lt;- diffuseProj(xx, newData, oldData, function(z) (1-cor(z))^2)

## End(Not run)
</code></pre>

<hr>
<h2 id='fastDist'>Fast vectorised Euclidean distance calculator</h2><span id='topic+fastDist'></span>

<h3>Description</h3>

<p>Fast vectorised Euclidean distance calculator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastDist(x, squared = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastDist_+3A_x">x</code></td>
<td>
<p>Matrix with vectors in columns.</p>
</td></tr>
<tr><td><code id="fastDist_+3A_squared">squared</code></td>
<td>
<p>Will not perform the square root, i.e. will return the squared &lsquo;L2-norm&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates Euclidean distances between vectors arranged as columns in a matrix.
</p>


<h3>Value</h3>

<p>Returns a matrix of pairwise distances
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dist &lt;- fastDist(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='filterGenes'>Filter genes</h2><span id='topic+filterGenes'></span>

<h3>Description</h3>

<p>Filter genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterGenes(x, mu = 0.01, cv = 2, fano = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterGenes_+3A_x">x</code></td>
<td>
<p>Matrix to be normalised with cells in rows and
genes in columns</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_mu">mu</code></td>
<td>
<p>Meam threshold</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_cv">cv</code></td>
<td>
<p>Coefficient of variation or Fano factor threshold.</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_fano">fano</code></td>
<td>
<p>Default TRUE. Predicate treat CV as Fano factor or CV</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Filter genes
Filter genes by mean and either coefficient of variation, cv or
Fano factor.
</p>


<h3>Value</h3>

<p>Returns a filtered matrix with same number of cells but fewer
genes than 'x'
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
expressionGenesFiltered &lt;- filterGenes(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='findLouvain'>Louvain clustering on transition matrix</h2><span id='topic+findLouvain'></span>

<h3>Description</h3>

<p>Louvain clustering on transition matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findLouvain(mkv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findLouvain_+3A_mkv">mkv</code></td>
<td>
<p>Transition matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Louvain clustering on transition matrix
</p>


<h3>Value</h3>

<p>Returns a list with graph, dataframe and community object
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xx &lt;- findLouvain(mkv)
xx$cll

## End(Not run)
</code></pre>

<hr>
<h2 id='fnc'>Find next cell function</h2><span id='topic+fnc'></span>

<h3>Description</h3>

<p>Find next cell function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnc(rdmap, tm, curInd, mom = NULL, momAdj = 0.5, w1 = exp(1), w2 = 1,
  varEst = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fnc_+3A_rdmap">rdmap</code></td>
<td>
<p>reduced dimensionality matrix with cells in rows and dims in columns</p>
</td></tr>
<tr><td><code id="fnc_+3A_tm">tm</code></td>
<td>
<p>Transition matrix</p>
</td></tr>
<tr><td><code id="fnc_+3A_curind">curInd</code></td>
<td>
<p>Current state on tm</p>
</td></tr>
<tr><td><code id="fnc_+3A_mom">mom</code></td>
<td>
<p>Current momentum vector</p>
</td></tr>
<tr><td><code id="fnc_+3A_momadj">momAdj</code></td>
<td>
<p>Weighting to adjust momentum. From 0-1. Lower numbers make smaller
adjustment to momentum vector.</p>
</td></tr>
<tr><td><code id="fnc_+3A_w1">w1</code></td>
<td>
<p>Parameter - Base used for modifying of tm probs.</p>
</td></tr>
<tr><td><code id="fnc_+3A_w2">w2</code></td>
<td>
<p>Parameter - Multiplifaction factor used for modifying tm probs.</p>
</td></tr>
<tr><td><code id="fnc_+3A_varest">varEst</code></td>
<td>
<p>Number of alternatives to sample for estimating variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Find next cell function. Transitioin probabilities are modifed by calulating the cosine
of the angle between the current momentum vector and the vector on the rdmap required for
each transtion. The tranisiton probability is adjusted by multiplying by w1^(w2 * (cosine_angle)) and then normalising.
</p>


<h3>Value</h3>

<p>Returns index of new cell and new momentum vector
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nextCell &lt;- fnc(rdmap, tm, curInd)

## End(Not run)
</code></pre>

<hr>
<h2 id='getTraj'>Find a plausible developmental journey</h2><span id='topic+getTraj'></span>

<h3>Description</h3>

<p>Return a plausible developmental journey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTraj(rdmap, tm, sourceCellInds, terminalCellsInd = NULL, momAdj = 0.5,
  w1 = exp(1), w2 = 1, simLen = 50, sim.seed = NULL, varEst = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTraj_+3A_rdmap">rdmap</code></td>
<td>
<p>reduced dimensionality matrix with cells in rows and dims in columns</p>
</td></tr>
<tr><td><code id="getTraj_+3A_tm">tm</code></td>
<td>
<p>Transition matrix</p>
</td></tr>
<tr><td><code id="getTraj_+3A_sourcecellinds">sourceCellInds</code></td>
<td>
<p>Starting sell indices</p>
</td></tr>
<tr><td><code id="getTraj_+3A_terminalcellsind">terminalCellsInd</code></td>
<td>
<p>Terminal cell indices</p>
</td></tr>
<tr><td><code id="getTraj_+3A_momadj">momAdj</code></td>
<td>
<p>Weighting to adjust momentum. From 0-1. Lower numbers make smaller
adjustment to momentum vector.</p>
</td></tr>
<tr><td><code id="getTraj_+3A_w1">w1</code></td>
<td>
<p>Parameter - Base used for modifying of tm probs.</p>
</td></tr>
<tr><td><code id="getTraj_+3A_w2">w2</code></td>
<td>
<p>Parameter - Multiplifaction factor used for modifying tm probs.</p>
</td></tr>
<tr><td><code id="getTraj_+3A_simlen">simLen</code></td>
<td>
<p>Maximum number of allowable tranisitons</p>
</td></tr>
<tr><td><code id="getTraj_+3A_sim.seed">sim.seed</code></td>
<td>
<p>Random seed for reproducibility</p>
</td></tr>
<tr><td><code id="getTraj_+3A_varest">varEst</code></td>
<td>
<p>Number of alternatives to sample for estimating variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return a plausible developmental journey
</p>


<h3>Value</h3>

<p>Returns a data.frame of ordered indices and momentums
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
traj &lt;- getTraj(rdmap, tm, startCells, terminalCells)

## End(Not run)
</code></pre>

<hr>
<h2 id='goggles'>View single cell dataset</h2><span id='topic+goggles'></span>

<h3>Description</h3>

<p>View single cell dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goggles(x, pcaDims = 90, nsig = 5, dmat = NULL, mkv = NULL,
  plotDims = 2, kernSq = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="goggles_+3A_x">x</code></td>
<td>
<p>Matrix with cells in rows and gene in columns</p>
</td></tr>
<tr><td><code id="goggles_+3A_pcadims">pcaDims</code></td>
<td>
<p>Number of PCA dimensions to keep for distance measure</p>
</td></tr>
<tr><td><code id="goggles_+3A_nsig">nsig</code></td>
<td>
<p>Number of significant neighbours to keep for Gaussian kernel</p>
</td></tr>
<tr><td><code id="goggles_+3A_dmat">dmat</code></td>
<td>
<p>Optional. Give your own distance matrix</p>
</td></tr>
<tr><td><code id="goggles_+3A_mkv">mkv</code></td>
<td>
<p>Optional. Give your own markov matrix.</p>
</td></tr>
<tr><td><code id="goggles_+3A_plotdims">plotDims</code></td>
<td>
<p>Default 2. Number of dimensions to plot</p>
</td></tr>
<tr><td><code id="goggles_+3A_kernsq">kernSq</code></td>
<td>
<p>Factor to tighten kernel - operates on sigmas.</p>
</td></tr>
<tr><td><code id="goggles_+3A_...">...</code></td>
<td>
<p>Additonal parameters not currently in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>View single cell dataset
</p>


<h3>Value</h3>

<p>A list of l, dimensionality reduced data.frame;
clust, returned from louvainClust();
adj, Sparse, pruned adjacency matrix;
dmat, distance matrix;
pca, PCA reduced matrix.
sparse, diagnostics on adj prior to applying sparseMarkov().
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xx &lt;- goggles(x)
plot(xx$l)

## End(Not run)
</code></pre>

<hr>
<h2 id='sparseMarkov'>Make markov matrix sparse</h2><span id='topic+sparseMarkov'></span>

<h3>Description</h3>

<p>Make markov matrix sparse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseMarkov(mkv, knn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparseMarkov_+3A_mkv">mkv</code></td>
<td>
<p>Markov matric</p>
</td></tr>
<tr><td><code id="sparseMarkov_+3A_knn">knn</code></td>
<td>
<p>Number of nearest neighbours. See above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Make markov matrix sparse
Choose knn as the maximum number of similar cells are likely to exist in your dataset.
</p>


<h3>Value</h3>

<p>Markovian sparse matrix.
</p>


<h3>Author(s)</h3>

<p>Wajid Jawaid
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
