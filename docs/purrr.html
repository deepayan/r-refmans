<!DOCTYPE html><html><head><title>Help for package purrr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {purrr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#accumulate'><p>Accumulate intermediate results of a vector reduction</p></a></li>
<li><a href='#along'><p>Create a list of given length</p></a></li>
<li><a href='#array-coercion'><p>Coerce array to list</p></a></li>
<li><a href='#as_mapper'><p>Convert an object into a mapper function</p></a></li>
<li><a href='#as_vector'><p>Coerce a list to a vector</p></a></li>
<li><a href='#at_depth'><p>Map at depth</p></a></li>
<li><a href='#attr_getter'><p>Create an attribute getter function</p></a></li>
<li><a href='#auto_browse'><p>Wrap a function so it will automatically <code>browse()</code> on error</p></a></li>
<li><a href='#chuck'><p>Get an element deep within a nested data structure, failing if it doesn't</p>
exist</a></li>
<li><a href='#compose'><p>Compose multiple functions together to create a new function</p></a></li>
<li><a href='#cross'><p>Produce all combinations of list elements</p></a></li>
<li><a href='#detect'><p>Find the value or position of the first match</p></a></li>
<li><a href='#every'><p>Do every, some, or none of the elements of a list satisfy a predicate?</p></a></li>
<li><a href='#faq-adverbs-export'><p>Best practices for exporting adverb-wrapped functions</p></a></li>
<li><a href='#flatten'><p>Flatten a list of lists into a simple vector</p></a></li>
<li><a href='#get-attr'><p>Infix attribute accessor</p></a></li>
<li><a href='#has_element'><p>Does a list contain an object?</p></a></li>
<li><a href='#head_while'><p>Find head/tail that all satisfies a predicate.</p></a></li>
<li><a href='#imap'><p>Apply a function to each element of a vector, and its index</p></a></li>
<li><a href='#insistently'><p>Transform a function to wait then retry after an error</p></a></li>
<li><a href='#invoke'><p>Invoke functions.</p></a></li>
<li><a href='#keep'><p>Keep/discard elements based on their values</p></a></li>
<li><a href='#keep_at'><p>Keep/discard elements based on their name/position</p></a></li>
<li><a href='#lift'><p>Lift the domain of a function</p></a></li>
<li><a href='#list_assign'><p>Modify a list</p></a></li>
<li><a href='#list_c'><p>Combine list elements into a single data structure</p></a></li>
<li><a href='#list_flatten'><p>Flatten a list</p></a></li>
<li><a href='#list_simplify'><p>Simplify a list to an atomic or S3 vector</p></a></li>
<li><a href='#list_transpose'><p>Transpose a list</p></a></li>
<li><a href='#lmap'><p>Apply a function to list-elements of a list</p></a></li>
<li><a href='#map'><p>Apply a function to each element of a vector</p></a></li>
<li><a href='#map_depth'><p>Map/modify elements at given depth</p></a></li>
<li><a href='#map_dfr'><p>Functions that return data frames</p></a></li>
<li><a href='#map_if'><p>Apply a function to each element of a vector conditionally</p></a></li>
<li><a href='#map_raw'><p>Functions that return raw vectors</p></a></li>
<li><a href='#map2'><p>Map over two inputs</p></a></li>
<li><a href='#modify'><p>Modify elements selectively</p></a></li>
<li><a href='#modify_in'><p>Modify a pluck location</p></a></li>
<li><a href='#modify_tree'><p>Recursively modify a list</p></a></li>
<li><a href='#negate'><p>Negate a predicate function so it selects what it previously rejected</p></a></li>
<li><a href='#partial'><p>Partially apply a function, filling in some arguments</p></a></li>
<li><a href='#pluck'><p>Safely get or set an element deep within a nested data structure</p></a></li>
<li><a href='#pluck_depth'><p>Compute the depth of a vector</p></a></li>
<li><a href='#pmap'><p>Map over multiple input simultaneously (in &quot;parallel&quot;)</p></a></li>
<li><a href='#possibly'><p>Wrap a function to return a value instead of an error</p></a></li>
<li><a href='#prepend'><p>Prepend a vector</p></a></li>
<li><a href='#progress_bars'><p>Progress bars in purrr</p></a></li>
<li><a href='#purrr_error_indexed'><p>Indexed errors (<code>purrr_error_indexed</code>)</p></a></li>
<li><a href='#purrr-package'><p>purrr: Functional Programming Tools</p></a></li>
<li><a href='#quietly'><p>Wrap a function to capture side-effects</p></a></li>
<li><a href='#rate_sleep'><p>Wait for a given time</p></a></li>
<li><a href='#rate-helpers'><p>Create delaying rate settings</p></a></li>
<li><a href='#rbernoulli'><p>Generate random sample from a Bernoulli distribution</p></a></li>
<li><a href='#rdunif'><p>Generate random sample from a discrete uniform distribution</p></a></li>
<li><a href='#reduce'><p>Reduce a list to a single value by iteratively applying a binary function</p></a></li>
<li><a href='#reduce_right'><p>Reduce from the right (retired)</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rerun'><p>Re-run expressions multiple times</p></a></li>
<li><a href='#safely'><p>Wrap a function to capture errors</p></a></li>
<li><a href='#slowly'><p>Wrap a function to wait between executions</p></a></li>
<li><a href='#splice'><p>Splice objects and lists of objects into a list</p></a></li>
<li><a href='#transpose'><p>Transpose a list.</p></a></li>
<li><a href='#update_list'><p>Update a list with formulas</p></a></li>
<li><a href='#when'><p>Match/validate a set of conditions for an object and continue with the action</p>
associated with the first valid match.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functional Programming Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A complete and consistent functional programming toolkit for
    R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://purrr.tidyverse.org/">https://purrr.tidyverse.org/</a>, <a href="https://github.com/tidyverse/purrr">https://github.com/tidyverse/purrr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/purrr/issues">https://github.com/tidyverse/purrr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.6.1), lifecycle (&ge; 1.0.3), magrittr (&ge; 1.5.0),
rlang (&ge; 1.1.1), vctrs (&ge; 0.6.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr (&ge; 0.7.8), httr, knitr, lubridate, rmarkdown,
testthat (&ge; 3.0.0), tibble, tidyselect</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cli</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate, tidyr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 16:13:31 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Lionel Henry [aut],
  RStudio [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-10 08:20:07 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:51:39 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='accumulate'>Accumulate intermediate results of a vector reduction</h2><span id='topic+accumulate'></span><span id='topic+accumulate2'></span>

<h3>Description</h3>

<p><code>accumulate()</code> sequentially applies a 2-argument function to elements of a
vector. Each application of the function uses the initial value or result
of the previous application as the first argument. The second argument is
the next value of the vector. The results of each application are
returned in a list. The accumulation can optionally terminate before
processing the whole vector in response to a <code>done()</code> signal returned by
the accumulation function.
</p>
<p>By contrast to <code>accumulate()</code>, <code>reduce()</code> applies a 2-argument function in
the same way, but discards all results except that of the final function
application.
</p>
<p><code>accumulate2()</code> sequentially applies a function to elements of two lists, <code>.x</code> and <code>.y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accumulate(
  .x,
  .f,
  ...,
  .init,
  .dir = c("forward", "backward"),
  .simplify = NA,
  .ptype = NULL
)

accumulate2(.x, .y, .f, ..., .init, .simplify = NA, .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accumulate_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="accumulate_+3A_.f">.f</code></td>
<td>
<p>For <code>accumulate()</code> <code>.f</code> is 2-argument function. The function will
be passed the accumulated result or initial value as the first argument.
The next value in sequence is passed as the second argument.
</p>
<p>For <code>accumulate2()</code>, a 3-argument function. The
function will be passed the accumulated result as the first
argument. The next value in sequence from <code>.x</code> is passed as the second argument. The
next value in sequence from <code>.y</code> is passed as the third argument.
</p>
<p>The accumulation terminates early if <code>.f</code> returns a value wrapped in
a <code><a href="purrr.html#topic+done">done()</a></code>.</p>
</td></tr>
<tr><td><code id="accumulate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="accumulate_+3A_.init">.init</code></td>
<td>
<p>If supplied, will be used as the first value to start
the accumulation, rather than using <code>.x[[1]]</code>. This is useful if
you want to ensure that <code>reduce</code> returns a correct value when <code>.x</code>
is empty. If missing, and <code>.x</code> is empty, will throw an error.</p>
</td></tr>
<tr><td><code id="accumulate_+3A_.dir">.dir</code></td>
<td>
<p>The direction of accumulation as a string, one of
<code>"forward"</code> (the default) or <code>"backward"</code>. See the section about
direction below.</p>
</td></tr>
<tr><td><code id="accumulate_+3A_.simplify">.simplify</code></td>
<td>
<p>If <code>NA</code>, the default, the accumulated list of
results is simplified to an atomic vector if possible.
If <code>TRUE</code>, the result is simplified, erroring if not possible.
If <code>FALSE</code>, the result is not simplified, always returning a list.</p>
</td></tr>
<tr><td><code id="accumulate_+3A_.ptype">.ptype</code></td>
<td>
<p>If <code>simplify</code> is <code>NA</code> or <code>TRUE</code>, optionally supply a vector
prototype to enforce the output type.</p>
</td></tr>
<tr><td><code id="accumulate_+3A_.y">.y</code></td>
<td>
<p>For <code>accumulate2()</code> <code>.y</code> is the second argument of the pair. It
needs to be 1 element shorter than the vector to be accumulated (<code>.x</code>).
If <code>.init</code> is set, <code>.y</code> needs to be one element shorted than the
concatenation of the initial value and <code>.x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length of <code>.x</code> with the same names as <code>.x</code>.
</p>
<p>If <code>.init</code> is supplied, the length is extended by 1. If <code>.x</code> has
names, the initial value is given the name <code>".init"</code>, otherwise
the returned vector is kept unnamed.
</p>
<p>If <code>.dir</code> is <code>"forward"</code> (the default), the first element is the
initial value (<code>.init</code> if supplied, or the first element of <code>.x</code>)
and the last element is the final reduced value. In case of a
right accumulation, this order is reversed.
</p>
<p>The accumulation terminates early if <code>.f</code> returns a value wrapped
in a <code><a href="purrr.html#topic+done">done()</a></code>. If the done box is empty, the last value is
used instead and the result is one element shorter (but always
includes the initial value, even when terminating at the first
iteration).
</p>


<h3>Life cycle</h3>

<p><code>accumulate_right()</code> is soft-deprecated in favour of the <code>.dir</code>
argument as of rlang 0.3.0. Note that the algorithm has
slightly changed: the accumulated value is passed to the right
rather than the left, which is consistent with a right reduction.
</p>


<h3>Direction</h3>

<p>When <code>.f</code> is an associative operation like <code>+</code> or <code>c()</code>, the
direction of reduction does not matter. For instance, reducing the
vector <code>1:3</code> with the binary function <code>+</code> computes the sum <code>((1 + 2) + 3)</code> from the left, and the same sum <code>(1 + (2 + 3))</code> from the
right.
</p>
<p>In other cases, the direction has important consequences on the
reduced value. For instance, reducing a vector with <code>list()</code> from
the left produces a left-leaning nested list (or tree), while
reducing <code>list()</code> from the right produces a right-leaning list.
</p>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+reduce">reduce()</a></code> when you only need the final reduced value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># With an associative operation, the final value is always the
# same, no matter the direction. You'll find it in the first element for a
# backward (left) accumulation, and in the last element for forward
# (right) one:
1:5 |&gt; accumulate(`+`)
1:5 |&gt; accumulate(`+`, .dir = "backward")

# The final value is always equal to the equivalent reduction:
1:5 |&gt; reduce(`+`)

# It is easier to understand the details of the reduction with
# `paste()`.
accumulate(letters[1:5], paste, sep = ".")

# Note how the intermediary reduced values are passed to the left
# with a left reduction, and to the right otherwise:
accumulate(letters[1:5], paste, sep = ".", .dir = "backward")

# By ignoring the input vector (nxt), you can turn output of one step into
# the input for the next. This code takes 10 steps of a random walk:
accumulate(1:10, \(acc, nxt) acc + rnorm(1), .init = 0)

# `accumulate2()` is a version of `accumulate()` that works with
# 3-argument functions and one additional vector:
paste2 &lt;- function(acc, nxt, sep = ".") paste(acc, nxt, sep = sep)
letters[1:4] |&gt; accumulate(paste2)
letters[1:4] |&gt; accumulate2(c("-", ".", "-"), paste2)

# You can shortcircuit an accumulation and terminate it early by
# returning a value wrapped in a done(). In the following example
# we return early if the result-so-far, which is passed on the LHS,
# meets a condition:
paste3 &lt;- function(out, input, sep = ".") {
  if (nchar(out) &gt; 4) {
    return(done(out))
  }
  paste(out, input, sep = sep)
}
letters |&gt; accumulate(paste3)

# Note how we get twice the same value in the accumulation. That's
# because we have returned it twice. To prevent this, return an empty
# done box to signal to accumulate() that it should terminate with the
# value of the last iteration:
paste3 &lt;- function(out, input, sep = ".") {
  if (nchar(out) &gt; 4) {
    return(done())
  }
  paste(out, input, sep = sep)
}
letters |&gt; accumulate(paste3)

# Here the early return branch checks the incoming inputs passed on
# the RHS:
paste4 &lt;- function(out, input, sep = ".") {
  if (input == "f") {
    return(done())
  }
  paste(out, input, sep = sep)
}
letters |&gt; accumulate(paste4)


# Simulating stochastic processes with drift
## Not run: 
library(dplyr)
library(ggplot2)

map(1:5, \(i) rnorm(100)) |&gt;
  set_names(paste0("sim", 1:5)) |&gt;
  map(\(l) accumulate(l, \(acc, nxt) .05 + acc + nxt)) |&gt;
  map(\(x) tibble(value = x, step = 1:100)) |&gt;
  list_rbind(id = "simulation") |&gt;
  ggplot(aes(x = step, y = value)) +
    geom_line(aes(color = simulation)) +
    ggtitle("Simulations of a random walk with drift")

## End(Not run)
</code></pre>

<hr>
<h2 id='along'>Create a list of given length</h2><span id='topic+along'></span><span id='topic+list_along'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated in purrr 1.0.0 since it's not related to the
core purpose of purrr.
</p>
<p>It can be useful to create an empty list that you plan to fill later. This is
similar to the idea of <code><a href="base.html#topic+seq_along">seq_along()</a></code>, which creates a vector of the same
length as its input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_along(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="along_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
seq_along(x)
list_along(x)
</code></pre>

<hr>
<h2 id='array-coercion'>Coerce array to list</h2><span id='topic+array-coercion'></span><span id='topic+array_branch'></span><span id='topic+array_tree'></span>

<h3>Description</h3>

<p><code>array_branch()</code> and <code>array_tree()</code> enable arrays to be
used with purrr's functionals by turning them into lists. The
details of the coercion are controlled by the <code>margin</code>
argument. <code>array_tree()</code> creates an hierarchical list (a tree)
that has as many levels as dimensions specified in <code>margin</code>,
while <code>array_branch()</code> creates a flat list (by analogy, a
branch) along all mentioned dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_branch(array, margin = NULL)

array_tree(array, margin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array-coercion_+3A_array">array</code></td>
<td>
<p>An array to coerce into a list.</p>
</td></tr>
<tr><td><code id="array-coercion_+3A_margin">margin</code></td>
<td>
<p>A numeric vector indicating the positions of the
indices to be to be enlisted. If <code>NULL</code>, a full margin is
used. If <code>numeric(0)</code>, the array as a whole is wrapped in a
list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When no margin is specified, all dimensions are used by
default. When <code>margin</code> is a numeric vector of length zero, the
whole array is wrapped in a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We create an array with 3 dimensions
x &lt;- array(1:12, c(2, 2, 3))

# A full margin for such an array would be the vector 1:3. This is
# the default if you don't specify a margin

# Creating a branch along the full margin is equivalent to
# as.list(array) and produces a list of size length(x):
array_branch(x) |&gt; str()

# A branch along the first dimension yields a list of length 2
# with each element containing a 2x3 array:
array_branch(x, 1) |&gt; str()

# A branch along the first and third dimensions yields a list of
# length 2x3 whose elements contain a vector of length 2:
array_branch(x, c(1, 3)) |&gt; str()

# Creating a tree from the full margin creates a list of lists of
# lists:
array_tree(x) |&gt; str()

# The ordering and the depth of the tree are controlled by the
# margin argument:
array_tree(x, c(3, 1)) |&gt; str()
</code></pre>

<hr>
<h2 id='as_mapper'>Convert an object into a mapper function</h2><span id='topic+as_mapper'></span><span id='topic+as_mapper.character'></span><span id='topic+as_mapper.numeric'></span><span id='topic+as_mapper.list'></span>

<h3>Description</h3>

<p><code>as_mapper</code> is the powerhouse behind the varied function
specifications that most purrr functions allow. It is an S3
generic. The default method forwards its arguments to
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_mapper(.f, ...)

## S3 method for class 'character'
as_mapper(.f, ..., .null, .default = NULL)

## S3 method for class 'numeric'
as_mapper(.f, ..., .null, .default = NULL)

## S3 method for class 'list'
as_mapper(.f, ..., .null, .default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_mapper_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous
functions. Note that formula functions conceptually take dots
(that's why you can use <code>..1</code> etc). They silently ignore
additional arguments that are not used in the formula expression.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="as_mapper_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="as_mapper_+3A_.default">.default</code>, <code id="as_mapper_+3A_.null">.null</code></td>
<td>
<p>Optional additional argument for extractor functions
(i.e. when <code>.f</code> is character, integer, or list). Returned when
value is absent (does not exist) or empty (has length 0).
<code>.null</code> is deprecated; please use <code>.default</code> instead.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>as_mapper(\(x) x + 1)
as_mapper(1)

as_mapper(c("a", "b", "c"))
# Equivalent to function(x) x[["a"]][["b"]][["c"]]

as_mapper(list(1, "a", 2))
# Equivalent to function(x) x[[1]][["a"]][[2]]

as_mapper(list(1, attr_getter("a")))
# Equivalent to function(x) attr(x[[1]], "a")

as_mapper(c("a", "b", "c"), .default = NA)
</code></pre>

<hr>
<h2 id='as_vector'>Coerce a list to a vector</h2><span id='topic+as_vector'></span><span id='topic+simplify'></span><span id='topic+simplify_all'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>These functions were superseded in purrr 1.0.0 in favour of
<code>list_simplify()</code> which has more consistent semantics based on vctrs
principles:
</p>

<ul>
<li> <p><code>as_vector(x)</code> is now <code>list_simplify(x)</code>
</p>
</li>
<li> <p><code>simplify(x)</code> is now <code>list_simplify(x, strict = FALSE)</code>
</p>
</li>
<li> <p><code>simplify_all(x)</code> is <code>map(x, list_simplify, strict = FALSE)</code>
</p>
</li></ul>

<p>Superseded functions will not go away, but will only receive critical
bug fixes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_vector(.x, .type = NULL)

simplify(.x, .type = NULL)

simplify_all(.x, .type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_vector_+3A_.x">.x</code></td>
<td>
<p>A list of vectors</p>
</td></tr>
<tr><td><code id="as_vector_+3A_.type">.type</code></td>
<td>
<p>Can be a vector mold specifying both the type and the
length of the vectors to be concatenated, such as <code>numeric(1)</code>
or <code>integer(4)</code>. Alternatively, it can be a string describing
the type, one of: &quot;logical&quot;, &quot;integer&quot;, &quot;double&quot;, &quot;complex&quot;,
&quot;character&quot; or &quot;raw&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># was
as.list(letters) |&gt; as_vector("character")
# now
as.list(letters) |&gt; list_simplify(ptype = character())

# was:
list(1:2, 3:4, 5:6) |&gt; as_vector(integer(2))
# now:
list(1:2, 3:4, 5:6) |&gt; list_c(ptype = integer())
</code></pre>

<hr>
<h2 id='at_depth'>Map at depth</h2><span id='topic+at_depth'></span>

<h3>Description</h3>

<p>This function is defunct and has been replaced by <code><a href="purrr.html#topic+map_depth">map_depth()</a></code>.
See also <code><a href="purrr.html#topic+modify_depth">modify_depth()</a></code> for a version that preserves the types of
the elements of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at_depth(.x, .depth, .f, ...)
</code></pre>

<hr>
<h2 id='attr_getter'>Create an attribute getter function</h2><span id='topic+attr_getter'></span>

<h3>Description</h3>

<p><code>attr_getter()</code> generates an attribute accessor function; i.e., it
generates a function for extracting an attribute with a given
name. Unlike the base R <code>attr()</code> function with default options, it
doesn't use partial matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attr_getter(attr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attr_getter_+3A_attr">attr</code></td>
<td>
<p>An attribute name as string.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+pluck">pluck()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># attr_getter() takes an attribute name and returns a function to
# access the attribute:
get_rownames &lt;- attr_getter("row.names")
get_rownames(mtcars)

# These getter functions are handy in conjunction with pluck() for
# extracting deeply into a data structure. Here we'll first
# extract by position, then by attribute:
obj1 &lt;- structure("obj", obj_attr = "foo")
obj2 &lt;- structure("obj", obj_attr = "bar")
x &lt;- list(obj1, obj2)

pluck(x, 1, attr_getter("obj_attr"))  # From first object
pluck(x, 2, attr_getter("obj_attr"))  # From second object
</code></pre>

<hr>
<h2 id='auto_browse'>Wrap a function so it will automatically <code>browse()</code> on error</h2><span id='topic+auto_browse'></span>

<h3>Description</h3>

<p>A function wrapped with <code>auto_browse()</code> will automatically enter an
interactive debugger using <code><a href="base.html#topic+browser">browser()</a></code> when ever it encounters an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_browse(.f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_browse_+3A_.f">.f</code></td>
<td>
<p>A function to modify, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. Only recommended if you require backward
compatibility with older versions of R.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes the same arguments as <code>.f</code>, but returns
a different value, as described above.
</p>


<h3>Adverbs</h3>

<p>This function is called an adverb because it modifies the effect of a
function (a verb). If you'd like to include a function created an adverb
in a package, be sure to read <a href="purrr.html#topic+faq-adverbs-export">faq-adverbs-export</a>.
</p>


<h3>See Also</h3>

<p>Other adverbs: 
<code><a href="igraph.html#topic+compose">compose</a>()</code>,
<code><a href="purrr.html#topic+insistently">insistently</a>()</code>,
<code><a href="purrr.html#topic+negate">negate</a>()</code>,
<code><a href="purrr.html#topic+partial">partial</a>()</code>,
<code><a href="purrr.html#topic+possibly">possibly</a>()</code>,
<code><a href="purrr.html#topic+quietly">quietly</a>()</code>,
<code><a href="purrr.html#topic+safely">safely</a>()</code>,
<code><a href="purrr.html#topic+slowly">slowly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For interactive usage, auto_browse() is useful because it automatically
# starts a browser() in the right place.
f &lt;- function(x) {
  y &lt;- 20
  if (x &gt; 5) {
    stop("!")
  } else {
    x
  }
}
if (interactive()) {
  map(1:6, auto_browse(f))
}

</code></pre>

<hr>
<h2 id='chuck'>Get an element deep within a nested data structure, failing if it doesn't
exist</h2><span id='topic+chuck'></span>

<h3>Description</h3>

<p><code>chuck()</code> implements a generalised form of <code>[[</code> that allow you to index
deeply and flexibly into data structures. If the index you are trying to
access does not exist (or is <code>NULL</code>), it will throw (i.e. chuck) an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chuck(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chuck_+3A_.x">.x</code></td>
<td>
<p>A vector or environment</p>
</td></tr>
<tr><td><code id="chuck_+3A_...">...</code></td>
<td>
<p>A list of accessors for indexing into the object. Can be
an positive integer, a negative integer (to index from the right),
a string (to index into names), or an accessor function
(except for the assignment variants which only support names and
positions). If the object being indexed is an S4 object,
accessing it by name will return the corresponding slot.
</p>
<p><a href="rlang.html#topic+dyn-dots">Dynamic dots</a> are supported. In particular, if
your accessors are stored in a list, you can splice that in with
<code style="white-space: pre;">&#8288;!!!&#8288;</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+pluck">pluck()</a></code> for a quiet equivalent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = 1, b = 2)

# When indexing an element that doesn't exist `[[` sometimes returns NULL:
x[["y"]]
# and sometimes errors:
try(x[[3]])

# chuck() consistently errors:
try(chuck(x, "y"))
try(chuck(x, 3))
</code></pre>

<hr>
<h2 id='compose'>Compose multiple functions together to create a new function</h2><span id='topic+compose'></span>

<h3>Description</h3>

<p>Create a new function that is the composition of multiple functions,
i.e. <code>compose(f, g)</code> is equivalent to <code>function(...) f(g(...))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose(..., .dir = c("backward", "forward"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose_+3A_...">...</code></td>
<td>
<p>Functions to apply in order (from right to left by
default). Formulas are converted to functions in the usual way.
</p>
<p><a href="rlang.html#topic+dyn-dots">Dynamic dots</a> are supported. In particular, if
your functions are stored in a list, you can splice that in with
<code style="white-space: pre;">&#8288;!!!&#8288;</code>.</p>
</td></tr>
<tr><td><code id="compose_+3A_.dir">.dir</code></td>
<td>
<p>If <code>"backward"</code> (the default), the functions are called
in the reverse order, from right to left, as is conventional in
mathematics. If <code>"forward"</code>, they are called from left to right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function
</p>


<h3>Adverbs</h3>

<p>This function is called an adverb because it modifies the effect of a
function (a verb). If you'd like to include a function created an adverb
in a package, be sure to read <a href="purrr.html#topic+faq-adverbs-export">faq-adverbs-export</a>.
</p>


<h3>See Also</h3>

<p>Other adverbs: 
<code><a href="purrr.html#topic+auto_browse">auto_browse</a>()</code>,
<code><a href="purrr.html#topic+insistently">insistently</a>()</code>,
<code><a href="purrr.html#topic+negate">negate</a>()</code>,
<code><a href="purrr.html#topic+partial">partial</a>()</code>,
<code><a href="purrr.html#topic+possibly">possibly</a>()</code>,
<code><a href="purrr.html#topic+quietly">quietly</a>()</code>,
<code><a href="purrr.html#topic+safely">safely</a>()</code>,
<code><a href="purrr.html#topic+slowly">slowly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not_null &lt;- compose(`!`, is.null)
not_null(4)
not_null(NULL)

add1 &lt;- function(x) x + 1
compose(add1, add1)(8)

fn &lt;- compose(\(x) paste(x, "foo"), \(x) paste(x, "bar"))
fn("input")

# Lists of functions can be spliced with !!!
fns &lt;- list(
  function(x) paste(x, "foo"),
  \(x) paste(x, "bar")
)
fn &lt;- compose(!!!fns)
fn("input")
</code></pre>

<hr>
<h2 id='cross'>Produce all combinations of list elements</h2><span id='topic+cross'></span><span id='topic+cross2'></span><span id='topic+cross3'></span><span id='topic+cross_df'></span><span id='topic+cross_n'></span><span id='topic+cross_d'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions were deprecated in purrr 1.0.0 because they
are slow and buggy, and we no longer think they are the right
approach to solving this problem. Please use <code>tidyr::expand_grid()</code>
instead.
</p>
<p>Here is an example of equivalent usages for <code>cross()</code> and
<code>expand_grid()</code>:
</p>
<div class="sourceCode r"><pre>data &lt;- list(
  id = c("John", "Jane"),
  sep = c("! ", "... "),
  greeting = c("Hello.", "Bonjour.")
)

# With deprecated `cross()`
data |&gt; cross() |&gt; map_chr(\(...) paste0(..., collapse = ""))
#&gt; [1] "John! Hello."     "Jane! Hello."     "John... Hello."   "Jane... Hello."  
#&gt; [5] "John! Bonjour."   "Jane! Bonjour."   "John... Bonjour." "Jane... Bonjour."

# With `expand_grid()`
tidyr::expand_grid(!!!data) |&gt; pmap_chr(paste)
#&gt; [1] "John! Hello."     "John! Bonjour."   "John... Hello."   "John... Bonjour."
#&gt; [5] "Jane! Hello."     "Jane! Bonjour."   "Jane... Hello."   "Jane... Bonjour."
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>cross(.l, .filter = NULL)

cross2(.x, .y, .filter = NULL)

cross3(.x, .y, .z, .filter = NULL)

cross_df(.l, .filter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_+3A_.l">.l</code></td>
<td>
<p>A list of lists or atomic vectors. Alternatively, a data
frame. <code>cross_df()</code> requires all elements to be named.</p>
</td></tr>
<tr><td><code id="cross_+3A_.filter">.filter</code></td>
<td>
<p>A predicate function that takes the same number of
arguments as the number of variables to be combined.</p>
</td></tr>
<tr><td><code id="cross_+3A_.x">.x</code>, <code id="cross_+3A_.y">.y</code>, <code id="cross_+3A_.z">.z</code></td>
<td>
<p>Lists or atomic vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cross2()</code> returns the product set of the elements of
<code>.x</code> and <code>.y</code>. <code>cross3()</code> takes an additional
<code>.z</code> argument. <code>cross()</code> takes a list <code>.l</code> and
returns the cartesian product of all its elements in a list, with
one combination by element. <code>cross_df()</code> is like
<code>cross()</code> but returns a data frame, with one combination by
row.
</p>
<p><code>cross()</code>, <code>cross2()</code> and <code>cross3()</code> return the
cartesian product is returned in wide format. This makes it more
amenable to mapping operations. <code>cross_df()</code> returns the output
in long format just as <code>expand.grid()</code> does. This is adapted
to rowwise operations.
</p>
<p>When the number of combinations is large and the individual
elements are heavy memory-wise, it is often useful to filter
unwanted combinations on the fly with <code>.filter</code>. It must be
a predicate function that takes the same number of arguments as the
number of crossed objects (2 for <code>cross2()</code>, 3 for
<code>cross3()</code>, <code>length(.l)</code> for <code>cross()</code>) and
returns <code>TRUE</code> or <code>FALSE</code>. The combinations where the
predicate function returns <code>TRUE</code> will be removed from the
result.
</p>


<h3>Value</h3>

<p><code>cross2()</code>, <code>cross3()</code> and <code>cross()</code>
always return a list. <code>cross_df()</code> always returns a data
frame. <code>cross()</code> returns a list where each element is one
combination so that the list can be directly mapped
over. <code>cross_df()</code> returns a data frame where each row is one
combination.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+expand.grid">expand.grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We build all combinations of names, greetings and separators from our
# list of data and pass each one to paste()
data &lt;- list(
  id = c("John", "Jane"),
  greeting = c("Hello.", "Bonjour."),
  sep = c("! ", "... ")
)

data |&gt;
  cross() |&gt;
  map(lift(paste))

# cross() returns the combinations in long format: many elements,
# each representing one combination. With cross_df() we'll get a
# data frame in long format: crossing three objects produces a data
# frame of three columns with each row being a particular
# combination. This is the same format that expand.grid() returns.
args &lt;- data |&gt; cross_df()

# In case you need a list in long format (and not a data frame)
# just run as.list() after cross_df()
args |&gt; as.list()

# This format is often less practical for functional programming
# because applying a function to the combinations requires a loop
out &lt;- vector("character", length = nrow(args))
for (i in seq_along(out))
  out[[i]] &lt;- invoke("paste", map(args, i))
out

# It's easier to transpose and then use invoke_map()
args |&gt; transpose() |&gt; map_chr(\(x) exec(paste, !!!x))

# Unwanted combinations can be filtered out with a predicate function
filter &lt;- function(x, y) x &gt;= y
cross2(1:5, 1:5, .filter = filter) |&gt; str()

# To give names to the components of the combinations, we map
# setNames() on the product:
x &lt;- seq_len(3)
cross2(x, x, .filter = `==`) |&gt;
  map(setNames, c("x", "y"))

# Alternatively we can encapsulate the arguments in a named list
# before crossing to get named components:
list(x = x, y = x) |&gt;
  cross(.filter = `==`)
</code></pre>

<hr>
<h2 id='detect'>Find the value or position of the first match</h2><span id='topic+detect'></span><span id='topic+detect_index'></span>

<h3>Description</h3>

<p>Find the value or position of the first match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect(
  .x,
  .f,
  ...,
  .dir = c("forward", "backward"),
  .right = NULL,
  .default = NULL
)

detect_index(.x, .f, ..., .dir = c("forward", "backward"), .right = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_+3A_.x">.x</code></td>
<td>
<p>A list or vector.</p>
</td></tr>
<tr><td><code id="detect_+3A_.f">.f</code></td>
<td>
<p>A function, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. You must use <code>.x</code> to refer to the first
argument. Only recommended if you require backward compatibility with
older versions of R.
</p>
</li>
<li><p> A string, integer, or list, e.g. <code>"idx"</code>, <code>1</code>, or <code>list("idx", 1)</code> which
are shorthand for <code style="white-space: pre;">&#8288;\(x) pluck(x, "idx")&#8288;</code>, <code style="white-space: pre;">&#8288;\(x) pluck(x, 1)&#8288;</code>, and
<code style="white-space: pre;">&#8288;\(x) pluck(x, "idx", 1)&#8288;</code> respectively. Optionally supply <code>.default</code> to
set a default value if the indexed element is <code>NULL</code> or does not exist.
</p>
</li></ul>
</td></tr>
<tr><td><code id="detect_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.p</code>.</p>
</td></tr>
<tr><td><code id="detect_+3A_.dir">.dir</code></td>
<td>
<p>If <code>"forward"</code>, the default, starts at the beginning of
the vector and move towards the end; if <code>"backward"</code>, starts at
the end of the vector and moves towards the beginning.</p>
</td></tr>
<tr><td><code id="detect_+3A_.right">.right</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>.dir</code> instead.</p>
</td></tr>
<tr><td><code id="detect_+3A_.default">.default</code></td>
<td>
<p>The value returned when nothing is detected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>detect</code> the value of the first item that matches the
predicate; <code>detect_index</code> the position of the matching item.
If not found, <code>detect</code> returns <code>NULL</code> and <code>detect_index</code>
returns 0.
</p>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+keep">keep()</a></code> for keeping all matching values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_even &lt;- function(x) x %% 2 == 0

3:10 |&gt; detect(is_even)
3:10 |&gt; detect_index(is_even)

3:10 |&gt; detect(is_even, .dir = "backward")
3:10 |&gt; detect_index(is_even, .dir = "backward")


# Since `.f` is passed to as_mapper(), you can supply a
# lambda-formula or a pluck object:
x &lt;- list(
  list(1, foo = FALSE),
  list(2, foo = TRUE),
  list(3, foo = TRUE)
)

detect(x, "foo")
detect_index(x, "foo")


# If you need to find all values, use keep():
keep(x, "foo")

# If you need to find all positions, use map_lgl():
which(map_lgl(x, "foo"))
</code></pre>

<hr>
<h2 id='every'>Do every, some, or none of the elements of a list satisfy a predicate?</h2><span id='topic+every'></span><span id='topic+some'></span><span id='topic+none'></span>

<h3>Description</h3>


<ul>
<li> <p><code>some()</code> returns <code>TRUE</code> when <code>.p</code> is <code>TRUE</code> for at least one element.
</p>
</li>
<li> <p><code>every()</code> returns <code>TRUE</code> when <code>.p</code> is <code>TRUE</code> for all elements.
</p>
</li>
<li> <p><code>none()</code> returns <code>TRUE</code> when <code>.p</code> is <code>FALSE</code> for all elements.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>every(.x, .p, ...)

some(.x, .p, ...)

none(.x, .p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="every_+3A_.x">.x</code></td>
<td>
<p>A list or vector.</p>
</td></tr>
<tr><td><code id="every_+3A_.p">.p</code></td>
<td>
<p>A predicate function (i.e. a function that returns either <code>TRUE</code>
or <code>FALSE</code>) specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>is.character</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) all(x &lt; 0)&#8288;</code> or <code>function(x) all(x &lt; 0)</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ all(.x &lt; 0)</code>. You must use <code>.x</code> to refer to the first
argument). Only recommended if you require backward compatibility with
older versions of R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="every_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(0:10, 5.5)
x |&gt; every(is.numeric)
x |&gt; every(is.integer)
x |&gt; some(is.integer)
x |&gt; none(is.character)

# Missing values are propagated:
some(list(NA, FALSE), identity)

# If you need to use these functions in a context where missing values are
# unsafe (e.g. in `if ()` conditions), make sure to use safe predicates:
if (some(list(NA, FALSE), rlang::is_true)) "foo" else "bar"
</code></pre>

<hr>
<h2 id='faq-adverbs-export'>Best practices for exporting adverb-wrapped functions</h2><span id='topic+faq-adverbs-export'></span>

<h3>Description</h3>

<p>Exporting functions created with purrr adverbs in your package
requires some precautions because the functions will contain internal
purrr code. This means that creating them once and for all when
the package is built may cause problems when purrr is updated, because
a function that the adverb uses might no longer exist.
</p>
<p>Instead, either create the modified function once per session on package
load or wrap the call within another function every time you use it:
</p>

<ul>
<li><p> Using the <code><a href="base.html#topic+.onLoad">.onLoad()</a></code> hook:
</p>
<div class="sourceCode"><pre>#' My function
#' @export
insist_my_function &lt;- function(...) "dummy"

my_function &lt;- function(...) {
  # Implementation
}

.onLoad &lt;- function(lib, pkg) {
  insist_my_function &lt;&lt;- purrr::insistently(my_function)
}
</pre></div>
</li>
<li><p> Using a wrapper function:
</p>
<div class="sourceCode"><pre>my_function &lt;- function(...) {
  # Implementation
}

#' My function
#' @export
insist_my_function &lt;- function(...) {
  purrr::insistently(my_function)(...)
}
</pre></div>
</li></ul>


<hr>
<h2 id='flatten'>Flatten a list of lists into a simple vector</h2><span id='topic+flatten'></span><span id='topic+flatten_lgl'></span><span id='topic+flatten_int'></span><span id='topic+flatten_dbl'></span><span id='topic+flatten_chr'></span><span id='topic+flatten_dfr'></span><span id='topic+flatten_dfc'></span><span id='topic+flatten_df'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>These functions were superseded in purrr 1.0.0 because their behaviour was
inconsistent. Superseded functions will not go away, but will only receive
critical bug fixes.
</p>

<ul>
<li> <p><code>flatten()</code> has been superseded by <code><a href="purrr.html#topic+list_flatten">list_flatten()</a></code>.
</p>
</li>
<li> <p><code>flatten_lgl()</code>, <code>flatten_int()</code>, <code>flatten_dbl()</code>, and <code>flatten_chr()</code>
have been superseded by <code><a href="purrr.html#topic+list_c">list_c()</a></code>.
</p>
</li>
<li> <p><code>flatten_dfr()</code> and <code>flatten_dfc()</code> have been superseded by <code><a href="purrr.html#topic+list_rbind">list_rbind()</a></code>
and <code><a href="purrr.html#topic+list_cbind">list_cbind()</a></code> respectively.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>flatten(.x)

flatten_lgl(.x)

flatten_int(.x)

flatten_dbl(.x)

flatten_chr(.x)

flatten_dfr(.x, .id = NULL)

flatten_dfc(.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_+3A_.x">.x</code></td>
<td>
<p>A list to flatten. The contents of the list can be anything for
<code>flatten()</code> (as a list is returned), but the contents must match the
type for the other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>flatten()</code> returns a list, <code>flatten_lgl()</code> a logical
vector, <code>flatten_int()</code> an integer vector, <code>flatten_dbl()</code> a
double vector, and <code>flatten_chr()</code> a character vector.
</p>
<p><code>flatten_dfr()</code> and <code>flatten_dfc()</code> return data frames created by
row-binding and column-binding respectively. They require dplyr to
be installed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- map(1:3, \(i) sample(4))
x

# was
x |&gt; flatten_int() |&gt; str()
# now
x |&gt; list_c() |&gt; str()

x &lt;- list(list(1, 2), list(3, 4))
# was
x |&gt; flatten() |&gt; str()
# now
x |&gt; list_flatten() |&gt; str()
</code></pre>

<hr>
<h2 id='get-attr'>Infix attribute accessor</h2><span id='topic+get-attr'></span><span id='topic++25+40+25'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated in purrr 0.3.0. Instead, lease use the <code style="white-space: pre;">&#8288;%@%&#8288;</code>
operator exported in rlang. It has an interface more consistent with <code>@</code>:
uses NSE, supports S4 fields, and has an assignment variant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %@% name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get-attr_+3A_x">x</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="get-attr_+3A_name">name</code></td>
<td>
<p>Attribute name</p>
</td></tr>
</table>

<hr>
<h2 id='has_element'>Does a list contain an object?</h2><span id='topic+has_element'></span>

<h3>Description</h3>

<p>Does a list contain an object?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_element(.x, .y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_element_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="has_element_+3A_.y">.y</code></td>
<td>
<p>Object to test for</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(1:10, 5, 9.9)
x |&gt; has_element(1:10)
x |&gt; has_element(3)
</code></pre>

<hr>
<h2 id='head_while'>Find head/tail that all satisfies a predicate.</h2><span id='topic+head_while'></span><span id='topic+tail_while'></span>

<h3>Description</h3>

<p>Find head/tail that all satisfies a predicate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head_while(.x, .p, ...)

tail_while(.x, .p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_while_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="head_while_+3A_.p">.p</code></td>
<td>
<p>A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as <code>.x</code>.
Alternatively, if the elements of <code>.x</code> are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where <code>.p</code> evaluates to
<code>TRUE</code> will be modified.</p>
</td></tr>
<tr><td><code id="head_while_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same type as <code>.x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos &lt;- function(x) x &gt;= 0
head_while(5:-5, pos)
tail_while(5:-5, negate(pos))

big &lt;- function(x) x &gt; 100
head_while(0:10, big)
tail_while(0:10, big)
</code></pre>

<hr>
<h2 id='imap'>Apply a function to each element of a vector, and its index</h2><span id='topic+imap'></span><span id='topic+imap_lgl'></span><span id='topic+imap_chr'></span><span id='topic+imap_int'></span><span id='topic+imap_dbl'></span><span id='topic+iwalk'></span>

<h3>Description</h3>

<p><code>imap(x, ...)</code>, an indexed map, is short hand for
<code>map2(x, names(x), ...)</code> if <code>x</code> has names, or <code>map2(x, seq_along(x), ...)</code>
if it does not. This is useful if you need to compute on both the value
and the position of an element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imap(.x, .f, ...)

imap_lgl(.x, .f, ...)

imap_chr(.x, .f, ...)

imap_int(.x, .f, ...)

imap_dbl(.x, .f, ...)

iwalk(.x, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imap_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="imap_+3A_.f">.f</code></td>
<td>
<p>A function, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>paste</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x, idx) x + idx&#8288;</code> or
<code>function(x, idx) x + idx</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + .y</code>. You must use <code>.x</code> to refer to the
current element and <code>.y</code> to refer to the current index. Only recommended
if you require backward compatibility with older versions of R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="imap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>.x</code>.
</p>


<h3>See Also</h3>

<p>Other map variants: 
<code><a href="purrr.html#topic+lmap">lmap</a>()</code>,
<code><a href="purrr.html#topic+map2">map2</a>()</code>,
<code><a href="purrr.html#topic+map_depth">map_depth</a>()</code>,
<code><a href="purrr.html#topic+map_if">map_if</a>()</code>,
<code><a href="maps.html#topic+map">map</a>()</code>,
<code><a href="purrr.html#topic+modify">modify</a>()</code>,
<code><a href="purrr.html#topic+pmap">pmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imap_chr(sample(10), paste)

imap_chr(sample(10), \(x, idx) paste0(idx, ": ", x))

iwalk(mtcars, \(x, idx) cat(idx, ": ", median(x), "\n", sep = ""))
</code></pre>

<hr>
<h2 id='insistently'>Transform a function to wait then retry after an error</h2><span id='topic+insistently'></span>

<h3>Description</h3>

<p><code>insistently()</code> takes a function and modifies it to retry after given
amount of time whenever it errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insistently(f, rate = rate_backoff(), quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insistently_+3A_f">f</code></td>
<td>
<p>A function to modify, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. Only recommended if you require backward
compatibility with older versions of R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="insistently_+3A_rate">rate</code></td>
<td>
<p>A <a href="purrr.html#topic+rate-helpers">rate</a> object. Defaults to jittered exponential
backoff.</p>
</td></tr>
<tr><td><code id="insistently_+3A_quiet">quiet</code></td>
<td>
<p>Hide errors (<code>TRUE</code>, the default), or display them
as they occur?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes the same arguments as <code>.f</code>, but returns
a different value, as described above.
</p>


<h3>Adverbs</h3>

<p>This function is called an adverb because it modifies the effect of a
function (a verb). If you'd like to include a function created an adverb
in a package, be sure to read <a href="purrr.html#topic+faq-adverbs-export">faq-adverbs-export</a>.
</p>


<h3>See Also</h3>

<p><code><a href="httr.html#topic+RETRY">httr::RETRY()</a></code> is a special case of <code><a href="purrr.html#topic+insistently">insistently()</a></code> for
HTTP verbs.
</p>
<p>Other adverbs: 
<code><a href="purrr.html#topic+auto_browse">auto_browse</a>()</code>,
<code><a href="igraph.html#topic+compose">compose</a>()</code>,
<code><a href="purrr.html#topic+negate">negate</a>()</code>,
<code><a href="purrr.html#topic+partial">partial</a>()</code>,
<code><a href="purrr.html#topic+possibly">possibly</a>()</code>,
<code><a href="purrr.html#topic+quietly">quietly</a>()</code>,
<code><a href="purrr.html#topic+safely">safely</a>()</code>,
<code><a href="purrr.html#topic+slowly">slowly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the purpose of this example, we first create a custom rate
# object with a low waiting time between attempts:
rate &lt;- rate_delay(0.1)

# insistently() makes a function repeatedly try to work
risky_runif &lt;- function(lo = 0, hi = 1) {
  y &lt;- runif(1, lo, hi)
  if(y &lt; 0.9) {
    stop(y, " is too small")
  }
  y
}

# Let's now create an exponential backoff rate with a low waiting
# time between attempts:
rate &lt;- rate_backoff(pause_base = 0.1, pause_min = 0.005, max_times = 4)

# Modify your function to run insistently.
insistent_risky_runif &lt;- insistently(risky_runif, rate, quiet = FALSE)

set.seed(6) # Succeeding seed
insistent_risky_runif()

set.seed(3) # Failing seed
try(insistent_risky_runif())

# You can also use other types of rate settings, like a delay rate
# that waits for a fixed amount of time. Be aware that a delay rate
# has an infinite amount of attempts by default:
rate &lt;- rate_delay(0.2, max_times = 3)
insistent_risky_runif &lt;- insistently(risky_runif, rate = rate, quiet = FALSE)
try(insistent_risky_runif())

# insistently() and possibly() are a useful combination
rate &lt;- rate_backoff(pause_base = 0.1, pause_min = 0.005)
possibly_insistent_risky_runif &lt;- possibly(insistent_risky_runif, otherwise = -99)

set.seed(6)
possibly_insistent_risky_runif()

set.seed(3)
possibly_insistent_risky_runif()
</code></pre>

<hr>
<h2 id='invoke'>Invoke functions.</h2><span id='topic+invoke'></span><span id='topic+invoke_map'></span><span id='topic+invoke_map_lgl'></span><span id='topic+invoke_map_int'></span><span id='topic+invoke_map_dbl'></span><span id='topic+invoke_map_chr'></span><span id='topic+invoke_map_raw'></span><span id='topic+invoke_map_dfr'></span><span id='topic+invoke_map_dfc'></span><span id='topic+invoke_map_df'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions were superded in purrr 0.3.0 and deprecated in purrr 1.0.0.
</p>

<ul>
<li> <p><code>invoke()</code> is deprecated in favour of the simpler <code>exec()</code> function
reexported from rlang. <code>exec()</code> evaluates a function call built
from its inputs and supports <a href="rlang.html#topic+dyn-dots">dynamic dots</a>:
</p>
<div class="sourceCode R"><pre># Before:
invoke(mean, list(na.rm = TRUE), x = 1:10)

# After
exec(mean, 1:10, !!!list(na.rm = TRUE))
</pre></div>
</li>
<li> <p><code>invoke_map()</code> is deprecated because it's harder to understand than the
corresponding code using <code>map()</code>/<code>map2()</code> and <code>exec()</code>:
</p>
<div class="sourceCode R"><pre># Before:
invoke_map(fns, list(args))
invoke_map(fns, list(args1, args2))

# After:
map(fns, exec, !!!args)
map2(fns, list(args1, args2), \(fn, args) exec(fn, !!!args))
</pre></div>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>invoke(.f, .x = NULL, ..., .env = NULL)

invoke_map(.f, .x = list(NULL), ..., .env = NULL)

invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)

invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)

invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)

invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)

invoke_map_raw(.f, .x = list(NULL), ..., .env = NULL)

invoke_map_dfr(.f, .x = list(NULL), ..., .env = NULL)

invoke_map_dfc(.f, .x = list(NULL), ..., .env = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invoke_+3A_.f">.f</code></td>
<td>
<p>For <code>invoke</code>, a function; for <code>invoke_map</code> a
list of functions.</p>
</td></tr>
<tr><td><code id="invoke_+3A_.x">.x</code></td>
<td>
<p>For <code>invoke</code>, an argument-list; for <code>invoke_map</code> a
list of argument-lists the same length as <code>.f</code> (or length 1).
The default argument, <code>list(NULL)</code>, will be recycled to the
same length as <code>.f</code>, and will call each function with no
arguments (apart from any supplied in <code>...</code>.</p>
</td></tr>
<tr><td><code id="invoke_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to each function.</p>
</td></tr>
<tr><td><code id="invoke_+3A_.env">.env</code></td>
<td>
<p>Environment in which <code><a href="base.html#topic+do.call">do.call()</a></code> should
evaluate a constructed expression. This only matters if you pass
as <code>.f</code> the name of a function rather than its value, or as
<code>.x</code> symbols of objects rather than their values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># was
invoke(runif, list(n = 10))
invoke(runif, n = 10)
# now
exec(runif, n = 10)

# was
args &lt;- list("01a", "01b")
invoke(paste, args, sep = "-")
# now
exec(paste, !!!args, sep = "-")

# was
funs &lt;- list(runif, rnorm)
funs |&gt; invoke_map(n = 5)
funs |&gt; invoke_map(list(list(n = 10), list(n = 5)))

# now
funs |&gt; map(exec, n = 5)
funs |&gt; map2(list(list(n = 10), list(n = 5)), function(f, args) exec(f, !!!args))

# or use pmap + a tibble
df &lt;- tibble::tibble(
  fun = list(runif, rnorm),
  args = list(list(n = 10), list(n = 5))
)
df |&gt; pmap(function(fun, args) exec(fun, !!!args))


# was
list(m1 = mean, m2 = median) |&gt; invoke_map(x = rcauchy(100))
# now
list(m1 = mean, m2 = median) |&gt; map(function(f) f(rcauchy(100)))

</code></pre>

<hr>
<h2 id='keep'>Keep/discard elements based on their values</h2><span id='topic+keep'></span><span id='topic+discard'></span><span id='topic+compact'></span>

<h3>Description</h3>

<p><code>keep()</code> selects all elements where <code>.p</code> evaluates to <code>TRUE</code>;
<code>discard()</code> selects all elements where <code>.p</code> evaluates to <code>FALSE</code>.
<code>compact()</code> discards elements where <code>.p</code> evaluates to an empty vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep(.x, .p, ...)

discard(.x, .p, ...)

compact(.x, .p = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_+3A_.x">.x</code></td>
<td>
<p>A list or vector.</p>
</td></tr>
<tr><td><code id="keep_+3A_.p">.p</code></td>
<td>
<p>A predicate function (i.e. a function that returns either <code>TRUE</code>
or <code>FALSE</code>) specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>is.character</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) all(x &lt; 0)&#8288;</code> or <code>function(x) all(x &lt; 0)</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ all(.x &lt; 0)</code>. You must use <code>.x</code> to refer to the first
argument). Only recommended if you require backward compatibility with
older versions of R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="keep_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.p</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In other languages, <code>keep()</code> and <code>discard()</code> are often called <code>select()</code>/
<code>filter()</code> and <code>reject()</code>/ <code>drop()</code>, but those names are already taken
in R. <code>keep()</code> is similar to <code><a href="base.html#topic+Filter">Filter()</a></code>, but the argument order is more
convenient, and the evaluation of the predicate function <code>.p</code> is stricter.
</p>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+keep_at">keep_at()</a></code>/<code><a href="purrr.html#topic+discard_at">discard_at()</a></code> to keep/discard elements by name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rep(10, 10) |&gt;
  map(sample, 5) |&gt;
  keep(function(x) mean(x) &gt; 6)

# Or use a formula
rep(10, 10) |&gt;
  map(sample, 5) |&gt;
  keep(\(x) mean(x) &gt; 6)

# Using a string instead of a function will select all list elements
# where that subelement is TRUE
x &lt;- rerun(5, a = rbernoulli(1), b = sample(10))
x
x |&gt; keep("a")
x |&gt; discard("a")

# compact() discards elements that are NULL or that have length zero
list(a = "a", b = NULL, c = integer(0), d = NA, e = list()) |&gt;
  compact()
</code></pre>

<hr>
<h2 id='keep_at'>Keep/discard elements based on their name/position</h2><span id='topic+keep_at'></span><span id='topic+discard_at'></span>

<h3>Description</h3>

<p>Keep/discard elements based on their name/position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep_at(x, at)

discard_at(x, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_at_+3A_x">x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="keep_at_+3A_at">at</code></td>
<td>
<p>A logical, integer, or character vector giving the elements
to select. Alternatively, a function that takes a vector of names,
and returns a logical, integer, or character vector of elements to select.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>: if the tidyselect package is
installed, you can use <code>vars()</code> and tidyselect helpers to select
elements.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+keep">keep()</a></code>/<code><a href="purrr.html#topic+discard">discard()</a></code> to keep/discard elements by value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(a = 1, b = 2, cat = 10, dog = 15, elephant = 5, e = 10)
x %&gt;% keep_at(letters)
x %&gt;% discard_at(letters)

# Can also use a function
x %&gt;% keep_at(~ nchar(.x) == 3)
x %&gt;% discard_at(~ nchar(.x) == 3)
</code></pre>

<hr>
<h2 id='lift'>Lift the domain of a function</h2><span id='topic+lift'></span><span id='topic+lift_dl'></span><span id='topic+lift_dv'></span><span id='topic+lift_vl'></span><span id='topic+lift_vd'></span><span id='topic+lift_ld'></span><span id='topic+lift_lv'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>lift_xy()</code> is a composition helper. It helps you compose
functions by lifting their domain from a kind of input to another
kind. The domain can be changed from and to a list (l), a vector
(v) and dots (d). For example, <code>lift_ld(fun)</code> transforms a
function taking a list to a function taking dots.
</p>
<p>The most important of those helpers is probably <code>lift_dl()</code>
because it allows you to transform a regular function to one that
takes a list. This is often essential for composition with purrr
functional tools. Since this is such a common function,
<code>lift()</code> is provided as an alias for that operation.
</p>
<p>These functions were superseded in purrr 1.0.0 because we no longer believe
&quot;lifting&quot; to be a mainstream operation, and we are striving to reduce purrr
to its most useful core. Superseded functions will not go away, but will only
receive critical bug fixes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lift(..f, ..., .unnamed = FALSE)

lift_dl(..f, ..., .unnamed = FALSE)

lift_dv(..f, ..., .unnamed = FALSE)

lift_vl(..f, ..., .type)

lift_vd(..f, ..., .type)

lift_ld(..f, ...)

lift_lv(..f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lift_+3A_..f">..f</code></td>
<td>
<p>A function to lift.</p>
</td></tr>
<tr><td><code id="lift_+3A_...">...</code></td>
<td>
<p>Default arguments for <code>..f</code>. These will be
evaluated only once, when the lifting factory is called.</p>
</td></tr>
<tr><td><code id="lift_+3A_.unnamed">.unnamed</code></td>
<td>
<p>If <code>TRUE</code>, <code>ld</code> or <code>lv</code> will not
name the parameters in the lifted function signature. This
prevents matching of arguments by name and match by position
instead.</p>
</td></tr>
<tr><td><code id="lift_+3A_.type">.type</code></td>
<td>
<p>Can be a vector mold specifying both the type and the
length of the vectors to be concatenated, such as <code>numeric(1)</code>
or <code>integer(4)</code>. Alternatively, it can be a string describing
the type, one of: &quot;logical&quot;, &quot;integer&quot;, &quot;double&quot;, &quot;complex&quot;,
&quot;character&quot; or &quot;raw&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function.
</p>


<h3>from ... to <code>list(...)</code> or <code>c(...)</code></h3>

<p>Here dots should be taken here in a figurative way. The lifted
functions does not need to take dots per se. The function is
simply wrapped a function in <code><a href="base.html#topic+do.call">do.call()</a></code>, so instead
of taking multiple arguments, it takes a single named list or
vector which will be interpreted as its arguments.  This is
particularly useful when you want to pass a row of a data frame
or a list to a function and don't want to manually pull it apart
in your function.
</p>


<h3>from <code>c(...)</code> to <code>list(...)</code> or <code>...</code></h3>

<p>These factories allow a function taking a vector to take a list
or dots instead. The lifted function internally transforms its
inputs back to an atomic vector. purrr does not obey the usual R
casting rules (e.g., <code>c(1, "2")</code> produces a character
vector) and will produce an error if the types are not
compatible. Additionally, you can enforce a particular vector
type by supplying <code>.type</code>.
</p>


<h3>from list(...) to c(...) or ...</h3>

<p><code>lift_ld()</code> turns a function that takes a list into a
function that takes dots. <code>lift_vd()</code> does the same with a
function that takes an atomic vector. These factory functions are
the inverse operations of <code>lift_dl()</code> and <code>lift_dv()</code>.
</p>
<p><code>lift_vd()</code> internally coerces the inputs of <code>..f</code> to
an atomic vector. The details of this coercion can be controlled
with <code>.type</code>.
</p>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+invoke">invoke()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Lifting from ... to list(...) or c(...)

x &lt;- list(x = c(1:100, NA, 1000), na.rm = TRUE, trim = 0.9)
lift_dl(mean)(x)
# You can also use the lift() alias for this common operation:
lift(mean)(x)
# now:
exec(mean, !!!x)

# Default arguments can also be specified directly in lift_dl()
list(c(1:100, NA, 1000)) |&gt; lift_dl(mean, na.rm = TRUE)()
# now:
mean(c(1:100, NA, 1000), na.rm = TRUE)

# lift_dl() and lift_ld() are inverse of each other.
# Here we transform sum() so that it takes a list
fun &lt;- sum |&gt; lift_dl()
fun(list(3, NA, 4, na.rm = TRUE))
# now:
fun &lt;- function(x) exec("sum", !!!x)
exec(sum, 3, NA, 4, na.rm = TRUE)
### Lifting from c(...) to list(...) or ...

# In other situations we need the vector-valued function to take a
# variable number of arguments as with pmap(). This is a job for
# lift_vd():
pmap_dbl(mtcars, lift_vd(mean))
# now
pmap_dbl(mtcars, \(...) mean(c(...)))
### Lifting from list(...) to c(...) or ...

# This kind of lifting is sometimes needed for function
# composition. An example would be to use pmap() with a function
# that takes a list. In the following, we use some() on each row of
# a data frame to check they each contain at least one element
# satisfying a condition:
mtcars |&gt; pmap_lgl(lift_ld(some, partial(`&lt;`, 200)))
# now
mtcars |&gt; pmap_lgl(\(...) any(c(...) &gt; 200))

</code></pre>

<hr>
<h2 id='list_assign'>Modify a list</h2><span id='topic+list_assign'></span><span id='topic+list_modify'></span><span id='topic+list_merge'></span>

<h3>Description</h3>


<ul>
<li> <p><code>list_assign()</code> modifies the elements of a list by name or position.
</p>
</li>
<li> <p><code>list_modify()</code> modifies the elements of a list recursively.
</p>
</li>
<li> <p><code>list_merge()</code> merges the elements of a list recursively.
</p>
</li></ul>

<p><code>list_modify()</code> is inspired by <code><a href="utils.html#topic+modifyList">utils::modifyList()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_assign(.x, ..., .is_node = NULL)

list_modify(.x, ..., .is_node = NULL)

list_merge(.x, ..., .is_node = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_assign_+3A_.x">.x</code></td>
<td>
<p>List to modify.</p>
</td></tr>
<tr><td><code id="list_assign_+3A_...">...</code></td>
<td>
<p>New values of a list. Use <code>zap()</code> to remove values.
</p>
<p>These values should be either all named or all unnamed. When
inputs are all named, they are matched to <code>.x</code> by name. When they
are all unnamed, they are matched by position.
</p>
<p><a href="rlang.html#topic+dyn-dots">Dynamic dots</a> are supported. In particular, if your
replacement values are stored in a list, you can splice that in with
<code style="white-space: pre;">&#8288;!!!&#8288;</code>.</p>
</td></tr>
<tr><td><code id="list_assign_+3A_.is_node">.is_node</code></td>
<td>
<p>A predicate function that determines whether an element is
a node (by returning <code>TRUE</code>) or a leaf (by returning <code>FALSE</code>). The
default value, <code>NULL</code>, treats simple lists as nodes and everything else
(including richer objects like data frames and linear models) as leaves,
using <code><a href="vctrs.html#topic+vec_is_list">vctrs::vec_is_list()</a></code>. To recurse into all objects built on lists
use <code><a href="base.html#topic+is.list">is.list()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(x = 1:10, y = 4, z = list(a = 1, b = 2))
str(x)

# Update values
str(list_assign(x, a = 1))
# Replace values
str(list_assign(x, z = 5))
str(list_assign(x, z = NULL))

str(list_assign(x, z = list(a = 1:5)))
# replace recursively, leaving the other elements of z alone
str(list_modify(x, z = list(a = 1:5)))

# Remove values
str(list_assign(x, z = zap()))

# Combine values with list_merge()
str(list_merge(x, x = 11, z = list(a = 2:5, c = 3)))

# All these functions support dynamic dots features. Use !!! to splice
# a list of arguments:
l &lt;- list(new = 1, y = zap(), z = 5)
str(list_assign(x, !!!l))
</code></pre>

<hr>
<h2 id='list_c'>Combine list elements into a single data structure</h2><span id='topic+list_c'></span><span id='topic+list_cbind'></span><span id='topic+list_rbind'></span>

<h3>Description</h3>


<ul>
<li> <p><code>list_c()</code> combines elements into a vector by concatenating them together
with <code><a href="vctrs.html#topic+vec_c">vctrs::vec_c()</a></code>.
</p>
</li>
<li> <p><code>list_rbind()</code> combines elements into a data frame by row-binding them
together with <code><a href="vctrs.html#topic+vec_bind">vctrs::vec_rbind()</a></code>.
</p>
</li>
<li> <p><code>list_cbind()</code> combines elements into a data frame by column-binding them
together with <code><a href="vctrs.html#topic+vec_bind">vctrs::vec_cbind()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>list_c(x, ..., ptype = NULL)

list_cbind(
  x,
  ...,
  name_repair = c("unique", "universal", "check_unique"),
  size = NULL
)

list_rbind(x, ..., names_to = rlang::zap(), ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_c_+3A_x">x</code></td>
<td>
<p>A list. For <code>list_rbind()</code> and <code>list_cbind()</code> the list must
only contain only data frames or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="list_c_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="list_c_+3A_ptype">ptype</code></td>
<td>
<p>An optional prototype to ensure that the output type is always
the same.</p>
</td></tr>
<tr><td><code id="list_c_+3A_name_repair">name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, or <code>"check_unique"</code>.
See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for the meaning of these options.</p>
</td></tr>
<tr><td><code id="list_c_+3A_size">size</code></td>
<td>
<p>An optional integer size to ensure that every input has the
same size (i.e. number of rows).</p>
</td></tr>
<tr><td><code id="list_c_+3A_names_to">names_to</code></td>
<td>
<p>By default, <code>names(x)</code> are lost. To keep them, supply a
string to <code>names_to</code> and the names will be saved into a column with that
name. If <code>names_to</code> is supplied and <code>x</code> is not named, the position of
the elements will be used instead of the names.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- list(a = 1, b = 2, c = 3)
list_c(x1)

x2 &lt;- list(
  a = data.frame(x = 1:2),
  b = data.frame(y = "a")
)
list_rbind(x2)
list_rbind(x2, names_to = "id")
list_rbind(unname(x2), names_to = "id")

list_cbind(x2)
</code></pre>

<hr>
<h2 id='list_flatten'>Flatten a list</h2><span id='topic+list_flatten'></span>

<h3>Description</h3>

<p>Flattening a list removes a single layer of internal hierarchy,
i.e. it inlines elements that are lists leaving non-lists alone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_flatten(
  x,
  ...,
  name_spec = "{outer}_{inner}",
  name_repair = c("minimal", "unique", "check_unique", "universal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_flatten_+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="list_flatten_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="list_flatten_+3A_name_spec">name_spec</code></td>
<td>
<p>If both inner and outer names are present, control
how they are combined. Should be a glue specification that uses
variables <code>inner</code> and <code>outer</code>.</p>
</td></tr>
<tr><td><code id="list_flatten_+3A_name_repair">name_repair</code></td>
<td>
<p>One of <code>"minimal"</code>, <code>"unique"</code>, <code>"universal"</code>, or
<code>"check_unique"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for the meaning of these
options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same type as <code>x</code>. The list might be shorter
if <code>x</code> contains empty lists, the same length if it contains lists
of length 1 or no sub-lists, or longer if it contains lists of
length &gt; 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(1, list(2, 3), list(4, list(5)))
x |&gt; list_flatten() |&gt; str()
x |&gt; list_flatten() |&gt; list_flatten() |&gt; str()

# Flat lists are left as is
list(1, 2, 3, 4, 5) |&gt; list_flatten() |&gt; str()

# Empty lists will disappear
list(1, list(), 2, list(3)) |&gt; list_flatten() |&gt; str()

# Another way to see this is that it reduces the depth of the list
x &lt;- list(
  list(),
  list(list())
)
x |&gt; pluck_depth()
x |&gt; list_flatten() |&gt; pluck_depth()

# Use name_spec to control how inner and outer names are combined
x &lt;- list(x = list(a = 1, b = 2), y = list(c = 1, d = 2))
x |&gt; list_flatten() |&gt; names()
x |&gt; list_flatten(name_spec = "{outer}") |&gt; names()
x |&gt; list_flatten(name_spec = "{inner}") |&gt; names()
</code></pre>

<hr>
<h2 id='list_simplify'>Simplify a list to an atomic or S3 vector</h2><span id='topic+list_simplify'></span>

<h3>Description</h3>

<p>Simplification maintains a one-to-one correspondence between the input
and output, implying that each element of <code>x</code> must contain a one element
vector or a one-row data frame. If you don't want to maintain this
correspondence, then you probably want either <code><a href="purrr.html#topic+list_c">list_c()</a></code>/<code><a href="purrr.html#topic+list_rbind">list_rbind()</a></code> or
<code><a href="purrr.html#topic+list_flatten">list_flatten()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_simplify(x, ..., strict = TRUE, ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_simplify_+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="list_simplify_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="list_simplify_+3A_strict">strict</code></td>
<td>
<p>What should happen if simplification fails? If <code>TRUE</code>,
it will error. If <code>FALSE</code> and <code>ptype</code> is not supplied, it will return <code>x</code>
unchanged.</p>
</td></tr>
<tr><td><code id="list_simplify_+3A_ptype">ptype</code></td>
<td>
<p>An optional prototype to ensure that the output type is always
the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list_simplify(list(1, 2, 3))

# Only works when vectors are length one and have compatible types:
try(list_simplify(list(1, 2, 1:3)))
try(list_simplify(list(1, 2, "x")))

# Unless you strict = FALSE, in which case you get the input back:
list_simplify(list(1, 2, 1:3), strict = FALSE)
list_simplify(list(1, 2, "x"), strict = FALSE)
</code></pre>

<hr>
<h2 id='list_transpose'>Transpose a list</h2><span id='topic+list_transpose'></span>

<h3>Description</h3>

<p><code>list_transpose()</code> turns a list-of-lists &quot;inside-out&quot;. For instance it turns a pair of
lists into a list of pairs, or a list of pairs into a pair of lists. For
example, if you had a list of length <code>n</code> where each component had values <code>a</code>
and <code>b</code>, <code>list_transpose()</code> would make a list with elements <code>a</code> and
<code>b</code> that contained lists of length <code>n</code>.
</p>
<p>It's called transpose because <code>x[["a"]][["b"]]</code> is equivalent to
<code>list_transpose(x)[["b"]][["a"]]</code>, i.e. transposing a list flips the order of
indices in a similar way to transposing a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_transpose(
  x,
  ...,
  template = NULL,
  simplify = NA,
  ptype = NULL,
  default = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_transpose_+3A_x">x</code></td>
<td>
<p>A list of vectors to transpose.</p>
</td></tr>
<tr><td><code id="list_transpose_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="list_transpose_+3A_template">template</code></td>
<td>
<p>A &quot;template&quot; that describes the output list. Can either be
a character vector (where elements are extracted by name), or an integer
vector (where elements are extracted by position). Defaults to the names
of the first element of <code>x</code>, or if they're not present, the integer
indices.</p>
</td></tr>
<tr><td><code id="list_transpose_+3A_simplify">simplify</code></td>
<td>
<p>Should the result be <a href="purrr.html#topic+list_simplify">simplified</a>?
</p>

<ul>
<li> <p><code>TRUE</code>: simplify or die trying.
</p>
</li>
<li> <p><code>NA</code>: simplify if possible.
</p>
</li>
<li> <p><code>FALSE</code>: never try to simplify, always leaving as a list.
</p>
</li></ul>

<p>Alternatively, a named list specifying the simplification by output
element.</p>
</td></tr>
<tr><td><code id="list_transpose_+3A_ptype">ptype</code></td>
<td>
<p>An optional vector prototype used to control the simplification.
Alternatively, a named list specifying the prototype by output element.</p>
</td></tr>
<tr><td><code id="list_transpose_+3A_default">default</code></td>
<td>
<p>A default value to use if a value is absent or <code>NULL</code>.
Alternatively, a named list specifying the default by output element.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># list_transpose() is useful in conjunction with safely()
x &lt;- list("a", 1, 2)
y &lt;- x |&gt; map(safely(log))
y |&gt; str()
# Put all the errors and results together
y |&gt; list_transpose() |&gt; str()
# Supply a default result to further simplify
y |&gt; list_transpose(default = list(result = NA)) |&gt; str()

# list_transpose() will try to simplify by default:
x &lt;- list(list(a = 1, b = 2), list(a = 3, b = 4), list(a = 5, b = 6))
x |&gt; list_transpose()
# this makes list_tranpose() not completely symmetric
x |&gt; list_transpose() |&gt; list_transpose()

# use simplify = FALSE to always return lists:
x |&gt; list_transpose(simplify = FALSE) |&gt; str()
x |&gt;
  list_transpose(simplify = FALSE) |&gt;
  list_transpose(simplify = FALSE) |&gt; str()

# Provide an explicit template if you know which elements you want to extract
ll &lt;- list(
  list(x = 1, y = "one"),
  list(z = "deux", x = 2)
)
ll |&gt; list_transpose()
ll |&gt; list_transpose(template = c("x", "y", "z"))
ll |&gt; list_transpose(template = 1)

# And specify a default if you want to simplify
ll |&gt; list_transpose(template = c("x", "y", "z"), default = NA)
</code></pre>

<hr>
<h2 id='lmap'>Apply a function to list-elements of a list</h2><span id='topic+lmap'></span><span id='topic+lmap_if'></span><span id='topic+lmap_at'></span>

<h3>Description</h3>

<p><code>lmap()</code>, <code>lmap_at()</code> and <code>lmap_if()</code> are similar to <code>map()</code>, <code>map_at()</code> and
<code>map_if()</code>, except instead of mapping over <code>.x[[i]]</code>, they instead map over
<code>.x[i]</code>.
</p>
<p>This has several advantages:
</p>

<ul>
<li><p> It makes it possible to work with functions that exclusively take a list.
</p>
</li>
<li><p> It allows <code>.f</code> to access the attributes of the encapsulating list,
like <code><a href="base.html#topic+names">names()</a></code>.
</p>
</li>
<li><p> It allows <code>.f</code> to return a larger or small list than it receives
changing the size of the output.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>lmap(.x, .f, ...)

lmap_if(.x, .p, .f, ..., .else = NULL)

lmap_at(.x, .at, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmap_+3A_.x">.x</code></td>
<td>
<p>A list or data frame.</p>
</td></tr>
<tr><td><code id="lmap_+3A_.f">.f</code></td>
<td>
<p>A function that takes a length-1 list and returns a list (of any
length.)</p>
</td></tr>
<tr><td><code id="lmap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="lmap_+3A_.p">.p</code></td>
<td>
<p>A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as <code>.x</code>.
Alternatively, if the elements of <code>.x</code> are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where <code>.p</code> evaluates to
<code>TRUE</code> will be modified.</p>
</td></tr>
<tr><td><code id="lmap_+3A_.else">.else</code></td>
<td>
<p>A function applied to elements of <code>.x</code> for which <code>.p</code>
returns <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lmap_+3A_.at">.at</code></td>
<td>
<p>A logical, integer, or character vector giving the elements
to select. Alternatively, a function that takes a vector of names,
and returns a logical, integer, or character vector of elements to select.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>: if the tidyselect package is
installed, you can use <code>vars()</code> and tidyselect helpers to select
elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or data frame, matching <code>.x</code>. There are no guarantees about
the length.
</p>


<h3>See Also</h3>

<p>Other map variants: 
<code><a href="purrr.html#topic+imap">imap</a>()</code>,
<code><a href="purrr.html#topic+map2">map2</a>()</code>,
<code><a href="purrr.html#topic+map_depth">map_depth</a>()</code>,
<code><a href="purrr.html#topic+map_if">map_if</a>()</code>,
<code><a href="maps.html#topic+map">map</a>()</code>,
<code><a href="purrr.html#topic+modify">modify</a>()</code>,
<code><a href="purrr.html#topic+pmap">pmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1014)

# Let's write a function that returns a larger list or an empty list
# depending on some condition. It also uses the input name to name the
# output
maybe_rep &lt;- function(x) {
  n &lt;- rpois(1, 2)
  set_names(rep_len(x, n), paste0(names(x), seq_len(n)))
}

# The output size varies each time we map f()
x &lt;- list(a = 1:4, b = letters[5:7], c = 8:9, d = letters[10])
x |&gt; lmap(maybe_rep) |&gt; str()

# We can apply f() on a selected subset of x
x |&gt; lmap_at(c("a", "d"), maybe_rep) |&gt; str()

# Or only where a condition is satisfied
x |&gt; lmap_if(is.character, maybe_rep) |&gt; str()
</code></pre>

<hr>
<h2 id='map'>Apply a function to each element of a vector</h2><span id='topic+map'></span><span id='topic+map_lgl'></span><span id='topic+map_int'></span><span id='topic+map_dbl'></span><span id='topic+map_chr'></span><span id='topic+map_vec'></span><span id='topic+walk'></span>

<h3>Description</h3>

<p>The map functions transform their input by applying a function to
each element of a list or atomic vector and returning an object of
the same length as the input.
</p>

<ul>
<li> <p><code>map()</code> always returns a list. See the <code><a href="purrr.html#topic+modify">modify()</a></code> family for
versions that return an object of the same type as the input.
</p>
</li>
<li> <p><code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code> and <code>map_chr()</code> return an
atomic vector of the indicated type (or die trying). For these functions,
<code>.f</code> must return a length-1 vector of the appropriate type.
</p>
</li>
<li> <p><code>map_vec()</code> simplifies to the common type of the output. It works with
most types of simple vectors like Date, POSIXct, factors, etc.
</p>
</li>
<li> <p><code>walk()</code> calls <code>.f</code> for its side-effect and returns
the input <code>.x</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>map(.x, .f, ..., .progress = FALSE)

map_lgl(.x, .f, ..., .progress = FALSE)

map_int(.x, .f, ..., .progress = FALSE)

map_dbl(.x, .f, ..., .progress = FALSE)

map_chr(.x, .f, ..., .progress = FALSE)

map_vec(.x, .f, ..., .ptype = NULL, .progress = FALSE)

walk(.x, .f, ..., .progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="map_+3A_.f">.f</code></td>
<td>
<p>A function, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. You must use <code>.x</code> to refer to the first
argument. Only recommended if you require backward compatibility with
older versions of R.
</p>
</li>
<li><p> A string, integer, or list, e.g. <code>"idx"</code>, <code>1</code>, or <code>list("idx", 1)</code> which
are shorthand for <code style="white-space: pre;">&#8288;\(x) pluck(x, "idx")&#8288;</code>, <code style="white-space: pre;">&#8288;\(x) pluck(x, 1)&#8288;</code>, and
<code style="white-space: pre;">&#8288;\(x) pluck(x, "idx", 1)&#8288;</code> respectively. Optionally supply <code>.default</code> to
set a default value if the indexed element is <code>NULL</code> or does not exist.
</p>
</li></ul>
</td></tr>
<tr><td><code id="map_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="map_+3A_.progress">.progress</code></td>
<td>
<p>Whether to show a progress bar. Use <code>TRUE</code> to turn on
a basic progress bar, use a string to give it a name, or see
<a href="purrr.html#topic+progress_bars">progress_bars</a> for more details.</p>
</td></tr>
<tr><td><code id="map_+3A_.ptype">.ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is the common type
of the elements of the result. Otherwise, supply a &quot;prototype&quot; giving
the desired type of output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output length is determined by the length of the input.
The output names are determined by the input names.
The output type is determined by the suffix:
</p>

<ul>
<li><p> No suffix: a list; <code>.f()</code> can return anything.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_lgl()&#8288;</code>, <code style="white-space: pre;">&#8288;_int()&#8288;</code>, <code style="white-space: pre;">&#8288;_dbl()&#8288;</code>, <code style="white-space: pre;">&#8288;_chr()&#8288;</code> return a logical, integer, double,
or character vector respectively; <code>.f()</code> must return a compatible atomic
vector of length 1.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_vec()&#8288;</code> return an atomic or S3 vector, the same type that <code>.f</code> returns.
<code>.f</code> can return pretty much any type of vector, as long as its length 1.
</p>
</li>
<li> <p><code>walk()</code> returns the input <code>.x</code> (invisibly). This makes it easy to
use in a pipe. The return value of <code>.f()</code> is ignored.
</p>
</li></ul>

<p>Any errors thrown by <code>.f</code> will be wrapped in an error with class
<a href="purrr.html#topic+purrr_error_indexed">purrr_error_indexed</a>.
</p>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+map_if">map_if()</a></code> for applying a function to only those elements
of <code>.x</code> that meet a specified condition.
</p>
<p>Other map variants: 
<code><a href="purrr.html#topic+imap">imap</a>()</code>,
<code><a href="purrr.html#topic+lmap">lmap</a>()</code>,
<code><a href="purrr.html#topic+map2">map2</a>()</code>,
<code><a href="purrr.html#topic+map_depth">map_depth</a>()</code>,
<code><a href="purrr.html#topic+map_if">map_if</a>()</code>,
<code><a href="purrr.html#topic+modify">modify</a>()</code>,
<code><a href="purrr.html#topic+pmap">pmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute normal distributions from an atomic vector
1:10 |&gt;
  map(rnorm, n = 10)

# You can also use an anonymous function
1:10 |&gt;
  map(\(x) rnorm(10, x))

# Simplify output to a vector instead of a list by computing the mean of the distributions
1:10 |&gt;
  map(rnorm, n = 10) |&gt;  # output a list
  map_dbl(mean)           # output an atomic vector

# Using set_names() with character vectors is handy to keep track
# of the original inputs:
set_names(c("foo", "bar")) |&gt; map_chr(paste0, ":suffix")

# Working with lists
favorite_desserts &lt;- list(Sophia = "banana bread", Eliott = "pancakes", Karina = "chocolate cake")
favorite_desserts |&gt; map_chr(\(food) paste(food, "rocks!"))

# Extract by name or position
# .default specifies value for elements that are missing or NULL
l1 &lt;- list(list(a = 1L), list(a = NULL, b = 2L), list(b = 3L))
l1 |&gt; map("a", .default = "???")
l1 |&gt; map_int("b", .default = NA)
l1 |&gt; map_int(2, .default = NA)

# Supply multiple values to index deeply into a list
l2 &lt;- list(
  list(num = 1:3,     letters[1:3]),
  list(num = 101:103, letters[4:6]),
  list()
)
l2 |&gt; map(c(2, 2))

# Use a list to build an extractor that mixes numeric indices and names,
# and .default to provide a default value if the element does not exist
l2 |&gt; map(list("num", 3))
l2 |&gt; map_int(list("num", 3), .default = NA)

# Working with data frames
# Use map_lgl(), map_dbl(), etc to return a vector instead of a list:
mtcars |&gt; map_dbl(sum)

# A more realistic example: split a data frame into pieces, fit a
# model to each piece, summarise and extract R^2
mtcars |&gt;
  split(mtcars$cyl) |&gt;
  map(\(df) lm(mpg ~ wt, data = df)) |&gt;
  map(summary) |&gt;
  map_dbl("r.squared")
</code></pre>

<hr>
<h2 id='map_depth'>Map/modify elements at given depth</h2><span id='topic+map_depth'></span><span id='topic+modify_depth'></span>

<h3>Description</h3>

<p><code>map_depth()</code> calls <code>map(.y, .f)</code> on all <code>.y</code> at the specified <code>.depth</code> in
<code>.x</code>. <code>modify_depth()</code> calls <code>modify(.y, .f)</code> on <code>.y</code> at the specified
<code>.depth</code> in <code>.x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_depth(.x, .depth, .f, ..., .ragged = .depth &lt; 0, .is_node = NULL)

modify_depth(.x, .depth, .f, ..., .ragged = .depth &lt; 0, .is_node = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_depth_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="map_depth_+3A_.depth">.depth</code></td>
<td>
<p>Level of <code>.x</code> to map on. Use a negative value to
count up from the lowest level of the list.
</p>

<ul>
<li> <p><code>map_depth(x, 0, fun)</code> is equivalent to <code>fun(x)</code>.
</p>
</li>
<li> <p><code>map_depth(x, 1, fun)</code> is equivalent to <code>x &lt;- map(x, fun)</code>
</p>
</li>
<li> <p><code>map_depth(x, 2, fun)</code> is equivalent to <code style="white-space: pre;">&#8288;x &lt;- map(x, \(y) map(y, fun))&#8288;</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="map_depth_+3A_.f">.f</code></td>
<td>
<p>A function, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. You must use <code>.x</code> to refer to the first
argument. Only recommended if you require backward compatibility with
older versions of R.
</p>
</li>
<li><p> A string, integer, or list, e.g. <code>"idx"</code>, <code>1</code>, or <code>list("idx", 1)</code> which
are shorthand for <code style="white-space: pre;">&#8288;\(x) pluck(x, "idx")&#8288;</code>, <code style="white-space: pre;">&#8288;\(x) pluck(x, 1)&#8288;</code>, and
<code style="white-space: pre;">&#8288;\(x) pluck(x, "idx", 1)&#8288;</code> respectively. Optionally supply <code>.default</code> to
set a default value if the indexed element is <code>NULL</code> or does not exist.
</p>
</li></ul>
</td></tr>
<tr><td><code id="map_depth_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="map_depth_+3A_.ragged">.ragged</code></td>
<td>
<p>If <code>TRUE</code>, will apply to leaves, even if they're not
at depth <code>.depth</code>. If <code>FALSE</code>, will throw an error if there are
no elements at depth <code>.depth</code>.</p>
</td></tr>
<tr><td><code id="map_depth_+3A_.is_node">.is_node</code></td>
<td>
<p>A predicate function that determines whether an element is
a node (by returning <code>TRUE</code>) or a leaf (by returning <code>FALSE</code>). The
default value, <code>NULL</code>, treats simple lists as nodes and everything else
(including richer objects like data frames and linear models) as leaves,
using <code><a href="vctrs.html#topic+vec_is_list">vctrs::vec_is_list()</a></code>. To recurse into all objects built on lists
use <code><a href="base.html#topic+is.list">is.list()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+modify_tree">modify_tree()</a></code> for a recursive version of <code>modify_depth()</code> that
allows you to apply a function to every leaf or every node.
</p>
<p>Other map variants: 
<code><a href="purrr.html#topic+imap">imap</a>()</code>,
<code><a href="purrr.html#topic+lmap">lmap</a>()</code>,
<code><a href="purrr.html#topic+map2">map2</a>()</code>,
<code><a href="purrr.html#topic+map_if">map_if</a>()</code>,
<code><a href="maps.html#topic+map">map</a>()</code>,
<code><a href="purrr.html#topic+modify">modify</a>()</code>,
<code><a href="purrr.html#topic+pmap">pmap</a>()</code>
</p>
<p>Other modify variants: 
<code><a href="purrr.html#topic+modify_tree">modify_tree</a>()</code>,
<code><a href="purrr.html#topic+modify">modify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># map_depth() -------------------------------------------------
# Use `map_depth()` to recursively traverse nested vectors and map
# a function at a certain depth:
x &lt;- list(a = list(foo = 1:2, bar = 3:4), b = list(baz = 5:6))
x |&gt; str()
x |&gt; map_depth(2, \(y) paste(y, collapse = "/")) |&gt; str()

# Equivalent to:
x |&gt; map(\(y) map(y, \(z) paste(z, collapse = "/"))) |&gt; str()

# When ragged is TRUE, `.f()` will also be passed leaves at depth &lt; `.depth`
x &lt;- list(1, list(1, list(1, list(1, 1))))
x |&gt; str()
x |&gt; map_depth(4, \(x) length(unlist(x)), .ragged = TRUE) |&gt; str()
x |&gt; map_depth(3, \(x) length(unlist(x)), .ragged = TRUE) |&gt; str()
x |&gt; map_depth(2, \(x) length(unlist(x)), .ragged = TRUE) |&gt; str()
x |&gt; map_depth(1, \(x) length(unlist(x)), .ragged = TRUE) |&gt; str()
x |&gt; map_depth(0, \(x) length(unlist(x)), .ragged = TRUE) |&gt; str()

# modify_depth() -------------------------------------------------
l1 &lt;- list(
  obj1 = list(
    prop1 = list(param1 = 1:2, param2 = 3:4),
    prop2 = list(param1 = 5:6, param2 = 7:8)
  ),
  obj2 = list(
    prop1 = list(param1 = 9:10, param2 = 11:12),
    prop2 = list(param1 = 12:14, param2 = 15:17)
  )
)

# In the above list, "obj" is level 1, "prop" is level 2 and "param"
# is level 3. To apply sum() on all params, we map it at depth 3:
l1 |&gt; modify_depth(3, sum) |&gt; str()

# modify() lets us pluck the elements prop1/param2 in obj1 and obj2:
l1 |&gt; modify(c("prop1", "param2")) |&gt; str()

# But what if we want to pluck all param2 elements? Then we need to
# act at a lower level:
l1 |&gt; modify_depth(2, "param2") |&gt; str()

# modify_depth() can be with other purrr functions to make them operate at
# a lower level. Here we ask pmap() to map paste() simultaneously over all
# elements of the objects at the second level. paste() is effectively
# mapped at level 3.
l1 |&gt; modify_depth(2, \(x) pmap(x, paste, sep = " / ")) |&gt; str()
</code></pre>

<hr>
<h2 id='map_dfr'>Functions that return data frames</h2><span id='topic+map_dfr'></span><span id='topic+map_df'></span><span id='topic+map_dfc'></span><span id='topic+imap_dfr'></span><span id='topic+imap_dfc'></span><span id='topic+map2_dfr'></span><span id='topic+map2_dfc'></span><span id='topic+map2_df'></span><span id='topic+pmap_dfr'></span><span id='topic+pmap_dfc'></span><span id='topic+pmap_df'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>These <code><a href="maps.html#topic+map">map()</a></code>, <code><a href="purrr.html#topic+map2">map2()</a></code>, <code><a href="purrr.html#topic+imap">imap()</a></code>, and <code><a href="purrr.html#topic+pmap">pmap()</a></code> variants return data
frames by row-binding or column-binding the outputs together.
</p>
<p>The functions were superseded in purrr 1.0.0 because their names
suggest they work like <code style="white-space: pre;">&#8288;_lgl()&#8288;</code>, <code style="white-space: pre;">&#8288;_int()&#8288;</code>, etc which require length
1 outputs, but actually they return results of any size because the results
are combined without any size checks. Additionally, they use
<code>dplyr::bind_rows()</code> and <code>dplyr::bind_cols()</code> which require dplyr to be
installed and have confusing semantics with edge cases. Superseded
functions will not go away, but will only receive critical bug fixes.
</p>
<p>Instead, we recommend using <code>map()</code>, <code>map2()</code>, etc with <code><a href="purrr.html#topic+list_rbind">list_rbind()</a></code> and
<code><a href="purrr.html#topic+list_cbind">list_cbind()</a></code>. These use <code><a href="vctrs.html#topic+vec_bind">vctrs::vec_rbind()</a></code> and <code><a href="vctrs.html#topic+vec_bind">vctrs::vec_cbind()</a></code>
under the hood, and have names that more clearly reflect their semantics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_dfr(.x, .f, ..., .id = NULL)

map_dfc(.x, .f, ...)

imap_dfr(.x, .f, ..., .id = NULL)

imap_dfc(.x, .f, ...)

map2_dfr(.x, .y, .f, ..., .id = NULL)

map2_dfc(.x, .y, .f, ...)

pmap_dfr(.l, .f, ..., .id = NULL)

pmap_dfc(.l, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_dfr_+3A_.id">.id</code></td>
<td>
<p>Either a string or <code>NULL</code>. If a string, the output will contain
a variable with that name, storing either the name (if <code>.x</code> is named) or
the index (if <code>.x</code> is unnamed) of the input. If <code>NULL</code>, the default, no
variable will be created.
</p>
<p>Only applies to <code style="white-space: pre;">&#8288;_dfr&#8288;</code> variant.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># map ---------------------------------------------
# Was:
mtcars |&gt;
  split(mtcars$cyl) |&gt;
  map(\(df) lm(mpg ~ wt, data = df)) |&gt;
  map_dfr(\(mod) as.data.frame(t(as.matrix(coef(mod)))))

# Now:
mtcars |&gt;
  split(mtcars$cyl) |&gt;
  map(\(df) lm(mpg ~ wt, data = df)) |&gt;
  map(\(mod) as.data.frame(t(as.matrix(coef(mod))))) |&gt;
  list_rbind()

# map2 ---------------------------------------------

ex_fun &lt;- function(arg1, arg2){
  col &lt;- arg1 + arg2
  x &lt;- as.data.frame(col)
}
arg1 &lt;- 1:4
arg2 &lt;- 10:13

# was
map2_dfr(arg1, arg2, ex_fun)
# now
map2(arg1, arg2, ex_fun) |&gt; list_rbind()

# was
map2_dfc(arg1, arg2, ex_fun)
# now
map2(arg1, arg2, ex_fun) |&gt; list_cbind()
</code></pre>

<hr>
<h2 id='map_if'>Apply a function to each element of a vector conditionally</h2><span id='topic+map_if'></span><span id='topic+map_at'></span>

<h3>Description</h3>

<p>The functions <code>map_if()</code> and <code>map_at()</code> take <code>.x</code> as input, apply
the function <code>.f</code> to some of the elements of <code>.x</code>, and return a
list of the same length as the input.
</p>

<ul>
<li> <p><code>map_if()</code> takes a predicate function <code>.p</code> as input to determine
which elements of <code>.x</code> are transformed with <code>.f</code>.
</p>
</li>
<li> <p><code>map_at()</code> takes a vector of names or positions <code>.at</code> to specify
which elements of <code>.x</code> are transformed with <code>.f</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>map_if(.x, .p, .f, ..., .else = NULL)

map_at(.x, .at, .f, ..., .progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_if_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="map_if_+3A_.p">.p</code></td>
<td>
<p>A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as <code>.x</code>.
Alternatively, if the elements of <code>.x</code> are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where <code>.p</code> evaluates to
<code>TRUE</code> will be modified.</p>
</td></tr>
<tr><td><code id="map_if_+3A_.f">.f</code></td>
<td>
<p>A function, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. You must use <code>.x</code> to refer to the first
argument. Only recommended if you require backward compatibility with
older versions of R.
</p>
</li>
<li><p> A string, integer, or list, e.g. <code>"idx"</code>, <code>1</code>, or <code>list("idx", 1)</code> which
are shorthand for <code style="white-space: pre;">&#8288;\(x) pluck(x, "idx")&#8288;</code>, <code style="white-space: pre;">&#8288;\(x) pluck(x, 1)&#8288;</code>, and
<code style="white-space: pre;">&#8288;\(x) pluck(x, "idx", 1)&#8288;</code> respectively. Optionally supply <code>.default</code> to
set a default value if the indexed element is <code>NULL</code> or does not exist.
</p>
</li></ul>
</td></tr>
<tr><td><code id="map_if_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="map_if_+3A_.else">.else</code></td>
<td>
<p>A function applied to elements of <code>.x</code> for which <code>.p</code>
returns <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="map_if_+3A_.at">.at</code></td>
<td>
<p>A logical, integer, or character vector giving the elements
to select. Alternatively, a function that takes a vector of names,
and returns a logical, integer, or character vector of elements to select.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>: if the tidyselect package is
installed, you can use <code>vars()</code> and tidyselect helpers to select
elements.</p>
</td></tr>
<tr><td><code id="map_if_+3A_.progress">.progress</code></td>
<td>
<p>Whether to show a progress bar. Use <code>TRUE</code> to turn on
a basic progress bar, use a string to give it a name, or see
<a href="purrr.html#topic+progress_bars">progress_bars</a> for more details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other map variants: 
<code><a href="purrr.html#topic+imap">imap</a>()</code>,
<code><a href="purrr.html#topic+lmap">lmap</a>()</code>,
<code><a href="purrr.html#topic+map2">map2</a>()</code>,
<code><a href="purrr.html#topic+map_depth">map_depth</a>()</code>,
<code><a href="maps.html#topic+map">map</a>()</code>,
<code><a href="purrr.html#topic+modify">modify</a>()</code>,
<code><a href="purrr.html#topic+pmap">pmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use a predicate function to decide whether to map a function:
iris |&gt; map_if(is.factor, as.character) |&gt; str()

# Specify an alternative with the `.else` argument:
iris |&gt; map_if(is.factor, as.character, .else = as.integer) |&gt; str()

# Use numeric vector of positions select elements to change:
iris |&gt; map_at(c(4, 5), is.numeric) |&gt; str()

# Use vector of names to specify which elements to change:
iris |&gt; map_at("Species", toupper) |&gt; str()
</code></pre>

<hr>
<h2 id='map_raw'>Functions that return raw vectors</h2><span id='topic+map_raw'></span><span id='topic+map2_raw'></span><span id='topic+imap_raw'></span><span id='topic+pmap_raw'></span><span id='topic+flatten_raw'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions were deprecated in purrr 1.0.0 because they are of limited
use and you can now use <code>map_vec()</code> instead. They are variants of <code><a href="maps.html#topic+map">map()</a></code>,
<code><a href="purrr.html#topic+map2">map2()</a></code>, <code><a href="purrr.html#topic+imap">imap()</a></code>, <code><a href="purrr.html#topic+pmap">pmap()</a></code>, and <code><a href="jsonlite.html#topic+flatten">flatten()</a></code> that return raw vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_raw(.x, .f, ...)

map2_raw(.x, .y, .f, ...)

imap_raw(.x, .f, ...)

pmap_raw(.l, .f, ...)

flatten_raw(.x)
</code></pre>

<hr>
<h2 id='map2'>Map over two inputs</h2><span id='topic+map2'></span><span id='topic+map2_lgl'></span><span id='topic+map2_int'></span><span id='topic+map2_dbl'></span><span id='topic+map2_chr'></span><span id='topic+map2_vec'></span><span id='topic+walk2'></span>

<h3>Description</h3>

<p>These functions are variants of <code><a href="maps.html#topic+map">map()</a></code> that iterate over two arguments at
a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map2(.x, .y, .f, ..., .progress = FALSE)

map2_lgl(.x, .y, .f, ..., .progress = FALSE)

map2_int(.x, .y, .f, ..., .progress = FALSE)

map2_dbl(.x, .y, .f, ..., .progress = FALSE)

map2_chr(.x, .y, .f, ..., .progress = FALSE)

map2_vec(.x, .y, .f, ..., .ptype = NULL, .progress = FALSE)

walk2(.x, .y, .f, ..., .progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map2_+3A_.x">.x</code>, <code id="map2_+3A_.y">.y</code></td>
<td>
<p>A pair of vectors, usually the same length. If not, a vector
of length 1 will be recycled to the length of the other.</p>
</td></tr>
<tr><td><code id="map2_+3A_.f">.f</code></td>
<td>
<p>A function, specified in one of the following ways:
</p>

<ul>
<li><p> A named function.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x, y) x + y&#8288;</code> or <code>function(x, y) x + y</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + .y</code>. You must use <code>.x</code> to refer to the current
element of <code>x</code> and <code>.y</code> to refer to the current element of <code>y</code>. Only
recommended if you require backward compatibility with older versions
of R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="map2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="map2_+3A_.progress">.progress</code></td>
<td>
<p>Whether to show a progress bar. Use <code>TRUE</code> to turn on
a basic progress bar, use a string to give it a name, or see
<a href="purrr.html#topic+progress_bars">progress_bars</a> for more details.</p>
</td></tr>
<tr><td><code id="map2_+3A_.ptype">.ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is the common type
of the elements of the result. Otherwise, supply a &quot;prototype&quot; giving
the desired type of output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output length is determined by the length of the input.
The output names are determined by the input names.
The output type is determined by the suffix:
</p>

<ul>
<li><p> No suffix: a list; <code>.f()</code> can return anything.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_lgl()&#8288;</code>, <code style="white-space: pre;">&#8288;_int()&#8288;</code>, <code style="white-space: pre;">&#8288;_dbl()&#8288;</code>, <code style="white-space: pre;">&#8288;_chr()&#8288;</code> return a logical, integer, double,
or character vector respectively; <code>.f()</code> must return a compatible atomic
vector of length 1.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_vec()&#8288;</code> return an atomic or S3 vector, the same type that <code>.f</code> returns.
<code>.f</code> can return pretty much any type of vector, as long as its length 1.
</p>
</li>
<li> <p><code>walk()</code> returns the input <code>.x</code> (invisibly). This makes it easy to
use in a pipe. The return value of <code>.f()</code> is ignored.
</p>
</li></ul>

<p>Any errors thrown by <code>.f</code> will be wrapped in an error with class
<a href="purrr.html#topic+purrr_error_indexed">purrr_error_indexed</a>.
</p>


<h3>See Also</h3>

<p>Other map variants: 
<code><a href="purrr.html#topic+imap">imap</a>()</code>,
<code><a href="purrr.html#topic+lmap">lmap</a>()</code>,
<code><a href="purrr.html#topic+map_depth">map_depth</a>()</code>,
<code><a href="purrr.html#topic+map_if">map_if</a>()</code>,
<code><a href="maps.html#topic+map">map</a>()</code>,
<code><a href="purrr.html#topic+modify">modify</a>()</code>,
<code><a href="purrr.html#topic+pmap">pmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(1, 1, 1)
y &lt;- list(10, 20, 30)

map2(x, y, \(x, y) x + y)
# Or just
map2(x, y, `+`)

# Split into pieces, fit model to each piece, then predict
by_cyl &lt;- mtcars |&gt; split(mtcars$cyl)
mods &lt;- by_cyl |&gt; map(\(df) lm(mpg ~ wt, data = df))
map2(mods, by_cyl, predict)
</code></pre>

<hr>
<h2 id='modify'>Modify elements selectively</h2><span id='topic+modify'></span><span id='topic+modify_if'></span><span id='topic+modify_at'></span><span id='topic+modify2'></span><span id='topic+imodify'></span>

<h3>Description</h3>

<p>Unlike <code><a href="maps.html#topic+map">map()</a></code> and its variants which always return a fixed object
type (list for <code>map()</code>, integer vector for <code>map_int()</code>, etc), the
<code>modify()</code> family always returns the same type as the input object.
</p>

<ul>
<li> <p><code>modify()</code> is a shortcut for <code style="white-space: pre;">&#8288;x[[i]] &lt;- f(x[[i]]); return(x)&#8288;</code>.
</p>
</li>
<li> <p><code>modify_if()</code> only modifies the elements of <code>x</code> that satisfy a
predicate and leaves the others unchanged. <code>modify_at()</code> only
modifies elements given by names or positions.
</p>
</li>
<li> <p><code>modify2()</code> modifies the elements of <code>.x</code> but also passes the
elements of <code>.y</code> to <code>.f</code>, just like <code><a href="purrr.html#topic+map2">map2()</a></code>. <code>imodify()</code> passes
the names or the indices to <code>.f</code> like <code><a href="purrr.html#topic+imap">imap()</a></code> does.
</p>
</li>
<li> <p><code><a href="purrr.html#topic+modify_in">modify_in()</a></code> modifies a single element in a <code><a href="purrr.html#topic+pluck">pluck()</a></code> location.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>modify(.x, .f, ...)

modify_if(.x, .p, .f, ..., .else = NULL)

modify_at(.x, .at, .f, ...)

modify2(.x, .y, .f, ...)

imodify(.x, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_+3A_.x">.x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="modify_+3A_.f">.f</code></td>
<td>
<p>A function specified in the same way as the corresponding map
function.</p>
</td></tr>
<tr><td><code id="modify_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="modify_+3A_.p">.p</code></td>
<td>
<p>A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as <code>.x</code>.
Alternatively, if the elements of <code>.x</code> are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where <code>.p</code> evaluates to
<code>TRUE</code> will be modified.</p>
</td></tr>
<tr><td><code id="modify_+3A_.else">.else</code></td>
<td>
<p>A function applied to elements of <code>.x</code> for which <code>.p</code>
returns <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modify_+3A_.at">.at</code></td>
<td>
<p>A logical, integer, or character vector giving the elements
to select. Alternatively, a function that takes a vector of names,
and returns a logical, integer, or character vector of elements to select.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>: if the tidyselect package is
installed, you can use <code>vars()</code> and tidyselect helpers to select
elements.</p>
</td></tr>
<tr><td><code id="modify_+3A_.y">.y</code></td>
<td>
<p>A vector, usually the same length as <code>.x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the transformation can alter the structure of the input; it's
your responsibility to ensure that the transformation produces a
valid output. For example, if you're modifying a data frame, <code>.f</code>
must preserve the length of the input.
</p>


<h3>Value</h3>

<p>An object the same class as <code>.x</code>
</p>


<h3>Genericity</h3>

<p><code>modify()</code> and variants are generic over classes that implement
<code>length()</code>, <code>[[</code> and <code style="white-space: pre;">&#8288;[[&lt;-&#8288;</code> methods. If the default implementation
is not compatible for your class, you can override them with your
own methods.
</p>
<p>If you implement your own <code>modify()</code> method, make sure it satisfies
the following invariants:
</p>
<div class="sourceCode"><pre>modify(x, identity) === x
modify(x, compose(f, g)) === modify(x, g) |&gt; modify(f)
</pre></div>
<p>These invariants are known as the <a href="https://wiki.haskell.org/Functor#Functor_Laws">functor laws</a> in computer
science.
</p>


<h3>See Also</h3>

<p>Other map variants: 
<code><a href="purrr.html#topic+imap">imap</a>()</code>,
<code><a href="purrr.html#topic+lmap">lmap</a>()</code>,
<code><a href="purrr.html#topic+map2">map2</a>()</code>,
<code><a href="purrr.html#topic+map_depth">map_depth</a>()</code>,
<code><a href="purrr.html#topic+map_if">map_if</a>()</code>,
<code><a href="maps.html#topic+map">map</a>()</code>,
<code><a href="purrr.html#topic+pmap">pmap</a>()</code>
</p>
<p>Other modify variants: 
<code><a href="purrr.html#topic+map_depth">map_depth</a>()</code>,
<code><a href="purrr.html#topic+modify_tree">modify_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert factors to characters
iris |&gt;
  modify_if(is.factor, as.character) |&gt;
  str()

# Specify which columns to map with a numeric vector of positions:
mtcars |&gt; modify_at(c(1, 4, 5), as.character) |&gt; str()

# Or with a vector of names:
mtcars |&gt; modify_at(c("cyl", "am"), as.character) |&gt; str()

list(x = sample(c(TRUE, FALSE), 100, replace = TRUE), y = 1:100) |&gt;
  list_transpose(simplify = FALSE) |&gt;
  modify_if("x", \(l) list(x = l$x, y = l$y * 100)) |&gt;
  list_transpose()

# Use modify2() to map over two vectors and preserve the type of
# the first one:
x &lt;- c(foo = 1L, bar = 2L)
y &lt;- c(TRUE, FALSE)
modify2(x, y, \(x, cond) if (cond) x else 0L)

# Use a predicate function to decide whether to map a function:
modify_if(iris, is.factor, as.character)

# Specify an alternative with the `.else` argument:
modify_if(iris, is.factor, as.character, .else = as.integer)
</code></pre>

<hr>
<h2 id='modify_in'>Modify a pluck location</h2><span id='topic+modify_in'></span><span id='topic+assign_in'></span>

<h3>Description</h3>


<ul>
<li> <p><code>assign_in()</code> takes a data structure and a <a href="purrr.html#topic+pluck">pluck</a> location,
assigns a value there, and returns the modified data structure.
</p>
</li>
<li> <p><code>modify_in()</code> applies a function to a pluck location, assigns the
result back to that location with <code><a href="purrr.html#topic+assign_in">assign_in()</a></code>, and returns the
modified data structure.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>modify_in(.x, .where, .f, ...)

assign_in(x, where, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_in_+3A_.x">.x</code>, <code id="modify_in_+3A_x">x</code></td>
<td>
<p>A vector or environment</p>
</td></tr>
<tr><td><code id="modify_in_+3A_.where">.where</code>, <code id="modify_in_+3A_where">where</code></td>
<td>
<p>A pluck location, as a numeric vector of
positions, a character vector of names, or a list combining both.
The location must exist in the data structure.</p>
</td></tr>
<tr><td><code id="modify_in_+3A_.f">.f</code></td>
<td>
<p>A function to apply at the pluck location given by <code>.where</code>.</p>
</td></tr>
<tr><td><code id="modify_in_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>.f</code>.</p>
</td></tr>
<tr><td><code id="modify_in_+3A_value">value</code></td>
<td>
<p>A value to replace in <code>.x</code> at the pluck location.
Use <code>zap()</code> to instead remove the element.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+pluck">pluck()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Recall that pluck() returns a component of a data structure that
# might be arbitrarily deep
x &lt;- list(list(bar = 1, foo = 2))
pluck(x, 1, "foo")

# Use assign_in() to modify the pluck location:
str(assign_in(x, list(1, "foo"), 100))
# Or zap to remove it
str(assign_in(x, list(1, "foo"), zap()))

# Like pluck(), this works even when the element (or its parents) don't exist
pluck(x, 1, "baz")
str(assign_in(x, list(2, "baz"), 100))

# modify_in() applies a function to that location and update the
# element in place:
modify_in(x, list(1, "foo"), \(x) x * 200)

# Additional arguments are passed to the function in the ordinary way:
modify_in(x, list(1, "foo"), `+`, 100)
</code></pre>

<hr>
<h2 id='modify_tree'>Recursively modify a list</h2><span id='topic+modify_tree'></span>

<h3>Description</h3>

<p><code>modify_tree()</code> allows you to recursively modify a list, supplying functions
that either modify each leaf or each node (or both).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_tree(
  x,
  ...,
  leaf = identity,
  is_node = NULL,
  pre = identity,
  post = identity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_tree_+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="modify_tree_+3A_...">...</code></td>
<td>
<p>Reserved for future use. Must be empty</p>
</td></tr>
<tr><td><code id="modify_tree_+3A_leaf">leaf</code></td>
<td>
<p>A function applied to each leaf.</p>
</td></tr>
<tr><td><code id="modify_tree_+3A_is_node">is_node</code></td>
<td>
<p>A predicate function that determines whether an element is
a node (by returning <code>TRUE</code>) or a leaf (by returning <code>FALSE</code>). The
default value, <code>NULL</code>, treats simple lists as nodes and everything else
(including richer objects like data frames and linear models) as leaves,
using <code><a href="vctrs.html#topic+vec_is_list">vctrs::vec_is_list()</a></code>. To recurse into all objects built on lists
use <code><a href="base.html#topic+is.list">is.list()</a></code>.</p>
</td></tr>
<tr><td><code id="modify_tree_+3A_pre">pre</code>, <code id="modify_tree_+3A_post">post</code></td>
<td>
<p>Functions applied to each node. <code>pre</code> is applied on the
way &quot;down&quot;, i.e. before the leaves are transformed with <code>leaf</code>, while
<code>post</code> is applied on the way &quot;up&quot;, i.e. after the leaves are transformed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other modify variants: 
<code><a href="purrr.html#topic+map_depth">map_depth</a>()</code>,
<code><a href="purrr.html#topic+modify">modify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(list(a = 2:1, c = list(b1 = 2), b = list(c2 = 3, c1 = 4)))
x |&gt; str()

# Transform each leaf
x |&gt; modify_tree(leaf = \(x) x + 100) |&gt;  str()

# Recursively sort the nodes
sort_named &lt;- function(x) {
  nms &lt;- names(x)
  if (!is.null(nms)) {
    x[order(nms)]
  } else {
    x
   }
}
x |&gt; modify_tree(post = sort_named) |&gt; str()
</code></pre>

<hr>
<h2 id='negate'>Negate a predicate function so it selects what it previously rejected</h2><span id='topic+negate'></span>

<h3>Description</h3>

<p>Negating a function changes <code>TRUE</code> to <code>FALSE</code> and <code>FALSE</code> to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negate(.p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negate_+3A_.p">.p</code></td>
<td>
<p>A predicate function (i.e. a function that returns either <code>TRUE</code>
or <code>FALSE</code>) specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>is.character</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) all(x &lt; 0)&#8288;</code> or <code>function(x) all(x &lt; 0)</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ all(.x &lt; 0)</code>. You must use <code>.x</code> to refer to the first
argument). Only recommended if you require backward compatibility with
older versions of R.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A new predicate function.
</p>


<h3>Adverbs</h3>

<p>This function is called an adverb because it modifies the effect of a
function (a verb). If you'd like to include a function created an adverb
in a package, be sure to read <a href="purrr.html#topic+faq-adverbs-export">faq-adverbs-export</a>.
</p>


<h3>See Also</h3>

<p>Other adverbs: 
<code><a href="purrr.html#topic+auto_browse">auto_browse</a>()</code>,
<code><a href="igraph.html#topic+compose">compose</a>()</code>,
<code><a href="purrr.html#topic+insistently">insistently</a>()</code>,
<code><a href="purrr.html#topic+partial">partial</a>()</code>,
<code><a href="purrr.html#topic+possibly">possibly</a>()</code>,
<code><a href="purrr.html#topic+quietly">quietly</a>()</code>,
<code><a href="purrr.html#topic+safely">safely</a>()</code>,
<code><a href="purrr.html#topic+slowly">slowly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(x = 1:10, y = rbernoulli(10), z = letters)
x |&gt; keep(is.numeric) |&gt; names()
x |&gt; keep(negate(is.numeric)) |&gt; names()
# Same as
x |&gt; discard(is.numeric)
</code></pre>

<hr>
<h2 id='partial'>Partially apply a function, filling in some arguments</h2><span id='topic+partial'></span>

<h3>Description</h3>

<p>Partial function application allows you to modify a function by pre-filling
some of the arguments. It is particularly useful in conjunction with
functionals and other function operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial(
  .f,
  ...,
  .env = deprecated(),
  .lazy = deprecated(),
  .first = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_+3A_.f">.f</code></td>
<td>
<p>a function. For the output source to read well, this should be a
named function.</p>
</td></tr>
<tr><td><code id="partial_+3A_...">...</code></td>
<td>
<p>named arguments to <code>.f</code> that should be partially applied.
</p>
<p>Pass an empty <code style="white-space: pre;">&#8288;... = &#8288;</code> argument to specify the position of future
arguments relative to partialised ones. See
<code><a href="rlang.html#topic+call_modify">rlang::call_modify()</a></code> to learn more about this syntax.
</p>
<p>These dots support quasiquotation. If you unquote a value, it is
evaluated only once at function creation time.  Otherwise, it is
evaluated each time the function is called.</p>
</td></tr>
<tr><td><code id="partial_+3A_.env">.env</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The environments are
now captured via quosures.</p>
</td></tr>
<tr><td><code id="partial_+3A_.lazy">.lazy</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please unquote the
arguments that should be evaluated once at function creation time
with <code style="white-space: pre;">&#8288;!!&#8288;</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_.first">.first</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please pass an
empty argument <code style="white-space: pre;">&#8288;... = &#8288;</code> to specify the position of future
arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>partial()</code> creates a function that takes <code>...</code> arguments. Unlike
<code><a href="igraph.html#topic+compose">compose()</a></code> and other function operators like <code><a href="purrr.html#topic+negate">negate()</a></code>, it
doesn't reuse the function signature of <code>.f</code>. This is because
<code>partial()</code> explicitly supports NSE functions that use
<code>substitute()</code> on their arguments. The only way to support those is
to forward arguments through dots.
</p>
<p>Other unsupported patterns:
</p>

<ul>
<li><p> It is not possible to call <code>partial()</code> repeatedly on the same
argument to pre-fill it with a different expression.
</p>
</li>
<li><p> It is not possible to refer to other arguments in pre-filled
argument.
</p>
</li></ul>



<h3>Value</h3>

<p>A function that takes the same arguments as <code>.f</code>, but returns
a different value, as described above.
</p>


<h3>Adverbs</h3>

<p>This function is called an adverb because it modifies the effect of a
function (a verb). If you'd like to include a function created an adverb
in a package, be sure to read <a href="purrr.html#topic+faq-adverbs-export">faq-adverbs-export</a>.
</p>


<h3>See Also</h3>

<p>Other adverbs: 
<code><a href="purrr.html#topic+auto_browse">auto_browse</a>()</code>,
<code><a href="igraph.html#topic+compose">compose</a>()</code>,
<code><a href="purrr.html#topic+insistently">insistently</a>()</code>,
<code><a href="purrr.html#topic+negate">negate</a>()</code>,
<code><a href="purrr.html#topic+possibly">possibly</a>()</code>,
<code><a href="purrr.html#topic+quietly">quietly</a>()</code>,
<code><a href="purrr.html#topic+safely">safely</a>()</code>,
<code><a href="purrr.html#topic+slowly">slowly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Partial is designed to replace the use of anonymous functions for
# filling in function arguments. Instead of:
compact1 &lt;- function(x) discard(x, is.null)

# we can write:
compact2 &lt;- partial(discard, .p = is.null)

# partial() works fine with functions that do non-standard
# evaluation
my_long_variable &lt;- 1:10
plot2 &lt;- partial(plot, my_long_variable)
plot2()
plot2(runif(10), type = "l")

# Note that you currently can't partialise arguments multiple times:
my_mean &lt;- partial(mean, na.rm = TRUE)
my_mean &lt;- partial(my_mean, na.rm = FALSE)
try(my_mean(1:10))


# The evaluation of arguments normally occurs "lazily". Concretely,
# this means that arguments are repeatedly evaluated across invocations:
f &lt;- partial(runif, n = rpois(1, 5))
f
f()
f()

# You can unquote an argument to fix it to a particular value.
# Unquoted arguments are evaluated only once when the function is created:
f &lt;- partial(runif, n = !!rpois(1, 5))
f
f()
f()


# By default, partialised arguments are passed before new ones:
my_list &lt;- partial(list, 1, 2)
my_list("foo")

# Control the position of these arguments by passing an empty
# `... = ` argument:
my_list &lt;- partial(list, 1, ... = , 2)
my_list("foo")
</code></pre>

<hr>
<h2 id='pluck'>Safely get or set an element deep within a nested data structure</h2><span id='topic+pluck'></span><span id='topic+pluck+3C-'></span><span id='topic+pluck_exists'></span>

<h3>Description</h3>

<p><code>pluck()</code> implements a generalised form of <code>[[</code> that allow you to index
deeply and flexibly into data structures. It always succeeds, returning
<code>.default</code> if the index you are trying to access does not exist or is <code>NULL</code>.
</p>
<p><code style="white-space: pre;">&#8288;pluck&lt;-()&#8288;</code> is the assignment equivalent, allowing you to modify an object
deep within a nested data structure.
</p>
<p><code>pluck_exists()</code> tells you whether or not an object exists using the
same rules as pluck (i.e. a <code>NULL</code> element is equivalent to an absent
element).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pluck(.x, ..., .default = NULL)

pluck(.x, ...) &lt;- value

pluck_exists(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pluck_+3A_.x">.x</code>, <code id="pluck_+3A_x">x</code></td>
<td>
<p>A vector or environment</p>
</td></tr>
<tr><td><code id="pluck_+3A_...">...</code></td>
<td>
<p>A list of accessors for indexing into the object. Can be
an positive integer, a negative integer (to index from the right),
a string (to index into names), or an accessor function
(except for the assignment variants which only support names and
positions). If the object being indexed is an S4 object,
accessing it by name will return the corresponding slot.
</p>
<p><a href="rlang.html#topic+dyn-dots">Dynamic dots</a> are supported. In particular, if
your accessors are stored in a list, you can splice that in with
<code style="white-space: pre;">&#8288;!!!&#8288;</code>.</p>
</td></tr>
<tr><td><code id="pluck_+3A_.default">.default</code></td>
<td>
<p>Value to use if target is <code>NULL</code> or absent.</p>
</td></tr>
<tr><td><code id="pluck_+3A_value">value</code></td>
<td>
<p>A value to replace in <code>.x</code> at the pluck location.
Use <code>zap()</code> to instead remove the element.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> You can pluck or chuck with standard accessors like integer
positions and string names, and also accepts arbitrary accessor
functions, i.e. functions that take an object and return some
internal piece.
</p>
<p>This is often more readable than a mix of operators and accessors
because it reads linearly and is free of syntactic
cruft. Compare: <code>accessor(x[[1]])$foo</code> to <code>pluck(x, 1, accessor, "foo")</code>.
</p>
</li>
<li><p> These accessors never partial-match. This is unlike <code>$</code> which
will select the <code>disp</code> object if you write <code>mtcars$di</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="purrr.html#topic+attr_getter">attr_getter()</a></code> for creating attribute getters suitable
for use with <code>pluck()</code> and <code>chuck()</code>. <code><a href="purrr.html#topic+modify_in">modify_in()</a></code> for
applying a function to a pluck location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's create a list of data structures:
obj1 &lt;- list("a", list(1, elt = "foo"))
obj2 &lt;- list("b", list(2, elt = "bar"))
x &lt;- list(obj1, obj2)

# pluck() provides a way of retrieving objects from such data
# structures using a combination of numeric positions, vector or
# list names, and accessor functions.

# Numeric positions index into the list by position, just like `[[`:
pluck(x, 1)
# same as x[[1]]

# Index from the back
pluck(x, -1)
# same as x[[2]]

pluck(x, 1, 2)
# same as x[[1]][[2]]

# Supply names to index into named vectors:
pluck(x, 1, 2, "elt")
# same as x[[1]][[2]][["elt"]]

# By default, pluck() consistently returns `NULL` when an element
# does not exist:
pluck(x, 10)
try(x[[10]])

# You can also supply a default value for non-existing elements:
pluck(x, 10, .default = NA)

# The map() functions use pluck() by default to retrieve multiple
# values from a list:
map_chr(x, 1)
map_int(x, c(2, 1))

# pluck() also supports accessor functions:
my_element &lt;- function(x) x[[2]]$elt
pluck(x, 1, my_element)
pluck(x, 2, my_element)

# Even for this simple data structure, this is more readable than
# the alternative form because it requires you to read both from
# right-to-left and from left-to-right in different parts of the
# expression:
my_element(x[[1]])

# If you have a list of accessors, you can splice those in with `!!!`:
idx &lt;- list(1, my_element)
pluck(x, !!!idx)
</code></pre>

<hr>
<h2 id='pluck_depth'>Compute the depth of a vector</h2><span id='topic+pluck_depth'></span><span id='topic+vec_depth'></span>

<h3>Description</h3>

<p>The depth of a vector is how many levels that you can index/pluck into it.
<code>pluck_depth()</code> was previously called <code>vec_depth()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pluck_depth(x, is_node = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pluck_depth_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="pluck_depth_+3A_is_node">is_node</code></td>
<td>
<p>Optionally override the default criteria for determine an
element can be recursed within. The default matches the behaviour of
<code>pluck()</code> which can recurse into lists and expressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(
  list(),
  list(list()),
  list(list(list(1)))
)
pluck_depth(x)
x |&gt; map_int(pluck_depth)
</code></pre>

<hr>
<h2 id='pmap'>Map over multiple input simultaneously (in &quot;parallel&quot;)</h2><span id='topic+pmap'></span><span id='topic+pmap_lgl'></span><span id='topic+pmap_int'></span><span id='topic+pmap_dbl'></span><span id='topic+pmap_chr'></span><span id='topic+pmap_vec'></span><span id='topic+pwalk'></span>

<h3>Description</h3>

<p>These functions are variants of <code><a href="maps.html#topic+map">map()</a></code> that iterate over multiple arguments
simultaneously. They are parallel in the sense that each input is processed
in parallel with the others, not in the sense of multicore computing, i.e.
they share the same notion of &quot;parallel&quot; as <code><a href="base.html#topic+Extremes">base::pmax()</a></code> and <code><a href="base.html#topic+Extremes">base::pmin()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmap(.l, .f, ..., .progress = FALSE)

pmap_lgl(.l, .f, ..., .progress = FALSE)

pmap_int(.l, .f, ..., .progress = FALSE)

pmap_dbl(.l, .f, ..., .progress = FALSE)

pmap_chr(.l, .f, ..., .progress = FALSE)

pmap_vec(.l, .f, ..., .ptype = NULL, .progress = FALSE)

pwalk(.l, .f, ..., .progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmap_+3A_.l">.l</code></td>
<td>
<p>A list of vectors. The length of <code>.l</code> determines the number of
arguments that <code>.f</code> will be called with. Arguments will be supply by
position if unnamed, and by name if named.
</p>
<p>Vectors of length 1 will be recycled to any length; all other elements
must be have the same length.
</p>
<p>A data frame is an important special case of <code>.l</code>. It will cause <code>.f</code>
to be called once for each row.</p>
</td></tr>
<tr><td><code id="pmap_+3A_.f">.f</code></td>
<td>
<p>A function, specified in one of the following ways:
</p>

<ul>
<li><p> A named function.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x, y, z) x + y / z&#8288;</code> or
<code>function(x, y, z) x + y / z</code>
</p>
</li>
<li><p> A formula, e.g. <code>~ ..1 + ..2 / ..3</code>. This syntax is not recommended as
you can only refer to arguments by position.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pmap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="pmap_+3A_.progress">.progress</code></td>
<td>
<p>Whether to show a progress bar. Use <code>TRUE</code> to turn on
a basic progress bar, use a string to give it a name, or see
<a href="purrr.html#topic+progress_bars">progress_bars</a> for more details.</p>
</td></tr>
<tr><td><code id="pmap_+3A_.ptype">.ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is the common type
of the elements of the result. Otherwise, supply a &quot;prototype&quot; giving
the desired type of output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output length is determined by the length of the input.
The output names are determined by the input names.
The output type is determined by the suffix:
</p>

<ul>
<li><p> No suffix: a list; <code>.f()</code> can return anything.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_lgl()&#8288;</code>, <code style="white-space: pre;">&#8288;_int()&#8288;</code>, <code style="white-space: pre;">&#8288;_dbl()&#8288;</code>, <code style="white-space: pre;">&#8288;_chr()&#8288;</code> return a logical, integer, double,
or character vector respectively; <code>.f()</code> must return a compatible atomic
vector of length 1.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_vec()&#8288;</code> return an atomic or S3 vector, the same type that <code>.f</code> returns.
<code>.f</code> can return pretty much any type of vector, as long as its length 1.
</p>
</li>
<li> <p><code>walk()</code> returns the input <code>.x</code> (invisibly). This makes it easy to
use in a pipe. The return value of <code>.f()</code> is ignored.
</p>
</li></ul>

<p>Any errors thrown by <code>.f</code> will be wrapped in an error with class
<a href="purrr.html#topic+purrr_error_indexed">purrr_error_indexed</a>.
</p>


<h3>See Also</h3>

<p>Other map variants: 
<code><a href="purrr.html#topic+imap">imap</a>()</code>,
<code><a href="purrr.html#topic+lmap">lmap</a>()</code>,
<code><a href="purrr.html#topic+map2">map2</a>()</code>,
<code><a href="purrr.html#topic+map_depth">map_depth</a>()</code>,
<code><a href="purrr.html#topic+map_if">map_if</a>()</code>,
<code><a href="maps.html#topic+map">map</a>()</code>,
<code><a href="purrr.html#topic+modify">modify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(1, 1, 1)
y &lt;- list(10, 20, 30)
z &lt;- list(100, 200, 300)
pmap(list(x, y, z), sum)

# Matching arguments by position
pmap(list(x, y, z), function(first, second, third) (first + third) * second)

# Matching arguments by name
l &lt;- list(a = x, b = y, c = z)
pmap(l, function(c, b, a) (a + c) * b)

# Vectorizing a function over multiple arguments
df &lt;- data.frame(
  x = c("apple", "banana", "cherry"),
  pattern = c("p", "n", "h"),
  replacement = c("P", "N", "H"),
  stringsAsFactors = FALSE
  )
pmap(df, gsub)
pmap_chr(df, gsub)

# Use `...` to absorb unused components of input list .l
df &lt;- data.frame(
  x = 1:3,
  y = 10:12,
  z = letters[1:3]
)
plus &lt;- function(x, y) x + y
## Not run: 
# this won't work
pmap(df, plus)

## End(Not run)
# but this will
plus2 &lt;- function(x, y, ...) x + y
pmap_dbl(df, plus2)

# The "p" for "parallel" in pmap() is the same as in base::pmin()
# and base::pmax()
df &lt;- data.frame(
  x = c(1, 2, 5),
  y = c(5, 4, 8)
)
# all produce the same result
pmin(df$x, df$y)
map2_dbl(df$x, df$y, min)
pmap_dbl(df, min)
</code></pre>

<hr>
<h2 id='possibly'>Wrap a function to return a value instead of an error</h2><span id='topic+possibly'></span>

<h3>Description</h3>

<p>Create a modified version of <code>.f</code> that return a default value (<code>otherwise</code>)
whenever an error occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possibly(.f, otherwise = NULL, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="possibly_+3A_.f">.f</code></td>
<td>
<p>A function to modify, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. Only recommended if you require backward
compatibility with older versions of R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="possibly_+3A_otherwise">otherwise</code></td>
<td>
<p>Default value to use when an error occurs.</p>
</td></tr>
<tr><td><code id="possibly_+3A_quiet">quiet</code></td>
<td>
<p>Hide errors (<code>TRUE</code>, the default), or display them
as they occur?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes the same arguments as <code>.f</code>, but returns
a different value, as described above.
</p>


<h3>Adverbs</h3>

<p>This function is called an adverb because it modifies the effect of a
function (a verb). If you'd like to include a function created an adverb
in a package, be sure to read <a href="purrr.html#topic+faq-adverbs-export">faq-adverbs-export</a>.
</p>


<h3>See Also</h3>

<p>Other adverbs: 
<code><a href="purrr.html#topic+auto_browse">auto_browse</a>()</code>,
<code><a href="igraph.html#topic+compose">compose</a>()</code>,
<code><a href="purrr.html#topic+insistently">insistently</a>()</code>,
<code><a href="purrr.html#topic+negate">negate</a>()</code>,
<code><a href="purrr.html#topic+partial">partial</a>()</code>,
<code><a href="purrr.html#topic+quietly">quietly</a>()</code>,
<code><a href="purrr.html#topic+safely">safely</a>()</code>,
<code><a href="purrr.html#topic+slowly">slowly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To replace errors with a default value, use possibly().
list("a", 10, 100) |&gt;
  map_dbl(possibly(log, NA_real_))

# The default, NULL, will be discarded with `list_c()`
list("a", 10, 100) |&gt;
  map(possibly(log)) |&gt;
  list_c()
</code></pre>

<hr>
<h2 id='prepend'>Prepend a vector</h2><span id='topic+prepend'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated in purrr 1.0.0 because it's not related to the
core purpose of purrr.
</p>
<p>This is a companion to <code><a href="base.html#topic+append">append()</a></code> to help merging two
lists or atomic vectors. <code>prepend()</code> is a clearer semantic
signal than <code>c()</code> that a vector is to be merged at the beginning of
another, especially in a pipe chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepend(x, values, before = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepend_+3A_x">x</code></td>
<td>
<p>the vector to be modified.</p>
</td></tr>
<tr><td><code id="prepend_+3A_values">values</code></td>
<td>
<p>to be included in the modified vector.</p>
</td></tr>
<tr><td><code id="prepend_+3A_before">before</code></td>
<td>
<p>a subscript, before which the values are to be appended. If
<code>NULL</code>, values will be appended at the beginning even for <code>x</code> of length 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A merged vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.list(1:3)

x |&gt; append("a")
x |&gt; prepend("a")
x |&gt; prepend(list("a", "b"), before = 3)
prepend(list(), x)
</code></pre>

<hr>
<h2 id='progress_bars'>Progress bars in purrr</h2><span id='topic+progress_bars'></span>

<h3>Description</h3>

<p>purrr's map functions have a <code>.progress</code> argument that you can use to
create a progress bar. <code>.progress</code> can be:
</p>

<ul>
<li> <p><code>FALSE</code>, the default: does not create a progress bar.
</p>
</li>
<li> <p><code>TRUE</code>: creates a basic unnamed progress bar.
</p>
</li>
<li><p> A string: creates a basic progress bar with the given name.
</p>
</li>
<li><p> A named list of progress bar parameters, as described below.
</p>
</li></ul>

<p>It's good practice to name your progress bars, to make it clear what
calculation or process they belong to. We recommend keeping the names
under 20 characters, so the whole progress bar fits comfortably even on
on narrower displays.
</p>


<h4>Progress bar parameters</h4>


<ul>
<li> <p><code>clear</code>: whether to remove the progress bar from the screen after
termination. Defaults to <code>TRUE</code>.
</p>
</li>
<li> <p><code>format</code>: format string. This overrides the default format string of
the progress bar type. It must be given for the <code>custom</code> type.
Format strings may contain R expressions to evaluate in braces.
They support cli <a href="cli.html#topic+pluralization">pluralization</a>, and
<a href="cli.html#topic+inline-markup">styling</a> and they can contain special
<a href="cli.html#topic+progress-variables">progress variables</a>.
</p>
</li>
<li> <p><code>format_done</code>: format string for successful termination. By default
the same as <code>format</code>.
</p>
</li>
<li> <p><code>format_failed</code>: format string for unsuccessful termination.
By default the same as <code>format</code>.
</p>
</li>
<li> <p><code>name</code>: progress bar name. This is by default the empty string and it
is displayed at the beginning of the progress bar.
</p>
</li>
<li> <p><code>show_after</code>: numeric scalar. Only show the progress bar after this
number of seconds. It overrides the <code>cli.progress_show_after</code>
global option.
</p>
</li>
<li> <p><code>type</code>: progress bar type. Currently supported types are:
</p>

<ul>
<li> <p><code>iterator</code>: the default, a for loop or a mapping function,
</p>
</li>
<li> <p><code>tasks</code>: a (typically small) number of tasks,
</p>
</li>
<li> <p><code>download</code>: download of one file,
</p>
</li>
<li> <p><code>custom</code>: custom type, <code>format</code> must not be <code>NULL</code> for this type.
The default display is different for each progress bar type.
</p>
</li></ul>

</li></ul>




<h4>Further documentation</h4>

<p>purrr's progress bars are powered by cli, so see
<a href="https://cli.r-lib.org/articles/progress.html">Introduction to progress bars in cli</a>
and <a href="https://cli.r-lib.org/articles/progress-advanced.html">Advanced cli progress bars</a>
for more details.
</p>


<hr>
<h2 id='purrr_error_indexed'>Indexed errors (<code>purrr_error_indexed</code>)</h2><span id='topic+purrr_error_indexed'></span>

<h3>Description</h3>

<p>The <code>purrr_error_indexed</code> class is thrown by <code><a href="maps.html#topic+map">map()</a></code>, <code><a href="purrr.html#topic+map2">map2()</a></code>, <code><a href="purrr.html#topic+pmap">pmap()</a></code>, and friends.
It wraps errors thrown during the processing on individual elements with information about the location of the error.
</p>


<h3>Structure</h3>

<p><code>purrr_error_indexed</code> has three important fields:
</p>

<ul>
<li> <p><code>location</code>: the location of the error as a single integer.
</p>
</li>
<li> <p><code>name</code>: the name of the location as a string. If the element was not named, <code>name</code> will be <code>NULL</code>
</p>
</li>
<li> <p><code>parent</code>: the original error thrown by <code>.f</code>.
</p>
</li></ul>

<p>Let's see this in action by capturing the generated condition from a very simple example:
</p>
<div class="sourceCode r"><pre>f &lt;- function(x) {
  rlang::abort("This is an error")
} 

cnd &lt;- rlang::catch_cnd(map(c(1, 4, 2), f))
class(cnd)
#&gt; [1] "purrr_error_indexed" "rlang_error"         "error"              
#&gt; [4] "condition"

cnd$location
#&gt; [1] 1

cnd$name
#&gt; NULL

print(cnd$parent, backtrace = FALSE)
#&gt; &lt;error/rlang_error&gt;
#&gt; Error in `.f()`:
#&gt; ! This is an error
</pre></div>
<p>If the input vector is named, <code>name</code> will be non-<code>NULL</code>:
</p>
<div class="sourceCode r"><pre>cnd &lt;- rlang::catch_cnd(map(c(a = 1, b = 4, c = 2), f))
cnd$name
#&gt; [1] "a"
</pre></div>


<h3>Handling errors</h3>

<p>(This section assumes that you're familiar with the basics of error handling in R, as described in <a href="https://adv-r.hadley.nz/conditions.html">Advanced R</a>.)
</p>
<p>This error chaining is really useful when doing interactive data analysis, but it adds some extra complexity when handling errors with <code>tryCatch()</code> or <code>withCallingHandlers()</code>.
Let's see what happens by adding a custom class to the error thrown by <code>f()</code>:
</p>
<div class="sourceCode r"><pre>f &lt;- function(x) {
  rlang::abort("This is an error", class = "my_error")
} 
map(c(1, 4, 2, 5, 3), f)
#&gt; Error in `map()`:
#&gt; i In index: 1.
#&gt; Caused by error in `.f()`:
#&gt; ! This is an error
</pre></div>
<p>This doesn't change the visual display, but you might be surprised if you try to catch this error with <code>tryCatch()</code> or <code>withCallingHandlers()</code>:
</p>
<div class="sourceCode r"><pre>tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  my_error = function(err) {
    # use NULL value if error
    NULL
  }
)
#&gt; Error in `map()`:
#&gt; i In index: 1.
#&gt; Caused by error in `.f()`:
#&gt; ! This is an error

withCallingHandlers(
  map(c(1, 4, 2, 5, 3), f),
  my_error = function(err) {
    # throw a more informative error
    abort("Wrapped error", parent = err)
  }
)
#&gt; Error in `map()`:
#&gt; i In index: 1.
#&gt; Caused by error in `.f()`:
#&gt; ! This is an error
</pre></div>
<p>That's because, as described above, the error that <code>map()</code> throws will always have class <code>purrr_error_indexed</code>:
</p>
<div class="sourceCode r"><pre>tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    print("Hello! I am now called :)")
  }
)
#&gt; [1] "Hello! I am now called :)"
</pre></div>
<p>In order to handle the error thrown by <code>f()</code>, you'll need to use <code>rlang::cnd_inherits()</code> on the parent error:
</p>
<div class="sourceCode r"><pre>tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    if (rlang::cnd_inherits(err, "my_error")) {
      NULL
    } else {
      rlang::cnd_signal(err)
    }
  }
)
#&gt; NULL

withCallingHandlers(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    if (rlang::cnd_inherits(err, "my_error")) {
      abort("Wrapped error", parent = err)
    }
  }
)
#&gt; Error:
#&gt; ! Wrapped error
#&gt; Caused by error in `map()`:
#&gt; i In index: 1.
#&gt; Caused by error in `.f()`:
#&gt; ! This is an error
</pre></div>
<p>(The <code>tryCatch()</code> approach is suboptimal because we're no longer just handling errors, but also rethrowing them.
The rethrown errors won't work correctly with (e.g.) <code>recover()</code> and <code>traceback()</code>, but we don't currently have a better approach.
In the future we expect to <a href="https://github.com/r-lib/rlang/issues/1534">enhance <code>try_fetch()</code></a> to make this easier to do 100% correctly).
</p>
<p>Finally, if you just want to get rid of purrr's wrapper error, you can resignal the parent error:
</p>
<div class="sourceCode r"><pre>withCallingHandlers(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    rlang::cnd_signal(err$parent)
  }
)
#&gt; Error in `.f()`:
#&gt; ! This is an error
</pre></div>
<p>Because we are resignalling an error, it's important to use <code>withCallingHandlers()</code> and not <code>tryCatch()</code> in order to preserve the full backtrace context.
That way <code>recover()</code>, <code>traceback()</code>, and related tools will continue to work correctly.
</p>

<hr>
<h2 id='purrr-package'>purrr: Functional Programming Tools</h2><span id='topic+purrr'></span><span id='topic+purrr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A complete and consistent functional programming toolkit for R.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@rstudio.com">hadley@rstudio.com</a> (<a href="https://orcid.org/0000-0003-4757-117X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Lionel Henry <a href="mailto:lionel@rstudio.com">lionel@rstudio.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> RStudio [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://purrr.tidyverse.org/">https://purrr.tidyverse.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/purrr">https://github.com/tidyverse/purrr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/purrr/issues">https://github.com/tidyverse/purrr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='quietly'>Wrap a function to capture side-effects</h2><span id='topic+quietly'></span>

<h3>Description</h3>

<p>Create a modified version of <code>.f</code> that captures side-effects along with
the return value of the function and returns a list containing
the <code>result</code>, <code>output</code>, <code>messages</code> and <code>warnings</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quietly(.f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quietly_+3A_.f">.f</code></td>
<td>
<p>A function to modify, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. Only recommended if you require backward
compatibility with older versions of R.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes the same arguments as <code>.f</code>, but returns
a different value, as described above.
</p>


<h3>Adverbs</h3>

<p>This function is called an adverb because it modifies the effect of a
function (a verb). If you'd like to include a function created an adverb
in a package, be sure to read <a href="purrr.html#topic+faq-adverbs-export">faq-adverbs-export</a>.
</p>


<h3>See Also</h3>

<p>Other adverbs: 
<code><a href="purrr.html#topic+auto_browse">auto_browse</a>()</code>,
<code><a href="igraph.html#topic+compose">compose</a>()</code>,
<code><a href="purrr.html#topic+insistently">insistently</a>()</code>,
<code><a href="purrr.html#topic+negate">negate</a>()</code>,
<code><a href="purrr.html#topic+partial">partial</a>()</code>,
<code><a href="purrr.html#topic+possibly">possibly</a>()</code>,
<code><a href="purrr.html#topic+safely">safely</a>()</code>,
<code><a href="purrr.html#topic+slowly">slowly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function() {
  print("Hi!")
  message("Hello")
  warning("How are ya?")
  "Gidday"
}
f()

f_quiet &lt;- quietly(f)
str(f_quiet())
</code></pre>

<hr>
<h2 id='rate_sleep'>Wait for a given time</h2><span id='topic+rate_sleep'></span><span id='topic+rate_reset'></span>

<h3>Description</h3>

<p>If the rate's internal counter exceeds the maximum number of times
it is allowed to sleep, <code>rate_sleep()</code> throws an error of class
<code>purrr_error_rate_excess</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_sleep(rate, quiet = TRUE)

rate_reset(rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rate_sleep_+3A_rate">rate</code></td>
<td>
<p>A <a href="purrr.html#topic+rate_backoff">rate</a> object determining the waiting time.</p>
</td></tr>
<tr><td><code id="rate_sleep_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, prints a message displaying how long until
the next request.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Call <code>rate_reset()</code> to reset the internal rate counter to 0.
</p>


<h3>See Also</h3>

<p><code><a href="purrr.html#topic+rate_backoff">rate_backoff()</a></code>, <code><a href="purrr.html#topic+insistently">insistently()</a></code>
</p>

<hr>
<h2 id='rate-helpers'>Create delaying rate settings</h2><span id='topic+rate-helpers'></span><span id='topic+rate_delay'></span><span id='topic+rate_backoff'></span><span id='topic+is_rate'></span>

<h3>Description</h3>

<p>These helpers create rate settings that you can pass to <code><a href="purrr.html#topic+insistently">insistently()</a></code> and
<code><a href="purrr.html#topic+slowly">slowly()</a></code>. You can also use them in your own functions with <code><a href="purrr.html#topic+rate_sleep">rate_sleep()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_delay(pause = 1, max_times = Inf)

rate_backoff(
  pause_base = 1,
  pause_cap = 60,
  pause_min = 1,
  max_times = 3,
  jitter = TRUE
)

is_rate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rate-helpers_+3A_pause">pause</code></td>
<td>
<p>Delay between attempts in seconds.</p>
</td></tr>
<tr><td><code id="rate-helpers_+3A_max_times">max_times</code></td>
<td>
<p>Maximum number of requests to attempt.</p>
</td></tr>
<tr><td><code id="rate-helpers_+3A_pause_base">pause_base</code>, <code id="rate-helpers_+3A_pause_cap">pause_cap</code></td>
<td>
<p><code>rate_backoff()</code> uses an exponential
back-off so that each request waits <code>pause_base * 2^i</code> seconds,
up to a maximum of <code>pause_cap</code> seconds.</p>
</td></tr>
<tr><td><code id="rate-helpers_+3A_pause_min">pause_min</code></td>
<td>
<p>Minimum time to wait in the backoff; generally
only necessary if you need pauses less than one second (which may
not be kind to the server, use with caution!).</p>
</td></tr>
<tr><td><code id="rate-helpers_+3A_jitter">jitter</code></td>
<td>
<p>Whether to introduce a random jitter in the waiting time.</p>
</td></tr>
<tr><td><code id="rate-helpers_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A delay rate waits the same amount of time:
rate &lt;- rate_delay(0.02)
for (i in 1:3) rate_sleep(rate, quiet = FALSE)

# A backoff rate waits exponentially longer each time, with random
# jitter by default:
rate &lt;- rate_backoff(pause_base = 0.2, pause_min = 0.005)
for (i in 1:3) rate_sleep(rate, quiet = FALSE)
</code></pre>

<hr>
<h2 id='rbernoulli'>Generate random sample from a Bernoulli distribution</h2><span id='topic+rbernoulli'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated in purrr 1.0.0 because it's not related to the
core purpose of purrr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbernoulli(n, p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbernoulli_+3A_n">n</code></td>
<td>
<p>Number of samples</p>
</td></tr>
<tr><td><code id="rbernoulli_+3A_p">p</code></td>
<td>
<p>Probability of getting <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rbernoulli(10)
rbernoulli(100, 0.1)
</code></pre>

<hr>
<h2 id='rdunif'>Generate random sample from a discrete uniform distribution</h2><span id='topic+rdunif'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated in purrr 1.0.0 because it's not related to the
core purpose of purrr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdunif(n, b, a = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdunif_+3A_n">n</code></td>
<td>
<p>Number of samples to draw.</p>
</td></tr>
<tr><td><code id="rdunif_+3A_a">a</code>, <code id="rdunif_+3A_b">b</code></td>
<td>
<p>Range of the distribution (inclusive).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>table(rdunif(1e3, 10))
table(rdunif(1e3, 10, -5))
</code></pre>

<hr>
<h2 id='reduce'>Reduce a list to a single value by iteratively applying a binary function</h2><span id='topic+reduce'></span><span id='topic+reduce2'></span>

<h3>Description</h3>

<p><code>reduce()</code> is an operation that combines the elements of a vector
into a single value. The combination is driven by <code>.f</code>, a binary
function that takes two values and returns a single value: reducing
<code>f</code> over <code>1:3</code> computes the value <code>f(f(1, 2), 3)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce(.x, .f, ..., .init, .dir = c("forward", "backward"))

reduce2(.x, .y, .f, ..., .init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="reduce_+3A_.f">.f</code></td>
<td>
<p>For <code>reduce()</code>, a 2-argument function. The function will be passed
the accumulated value as the first argument and the &quot;next&quot; value as the
second argument.
</p>
<p>For <code>reduce2()</code>, a 3-argument function. The function will be passed the
accumulated value as the first argument, the next value of <code>.x</code> as the
second argument, and the next value of <code>.y</code> as the third argument.
</p>
<p>The reduction terminates early if <code>.f</code> returns a value wrapped in
a <code><a href="purrr.html#topic+done">done()</a></code>.</p>
</td></tr>
<tr><td><code id="reduce_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="reduce_+3A_.init">.init</code></td>
<td>
<p>If supplied, will be used as the first value to start
the accumulation, rather than using <code>.x[[1]]</code>. This is useful if
you want to ensure that <code>reduce</code> returns a correct value when <code>.x</code>
is empty. If missing, and <code>.x</code> is empty, will throw an error.</p>
</td></tr>
<tr><td><code id="reduce_+3A_.dir">.dir</code></td>
<td>
<p>The direction of reduction as a string, one of
<code>"forward"</code> (the default) or <code>"backward"</code>. See the section about
direction below.</p>
</td></tr>
<tr><td><code id="reduce_+3A_.y">.y</code></td>
<td>
<p>For <code>reduce2()</code> and <code>accumulate2()</code>, an additional
argument that is passed to <code>.f</code>. If <code>init</code> is not set, <code>.y</code>
should be 1 element shorter than <code>.x</code>.</p>
</td></tr>
</table>


<h3>Direction</h3>

<p>When <code>.f</code> is an associative operation like <code>+</code> or <code>c()</code>, the
direction of reduction does not matter. For instance, reducing the
vector <code>1:3</code> with the binary function <code>+</code> computes the sum <code>((1 + 2) + 3)</code> from the left, and the same sum <code>(1 + (2 + 3))</code> from the
right.
</p>
<p>In other cases, the direction has important consequences on the
reduced value. For instance, reducing a vector with <code>list()</code> from
the left produces a left-leaning nested list (or tree), while
reducing <code>list()</code> from the right produces a right-leaning list.
</p>


<h3>Life cycle</h3>

<p><code>reduce_right()</code> is soft-deprecated as of purrr 0.3.0. Please use
the <code>.dir</code> argument of <code>reduce()</code> instead. Note that the algorithm
has changed. Whereas <code>reduce_right()</code> computed <code>f(f(3, 2), 1)</code>,
<code style="white-space: pre;">&#8288;reduce(.dir = \"backward\")&#8288;</code> computes <code>f(1, f(2, 3))</code>. This is the
standard way of reducing from the right.
</p>
<p>To update your code with the same reduction as <code>reduce_right()</code>,
simply reverse your vector and use a left reduction:
</p>
<div class="sourceCode r"><pre># Before:
reduce_right(1:3, f)

# After:
reduce(rev(1:3), f)
</pre></div>
<p><code>reduce2_right()</code> is soft-deprecated as of purrr 0.3.0 without
replacement. It is not clear what algorithmic properties should a
right reduction have in this case. Please reach out if you know
about a use case for a right reduction with a ternary function.
</p>


<h3>See Also</h3>

<p><code><a href="foreach.html#topic+accumulate">accumulate()</a></code> for a version that returns all intermediate
values of the reduction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reducing `+` computes the sum of a vector while reducing `*`
# computes the product:
1:3 |&gt; reduce(`+`)
1:10 |&gt; reduce(`*`)

# By ignoring the input vector (nxt), you can turn output of one step into
# the input for the next. This code takes 10 steps of a random walk:
reduce(1:10, \(acc, nxt) acc + rnorm(1), .init = 0)

# When the operation is associative, the direction of reduction
# does not matter:
reduce(1:4, `+`)
reduce(1:4, `+`, .dir = "backward")

# However with non-associative operations, the reduced value will
# be different as a function of the direction. For instance,
# `list()` will create left-leaning lists when reducing from the
# right, and right-leaning lists otherwise:
str(reduce(1:4, list))
str(reduce(1:4, list, .dir = "backward"))

# reduce2() takes a ternary function and a second vector that is
# one element smaller than the first vector:
paste2 &lt;- function(x, y, sep = ".") paste(x, y, sep = sep)
letters[1:4] |&gt; reduce(paste2)
letters[1:4] |&gt; reduce2(c("-", ".", "-"), paste2)

x &lt;- list(c(0, 1), c(2, 3), c(4, 5))
y &lt;- list(c(6, 7), c(8, 9))
reduce2(x, y, paste)


# You can shortcircuit a reduction and terminate it early by
# returning a value wrapped in a done(). In the following example
# we return early if the result-so-far, which is passed on the LHS,
# meets a condition:
paste3 &lt;- function(out, input, sep = ".") {
  if (nchar(out) &gt; 4) {
    return(done(out))
  }
  paste(out, input, sep = sep)
}
letters |&gt; reduce(paste3)

# Here the early return branch checks the incoming inputs passed on
# the RHS:
paste4 &lt;- function(out, input, sep = ".") {
  if (input == "j") {
    return(done(out))
  }
  paste(out, input, sep = sep)
}
letters |&gt; reduce(paste4)
</code></pre>

<hr>
<h2 id='reduce_right'>Reduce from the right (retired)</h2><span id='topic+reduce_right'></span><span id='topic+reduce2_right'></span><span id='topic+accumulate_right'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions were deprecated in purrr 0.3.0. Please use the
<code>.dir</code> argument of <code><a href="purrr.html#topic+reduce">reduce()</a></code> instead, or reverse your vectors
and use a left reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_right(.x, .f, ..., .init)

reduce2_right(.x, .y, .f, ..., .init)

accumulate_right(.x, .f, ..., .init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_right_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="reduce_right_+3A_.f">.f</code></td>
<td>
<p>For <code>reduce()</code>, a 2-argument function. The function will be passed
the accumulated value as the first argument and the &quot;next&quot; value as the
second argument.
</p>
<p>For <code>reduce2()</code>, a 3-argument function. The function will be passed the
accumulated value as the first argument, the next value of <code>.x</code> as the
second argument, and the next value of <code>.y</code> as the third argument.
</p>
<p>The reduction terminates early if <code>.f</code> returns a value wrapped in
a <code><a href="purrr.html#topic+done">done()</a></code>.</p>
</td></tr>
<tr><td><code id="reduce_right_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.
</p>
<p>We now generally recommend against using <code>...</code> to pass additional
(constant) arguments to <code>.f</code>. Instead use a shorthand anonymous function:
</p>
<div class="sourceCode R"><pre># Instead of
x |&gt; map(f, 1, 2, collapse = ",")
# do:
x |&gt; map(\(x) f(x, 1, 2, collapse = ","))
</pre></div>
<p>This makes it easier to understand which arguments belong to which
function and will tend to yield better error messages.</p>
</td></tr>
<tr><td><code id="reduce_right_+3A_.init">.init</code></td>
<td>
<p>If supplied, will be used as the first value to start
the accumulation, rather than using <code>.x[[1]]</code>. This is useful if
you want to ensure that <code>reduce</code> returns a correct value when <code>.x</code>
is empty. If missing, and <code>.x</code> is empty, will throw an error.</p>
</td></tr>
<tr><td><code id="reduce_right_+3A_.y">.y</code></td>
<td>
<p>For <code>reduce2()</code> and <code>accumulate2()</code>, an additional
argument that is passed to <code>.f</code>. If <code>init</code> is not set, <code>.y</code>
should be 1 element shorter than <code>.x</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+set_names'></span><span id='topic+exec'></span><span id='topic+zap'></span><span id='topic++25+7C+7C+25'></span><span id='topic+done'></span><span id='topic+rep_along'></span><span id='topic+is_bare_list'></span><span id='topic+is_bare_atomic'></span><span id='topic+is_bare_vector'></span><span id='topic+is_bare_double'></span><span id='topic+is_bare_integer'></span><span id='topic+is_bare_numeric'></span><span id='topic+is_bare_character'></span><span id='topic+is_bare_logical'></span><span id='topic+is_list'></span><span id='topic+is_atomic'></span><span id='topic+is_vector'></span><span id='topic+is_integer'></span><span id='topic+is_double'></span><span id='topic+is_character'></span><span id='topic+is_logical'></span><span id='topic+is_null'></span><span id='topic+is_function'></span><span id='topic+is_scalar_list'></span><span id='topic+is_scalar_atomic'></span><span id='topic+is_scalar_vector'></span><span id='topic+is_scalar_double'></span><span id='topic+is_scalar_character'></span><span id='topic+is_scalar_logical'></span><span id='topic+is_scalar_integer'></span><span id='topic+is_empty'></span><span id='topic+is_formula'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>rlang</dt><dd><p><code><a href="rlang.html#topic+op-null-default">%||%</a></code>, <code><a href="rlang.html#topic+done">done</a></code>, <code><a href="rlang.html#topic+exec">exec</a></code>, <code><a href="rlang.html#topic+type-predicates">is_atomic</a></code>, <code><a href="rlang.html#topic+bare-type-predicates">is_bare_atomic</a></code>, <code><a href="rlang.html#topic+bare-type-predicates">is_bare_character</a></code>, <code><a href="rlang.html#topic+bare-type-predicates">is_bare_double</a></code>, <code><a href="rlang.html#topic+bare-type-predicates">is_bare_integer</a></code>, <code><a href="rlang.html#topic+bare-type-predicates">is_bare_list</a></code>, <code><a href="rlang.html#topic+bare-type-predicates">is_bare_logical</a></code>, <code><a href="rlang.html#topic+bare-type-predicates">is_bare_numeric</a></code>, <code><a href="rlang.html#topic+bare-type-predicates">is_bare_vector</a></code>, <code><a href="rlang.html#topic+type-predicates">is_character</a></code>, <code><a href="rlang.html#topic+type-predicates">is_double</a></code>, <code><a href="rlang.html#topic+is_empty">is_empty</a></code>, <code><a href="rlang.html#topic+is_formula">is_formula</a></code>, <code><a href="rlang.html#topic+is_function">is_function</a></code>, <code><a href="rlang.html#topic+type-predicates">is_integer</a></code>, <code><a href="rlang.html#topic+type-predicates">is_list</a></code>, <code><a href="rlang.html#topic+type-predicates">is_logical</a></code>, <code><a href="rlang.html#topic+type-predicates">is_null</a></code>, <code><a href="rlang.html#topic+scalar-type-predicates">is_scalar_atomic</a></code>, <code><a href="rlang.html#topic+scalar-type-predicates">is_scalar_character</a></code>, <code><a href="rlang.html#topic+scalar-type-predicates">is_scalar_double</a></code>, <code><a href="rlang.html#topic+scalar-type-predicates">is_scalar_integer</a></code>, <code><a href="rlang.html#topic+scalar-type-predicates">is_scalar_list</a></code>, <code><a href="rlang.html#topic+scalar-type-predicates">is_scalar_logical</a></code>, <code><a href="rlang.html#topic+scalar-type-predicates">is_scalar_vector</a></code>, <code><a href="rlang.html#topic+type-predicates">is_vector</a></code>, <code><a href="rlang.html#topic+rep_along">rep_along</a></code>, <code><a href="rlang.html#topic+set_names">set_names</a></code>, <code><a href="rlang.html#topic+zap">zap</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rerun'>Re-run expressions multiple times</h2><span id='topic+rerun'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated in purrr 1.0.0 because we believe that NSE
functions are not a  good fit for purrr. Also, <code>rerun(n, x)</code> can just as
easily be expressed as <code style="white-space: pre;">&#8288;map(1:n, \(i) x)&#8288;</code>
</p>
<p><code>rerun()</code> is a convenient way of generating sample data. It works similarly to
<code><a href="base.html#topic+replicate">replicate</a>(..., simplify = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rerun(.n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rerun_+3A_.n">.n</code></td>
<td>
<p>Number of times to run expressions</p>
</td></tr>
<tr><td><code id="rerun_+3A_...">...</code></td>
<td>
<p>Expressions to re-run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>.n</code>. Each element of <code>...</code> will be
re-run once for each <code>.n</code>.
</p>
<p>There is one special case: if there's a single unnamed input, the second
level list will be dropped. In this case, <code>rerun(n, x)</code> behaves like
<code>replicate(n, x, simplify = FALSE)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># old
5 |&gt; rerun(rnorm(5)) |&gt; str()
# new
1:5 |&gt; map(\(i) rnorm(5)) |&gt; str()

# old
5 |&gt;
  rerun(x = rnorm(5), y = rnorm(5)) |&gt;
  map_dbl(\(l) cor(l$x, l$y))
# new
1:5 |&gt;
  map(\(i) list(x = rnorm(5), y = rnorm(5))) |&gt;
  map_dbl(\(l) cor(l$x, l$y))
</code></pre>

<hr>
<h2 id='safely'>Wrap a function to capture errors</h2><span id='topic+safely'></span>

<h3>Description</h3>

<p>Creates a modified version of <code>.f</code> that always succeeds. It returns a list
with components <code>result</code> and <code>error</code>. If the function succeeds, <code>result</code>
contains the returned value and <code>error</code> is <code>NULL</code>. If an error occurred,
<code>error</code> is an <code>error</code> object and <code>result</code> is either <code>NULL</code> or <code>otherwise</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safely(.f, otherwise = NULL, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="safely_+3A_.f">.f</code></td>
<td>
<p>A function to modify, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. Only recommended if you require backward
compatibility with older versions of R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="safely_+3A_otherwise">otherwise</code></td>
<td>
<p>Default value to use when an error occurs.</p>
</td></tr>
<tr><td><code id="safely_+3A_quiet">quiet</code></td>
<td>
<p>Hide errors (<code>TRUE</code>, the default), or display them
as they occur?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes the same arguments as <code>.f</code>, but returns
a different value, as described above.
</p>


<h3>Adverbs</h3>

<p>This function is called an adverb because it modifies the effect of a
function (a verb). If you'd like to include a function created an adverb
in a package, be sure to read <a href="purrr.html#topic+faq-adverbs-export">faq-adverbs-export</a>.
</p>


<h3>See Also</h3>

<p>Other adverbs: 
<code><a href="purrr.html#topic+auto_browse">auto_browse</a>()</code>,
<code><a href="igraph.html#topic+compose">compose</a>()</code>,
<code><a href="purrr.html#topic+insistently">insistently</a>()</code>,
<code><a href="purrr.html#topic+negate">negate</a>()</code>,
<code><a href="purrr.html#topic+partial">partial</a>()</code>,
<code><a href="purrr.html#topic+possibly">possibly</a>()</code>,
<code><a href="purrr.html#topic+quietly">quietly</a>()</code>,
<code><a href="purrr.html#topic+slowly">slowly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>safe_log &lt;- safely(log)
safe_log(10)
safe_log("a")

list("a", 10, 100) |&gt;
  map(safe_log) |&gt;
  transpose()

# This is a bit easier to work with if you supply a default value
# of the same type and use the simplify argument to transpose():
safe_log &lt;- safely(log, otherwise = NA_real_)
list("a", 10, 100) |&gt;
  map(safe_log) |&gt;
  transpose() |&gt;
  simplify_all()
</code></pre>

<hr>
<h2 id='slowly'>Wrap a function to wait between executions</h2><span id='topic+slowly'></span>

<h3>Description</h3>

<p><code>slowly()</code> takes a function and modifies it to wait a given
amount of time between each call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slowly(f, rate = rate_delay(), quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slowly_+3A_f">f</code></td>
<td>
<p>A function to modify, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. Only recommended if you require backward
compatibility with older versions of R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slowly_+3A_rate">rate</code></td>
<td>
<p>A <a href="purrr.html#topic+rate-helpers">rate</a> object. Defaults to a constant delay.</p>
</td></tr>
<tr><td><code id="slowly_+3A_quiet">quiet</code></td>
<td>
<p>Hide errors (<code>TRUE</code>, the default), or display them
as they occur?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes the same arguments as <code>.f</code>, but returns
a different value, as described above.
</p>


<h3>Adverbs</h3>

<p>This function is called an adverb because it modifies the effect of a
function (a verb). If you'd like to include a function created an adverb
in a package, be sure to read <a href="purrr.html#topic+faq-adverbs-export">faq-adverbs-export</a>.
</p>


<h3>See Also</h3>

<p>Other adverbs: 
<code><a href="purrr.html#topic+auto_browse">auto_browse</a>()</code>,
<code><a href="igraph.html#topic+compose">compose</a>()</code>,
<code><a href="purrr.html#topic+insistently">insistently</a>()</code>,
<code><a href="purrr.html#topic+negate">negate</a>()</code>,
<code><a href="purrr.html#topic+partial">partial</a>()</code>,
<code><a href="purrr.html#topic+possibly">possibly</a>()</code>,
<code><a href="purrr.html#topic+quietly">quietly</a>()</code>,
<code><a href="purrr.html#topic+safely">safely</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For these example, we first create a custom rate
# with a low waiting time between attempts:
rate &lt;- rate_delay(0.1)

# slowly() causes a function to sleep for a given time between calls:
slow_runif &lt;- slowly(\(x) runif(1), rate = rate, quiet = FALSE)
out &lt;- map(1:5, slow_runif)
</code></pre>

<hr>
<h2 id='splice'>Splice objects and lists of objects into a list</h2><span id='topic+splice'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated in purrr 1.0.0 because we no longer believe that
this style of implicit/automatic splicing is a good idea; instead use
<code>rlang::list2()</code> + <code style="white-space: pre;">&#8288;!!!&#8288;</code> or <code><a href="purrr.html#topic+list_flatten">list_flatten()</a></code>.
</p>
<p><code>splice()</code> splices all arguments into a list. Non-list objects and lists
with a S3 class are encapsulated in a list before concatenation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splice(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splice_+3A_...">...</code></td>
<td>
<p>Objects to concatenate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputs &lt;- list(arg1 = "a", arg2 = "b")

# splice() concatenates the elements of inputs with arg3
splice(inputs, arg3 = c("c1", "c2")) |&gt; str()
list(inputs, arg3 = c("c1", "c2")) |&gt; str()
c(inputs, arg3 = c("c1", "c2")) |&gt; str()
</code></pre>

<hr>
<h2 id='transpose'>Transpose a list.</h2><span id='topic+transpose'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>transpose()</code> turns a list-of-lists &quot;inside-out&quot;; it turns a pair of lists
into a list of pairs, or a list of pairs into pair of lists. For example,
if you had a list of length n where each component had values <code>a</code> and
<code>b</code>, <code>transpose()</code> would make a list with elements <code>a</code> and
<code>b</code> that contained lists of length n. It's called transpose because
<code>x[[1]][[2]]</code> is equivalent to <code>transpose(x)[[2]][[1]]</code>.
</p>
<p>This function was superseded in purrr 1.0.0 because <code><a href="purrr.html#topic+list_transpose">list_transpose()</a></code>
has a better name and can automatically simplify the output, as is commonly
needed. Superseded functions will not go away, but will only receive critical
bug fixes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transpose(.l, .names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpose_+3A_.l">.l</code></td>
<td>
<p>A list of vectors to transpose. The first element is used as the
template; you'll get a warning if a subsequent element has a different
length.</p>
</td></tr>
<tr><td><code id="transpose_+3A_.names">.names</code></td>
<td>
<p>For efficiency, <code>transpose()</code> bases the return structure on
the first component of <code>.l</code> by default. Specify <code>.names</code> to override this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with indexing transposed compared to <code>.l</code>.
</p>
<p><code>transpose()</code> is its own inverse, much like the transpose operation on a
matrix. You can get back the original input by transposing it twice.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- map(1:5, \(i) list(x = runif(1), y = runif(5)))
# was
x |&gt; transpose() |&gt; str()
# now
x |&gt; list_transpose(simplify = FALSE) |&gt; str()

# transpose() is useful in conjunction with safely() &amp; quietly()
x &lt;- list("a", 1, 2)
y &lt;- x |&gt; map(safely(log))
# was
y |&gt; transpose() |&gt; str()
# now:
y |&gt; list_transpose() |&gt; str()

# Previously, output simplification required a call to another function
x &lt;- list(list(a = 1, b = 2), list(a = 3, b = 4), list(a = 5, b = 6))
x |&gt; transpose() |&gt; simplify_all()
# Now can take advantage of automatic simplification
x |&gt; list_transpose()

# Provide explicit component names to prevent loss of those that don't
# appear in first component
ll &lt;- list(
  list(x = 1, y = "one"),
  list(z = "deux", x = 2)
)
ll |&gt; transpose()
nms &lt;- ll |&gt; map(names) |&gt; reduce(union)
# was
ll |&gt; transpose(.names = nms)
# now
ll |&gt; list_transpose(template = nms)
# and can supply default value
ll |&gt; list_transpose(template = nms, default = NA)
</code></pre>

<hr>
<h2 id='update_list'>Update a list with formulas</h2><span id='topic+update_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>update_list()</code> was deprecated in purrr 1.0.0, because we no longer believe
that functions that use NSE are a good fit for purrr.
</p>
<p><code>update_list()</code> handles formulas and quosures that can refer to
values existing within the input list. This function is deprecated
because we no longer believe that functions that use tidy evaluation are
a good fit for purrr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_list(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_list_+3A_.x">.x</code></td>
<td>
<p>List to modify.</p>
</td></tr>
<tr><td><code id="update_list_+3A_...">...</code></td>
<td>
<p>New values of a list. Use <code>zap()</code> to remove values.
</p>
<p>These values should be either all named or all unnamed. When
inputs are all named, they are matched to <code>.x</code> by name. When they
are all unnamed, they are matched by position.
</p>
<p><a href="rlang.html#topic+dyn-dots">Dynamic dots</a> are supported. In particular, if your
replacement values are stored in a list, you can splice that in with
<code style="white-space: pre;">&#8288;!!!&#8288;</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='when'>Match/validate a set of conditions for an object and continue with the action
associated with the first valid match.</h2><span id='topic+when'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated in purrr 1.0.0 because it's not related to the
core purpose of purrr. You can pull your code out of a pipe and use regular
<code>if</code>/<code style="white-space: pre;">&#8288;else&#8288;</code> statements instead.
</p>
<p><code>when()</code> is a flavour of pattern matching (or an if-else abstraction) in
which a value is matched against a sequence of condition-action sets. When a
valid match/condition is found the action is executed and the result of the
action is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>when(., ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="when_+3A_.">.</code></td>
<td>
<p>the value to match against</p>
</td></tr>
<tr><td><code id="when_+3A_...">...</code></td>
<td>
<p>formulas; each containing a condition as LHS and an action as RHS.
named arguments will define additional values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value resulting from the action of the first valid
match/condition is returned. If no matches are found, and no default is
given, NULL will be returned.
</p>
<p>Validity of the conditions are tested with <code>isTRUE</code>, or equivalently
with <code>identical(condition, TRUE)</code>.
In other words conditions resulting in more than one logical will never
be valid. Note that the input value is always treated as a single object,
as opposed to the <code>ifelse</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>1:10 %&gt;%
  when(
    sum(.) &lt;=  50 ~ sum(.),
    sum(.) &lt;= 100 ~ sum(.)/2,
    ~ 0
  )

# now
x &lt;- 1:10
if (sum(x) &lt; 10) {
  sum(x)
} else if (sum(x) &lt; 100) {
  sum(x) / 2
} else {
  0
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
