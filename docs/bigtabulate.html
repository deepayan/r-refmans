<!DOCTYPE html><html><head><title>Help for package bigtabulate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigtabulate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bigtabulate'><p>Extended Tabular Operations for Both matrix and big.matrix Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.9</td>
</tr>
<tr>
<td>Title:</td>
<td>Table, Apply, and Split Functionality for Matrix and
'big.matrix' Objects</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael J. Kane &lt;kaneplusplus@gmail.com&gt; and John W. Emerson
    &lt;jayemerson@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael J. Kane &lt;bigmemoryauthors@gmail.com&gt;</td>
</tr>
<tr>
<td>Contact:</td>
<td>Jay and Mike &lt;bigmemoryauthors@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>bigmemory (&ge; 4.0.0), biganalytics</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH, bigmemory</td>
</tr>
<tr>
<td>Description:</td>
<td>Extend the bigmemory package with 'table', 'tapply', and 'split'
    support for 'big.matrix' objects. The functions may also be used with native R
    matrices for improving speed and memory-efficiency.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> | <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>(C) 2015 Michael J. Kane and John W. Emerson</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.bigmemory.org">http://www.bigmemory.org</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Biarch:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-05 13:52:19 UTC; mike</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-11 14:12:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='bigtabulate'>Extended Tabular Operations for Both matrix and big.matrix Objects</h2><span id='topic+bigtabulate'></span><span id='topic+bigsplit'></span><span id='topic+bigtable'></span><span id='topic+bigtsummary'></span>

<h3>Description</h3>

<p>This package extends the <span class="pkg">bigmemory</span> package, but the 
functions may also be used with traditional <span class="rlang"><b>R</b></span> <code>matrix</code> and 
<code>data.frame</code> objects. The function <code><a href="#topic+bigtabulate">bigtabulate</a></code> is 
exposed, but we expect most users will prefer the higher-level functions 
<code>bigtable</code>, <code>bigtsummary</code>, and <code>bigsplit</code>. Each of these
functions provides functionality based on a specified conditional 
structure.  In other words, for every cell of a (possibly multidimensional) 
contingency table, they provide (or tabulate) some useful conditional 
behavior (or statistic(s)) of interest.  At the most basic level, this 
provides an extremely fast and memory-efficient alternative to 
<code><a href="base.html#topic+table">table</a></code> for matrices and data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bigtabulate(
  x,
  ccols,
  breaks = vector("list", length = length(ccols)),
  table = TRUE,
  useNA = "no",
  summary.cols = NULL,
  summary.na.rm = FALSE,
  splitcol = NULL,
  splitret = "list"
)

bigsplit(
  x,
  ccols,
  breaks = vector("list", length = length(ccols)),
  useNA = "no",
  splitcol = NA,
  splitret = "list"
)

bigtable(
  x,
  ccols,
  breaks = vector("list", length = length(ccols)),
  useNA = "no"
)

bigtsummary(
  x,
  ccols,
  breaks = vector("list", length = length(ccols)),
  useNA = "no",
  cols,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigtabulate_+3A_x">x</code></td>
<td>
<p>a <code><a href="bigmemory.html#topic+big.matrix">big.matrix</a></code> or a 
<code><a href="base.html#topic+data.frame">data.frame</a></code> or a <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_ccols">ccols</code></td>
<td>
<p>a vector of column indices or names specifying which 
columns should be used for conditioning (e.g. for building a contingency 
table or structure for tabulation).</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_breaks">breaks</code></td>
<td>
<p>a vector or list of <code>length(ccols)</code>.  If a vector,
<code>NA</code> indicates that the associated column should be treated like a
factor (categorical variable), while an integer value indicates that the
range of the associated column should be broken into a specified number of
evenly-spaced bins (histogram-like).  If a list, <code>NA</code> triggers the
factor-like handling, a single number triggers bin-like behavior, while a
triplet (min,max,breaks) indicates that the bin-like behavior should be on
a restricted range rather than on the range of data for that column.  See
<code><a href="biganalytics.html#topic+binit">binit</a></code> for similar specification of this option.</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_table">table</code></td>
<td>
<p>if <code>TRUE</code>, a list of table counts will be returned.</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_usena">useNA</code></td>
<td>
<p>whether to include extra '<code>NA</code>' levels in the table.</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_summary.cols">summary.cols</code></td>
<td>
<p>column(s) for which table summaries will be calculated.</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_summary.na.rm">summary.na.rm</code></td>
<td>
<p>if <code>TRUE</code>, <code>NA</code>s are removed from table
summary calculations.</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_splitcol">splitcol</code></td>
<td>
<p>if <code>NA</code>, the indices which correspond to
table-levels are returned.  If numeric, the corresponding column
values will be returned in a list corresponding to table-levels.  If
<code>NULL</code>, then there is no splitting at all.</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_splitret">splitret</code></td>
<td>
<p>if <code>"list"</code>, the <code>splitcol</code> value is returned
as a list.  When <code>splitcol</code> is <code>NA</code>, <code>splitret</code> may
be <code>"vector"</code>.  Finally, <code>"sparselist"</code> may be a useful option
when the full-blown splitting structure has many unrepresented &quot;cells&quot;;
this is like using the <code>drop=TRUE</code> option to <code><a href="base.html#topic+split">split</a></code>.</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_cols">cols</code></td>
<td>
<p>with <code>bigtsummary</code>, which column(s) should be conditionally
summarized?  This (or these) will be passed on as <code>summary.cols</code>.</p>
</td></tr>
<tr><td><code id="bigtabulate_+3A_na.rm">na.rm</code></td>
<td>
<p>an obvious option for summaries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This package concentrates on conditional stuctures and calculations,
much like <code><a href="base.html#topic+table">table</a></code>, <code><a href="base.html#topic+tapply">tapply</a></code>, and <code><a href="base.html#topic+split">split</a></code>.
The functions are juiced-up versions of the base <span class="rlang"><b>R</b></span> functions;
they work on both regular <span class="rlang"><b>R</b></span> matrices and data frames, but are specialized
for use with <span class="pkg">bigmemory</span> and (for more advanced usage) <span class="pkg">foreach</span>.
They are particularly fast and memory-efficient.  We have found that
<code>bigsplit</code> followed by <code><a href="base.html#topic+lapply">lapply</a></code> or <code><a href="base.html#topic+sapply">sapply</a></code>
can be particularly effective, when the subsets produced by the split
are of reasonable size.  For intensive calculations, subsequent use of
<code>foreach</code> can be helpful (think: parallel apply-like behavior).
</p>
<p>When <code>x</code> is a <code>matrix</code> or a <code>data.frame</code>, some additional
work may be required.  For example, a character column of a <code>data.frame</code>
will be converted to a <code><a href="base.html#topic+factor">factor</a></code> and then coerced to numeric
values (factor level numberings).
</p>
<p>The conditional structure is specified via <code>ccols</code> and <code>breaks</code>.
This differs from the design of the base <span class="rlang"><b>R</b></span> functions but is at the root
of the gains in speed and memory-efficiency.  The <code>breaks</code> may seem
distracting, as most users will simply condition on categorical-like columns.
However, it provides the flexibility to &ldquo;bin&rdquo; &ldquo;continuous&rdquo;,
column(s) much like a histogram.  See <code><a href="biganalytics.html#topic+binit">binit</a></code> for
another example
of this type of option, which can be particularly valuable with massive 
data sets.
</p>
<p>A word of caution: if a &ldquo;continuous&rdquo; variable is not &ldquo;binned&rdquo;,
it will be treated like a factor and the resulting conditional structure will
be large (perhaps immensely so).
The function uses left-closed intervals [a,b) for the &quot;binning&quot; behavior,
when specified, except in the right-most bin, where the interval is entirely
closed.
</p>
<p>Finally, <code>bigsplit</code> is somewhat more general than <code>split</code>.
The default behavior (<code>splitcol=NA</code>)
returns a split of <code>1:nrow(x)</code> as a list
based on the specified conditional structure.  However, it may also
return a vector of cell (or category) numbers.  And of course it may
conduct a split of <code>x[,splitcol]</code>.
</p>


<h3>Value</h3>

<p>array-like object(s), each similar to what is returned by
<code><a href="base.html#topic+tapply">tapply</a></code> and the associated <span class="rlang"><b>R</b></span> functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

# First, break up column 2 into 5 groups, and leave column 5 as a
# factor (which it is).  Note that iris is a data.frame, which is
# fine.  A matrix would also be fine.  A big.matrix would also be fine!
bigtable(iris, ccols=c(2, 5), breaks=list(5, NA))

iris[,2] &lt;- round(iris[,2]) # So columns 2 and 5 will be factor-like
                            # for convenience in these examples, below:

ans1 &lt;- bigtable(iris, c(2, 5))
ans1
# Same answer, but with nice factor labels from table(), because
# table() handles factors.  bigtable() uses the numeric factor
# levels only.
table(iris[,2], iris[,5])

# Here, our formulation is simpler than split's, and is faster and
# more memory-efficient:
ans2 &lt;- bigsplit(iris, c(2, 5), splitcol=1)
ans2[1:3]
split(iris[,1], list(col2=factor(iris[,2]), col5=iris[,5]))[1:3]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
