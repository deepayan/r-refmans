<!DOCTYPE html><html lang="en"><head><title>Help for package mcprogress</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcprogress}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cat_parallel'><p>Versions of <code>cat()</code> and <code>message()</code> for parallel processing</p></a></li>
<li><a href='#catchError'><p>Catch error messages during parallel processing</p></a></li>
<li><a href='#mcProgressBar'><p>Show progress bar during parallel processing</p></a></li>
<li><a href='#mcstop'><p>Stop and print error message during parallel processing</p></a></li>
<li><a href='#pmclapply'><p>mclapply with progress bar</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Progress Bars and Messages for Parallel Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for monitoring progress during parallel processing. Lightweight package which acts as a wrapper around mclapply() and adds a progress bar to it in 'RStudio' or 'Linux' environments. Simply replace your original call to mclapply() with pmclapply(). A progress bar can also be displayed during parallelisation via the 'foreach' package. Also included are functions to safely print messages (including error messages) from within parallelised code, which can be useful for debugging parallelised R code.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/myles-lewis/mcprogress/issues">https://github.com/myles-lewis/mcprogress/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/myles-lewis/mcprogress">https://github.com/myles-lewis/mcprogress</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, rstudioapi</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-25 13:51:23 UTC; myles</td>
</tr>
<tr>
<td>Author:</td>
<td>Myles Lewis <a href="https://orcid.org/0000-0001-9365-5345"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Myles Lewis &lt;myles.lewis@qmul.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-26 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cat_parallel'>Versions of <code><a href="base.html#topic+cat">cat()</a></code> and <code><a href="base.html#topic+message">message()</a></code> for parallel processing</h2><span id='topic+cat_parallel'></span><span id='topic+message_parallel'></span>

<h3>Description</h3>

<p>Prints messages to the console using <code>echo</code> during to enable messages to be
printed during parallel processing. Text is only printed if the Rstudio
environment is detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_parallel(...)

message_parallel(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_parallel_+3A_...">...</code></td>
<td>
<p>zero or more objects which can be coerced to character and which
are pasted together.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a message to the console. <code>cat_parallel()</code> uses no line feed,
while <code>message_parallel()</code> always adds a newline.
</p>

<hr>
<h2 id='catchError'>Catch error messages during parallel processing</h2><span id='topic+catchError'></span>

<h3>Description</h3>

<p>Allows an expression to be wrapped in <code><a href="base.html#topic+try">try()</a></code> to catch error messages. Any
error messages are printed to the console using <code><a href="#topic+mcstop">mcstop()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catchError(expr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="catchError_+3A_expr">expr</code></td>
<td>
<p>An expression to be wrapped in <code><a href="base.html#topic+try">try()</a></code> to allow execution and
catch error messages.</p>
</td></tr>
<tr><td><code id="catchError_+3A_...">...</code></td>
<td>
<p>Optional objects to be tracked if you want to know state of
objects at the point error messages are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints error messages during parallel processing. If there is no
error, the result of the evaluated expression is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcstop">mcstop()</a></code>
</p>

<hr>
<h2 id='mcProgressBar'>Show progress bar during parallel processing</h2><span id='topic+mcProgressBar'></span><span id='topic+closeProgress'></span>

<h3>Description</h3>

<p>Uses <code>echo</code> to safely output a progress bar to Rstudio or Linux console
during parallel processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcProgressBar(
  val,
  len = 1L,
  cores = 1L,
  subval = NULL,
  title = "",
  spinner = FALSE,
  eta = TRUE,
  start = NULL,
  sensitivity = 0.01
)

closeProgress(start = NULL, title = "", eta = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcProgressBar_+3A_val">val</code></td>
<td>
<p>Integer measuring progress</p>
</td></tr>
<tr><td><code id="mcProgressBar_+3A_len">len</code></td>
<td>
<p>Total number of processes to be executed overall.</p>
</td></tr>
<tr><td><code id="mcProgressBar_+3A_cores">cores</code></td>
<td>
<p>Number of cores used for parallel processing.</p>
</td></tr>
<tr><td><code id="mcProgressBar_+3A_subval">subval</code></td>
<td>
<p>Optional subvalue ranging from 0 to 1 to enable granularity
during long processes. Especially useful if <code>len</code> is small relative to
<code>cores</code>.</p>
</td></tr>
<tr><td><code id="mcProgressBar_+3A_title">title</code></td>
<td>
<p>Optional title for the progress bar.</p>
</td></tr>
<tr><td><code id="mcProgressBar_+3A_spinner">spinner</code></td>
<td>
<p>Logical whether to show a spinner which moves when each core
completes a process. More useful for relatively long processes where the
length of time for each process to complete is variable. Not shown if
<code>subval</code> is used. Can add significant overhead is <code>len</code> is large and each
process is very fast.</p>
</td></tr>
<tr><td><code id="mcProgressBar_+3A_eta">eta</code></td>
<td>
<p>Logical whether to show estimated time to completion. <code>start</code>
system time must be supplied with each call to <code>mcProgressbar()</code> in order to
estimate the time to completion.</p>
</td></tr>
<tr><td><code id="mcProgressBar_+3A_start">start</code></td>
<td>
<p>Used to pass the system time from the start of the call to show
a total time elapsed. See the example below.</p>
</td></tr>
<tr><td><code id="mcProgressBar_+3A_sensitivity">sensitivity</code></td>
<td>
<p>Determines maximum sensitivity with which to report
progress for situations where <code>len</code> is large, to reduce overhead. Default
0.01 refers to 1%. Not used if <code>subval</code> is invoked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This package provides 2 main methods to show progress during parallelised
code using <code><a href="parallel.html#topic+mclapply">mclapply()</a></code>. If <code>X</code> (the list object looped over in a call to
<code><a href="parallel.html#topic+mclapply">mclapply()</a></code>) has many elements compared to the number of cores, then it is
easiest to use <code><a href="#topic+pmclapply">pmclapply()</a></code>. However, in some use cases the length of <code>X</code> is
comparable to the number of cores and each process may take a long time. For
example, machine learning applied to each of 8 folds on an 8-core machine
will open 8 processes from the outset. Each process will often complete at
roughly the same time. In this case <code><a href="#topic+pmclapply">pmclapply()</a></code> is much less informative as
it only shows completion at the end of 1 round of processes so it will go
from 0% to 100%. In this example, if each process code is long and
subprogress can be reported along the way, for example during nested loops,
then <code>mcProgressBar()</code> provides a way to show the subprogress during the
inner loop. The example below shows how to write code involving an outer call
to <code><a href="parallel.html#topic+mclapply">mclapply()</a></code> and an inner loop whose subprogress is tracked via calls to
<code>mcProgressBar()</code>.
</p>
<p>Technically only 1 process can be tracked. If <code>cores</code> is set to 4 and
<code>subval</code> is invoked, then the 1st, 5th, 9th, 13th etc process is tracked.
Subprogress of this process is computed as part of the number of blocks of
processes required. ETA is approximate. As part of minimising overhead, it is
only updated with each change in progress (i.e. each time a block of
processes completes) or when subprogress changes. It is not updated by
interrupt.
</p>


<h3>Value</h3>

<p>No return value. Prints a progress bar to the console if called
within an Rstudio or Linux environment.
</p>


<h3>Author(s)</h3>

<p>Myles Lewis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmclapply">pmclapply()</a></code> <code><a href="parallel.html#topic+mclapply">mclapply()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.info()["sysname"] != "Windows") {

## Example function with mclapply wrapped around another nested function
library(parallel)

my_fun &lt;- function(x, cores) {
  start &lt;- Sys.time()
  mcProgressBar(0, title = "my_fun")  # initialise progress bar
  res &lt;- mclapply(seq_along(x), function(i) {
    # inner loop of calculation
    y &lt;- 1:4
    inner &lt;- lapply(seq_along(y), function(j) {
      Sys.sleep(0.2 + runif(1) * 0.1)
      mcProgressBar(val = i, len = length(x), cores, subval = j / length(y),
                    title = "my_fun")
      rnorm(4)
    })
    inner
  }, mc.cores = cores)
  closeProgress(start, title = "my_fun")  # finalise the progress bar
  res
}

res &lt;- my_fun(letters[1:4], cores = 2)

## Example of long function
longfun &lt;- function(x, cores) {
  start &lt;- Sys.time()
  mcProgressBar(0, title = "longfun")  # initialise progress bar
  res &lt;- mclapply(seq_along(x), function(i) {
    # long sequential calculation in parallel with 3 major steps
    Sys.sleep(0.2)
    mcProgressBar(val = i, len = length(x), cores, subval = 0.33,
                  title = "longfun")  # 33% complete
    Sys.sleep(0.2)
    mcProgressBar(val = i, len = length(x), cores, subval = 0.66,
                  title = "longfun")  # 66% complete
    Sys.sleep(0.2)
    mcProgressBar(val = i, len = length(x), cores, subval = 1,
                  title = "longfun")  # 100% complete
    return(rnorm(4))
  }, mc.cores = cores)
  closeProgress(start, title = "longfun")  # finalise the progress bar
  res
}

res &lt;- longfun(letters[1:2], cores = 2)

}
</code></pre>

<hr>
<h2 id='mcstop'>Stop and print error message during parallel processing</h2><span id='topic+mcstop'></span>

<h3>Description</h3>

<p><code>mcstop()</code> is a multicore version of <code><a href="base.html#topic+stop">stop()</a></code> which prints to the console
using 'echo' during parallel commands such as <code><a href="parallel.html#topic+mclapply">mclapply()</a></code>, to allow error
messages to be more visible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcstop(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcstop_+3A_...">...</code></td>
<td>
<p>Objects coerced to character and pasted together and printed to
the console using <code>echo</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints an error message.
</p>

<hr>
<h2 id='pmclapply'>mclapply with progress bar</h2><span id='topic+pmclapply'></span>

<h3>Description</h3>

<p><code>pmclapply()</code> adds a progress bar to <code><a href="parallel.html#topic+mclapply">mclapply()</a></code> in Rstudio or Linux
environments using output to the console. It is designed to add very little
overhead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmclapply(
  X,
  FUN,
  ...,
  progress = TRUE,
  spinner = FALSE,
  title = "",
  eta = TRUE,
  mc.preschedule = TRUE,
  mc.set.seed = TRUE,
  mc.silent = FALSE,
  mc.cores = getOption("mc.cores", 2L),
  mc.cleanup = TRUE,
  mc.allow.recursive = TRUE,
  affinity.list = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmclapply_+3A_x">X</code></td>
<td>
<p>a vector (atomic or list) or an expressions vector. Other objects
(including classed objects) will be coerced by <code>as.list()</code>.</p>
</td></tr>
<tr><td><code id="pmclapply_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied via <code><a href="parallel.html#topic+mclapply">mclapply()</a></code> to each element of <code>X</code>
in parallel.</p>
</td></tr>
<tr><td><code id="pmclapply_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="pmclapply_+3A_progress">progress</code></td>
<td>
<p>Logical whether to show the progress bar.</p>
</td></tr>
<tr><td><code id="pmclapply_+3A_spinner">spinner</code></td>
<td>
<p>Logical whether to show a spinner which moves each time a
parallel process is completed. More useful if the length of time for each
process to complete is variable.</p>
</td></tr>
<tr><td><code id="pmclapply_+3A_title">title</code></td>
<td>
<p>Title for the progress bar.</p>
</td></tr>
<tr><td><code id="pmclapply_+3A_eta">eta</code></td>
<td>
<p>Logical whether to show estimated time to completion.</p>
</td></tr>
<tr><td><code id="pmclapply_+3A_mc.preschedule">mc.preschedule</code>, <code id="pmclapply_+3A_mc.set.seed">mc.set.seed</code>, <code id="pmclapply_+3A_mc.silent">mc.silent</code>, <code id="pmclapply_+3A_mc.cleanup">mc.cleanup</code>, <code id="pmclapply_+3A_mc.allow.recursive">mc.allow.recursive</code>, <code id="pmclapply_+3A_affinity.list">affinity.list</code></td>
<td>
<p>See <code><a href="parallel.html#topic+mclapply">mclapply()</a></code>.</p>
</td></tr>
<tr><td><code id="pmclapply_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child
processes will be run simultaneously. The option is initialized from
environment variable <code>MC_CORES</code> if set. Must be at least one, and
parallelization requires at least two cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in an identical manner to <code><a href="parallel.html#topic+mclapply">mclapply()</a></code>. It is ideal
for use if the length of <code>X</code> is comparably &gt; cores. As processes are spawned
in a block and most code for each process completes at roughly the same time,
processes move along in blocks as determined by <code>mc.cores</code>. To track
progress, <code>pmclapply()</code> only tracks the nth process, where n=<code>mc.cores</code>. For
example, with 4 cores, <code>pmclapply()</code> reports progress when the 4th, 8th,
12th, 16th etc process has completed. If the length of <code>X</code> is very large
(e.g. in the 1000s), then the progress bar will only update for each 1% of
progress in order to reduce overhead.
</p>
<p>However, in some scenarios the length of <code>X</code> is comparable to the number of
cores and each process may take a long time. For example, machine learning
applied to each of 8 cross-validation folds on an 8-core machine will open 8
processes from the outset. Each process will often complete at roughly the
same time. In this case <code>pmclapply()</code> is much less informative as it only
shows completion at the end of 1 round of processes, so it will go from 0%
straight to 100%. For this scenario, we recommend users use <code><a href="#topic+mcProgressBar">mcProgressBar()</a></code>
which allows more fine-grained reporting of subprogress from within a block
of parallel processes.
</p>
<p>ETA is approximate. As part of minimising overhead, it is only updated with
each change in progress (i.e. each time a block of processes completes). It
is not updated by interrupt.
</p>


<h3>Value</h3>

<p>A list of the same length as <code>X</code> and named by <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Myles Lewis
</p>


<h3>See Also</h3>

<p><code><a href="parallel.html#topic+mclapply">mclapply()</a></code> <code><a href="#topic+mcProgressBar">mcProgressBar()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.info()["sysname"] != "Windows") {

res &lt;- pmclapply(letters[1:20], function(i) {
                 Sys.sleep(0.2 + runif(1) * 0.1)
                 setNames(rnorm(5), paste0(i, 1:5))
                 }, mc.cores = 2, title = "Working")

}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
