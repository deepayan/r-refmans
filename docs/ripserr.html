<!DOCTYPE html><html lang="en"><head><title>Help for package ripserr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ripserr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cubical'><p>Calculate Persistent Homology using a Cubical Complex</p></a></li>
<li><a href='#ripserr'><p>Calculate Persistent Homology with Ripser-Based Engines</p></a></li>
<li><a href='#vietoris_rips'><p>Calculate Persistent Homology of a Point Cloud</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Calculate Persistent Homology with Ripser-Based Engines</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Ports the Ripser &lt;<a href="https://doi.org/10.48550/arXiv.1908.02518">doi:10.48550/arXiv.1908.02518</a>&gt; and Cubical Ripser
        &lt;<a href="https://doi.org/10.48550/arXiv.2005.12692">doi:10.48550/arXiv.2005.12692</a>&gt; persistent homology calculation engines from
        C++. Can be used as a rapid calculation tool in topological
        data analysis pipelines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rrrlw.github.io/ripserr/">https://rrrlw.github.io/ripserr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rrrlw/ripserr/issues">https://github.com/rrrlw/ripserr/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods (&ge; 3.0), Rcpp (&ge; 1.0), stats (&ge; 3.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.3), covr (&ge; 3.5), knitr (&ge; 1.29), rmarkdown
(&ge; 2.3)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-15 10:51:01 UTC; appveyor</td>
</tr>
<tr>
<td>Author:</td>
<td>Raoul Wadhwa <a href="https://orcid.org/0000-0003-0503-9580"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Matt Piekenbrock [aut],
  Jacob Scott <a href="https://orcid.org/0000-0003-2971-7673"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Takeki Sudo [cph, ctb] (Takeki Sudo is a copyright holder for Cubical
    Ripser (GPL-3 license), which was refactored prior to inclusion in
    ripserr.),
  Kazushi Ahara [cph, ctb] (Kazushi Ahara is a copyright holder for
    Cubical Ripser (GPL-3 license), which was refactored prior to
    inclusion in ripserr.),
  Ulrich Bauer [cph, ctb] (Ulrich Bauer holds the copyright to Ripser
    (MIT license), which was refactored prior to inclusion in ripserr.)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raoul Wadhwa &lt;raoulwadhwa@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-20 20:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cubical'>Calculate Persistent Homology using a Cubical Complex</h2><span id='topic+cubical'></span>

<h3>Description</h3>

<p>Calculates the persistent homology of a 2- to 4-dimensional numeric array
using a Cubical complex. This function is an R wrapper for Takeki Sudo
and Kazushi Ahara's Cubical Ripser C++ library. For more information on
the C++ library, see <a href="https://github.com/CubicalRipser">https://github.com/CubicalRipser</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubical(
  dataset,
  threshold = 9999,
  method = 0,
  standardize = FALSE,
  return_format = "df"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cubical_+3A_dataset">dataset</code></td>
<td>
<p>numeric array containing pixel/voxel data</p>
</td></tr>
<tr><td><code id="cubical_+3A_threshold">threshold</code></td>
<td>
<p>maximum diameter for computation of Cubical complex</p>
</td></tr>
<tr><td><code id="cubical_+3A_method">method</code></td>
<td>
<p>defaults to 0 for link join; alternatively, can be 1 for
compute pairs. See original Cubical Ripser code at GitHub user
CubicalRipser for details.</p>
</td></tr>
<tr><td><code id="cubical_+3A_standardize">standardize</code></td>
<td>
<p>boolean determining whether point cloud size should be standardized</p>
</td></tr>
<tr><td><code id="cubical_+3A_return_format">return_format</code></td>
<td>
<p>defaults to <code>"df"</code>, returning a data frame;
if <code>mat</code>, returns a numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-column matrix with each row representing a TDA feature
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 2-dim example
dataset &lt;- rnorm(10 ^ 2)
dim(dataset) &lt;- rep(10, 2)
cubical_hom2 &lt;- cubical(dataset)

# 3-dim example
dataset &lt;- rnorm(8 ^ 3)
dim(dataset) &lt;- rep(8, 3)
cubical_hom3 &lt;- cubical(dataset)

# 4-dim example
dataset &lt;- rnorm(5 ^ 4)
dim(dataset) &lt;- rep(5, 4)
cubical_hom4 &lt;- cubical(dataset)
</code></pre>

<hr>
<h2 id='ripserr'>Calculate Persistent Homology with Ripser-Based Engines</h2><span id='topic+ripserr'></span>

<h3>Description</h3>

<p>Ports Ripser-based persistent homology calculation engines
from C++ to R using the Rcpp package.
</p>

<hr>
<h2 id='vietoris_rips'>Calculate Persistent Homology of a Point Cloud</h2><span id='topic+vietoris_rips'></span>

<h3>Description</h3>

<p>Calculates the persistent homology of a point cloud, as represented by
a Vietoris-Rips complex. This function is an R wrapper for Ulrich Bauer's
Ripser C++ library for calculating persistent homology. For more
information on the C++ library, see <a href="https://github.com/Ripser/ripser">https://github.com/Ripser/ripser</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vietoris_rips(
  dataset,
  dim = 1,
  threshold = -1,
  p = 2L,
  format = "cloud",
  standardize = FALSE,
  return_format = "df"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vietoris_rips_+3A_dataset">dataset</code></td>
<td>
<p>numeric matrix containing point cloud or distance matrix</p>
</td></tr>
<tr><td><code id="vietoris_rips_+3A_dim">dim</code></td>
<td>
<p>maximum dimension of features to calculate</p>
</td></tr>
<tr><td><code id="vietoris_rips_+3A_threshold">threshold</code></td>
<td>
<p>maximum diameter for computation of Vietoris-Rips complexes</p>
</td></tr>
<tr><td><code id="vietoris_rips_+3A_p">p</code></td>
<td>
<p>number of the prime field Z/pZ to compute the homology over</p>
</td></tr>
<tr><td><code id="vietoris_rips_+3A_format">format</code></td>
<td>
<p>format of <code>mat</code>, either <code>"cloud"</code> for point cloud or <code>"distmat"</code> for distance matrix</p>
</td></tr>
<tr><td><code id="vietoris_rips_+3A_standardize">standardize</code></td>
<td>
<p>boolean determining whether point cloud size should be standardized</p>
</td></tr>
<tr><td><code id="vietoris_rips_+3A_return_format">return_format</code></td>
<td>
<p>defaults to <code>"df"</code>, returning a data frame;
if <code>mat</code>, returns a numeric matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mat</code> parameter should be a numeric matrix with each row corresponding
to a single point, and each column corresponding to a single dimension. Thus,
if <code>mat</code> has 50 rows and 5 columns, it represents a point cloud with 50 points
in 5 dimensions. The <code>dim</code> parameter should be a positive integer.
Alternatively, the <code>mat</code> parameter could be a distance matrix (upper
triangular half is ignored); note: <code>format</code> should be specified as &quot;distmat&quot;.
</p>


<h3>Value</h3>

<p>3-column matrix or data frame, with each row representing a TDA feature
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a 2-d point cloud of a circle (100 points)
num.pts &lt;- 100
rand.angle &lt;- runif(num.pts, 0, 2*pi)
pt.cloud &lt;- cbind(cos(rand.angle), sin(rand.angle))

# calculate persistent homology (num.pts by 3 numeric matrix)
pers.hom &lt;- vietoris_rips(pt.cloud)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
