<!DOCTYPE html><html><head><title>Help for package vcdExtra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vcdExtra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Abortion'><p>Abortion Opinion Data</p></a></li>
<li><a href='#Accident'>
<p>Traffic Accident Victims in France in 1958</p></a></li>
<li><a href='#AirCrash'>
<p>Air Crash Data</p></a></li>
<li><a href='#Alligator'>
<p>Alligator Food Choice</p></a></li>
<li><a href='#Asbestos'>
<p>Effect of Exposure to Asbestos</p></a></li>
<li><a href='#Bartlett'><p>Bartlett Data on Plum Root Cuttings</p></a></li>
<li><a href='#blogits'>
<p>Bivariate Logits and Log Odds Ratio</p></a></li>
<li><a href='#Burt'>
<p>Burt (1950) Data on Hair, Eyes, Head and Stature</p></a></li>
<li><a href='#Caesar'><p>Risk Factors for Infection in Caesarian Births</p></a></li>
<li><a href='#Cancer'><p>Survival of Breast Cancer Patients</p></a></li>
<li><a href='#CMHtest'>
<p>Generalized Cochran-Mantel-Haenszel Tests</p></a></li>
<li><a href='#collapse.table'><p>Collapse Levels of a Table</p></a></li>
<li><a href='#Cormorants'>
<p>Advertising Behavior by Males Cormorants</p></a></li>
<li><a href='#Crossings'><p>Crossings Interaction of Factors</p></a></li>
<li><a href='#cutfac'>
<p>Cut a Numeric Variable to a Factor</p></a></li>
<li><a href='#CyclingDeaths'>
<p>London Cycling Deaths</p></a></li>
<li><a href='#datasets'>
<p>Information on Data Sets in Packages</p></a></li>
<li><a href='#DaytonSurvey'><p>Dayton Student Survey on Substance Use</p></a></li>
<li><a href='#Depends'>
<p>Dependencies of R Packages</p></a></li>
<li><a href='#Detergent'><p>Detergent preference data</p></a></li>
<li><a href='#Donner'>
<p>Survival in the Donner Party</p></a></li>
<li><a href='#Draft1970'>
<p>USA 1970 Draft Lottery Data</p></a></li>
<li><a href='#Draft1970table'>
<p>USA 1970 Draft Lottery Table</p></a></li>
<li><a href='#Dyke'><p>Sources of Knowledge of Cancer</p></a></li>
<li><a href='#expand.dft'><p> Expand a frequency table to case form</p></a></li>
<li><a href='#Fungicide'>
<p>Carcinogenic Effects of a Fungicide</p></a></li>
<li><a href='#Geissler'><p>Geissler's Data on the Human Sex Ratio</p></a></li>
<li><a href='#Gilby'><p>Clothing and Intelligence Rating of Children</p></a></li>
<li><a href='#GKgamma'><p>Calculate Goodman-Kruskal Gamma for ordered tables</p></a></li>
<li><a href='#Glass'><p>British Social Mobility from Glass(1954)</p></a></li>
<li><a href='#glmlist'>
<p>Create a Model List Object</p></a></li>
<li><a href='#GSS'><p>General Social Survey&ndash; Sex and Party affiliation</p></a></li>
<li><a href='#HairEyePlace'>
<p>Hair Color and Eye Color in Caithness and Aberdeen</p></a></li>
<li><a href='#Hauser79'>
<p>Hauser (1979) Data on Social Mobility</p></a></li>
<li><a href='#Heart'><p>Sex, Occupation and Heart Disease</p></a></li>
<li><a href='#Heckman'><p>Labour Force Participation of Married Women 1967-1971</p></a></li>
<li><a href='#HLtest'>
<p>Hosmer-Lemeshow Goodness of Fit Test</p></a></li>
<li><a href='#HospVisits'>
<p>Hospital Visits Data</p></a></li>
<li><a href='#HouseTasks'>
<p>Household Tasks Performed by Husbands and Wives</p></a></li>
<li><a href='#Hoyt'><p>Minnesota High School Graduates</p></a></li>
<li><a href='#ICU'><p>ICU data set</p></a></li>
<li><a href='#JobSat'><p>Cross-classification of job satisfaction by income</p></a></li>
<li><a href='#Kway'>
<p>Fit All K-way Models in a GLM</p></a></li>
<li><a href='#logLik.loglm'><p>Log-Likelihood of a loglm Object</p></a></li>
<li><a href='#loglin-utilities'>
<p>Loglinear Model Utilities</p></a></li>
<li><a href='#logseries'>
<p>The Logarithmic Series Distribution</p></a></li>
<li><a href='#LRstats'>
<p>Brief Summary of Model Fit for glm and loglm Models</p></a></li>
<li><a href='#Mammograms'><p>Mammogram Ratings</p></a></li>
<li><a href='#mcaplot'><p>Simple and enhanced plot of MCA solutions</p></a></li>
<li><a href='#Mental'><p>Mental Impairment and Parents SES</p></a></li>
<li><a href='#Mice'><p>Mice Depletion Data</p></a></li>
<li><a href='#Mobility'><p>Social Mobility data</p></a></li>
<li><a href='#modFit'><p>Brief Summary of Model Fit for a glm or loglm Object</p></a></li>
<li><a href='#mosaic.glm'><p>Mosaic plots for fitted generalized linear and generalized nonlinear models</p></a></li>
<li><a href='#mosaic.glmlist'>
<p>Mosaic Displays for <code>glmlist</code> and <code>loglmlist</code> Objects</p></a></li>
<li><a href='#mosaic3d'>
<p>3D Mosaic Plots</p></a></li>
<li><a href='#PhdPubs'>
<p>Publications of PhD Candidates</p></a></li>
<li><a href='#print.Kappa'><p> Print Kappa</p></a></li>
<li><a href='#seq_loglm'><p>Sequential Loglinear Models for an N-way Table</p></a></li>
<li><a href='#seq_mosaic'>
<p>Sequential Mosaics and Strucplots for an N-way Table</p></a></li>
<li><a href='#ShakeWords'>
<p>Shakespeare's Word Type Frequencies</p></a></li>
<li><a href='#split3d'>
<p>Subdivide a 3D Object</p></a></li>
<li><a href='#Summarise'>
<p>Brief Summary of Model Fit for glm and loglm Models</p></a></li>
<li><a href='#Titanicp'><p>Passengers on the Titanic</p></a></li>
<li><a href='#Toxaemia'><p>Toxaemia Symptoms in Pregnancy</p></a></li>
<li><a href='#TV'><p>TV Viewing Data</p></a></li>
<li><a href='#update.xtabs'>
<p>Update method for a <code>xtabs</code> object</p></a></li>
<li><a href='#vcdExtra-deprecated'><p>Deprecated Functions in vcdExtra Package</p></a></li>
<li><a href='#vcdExtra-package'>
<p>Extensions and additions to vcd: Visualizing Categorical Data</p></a></li>
<li><a href='#Vietnam'><p>Student Opinion about the Vietnam War</p></a></li>
<li><a href='#Vote1980'>
<p>Race and Politics in the 1980 Presidential Vote</p></a></li>
<li><a href='#WorkerSat'><p>Worker Satisfaction Data</p></a></li>
<li><a href='#Yamaguchi87'><p>Occupational Mobility in Three Countries</p></a></li>
<li><a href='#zero.test'>
<p>Score test for zero inflation in Poisson data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'vcd' Extensions and Additions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Friendly &lt;friendly@yorku.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), vcd, gnm (&ge; 1.0-3), grid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gmodels, Fahrmeir, effects, VGAM, plyr, lmtest, nnet,
ggplot2, Sleuth2, car, lattice, stats4, rgl, AER, coin, Hmisc,
knitr, rmarkdown, seriation,</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, grDevices, stats, utils, ca, dplyr, glue, here, purrr,
readxl, stringr, tidyr (&ge; 1.3.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides additional data sets, methods and documentation to complement the 'vcd' package for Visualizing Categorical Data
    and the 'gnm' package for Generalized Nonlinear Models.
	In particular, 'vcdExtra' extends mosaic, assoc and sieve plots from 'vcd' to handle 'glm()' and 'gnm()' models and
	adds a 3D version in 'mosaic3d'.  Additionally, methods are provided for comparing and visualizing lists of
	'glm' and 'loglm' objects. This package is now a support package for the book, "Discrete Data Analysis with R" by
  Michael Friendly and David Meyer.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://friendly.github.io/vcdExtra/">https://friendly.github.io/vcdExtra/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/friendly/vcdExtra">https://github.com/friendly/vcdExtra</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 20:10:59 UTC; friendly</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Friendly <a href="https://orcid.org/0000-0002-3237-0941"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Heather Turner [ctb],
  David Meyer [ctb],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Duncan Murdoch [ctb],
  David Firth [ctb],
  Matt Kumar [ctb],
  Shuguang Sun [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 03:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Abortion'>Abortion Opinion Data</h2><span id='topic+Abortion'></span>

<h3>Description</h3>

<p>Opinions about abortion classified by gender and SES</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Abortion)
</code></pre>


<h3>Format</h3>

<p>A 3-dimensional array resulting from cross-tabulating 3 variables for  1100 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name                    </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1  </td><td style="text-align: left;"> <code>Sex</code>              </td><td style="text-align: left;"> <code>"Female", "Male"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2  </td><td style="text-align: left;"> <code>Status</code>           </td><td style="text-align: left;"> <code>"Lo", "Hi"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    3  </td><td style="text-align: left;"> <code>Support_Abortion</code> </td><td style="text-align: left;"> <code>"Yes", "No"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p><code>Support_Abortion</code> is a natural response variable.
</p>
<p>The combinations of <code>Sex</code> and <code>Status</code> represent four independent samples, having
fixed <code>Sex</code>-<code>Status</code> marginal totals.
There were 500 females and 600 males. Within the female group, 250 of low status and 250
of high status were sampled. Similarly for the males, with 300 in each of the low and high
status sub-groups.
</p>
<p>This is an example of a product-multinomial sampling scheme.
the <code>Sex:Status</code> association must be included in any loglinear model
where the goal is to determine how attitude toward abortion depends on the others.
</p>
<p>Alternatively, a logit model for abortion support may provide a simpler analysis.
</p>


<h3>Source</h3>


<p>Christensen, R. (1990).
<em>Log-Linear Models</em>,
New York, NY: Springer-Verlag, p. 92, Example 3.5.2.
</p>
<p>Christensen, R. (1997).
<em>Log-Linear Models and Logistic Regression</em>,
New York, NY: Springer, p. 100, Example 3.5.2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Abortion)


ftable(Abortion)
mosaic(Abortion, shade=TRUE)

# stratified by Sex
fourfold(aperm(Abortion, 3:1))
# stratified by Status
fourfold(aperm(Abortion, c(3,1,2)))

</code></pre>

<hr>
<h2 id='Accident'>
Traffic Accident Victims in France in 1958
</h2><span id='topic+Accident'></span>

<h3>Description</h3>

<p>Bertin (1983) used these data to illustrate the cross-classification of 
data by numerous variables, each of which could have various types
and could be assigned to various visual attributes.  
</p>
<p>For modeling and visualization purposes, the data can be treated as a
4-way table using loglinear models and mosaic displays, or as a 
frequency-weighted data frame using a binomial response for
<code>result</code> (<code>"Died"</code> vs. <code>"Injured"</code>) and plots of
predicted probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Accident)</code></pre>


<h3>Format</h3>

<p>A data frame in frequency form (comprising a 5 x 2 x 4 x 2 table)
with 80 observations on the following 5 variables.
</p>

<dl>
<dt><code>age</code></dt><dd><p>an ordered factor with levels <code>0-9</code> &lt; <code>10-19</code> &lt; <code>20-29</code> &lt; <code>30-49</code> &lt; <code>50+</code></p>
</dd>
<dt><code>result</code></dt><dd><p>a factor with levels <code>Died</code> <code>Injured</code></p>
</dd>
<dt><code>mode</code></dt><dd><p>mode of transportation,
a factor with levels <code>4-Wheeled</code> <code>Bicycle</code> <code>Motorcycle</code> <code>Pedestrian</code></p>
</dd>
<dt><code>gender</code></dt><dd><p>a factor with levels <code>Female</code> <code>Male</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>age</code> is an ordered factor, but arguably, <code>mode</code> should be treated as ordered, with levels
<code>Pedestrian</code> &lt; <code>Bicycle</code> &lt; <code>Motorcycle</code> &lt; <code>4-Wheeled</code> 
as Bertin does.  This affects the parameterization in models, so we don't do this directly in the
data frame.
</p>


<h3>Source</h3>

<p>Bertin (1983), p. 30; original data from the Ministere des Travaux Publics
</p>


<h3>References</h3>

<p>Bertin, J. (1983),  <em>Semiology of Graphics</em>, University of Wisconsin Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples
data(Accident)
head(Accident)

# for graphs, reorder mode
Accident$mode &lt;- ordered(Accident$mode,
   levels=levels(Accident$mode)[c(4,2,3,1)])

# Bertin's table
accident_tab &lt;- xtabs(Freq ~ gender + mode + age + result, data=Accident)
structable(mode + gender ~ age + result, data=accident_tab)

## Loglinear models
## ----------------

# mutual independence
acc.mod0 &lt;- glm(Freq ~ age + result + mode + gender, 
                data=Accident, 
                family=poisson)
LRstats(acc.mod0)

mosaic(acc.mod0, ~mode + age + gender + result)

# result as a response
acc.mod1 &lt;- glm(Freq ~ age*mode*gender + result, 
                data=Accident, 
                family=poisson)
LRstats(acc.mod1)

mosaic(acc.mod1, ~mode + age + gender + result, 
    labeling_args = list(abbreviate = c(gender=1, result=4)))

# allow two-way association of result with each explanatory variable
acc.mod2 &lt;- glm(Freq ~ age*mode*gender + result*(age+mode+gender), 
                data=Accident, 
                family=poisson)
LRstats(acc.mod2)
mosaic(acc.mod2, ~mode + age + gender + result, 
    labeling_args = list(abbreviate = c(gender=1, result=4)))

acc.mods &lt;- glmlist(acc.mod0, acc.mod1, acc.mod2)
LRstats(acc.mods)

## Binomial (logistic regression) models for result
## ------------------------------------------------
library(car)  # for Anova()
acc.bin1 &lt;- glm(result=='Died' ~ age + mode + gender, 
    weights=Freq, data=Accident, family=binomial)
Anova(acc.bin1)

acc.bin2 &lt;- glm(result=='Died' ~ (age + mode + gender)^2, 
    weights=Freq, data=Accident, family=binomial)
Anova(acc.bin2)

acc.bin3 &lt;- glm(result=='Died' ~ (age + mode + gender)^3, 
    weights=Freq, data=Accident, family=binomial)
Anova(acc.bin3)

# compare models
anova(acc.bin1, acc.bin2, acc.bin3, test="Chisq")

# visualize probability of death with effect plots
## Not run: 
library(effects)
plot(allEffects(acc.bin1), ylab='Pr (Died)')

plot(allEffects(acc.bin2), ylab='Pr (Died)')

## End(Not run)


#</code></pre>

<hr>
<h2 id='AirCrash'>
Air Crash Data
</h2><span id='topic+AirCrash'></span>

<h3>Description</h3>

<p>Data on all fatal commercial airplane crashes from 1993&ndash;2015.
Excludes small planes (less than 6 passengers) and non-commercial (cargo, military, private) aircraft.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("AirCrash")</code></pre>


<h3>Format</h3>

<p>A data frame with 439 observations on the following 5 variables.
</p>

<dl>
<dt><code>Phase</code></dt><dd><p>phase of the flight, a factor with levels <code>en route</code> <code>landing</code> <code>standing</code> <code>take-off</code> <code>unknown</code></p>
</dd>
<dt><code>Cause</code></dt><dd><p>a factor with levels <code>criminal</code> <code>human error</code> <code>mechanical</code> <code>unknown</code> <code>weather</code></p>
</dd>
<dt><code>date</code></dt><dd><p>date of crash, a Date</p>
</dd>
<dt><code>Fatalities</code></dt><dd><p>number of fatalities, a numeric vector</p>
</dd>
<dt><code>Year</code></dt><dd><p>year, a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>Phase</code> of the flight was cleaned by combining related variants, spelling, etc.
</p>


<h3>Source</h3>

<p>Originally from David McCandless,
<a href="https://informationisbeautiful.net/visualizations/plane-truth-every-single-commercial-plane-crash-visualized/">https://informationisbeautiful.net/visualizations/plane-truth-every-single-commercial-plane-crash-visualized/</a>,
with the data at
<a href="https://docs.google.com/spreadsheets/d/1OvDq4_BtbR6nSnnHnjD5hVC3HQ-ulZPGbo0RDGbzM3Q/edit?usp=drive_web">https://docs.google.com/spreadsheets/d/1OvDq4_BtbR6nSnnHnjD5hVC3HQ-ulZPGbo0RDGbzM3Q/edit?usp=drive_web</a>,
downloaded April 14, 2015.
</p>


<h3>References</h3>

<p>Rick Wicklin,
<a href="http://blogs.sas.com/content/iml/2015/03/30/visualizing-airline-crashes.html">http://blogs.sas.com/content/iml/2015/03/30/visualizing-airline-crashes.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AirCrash)
aircrash.tab &lt;- xtabs(~Phase + Cause, data=AirCrash)
mosaic(aircrash.tab, shade=TRUE)

# fix label overlap
mosaic(aircrash.tab, shade=TRUE,
       labeling_args=list(rot_labels=c(30, 30, 30, 30)))

# reorder by Phase
phase.ord &lt;- rev(c(3,4,1,2,5))
mosaic(aircrash.tab[phase.ord,], shade=TRUE,
       labeling_args=list(rot_labels=c(30, 30, 30, 30)),
       offset_varnames=0.5)

# reorder by frequency
phase.ord &lt;- order(rowSums(aircrash.tab), decreasing=TRUE)
cause.ord &lt;- order(colSums(aircrash.tab), decreasing=TRUE)
mosaic(aircrash.tab[phase.ord,cause.ord], shade=TRUE,
       labeling_args=list(rot_labels=c(30, 30, 30, 30)))


library(ca)
aircrash.ca &lt;- ca(aircrash.tab)
plot(aircrash.ca)
</code></pre>

<hr>
<h2 id='Alligator'>
Alligator Food Choice
</h2><span id='topic+Alligator'></span>

<h3>Description</h3>

<p>The Alligator data, from Agresti (2002), comes from a study of the primary food choices of alligators 
in four Florida lakes. Researchers classified the stomach contents of 219 captured alligators into five categories: 
Fish (the most common primary food choice), Invertebrate (snails, insects, crayfish, etc.), 
Reptile (turtles, alligators), Bird, and Other (amphibians, plants, household pets, stones, and other debris).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Alligator)</code></pre>


<h3>Format</h3>

<p>A frequency data frame with 80 observations on the following 5 variables.
</p>

<dl>
<dt><code>lake</code></dt><dd><p>a factor with levels <code>George</code> <code>Hancock</code> <code>Oklawaha</code> <code>Trafford</code></p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>female</code> <code>male</code></p>
</dd>
<dt><code>size</code></dt><dd><p>alligator size, a factor with levels <code>large</code> (&gt;2.3m) <code>small</code> (&lt;=2.3m)</p>
</dd>
<dt><code>food</code></dt><dd><p>primary food choice, a factor with levels <code>bird</code> <code>fish</code> <code>invert</code> <code>other</code> <code>reptile</code></p>
</dd>
<dt><code>count</code></dt><dd><p>cell frequency, a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The table contains a fair number of 0 counts.
</p>
<p><code>food</code> is the response variable.  <code>fish</code> is the most frequent choice, and often
taken as a baseline category in multinomial response models.
</p>


<h3>Source</h3>

<p>Agresti, A. (2002). <em>Categorical Data Analysis</em>, New York: Wiley, 2nd Ed., Table 7.1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Alligator)

# change from frequency data.frame to table
allitable &lt;- xtabs(count ~ lake + sex + size + food, data=Alligator)
# Agresti's Table 7.1
structable(food ~ lake + sex + size, allitable)


plot(allitable, shade=TRUE)

# mutual independence model
mosaic(~ food + lake + size, allitable, shade=TRUE)

# food jointly independent of lake and size
mosaic(~ food + lake + size, allitable, shade=TRUE, 
       expected = ~lake:size + food)

if (require(nnet)) {
	# multinomial logit model
	mod1 &lt;- multinom(food ~ lake + size + sex, data=Alligator, weights=count)
}

</code></pre>

<hr>
<h2 id='Asbestos'>
Effect of Exposure to Asbestos
</h2><span id='topic+Asbestos'></span>

<h3>Description</h3>

<p>A two-way
contingency table formed from the cross-classification of
the number of years of occupational exposure to asbestos and
the diagnosed severity of asbestosis of 1117 New York workers.
Asbestosis is a chronic lung disease that results in the lung
tissue being scared due to contact with the fibers which can
lead to severe breathing difficulties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Asbestos")</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:5, 1:4] 310 212 21 25 7 36 158 35 102 35 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ exposure: chr [1:5] &quot;0-9&quot; &quot;10-19&quot; &quot;20-29&quot; &quot;30-39&quot; ...
..$ grade   : chr [1:4] &quot;None&quot; &quot;Grade 1&quot; &quot;Grade 2&quot; &quot;Grade 3&quot;
</p>


<h3>Details</h3>

<p><code>exposure</code> and <code>grade</code> should be regarded as ordered factors.
Beh and Lombardo (2022) use this data to illustrate a polynomial
biplot for ordered categories.
</p>
<p>The data summarized here was studied by Beh and Smith (2011) and
comes from the original data collected and published by Selikoff
(1981) who examined the link between asbestos exposure and
asbestosis severity in 1963.
</p>


<h3>Source</h3>

<p>Beh, E. J. &amp; Lombardo, R. (2022). Features of the Polynomial Biplot for
Ordered Contingency Tables, 
<em>Journal of Computational and Graphical Statistics</em>, 31:2, 403-412,
DOI: 10.1080/10618600.2021.1990773, Table 1.
</p>


<h3>References</h3>

<p>Beh, E. J., and D. R. Smith (2011b), Real World Occupational Epidemiology, Part 2: A Visual Interpretation of Statistical Significance, 
<em>Archives of Environmental &amp; Occupational Health</em>, <b>66</b>, 245-248.
</p>
<p>Selikoff, I. J. (1981), Household Risks With Inorganic Fibers,
<em>Bulletin of the New York Academy of Medicine</em>, <b>57</b>, 947-961.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Asbestos)
# mosaic plot
vcd::mosaic(Asbestos, shade=TRUE, legend=FALSE)

# do the correspondence analysis
library(ca)
Asbestos.ca &lt;- ca(Asbestos) 

plot(Asbestos.ca, lines=TRUE) 

</code></pre>

<hr>
<h2 id='Bartlett'>Bartlett Data on Plum Root Cuttings</h2><span id='topic+Bartlett'></span>

<h3>Description</h3>

<p>In an experiment to investigate the effect of cutting length (two levels) and planting time (two levels) 
on the survival of plum root cuttings, 240 cuttings were planted for each of the 2 x 2 combinations of these factors, 
and their survival was later recorded. 
</p>
<p>Bartlett (1935) used these data to illustrate a method for testing for no three-way interaction in a contingency table.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Bartlett)
</code></pre>


<h3>Format</h3>

<p>A 3-dimensional array resulting from cross-tabulating 3 variables for   960 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name          </td><td style="text-align: left;"> Levels                </td>
</tr>
<tr>
 <td style="text-align: right;">
    1  </td><td style="text-align: left;"> <code>Alive</code>  </td><td style="text-align: left;"> <code>"Alive", "Dead"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2  </td><td style="text-align: left;"> <code>Time</code>   </td><td style="text-align: left;"> <code>"Now", "Spring"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    3  </td><td style="text-align: left;"> <code>Length</code> </td><td style="text-align: left;"> <code>"Long", "Short"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>


<p>Hand, D. and Daly, F. and Lunn, A. D.and McConway, K. J. and Ostrowski, E. (1994).
<em>A Handbook of Small Data Sets</em>.  London: Chapman &amp; Hall, p. 15, # 19.
</p>


<h3>References</h3>


<p>Bartlett, M. S. (1935).
Contingency Table Interactions 
<em>Journal of the Royal Statistical Society</em>, Supplement, 1935, 2, 248-252.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bartlett)

# measures of association
assocstats(Bartlett)
oddsratio(Bartlett)

# Test models

## Independence
MASS::loglm(formula = ~Alive + Time + Length, data = Bartlett)

## No three-way association
MASS::loglm(formula = ~(Alive + Time + Length)^2, data = Bartlett)

# Use woolf_test() for a formal test of homogeneity of odds ratios
vcd::woolf_test(Bartlett)


# Plots
fourfold(Bartlett, mfrow=c(1,2))

mosaic(Bartlett, shade=TRUE)
pairs(Bartlett, gp=shading_Friendly)
</code></pre>

<hr>
<h2 id='blogits'>
Bivariate Logits and Log Odds Ratio
</h2><span id='topic+blogits'></span>

<h3>Description</h3>

<p>This function calculates the log odds and log odds ratio for
two binary responses classified by one or more stratifying
variables.
</p>
<p>It is useful for plotting the results of bivariate logistic regression
models, such as those fit using <code><a href="VGAM.html#topic+vglm">vglm</a></code> in the
<span class="pkg">VGAM</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blogits(Y, add, colnames, row.vars, rev=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blogits_+3A_y">Y</code></td>
<td>

<p>A four-column matrix or data frame whose columns correspond to the 2 x 2
combinations of two binary responses. 
</p>
</td></tr>
<tr><td><code id="blogits_+3A_add">add</code></td>
<td>

<p>Constant added to all cells to allow for zero frequencies.  The default
is 0.5 if <code>any(Y)==0</code> and 0 otherwise.
</p>
</td></tr>
<tr><td><code id="blogits_+3A_colnames">colnames</code></td>
<td>

<p>Names for the columns of the results. The default is 
<code>c("logit1", "logit2", "logOR")</code>.  If less than three
names are supplied, the remaining ones are filled in from the default.
</p>
</td></tr>
<tr><td><code id="blogits_+3A_row.vars">row.vars</code></td>
<td>

<p>A data frame or matrix giving the factor levels of one or more factors
corresponding to the rows of <code>Y</code> 
</p>
</td></tr>
<tr><td><code id="blogits_+3A_rev">rev</code></td>
<td>
<p>A logical, indicating whether the order of the columns in <code>Y</code>
should be reversed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two binary variables with levels 0,1 the logits are calculated 
assuming the columns in <code>Y</code> are given in the order
11, 10, 01, 00, so the logits give the log odds of the 1 response
compared to 0.  
If this is not the case, either use <code>rev=TRUE</code> or supply
<code>Y[,4:1]</code> as the first argument.
</p>


<h3>Value</h3>

<p>A data frame with <code>nrow(Y)</code> rows and <code>3 + ncol(row.vars)</code> columns
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Friendly, M. and Meyer, D. (2016). 
<em>Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data</em>. 
Boca Raton, FL: Chapman &amp; Hall/CRC. <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+vglm">vglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Toxaemia)
tox.tab &lt;- xtabs(Freq~class + smoke + hyper + urea, Toxaemia)

# reshape to 4-column matrix
toxaemia &lt;- t(matrix(aperm(tox.tab), 4, 15))
colnames(toxaemia) &lt;- c("hu", "hU", "Hu", "HU")
rowlabs &lt;- expand.grid(smoke=c("0", "1-19", "20+"), class=factor(1:5))
toxaemia &lt;- cbind(toxaemia, rowlabs)

# logits for H and U
logitsTox &lt;- blogits(toxaemia[,4:1], 
                     add=0.5, 
                     colnames=c("logitH", "logitW"), 
                     row.vars=rowlabs)
logitsTox

</code></pre>

<hr>
<h2 id='Burt'>
Burt (1950) Data on Hair, Eyes, Head and Stature
</h2><span id='topic+Burt'></span>

<h3>Description</h3>

<p>Cyril Burt (1950) gave these data, on a sample of 100 people from Liverpool,
to illustrate the application of a method of factor analysis (later
called multiple correspondence analysis) applied to 
categorical data.
</p>
<p>He presented these data initially in the form that has come to be called a &quot;Burt table&quot;,
giving the univariate and bivariate frequencies for an n-way frequency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Burt")</code></pre>


<h3>Format</h3>

<p>A frequency data frame (representing a 3 x 3 x 2 x 2 frequency table) with 36 cells on the following 5 variables.
</p>

<dl>
<dt><code>Hair</code></dt><dd><p>hair color, a factor with levels <code>Fair</code> <code>Red</code> <code>Dark</code></p>
</dd>
<dt><code>Eyes</code></dt><dd><p>eye color, a factor with levels <code>Light</code> <code>Mixed</code> <code>Dark</code></p>
</dd>
<dt><code>Head</code></dt><dd><p>head shape, a factor with levels <code>Narrow</code> <code>Wide</code></p>
</dd>
<dt><code>Stature</code></dt><dd><p>height, a factor with levels <code>Tall</code> <code>Short</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Burt says: &quot;In all, 217 individuals were examined, about two-thirds of them males.
But, partly to simplify the calculations and partly because the later observations were rather more trustworthy, 
I shall here restrict my analysis to the data obtained from the last hundred males in the series.&quot;
</p>
<p><code>Head</code> and <code>Stature</code> reflect a binary coding where people are classified
according to whether they are below or above the average for the population.
</p>


<h3>Source</h3>

<p>Burt, C. (1950). The factorial analysis of qualitative data, 
<em>British Journal of Statistical Psychology</em>, <b>3</b>(3), 166-185.
Table IX.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Burt)
mosaic(Freq ~ Hair + Eyes + Head + Stature, data=Burt, shade=TRUE)

#or
burt.tab &lt;- xtabs(Freq ~ Hair + Eyes + Head + Stature, data=Burt)
mosaic(burt.tab, shade=TRUE)
</code></pre>

<hr>
<h2 id='Caesar'>Risk Factors for Infection in Caesarian Births</h2><span id='topic+Caesar'></span>

<h3>Description</h3>

<p>Data from infection from birth by Caesarian section, classified by <code>Risk</code> (two levels), 
whether <code>Antibiotics</code> were used (two levels) and whether the Caesarian section was <code>Planned</code> or not.  
The outcome is <code>Infection</code> (three levels).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Caesar)
</code></pre>


<h3>Format</h3>

<p>A 4-dimensional array resulting from cross-tabulating 4 variables for   251 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1</td><td style="text-align: left;"> <code>Infection</code></td><td style="text-align: left;"> <code>"Type 1", "Type 2", "None"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2</td><td style="text-align: left;"> <code>Risk</code></td><td style="text-align: left;"> <code>"Yes", "No"</code> (presence of risk factors)</td>
</tr>
<tr>
 <td style="text-align: right;">
    3</td><td style="text-align: left;"> <code>Antibiotics</code></td><td style="text-align: left;"> <code>"Yes", "No"</code> (were antibiotics given?)</td>
</tr>
<tr>
 <td style="text-align: right;">
    4</td><td style="text-align: left;"> <code>Planned</code></td><td style="text-align: left;"> <code>"Yes", "No"</code> (was the C section planned?)</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p><code>Infection</code> is regarded as the response variable here. 
There are quite a few 0 cells here, particularly when  <code>Risk</code>
is absent and the Caesarian section was unplanned.
Should these be treated as structural or sampling zeros?
</p>


<h3>Source</h3>


<p>Fahrmeir, L. &amp; Tutz, G. (1994).
Multivariate Statistical Modelling Based on Generalized Linear Models 
New York: Springer Verlag, Table 1.1.
</p>


<h3>See Also</h3>

<p><code><a href="Fahrmeir.html#topic+caesar">caesar</a></code> for the same data recorded as a frequency data frame
with other variables.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Caesar)
#display table;  note that there are quite a few 0 cells
structable(Caesar)
require(MASS)

# baseline model, Infection as response
Caesar.mod0 &lt;- loglm(~Infection + (Risk*Antibiotics*Planned), 
                     data=Caesar)

# NB: Pearson chisq cannot be computed due to the 0 cells
Caesar.mod0

mosaic(Caesar.mod0, main="Baseline model")

# Illustrate handling structural zeros
zeros &lt;- 0+ (Caesar &gt;0)
zeros[1,,1,1] &lt;- 1
structable(zeros)

# fit model excluding possible structural zeros
Caesar.mod0s &lt;- loglm(~Infection + (Risk*Antibiotics*Planned), 
                      data=Caesar, 
	                    start=zeros)
Caesar.mod0s

anova(Caesar.mod0, Caesar.mod0s, test="Chisq")

mosaic (Caesar.mod0s)

# what terms to add?
add1(Caesar.mod0, ~.^2, test="Chisq")

# add Association of Infection:Antibiotics
Caesar.mod1 &lt;- update(Caesar.mod0, ~ . + Infection:Antibiotics)
anova(Caesar.mod0, Caesar.mod1, test="Chisq")

mosaic(Caesar.mod1, 
       gp=shading_Friendly, 
       main="Adding Infection:Antibiotics")

</code></pre>

<hr>
<h2 id='Cancer'>Survival of Breast Cancer Patients</h2><span id='topic+Cancer'></span>

<h3>Description</h3>

<p>Three year survival of 474 breast cancer patients according to nuclear grade and diagnostic center.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Cancer)
</code></pre>


<h3>Format</h3>

<p>A 3-dimensional array resulting from cross-tabulating 3 variables for   474 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1</td><td style="text-align: left;"> <code>Survival</code></td><td style="text-align: left;"> <code>"Died", "Surv"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2</td><td style="text-align: left;"> <code>Grade</code></td><td style="text-align: left;"> <code>"Malignant", "Benign"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    3</td><td style="text-align: left;"> <code>Center</code></td><td style="text-align: left;"> <code>"Boston", "Glamorgan"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>



<p>Lindsey, J. K. (1995). 
Analysis of Frequency and Count Data 
Oxford, UK: Oxford University Press. p. 38, Table 2.5.
</p>
<p>Whittaker, J. (1990)
Graphical Models in Applied Multivariate Statistics
New York: John Wiley and Sons, p. 220.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Cancer)

MASS::loglm(~Survival + Grade + Center, data = Cancer)

vcd::mosaic(Cancer, shade=TRUE)
</code></pre>

<hr>
<h2 id='CMHtest'>
Generalized Cochran-Mantel-Haenszel Tests
</h2><span id='topic+CMHtest'></span><span id='topic+CMHtest.formula'></span><span id='topic+CMHtest.default'></span><span id='topic+Cochran+20Mantel+20Haenszel+20test'></span><span id='topic+print.CMHtest'></span>

<h3>Description</h3>

<p>Provides generalized Cochran-Mantel-Haenszel tests of association of two possibly ordered factors, 
optionally stratified other factor(s).  With strata, <code>CMHtest</code> calculates these tests for
each level of the stratifying variables and also provides overall tests controlling for the
strata.
</p>
<p>For ordinal factors, more powerful tests than the test for general association
(independence) are obtained by assigning scores to the row and column categories. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CMHtest(x, ...)

## S3 method for class 'formula'
CMHtest(formula, data = NULL, subset = NULL, na.action = NULL, ...)

## Default S3 method:
CMHtest(x, 
   strata = NULL, 
   rscores = 1:R, 
   cscores = 1:C, 
   types = c("cor", "rmeans", "cmeans", "general"), 
   overall=FALSE, 
   details=overall, ...)

## S3 method for class 'CMHtest'
print(x, digits = max(getOption("digits") - 2, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CMHtest_+3A_x">x</code></td>
<td>

<p>A 2+ way contingency table in array form, or a class <code>"table"</code> object
with optional category labels specified in the dimnames(x) attribute.
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the variables used to create a contingency table from <code>data</code>.
This should be a one-sided formula when <code>data</code> is in array form, and a two-sided formula
with a response <code>Freq</code> if <code>data</code> is a data frame with a cell frequency variable. 
For convenience, conditioning formulas can be specified indicating strata.
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_data">data</code></td>
<td>
<p>either a data frame, or an object of class <code>"table"</code> or <code>"ftable"</code>.
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s. 
Ignored if <code>data</code> is a contingency table
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_strata">strata</code></td>
<td>

<p>For a 3- or higher-way table, the names or numbers of the factors
to be treated as strata.  By default, the first 2 factors are treated
as the main table variables, and all others considered stratifying factors.
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_rscores">rscores</code></td>
<td>

<p>Row scores.  Either a set of numbers (typically integers, <code>1:R</code>)
or the string <code>"midrank"</code> for standardized midrank scores,
or <code>NULL</code> to exclude tests that depend on row scores.
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_cscores">cscores</code></td>
<td>

<p>Column scores. Same as for row scores.
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_types">types</code></td>
<td>

<p>Types of CMH tests to compute: Any one or more of 
<code>c("cor", "cmeans", "rmeans", "general")</code>,
or <code>"ALL"</code> for all of these.
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_overall">overall</code></td>
<td>

<p>logical. Whether to calculate overall tests, controlling for
the stratifying factors. 
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_details">details</code></td>
<td>

<p>logical.  Whether to include computational details in the result
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_...">...</code></td>
<td>

<p>Other arguments passed to default method.
</p>
</td></tr>
<tr><td><code id="CMHtest_+3A_digits">digits</code></td>
<td>

<p>Digits to print.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard <code class="reqn">\chi^2</code> tests for association in a two-way table
treat both table factors as nominal (unordered) categories.
When one or both factors of a two-way table are
quantitative or ordinal, more powerful tests of association
may be obtained by taking ordinality into account using
row and or column scores to test for linear trends or differences
in row or column means.
</p>
<p>The CMH analysis for a two-way table produces generalized Cochran-Mantel-Haenszel statistics
(Landis etal., 1978).
</p>
<p>These include the CMH <b>correlation</b> statistic (<code>"cor"</code>),
treating both factors as ordered.
For a given statum, with equally spaced row and column scores,
this CMH statistic reduces to <code class="reqn">(n-1) r^2</code>,
where <code class="reqn">r</code> is the Pearson correlation between X and Y.
With <code>"midrank"</code> scores, this CMH statistic is analogous
to <code class="reqn">(n-1) r_S^2</code>, using the Spearman rank correlation.
</p>
<p>The <b>ANOVA</b> (row mean scores and column mean scores) statistics,
treat the columns and rows respectively as ordinal,
and are sensitive to mean shifts over columns or rows.
These are transforms of the <code class="reqn">F</code> statistics from one-way ANOVAs
with equally spaced scores and to Kruskal-Wallis tests with
<code>"midrank"</code> scores. 
</p>
<p>The CMH <b>general</b> association statistic treat both factors as unordered,
and give a test closely related to the Pearson <code class="reqn">\chi^2</code> test.
When there is more than one stratum, the overall general CMH statistic
gives a stratum-adjusted Pearson <code class="reqn">\chi^2</code>,
equivalent to what is calculated by <code><a href="stats.html#topic+mantelhaen.test">mantelhaen.test</a></code>.
</p>
<p>For a 3+ way table, one table of CMH tests is produced for each 
combination of the factors identified as <code>strata</code>.
If <code>overall=TRUE</code>, an additional table is calculated for
the same two primary variables, controlling for (pooling over)
the <code>strata</code> variables.
</p>
<p>These overall tests implicitly assume no interactions  between the 
primary variables and the strata and they will have low power in the
presence of interactions.
</p>


<h3>Value</h3>

<p>An object of class <code>"CMHtest"</code> , a list with the following 4 components:
</p>
<table>
<tr><td><code>table</code></td>
<td>
<p>A matrix containing the test statistics, with columns
<code>Chisq</code>, <code>Df</code> and <code>Prob</code> </p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>The names of the table row and column variables</p>
</td></tr>
<tr><td><code>rscore</code></td>
<td>
<p>Row scores</p>
</td></tr>
<tr><td><code>cscore</code></td>
<td>
<p>Column scores</p>
</td></tr>
</table>
<p>If <code>details==TRUE</code>, additional components are included.
</p>
<p>If there are strata, the result is a list of <code>"CMHtest"</code> objects.
If <code>overall=TRUE</code> another component, labeled <code>ALL</code>
is appended to the list.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Stokes, M. E. &amp; Davis, C. S.  &amp; Koch, G., (2000). 
<em>Categorical Data Analysis using the SAS System</em>, 2nd Ed.,
Cary, NC: SAS Institute,
pp 74-75, 92-101, 124-129.
Details of the computation are given at:
<a href="http://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_freq_a0000000648.htm">http://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_freq_a0000000648.htm</a>
</p>
<p>Cochran, W. G. (1954), Some Methods for Strengthening the Common <code class="reqn">\chi^2</code> Tests, 
<em>Biometrics</em>, 10, 417-451. 
</p>
<p>Landis, R. J., Heyman, E. R., and Koch, G. G. (1978). 
Average Partial Association in Three-way Contingency Tables: 
A Review and Discussion of Alternative Tests, 
<em>International Statistical Review</em>, <b>46</b>, 237-254.
</p>
<p>Mantel, N. (1963), Chi-square Tests with One Degree of Freedom: Extensions of the Mantel-Haenszel Procedure,&quot;
<em>Journal of the American Statistical Association</em>, 58, 690-700. 
</p>


<h3>See Also</h3>

<p><code><a href="coin.html#topic+cmh_test">cmh_test</a></code> provides the CMH test of general association;
<code><a href="coin.html#topic+lbl_test">lbl_test</a></code> provides the CMH correlation test of linear by linear association.
</p>
<p><code><a href="stats.html#topic+mantelhaen.test">mantelhaen.test</a></code> provides the overall general
Cochran-Mantel-Haenszel chi-squared test of the null that two nominal variables are conditionally independent 
in each stratum, assuming that there is no three-way interaction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(JobSat, package="vcdExtra")
CMHtest(JobSat)
CMHtest(JobSat, rscores="midrank", cscores="midrank")

# formula interface
CMHtest(~ ., data=JobSat)

# A 3-way table (both factors ordinal)
data(MSPatients, package="vcd")
CMHtest(MSPatients)


# also calculate overall tests, controlling for Patient
CMHtest(MSPatients, overall = TRUE)
# compare with mantelhaen.test
mantelhaen.test(MSPatients)

# formula interface
CMHtest(~ ., data = MSPatients, overall = TRUE)

# using a frequency data.frame
CMHtest(xtabs(Freq~ses + mental, data = Mental))
# or, more simply
CMHtest(Freq~ses + mental, data = Mental)

# conditioning formulae
CMHtest(Freq~right + left | gender, data = VisualAcuity)
 
CMHtest(Freq ~ attitude + memory | education + age, data = Punishment)


# Stokes etal, Table 5.1, p 92: two unordered factors
parties &lt;- matrix(
	c(221, 160, 360, 140,
	  200, 291, 160, 311,
	  208, 106, 316, 97), 
	nrow=3, ncol=4, 
	byrow=TRUE)
dimnames(parties) &lt;- list(party=c("Dem", "Indep", "Rep"),
             neighborhood=c("Bayside", "Highland", "Longview", "Sheffield"))
CMHtest(parties, rscores=NULL, cscores=NULL)

# compare with Pearson chisquare
chisq.test(parties)
</code></pre>

<hr>
<h2 id='collapse.table'>Collapse Levels of a Table</h2><span id='topic+collapse.table'></span>

<h3>Description</h3>

<p>Collapse (or re-label) variables in a
a contingency table, array or <code>ftable</code> object by re-assigning levels of the table variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse.table(table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse.table_+3A_table">table</code></td>
<td>
<p>A <code><a href="base.html#topic+table">table</a></code>, <code><a href="base.html#topic+array">array</a></code> or <code><a href="stats.html#topic+ftable">ftable</a></code> object</p>
</td></tr>
<tr><td><code id="collapse.table_+3A_...">...</code></td>
<td>
<p> A collection of one or more assignments of factors of the table to
a list of levels </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the <code>...</code> arguments must be of the form 
<code>variable = levels</code>, where <code>variable</code> is the name of one of the table
dimensions, and <code>levels</code> is a character or numeric vector of length equal
to the corresponding dimension of the table.
</p>


<h3>Value</h3>

<p>A <code>xtabs</code> and <code>table</code> object, representing the original table with
one or more of its factors collapsed or rearranged into other levels.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+expand.dft">expand.dft</a></code> expands a frequency data frame to case form.
</p>
<p><code><a href="base.html#topic+margin.table">margin.table</a></code> &quot;collapses&quot; a table in a different way, by
summing over table dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some sample data in table form
sex &lt;- c("Male", "Female")
age &lt;- letters[1:6]
education &lt;- c("low", 'med', 'high')
data &lt;- expand.grid(sex=sex, age=age, education=education)
counts &lt;- rpois(36, 100) 
data &lt;- cbind(data, counts)
t1 &lt;- xtabs(counts ~ sex + age + education, data=data)
structable(t1)

##                  age   a   b   c   d   e   f
## sex    education                            
## Male   low           119 101 109  85  99  93
##        med            94  98 103 108  84  84
##        high           81  88  96 110 100  92
## Female low           107 104  95  86 103  96
##        med           104  98  94  95 110 106
##        high           93  85  90 109  99  86


# collapse age to 3 levels
t2 &lt;- collapse.table(t1, age=c("A", "A", "B", "B", "C", "C"))
structable(t2)

##                  age   A   B   C
## sex    education                
## Male   low           220 194 192
##        med           192 211 168
##        high          169 206 192
## Female low           211 181 199
##        med           202 189 216
##        high          178 199 185


# collapse age to 3 levels and pool education: "low" and "med" to "low"
t3 &lt;- collapse.table(t1, age=c("A", "A", "B", "B", "C", "C"), 
    education=c("low", "low", "high"))
structable(t3)

##                  age   A   B   C
## sex    education                
## Male   low           412 405 360
##        high          169 206 192
## Female low           413 370 415
##        high          178 199 185



# change labels for levels of education to 1:3
t4 &lt;- collapse.table(t1,  education=1:3)
structable(t4)

structable(t4)
##                  age   a   b   c   d   e   f
## sex    education                            
## Male   1             119 101 109  85  99  93
##        2              94  98 103 108  84  84
##        3              81  88  96 110 100  92
## Female 1             107 104  95  86 103  96
##        2             104  98  94  95 110 106
##        3              93  85  90 109  99  86



</code></pre>

<hr>
<h2 id='Cormorants'>
Advertising Behavior by Males Cormorants
</h2><span id='topic+Cormorants'></span>

<h3>Description</h3>

<p>Male double-crested cormorants use advertising behavior to attract females for breeding.
In this study by Meagan McRae (2015), cormorants were observed two or three times a week
at six stations in a tree-nesting colony
for an entire season, April 10, 2014-July 10, 2014.
The number of advertising birds was counted and these observations were classified
by characteristics of the trees and nests.
</p>
<p>The goal is to determine how this behavior varies temporally over the season and spatially,
as well as with characteristics of nesting sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Cormorants")</code></pre>


<h3>Format</h3>

<p>A data frame with 343 observations on the following 8 variables.
</p>

<dl>
<dt><code>category</code></dt><dd><p>Time of season, divided into 3 categories based on breeding chronology, an ordered factor with levels <code>Pre</code> &lt; <code>Incubation</code> &lt; <code>Chicks Present</code></p>
</dd>
<dt><code>week</code></dt><dd><p>Week of the season</p>
</dd>
<dt><code>station</code></dt><dd><p>Station of observations on two different peninsulas in a park, a factor with levels <code>B1</code> <code>B2</code> <code>C1</code> <code>C2</code> <code>C3</code> <code>C4</code></p>
</dd>
<dt><code>nest</code></dt><dd><p>Type of nest, an ordered factor with levels <code>no</code> &lt; <code>partial</code> &lt; <code>full</code></p>
</dd>
<dt><code>height</code></dt><dd><p>Relative height of bird in the tree, an ordered factor with levels <code>low</code> &lt; <code>mid</code> &lt; <code>high</code></p>
</dd>
<dt><code>density</code></dt><dd><p>Number of other nests in the tree, an ordered factor with levels <code>zero</code> &lt; <code>few</code> &lt; <code>moderate</code> &lt; <code>high</code></p>
</dd>
<dt><code>tree_health</code></dt><dd><p>Health of the tree the bird is advertising in, a factor with levels <code>dead</code> <code>healthy</code></p>
</dd>
<dt><code>count</code></dt><dd><p>Number of birds advertising, a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Observations were made on only 2 days in weeks 3 and 4, but 3 days in all other weeks.
One should use log(days) as an offset, so that the response measures rate.
</p>
<p><code>Cormorants$days &lt;- ifelse(Cormorants$week %in% 3:4, 2, 3)</code>
</p>


<h3>Source</h3>

<p>McRae, M. (2015).
Spatial, Habitat and Frequency Changes in Double-crested Cormorant Advertising Display in a  Tree-nesting Colony.
Unpublished MA project, Environmental Studies, York University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Cormorants)
str(Cormorants)

if (require("ggplot2")) {
  print(ggplot(Cormorants, aes(count)) + 
    geom_histogram(binwidth=0.5) + 
	  labs(x="Number of birds advertising"))

# Quick look at the data, on the log scale, for plots of `count ~ week`, 
#   stratified by something else.

  print(ggplot(Cormorants, aes(week, count, color=height)) + 
    geom_jitter() +
	  stat_smooth(method="loess", size=2) + 
	  scale_y_log10(breaks=c(1,2,5,10)) +
	  geom_vline(xintercept=c(4.5, 9.5)))
}

# ### models using week 
fit1 &lt;-glm(count ~ week + station + nest + height + density + tree_health, 
           data=Cormorants,
           family =  poisson)

if (requireNamespace("car"))
  car::Anova(fit1)
  
# plot fitted effects
if (requireNamespace("effects"))
  plot(effects::allEffects(fit1))

</code></pre>

<hr>
<h2 id='Crossings'>Crossings Interaction of Factors</h2><span id='topic+Crossings'></span>

<h3>Description</h3>

<p>Given two ordered factors in a square, n x n frequency table, <code>Crossings</code>
creates an n-1 column matrix corresponding to different degrees of difficulty
in crossing from one level to the next, as described by Goodman (1972).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Crossings(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Crossings_+3A_...">...</code></td>
<td>

<p>Two factors
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For two factors of <code>n</code> levels, returns a binary indicator matrix
of <code>n*n</code> rows and <code>n-1</code> columns.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly and Heather Turner</p>


<h3>References</h3>

<p>Goodman, L. (1972).  Some multiplicative models for the analysis of cross-classified data.
In: <em>Proceedings of the Sixth Berkeley Symposium on Mathematical Statistics and Probability</em>,
Berkeley, CA: University of California Press, pp. 649-696.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, 
<code><a href="gnm.html#topic+gnm">gnm</a></code> for model fitting functions for frequency tables
</p>
<p><code><a href="gnm.html#topic+Diag">Diag</a></code>, 
<code><a href="gnm.html#topic+Mult">Mult</a></code>, 
<code><a href="gnm.html#topic+Symm">Symm</a></code>, 
<code><a href="gnm.html#topic+Topo">Topo</a></code> 
for similar extensions to terms in model formulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Hauser79)
# display table
structable(~Father + Son, data=Hauser79)

hauser.indep &lt;- gnm(Freq ~ Father + Son, 
                    data=Hauser79, 
                    family=poisson)

hauser.CR &lt;- update(hauser.indep, 
                    ~ . + Crossings(Father,Son))
LRstats(hauser.CR)

hauser.CRdiag &lt;- update(hauser.indep, 
                        ~ . + Crossings(Father,Son) + Diag(Father,Son))
LRstats(hauser.CRdiag)

</code></pre>

<hr>
<h2 id='cutfac'>
Cut a Numeric Variable to a Factor
</h2><span id='topic+cutfac'></span>

<h3>Description</h3>

<p><code>cutfac</code> acts like <code><a href="base.html#topic+cut">cut</a></code>,
dividing the range of <code>x</code> into intervals and
coding the values in <code>x</code> according in which interval they fall.
However, it gives nicer labels for the factor levels and 
by default chooses convenient breaks among the values based on deciles.
</p>
<p>It is particularly useful for plots in which one wants to make a
numeric variable discrete for the purpose of getting boxplots,
spinograms or mosaic plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutfac(x, breaks = NULL, q = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutfac_+3A_x">x</code></td>
<td>
<p>a numeric vector which is to be converted to a factor by cutting
</p>
</td></tr>
<tr><td><code id="cutfac_+3A_breaks">breaks</code></td>
<td>

<p>either a numeric vector of two or more unique cut points or a single number (greater than or equal to 2) giving the number of intervals into which <code>x</code> is to be cut.
</p>
</td></tr>
<tr><td><code id="cutfac_+3A_q">q</code></td>
<td>

<p>the number of quantile groups used to define <code>breaks</code>, if that has not been specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code><a href="base.html#topic+cut">cut</a></code> chooses breaks by equal lengths of the range of <code>x</code>,
whereas <code>cutfac</code> uses <code><a href="stats.html#topic+quantile">quantile</a></code> to choose breaks of roughly equal count.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+factor">factor</a></code> corresponding to <code>x</code> is returned
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis</p>


<h3>References</h3>

<p>Friendly, M. and Meyer, D. (2016). 
<em>Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data</em>. 
Boca Raton, FL: Chapman &amp; Hall/CRC. <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>, 
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(AER)) {
data("NMES1988", package="AER")
nmes &lt;- NMES1988[, c(1, 6:8, 13, 15, 18)]

plot(log(visits+1) ~ cutfac(chronic), 
  data = nmes,
  ylab = "Physician office visits (log scale)", 
  xlab = "Number of chronic conditions", main = "chronic")

plot(log(visits+1) ~ cutfac(hospital, c(0:2, 8)), 
  data = nmes,
  ylab = "Physician office visits (log scale)", 
  xlab = "Number of hospital stays", main = "hospital")
}


















</code></pre>

<hr>
<h2 id='CyclingDeaths'>
London Cycling Deaths
</h2><span id='topic+CyclingDeaths'></span>

<h3>Description</h3>

<p>A data frame containing the number of deaths of cyclists in London from 2005 through
2012 in each fortnightly period.  Aberdein &amp; Spiegelhalter (2013)
discuss these data in relation to the observation that six cyclists
died in London between Nov. 5 and Nov. 13, 2013. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CyclingDeaths)</code></pre>


<h3>Format</h3>

<p>A data frame with 208 observations on the following 2 variables.
</p>

<dl>
<dt><code>date</code></dt><dd><p>a Date</p>
</dd>
<dt><code>deaths</code></dt><dd><p>number of deaths, a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.data.gov.uk/dataset/cb7ae6f0-4be6-4935-9277-47e5ce24a11f/road-safety-data">https://www.data.gov.uk/dataset/cb7ae6f0-4be6-4935-9277-47e5ce24a11f/road-safety-data</a>,
STATS 19 data, 2005-2012, using the files
<code>Casualty0512.csv</code> and 
<code>Accidents0512.csv</code>
</p>


<h3>References</h3>

<p>Aberdein, Jody and Spiegelhalter, David (2013).
Have London's roads become more dangerous for cyclists?
<em>Significance</em>, 10(6), 46&ndash;48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CyclingDeaths)

plot(deaths ~ date, data=CyclingDeaths, 
  type="h", 
	lwd=3, 
	ylab="Number of deaths", 
	axes=FALSE)
axis(1, at=seq(as.Date('2005-01-01'), 
               by='years', 
               length.out=9), 
     labels=2005:2013)
axis(2, at=0:3)

# make a one-way frequency table
CyclingDeaths.tab &lt;- table(CyclingDeaths$deaths)

gf &lt;- goodfit(CyclingDeaths.tab)
gf
summary(gf)

rootogram(gf, xlab="Number of Deaths")
distplot(CyclingDeaths.tab)

# prob of 6 or more deaths in one fortnight
lambda &lt;- gf$par$lambda
ppois(5, lambda, lower.tail=FALSE)
</code></pre>

<hr>
<h2 id='datasets'>
Information on Data Sets in Packages
</h2><span id='topic+datasets'></span>

<h3>Description</h3>

<p>The <code><a href="utils.html#topic+data">data</a></code> function is used both to load data sets from packages, 
and give a display of the names and titles of data sets in one or more packages,
however it does not return a result that can be easily used to get additional
information about the nature of data sets in packages.
</p>
<p>The <code>datasets()</code> function is designed to produce a more useful summary
display of data sets in one or more packages.  It extracts the <code>class</code>
and dimension information (<code>dim</code> or codelength) of each item,
and formats these to provide additional descriptors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasets(package, 
        allClass=FALSE, 
        incPackage=length(package) &gt; 1,
        maxTitle=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datasets_+3A_package">package</code></td>
<td>
<p>a character vector giving the package(s) to look in</p>
</td></tr>
<tr><td><code id="datasets_+3A_allclass">allClass</code></td>
<td>
<p>a logical variable. Include all classes of the item (<code>TRUE</code>) or just the last class   
(<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="datasets_+3A_incpackage">incPackage</code></td>
<td>
<p>include the package name in result?</p>
</td></tr>
<tr><td><code id="datasets_+3A_maxtitle">maxTitle</code></td>
<td>
<p>maximum length of data set Title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The requested packages must be installed, and are silently loaded in order
to extract <code>class</code> and size information.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> whose rows correspond to data sets found in <code>package</code>.
</p>
<p>The columns (for a single package) are:
</p>
<table>
<tr><td><code>Item</code></td>
<td>
<p>data set name, a character variable</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>class, the object class of the data set, typically one of <code>"data.frame"</code>, <code>"table"</code>, <code>"array"</code> ...</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>an abbreviation of the dimensions of the data set, in a form like <code>"36x3"</code> for a data.frame or matrix with 36 rows and 3 columns.</p>
</td></tr>
<tr><td><code>Title</code></td>
<td>
<p>data set title</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In Rmd documents, 'datasets(&quot;package&quot;) |&gt; knitr::kable()' can be used to create
a more pleasing display.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly, with R-help from Curt Seeliger 
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+data">data</a></code>, <code><a href="knitr.html#topic+kable">kable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datasets("vcdExtra")
# datasets(c("vcd", "vcdExtra"))
datasets("datasets", maxTitle=50)

# just list dataset names in a package
datasets("vcdExtra")[,"Item"]
datasets("vcd")[,"Item"]

</code></pre>

<hr>
<h2 id='DaytonSurvey'>Dayton Student Survey on Substance Use</h2><span id='topic+DaytonSurvey'></span>

<h3>Description</h3>

<p>This data, from Agresti (2002), Table 9.1, gives the result of a 1992
survey in Dayton Ohio of  2276 high school seniors on
whether they had ever used 
alcohol, cigarettes and marijuana.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DaytonSurvey)</code></pre>


<h3>Format</h3>

<p>A frequency data frame with 32 observations on the following 6 variables.
</p>

<dl>
<dt><code>cigarette</code></dt><dd><p>a factor with levels <code>Yes</code> <code>No</code></p>
</dd>
<dt><code>alcohol</code></dt><dd><p>a factor with levels <code>Yes</code> <code>No</code></p>
</dd>
<dt><code>marijuana</code></dt><dd><p>a factor with levels <code>Yes</code> <code>No</code></p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>female</code> <code>male</code></p>
</dd>
<dt><code>race</code></dt><dd><p>a factor with levels <code>white</code> <code>other</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Agresti uses the letters G (<code>sex</code>), R (<code>race</code>),
A (<code>alcohol</code>), C (<code>cigarette</code>), M (<code>marijuana</code>) to refer to the table variables,
and this usage is followed in the examples below.
</p>
<p>Background variables include <code>sex</code> and <code>race</code> of the
respondent (GR), typically treated as explanatory, so that any
model for the full table should include the term <code>sex:race</code>.
Models for the reduced table, collapsed over <code>sex</code> and <code>race</code>
are not entirely unreasonable, but don't permit the estimation
of the effects of these variables on the responses.
</p>
<p>The full 5-way table contains a number of cells with counts of 0 or 1,
as well as many cells with large counts, and even the ACM table
collapsed over GR has some small cell counts.  Consequently, 
residuals for these models in mosaic displays are best represented
as standardized (adjusted) residuals.
</p>


<h3>Source</h3>

<p>Agresti, A. (2002). <em>Categorical Data Analysis</em>, 2nd Ed.,
New York: Wiley-Interscience, Table 9.1, p. 362.
</p>


<h3>References</h3>

<p>Thompson, L. (2009). <em>R (and S-PLUS) Manual to Accompany Agresti's Categorical Data</em>,
http://www.stat.ufl.edu/~aa/cda/Thompson_manual.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DaytonSurvey)

# mutual independence
mod.0  &lt;- glm(Freq ~ ., data=DaytonSurvey, family=poisson)   

# mutual independence + GR
mod.GR &lt;- glm(Freq ~ . + sex*race, data=DaytonSurvey, family=poisson)  
anova(mod.GR, test = "Chisq")

# all two-way terms
mod.all2way &lt;- glm(Freq ~ .^2, data=DaytonSurvey, family=poisson)  
anova(mod.all2way, test = "Chisq")

# compare models
LRstats(mod.0, mod.GR, mod.all2way)

# collapse over sex and race
Dayton.ACM &lt;- aggregate(Freq ~ cigarette+alcohol+marijuana, 
                        data=DaytonSurvey, 
                        FUN=sum)
Dayton.ACM
</code></pre>

<hr>
<h2 id='Depends'>
Dependencies of R Packages
</h2><span id='topic+Depends'></span>

<h3>Description</h3>

<p>This one-way table gives the type-token distribution of the number of
dependencies declared in 4983 packages listed on CRAN on January 17, 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Depends)</code></pre>


<h3>Format</h3>

<p>The format is a one-way frequency table of counts of packages with 0, 1, 2, ... dependencies.
</p>
<p>'table' int [1:15(1d)] 986 1347 993 685 375 298 155 65 32 19 ...
- attr(*, &quot;dimnames&quot;)=List of 1
..$ Depends: chr [1:15] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; ...
</p>


<h3>Source</h3>

<p>Using code from
<a href="https://blog.revolutionanalytics.com/2013/12/a-look-at-the-distribution-of-r-package-dependencies.html">https://blog.revolutionanalytics.com/2013/12/a-look-at-the-distribution-of-r-package-dependencies.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Depends)
plot(Depends, 
     xlab="Number of Dependencies", 
     ylab="Number of R Packages", 
     lwd=8)

# what type of distribution?
# Ord_plot can't classify this!
Ord_plot(Depends)

## Not run: 
# The code below, from Joseph Rickert, downloads and tabulates the data
p &lt;- as.data.frame(available.packages(),stringsAsFactors=FALSE)
names(p)

pkgs &lt;- data.frame(p[,c(1,4)])                  # Pick out Package names and Depends
row.names(pkgs) &lt;- NULL                         # Get rid of row names
pkgs &lt;- pkgs[complete.cases(pkgs[,2]),]         # Remove NAs

pkgs$Depends2 &lt;-strsplit(pkgs$Depends,",")      # split list of Depends
pkgs$numDepends &lt;- as.numeric(lapply(pkgs$Depends2,length)) # Count number of dependencies in list
zeros &lt;- c(rep(0,dim(p)[1] - dim(pkgs)[1]))     # Account for packages with no dependencies
Deps &lt;- as.vector(c(zeros,pkgs$numDepends))     # Set up to tablate
Depends &lt;- table(Deps)


## End(Not run)
</code></pre>

<hr>
<h2 id='Detergent'>Detergent preference data</h2><span id='topic+Detergent'></span>

<h3>Description</h3>

<p>Cross-classification of a sample of 1008 consumers according to 
(a) the softness of the laundry water used, (b) previous use of detergent Brand M, (c) the temperature of laundry water used and (d) expressed preference for Brand X or Brand M in a blind trial.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Detergent)
</code></pre>


<h3>Format</h3>

<p>A 4-dimensional array resulting from cross-tabulating 4 variables for  1008 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1</td><td style="text-align: left;"> <code>Temperature</code></td><td style="text-align: left;"> <code>"High", "Low"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2</td><td style="text-align: left;"> <code>M_User</code></td><td style="text-align: left;"> <code>"Yes", "No"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    3</td><td style="text-align: left;"> <code>Preference</code></td><td style="text-align: left;"> <code>"Brand X", "Brand M"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    4</td><td style="text-align: left;"> <code>Water_softness</code></td><td style="text-align: left;"> <code>"Soft", "Medium", "Hard"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>


<p>Fienberg, S. E. (1980).
<em>The Analysis of Cross-Classified Categorical Data</em>
Cambridge, MA: MIT Press, p. 71.
</p>


<h3>References</h3>


<p>Ries, P. N. &amp; Smith, H. (1963).
The use of chi-square for preference testing in multidimensional problems. 
<em>Chemical Engineering Progress</em>, 59, 39-43.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Detergent)

# basic mosaic plot
mosaic(Detergent, shade=TRUE)

require(MASS)
(det.mod0 &lt;- loglm(~ Preference + Temperature + M_User + Water_softness, 
                   data=Detergent))
# examine addition of two-way terms
add1(det.mod0, ~ .^2, test="Chisq")

# model for Preference as a response
(det.mod1 &lt;- loglm(~ Preference + (Temperature * M_User * Water_softness), 
                   data=Detergent))
mosaic(det.mod0)


</code></pre>

<hr>
<h2 id='Donner'>
Survival in the Donner Party
</h2><span id='topic+Donner'></span>

<h3>Description</h3>

<p>This data frame contains information on the members of the Donner Party,
a group of people who attempted to migrate to California in 1846.
They were trapped by an early blizzard on the eastern side of the
Sierra Nevada mountains, and before they could be rescued, 
nearly half of the party had died.
</p>
<p>What factors affected who lived and who died?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Donner)</code></pre>


<h3>Format</h3>

<p>A data frame with 90 observations on the following 5 variables.
</p>

<dl>
<dt><code>family</code></dt><dd><p>family name, a factor with 10 levels </p>
</dd>
<dt><code>age</code></dt><dd><p>age of person, a numeric vector</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>Female</code> <code>Male</code></p>
</dd>
<dt><code>survived</code></dt><dd><p>a numeric vector, 0 or 1</p>
</dd>
<dt><code>death</code></dt><dd><p>date of death for those who died before rescue, a POSIXct</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data frame uses the person's name as row labels.
<code>family</code> reflects a recoding of the last names of individuals
to reduce the number of factor levels.
The main families in the Donner party were: Donner, Graves, Breen and Reed.
The families of Murphy, Foster and Pike are grouped as <code>'MurFosPik'</code>,
those of Fosdick and Wolfinger are coded as <code>'FosdWolf'</code>, and
all others as <code>'Other'</code>.
</p>
<p><code>survived</code> is the response variable. What kind of models should be used here?
</p>


<h3>Source</h3>

<p>D. K. Grayson, 1990, &quot;Donner party deaths: A demographic
assessment&quot;, <em>J. Anthropological Research</em>, <b>46</b>, 223-242.
</p>
<p>Johnson, K. (1996). <em>Unfortunate Emigrants: Narratives of the Donner Party</em>. 
Logan, UT: Utah State University Press. 
Additions, and dates of death from <a href="http://user.xmission.com/~octa/DonnerParty/Roster.htm">http://user.xmission.com/~octa/DonnerParty/Roster.htm</a>.
</p>


<h3>References</h3>

<p>Ramsey, F.L. and Schafer, D.W. (2002). 
<em>The Statistical Sleuth: A Course in Methods of Data Analysis</em>, (2nd ed), Duxbury.
</p>
<p>Friendly, M. and Meyer, D. (2016). 
<em>Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data</em>. 
Boca Raton, FL: Chapman &amp; Hall/CRC. <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>.
</p>


<h3>See Also</h3>

<p><code>donner</code> in <span class="pkg">alr3</span>,
<code><a href="Sleuth2.html#topic+case2001">case2001</a></code> in <span class="pkg">Sleuth2</span>(adults only) provide similar data sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># conditional density plots
op &lt;- par(mfrow=c(1,2), cex.lab=1.5)
cdplot(factor(survived) ~ age, 
       subset=sex=='Male', 
       data=Donner, 
       main="Donner party: Males", 
       ylevels=2:1, 
       ylab="Survived", 
       yaxlabels=c("yes", "no"))
with(Donner, rug(jitter(age[sex=="Male"]), 
                 col="white", quiet=TRUE))

cdplot(factor(survived) ~ age, 
       subset=sex=='Female', 
       data=Donner, 
       main="Donner party: Females", 
       ylevels=2:1, 
       ylab="Survived", 
       yaxlabels=c("yes", "no"))
with(Donner, rug(jitter(age[sex=="Female"]), 
                 col="white", quiet=TRUE))
par(op)


# fit some models
(mod1 &lt;- glm(survived ~ age + sex, data=Donner, family=binomial))
(mod2 &lt;- glm(survived ~ age * sex, data=Donner, family=binomial))
anova(mod2, test="Chisq")

(mod3 &lt;- glm(survived ~ poly(age,2) * sex, data=Donner, family=binomial))
anova(mod3, test="Chisq")
LRstats(glmlist(mod1, mod2, mod3))

# plot fitted probabilities from mod2 and mod3
# idea from: http://www.ling.upenn.edu/~joseff/rstudy/summer2010_ggplot2_intro.html
library(ggplot2)

# separate linear fits on age for M/F
ggplot(Donner, aes(age, survived, color = sex)) +
  geom_point(position = position_jitter(height = 0.02, width = 0)) +
  stat_smooth(method = "glm", 
              method.args = list(family = binomial), 
              formula = y ~ x,
              alpha = 0.2, 
              size=2, 
              aes(fill = sex))

# separate quadratics
ggplot(Donner, aes(age, survived, color = sex)) +
  geom_point(position = position_jitter(height = 0.02, width = 0)) +
  stat_smooth(method = "glm", 
              method.args = list(family = binomial), 
              formula = y ~ poly(x,2),
              alpha = 0.2, 
              size=2, 
              aes(fill = sex))


</code></pre>

<hr>
<h2 id='Draft1970'>
USA 1970 Draft Lottery Data
</h2><span id='topic+Draft1970'></span>

<h3>Description</h3>

<p>This data set gives the results of the 1970 US draft lottery, in the form of a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Draft1970)</code></pre>


<h3>Format</h3>

<p>A data frame with 366 observations on the following 3 variables.
</p>

<dl>
<dt><code>Day</code></dt><dd><p>day of the year, 1:366</p>
</dd>
<dt><code>Rank</code></dt><dd><p>draft priority rank of people born on that day</p>
</dd>
<dt><code>Month</code></dt><dd><p>an ordered factor with levels <code>Jan</code> &lt; <code>Feb</code> ... &lt; <code>Dec</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The draft lottery was used to determine the order in which eligible men would
be called to the Selective Service draft.
The days of the year (including  February 29) were represented by the  numbers 1
through 366 written on slips of paper. The slips were placed in separate plastic
capsules that were  mixed in a  shoebox and then  dumped into a  deep glass jar.
Capsules were drawn from the jar one at a time.
</p>
<p>The first  number drawn  was 258  (September 14),  so all  registrants with that
birthday were assigned lottery number <code>Rank</code> 1. The second number drawn corresponded to
April 24, and so forth.  All men of draft age  (born 1944 to 1950) who  shared a
birthdate would be called to serve at once. The first 195 birthdates drawn  were
later called  to serve  in the  order they  were drawn;  the last  of these  was
September 24.
</p>


<h3>Source</h3>

<p>Starr, N. (1997).
Nonrandom Risk: The 1970 Draft Lottery,
<em>Journal of Statistics Education</em>, v.5, n.2
<a href="http://jse.amstat.org/v5n2/datasets.starr.html">http://jse.amstat.org/v5n2/datasets.starr.html</a>
</p>


<h3>References</h3>

<p>Fienberg, S. E. (1971), 
&quot;Randomization and Social Affairs: The 1970 Draft Lottery,&quot; <em>Science</em>, 171, 255-261.
</p>
<p><a href="https://en.wikipedia.org/wiki/Draft_lottery_(1969)">https://en.wikipedia.org/wiki/Draft_lottery_(1969)</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Draft1970table">Draft1970table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Draft1970)

# scatterplot
plot(Rank ~ Day, data=Draft1970)
with(Draft1970, lines(lowess(Day, Rank), col="red", lwd=2))
abline(lm(Rank ~ Day, data=Draft1970), col="blue")
 
# boxplots
plot(Rank ~ Month, data=Draft1970, col="bisque")

lm(Rank ~ Month, data=Draft1970)
anova(lm(Rank ~ Month, data=Draft1970))

# make the table version
Draft1970$Risk &lt;- cut(Draft1970$Rank, breaks=3, labels=c("High", "Med", "Low"))
with(Draft1970, table(Month, Risk))
</code></pre>

<hr>
<h2 id='Draft1970table'>
USA 1970 Draft Lottery Table
</h2><span id='topic+Draft1970table'></span>

<h3>Description</h3>

<p>This data set gives the results of the 1970 US draft lottery, in the form of
a frequency table.
The rows are months of the year, Jan&ndash;Dec and columns 
give the number of days in that month which fall into each of three
draft risk categories High, Medium, and Low, corresponding to
the chances of being called to serve in the US army.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Draft1970table)</code></pre>


<h3>Format</h3>

<p>The format is:
'table' int [1:12, 1:3] 9 7 5 8 9 11 12 13 10 9 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ Month: chr [1:12] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; ...
..$ Risk : chr [1:3] &quot;High&quot; &quot;Med&quot; &quot;Low&quot;
</p>


<h3>Details</h3>

<p>The lottery numbers are divided into three categories 
of risk of being called for the draft &ndash; High, Medium, and Low &ndash;
each representing roughly one third of the days in a year.
Those birthdays having the highest risk have lottery numbers
1-122, medium risk have numbers 123-244, and the lowest risk
category contains lottery numbers 245-366.
</p>


<h3>Source</h3>

<p>This data is available in several forms, but the table version was obtained from
</p>
<p><a href="https://sas.uwaterloo.ca/~rwoldfor/software/eikosograms/data/draft-70">https://sas.uwaterloo.ca/~rwoldfor/software/eikosograms/data/draft-70</a>
</p>


<h3>References</h3>

<p>Fienberg, S. E. (1971), 
&quot;Randomization and Social Affairs: The 1970 Draft Lottery,&quot; <em>Science</em>, 171, 255-261.
</p>
<p>Starr, N. (1997).
Nonrandom Risk: The 1970 Draft Lottery,
<em>Journal of Statistics Education</em>, v.5, n.2
<a href="https://jse.amstat.org/v5n2/datasets.starr.html">https://jse.amstat.org/v5n2/datasets.starr.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Draft1970">Draft1970</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Draft1970table)
chisq.test(Draft1970table)

# plot.table -&gt; graphics:::mosaicplot
plot(Draft1970table, shade=TRUE)
mosaic(Draft1970table, gp=shading_Friendly)

# correspondence analysis
if(require(ca)) {
  ca(Draft1970table)
  plot(ca(Draft1970table))
}

# convert to a frequency data frame with ordered factors
Draft1970df &lt;- as.data.frame(Draft1970table)

Draft1970df &lt;- within(Draft1970df, {
  Month &lt;- ordered(Month)
  Risk &lt;- ordered(Risk, levels=rev(levels(Risk)))
  })
str(Draft1970df)

# similar model, as a Poisson GLM  
indep &lt;- glm(Freq ~ Month + Risk, family = poisson, data = Draft1970df)

mosaic(indep, residuals_type="rstandard", gp=shading_Friendly)

# numeric scores for tests of ordinal factors
Cscore &lt;- as.numeric(Draft1970df$Risk)
Rscore &lt;- as.numeric(Draft1970df$Month)

# linear x linear association between Month and Risk
linlin &lt;- glm(Freq ~ Month + Risk + Rscore:Cscore, family = poisson, data = Draft1970df)

# compare models
anova(indep, linlin, test="Chisq")
mosaic(linlin, residuals_type="rstandard", gp=shading_Friendly)


</code></pre>

<hr>
<h2 id='Dyke'>Sources of Knowledge of Cancer</h2><span id='topic+Dyke'></span>

<h3>Description</h3>

<p>Observational data on a sample of 1729 individuals, cross-classified in a 2^5 table according to their sources of 
information (read newspapers, listen to the radio, do 'solid' reading, attend lectures) and whether they have
good or poor knowledge regarding cancer.  Knowledge of cancer is often treated as the response.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Dyke)</code></pre>


<h3>Format</h3>

<p>A 5-dimensional array resulting from cross-tabulating 5 variables for  1729 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1</td><td style="text-align: left;"> <code>Knowledge</code></td><td style="text-align: left;"> <code>"Good", "Poor"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2</td><td style="text-align: left;"> <code>Reading</code></td><td style="text-align: left;"> <code>"No", "Yes"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    3</td><td style="text-align: left;"> <code>Radio</code></td><td style="text-align: left;"> <code>"No", "Yes"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    4</td><td style="text-align: left;"> <code>Lectures</code></td><td style="text-align: left;"> <code>"No", "Yes"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    5</td><td style="text-align: left;"> <code>Newspaper</code></td><td style="text-align: left;"> <code>"No", "Yes"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Fienberg, S. E. (1980).
<em>The Analysis of Cross-Classified Categorical Data</em>
Cambridge, MA: MIT Press, p. 85, Table 5-6.
</p>


<h3>References</h3>

<p>Dyke, G. V. and Patterson, H. D. (1952).
Analysis of factorial arrangements when the data are proportions.
<em>Biometrics</em>, 8, 1-12.
</p>
<p>Lindsey, J. K. (1993). 
<em>Models for Repeated Measurements</em>
Oxford, UK: Oxford University Press, p. 57.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Dyke)

# independence model
mosaic(Dyke, shade=TRUE)

# null model, Knowledge as response, independent of others
require(MASS)
dyke.mod0 &lt;- loglm(~ Knowledge + (Reading * Radio * Lectures * Newspaper), data=Dyke)
dyke.mod0
mosaic(dyke.mod0)

# view as doubledecker plot
Dyke &lt;- Dyke[2:1,,,,]    # make Good the highlighted value of Knowledge
doubledecker(Knowledge ~ ., data=Dyke)

# better version, with some options
doubledecker(Knowledge ~ Lectures + Reading + Newspaper + Radio, 
  data=Dyke,
	margins = c(1,6, length(dim(Dyke)) + 1, 1), 
	fill_boxes=list(rep(c("white", gray(.90)),4))
	)

# separate (conditional) plots for those who attend lectures and those who do not
doubledecker(Knowledge ~ Reading + Newspaper + Radio, 
  data=Dyke[,,,1,],
	main="Do not attend lectures",
	margins = c(1,6, length(dim(Dyke)) + 1, 1), 
	fill_boxes=list(rep(c("white", gray(.90)),3))
	)
doubledecker(Knowledge ~ Reading + Newspaper + Radio, 
  data=Dyke[,,,2,],
	main="Attend lectures",
	margins = c(1,6, length(dim(Dyke)) + 1, 1), 
	fill_boxes=list(rep(c("white", gray(.90)),3))
	)


drop1(dyke.mod0, test="Chisq")

</code></pre>

<hr>
<h2 id='expand.dft'> Expand a frequency table to case form</h2><span id='topic+expand.dft'></span><span id='topic+expand.table'></span>

<h3>Description</h3>

<p>Converts a frequency table, given either as a table object or a data frame in frequency form
to a data frame representing individual observations in the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.dft(x, var.names = NULL, freq = "Freq", ...)

expand.table(x, var.names = NULL, freq = "Freq", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.dft_+3A_x">x</code></td>
<td>
<p>A table object, or a data frame in frequency form containing factors and one numeric variable
representing the cell frequency for that combination of factors. </p>
</td></tr>
<tr><td><code id="expand.dft_+3A_var.names">var.names</code></td>
<td>
<p>A list of variable names for the factors, if you wish to override those already in the table</p>
</td></tr>
<tr><td><code id="expand.dft_+3A_freq">freq</code></td>
<td>
<p>The name of the frequency variable in the table</p>
</td></tr>
<tr><td><code id="expand.dft_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to <code>type.convert</code>.  In particular, pay attention to 
<code>na.strings</code> (default: <code>na.strings=NA</code> if there are missing cells) and <code>as.is</code>
(default: <code>as.is=FALSE</code>, converting character vectors to factors).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>expand.table</code> is a synonym for <code>expand.dft</code>.
</p>


<h3>Value</h3>

<p>A data frame containing the factors in the table and as many observations as are
represented by the total of the <code>freq</code> variable.
</p>


<h3>Author(s)</h3>

<p> Mark Schwarz </p>


<h3>References</h3>

<p>Originally posted on R-Help, Jan 20, 2009,
http://tolstoy.newcastle.edu.au/R/e6/help/09/01/1873.html
</p>
<p>Friendly, M. and Meyer, D. (2016). 
<em>Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data</em>. 
Boca Raton, FL: Chapman &amp; Hall/CRC. <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="utils.html#topic+type.convert">type.convert</a></code>, <code><a href="gnm.html#topic+expandCategorical">expandCategorical</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vcd)
art &lt;- xtabs(~Treatment + Improved, data = Arthritis)
art
artdf &lt;- expand.dft(art)
str(artdf)

# 1D case
(tab &lt;- table(sample(head(letters), 20, replace=TRUE)))
expand.table(tab, var.names="letter")

</code></pre>

<hr>
<h2 id='Fungicide'>
Carcinogenic Effects of a Fungicide
</h2><span id='topic+Fungicide'></span>

<h3>Description</h3>

<p>Data from Gart (1971) on the carcinogenic effects of a certain fungicide
in two strains of mice.
Of interest is how the association between <code>group</code> (Control, Treated)
and <code>outcome</code> (Tumor, No Tumor) varies with <code>sex</code> and
<code>strain</code> of the mice.
</p>
<p>Breslow (1976) used this data to illustrate the application of linear models
to log odds ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Fungicide)</code></pre>


<h3>Format</h3>

<p>The data comprise a set of four 2 x 2 tables classifying 403 mice, either
Control or Treated and whether or not a tumor was later observed.  
The four groups represent the combinations of sex and strain of mice.
The format is:
num [1:2, 1:2, 1:2, 1:2] 5 4 74 12 3 2 84 14 10 4 ...
- attr(*, &quot;dimnames&quot;)=List of 4
..$ group  : chr [1:2] &quot;Control&quot; &quot;Treated&quot;
..$ outcome: chr [1:2] &quot;Tumor&quot; &quot;NoTumor&quot;
..$ sex    : chr [1:2] &quot;M&quot; &quot;F&quot;
..$ strain : chr [1:2] &quot;1&quot; &quot;2&quot;
</p>


<h3>Details</h3>

<p>All tables have some small cells, so a continuity correction is recommended.
</p>


<h3>Source</h3>

<p>Gart, J. J. (1971). The comparison of proportions: a review of significance tests,
confidence intervals and adjustments for stratification. 
<em>International Statistical Review</em>,
39, 148-169.
</p>


<h3>References</h3>

<p>Breslow, N. (1976), Regression analysis of the log odds ratio:
A method for retrospective studies, <em>Biometrics</em>, 32(3), 409-416.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Fungicide)
# loddsratio was moved to vcd; requires vcd_1.3-3+
## Not run: 
fung.lor &lt;- loddsratio(Fungicide, correct=TRUE)
fung.lor
confint(fung.lor)

## End(Not run)

# visualize odds ratios in fourfold plots
cotabplot(Fungicide, panel=cotab_fourfold)
#  -- fourfold() requires vcd &gt;= 1.2-10
fourfold(Fungicide, p_adjust_method="none")


</code></pre>

<hr>
<h2 id='Geissler'>Geissler's Data on the Human Sex Ratio</h2><span id='topic+Geissler'></span>

<h3>Description</h3>

<p>Geissler (1889) published data on the distributions of boys and girls in families in 
Saxony, collected for the period 1876-1885. The <code>Geissler</code> data tabulates 
the family composition of 991,958 families by the number of boys and girls
listed in the table supplied by Edwards (1958, Table 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Geissler)</code></pre>


<h3>Format</h3>

<p>A data frame with 90 observations on the following 4 variables.  The rows represent the
non-NA entries in Edwards' table.
</p>

<dl>
<dt><code>boys</code></dt><dd><p>number of boys in the family, <code>0:12</code></p>
</dd>
<dt><code>girls</code></dt><dd><p>number of girls in the family, <code>0:12</code></p>
</dd>
<dt><code>size</code></dt><dd><p>family size: <code>boys+girls</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>number of families with this sex composition</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data on family composition was available because, on the birth of a child,
the parents had to state the sex of all their children on the birth certificate.
These family records are not necessarily independent, because a given family
may have had several children during this 10 year period, included as 
multiple records.
</p>


<h3>Source</h3>

<p>Edwards, A. W. F. (1958).
An Analysis Of Geissler's Data On The Human Sex Ratio.
<em>Annals of Human Genetics</em>, 
23, 6-15.
</p>


<h3>References</h3>

<p>Friendly, M. and Meyer, D. (2016). 
<em>Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data</em>. 
Boca Raton, FL: Chapman &amp; Hall/CRC. <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>.
</p>
<p>Geissler, A. (1889).
<em>Beitrage zur Frage des Geschlechts verhaltnisses der Geborenen</em>
Z. K. Sachsischen Statistischen Bureaus, 35, n.p.
</p>
<p>Lindsey, J. K. &amp; Altham, P. M. E. (1998). 
Analysis of the human sex ratio by using overdispersion models.
<em>Journal of the Royal Statistical Society: Series C (Applied Statistics)</em>, 
47, 149-157. 
</p>


<h3>See Also</h3>

<p><code><a href="vcd.html#topic+Saxony">Saxony</a></code>, containing the data for families of size 12.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Geissler)
str(Geissler)

# reproduce Saxony data, families of size 12
Saxony12 &lt;- subset(Geissler, size==12, select=c(boys, Freq))
rownames(Saxony12)&lt;-NULL

# make a 1-way table
xtabs(Freq~boys, Saxony12)

# extract data for other family sizes
Saxony11 &lt;- subset(Geissler, size==11, select=c(boys, Freq))
rownames(Saxony11)&lt;-NULL

Saxony10 &lt;- subset(Geissler, size==10, select=c(boys, Freq))
rownames(Saxony10)&lt;-NULL

</code></pre>

<hr>
<h2 id='Gilby'>Clothing and Intelligence Rating of Children</h2><span id='topic+Gilby'></span>

<h3>Description</h3>

<p>Schoolboys were classified according to their clothing and to their teachers rating of &quot;dullness&quot;
(lack of intelligence), in a 5 x 7 table originally from 
Gilby (1911).
Anscombe (1981) presents a slightly collapsed 4 x 6 table, used here, where 
the last two categories of clothing were pooled as were the first two categories of dullness due to small counts.
</p>
<p>Both <code>Dullness</code> and <code>Clothing</code> are ordered categories, so models and methods
that examine their association in terms of ordinal categories are profitable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Gilby)
</code></pre>


<h3>Format</h3>

<p>A 2-dimensional array resulting from cross-tabulating 2 variables for  1725 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1</td><td style="text-align: left;"> <code>Dullness</code></td><td style="text-align: left;"> <code>"Ment. defective", "Slow", "Slow Intell", "Fairly Intell", "Capable", "V.Able"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2</td><td style="text-align: left;"> <code>Clothing</code></td><td style="text-align: left;"> <code>"V.Well clad", "Well clad", "Passable", "Insufficient"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Anscombe, F. J. (1981).
<em>Computing in Statistical Science Through APL</em>.
New York: Springer-Verlag, p. 302
</p>


<h3>References</h3>


<p>Gilby, W. H. (1911).
On the significance of the teacher's appreciation of
general intelligence.  <em>Biometrika</em>, 8, 93-108 (esp. p. 94).
[Quoted by Kendall (1943,..., 1953) Table 13.1, p 320.]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gilby)

# CMH tests treating row/column variables as ordinal
CMHtest(Gilby)

mosaic(Gilby, shade=TRUE)

# correspondence analysis to see relations among categories
if(require(ca)){
	ca(Gilby)
	plot(ca(Gilby), lines=TRUE)

}


</code></pre>

<hr>
<h2 id='GKgamma'>Calculate Goodman-Kruskal Gamma for ordered tables</h2><span id='topic+GKgamma'></span><span id='topic+print.GKgamma'></span>

<h3>Description</h3>

<p>The Goodman-Kruskal <code class="reqn">\gamma</code> statistic is a measure of
association for ordinal factors in a two-way table proposed by
Goodman and Kruskal (1954).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GKgamma(x, level = 0.95)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GKgamma_+3A_x">x</code></td>
<td>
<p>A two-way frequency table, in matrix or table form.  The rows and columns
are considered to be ordinal factors</p>
</td></tr>
<tr><td><code id="GKgamma_+3A_level">level</code></td>
<td>
<p>Confidence level for a significance test of <code class="reqn">\gamma \ne =</code></p>
</td></tr>


</table>


<h3>Value</h3>

<p>Returns an object of class <code>"GKgamma"</code> with 6 components, as follows


</p>
<table>
<tr><td><code>gamma</code></td>
<td>
<p>The gamma statistic</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Total number of concordant pairs in the table</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Total number of discordant pairs in the table</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Standard error of gamma </p>
</td></tr>
<tr><td><code>CIlevel</code></td>
<td>
<p>Confidence level</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>Confidence interval</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Michael Friendly; original version by Laura Thompson</p>


<h3>References</h3>

<p>Agresti, A. <em>Categorical Data Analysis</em>. John Wiley &amp; Sons, 2002,
pp. 57&ndash;59.
</p>
<p>Goodman, L. A., &amp; Kruskal, W. H. (1954). Measures of
association for cross classifications. <em>Journal of the
American Statistical Association</em>, 49, 732-764.
</p>
<p>Goodman, L. A., &amp; Kruskal, W. H. (1963). Measures of
association for cross classifications III: Approximate
sampling theory. <em>Journal of the American Statistical
Association</em>, 58, 310-364.
</p>


<h3>See Also</h3>

<p><code><a href="vcd.html#topic+assocstats">assocstats</a></code>, <a href="vcd.html#topic+Kappa">Kappa</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(JobSat)
GKgamma(JobSat)
</code></pre>

<hr>
<h2 id='Glass'>British Social Mobility from Glass(1954)</h2><span id='topic+Glass'></span>

<h3>Description</h3>

<p>Glass(1954) gave this 5 x 5 table on the occupations of 3500 British fathers and their sons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Glass")</code></pre>


<h3>Format</h3>

<p>A frequency data frame with 25 observations on the following 3 variables representing a 5 x 5 table with 3500 cases.
</p>

<dl>
<dt><code>father</code></dt><dd><p>a factor with levels <code>Managerial</code> <code>Professional</code> <code>Skilled</code> <code>Supervisory</code> <code>Unskilled</code></p>
</dd>
<dt><code>son</code></dt><dd><p>a factor with levels <code>Managerial</code> <code>Professional</code> <code>Skilled</code> <code>Supervisory</code> <code>Unskilled</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The occupational categories in order of status are:
(1) Professional &amp; High Administrative
(2) Managerial, Executive &amp; High Supervisory
(3) Low Inspectional &amp; Supervisory
(4) Routine Nonmanual &amp; Skilled Manual
(5) Semi- &amp; Unskilled Manual
</p>
<p>However, to make the point that factors are ordered alphabetically by default,
Friendly &amp; Meyer (2016) introduce this data set in the form given here. 
</p>


<h3>Source</h3>

<p>Glass, D. V. (1954), <em>Social Mobility in Britain</em>. The Free Press.
</p>


<h3>References</h3>

<p>Bishop, Y. M. M. and Fienberg, S. E. and Holland, P. W. (1975).
<em>Discrete Multivariate Analysis: Theory and Practice</em>, MIT Press.
</p>
<p>Friendly, M. and Meyer, D. (2016). 
<em>Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data</em>. 
Boca Raton, FL: Chapman &amp; Hall/CRC. <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Glass)
glass.tab &lt;- xtabs(Freq ~ father + son, data=Glass)

largs &lt;- list(set_varnames=list(father="Father's Occupation", 
                                son="Son's Occupation"),
              abbreviate=10)
gargs &lt;- list(interpolate=c(1,2,4,8))

mosaic(glass.tab, 
  shade=TRUE, 
  labeling_args=largs, 
  gp_args=gargs,
  main="Alphabetic order", 
  legend=FALSE, 
  rot_labels=c(20,90,0,70))

# reorder by status
ord &lt;- c(2, 1, 4, 3, 5) 
mosaic(glass.tab[ord, ord], 
  shade=TRUE, 
  labeling_args=largs,  
  gp_args=gargs,
  main="Effect order", 
  legend=FALSE, 
  rot_labels=c(20,90,0,70))

</code></pre>

<hr>
<h2 id='glmlist'>
Create a Model List Object
</h2><span id='topic+glmlist'></span><span id='topic+loglmlist'></span><span id='topic+coef.glmlist'></span>

<h3>Description</h3>

<p><code>glmlist</code> creates a <code>glmlist</code> object containing a list of fitted <code>glm</code> objects with their names.
<code>loglmlist</code> does the same for <code>loglm</code> objects.
</p>
<p>The intention is to provide object classes to facilitate model comparison,
extraction, summary and plotting of model components, etc., perhaps using
<code><a href="base.html#topic+lapply">lapply</a></code> or similar.
</p>
<p>There exists a <code><a href="stats.html#topic+anova.glm">anova.glm</a></code> method for <code>glmlist</code> objects.  Here,
a <code>coef</code> method is also defined, collecting the coefficients from all models in
a single object of type determined by <code>result</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmlist(...)
loglmlist(...)

## S3 method for class 'glmlist'
coef(object, result=c("list", "matrix", "data.frame"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmlist_+3A_...">...</code></td>
<td>
<p>One or more model objects, as appropriate to the function, optionally assigned names as in <code>list</code>.</p>
</td></tr>
<tr><td><code id="glmlist_+3A_object">object</code></td>
<td>
<p>a <code>glmlist</code> object</p>
</td></tr>
<tr><td><code id="glmlist_+3A_result">result</code></td>
<td>
<p>type of the result to be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments to <code>glmlist</code>  or <code>loglmlist</code> are of the form <code>value</code> or <code>name=value</code>.
</p>
<p>Any objects which do not inherit the appropriate class <code>glm</code> or <code>loglm</code> are excluded, with a warning.
</p>
<p>In the <code>coef</code> method, coefficients from the different models are matched by name in the list of
unique names across all models.
</p>


<h3>Value</h3>

<p>An object of class <code>glmlist</code> <code>loglmlist</code>, just like a <code>list</code>,
except that each model is given a <code>name</code> attribute.</p>


<h3>Author(s)</h3>

<p>Michael Friendly;
<code>coef</code> method by John Fox
</p>


<h3>See Also</h3>

<p>The function <code><a href="Hmisc.html#topic+llist">llist</a></code> in package <code>Hmisc</code> is similar, but perplexingly
more general.
</p>
<p>The function <code><a href="stats.html#topic+anova.glm">anova.glm</a></code> also handles <code>glmlist objects</code>
</p>
<p><code><a href="#topic+LRstats">LRstats</a></code> gives LR statistics and tests for a <code>glmlist</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mental)
indep &lt;- glm(Freq ~ mental+ses,
                family = poisson, data = Mental)
Cscore &lt;- as.numeric(Mental$ses)
Rscore &lt;- as.numeric(Mental$mental)

coleff &lt;- glm(Freq ~ mental + ses + Rscore:ses,
                family = poisson, data = Mental)
roweff &lt;- glm(Freq ~ mental + ses + mental:Cscore,
                family = poisson, data = Mental)
linlin &lt;- glm(Freq ~ mental + ses + Rscore:Cscore,
                family = poisson, data = Mental)
                
# use object names
mods &lt;- glmlist(indep, coleff, roweff, linlin)
names(mods)

# assign new names
mods &lt;- glmlist(Indep=indep, Col=coleff, Row=roweff, LinxLin=linlin)
names(mods)

LRstats(mods)

coef(mods, result='data.frame')

#extract model components
unlist(lapply(mods, deviance))

res &lt;- lapply(mods, residuals)
boxplot(as.data.frame(res), main="Residuals from various models")
</code></pre>

<hr>
<h2 id='GSS'>General Social Survey&ndash; Sex and Party affiliation</h2><span id='topic+GSS'></span>

<h3>Description</h3>

<p>Data from the General Social Survey, 1991, on the relation between 
sex and party affiliation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GSS)</code></pre>


<h3>Format</h3>

<p>A data frame in frequency form with 6 observations on the following 3 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>female</code> <code>male</code></p>
</dd>
<dt><code>party</code></dt><dd><p>a factor with levels <code>dem</code> <code>indep</code> <code>rep</code></p>
</dd>
<dt><code>count</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Agresti, A. <em>Categorical Data Analysis</em>, 2nd E., John Wiley &amp; Sons, 2002,
Table 3.11, p. 106.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GSS)
str(GSS)

# use xtabs to show the table in a compact form
(GSStab &lt;- xtabs(count ~ sex + party, data=GSS))

# fit the independence model
(mod.glm &lt;- glm(count ~ sex + party, family = poisson, data = GSS))

# display all the residuals in a mosaic plot
mosaic(mod.glm, 
  formula = ~ sex + party, 
  labeling = labeling_residuals, 
  suppress=0)
</code></pre>

<hr>
<h2 id='HairEyePlace'>
Hair Color and Eye Color in Caithness and Aberdeen
</h2><span id='topic+HairEyePlace'></span>

<h3>Description</h3>

<p>A three-way frequency table crossing eye color and hair color in two places, Caithness and Aberdeen,
Scotland.
These data were of interest to Fisher (1940) and others because
there are mixtures of people of Nordic, Celtic and Anglo-Saxon origin.
</p>
<p>One or both tables have been widely analyzed in conjunction with
RC and canonical correlation models for categorical data, e.g.,
Becker and Clogg (1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HairEyePlace)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:4, 1:5, 1:2] 326 688 343 98 38 116 84 48 241 584 ...
- attr(*, &quot;dimnames&quot;)=List of 3
..$ Eye  : chr [1:4] &quot;Blue&quot; &quot;Light&quot; &quot;Medium&quot; &quot;Dark&quot;
..$ Hair : chr [1:5] &quot;Fair&quot; &quot;Red&quot; &quot;Medium&quot; &quot;Dark&quot; ...
..$ Place: chr [1:2] &quot;Caithness&quot; &quot;Aberdeen&quot;
</p>


<h3>Details</h3>

<p>The hair and eye colors are ordered as in the original source,
suggesting that they form ordered categories.
</p>


<h3>Source</h3>

<p>This data was taken from the <code>colors</code> data in <span class="pkg">logmult</span>.
</p>


<h3>References</h3>

<p>Becker, M. P., and Clogg, C. C. (1989). 
Analysis of Sets of Two-Way Contingency Tables Using Association Models. 
<em>Journal of the American Statistical Association</em>, 84(405), 142-151. 
</p>
<p>Fisher, R.A. (1940) The precision of discriminant functions. 
<em>Annals of Eugenics</em>, 10, 422-429.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HairEyePlace)

# separate mosaics
mosaic(HairEyePlace[,,1], shade=TRUE, main="Caithness")
mosaic(HairEyePlace[,,2], shade=TRUE, main="Aberdeen")

# condition on Place
mosaic(~Hair + Eye |Place, data=HairEyePlace, shade=TRUE, legend=FALSE)

cotabplot(~Hair+Eye|Place, data=HairEyePlace, shade=TRUE, legend=FALSE)
</code></pre>

<hr>
<h2 id='Hauser79'>
Hauser (1979) Data on Social Mobility
</h2><span id='topic+Hauser79'></span>

<h3>Description</h3>

<p>Hauser (1979) presented this two-way frequency table,
cross-classifying occupational categories of sons and fathers
in the United States.
</p>
<p>It is a good example for exploring a variety of models for square tables:
quasi-independence, quasi-symmetry, row/column effects, uniform association, etc.,
using the facilities of the <span class="pkg">gnm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Hauser79)</code></pre>


<h3>Format</h3>

<p>A frequency data frame with 25 observations on the following 3 variables, representing the
cross-classification of 19912 individuals by father's occupation and son's first occupation. 
</p>

<dl>
<dt><code>Son</code></dt><dd><p>a factor with levels <code>UpNM</code> <code>LoNM</code> <code>UpM</code> <code>LoM</code> <code>Farm</code></p>
</dd>
<dt><code>Father</code></dt><dd><p>a factor with levels <code>UpNM</code> <code>LoNM</code> <code>UpM</code> <code>LoM</code> <code>Farm</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Hauser's data was first presented in 1979, and then published in 1980. The name of the
dataset reflects the earliest use.
</p>
<p>It reflects the &quot;frequencies in a classification of son's first full-time civilian occupation by father's (or other family head's) occupation at son's sixteenth birthday among American men who were aged 20 to 64 in 1973 and were not currently enrolled in school&quot;.
</p>
<p>As noted in Hauser's Table 1,
&quot;Counts are based on observations weighted to estimate population counts and compensate for departures of the sampling design from simple random sampling. Broad occupation groups are upper nonmanual: professional and kindred workers, managers and officials, and non-retail sales workers; lower nonmanual: proprietors, clerical and kindred workers, and retail sales workers; upper manual: craftsmen, foremen, and kindred workers; lower manual: service workers, operatives and kindred workers, and laborers (except farm); farm: farmers and farm managers, farm laborers, and foremen. density of mobility or immobility in the cells to which they refer.&quot;
</p>
<p>The table levels for <code>Son</code> and <code>Father</code> have been arranged in order of decreasing status
as is common for mobility tables.
</p>


<h3>Source</h3>

<p>R.M. Hauser (1979), Some exploratory methods for modeling mobility tables and other cross-classified data. 
In: K.F. Schuessler (Ed.), <em>Sociological Methodology</em>, 1980, Jossey-Bass, San Francisco, pp. 413-458. Table 1.
</p>


<h3>References</h3>

<p>Powers, D.A. and Xie, Y. (2008). <em>Statistical Methods for Categorical Data Analysis</em>, 
Bingley, UK: Emerald.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Hauser79)
str(Hauser79)

# display table
structable(~Father+Son, data=Hauser79)

#Examples from Powers &amp; Xie, Table 4.15
# independence model
mosaic(Freq ~ Father + Son, data=Hauser79, shade=TRUE)

hauser.indep &lt;- gnm(Freq ~ Father + Son, 
  data=Hauser79, 
  family=poisson)

mosaic(hauser.indep, ~Father+Son, 
       main="Independence model", 
       gp=shading_Friendly)

# Quasi-independence
hauser.quasi &lt;-  update(hauser.indep, 
                        ~ . + Diag(Father,Son))
mosaic(hauser.quasi, ~Father+Son, 
       main="Quasi-independence model", 
       gp=shading_Friendly)

# Quasi-symmetry
hauser.qsymm &lt;-  update(hauser.indep, 
                        ~ . + Diag(Father,Son) + Symm(Father,Son))

mosaic(hauser.qsymm, ~Father+Son, 
       main="Quasi-symmetry model", 
       gp=shading_Friendly)


# numeric scores for row/column effects
Sscore &lt;- as.numeric(Hauser79$Son)
Fscore &lt;- as.numeric(Hauser79$Father)

# row effects model
hauser.roweff &lt;- update(hauser.indep, ~ . + Father*Sscore)
LRstats(hauser.roweff)

# uniform association
hauser.UA &lt;- update(hauser.indep, ~ . + Fscore*Sscore)
LRstats(hauser.UA)

# uniform association, omitting diagonals
hauser.UAdiag &lt;- update(hauser.indep, ~ . + Fscore*Sscore + Diag(Father,Son))
LRstats(hauser.UAdiag)

# Levels for Hauser 5-level model
levels &lt;- matrix(c(
  2,  4,  5,  5,  5,
  3,  4,  5,  5,  5,
  5,  5,  5,  5,  5,
  5,  5,  5,  4,  4,
  5,  5,  5,  4,  1
  ), 5, 5, byrow=TRUE)

hauser.topo &lt;- update(hauser.indep, 
                      ~ . + Topo(Father, Son, spec=levels))

mosaic(hauser.topo, ~Father+Son, 
       main="Topological model", gp=shading_Friendly)

# RC model
hauser.RC &lt;- update(hauser.indep, ~ . + Mult(Father, Son), verbose=FALSE)
mosaic(hauser.RC, ~Father+Son, main="RC model", gp=shading_Friendly)
LRstats(hauser.RC)

# crossings models 
hauser.CR &lt;- update(hauser.indep, ~ . + Crossings(Father,Son))
mosaic(hauser.topo, ~Father+Son, main="Crossings model", gp=shading_Friendly)
LRstats(hauser.CR)

hauser.CRdiag &lt;- update(hauser.indep, ~ . + Crossings(Father,Son) + Diag(Father,Son))
LRstats(hauser.CRdiag)


# compare model fit statistics
modlist &lt;- glmlist(hauser.indep, hauser.roweff, hauser.UA, hauser.UAdiag, 
                   hauser.quasi, hauser.qsymm,  hauser.topo, 
                   hauser.RC, hauser.CR, hauser.CRdiag)
sumry &lt;- LRstats(modlist)
sumry[order(sumry$AIC, decreasing=TRUE),]
# or, more simply
LRstats(modlist, sortby="AIC")

mods &lt;- substring(rownames(sumry),8)
with(sumry,
	{plot(Df, AIC, cex=1.3, pch=19, xlab='Degrees of freedom', ylab='AIC')
	text(Df, AIC, mods, adj=c(0.5,-.5), col='red', xpd=TRUE)
	})


</code></pre>

<hr>
<h2 id='Heart'>Sex, Occupation and Heart Disease</h2><span id='topic+Heart'></span>

<h3>Description</h3>

<p>Classification of individuals by gender, occupational category and occurrence of heart disease</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Heart)</code></pre>


<h3>Format</h3>

<p>A 3-dimensional array resulting from cross-tabulating 3 variables for 21522 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1</td><td style="text-align: left;"> <code>Disease</code></td><td style="text-align: left;"> <code>"Disease", "None"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2</td><td style="text-align: left;"> <code>Gender</code></td><td style="text-align: left;"> <code>"Male", "Female"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    3</td><td style="text-align: left;"> <code>Occup</code></td><td style="text-align: left;"> <code>"Unempl", "WhiteCol", "BlueCol"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>


<p>Karger, (1980).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Heart)
str(Heart)

# Display the frequencies for occupational categories.
# Each row is a 2 x 2 table
vcd::structable(Disease + Gender ~ Occup, data=Heart)

# display as fourfold plots
vcd::cotabplot(~ Disease + Gender | Occup, data=Heart, panel = cotab_fourfold)
</code></pre>

<hr>
<h2 id='Heckman'>Labour Force Participation of Married Women 1967-1971</h2><span id='topic+Heckman'></span>

<h3>Description</h3>

<p>1583 married women were surveyed over the years 1967-1971, 
recording whether or not they were employed in the labor force.
</p>
<p>The data, originally from Heckman &amp; Willis (1977) provide an example
of modeling longitudinal categorical data, e.g., with markov chain
models for dependence over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Heckman)
</code></pre>


<h3>Format</h3>

<p>A 5-dimensional <code class="reqn">2^5</code> array resulting from cross-tabulating 5 binary variables for 1583 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1</td><td style="text-align: left;"> <code>e1971</code></td><td style="text-align: left;"> <code>"71Yes", "No"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2</td><td style="text-align: left;"> <code>e1970</code></td><td style="text-align: left;"> <code>"70Yes", "No"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    3</td><td style="text-align: left;"> <code>e1969</code></td><td style="text-align: left;"> <code>"69Yes", "No"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    4</td><td style="text-align: left;"> <code>e1968</code></td><td style="text-align: left;"> <code>"68Yes", "No"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    5</td><td style="text-align: left;"> <code>e1967</code></td><td style="text-align: left;"> <code>"67Yes", "No"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Lindsey (1993) fits an initial set of logistic regression models examining the dependence of
employment in 1971 (<code>e1971</code>) on successive subsets of the previous years,
<code>e1970</code>, <code>e1969</code>, ... <code>e1967</code>.
</p>
<p>Alternatively, one can examine markov chain models of first-order (dependence on previous
year), second-order (dependence on previous two years), etc.
</p>


<h3>Source</h3>


<p>Lindsey, J. K. (1993). 
<em>Models for Repeated Measurements</em>
Oxford, UK: Oxford University Press, p. 185.
</p>


<h3>References</h3>


<p>Heckman, J.J. &amp; Willis, R.J. (1977). 
&quot;A beta-logistic model for the analysis of sequential labor force participation by married women.&quot; 
<em>Journal of Political Economy</em>, 85: 27-58
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Heckman)

# independence model
mosaic(Heckman, shade=TRUE)
# same, as a loglm()
require(MASS)
(heckman.mod0 &lt;- loglm(~ e1971+e1970+e1969+e1968+e1967, data=Heckman))
mosaic(heckman.mod0, main="Independence model")

# first-order markov chain: bad fit
(heckman.mod1 &lt;- loglm(~ e1971*e1970 + e1970*e1969 +e1969*e1968 + e1968*e1967, data=Heckman))
mosaic(heckman.mod1, main="1st order markov chain model")

# second-order markov chain: bad fit
(heckman.mod2 &lt;- loglm(~ e1971*e1970*e1969 + e1970*e1969*e1968 +e1969*e1968*e1967, data=Heckman))
mosaic(heckman.mod2, main="2nd order markov chain model")

# third-order markov chain: fits OK
(heckman.mod3 &lt;- loglm(~ e1971*e1970*e1969*e1968 + e1970*e1969*e1968*e1967, data=Heckman))
mosaic(heckman.mod2, main="3rd order markov chain model")

</code></pre>

<hr>
<h2 id='HLtest'>
Hosmer-Lemeshow Goodness of Fit Test
</h2><span id='topic+HosmerLemeshow'></span><span id='topic+HLtest'></span><span id='topic+plot.HLtest'></span><span id='topic+print.HLtest'></span><span id='topic+rootogram.HLtest'></span><span id='topic+summary.HLtest'></span>

<h3>Description</h3>

<p>The <code>HLtest</code> function computes the classical Hosmer-Lemeshow (1980) goodness of fit test
for a binomial <code>glm</code> object in logistic regression
</p>
<p>The general idea is to assesses whether or not the observed event rates match expected event rates in subgroups of the 
model population. The Hosmer-Lemeshow test specifically identifies subgroups as the deciles of fitted event values,
or other quantiles as determined by the <code>g</code> argument.
Given these subgroups, a simple chisquare test on <code>g-2</code> df is used.
</p>
<p>In addition to <code>print</code> and <code>summary</code> methods, a <code>plot</code> method is
supplied to visualize the discrepancies between observed and fitted frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
HosmerLemeshow(model, g = 10)

HLtest(model, g = 10)

## S3 method for class 'HLtest'
print(x, ...)
## S3 method for class 'HLtest'
summary(object, ...)
## S3 method for class 'HLtest'
plot(x, ...)
## S3 method for class 'HLtest'
rootogram(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HLtest_+3A_model">model</code></td>
<td>
<p>A <code>glm</code> model object in the <code>binomial</code> family</p>
</td></tr>
<tr><td><code id="HLtest_+3A_g">g</code></td>
<td>
<p>Number of groups used to partition the fitted values for the GOF test.</p>
</td></tr>
<tr><td><code id="HLtest_+3A_x">x</code>, <code id="HLtest_+3A_object">object</code></td>
<td>
<p>A <code>HLtest</code> object</p>
</td></tr>
<tr><td><code id="HLtest_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class <code>HLtest</code> object  with the following components:
</p>
<table>
<tr><td><code>table</code></td>
<td>
<p>A data.frame describing the results of partitioning the data into <code>g</code>
groups with the following columns: <code>cut</code>, <code>total</code>, <code>obs</code>, <code>exp</code>, <code>chi</code></p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>The chisquare statistics</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p value</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p><code>model</code> call</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Hosmer, David W., Lemeshow, Stanley (1980). 
A goodness-of-fit test for multiple logistic regression model.
<em>Communications in Statistics, Series A</em>, 9, 1043-1069.
</p>
<p>Hosmer, David W., Lemeshow, Stanley (2000). 
<em>Applied Logistic Regression</em>, New York: Wiley, ISBN 0-471-61553-6
</p>
<p>Lemeshow, S. and Hosmer, D.W.  (1982). 
A review of goodness of fit statistics for use in the development of logistic regression models. 
<em>American Journal of Epidemiology</em>, 115(1), 92-106.
</p>


<h3>See Also</h3>

<p><code><a href="vcd.html#topic+rootogram">rootogram</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(birthwt, package="MASS")
# how to do this without attach?
attach(birthwt)
	race = factor(race, labels = c("white", "black", "other"))
	ptd = factor(ptl &gt; 0)
	ftv = factor(ftv)
	levels(ftv)[-(1:2)] = "2+"
	bwt &lt;- data.frame(low = factor(low), age, lwt, race,
    	smoke = (smoke &gt; 0), ptd, ht = (ht &gt; 0), ui = (ui &gt; 0), ftv)
detach(birthwt)

options(contrasts = c("contr.treatment", "contr.poly"))
BWmod &lt;- glm(low ~ ., family=binomial, data=bwt)

(hlt &lt;- HLtest(BWmod))
str(hlt)
summary(hlt)
plot(hlt)

# basic model
BWmod0 &lt;- glm(low ~ age, family=binomial, data=bwt)
(hlt0 &lt;- HLtest(BWmod0))
str(hlt0)
summary(hlt0)
plot(hlt0)


</code></pre>

<hr>
<h2 id='HospVisits'>
Hospital Visits Data
</h2><span id='topic+HospVisits'></span>

<h3>Description</h3>

<p>Length of stay in hospital for 132 schizophrenic patients, classified by
visiting patterns, originally from Wing (1962).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HospVisits")</code></pre>


<h3>Format</h3>

<p>A 3 by 3 frequency table, with format:
table [1:3, 1:3] 43 6 9 16 11 18 3 10 16
- attr(*, &quot;dimnames&quot;)=List of 2
..$ visit: chr [1:3] &quot;Regular&quot; &quot;Infrequent&quot; &quot;Never&quot;
..$ stay : chr [1:3] &quot;2-9&quot; &quot;10-19&quot; &quot;20+&quot;
</p>


<h3>Details</h3>

<p>Both table variables can be considered ordinal.
The variable <code>visit</code> refers to visiting patterns recorded hospital. 
The category labels are abbreviations of those given by Goodman (1983);
e.g., <code>"Regular"</code> is short for &ldquo;received visitors regularly or patient went home&rdquo;.
The variable <code>stay</code> refers to length of stay in hospital, in year groups.
</p>


<h3>Source</h3>

<p>Goodman, L. A. (1983) The analysis of dependence in cross-classifications having ordered categories, using log-linear models for frequencies and log-linear models for odds. 
<em>Biometrics</em>, 39, 149-160.
</p>


<h3>References</h3>

<p>Wing, J. K. (1962). Institutionalism in Mental Hospitals,
<em>British Journal of Social and Clinical Psychology</em>, 1 (1), 38-51.
</p>


<h3>See Also</h3>

<p><code><a href="ca.html#topic+ca">ca</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HospVisits)
mosaic(HospVisits, gp=shading_Friendly)

if(require(ca)){
  ca(HospVisits)
  # surprisingly 1D !
  plot(ca(HospVisits))
  }
</code></pre>

<hr>
<h2 id='HouseTasks'>
Household Tasks Performed by Husbands and Wives
</h2><span id='topic+HouseTasks'></span>

<h3>Description</h3>

<p>A 13 x 4 table of frequencies of household tasks performed by couples,
either by the 'Husband', 'Wife', 'Alternating' or 'Jointly'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HouseTasks")</code></pre>


<h3>Format</h3>

<p>The format is:
'table' int [1:13, 1:4] 36 11 24 51 13 1 1 14 20 46 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ Task: chr [1:13] &quot;Breakfast&quot; &quot;Dinner&quot; &quot;Dishes&quot; &quot;Driving&quot; ...
..$ Who : chr [1:4] &quot;Alternating&quot; &quot;Husband&quot; &quot;Jointly&quot; &quot;Wife&quot;
</p>


<h3>Source</h3>

<p>This data set was taken from <code><a href="factoextra.html#topic+housetasks">housetasks</a></code>, a 
13 x 4 data.frame.
In this table version, the rows and columns were sorted alphabetically
(and a typo was corrected).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HouseTasks)
## maybe str(HouseTasks) 

chisq.test(HouseTasks)

# mosaic plot, illustrating some tweaks to handle overlapping labels
require(vcd)
mosaic(HouseTasks, shade = TRUE,
       labeling = labeling_border(rot_labels = c(45,0, 0, 0), 
                                  offset_label =c(.5,5,0, 0),
                                  varnames = c(FALSE, TRUE),
                                  just_labels=c("center","right"),
                                  tl_varnames = FALSE),
       legend = FALSE)

# use seriation package to permute rows &amp; cols using correspondence analysis
if(require(seriation)) {
order &lt;- seriate(HouseTasks, method = "CA")
# the permuted row and column labels
rownames(HouseTasks)[order[[1]]]
colnames(HouseTasks)[order[[2]]]

# do the permutation
HT_perm &lt;- permute(HouseTasks, order, margin=1)

mosaic(HT_perm, shade = TRUE,
       labeling = labeling_border(rot_labels = c(45,0, 0, 0), 
                                  offset_label =c(.5,5,0, 0),
                                  varnames = c(FALSE, TRUE),
                                  just_labels=c("center","right"),
                                  tl_varnames = FALSE),
       legend = FALSE)
}
</code></pre>

<hr>
<h2 id='Hoyt'>Minnesota High School Graduates</h2><span id='topic+Hoyt'></span>

<h3>Description</h3>

<p>Minnesota high school graduates of June 1930 were classified with respect to 
(a) <code>Rank</code> by thirds in their graduating class, (b) post-high school <code>Status</code> in April 1939 (4 levels), (c) <code>Sex</code>, 
(d) father's <code>Occupation</code>al status (7 levels, from 1=High to 7=Low).
</p>
<p>The data were first presented by Hoyt et al. (1959) and have been analyzed by Fienberg(1980), Plackett(1974)
and others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Hoyt)
</code></pre>


<h3>Format</h3>

<p>A     4-dimensional array resulting from cross-tabulating    4 variables for 13968 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1</td><td style="text-align: left;"> <code>Status</code></td><td style="text-align: left;"> <code>"College", "School", "Job", "Other"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    2</td><td style="text-align: left;"> <code>Rank</code></td><td style="text-align: left;"> <code>"Low", "Middle", "High"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    3</td><td style="text-align: left;"> <code>Occupation</code></td><td style="text-align: left;"> <code>"1", "2", "3", "4", "5", "6", "7"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    4</td><td style="text-align: left;"> <code>Sex</code></td><td style="text-align: left;"> <code>"Male", "Female"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Post high-school <code>Status</code> is natural to consider as the response.
<code>Rank</code> and father's <code>Occupation</code> are ordinal variables.</p>


<h3>Source</h3>





<p>Fienberg, S. E. (1980).
<em>The Analysis of Cross-Classified Categorical Data</em>.
Cambridge, MA: MIT Press, p. 91-92.
</p>
<p>R. L. Plackett, (1974).
<em>The Analysis of Categorical Data</em>. London: Griffin.
</p>


<h3>References</h3>

<p>Hoyt, C. J., Krishnaiah, P. R. and Torrance, E. P. (1959) 
Analysis of complex contingency tables, 
<em>Journal of Experimental Education</em> 27, 187-194. 
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+minn38">minn38</a></code> provides the same data as a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Hoyt)

# display the table
structable(Status + Sex ~ Rank + Occupation, data=Hoyt)

# mosaic for independence model
plot(Hoyt, shade=TRUE)

# examine all pairwise mosaics
pairs(Hoyt, shade=TRUE)

# collapse Status to College vs. Non-College
Hoyt1 &lt;- collapse.table(Hoyt, Status=c("College", rep("Non-College",3)))
plot(Hoyt1, shade=TRUE)

#################################################
# fitting models with loglm, plotting with mosaic
#################################################

# fit baseline log-linear model for Status as response
require(MASS)
hoyt.mod0 &lt;- loglm(~ Status + (Sex*Rank*Occupation), 
  data=Hoyt1)
hoyt.mod0

mosaic(hoyt.mod0, 
  gp=shading_Friendly, 
  main="Baseline model: Status + (Sex*Rank*Occ)")

# add one-way association of Status with factors
hoyt.mod1 &lt;- loglm(~ Status * (Sex + Rank + Occupation) + (Sex*Rank*Occupation), 
  data=Hoyt1)
hoyt.mod1

mosaic(hoyt.mod1, 
  gp=shading_Friendly, 
  main="Status * (Sex + Rank + Occ)")

# can we drop any terms?
drop1(hoyt.mod1, test="Chisq")

# assess model fit
anova(hoyt.mod0, hoyt.mod1)

# what terms to add?
add1(hoyt.mod1, ~.^2, test="Chisq")

# add interaction of Sex:Occupation on Status
hoyt.mod2 &lt;- update(hoyt.mod1, ~ . + Status:Sex:Occupation)

mosaic(hoyt.mod2, 
  gp=shading_Friendly, 
  main="Adding Status:Sex:Occupation")

# compare model fits
anova(hoyt.mod0, hoyt.mod1, hoyt.mod2)

# Alternatively, try stepwise analysis, heading toward the saturated model
steps &lt;- step(hoyt.mod0, 
  direction="forward", 
  scope=~Status*Sex*Rank*Occupation)

# display anova
steps$anova

</code></pre>

<hr>
<h2 id='ICU'>ICU data set</h2><span id='topic+ICU'></span>

<h3>Description</h3>

<p>The ICU data set consists of a sample of 200 subjects who were part of
a much larger study on survival of patients following admission to an adult
intensive care unit (ICU), derived from  
Hosmer, Lemeshow and Sturdivant (2013) and Friendly (2000).
</p>
<p>The major goal of this study was to develop a
logistic regression model to predict the probability of survival to hospital
discharge of these patients and to study the risk factors associated with 
ICU mortality. The clinical details of the study are described in 
Lemeshow, Teres, Avrunin, and Pastides (1988).
</p>
<p>This data set is often used to illustrate model selection methods for
logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ICU)</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 22 variables.
</p>


<dl>
<dt><code>died</code></dt><dd><p>Died before discharge?, a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>age</code></dt><dd><p>Patient age, a numeric vector</p>
</dd>
<dt><code>sex</code></dt><dd><p>Patient sex, a factor with levels <code>Female</code> <code>Male</code></p>
</dd>
<dt><code>race</code></dt><dd><p>Patient race, a factor with levels <code>Black</code> <code>Other</code> <code>White</code>.  Also represented here as <code>white</code>.</p>
</dd>
<dt><code>service</code></dt><dd><p>Service at ICU Admission, a factor with levels <code>Medical</code> <code>Surgical</code></p>
</dd>
<dt><code>cancer</code></dt><dd><p>Cancer part of present problem?, a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>renal</code></dt><dd><p>History of chronic renal failure?, a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>infect</code></dt><dd><p>Infection probable at ICU admission?, a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>cpr</code></dt><dd><p>Patient received CPR prior to ICU admission?, a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>systolic</code></dt><dd><p>Systolic blood pressure at admission (mm Hg), a numeric vector</p>
</dd>
<dt><code>hrtrate</code></dt><dd><p>Heart rate at ICU Admission (beats/min), a numeric vector</p>
</dd>
<dt><code>previcu</code></dt><dd><p>Previous admission to an ICU within 6 Months?, a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>admit</code></dt><dd><p>Type of admission, a factor with levels <code>Elective</code> <code>Emergency</code></p>
</dd>
<dt><code>fracture</code></dt><dd><p>Admission with a long bone, multiple, neck, single area, or hip fracture?
a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>po2</code></dt><dd><p>PO2 from initial blood gases, a factor with levels <code>&gt;60</code> <code>&lt;=60</code></p>
</dd>
<dt><code>ph</code></dt><dd><p>pH from initial blood gases, a factor with levels <code>&gt;=7.25</code> <code>&lt;7.25</code></p>
</dd>
<dt><code>pco</code></dt><dd><p>PCO2 from initial blood gases, a factor with levels <code>&lt;=45</code> <code>&gt;45</code></p>
</dd>
<dt><code>bic</code></dt><dd><p>Bicarbonate (HCO3) level from initial blood gases, a factor with levels <code>&gt;=18</code> <code>&lt;18</code></p>
</dd>
<dt><code>creatin</code></dt><dd><p>Creatinine, from initial blood gases, a factor with levels <code>&lt;=2</code> <code>&gt;2</code></p>
</dd>
<dt><code>coma</code></dt><dd><p>Level of unconsciousness at admission to ICU,	a factor with levels <code>None</code> <code>Stupor</code> <code>Coma</code></p>
</dd>
<dt><code>white</code></dt><dd><p>a recoding of <code>race</code>,  a factor with levels <code>White</code> <code>Non-white</code></p>
</dd>
<dt><code>uncons</code></dt><dd><p>a recoding of <code>coma</code> a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>Patient ID numbers are the rownames of the data frame.
</p>
<p>Note that the last two variables <code>white</code> and <code>uncons</code> are a recoding of
respectively <code>race</code> and <code>coma</code> to binary variables.
</p>


<h3>Source</h3>

<p>M. Friendly (2000), <em>Visualizing Categorical Data</em>, Appendix B.4. SAS Institute, Cary, NC. 
</p>
<p>Hosmer, D. W. Jr., Lemeshow, S. and Sturdivant, R. X. (2013) 
<em>Applied Logistic Regression</em>, NY: Wiley,
Third Edition.	
</p>


<h3>References</h3>

<p>Lemeshow, S., Teres, D., Avrunin, J. S., Pastides, H. (1988). Predicting
the Outcome of Intensive Care Unit Patients. <em>Journal of the American
Statistical Association</em>, 83, 348-356.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ICU)
# remove redundant variables (race, coma)
ICU1 &lt;- ICU[,-c(4,20)]

# fit full model
icu.full &lt;- glm(died ~ ., data=ICU1, family=binomial)
summary(icu.full)

# simpler model (found from a "best" subsets procedure)
icu.mod1 &lt;- glm(died ~ age + sex + cancer + systolic + admit + uncons, 
  data=ICU1, 
  family=binomial)
summary(icu.mod1)

# even simpler model
icu.mod2 &lt;- glm(died ~ age + cancer  + admit + uncons, 
  data=ICU1, 
  family=binomial)
summary(icu.mod2)

anova(icu.mod2, icu.mod1, icu.full, test="Chisq")

## Reproduce Fig 6.12 from VCD

icu.fit &lt;- data.frame(ICU, prob=predict(icu.mod2, type="response"))

# combine categorical risk factors to a single string
risks &lt;- ICU[, c("cancer", "admit", "uncons")]
risks[,1] &lt;- ifelse(risks[,1]=="Yes", "Cancer", "")
risks[,2] &lt;- ifelse(risks[,2]=="Emergency", "Emerg", "")
risks[,3] &lt;- ifelse(risks[,3]=="Yes", "Uncons", "")
risks &lt;- apply(risks, 1, paste, collapse="")
risks[risks==""] &lt;- "(none)"
icu.fit$risks &lt;- risks

library(ggplot2)
ggplot(icu.fit, aes(x=age, y=prob, color=risks)) +
	geom_point(size=2) +
	geom_line(size=1.25, alpha=0.5) +
	theme_bw() + ylab("Probability of death")

</code></pre>

<hr>
<h2 id='JobSat'>Cross-classification of job satisfaction by income</h2><span id='topic+JobSat'></span>

<h3>Description</h3>

<p>This data set is a contingency table of job satisfaction by income for a small sample
of black males from the 1996 General Social Survey, as used by Agresti (2002) for
an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(JobSat)</code></pre>


<h3>Format</h3>

<p>A 4 x 4 contingency table of <code>income</code> by <code>satisfaction</code>, with the following structure:
</p>
<pre>
 table [1:4, 1:4] 1 2 1 0 3 3 6 1 10 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ income      : chr [1:4] "&lt; 15k" "15-25k" "25-40k" "&gt; 40k"
  ..$ satisfaction: chr [1:4] "VeryD" "LittleD" "ModerateS" "VeryS"
</pre>


<h3>Details</h3>

<p>Both <code>income</code> and <code>satisfaction</code> are ordinal variables, and are so ordered in the
table.  Measures of association, visualizations, and models should take ordinality into
account.
</p>


<h3>Source</h3>

<p>Agresti, A. Categorical Data Analysis John Wiley &amp; Sons, 2002,
Table 2.8, p. 57.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(JobSat)
assocstats(JobSat)
GKgamma(JobSat)
</code></pre>

<hr>
<h2 id='Kway'>
Fit All K-way Models in a GLM
</h2><span id='topic+Kway'></span>

<h3>Description</h3>

<p>Generate and fit all 0-way, 1-way, 2-way, ... k-way terms in a glm.
</p>
<p>This function is designed mainly for hierarchical
loglinear models (or <code>glm</code>s
in the poisson family), where it is desired to find the 
highest-order terms necessary to achieve a satisfactory fit.
</p>
<p>Using <code><a href="stats.html#topic+anova">anova</a></code> on the resulting <code><a href="#topic+glmlist">glmlist</a></code>
object will then give sequential tests of the pooled contributions of
all terms of degree <code class="reqn">k+1</code> over and above those of degree <code class="reqn">k</code>. 
</p>
<p>This function is also intended as an example of a generating function
for <code><a href="#topic+glmlist">glmlist</a></code> objects, to facilitate model comparison, extraction, 
summary and plotting of model components, etc., perhaps using <code>lapply</code> or similar. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kway(formula, family=poisson, data, ..., order = nt, prefix = "kway")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kway_+3A_formula">formula</code></td>
<td>

<p>a two-sided formula for the 1-way effects in the model.
The LHS should be the response, and the RHS should be the first-order terms
connected by <code>+</code> signs.
</p>
</td></tr>
<tr><td><code id="Kway_+3A_family">family</code></td>
<td>

<p>a description  of the  error distribution  and link  function to  be used in the
model.  This  can be  a  character string  naming  a family  function,  a family
function or the result of a call to a family function. 
(See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.)
</p>
</td></tr>
<tr><td><code id="Kway_+3A_data">data</code></td>
<td>

<p>an  optional  data   frame,  list  or   environment  (or  object   coercible  by
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a  data frame) containing  the variables in  the model. If  not
found in data, the variables are taken from <code>environment(formula)</code>, typically  the
environment from which <code>glm</code> is called.
</p>
</td></tr>
<tr><td><code id="Kway_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>glm</code></p>
</td></tr>
<tr><td><code id="Kway_+3A_order">order</code></td>
<td>
<p>Highest order interaction of the models generated. Defaults to the number of terms in the model formula.</p>
</td></tr>
<tr><td><code id="Kway_+3A_prefix">prefix</code></td>
<td>
<p>Prefix used to label the models fit in the <code>glmlist</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>y</code> as the response in the <code>formula</code>, the 0-way (null) model
is <code>y ~ 1</code>.  
The 1-way (&quot;main effects&quot;) model is that specified in the
<code>formula</code> argument.  The k-way model is generated using the formula
<code>. ~ .^k</code>.
With the default <code>order = nt</code>, the final model is the saturated model.
</p>
<p>As presently written, the function requires a two-sided formula with an explicit
response on the LHS. For frequency data in table form (e.g., produced by <code>xtabs</code>)
you the <code>data</code> argument is coerced to a data.frame, so you
should  supply the <code>formula</code> in the form <code>Freq ~ </code> ....
</p>


<h3>Value</h3>

<p>An object of class <code>glmlist</code>, of length <code>order+1</code>
containing the 0-way, 1-way, ... 
models up to degree <code>order</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly and Heather Turner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmlist">glmlist</a></code>, 
<code><a href="#topic+Summarise">Summarise</a></code> (soon to be deprecated),
<code><a href="#topic+LRstats">LRstats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## artificial data
factors &lt;- expand.grid(A=factor(1:3), 
                       B=factor(1:2), 
                       C=factor(1:3), 
                       D=factor(1:2))
Freq &lt;- rpois(nrow(factors), lambda=40)
df &lt;- cbind(factors, Freq)

mods3 &lt;- Kway(Freq ~ A + B + C, data=df, family=poisson)
LRstats(mods3)
mods4 &lt;- Kway(Freq ~ A + B + C + D, data=df, family=poisson)
LRstats(mods4)

# JobSatisfaction data
data(JobSatisfaction, package="vcd")
modSat &lt;- Kway(Freq ~ management+supervisor+own, 
               data=JobSatisfaction, 
               family=poisson, prefix="JobSat")
LRstats(modSat)
anova(modSat, test="Chisq")

# Rochdale data: very sparse, in table form
data(Rochdale, package="vcd")
## Not run: 
modRoch &lt;- Kway(Freq~EconActive + Age + HusbandEmployed + Child + 
                     Education + HusbandEducation + Asian + HouseholdWorking,
                data=Rochdale, family=poisson)
LRstats(modRoch)

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.loglm'>Log-Likelihood of a loglm Object</h2><span id='topic+logLik.loglm'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood value of the <code>loglm</code> model represented by <code>object</code> 
evaluated at the estimated coefficients.
</p>
<p>It allows the use of <code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>, which require
that a <code>logLik</code> method exists to extract the corresponding log-likelihood for the 
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loglm'
logLik(object, ..., zero=1E-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.loglm_+3A_object">object</code></td>
<td>
<p>A <code>loglm</code> object</p>
</td></tr>
<tr><td><code id="logLik.loglm_+3A_...">...</code></td>
<td>
<p>For compatibility with the S3 generic; not used here</p>
</td></tr>
<tr><td><code id="logLik.loglm_+3A_zero">zero</code></td>
<td>
<p>value used to replace zero frequencies in calculating the log-likelihood</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If cell frequencies have not been stored with the <code>loglm</code> object
(via the argument <code>keep.frequencies = TRUE</code>), they are obtained
using <code>update</code>.
</p>
<p>This function calculates the log-likelihood in a way that allows for non-integer
frequencies, such as the case where 0.5 has been added to all cell frequencies
to allow for sampling zeros.  If the frequencies still contain zero values,
those are replaced by the value of <code>start</code>.
</p>
<p>For integer frequencies, it gives the same result as the corresponding
model fit using <code><a href="stats.html#topic+glm">glm</a></code>, whereas <code><a href="stats.html#topic+glm">glm</a></code>
returns <code>-Inf</code> if there are any non-integer frequencies.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>logLik</code>. 
This is a number with one attribute, <code>"df"</code> (degrees of freedom), 
giving the number of (estimated) parameters in the model. </p>


<h3>Author(s)</h3>

<p>Achim Zeileis</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+loglm">loglm</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+BIC">BIC</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Titanic, package="datasets")  

require(MASS)
titanic.mod1 &lt;- loglm(~ (Class * Age * Sex) + Survived, data=Titanic)
titanic.mod2 &lt;- loglm(~ (Class * Age * Sex) + Survived*(Class + Age + Sex), data=Titanic)
titanic.mod3 &lt;- loglm(~ (Class * Age * Sex) + Survived*(Class + Age * Sex), data=Titanic)

logLik(titanic.mod1)
AIC(titanic.mod1, titanic.mod2, titanic.mod3)
BIC(titanic.mod1, titanic.mod2, titanic.mod3)

# compare with models fit using glm()
titanic &lt;- as.data.frame(Titanic)
titanic.glm1 &lt;- glm(Freq ~ (Class * Age * Sex) + Survived, 
                    data=titanic, family=poisson)
titanic.glm2 &lt;- glm(Freq ~ (Class * Age * Sex) + Survived*(Class + Age + Sex), 
                    data=titanic, family=poisson)
titanic.glm3 &lt;- glm(Freq ~ (Class * Age * Sex) + Survived*(Class + Age * Sex), 
                    data=titanic, family=poisson)

logLik(titanic.glm1)
AIC(titanic.glm1, titanic.glm2, titanic.glm3)
BIC(titanic.glm1, titanic.glm2, titanic.glm3)

</code></pre>

<hr>
<h2 id='loglin-utilities'>
Loglinear Model Utilities
</h2><span id='topic+loglin-utilities'></span><span id='topic+conditional'></span><span id='topic+joint'></span><span id='topic+loglin2formula'></span><span id='topic+loglin2string'></span><span id='topic+markov'></span><span id='topic+mutual'></span><span id='topic+saturated'></span>

<h3>Description</h3>

<p>These functions generate lists of terms to specify a loglinear model
in a form compatible with <code><a href="stats.html#topic+loglin">loglin</a></code> and also provide for conversion to an
equivalent <code><a href="MASS.html#topic+loglm">loglm</a></code> specification or a shorthand character
string representation.
</p>
<p>They allow for a more conceptual
way to specify such models by a function for their type, as opposed
to just an uninterpreted list of model terms
and also allow
easy specification of marginal models for a given contingency table.
</p>
<p>They are intended to be used as tools in higher-level modeling and 
graphics functions, but can also be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
conditional(nf, table = NULL, factors = 1:nf, with = nf)

joint(nf, table = NULL, factors = 1:nf, with = nf)

markov(nf, factors = 1:nf, order = 1)

mutual(nf, table = NULL, factors = 1:nf)

saturated(nf, table = NULL, factors = 1:nf)

loglin2formula(x, env = parent.frame())

loglin2string(x, brackets = c("[", "]"), sep = ",", collapse = " ", abbrev)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglin-utilities_+3A_nf">nf</code></td>
<td>

<p>number of factors for which to generate the model
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_table">table</code></td>
<td>

<p>a contingency table used only for factor names in the model, typically the output from <code><a href="base.html#topic+table">table</a></code>
and possibly permuted with <code>aperm</code>
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_factors">factors</code></td>
<td>

<p>names of factors used in the model formula when <code>table</code> is not specified
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_with">with</code></td>
<td>

<p>For <code>joint</code> and <code>conditional</code> models, <code>with</code> gives the
indices of the factors against which all others are considered jointly 
or conditionally independent
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_order">order</code></td>
<td>

<p>For <code>markov</code>, this gives the order of the Markov chain model for the
factors.  An <code>order=1</code> Markov chain allows associations among
sequential pairs of factors, e.g., <code>[A,B], [B,C], [C,D]</code> ....
An <code>order=2</code> Markov chain allows associations among
sequential triples.
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_x">x</code></td>
<td>

<p>For the <code>loglin2*</code> functions, 
a list of terms in a loglinear model, such as returned by <code>conditional</code>, <code>joint</code>, 
...
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_env">env</code></td>
<td>

<p>For <code>loglin2formula</code>, environment in which to evaluate the formula
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_brackets">brackets</code></td>
<td>

<p>For <code>loglin2string</code>, 
characters to use to surround model terms.  
Either a single character string containing two characters (e.g., <code>'[]'</code>
or a character vector of length two.
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_sep">sep</code></td>
<td>

<p>For <code>loglin2string</code>,
the separator character string used for factor names within a given model term
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_collapse">collapse</code></td>
<td>

<p>For <code>loglin2string</code>,
the character string used between terms in the the model string
</p>
</td></tr>
<tr><td><code id="loglin-utilities_+3A_abbrev">abbrev</code></td>
<td>

<p>For <code>loglin2string</code>,
whether and how to abbreviate the terms in the string representation.
This has not yet been implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main model specification functions, <code>conditional</code>, <code>joint</code>, 
<code>markov</code>, ..., <code>saturated</code>,
return a list of vectors indicating the marginal totals to be fit,
via the <code>margin</code> argument to <code><a href="stats.html#topic+loglin">loglin</a></code>.
Each element of this list corresponds to a high-order
term in a hierarchical loglinear model, where, e.g., a term
like <code>c("A", "B")</code> is equivalent to the <code><a href="MASS.html#topic+loglm">loglm</a></code>
term <code>"A:B"</code> and hence automatically includes all low-order terms.
</p>
<p>Note that these can be used to supply the <code>expected</code> argument for
the default <code><a href="vcd.html#topic+mosaic">mosaic</a></code> function, when the data is supplied
as a contingency table.
</p>
<p>The table below shows some typical results in terms of the standard shorthand
notation for loglinear models, with factors A, B, C, ..., where brackets
are used to delimit the high-order terms in the loglinear model.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>function</strong> </td><td style="text-align: left;"> <strong>3-way</strong> </td><td style="text-align: left;"> <strong>4-way</strong> </td><td style="text-align: left;"> <strong>5-way</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mutual</code> </td><td style="text-align: left;">  [A]  [B]  [C]  </td><td style="text-align: left;">
             [A]  [B]  [C]  [D]  </td><td style="text-align: left;">
             [A]  [B]  [C]  [D]  [E] </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>joint</code>  </td><td style="text-align: left;">  [AB]  [C]  </td><td style="text-align: left;">
             [ABC]  [D]  </td><td style="text-align: left;">
             [ABCE]  [E]  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>joint (with=1)</code> </td><td style="text-align: left;"> 
             [A]  [BC]  </td><td style="text-align: left;">
             [A]  [BCD]  </td><td style="text-align: left;">
             [A]  [BCDE]  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>conditional</code>  </td><td style="text-align: left;"> 
             [AC]  [BC]  </td><td style="text-align: left;"> 
             [AD]  [BD]  [CD]  </td><td style="text-align: left;">
             [AE]  [BE]  [CE]  [DE] </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>condit (with=1)</code>  </td><td style="text-align: left;"> 
             [AB]  [AC]  </td><td style="text-align: left;"> 
             [AB]  [AC]  [AD]  </td><td style="text-align: left;">
             [AB]  [AC]  [AD]  [AE] </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>markov (order=1)</code>  </td><td style="text-align: left;">  
             [AB]  [BC]  </td><td style="text-align: left;">
             [AB]  [BC]  [CD]  </td><td style="text-align: left;">
             [AB]  [BC]  [CD]  [DE] </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>markov (order=2)</code>  </td><td style="text-align: left;"> 
             [A]  [B]  [C]  </td><td style="text-align: left;">
             [ABC]  [BCD]  </td><td style="text-align: left;">
             [ABC]  [BCD]  [CDE]  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>saturated</code>  </td><td style="text-align: left;">
             [ABC] </td><td style="text-align: left;"> [ABCD] </td><td style="text-align: left;"> [ABCDE] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>loglin2formula</code> converts the output of one of these to a model formula
suitable as the <code>formula</code> for of <code><a href="MASS.html#topic+loglm">loglm</a></code>.
</p>
<p><code>loglin2string</code> converts the output of one of these to a string
describing the loglinear model in the shorthand bracket notation,
e.g., <code>"[A,B] [A,C]"</code>.  
</p>


<h3>Value</h3>

<p>For the main model specification functions, <code>conditional</code>, <code>joint</code>, 
<code>markov</code>, ..., the result is
a list of vectors (terms), where the elements in each vector are the
names of the factors. The elements of the list are given names
<code>term1, term2, ...</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>These functions were inspired by the original SAS implementation of
mosaic displays, described in the <em>User's Guide</em>,
<a href="http://www.datavis.ca/mosaics/mosaics.pdf">http://www.datavis.ca/mosaics/mosaics.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+loglin">loglin</a></code>,
<code><a href="MASS.html#topic+loglm">loglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>joint(3, table=HairEyeColor)
# as a formula or string
loglin2formula(joint(3, table=HairEyeColor))
loglin2string(joint(3, table=HairEyeColor))

joint(2, HairEyeColor)  # marginal model for [Hair] [Eye]

# other possibilities
joint(4, factors=letters, with=1)
joint(5, factors=LETTERS)
joint(5, factors=LETTERS, with=4:5)

conditional(4)
conditional(4, with=3:4)

# use in mosaic displays or other strucplots
mosaic(HairEyeColor, expected=joint(3))
mosaic(HairEyeColor, expected=conditional(3))

# use with MASS::loglm
cond3 &lt;- loglin2formula(conditional(3, table=HairEyeColor))
cond3 &lt;- loglin2formula(conditional(3))  # same, with factors 1,2,3
require(MASS)
loglm(cond3, data=HairEyeColor)

saturated(3, HairEyeColor)
loglin2formula(saturated(3, HairEyeColor))
loglin2string(saturated(3, HairEyeColor))
loglin2string(saturated(3, HairEyeColor), brackets='{}', sep=', ')

</code></pre>

<hr>
<h2 id='logseries'>
The Logarithmic Series Distribution
</h2><span id='topic+Logseries'></span><span id='topic+dlogseries'></span><span id='topic+plogseries'></span><span id='topic+qlogseries'></span><span id='topic+rlogseries'></span>

<h3>Description</h3>

<p>The logarithmic series distribution is a long-tailed distribution
introduced by
Fisher etal. (1943)
in connection with data on the abundance of individuals
classified by species. 
</p>
<p>These functions provide the density, distribution function, quantile function and 
random generation for the 
logarithmic series distribution with parameter <code>prob</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
dlogseries(x, prob = 0.5, log = FALSE)

plogseries(q, prob = 0.5, lower.tail = TRUE, log.p = FALSE)

qlogseries(p, prob = 0.5, lower.tail = TRUE, log.p = FALSE, max.value = 10000)

rlogseries(n, prob = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logseries_+3A_x">x</code>, <code id="logseries_+3A_q">q</code></td>
<td>

<p>vector of quantiles representing the number of events.
</p>
</td></tr>
<tr><td><code id="logseries_+3A_prob">prob</code></td>
<td>

<p>parameter for the distribution, <code>0 &lt; prob &lt; 1</code>
</p>
</td></tr>
<tr><td><code id="logseries_+3A_log">log</code>, <code id="logseries_+3A_log.p">log.p</code></td>
<td>

<p>logical; if TRUE, probabilities <code>p</code> are given as <code>log(p)</code>
</p>
</td></tr>
<tr><td><code id="logseries_+3A_lower.tail">lower.tail</code></td>
<td>

<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>, 
otherwise, <code class="reqn">P[X &gt; x]</code>.
</p>
</td></tr>
<tr><td><code id="logseries_+3A_p">p</code></td>
<td>

<p>vector of probabilities
</p>
</td></tr>
<tr><td><code id="logseries_+3A_max.value">max.value</code></td>
<td>

<p>maximum value returned by <code>qlogseries</code>
</p>
</td></tr>
<tr><td><code id="logseries_+3A_n">n</code></td>
<td>

<p>number of observations for <code>rlogseries</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logarithmic series distribution with <code>prob</code> = <code class="reqn">p</code> has density
</p>
<p style="text-align: center;"><code class="reqn">
	p ( x )  = \alpha p^x / x
</code>
</p>

<p>for <code class="reqn">x = 1, 2, \dots</code>, where <code class="reqn">\alpha= -1 / \log(1 - p)</code>
and <code class="reqn">0 &lt; p &lt;1</code>.  Note that counts <code>x==2</code> cannot occur.
</p>


<h3>Value</h3>

<p><code>dlogseries</code> gives the density, 
<code>plogseries</code> gives the distribution function, 
<code>qlogseries</code> gives the quantile function, and 
<code>rlogseries</code> generates random deviates.
</p>







<h3>Author(s)</h3>

<p>Michael Friendly, using
original code modified from the <code>gmlss.dist</code> package
by Mikis Stasinopoulos.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Logarithmic_distribution">https://en.wikipedia.org/wiki/Logarithmic_distribution</a>
</p>
<p>Fisher, R. A. and Corbet, A. S. and Williams, C. B. (1943).
The relation between the number of species and the number of individuals 
<em>Journal of Animal Ecology</em>, 12, 42-58.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Distributions">Distributions</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XL &lt;-expand.grid(x=1:5, p=c(0.33, 0.66, 0.99))
lgs.df &lt;- data.frame(XL, prob=dlogseries(XL[,"x"], XL[,"p"]))
lgs.df$p = factor(lgs.df$p)
str(lgs.df)

require(lattice)
mycol &lt;- palette()[2:4]
xyplot( prob ~ x, data=lgs.df, groups=p,
	xlab=list('Number of events (k)', cex=1.25),
	ylab=list('Probability',  cex=1.25),
	type='b', pch=15:17, lwd=2, cex=1.25, col=mycol,
	key = list(
					title = 'p',
					points = list(pch=15:17, col=mycol, cex=1.25),
					lines = list(lwd=2, col=mycol),
					text = list(levels(lgs.df$p)),
					x=0.9, y=0.98, corner=c(x=1, y=1)
					)
	)


# random numbers
hist(rlogseries(200, prob=.4), xlab='x')
hist(rlogseries(200, prob=.8), xlab='x')

</code></pre>

<hr>
<h2 id='LRstats'>
Brief Summary of Model Fit for glm and loglm Models
</h2><span id='topic+LRstats'></span><span id='topic+LRstats.glmlist'></span><span id='topic+LRstats.loglmlist'></span><span id='topic+LRstats.default'></span>

<h3>Description</h3>

<p>For <code>glm</code> objects, the <code>print</code> and <code>summary</code> methods give
too much information if all one wants to see is a brief summary of model
goodness of fit, and there is no easy way to display a compact comparison of
model goodness of fit for a collection of models fit to the same data.
All <code>loglm</code> models have equivalent glm forms, but the 
<code>print</code> and <code>summary</code> methods give quite different results.
</p>
<p><code>LRstats</code> provides a brief summary for one or more models
fit to the same dataset
for which <code>logLik</code> and <code>nobs</code> methods exist
(e.g., <code>glm</code> and <code>loglm</code> models).

</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRstats(object, ...)

## S3 method for class 'glmlist'
LRstats(object, ..., saturated = NULL, sortby = NULL)
## S3 method for class 'loglmlist'
LRstats(object, ..., saturated = NULL, sortby = NULL)
## Default S3 method:
LRstats(object, ..., saturated = NULL, sortby = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LRstats_+3A_object">object</code></td>
<td>

<p>a fitted model object for which there exists a logLik method to extract the corresponding log-likelihood</p>
</td></tr>
<tr><td><code id="LRstats_+3A_...">...</code></td>
<td>

<p>optionally more fitted model objects
</p>
</td></tr>
<tr><td><code id="LRstats_+3A_saturated">saturated</code></td>
<td>

<p>saturated model log likelihood reference value (use 0 if deviance is not available)
</p>
</td></tr>
<tr><td><code id="LRstats_+3A_sortby">sortby</code></td>
<td>

<p>either a numeric or character string specifying
the column in the result by which the rows are sorted (in decreasing order)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function relies on residual degrees of freedom for the LR chisq test being available
in the model object.  This is true for objects inheriting from 
<code>lm</code>, <code>glm</code>, <code>loglm</code>, <code>polr</code>
and <code>negbin</code>.
</p>


<h3>Value</h3>

<p>A data frame (also of class <code>anova</code>) with columns 
<code>c("AIC", "BIC", "LR Chisq", "Df", "Pr(&gt;Chisq)")</code>.
Row names are taken from the names of the model object(s).
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="MASS.html#topic+loglm">loglm</a></code>, 
</p>
<p><code><a href="#topic+logLik.loglm">logLik.loglm</a></code>, <code><a href="#topic+modFit">modFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mental)
indep &lt;- glm(Freq ~ mental+ses,
                family = poisson, data = Mental)
LRstats(indep)
Cscore &lt;- as.numeric(Mental$ses)
Rscore &lt;- as.numeric(Mental$mental)

coleff &lt;- glm(Freq ~ mental + ses + Rscore:ses,
                family = poisson, data = Mental)
roweff &lt;- glm(Freq ~ mental + ses + mental:Cscore,
                family = poisson, data = Mental)
linlin &lt;- glm(Freq ~ mental + ses + Rscore:Cscore,
                family = poisson, data = Mental)
                
# compare models
LRstats(indep, coleff, roweff, linlin)

</code></pre>

<hr>
<h2 id='Mammograms'>Mammogram Ratings</h2><span id='topic+Mammograms'></span>

<h3>Description</h3>

<p>Kundel &amp; Polansky (2003) give (possibly contrived) data on a 
set of 110 mammograms rated by two readers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Mammograms)</code></pre>


<h3>Format</h3>

<p>A frequency table in matrix form.  The format is:
num [1:4, 1:4] 34 6 2 0 10 8 5 1 2 8 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ Reader2: chr [1:4] &quot;Absent&quot; &quot;Minimal&quot; &quot;Moderate&quot; &quot;Severe&quot;
..$ Reader1: chr [1:4] &quot;Absent&quot; &quot;Minimal&quot; &quot;Moderate&quot; &quot;Severe&quot;
</p>


<h3>Source</h3>

<p>Kundel, H. L. &amp; Polansky, M. (2003), 
&quot;Measurement of Observer Agreement&quot;, <em>Radiology</em>, <b>228</b>, 303-308, Table A1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mammograms)
B &lt;- agreementplot(Mammograms, main="Mammogram ratings")
# agreement measures
B
Kappa(Mammograms)

## other displays
mosaic(Mammograms, shade=TRUE)

sieve(Mammograms, pop = FALSE, shade = TRUE)
labeling_cells(text = Mammograms, 
  gp_text = gpar(fontface = 2, cex=1.75))(as.table(Mammograms))
</code></pre>

<hr>
<h2 id='mcaplot'>Simple and enhanced plot of MCA solutions</h2><span id='topic+mcaplot'></span>

<h3>Description</h3>

<p>This function is intended as an alternative to <code><a href="ca.html#topic+plot.mjca">plot.mjca</a></code>
for plotting multiple correspondence analysis solutions.
It provides more flexibility for labeling factor levels and connecting
them with lines. It does not support some features of
<code>plot.mjca</code> (centroids, supplementary points, arrows, etc.) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcaplot(obj, 
  map = "symmetric", 
  dim = 1:2, 
  col = c("blue", "red", "brown", "black", "green3", "purple"), 
  pch = 15:20, 
  cex = 1.2, 
  pos = 3, 
  lines = TRUE, 
  lwd = 2, 
  legend = FALSE, 
  legend.pos = "topright", 
  xlab = "_auto_", 
  ylab = "_auto_", 
  rev.axes  = c(FALSE, FALSE),
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcaplot_+3A_obj">obj</code></td>
<td>
<p>An <code>"mjca"</code> object</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_map">map</code></td>
<td>
<p>Character string specifying the map type, i.e., the scaling applied to coordinates
for different types of MCA representations.
Allowed options include:
<code>"symmetric"</code> (default),
<code>"rowprincipal"</code>,   <code>"colprincipal"</code>, <code>"symbiplot"</code>,
<code>"rowgab"</code>, <code>"colgab"</code>, <code>"rowgreen"</code>, <code>"colgreen"</code>.
See <code><a href="ca.html#topic+mjca">mjca</a></code> for details.
</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_dim">dim</code></td>
<td>
<p>Dimensions to plot, an integer vector of length 2</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_col">col</code></td>
<td>
<p>Vector of colors, one for each factor in the MCA</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_pch">pch</code></td>
<td>
<p>Vector of point symbols for the category levels, one for each factor</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_cex">cex</code></td>
<td>
<p>Character size for points and level labels</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_pos">pos</code></td>
<td>
<p>Position of level labels relative to the category points; either a single number or a vector of length equal to the number of category points.</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_lines">lines</code></td>
<td>
<p>A logical or an integer vector indicating which factors are to be
joined with lines using <code><a href="ca.html#topic+multilines">multilines</a></code></p>
</td></tr>
<tr><td><code id="mcaplot_+3A_lwd">lwd</code></td>
<td>
<p>Line width(s) for the lines</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_legend">legend</code></td>
<td>
<p>Logical; draw a legend for the factor names?</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Position of the legend in the plot, as in <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="mcaplot_+3A_xlab">xlab</code>, <code id="mcaplot_+3A_ylab">ylab</code></td>
<td>
<p>Labels for horizontal and vertical axes. 
The default, <code>"_auto_"</code> means that the function auto-generates a label of 
the form <code>"Dimension X (xx.x %)"</code>
</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_rev.axes">rev.axes</code></td>
<td>
<p>A logical vector of length 2, where TRUE reverses the direction of the
corresponding axis</p>
</td></tr>
<tr><td><code id="mcaplot_+3A_...">...</code></td>
<td>
<p>Arguments passed down to <code>plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the coordinates of the category points invisibly





</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="ca.html#topic+mjca">mjca</a></code>,
<code><a href="ca.html#topic+plot.mjca">plot.mjca</a></code>
</p>
<p><code><a href="ca.html#topic+cacoord">cacoord</a></code> returns CA and MCA coordinates,
<code><a href="ca.html#topic+multilines">multilines</a></code> draw multiple lines according to a factor,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ca)
data(Titanic)
titanic.mca &lt;- mjca(Titanic)
mcaplot(titanic.mca, legend=TRUE, legend.pos="topleft")

data(HairEyeColor)
haireye.mca &lt;- mjca(HairEyeColor)
mcaplot(haireye.mca, legend=TRUE, cex.lab=1.3)


</code></pre>

<hr>
<h2 id='Mental'>Mental Impairment and Parents SES</h2><span id='topic+Mental'></span>

<h3>Description</h3>

<p>A 6 x 4 contingency table representing the cross-classification of
mental health status (<code>mental</code>) of 1660 young New York residents by
their parents' socioeconomic status (<code>ses</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Mental)</code></pre>


<h3>Format</h3>

<p>A data frame frequency table with 24 observations on the following 3 variables.
</p>

<dl>
<dt><code>ses</code></dt><dd><p>an ordered factor with levels <code>1</code> &lt; <code>2</code> &lt; <code>3</code> &lt; <code>4</code> &lt; <code>5</code> &lt; <code>6</code></p>
</dd>
<dt><code>mental</code></dt><dd><p>an ordered factor with levels <code>Well</code> &lt; <code>Mild</code> &lt; <code>Moderate</code> &lt; <code>Impaired</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>cell frequency: a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Both <code>ses</code> and <code>mental</code> can be treated as ordered factors or
integer scores.  For <code>ses</code>, 1=&quot;High&quot; and 6=&quot;Low&quot;.
</p>


<h3>Source</h3>

<p>Haberman, S. J. 
<em>The Analysis of Qualitative Data: New Developments</em>, Academic Press, 1979, Vol. II,
p. 375.
</p>
<p>Srole, L.; Langner, T. S.; Michael, S. T.; Kirkpatrick, P.; Opler, M. K. &amp; Rennie, T. A. C. 
<em>Mental Health in the Metropolis: The Midtown Manhattan Study</em>,
NYU Press, 1978, p. 289
</p>


<h3>References</h3>

<p>Friendly, M. <em>Visualizing Categorical Data</em>, Cary, NC: SAS Institute, 2000, Appendix B.7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mental)
str(Mental)
(Mental.tab &lt;- xtabs(Freq ~ ses + mental, data=Mental))

# mosaic and sieve plots
mosaic(Mental.tab, gp=shading_Friendly)
sieve(Mental.tab, gp=shading_Friendly)

if(require(ca)){
  plot(ca(Mental.tab), main="Mental impairment &amp; SES")
}

</code></pre>

<hr>
<h2 id='Mice'>Mice Depletion Data</h2><span id='topic+Mice'></span>

<h3>Description</h3>

<p>Data from Kastenbaum and Lamphiear (1959).
The table gives the number of depletions (deaths) in 657 litters of mice, classified by
litter size and treatment.  This data set has become a classic in the analysis of
contingency tables, yet unfortunately little information on the details of the
experiment has been published.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Mice")</code></pre>


<h3>Format</h3>

<p>A frequency data frame with 30 observations on the following 4 variables, representing a 5 x 2 x 3 contingency table.
</p>

<dl>
<dt><code>litter</code></dt><dd><p>litter size, a numeric vector</p>
</dd>
<dt><code>treatment</code></dt><dd><p>treatment, a factor with levels <code>A</code> <code>B</code></p>
</dd>
<dt><code>deaths</code></dt><dd><p>number of depletions, a factor with levels <code>0</code> <code>1</code> <code>2+</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>cell frequency, a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Goodman, L. A. (1983)
The analysis of dependence in cross-classifications having ordered categories, using log-linear models for frequencies and log-linear models for odds.
<em>Biometrics</em>, 39, 149-160.
</p>


<h3>References</h3>

<p>Kastenbaum, M. A. &amp; Lamphiear, D. E. (1959)
Calculation of chi-square to calculate the no three-factor interaction hypothesis. <em>Biometrics</em>, 15, 107-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(Mice)
# make a table
ftable(mice.tab &lt;- xtabs(Freq ~ litter + treatment + deaths, data=Mice))

#library(vcd)
vcd::mosaic(mice.tab, shade=TRUE)

</code></pre>

<hr>
<h2 id='Mobility'>Social Mobility data</h2><span id='topic+Mobility'></span>

<h3>Description</h3>

<p>Data on social mobility, recording the occupational category of fathers and their sons. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Mobility)</code></pre>


<h3>Format</h3>

<p>A 2-dimensional array resulting from cross-tabulating 2 variables for 19912 observations. The variable names and their levels are:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1</td><td style="text-align: left;"> <code>Son's_Occupation}\tab \code{"UpNonMan", "LoNonMan", "UpManual", "LoManual", "Farm"}\cr
    2\tab \code{Father's_Occupation</code></td><td style="text-align: left;"> <code>"UpNonMan", "LoNonMan", "UpManual", "LoManual", "Farm"</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Falguerolles, A. de and Mathieu, J. R. (1988). 
<em>Proceedings of COMPSTAT 88</em>, Copenhagen,  Denmark, Springer-Verlag.
</p>

<p>Featherman, D. L. and Hauser, R. M.
Occupations and social mobility in the United States. 
<em>Sociological Microjournal</em>, 12,
Fiche 62. Copenhagen: Sociological Institute.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Glass">Glass</a></code>, 
<code><a href="#topic+Hauser79">Hauser79</a></code>,
<code><a href="#topic+Yamaguchi87">Yamaguchi87</a></code> for other examples of mobility data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mobility)
Mobility

# independence model
MASS::loglm(~Father_Occupation + Son_Occupation, data = Mobility)

vcd::mosaic(Mobility, shade=TRUE, legend = FALSE)


</code></pre>

<hr>
<h2 id='modFit'>Brief Summary of Model Fit for a glm or loglm Object</h2><span id='topic+modFit'></span><span id='topic+modFit.loglm'></span><span id='topic+modFit.glm'></span>

<h3>Description</h3>

<p>Formats a brief summary of model fit for a <code>glm</code> or <code>loglm</code> object, showing
the likelihood ratio Chisq (df) value and or AIC.  Useful for inclusion in a plot
title or annotation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modFit(x, ...)
## S3 method for class 'glm'
modFit(x, stats="chisq", digits=2, ...)
## S3 method for class 'loglm'
modFit(x, stats="chisq", digits=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modFit_+3A_x">x</code></td>
<td>
<p>A <code>glm</code> or <code>loglm</code> object</p>
</td></tr>
<tr><td><code id="modFit_+3A_...">...</code></td>
<td>
<p>Arguments passed down</p>
</td></tr>
<tr><td><code id="modFit_+3A_stats">stats</code></td>
<td>
<p>One or more of <code>chisq</code> or <code>aic</code>, determining the statistics displayed.</p>
</td></tr>
<tr><td><code id="modFit_+3A_digits">digits</code></td>
<td>
<p>Number of digits after the decimal point in displayed statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string containing the formatted values of the chosen statistics.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly</p>


<h3>See Also</h3>

<p><code><a href="#topic+Summarise">Summarise</a></code> (soon to be deprecated),
<code><a href="#topic+LRstats">LRstats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mental)
require(MASS)
(Mental.tab &lt;- xtabs(Freq ~ ses + mental, data=Mental))
(Mental.mod &lt;- loglm(~ses + mental, Mental.tab))
Mental.mod
modFit(Mental.mod)

# use to label mosaic()
mosaic(Mental.mod, main=paste("Independence model,", modFit(Mental.mod)))
</code></pre>

<hr>
<h2 id='mosaic.glm'>Mosaic plots for fitted generalized linear and generalized nonlinear models </h2><span id='topic+mosaic.glm'></span><span id='topic+sieve.glm'></span><span id='topic+assoc.glm'></span>

<h3>Description</h3>

<p>Produces mosaic plots (and other plots in the <code><a href="vcd.html#topic+strucplot">strucplot</a></code> framework) 
for a log-linear model fitted with <code><a href="stats.html#topic+glm">glm</a></code>
or for a generalized nonlinear model fitted with <code><a href="gnm.html#topic+gnm">gnm</a></code>.
</p>
<p>These methods extend the range of strucplot
visualizations well beyond the models that can
be fit with <code><a href="MASS.html#topic+loglm">loglm</a></code>.
They are intended for models for counts using the Poisson family (or quasi-poisson),
but should be sensible as long as (a) the response variable is non-negative and (b) the
predictors visualized in the <code>strucplot</code> are discrete factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
mosaic(x, formula = NULL, panel = mosaic, 
     type = c("observed", "expected"), 
     residuals = NULL, 
     residuals_type = c("pearson", "deviance", "rstandard"), 
     gp = shading_hcl, gp_args = list(), ...)
## S3 method for class 'glm'
sieve(x,  ...)
## S3 method for class 'glm'
assoc(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic.glm_+3A_x">x</code></td>
<td>
<p> A <code>glm</code> or <code>gnm</code> object. The response variable, typically a 
cell frequency, should be non-negative. </p>
</td></tr>
<tr><td><code id="mosaic.glm_+3A_formula">formula</code></td>
<td>
<p> A one-sided formula with the indexing factors of the plot
separated by '+', determining the order in which the variables are used in the mosaic. 
A formula must be provided unless <code>x$data</code>
inherits from class <code>"table"</code> &ndash; in which case the indexing
factors of this table are used, or the factors in <code>x$data</code>
(or model.frame(x) if <code>x$data</code> is an environment) exactly
cross-classify the data &ndash; in which case this set of
cross-classifying factors are used. </p>
</td></tr> 
<tr><td><code id="mosaic.glm_+3A_panel">panel</code></td>
<td>
<p>Panel function used to draw the plot for visualizing the observed values, residuals 
and expected values. Currently, one of <code>"mosaic"</code>, <code>"assoc"</code>, or <code>"sieve"</code>
in <code>vcd</code>.</p>
</td></tr>
<tr><td><code id="mosaic.glm_+3A_type">type</code></td>
<td>
<p>A character string indicating whether the 
<code>"observed"</code> or the <code>"expected"</code> values of the table should be visualized
by the area of the tiles or bars.</p>
</td></tr>
<tr><td><code id="mosaic.glm_+3A_residuals">residuals</code></td>
<td>
<p> An optional array or vector of residuals corresponding to the cells in the
data, for example, as calculated by <code>residuals.glm(x)</code>, <code>residuals.gnm(x)</code>.</p>
</td></tr>
<tr><td><code id="mosaic.glm_+3A_residuals_type">residuals_type</code></td>
<td>
<p>If the <code>residuals</code> argument is <code>NULL</code>, residuals are calculated internally
and used in the display.  In this case, <code>residual_type</code> can be <code>"pearson"</code>, 
<code>"deviance"</code> or <code>"rstandard"</code>.  Otherwise (when <code>residuals</code> is supplied),
<code>residuals_type</code> is used as a label for the legend in the 
plot.  
</p>
</td></tr>
<tr><td><code id="mosaic.glm_+3A_gp">gp</code></td>
<td>
<p>Object of class <code>"gpar"</code>, shading function or a corresponding generating function 
(see <code><a href="vcd.html#topic+strucplot">strucplot</a></code> Details and <code><a href="vcd.html#topic+shadings">shadings</a></code>). 
Ignored if shade = FALSE.</p>
</td></tr>
<tr><td><code id="mosaic.glm_+3A_gp_args">gp_args</code></td>
<td>
<p>A list of arguments for the shading-generating function, if specified.</p>
</td></tr>
<tr><td><code id="mosaic.glm_+3A_...">...</code></td>
<td>
<p> Other arguments passed to the <code>panel</code> function e.g., <code><a href="vcd.html#topic+mosaic">mosaic</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For both poisson family generalized linear models and loglinear models, standardized residuals
provided by <code>rstandard</code>
(sometimes called adjusted residuals) are often preferred because they have 
constant unit asymptotic variance.
</p>
<p>The <code>sieve</code> and <code>assoc</code> methods are simple convenience interfaces to this plot method, setting the panel argument accordingly. 
</p>


<h3>Value</h3>

<p>The <code>structable</code> visualized by <code><a href="vcd.html#topic+strucplot">strucplot</a></code> is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Heather Turner, Michael Friendly, with help from Achim Zeileis</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="gnm.html#topic+gnm">gnm</a></code>, <code><a href="vcd.html#topic+plot.loglm">plot.loglm</a></code>, <code><a href="vcd.html#topic+mosaic">mosaic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GSStab &lt;- xtabs(count ~ sex + party, data=GSS)
# using the data in table form
mod.glm1 &lt;- glm(Freq ~ sex + party, family = poisson, data = GSStab)
res &lt;- residuals(mod.glm1)    
std &lt;- rstandard(mod.glm1)

# For mosaic.default(), need to re-shape residuals to conform to data
stdtab &lt;- array(std, 
                dim=dim(GSStab), 
                dimnames=dimnames(GSStab))

mosaic(GSStab, 
       gp=shading_Friendly, 
       residuals=stdtab, 
       residuals_type="Std\nresiduals", 
       labeling = labeling_residuals)


# Using externally calculated residuals with the glm() object
mosaic.glm(mod.glm1, 
           residuals=std, 
           labeling = labeling_residuals, 
           shade=TRUE)

# Using residuals_type
mosaic.glm(mod.glm1, 
           residuals_type="rstandard", 
           labeling = labeling_residuals, shade=TRUE)

## Ordinal factors and structured associations
data(Mental)
xtabs(Freq ~ mental+ses, data=Mental)
long.labels &lt;- list(set_varnames = c(mental="Mental Health Status", 
                                     ses="Parent SES"))

# fit independence model
# Residual deviance: 47.418 on 15 degrees of freedom
indep &lt;- glm(Freq ~ mental+ses,
             family = poisson, data = Mental)

long.labels &lt;- list(set_varnames = c(mental="Mental Health Status", 
                                     ses="Parent SES"))
mosaic(indep,
       residuals_type="rstandard", 
       labeling_args = long.labels, 
       labeling=labeling_residuals)

# or, show as a sieve diagram
mosaic(indep, 
       labeling_args = long.labels, 
       panel=sieve, 
       gp=shading_Friendly)

# fit linear x linear (uniform) association.  Use integer scores for rows/cols 
Cscore &lt;- as.numeric(Mental$ses)
Rscore &lt;- as.numeric(Mental$mental)

linlin &lt;- glm(Freq ~ mental + ses + Rscore:Cscore,
                family = poisson, data = Mental)

mosaic(linlin,
       residuals_type="rstandard", 
       labeling_args = long.labels, 
       labeling=labeling_residuals, 
       suppress=1, 
       gp=shading_Friendly,
       main="Lin x Lin model")

##  Goodman Row-Column association model fits even better (deviance 3.57, df 8)
if (require(gnm)) {
Mental$mental &lt;- C(Mental$mental, treatment)
Mental$ses &lt;- C(Mental$ses, treatment)
RC1model &lt;- gnm(Freq ~ ses + mental + Mult(ses, mental),
                family = poisson, data = Mental)

mosaic(RC1model,
       residuals_type="rstandard", 
       labeling_args = long.labels, 
       labeling=labeling_residuals, 
       suppress=1, 
       gp=shading_Friendly,
       main="RC1 model")
 }
 
 ############# UCB Admissions data, fit using glm()
 
structable(Dept ~ Admit+Gender,UCBAdmissions)
 
berkeley &lt;- as.data.frame(UCBAdmissions)
berk.glm1 &lt;- glm(Freq ~ Dept * (Gender+Admit), data=berkeley, family="poisson")
summary(berk.glm1)

mosaic(berk.glm1, 
       gp=shading_Friendly, 
       labeling=labeling_residuals, 
       formula=~Admit+Dept+Gender)

# the same, displaying studentized residuals; 
# note use of formula to reorder factors in the mosaic
mosaic(berk.glm1, 
       residuals_type="rstandard", 
       labeling=labeling_residuals, 
       shade=TRUE, 
	     formula=~Admit+Dept+Gender, 
	     main="Model: [DeptGender][DeptAdmit]")

## all two-way model
berk.glm2 &lt;- glm(Freq ~ (Dept + Gender + Admit)^2, data=berkeley, family="poisson")
summary(berk.glm2)

mosaic.glm(berk.glm2, 
       residuals_type="rstandard", 
       labeling = labeling_residuals, 
       shade=TRUE,
	     formula=~Admit+Dept+Gender, 
	     main="Model: [DeptGender][DeptAdmit][AdmitGender]")

anova(berk.glm1, berk.glm2, test="Chisq")

# Add 1 df term for association of [GenderAdmit] only in Dept A
berkeley &lt;- within(berkeley, 
                   dept1AG &lt;- (Dept=='A')*(Gender=='Female')*(Admit=='Admitted'))
berkeley[1:6,]

berk.glm3 &lt;- glm(Freq ~ Dept * (Gender+Admit) + dept1AG, data=berkeley, family="poisson")
summary(berk.glm3)

mosaic.glm(berk.glm3, 
           residuals_type="rstandard", 
           labeling = labeling_residuals, 
           shade=TRUE,
	         formula=~Admit+Dept+Gender, 
	         main="Model: [DeptGender][DeptAdmit] + DeptA*[GA]")

# compare models
anova(berk.glm1, berk.glm3, test="Chisq")
 
</code></pre>

<hr>
<h2 id='mosaic.glmlist'>
Mosaic Displays for <code>glmlist</code> and <code>loglmlist</code> Objects
</h2><span id='topic+mosaic.glmlist'></span><span id='topic+mosaic.loglmlist'></span>

<h3>Description</h3>

<p>This function provides a convenient interface for viewing mosaic displays
associated with a collection of glm models for frequency tables that have
been stored in a <code>glmlist</code> or <code>loglmlist</code> object.  You can plot either selected models
individually, or mosaics for all models in an array of viewports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmlist'
mosaic(x, selection, 
  panel=mosaic,
  type=c("observed", "expected"), 
  legend=ask | !missing(selection),
  main=NULL,
  ask=TRUE, graphics=TRUE, rows, cols, newpage=TRUE,
  ...)

## S3 method for class 'loglmlist'
mosaic(x, selection, 
  panel=mosaic,
  type=c("observed", "expected"), 
  legend=ask | !missing(selection),
  main=NULL,
  ask=TRUE, graphics=TRUE, rows, cols, newpage=TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic.glmlist_+3A_x">x</code></td>
<td>

<p>a <code>glmlist</code> or <code>loglmlist</code> object
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_selection">selection</code></td>
<td>

<p>the index or name of one <code>glm</code> or <code>loglm</code> object in <code>x</code>.  If no selection is specified,
a menu of models is presented or all models are plotted.
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_panel">panel</code></td>
<td>

<p>a <code><a href="vcd.html#topic+strucplot">strucplot</a></code> panel function, typically <code><a href="vcd.html#topic+mosaic">mosaic</a></code> or <code><a href="vcd.html#topic+sieve">sieve</a></code>
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_type">type</code></td>
<td>

<p>a character string indicating whether the <code>"observed"</code> or the <code>"expected"</code> values of the table should be visualized
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_legend">legend</code></td>
<td>

<p>logical: show a legend for residuals in the mosaic display(s)?  The default behavior is to include a legend
when only a single plot is shown, i.e., if <code>ask</code> is <code>TRUE</code> or a <code>selection</code> has been
specified.
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_main">main</code></td>
<td>

<p>either a logical, or a vector of character strings used for plotting the main title. 
If main is a logical and <code>TRUE</code>, the name of the selected glm object  is used.
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_ask">ask</code></td>
<td>

<p>logical: should the function display a menu of models, when one is not specified in <code>selection</code>?
If <code>selection</code> is not supplied and <code>ask</code> is <code>TRUE</code> (the default), 
a menu of model names is presented; 
if <code>ask</code> is <code>FALSE</code>, mosaics for all models are plotted in an array.
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_graphics">graphics</code></td>
<td>

<p>logical: use a graphic dialog box when <code>ask=TRUE</code>?
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_rows">rows</code>, <code id="mosaic.glmlist_+3A_cols">cols</code></td>
<td>

<p>when <code>ask=FALSE</code>, the number of rows and columns in which to plot the mosaics.
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_newpage">newpage</code></td>
<td>

<p>start a new page? (only applies to <code>ask=FALSE</code>)
</p>
</td></tr>
<tr><td><code id="mosaic.glmlist_+3A_...">...</code></td>
<td>

<p>other arguments passed to <code><a href="#topic+mosaic.glm">mosaic.glm</a></code> and ultimately to <code><a href="vcd.html#topic+mosaic">mosaic</a></code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most details of the plots produced can be controlled via ... arguments
as shown in some of the examples below.  In particular, with <code>panel=sieve</code>
you need to also pass <code>gp=shading_Friendly</code> to get a color version.
</p>


<h3>Value</h3>

<p>Returns the result of <code><a href="#topic+mosaic.glm">mosaic.glm</a></code>.





</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>David Meyer, Achim Zeileis, and Kurt Hornik (2006). The Strucplot Framework: Visualizing Multi-Way
Contingency Tables with vcd. <em>Journal of Statistical Software</em>, 17(3), 1-48. 

<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a>,
available as <code>vignette("strucplot", package="vcd")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmlist">glmlist</a></code>, <code><a href="#topic+loglmlist">loglmlist</a></code>,
<code><a href="#topic+Kway">Kway</a></code>
</p>
<p><code><a href="#topic+mosaic.glm">mosaic.glm</a></code>, <code><a href="vcd.html#topic+mosaic">mosaic</a></code>,
<code><a href="vcd.html#topic+strucplot">strucplot</a></code>, for the many parameters that control the details of mosaic plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(JobSatisfaction, package="vcd")

# view all pairwise mosaics
pairs(xtabs(Freq~management+supervisor+own, data=JobSatisfaction), 
    shade=TRUE, diag_panel=pairs_diagonal_mosaic)

modSat &lt;- Kway(Freq ~ management+supervisor+own, data=JobSatisfaction, 
               family=poisson, prefix="JobSat")
names(modSat)

## Not run: 
mosaic(modSat)              # uses menu, if interactive()

## End(Not run)
mosaic(modSat, "JobSat.1")  # model label
mosaic(modSat, 2)           # model index

# supply a formula to determine the order of variables in the mosaic
mosaic(modSat, 2, formula=~own+supervisor+management)

mosaic(modSat, ask=FALSE)   # uses viewports 

# use a different panel function, label the observed valued in the cells
mosaic(modSat, 1, main=TRUE, panel=sieve, gp=shading_Friendly, labeling=labeling_values)

data(Mental)
indep &lt;- glm(Freq ~ mental+ses,
                family = poisson, data = Mental)
Cscore &lt;- as.numeric(Mental$ses)
Rscore &lt;- as.numeric(Mental$mental)

coleff &lt;- glm(Freq ~ mental + ses + Rscore:ses,
                family = poisson, data = Mental)
roweff &lt;- glm(Freq ~ mental + ses + mental:Cscore,
                family = poisson, data = Mental)
linlin &lt;- glm(Freq ~ mental + ses + Rscore:Cscore,
                family = poisson, data = Mental)

# assign names for the plot labels
modMental &lt;- glmlist(Indep=indep, ColEff=coleff, RowEff=roweff, `Lin x Lin`=linlin)
mosaic(modMental, ask=FALSE, margins=c(3,1,1,2), labeling_args=list(abbreviate_labs=5))


</code></pre>

<hr>
<h2 id='mosaic3d'>
3D Mosaic Plots
</h2><span id='topic+mosaic3d'></span><span id='topic+mosaic3d.default'></span><span id='topic+mosaic3d.loglm'></span>

<h3>Description</h3>

<p>Produces a 3D mosaic plot for a contingency table (or a <code>link[MASS]{loglm}</code> model)
using the <code><a href="rgl.html#topic+rgl-package">rgl-package</a></code>.
</p>
<p>Generalizing the 2D mosaic plot, this begins
with a given 3D shape
(a unit cube), and successively sub-divides it along the X, Y, Z dimensions
according to the table margins, generating a nested set of 3D tiles.
The volume of the resulting tiles 
is therefore proportional to the frequency represented in the
table cells.
Residuals from a given loglinear model are then used to color or shade each of the tiles.
</p>
<p>This is a developing implementation.  The arguments and details are subject to change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic3d(x, ...)

## S3 method for class 'loglm'
mosaic3d(
  x, 
  type = c("observed", "expected"), 
  residuals_type = c("pearson", "deviance"), 
  ...)

## Default S3 method:
mosaic3d(
  x, expected = NULL, 
  residuals = NULL,  
	type = c("observed", "expected"), 
	residuals_type = NULL, 
	shape = rgl::cube3d(alpha = alpha), 
	alpha = 0.5, 
	spacing = 0.1, 
	split_dir = 1:3, 
	shading = shading_basic, 
	interpolate=c(2,4), 
	zero_size=.05,
	label_edge,
	labeling_args = list(), 
	newpage = TRUE, 
	box=FALSE, 
	...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic3d_+3A_x">x</code></td>
<td>
<p>A <code>link[MASS]{loglm}</code> model object. Alternatively,
a multidimensional <code>array</code> or <code>table</code>   
or<code><a href="vcd.html#topic+structable">structable</a></code> of frequencies in a contingency table. 
In the present implementation, the dimensions are taken in sequential order. Use <code>link[base]{aperm}</code> or <code><a href="vcd.html#topic+structable">structable</a></code> to change this.
</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_expected">expected</code></td>
<td>
<p>optionally, for contingency tables,
an array of expected frequencies of the same dimension as <code>x</code>, or alternatively the corresponding loglinear model specification as used by <code>link[stats]{loglin}</code>
or <code>link[MASS]{loglm}</code> (see <code><a href="vcd.html#topic+structable">structable</a></code> for details).</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_residuals">residuals</code></td>
<td>
<p>optionally, an array of residuals of the same dimension as <code>x</code> (see details).</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_type">type</code></td>
<td>
<p>a character string indicating whether the <code>"observed"</code> or the <code>"expected"</code> 
frequencies in the table should be visualized by the volume of the 3D tiles.
</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_residuals_type">residuals_type</code></td>
<td>
<p>a character string indicating the type of residuals to be computed when none are
supplied.  If  residuals  is  <code>NULL</code>,  <code>residuals_type</code>  must  be  one  of 
<code>"pearson"</code> (default;  giving  components  of  Pearson's  chi-squared),  
<code>"deviance"</code>  (giving components of the likelihood ratio  chi-squared), 
or <code>"FT"</code> for the  Freeman-Tukey residuals.  
The value  of this  argument can  be abbreviated.  
</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_shape">shape</code></td>
<td>
<p>The initial 3D shape on which the mosaic is based.  Typically this is a call to an rgl function, and must produce a <code>shape3d</code> object.
The default is a &quot;unit cube&quot; on (-1, +1), with transparency specified by
<code>alpha</code>.</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_alpha">alpha</code></td>
<td>
<p>Specifies the transparency of the 3D tiles used to compose the 3D mosaic.</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_spacing">spacing</code></td>
<td>
<p>A number or vector giving the total amount of space used to separate the
3D tiles along each of the dimensions of the table. The values specified
are re-cycled to the number of table dimensions.</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_split_dir">split_dir</code></td>
<td>
<p>A numeric vector composed of the integers <code>1:3</code> or a character vector
composed of <code>c("x", "y", "z")</code>, where <code>split_dir[i]</code> specifies the
axis along which the tiles should be split for dimension <code>i</code> of the
table. The values specified are re-cycled to the number of table dimensions.</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_shading">shading</code></td>
<td>
<p>A function, taking an array or vector of residuals for the given model,
returning a vector of colors.  At present, only the default
<code>shading=shading_basic</code> is provided.  This is roughly equivalent
to the use of the <code>shade</code> argument in <code><a href="graphics.html#topic+mosaicplot">mosaicplot</a></code>
or to the use of <code>gp=shading_Friendly</code> in <code><a href="vcd.html#topic+mosaic">mosaic</a></code>.
</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_interpolate">interpolate</code></td>
<td>
<p>a vector of interpolation values for the <code>shading</code> function.</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_zero_size">zero_size</code></td>
<td>

<p>The radius of a small sphere used to mark zero cells in the display.
</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_label_edge">label_edge</code></td>
<td>
<p>A character vector composed of <code>c("-", "+")</code> indicating whether the
labels for a given table dimension are to be written at the minima (<code>"-"</code>)
or maxima (<code>"+"</code>) of the <em>other</em> dimensions in the plot.
The default is <code>rep( c('-', '+'), each=3, length=ndim)</code>, meaning
that the first three table variables are labeled at the minima,
and successive ones at the maxima.
</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_labeling_args">labeling_args</code></td>
<td>

<p>This argument is intended to be used to specify details of the rendering
of labels for the table dimensions, but at present has no effect.
</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_newpage">newpage</code></td>
<td>
<p>logical indicating whether a new page should be created for the plot or not.</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_box">box</code></td>
<td>

<p>logical indicating whether a bounding box should be drawn around the plot.
</p>
</td></tr>
<tr><td><code id="mosaic3d_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to <code>mosaic.default</code> or  3D functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Friendly (1995), Friendly [Sect. 4.5](2000) and Theus and Lauer (1999)
have all used the idea of 3D mosaic displays to explain various aspects
of loglinear models (the iterative proportional fitting algorithm,
the structure of various models for 3-way and n-way tables, etc.),
but no implementation of 3D mosaics was previously available.	
</p>
<p>For the default method,
residuals, used to color and shade the 3D tiles, can be passed explicitly,
or, more typically,
are computed as  needed from observed and expected  frequencies.
In this case, the  expected  frequencies  are  optionally  computed  for  a   specified
loglinear model given by the <code>expected</code> argument.
For the loglm method, residuals and observed frequencies are calculated from the model
object.
</p>


<h3>Value</h3>

<p>Invisibly, the list of <code>shape3d</code> objects used to draw the 3D mosaic,
with names corresponding to the concatenation of the level labels, separated by &quot;:&quot;.</p>


<h3>Author(s)</h3>

<p>Michael Friendly, with the help of Duncan Murdoch and Achim Zeileis</p>


<h3>References</h3>

<p>Friendly, M. (1995).
Conceptual and Visual Models for Categorical Data, 
<em>The American Statistician</em>, <b>49</b>, 153-160.
</p>
<p>Friendly, M. <em>Visualizing Categorical Data</em>, Cary NC: SAS Institute, 2000.
Web materials: <a href="http://www.datavis.ca/books/vcd/">http://www.datavis.ca/books/vcd/</a>.
</p>
<p>Theus, M. &amp; Lauer, S. R. W. (1999)
Visualizing Loglinear Models. 
<em>Journal of Computational and Graphical Statistics</em>, <b>8</b>, 396-412.
</p>


<h3>See Also</h3>

<p><code><a href="vcd.html#topic+strucplot">strucplot</a></code>,
<code><a href="vcd.html#topic+mosaic">mosaic</a></code>, 
<code><a href="graphics.html#topic+mosaicplot">mosaicplot</a></code>
</p>
<p><code><a href="stats.html#topic+loglin">loglin</a></code>,
<code><a href="MASS.html#topic+loglm">loglm</a></code> for details on fitting loglinear models
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 x 2 x 2
if(requireNamespace("rgl")){
mosaic3d(Bartlett, box=TRUE)
# compare with expected frequencies under model of mutual independence
mosaic3d(Bartlett, type="expected", box=TRUE)
	
# 2 x 2 x 3
mosaic3d(Heart, box=TRUE)
}

## Not run: 
# 2 x 2 x 2 x 3
# illustrates a 4D table
mosaic3d(Detergent)

# compare 2D and 3D mosaics
demo("mosaic-hec")

## End(Not run)

</code></pre>

<hr>
<h2 id='PhdPubs'>
Publications of PhD Candidates
</h2><span id='topic+PhdPubs'></span>

<h3>Description</h3>

<p>A data set giving the number of publications by doctoral candidates in biochemistry
in relation to various predictors, originally from Long (1997).
</p>
<p>There is a large number of zero counts. Is there evidence for
a separate group of non-publishers?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PhdPubs)</code></pre>


<h3>Format</h3>

<p>A data frame with 915 observations on the following 6 variables.
</p>

<dl>
<dt><code>articles</code></dt><dd><p>number of articles published in the final three years of PhD studies</p>
</dd>
<dt><code>female</code></dt><dd><p>dummy variable for gender, coded <code>1</code> for female</p>
</dd>
<dt><code>married</code></dt><dd><p>dummy variable for marital status, coded <code>1</code> for married</p>
</dd>
<dt><code>kid5</code></dt><dd><p>number of young children, age 5 and under</p>
</dd>
<dt><code>phdprestige</code></dt><dd><p>prestige of the PhD department.  The higher the number the more prestigious the program. </p>
</dd>
<dt><code>mentor</code></dt><dd><p>number of publications by the mentor in the preceeding three years</p>
</dd>
</dl>



<h3>Details</h3>

<p>In this version of the data set, <code>phdprestige</code> had been rounded to the nearest integer.
A Stata version with the continuous values was subsequently found at
<a href="https://www.stata-press.com/data/lf2/couart2.dta">https://www.stata-press.com/data/lf2/couart2.dta</a>
</p>


<h3>Source</h3>

<p>Long, J. S. (1997). <em>Regression Models for Categorical and Limited Dependent Variables</em>,
Sage.
</p>
<p>Long, J. S. &amp; Freese, J. (2006). <em>Regression Models for Categorical Dependent Variables Using Stata</em>, 2nd Ed.,
Stata Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PhdPubs)
# very uninformative
hist(PhdPubs$articles, 
     breaks=0:19, col="pink", xlim=c(0,20),
     xlab="Number of Articles")

library(vcd)
rootogram(goodfit(PhdPubs$articles), xlab="Number of Articles")

# compare with negative binomial
rootogram(goodfit(PhdPubs$articles, type="nbinomial"), 
	xlab="Number of Articles", main="Negative binomial")


</code></pre>

<hr>
<h2 id='print.Kappa'> Print Kappa </h2><span id='topic+print.Kappa'></span>

<h3>Description</h3>

<p>This is a replacement for the <code>print.Kappa</code> method in <code>vcd</code>,
adding display of <code>z</code> values to the <code>vcd</code> version and
optional confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kappa'
print(
  x, 
  digits=max(getOption("digits") - 3, 3), 
  CI=FALSE, 
  level=0.95,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Kappa_+3A_x">x</code></td>
<td>
<p> A Kappa object</p>
</td></tr>
<tr><td><code id="print.Kappa_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.Kappa_+3A_ci">CI</code></td>
<td>
<p>Include confidence intervals in the display?</p>
</td></tr>
<tr><td><code id="print.Kappa_+3A_level">level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="print.Kappa_+3A_...">...</code></td>
<td>
<p> Other arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the Kappa object, invisibly.
</p>


<h3>Author(s)</h3>

<p> Michael Friendly</p>


<h3>See Also</h3>

 
<p><code><a href="vcd.html#topic+confint.Kappa">confint.Kappa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SexualFun")
Kappa(SexualFun)
print(Kappa(SexualFun), CI=TRUE)

# stratified 3-way table
apply(MSPatients, 3, Kappa)
</code></pre>

<hr>
<h2 id='seq_loglm'>Sequential Loglinear Models for an N-way Table</h2><span id='topic+seq_loglm'></span>

<h3>Description</h3>

<p>This function takes an n-way contingency table and fits a series of sequential
models to the 1-, 2-, ... n-way marginal tables, corresponding to a variety of
types of loglinear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_loglm(x, 
   type = c("joint", "conditional", "mutual", "markov", "saturated"), 
   marginals = 1:nf, 
   vorder = 1:nf, 
   k = NULL, 
   prefix = "model", 
   fitted = TRUE,
   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_loglm_+3A_x">x</code></td>
<td>
<p>a contingency table in array form, with optional category labels specified in the dimnames(x) attribute, or else a data.frame in frequency form, with the frequency variable named <code>"Freq"</code>.
</p>
</td></tr>
<tr><td><code id="seq_loglm_+3A_type">type</code></td>
<td>
<p>type of sequential model to fit, a character string.
One of <code>"joint"</code>, <code>"conditional"</code>, <code>"mutual"</code>, <code>"markov"</code>,
or  <code>"saturated"</code>.
</p>
</td></tr>
<tr><td><code id="seq_loglm_+3A_marginals">marginals</code></td>
<td>
<p>which marginal sub-tables to fit? A vector of a (sub)set of the integers, <code>1:nf</code>
where <code>nf</code> is the number of factors in the full n-way table.
</p>
</td></tr>
<tr><td><code id="seq_loglm_+3A_vorder">vorder</code></td>
<td>
<p>order of variables, a permutation of the integers <code>1:nf</code>,
used to reorder the variables in the original table for the purpose
of fitting sequential marginal models. 
</p>
</td></tr>
<tr><td><code id="seq_loglm_+3A_k">k</code></td>
<td>
<p>conditioning variable(s) for <code>type</code> = <code>"joint"</code>, <code>"conditional"</code> 
or Markov chain order for <code>type</code> = <code>"markov"</code>
</p>
</td></tr>
<tr><td><code id="seq_loglm_+3A_prefix">prefix</code></td>
<td>
<p>prefix used to give names to the sequential models</p>
</td></tr>
<tr><td><code id="seq_loglm_+3A_fitted">fitted</code></td>
<td>
<p>argument passed to <code>loglm</code> to store the fitted values in the model objects</p>
</td></tr>
<tr><td><code id="seq_loglm_+3A_...">...</code></td>
<td>
<p>other arguments, passed down</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sequential marginal models for an n-way tables begin with the
model of equal-probability for the one-way margin
(equivalent to a <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>) and add
successive variables one at a time in the order specified by
<code>vorder</code>.
</p>
<p>All model types give the same result for the two-way margin,
namely the test of independence for the first two factors.
</p>
<p>Sequential models of <em>joint independence</em> (<code>type="joint"</code>)
have a particularly simple interpretation, because they
decompose the likelihood ratio test for the model of 
mutual independence in the full n-way table, and hence
account for &quot;total&quot; association in terms of portions attributable
to the conditional probabilities of each new variable,
given all prior variables.
</p>


<h3>Value</h3>

<p>An object of class <code>"loglmlist"</code>, each of which is a class <code>"loglm"</code> object




</p>


<h3>Note</h3>

<p>One-way marginal tables are a bit of a problem here, because they
cannot be fit directly using <code><a href="MASS.html#topic+loglm">loglm</a></code>.
The present version uses <code><a href="stats.html#topic+loglin">loglin</a></code>,
and repairs the result to look like a <code>loglm</code> object (sort of).
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>These functions were inspired by the original SAS implementation of
mosaic displays, described in the <em>User's Guide</em>,
<a href="http://www.datavis.ca/mosaics/mosaics.pdf">http://www.datavis.ca/mosaics/mosaics.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglin-utilities">loglin-utilities</a></code> for descriptions of sequential models,
<code><a href="#topic+conditional">conditional</a></code>,
<code><a href="#topic+joint">joint</a></code>,
<code><a href="#topic+mutual">mutual</a></code>, ...
</p>
<p><code><a href="#topic+loglmlist">loglmlist</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Titanic, package="datasets")
# variables are in the order Class, Sex, Age, Survived
tt &lt;- seq_loglm(Titanic)


</code></pre>

<hr>
<h2 id='seq_mosaic'>
Sequential Mosaics and Strucplots for an N-way Table
</h2><span id='topic+seq_mosaic'></span>

<h3>Description</h3>

<p>This function takes an n-way contingency table and plots mosaics for series of sequential
models to the 1-, 2-, ... n-way marginal tables, corresponding to a variety of
types of loglinear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_mosaic(x, panel = mosaic, 
   type = c("joint", "conditional", "mutual", "markov", "saturated"), 
   plots = 1:nf, vorder = 1:nf, 
   k = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_mosaic_+3A_x">x</code></td>
<td>
<p>a contingency table in array form, with optional category labels specified in the dimnames(x) attribute, or else a data.frame in frequency form, with the frequency variable named <code>"Freq"</code>.</p>
</td></tr>
<tr><td><code id="seq_mosaic_+3A_panel">panel</code></td>
<td>
<p>a <code><a href="vcd.html#topic+strucplot">strucplot</a></code> panel function, 
typically <code><a href="vcd.html#topic+mosaic">mosaic</a></code> or <code><a href="vcd.html#topic+sieve">sieve</a>. NOT yet implemented.</code>
</p>
</td></tr>
<tr><td><code id="seq_mosaic_+3A_type">type</code></td>
<td>
<p>type of sequential model to fit, a character string.
One of <code>"joint"</code>, <code>"conditional"</code>, <code>"mutual"</code>, <code>"markov"</code>, or  <code>"saturated"</code>.</p>
</td></tr>
<tr><td><code id="seq_mosaic_+3A_plots">plots</code></td>
<td>
<p>which marginal sub-tables to plot? A vector of a (sub)set of the integers, <code>1:nf</code> where <code>nf</code> is the number of factors in the full n-way table.</p>
</td></tr>
<tr><td><code id="seq_mosaic_+3A_vorder">vorder</code></td>
<td>
<p>order of variables, a permutation of the integers <code>1:nf</code>, used to reorder the variables in the original table for the purpose
of fitting sequential marginal models. </p>
</td></tr>
<tr><td><code id="seq_mosaic_+3A_k">k</code></td>
<td>
<p>conditioning variable(s) for <code>type</code> = <code>"joint"</code>, <code>"conditional"</code> or Markov chain order for <code>type</code> = <code>"markov"</code>
</p>
</td></tr>
<tr><td><code id="seq_mosaic_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="vcd.html#topic+mosaic">mosaic</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces 
similar plots to the use of <code><a href="#topic+mosaic.loglmlist">mosaic.loglmlist</a></code>,
called with the result of <code><a href="#topic+seq_loglm">seq_loglm</a></code>.
</p>


<h3>Value</h3>

<p>None. Used for its side-effect of producing plots




</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>These functions were inspired by the original SAS implementation of
mosaic displays, described in the <em>User's Guide for Mosaics</em>,
<a href="http://www.datavis.ca/mosaics/mosaics.pdf">http://www.datavis.ca/mosaics/mosaics.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglin-utilities">loglin-utilities</a></code> for descriptions of sequential models,
<code><a href="#topic+conditional">conditional</a></code>,
<code><a href="#topic+joint">joint</a></code>,
<code><a href="#topic+mutual">mutual</a></code>, ...
</p>
<p><code><a href="#topic+loglmlist">loglmlist</a></code>,  <code><a href="#topic+mosaic.loglmlist">mosaic.loglmlist</a></code>,
<code><a href="#topic+seq_loglm">seq_loglm</a></code>
</p>
<p><code><a href="#topic+mosaic.glm">mosaic.glm</a></code>, <code><a href="vcd.html#topic+mosaic">mosaic</a></code>,
<code><a href="vcd.html#topic+strucplot">strucplot</a></code>, for the many parameters that control the details of mosaic plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Titanic, package="datasets")

seq_mosaic(Titanic)  # models of joint independence, Survived last
seq_mosaic(Titanic, type="condit")
seq_mosaic(Titanic, type="mutual")

# other panel functions and options: presently BUGGED
## Not run: 
seq_mosaic(Titanic, type="mutual", panel=sieve, 
   gp=shading_Friendly, labeling=labeling_values)

## End(Not run)

</code></pre>

<hr>
<h2 id='ShakeWords'>
Shakespeare's Word Type Frequencies
</h2><span id='topic+ShakeWords'></span>

<h3>Description</h3>

<p>This data set, from Efron and Thisted (1976), 
gives the number of distinct words types (<code>Freq</code>) of words
that appeared exactly once, twice, etc. up to 100 times (<code>count</code>)
in the complete works of Shakespeare.  In these works, Shakespeare
used 31,534 distinct words (types), comprising 884,647 words in total.
</p>
<p>Efron &amp; Thisted used this data to ask the question, &quot;How many
words did Shakespeare know?&quot;  Put another way, suppose another
new corpus of works Shakespeare were discovered, also with
884,647 words. How many new word types would appear?
The answer to the main question involves contemplating
an infinite number of such new corpora.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ShakeWords)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 2 variables.
</p>

<dl>
<dt><code>count</code></dt><dd><p>the number of times a word type appeared in Shakespeare's written works</p>
</dd>
<dt><code>Freq</code></dt><dd><p>the number of different words (types) appearing with this count.</p>
</dd>
</dl>



<h3>Details</h3>

<p>In addition to the words that appear <code>1:100</code> times, there are 846 words 
that appear more than 100 times, not listed in this data set. 
</p>


<h3>Source</h3>

<p>Bradley Efron and Ronald Thisted (1976).
Estimating the Number of Unseen Species: How Many Words Did Shakespeare Know?
<em>Biometrika</em>,
Vol. 63, No. 3, pp. 435-447, 

</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ShakeWords)
str(ShakeWords)

plot(sqrt(Freq) ~ count, data=ShakeWords)
</code></pre>

<hr>
<h2 id='split3d'>
Subdivide a 3D Object
</h2><span id='topic+split3d'></span><span id='topic+split3d.shape3d'></span><span id='topic+split3d.list'></span><span id='topic+range3d'></span><span id='topic+center3d'></span>

<h3>Description</h3>

<p>Subdivides a <code>shape3d</code> object or a list of <code>shape3d</code> objects
into objects of the same shape along a given dimension
according to the proportions or frequencies specified in vector(s).
</p>
<p><code>split3d</code> is the basic workhorse used in <code><a href="#topic+mosaic3d">mosaic3d</a></code>,
but may be useful in other contexts.
</p>
<p><code>range3d</code> and <code>center3d</code> are utility functions, also useful in other contexts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
split3d(obj, ...)

## S3 method for class 'shape3d'
split3d(obj, p, dim, space = 0.1, ...)

## S3 method for class 'list'
split3d(obj, p, dim, space = 0.1, ...)

range3d(obj)

center3d(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split3d_+3A_obj">obj</code></td>
<td>

<p>A <code>shape3d</code> object, or a list composed of them
</p>
</td></tr>
<tr><td><code id="split3d_+3A_...">...</code></td>
<td>

<p>Other arguments for split3d methods
</p>
</td></tr>
<tr><td><code id="split3d_+3A_p">p</code></td>
<td>

<p>For a single <code>shade3d</code> object, a vector of proportions
(or a vector of non-negative numbers which will be normed to proportions)
indicating the number of subdivisions and their scaling along dimension <code>dim</code>.
For a list of <code>shade3d</code> objects, a matrix whose columns indicate the
subdivisions of each object.  
</p>
</td></tr>
<tr><td><code id="split3d_+3A_dim">dim</code></td>
<td>

<p>The dimension along which the object is to be subdivided.
Either an integer: 1, 2, or 3, or a character: &quot;x&quot;, &quot;y&quot;, or &quot;z&quot;.
</p>
</td></tr>
<tr><td><code id="split3d_+3A_space">space</code></td>
<td>

<p>The total space used to separate the copies of the object along
dimension <code>dim</code>.
The unit inter-object space is therefore <code>space/(length(p)-1)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting list of <code>shape3d</code> objects is actually composed of <em>copies</em>
of the input object(s), scaled according to the proportions in <code>p</code>
and then translated to make their range along the splitting dimension
equal to that of the input object(s).  
</p>


<h3>Value</h3>

<p><code>split3d</code> returns a list of <code>shape3d</code> objects.
</p>
<p><code>range3d</code> returns a 2 x 3 matrix, whose first row contains
the minima on dimensions x, y, z, and whose second row contains
the maxima.
</p>
<p><code>center3d</code> returns a numeric vector containing
the means of the minima and maxima on dimensions x, y, z.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch, with refinements by Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mosaic3d">mosaic3d</a></code>
</p>
<p><code><a href="rgl.html#topic+shapelist3d">shapelist3d</a></code> for the plotting of lists of <code>shape3d</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(rgl)) {
  open3d()
  cube &lt;- cube3d(alpha=0.4)
  sl1 &lt;- split3d(cube, c(.2, .3, .5), 1)
  col &lt;- c("#FF000080", "#E5E5E580", "#0000FF80")
  shapelist3d(sl1, col=col)
	
  open3d()
  p &lt;- matrix(c(.6, .4, .5, .5, .2, .8), nrow=2)
  sl2 &lt;- split3d(sl1, p, 2)
  shapelist3d(sl2, col=col)	
  }
</code></pre>

<hr>
<h2 id='Summarise'>
Brief Summary of Model Fit for glm and loglm Models
</h2><span id='topic+Summarise'></span><span id='topic+Summarise.glmlist'></span><span id='topic+Summarise.loglmlist'></span><span id='topic+Summarise.default'></span>

<h3>Description</h3>

<p>For <code>glm</code> objects, the <code>print</code> and <code>summary</code> methods give
too much information if all one wants to see is a brief summary of model
goodness of fit, and there is no easy way to display a compact comparison of
model goodness of fit for a collection of models fit to the same data.
All <code>loglm</code> models have equivalent glm forms, but the 
<code>print</code> and <code>summary</code> methods give quite different results.
</p>
<p><code>Summarise</code> provides a brief summary for one or more models
fit to the same dataset
for which <code>logLik</code> and <code>nobs</code> methods exist
(e.g., <code>glm</code> and <code>loglm</code> models).

</p>


<h3>Usage</h3>

<pre><code class='language-R'>Summarise(object, ...)

## S3 method for class 'glmlist'
Summarise(object, ..., saturated = NULL, sortby = NULL)
## S3 method for class 'loglmlist'
Summarise(object, ..., saturated = NULL, sortby = NULL)
## Default S3 method:
Summarise(object, ..., saturated = NULL, sortby = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summarise_+3A_object">object</code></td>
<td>

<p>a fitted model object for which there exists a logLik method to extract the corresponding log-likelihood</p>
</td></tr>
<tr><td><code id="Summarise_+3A_...">...</code></td>
<td>

<p>optionally more fitted model objects
</p>
</td></tr>
<tr><td><code id="Summarise_+3A_saturated">saturated</code></td>
<td>

<p>saturated model log likelihood reference value (use 0 if deviance is not available)
</p>
</td></tr>
<tr><td><code id="Summarise_+3A_sortby">sortby</code></td>
<td>

<p>either a numeric or character string specifying
the column in the result by which the rows are sorted (in decreasing order)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function relies on residual degrees of freedom for the LR chisq test being available
in the model object.  This is true for objects inheriting from 
<code>lm</code>, <code>glm</code>, <code>loglm</code>, <code>polr</code>
and <code>negbin</code>.
</p>


<h3>Value</h3>

<p>A data frame (also of class <code>anova</code>) with columns 
<code>c("AIC", "BIC", "LR Chisq", "Df", "Pr(&gt;Chisq)")</code>.
Row names are taken from the names of the model object(s).
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="MASS.html#topic+loglm">loglm</a></code>, 
</p>
<p><code><a href="#topic+logLik.loglm">logLik.loglm</a></code>, <code><a href="#topic+modFit">modFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mental)
indep &lt;- glm(Freq ~ mental+ses,
                family = poisson, data = Mental)
Summarise(indep)
Cscore &lt;- as.numeric(Mental$ses)
Rscore &lt;- as.numeric(Mental$mental)

coleff &lt;- glm(Freq ~ mental + ses + Rscore:ses,
                family = poisson, data = Mental)
roweff &lt;- glm(Freq ~ mental + ses + mental:Cscore,
                family = poisson, data = Mental)
linlin &lt;- glm(Freq ~ mental + ses + Rscore:Cscore,
                family = poisson, data = Mental)
                
# compare models
Summarise(indep, coleff, roweff, linlin)

</code></pre>

<hr>
<h2 id='Titanicp'>Passengers on the Titanic</h2><span id='topic+Titanicp'></span>

<h3>Description</h3>

<p>Data on passengers on the RMS Titanic, excluding the Crew and some
individual identifier variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Titanicp)</code></pre>


<h3>Format</h3>

<p>A data frame with 1309 observations on the following 6 variables.
</p>

<dl>
<dt><code>pclass</code></dt><dd><p>a factor with levels <code>1st</code> <code>2nd</code> <code>3rd</code></p>
</dd>
<dt><code>survived</code></dt><dd><p>a factor with levels <code>died</code> <code>survived</code></p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>female</code> <code>male</code></p>
</dd>
<dt><code>age</code></dt><dd><p>passenger age in years (or fractions of a year, for children), a numeric vector; age is missing for 263 of the passengers</p>
</dd>
<dt><code>sibsp</code></dt><dd><p>number of siblings or spouses aboard, integer: <code>0:8</code></p>
</dd>
<dt><code>parch</code></dt><dd><p>number of parents or children aboard, integer: <code>0:6</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>There are a number of related versions of the Titanic data, in various formats.
This version was derived from <code>ptitanic</code> in the <span class="pkg">rpart.plot</span> package,
modifying it to remove the <code>Class 'labelled'</code> attributes for some variables
(inherited from Frank Harrell's <code>titanic3</code> version)
which caused problems with some applications, notably <code>ggplot2</code>.
</p>
<p>Other versions:
</p>
<p><code><a href="datasets.html#topic+Titanic">Titanic</a></code> is the 4-way frequency table of all 2201 people
aboard the Titanic, including passengers and crew.
</p>


<h3>Source</h3>

<p>The original R source for this
dataset was compiled by Frank Harrell and Robert Dawson:
<a href="https://biostat.app.vumc.org/wiki/pub/Main/DataSets/titanic.html">https://biostat.app.vumc.org/wiki/pub/Main/DataSets/titanic.html</a>,
described in more detail in
<a href="https://biostat.app.vumc.org/wiki/pub/Main/DataSets/titanic3info.txt">https://biostat.app.vumc.org/wiki/pub/Main/DataSets/titanic3info.txt</a>
</p>
<p>For this version of the Titanic data, passenger details were deleted, 
survived was cast as a factor, and the name changed to <code>Titanicp</code> to minimize confusion 
with other versions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Titanicp)
## maybe str(Titanicp) ; plot(Titanicp) ...
</code></pre>

<hr>
<h2 id='Toxaemia'>Toxaemia Symptoms in Pregnancy</h2><span id='topic+Toxaemia'></span>

<h3>Description</h3>

<p>Brown et al (1983) gave these data on two signs of toxaemia,
an abnormal condition during pregnancy characterized by
high blood pressure (hypertension) and high levels of protein
in the urine.  If untreated, both the mother and baby are
at risk of complications or death.
</p>
<p>The data frame <code>Toxaemia</code> represents 13384 expectant
mothers in Bradford, England in their first pregnancy, who
were also classified according to social class and the number
of cigarettes smoked per day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Toxaemia)</code></pre>


<h3>Format</h3>

<p>A data frame in frequency form representing a 5 x 3 x 2 x 2 contingency table,
with 60 observations on the following 5 variables.
</p>

<dl>
<dt><code>class</code></dt><dd><p>Social class of mother, a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code></p>
</dd>
<dt><code>smoke</code></dt><dd><p>Cigarettes smoked per day during pregnancy, a factor with levels <code>0</code> <code>1-19</code> <code>20+</code></p>
</dd>
<dt><code>hyper</code></dt><dd><p>Hypertension level, a factor with levels <code>Low</code> <code>High</code></p>
</dd>
<dt><code>urea</code></dt><dd><p>Protein urea level, a factor with levels <code>Low</code> <code>High</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>frequency in each cell, a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Brown, P. J., Stone, J. and Ord-Smith, C. (1983), 
Toxaemic signs during pregnancy.
<em>JRSS, Series C, Applied Statistics</em>, 32, 69-72
</p>


<h3>References</h3>

<p>Friendly, M.  (2000), <em>Visualizing Categorical Data</em>, SAS Institute, Cary, NC,
Example 7.15.
</p>
<p>Friendly, M. and Meyer, D. (2016). 
<em>Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data</em>. 
Boca Raton, FL: Chapman &amp; Hall/CRC. <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>. Example 10.10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Toxaemia)

tox.tab &lt;- xtabs(Freq ~ class + smoke + hyper + urea, Toxaemia)
ftable(tox.tab, row.vars=1)


# symptoms by smoking
mosaic(~smoke + hyper + urea, data=tox.tab, shade=TRUE)

# symptoms by social class
mosaic(~class + hyper + urea, data=tox.tab, shade=TRUE)

# predictors
mosaic(~smoke + class, data=tox.tab, shade=TRUE)

# responses
mosaic(~hyper + urea, data=tox.tab, shade=TRUE)

# log odds ratios for urea and hypertension, by class and smoke
## Not run: 
LOR &lt;-loddsratio(aperm(tox.tab))
LOR

## End(Not run)

</code></pre>

<hr>
<h2 id='TV'>TV Viewing Data</h2><span id='topic+TV'></span>

<h3>Description</h3>

<p>This data set <code>TV</code> comprises a 5 x 11 x 3 contingency table based on
audience viewing data from Neilsen Media Research for the week starting
November 6, 1995.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TV)</code></pre>


<h3>Format</h3>

<p>A 5 x 11 x 3 array of cell frequencies with the following structure:
</p>
<pre>
 int [1:5, 1:11, 1:3] 146 244 233 174 294 151 181 161 183 281 ...
 - attr(*, "dimnames")=List of 3
  ..$ Day    : chr [1:5] "Monday" "Tuesday" "Wednesday" "Thursday" ...
  ..$ Time   : chr [1:11] "8:00" "8:15" "8:30" "8:45" ...
  ..$ Network: chr [1:3] "ABC" "CBS" "NBC"
</pre>


<h3>Details</h3>

<p>The original data, <code>tv.dat</code>, contains two additional networks: &quot;Fox&quot; and &quot;Other&quot;, with small
frequencies. These levels were removed in the current version.
There is also a fourth factor, transition State
transition (turn the television Off, Switch channels, or Persist in viewing the current channel).
The <code>TV</code> data here includes only the Persist observations.
</p>


<h3>Source</h3>

<p>The original data, <code>tv.dat</code>, came from the initial implementation of 
mosaic displays in R by Jay Emerson (1998). Similar data had been used by
Hartigan and Kleiner (1984) as an illustration.
</p>


<h3>References</h3>

<p>Friendly, M. and Meyer, D. (2016). 
<em>Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data</em>. 
Boca Raton, FL: Chapman &amp; Hall/CRC. <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>.
</p>
<p>Emerson, John W. Mosaic Displays in S-PLUS: A General Implementation and a Case Study.
<em>Statistical Graphics and Computing Newsletter</em>, 1998, 9(1), 17&ndash;23, 
<a href="http://www.stat.yale.edu/~jay/R/mosaic/v91.pdf">http://www.stat.yale.edu/~jay/R/mosaic/v91.pdf</a>
</p>
<p>Hartigan, J. A. &amp; Kleiner, B. A Mosaic of Television Ratings. <em>The American Statistician</em>, 1984, 38, 32-35.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
structable(TV)
doubledecker(TV)

# reduce number of levels of Time
TV.df &lt;- as.data.frame.table(TV)
levels(TV.df$Time) &lt;- rep(c("8:00-8:59", "9:00-9:59", "10:00-10:44"), 
                          c(4, 4, 3))

TV2 &lt;- xtabs(Freq ~ Day + Time + Network, TV.df)

# re-label for mosaic display
levels(TV.df$Time) &lt;- c("8", "9", "10")
# fit mode of joint independence, showing association of Network with Day*Time
mosaic(~ Day + Network + Time, 
  data = TV.df, 
  expected = ~ Day:Time + Network, 
  legend = FALSE)


# with doubledecker arrangement
mosaic(~ Day + Network + Time, 
  data = TV.df, 
  expected = ~ Day:Time + Network,
  split = c(TRUE, TRUE, FALSE), 
  spacing = spacing_highlighting, 
  legend = FALSE)
</code></pre>

<hr>
<h2 id='update.xtabs'>
Update method for a <code>xtabs</code> object
</h2><span id='topic+update.xtabs'></span>

<h3>Description</h3>

<p>Provides an <code>update</code> method for <code>"xtabs"</code> objects,
typically by removing terms from the formula to collapse over them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xtabs'
update(object, formula., ..., evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.xtabs_+3A_object">object</code></td>
<td>
<p>An existing <code>"xtabs"</code> object</p>
</td></tr>
<tr><td><code id="update.xtabs_+3A_formula.">formula.</code></td>
<td>
<p>Changes to the formula ? see <code><a href="stats.html#topic+update.formula">update.formula</a></code> for details</p>
</td></tr>
<tr><td><code id="update.xtabs_+3A_...">...</code></td>
<td>
<p>Additional arguments to the call, or arguments with changed values.
</p>
</td></tr>
<tr><td><code id="update.xtabs_+3A_evaluate">evaluate</code></td>
<td>
<p>If <code>TRUE</code>, evaluate the new call else return the call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>evaluate == TRUE</code>, the new <code>"xtabs"</code> object, otherwise the updated call
</p>


<h3>Author(s)</h3>

<p>Michael Friendly</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+update.formula">update.formula</a></code> for details on updates to model formulae
</p>
<p><code><a href="base.html#topic+margin.table">margin.table</a></code> does something similar,
<code><a href="#topic+collapse.table">collapse.table</a></code> collapses category levels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vietnam.tab &lt;- xtabs(Freq ~ sex + year + response, data=Vietnam)

update(vietnam.tab, formula = ~ . -year)


</code></pre>

<hr>
<h2 id='vcdExtra-deprecated'>Deprecated Functions in vcdExtra Package</h2><span id='topic+vcdExtra-deprecated'></span><span id='topic+summarise'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of the <span class="pkg">vcdExtra</span> package only. 
They are replaced by <code><a href="#topic+LRstats">LRstats</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise(...)




</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcdExtra-deprecated_+3A_...">...</code></td>
<td>
<p>pass arguments down.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summarise.*</code> have been replaced by <code><a href="#topic+LRstats">LRstats</a></code> functions.
</p>

<hr>
<h2 id='vcdExtra-package'>
Extensions and additions to vcd: Visualizing Categorical Data
</h2><span id='topic+vcdExtra-package'></span><span id='topic+vcdExtra'></span>

<h3>Description</h3>


<p>This package provides additional data sets, documentation, and
a few functions designed to extend the <code>vcd</code> package for Visualizing Categorical Data
and the <code>gnm</code> package for Generalized Nonlinear Models.
In particular, vcdExtra extends mosaic, assoc and sieve plots from vcd to handle glm() and gnm() models and
adds a 3D version in <code><a href="#topic+mosaic3d">mosaic3d</a></code>.
</p>
<p>This package is also a support package for the book, <em>Discrete Data Analysis with R</em> by
Michael Friendly and David Meyer, Chapman &amp; Hall/CRC, 2016,
<a href="https://www.routledge.com/Discrete-Data-Analysis-with-R-Visualization-and-Modeling-Techniques-for/Friendly-Meyer/9781498725835">https://www.routledge.com/Discrete-Data-Analysis-with-R-Visualization-and-Modeling-Techniques-for/Friendly-Meyer/9781498725835</a>
with a number of additional data sets,
and functions.
The web site for the book is <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>.
</p>
<p>In addition, I teach a course, <em>Psy 6136: Categorical Data Analysis</em>,
<a href="https://friendly.github.io/psy6136/">https://friendly.github.io/psy6136/</a> using this package.
</p>


<h3>Details</h3>

<p>The main purpose of this package is to serve as a sandbox for
introducing extensions of
mosaic plots and related graphical methods
that apply to loglinear models fitted using
<code>glm()</code> and related, generalized nonlinear models fitted
with <code>gnm()</code> in the <code><a href="gnm.html#topic+gnm-package">gnm-package</a></code> package.
A related purpose is to fill in some holes in the analysis of
categorical data in R, not provided in base R, the <span class="pkg">vcd</span>,
or other commonly used packages.
</p>
<p>The method <code><a href="#topic+mosaic.glm">mosaic.glm</a></code>
extends the <code><a href="vcd.html#topic+mosaic.loglm">mosaic.loglm</a></code> method in the <span class="pkg">vcd</span>
package to this wider class of models.  This method also works for
the generalized nonlinear models fit with the <code><a href="gnm.html#topic+gnm-package">gnm-package</a></code> package,
including models for square tables and models with multiplicative associations.
</p>
<p><code><a href="#topic+mosaic3d">mosaic3d</a></code>
introduces a 3D generalization of mosaic displays using the
<span class="pkg">rgl</span> package.
</p>
<p>In addition, there are several new data sets, a tutorial vignette,
</p>

<dl>
<dt>vcd-tutorial</dt><dd><p>Working with categorical data with R and the vcd package, <code>vignette("vcd-tutorial", package = "vcdExtra") </code></p>
</dd>
</dl>

<p>and a few functions for manipulating categorical data sets and working with models for
categorical data.
</p>
<p>A new class, <code><a href="#topic+glmlist">glmlist</a></code>, is introduced for working with
collections of <code>glm</code> objects, e.g., <code><a href="#topic+Kway">Kway</a></code> for fitting
all K-way models from a basic marginal model, and <code><a href="#topic+LRstats">LRstats</a></code>
for brief statistical summaries of goodness-of-fit for a collection of
models.
</p>
<p>For square tables with ordered factors, <code><a href="#topic+Crossings">Crossings</a></code> supplements the
specification of terms in model formulas using
<code><a href="gnm.html#topic+Symm">Symm</a></code>,
<code><a href="gnm.html#topic+Diag">Diag</a></code>,
<code><a href="gnm.html#topic+Topo">Topo</a></code>, etc. in the <code><a href="gnm.html#topic+gnm-package">gnm-package</a></code>.
</p>
<p>Some of these extensions may be migrated into <span class="pkg">vcd</span> or <span class="pkg">gnm</span>.
</p>
<p>A collection of demos is included to illustrate fitting and visualizing a wide variety of models:
</p>

<dl>
<dt>mental-glm</dt><dd><p>Mental health data: mosaics for glm() and gnm() models</p>
</dd>
<dt>occStatus</dt><dd><p>Occupational status data: Compare mosaic using expected= to mosaic.glm</p>
</dd>
<dt>ucb-glm</dt><dd><p>UCBAdmissions data: Conditional independence via loglm() and glm()</p>
</dd>
<dt>vision-quasi</dt><dd><p>VisualAcuity data: Quasi- and Symmetry models</p>
</dd>
<dt>yaish-unidiff</dt><dd><p>Yaish data: Unidiff model for 3-way table</p>
</dd>
<dt>Wong2-3</dt><dd><p>Political views and support for women to work (U, R, C, R+C and RC(1) models)</p>
</dd>
<dt>Wong3-1</dt><dd><p>Political views, support for women to work and national welfare spending (3-way, marginal, and conditional independence models)</p>
</dd>
<dt>housing</dt><dd><p>Visualize glm(), multinom() and polr() models from <code>example(housing, package="MASS")</code></p>
</dd>
</dl>

<p>Use <code> demo(package="vcdExtra")</code> for a complete current list.
</p>
<p>The <span class="pkg">vcdExtra</span> package now contains a large number of data sets illustrating various forms of categorical data analysis
and related visualizations, from simple to advanced. Use <code>data(package="vcdExtra")</code> for a
complete list, or <code>datasets(package="vcdExtra")</code> for an annotated one showing the <code>class</code> and
<code>dim</code> for each data set.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>
<p>Maintainer: Michael Friendly &lt;friendly AT yorku.ca&gt; || (<a href="https://orcid.org/0000-0002-3237-0941">ORCID</a>)
</p>


<h3>References</h3>

<p>Friendly, M. <em>Visualizing Categorical Data</em>, Cary NC: SAS Institute, 2000.
Web materials: <a href="http://www.datavis.ca/books/vcd/">http://www.datavis.ca/books/vcd/</a>.
</p>
<p>Friendly, M. and Meyer, D. (2016).
<em>Discrete Data Analysis with R: Visualization and Modeling Techniques for Categorical and Count Data</em>.
Boca Raton, FL: Chapman &amp; Hall/CRC. <a href="http://ddar.datavis.ca">http://ddar.datavis.ca</a>.
</p>
<p>Meyer, D.; Zeileis, A. &amp; Hornik, K.
The Strucplot Framework: Visualizing Multi-way Contingency Tables with vcd
<em>Journal of Statistical Software</em>, 2006, <b>17</b>, 1-48.
Available in R via <code>vignette("strucplot", package = "vcd")</code>
</p>
<p>Turner, H. and Firth, D. <em>Generalized nonlinear models in R: An overview of the gnm package</em>,
2007,
<a href="http://eprints.ncrm.ac.uk/472/">http://eprints.ncrm.ac.uk/472/</a>. Available in R via <code>vignette("gnmOverview", package = "gnm")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="gnm.html#topic+gnm-package">gnm-package</a></code>, for an extended range of models for contingency tables
</p>
<p><code><a href="vcd.html#topic+mosaic">mosaic</a></code> for details on mosaic displays within the strucplot framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(mosaic.glm)

demo("mental-glm")
</code></pre>

<hr>
<h2 id='Vietnam'>Student Opinion about the Vietnam War</h2><span id='topic+Vietnam'></span>

<h3>Description</h3>

<p>A survey of student opinion on the Vietnam War was taken at the
University of North Carolina at Chapel Hill in May 1967 and published
in the student newspaper. Students were asked to fill in ballot
papers stating which policy out of A,B,C or D they supported.
Responses were cross-classified by gender/year.
</p>
<p>The response categories were:
</p>

<dl>
<dt><code>A</code></dt><dd><p>Defeat North Vietnam by widespread bombing and land invasion</p>
</dd>
<dt><code>B</code></dt><dd><p>Maintain the present policy</p>
</dd>
<dt><code>C</code></dt><dd><p>De-escalate military activity, stop bombing and begin negotiations</p>
</dd>
<dt><code>D</code></dt><dd><p>Withdraw military forces Immediately</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>data(Vietnam)</code></pre>


<h3>Format</h3>

<p>A frequency data frame with 40 observations representing a 2 x 5 x 4 contingency table
on the following 4 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>Female</code> <code>Male</code></p>
</dd>
<dt><code>year</code></dt><dd><p>year of study, an ordered factor with levels
<code>Freshmen</code>, <code>Sophomore</code>, <code>Junior</code>, <code>Senior</code>, <code>Grad student</code></p>
</dd>
<dt><code>response</code></dt><dd><p>a factor with levels <code>A</code> <code>B</code> <code>C</code> <code>D</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>cell frequency, a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>For some analyses, it is useful to treat <code>year</code> as numeric,
and possibly assign grad students a value <code>year=7</code>.
</p>


<h3>Source</h3>

<p>Aitken, M. etal, 1989,  <em>Statistical Modelling in GLIM</em>
</p>


<h3>References</h3>

<p>Friendly, M.  (2000), <em>Visualizing Categorical Data</em>, SAS Institute, Cary, NC,
Example 7.9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Vietnam)
## maybe str(Vietnam) ; plot(Vietnam) ...
</code></pre>

<hr>
<h2 id='Vote1980'>
Race and Politics in the 1980 Presidential Vote
</h2><span id='topic+Vote1980'></span>

<h3>Description</h3>

<p>Data from the 1982 General Social Survey on votes in the 1980 U.S.
presidential election in relation to race and political 
conservatism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Vote1980)</code></pre>


<h3>Format</h3>

<p>A frequency data frame representing a 2 x 7 x 2 table, with 28 observations on the following 4 variables.
</p>

<dl>
<dt><code>race</code></dt><dd><p>a factor with levels <code>NonWhite</code> <code>White</code></p>
</dd>
<dt><code>conservatism</code></dt><dd>
<p>a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code>,
<code>1</code>=most liberal, <code>7</code>=most conservative</p>
</dd>
<dt><code>votefor</code></dt><dd><p>a factor with levels <code>Carter</code> <code>Reagan</code>; <code>Carter</code> 
represents Jimmy Carter or other.</p>
</dd>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data contains a number of sampling zeros in the frequencies of
NonWhites voting for Ronald Reagan.
</p>


<h3>Source</h3>

<p>Clogg, C. &amp; Shockey, J. W. (1988).
In Nesselroade, J. R. &amp; Cattell, R. B. (ed.) 
Multivariate Analysis of Discrete Data,
<em>Handbook of Multivariate Experimental Psychology</em>, 
New York: Plenum Press.
</p>


<h3>References</h3>

<p>Agresti, A. (1990)
<em>Categorical Data Analysis</em>, Table 4.12
New York: Wiley-Interscience.
</p>
<p>Friendly, M. (2000)
<em>Visualizing Categorical Data</em>, Example 7.5
Cary, NC: SAS Institute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Vote1980)
fourfold(xtabs(Freq ~ race + votefor + conservatism, 
  data=Vote1980), 
  mfrow=c(2,4))

</code></pre>

<hr>
<h2 id='WorkerSat'>Worker Satisfaction Data</h2><span id='topic+WorkerSat'></span>

<h3>Description</h3>

<p>Blue collar workers job satisfaction from large scale investigation in Denmark in 1968 (Andersen, 1991). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("WorkerSat")</code></pre>


<h3>Format</h3>

<p>A frequency data frame with 8 observations on the following 4 variables, representing the 2 x 2 x 2 classification of 715 cases.
</p>

<dl>
<dt><code>Manage</code></dt><dd><p>Quality of management, an ordered factor with levels <code>bad</code> &lt; <code>good</code></p>
</dd>
<dt><code>Super</code></dt><dd><p>Supervisor satisfaction, an ordered factor with levels <code>low</code> &lt; <code>high</code></p>
</dd>
<dt><code>Worker</code></dt><dd><p>Worker job satisfaction, an ordered factor with levels <code>low</code> &lt; <code>high</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Originally from <a href="https://online.stat.psu.edu/stat504/lesson/10/">https://online.stat.psu.edu/stat504/lesson/10/</a>
</p>


<h3>References</h3>

<p>Andersen, E. B. (1991)
Statistical Analysis of Categorical Data, 2nd Ed., Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WorkerSat)

worker.tab &lt;- xtabs(Freq ~ Worker + Super + Manage, data=WorkerSat)
fourfold(worker.tab)
mosaic(worker.tab, shade=TRUE)

</code></pre>

<hr>
<h2 id='Yamaguchi87'>Occupational Mobility in Three Countries</h2><span id='topic+Yamaguchi87'></span>

<h3>Description</h3>

<p>Yamaguchi (1987) presented this three-way frequency table,
cross-classifying occupational categories of sons and fathers
in the United States, United Kingdom and Japan.  This data set has
become a classic for models comparing two-way mobility tables across
layers corresponding to countries, groups or time (e.g.,
Goodman and Hout, 1998; Xie, 1992).
</p>
<p>The US data were derived from the 1973 OCG-II survey; those
for the UK from the 1972 Oxford Social Mobility Survey; those
for Japan came from the 1975 Social Stratification and Mobility
survey. They pertain to men aged 20-64.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Yamaguchi87)</code></pre>


<h3>Format</h3>

<p>A frequency data frame with 75 observations on the following 4 variables. The total sample size is 28887.
</p>

<dl>
<dt><code>Son</code></dt><dd><p>a factor with levels <code>UpNM</code> <code>LoNM</code> <code>UpM</code> <code>LoM</code> <code>Farm</code></p>
</dd>
<dt><code>Father</code></dt><dd><p>a factor with levels <code>UpNM</code> <code>LoNM</code> <code>UpM</code> <code>LoM</code> <code>Farm</code></p>
</dd>
<dt><code>Country</code></dt><dd><p>a factor with levels <code>US</code> <code>UK</code> <code>Japan</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Five status categories &ndash; upper and lower
nonmanuals (<code>UpNM</code>, <code>LoNM</code>), 
upper and lower manuals (<code>UpM</code>, <code>LoM</code>), 
and <code>Farm</code>) are used for both fathers' occupations and
sons' occupations. 
</p>
<p>Upper nonmanuals are professionals,
managers, and officials; lower
nonmanuals are proprietors, sales workers, and
clerical workers; upper manuals are skilled
workers; lower manuals are semi-skilled and
unskilled nonfarm workers; and farm workers
are farmers and farm laborers.
</p>
<p>Some of the models from Xie (1992), Table 1, are fit in <code>demo(yamaguchi-xie)</code>.
</p>


<h3>Source</h3>

<p>Yamaguchi, K. (1987). 
Models for comparing mobility tables: toward parsimony and substance, 
<em>American Sociological Review</em>, vol. 52 (Aug.), 482-494, Table 1
</p>


<h3>References</h3>

<p>Goodman, L. A. and Hout, M. (1998).
Statistical Methods and Graphical Displays for Analyzing How the Association Between Two Qualitative Variables Differs Among Countries, Among Groups, Or Over Time: 
A Modified Regression-Type Approach.
<em>Sociological Methodology</em>, 28 (1), 175-230.
</p>
<p>Xie, Yu (1992).
The log-multiplicative layer effect model for comparing mobility tables.
<em>American Sociological Review</em>, 57 (June), 380-395.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Yamaguchi87)
# reproduce Table 1
structable(~ Father + Son + Country, Yamaguchi87)
# create table form
Yama.tab &lt;- xtabs(Freq ~ Son + Father + Country, data=Yamaguchi87)

# define mosaic labeling_args for convenient reuse in 3-way displays
largs &lt;- list(rot_labels=c(right=0), offset_varnames = c(right = 0.6), 
              offset_labels = c(right = 0.2),
              set_varnames = c(Son="Son's status", Father="Father's status") 
             )

###################################
# Fit some models &amp; display mosaics
  
# Mutual independence
yama.indep &lt;- glm(Freq ~ Son + Father + Country, 
  data=Yamaguchi87, 
  family=poisson)
anova(yama.indep)

mosaic(yama.indep, ~Son+Father, main="[S][F] ignoring country")

mosaic(yama.indep, ~Country + Son + Father, condvars="Country",
       labeling_args=largs, 
       main='[S][F][C] Mutual independence') 

# no association between S and F given country ('perfect mobility')
# asserts same associations for all countries
yama.noRC &lt;- glm(Freq ~ (Son + Father) * Country, 
  data=Yamaguchi87, 
  family=poisson)
anova(yama.noRC)

mosaic(yama.noRC, ~~Country + Son + Father, condvars="Country", 
       labeling_args=largs, 
       main="[SC][FC] No [SF] (perfect mobility)")

# ignore diagonal cells
yama.quasi &lt;- update(yama.noRC, ~ . + Diag(Son,Father):Country)
anova(yama.quasi)

mosaic(yama.quasi, ~Son + Father, main="Quasi [S][F]")

## see also:
# demo(yamaguchi-xie)
##
</code></pre>

<hr>
<h2 id='zero.test'>
Score test for zero inflation in Poisson data
</h2><span id='topic+zero.test'></span>

<h3>Description</h3>

<p>Carries out a simple score test (van den Broek, 1995) for excess zeros in 
an otherwise Poisson distribution of counts.  It gives a <code class="reqn">\chi^2_1</code>
statistic on one degree of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero.test(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero.test_+3A_x">x</code></td>
<td>

<p>A vector of non-negative counts, or a one-way frequency table
of such counts.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test first calculates the rate estimate from the mean,
<code class="reqn">\hat{\lambda} = \bar{x}</code>.
The number of observed zeros, <code class="reqn">n_0</code> is then compared with the expected
number, <code class="reqn">n \hat{p_0}</code>, where <code class="reqn">\hat{p}_0=\exp[-\hat{\lambda}]</code>.
Then the test statistic is calculated by the formula: 
</p>
<p style="text-align: center;"><code class="reqn">\frac{(n_0 - n\hat{p}_0)^2}{n\hat{p}_0(1-\hat{p}_0) - n\bar{x}\hat{p}_0^2}</code>
</p>
 
<p>This test statistic
has a <code class="reqn">\chi^2_1</code> distribution.
</p>


<h3>Value</h3>

<p>Returns invisibly a list of three elements:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Description of 'comp1'</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Description of 'comp2'</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>Upper tail p-value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>The original R code came from a Stackexchange question,
<a href="https://stats.stackexchange.com/questions/118322/how-to-test-for-zero-inflation-in-a-dataset">https://stats.stackexchange.com/questions/118322/how-to-test-for-zero-inflation-in-a-dataset</a>
</p>
<p>Van den Broek, J. (1995). 
A Score Test for Zero Inflation in a Poisson Distribution. 
<em>Biometrics</em>, <b>51</b>(2), 738-743. https://www.jstor.org/stable/2532959
</p>
<p>Yang, Zhao, James W. Hardin, and Cheryl L. Addy (2010). 
Score Tests for Zero-Inflation in Overdispersed Count Data. 
<em>Communications in Statistics - Theory and Methods</em> <b>39</b> (11) 2008-2030. 
<a href="https://doi.org/10.1080/03610920902948228">doi:10.1080/03610920902948228</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># synthetic tests
zero.test(rpois(100, 1))
zero.test(rpois(100, 5))
# add some extra zeros
zero.test(c(rep(0, 20), rpois(100, 5)))

# Articles by Phd candidates
data(PhdPubs, package="vcdExtra")
zero.test(PhdPubs$articles)

phd.tab &lt;- table(PhdPubs$articles)
zero.test(phd.tab)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
