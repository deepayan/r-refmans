<!DOCTYPE html><html lang="en"><head><title>Help for package spatialwarnings</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatialwarnings}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spatialwarnings'><p>Early Spatial-Warnings of Ecosystem Degradation</p></a></li>
<li><a href='#arizona'><p>Aerial views of vegetation from Arizona, USA</p></a></li>
<li><a href='#coarse_grain'><p>Matrix coarse-graining</p></a></li>
<li><a href='#convert_to_matrix'><p>Convert an object to a matrix</p></a></li>
<li><a href='#create_indicator'><p>Custom Spatial Early-Warning signals</p></a></li>
<li><a href='#dda'><p>Density-dependent aggregation model</p></a></li>
<li><a href='#display_matrix'><p>Plot a matrix</p></a></li>
<li><a href='#dLSW'><p>The Lifshitz-Slyozov-Wagner distribution</p></a></li>
<li><a href='#extract_spectrum'><p>Extract the r-spectrum from objects</p></a></li>
<li><a href='#extract_variogram'><p>extract_variogram() method for variogram_sews objects</p></a></li>
<li><a href='#flowlength_sews'><p>Flowlength connectivity indicator (uniform topography)</p></a></li>
<li><a href='#forestgap'><p>A list of binary matrices and their associated parameters</p></a></li>
<li><a href='#generic_sews'><p>Generic Spatial Early-Warning signals</p></a></li>
<li><a href='#indicator_plrange'><p>Power-law range indicator</p></a></li>
<li><a href='#indicator_psdtype'><p>Change in patch-size distributions types</p></a></li>
<li><a href='#indictest'><p>Significance-assessment of spatial early-warning signals</p></a></li>
<li><a href='#kbdm_sews'><p>Indicator based on Kolmogorov Complexity</p></a></li>
<li><a href='#label'><p>Labelling of unique patches and detection of percolation.</p></a></li>
<li><a href='#lsw_sews'><p>Indicators based on the LSW distribution</p></a></li>
<li><a href='#patchdistr_sews'><p>Early-warning signals based on patch size distributions</p></a></li>
<li><a href='#patchdistr_sews_plot'><p>Early-warning signals based on patch size distributions</p></a></li>
<li><a href='#patchdistr_sews_predict'><p>predict method for patchdistr_sews objects</p></a></li>
<li><a href='#patchsizes'><p>Get patch sizes.</p></a></li>
<li><a href='#pl_fit'><p>Distribution-fitting functions</p></a></li>
<li><a href='#plot_spectrum'><p>Display the r-spectrum of a <code>spectral_sews</code> object</p></a></li>
<li><a href='#plot.simple_sews_test'><p>Spatial early-warning signals: display of trends</p></a></li>
<li><a href='#raw_cg_moran'><p>Moran's Index at lag of 1</p></a></li>
<li><a href='#raw_cg_skewness'><p>Skewness indicator</p></a></li>
<li><a href='#raw_cg_variance'><p>Spatial variance indicator</p></a></li>
<li><a href='#raw_clustering'><p>Clustering of pairs</p></a></li>
<li><a href='#raw_flowlength_uniform'><p>Flow length (uniform slope)</p></a></li>
<li><a href='#raw_kbdm'><p>Kolmogorov complexity of a matrix</p></a></li>
<li><a href='#raw_moran'><p>Spatial correlation at lag 1</p></a></li>
<li><a href='#raw_plrange'><p>Power-law range indicator</p></a></li>
<li><a href='#raw_sdr'><p>Spectral Density Ratio (SDR) indicator</p></a></li>
<li><a href='#raw_structvar'><p>Structural variance</p></a></li>
<li><a href='#raw_variogram_metrics'><p>Variogram parameters</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rspectrum'><p>r-spectrum</p></a></li>
<li><a href='#serengeti'><p>Serengeti dataset</p></a></li>
<li><a href='#simple_sews'><p><code>simple_sews</code> objects</p></a></li>
<li><a href='#spectral_sews'><p>Spectrum-based spatial early-warning signals.</p></a></li>
<li><a href='#variogram_sews'><p>Early-Warning signals based on variograms (EXPERIMENTAL)</p></a></li>
<li><a href='#variogram_sews_plot'><p>Early-warning signals based on variograms</p></a></li>
<li><a href='#variogram_sews_predict'><p>predict() method for variogram_sews objects</p></a></li>
<li><a href='#xmin_estim'><p>Estimate the minimum patch size of a power-law distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Early Warning Signals of Ecosystem Degradation</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexandre Genin &lt;alexandre.genin@sete.cnrs.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to compute and assess significance of early-warnings signals (EWS) of ecosystem degradation on raster data sets. EWS are spatial metrics derived from raster data &ndash; e.g. spatial autocorrelation &ndash; that increase before an ecosystem undergoes a non-linear transition (Genin et al. (2018) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13058">doi:10.1111/2041-210X.13058</a>&gt;).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/spatial-ews/spatialwarnings">https://github.com/spatial-ews/spatialwarnings</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spatial-ews/spatialwarnings/issues">https://github.com/spatial-ews/spatialwarnings/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), future</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, ggplot2, plyr, stats, utils, future.apply, gsl,
segmented</td>
</tr>
<tr>
<td>Suggests:</td>
<td>moments, poweRlaw, reshape2, testthat, covr, acss, mgcv,
gstat, sp, raster</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-06 13:02:17 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Alain Danet [aut],
  Alexandre Genin [aut, cre],
  Vishwesha Guttal [aut],
  Sonia Kefi [aut],
  Sabiha Majumder [aut],
  Sumithra Sankaran [aut],
  Florian Schneider [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-06 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spatialwarnings'>Early Spatial-Warnings of Ecosystem Degradation</h2><span id='topic+spatialwarnings'></span><span id='topic+spatialwarnings-package'></span>

<h3>Description</h3>

<p>Many dynamical systems such as ecosystems exhibit non-linear responses to 
changes in their external drivers, resulting in possible wide state shifts 
with strong ecological or economical consequences. This often happens when 
a system exhibit a change in its stability properties as a threshold is 
crossed, <em>e.g.</em> going from multiple stable states to a single stable 
state. For a few decades, much research has been dedicated to finding a 
way to anticipate these tipping points in ecological systems. This has led 
to the development of indicators, which are metrics based on spatial
structure, that could reflect the proximity of an ecosystem to a tipping
point. 
</p>
<p>This package implements many of these indicators, or 
<em>early-warning signals</em> (EWS), on spatial raster data. High-level 
functions and methods provide familiar workflows to compute several related
indicators at once, and display their variations along environmental gradients 
or time-series. Lower-level functions are also available to integrate 
early-warning signals into different workflows. 
</p>
<p>Main, &quot;workflow&quot; functions provided by this package: 
</p>
<p>&quot;Workflow&quot; functions, which may compute several indicators at once:
</p>
 
<ul>
<li> <p><code><a href="#topic+generic_sews">generic_sews</a></code>: Generic spatial EWS
</p>
</li>
<li> <p><code><a href="#topic+spectral_sews">spectral_sews</a></code>: Spectrum-based EWS
</p>
</li>
<li> <p><code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>: EWS based on patch-size distributions
</p>
</li>
<li> <p><code><a href="#topic+kbdm_sews">kbdm_sews</a></code>: Kolmogorov complexity
</p>
</li>
<li> <p><code><a href="#topic+flowlength_sews">flowlength_sews</a></code>: Flow length 
</p>
</li>
<li> <p><code><a href="#topic+variogram_sews">variogram_sews</a></code>: Variogram-based indicators
</p>
</li>
<li> <p><code><a href="#topic+lsw_sews">lsw_sews</a></code>: Indicators based on the Lifshitz-Slyozov-Wagner distribution
</p>
</li></ul>

<p>Individual indicator functions, which may be used to compute raw indicator values 
</p>
 
<ul>
<li> <p><code><a href="#topic+raw_cg_moran">raw_cg_moran</a></code>: lag-1 spatial autocorrelation 
</p>
</li>
<li> <p><code><a href="#topic+raw_cg_variance">raw_cg_variance</a></code>: Spatial variance
</p>
</li>
<li> <p><code><a href="#topic+raw_cg_skewness">raw_cg_skewness</a></code>: Spatial skewness
</p>
</li>
<li> <p><code><a href="#topic+raw_sdr">raw_sdr</a></code>: Spectral density ratio (SDR)
</p>
</li>
<li> <p><code><a href="#topic+indicator_psdtype">indicator_psdtype</a></code>: Patch-size distribution shape 
</p>
</li>
<li> <p><code><a href="#topic+indicator_plrange">indicator_plrange</a></code>, 
<code><a href="#topic+raw_plrange">raw_plrange</a></code> : Power-law range
</p>
</li>
<li> <p><code><a href="#topic+raw_kbdm">raw_kbdm</a></code>: Kolmogorov complexity
</p>
</li>
<li> <p><code><a href="#topic+raw_flowlength_uniform">raw_flowlength_uniform</a></code>: Flow Length
</p>
</li>
<li> <p><code><a href="#topic+raw_structvar">raw_structvar</a></code>: Structural variance
</p>
</li>
<li> <p><code><a href="#topic+raw_lsw_aicw">raw_lsw_aicw</a></code>: Support for LSW distribution relative to lognormal
</p>
</li>
<li> <p><code><a href="#topic+raw_patch_radii_skewness">raw_patch_radii_skewness</a></code>: Skewness of patch radii
</p>
</li></ul>

<p>The package homepage is available at 
<a href="https://github.com/spatial-ews/spatialwarnings">Github</a>
and a  
<a href="https://alex.lecairn.org/spatialwarnings-faq.html">user guide</a> is 
also available. Do not hesitate to get in touch if you want to make changes to the 
package or add another indicator.
</p>

<hr>
<h2 id='arizona'>Aerial views of vegetation from Arizona, USA</h2><span id='topic+arizona'></span>

<h3>Description</h3>

<p>Aerial views of vegetation from Arizona, USA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arizona
</code></pre>


<h3>Format</h3>

<p>A list of logical matrices which were obtained through the 
classification of aerial images of vegetation taken in Arizona (USA).
</p>


<h3>Source</h3>

<p>Derived from the images provided in the Supplementary Material of 
Rodriguez et al. (2017).
</p>


<h3>References</h3>

<p>Rodriguez, F., A. G. Mayor, M. Rietkerk, and S. Bautista. 2017. A null model 
for assessing the cover-independent role of bare soil connectivity as 
indicator of dryland functioning and dynamics. Ecological Indicators.
</p>

<hr>
<h2 id='coarse_grain'>Matrix coarse-graining</h2><span id='topic+coarse_grain'></span>

<h3>Description</h3>

<p>This function averages the spatial data locally. It divides 
the input matrix into submatrices of dimension <code>subsize</code> and 
averages the spatial data in these submatrices. By doing this, the 
dimension of resultant matrix is reduced by a factor of 
<code>subsize</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coarse_grain(mat, subsize)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coarse_grain_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="coarse_grain_+3A_subsize">subsize</code></td>
<td>
<p>Dimension of the submatrix. This has to be a positive 
integer smaller than the dimension of input matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the data is classified into discrete units, the calculation of 
variance and skewness can give spurious results irrelevant to the proximity 
to transition. Therefore, discrete data should be 'coarse-grained' before 
calculating the spatial early warning signals. However, this can also be 
applied to continuous state data.
</p>


<h3>Value</h3>

<p>A matrix of reduced dimension.
</p>


<h3>References</h3>

<p>Sankaran, S., Majumder, S., Kefi, S. and Guttal, V. (2017). Implications 
of being discrete and spatial for detecting early warning signals of 
regime shifts. Ecological Indicators.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generic_sews">generic_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmat &lt;- matrix(runif(20*10) &gt; .5, 
               ncol = 20, nrow = 10)
rmat.cg &lt;- coarse_grain(rmat, subsize = 2)

par(mfrow = c(1, 2))
image(rmat)
title('Raw matrix') 
image(rmat.cg) 
title('Coarse-grained matrix')

</code></pre>

<hr>
<h2 id='convert_to_matrix'>Convert an object to a matrix</h2><span id='topic+convert_to_matrix'></span>

<h3>Description</h3>

<p>This function is mainly for internal use by the 
<code><a href="#topic+spatialwarnings">spatialwarnings</a></code> package to convert objects before they are 
processed by <code>*_sews</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_matrix_+3A_object">object</code></td>
<td>
<p>An object (typically, a matrix or a list of matrices)</p>
</td></tr>
<tr><td><code id="convert_to_matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function is here so that other packages can extend it. 
For example, <a href="https://github.com/spatial-ews/spatialwarningsGis">spatialwarningsGis</a> will provide methods so that GIS objects can be handled 
(e.g. <code>RasterLayer</code> from package <code>raster</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# this does nothing
convert_to_matrix(serengeti[2:3]) 

</code></pre>

<hr>
<h2 id='create_indicator'>Custom Spatial Early-Warning signals</h2><span id='topic+create_indicator'></span><span id='topic+custom_indicator'></span><span id='topic+compute_indicator'></span>

<h3>Description</h3>

<p>Computation, significance assessment and display of trends 
of a custom, user-defined indicator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_indicator(fun, taskname = as.character(substitute(fun)))

compute_indicator(mat, fun, taskname = as.character(substitute(fun)), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_indicator_+3A_fun">fun</code></td>
<td>
<p>A function that takes a matrix as input and returns 
a vector of numerical values. If the function returns a named vector, 
then the names will be used in plots and summaries. The function may also
accept extra arguments.</p>
</td></tr>
<tr><td><code id="create_indicator_+3A_taskname">taskname</code></td>
<td>
<p>The task name. A character string used used for plots and
textual summaries that describes the indicator (or set of indicators) 
being computed. If a task name cannot be derived from <code>fun</code>, then 
a default name is used.</p>
</td></tr>
<tr><td><code id="create_indicator_+3A_mat">mat</code></td>
<td>
<p>A matrix or a list of matrices.</p>
</td></tr>
<tr><td><code id="create_indicator_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the function <code>fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spatialwarnings</code> provides &quot;workflow functions&quot;, named <code>*_sews</code>, 
that assist the user in computing, displaying and assessing the 
significance of indicator values. The functions <code>create_indicator</code> and 
<code>compute_indicator</code> provides such workflow for any arbitrary function. 
</p>
<p><code>create_indicator</code> takes a function 'fun' and returns another function 
that can be used as an indicator similar to the <code>*_sews</code> functions. The 
results of this function can be assessed for significance using 
<code>indictest</code> and trends can be displayed using 
<code>plot</code>, <code>summary</code>, etc. (see Examples). <code>compute_indicator</code> 
does the same but without needing an intermediate indicator function.
</p>


<h3>Value</h3>

<p><code>create_indicator</code> returns a function that can be used in the same way 
than the other <code>*_sews</code> functions (e.g. <code>generic_sews</code>). This 
function as well as <code>compute_indicator</code> will return
<code><a href="#topic+simple_sews">simple_sews_*</a></code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simple_sews">simple_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use the maximum patch size as indicator of degradation
maxpatchsize &lt;- function(mat) { 
  max(patchsizes(mat))
}

# Create the indicator function
maxpatch_sews &lt;- create_indicator(maxpatchsize)

# Then work with this function as if it were a function from the *_sews 
# family. 
mp_indic &lt;- maxpatch_sews(forestgap)
summary(mp_indic)

 
# Assess significance and display trends
mp_test &lt;- indictest(mp_indic, nulln = 49)
plot(mp_test)




# Try spatial coefficient of variation as a spatial EWS. This function can 
# have arguments. 
spatial_cv &lt;- function(mat, subsize) { 
  matc &lt;- coarse_grain(mat, subsize)
  return( sd(matc) / mean(matc) )
}

# Create indicator function
cv_sews &lt;- create_indicator(spatial_cv)

# Compute and display trends
cv_indic &lt;- cv_sews(serengeti, subsize = 3)
plot(cv_indic, along = serengeti.rain)

# We can do the same work in one go using compute_indicator
cv_indic2 &lt;- compute_indicator(serengeti, spatial_cv, subsize = 3)
plot(cv_indic2, along = serengeti.rain)

 
indictest(cv_indic, nulln = 99)

</code></pre>

<hr>
<h2 id='dda'>Density-dependent aggregation model</h2><span id='topic+dda'></span><span id='topic+dda.pars'></span>

<h3>Description</h3>

<p><code>dda</code> is a list of matrices representing results from the 
density-dependent aggregation model (Siteur et al. 2023) in <code>dda</code>.
<code>dda.pars</code> is a data frame with the model parameters. Each row of
<code>dda.pars</code> corresponds to a matrix in <code>dda</code>, in the same order. All
parameters were maintained constant, except for tau (see model
definition in Siteur et al. 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dda

dda.pars
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>
<p>An object of class <code>data.frame</code> with 4 rows and 5 columns.
</p>


<h3>Source</h3>

<p>Kindly provided by Koen Siteur
</p>


<h3>References</h3>

<p>Siteur, Koen, Quan-Xing Liu, Vivi Rottschäfer, Tjisse van der Heide, Max Rietkerk,
Arjen Doelman, Christoffer Boström, and Johan van de Koppel. 2023. &quot;Phase-Separation
Physics Underlies New Theory for the Resilience of Patchy Ecosystems.&quot; Proceedings 
of the National Academy of Sciences 120 (2): e2202683120. 
https://doi.org/10.1073/pnas.2202683120.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ddasews &lt;- lsw_sews(dda)
plot(ddasews, along = dda.pars[ ,"tau"]) # tau is the changing parameter

display_matrix(dda[[4]]) 

</code></pre>

<hr>
<h2 id='display_matrix'>Plot a matrix</h2><span id='topic+display_matrix'></span>

<h3>Description</h3>

<p>Display a matrix or a list of matrices in a plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_matrix(object, palette = "RdYlBu", along = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="display_matrix_+3A_object">object</code></td>
<td>
<p>A matrix, a list of matrices, an object produced by 
<code>*_sews</code> functions or <code>indictest()</code></p>
</td></tr>
<tr><td><code id="display_matrix_+3A_palette">palette</code></td>
<td>
<p>A color palette to use in the plot. It can be any color 
palette understood by <a href="ggplot2.html#topic+scale_fill_brewer">scale_fill_brewer</a>.</p>
</td></tr>
<tr><td><code id="display_matrix_+3A_along">along</code></td>
<td>
<p>A vector of values used in facet headers. If <code>object</code> is 
a matrix, this is ignored.</p>
</td></tr>
<tr><td><code id="display_matrix_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will plot a matrix using ggplot2, using the provided 
palette. Its use-case is very much like <code>image()</code>, but its produces 
nicer plots by default (<code>image()</code> is much faster, however).
</p>


<h3>Value</h3>

<p>A ggplot2 object, which is printed when this function is used 
interactively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# display_matrix works with single matrices or lists of matrices 
display_matrix(serengeti[2:3])

# display_matrix is compatible with "*_sews" objects
indics &lt;- compute_indicator(serengeti[2:3], raw_moran) 
display_matrix(indics)

</code></pre>

<hr>
<h2 id='dLSW'>The Lifshitz-Slyozov-Wagner distribution</h2><span id='topic+dLSW'></span><span id='topic+pLSW'></span><span id='topic+LSW_fit'></span>

<h3>Description</h3>

<p>Density and distribution function for the Lifshitz-Slyozov-Wagner (LSW)
distribution with mean mu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLSW(x, mu, log = FALSE)

pLSW(x, mu, lower.tail = TRUE, log.p = FALSE)

LSW_fit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dLSW_+3A_x">x</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="dLSW_+3A_mu">mu</code></td>
<td>
<p>the mean of the distribution</p>
</td></tr>
<tr><td><code id="dLSW_+3A_log">log</code>, <code id="dLSW_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities p are given as log(p)</p>
</td></tr>
<tr><td><code id="dLSW_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LSW distribution is a continuous distribution with density
</p>
<p style="text-align: center;"><code class="reqn"> 
  f(x) = \frac{4x^2}{9\mu^3} ( \frac{3\mu}{3\mu + x} )^{7/3} 
           ( \frac{3\mu}{3\mu - 2x} )^{11/3} e^{\frac{2x}{2x - 3\mu}} 
</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean of the distribution. 
</p>
<p>The functions <code>dLSW</code> gives the probability density, <code>pLSW</code> gives the 
distribution function. <code>qLSW</code> and <code>rLSW</code> are not implemented. You 
can use <code>LSW_fit</code> to fit an LSW distribution to a set of observations. 
</p>
<p>The length of the results is determined by the length of <code>x</code>, and <code>mu</code> can 
only be a single value. 
</p>
<p>Please note that this distribution has support only on the interval <code>[0,mu*3/2)</code>. 
Probabilities outside this interval are returned as 0.
</p>


<h3>Value</h3>

<p>dLSW gives the density, pLSW gives the distribution function, both as numerical 
vectors determined by the length of <code>x</code>.
</p>


<h3>References</h3>

<p>Siteur, Koen, Quan-Xing Liu, Vivi Rottschäfer, Tjisse van der Heide, Max Rietkerk, 
Arjen Doelman, Christoffer Boström, and Johan van de Koppel. 2023. 
&quot;Phase-Separation Physics Underlies New Theory for the Resilience of Patchy 
Ecosystems.&quot; Proceedings of the National Academy of Sciences 120 (2): e2202683120.
https://doi.org/10.1073/pnas.2202683120.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsw_sews">lsw_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plot the density 
x &lt;- seq(0, 10, l = 128) 
plot(x, dLSW(x, mu = 3), type = "l", col = "black")
lines(x, dLSW(x, mu = 5), type = "l", col = "red")
lines(x, dLSW(x, mu = 7), type = "l", col = "blue")
legend(x = 0, y = max(dLSW(x, mu = 3)), lty = 1, col = c("black", "red", "blue"), 
       legend = paste("mu =", c(3, 5, 7)))

</code></pre>

<hr>
<h2 id='extract_spectrum'>Extract the r-spectrum from objects</h2><span id='topic+extract_spectrum'></span>

<h3>Description</h3>

<p>Extract the r-spectrum from objects produced by
<code>spectral_sews</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_spectrum(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_spectrum_+3A_x">x</code></td>
<td>
<p>An object produced by <code>spectral_sews</code> or the result of the 
<code>indictest</code> function called on such object</p>
</td></tr>
<tr><td><code id="extract_spectrum_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The empirical r-spectrum as a <code>data.frame</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectral_sews">spectral_sews</a></code>, <code><a href="#topic+rspectrum">rspectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Extract the r-spectrum after computing indicators
indics &lt;- spectral_sews(serengeti[2:3])
extract_spectrum(indics) 

</code></pre>

<hr>
<h2 id='extract_variogram'>extract_variogram() method for variogram_sews objects</h2><span id='topic+extract_variogram'></span>

<h3>Description</h3>

<p>Extract the empirical variogram from a <code>variogram_sews</code> 
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_variogram(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_variogram_+3A_x">x</code></td>
<td>
<p>An object produced by <code>variogram_sews</code>, or
<code>indictest</code></p>
</td></tr>
<tr><td><code id="extract_variogram_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the variogram with the distances 
(column <code>dist</code>), the empirical semivariance values (<code>gamma</code>), 
and if object contains more than one matrix, a column named <code>matrixn</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variogram_sews">variogram_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
vario_indics &lt;- variogram_sews(serengeti)
predict(vario_indics)
vario_test &lt;- indictest(vario_indics, nulln = 19)
predict(vario_test) # same result


</code></pre>

<hr>
<h2 id='flowlength_sews'>Flowlength connectivity indicator (uniform topography)</h2><span id='topic+flowlength_sews'></span>

<h3>Description</h3>

<p>Measures the connectivity of runoff-source areas as determined 
by vegetation patterns and (uniform) topography
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowlength_sews(mat, slope = 20, cell_size = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flowlength_sews_+3A_mat">mat</code></td>
<td>
<p>The input matrix (must be a logical matrix)</p>
</td></tr>
<tr><td><code id="flowlength_sews_+3A_slope">slope</code></td>
<td>
<p>The slope of the area documented by the matrix (in degree).</p>
</td></tr>
<tr><td><code id="flowlength_sews_+3A_cell_size">cell_size</code></td>
<td>
<p>The horizontal size of a cell in the matrix (as viewed 
from above).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes Flowlength, a simple metric that measures the 
potential hydrological connectivity of runoff-source areas 
(e.g., bare soil) considering vegetation cover, vegetation patterns and 
topography. Flowlength is defined as the average length of all the 
potential runoff pathways in the target area. Thus, a higher value of 
the index indicates a higher hydrologic connectivity of runoff source 
areas. This function is designed for an idealized uniform hillslope 
(e.g., with constant slope angle, the direction of maximum slope being 
from the top to the bottom of the input matrices). 
</p>
<p>The deviations of Flowlength from its expected values under random or 
aggregated-pattern null models can be used as an indicator of imminent 
transition to a degraded state (Rodriguez et al. 2017) in the context 
of arid drylands. An increased deviation of flowlength compared to its 
null values is expected as a possible transition gets closer. This deviation
can be computed using any null model provided by <code>spatialwarnings</code> (see 
<code><a href="#topic+indictest">indictest</a></code> for more details), but a specific null model is 
provided for Flowlength based on a much-faster analytical approximation, 
using the argument <code>null_method = "approx_rand"</code> when calling 
<code>indictest</code> (see examples below). 
</p>
<p>In general, Flowlength can be used as indicator of dryland functional status 
by assessing potential water and soil losses in patchy landscapes 
(Mayor et al. 2008, Moreno-de las Heras et al. 2012, Mayor et al. 2013, 
Okin et al. 2015). Finally, the combination of observed and expected 
Flowlength under null models for random or aggregated vegetation cover 
can be used for assessing the cover-independent role of bare-
soil connectivity (Rodriguez et al. 2018).
</p>


<h3>Value</h3>

<p>A 'simple_sews' object containing the flow length value, among 
other things, see <code><a href="#topic+simple_sews_object">simple_sews_object</a></code> for more information.
</p>


<h3>References</h3>

<p>Rodriguez, F., A. G. Mayor, M. Rietkerk, and S. Bautista. 2017. A null model 
for assessing the cover-independent role of bare soil connectivity as 
indicator of dryland functioning and dynamics. Ecological Indicators.
</p>
<p>Mayor, A.G., Bautista, S., Small, E.E., Dixon, M., Bellot, J., 2008. 
Measurement of the connectivity of runoff source areas as determined by 
vegetation pattern and topography: a tool for assessing potential water 
and soil losses in drylands. Water Resour. Res. 44, W10423.
</p>
<p>Mayor, A.G., Kefi, S., Bautista, S., Rodriguez, F., Carteni, F., Rietkerk, 
M., 2013. Feedbacks between vegetation pattern and resource loss 
dramatically decrease ecosystem resilience and restoration potential in 
a simple dryland model. Landsc. Ecol. 28, 931-942.
</p>
<p>Moreno-de las Heras, M., Saco, P.M., Willgoose, G.R., Tongway, D.J., 2012. 
Variations in hydrological connectivity of Australian semiarid landscapes 
indicate abrupt changes in rainfall-use efficiency of vegetation. 
J. Geophys. Res. 117, G03009.
</p>
<p>Okin, G.S., Moreno-de las Heras, M., Saco, P.M., Throop, H.L., Vivoni, E.R., 
Parsons, A.J., Wainwright, J., Peters, D.P.C., 2015. Connectivity in 
dryland landscapes: shifting concepts of spatial interactions. 
Front. Ecol. Environ. 13 (1), 20-27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raw_flowlength_uniform">raw_flowlength_uniform</a></code>, 
<code><a href="#topic+indictest">indictest</a></code> to test the significance of indicator values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
fl_result &lt;- flowlength_sews(arizona, slope = 20, cell_size = 1)

# Compute the Z-score (standardized deviation to null distribution) and plot 
#   its variations along the gradient. This Z-score is suggested by 
#   Rodriguez et al. (2017) as an indicator of degradation. 
fl_test &lt;- indictest(fl_result, nulln = 19)
plot(fl_test, what = "z_score")

# Use the analytical approximation suggested in Rodriguez et al. (2017), 
# instead of permuting the original values in the matrix (much faster)
fl_test &lt;- indictest(fl_result, null_method = "approx_rand")
plot(fl_test, what = "z_score")



</code></pre>

<hr>
<h2 id='forestgap'>A list of binary matrices and their associated parameters</h2><span id='topic+forestgap'></span><span id='topic+forestgap.pars'></span>

<h3>Description</h3>

<p>A list of binary matrices and their associated parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forestgap

forestgap.pars
</code></pre>


<h3>Format</h3>

<p>A list of logical matrices which are the end results of simulations 
from Kubo's Forest Gap model along a gradient of increasing values of 
stress (see references).
</p>
<p>The parameters used for the simulations, as a data frame.
</p>


<h3>Details</h3>

<p>Kubo's forest gap model has three parameters, <code class="reqn">\alpha</code> 
that controls the reproductive rate of trees, <code class="reqn">d</code> controls the 
non-spatialized mortality and <code class="reqn">\delta</code> the increased mortality 
due to the presence of a neighboring gap.
</p>


<h3>Source</h3>

<p>Generated using the implementation of Kubo's model in caspr 0.2.0 
<a href="https://github.com/fdschneider/caspr">https://github.com/fdschneider/caspr</a>.
</p>


<h3>References</h3>

<p>Kubo, T., Iwasa, Y., &amp; Furumoto, N. (1996). Forest spatial dynamics with gap
expansion: Total gap area and gap size distribution. Journal of Theoretical
Biology, 180(3), 229-246. <a href="https://doi.org/10.1006/jtbi.1996.0099">doi:10.1006/jtbi.1996.0099</a>
</p>

<hr>
<h2 id='generic_sews'>Generic Spatial Early-Warning signals</h2><span id='topic+generic_sews'></span>

<h3>Description</h3>

<p>Computation, significance assessment and display of spatial 
generic early warning signals (Moran's I, variance and skewness)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generic_sews(
  mat,
  subsize = 4,
  abs_skewness = FALSE,
  moranI_coarse_grain = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generic_sews_+3A_mat">mat</code></td>
<td>
<p>A matrix (quantitative data), a binary matrix (which contains 
<code>TRUE</code> or <code>FALSE</code> values) 
or a list of those</p>
</td></tr>
<tr><td><code id="generic_sews_+3A_subsize">subsize</code></td>
<td>
<p>The subsize used for the coarse-graining phase (see Details)</p>
</td></tr>
<tr><td><code id="generic_sews_+3A_abs_skewness">abs_skewness</code></td>
<td>
<p>Should the absolute skewness be used instead of its 
raw values ?</p>
</td></tr>
<tr><td><code id="generic_sews_+3A_morani_coarse_grain">moranI_coarse_grain</code></td>
<td>
<p>Should the input matrix be coarse-grained before
computing the Moran's I indicator value ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Generic Early warning signal are based on the property of a 
dynamical system to &quot;slow down&quot; when approaching a critical point, 
that is, take more time to return to equilibrium after a perturbation. This 
is expected to be reflected in several spatial characteristics: the 
variance, the spatial autocorrelation (at lag-1) and the skewness. This 
function provides a convenient workflow to compute these indicators, 
assess their significance and display the results. 
</p>
<p>Before computing the actual indicators, the matrix can be &quot;coarse-grained&quot;. 
This process reduces the matrix by averaging the nearby cells using 
a square window defined by the <code>subsize</code> parameter. This makes spatial  
variance and skewness reflect actual spatial patterns when working with 
binary (<code>TRUE</code>/<code>FALSE</code> data), but is optional when using 
continuous data. Keep in mind that it effectively reduces the size of 
the matrix by approximately <code>subsize</code> on each dimension. 
</p>
<p>The significance of generic early-warning signals can be estimated by 
reshuffling the original matrix (function <code>indictest</code>). Indicators 
are then recomputed on the shuffled matrices and the values obtained are 
used as a null distribution. P-values are obtained based on the rank of 
the observed value in the null distribution. A small P-value means 
that the indicator is significantly above the null values, as expected 
before a critical point. 
</p>
<p>The <code>plot</code> method can displays the results graphically. A text summary 
can be obtained using the <code>summary</code> method.
</p>


<h3>Value</h3>

<p><code>generic_sews</code> returns an object of class <code>simple_sews_single</code>
(a list) if <code>mat</code> is a single matrix or an object of class 
<code>simple_sews_list</code> if <code>mat</code> is a list. You probably want to use some  
of the methods written for these complicated objects instead of extracting 
values directly (they are displayed using <code>print(&lt;object&gt;)</code>).
</p>
<p><code>indictest</code> returns an object of class <code>generic_test</code> (a <code>data.frame</code>). 
</p>
<p><code>plot</code> methods return <code>ggplot</code> objects, usually immediately displayed 
when <code>plot</code> is being called at the R prompt.
</p>


<h3>References</h3>

<p>Kefi, S., Guttal, V., Brock, W.A., Carpenter, S.R., Ellison, A.M., 
Livina, V.N., et al. (2014). Early Warning Signals of Ecological 
Transitions: Methods for Spatial Patterns. PLoS ONE, 9, e92097.
</p>
<p>Dakos, V., van Nes, E. H., Donangelo, R., Fort, H., &amp; 
Scheffer, M. (2010). Spatial correlation as leading indicator of 
catastrophic shifts. Theoretical Ecology, 3(3), 163-174.
</p>
<p>Guttal, V., &amp; Jayaprakash, C. (2008). Spatial variance and spatial 
skewness: leading indicators of regime shifts in spatial ecological 
systems. Theoretical Ecology, 2(1), 3-12.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indictest">indictest</a></code>, to test the significance of indicator values. 
Individual indicators: <code><a href="#topic+raw_cg_moran">raw_cg_moran</a></code>
<code><a href="#topic+raw_cg_variance">raw_cg_variance</a></code>, <code><a href="#topic+raw_cg_skewness">raw_cg_skewness</a></code>, 
<code><a href="#topic+simple_sews">simple_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(serengeti)
gen_indic &lt;- generic_sews(serengeti, subsize = 5, 
                           moranI_coarse_grain = TRUE)

# Display results
summary(gen_indic)

# Display trends along the varying model parameter
plot(gen_indic, along = serengeti.rain)

# Compute significance (long)

gen_test &lt;- indictest(gen_indic, nulln = 199)

print(gen_test)

# Display the trend, now with a grey ribbon indicating the 5%-95% quantile
# range of the null distribution
plot(gen_test, along = serengeti.rain)

# Display the effect size compared to null distribution 
plot(gen_test, along = serengeti.rain, what = "z_score")

# Note that plot() method returns a ggplot object that can be modified
# for convenience
if ( require(ggplot2) ) { 
  plot(gen_test, along = serengeti.rain) + 
    geom_vline(xintercept = 733, color = "red", linetype = "dashed") +
    xlab('Annual rainfall') + 
    theme_minimal()
}



</code></pre>

<hr>
<h2 id='indicator_plrange'>Power-law range indicator</h2><span id='topic+indicator_plrange'></span>

<h3>Description</h3>

<p>Compute the power-law range of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indicator_plrange(mat, merge = FALSE, xmin_bounds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indicator_plrange_+3A_mat">mat</code></td>
<td>
<p>A logical matrix, or a list of logical matrices</p>
</td></tr>
<tr><td><code id="indicator_plrange_+3A_merge">merge</code></td>
<td>
<p>Controls whether the patch-size distributions of the input 
matrices are merged together before computing the power-law range. Setting 
this value to <code>TRUE</code> makes the function return a single value even 
if multiple matrices are given as input.</p>
</td></tr>
<tr><td><code id="indicator_plrange_+3A_xmin_bounds">xmin_bounds</code></td>
<td>
<p>A vector of two integer values, defining a range in which 
to search for the best xmin (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some ecosystems show typical changes in their patch-size 
distribution as they become more and more degraded. In particular, an 
increase in the truncation of the patch-size distribution (PSD) is expected 
to occur. The power-law range (PLR) measures the truncation of the PSD 
in a single value (see also <code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code> for more details). 
</p>
<p>To compute the PLR, power-laws are fitted with a variable 
minimum patch size (<code class="reqn">x_{min}</code>) and the one with the lowest Kolmogorov-Smirnov
distance to the empirical distribution is retained. PLR is then computed 
using this best-fitting <code class="reqn">x_{min}</code> as: 
</p>
<p style="text-align: center;"><code class="reqn">\frac{log(x_{max}) - log(x_{min})}{log(x_{max}) - log(x_{smallest})}</code>
</p>

<p>where <code class="reqn">x_{max}</code> is the maximum observed patch size, and 
<code class="reqn">x_{smallest}</code> is the minimum observed patch size.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>minsize</code>, <code>maxsize</code> which are the
observed minimum and maximum patch sizes, the estimated <code class="reqn">x_{min}</code> as column
<code>xmin</code> and the value of the power-law range as <code>plrange</code>. If multiple
matrices were provided, then a list of data.frames is returned
</p>


<h3>References</h3>

<p>Clauset, A., Shalizi, C. R., &amp; Newman, M. E. (2009). 
Power-law distributions in empirical data. SIAM review, 51(4), 661-703.
</p>
<p>Berdugo, M., Kefi, S., Soliveres, S. &amp; Maestre, F.T. (2017). Plant spatial 
patterns identify alternative ecosystem multifunctionality states in 
global drylands. Nature in Ecology and Evolution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
forestgap.plr &lt;- indicator_plrange(forestgap) 
do.call(rbind, forestgap.plr) # convert results to data.frame

# Restrict to small xmins 
forestgap.plr2 &lt;- indicator_plrange(forestgap, xmin_bounds = c(1, 10)) 
do.call(rbind, forestgap.plr2) 

</code></pre>

<hr>
<h2 id='indicator_psdtype'>Change in patch-size distributions types</h2><span id='topic+indicator_psdtype'></span>

<h3>Description</h3>

<p>This functions fits different patch size distributions 
types (power-law, log-normal, exponential and truncated power-law) to 
the patches contained in a matrix. The distributions are returned with 
their corresponding AIC, BIC and AICc to select the best fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indicator_psdtype(
  x,
  xmin = 1,
  merge = FALSE,
  fit_lnorm = FALSE,
  xmin_bounds = NULL,
  best_by = "AIC",
  wrap = FALSE,
  nbmask = "von_neumann"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indicator_psdtype_+3A_x">x</code></td>
<td>
<p>A logical (<code>TRUE</code>/<code>FALSE</code> values) matrix or a list of these.</p>
</td></tr>
<tr><td><code id="indicator_psdtype_+3A_xmin">xmin</code></td>
<td>
<p>The xmin to be used to fit the patch size distributions. Use 
the special values &quot;estimate&quot; to use an estimated xmin for each fit</p>
</td></tr>
<tr><td><code id="indicator_psdtype_+3A_merge">merge</code></td>
<td>
<p>The default behavior is to produce indicators values for each 
matrix. If this parameter is set to TRUE then the patch size distributions 
are pooled together for fitting.</p>
</td></tr>
<tr><td><code id="indicator_psdtype_+3A_fit_lnorm">fit_lnorm</code></td>
<td>
<p>Fit also a log-normal distribution</p>
</td></tr>
<tr><td><code id="indicator_psdtype_+3A_xmin_bounds">xmin_bounds</code></td>
<td>
<p>Restrict the possible xmins in this range (defaults to 
the whole range of observed patch sizes)</p>
</td></tr>
<tr><td><code id="indicator_psdtype_+3A_best_by">best_by</code></td>
<td>
<p>The criterion used to select the best distribution type 
(one of <code>"AIC"</code>, <code>"BIC"</code> or <code>"AICc"</code>).</p>
</td></tr>
<tr><td><code id="indicator_psdtype_+3A_wrap">wrap</code></td>
<td>
<p>Determines whether patches are considered to wrap around the 
matrix when reaching the side</p>
</td></tr>
<tr><td><code id="indicator_psdtype_+3A_nbmask">nbmask</code></td>
<td>
<p>Either &quot;moore&quot; for 8-way neighborhood, &quot;von_neumann&quot; for four-way 
neighborhood (default), or a 3x3 matrix describing which neighbors to 
consider around a cell. See <code><a href="#topic+patchsizes">patchsizes</a></code> for details on how to specify 
such neighborhoods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Patterned ecosystems can exhibit a change in their spatial structure as they 
become more and more stressed. It has been suggested that this should be 
reflected in changes in the observed patch size distributions (PSD). 
The following sequence is expected to occur (Kefi et al. 2011) as patterned 
ecosystems become more and more degraded:
</p>
<p>- Percolation of vegetation patches occurs (a patch has a width or height 
equal to the size of the system)
</p>
<p>- The patch-size distribution follows a power-law
</p>
<p>- The patch-size distribution deviates from a power-law as larger patches 
break down
</p>
<p>- The patch-size distribution is closer to an exponential 
distribution
</p>
<p>This indicator fits the observed patch size distribution based on 
maximum-likelihood (following Clauset et al. 2009 recommendations), then 
select the best model using AIC, BIC (default) or AICc.
</p>


<h3>Value</h3>

<p>A data.frame (or a list of these if x is a list) with the 
following columns:
</p>

<ul>
<li> <p><code>method</code> the method used for fitting (currently: only 
log-likelihood is implemented, &quot;ll&quot;)
</p>
</li>
<li> <p><code>type</code> the type of distribution
</p>
</li>
<li><p> npars the number of parameters of the distribution type
</p>
</li>
<li><p> AIC, 'AICc' and 'BIC' the values for Akaike Information 
Criterion (or the corrected for small samples equivalent AICc), 
and Bayesion Information Criterion (BIC)
</p>
</li>
<li> <p><code>best</code> A logical vector indicating which distribution is the 
best fit 
</p>
</li>
<li> <p><code>plexpo</code>, <code>cutoff</code>, <code>meanlog</code>, <code>sdlog</code> the estimates
for distribution parameters (see <code><a href="#topic+pl_fit">pl_fit</a></code>)
</p>
</li>
<li> <p><code>percolation</code> A logical value indicating whether there is 
<code><a href="#topic+percolation">percolation</a></code> in the system. 
</p>
</li></ul>



<h3>References</h3>

<p>Kefi, S., Rietkerk, M., Roy, M., Franc, A., de Ruiter, P.C. &amp; Pascual, M.
(2011). Robust scaling in ecosystems and the meltdown of patch size
distributions before extinction: Patch size distributions towards 
extinction. Ecology Letters, 14, 29-35.
</p>
<p>Kefi, S., Rietkerk, M., Alados, C.L., Pueyo, Y., Papanastasis, V.P., ElAich,
A., et al. (2007). Spatial vegetation patterns and imminent desertification
in Mediterranean arid ecosystems. Nature, 449, 213-217.
</p>
<p>Clauset, A., Shalizi, C. R., &amp; Newman, M. E. (2009). 
Power-law distributions in empirical data. SIAM review, 51(4), 661-703.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>
</p>
<p><code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(forestgap)

# One logical matrix only
indicator_psdtype(forestgap[[1]])

# A list of these matrices
 
indicator_psdtype(forestgap)


</code></pre>

<hr>
<h2 id='indictest'>Significance-assessment of spatial early-warning signals</h2><span id='topic+indictest'></span>

<h3>Description</h3>

<p>Assess the significance of spatial early-warning indicators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indictest(x, nulln = 999, null_method = "perm", null_control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indictest_+3A_x">x</code></td>
<td>
<p>An object such as one produced by the <code>*_sews</code>
functions, or <code><a href="#topic+compute_indicator">compute_indicator</a></code></p>
</td></tr>
<tr><td><code id="indictest_+3A_nulln">nulln</code></td>
<td>
<p>The number of values to produce the null distribution</p>
</td></tr>
<tr><td><code id="indictest_+3A_null_method">null_method</code></td>
<td>
<p>The method used to produce the null values (see Details)</p>
</td></tr>
<tr><td><code id="indictest_+3A_null_control">null_control</code></td>
<td>
<p>List of arguments used to control the generation of 
null matrices. If NULL, then sensible defaults are chosen (see Details)</p>
</td></tr>
<tr><td><code id="indictest_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>indictest</code> is used to test the significance of early-warning signals
against 'null matrices', which represent the expected spatial structure 
in the absence of the biological process of interest. 
</p>
<p>For a given indicator, a null distribution is obtained by producing a set 
of 'null' matrices, from which indicator values are recomputed. This
produces a null distribution of <code>nulln</code> indicator values against
which the observed value is tested. 
</p>
<p>Several methods are available to produce the set of null matrices. If 
<code>null_method</code> is set to &quot;perm&quot;, the original matrix is reshuffled 
to obtain a null matrix. If <code>null_method</code> is set to &quot;intercept&quot;, then 
a generalized linear model of the form 'y ~ 1' (where y represents the 
values of the matrix) is fitted, then values are drawn from this model. If 
<code>null_method</code> is set to &quot;smooth&quot;, then a smooth surface is fitted
based on a generalized additive model (using <code><a href="mgcv.html#topic+gam">gam</a></code>) to
the matrix, then values are drawn from this model. When using the
&quot;intercept&quot; or &quot;smooth&quot; null models, it is important to make sure the
model 'family' corresponds to the type of values present in the matrix. By
default, if a matrix contains <code>TRUE</code>/<code>FALSE</code> values, a 'binomial()' 
family is used, otherwise a 'gaussian()' family is used. More information about 
null models is available in the <a href="https://alex.lecairn.org/spatialwarnings-faq.html#Using_advanced_null_models">spatialwarnings FAQ</a>. 
</p>
<p>Please note that specific null methods may exists for some indicators, such as
<code><a href="#topic+flowlength_sews">flowlength</a></code>. These are often based on 
analytical approximation and allow faster computations. 
</p>
<p>If a matrix has attributes, then these are preserved and passed to the 
function used to compute the indicator value, except when using the 
null method 'perm', in which case matrix attributes are discarded. 
</p>
<p>The list <code>null_control</code> can be used to adjust the computation of 
null matrices. It can have the following components: 
</p>
 
<dl>
<dt><code>family</code></dt><dd><p>The family used in the model used to produce the null 
matrices. Typically, it is one of <code><a href="stats.html#topic+stats">binomial</a>()</code>, 
<code><a href="stats.html#topic+stats">gaussian</a>()</code>, etc. </p>
</dd>
<dt><code>qinf</code></dt><dd><p>The lower quantile to compute from the null distribution 
and display in summaries/plots. A numeric value between 0 and 1.</p>
</dd>
<dt><code>qsup</code></dt><dd><p>The upper quantile to compute from the null distribution 
and display in summaries/plots. A numeric value between 0 and 1.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object with a class ending in <code>*_sews_test</code>, whose exact
class depends on the input object. <code>plot</code>, <code>summary</code> methods are
available to display the results of computations, and additional methods
may be available depending on the input object (e.g. see
<code><a href="#topic+patchdistr_sews_plot">patchdistr_sews_plot</a></code>).
</p>


<h3>References</h3>

<p>Kefi, S., Guttal, V., Brock, W.A., Carpenter, S.R., Ellison, A.M., Livina, 
V.N., et al. (2014). Early Warning Signals of Ecological Transitions: 
Methods for Spatial Patterns. PLoS ONE, 9, e92097
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generic_sews">generic_sews</a></code>, <code><a href="#topic+spectral_sews">spectral_sews</a></code>, 
<code><a href="#topic+kbdm_sews">kbdm_sews</a></code>,
<code><a href="#topic+compute_indicator">compute_indicator</a></code>, <code><a href="#topic+flowlength_sews">flowlength_sews</a></code>
</p>

<hr>
<h2 id='kbdm_sews'>Indicator based on Kolmogorov Complexity</h2><span id='topic+kbdm_sews'></span>

<h3>Description</h3>

<p>Computes the Kolmogorov Complexity on a set of matrices, 
using the Block Decomposition Method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kbdm_sews(mat, subsize = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kbdm_sews_+3A_mat">mat</code></td>
<td>
<p>A logical matrix (<code>TRUE</code>/<code>FALSE</code> values) or a list of logical 
matrices</p>
</td></tr>
<tr><td><code id="kbdm_sews_+3A_subsize">subsize</code></td>
<td>
<p>A submatrix size to carry out the Block Decomposition Method
(must be between 1 and 3)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>be a useful indicator to anticipate transitions in model ecological 
systems (Dakos and Soler-Toscano, 2017). When close to the transition 
critical point, the complexity is expected to decrease. 
</p>
<p>The Kolmogorov complexity cannot be computed directly for large strings 
(i.e. matrices). However, the complexity of smaller submatrices can be 
estimated, then combined to obtain an approximation of the complexity 
of the whole matrix. This method, the Block Decomposition Method is 
implemented in this indicator following Dakos and Soler-Toscano (2017).
</p>


<h3>Value</h3>

<p><code>kbdm_sews</code> returns an object of class <code>simple_sews_single</code> 
(a list) if mat is a single matrix, and an object of class 
<code>simple_sews_list</code> if mat is a list of matrices. These objects can 
be used with generic methods indictest (to test significance) or plot 
(to display trends), see also the examples below.
</p>


<h3>References</h3>

<p>Dakos, V., and F. Soler-Toscano. 2017. Measuring complexity to infer 
changes in the dynamics of ecological systems under stress. Ecological 
Complexity 32:144-155.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raw_kbdm">raw_kbdm</a></code>, <code><a href="acss.html#topic+acss">acss</a></code>, 
<code><a href="#topic+indictest">indictest</a></code>, to test the significance of indicator values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 

kbdm_result &lt;- kbdm_sews(serengeti, subsize = 3)
plot(kbdm_result, along = serengeti.rain)

kbdm_test &lt;- indictest(kbdm_result, nulln = 49)
plot(kbdm_test, along = serengeti.rain)

# Plot deviation to null expectation
plot(kbdm_test, along = serengeti.rain, what = "z_score") 




</code></pre>

<hr>
<h2 id='label'>Labelling of unique patches and detection of percolation.</h2><span id='topic+label'></span><span id='topic+percolation'></span>

<h3>Description</h3>

<p>Label each patch with a number in a binary matrix
</p>
<p><code>percolation()</code> detects whether percolation occurs in the
matrix (i.e. a patch has a width or a height equal to the size of the 
matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label(mat, nbmask = "von_neumann", wrap = FALSE)

percolation(mat, nbmask = "von_neumann")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_+3A_mat">mat</code></td>
<td>
<p>A binary matrix</p>
</td></tr>
<tr><td><code id="label_+3A_nbmask">nbmask</code></td>
<td>
<p>Either &quot;moore&quot; for 8-way neighborhood, &quot;von_neumann&quot; for four-way 
neighborhood (default), or a 3x3 matrix describing which neighbors to 
consider around a cell. See <code><a href="#topic+patchsizes">patchsizes</a></code> for details on how to specify 
such neighborhoods.</p>
</td></tr>
<tr><td><code id="label_+3A_wrap">wrap</code></td>
<td>
<p>Whether to wrap around lattice boundaries ('TRUE'/'FALSE'), 
effectively using periodic boundaries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>label</code> function &quot;labels&quot; the patches of a binary 
(<code>TRUE</code>/<code>FALSE</code>) matrix. It returns a matrix of similar height and width, 
with integer values representing the ID of each unique patch (contiguous
cells). Empty cells are labelled as <code>NA</code>.
</p>


<h3>Value</h3>

<p>A matrix containing ID numbers for each connected patch. Default 
parameters assume 4-cell neighborhood and periodic boundaries. The 
distribution of patch sizes is returned as the attribute &quot;psd&quot; and the 
percolation status as &quot;percolation&quot; (whether a TRUE patch has a width 
or height equal to the size of the matrix).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+patchsizes">patchsizes</a></code>, <code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(forestgap)

rmat &lt;- matrix(rnorm(100) &gt; .1, ncol = 10)
display_matrix(label(rmat))

# With 8-way neighborhood mask and no wrapping around borders
display_matrix(label(rmat, "moore", wrap = FALSE))

# On real data: 
display_matrix(label(forestgap[[5]], "moore", wrap = FALSE))

</code></pre>

<hr>
<h2 id='lsw_sews'>Indicators based on the LSW distribution</h2><span id='topic+lsw_sews'></span><span id='topic+raw_patch_radii_skewness'></span><span id='topic+raw_lsw_aicw'></span>

<h3>Description</h3>

<p>LSW indicators for systems with density-dependent aggregation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsw_sews(mat, wrap = FALSE)

raw_patch_radii_skewness(mat, wrap = FALSE)

raw_lsw_aicw(mat, wrap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lsw_sews_+3A_mat">mat</code></td>
<td>
<p>A logical matrix (<code>TRUE</code>/<code>FALSE</code> values) or a list of such
matrices</p>
</td></tr>
<tr><td><code id="lsw_sews_+3A_wrap">wrap</code></td>
<td>
<p>Determines whether patches are considered to wrap around the 
matrix when reaching on of its edges</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In systems where a mobile resource or consumer can be fixed in space by a sessile 
species, specific patterns are expected to appear. Such systems can include situations 
where nutrients available in the environmeent are fixed by a sessile species (e.g. 
seagrasses or corals), or where the behavior of herbivores is altered to restrict 
them to certain areas (see full theoretical background in Siteur et al. 2023). 
</p>
<p>In those systems, as environmental conditions change and the global density of 
the sessile species decreases, its spatial structure is expected to change. The area 
of patches of the sessile species (as measured by their radii, which assumes circular
patches), is expected to go from a log-normal to a  Lifshitz–Slyozov–Wagner (LSW)
distribution. Thus, measuring how close the observed distribution of radii are to 
those two candidate distributions can constitute an indicator of ecosystem 
degradation. 
</p>
<p>This function measures this through the relative support based on AIC for the two 
distributions (equal to 1 when the empirical distribution is best-approximated by an 
LSW, and 0 when it is a log-normal distribution (<code><a href="stats.html#topic+dlnorm">dlnorm</a></code>), and the 
skewness of the observed patch radii, which should approach a value around -0.92 as
conditions worsen.
</p>


<h3>Value</h3>

<p><code>lsw_sews</code> returns an object of class <code>simple_sews_single</code>
(a list) if <code>mat</code> is a single matrix or an object of class 
<code>simple_sews_list</code> if <code>mat</code> is a list. You probably want to use some  
of the methods written for these complicated objects instead of extracting 
values directly (they are displayed using <code>print(&lt;object&gt;)</code>).
</p>


<h3>Author(s)</h3>

<p>This code has received contributions from Koen Siteur
</p>


<h3>References</h3>

<p>Siteur, Koen, Quan-Xing Liu, Vivi Rottschäfer, Tjisse van der Heide, Max Rietkerk, 
Arjen Doelman, Christoffer Boström, and Johan van de Koppel. 2023. 
&quot;Phase-Separation Physics Underlies New Theory for the Resilience of Patchy 
Ecosystems.&quot; Proceedings of the National Academy of Sciences 120 (2): e2202683120.
https://doi.org/10.1073/pnas.2202683120.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dLSW">dLSW</a></code>, <code><a href="#topic+dda">dda</a></code>,
<code><a href="#topic+raw_patch_radii_skewness">raw_patch_radii_skewness</a></code>, <code><a href="#topic+raw_lsw_aicw">raw_lsw_aicw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dda)
data(dda.pars)

# Compute all indicators at once (skewness and relative AIC support)
indics &lt;- lsw_sews(dda)
plot(indics, along = dda.pars[ ,"tau"]) 

# Compute individual indicators 

# Skewness of the distribution of patch radii
radii_skewness &lt;- compute_indicator(dda, raw_patch_radii_skewness)
plot(radii_skewness, along = dda.pars[ ,"tau"])

# Aic weight of LSW distribution relative to a lognormal distribution. tau here 
# represents the density at equilibrium in Siteur et al's model (2023)
lsw_aicw &lt;- compute_indicator(dda, raw_lsw_aicw)
plot(lsw_aicw, along = 1 - dda.pars[ ,"tau"])

</code></pre>

<hr>
<h2 id='patchdistr_sews'>Early-warning signals based on patch size distributions</h2><span id='topic+patchdistr_sews'></span>

<h3>Description</h3>

<p>Compute early-warning signals based on patch size distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patchdistr_sews(
  mat,
  merge = FALSE,
  fit_lnorm = FALSE,
  best_by = "BIC",
  xmin = 1,
  xmin_bounds = NULL,
  wrap = FALSE,
  nbmask = "von_neumann"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patchdistr_sews_+3A_mat">mat</code></td>
<td>
<p>A logical matrix (<code>TRUE</code>/<code>FALSE</code> values) or a list of these</p>
</td></tr>
<tr><td><code id="patchdistr_sews_+3A_merge">merge</code></td>
<td>
<p>The default behavior is to produce indicators values for each 
matrix. If this parameter is set to TRUE then the patch size distributions 
are pooled together before fitting, yielding only one final indicator 
value for the set of input matrices (argument <code>mat</code>).</p>
</td></tr>
<tr><td><code id="patchdistr_sews_+3A_fit_lnorm">fit_lnorm</code></td>
<td>
<p>When patch size distributions are compared, should we 
consider lognormal type ? (see details)</p>
</td></tr>
<tr><td><code id="patchdistr_sews_+3A_best_by">best_by</code></td>
<td>
<p>The criterion to use to select the best fit (one of &quot;AIC&quot;, 
&quot;BIC&quot; or &quot;AICc&quot;)</p>
</td></tr>
<tr><td><code id="patchdistr_sews_+3A_xmin">xmin</code></td>
<td>
<p>The <code class="reqn">x_{min}</code> to be used to fit the patch size distributions. Use 
the special value &quot;estimate&quot; to compute first the <code class="reqn">x_{min}</code> that produces 
the best power-law fit, then use this estimated value to fit all 
distributions.</p>
</td></tr>
<tr><td><code id="patchdistr_sews_+3A_xmin_bounds">xmin_bounds</code></td>
<td>
<p>Bounds when estimating <code class="reqn">x_{min}</code> for power-law distributions</p>
</td></tr>
<tr><td><code id="patchdistr_sews_+3A_wrap">wrap</code></td>
<td>
<p>Determines whether patches are considered to wrap around the 
matrix when reaching the side</p>
</td></tr>
<tr><td><code id="patchdistr_sews_+3A_nbmask">nbmask</code></td>
<td>
<p>Either &quot;moore&quot; for 8-way neighborhood, &quot;von_neumann&quot; for four-way 
neighborhood (default), or a 3x3 matrix describing which neighbors to 
consider around a cell. See <code><a href="#topic+patchsizes">patchsizes</a></code> for details on how to specify 
such neighborhoods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Patterned ecosystems can exhibit a change in their spatial structure as they 
become more and more stressed. It has been suggested that this should be 
reflected in changes in the observed patch size distributions (PSD). 
The following sequence is expected to occur (Kefi et al. 2011) as patterned 
ecosystems become more and more degraded:
</p>
<p>- Percolation of vegetation patches occurs (a patch has a width or height 
equal to the size of the system)
</p>
<p>- The patch-size distribution follows a power-law
</p>
<p>- The patch-size distribution deviates from a power-law as larger patches 
break down
</p>
<p>- The patch-size distribution is closer to an exponential 
distribution
</p>
<p>Additionally, it has been suggested that these changes in patch size 
distribution shape should be reflected in the power-law range (PLR). This 
function carries out all the required computations and helps display 
the results in a convenient form. 
</p>
<p>The fitting of PSDs is based on maximum-likelihood following Clauset et al.'s 
procedure. The best discrete distribution is estimated among these 
candidates: a power-law <code class="reqn">x^\lambda</code>, an exponential 
<code class="reqn">exp(\alpha x)</code>, a truncated power-law and <code class="reqn">x^\lambda exp(\alpha x)</code>,
and optionally, a log-normal. Each distribution parameter is estimated 
using maximum-likelihood, with a minimum patch size (xmin) fixed to one. 
The best distribution is selected based on BIC by default. In raw results, 
<code>plexpo</code> refers to the power-law exponent (<code class="reqn">\lambda</code> in the previous 
equations) and <code>cutoff</code> referes to the exponential decay rate
<code class="reqn">\alpha</code>. 
</p>
<p>To compute the Power-law range (PLR), power-laws are fitted with a variable 
minimum patch size (xmin) and the one with the lowest Kolmogorov-Smirnov
distance to the empirical distribution is retained. PLR is then computed 
using this best-fitting xmin: 
</p>
<p style="text-align: center;"><code class="reqn">\frac{log(x_{max}) - log(x_{min})}{log(x_{max}) - log(x_{smallest})}</code>
</p>

<p>Results can be displayed using the text-based <code>summary</code> and <code>print</code>, 
but graphical options are also available to plot the trends (<code>plot</code>) and 
the fitted distributions (<code><a href="#topic+plot_distr">plot_distr</a></code>). Plotting functions are 
documented in a <a href="#topic+patchdistr_sews_plot">separate page</a>. Observed and 
fitted distributions can be produced using the <code>predict</code> function, 
as documented on <a href="#topic+patchdistr_sews_predict">this page</a>.
</p>


<h3>Value</h3>

<p>A list object of class 'psdfit' containing among other things 
- the observed patch size distribution data
- the model outputs for the candidate distribution fits
- the power-law range values 
- the percolation values (if several matrices were provided and 
'merge' was TRUE, then the average percolation value is returned)
</p>


<h3>References</h3>

<p>Kefi, S., Rietkerk, M., Alados, C. L., Pueyo, Y., Papanastasis, 
V. P., ElAich, A., &amp; De Ruiter, P. C. (2007). Spatial vegetation patterns 
and imminent desertification in Mediterranean arid ecosystems. 
Nature, 449(7159), 213-217.
</p>
<p>Kefi, S., Rietkerk, M., Roy, M., Franc, A., de Ruiter, P.C. &amp; Pascual, M. 
(2011). Robust scaling in ecosystems and the meltdown of patch size 
distributions before extinction: Patch size distributions towards 
extinction. Ecology Letters, 14, 29-35.
</p>
<p>Berdugo, M, Sonia Kefi, Santiago Soliveres, and Fernando T. Maestre. (2017) 
Plant Spatial Patterns Identify Alternative Ecosystem Multifunctionality 
States in Global Drylands. Nature in Ecology and Evolution, no. 1.
</p>
<p>Clauset, A., Shalizi, C. R., &amp; Newman, M. E. (2009). 
Power-law distributions in empirical data. SIAM review, 51(4), 661-703.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+patchsizes">patchsizes</a></code>, <code><a href="#topic+plot_distr">plot_distr</a></code>, 
<code><a href="#topic+predict.patchdistr_sews_single">predict</a></code>, 
<code><a href="#topic+plot.patchdistr_sews">plot</a></code>,
</p>
<p><code><a href="#topic+indictest">indictest</a></code>, to test the significance of indicator values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(forestgap)


psd_indic &lt;- patchdistr_sews(forestgap)

summary(psd_indic)
plot(psd_indic)

# Plots can be modified using ggplot2 directives 
if ( require(ggplot2) ) { 
  plot(psd_indic) + 
    theme_minimal()
}

# Export results to a data.frame
psd_indic_export &lt;- as.data.frame(psd_indic) 
head(psd_indic_export)


</code></pre>

<hr>
<h2 id='patchdistr_sews_plot'>Early-warning signals based on patch size distributions</h2><span id='topic+patchdistr_sews_plot'></span><span id='topic+plot.patchdistr_sews'></span><span id='topic+plot_distr'></span>

<h3>Description</h3>

<p>Plot early-warning signals based on patch size distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'patchdistr_sews'
plot(x, along = NULL, ...)

plot_distr(x, along = NULL, best_only = TRUE, plrange = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patchdistr_sews_plot_+3A_x">x</code></td>
<td>
<p>An object as produced by <code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>, or 
the result of <code><a href="#topic+indictest">indictest</a></code> called on such object</p>
</td></tr>
<tr><td><code id="patchdistr_sews_plot_+3A_along">along</code></td>
<td>
<p>A vector providing values along which the indicator trends 
will be plotted. If <code>NULL</code> then the values are plotted sequentially 
in their original order.</p>
</td></tr>
<tr><td><code id="patchdistr_sews_plot_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="patchdistr_sews_plot_+3A_best_only">best_only</code></td>
<td>
<p>Plot only the best fit the empirical (inverse cumulative) 
patch-size distribution with an overlay of the estimated fits.</p>
</td></tr>
<tr><td><code id="patchdistr_sews_plot_+3A_plrange">plrange</code></td>
<td>
<p>Plot the power-law range</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> function will produce a figure summarizing the changes
in patch size distributions along a set of values. The figure has two 
panels: 
</p>
 
<ul>
<li><p> the upper panel shows the percolation status of empty 
(<code>FALSE</code>) and occupied cells (<code>TRUE</code>), and shows the mean 
value (proportion of <code>TRUE</code> values). The background shows 
the proportion of each type of distribution for each unique values 
of the <code>along</code> vector. 
</p>
</li>
<li><p> the bottom panel displays the power-law range
</p>
</li></ul>

<p>The <code>plot_distr</code> function displays each distribution in an 
individual facet, with an overlay of the best distribution fit and a blue 
bar showing the power-law range. If appropriate, a grey ribbon is used to
display the expected distribution given the null expectation (i.e. when 
<code>plot_distr</code> is called on the results of <code>indictest()</code>. This 
function can produce quite crowded graphs, but it displays in full the
shape of the distributions, and can be useful e.g. to assess the quality 
of the fits.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
data(forestgap)
psd_indic &lt;- patchdistr_sews(forestgap)

plot(psd_indic, along = forestgap.pars[ ,"d"]) 

# When along is non-numeric, bars are used for display
plot(psd_indic, along = as.factor(forestgap.pars[ ,"d"]))

# Display individual distributions
plot_distr(psd_indic, along = forestgap.pars[ ,"d"])

# We can display the distributions along with the null expectation after 
# indictest() is run
psd_test &lt;- indictest(psd_indic, nulln = 19)
plot_distr(psd_test, along = forestgap.pars[ ,"d"])


</code></pre>

<hr>
<h2 id='patchdistr_sews_predict'>predict method for patchdistr_sews objects</h2><span id='topic+patchdistr_sews_predict'></span><span id='topic+predict.patchdistr_sews_single'></span>

<h3>Description</h3>

<p>Export the observed and fitted patch size distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'patchdistr_sews_single'
predict(object, ..., newdata = NULL, best_only = FALSE, xmin_rescale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patchdistr_sews_predict_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code> object</p>
</td></tr>
<tr><td><code id="patchdistr_sews_predict_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored)</p>
</td></tr>
<tr><td><code id="patchdistr_sews_predict_+3A_newdata">newdata</code></td>
<td>
<p>A vector of patch sizes at which the fit is returned (default 
to 200 regularly-spaced values).</p>
</td></tr>
<tr><td><code id="patchdistr_sews_predict_+3A_best_only">best_only</code></td>
<td>
<p>Return values for only the best fit of each element (matrix)
in <code>object</code>, or return the values for all fitted distribution.</p>
</td></tr>
<tr><td><code id="patchdistr_sews_predict_+3A_xmin_rescale">xmin_rescale</code></td>
<td>
<p>If the xmin value used for fits is above one, then setting this
to <code>TRUE</code> will rescale the predicted probabilities so that they align on 
the cumulative distribution of the observed patch sizes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code> fits competing 
distribution models to the observed patch size distributions. This 
functions is able to export the observed values and the fitted values 
altogether.
</p>


<h3>Value</h3>

<p>A list with component <code>obs</code>, a <code>data.frame</code> containing the observed 
distribution values and <code>pred</code>, a <code>data.frame</code> containing the fitted 
values. Both <code>data.frame</code>s have columns <code>matrixn</code>, the number of 
the matrix for which values are given, <code>type</code>, the fitted type of distribution, 
as well as <code>patchsize</code> and <code>y</code>, the patch size and value of the
inverse cumulative distribution function (i.e. <code class="reqn">1 - P(x&lt;k)</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
patch_indics &lt;- patchdistr_sews(forestgap)

predict(patch_indics)



</code></pre>

<hr>
<h2 id='patchsizes'>Get patch sizes.</h2><span id='topic+patchsizes'></span>

<h3>Description</h3>

<p>Get the distribution of patch sizes from a logical matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patchsizes(mat, merge = FALSE, nbmask = "von_neumann", wrap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patchsizes_+3A_mat">mat</code></td>
<td>
<p>A logical matrix or a list of such matrices.</p>
</td></tr>
<tr><td><code id="patchsizes_+3A_merge">merge</code></td>
<td>
<p>Controls whether the obtained patch size distributions are to 
be pooled together if <code>mat</code> is a list of matrices.</p>
</td></tr>
<tr><td><code id="patchsizes_+3A_nbmask">nbmask</code></td>
<td>
<p>Either &quot;moore&quot; for 8-way neighborhood, &quot;von_neumann&quot; for four-way 
neighborhood (default), or a 3x3 matrix describing which neighbors to 
consider around a cell. See <code><a href="#topic+patchsizes">patchsizes</a></code> for details on how to specify 
such neighborhoods.</p>
</td></tr>
<tr><td><code id="patchsizes_+3A_wrap">wrap</code></td>
<td>
<p>Whether to wrap around lattice boundaries ('TRUE'/'FALSE'), 
effectively using periodic boundaries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If mat is a logical matrix, then the function returns a vector of 
patch sizes. If mat is a list of logical matrices, then it returns 
a list of vectors of patch sizes: this list is flattened if merge is TRUE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+label">label</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(forestgap)
patchsizes(forestgap[[5]]) # Use a single matrix

# Compute the average patch size of each matrix
list_patches &lt;- patchsizes(forestgap) # get the patch size for each matrix
print( sapply(list_patches, mean)) # print the average patch size 

# Example with 8-way neighborhood
patchsizes(forestgap[[5]], nbmask = "moore")

# Same neighborhood as above, but specified in matrix form 
moore_nb &lt;- matrix(c(1, 1, 1, 
                     1, 0, 1, 
                     1, 1, 1), 
                   nrow = 3, ncol = 3, byrow = TRUE)
patchsizes(forestgap[[5]], nbmask = moore_nb) 

</code></pre>

<hr>
<h2 id='pl_fit'>Distribution-fitting functions</h2><span id='topic+pl_fit'></span><span id='topic+exp_fit'></span><span id='topic+lnorm_fit'></span><span id='topic+tpl_fit'></span>

<h3>Description</h3>

<p>These functions fit parametric distributions to a set of
discrete values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pl_fit(dat, xmin = 1)

exp_fit(dat, xmin = 1)

lnorm_fit(dat, xmin = 1)

tpl_fit(dat, xmin = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pl_fit_+3A_dat">dat</code></td>
<td>
<p>The set of values to which the distribution are fit</p>
</td></tr>
<tr><td><code id="pl_fit_+3A_xmin">xmin</code></td>
<td>
<p>The minimum possible value to consider when fitting the
distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will fit distributions to a set of values using 
maximum-likelihood estimation. In the context of the 'spatialwarnings' 
package, they are most-often used to fit parametric distributions on patch
size distributions. As a result, these functions assume that the data 
contains only integer, strictly positive values. The type of distribution
depends on the prefix of the function: 'pl' for power-law, 'tpl' for
truncated power-law, 'lnorm' for lognormal and 'exp' for an exponential
distribution. 
</p>
<p>In the context of distribution-fitting, 'xmin' represents the minimum value 
that a distribution can take. It is often used to represent the minimum 
scale at which a power-law model is appropriate (Clauset et al. 2009), and 
can be estimated on an empirical distribution using
<code><a href="#topic+xmin_estim">xmin_estim</a></code>. Again, please note that the fitting procedure 
assumes here that xmin is equal or grater than one.
</p>
<p>Please note that a best effort is made to have the fit converge, but 
it may sometimes fail when the parameters are far from their usual 
range, and numerical issues may occur. It is good practice to make 
sure the fits are sensible when convergence warnings are reported.
</p>
<p>For reference, the shape of the distributions is as follow: 
</p>

<dl>
<dt>power-law</dt><dd><p><code class="reqn">x^{-a}</code> where a is the power-law exponent</p>
</dd>
<dt>exponential</dt><dd><p><code class="reqn">exp(-bx)</code> where b is the truncation rate
of the exponential</p>
</dd>
<dt>truncated power-law</dt><dd><p><code class="reqn">x^{-a}exp(-bx)</code> where a
and b are the exponent of the power law and the rate of truncation</p>
</dd>
</dl>

<p>The lognormal form follows the <a href="stats.html#topic+dlnorm">standard definition</a>.
</p>
<p>The following global options can be used to change the behavior of fitting functions 
and/or produce more verbose output: 
</p>
 
<dl>
<dt>spatialwarnings.constants.reltol</dt><dd><p>the relative tolerance to use to compute 
the power-law normalizing constant
</p>
<p style="text-align: center;"><code class="reqn">sum_{k=1}^{\infty} x^{ak}e^{-bk}</code>
</p>
<p>. 
Increase to increase the precision of this constant, which can be useful in some 
cases, typically with large sample sizes. Default is 1e-8.</p>
</dd>
<dt>spatialwarnings.constants.maxit</dt><dd><p>the maximum number of iterations to compute 
the normalizing constant of a truncated power-law. Increase if you get a warning 
that the relative tolerance level (defined above) was not reached. Default is 1e8</p>
</dd>
<dt>spatialwarnings.debug.fit_warn_on_bound</dt><dd><p>logical value. Warn if the fit is 
at the boundary of the valid range for distribution parameter</p>
</dd>
<dt>spatialwarnings.debug.fit_warn_on_NA</dt><dd><p>logical value. Warn if the returned fit 
has <code>NA</code>/<code>NaN</code> parameters</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing at list the following components: 
</p>
 
<dl>
<dt><code>type</code></dt><dd><p>The type of distribution fitted (as a character string)</p>
</dd>
<dt><code>method</code></dt><dd><p>The method used for the fit - here, maximum likelihood, 'll'</p>
</dd>
<dt><code>ll</code></dt><dd><p>The log likelihood at the estimated parameter values</p>
</dd>
<dt><code>xmin</code></dt><dd><p>The value of xmin used for the fit</p>
</dd>
<dt><code>npars</code></dt><dd><p>The number of parameters of the distribution</p>
</dd>
</dl>

<p>Additionally, this list may have one or more of the following elements depending on 
the type of distribution that has been fitted: 
</p>
 
<dl>
<dt><code>plexpo</code></dt><dd><p>The exponent of the power-law</p>
</dd>
<dt><code>cutoff</code></dt><dd><p>The rate of truncation, for truncated power law and 
exponential fits</p>
</dd>
<dt><code>meanlog</code></dt><dd><p>The mean of the lognormal distribution</p>
</dd>
<dt><code>sdlog</code></dt><dd><p>The s.d. of the lognormal distribution</p>
</dd>
</dl>



<h3>References</h3>

<p>Clauset, Aaron, Cosma Rohilla Shalizi, and M. E. J. Newman. 2009. “Power-Law
Distributions in Empirical Data.” SIAM Review 51 (4): 661–703. 
https://doi.org/10.1137/070710111.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>, <code><a href="#topic+xmin_estim">xmin_estim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit an exponential model to patch size distribution 
exp_fit(patchsizes(forestgap[[8]]))
 
# Use the estimated parameters as an indicator function


get_truncation &lt;- function(mat) { 
   c(exp_cutoff = exp_fit(patchsizes(mat))$cutoff)
}
trunc_indic &lt;- compute_indicator(forestgap, get_truncation)
plot(trunc_indic)
plot(indictest(trunc_indic, nulln = 19))



</code></pre>

<hr>
<h2 id='plot_spectrum'>Display the r-spectrum of a <code>spectral_sews</code> object</h2><span id='topic+plot_spectrum'></span>

<h3>Description</h3>

<p>Display the r-spectrum (or multiple spectra) that are contained
in an object returned by <code><a href="#topic+spectral_sews">spectral_sews</a></code> object (or the result 
of <code><a href="#topic+indictest">indictest</a></code> applied on such object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spectrum(x, along = NULL, log = TRUE, display_null = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_spectrum_+3A_x">x</code></td>
<td>
<p>An object produced by <code><a href="#topic+spectral_sews">spectral_sews</a></code> or the result 
returned by <code><a href="#topic+indictest">indictest</a></code> applied on such object</p>
</td></tr>
<tr><td><code id="plot_spectrum_+3A_along">along</code></td>
<td>
<p>A vector providing numerical or categorical values along 
which the indicator trends will be plotted. If <code>NULL</code>, then the
indicator values are plotted sequentially in their original order.</p>
</td></tr>
<tr><td><code id="plot_spectrum_+3A_log">log</code></td>
<td>
<p>Whether to use a log scale or a linear scale on the y axis</p>
</td></tr>
<tr><td><code id="plot_spectrum_+3A_display_null">display_null</code></td>
<td>
<p>Whether to display null information. This argument is 
ignored if <code>x</code> has not been produced through <code><a href="#topic+indictest">indictest</a></code> 
(and thus does not contain data regarding the null model)</p>
</td></tr>
<tr><td><code id="plot_spectrum_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rspectrum">rspectrum</a></code>, <code><a href="#topic+spectral_sews">spectral_sews</a></code>, 
<code><a href="#topic+extract_spectrum">extract_spectrum</a></code>
</p>

<hr>
<h2 id='plot.simple_sews_test'>Spatial early-warning signals: display of trends</h2><span id='topic+plot.simple_sews_test'></span><span id='topic+plot.simple_sews_list'></span>

<h3>Description</h3>

<p>Spatial early-warning signals: display of trends
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simple_sews_test'
plot(x, along = NULL, what = "value", display_null = TRUE, ...)

## S3 method for class 'simple_sews_list'
plot(x, along = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simple_sews_test_+3A_x">x</code></td>
<td>
<p>A <code>simple_sews_test</code> object (as provided by **_sews functions, such 
as <code>generic_sews()</code></p>
</td></tr>
<tr><td><code id="plot.simple_sews_test_+3A_along">along</code></td>
<td>
<p>A vector providing values over which the indicator trend 
will be plotted. If <code>NULL</code> then the values are plotted sequentially 
in their original order.</p>
</td></tr>
<tr><td><code id="plot.simple_sews_test_+3A_what">what</code></td>
<td>
<p>The trendline to be displayed. Defaults to the indicator's 
values (&quot;value&quot;) but other metrics can be displayed. Accepted values are 
&quot;value&quot;, &quot;pval&quot;, &quot;difference&quot; (obs - null mean), or &quot;z_score&quot; 
( (obs - null mean) / (null sd) ).</p>
</td></tr>
<tr><td><code id="plot.simple_sews_test_+3A_display_null">display_null</code></td>
<td>
<p>Chooses whether a grey ribbon should be added to reflect
the null distribution. Note that it can not be displayed when the trend 
line reflects something else than the indicator values (when <code>what</code> 
is not set to &quot;value&quot;).</p>
</td></tr>
<tr><td><code id="plot.simple_sews_test_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the produced plot is adjusted depending on whether 
<code>along</code> is numeric or not.
</p>

<hr>
<h2 id='raw_cg_moran'>Moran's Index at lag of 1</h2><span id='topic+raw_cg_moran'></span>

<h3>Description</h3>

<p>This functions computes the Moran's spatial correlation index 
(with lag one) on a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_cg_moran(mat, subsize = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_cg_moran_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="raw_cg_moran_+3A_subsize">subsize</code></td>
<td>
<p>logical. Dimension of the submatrix used to coarse-grain the 
original matrix (set to 1 for no coarse-graining).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Moran's I index measuring autocorrelation at lag 1 as a 
named vector
</p>


<h3>References</h3>

<p>Dakos, V., van Nes, E. H., Donangelo, R., Fort, H., &amp; 
Scheffer, M. (2010). Spatial correlation as leading indicator of 
catastrophic shifts. Theoretical Ecology, 3(3), 163-174.
</p>
<p>Legendre, P., &amp; Legendre, L. F. J. (2012). Numerical Ecology.
Elsevier Science.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generic_sews">generic_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(serengeti)
raw_cg_moran(serengeti[[1]], subsize = 1)


</code></pre>

<hr>
<h2 id='raw_cg_skewness'>Skewness indicator</h2><span id='topic+raw_cg_skewness'></span>

<h3>Description</h3>

<p>Compute the spatial skewness of spatial data (a matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_cg_skewness(mat, subsize = 5, absolute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_cg_skewness_+3A_mat">mat</code></td>
<td>
<p>A matrix. The matrix 
values can be logical, with <code>FALSE</code> (empty) or <code>TRUE</code> (occupied) 
values. The entries can also be continuous (like NDVI or EVI data).</p>
</td></tr>
<tr><td><code id="raw_cg_skewness_+3A_subsize">subsize</code></td>
<td>
<p>Dimension of the submatrix used to coarse-grain the 
original matrix. This must be an integer less than size of the full 
matrix. Coarse-graining reduces the size of the matrix by a factor 
<code>subsize</code> in each dimension of the matrix. Skewness is calculated 
on the coarse-grained matrix.</p>
</td></tr>
<tr><td><code id="raw_cg_skewness_+3A_absolute">absolute</code></td>
<td>
<p>Should the function return the absolute value or raw value 
of skewness ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial skewness is a measure of fluctuations in space; specifically, it 
measures if fluctuations are getting biased (skewed) in one direction. Based 
on the theory of critical slowing down, when systems approach critical 
points they are expected to show increased fluctuations in space. Thus, 
increasing spatial skewness is proposed as an early warning signal of 
impending critical transitions. 
</p>
<p>Computing spatial skewness is straightforward. However, detecting trends of 
skewness that correspond to critical slowing down can be tricky, especially 
if data come from discrete classification of state variable.
</p>
<p>Many high resolution spatial data are classified as FALSE (empty) 
or TRUE (occupied by plant). In such cases, spatial skewness captures just 
the skewness in data, but not that of spatial structure. 
To resolve the issue, this function employs a method called coarse-graining, 
proposed in Kefi et al (2014), and described in detail in 
Sankaran et al. (2017). One must specify a subsize above one for 
binary valued data sets to obtain meaningful values. 
</p>
<p><code>subsize</code> has to be an integer. It has to be less than or equal to 
half of matrix size (N). <code>subsize</code> must also be preferably a 
divisor of N. If it is not a divisor of N, the remainder rows and columns 
are discarded when computing coarse-graining matrices. 
</p>
<p>Null model evaluations are also done on coarse-grained matrices.
</p>


<h3>Value</h3>

<p>The spatial skewness of the matrix as a named vector
</p>


<h3>References</h3>

<p>Guttal, V., and Jayaprakash, C. (2009). Spatial variance and 
spatial skewness: leading indicators of regime shifts in spatial 
ecological systems. Theoretical Ecology, 2(1), 3-12.
</p>
<p>Kefi, S., Guttal, V., Brock, W.A., Carpenter, S.R., Ellison, A.M., 
Livina, V.N., et al. (2014). Early Warning Signals of Ecological 
Transitions: Methods for Spatial Patterns. PLoS ONE, 9, e92097.
</p>
<p>Sankaran, S., Majumder, S., Kefi, S., and Guttal, V. (2017). Implication of 
being discrete and spatial in detecting early warning signals of regime 
shifts. Ecological indicators.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generic_sews">generic_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(serengeti)

raw_cg_skewness(serengeti[[1]])
compute_indicator(serengeti, fun = raw_cg_skewness, subsize = 5)


</code></pre>

<hr>
<h2 id='raw_cg_variance'>Spatial variance indicator</h2><span id='topic+raw_cg_variance'></span>

<h3>Description</h3>

<p>This functions computes the spatial variance of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_cg_variance(mat, subsize = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_cg_variance_+3A_mat">mat</code></td>
<td>
<p>A matrix. Its values can be logical, with <code>FALSE</code> (empty) 
or <code>TRUE</code> (occupied) values. The entries can also be continuous 
(like NDVI or EVI data).</p>
</td></tr>
<tr><td><code id="raw_cg_variance_+3A_subsize">subsize</code></td>
<td>
<p>Dimension of the submatrix used to coarse-grain the 
original matrix. This must be an integer less than size of the full 
matrix. Coarse-graining reduces the size of the matrix by a factor 
<code>subsize</code> in each dimension of the matrix. Variance is calculated 
on the coarse-grained matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial variance is a measure of fluctuations in space. Based on the theory 
of critical slowing down, when systems approach critical points
they are expected to show increased fluctuations in space. Thus, increasing 
spatial variance is proposed as an early warning signal of impending 
critical transitions. 
</p>
<p>Many high resolution spatial data are classified as FALSE (empty) 
or TRUE (occupied). In such cases, spatial variance captures just 
the variance in data, but not that of spatial structure. 
To resolve the issue, this function employs a method called coarse-graining, 
proposed in Kefi et al (2014), and described in detail in 
Sankaran et al. (2017). One must specify a subsize above one for 
binary valued data sets to obtain meaningful values. 
</p>
<p><code>subsize</code> has to be an integer. It has to be less than or equal to 
half of matrix size (N). <code>subsize</code> must also be preferably a 
divisor of N. If it is not a divisor of N, the remainder rows and columns 
are discarded when computing coarse-graining matrices. 
</p>
<p>Null model evaluations are also done on coarse-grained matrices.
</p>


<h3>Value</h3>

<p>The variance of the coarse-grained matrix as a named vector
</p>


<h3>References</h3>

<p>Guttal, V., and Jayaprakash, C. (2009). Spatial variance and 
spatial skewness: leading indicators of regime shifts in spatial 
ecological systems. Theoretical Ecology, 2(1), 3-12.
</p>
<p>Kefi, S., Guttal, V., Brock, W.A., Carpenter, S.R., Ellison, A.M., 
Livina, V.N., et al. (2014). Early Warning Signals of Ecological 
Transitions: Methods for Spatial Patterns. PLoS ONE, 9, e92097.
</p>
<p>Sankaran, S., Majumder, S., Kefi, S., and Guttal, V. (2017). Implication 
of being discrete and spatial in detecting early warning signals
of regime shifts. Ecological Indicators.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generic_sews">generic_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(serengeti)
raw_cg_variance(serengeti[[1]])
compute_indicator(serengeti, fun = raw_cg_variance, subsize = 5)


</code></pre>

<hr>
<h2 id='raw_clustering'>Clustering of pairs</h2><span id='topic+raw_clustering'></span><span id='topic+pair_counts'></span>

<h3>Description</h3>

<p>Compute the number of pairs of neighbor cells in a landscape and derive 
from it clustering indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_clustering(mat, wrap = TRUE, use_8_nb = FALSE)

pair_counts(mat, wrap = TRUE, use_8_nb = FALSE, prop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_clustering_+3A_mat">mat</code></td>
<td>
<p>A matrix, usually with discrete values (logical, integers, etc.)</p>
</td></tr>
<tr><td><code id="raw_clustering_+3A_wrap">wrap</code></td>
<td>
<p>Whether space should be considered to wrap at the edges</p>
</td></tr>
<tr><td><code id="raw_clustering_+3A_use_8_nb">use_8_nb</code></td>
<td>
<p>Set to <code>TRUE</code> to use an 8-way neighborhood. The default is set
to FALSE, which uses a 4-way neighborhood</p>
</td></tr>
<tr><td><code id="raw_clustering_+3A_prop">prop</code></td>
<td>
<p>Return the counts for all pairs in the matrix (FALSE), or
the proportions for each pair (out of all possible pairs)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clustering of pairs is defined as the density of pairs, i.e.
the proportion of all neighboring pairs of cells that share the same state, 
divided by the null expectation given a random, homogeneous spatial structure.
</p>
<p>For example, let's consider a matrix with two states, 'a' and 'b'.
<code>raw_clustering</code> will count all pairs of cells 'a-a' or 'b-b', and
divide this by the total number of pairs. This proportion is then again
divided by the probability of obtaining these proportion of pairs under
the assumption of no spatial structure (random mixing of cells in the
matrix). 
</p>
<p>Clustering is equal to one when there is no spatial structure. It is
above one when two states are found next to each other (i.e. cluster)
more than expected by chance. Values below one means that those two
states tend to be neighbors less frequently than expected by chance. 
</p>
<p>If you are only interested in the proportion of pairs for each combination
of states, you can use the function <code>pair_counts</code>, which returns
a matrix with as many rows and columns as there are states in the matrix, and 
contains the counts for all possible pairs of cells found in the matrix 
(or their relative proportions).
</p>


<h3>Value</h3>

<p>A vector with the requested clutering values for <code>raw_clustering</code>,
whose names are equal to each state (unique value) found in the
original matrix, preceded by 'clust_' (to make sure names are
compatible with other functions).
</p>
<p><code>pair_counts</code> returns the counts of pairs of states in the matrix,
or the proportion of each pair, depending on the value of <code>prop</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The clustering of a random matrix is close to one
ls &lt;- 100 # lattice size
mm &lt;- matrix(sample(c("sp1", "sp2", "sp3", "sp4"), size = ls^2, replace = TRUE),
             nrow = ls, ncol = ls)
clust &lt;- raw_clustering(mm, wrap = TRUE, use_8_nb = TRUE)
print(clust)

# Compute clustering along the gradient for the serengeti dataset


data(forestgap)
clust_indic &lt;- compute_indicator(serengeti, raw_clustering,
                                 wrap = TRUE, use_8_nb = FALSE)
# The interesting one is the clustering of state 0 (FALSE in the original matrix),
# which corresponds to grassland pixels, which get more and more clustered with 
# increasing rainfall (see also ?generic_sews for how that compares with generic 
# indicators)
plot(clust_indic, along = serengeti.rain)

# Add null trend
clust_test &lt;- indictest(clust_indic, nulln = 19)
plot(clust_test, along = serengeti.rain)

# Show the proportion of each pairs of states in the matrix... 
pair_counts(serengeti[[5]])

# ... or the total count
pair_counts(serengeti[[5]], prop = FALSE)



</code></pre>

<hr>
<h2 id='raw_flowlength_uniform'>Flow length (uniform slope)</h2><span id='topic+raw_flowlength_uniform'></span>

<h3>Description</h3>

<p>Compute a simple approximation of the flow length assuming a 
constant slope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_flowlength_uniform(mat, slope, cell_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_flowlength_uniform_+3A_mat">mat</code></td>
<td>
<p>The input matrix (must be a logical matrix)</p>
</td></tr>
<tr><td><code id="raw_flowlength_uniform_+3A_slope">slope</code></td>
<td>
<p>The slope of the area documented by the matrix (in degrees).</p>
</td></tr>
<tr><td><code id="raw_flowlength_uniform_+3A_cell_size">cell_size</code></td>
<td>
<p>The horizontal size of a cell in the matrix (as viewed 
from above).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the Flowlength of a given matrix, using a 
uniform approximation (the slope is constant across the whole matrix, 
with maximum slope being from the top of the matrix to its bottom), 
as per Rodriguez et al. (2017). See <code><a href="#topic+flowlength_sews">flowlength_sews</a></code> for 
more details.
</p>


<h3>Value</h3>

<p>A named vector of length 1 containing the flow length numerical 
value
</p>


<h3>References</h3>

<p>Rodriguez, F., A. G. Mayor, M. Rietkerk, and S. Bautista. 2017. A null model 
for assessing the cover-independent role of bare soil connectivity as 
indicator of dryland functioning and dynamics. Ecological Indicators.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flowlength_sews">flowlength_sews</a></code>
</p>
<p><code><a href="#topic+indictest">indictest</a></code>, to test the significance of indicator values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
raw_flowlength_uniform(arizona[[1]], slope = 20, cell_size = 1)



</code></pre>

<hr>
<h2 id='raw_kbdm'>Kolmogorov complexity of a matrix</h2><span id='topic+raw_kbdm'></span>

<h3>Description</h3>

<p>Compute the Kolmogorov complexity of a matrix using the 
Block Decomposition Method (requires the <code>acss</code> package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_kbdm(mat, subsize)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_kbdm_+3A_mat">mat</code></td>
<td>
<p>A logical matrix (with TRUE/FALSE values)</p>
</td></tr>
<tr><td><code id="raw_kbdm_+3A_subsize">subsize</code></td>
<td>
<p>A submatrix size to carry out the Block Decomposition Method
(must be between 1 and 3)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kolmogorov complexity cannot be computed directly for large strings 
(i.e. matrices). However, the complexity of smaller submatrices can be 
estimated, then combined to obtain an approximation of the complexity 
of the whole matrix. This method, the Block Decomposition Method is 
implemented in this function. See also <code><a href="#topic+kbdm_sews">kbdm_sews</a></code> 
for more details.
</p>


<h3>Value</h3>

<p>The KBDM numeric value as a named vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kbdm_sews">kbdm_sews</a></code>, <code><a href="acss.html#topic+acss">acss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
raw_kbdm(forestgap[[1]], subsize = 3)


</code></pre>

<hr>
<h2 id='raw_moran'>Spatial correlation at lag 1</h2><span id='topic+raw_moran'></span>

<h3>Description</h3>

<p>This function computes the Moran's I index of spatial 
correlation at lag 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_moran(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_moran_+3A_mat">mat</code></td>
<td>
<p>A matrix containing logical, numeric or integer values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the spatial correlation as measured by 
the Moran's I index. If the variance of the matrix is zero, then 
<code>NaN</code> is returned. This function assumes a 4-way neighborhood (a.k.a. 
von-Neumann neighborhood), and does not wrap around at the sides of the matrix.
</p>


<h3>Value</h3>

<p>The Moran's I numeric value as a numeric number.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generic_sews">generic_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Spatial correlation of white noise is close to zero
rmat &lt;- matrix(runif(1000) &gt; .5, ncol = 100)
raw_moran(rmat) 

# Spatial correlation of a half-ones / half-zeros matrix is close to one. 
# This would produce close but inaccurate results in version &lt;3.0.2
m &lt;- cbind(matrix(1, nrow = 100, ncol = 50), 
           matrix(0, nrow = 100, ncol = 50))

raw_moran(m)

</code></pre>

<hr>
<h2 id='raw_plrange'>Power-law range indicator</h2><span id='topic+raw_plrange'></span>

<h3>Description</h3>

<p>Compute the power-law range of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_plrange(mat, xmin_bounds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_plrange_+3A_mat">mat</code></td>
<td>
<p>A logical matrix, or a list of logical matrices</p>
</td></tr>
<tr><td><code id="raw_plrange_+3A_xmin_bounds">xmin_bounds</code></td>
<td>
<p>A vector of two integer values, defining a range in which 
to search for the best xmin (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some ecosystems show typical changes in their patch-size 
distribution as they become more and more degraded. In particular, an 
increase in the truncation of the patch-size distribution (PSD) is expected 
to occur. The power-law range (PLR) measures the truncation of the PSD 
in a single value (see also <code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code> for more details). 
</p>
<p>To compute the PLR, power-laws are fitted with a variable 
minimum patch size (xmin) and the one with the lowest Kolmogorov-Smirnov
distance to the empirical distribution is retained. PLR is then computed 
using this best-fitting xmin: 
</p>
<p style="text-align: center;"><code class="reqn">\frac{log(x_{max}) - log(x_{min})}{log(x_{max}) - log(x_{smallest})}</code>
</p>

<p>where <code class="reqn">x_{max}</code> is the maximum observed patch size, and 
<code class="reqn">x_{smallest}</code> is the minimum observed patch size.
</p>


<h3>Value</h3>

<p>A named vector containing the power-law range value
</p>


<h3>References</h3>

<p>Clauset, A., Shalizi, C. R., &amp; Newman, M. E. (2009). 
Power-law distributions in empirical data. SIAM review, 51(4), 661-703.
</p>
<p>Berdugo, M., Kefi, S., Soliveres, S. &amp; Maestre, F.T. (2017). Plant spatial 
patterns identify alternative ecosystem multifunctionality states in 
global drylands. Nature in Ecology and Evolution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
forestgap.plr &lt;- raw_plrange(forestgap[[2]]) 

# Restrict to small xmins 
forestgap.plr2 &lt;- indicator_plrange(forestgap[[2]], xmin_bounds = c(1, 10)) 

</code></pre>

<hr>
<h2 id='raw_sdr'>Spectral Density Ratio (SDR) indicator</h2><span id='topic+raw_sdr'></span>

<h3>Description</h3>

<p>Compute the ratio of low frequencies over high frequencies
of the r-spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_sdr(mat, sdr_low_range = NULL, sdr_high_range = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_sdr_+3A_mat">mat</code></td>
<td>
<p>A matrix with continuous values, or a logical matrix 
(<code>TRUE</code>/<code>FALSE</code> values).</p>
</td></tr>
<tr><td><code id="raw_sdr_+3A_sdr_low_range">sdr_low_range</code></td>
<td>
<p>The range of values (in proportion) to 
use for the computation of the spectral density ratio.
For example, for the lowest 20% (default value), set <code>sdr_low_range</code>
to <code>c(0, .2)</code>.</p>
</td></tr>
<tr><td><code id="raw_sdr_+3A_sdr_high_range">sdr_high_range</code></td>
<td>
<p>The range of values (in proportion) to 
use for the computation of the spectral density ratio. For example, for 
the highest 20% (default value), set <code>sdr_high_range</code> to 
<code>c(.8, 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SDR measures the increase in long-range correlations before a critical point. 
It is the ratio of the average low frequency value over high frequency 
values. In this implementation, an increase in SDR implies a &quot;reddening&quot; 
of the <a href="#topic+rspectrum">r-spectrum</a>. See also <code><a href="#topic+spectral_sews">spectral_sews</a></code> for 
a more complete description. 
</p>
<p>Low and high frequencies are averaged in order to compute the SDR. The 
parameters <code>sdr_low_range</code> and <code>sdr_high_range</code> control which 
frequencies are selected for averaging. For example 
<code>sdr_low_range = c(0, .2)</code> (default) uses the lower 20
the average of low frequencies. <code>sdr_high_range = c(.8, 1)</code> uses the 
higher 20
</p>


<h3>Value</h3>

<p>The SDR values computed on the matrix as a named vector
</p>


<h3>References</h3>

<p>Carpenter, S.R. &amp; Brock, W.A. (2010). Early warnings of regime shifts in 
spatial dynamics using the discrete Fourier transform. Ecosphere
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indictest">indictest</a></code>, 
<code><a href="#topic+rspectrum">rspectrum</a></code>, <code><a href="#topic+plot_spectrum">plot_spectrum</a></code>, 
<code><a href="#topic+spectral_sews">spectral_sews</a></code>, <code><a href="#topic+extract_spectrum">extract_spectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
data(serengeti)
serengeti.sdr &lt;- raw_sdr(serengeti[[1]], 
                         sdr_low_range = c(0, 0.2), 
                         sdr_high_range = c(0.8, 1))
compute_indicator(serengeti, raw_sdr)


</code></pre>

<hr>
<h2 id='raw_structvar'>Structural variance</h2><span id='topic+raw_structvar'></span>

<h3>Description</h3>

<p>Compute the structural variance on a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_structvar(mat, model = "sph", nmax = 100000L, nbins = 32, cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_structvar_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="raw_structvar_+3A_model">model</code></td>
<td>
<p>The variogram model to use, either &quot;sph&quot; (for a spherical
model) or &quot;exp&quot; (for an exponential model)</p>
</td></tr>
<tr><td><code id="raw_structvar_+3A_nmax">nmax</code></td>
<td>
<p>The maximum number of pairs of cells to use when computing the 
variogram</p>
</td></tr>
<tr><td><code id="raw_structvar_+3A_nbins">nbins</code></td>
<td>
<p>Number of distance bins to use to compute the variogram</p>
</td></tr>
<tr><td><code id="raw_structvar_+3A_cutoff">cutoff</code></td>
<td>
<p>Maximum distance to consider in the variogram. If NULL, then 
a distance equal to one third of the diagonal of the matrix is used</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>raw_variogram_metrics, variogram_sews
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
raw_structvar(serengeti[[5]])

</code></pre>

<hr>
<h2 id='raw_variogram_metrics'>Variogram parameters</h2><span id='topic+raw_variogram_metrics'></span>

<h3>Description</h3>

<p>Compute the nugget, partial sill, correlation range and 
structural variance on a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_variogram_metrics(
  mat,
  model = "sph",
  nmax = 100000L,
  nbins = 32,
  cutoff = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_variogram_metrics_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="raw_variogram_metrics_+3A_model">model</code></td>
<td>
<p>The variogram model to use, either &quot;sph&quot; (for a spherical
model) or &quot;exp&quot; (for an exponential model)</p>
</td></tr>
<tr><td><code id="raw_variogram_metrics_+3A_nmax">nmax</code></td>
<td>
<p>The maximum number of pairs of cells to use when computing the 
variogram</p>
</td></tr>
<tr><td><code id="raw_variogram_metrics_+3A_nbins">nbins</code></td>
<td>
<p>Number of distance bins to use to compute the variogram</p>
</td></tr>
<tr><td><code id="raw_variogram_metrics_+3A_cutoff">cutoff</code></td>
<td>
<p>Maximum distance to consider in the variogram. If NULL, then 
a distance equal to one third of the diagonal of the matrix is used</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>variogram_sews, raw_structvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
raw_variogram_metrics(serengeti[[5]])

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+plan'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>future</dt><dd><p><code><a href="future.html#topic+plan">plan</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rspectrum'>r-spectrum</h2><span id='topic+rspectrum'></span>

<h3>Description</h3>

<p>Compute the r-spectrum of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspectrum(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rspectrum_+3A_mat">mat</code></td>
<td>
<p>A matrix with logical or numeric values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions returns a <code>data.frame</code> with <code>NA</code>s in the
<code>rspec</code> column if the input matrix has zero variance. Note that if the matrix 
is not square, then only the largest square matrix fitting in the upper left
corner is used.
</p>


<h3>Value</h3>

<p>A data.frame with two columns: <code>dist</code>, the wave number and 
<code>rspec</code>, the normalized value of the r-spectrum
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectral_sews">spectral_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Spectrum of white noise
rmat &lt;- matrix(runif(100*100) &gt; .5, ncol = 100)
spec &lt;- rspectrum(rmat) 
plot(spec, type = "l")

# Add some spatial correlation and compare the two spectra
rmat.cor &lt;- rmat
for (i in seq(1, nrow(rmat)-1)) { 
  for (j in seq(1, nrow(rmat)-1)) { 
    rmat.cor[i,j] &lt;- mean(rmat[(i-1):(i+1), (j-1):(j+1)])
  }
}
spec.cor &lt;- rspectrum(rmat.cor)
plot(spec.cor, type = "n")
lines(spec, col = "black")
lines(spec.cor, col = "blue")

</code></pre>

<hr>
<h2 id='serengeti'>Serengeti dataset</h2><span id='topic+serengeti'></span><span id='topic+serengeti.rain'></span>

<h3>Description</h3>

<p>Vegetation data along a rainfall gradient in Serengeti national 
park.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serengeti

serengeti.rain
</code></pre>


<h3>Format</h3>

<p>A list of logical matrices
</p>
<p>The annual rainfall corresponding to the matrices in the serengeti 
dataset, in the corresponding order.
</p>


<h3>Details</h3>

<p>The data-set consists of a rectangular area of size 7.5 km x 90 km. 
These data are represented as a list of matrices. Each matrix is a moving 
window of 7.5 km x 7.5 km which moves my 2.5 km along the length of the 
rectangular data-set. 
</p>
<p>Each entry in the matrix is vegetation data at a resolution of 30m as 
classified into binary units with FALSE (grass) and TRUE (forest).
The rainfall data provided here is the average rainfall (mm/yr) of a 
moving window of dimension 7.5km which moves my 2.5 km along the length 
of the rectangular data-set.
</p>


<h3>Source</h3>

<p>Extracted from Eby's et al (2017) supplementary material 
<a href="https://github.com/tee-lab/spacetime-csd/">https://github.com/tee-lab/spacetime-csd/</a>
</p>


<h3>References</h3>

<p>Eby, S., Agrawal, A., Majumder, S., Dobson, A.P. &amp; Guttal, V. (2017). 
Alternative stable states and spatial indicators of critical slowing down 
along a spatial gradient in a savanna ecosystem: Global Ecology 
and Biogeography, 26, 638-649
</p>
<p>Reed, D. N., Anderson, T. M., Dempewolf, J., Metzger, K., &amp; Serneels, S. (2009). 
The spatial distribution of vegetation types in the Serengeti ecosystem: 
the influence of rainfall and topographic relief on vegetation patch 
characteristics. Journal of Biogeography, 36(4), 770-782.
</p>

<hr>
<h2 id='simple_sews'><code>simple_sews</code> objects</h2><span id='topic+simple_sews'></span><span id='topic+simple_sews_object'></span>

<h3>Description</h3>

<p>This help page describes the structure of <code>simple_sews_*</code> 
objects, such as those defined by the classes <code>simple_sews_single</code>,
<code>simple_sews_list</code>
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+spatialwarnings">spatialwarnings</a></code> uses S3 objects (lists) internally to store 
indicator values, along with the necessary data to plot and display
results. It is not recommended to extract data directly from these objects,
as they are subject to change with different releases of the package. The 
preferred method is to use dedicated generic functions such as 
<code>plot()</code> or <code>as.data.frame()</code> to display or export the results.
Nonetheless, we document the structure of these objects here for reference. 
</p>
<p><code>simple_sews</code> objects are returned by all indicator functions that 
return numeric values. This includes for example <code><a href="#topic+generic_sews">generic_sews</a></code>, 
<code><a href="#topic+flowlength_sews">flowlength_sews</a></code>, <code><a href="#topic+compute_indicator">compute_indicator</a></code> but *not*
<code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code> or <code><a href="#topic+spectral_sews">spectral_sews</a></code>, which provide
indicators that depend on non-numeric values (e.g. patch-size distribution
type), or need to store more information than just a single numerical value
(e.g. the spectrum of the input matrix). 
</p>
<p><code>simple_sews</code> objects come in multiple variants:
<code>simple_sews_single</code> is the result of an indicator function applied to 
a single matrix, and <code>simple_sews_test_single</code> is the result of 
<code><a href="#topic+indictest">indictest</a></code> applied to a <code>simple_sews_single</code> object. Both 
these objects have list equivalents, <code>simple_sews_list</code> and 
<code>simple_sews_test_list</code> which are simply a collection of their 
'single' equivalent. These 'list' objects are used to store the results 
of computations when working with multiple matrices. 
</p>
<p>A <code>simple_sews_single</code> object is a list with the following components
</p>

<dl>
<dt><code>itemvalue</code></dt><dd><p>the indicator values. A vector of length one if there is 
only one numeric value returned by the indicator function (e.g.
<code><a href="#topic+flowlength_sews">flowlength_sews</a></code>, or with a length above one otherwise</p>
</dd>
<dt><code>orig_data</code></dt><dd><p>the original matrix on which the indicator was computed</p>
</dd>
<dt><code>fun.args</code></dt><dd><p>the argument used in the call to the indicator function 
(the function that given a matrix, returns the spatial metrics of
interest)</p>
</dd>
<dt><code>taskname</code></dt><dd><p>a character string describing the current indicator(s) 
being computed</p>
</dd>
<dt><code>indicf</code></dt><dd><p>the indicator function, which given the matrix, returns the
spatial metric(s) of interest</p>
</dd>
</dl>

<p><code>simple_sews_test_single</code> have all of the above components, plus 
the following: 
</p>
 
<dl>
<dt><code>nulldistr</code></dt><dd><p>the null distribution of values, with nulln rows and 
as many columns as the number of values returned by the indicator 
function</p>
</dd>
<dt><code>null_mean</code></dt><dd><p>the mean indicator values in the null distribution</p>
</dd>
<dt><code>null_sd</code></dt><dd><p>the standard deviation of the null distribution</p>
</dd>
<dt><code>null_qsup</code></dt><dd><p>the upper quantile of the null distribution, by default 
the 95
adjust this</p>
</dd>
<dt><code>null_qinf</code></dt><dd><p>the upper quantile of the null distribution, by default 
the 05
adjust this</p>
</dd>
<dt><code>z_score</code></dt><dd><p>the z_score of the observed value relative to the null 
distribution, i.e. (value - null_mean) / null_sd</p>
</dd>
<dt><code>pval</code></dt><dd><p>the p-value of the indicator, i.e. the proporation of values 
of the null distribution that fall below the observed indicator value</p>
</dd>
<dt><code>null_method</code></dt><dd><p>the method used to produce the null matrices. See 
<code><a href="#topic+indictest">indictest</a></code> for details</p>
</dd>
<dt><code>nulln</code></dt><dd><p>the number of null matrices used</p>
</dd>
<dt><code>get_nullmat</code></dt><dd><p>a function that can be called to obtain a randomized 
matrix</p>
</dd>
<dt><code>matrixn</code></dt><dd><p>the number of the matrix, can be above one if the
computations have been run on a list of matrices, or non-existent if 
only one matrix was used</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+custom_indicator">custom_indicator</a></code>
</p>

<hr>
<h2 id='spectral_sews'>Spectrum-based spatial early-warning signals.</h2><span id='topic+spectral_sews'></span>

<h3>Description</h3>

<p>Computation of spatial early warning signals based on spectral
properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_sews(mat, sdr_low_range = NULL, sdr_high_range = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectral_sews_+3A_mat">mat</code></td>
<td>
<p>The input matrix or a list of matrices.</p>
</td></tr>
<tr><td><code id="spectral_sews_+3A_sdr_low_range">sdr_low_range</code></td>
<td>
<p>The range of values (in proportion) to 
use for the computation of the spectral density ratio.
For example, for the lowest 20% (default value), set <code>sdr_low_range</code> to 
<code>c(0, .2)</code>. See also the Details section.</p>
</td></tr>
<tr><td><code id="spectral_sews_+3A_sdr_high_range">sdr_high_range</code></td>
<td>
<p>The range of values (in proportion) to 
use for the computation of the spectral density ratio. For example, for 
the higher 20% (default value), set <code>sdr_high_range</code> to 
<code>c(.8, 1)</code>. See also the Details section.</p>
</td></tr>
<tr><td><code id="spectral_sews_+3A_quiet">quiet</code></td>
<td>
<p>Do not display some warnings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spectral early warning signals are based on the fact that some 
dynamical systems can exhibit an change in specific characteristics of their 
spatial structure when approaching a transition. In particular, long-range 
correlations are expected to have an increased importance. This is expected 
to be reflected in the spectrum of the spatial structure as an increase of the
relative importance of lower frequencies over higher frequencies (&quot;reddening&quot; 
of the spatial spectrum).
</p>
<p>This task allows computing the radial-spectrum which gives the relative 
importance of each space scale as a function of distance, from 1 to 
<code>N/2</code> (<code>N</code> being the minimum between the number of rows and columns). 
If the matrix is not square, then it is cropped to biggest square that 
fits within the left side of the matrix. 
</p>
<p>Additionally, it summarizes this spectrum into a Spectral 
Density Ratio (SDR), which is the ratio of low frequencies over 
high frequencies of the r-spectrum. The SDR value is expected to increase
before a transition point.
</p>
<p>The significance of spectral early-warning signals can be estimated by 
reshuffling the original matrix (function <code>indictest</code>). Indicators 
are then recomputed on the shuffled matrices and the values obtained are 
used as a null distribution. P-values are obtained based on the rank of 
the observed value in the null distribution. 
</p>
<p>The trend of SDR values can be plotted using the <code>plot()</code> method. 
Alternatively, the spectrum itself can be plotted (with facets 
if multiple input matrices were used) using the <code>plot_spectrum</code> 
method.
</p>


<h3>Value</h3>

<p>Function <code>spectral_sews</code> object of class <code>spectral_sews_list</code> or 
<code>spectral_sews_single</code> depending on whether the input was a list of 
matrices or a single matrix. 
</p>
<p>Function <code>indictest</code> 
</p>
<p>The <code>plot</code> methods returns a ggplot object (usually displayed 
immediately when called interactively).
</p>


<h3>References</h3>

<p>Kefi, S., Guttal, V., Brock, W.A., Carpenter, S.R., Ellison, A.M., 
Livina, V.N., et al. (2014). Early Warning Signals of Ecological 
Transitions: Methods for Spatial Patterns. PLoS ONE, 9, e92097.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rspectrum">rspectrum</a></code>, <code><a href="#topic+plot_spectrum">plot_spectrum</a></code>, 
<code><a href="#topic+raw_sdr">raw_sdr</a></code>, <code><a href="#topic+extract_spectrum">extract_spectrum</a></code>
</p>
<p><code><a href="#topic+indictest">indictest</a></code>, to test the significance of indicator values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(serengeti) 
data(serengeti.rain) 


spec_indic &lt;- spectral_sews(serengeti, 
                            sdr_low_range  = c(0, .2), 
                            sdr_high_range = c(.8, 1))

summary(spec_indic)

# Display trends along the varying model parameter
plot(spec_indic, along = serengeti.rain)

# Computing spectra many times is expensive, consider setting parallel 
# computing using: options(mc.cores = n)

# Assess significance
spec_test &lt;- indictest(spec_indic, nulln = 199)
summary(spec_test)

# Display the SDR trend, now with a grey ribbon representing 5%-95% 
# quantiles of the null distribution
plot(spec_test, along = serengeti.rain)

# Add a line highlighting the shift 
if (require(ggplot2)) {
  plot(spec_test, along = serengeti.rain) + 
    geom_vline(xintercept = 590, color = "red", linetype = "dashed")
}


# Display radial-spectra
plot_spectrum(spec_indic, along = serengeti.rain)

# Graphics can be modified using ggplot2 functions
if (require(ggplot2)) { 
  plot_spectrum(spec_indic, along = serengeti.rain) + 
    scale_y_log10()
}


</code></pre>

<hr>
<h2 id='variogram_sews'>Early-Warning signals based on variograms (EXPERIMENTAL)</h2><span id='topic+variogram_sews'></span>

<h3>Description</h3>

<p>Compute Early-warning signals based on metrics derived 
form semi-variograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogram_sews(mat, model = "sph", nmax = 1e+05, nbins = 32, cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variogram_sews_+3A_mat">mat</code></td>
<td>
<p>A matrix (TRUE/FALSE values) or a list of matrices</p>
</td></tr>
<tr><td><code id="variogram_sews_+3A_model">model</code></td>
<td>
<p>The variogram model to use, either &quot;sph&quot; (for a spherical
model) or &quot;exp&quot; (for an exponential model)</p>
</td></tr>
<tr><td><code id="variogram_sews_+3A_nmax">nmax</code></td>
<td>
<p>The maximum number of pairs of cells to use when computing the 
variogram</p>
</td></tr>
<tr><td><code id="variogram_sews_+3A_nbins">nbins</code></td>
<td>
<p>Number of distance bins to use to compute the variogram</p>
</td></tr>
<tr><td><code id="variogram_sews_+3A_cutoff">cutoff</code></td>
<td>
<p>Maximum distance to consider in the variogram. If NULL, then 
a distance equal to one third of the diagonal of the matrix is used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>During ecosystem degradation and especially before a regime shift occurs in 
some ecosystems, spatial autocorrelation is expected to increase in a
landscape. This increase can be measured based on variograms, which
represent how the difference (variance) between two points in a landscape
varies as a function of distance. 
</p>
<p>The approach used to derive variogram-based EWS is to compute the 
empirical variogram of a landscape (represented passed as a matrix of 
values), then fit a variogram model to it. Three 
parameters are then extracted from the variogram model (see Nijp et al.
2019 for a visual description of these parameters): 
</p>
 
<ol>
<li><p> The <em>nugget</em> (intercept)
</p>
</li>
<li><p> The <em>partial sill</em>, i.e. the reduction in semivariance at 
distance zero
</p>
</li>
<li><p> The <em>correlation range</em>, i.e. the distance at which the 
relationship between semivariance and distance flattens
</p>
</li></ol>

<p>Additionally, the <em>structural variance</em> is computed as 
(partial sill)/(nugget + partial sill), wich quantifies whether the 
data are spatially structured (structural variance of one), or completely 
unstructured (value of zero). Theoretical work suggests that partial sill,
correlation range and structural variance should increase before a regime
shift occurs in an ecosystem (Nijp et al. 2019). 
</p>
<p>This function offers to fit a spherical model or 
an exponential model. The best-fitting model depends on your data, you 
should try different options and review the fits using
<code><a href="#topic+plot_variogram">plot_variogram</a></code>.
</p>
<p>Please note that this part of the package is still experimental and deserves 
more testing.
</p>


<h3>Value</h3>

<p>A list object of class &quot;variogram_sews&quot;, that can be displayed 
using <code>summary()</code>, <code>plot()</code>, etc. Significance of values can 
be tested using <code><a href="#topic+indictest">indictest</a></code>.
</p>


<h3>References</h3>

<p>Nijp, Jelmer J., Arnaud J.A.M. Temme, George A.K. Voorn, Lammert Kooistra,
Geerten M. Hengeveld, Merel B. Soons, Adriaan J. Teuling, and Jakob
Wallinga. (2019) Spatial Early Warning Signals for Impending Regime Shifts:
A Practical Framework for Application in Real-world Landscapes. Global
Change Biology 25 (6): 1905-21. <a href="https://doi.org/10.1111/gcb.14591">doi:10.1111/gcb.14591</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raw_structvar">raw_structvar</a></code>,
<code><a href="#topic+plot_variogram">plot_variogram</a></code>, <code><a href="#topic+extract_variogram">extract_variogram</a></code>,
<code><a href="#topic+predict.variogram_sews_list">predict</a></code>
</p>
<p><code><a href="#topic+indictest">indictest</a></code>, to test the significance of indicator values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

serengeti_ews &lt;- variogram_sews(serengeti, 
                                model ="exp")
plot(serengeti_ews, along = serengeti.rain)
summary(serengeti_ews)

plot_variogram(serengeti_ews)

# nulln should be set to a higher values for meaningful results
serengeti_test &lt;- indictest(serengeti_ews, nulln = 9)
plot(serengeti_test) # gray ribbons indicate the null indicator values 
summary(serengeti_test)


</code></pre>

<hr>
<h2 id='variogram_sews_plot'>Early-warning signals based on variograms</h2><span id='topic+variogram_sews_plot'></span><span id='topic+plot.variogram_sews'></span><span id='topic+plot_variogram'></span><span id='topic+plot_variogram.variogram_sews'></span><span id='topic+plot.variogram_sews_test'></span><span id='topic+plot_variogram.variogram_sews_test'></span>

<h3>Description</h3>

<p>Plot trends of indicators based on variograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variogram_sews'
plot(x, along = NULL, ...)

plot_variogram(x, along = NULL, ...)

## S3 method for class 'variogram_sews'
plot_variogram(x, along = NULL, ...)

## S3 method for class 'variogram_sews_test'
plot(x, along = NULL, what = "value", display_null = TRUE, ...)

## S3 method for class 'variogram_sews_test'
plot_variogram(x, along = NULL, what = "value", display_null = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variogram_sews_plot_+3A_x">x</code></td>
<td>
<p>An object produced by <code><a href="#topic+variogram_sews">variogram_sews</a></code>, or the 
result of applying <code>indictest</code> on such object.</p>
</td></tr>
<tr><td><code id="variogram_sews_plot_+3A_along">along</code></td>
<td>
<p>A vector providing values along which the indicator trends 
will be plotted. If <code>NULL</code> then the indicator values are plotted
sequentially in their original order.</p>
</td></tr>
<tr><td><code id="variogram_sews_plot_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
<tr><td><code id="variogram_sews_plot_+3A_what">what</code></td>
<td>
<p>The trendline to be displayed. Defaults to the indicator's 
values (&quot;value&quot;) but other metrics can be displayed. Accepted values are 
&quot;value&quot;, &quot;pval&quot;, &quot;difference&quot; (obs - null mean), or &quot;z_score&quot; 
( (obs - null mean) / (null sd) ).</p>
</td></tr>
<tr><td><code id="variogram_sews_plot_+3A_display_null">display_null</code></td>
<td>
<p>Chooses whether a grey ribbon should be added to reflect
the null distribution. Note that it can not be displayed when the trend 
line reflects something else than the indicator values (when <code>what</code> 
is not set to &quot;value&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot()</code> function will display how the estimated 
variogram parameters change along a set of values (passed with argument
<code>along</code>). If the object passed has been processed through 
<code>indictest</code>, then the null values are also displayed. 
<code>plot_variogram()</code> can be used to display the individual variograms
that have been fit to the data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variogram_sews">variogram_sews</a></code>, <code><a href="#topic+indictest">indictest</a></code>, 
<code><a href="#topic+plot_variogram">plot_variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
 
serengeti_ews &lt;- variogram_sews(serengeti, model ="exp")

# Display the change in variogram parameters 
plot(serengeti_ews, along = serengeti.rain) + 
  ggplot2::labs(x = "Rainfall (mm)")

# Visualize the fitted variograms
plot_variogram(serengeti_ews, along = serengeti.rain) 

  # Test the trends (nulln should be set to a higher value to obtain 
  # meaningful results
  serengeti_test &lt;- indictest(serengeti_ews, nulln = 19)
  plot(serengeti_test, along = serengeti.rain)
  plot_variogram(serengeti_test, along = serengeti.rain)


</code></pre>

<hr>
<h2 id='variogram_sews_predict'>predict() method for variogram_sews objects</h2><span id='topic+variogram_sews_predict'></span><span id='topic+predict.variogram_sews_list'></span>

<h3>Description</h3>

<p>Export the fitted variogram(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variogram_sews_list'
predict(object, newdist = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variogram_sews_predict_+3A_object">object</code></td>
<td>
<p>An object produced by variogram_sews</p>
</td></tr>
<tr><td><code id="variogram_sews_predict_+3A_newdist">newdist</code></td>
<td>
<p>A vector of distances at which to return the variogram fit 
values (defaults to 128 regularly-spaced values).</p>
</td></tr>
<tr><td><code id="variogram_sews_predict_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the distances (column <code>dist</code>), the fitted 
values (<code>gamma</code>), and if object contains more than one matrix, 
a column <code>matrixn</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variogram_sews">variogram_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
vario_indics &lt;- variogram_sews(serengeti)
predict(vario_indics)
vario_test &lt;- indictest(vario_indics, nulln = 19)
predict(vario_test) # same result


</code></pre>

<hr>
<h2 id='xmin_estim'>Estimate the minimum patch size of a power-law distribution</h2><span id='topic+xmin_estim'></span>

<h3>Description</h3>

<p>When fitting a power-law to a discrete distribution, it might 
be worth discarding points below a certain threshold (xmin) to improve 
the fit. This function estimates the optimal xmin based on the 
Kolmogorov-Smirnoff distance between the fit and the empirical 
distribution, as suggested by Clauset et al. (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmin_estim(dat, bounds = range(dat))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xmin_estim_+3A_dat">dat</code></td>
<td>
<p>A vector of integer values</p>
</td></tr>
<tr><td><code id="xmin_estim_+3A_bounds">bounds</code></td>
<td>
<p>A vector of two values representing the bounds in which 
the best xmin is searched</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns NA if <code>dat</code> has only three unique values 
or if the power-law fit failed.
</p>


<h3>Value</h3>

<p>The estimated xmin as an integer value
</p>


<h3>References</h3>

<p>Clauset, A., Shalizi, C. R., &amp; Newman, M. E. (2009). 
Power-law distributions in empirical data. SIAM review, 51(4), 661-703.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+patchdistr_sews">patchdistr_sews</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
psd &lt;- patchsizes(forestgap[[5]])
xmin_estim(psd)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
