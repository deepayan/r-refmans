<!DOCTYPE html><html><head><title>Help for package maximin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {maximin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lola_kn'><p>spatial locations of 1535 weather stations</p></a></li>
<li><a href='#maximin'>
<p>Space-filling design under the criterion of maximin distance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Space-Filling Design under Maximin Distance</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Furong Sun &lt;furong.sun@gmail.com&gt;, Robert B. Gramacy &lt;rbg@vt.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>plgp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lhs</td>
</tr>
<tr>
<td>Description:</td>
<td>Constructs a space-filling design under the criterion of maximum-minimum distance. Both discrete and continuous searches are provided.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Furong Sun &lt;furong.sun@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-13 21:15:37 UTC; furongsun</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-14 00:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='lola_kn'>spatial locations of 1535 weather stations</h2><span id='topic+lola_kn'></span>

<h3>Description</h3>

<p>The dataset contains spatial locations of 1535 weather stations 
for measuring solar irradiance across the continental United States.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lola_kn)</code></pre>


<h3>Format</h3>

<p>A data frame containing 1535 observations and 2 variables</p>


<h3>Source</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/sam.11414">https://onlinelibrary.wiley.com/doi/abs/10.1002/sam.11414</a></p>


<h3>References</h3>

<p>F. Sun, R.B. Gramacy, B. Haaland, S.Y. Lu, and Y. Hwang (2019)
<em>Synthesizing Simulation and Field Data of Solar Irradiance</em>, Statistical Analysis and Data Mining, 12(4), 311-324;
preprint on arXiv:1806.05131.
</p>

<hr>
<h2 id='maximin'>
Space-filling design under the criterion of maximin distance
</h2><span id='topic+maximin'></span><span id='topic+maximin.cand'></span>

<h3>Description</h3>

<p>Generates a space-filling design under the criterion of maximum-minimum distance;
both discrete and continuous searches are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  maximin.cand(n, Xcand, Tmax, Xorig=NULL, init=NULL, verb=FALSE, tempfile=NULL) 
  maximin(n, p, T, Xorig=NULL, Xinit=NULL, verb=FALSE, plot=FALSE, boundary=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximin_+3A_n">n</code></td>
<td>
<p> the number of space-filling locations </p>
</td></tr>
<tr><td><code id="maximin_+3A_xcand">Xcand</code></td>
<td>
<p> the candidate set, from which each space-filling location is selected </p>
</td></tr>
<tr><td><code id="maximin_+3A_tmax">Tmax</code></td>
<td>
<p> the number of iterations; <code>Tmax &lt;= nrow(Xcand)</code>; to be safe, set <code>Tmax = nrow(Xcand)</code>. </p>
</td></tr>
<tr><td><code id="maximin_+3A_xorig">Xorig</code></td>
<td>
<p> the existing design; <code>ncol(Xorig) = ncol(Xcand)</code> </p>
</td></tr>
<tr><td><code id="maximin_+3A_init">init</code></td>
<td>
<p> the initial indices of <code>X</code>; it can be randomly selected from <code>Xcand</code> or introduced from a previous experiment. </p>
</td></tr>
<tr><td><code id="maximin_+3A_verb">verb</code></td>
<td>
<p> progress indicator &mdash; every tenth iteration is printed out; by default <code>verb = FALSE</code>. </p>
</td></tr>
<tr><td><code id="maximin_+3A_tempfile">tempfile</code></td>
<td>
<p> the name of a temporary file given the progress is saved with each iteration; by default <code>tempfile = NULL</code></p>
</td></tr>
<tr><td><code id="maximin_+3A_p">p</code></td>
<td>
<p> the dimensionality of input space </p>
</td></tr>
<tr><td><code id="maximin_+3A_t">T</code></td>
<td>
<p> the number of iterations; <code class="reqn">T &gt; n</code>; setting <code class="reqn">T = 10 * n</code> is a good starting point. </p>
</td></tr>
<tr><td><code id="maximin_+3A_xinit">Xinit</code></td>
<td>
<p> the (initial) design introduced from a previous experiment </p>
</td></tr>
<tr><td><code id="maximin_+3A_plot">plot</code></td>
<td>
<p> if <code>plot = TRUE</code>, then the search space and the &quot;start location &ndash;&gt; new location&quot; with each iteration is plotted; 
if <code class="reqn">p &gt; 2</code>, then TWO input coordinates are RANDOMLY chosen for plotting; it is worth noticing that the search space 
only VISUALLY makes sense when <code class="reqn">p = 2</code>. </p>
</td></tr>
<tr><td><code id="maximin_+3A_boundary">boundary</code></td>
<td>
<p> if <code>boundary = TRUE</code>, then for each iteration, the &quot;to-be-swapped-in&quot; location will be away from the 
boundary in addition to being away from other <code>X</code> locations and <code>Xorig</code>; how far is it? <code class="reqn">min(d, 4*d.bound)</code>, 
where <code>d</code> is the Euclidean distance between the &quot;to-be-swapped-in&quot; location and other <code>X</code> locations as well as <code>Xorig</code>, while 
<code>d.bound</code> is the minimum Euclidean distance between the &quot;to-be-swapped-in&quot; location and the boundaries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructing a space-filling design under the criterion of maximum-minimum distance is quite 
useful in computer experiments and related fields. Previously, researchers would construct 
such a design in a random accept-reject way, i.e., randomly propose a location within the 
study region to replace a randomly selected row from the initial design. If such a proposal 
increases the minimum pairwise Euclidean distance, then accept the replacement; otherwise 
keep the original design location. By repeatedly proposing (and accept-rejecting) in this 
way one is able to construct an (approximately) space-filling design.  However the algorithm 
is inefficient computationally.  The reason is that the proposals are not optimized in any way.
</p>
<p>In this package, we provide an alternative to build up a well-defined space-filling design 
more efficiently. There are two versions, one is with discrete search, while the other is 
with continuous search. For the former, each iteration proposes to swap out a row from the 
initial design with the minimum distance, and swap in one location from a candidate set to 
increase the minimum distance. For the latter, the core idea is the same, but instead of working 
with a candidate set, <code><a href="stats.html#topic+optim">optim</a></code> is used to maximize the distance between the &quot;to-be-swapped-in&quot; 
location and other design locations as well as to any existing design, <code>Xorig</code>. Several 
heuristics are deployed for situations where the search becomes stuck in a local mode.  One 
involves moving to a location with non-minimum distance, and the other is to jump to a location 
which has the maximum minimum distance. 
</p>
<p>For a visualization of applying <code>maximin.cand</code> in a real-life problem on solar irradiance, see Sun et al. (2019).
</p>
<p><code>maximin.cand</code> returns the indices of <code>Xcand</code>, which makes the final space-filling design,
and the minimum pairwise Euclidean distance with each iteration
</p>
<p><code>maximin</code> returns the combined existing design and the space-filling design, 
together with the minimum pairwise Euclidean distance with each iteration
</p>


<h3>Value</h3>

<p><code>maximin.cand</code> returns
</p>
<table>
<tr><td><code>inds</code></td>
<td>
<p> the indices of <code>Xcand</code>, which makes the final space-filling design </p>
</td></tr>
<tr><td><code>mis</code></td>
<td>
<p> the minimum distance with each iteration; <code>length(mis) = Tmax + 1</code> </p>
</td></tr>
</table>
<p><code>maximin</code> returns
</p>
<table>
<tr><td><code>Xf</code></td>
<td>
 <p><code>dim(Xf) = (nrow(Xorig) + n) * p</code> </p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p> the minimum distance with each iteration; <code>length(mi) = T + 1</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Furong Sun <a href="mailto:furong.sun@gmail.com">furong.sun@gmail.com</a> and Robert B. Gramacy <a href="mailto:rbg@vt.edu">rbg@vt.edu</a> 
</p>


<h3>References</h3>

<p>F. Sun, R.B. Gramacy, B. Haaland, S.Y. Lu, and Y. Hwang (2019)
<em>Synthesizing Simulation and Field Data of Solar Irradiance</em>, Statistical Analysis and Data Mining, 12(4), 311-324;
preprint on arXiv:1806.05131.
</p>
<p>M.H.Y. Tan (2013)
<em>Minimax Designs for Finite Design Regions</em>, Technometrics, 55(3), 346-358. 
</p>
<p>M.E. Johnson, L.M. Moore, and D. Yivisaker (1990)
<em>Minimax and Maximin Distance Designs</em>, Journal of Statistical Planning and Inference, 26(2), 131-148. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
 ## Not run: 
   ## maximin.cand
   # generate the design
   library("lhs")
   n &lt;- 100
   p &lt;- 2
   Xorig &lt;- randomLHS(10, p)
   x1 &lt;- seq(0, 1, length.out=n)
   Xcand &lt;- expand.grid(replicate(p, x1, simplify=FALSE))
   names(Xcand) &lt;- paste0("x", 1:2)
   T &lt;- nrow(Xcand)
   Xsparse &lt;- maximin.cand(n=n, Xcand=Xcand, Tmax=T, Xorig=Xorig, 
                           init=NULL, verb=FALSE, tempfile=NULL)
   
   maxmd &lt;- as.numeric(format(round(max(na.omit(Xsparse$mis)), 5), nsmall=5))
   
   # visualization
   par(mfrow=c(1, 2))
   X &lt;- Xcand[Xsparse$inds,]
   plot(X$x1, X$x2, xlab=expression(x[1]), ylab=expression(x[2]), 
        xlim=c(0, 1), ylim=c(0, 1), 
        main=paste0("n=", n, "_p=", p, "_maximin=", maxmd))
   points(Xorig, col=2, pch=20)
   abline(h=c(0, 1), v=c(0, 1), lty=2, col=2)
   if(!is.null(Xorig))
   {
     legend("topright", "Xorig", xpd=TRUE, horiz=TRUE, 
            inset=c(-0.03, -0.05), pch=20, col=2, bty="n")
   }
   plot(log(na.omit(Xsparse$mis)), type="b", 
        xlab="iteration", ylab="log(minimum distance)", 
        main="progress on minimum distance")
   abline(v=n, lty=2)
   mtext(paste0("design size=", n), at=n, cex=0.6)
   
  
## End(Not run)
  
  ## maximin
  # generate the design
  library("lhs")
  n &lt;- 10
  p &lt;- 2
  T &lt;- 10*n
  Xorig &lt;- randomLHS(10, p)
  Xsparse &lt;- maximin(n=n, p=p, T=T, Xorig=Xorig, Xinit=NULL, 
                     verb=FALSE, plot=FALSE, boundary=FALSE)
  maxmd &lt;- as.numeric(format(round(Xsparse$mi[T+1], 5), nsmall=5))
  
  # visualization
  par(mfrow=c(1,2))
  plot(Xsparse$Xf[,1], Xsparse$Xf[,2], xlab=expression(x[1]), ylab=expression(x[2]), 
       xlim=c(0, 1), ylim=c(0, 1), 
       main=paste0("n=", n, " p=", p, " T=", T, " maximin=", maxmd))
  points(Xorig, col=2, pch=20)
  abline(h=c(0,1), v=c(0,1), lty=2, col=2)
  if(!is.null(Xorig)) legend("topright", "Xorig", xpd=TRUE, horiz=TRUE, 
     inset=c(-0.03, -0.05), pch=20, col=2, bty="n")
  plot(log(Xsparse$mi), type="b", xlab="iteration", ylab="log(minimum distance)", 
       main="progress on minimum distance")
  abline(v=n, lty=2)
  mtext(paste0("design size=", n), at=n, cex=0.6)
  abline(v=T, lty=2)
  mtext(paste0("max.md=", maxmd), at=T, cex=0.6)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
