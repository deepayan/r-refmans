<!DOCTYPE html><html><head><title>Help for package insight</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {insight}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#insight-package'><p>insight: A Unified Interface to Access Information from Model Objects in R.</p></a></li>
<li><a href='#.colour_detect'><p>Detect coloured cells</p></a></li>
<li><a href='#all_models_equal'><p>Checks if all objects are models of same class</p></a></li>
<li><a href='#apply_table_theme'><p>Data frame and Tables Pretty Formatting</p></a></li>
<li><a href='#check_if_installed'><p>Checking if needed package is installed</p></a></li>
<li><a href='#clean_names'><p>Get clean names of model terms</p></a></li>
<li><a href='#clean_parameters'><p>Get clean names of model parameters</p></a></li>
<li><a href='#color_if'><p>Color-formatting for data columns based on condition</p></a></li>
<li><a href='#compact_character'><p>Remove empty strings from character</p></a></li>
<li><a href='#compact_list'><p>Remove empty elements from lists</p></a></li>
<li><a href='#display'><p>Generic export of data frames into formatted tables</p></a></li>
<li><a href='#download_model'><p>Download circus models</p></a></li>
<li><a href='#ellipsis_info'><p>Gather information about objects in ellipsis (dot dot dot)</p></a></li>
<li><a href='#find_algorithm'><p>Find sampling algorithm and optimizers</p></a></li>
<li><a href='#find_formula'><p>Find model formula</p></a></li>
<li><a href='#find_interactions'><p>Find interaction terms from models</p></a></li>
<li><a href='#find_offset'><p>Find possible offset terms in a model</p></a></li>
<li><a href='#find_parameters'><p>Find names of model parameters</p></a></li>
<li><a href='#find_parameters.averaging'><p>Find model parameters from models with special components</p></a></li>
<li><a href='#find_parameters.betamfx'><p>Find names of model parameters from marginal effects models</p></a></li>
<li><a href='#find_parameters.BGGM'><p>Find names of model parameters from Bayesian models</p></a></li>
<li><a href='#find_parameters.emmGrid'><p>Find model parameters from estimated marginal means objects</p></a></li>
<li><a href='#find_parameters.gamlss'><p>Find names of model parameters from generalized additive models</p></a></li>
<li><a href='#find_parameters.glmmTMB'><p>Find names of model parameters from mixed models</p></a></li>
<li><a href='#find_parameters.zeroinfl'><p>Find names of model parameters from zero-inflated models</p></a></li>
<li><a href='#find_predictors'><p>Find names of model predictors</p></a></li>
<li><a href='#find_random'><p>Find names of random effects</p></a></li>
<li><a href='#find_random_slopes'><p>Find names of random slopes</p></a></li>
<li><a href='#find_response'><p>Find name of the response variable</p></a></li>
<li><a href='#find_smooth'><p>Find smooth terms from a model object</p></a></li>
<li><a href='#find_statistic'><p>Find statistic for model</p></a></li>
<li><a href='#find_terms'><p>Find all model terms</p></a></li>
<li><a href='#find_transformation'><p>Find possible transformation of response variables</p></a></li>
<li><a href='#find_variables'><p>Find names of all variables</p></a></li>
<li><a href='#find_weights'><p>Find names of model weights</p></a></li>
<li><a href='#fish'><p>Sample data set</p></a></li>
<li><a href='#format_bf'><p>Bayes Factor formatting</p></a></li>
<li><a href='#format_capitalize'><p>Capitalizes the first letter in a string</p></a></li>
<li><a href='#format_ci'><p>Confidence/Credible Interval (CI) Formatting</p></a></li>
<li><a href='#format_message'><p>Format messages and warnings</p></a></li>
<li><a href='#format_number'><p>Convert number to words</p></a></li>
<li><a href='#format_p'><p>p-values formatting</p></a></li>
<li><a href='#format_pd'><p>Probability of direction (pd) formatting</p></a></li>
<li><a href='#format_rope'><p>Percentage in ROPE formatting</p></a></li>
<li><a href='#format_string'><p>String Values Formatting</p></a></li>
<li><a href='#format_table'><p>Parameter table formatting</p></a></li>
<li><a href='#format_value'><p>Numeric Values Formatting</p></a></li>
<li><a href='#get_auxiliary'><p>Get auxiliary parameters from models</p></a></li>
<li><a href='#get_call'><p>Get the model's function call</p></a></li>
<li><a href='#get_data'><p>Get the data that was used to fit the model</p></a></li>
<li><a href='#get_datagrid'><p>Create a reference grid</p></a></li>
<li><a href='#get_deviance'><p>Model Deviance</p></a></li>
<li><a href='#get_df'><p>Extract degrees of freedom</p></a></li>
<li><a href='#get_family'><p>A robust alternative to stats::family</p></a></li>
<li><a href='#get_intercept'><p>Get the value at the intercept</p></a></li>
<li><a href='#get_loglikelihood'><p>Log-Likelihood</p></a></li>
<li><a href='#get_modelmatrix'><p>Model Matrix</p></a></li>
<li><a href='#get_parameters'><p>Get model parameters</p></a></li>
<li><a href='#get_parameters.betamfx'><p>Get model parameters from marginal effects models</p></a></li>
<li><a href='#get_parameters.betareg'><p>Get model parameters from models with special components</p></a></li>
<li><a href='#get_parameters.BGGM'><p>Get model parameters from Bayesian models</p></a></li>
<li><a href='#get_parameters.emmGrid'><p>Get model parameters from estimated marginal means objects</p></a></li>
<li><a href='#get_parameters.gamm'><p>Get model parameters from generalized additive models</p></a></li>
<li><a href='#get_parameters.glmm'><p>Get model parameters from mixed models</p></a></li>
<li><a href='#get_parameters.htest'><p>Get model parameters from htest-objects</p></a></li>
<li><a href='#get_parameters.zeroinfl'><p>Get model parameters from zero-inflated and hurdle models</p></a></li>
<li><a href='#get_predicted'><p>Model predictions (robust) and their confidence intervals</p></a></li>
<li><a href='#get_predicted_ci'><p>Confidence intervals around predicted values</p></a></li>
<li><a href='#get_predictors'><p>Get the data from model predictors</p></a></li>
<li><a href='#get_priors'><p>Get summary of priors used for a model</p></a></li>
<li><a href='#get_random'><p>Get the data from random effects</p></a></li>
<li><a href='#get_residuals'><p>Extract model residuals</p></a></li>
<li><a href='#get_response'><p>Get the values from the response variable</p></a></li>
<li><a href='#get_sigma'><p>Get residual standard deviation from models</p></a></li>
<li><a href='#get_statistic'><p>Get statistic associated with estimates</p></a></li>
<li><a href='#get_transformation'><p>Return function of transformed response variables</p></a></li>
<li><a href='#get_varcov'><p>Get variance-covariance matrix from models</p></a></li>
<li><a href='#get_variance'><p>Get variance components from random effects models</p></a></li>
<li><a href='#get_weights'><p>Get the values from model weights</p></a></li>
<li><a href='#has_intercept'><p>Checks if model has an intercept</p></a></li>
<li><a href='#is_converged'><p>Convergence test for mixed effects models</p></a></li>
<li><a href='#is_empty_object'><p>Check if object is empty</p></a></li>
<li><a href='#is_gam_model'><p>Checks if a model is a generalized additive model</p></a></li>
<li><a href='#is_mixed_model'><p>Checks if a model is a mixed effects model</p></a></li>
<li><a href='#is_model'><p>Checks if an object is a regression model or statistical test object</p></a></li>
<li><a href='#is_model_supported'><p>Checks if a regression model object is supported by the insight package</p></a></li>
<li><a href='#is_multivariate'><p>Checks if an object stems from a multivariate response model</p></a></li>
<li><a href='#is_nested_models'><p>Checks whether a list of models are nested models</p></a></li>
<li><a href='#is_nullmodel'><p>Checks if model is a null-model (intercept-only)</p></a></li>
<li><a href='#link_function'><p>Get link-function from model object</p></a></li>
<li><a href='#link_inverse'><p>Get link-inverse function from model object</p></a></li>
<li><a href='#model_info'><p>Access information from model objects</p></a></li>
<li><a href='#model_name'><p>Name the model</p></a></li>
<li><a href='#n_grouplevels'><p>Count number of random effect levels in a mixed model</p></a></li>
<li><a href='#n_obs'><p>Get number of observations from a model</p></a></li>
<li><a href='#n_parameters'><p>Count number of parameters in a model</p></a></li>
<li><a href='#null_model'><p>Compute intercept-only model for regression models</p></a></li>
<li><a href='#object_has_names'><p>Check names and rownames</p></a></li>
<li><a href='#print_color'><p>Coloured console output</p></a></li>
<li><a href='#print_parameters'><p>Prepare summary statistics of model parameters for printing</p></a></li>
<li><a href='#standardize_column_order'><p>Standardize column order</p></a></li>
<li><a href='#standardize_names'><p>Standardize column names</p></a></li>
<li><a href='#text_remove_backticks'><p>Remove backticks from a string</p></a></li>
<li><a href='#trim_ws'><p>Small helper functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Easy Access to Model Information for Various Model Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.19.10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Lüdecke &lt;d.luedecke@uke.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool to provide an easy, intuitive and consistent
    access to information contained in various R models, like model
    formulas, model terms, information about random effects, data that was
    used to fit the model or data from response variables. 'insight'
    mainly revolves around two types of functions: Functions that find
    (the names of) information, starting with 'find_', and functions that
    get the underlying data, starting with 'get_'.  The package has a
    consistent syntax and works with many different model objects, where
    otherwise functions to access these information are missing.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://easystats.github.io/insight/">https://easystats.github.io/insight/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/easystats/insight/issues">https://github.com/easystats/insight/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AER, afex, aod, BayesFactor, bayestestR, bbmle, bdsmatrix,
betareg, bife, biglm, blavaan, blme, boot, brms, broom, car,
carData, censReg, cgam, clubSandwich, coxme, cplm, crch, curl,
datawizard, effectsize, emmeans, epiR, estimatr, feisr, fixest
(&ge; 0.11.2), fungible, gam, gamlss, gamlss.data, gamm4, gbm,
gee, geepack, geoR, ggeffects, GLMMadaptive, glmmTMB, gmnl,
grDevices, gt, httr, interp, ivreg, JM, knitr, lavaan,
lavaSearch2, lfe, lme4, lmerTest, lmtest, logistf, logitr,
MASS, marginaleffects, Matrix, mclogit, mclust, MCMCglmm,
merTools, metaBMA, metadat, metafor, metaplus, mgcv, mice,
mlogit, mhurdle, mmrm, modelbased, multgee, MuMIn, nestedLogit,
nlme, nnet, nonnest2, ordinal, panelr, parameters, parsnip,
pbkrtest, performance, plm, poorman, PROreg (&ge; 1.3.0), pscl,
psych, quantreg, Rcpp, rmarkdown, rms, rpart, robustbase,
robustlmm, rstanarm (&ge; 2.21.1), rstantools (&ge; 2.1.0),
rstudioapi, sandwich, serp, speedglm, splines, statmod, survey,
survival, testthat, tinytable (&ge; 0.1.0), truncreg, tweedie,
TMB, VGAM, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rstudio/bslib, r-lib/pkgdown,
easystats/easystatstemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-21 22:24:16 UTC; Daniel</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Lüdecke <a href="https://orcid.org/0000-0002-8895-3206"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (@strengejacke),
  Dominique Makowski
    <a href="https://orcid.org/0000-0001-5375-9967"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, ctb]
    (@Dom_Makowski),
  Indrajeet Patil <a href="https://orcid.org/0000-0003-1995-6531"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb] (@patilindrajeets),
  Philip Waggoner <a href="https://orcid.org/0000-0002-7825-7573"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Mattan S. Ben-Shachar
    <a href="https://orcid.org/0000-0002-4287-4801"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, ctb],
  Brenton M. Wiernik
    <a href="https://orcid.org/0000-0001-9560-6336"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, ctb]
    (@bmwiernik),
  Vincent Arel-Bundock
    <a href="https://orcid.org/0000-0003-2042-7063"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, ctb],
  Etienne Bacher <a href="https://orcid.org/0000-0002-9271-5075"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Alex Hayes <a href="https://orcid.org/0000-0002-4985-5160"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Grant McDermott <a href="https://orcid.org/0000-0001-7883-8573"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Rémi Thériault <a href="https://orcid.org/0000-0003-4315-6788"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (@rempsyc),
  Alex Reinhart <a href="https://orcid.org/0000-0002-6658-514X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-22 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='insight-package'>insight: A Unified Interface to Access Information from Model Objects in R.</h2><span id='topic+insight-package'></span><span id='topic+insight'></span>

<h3>Description</h3>

<p>When fitting any statistical model, there are many useful pieces of information
that are simultaneously calculated and stored beyond coefficient estimates
and general model fit statistics. Although there exist some generic functions
to obtain model information and data, many package-specific modelling functions
do not provide such methods to allow users to access such valuable information.
</p>
<p><strong>insight</strong> is an R-package that fills this important gap by providing a
suite of functions to support almost any model (see a list of the many models
supported below in the <strong>List of Supported Packages and Models</strong> section).
The goal of <strong>insight</strong>, then, is to provide tools to provide <em>easy</em>,
<em>intuitive</em>, and <em>consistent</em> access to information contained in model
objects. These tools aid applied research in virtually any field who fit,
diagnose, and present statistical models by streamlining access to every
aspect of many model objects via consistent syntax and output.
</p>
<p>References: Lüdecke et al. (2019) <a href="https://doi.org/10.21105/joss.01412">doi:10.21105/joss.01412</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Daniel Lüdecke <a href="mailto:d.luedecke@uke.de">d.luedecke@uke.de</a> (<a href="https://orcid.org/0000-0002-8895-3206">ORCID</a>) (@strengejacke)
</p>
<p>Authors:
</p>

<ul>
<li><p> Dominique Makowski <a href="mailto:dom.makowski@gmail.com">dom.makowski@gmail.com</a> (<a href="https://orcid.org/0000-0001-5375-9967">ORCID</a>) (@Dom_Makowski) [contributor]
</p>
</li>
<li><p> Indrajeet Patil <a href="mailto:patilindrajeet.science@gmail.com">patilindrajeet.science@gmail.com</a> (<a href="https://orcid.org/0000-0003-1995-6531">ORCID</a>) (@patilindrajeets) [contributor]
</p>
</li>
<li><p> Philip Waggoner <a href="mailto:philip.waggoner@gmail.com">philip.waggoner@gmail.com</a> (<a href="https://orcid.org/0000-0002-7825-7573">ORCID</a>) [contributor]
</p>
</li>
<li><p> Mattan S. Ben-Shachar <a href="mailto:matanshm@post.bgu.ac.il">matanshm@post.bgu.ac.il</a> (<a href="https://orcid.org/0000-0002-4287-4801">ORCID</a>) [contributor]
</p>
</li>
<li><p> Brenton M. Wiernik <a href="mailto:brenton@wiernik.org">brenton@wiernik.org</a> (<a href="https://orcid.org/0000-0001-9560-6336">ORCID</a>) (@bmwiernik) [contributor]
</p>
</li>
<li><p> Vincent Arel-Bundock <a href="mailto:vincent.arel-bundock@umontreal.ca">vincent.arel-bundock@umontreal.ca</a> (<a href="https://orcid.org/0000-0003-2042-7063">ORCID</a>) [contributor]
</p>
</li>
<li><p> Etienne Bacher <a href="mailto:etienne.bacher@protonmail.com">etienne.bacher@protonmail.com</a> (<a href="https://orcid.org/0000-0002-9271-5075">ORCID</a>) [contributor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Alex Hayes <a href="mailto:alexpghayes@gmail.com">alexpghayes@gmail.com</a> (<a href="https://orcid.org/0000-0002-4985-5160">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Grant McDermott <a href="mailto:grantmcd@uoregon.edu">grantmcd@uoregon.edu</a> (<a href="https://orcid.org/0000-0001-7883-8573">ORCID</a>) [contributor]
</p>
</li>
<li><p> Rémi Thériault <a href="mailto:remi.theriault@mail.mcgill.ca">remi.theriault@mail.mcgill.ca</a> (<a href="https://orcid.org/0000-0003-4315-6788">ORCID</a>) (@rempsyc) [contributor]
</p>
</li>
<li><p> Alex Reinhart <a href="mailto:areinhar@stat.cmu.edu">areinhar@stat.cmu.edu</a> (<a href="https://orcid.org/0000-0002-6658-514X">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://easystats.github.io/insight/">https://easystats.github.io/insight/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/easystats/insight/issues">https://github.com/easystats/insight/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.colour_detect'>Detect coloured cells</h2><span id='topic+.colour_detect'></span>

<h3>Description</h3>

<p>Detect coloured cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.colour_detect(x)
</code></pre>

<hr>
<h2 id='all_models_equal'>Checks if all objects are models of same class</h2><span id='topic+all_models_equal'></span><span id='topic+all_models_same_class'></span>

<h3>Description</h3>

<p>Small helper that checks if all objects are <em>supported</em>
(regression) model objects and of same class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_models_equal(..., verbose = FALSE)

all_models_same_class(..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_models_equal_+3A_...">...</code></td>
<td>
<p>A list of objects.</p>
</td></tr>
<tr><td><code id="all_models_equal_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical, <code>TRUE</code> if <code>x</code> are all supported model objects
of same class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
data(sleepstudy, package = "lme4")

m1 &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
m2 &lt;- lm(mpg ~ wt + cyl, data = mtcars)
m3 &lt;- lme4::lmer(Reaction ~ Days + (1 | Subject), data = sleepstudy)
m4 &lt;- glm(formula = vs ~ wt, family = binomial(), data = mtcars)

all_models_same_class(m1, m2)
all_models_same_class(m1, m2, m3)
all_models_same_class(m1, m4, m2, m3, verbose = TRUE)
all_models_same_class(m1, m4, mtcars, m2, m3, verbose = TRUE)

</code></pre>

<hr>
<h2 id='apply_table_theme'>Data frame and Tables Pretty Formatting</h2><span id='topic+apply_table_theme'></span><span id='topic+export_table'></span>

<h3>Description</h3>

<p>Data frame and Tables Pretty Formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_table_theme(out, x, theme = "default", sub_header_positions = NULL)

export_table(
  x,
  sep = " | ",
  header = "-",
  cross = NULL,
  empty_line = NULL,
  digits = 2,
  protect_integers = TRUE,
  missing = "",
  width = NULL,
  format = NULL,
  title = NULL,
  caption = title,
  subtitle = NULL,
  footer = NULL,
  align = NULL,
  group_by = NULL,
  zap_small = FALSE,
  table_width = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_table_theme_+3A_out">out</code></td>
<td>
<p>A <code>tinytable</code> object.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_x">x</code></td>
<td>
<p>A data frame. May also be a list of data frames, to export multiple
data frames into multiple tables.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_theme">theme</code></td>
<td>
<p>The theme to apply to the table. One of <code>"default"</code>, <code>"grid"</code>,
<code>"striped"</code>, <code>"bootstrap"</code>, <code>"void"</code>, <code>"tabular"</code>, or <code>"darklines"</code>.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_sub_header_positions">sub_header_positions</code></td>
<td>
<p>A vector of row positions to apply a border to.
Currently particular for internal use of other <em>easystats</em> packages.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_sep">sep</code></td>
<td>
<p>Column separator.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_header">header</code></td>
<td>
<p>Header separator. Can be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_cross">cross</code></td>
<td>
<p>Character that is used where separator and header lines cross.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_empty_line">empty_line</code></td>
<td>
<p>Separator used for empty lines. If <code>NULL</code>, line remains
empty (i.e. filled with whitespaces).</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding or significant figures. May also
be <code>"signif"</code> to return significant figures or <code>"scientific"</code>
to return scientific notation. Control the number of digits by adding the
value as suffix, e.g. <code>digits = "scientific4"</code> to have scientific
notation with 4 decimal places, or <code>digits = "signif5"</code> for 5
significant figures (see also <code><a href="base.html#topic+signif">signif()</a></code>).</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_protect_integers">protect_integers</code></td>
<td>
<p>Should integers be kept as integers (i.e., without
decimals)?</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_missing">missing</code></td>
<td>
<p>Value by which <code>NA</code> values are replaced. By default, an
empty string (i.e. <code>""</code>) is returned for <code>NA</code>.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_width">width</code></td>
<td>
<p>Refers to the width of columns (with numeric values). Can be
either <code>NULL</code>, a number or a named numeric vector. If <code>NULL</code>, the width for
each column is adjusted to the minimum required width. If a number, columns
with numeric values will have the minimum width specified in <code>width</code>. If
a named numeric vector, value names are matched against column names, and
for each match, the specified width is used (see 'Examples'). Only applies
to text-format (see <code>format</code>).</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_format">format</code></td>
<td>
<p>Name of output-format, as string. If <code>NULL</code> (or <code>"text"</code>),
returned output is used for basic printing. Can be one of <code>NULL</code> (the
default) resp. <code>"text"</code> for plain text, <code>"markdown"</code> (or
<code>"md"</code>) for markdown and <code>"html"</code> for HTML output.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_title">title</code>, <code id="apply_table_theme_+3A_caption">caption</code>, <code id="apply_table_theme_+3A_subtitle">subtitle</code></td>
<td>
<p>Table title (same as caption) and subtitle, as strings. If <code>NULL</code>,
no title or subtitle is printed, unless it is stored as attributes (<code>table_title</code>,
or its alias <code>table_caption</code>, and <code>table_subtitle</code>). If <code>x</code> is a list of
data frames, <code>caption</code> may be a list of table captions, one for each table.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_footer">footer</code></td>
<td>
<p>Table footer, as string. For markdown-formatted tables, table
footers, due to the limitation in markdown rendering, are actually just a
new text line under the table. If <code>x</code> is a list of data frames, <code>footer</code>
may be a list of table captions, one for each table.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_align">align</code></td>
<td>
<p>Column alignment. For markdown-formatted tables, the default
<code>align = NULL</code> will right-align numeric columns, while all other
columns will be left-aligned. If <code>format = "html"</code>, the default is
left-align first column and center all remaining. May be a string to
indicate alignment rules for the complete table, like <code>"left"</code>,
<code>"right"</code>, <code>"center"</code> or <code>"firstleft"</code> (to left-align first
column, center remaining); or maybe a string with abbreviated alignment
characters, where the length of the string must equal the number of columns,
for instance, <code>align = "lccrl"</code> would left-align the first column, center
the second and third, right-align column four and left-align the fifth
column. For HTML-tables, may be one of <code>"center"</code>, <code>"left"</code> or
<code>"right"</code>.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_group_by">group_by</code></td>
<td>
<p>Name of column in <code>x</code> that indicates grouping for tables.
Only applies when <code>format = "html"</code>. <code>group_by</code> is passed down
to <code>gt::gt(groupname_col = group_by)</code>.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_zap_small">zap_small</code></td>
<td>
<p>Logical, if <code>TRUE</code>, small values are rounded after
<code>digits</code> decimal places. If <code>FALSE</code>, values with more decimal
places than <code>digits</code> are printed in scientific notation.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_table_width">table_width</code></td>
<td>
<p>Numeric, or <code>"auto"</code>, indicating the width of the complete
table. If <code>table_width = "auto"</code> and the table is wider than the current
width (i.e. line length) of the console (or any other source for textual
output, like markdown files), the table is split into two parts. Else,
if <code>table_width</code> is numeric and table rows are larger than <code>table_width</code>,
the table is split into two parts.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="apply_table_theme_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in character format.
</p>


<h3>Note</h3>

<p>The values for <code>caption</code>, <code>subtitle</code> and <code>footer</code> can also be provided
as attributes of <code>x</code>, e.g. if <code>caption = NULL</code> and <code>x</code> has attribute
<code>table_caption</code>, the value for this attribute will be used as table caption.
<code>table_subtitle</code> is the attribute for <code>subtitle</code>, and <code>table_footer</code> for
<code>footer</code>.
</p>


<h3>See Also</h3>

<p>Vignettes
<a href="https://easystats.github.io/insight/articles/display.html">Formatting, printing and exporting tables</a>
and <a href="https://easystats.github.io/parameters/articles/model_parameters_formatting.html">Formatting model parameters</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>export_table(head(iris))
export_table(head(iris), cross = "+")
export_table(head(iris), sep = " ", header = "*", digits = 1)

# split longer tables
export_table(head(iris), table_width = 30)


# colored footers
data(iris)
x &lt;- as.data.frame(iris[1:5, ])
attr(x, "table_footer") &lt;- c("This is a yellow footer line.", "yellow")
export_table(x)

attr(x, "table_footer") &lt;- list(
  c("\nA yellow line", "yellow"),
  c("\nAnd a red line", "red"),
  c("\nAnd a blue line", "blue")
)
export_table(x)

attr(x, "table_footer") &lt;- list(
  c("Without the ", "yellow"),
  c("new-line character ", "red"),
  c("we can have multiple colors per line.", "blue")
)
export_table(x)


# column-width
d &lt;- data.frame(
  x = c(1, 2, 3),
  y = c(100, 200, 300),
  z = c(10000, 20000, 30000)
)
export_table(d)
export_table(d, width = 8)
export_table(d, width = c(x = 5, z = 10))
export_table(d, width = c(x = 5, y = 5, z = 10), align = "lcr")
</code></pre>

<hr>
<h2 id='check_if_installed'>Checking if needed package is installed</h2><span id='topic+check_if_installed'></span>

<h3>Description</h3>

<p>Checking if needed package is installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_if_installed(
  package,
  reason = "for this function to work",
  stop = TRUE,
  minimum_version = NULL,
  quietly = FALSE,
  prompt = interactive(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_if_installed_+3A_package">package</code></td>
<td>
<p>A character vector naming the package(s), whose installation
needs to be checked in any of the libraries.</p>
</td></tr>
<tr><td><code id="check_if_installed_+3A_reason">reason</code></td>
<td>
<p>A phrase describing why the package is needed. The default is a
generic description.</p>
</td></tr>
<tr><td><code id="check_if_installed_+3A_stop">stop</code></td>
<td>
<p>Logical that decides whether the function should stop if the
needed package is not installed.</p>
</td></tr>
<tr><td><code id="check_if_installed_+3A_minimum_version">minimum_version</code></td>
<td>
<p>A character vector, representing the minimum package
version that is required for each package. Should be of same length as
<code>package</code>. If <code>NULL</code>, will automatically check the DESCRIPTION file for
the correct minimum version. If using <code>minimum_version</code> with more than one
package, <code>NA</code> should be used instead of <code>NULL</code> for packages where a
specific version is not necessary.</p>
</td></tr>
<tr><td><code id="check_if_installed_+3A_quietly">quietly</code></td>
<td>
<p>Logical, if <code>TRUE</code>, invisibly returns a vector of logicals
(<code>TRUE</code> for each installed package, <code>FALSE</code> otherwise), and does not stop
or throw a warning. If <code>quietly = TRUE</code>, arguments <code>stop</code> and <code>prompt</code> are
ignored. Use this argument to internally check for package dependencies
without stopping or warnings.</p>
</td></tr>
<tr><td><code id="check_if_installed_+3A_prompt">prompt</code></td>
<td>
<p>If <code>TRUE</code>, will prompt the user to install needed package(s).
Ignored if <code>quietly = TRUE</code>.</p>
</td></tr>
<tr><td><code id="check_if_installed_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>stop = TRUE</code>, and <code>package</code> is not yet installed, the
function stops and throws an error. Else, a named logical vector is
returned, indicating which of the packages are installed, and which not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

check_if_installed("insight")
try(check_if_installed("datawizard", stop = FALSE))
try(check_if_installed("rstanarm", stop = FALSE))
try(check_if_installed("nonexistent_package", stop = FALSE))
try(check_if_installed("insight", minimum_version = "99.8.7"))
try(check_if_installed(c("nonexistent", "also_not_here"), stop = FALSE))
try(check_if_installed(c("datawizard", "rstanarm"), stop = FALSE))
try(check_if_installed(c("datawizard", "rstanarm"),
  minimum_version = c(NA, "2.21.1"), stop = FALSE
))


</code></pre>

<hr>
<h2 id='clean_names'>Get clean names of model terms</h2><span id='topic+clean_names'></span><span id='topic+clean_names.character'></span>

<h3>Description</h3>

<p>This function &quot;cleans&quot; names of model terms (or a character
vector with such names) by removing patterns like <code>log()</code> or
<code>as.factor()</code> etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_names(x, ...)

## S3 method for class 'character'
clean_names(x, include_names = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_names_+3A_x">x</code></td>
<td>
<p>A fitted model, or a character vector.</p>
</td></tr>
<tr><td><code id="clean_names_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="clean_names_+3A_include_names">include_names</code></td>
<td>
<p>Logical, if <code>TRUE</code>, returns a named vector where
names are the original values of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The &quot;cleaned&quot; variable names as character vector, i.e. pattern
like <code>s()</code> for splines or <code>log()</code> are removed from
the model terms.
</p>


<h3>Note</h3>

<p>Typically, this method is intended to work on character vectors,
in order to remove patterns that obscure the variable names. For
convenience reasons it is also possible to call <code>clean_names()</code>
also on a model object. If <code>x</code> is a regression model, this
function is (almost) equal to calling <code>find_variables()</code>. The
main difference is that <code>clean_names()</code> always returns a character
vector, while <code>find_variables()</code> returns a list of character
vectors, unless <code>flatten = TRUE</code>. See 'Examples'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example from ?stats::glm
counts &lt;- c(18, 17, 15, 20, 10, 20, 25, 13, 12)
outcome &lt;- as.numeric(gl(3, 1, 9))
treatment &lt;- gl(3, 3)
m &lt;- glm(counts ~ log(outcome) + as.factor(treatment), family = poisson())
clean_names(m)

# difference "clean_names()" and "find_variables()"
data(cbpp, package = "lme4")
m &lt;- lme4::glmer(
  cbind(incidence, size - incidence) ~ period + (1 | herd),
  data = cbpp,
  family = binomial
)

clean_names(m)
find_variables(m)
find_variables(m, flatten = TRUE)

</code></pre>

<hr>
<h2 id='clean_parameters'>Get clean names of model parameters</h2><span id='topic+clean_parameters'></span>

<h3>Description</h3>

<p>This function &quot;cleans&quot; names of model parameters by removing
patterns like <code>"r_"</code> or <code>"b[]"</code> (mostly applicable to Stan models)
and adding columns with information to which group or component parameters
belong (i.e. fixed or random, count or zero-inflated...)
</p>
<p>The main purpose of this function is to easily filter and select model parameters,
in particular of - but not limited to - posterior samples from Stan models,
depending on certain characteristics. This might be useful when only selective
results should be reported or results from all parameters should be filtered
to return only certain results (see <code><a href="#topic+print_parameters">print_parameters()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_parameters(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_parameters_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="clean_parameters_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Effects</code> column indicate if a parameter is a <em>fixed</em> or <em>random</em> effect.
The <code>Component</code> can either be <em>conditional</em> or <em>zero_inflated</em>. For models
with random effects, the <code>Group</code> column indicates the grouping factor of the
random effects. For multivariate response models from <strong>brms</strong> or
<strong>rstanarm</strong>, an additional <em>Response</em> column is included, to indicate
which parameters belong to which response formula. Furthermore,
<em>Cleaned_Parameter</em> column is returned that contains &quot;human readable&quot;
parameter names (which are mostly identical to <code>Parameter</code>, except for for
models from <strong>brms</strong> or <strong>rstanarm</strong>, or for specific terms like smooth-
or spline-terms).
</p>


<h3>Value</h3>

<p>A data frame with &quot;cleaned&quot; parameter names and information on effects,
component and group where parameters belong to. To be consistent across
different models, the returned data frame always has at least four columns
<code>Parameter</code>, <code>Effects</code>, <code>Component</code> and <code>Cleaned_Parameter</code>. See 'Details'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

model &lt;- download_model("brms_zi_2")
clean_parameters(model)


</code></pre>

<hr>
<h2 id='color_if'>Color-formatting for data columns based on condition</h2><span id='topic+color_if'></span><span id='topic+colour_if'></span>

<h3>Description</h3>

<p>Convenient function that formats columns in data frames with color codes,
where the color is chosen based on certain conditions. Columns are then
printed in color in the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_if(
  x,
  columns,
  predicate = `&gt;`,
  value = 0,
  color_if = "green",
  color_else = "red",
  digits = 2
)

colour_if(
  x,
  columns,
  predicate = `&gt;`,
  value = 0,
  colour_if = "green",
  colour_else = "red",
  digits = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_if_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="color_if_+3A_columns">columns</code></td>
<td>
<p>Character vector with column names of <code>x</code> that should be
formatted.</p>
</td></tr>
<tr><td><code id="color_if_+3A_predicate">predicate</code></td>
<td>
<p>A function that takes <code>columns</code> and <code>value</code> as input
and which should return <code>TRUE</code> or <code>FALSE</code>, based on if the condition
(in comparison with <code>value</code>) is met.</p>
</td></tr>
<tr><td><code id="color_if_+3A_value">value</code></td>
<td>
<p>The comparator. May be used in conjunction with <code>predicate</code>
to quickly set up a function which compares elements in <code>colums</code> to <code>value</code>.
May be ignored when <code>predicate</code> is a function that internally computes other
comparisons. See 'Examples'.</p>
</td></tr>
<tr><td><code id="color_if_+3A_color_if">color_if</code>, <code id="color_if_+3A_colour_if">colour_if</code></td>
<td>
<p>Character vector, indicating the color code used to
format values in <code>x</code> that meet the condition of <code>predicate</code> and <code>value</code>.
May be one of <code>"red"</code>, <code>"yellow"</code>, <code>"green"</code>, <code>"blue"</code>,
<code>"violet"</code>, <code>"cyan"</code> or <code>"grey"</code>. Formatting is also possible
with <code>"bold"</code> or <code>"italic"</code>.</p>
</td></tr>
<tr><td><code id="color_if_+3A_color_else">color_else</code>, <code id="color_if_+3A_colour_else">colour_else</code></td>
<td>
<p>See <code>color_if</code>, but only for conditions
that are <em>not</em> met.</p>
</td></tr>
<tr><td><code id="color_if_+3A_digits">digits</code></td>
<td>
<p>Digits for rounded values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predicate-function simply works like this:
<code>which(predicate(x[, columns], value))</code>
</p>


<h3>Value</h3>

<p><code>x</code>, where columns matched by <code>predicate</code> are wrapped into color codes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all values in Sepal.Length larger than 5 in green, all remaining in red
x &lt;- color_if(iris[1:10, ], columns = "Sepal.Length", predicate = `&gt;`, value = 5)
x
cat(x$Sepal.Length)

# all levels "setosa" in Species in green, all remaining in red
x &lt;- color_if(iris, columns = "Species", predicate = `==`, value = "setosa")
cat(x$Species)

# own function, argument "value" not needed here
p &lt;- function(x, y) {
  x &gt;= 4.9 &amp; x &lt;= 5.1
}
# all values in Sepal.Length between 4.9 and 5.1 in green, all remaining in red
x &lt;- color_if(iris[1:10, ], columns = "Sepal.Length", predicate = p)
cat(x$Sepal.Length)
</code></pre>

<hr>
<h2 id='compact_character'>Remove empty strings from character</h2><span id='topic+compact_character'></span>

<h3>Description</h3>

<p>Remove empty strings from character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact_character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compact_character_+3A_x">x</code></td>
<td>
<p>A single character or a vector of characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character or a character vector with empty strings removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compact_character(c("x", "y", NA))
compact_character(c("x", "NULL", "", "y"))

</code></pre>

<hr>
<h2 id='compact_list'>Remove empty elements from lists</h2><span id='topic+compact_list'></span>

<h3>Description</h3>

<p>Remove empty elements from lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact_list(x, remove_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compact_list_+3A_x">x</code></td>
<td>
<p>A list or vector.</p>
</td></tr>
<tr><td><code id="compact_list_+3A_remove_na">remove_na</code></td>
<td>
<p>Logical to decide if <code>NA</code>s should be removed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>compact_list(list(NULL, 1, c(NA, NA)))
compact_list(c(1, NA, NA))
compact_list(c(1, NA, NA), remove_na = TRUE)
</code></pre>

<hr>
<h2 id='display'>Generic export of data frames into formatted tables</h2><span id='topic+display'></span><span id='topic+print_md'></span><span id='topic+print_html'></span><span id='topic+display.data.frame'></span><span id='topic+print_md.data.frame'></span><span id='topic+print_html.data.frame'></span>

<h3>Description</h3>

<p><code>display()</code> is a generic function to export data frames
into various table formats (like plain text, markdown, ...). <code>print_md()</code>
usually is a convenient wrapper for <code>display(format = "markdown")</code>.
Similar, <code>print_html()</code> is a shortcut for <code>display(format = "html")</code>.
See the documentation for the specific objects' classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display(object, ...)

print_md(x, ...)

print_html(x, ...)

## S3 method for class 'data.frame'
display(object, format = "markdown", ...)

## S3 method for class 'data.frame'
print_md(x, ...)

## S3 method for class 'data.frame'
print_html(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_+3A_object">object</code>, <code id="display_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="display_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="display_+3A_format">format</code></td>
<td>
<p>String, indicating the output format. Can be <code>"markdown"</code> or <code>"html"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on <code>format</code>, either an object of class <code>gt_tbl</code>
or a character vector of class <code>knitr_kable</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>display(iris[1:5, ])
</code></pre>

<hr>
<h2 id='download_model'>Download circus models</h2><span id='topic+download_model'></span>

<h3>Description</h3>

<p>Downloads pre-compiled models from the <em>circus</em>-repository.
The <em>circus</em>-repository contains a variety of fitted models to help
the systematic testing of other packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_model(name, url = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_model_+3A_name">name</code></td>
<td>
<p>Model name.</p>
</td></tr>
<tr><td><code id="download_model_+3A_url">url</code></td>
<td>
<p>String with the URL from where to download the model data.
Optional, and should only be used in case the repository-URL is
changing. By default, models are downloaded from
<code style="white-space: pre;">&#8288;https://raw.github.com/easystats/circus/master/data/&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code that generated the model is available at the
<a href="https://easystats.github.io/circus/reference/index.html">https://easystats.github.io/circus/reference/index.html</a>.
</p>


<h3>Value</h3>

<p>A model from the <em>circus</em>-repository, or <code>NULL</code> if model could
not be downloaded (e.g., due to server problems).
</p>


<h3>References</h3>

<p><a href="https://easystats.github.io/circus/">https://easystats.github.io/circus/</a>
</p>

<hr>
<h2 id='ellipsis_info'>Gather information about objects in ellipsis (dot dot dot)</h2><span id='topic+ellipsis_info'></span><span id='topic+ellipsis_info.default'></span>

<h3>Description</h3>

<p>Provides information regarding the models entered in an ellipsis.
It detects whether all are models, regressions, nested regressions etc.,
assigning different classes to the list of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipsis_info(objects, ...)

## Default S3 method:
ellipsis_info(..., only_models = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipsis_info_+3A_objects">objects</code>, <code id="ellipsis_info_+3A_...">...</code></td>
<td>
<p>Arbitrary number of objects. May also be a list of model objects.</p>
</td></tr>
<tr><td><code id="ellipsis_info_+3A_only_models">only_models</code></td>
<td>
<p>Only keep supported models (default to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ellipsis_info_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list with objects that were passed to the function, including
additional information as attributes (e.g. if models have same response or
are nested).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lm(Sepal.Length ~ Petal.Width + Species, data = iris)
m2 &lt;- lm(Sepal.Length ~ Species, data = iris)
m3 &lt;- lm(Sepal.Length ~ Petal.Width, data = iris)
m4 &lt;- lm(Sepal.Length ~ 1, data = iris)
m5 &lt;- lm(Petal.Width ~ 1, data = iris)

objects &lt;- ellipsis_info(m1, m2, m3, m4)
class(objects)

objects &lt;- ellipsis_info(m1, m2, m4)
attributes(objects)$is_nested

objects &lt;- ellipsis_info(m1, m2, m5)
attributes(objects)$same_response
</code></pre>

<hr>
<h2 id='find_algorithm'>Find sampling algorithm and optimizers</h2><span id='topic+find_algorithm'></span>

<h3>Description</h3>

<p>Returns information on the sampling or estimation algorithm
as well as optimization functions, or for Bayesian model information on
chains, iterations and warmup-samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_algorithm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_algorithm_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_algorithm_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements depending on the model.
</p>
<p>For frequentist models:
</p>

<ul>
<li> <p><code>algorithm</code>, for instance <code>"OLS"</code> or <code>"ML"</code>
</p>
</li>
<li> <p><code>optimizer</code>, name of optimizing function, only applies to
specific models (like <code>gam</code>)
</p>
</li></ul>

<p>For frequentist mixed models:
</p>

<ul>
<li> <p><code>algorithm</code>, for instance <code>"REML"</code> or <code>"ML"</code>
</p>
</li>
<li> <p><code>optimizer</code>, name of optimizing function
</p>
</li></ul>

<p>For Bayesian models:
</p>

<ul>
<li> <p><code>algorithm</code>, the algorithm
</p>
</li>
<li> <p><code>chains</code>, number of chains
</p>
</li>
<li> <p><code>iterations</code>, number of iterations per chain
</p>
</li>
<li> <p><code>warmup</code>, number of warmups per chain
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(sleepstudy, package = "lme4")
m &lt;- lme4::lmer(Reaction ~ Days + (1 | Subject), data = sleepstudy)
find_algorithm(m)



data(sleepstudy, package = "lme4")
m &lt;- suppressWarnings(rstanarm::stan_lmer(
  Reaction ~ Days + (1 | Subject),
  data = sleepstudy,
  refresh = 0
))
find_algorithm(m)


</code></pre>

<hr>
<h2 id='find_formula'>Find model formula</h2><span id='topic+find_formula'></span><span id='topic+formula_ok'></span><span id='topic+find_formula.default'></span><span id='topic+find_formula.nestedLogit'></span>

<h3>Description</h3>

<p>Returns the formula(s) for the different parts of a model
(like fixed or random effects, zero-inflated component, ...).
<code>formula_ok()</code> checks if a model formula has valid syntax
regarding writing <code>TRUE</code> instead of <code>T</code> inside <code>poly()</code>
and that no data names are used (i.e. no <code>data$variable</code>, but rather
<code>variable</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_formula(x, ...)

formula_ok(x, verbose = TRUE, ...)

## Default S3 method:
find_formula(x, verbose = TRUE, ...)

## S3 method for class 'nestedLogit'
find_formula(x, dichotomies = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_formula_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_formula_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="find_formula_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="find_formula_+3A_dichotomies">dichotomies</code></td>
<td>
<p>Logical, if model is a <code>nestedLogit</code> objects, returns
the formulas for the dichotomies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of formulas that describe the model. For simple models,
only one list-element, <code>conditional</code>, is returned. For more complex
models, the returned list may have following elements:
</p>

<ul>
<li> <p><code>conditional</code>, the &quot;fixed effects&quot; part from the model (in the
context of fixed-effects or instrumental variable regression, also
called <em>regressors</em>) . One exception are <code>DirichletRegModel</code> models
from <strong>DirichletReg</strong>, which has two or three components,
depending on <code>model</code>.
</p>
</li>
<li> <p><code>random</code>, the &quot;random effects&quot; part from the model (or the
<code>id</code> for gee-models and similar)
</p>
</li>
<li> <p><code>zero_inflated</code>, the &quot;fixed effects&quot; part from the
zero-inflation component of the model
</p>
</li>
<li> <p><code>zero_inflated_random</code>, the &quot;random effects&quot; part from the
zero-inflation component of the model
</p>
</li>
<li> <p><code>dispersion</code>, the dispersion formula
</p>
</li>
<li> <p><code>instruments</code>, for fixed-effects or instrumental variable
regressions like <code>ivreg::ivreg()</code>, <code>lfe::felm()</code> or <code>plm::plm()</code>,
the instrumental variables
</p>
</li>
<li> <p><code>cluster</code>, for fixed-effects regressions like
<code>lfe::felm()</code>, the cluster specification
</p>
</li>
<li> <p><code>correlation</code>, for models with correlation-component like
<code>nlme::gls()</code>, the formula that describes the correlation structure
</p>
</li>
<li> <p><code>scale</code>, for distributional models such as <code>mgcv::gaulss()</code> family fitted
with <code>mgcv::gam()</code>, the formula that describes the scale parameter
</p>
</li>
<li> <p><code>slopes</code>, for fixed-effects individual-slope models like
<code>feisr::feis()</code>, the formula for the slope parameters
</p>
</li>
<li> <p><code>precision</code>, for <code>DirichletRegModel</code> models from
<strong>DirichletReg</strong>, when parametrization (i.e. <code>model</code>) is
<code>"alternative"</code>.
</p>
</li></ul>



<h3>Note</h3>

<p>For models of class <code>lme</code> or <code>gls</code> the correlation-component
is only returned, when it is explicitly defined as named argument
(<code>form</code>), e.g. <code>corAR1(form = ~1 | Mare)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_formula(m)

m &lt;- lme4::lmer(Sepal.Length ~ Sepal.Width + (1 | Species), data = iris)
f &lt;- find_formula(m)
f
format(f)

</code></pre>

<hr>
<h2 id='find_interactions'>Find interaction terms from models</h2><span id='topic+find_interactions'></span>

<h3>Description</h3>

<p>Returns all lowest to highest order interaction terms from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_interactions(
  x,
  component = c("all", "conditional", "zi", "zero_inflated", "dispersion", "instruments"),
  flatten = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_interactions_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_interactions_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="find_interactions_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors that represent the interaction terms.
Depending on <code>component</code>, the returned list has following
elements (or <code>NULL</code>, if model has no interaction term):
</p>

<ul>
<li> <p><code>conditional</code>, interaction terms that belong to the &quot;fixed
effects&quot; terms from the model
</p>
</li>
<li> <p><code>zero_inflated</code>, interaction terms that belong to the &quot;fixed
effects&quot; terms from the zero-inflation component of the model
</p>
</li>
<li> <p><code>instruments</code>, for fixed-effects regressions like <code>ivreg</code>,
<code>felm</code> or <code>plm</code>, interaction terms that belong to the
instrumental variables
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)

m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_interactions(m)

m &lt;- lm(mpg ~ wt * cyl + vs * hp * gear + carb, data = mtcars)
find_interactions(m)
</code></pre>

<hr>
<h2 id='find_offset'>Find possible offset terms in a model</h2><span id='topic+find_offset'></span>

<h3>Description</h3>

<p>Returns a character vector with the name(s) of offset terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_offset(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_offset_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the name(s) of offset terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some zero-inflated data
set.seed(123)
N &lt;- 100 # Samples
x &lt;- runif(N, 0, 10) # Predictor
off &lt;- rgamma(N, 3, 2) # Offset variable
yhat &lt;- -1 + x * 0.5 + log(off) # Prediction on log scale
dat &lt;- data.frame(y = NA, x, logOff = log(off))
dat$y &lt;- rpois(N, exp(yhat)) # Poisson process
dat$y &lt;- ifelse(rbinom(N, 1, 0.3), 0, dat$y) # Zero-inflation process

m1 &lt;- zeroinfl(y ~ offset(logOff) + x | 1, data = dat, dist = "poisson")
find_offset(m1)

m2 &lt;- zeroinfl(y ~ x | 1, data = dat, offset = logOff, dist = "poisson")
find_offset(m2)

</code></pre>

<hr>
<h2 id='find_parameters'>Find names of model parameters</h2><span id='topic+find_parameters'></span><span id='topic+find_parameters.default'></span><span id='topic+find_parameters.pgmm'></span><span id='topic+find_parameters.nls'></span>

<h3>Description</h3>

<p>Returns the names of model parameters, like they typically
appear in the <code>summary()</code> output. For Bayesian models, the parameter
names equal the column names of the posterior samples after coercion
from <code>as.data.frame()</code>. See the documentation for your object's class:
</p>

<ul>
<li> <p><a href="#topic+find_parameters.BGGM">Bayesian models</a> (<strong>rstanarm</strong>, <strong>brms</strong>, <strong>MCMCglmm</strong>, ...)
</p>
</li>
<li> <p><a href="#topic+find_parameters.gamlss">Generalized additive models</a> (<strong>mgcv</strong>, <strong>VGAM</strong>, ...)
</p>
</li>
<li> <p><a href="#topic+find_parameters.betamfx">Marginal effects models</a> (<strong>mfx</strong>)
</p>
</li>
<li> <p><a href="#topic+find_parameters.emmGrid">Estimated marginal means</a> (<strong>emmeans</strong>)
</p>
</li>
<li> <p><a href="#topic+find_parameters.glmmTMB">Mixed models</a> (<strong>lme4</strong>, <strong>glmmTMB</strong>, <strong>GLMMadaptive</strong>, ...)
</p>
</li>
<li> <p><a href="#topic+find_parameters.zeroinfl">Zero-inflated and hurdle models</a> (<strong>pscl</strong>, ...)
</p>
</li>
<li> <p><a href="#topic+find_parameters.averaging">Models with special components</a> (<strong>betareg</strong>, <strong>MuMIn</strong>, ...)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>find_parameters(x, ...)

## Default S3 method:
find_parameters(x, flatten = FALSE, verbose = TRUE, ...)

## S3 method for class 'pgmm'
find_parameters(x, component = c("conditional", "all"), flatten = FALSE, ...)

## S3 method for class 'nls'
find_parameters(
  x,
  component = c("all", "conditional", "nonlinear"),
  flatten = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_parameters_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_parameters_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="find_parameters_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_parameters_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="find_parameters_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter names. For simple models, only one list-element,
<code>conditional</code>, is returned.
</p>


<h3>Model components</h3>

<p>Possible values for the <code>component</code> argument depend on the model class.
Following are valid options:
</p>

<ul>
<li> <p><code>"all"</code>: returns all model components, applies to all models, but will only
have an effect for models with more than just the conditional model component.
</p>
</li>
<li> <p><code>"conditional"</code>: only returns the conditional component, i.e. &quot;fixed effects&quot;
terms from the model. Will only have an effect for models with more than
just the conditional model component.
</p>
</li>
<li> <p><code>"smooth_terms"</code>: returns smooth terms, only applies to GAMs (or similar
models that may contain smooth terms).
</p>
</li>
<li> <p><code>"zero_inflated"</code> (or <code>"zi"</code>): returns the zero-inflation component.
</p>
</li>
<li> <p><code>"dispersion"</code>: returns the dispersion model component. This is common
for models with zero-inflation or that can model the dispersion parameter.
</p>
</li>
<li> <p><code>"instruments"</code>: for instrumental-variable or some fixed effects regression,
returns the instruments.
</p>
</li>
<li> <p><code>"location"</code>: returns location parameters such as <code>conditional</code>,
<code>zero_inflated</code>, <code>smooth_terms</code>, or <code>instruments</code> (everything that are
fixed or random effects - depending on the <code>effects</code> argument - but no
auxiliary parameters).
</p>
</li>
<li> <p><code>"distributional"</code> (or <code>"auxiliary"</code>): components like <code>sigma</code>, <code>dispersion</code>,
<code>beta</code> or <code>precision</code> (and other auxiliary parameters) are returned.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_parameters(m)
</code></pre>

<hr>
<h2 id='find_parameters.averaging'>Find model parameters from models with special components</h2><span id='topic+find_parameters.averaging'></span><span id='topic+find_parameters.betareg'></span><span id='topic+find_parameters.DirichletRegModel'></span><span id='topic+find_parameters.mjoint'></span><span id='topic+find_parameters.glmx'></span>

<h3>Description</h3>

<p>Returns the names of model parameters, like they typically
appear in the <code>summary()</code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'averaging'
find_parameters(x, component = c("conditional", "full"), flatten = FALSE, ...)

## S3 method for class 'betareg'
find_parameters(
  x,
  component = c("all", "conditional", "precision", "location", "distributional",
    "auxiliary"),
  flatten = FALSE,
  ...
)

## S3 method for class 'DirichletRegModel'
find_parameters(
  x,
  component = c("all", "conditional", "precision", "location", "distributional",
    "auxiliary"),
  flatten = FALSE,
  ...
)

## S3 method for class 'mjoint'
find_parameters(
  x,
  component = c("all", "conditional", "survival"),
  flatten = FALSE,
  ...
)

## S3 method for class 'glmx'
find_parameters(
  x,
  component = c("all", "conditional", "extra"),
  flatten = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_parameters.averaging_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_parameters.averaging_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="find_parameters.averaging_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_parameters.averaging_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter names. The returned list may have following
elements:
</p>

<ul>
<li> <p><code>conditional</code>, the &quot;fixed effects&quot; part from the model.
</p>
</li>
<li> <p><code>full</code>, parameters from the full model.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_parameters(m)
</code></pre>

<hr>
<h2 id='find_parameters.betamfx'>Find names of model parameters from marginal effects models</h2><span id='topic+find_parameters.betamfx'></span><span id='topic+find_parameters.logitmfx'></span>

<h3>Description</h3>

<p>Returns the names of model parameters, like they typically
appear in the <code>summary()</code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betamfx'
find_parameters(
  x,
  component = c("all", "conditional", "precision", "marginal", "location",
    "distributional", "auxiliary"),
  flatten = FALSE,
  ...
)

## S3 method for class 'logitmfx'
find_parameters(
  x,
  component = c("all", "conditional", "marginal", "location"),
  flatten = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_parameters.betamfx_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_parameters.betamfx_+3A_component">component</code></td>
<td>
<p>Which type of parameters to return, such as parameters for the
conditional model, the zero-inflated part of the model, the dispersion
term, the instrumental variables or marginal effects be returned? Applies
to models with zero-inflated and/or dispersion formula, or to models with
instrumental variables (so called fixed-effects regressions), or models
with marginal effects from <strong>mfx</strong>. May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model. There are three convenient shortcuts:
<code>component = "all"</code> returns all possible parameters.
If <code>component = "location"</code>, location parameters such as <code>conditional</code>,
<code>zero_inflated</code>, <code>smooth_terms</code>, or <code>instruments</code> are returned
(everything that are fixed or random effects - depending on the <code>effects</code>
argument - but no auxiliary parameters). For <code>component = "distributional"</code>
(or <code>"auxiliary"</code>), components like <code>sigma</code>, <code>dispersion</code>,
<code>beta</code> or <code>precision</code> (and other auxiliary parameters) are returned.</p>
</td></tr>
<tr><td><code id="find_parameters.betamfx_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_parameters.betamfx_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter names. The returned list may have following
elements:
</p>

<ul>
<li> <p><code>conditional</code>, the &quot;fixed effects&quot; part from the model.
</p>
</li>
<li> <p><code>marginal</code>, the marginal effects.
</p>
</li>
<li> <p><code>precision</code>, the precision parameter.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_parameters(m)
</code></pre>

<hr>
<h2 id='find_parameters.BGGM'>Find names of model parameters from Bayesian models</h2><span id='topic+find_parameters.BGGM'></span><span id='topic+find_parameters.BFBayesFactor'></span><span id='topic+find_parameters.MCMCglmm'></span><span id='topic+find_parameters.bamlss'></span><span id='topic+find_parameters.brmsfit'></span><span id='topic+find_parameters.bayesx'></span><span id='topic+find_parameters.stanreg'></span><span id='topic+find_parameters.stanmvreg'></span><span id='topic+find_parameters.sim.merMod'></span>

<h3>Description</h3>

<p>Returns the names of model parameters, like they typically
appear in the <code>summary()</code> output. For Bayesian models, the parameter
names equal the column names of the posterior samples after coercion
from <code>as.data.frame()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGGM'
find_parameters(
  x,
  component = c("correlation", "conditional", "intercept", "all"),
  flatten = FALSE,
  ...
)

## S3 method for class 'BFBayesFactor'
find_parameters(
  x,
  effects = c("all", "fixed", "random"),
  component = c("all", "extra"),
  flatten = FALSE,
  ...
)

## S3 method for class 'MCMCglmm'
find_parameters(x, effects = c("all", "fixed", "random"), flatten = FALSE, ...)

## S3 method for class 'bamlss'
find_parameters(
  x,
  flatten = FALSE,
  component = c("all", "conditional", "location", "distributional", "auxiliary"),
  parameters = NULL,
  ...
)

## S3 method for class 'brmsfit'
find_parameters(
  x,
  effects = "all",
  component = "all",
  flatten = FALSE,
  parameters = NULL,
  ...
)

## S3 method for class 'bayesx'
find_parameters(
  x,
  component = c("all", "conditional", "smooth_terms"),
  flatten = FALSE,
  parameters = NULL,
  ...
)

## S3 method for class 'stanreg'
find_parameters(
  x,
  effects = c("all", "fixed", "random"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  flatten = FALSE,
  parameters = NULL,
  ...
)

## S3 method for class 'stanmvreg'
find_parameters(
  x,
  effects = c("all", "fixed", "random"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  flatten = FALSE,
  parameters = NULL,
  ...
)

## S3 method for class 'sim.merMod'
find_parameters(
  x,
  effects = c("all", "fixed", "random"),
  flatten = FALSE,
  parameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_parameters.BGGM_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_parameters.BGGM_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="find_parameters.BGGM_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_parameters.BGGM_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="find_parameters.BGGM_+3A_effects">effects</code></td>
<td>
<p>Should parameters for fixed effects, random effects
or both be returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="find_parameters.BGGM_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters that
should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter names. For simple models, only one list-element,
<code>conditional</code>, is returned. For more complex models, the returned list may
have following elements:
</p>

<ul>
<li> <p><code>conditional</code>, the &quot;fixed effects&quot; part from the model
</p>
</li>
<li> <p><code>random</code>, the &quot;random effects&quot; part from the model
</p>
</li>
<li> <p><code>zero_inflated</code>, the &quot;fixed effects&quot; part from the zero-inflation component
of the model
</p>
</li>
<li> <p><code>zero_inflated_random</code>, the &quot;random effects&quot; part from the zero-inflation
component of the model
</p>
</li>
<li> <p><code>smooth_terms</code>, the smooth parameters
</p>
</li></ul>

<p>Furthermore, some models, especially from <strong>brms</strong>, can also return auxiliary
parameters. These may be one of the following:
</p>

<ul>
<li> <p><code>sigma</code>, the residual standard deviation (auxiliary parameter)
</p>
</li>
<li> <p><code>dispersion</code>, the dispersion parameters (auxiliary parameter)
</p>
</li>
<li> <p><code>beta</code>, the beta parameter (auxiliary parameter)
</p>
</li>
<li> <p><code>simplex</code>, simplex parameters of monotonic effects (<strong>brms</strong> only)
</p>
</li>
<li> <p><code>mix</code>, mixture parameters (<strong>brms</strong> only)
</p>
</li>
<li> <p><code>shiftprop</code>, shifted proportion parameters (<strong>brms</strong> only)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_parameters(m)
</code></pre>

<hr>
<h2 id='find_parameters.emmGrid'>Find model parameters from estimated marginal means objects</h2><span id='topic+find_parameters.emmGrid'></span>

<h3>Description</h3>

<p>Returns the parameter names from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emmGrid'
find_parameters(x, flatten = FALSE, merge_parameters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_parameters.emmGrid_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_parameters.emmGrid_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_parameters.emmGrid_+3A_merge_parameters">merge_parameters</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> has multiple columns for
parameter names (like <code>emmGrid</code> objects may have), these are merged into a
single parameter column, with parameters names and values as values.</p>
</td></tr>
<tr><td><code id="find_parameters.emmGrid_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter names. For simple models, only one list-element,
<code>conditional</code>, is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
model &lt;- lm(mpg ~ wt * factor(cyl), data = mtcars)
emm &lt;- emmeans(model, c("wt", "cyl"))
find_parameters(emm)

</code></pre>

<hr>
<h2 id='find_parameters.gamlss'>Find names of model parameters from generalized additive models</h2><span id='topic+find_parameters.gamlss'></span><span id='topic+find_parameters.gam'></span>

<h3>Description</h3>

<p>Returns the names of model parameters, like they typically
appear in the <code>summary()</code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
find_parameters(x, flatten = FALSE, ...)

## S3 method for class 'gam'
find_parameters(
  x,
  component = c("all", "conditional", "smooth_terms", "location"),
  flatten = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_parameters.gamlss_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_parameters.gamlss_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_parameters.gamlss_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="find_parameters.gamlss_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter names. The returned list may have following
elements:
</p>

<ul>
<li> <p><code>conditional</code>, the &quot;fixed effects&quot; part from the model.
</p>
</li>
<li> <p><code>smooth_terms</code>, the smooth parameters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_parameters(m)
</code></pre>

<hr>
<h2 id='find_parameters.glmmTMB'>Find names of model parameters from mixed models</h2><span id='topic+find_parameters.glmmTMB'></span><span id='topic+find_parameters.nlmerMod'></span><span id='topic+find_parameters.hglm'></span><span id='topic+find_parameters.merMod'></span>

<h3>Description</h3>

<p>Returns the names of model parameters, like they typically
appear in the <code>summary()</code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
find_parameters(
  x,
  effects = c("all", "fixed", "random"),
  component = c("all", "conditional", "zi", "zero_inflated", "dispersion"),
  flatten = FALSE,
  ...
)

## S3 method for class 'nlmerMod'
find_parameters(
  x,
  effects = c("all", "fixed", "random"),
  component = c("all", "conditional", "nonlinear"),
  flatten = FALSE,
  ...
)

## S3 method for class 'hglm'
find_parameters(
  x,
  effects = c("all", "fixed", "random"),
  component = c("all", "conditional", "dispersion"),
  flatten = FALSE,
  ...
)

## S3 method for class 'merMod'
find_parameters(x, effects = c("all", "fixed", "random"), flatten = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_parameters.glmmTMB_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_parameters.glmmTMB_+3A_effects">effects</code></td>
<td>
<p>Should parameters for fixed effects, random effects
or both be returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="find_parameters.glmmTMB_+3A_component">component</code></td>
<td>
<p>Which type of parameters to return, such as parameters for
the conditional model, the zero-inflated part of the model or the
dispersion term? Applies to models with zero-inflated and/or dispersion
formula. Note that the <em>conditional</em> component is also called
<em>count</em> or <em>mean</em> component, depending on the model. There are
three convenient shortcuts: <code>component = "all"</code> returns all possible
parameters. If <code>component = "location"</code>, location parameters such as
<code>conditional</code> or <code>zero_inflated</code> are returned (everything that
are fixed or random effects - depending on the <code>effects</code> argument -
but no auxiliary parameters). For <code>component = "distributional"</code> (or
<code>"auxiliary"</code>), components like <code>sigma</code> or <code>dispersion</code> (and
other auxiliary parameters) are returned.</p>
</td></tr>
<tr><td><code id="find_parameters.glmmTMB_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_parameters.glmmTMB_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter names. The returned list may have following
elements:
</p>

<ul>
<li> <p><code>conditional</code>, the &quot;fixed effects&quot; part from the model.
</p>
</li>
<li> <p><code>random</code>, the &quot;random effects&quot; part from the model.
</p>
</li>
<li> <p><code>zero_inflated</code>, the &quot;fixed effects&quot; part from the zero-inflation component
of the model.
</p>
</li>
<li> <p><code>zero_inflated_random</code>, the &quot;random effects&quot; part from the zero-inflation
component of the model.
</p>
</li>
<li> <p><code>dispersion</code>, the dispersion parameters (auxiliary parameter)
</p>
</li>
<li> <p><code>nonlinear</code>, the parameters from the nonlinear formula.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_parameters(m)
</code></pre>

<hr>
<h2 id='find_parameters.zeroinfl'>Find names of model parameters from zero-inflated models</h2><span id='topic+find_parameters.zeroinfl'></span><span id='topic+find_parameters.mhurdle'></span>

<h3>Description</h3>

<p>Returns the names of model parameters, like they typically
appear in the <code>summary()</code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zeroinfl'
find_parameters(
  x,
  component = c("all", "conditional", "zi", "zero_inflated"),
  flatten = FALSE,
  ...
)

## S3 method for class 'mhurdle'
find_parameters(
  x,
  component = c("all", "conditional", "zi", "zero_inflated", "infrequent_purchase", "ip",
    "auxiliary"),
  flatten = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_parameters.zeroinfl_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_parameters.zeroinfl_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="find_parameters.zeroinfl_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_parameters.zeroinfl_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter names. The returned list may have following
elements:
</p>

<ul>
<li> <p><code>conditional</code>, the &quot;fixed effects&quot; part from the model.
</p>
</li>
<li> <p><code>zero_inflated</code>, the &quot;fixed effects&quot; part from the zero-inflation
component of the model.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_parameters(m)
</code></pre>

<hr>
<h2 id='find_predictors'>Find names of model predictors</h2><span id='topic+find_predictors'></span><span id='topic+find_predictors.default'></span><span id='topic+find_predictors.afex_aov'></span>

<h3>Description</h3>

<p>Returns the names of the predictor variables for the
different parts of a model (like fixed or random effects, zero-inflated
component, ...). Unlike <code><a href="#topic+find_parameters">find_parameters()</a></code>, the names from
<code>find_predictors()</code> match the original variable names from the data
that was used to fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_predictors(x, ...)

## Default S3 method:
find_predictors(
  x,
  effects = c("fixed", "random", "all"),
  component = c("all", "conditional", "zi", "zero_inflated", "dispersion", "instruments",
    "correlation", "smooth_terms"),
  flatten = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'afex_aov'
find_predictors(
  x,
  effects = c("fixed", "random", "all"),
  component = c("all", "conditional", "zi", "zero_inflated", "dispersion", "instruments",
    "correlation", "smooth_terms"),
  flatten = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_predictors_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_predictors_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="find_predictors_+3A_effects">effects</code></td>
<td>
<p>Should variables for fixed effects, random effects
or both be returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="find_predictors_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="find_predictors_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_predictors_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors that represent the name(s) of the
predictor variables. Depending on the combination of the arguments
<code>effects</code> and <code>component</code>, the returned list has following elements:
</p>

<ul>
<li> <p><code>conditional</code>, the &quot;fixed effects&quot; terms from the model
</p>
</li>
<li> <p><code>random</code>, the &quot;random effects&quot; terms from the model
</p>
</li>
<li> <p><code>zero_inflated</code>, the &quot;fixed effects&quot; terms from the zero-inflation
component of the model
</p>
</li>
<li> <p><code>zero_inflated_random</code>, the &quot;random effects&quot; terms from the zero-inflation
component of the model
</p>
</li>
<li> <p><code>dispersion</code>, the dispersion terms
</p>
</li>
<li> <p><code>instruments</code>, for fixed-effects regressions like <code>ivreg</code>, <code>felm</code> or <code>plm</code>,
the instrumental variables
</p>
</li>
<li> <p><code>correlation</code>, for models with correlation-component like <code>gls</code>, the
variables used to describe the correlation structure
</p>
</li></ul>



<h3>Model components</h3>

<p>Possible values for the <code>component</code> argument depend on the model class.
Following are valid options:
</p>

<ul>
<li> <p><code>"all"</code>: returns all model components, applies to all models, but will only
have an effect for models with more than just the conditional model component.
</p>
</li>
<li> <p><code>"conditional"</code>: only returns the conditional component, i.e. &quot;fixed effects&quot;
terms from the model. Will only have an effect for models with more than
just the conditional model component.
</p>
</li>
<li> <p><code>"smooth_terms"</code>: returns smooth terms, only applies to GAMs (or similar
models that may contain smooth terms).
</p>
</li>
<li> <p><code>"zero_inflated"</code> (or <code>"zi"</code>): returns the zero-inflation component.
</p>
</li>
<li> <p><code>"dispersion"</code>: returns the dispersion model component. This is common
for models with zero-inflation or that can model the dispersion parameter.
</p>
</li>
<li> <p><code>"instruments"</code>: for instrumental-variable or some fixed effects regression,
returns the instruments.
</p>
</li>
<li> <p><code>"location"</code>: returns location parameters such as <code>conditional</code>,
<code>zero_inflated</code>, <code>smooth_terms</code>, or <code>instruments</code> (everything that are
fixed or random effects - depending on the <code>effects</code> argument - but no
auxiliary parameters).
</p>
</li>
<li> <p><code>"distributional"</code> (or <code>"auxiliary"</code>): components like <code>sigma</code>, <code>dispersion</code>,
<code>beta</code> or <code>precision</code> (and other auxiliary parameters) are returned.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_predictors(m)
</code></pre>

<hr>
<h2 id='find_random'>Find names of random effects</h2><span id='topic+find_random'></span>

<h3>Description</h3>

<p>Return the name of the grouping factors from mixed effects models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_random(x, split_nested = FALSE, flatten = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_random_+3A_x">x</code></td>
<td>
<p>A fitted mixed model.</p>
</td></tr>
<tr><td><code id="find_random_+3A_split_nested">split_nested</code></td>
<td>
<p>Logical, if <code>TRUE</code>, terms from nested random
effects will be returned as separated elements, not as single string
with colon. See 'Examples'.</p>
</td></tr>
<tr><td><code id="find_random_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors that represent the name(s) of the
random effects (grouping factors). Depending on the model, the
returned list has following elements:
</p>

<ul>
<li> <p><code>random</code>, the &quot;random effects&quot; terms from the conditional part of model
</p>
</li>
<li> <p><code>zero_inflated_random</code>, the &quot;random effects&quot; terms from the zero-inflation
component of the model
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(sleepstudy, package = "lme4")
sleepstudy$mygrp &lt;- sample(1:5, size = 180, replace = TRUE)
sleepstudy$mysubgrp &lt;- NA
for (i in 1:5) {
  filter_group &lt;- sleepstudy$mygrp == i
  sleepstudy$mysubgrp[filter_group] &lt;-
    sample(1:30, size = sum(filter_group), replace = TRUE)
}

m &lt;- lme4::lmer(
  Reaction ~ Days + (1 | mygrp / mysubgrp) + (1 | Subject),
  data = sleepstudy
)

find_random(m)
find_random(m, split_nested = TRUE)

</code></pre>

<hr>
<h2 id='find_random_slopes'>Find names of random slopes</h2><span id='topic+find_random_slopes'></span>

<h3>Description</h3>

<p>Return the name of the random slopes from mixed effects models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_random_slopes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_random_slopes_+3A_x">x</code></td>
<td>
<p>A fitted mixed model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors with the name(s) of the random slopes, or
<code>NULL</code> if model has no random slopes. Depending on the model, the returned
list has following elements:
</p>

<ul>
<li> <p><code>random</code>, the random slopes from the conditional part of model
</p>
</li>
<li> <p><code>zero_inflated_random</code>, the random slopes from the zero-inflation
component of the model
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(sleepstudy, package = "lme4")
m &lt;- lme4::lmer(Reaction ~ Days + (1 + Days | Subject), data = sleepstudy)
find_random_slopes(m)

</code></pre>

<hr>
<h2 id='find_response'>Find name of the response variable</h2><span id='topic+find_response'></span><span id='topic+find_response.mjoint'></span><span id='topic+find_response.joint'></span>

<h3>Description</h3>

<p>Returns the name(s) of the response variable(s) from a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_response(x, combine = TRUE, ...)

## S3 method for class 'mjoint'
find_response(
  x,
  combine = TRUE,
  component = c("conditional", "survival", "all"),
  ...
)

## S3 method for class 'joint'
find_response(
  x,
  combine = TRUE,
  component = c("conditional", "survival", "all"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_response_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_response_+3A_combine">combine</code></td>
<td>
<p>Logical, if <code>TRUE</code> and the response is a matrix-column,
the name of the response matches the notation in formula, and would for
instance also contain patterns like <code>"cbind(...)"</code>. Else, the original
variable names from the matrix-column are returned. See 'Examples'.</p>
</td></tr>
<tr><td><code id="find_response_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="find_response_+3A_component">component</code></td>
<td>
<p>Character, if <code>x</code> is a joint model, this argument can be
used to specify which component to return. Possible values are
<code>"conditional"</code>, <code>"survival"</code> or <code>"all"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name(s) of the response variable(s) from <code>x</code> as character
vector, or <code>NULL</code> if response variable could not be found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cbpp, package = "lme4")
cbpp$trials &lt;- cbpp$size - cbpp$incidence
m &lt;- glm(cbind(incidence, trials) ~ period, data = cbpp, family = binomial)

find_response(m, combine = TRUE)
find_response(m, combine = FALSE)

</code></pre>

<hr>
<h2 id='find_smooth'>Find smooth terms from a model object</h2><span id='topic+find_smooth'></span>

<h3>Description</h3>

<p>Return the names of smooth terms from a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_smooth(x, flatten = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_smooth_+3A_x">x</code></td>
<td>
<p>A (gam) model.</p>
</td></tr>
<tr><td><code id="find_smooth_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the name(s) of the smooth terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
model &lt;- mgcv::gam(Petal.Length ~ Petal.Width + s(Sepal.Length), data = iris)
find_smooth(model)

</code></pre>

<hr>
<h2 id='find_statistic'>Find statistic for model</h2><span id='topic+find_statistic'></span>

<h3>Description</h3>

<p>Returns the statistic for a regression model (<em>t</em>-statistic,
<em>z</em>-statistic, etc.).
</p>
<p>Small helper that checks if a model is a regression model
object and return the statistic used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_statistic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_statistic_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="find_statistic_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character describing the type of statistic. If there is no
statistic available with a distribution, <code>NULL</code> will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># regression model object
data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
find_statistic(m)
</code></pre>

<hr>
<h2 id='find_terms'>Find all model terms</h2><span id='topic+find_terms'></span><span id='topic+find_terms.default'></span>

<h3>Description</h3>

<p>Returns a list with the names of all terms, including response
value and random effects, &quot;as is&quot;. This means, on-the-fly tranformations
or arithmetic expressions like <code>log()</code>, <code>I()</code>, <code>as.factor()</code> etc. are
preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_terms(x, ...)

## Default S3 method:
find_terms(x, flatten = FALSE, as_term_labels = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_terms_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_terms_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="find_terms_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_terms_+3A_as_term_labels">as_term_labels</code></td>
<td>
<p>Logical, if <code>TRUE</code>, extracts model formula and tries to
access the <code>"term.labels"</code> attribute. This should better mimic the <code>terms()</code>
behaviour even for those models that do not have such a method, but may be
insufficient, e.g. for mixed models.</p>
</td></tr>
<tr><td><code id="find_terms_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with (depending on the model) following elements (character
vectors):
</p>

<ul>
<li> <p><code>response</code>, the name of the response variable
</p>
</li>
<li> <p><code>conditional</code>, the names of the predictor variables from the <em>conditional</em>
model (as opposed to the zero-inflated part of a model)
</p>
</li>
<li> <p><code>random</code>, the names of the random effects (grouping factors)
</p>
</li>
<li> <p><code>zero_inflated</code>, the names of the predictor variables from the <em>zero-inflated</em> part of the model
</p>
</li>
<li> <p><code>zero_inflated_random</code>, the names of the random effects (grouping factors)
</p>
</li>
<li> <p><code>dispersion</code>, the name of the dispersion terms
</p>
</li>
<li> <p><code>instruments</code>, the names of instrumental variables
</p>
</li></ul>

<p>Returns <code>NULL</code> if no terms could be found (for instance, due to
problems in accessing the formula).
</p>


<h3>Note</h3>

<p>The difference to <code><a href="#topic+find_variables">find_variables()</a></code> is that <code>find_terms()</code>
may return a variable multiple times in case of multiple transformations
(see examples below), while <code>find_variables()</code> returns each variable
name only once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sleepstudy, package = "lme4")
m &lt;- suppressWarnings(lme4::lmer(
  log(Reaction) ~ Days + I(Days^2) + (1 + Days + exp(Days) | Subject),
  data = sleepstudy
))

find_terms(m)

# sometimes, it is necessary to retrieve terms from "term.labels" attribute
m &lt;- lm(mpg ~ hp * (am + cyl), data = mtcars)
find_terms(m, as_term_labels = TRUE)

</code></pre>

<hr>
<h2 id='find_transformation'>Find possible transformation of response variables</h2><span id='topic+find_transformation'></span>

<h3>Description</h3>

<p>This functions checks whether any transformation, such as log-
or exp-transforming, was applied to the response variable (dependent
variable) in a regression formula. Currently, following patterns are
detected: <code>log</code>, <code>log1p</code>, <code>log2</code>, <code>log10</code>, <code>exp</code>, <code>expm1</code>, <code>sqrt</code>,
<code style="white-space: pre;">&#8288;log(x+&lt;number&gt;)&#8288;</code>, <code>log-log</code> and <code>power</code> (to 2nd power, like <code>I(x^2)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_transformation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_transformation_+3A_x">x</code></td>
<td>
<p>A regression model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string, with the name of the function of the applied transformation.
Returns <code>"identity"</code> for no transformation, and e.g. <code>"log(x+3)"</code> when
a specific values was added to the response variables before
log-transforming. For unknown transformations, returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># identity, no transformation
model &lt;- lm(Sepal.Length ~ Species, data = iris)
find_transformation(model)

# log-transformation
model &lt;- lm(log(Sepal.Length) ~ Species, data = iris)
find_transformation(model)

# log+2
model &lt;- lm(log(Sepal.Length + 2) ~ Species, data = iris)
find_transformation(model)
</code></pre>

<hr>
<h2 id='find_variables'>Find names of all variables</h2><span id='topic+find_variables'></span>

<h3>Description</h3>

<p>Returns a list with the names of all variables, including
response value and random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_variables(
  x,
  effects = "all",
  component = "all",
  flatten = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_variables_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_variables_+3A_effects">effects</code></td>
<td>
<p>Should variables for fixed effects, random effects
or both be returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="find_variables_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="find_variables_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
<tr><td><code id="find_variables_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with (depending on the model) following elements (character
vectors):
</p>

<ul>
<li> <p><code>response</code>, the name of the response variable
</p>
</li>
<li> <p><code>conditional</code>, the names of the predictor variables from the <em>conditional</em> model (as opposed to the zero-inflated part of a model)
</p>
</li>
<li> <p><code>cluster</code>, the names of cluster or grouping variables
</p>
</li>
<li> <p><code>dispersion</code>, the name of the dispersion terms
</p>
</li>
<li> <p><code>instruments</code>, the names of instrumental variables
</p>
</li>
<li> <p><code>random</code>, the names of the random effects (grouping factors)
</p>
</li>
<li> <p><code>zero_inflated</code>, the names of the predictor variables from the <em>zero-inflated</em> part of the model
</p>
</li>
<li> <p><code>zero_inflated_random</code>, the names of the random effects (grouping factors)
</p>
</li></ul>



<h3>Model components</h3>

<p>Possible values for the <code>component</code> argument depend on the model class.
Following are valid options:
</p>

<ul>
<li> <p><code>"all"</code>: returns all model components, applies to all models, but will only
have an effect for models with more than just the conditional model component.
</p>
</li>
<li> <p><code>"conditional"</code>: only returns the conditional component, i.e. &quot;fixed effects&quot;
terms from the model. Will only have an effect for models with more than
just the conditional model component.
</p>
</li>
<li> <p><code>"smooth_terms"</code>: returns smooth terms, only applies to GAMs (or similar
models that may contain smooth terms).
</p>
</li>
<li> <p><code>"zero_inflated"</code> (or <code>"zi"</code>): returns the zero-inflation component.
</p>
</li>
<li> <p><code>"dispersion"</code>: returns the dispersion model component. This is common
for models with zero-inflation or that can model the dispersion parameter.
</p>
</li>
<li> <p><code>"instruments"</code>: for instrumental-variable or some fixed effects regression,
returns the instruments.
</p>
</li>
<li> <p><code>"location"</code>: returns location parameters such as <code>conditional</code>,
<code>zero_inflated</code>, <code>smooth_terms</code>, or <code>instruments</code> (everything that are
fixed or random effects - depending on the <code>effects</code> argument - but no
auxiliary parameters).
</p>
</li>
<li> <p><code>"distributional"</code> (or <code>"auxiliary"</code>): components like <code>sigma</code>, <code>dispersion</code>,
<code>beta</code> or <code>precision</code> (and other auxiliary parameters) are returned.
</p>
</li></ul>



<h3>Note</h3>

<p>The difference to <code><a href="#topic+find_terms">find_terms()</a></code> is that
<code>find_variables()</code> returns each variable name only once, while
<code>find_terms()</code> may return a variable multiple times in case of
transformations or when arithmetic expressions were used in the formula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cbpp, package = "lme4")
data(sleepstudy, package = "lme4")
# some data preparation...
cbpp$trials &lt;- cbpp$size - cbpp$incidence
sleepstudy$mygrp &lt;- sample(1:5, size = 180, replace = TRUE)
sleepstudy$mysubgrp &lt;- NA
for (i in 1:5) {
  filter_group &lt;- sleepstudy$mygrp == i
  sleepstudy$mysubgrp[filter_group] &lt;-
    sample(1:30, size = sum(filter_group), replace = TRUE)
}

m1 &lt;- lme4::glmer(
  cbind(incidence, size - incidence) ~ period + (1 | herd),
  data = cbpp,
  family = binomial
)
find_variables(m1)

m2 &lt;- lme4::lmer(
  Reaction ~ Days + (1 | mygrp / mysubgrp) + (1 | Subject),
  data = sleepstudy
)
find_variables(m2)
find_variables(m2, flatten = TRUE)

</code></pre>

<hr>
<h2 id='find_weights'>Find names of model weights</h2><span id='topic+find_weights'></span>

<h3>Description</h3>

<p>Returns the name of the variable that describes the weights of a
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_weights(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_weights_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="find_weights_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the weighting variable as character vector, or <code>NULL</code>
if no weights were specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
mtcars$weight &lt;- rnorm(nrow(mtcars), 1, .3)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars, weights = weight)
find_weights(m)
</code></pre>

<hr>
<h2 id='fish'>Sample data set</h2><span id='topic+fish'></span>

<h3>Description</h3>

<p>A sample data set, used in tests and some examples.
</p>

<hr>
<h2 id='format_bf'>Bayes Factor formatting</h2><span id='topic+format_bf'></span>

<h3>Description</h3>

<p>Bayes Factor formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_bf(
  bf,
  stars = FALSE,
  stars_only = FALSE,
  name = "BF",
  protect_ratio = FALSE,
  na_reference = NA,
  exact = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_bf_+3A_bf">bf</code></td>
<td>
<p>Bayes Factor.</p>
</td></tr>
<tr><td><code id="format_bf_+3A_stars">stars</code></td>
<td>
<p>Add significance stars (e.g., p &lt; .001***).</p>
</td></tr>
<tr><td><code id="format_bf_+3A_stars_only">stars_only</code></td>
<td>
<p>Return only significance stars.</p>
</td></tr>
<tr><td><code id="format_bf_+3A_name">name</code></td>
<td>
<p>Name prefixing the text. Can be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="format_bf_+3A_protect_ratio">protect_ratio</code></td>
<td>
<p>Should values smaller than 1 be represented as ratios?</p>
</td></tr>
<tr><td><code id="format_bf_+3A_na_reference">na_reference</code></td>
<td>
<p>How to format missing values (<code>NA</code>).</p>
</td></tr>
<tr><td><code id="format_bf_+3A_exact">exact</code></td>
<td>
<p>Should very large or very small values be reported with a
scientific format (e.g., 4.24e5), or as truncated values (as &quot;&gt; 1000&quot; and
&quot;&lt; 1/1000&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_bf(bfs &lt;- c(0.000045, 0.033, NA, 1557, 3.54))
format_bf(bfs, exact = TRUE, name = NULL)
format_bf(bfs, stars = TRUE)
format_bf(bfs, protect_ratio = TRUE)
format_bf(bfs, protect_ratio = TRUE, exact = TRUE)
format_bf(bfs, na_reference = 1)
</code></pre>

<hr>
<h2 id='format_capitalize'>Capitalizes the first letter in a string</h2><span id='topic+format_capitalize'></span>

<h3>Description</h3>

<p>This function converts the first letter in a string into upper case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_capitalize(x, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_capitalize_+3A_x">x</code></td>
<td>
<p>A character vector or a factor. The latter is coerced to character.
All other objects are returned unchanged.</p>
</td></tr>
<tr><td><code id="format_capitalize_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, with first letter capitalized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_capitalize("hello")
format_capitalize(c("hello", "world"))
unique(format_capitalize(iris$Species))
</code></pre>

<hr>
<h2 id='format_ci'>Confidence/Credible Interval (CI) Formatting</h2><span id='topic+format_ci'></span><span id='topic+format_ci.numeric'></span>

<h3>Description</h3>

<p>Confidence/Credible Interval (CI) Formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_ci(CI_low, ...)

## S3 method for class 'numeric'
format_ci(
  CI_low,
  CI_high,
  ci = 0.95,
  digits = 2,
  brackets = TRUE,
  width = NULL,
  width_low = width,
  width_high = width,
  missing = "",
  zap_small = FALSE,
  ci_string = "CI",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_ci_+3A_ci_low">CI_low</code></td>
<td>
<p>Lower CI bound. Usually a numeric value, but can also be a
CI output returned <code>bayestestR</code>, in which case the remaining arguments
are unnecessary.</p>
</td></tr>
<tr><td><code id="format_ci_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="format_ci_+3A_ci_high">CI_high</code></td>
<td>
<p>Upper CI bound.</p>
</td></tr>
<tr><td><code id="format_ci_+3A_ci">ci</code></td>
<td>
<p>CI level in percentage.</p>
</td></tr>
<tr><td><code id="format_ci_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding or significant figures. May also
be <code>"signif"</code> to return significant figures or <code>"scientific"</code>
to return scientific notation. Control the number of digits by adding the
value as suffix, e.g. <code>digits = "scientific4"</code> to have scientific
notation with 4 decimal places, or <code>digits = "signif5"</code> for 5
significant figures (see also <code><a href="base.html#topic+signif">signif()</a></code>).</p>
</td></tr>
<tr><td><code id="format_ci_+3A_brackets">brackets</code></td>
<td>
<p>Either a logical, and if <code>TRUE</code> (default), values are
encompassed in square brackets. If <code>FALSE</code> or <code>NULL</code>, no brackets
are used. Else, a character vector of length two, indicating the opening
and closing brackets.</p>
</td></tr>
<tr><td><code id="format_ci_+3A_width">width</code></td>
<td>
<p>Minimum width of the returned string. If not <code>NULL</code> and
<code>width</code> is larger than the string's length, leading whitespaces are
added to the string. If <code>width="auto"</code>, width will be set to the
length of the longest string.</p>
</td></tr>
<tr><td><code id="format_ci_+3A_width_low">width_low</code>, <code id="format_ci_+3A_width_high">width_high</code></td>
<td>
<p>Like <code>width</code>, but only applies to the lower
or higher confidence interval value. This can be used when the values for
the lower and upper CI are of very different length.</p>
</td></tr>
<tr><td><code id="format_ci_+3A_missing">missing</code></td>
<td>
<p>Value by which <code>NA</code> values are replaced. By default, an
empty string (i.e. <code>""</code>) is returned for <code>NA</code>.</p>
</td></tr>
<tr><td><code id="format_ci_+3A_zap_small">zap_small</code></td>
<td>
<p>Logical, if <code>TRUE</code>, small values are rounded after
<code>digits</code> decimal places. If <code>FALSE</code>, values with more decimal
places than <code>digits</code> are printed in scientific notation.</p>
</td></tr>
<tr><td><code id="format_ci_+3A_ci_string">ci_string</code></td>
<td>
<p>String to be used in the output to indicate the type of
interval. Default is <code>"CI"</code>, but can be changed to <code>"HDI"</code> or anything else,
if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_ci(1.20, 3.57, ci = 0.90)
format_ci(1.20, 3.57, ci = NULL)
format_ci(1.20, 3.57, ci = NULL, brackets = FALSE)
format_ci(1.20, 3.57, ci = NULL, brackets = c("(", ")"))
format_ci(c(1.205645, 23.4), c(3.57, -1.35), ci = 0.90)
format_ci(c(1.20, NA, NA), c(3.57, -1.35, NA), ci = 0.90)

# automatic alignment of width, useful for printing multiple CIs in columns
x &lt;- format_ci(c(1.205, 23.4, 100.43), c(3.57, -13.35, 9.4))
cat(x, sep = "\n")

x &lt;- format_ci(c(1.205, 23.4, 100.43), c(3.57, -13.35, 9.4), width = "auto")
cat(x, sep = "\n")
</code></pre>

<hr>
<h2 id='format_message'>Format messages and warnings</h2><span id='topic+format_message'></span><span id='topic+format_alert'></span><span id='topic+format_warning'></span><span id='topic+format_error'></span>

<h3>Description</h3>

<p>Inserts line breaks into a longer message or warning string.
Line length is adjusted to maximum length of the console, if the width
can be accessed. By default, new lines are indented by two spaces.
</p>
<p><code>format_alert()</code> is a wrapper that combines formatting a string with a
call to <code>message()</code>, <code>warning()</code> or <code>stop()</code>. By default, <code>format_alert()</code>
creates a <code>message()</code>. <code>format_warning()</code> and <code>format_error()</code> change the
default type of exception to <code>warning()</code> and <code>stop()</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_message(
  string,
  ...,
  line_length = 0.9 * getOption("width", 80),
  indent = "  "
)

format_alert(
  string,
  ...,
  line_length = 0.9 * getOption("width", 80),
  indent = "  ",
  type = "message",
  call. = FALSE
)

format_warning(...)

format_error(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_message_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="format_message_+3A_...">...</code></td>
<td>
<p>Further strings that will be concatenated as indented new lines.</p>
</td></tr>
<tr><td><code id="format_message_+3A_line_length">line_length</code></td>
<td>
<p>Numeric, the maximum length of a line.
The default is 90% of the width of the console window.</p>
</td></tr>
<tr><td><code id="format_message_+3A_indent">indent</code></td>
<td>
<p>Character vector. If further lines are specified in <code>...</code>, a
user-defined string can be specified to indent subsequent lines. Defaults to
<code>"  "</code> (two white spaces), hence for each start of the line after the first
line, two white space characters are inserted.</p>
</td></tr>
<tr><td><code id="format_message_+3A_type">type</code></td>
<td>
<p>Type of exception alert to raise.
Can be <code>"message"</code> for <code>message()</code>, <code>"warning"</code> for <code>warning()</code>,
or <code>"error"</code> for <code>stop()</code>.</p>
</td></tr>
<tr><td><code id="format_message_+3A_call.">call.</code></td>
<td>
<p>Logical. Indicating if the call should be included in the the
error message. This is usually confusing for users when the function
producing the warning or error is deep within another function, so the
default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is an experimental formatting feature implemented in this function.
You can use following tags:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;{.b text}&#8288;</code> for bold formatting
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;{.i text}&#8288;</code> to use italic font style
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;{.url www.url.com}&#8288;</code> formats the string as URL (i.e., enclosing URL in
<code>&lt;</code> and <code>&gt;</code>, blue color and italic font style)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;{.pkg packagename}&#8288;</code> formats the text in blue color.
</p>
</li></ul>

<p>This features has some limitations: it's hard to detect the exact length for
each line when the string has multiple lines (after line breaks) and the
string contains formatting tags. Thus, it can happen that lines are wrapped at
an earlier length than expected. Furthermore, if you have multiple words in a
format tag (<code style="white-space: pre;">&#8288;{.b one two three}&#8288;</code>), a line break might occur inside this tag,
and the formatting no longer works (messing up the message-string).
</p>


<h3>Value</h3>

<p>For <code>format_message()</code>, a formatted string.
For <code>format_alert()</code> and related functions, the requested exception,
with the exception formatted using <code>format_message()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msg &lt;- format_message("Much too long string for just one line, I guess!",
  line_length = 15
)
message(msg)

msg &lt;- format_message("Much too long string for just one line, I guess!",
  "First new line",
  "Second new line",
  "(both indented)",
  line_length = 30
)
message(msg)

msg &lt;- format_message("Much too long string for just one line, I guess!",
  "First new line",
  "Second new line",
  "(not indented)",
  line_length = 30,
  indent = ""
)
message(msg)

# Caution, experimental! See 'Details'
msg &lt;- format_message(
  "This is {.i italic}, visit {.url easystats.github.io/easystats}",
  line_length = 30
)
message(msg)


# message
format_alert("This is a message.")
format_alert("This is a warning.", type = "message")

# error
try(format_error("This is an error."))


# warning
format_warning("This is a warning.")

</code></pre>

<hr>
<h2 id='format_number'>Convert number to words</h2><span id='topic+format_number'></span>

<h3>Description</h3>

<p>Convert number to words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_number(x, textual = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_number_+3A_x">x</code></td>
<td>
<p>Number.</p>
</td></tr>
<tr><td><code id="format_number_+3A_textual">textual</code></td>
<td>
<p>Return words. If <code>FALSE</code>, will run <code><a href="#topic+format_value">format_value()</a></code>.</p>
</td></tr>
<tr><td><code id="format_number_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+format_value">format_value()</a></code> if <code>textual</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string.
</p>


<h3>Note</h3>

<p>The code has been adapted from here https://github.com/ateucher/useful_code/blob/master/R/numbers2words.r
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_number(2)
format_number(45)
format_number(324.68765)
</code></pre>

<hr>
<h2 id='format_p'>p-values formatting</h2><span id='topic+format_p'></span>

<h3>Description</h3>

<p>Format p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_p(
  p,
  stars = FALSE,
  stars_only = FALSE,
  whitespace = TRUE,
  name = "p",
  missing = "",
  decimal_separator = NULL,
  digits = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_p_+3A_p">p</code></td>
<td>
<p>value or vector of p-values.</p>
</td></tr>
<tr><td><code id="format_p_+3A_stars">stars</code></td>
<td>
<p>Add significance stars (e.g., p &lt; .001***).</p>
</td></tr>
<tr><td><code id="format_p_+3A_stars_only">stars_only</code></td>
<td>
<p>Return only significance stars.</p>
</td></tr>
<tr><td><code id="format_p_+3A_whitespace">whitespace</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), preserves whitespaces. Else,
all whitespace characters are removed from the returned string.</p>
</td></tr>
<tr><td><code id="format_p_+3A_name">name</code></td>
<td>
<p>Name prefixing the text. Can be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="format_p_+3A_missing">missing</code></td>
<td>
<p>Value by which <code>NA</code> values are replaced. By default, an
empty string (i.e. <code>""</code>) is returned for <code>NA</code>.</p>
</td></tr>
<tr><td><code id="format_p_+3A_decimal_separator">decimal_separator</code></td>
<td>
<p>Character, if not <code>NULL</code>, will be used as
decimal separator.</p>
</td></tr>
<tr><td><code id="format_p_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits. May also be <code>"scientific"</code>
to return exact p-values in scientific notation, or <code>"apa"</code> to use
an APA 7th edition-style for p-values (equivalent to <code>digits = 3</code>).
If <code>"scientific"</code>, control the number of digits by adding the value as
a suffix, e.g.m <code>digits = "scientific4"</code> to have scientific notation
with 4 decimal places.</p>
</td></tr>
<tr><td><code id="format_p_+3A_...">...</code></td>
<td>
<p>Arguments from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_p(c(.02, .065, 0, .23))
format_p(c(.02, .065, 0, .23), name = NULL)
format_p(c(.02, .065, 0, .23), stars_only = TRUE)

model &lt;- lm(mpg ~ wt + cyl, data = mtcars)
p &lt;- coef(summary(model))[, 4]
format_p(p, digits = "apa")
format_p(p, digits = "scientific")
format_p(p, digits = "scientific2")
</code></pre>

<hr>
<h2 id='format_pd'>Probability of direction (pd) formatting</h2><span id='topic+format_pd'></span>

<h3>Description</h3>

<p>Probability of direction (pd) formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_pd(pd, stars = FALSE, stars_only = FALSE, name = "pd")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_pd_+3A_pd">pd</code></td>
<td>
<p>Probability of direction (pd).</p>
</td></tr>
<tr><td><code id="format_pd_+3A_stars">stars</code></td>
<td>
<p>Add significance stars (e.g., p &lt; .001***).</p>
</td></tr>
<tr><td><code id="format_pd_+3A_stars_only">stars_only</code></td>
<td>
<p>Return only significance stars.</p>
</td></tr>
<tr><td><code id="format_pd_+3A_name">name</code></td>
<td>
<p>Name prefixing the text. Can be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_pd(0.12)
format_pd(c(0.12, 1, 0.9999, 0.98, 0.995, 0.96), name = NULL)
format_pd(c(0.12, 1, 0.9999, 0.98, 0.995, 0.96), stars = TRUE)
</code></pre>

<hr>
<h2 id='format_rope'>Percentage in ROPE formatting</h2><span id='topic+format_rope'></span>

<h3>Description</h3>

<p>Percentage in ROPE formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_rope(rope_percentage, name = "in ROPE", digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_rope_+3A_rope_percentage">rope_percentage</code></td>
<td>
<p>Value or vector of percentages in ROPE.</p>
</td></tr>
<tr><td><code id="format_rope_+3A_name">name</code></td>
<td>
<p>Name prefixing the text. Can be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="format_rope_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits. May also be <code>"scientific"</code>
to return exact p-values in scientific notation, or <code>"apa"</code> to use
an APA 7th edition-style for p-values (equivalent to <code>digits = 3</code>).
If <code>"scientific"</code>, control the number of digits by adding the value as
a suffix, e.g.m <code>digits = "scientific4"</code> to have scientific notation
with 4 decimal places.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_rope(c(0.02, 0.12, 0.357, 0))
format_rope(c(0.02, 0.12, 0.357, 0), name = NULL)
</code></pre>

<hr>
<h2 id='format_string'>String Values Formatting</h2><span id='topic+format_string'></span><span id='topic+format_string.character'></span>

<h3>Description</h3>

<p>String Values Formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_string(x, ...)

## S3 method for class 'character'
format_string(x, length = NULL, abbreviate = "...", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_string_+3A_x">x</code></td>
<td>
<p>String value.</p>
</td></tr>
<tr><td><code id="format_string_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="format_string_+3A_length">length</code></td>
<td>
<p>Numeric, maximum length of the returned string. If not
<code>NULL</code>, will shorten the string to a maximum <code>length</code>, however,
it will not truncate inside words. I.e. if the string length happens to be
inside a word, this word is removed from the returned string, so the
returned string has a <em>maximum</em> length of <code>length</code>, but might be
shorter.</p>
</td></tr>
<tr><td><code id="format_string_+3A_abbreviate">abbreviate</code></td>
<td>
<p>String that will be used as suffix, if <code>x</code> was
shortened.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- "This can be considered as very long string!"
# string is shorter than max.length, so returned as is
format_string(s, 60)

# string is shortened to as many words that result in
# a string of maximum 20 chars
format_string(s, 20)
</code></pre>

<hr>
<h2 id='format_table'>Parameter table formatting</h2><span id='topic+format_table'></span>

<h3>Description</h3>

<p>This functions takes a data frame with model parameters as input
and formats certain columns into a more readable layout (like collapsing
separate columns for lower and upper confidence interval values). Furthermore,
column names are formatted as well. Note that <code>format_table()</code>
converts all columns into character vectors!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_table(
  x,
  pretty_names = TRUE,
  stars = FALSE,
  digits = 2,
  ci_width = "auto",
  ci_brackets = TRUE,
  ci_digits = 2,
  p_digits = 3,
  rope_digits = 2,
  ic_digits = 1,
  zap_small = FALSE,
  preserve_attributes = FALSE,
  exact = TRUE,
  use_symbols = getOption("insight_use_symbols", FALSE),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_table_+3A_x">x</code></td>
<td>
<p>A data frame of model's parameters, as returned by various functions
of the <strong>easystats</strong>-packages. May also be a result from
<code>broom::tidy()</code>.</p>
</td></tr>
<tr><td><code id="format_table_+3A_pretty_names">pretty_names</code></td>
<td>
<p>Return &quot;pretty&quot; (i.e. more human readable) parameter
names.</p>
</td></tr>
<tr><td><code id="format_table_+3A_stars">stars</code></td>
<td>
<p>If <code>TRUE</code>, add significance stars (e.g., <code style="white-space: pre;">&#8288;p &lt; .001***&#8288;</code>). Can
also be a character vector, naming the columns that should include stars
for significant values. This is especially useful for Bayesian models,
where we might have multiple columns with significant values, e.g. <code>BF</code>
for the Bayes factor or <code>pd</code> for the probability of direction. In such
cases, use <code>stars = c("pd", "BF")</code> to add stars to both columns, or
<code>stars = "BF"</code> to only add stars to the Bayes factor and exclude the <code>pd</code>
column. Currently, following columns are recognized: <code>"BF"</code>, <code>"pd"</code> and <code>"p"</code>.</p>
</td></tr>
<tr><td><code id="format_table_+3A_digits">digits</code>, <code id="format_table_+3A_ci_digits">ci_digits</code>, <code id="format_table_+3A_p_digits">p_digits</code>, <code id="format_table_+3A_rope_digits">rope_digits</code>, <code id="format_table_+3A_ic_digits">ic_digits</code></td>
<td>
<p>Number of digits for
rounding or significant figures. May also be <code>"signif"</code> to return significant
figures or <code>"scientific"</code> to return scientific notation. Control the
number of digits by adding the value as suffix, e.g. <code>digits = "scientific4"</code>
to have scientific notation with 4 decimal places, or <code>digits = "signif5"</code>
for 5 significant figures (see also <code><a href="base.html#topic+signif">signif()</a></code>).</p>
</td></tr>
<tr><td><code id="format_table_+3A_ci_width">ci_width</code></td>
<td>
<p>Minimum width of the returned string for confidence
intervals. If not <code>NULL</code> and width is larger than the string's length,
leading whitespaces are added to the string. If <code>width="auto"</code>, width
will be set to the length of the longest string.</p>
</td></tr>
<tr><td><code id="format_table_+3A_ci_brackets">ci_brackets</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), CI-values are
encompassed in square brackets (else in parentheses).</p>
</td></tr>
<tr><td><code id="format_table_+3A_zap_small">zap_small</code></td>
<td>
<p>Logical, if <code>TRUE</code>, small values are rounded after
<code>digits</code> decimal places. If <code>FALSE</code>, values with more decimal
places than <code>digits</code> are printed in scientific notation.</p>
</td></tr>
<tr><td><code id="format_table_+3A_preserve_attributes">preserve_attributes</code></td>
<td>
<p>Logical, if <code>TRUE</code>, preserves all attributes
from the input data frame.</p>
</td></tr>
<tr><td><code id="format_table_+3A_exact">exact</code></td>
<td>
<p>Formatting for Bayes factor columns, in case the provided data
frame contains such a column (i.e. columns named <code>"BF"</code> or <code>"log_BF"</code>).
For <code>exact = TRUE</code>, very large or very small values are then either reported
with a scientific format (e.g., 4.24e5), else as truncated values (as &quot;&gt; 1000&quot;
and &quot;&lt; 1/1000&quot;).</p>
</td></tr>
<tr><td><code id="format_table_+3A_use_symbols">use_symbols</code></td>
<td>
<p>Logical, if <code>TRUE</code>, column names that refer to particular
effectsizes (like Phi, Omega or Epsilon) include the related unicode-character
instead of the written name. This only works on Windows for R &gt;= 4.2, and on
OS X or Linux for R &gt;= 4.0. It is possible to define a global option for this
setting, see 'Note'.</p>
</td></tr>
<tr><td><code id="format_table_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="format_table_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame. Note that <code>format_table()</code> converts all columns
into character vectors!
</p>


<h3>Note</h3>

<p><code>options(insight_use_symbols = TRUE)</code> override the <code>use_symbols</code> argument
and always displays symbols, if possible.
</p>


<h3>See Also</h3>

<p>Vignettes
<a href="https://easystats.github.io/insight/articles/display.html">Formatting, printing and exporting tables</a>
and <a href="https://easystats.github.io/parameters/articles/model_parameters_formatting.html">Formatting model parameters</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
format_table(head(iris), digits = 1)

m &lt;- lm(Sepal.Length ~ Species * Sepal.Width, data = iris)
x &lt;- parameters::model_parameters(m)
as.data.frame(format_table(x))
as.data.frame(format_table(x, p_digits = "scientific"))


model &lt;- rstanarm::stan_glm(
  Sepal.Length ~ Species,
  data = iris,
  refresh = 0,
  seed = 123
)
x &lt;- parameters::model_parameters(model, ci = c(0.69, 0.89, 0.95))
as.data.frame(format_table(x))


</code></pre>

<hr>
<h2 id='format_value'>Numeric Values Formatting</h2><span id='topic+format_value'></span><span id='topic+format_value.data.frame'></span><span id='topic+format_value.numeric'></span><span id='topic+format_percent'></span>

<h3>Description</h3>

<p><code>format_value()</code> converts numeric values into formatted string values, where
formatting can be something like rounding digits, scientific notation etc.
<code>format_percent()</code> is a short-cut for <code>format_value(as_percent = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_value(x, ...)

## S3 method for class 'data.frame'
format_value(
  x,
  digits = 2,
  protect_integers = FALSE,
  missing = "",
  width = NULL,
  as_percent = FALSE,
  zap_small = FALSE,
  lead_zero = TRUE,
  style_positive = "none",
  style_negative = "hyphen",
  ...
)

## S3 method for class 'numeric'
format_value(
  x,
  digits = 2,
  protect_integers = FALSE,
  missing = "",
  width = NULL,
  as_percent = FALSE,
  zap_small = FALSE,
  lead_zero = TRUE,
  style_positive = "none",
  style_negative = "hyphen",
  ...
)

format_percent(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_value_+3A_x">x</code></td>
<td>
<p>Numeric value.</p>
</td></tr>
<tr><td><code id="format_value_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="format_value_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding or significant figures. May also
be <code>"signif"</code> to return significant figures or <code>"scientific"</code>
to return scientific notation. Control the number of digits by adding the
value as suffix, e.g. <code>digits = "scientific4"</code> to have scientific
notation with 4 decimal places, or <code>digits = "signif5"</code> for 5
significant figures (see also <code><a href="base.html#topic+signif">signif()</a></code>).</p>
</td></tr>
<tr><td><code id="format_value_+3A_protect_integers">protect_integers</code></td>
<td>
<p>Should integers be kept as integers (i.e., without
decimals)?</p>
</td></tr>
<tr><td><code id="format_value_+3A_missing">missing</code></td>
<td>
<p>Value by which <code>NA</code> values are replaced. By default, an
empty string (i.e. <code>""</code>) is returned for <code>NA</code>.</p>
</td></tr>
<tr><td><code id="format_value_+3A_width">width</code></td>
<td>
<p>Minimum width of the returned string. If not <code>NULL</code> and
<code>width</code> is larger than the string's length, leading whitespaces are
added to the string.</p>
</td></tr>
<tr><td><code id="format_value_+3A_as_percent">as_percent</code></td>
<td>
<p>Logical, if <code>TRUE</code>, value is formatted as percentage
value.</p>
</td></tr>
<tr><td><code id="format_value_+3A_zap_small">zap_small</code></td>
<td>
<p>Logical, if <code>TRUE</code>, small values are rounded after
<code>digits</code> decimal places. If <code>FALSE</code>, values with more decimal
places than <code>digits</code> are printed in scientific notation.</p>
</td></tr>
<tr><td><code id="format_value_+3A_lead_zero">lead_zero</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), includes leading zeros, else
leading zeros are dropped.</p>
</td></tr>
<tr><td><code id="format_value_+3A_style_positive">style_positive</code></td>
<td>
<p>A string that determines the style of positive numbers.
May be <code>"none"</code> (default), <code>"plus"</code> to add a plus-sign or <code>"space"</code> to
precede the string by a Unicode &quot;figure space&quot;, i.e., a space equally as
wide as a number or <code>+</code>.</p>
</td></tr>
<tr><td><code id="format_value_+3A_style_negative">style_negative</code></td>
<td>
<p>A string that determines the style of negative numbers.
May be <code>"hyphen"</code> (default), <code>"minus"</code> for a proper Unicode minus symbol or
<code>"parens"</code> to wrap the number in parentheses.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_value(1.20)
format_value(1.2)
format_value(1.2012313)
format_value(c(0.0045, 234, -23))
format_value(c(0.0045, .12, .34))
format_value(c(0.0045, .12, .34), as_percent = TRUE)
format_value(c(0.0045, .12, .34), digits = "scientific")
format_value(c(0.0045, .12, .34), digits = "scientific2")
format_value(c(0.045, .12, .34), lead_zero = FALSE)

# default
format_value(c(0.0045, .123, .345))
# significant figures
format_value(c(0.0045, .123, .345), digits = "signif")

format_value(as.factor(c("A", "B", "A")))
format_value(iris$Species)

format_value(3)
format_value(3, protect_integers = TRUE)

format_value(head(iris))
</code></pre>

<hr>
<h2 id='get_auxiliary'>Get auxiliary parameters from models</h2><span id='topic+get_auxiliary'></span>

<h3>Description</h3>

<p>Returns the requested auxiliary parameters from models, like
dispersion, sigma, or beta...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_auxiliary(
  x,
  type = "sigma",
  summary = TRUE,
  centrality = "mean",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_auxiliary_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="get_auxiliary_+3A_type">type</code></td>
<td>
<p>The name of the auxiliary parameter that should be retrieved.
<code>"sigma"</code> is available for most models, <code>"dispersion"</code> for models
of class <code>glm</code>, <code>glmerMod</code> or <code>glmmTMB</code> as well as <code>brmsfit</code>.
<code>"beta"</code> and other parameters are currently only returned for <code>brmsfit</code>
models. See 'Details'.</p>
</td></tr>
<tr><td><code id="get_auxiliary_+3A_summary">summary</code></td>
<td>
<p>Logical, indicates whether the full posterior samples
(<code>summary = FALSE</code>)) or the summarized centrality indices of
the posterior samples (<code>summary = TRUE</code>)) should be returned as
estimates.</p>
</td></tr>
<tr><td><code id="get_auxiliary_+3A_centrality">centrality</code></td>
<td>
<p>Only for models with posterior samples, and when
<code>summary = TRUE</code>. In this case, <code>centrality = "mean"</code> would
calculate means of posterior samples for each parameter, while
<code>centrality = "median"</code> would use the more robust median value as
measure of central tendency.</p>
</td></tr>
<tr><td><code id="get_auxiliary_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="get_auxiliary_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only sigma and the dispersion parameter are returned, and
only for a limited set of models.
</p>


<h4>Sigma Parameter</h4>

<p>See <code><a href="#topic+get_sigma">get_sigma()</a></code>.
</p>



<h4>Dispersion Parameter</h4>

<p>There are many different definitions of &quot;dispersion&quot;, depending on the context.
<code>get_auxiliary()</code> returns the dispersion parameters that usually can
be considered as variance-to-mean ratio for generalized (linear) mixed
models. Exceptions are models of class <code>glmmTMB</code>, where the dispersion
equals &sigma;<sup>2</sup>.
In detail, the computation of the dispersion parameter for generalized linear
models is the ratio of the sum of the squared working-residuals and the
residual degrees of freedom. For mixed models of class <code>glmer</code>, the
dispersion parameter is also called &phi;
and is the ratio of the sum of the squared Pearson-residuals and the residual
degrees of freedom. For models of class <code>glmmTMB</code>, dispersion is
&sigma;<sup>2</sup>.
</p>



<h4><strong>brms</strong> models</h4>

<p>For models of class <code>brmsfit</code>, there are different options for the
<code>type</code> argument. See a list of supported auxiliary parameters here:
<code><a href="#topic+find_parameters.BGGM">find_parameters.BGGM()</a></code>.
</p>



<h3>Value</h3>

<p>The requested auxiliary parameter, or <code>NULL</code> if this information
could not be accessed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># from ?glm
clotting &lt;- data.frame(
  u = c(5, 10, 15, 20, 30, 40, 60, 80, 100),
  lot1 = c(118, 58, 42, 35, 27, 25, 21, 19, 18),
  lot2 = c(69, 35, 26, 21, 18, 16, 13, 12, 12)
)
model &lt;- glm(lot1 ~ log(u), data = clotting, family = Gamma())
get_auxiliary(model, type = "dispersion") # same as summary(model)$dispersion
</code></pre>

<hr>
<h2 id='get_call'>Get the model's function call</h2><span id='topic+get_call'></span>

<h3>Description</h3>

<p>Returns the model's function call when available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_call(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_call_+3A_x">x</code></td>
<td>
<p>A fitted mixed model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_call(m)

m &lt;- lme4::lmer(Sepal.Length ~ Sepal.Width + (1 | Species), data = iris)
get_call(m)

</code></pre>

<hr>
<h2 id='get_data'>Get the data that was used to fit the model</h2><span id='topic+get_data'></span><span id='topic+get_data.default'></span><span id='topic+get_data.glmmTMB'></span><span id='topic+get_data.afex_aov'></span><span id='topic+get_data.rma'></span>

<h3>Description</h3>

<p>This functions tries to get the data that was used to fit the
model and returns it as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(x, ...)

## Default S3 method:
get_data(x, source = "environment", verbose = TRUE, ...)

## S3 method for class 'glmmTMB'
get_data(
  x,
  effects = "all",
  component = "all",
  source = "environment",
  verbose = TRUE,
  ...
)

## S3 method for class 'afex_aov'
get_data(x, shape = c("long", "wide"), ...)

## S3 method for class 'rma'
get_data(
  x,
  source = "environment",
  verbose = TRUE,
  include_interval = FALSE,
  transf = NULL,
  transf_args = NULL,
  ci = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_data_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_data_+3A_source">source</code></td>
<td>
<p>String, indicating from where data should be recovered. If
<code>source = "environment"</code> (default), data is recovered from the environment
(e.g. if the data is in the workspace). This option is usually the fastest
way of getting data and ensures that the original variables used for model
fitting are returned. Note that always the <em>current</em> data is recovered from
the environment. Hence, if the data was modified <em>after</em> model fitting
(e.g., variables were recoded or rows filtered), the returned data may no
longer equal the model data. If <code>source = "frame"</code> (or <code>"mf"</code>), the data
is taken from the model frame. Any transformed variables are back-transformed,
if possible. This option returns the data even if it is not available in
the environment, however, in certain edge cases back-transforming to the
original data may fail. If <code>source = "environment"</code> fails to recover the
data, it tries to extract the data from the model frame; if
<code>source = "frame"</code> and data cannot be extracted from the model frame, data
will be recovered from the environment. Both ways only returns observations
that have no missing data in the variables used for model fitting.</p>
</td></tr>
<tr><td><code id="get_data_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="get_data_+3A_effects">effects</code></td>
<td>
<p>Should model data for fixed effects (<code>"fixed"</code>), random
effects (<code>"random"</code>) or both (<code>"all"</code>) be returned? Only applies to mixed
or gee models.</p>
</td></tr>
<tr><td><code id="get_data_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="get_data_+3A_shape">shape</code></td>
<td>
<p>Return long or wide data? Only applicable in repeated measures
designs.</p>
</td></tr>
<tr><td><code id="get_data_+3A_include_interval">include_interval</code></td>
<td>
<p>For meta-analysis models, should normal-approximation
confidence intervals be added for each response effect size?</p>
</td></tr>
<tr><td><code id="get_data_+3A_transf">transf</code></td>
<td>
<p>For meta-analysis models, if intervals are included, a function
applied to each response effect size and its interval.</p>
</td></tr>
<tr><td><code id="get_data_+3A_transf_args">transf_args</code></td>
<td>
<p>For meta-analysis models, an optional list of arguments
passed to the <code>transf</code> function.</p>
</td></tr>
<tr><td><code id="get_data_+3A_ci">ci</code></td>
<td>
<p>For meta-analysis models, the Confidence Interval (CI) level if
<code>include_interval = TRUE</code>. Default to 0.95 (95%).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data that was used to fit the model.
</p>


<h3>Model components</h3>

<p>Possible values for the <code>component</code> argument depend on the model class.
Following are valid options:
</p>

<ul>
<li> <p><code>"all"</code>: returns all model components, applies to all models, but will only
have an effect for models with more than just the conditional model component.
</p>
</li>
<li> <p><code>"conditional"</code>: only returns the conditional component, i.e. &quot;fixed effects&quot;
terms from the model. Will only have an effect for models with more than
just the conditional model component.
</p>
</li>
<li> <p><code>"smooth_terms"</code>: returns smooth terms, only applies to GAMs (or similar
models that may contain smooth terms).
</p>
</li>
<li> <p><code>"zero_inflated"</code> (or <code>"zi"</code>): returns the zero-inflation component.
</p>
</li>
<li> <p><code>"dispersion"</code>: returns the dispersion model component. This is common
for models with zero-inflation or that can model the dispersion parameter.
</p>
</li>
<li> <p><code>"instruments"</code>: for instrumental-variable or some fixed effects regression,
returns the instruments.
</p>
</li>
<li> <p><code>"location"</code>: returns location parameters such as <code>conditional</code>,
<code>zero_inflated</code>, <code>smooth_terms</code>, or <code>instruments</code> (everything that are
fixed or random effects - depending on the <code>effects</code> argument - but no
auxiliary parameters).
</p>
</li>
<li> <p><code>"distributional"</code> (or <code>"auxiliary"</code>): components like <code>sigma</code>, <code>dispersion</code>,
<code>beta</code> or <code>precision</code> (and other auxiliary parameters) are returned.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(cbpp, package = "lme4")
cbpp$trials &lt;- cbpp$size - cbpp$incidence
m &lt;- glm(cbind(incidence, trials) ~ period, data = cbpp, family = binomial)
head(get_data(m))

</code></pre>

<hr>
<h2 id='get_datagrid'>Create a reference grid</h2><span id='topic+get_datagrid'></span><span id='topic+get_datagrid.data.frame'></span><span id='topic+get_datagrid.numeric'></span><span id='topic+get_datagrid.factor'></span><span id='topic+get_datagrid.default'></span>

<h3>Description</h3>

<p>Create a reference matrix, useful for visualisation, with evenly spread and
combined values. Usually used to make generate predictions using <code><a href="#topic+get_predicted">get_predicted()</a></code>.
See this <a href="https://easystats.github.io/modelbased/articles/visualisation_matrix.html">vignette</a>
for a tutorial on how to create a visualisation matrix using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_datagrid(x, ...)

## S3 method for class 'data.frame'
get_datagrid(
  x,
  at = "all",
  factors = "reference",
  numerics = "mean",
  preserve_range = FALSE,
  reference = x,
  length = 10,
  range = "range",
  ...
)

## S3 method for class 'numeric'
get_datagrid(x, length = 10, range = "range", ...)

## S3 method for class 'factor'
get_datagrid(x, ...)

## Default S3 method:
get_datagrid(
  x,
  at = "all",
  factors = "reference",
  numerics = "mean",
  preserve_range = TRUE,
  reference = x,
  include_smooth = TRUE,
  include_random = FALSE,
  include_response = FALSE,
  data = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_datagrid_+3A_x">x</code></td>
<td>
<p>An object from which to construct the reference grid.</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods (for instance, <code>length</code>
or <code>range</code> to control the spread of numeric variables.).</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_at">at</code></td>
<td>
<p>Indicates the <em>focal predictors</em> (variables) for the reference grid
and at which values focal predictors should be represented. If not specified
otherwise, representative values for numeric variables or predictors are
evenly distributed from the minimum to the maximum, with a total number of
<code>length</code> values covering that range (see 'Examples'). Possible options for
<code>at</code> are:
</p>

<ul>
<li> <p><code>"all"</code>, which will include all variables or predictors.
</p>
</li>
<li><p> a character vector of one or more variable or predictor names, like
<code>c("Species", "Sepal.Width")</code>, which will create a grid of all combinations
of unique values. For factors, will use all levels, for numeric variables,
will use a range of length <code>length</code> (evenly spread from minimum to maximum)
and for character vectors, will use all unique values.
</p>
</li>
<li><p> a list of named elements, indicating focal predictors and their representative
values, e.g. <code>at = list(Sepal.Length = c(2, 4), Species = "setosa")</code>.
</p>
</li>
<li><p> a string with assignments, e.g. <code>at = "Sepal.Length = 2"</code> or
<code>at = c("Sepal.Length = 2", "Species = 'setosa'")</code> - note the usage of single
and double quotes to assign strings within strings.
</p>
</li></ul>

<p>There is a special handling of assignments with <em>brackets</em>, i.e. values
defined inside <code>[</code> and <code style="white-space: pre;">&#8288;]&#8288;</code>.For <strong>numeric</strong> variables, the value(s) inside
the brackets should either be
</p>

<ul>
<li><p> two values, indicating minimum and maximum (e.g. <code>at = "Sepal.Length = [0, 5]"</code>),
for which a range of length <code>length</code> (evenly spread from given minimum to
maximum) is created.
</p>
</li>
<li><p> more than two numeric values <code>at = "Sepal.Length = [2,3,4,5]"</code>, in which
case these values are used as representative values.
</p>
</li>
<li><p> a &quot;token&quot; that creates pre-defined representative values:
</p>

<ul>
<li><p> for mean and -/+ 1 SD around the mean: <code>"x = [sd]"</code>
</p>
</li>
<li><p> for median and -/+ 1 MAD around the median: <code>"x = [mad]"</code>
</p>
</li>
<li><p> for Tukey's five number summary (minimum, lower-hinge, median, upper-hinge, maximum): <code>"x = [fivenum]"</code>
</p>
</li>
<li><p> for terciles, including minimum and maximum: <code>"x = [terciles]"</code>
</p>
</li>
<li><p> for terciles, excluding minimum and maximum: <code>"x = [terciles2]"</code>
</p>
</li>
<li><p> for quartiles, including minimum and maximum: <code>"x = [quartiles]"</code>
</p>
</li>
<li><p> for quartiles, excluding minimum and maximum: <code>"x = [quartiles2]"</code>
</p>
</li>
<li><p> for minimum and maximum value: <code>"x = [minmax]"</code>
</p>
</li>
<li><p> for 0 and the maximum value: <code>"x = [zeromax]"</code>
</p>
</li></ul>

</li></ul>

<p>For <strong>factor</strong> variables, the value(s) inside the brackets should indicate
one or more factor levels, like <code>at = "Species = [setosa, versicolor]"</code>.
<strong>Note</strong>: the <code>length</code> argument will be ignored when using brackets-tokens.
</p>
<p>The remaining variables not specified in <code>at</code> will be fixed (see also arguments
<code>factors</code> and <code>numerics</code>).</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_factors">factors</code></td>
<td>
<p>Type of summary for factors. Can be <code>"reference"</code> (set at the
reference level), <code>"mode"</code> (set at the most common level) or <code>"all"</code> to
keep all levels.</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_numerics">numerics</code></td>
<td>
<p>Type of summary for numeric values. Can be <code>"all"</code> (will
duplicate the grid for all unique values), any function (<code>"mean"</code>,
<code>"median"</code>, ...) or a value (e.g., <code>numerics = 0</code>).</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_preserve_range">preserve_range</code></td>
<td>
<p>In the case of combinations between numeric variables
and factors, setting <code>preserve_range = TRUE</code> will drop the observations
where the value of the numeric variable is originally not present in the
range of its factor level. This leads to an unbalanced grid. Also, if you
want the minimum and the maximum to closely match the actual ranges, you
should increase the <code>length</code> argument.</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_reference">reference</code></td>
<td>
<p>The reference vector from which to compute the mean and SD.
Used when standardizing or unstandardizing the grid using <code>effectsize::standardize</code>.</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_length">length</code></td>
<td>
<p>Length of numeric target variables selected in <code>"at"</code>. This arguments
controls the number of (equally spread) values that will be taken to represent the
continuous variables. A longer length will increase precision, but can also
substantially increase the size of the datagrid (especially in case of interactions).
If <code>NA</code>, will return all the unique values. In case of multiple continuous target
variables, <code>length</code> can also be a vector of different values (see examples).</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_range">range</code></td>
<td>
<p>Option to control the representative values given in <code>at</code>, if
no specific values were provided. Use in combination with the <code>length</code> argument
to control the number of values within the specified range. <code>range</code> can be
one of the following:
</p>

<ul>
<li> <p><code>"range"</code> (default), will use the minimum and maximum of the original data
vector as end-points (min and max).
</p>
</li>
<li><p> if an interval type is specified, such as <code><a href="stats.html#topic+IQR">&quot;iqr&quot;</a></code>,
<code><a href="bayestestR.html#topic+ci">&quot;ci&quot;</a></code>, <code><a href="bayestestR.html#topic+hdi">&quot;hdi&quot;</a></code> or
<code><a href="bayestestR.html#topic+eti">&quot;eti&quot;</a></code>, it will spread the values within that range
(the default CI width is <code style="white-space: pre;">&#8288;95%&#8288;</code> but this can be changed by adding for instance
<code>ci = 0.90</code>.) See <code><a href="stats.html#topic+IQR">IQR()</a></code> and <code><a href="bayestestR.html#topic+ci">bayestestR::ci()</a></code>. This can be useful to have
more robust change and skipping extreme values.
</p>
</li>
<li><p> if <code><a href="stats.html#topic+sd">&quot;sd&quot;</a></code> or <code><a href="stats.html#topic+mad">&quot;mad&quot;</a></code>, it will spread by this dispersion
index around the mean or the median, respectively. If the <code>length</code> argument
is an even number (e.g., <code>4</code>), it will have one more step on the positive
side (i.e., <code style="white-space: pre;">&#8288;-1, 0, +1, +2&#8288;</code>). The result is a named vector. See 'Examples.'
</p>
</li>
<li> <p><code>"grid"</code> will create a reference grid that is useful when plotting
predictions, by choosing representative values for numeric variables based
on their position in the reference grid. If a numeric variable is the first
predictor in <code>at</code>, values from minimum to maximum of the same length as
indicated in <code>length</code> are generated. For numeric predictors not specified at
first in <code>at</code>, mean and -1/+1 SD around the mean are returned. For factors,
all levels are returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_datagrid_+3A_include_smooth">include_smooth</code></td>
<td>
<p>If <code>x</code> is a model object, decide whether smooth terms
should be included in the data grid or not.</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_include_random">include_random</code></td>
<td>
<p>If <code>x</code> is a mixed model object, decide whether random
effect terms should be included in the data grid or not. If
<code>include_random</code> is <code>FALSE</code>, but <code>x</code> is a mixed model with random effects,
these will still be included in the returned grid, but set to their
&quot;population level&quot; value (e.g., <code>NA</code> for <em>glmmTMB</em> or <code>0</code> for <em>merMod</em>).
This ensures that common <code>predict()</code> methods work properly, as these
usually need data with all variables in the model included.</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_include_response">include_response</code></td>
<td>
<p>If <code>x</code> is a model object, decide whether the response
variable should be included in the data grid or not.</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_data">data</code></td>
<td>
<p>Optional, the data frame that was used to fit the model. Usually,
the data is retrieved via <code>get_data()</code>.</p>
</td></tr>
<tr><td><code id="get_datagrid_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reference grid data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_predicted">get_predicted()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Datagrids of variables and dataframes =====================================

# Single variable is of interest; all others are "fixed" ------------------
# Factors
get_datagrid(iris, at = "Species") # Returns all the levels
get_datagrid(iris, at = "Species = c('setosa', 'versicolor')") # Specify an expression

# Numeric variables
get_datagrid(iris, at = "Sepal.Length") # default spread length = 10
get_datagrid(iris, at = "Sepal.Length", length = 3) # change length
get_datagrid(iris[2:150, ],
  at = "Sepal.Length",
  factors = "mode", numerics = "median"
) # change non-targets fixing
get_datagrid(iris, at = "Sepal.Length", range = "ci", ci = 0.90) # change min/max of target
get_datagrid(iris, at = "Sepal.Length = [0, 1]") # Manually change min/max
get_datagrid(iris, at = "Sepal.Length = [sd]") # -1 SD, mean and +1 SD
# identical to previous line: -1 SD, mean and +1 SD
get_datagrid(iris, at = "Sepal.Length", range = "sd", length = 3)
get_datagrid(iris, at = "Sepal.Length = [quartiles]") # quartiles

# Numeric and categorical variables, generating a grid for plots
# default spread length = 10
get_datagrid(iris, at = c("Sepal.Length", "Species"), range = "grid")
# default spread length = 3 (-1 SD, mean and +1 SD)
get_datagrid(iris, at = c("Species", "Sepal.Length"), range = "grid")

# Standardization and unstandardization
data &lt;- get_datagrid(iris, at = "Sepal.Length", range = "sd", length = 3)
data$Sepal.Length # It is a named vector (extract names with `names(out$Sepal.Length)`)
datawizard::standardize(data, select = "Sepal.Length")
data &lt;- get_datagrid(iris, at = "Sepal.Length = c(-2, 0, 2)") # Manually specify values
data
datawizard::unstandardize(data, select = "Sepal.Length")

# Multiple variables are of interest, creating a combination --------------
get_datagrid(iris, at = c("Sepal.Length", "Species"), length = 3)
get_datagrid(iris, at = c("Sepal.Length", "Petal.Length"), length = c(3, 2))
get_datagrid(iris, at = c(1, 3), length = 3)
get_datagrid(iris, at = c("Sepal.Length", "Species"), preserve_range = TRUE)
get_datagrid(iris, at = c("Sepal.Length", "Species"), numerics = 0)
get_datagrid(iris, at = c("Sepal.Length = 3", "Species"))
get_datagrid(iris, at = c("Sepal.Length = c(3, 1)", "Species = 'setosa'"))

# With list-style at-argument
get_datagrid(iris, at = list(Sepal.Length = c(1, 3), Species = "setosa"))

# With models ===============================================================
# Fit a linear regression
model &lt;- lm(Sepal.Length ~ Sepal.Width * Petal.Length, data = iris)
# Get datagrid of predictors
data &lt;- get_datagrid(model, length = c(20, 3), range = c("range", "sd"))
# same as: get_datagrid(model, range = "grid", length = 20)
# Add predictions
data$Sepal.Length &lt;- get_predicted(model, data = data)
# Visualize relationships (each color is at -1 SD, Mean, and + 1 SD of Petal.Length)
plot(data$Sepal.Width, data$Sepal.Length,
  col = data$Petal.Length,
  main = "Relationship at -1 SD, Mean, and + 1 SD of Petal.Length"
)

</code></pre>

<hr>
<h2 id='get_deviance'>Model Deviance</h2><span id='topic+get_deviance'></span><span id='topic+get_deviance.default'></span>

<h3>Description</h3>

<p>Returns model deviance (see <code>stats::deviance()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_deviance(x, ...)

## Default S3 method:
get_deviance(x, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_deviance_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="get_deviance_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="get_deviance_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For GLMMs of class <code>glmerMod</code>, <code>glmmTMB</code> or <code>MixMod</code>,
the <em>absolute unconditional</em> deviance is returned (see 'Details' in
<code>?lme4::merMod-class</code>), i.e. minus twice the log-likelihood. To get
the <em>relative conditional</em> deviance (relative to a saturated model,
conditioned on the conditional modes of random effects), use <code>deviance()</code>.
The value returned <code>get_deviance()</code> usually equals the deviance-value
from the <code>summary()</code>.
</p>


<h3>Value</h3>

<p>The model deviance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
x &lt;- lm(mpg ~ cyl, data = mtcars)
get_deviance(x)
</code></pre>

<hr>
<h2 id='get_df'>Extract degrees of freedom</h2><span id='topic+get_df'></span><span id='topic+get_df.default'></span>

<h3>Description</h3>

<p>Estimate or extract residual or model-based degrees of freedom
from regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_df(x, ...)

## Default S3 method:
get_df(x, type = "residual", verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_df_+3A_x">x</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="get_df_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_df_+3A_type">type</code></td>
<td>
<p>Can be <code>"residual"</code>, <code>"wald"</code>, <code>"normal"</code>, or
<code>"model"</code>. <code>"analytical"</code> is an alias for <code>"residual"</code>.
</p>

<ul>
<li> <p><code>"residual"</code> (aka <code>"analytical"</code>) returns the residual degrees of
freedom, which usually is what <code><a href="stats.html#topic+df.residual">stats::df.residual()</a></code> returns. If a
model object has no method to extract residual degrees of freedom, these
are calculated as <code>n-p</code>, i.e. the number of observations minus the number
of estimated parameters. If residual degrees of freedom cannot be extracted
by either approach, returns <code>Inf</code>.
</p>
</li>
<li> <p><code>"wald"</code> returns residual (aka analytical) degrees of freedom for models
with t-statistic, <code>1</code> for models with Chi-squared statistic, and <code>Inf</code> for
all other models. Also returns <code>Inf</code> if residual degrees of freedom cannot
be extracted.
</p>
</li>
<li> <p><code>"normal"</code> always returns <code>Inf</code>.
</p>
</li>
<li> <p><code>"model"</code> returns model-based degrees of freedom, i.e. the number of
(estimated) parameters.
</p>
</li>
<li><p> For mixed models, can also be <code>"ml1"</code> (approximation of degrees of freedom
based on a &quot;m-l-1&quot; heuristic as suggested by <em>Elff et al. 2019</em>) or
<code>"betwithin"</code>, and for models of class <code>merMod</code>, <code>type</code> can also be
<code>"satterthwaite"</code> or <code>"kenward-roger"</code>. See 'Details'.
</p>
</li></ul>

<p>Usually, when degrees of freedom are required to calculate p-values or
confidence intervals, <code>type = "wald"</code> is likely to be the best choice in
most cases.</p>
</td></tr>
<tr><td><code id="get_df_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Degrees of freedom for mixed models</strong>
</p>
<p>Inferential statistics (like p-values, confidence intervals and
standard errors) may be biased in mixed models when the number of clusters
is small (even if the sample size of level-1 units is high). In such cases
it is recommended to approximate a more accurate number of degrees of freedom
for such inferential statistics (see <em>Li and Redden 2015</em>).
</p>
<p><em>m-l-1 degrees of freedom</em>
</p>
<p>The <em>m-l-1</em> heuristic is an approach that uses a t-distribution with fewer
degrees of freedom. In particular for repeated measure designs (longitudinal
data analysis), the m-l-1 heuristic is likely to be more accurate than simply
using the residual or infinite degrees of freedom, because <code>get_df(type = "ml1")</code>
returns different degrees of freedom for within-cluster and between-cluster
effects. Note that the &quot;m-l-1&quot; heuristic is not applicable (or at least less
accurate) for complex multilevel designs, e.g. with cross-classified clusters.
In such cases, more accurate approaches like the Kenward-Roger approximation
is recommended. However, the &quot;m-l-1&quot; heuristic also applies to generalized
mixed models, while approaches like Kenward-Roger or Satterthwaite are limited
to linear mixed models only.
</p>
<p><em>Between-within degrees of freedom</em>
</p>
<p>The Between-within denominator degrees of freedom approximation is, similar
to the &quot;m-l-1&quot; heuristic, recommended in particular for (generalized) linear
mixed models with repeated measurements (longitudinal design).
<code>get_df(type = "betwithin")</code> implements a heuristic based on the between-within
approach, i.e. this type returns different degrees of freedom for within-cluster
and between-cluster effects. Note that this implementation does not return
exactly the same results as shown in <em>Li and Redden 2015</em>, but similar.
</p>
<p><em>Satterthwaite and Kenward-Rogers degrees of freedom</em>
</p>
<p>Unlike simpler approximation heuristics like the &quot;m-l-1&quot; rule (<code>type = "ml1"</code>),
the Satterthwaite or Kenward-Rogers approximation is also applicable in more
complex multilevel designs. However, the &quot;m-l-1&quot; or &quot;between-within&quot; heuristics
also apply to generalized mixed models, while approaches like Kenward-Roger
or Satterthwaite are limited to linear mixed models only.
</p>


<h3>References</h3>


<ul>
<li><p> Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for
fixed effects from restricted maximum likelihood. Biometrics, 983-997.
</p>
</li>
<li><p> Satterthwaite FE (1946) An approximate distribution of estimates of
variance components. Biometrics Bulletin 2 (6):110–4.
</p>
</li>
<li><p> Elff, M.; Heisig, J.P.; Schaeffer, M.; Shikano, S. (2019). Multilevel
Analysis with Few Clusters: Improving Likelihood-based Methods to Provide
Unbiased Estimates and Accurate Inference, British Journal of Political
Science.
</p>
</li>
<li><p> Li, P., Redden, D. T. (2015). Comparing denominator degrees of freedom
approximations for the generalized linear mixed model in analyzing binary
outcome in small sample cluster-randomized trials. BMC Medical Research
Methodology, 15(1), 38
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- lm(Sepal.Length ~ Petal.Length * Species, data = iris)
get_df(model) # same as df.residual(model)
get_df(model, type = "model") # same as attr(logLik(model), "df")
</code></pre>

<hr>
<h2 id='get_family'>A robust alternative to stats::family</h2><span id='topic+get_family'></span>

<h3>Description</h3>

<p>A robust and resilient alternative to <code>stats::family</code>. To avoid issues
with models like <code>gamm4</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_family(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_family_+3A_x">x</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="get_family_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
x &lt;- glm(vs ~ wt, data = mtcars, family = "binomial")
get_family(x)

x &lt;- mgcv::gamm(
  vs ~ am + s(wt),
  random = list(cyl = ~1),
  data = mtcars,
  family = "binomial"
)
get_family(x)

</code></pre>

<hr>
<h2 id='get_intercept'>Get the value at the intercept</h2><span id='topic+get_intercept'></span>

<h3>Description</h3>

<p>Returns the value at the intercept (i.e., the intercept
parameter), and <code>NA</code> if there isn't one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_intercept(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_intercept_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="get_intercept_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the intercept.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_intercept(lm(Sepal.Length ~ Petal.Width, data = iris))
get_intercept(lm(Sepal.Length ~ 0 + Petal.Width, data = iris))


get_intercept(lme4::lmer(Sepal.Length ~ Sepal.Width + (1 | Species), data = iris))


get_intercept(gamm4::gamm4(Sepal.Length ~ s(Petal.Width), data = iris))

</code></pre>

<hr>
<h2 id='get_loglikelihood'>Log-Likelihood</h2><span id='topic+get_loglikelihood'></span><span id='topic+loglikelihood'></span><span id='topic+get_loglikelihood.lm'></span>

<h3>Description</h3>

<p>A robust function to compute the log-likelihood of a model, as well as
individual log-likelihoods (for each observation) whenever possible. Can be
used as a replacement for <code>stats::logLik()</code> out of the box, as the
returned object is of the same class (and it gives the same results by
default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_loglikelihood(x, ...)

loglikelihood(x, ...)

## S3 method for class 'lm'
get_loglikelihood(
  x,
  estimator = "ML",
  REML = FALSE,
  check_response = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_loglikelihood_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="get_loglikelihood_+3A_...">...</code></td>
<td>
<p>Passed down to <code>logLik()</code>, if possible.</p>
</td></tr>
<tr><td><code id="get_loglikelihood_+3A_estimator">estimator</code></td>
<td>
<p>Corresponds to the different estimators for the standard
deviation of the errors. If <code>estimator="ML"</code> (default), the scaling is
done by n (the biased ML estimator), which is then equivalent to using
<code>stats::logLik()</code>. If <code>estimator="OLS"</code>, it returns the unbiased
OLS estimator. <code>estimator="REML"</code> will give same results as
<code>logLik(..., REML=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="get_loglikelihood_+3A_reml">REML</code></td>
<td>
<p>Only for linear models. This argument is present for
compatibility with <code>stats::logLik()</code>. Setting it to <code>TRUE</code> will
overwrite the <code>estimator</code> argument and is thus equivalent to setting
<code>estimator="REML"</code>. It will give the same results as
<code>stats::logLik(..., REML=TRUE)</code>. Note that individual log-likelihoods
are not available under REML.</p>
</td></tr>
<tr><td><code id="get_loglikelihood_+3A_check_response">check_response</code></td>
<td>
<p>Logical, if <code>TRUE</code>, checks if the response variable
is transformed (like <code>log()</code> or <code>sqrt()</code>), and if so, returns a corrected
log-likelihood. To get back to the original scale, the likelihood of the
model is multiplied by the Jacobian/derivative of the transformation.</p>
</td></tr>
<tr><td><code id="get_loglikelihood_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"logLik"</code>, also containing the
log-likelihoods for each observation as a <code>per_observation</code> attribute
(<code>attributes(get_loglikelihood(x))$per_observation</code>) when possible.
The code was partly inspired from the <strong>nonnest2</strong> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- lm(Sepal.Length ~ Petal.Width + Species, data = iris)

get_loglikelihood(x, estimator = "ML") # Equivalent to stats::logLik(x)
get_loglikelihood(x, estimator = "REML") # Equivalent to stats::logLik(x, REML=TRUE)
get_loglikelihood(x, estimator = "OLS")
</code></pre>

<hr>
<h2 id='get_modelmatrix'>Model Matrix</h2><span id='topic+get_modelmatrix'></span>

<h3>Description</h3>

<p>Creates a design matrix from the description. Any character variables are coerced to factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_modelmatrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_modelmatrix_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="get_modelmatrix_+3A_...">...</code></td>
<td>
<p>Passed down to other methods (mainly <code>model.matrix()</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)

model &lt;- lm(am ~ vs, data = mtcars)
get_modelmatrix(model)
</code></pre>

<hr>
<h2 id='get_parameters'>Get model parameters</h2><span id='topic+get_parameters'></span><span id='topic+get_parameters.default'></span>

<h3>Description</h3>

<p>Returns the coefficients (or posterior samples for Bayesian
models) from a model. See the documentation for your object's class:
</p>

<ul>
<li> <p><a href="#topic+get_parameters.BGGM">Bayesian models</a> (<strong>rstanarm</strong>, <strong>brms</strong>, <strong>MCMCglmm</strong>, ...)
</p>
</li>
<li> <p><a href="#topic+get_parameters.emmGrid">Estimated marginal means</a> (<strong>emmeans</strong>)
</p>
</li>
<li> <p><a href="#topic+get_parameters.gamm">Generalized additive models</a> (<strong>mgcv</strong>, <strong>VGAM</strong>, ...)
</p>
</li>
<li> <p><a href="#topic+get_parameters.betamfx">Marginal effects models</a> (<strong>mfx</strong>)
</p>
</li>
<li> <p><a href="#topic+get_parameters.glmm">Mixed models</a> (<strong>lme4</strong>, <strong>glmmTMB</strong>, <strong>GLMMadaptive</strong>, ...)
</p>
</li>
<li> <p><a href="#topic+get_parameters.zeroinfl">Zero-inflated and hurdle models</a> (<strong>pscl</strong>, ...)
</p>
</li>
<li> <p><a href="#topic+get_parameters.betareg">Models with special components</a> (<strong>betareg</strong>, <strong>MuMIn</strong>, ...)
</p>
</li>
<li> <p><a href="#topic+get_parameters.htest">Hypothesis tests</a> (<code>htest</code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>get_parameters(x, ...)

## Default S3 method:
get_parameters(x, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_parameters_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_parameters_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases when models either return different &quot;effects&quot; (fixed,
random) or &quot;components&quot; (conditional, zero-inflated, ...), the arguments
<code>effects</code> and <code>component</code> can be used.
</p>
<p><code>get_parameters()</code> is comparable to <code>coef()</code>, however, the coefficients
are returned as data frame (with columns for names and point estimates of
coefficients). For Bayesian models, the posterior samples of parameters are
returned.
</p>


<h3>Value</h3>


<ul>
<li><p> for non-Bayesian models, a data frame with two columns: the parameter names
and the related point estimates.
</p>
</li>
<li><p> for Anova (<code>aov()</code>) with error term, a list of parameters for the
conditional and the random effects parameters
</p>
</li></ul>



<h3>Model components</h3>

<p>Possible values for the <code>component</code> argument depend on the model class.
Following are valid options:
</p>

<ul>
<li> <p><code>"all"</code>: returns all model components, applies to all models, but will only
have an effect for models with more than just the conditional model component.
</p>
</li>
<li> <p><code>"conditional"</code>: only returns the conditional component, i.e. &quot;fixed effects&quot;
terms from the model. Will only have an effect for models with more than
just the conditional model component.
</p>
</li>
<li> <p><code>"smooth_terms"</code>: returns smooth terms, only applies to GAMs (or similar
models that may contain smooth terms).
</p>
</li>
<li> <p><code>"zero_inflated"</code> (or <code>"zi"</code>): returns the zero-inflation component.
</p>
</li>
<li> <p><code>"dispersion"</code>: returns the dispersion model component. This is common
for models with zero-inflation or that can model the dispersion parameter.
</p>
</li>
<li> <p><code>"instruments"</code>: for instrumental-variable or some fixed effects regression,
returns the instruments.
</p>
</li>
<li> <p><code>"location"</code>: returns location parameters such as <code>conditional</code>,
<code>zero_inflated</code>, <code>smooth_terms</code>, or <code>instruments</code> (everything that are
fixed or random effects - depending on the <code>effects</code> argument - but no
auxiliary parameters).
</p>
</li>
<li> <p><code>"distributional"</code> (or <code>"auxiliary"</code>): components like <code>sigma</code>, <code>dispersion</code>,
<code>beta</code> or <code>precision</code> (and other auxiliary parameters) are returned.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_parameters(m)
</code></pre>

<hr>
<h2 id='get_parameters.betamfx'>Get model parameters from marginal effects models</h2><span id='topic+get_parameters.betamfx'></span><span id='topic+get_parameters.logitmfx'></span>

<h3>Description</h3>

<p>Returns the coefficients from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betamfx'
get_parameters(
  x,
  component = c("all", "conditional", "precision", "marginal"),
  ...
)

## S3 method for class 'logitmfx'
get_parameters(x, component = c("all", "conditional", "marginal"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters.betamfx_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_parameters.betamfx_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="get_parameters.betamfx_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns: the parameter names, the related
point estimates and the component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_parameters(m)
</code></pre>

<hr>
<h2 id='get_parameters.betareg'>Get model parameters from models with special components</h2><span id='topic+get_parameters.betareg'></span><span id='topic+get_parameters.DirichletRegModel'></span><span id='topic+get_parameters.averaging'></span><span id='topic+get_parameters.glmx'></span><span id='topic+get_parameters.clm2'></span><span id='topic+get_parameters.mvord'></span><span id='topic+get_parameters.mjoint'></span>

<h3>Description</h3>

<p>Returns the coefficients from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betareg'
get_parameters(
  x,
  component = c("all", "conditional", "precision", "location", "distributional",
    "auxiliary"),
  ...
)

## S3 method for class 'DirichletRegModel'
get_parameters(
  x,
  component = c("all", "conditional", "precision", "location", "distributional",
    "auxiliary"),
  ...
)

## S3 method for class 'averaging'
get_parameters(x, component = c("conditional", "full"), ...)

## S3 method for class 'glmx'
get_parameters(
  x,
  component = c("all", "conditional", "extra", "location", "distributional", "auxiliary"),
  ...
)

## S3 method for class 'clm2'
get_parameters(x, component = c("all", "conditional", "scale"), ...)

## S3 method for class 'mvord'
get_parameters(
  x,
  component = c("all", "conditional", "thresholds", "correlation"),
  ...
)

## S3 method for class 'mjoint'
get_parameters(x, component = c("all", "conditional", "survival"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters.betareg_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_parameters.betareg_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="get_parameters.betareg_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns: the parameter names, the related
point estimates and the component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_parameters(m)
</code></pre>

<hr>
<h2 id='get_parameters.BGGM'>Get model parameters from Bayesian models</h2><span id='topic+get_parameters.BGGM'></span><span id='topic+get_parameters.MCMCglmm'></span><span id='topic+get_parameters.BFBayesFactor'></span><span id='topic+get_parameters.stanmvreg'></span><span id='topic+get_parameters.brmsfit'></span><span id='topic+get_parameters.stanreg'></span><span id='topic+get_parameters.bayesx'></span><span id='topic+get_parameters.bamlss'></span><span id='topic+get_parameters.sim.merMod'></span><span id='topic+get_parameters.sim'></span>

<h3>Description</h3>

<p>Returns the coefficients (or posterior samples for Bayesian
models) from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGGM'
get_parameters(
  x,
  component = c("correlation", "conditional", "intercept", "all"),
  summary = FALSE,
  centrality = "mean",
  ...
)

## S3 method for class 'MCMCglmm'
get_parameters(
  x,
  effects = c("fixed", "random", "all"),
  summary = FALSE,
  centrality = "mean",
  ...
)

## S3 method for class 'BFBayesFactor'
get_parameters(
  x,
  effects = c("all", "fixed", "random"),
  component = c("all", "extra"),
  iterations = 4000,
  progress = FALSE,
  verbose = TRUE,
  summary = FALSE,
  centrality = "mean",
  ...
)

## S3 method for class 'stanmvreg'
get_parameters(
  x,
  effects = c("fixed", "random", "all"),
  parameters = NULL,
  summary = FALSE,
  centrality = "mean",
  ...
)

## S3 method for class 'brmsfit'
get_parameters(
  x,
  effects = "fixed",
  component = "all",
  parameters = NULL,
  summary = FALSE,
  centrality = "mean",
  ...
)

## S3 method for class 'stanreg'
get_parameters(
  x,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  summary = FALSE,
  centrality = "mean",
  ...
)

## S3 method for class 'bayesx'
get_parameters(
  x,
  component = c("conditional", "smooth_terms", "all"),
  summary = FALSE,
  centrality = "mean",
  ...
)

## S3 method for class 'bamlss'
get_parameters(
  x,
  component = c("all", "conditional", "smooth_terms", "location", "distributional",
    "auxiliary"),
  parameters = NULL,
  summary = FALSE,
  centrality = "mean",
  ...
)

## S3 method for class 'sim.merMod'
get_parameters(
  x,
  effects = c("fixed", "random", "all"),
  parameters = NULL,
  summary = FALSE,
  centrality = "mean",
  ...
)

## S3 method for class 'sim'
get_parameters(x, parameters = NULL, summary = FALSE, centrality = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters.BGGM_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_parameters.BGGM_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="get_parameters.BGGM_+3A_summary">summary</code></td>
<td>
<p>Logical, indicates whether the full posterior samples
(<code>summary = FALSE</code>)) or the summarized centrality indices of
the posterior samples (<code>summary = TRUE</code>)) should be returned as
estimates.</p>
</td></tr>
<tr><td><code id="get_parameters.BGGM_+3A_centrality">centrality</code></td>
<td>
<p>Only for models with posterior samples, and when
<code>summary = TRUE</code>. In this case, <code>centrality = "mean"</code> would
calculate means of posterior samples for each parameter, while
<code>centrality = "median"</code> would use the more robust median value as
measure of central tendency.</p>
</td></tr>
<tr><td><code id="get_parameters.BGGM_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_parameters.BGGM_+3A_effects">effects</code></td>
<td>
<p>Should parameters for fixed effects, random effects
or both be returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="get_parameters.BGGM_+3A_iterations">iterations</code></td>
<td>
<p>Number of posterior draws.</p>
</td></tr>
<tr><td><code id="get_parameters.BGGM_+3A_progress">progress</code></td>
<td>
<p>Display progress.</p>
</td></tr>
<tr><td><code id="get_parameters.BGGM_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="get_parameters.BGGM_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters that
should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases when models either return different &quot;effects&quot; (fixed,
random) or &quot;components&quot; (conditional, zero-inflated, ...), the arguments
<code>effects</code> and <code>component</code> can be used.
</p>


<h3>Value</h3>

<p>The posterior samples from the requested parameters as data frame.
If <code>summary = TRUE</code>, returns a data frame with two columns: the
parameter names and the related point estimates (based on <code>centrality</code>).
</p>


<h3>BFBayesFactor Models</h3>

<p>Note that for <code>BFBayesFactor</code> models (from the <strong>BayesFactor</strong> package),
posteriors are only extracted from the first numerator model (i.e.,
<code>model[1]</code>). If you want to apply some function <code>foo()</code> to another
model stored in the <code>BFBayesFactor</code> object, index it directly, e.g.
<code>foo(model[2])</code>, <code>foo(1/model[5])</code>, etc.
See also <code><a href="bayestestR.html#topic+weighted_posteriors">bayestestR::weighted_posteriors()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_parameters(m)
</code></pre>

<hr>
<h2 id='get_parameters.emmGrid'>Get model parameters from estimated marginal means objects</h2><span id='topic+get_parameters.emmGrid'></span><span id='topic+get_parameters.emm_list'></span>

<h3>Description</h3>

<p>Returns the coefficients from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emmGrid'
get_parameters(x, summary = FALSE, merge_parameters = FALSE, ...)

## S3 method for class 'emm_list'
get_parameters(x, summary = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters.emmGrid_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_parameters.emmGrid_+3A_summary">summary</code></td>
<td>
<p>Logical, indicates whether the full posterior samples
(<code>summary = FALSE</code>)) or the summarized centrality indices of
the posterior samples (<code>summary = TRUE</code>)) should be returned as
estimates.</p>
</td></tr>
<tr><td><code id="get_parameters.emmGrid_+3A_merge_parameters">merge_parameters</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> has multiple columns for
parameter names (like <code>emmGrid</code> objects may have), these are merged into a
single parameter column, with parameters names and values as values.</p>
</td></tr>
<tr><td><code id="get_parameters.emmGrid_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: the parameter names and the related
point estimates.
</p>


<h3>Note</h3>

<p>Note that <code>emmGrid</code> or <code>emm_list</code> objects returned by functions from
<strong>emmeans</strong> have a different structure compared to usual regression models.
Hence, the <code>Parameter</code> column does not always contain names of <em>variables</em>,
but may rather contain <em>values</em>, e.g. for contrasts. See an example for
pairwise comparisons below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
model &lt;- lm(mpg ~ wt * factor(cyl), data = mtcars)

emm &lt;- emmeans(model, "cyl")
get_parameters(emm)

emm &lt;- emmeans(model, pairwise ~ cyl)
get_parameters(emm)

</code></pre>

<hr>
<h2 id='get_parameters.gamm'>Get model parameters from generalized additive models</h2><span id='topic+get_parameters.gamm'></span><span id='topic+get_parameters.gam'></span><span id='topic+get_parameters.rqss'></span>

<h3>Description</h3>

<p>Returns the coefficients from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamm'
get_parameters(
  x,
  component = c("all", "conditional", "smooth_terms", "location"),
  ...
)

## S3 method for class 'gam'
get_parameters(
  x,
  component = c("all", "conditional", "smooth_terms", "location"),
  ...
)

## S3 method for class 'rqss'
get_parameters(x, component = c("all", "conditional", "smooth_terms"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters.gamm_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_parameters.gamm_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="get_parameters.gamm_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For models with smooth terms or zero-inflation component, a data
frame with three columns: the parameter names, the related point estimates
and the component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_parameters(m)
</code></pre>

<hr>
<h2 id='get_parameters.glmm'>Get model parameters from mixed models</h2><span id='topic+get_parameters.glmm'></span><span id='topic+get_parameters.coxme'></span><span id='topic+get_parameters.nlmerMod'></span><span id='topic+get_parameters.merMod'></span><span id='topic+get_parameters.glmmTMB'></span><span id='topic+get_parameters.glimML'></span>

<h3>Description</h3>

<p>Returns the coefficients from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmm'
get_parameters(x, effects = c("all", "fixed", "random"), ...)

## S3 method for class 'coxme'
get_parameters(x, effects = c("fixed", "random"), ...)

## S3 method for class 'nlmerMod'
get_parameters(
  x,
  effects = c("fixed", "random"),
  component = c("all", "conditional", "nonlinear"),
  ...
)

## S3 method for class 'merMod'
get_parameters(x, effects = c("fixed", "random"), ...)

## S3 method for class 'glmmTMB'
get_parameters(
  x,
  effects = c("fixed", "random"),
  component = c("all", "conditional", "zi", "zero_inflated", "dispersion"),
  ...
)

## S3 method for class 'glimML'
get_parameters(x, effects = c("fixed", "random", "all"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters.glmm_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_parameters.glmm_+3A_effects">effects</code></td>
<td>
<p>Should parameters for fixed effects, random effects
or both be returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="get_parameters.glmm_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_parameters.glmm_+3A_component">component</code></td>
<td>
<p>Which type of parameters to return, such as parameters for
the conditional model, the zero-inflated part of the model or the
dispersion term? Applies to models with zero-inflated and/or dispersion
formula. Note that the <em>conditional</em> component is also called
<em>count</em> or <em>mean</em> component, depending on the model. There are
three convenient shortcuts: <code>component = "all"</code> returns all possible
parameters. If <code>component = "location"</code>, location parameters such as
<code>conditional</code> or <code>zero_inflated</code> are returned (everything that
are fixed or random effects - depending on the <code>effects</code> argument -
but no auxiliary parameters). For <code>component = "distributional"</code> (or
<code>"auxiliary"</code>), components like <code>sigma</code> or <code>dispersion</code> (and
other auxiliary parameters) are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases when models either return different &quot;effects&quot; (fixed,
random) or &quot;components&quot; (conditional, zero-inflated, ...), the arguments
<code>effects</code> and <code>component</code> can be used.
</p>


<h3>Value</h3>

<p>If <code>effects = "fixed"</code>, a data frame with two columns: the
parameter names and the related point estimates. If <code>effects = "random"</code>, a list of data frames with the random effects (as returned by
<code>ranef()</code>), unless the random effects have the same simplified
structure as fixed effects (e.g. for models from <strong>MCMCglmm</strong>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_parameters(m)
</code></pre>

<hr>
<h2 id='get_parameters.htest'>Get model parameters from htest-objects</h2><span id='topic+get_parameters.htest'></span>

<h3>Description</h3>

<p>Returns the parameters from a hypothesis test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'htest'
get_parameters(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters.htest_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_parameters.htest_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: the parameter names and the related
point estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_parameters(t.test(1:10, y = c(7:20)))
</code></pre>

<hr>
<h2 id='get_parameters.zeroinfl'>Get model parameters from zero-inflated and hurdle models</h2><span id='topic+get_parameters.zeroinfl'></span><span id='topic+get_parameters.zcpglm'></span><span id='topic+get_parameters.mhurdle'></span>

<h3>Description</h3>

<p>Returns the coefficients from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zeroinfl'
get_parameters(
  x,
  component = c("all", "conditional", "zi", "zero_inflated"),
  ...
)

## S3 method for class 'zcpglm'
get_parameters(
  x,
  component = c("all", "conditional", "zi", "zero_inflated"),
  ...
)

## S3 method for class 'mhurdle'
get_parameters(
  x,
  component = c("all", "conditional", "zi", "zero_inflated", "infrequent_purchase", "ip",
    "auxiliary"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters.zeroinfl_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_parameters.zeroinfl_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="get_parameters.zeroinfl_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For models with smooth terms or zero-inflation component, a data
frame with three columns: the parameter names, the related point estimates
and the component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_parameters(m)
</code></pre>

<hr>
<h2 id='get_predicted'>Model predictions (robust) and their confidence intervals</h2><span id='topic+get_predicted'></span><span id='topic+get_predicted.default'></span><span id='topic+get_predicted.lm'></span><span id='topic+get_predicted.stanreg'></span><span id='topic+get_predicted.gam'></span><span id='topic+get_predicted.lmerMod'></span><span id='topic+get_predicted.principal'></span>

<h3>Description</h3>

<p>The <code>get_predicted()</code> function is a robust, flexible and user-friendly
alternative to base R <code><a href="stats.html#topic+predict">predict()</a></code> function. Additional features and
advantages include availability of uncertainty intervals (CI), bootstrapping,
a more intuitive API and the support of more models than base R's <code>predict()</code>
function. However, although the interface are simplified, it is still very
important to read the documentation of the arguments. This is because making
&quot;predictions&quot; (a lose term for a variety of things) is a non-trivial process,
with lots of caveats and complications. Read the 'Details' section for more
information.
</p>
<p><code><a href="#topic+get_predicted_ci">get_predicted_ci()</a></code> returns the confidence (or prediction) interval (CI)
associated with predictions made by a model. This function can be called
separately on a vector of predicted values. <code>get_predicted()</code> usually
returns confidence intervals (included as attribute, and accessible via the
<code>as.data.frame()</code> method) by default. It is preferred to rely on the
<code>get_predicted()</code> function for standard errors and confidence intervals -
use <code>get_predicted_ci()</code> only if standard errors and confidence intervals
are not available otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_predicted(x, ...)

## Default S3 method:
get_predicted(
  x,
  data = NULL,
  predict = "expectation",
  ci = NULL,
  ci_type = "confidence",
  ci_method = NULL,
  dispersion_method = "sd",
  vcov = NULL,
  vcov_args = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'lm'
get_predicted(
  x,
  data = NULL,
  predict = "expectation",
  ci = NULL,
  iterations = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'stanreg'
get_predicted(
  x,
  data = NULL,
  predict = "expectation",
  iterations = NULL,
  ci = NULL,
  ci_method = NULL,
  include_random = "default",
  include_smooth = TRUE,
  verbose = TRUE,
  ...
)

## S3 method for class 'gam'
get_predicted(
  x,
  data = NULL,
  predict = "expectation",
  ci = NULL,
  include_random = TRUE,
  include_smooth = TRUE,
  iterations = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'lmerMod'
get_predicted(
  x,
  data = NULL,
  predict = "expectation",
  ci = NULL,
  ci_method = NULL,
  include_random = "default",
  iterations = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'principal'
get_predicted(x, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_predicted_+3A_x">x</code></td>
<td>
<p>A statistical model (can also be a data.frame, in which case the
second argument has to be a model).</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_...">...</code></td>
<td>
<p>Other argument to be passed, for instance to <code>get_predicted_ci()</code>.</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_data">data</code></td>
<td>
<p>An optional data frame in which to look for variables with which
to predict. If omitted, the data used to fit the model is used. Visualization
matrices can be generated using <code><a href="#topic+get_datagrid">get_datagrid()</a></code>.</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_predict">predict</code></td>
<td>
<p>string or <code>NULL</code>
</p>

<ul>
<li> <p><code>"link"</code> returns predictions on the model's link-scale (for logistic models,
that means the log-odds scale) with a confidence interval (CI).
</p>
</li>
<li> <p><code>"expectation"</code> (default) also returns confidence intervals, but this time
the output is on the response scale (for logistic models, that means
probabilities).
</p>
</li>
<li> <p><code>"prediction"</code> also gives an output on the response scale, but this time
associated with a prediction interval (PI), which is larger than a confidence
interval (though it mostly make sense for linear models).
</p>
</li>
<li> <p><code>"classification"</code> only differs from <code>"prediction"</code> for binomial models
where it additionally transforms the predictions into the original response's
type (for instance, to a factor).
</p>
</li>
<li><p> Other strings are passed directly to the <code>type</code> argument of the <code>predict()</code>
method supplied by the modelling package.
</p>
</li>
<li><p> When <code>predict = NULL</code>, alternative arguments such as <code>type</code> will be captured
by the <code>...</code> ellipsis and passed directly to the <code>predict()</code> method supplied
by the modelling package. Note that this might result in conflicts with
multiple matching <code>type</code> arguments - thus, the recommendation is to use the
<code>predict</code> argument for those values.
</p>
</li>
<li><p> Notes: You can see the 4 options for predictions as on a gradient from
&quot;close to the model&quot; to &quot;close to the response data&quot;: &quot;link&quot;, &quot;expectation&quot;,
&quot;prediction&quot;, &quot;classification&quot;. The <code>predict</code> argument modulates two things:
the scale of the output and the type of certainty interval. Read more about
in the <strong>Details</strong> section below.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_predicted_+3A_ci">ci</code></td>
<td>
<p>The interval level. Default is <code>NULL</code>, to be fast even for larger
models. Set the interval level to an explicit value, e.g. <code>0.95</code>, for <code style="white-space: pre;">&#8288;95%&#8288;</code>
CI).</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_ci_type">ci_type</code></td>
<td>
<p>Can be <code>"prediction"</code> or <code>"confidence"</code>. Prediction
intervals show the range that likely contains the value of a new
observation (in what range it would fall), whereas confidence intervals
reflect the uncertainty around the estimated parameters (and gives the
range of the link; for instance of the regression line in a linear
regressions). Prediction intervals account for both the uncertainty in the
model's parameters, plus the random variation of the individual values.
Thus, prediction intervals are always wider than confidence intervals.
Moreover, prediction intervals will not necessarily become narrower as the
sample size increases (as they do not reflect only the quality of the fit).
This applies mostly for &quot;simple&quot; linear models (like <code>lm</code>), as for
other models (e.g., <code>glm</code>), prediction intervals are somewhat useless
(for instance, for a binomial model for which the dependent variable is a
vector of 1s and 0s, the prediction interval is... <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>).</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_ci_method">ci_method</code></td>
<td>
<p>The method for computing p values and confidence intervals.
Possible values depend on model type.
</p>

<ul>
<li> <p><code>NULL</code> uses the default method, which varies based on the model type.
</p>
</li>
<li><p> Most frequentist models: <code>"wald"</code> (default), <code>"residual"</code> or <code>"normal"</code>.
</p>
</li>
<li><p> Bayesian models:  <code>"quantile"</code>  (default), <code>"hdi"</code>, <code>"eti"</code>, and <code>"spi"</code>.
</p>
</li>
<li><p> Mixed effects <strong>lme4</strong> models: <code>"wald"</code> (default), <code>"residual"</code>, <code>"normal"</code>,
<code>"satterthwaite"</code>, and <code>"kenward-roger"</code>.
</p>
</li></ul>

<p>See <code><a href="#topic+get_df">get_df()</a></code> for details.</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_dispersion_method">dispersion_method</code></td>
<td>
<p>Bootstrap dispersion and Bayesian posterior summary:
<code>"sd"</code> or <code>"mad"</code>.</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_vcov">vcov</code></td>
<td>
<p>Variance-covariance matrix used to compute uncertainty estimates
(e.g., for robust standard errors). This argument accepts a covariance
matrix, a function which returns a covariance matrix, or a string which
identifies the function to be used to compute the covariance matrix.
</p>

<ul>
<li><p> A covariance matrix
</p>
</li>
<li><p> A function which returns a covariance matrix (e.g., <code>stats::vcov()</code>)
</p>
</li>
<li><p> A string which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"vcovHC"</code>, <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>,
<code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Cluster-robust: <code>"vcovCR"</code>, <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>, <code>"CR1S"</code>,
<code>"CR2"</code>, <code>"CR3"</code>. See <code>?clubSandwich::vcovCR()</code>
</p>
</li>
<li><p> Bootstrap: <code>"vcovBS"</code>, <code>"xy"</code>, <code>"residual"</code>, <code>"wild"</code>, <code>"mammen"</code>,
<code>"webb"</code>. See <code>?sandwich::vcovBS</code>
</p>
</li>
<li><p> Other <code>sandwich</code> package functions: <code>"vcovHAC"</code>, <code>"vcovPC"</code>, <code>"vcovCL"</code>,
<code>"vcovPL"</code>.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="get_predicted_+3A_vcov_args">vcov_args</code></td>
<td>
<p>List of arguments to be passed to the function identified by
the <code>vcov</code> argument. This function is typically supplied by the <strong>sandwich</strong>
or <strong>clubSandwich</strong> packages. Please refer to their documentation (e.g.,
<code>?sandwich::vcovHAC</code>) to see the list of available arguments. If no estimation
type (argument <code>type</code>) is given, the default type for <code>"HC"</code> (or <code>"vcovHC"</code>)
equals the default from the <strong>sandwich</strong> package; for type <code>"CR"</code> (or
<code>"vcoCR"</code>), the default is set to <code>"CR3"</code>.</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_iterations">iterations</code></td>
<td>
<p>For Bayesian models, this corresponds to the number of
posterior draws. If <code>NULL</code>, will return all the draws (one for each
iteration of the model). For frequentist models, if not <code>NULL</code>, will
generate bootstrapped draws, from which bootstrapped CIs will be computed.
Iterations can be accessed by running <code>as.data.frame(..., keep_iterations = TRUE)</code>
on the output.</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_include_random">include_random</code></td>
<td>
<p>If <code>"default"</code>, include all random effects in the
prediction, unless random effect variables are not in the data.  If <code>TRUE</code>,
include all random effects in the prediction (in this case, it will be
checked if actually all random effect variables are in <code>data</code>). If <code>FALSE</code>,
don't take them into account. Can also be a formula to specify which random
effects to condition on when predicting (passed to the <code>re.form</code> argument).
If <code>include_random = TRUE</code> and <code>data</code> is provided, make sure to include
the random effect variables in <code>data</code> as well.</p>
</td></tr>
<tr><td><code id="get_predicted_+3A_include_smooth">include_smooth</code></td>
<td>
<p>For General Additive Models (GAMs). If <code>FALSE</code>,
will fix the value of the smooth to its average, so that the predictions
are not depending on it. (default), <code>mean()</code>, or
<code>bayestestR::map_estimate()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>insight::get_predicted()</code>, the <code>predict</code> argument jointly
modulates two separate concepts, the <strong>scale</strong> and the <strong>uncertainty interval</strong>.
</p>


<h3>Value</h3>

<p>The fitted values (i.e. predictions for the response). For Bayesian
or bootstrapped models (when <code>iterations != NULL</code>), iterations (as
columns and observations are rows) can be accessed via <code>as.data.frame()</code>.
</p>


<h3>Confidence Interval (CI) vs. Prediction Interval (PI))</h3>


<ul>
<li> <p><strong>Linear models</strong> - <code>lm()</code>: For linear models, prediction
intervals (<code>predict="prediction"</code>) show the range that likely
contains the value of a new observation (in what range it is likely to
fall), whereas confidence intervals (<code>predict="expectation"</code> or
<code>predict="link"</code>) reflect the uncertainty around the estimated
parameters (and gives the range of uncertainty of the regression line). In
general, Prediction Intervals (PIs) account for both the uncertainty in the
model's parameters, plus the random variation of the individual values.
Thus, prediction intervals are always wider than confidence intervals.
Moreover, prediction intervals will not necessarily become narrower as the
sample size increases (as they do not reflect only the quality of the fit,
but also the variability within the data).
</p>
</li>
<li> <p><strong>Generalized Linear models</strong> - <code>glm()</code>: For binomial models,
prediction intervals are somewhat useless (for instance, for a binomial
(Bernoulli) model for which the dependent variable is a vector of 1s and
0s, the prediction interval is... <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>).
</p>
</li></ul>



<h3>Link scale vs. Response scale</h3>

<p>When users set the <code>predict</code> argument to <code>"expectation"</code>, the predictions
are returned on the response scale, which is arguably the most convenient
way to understand and visualize relationships of interest. When users set
the <code>predict</code> argument to <code>"link"</code>, predictions are returned on the link
scale, and no transformation is applied. For instance, for a logistic
regression model, the response scale corresponds to the predicted
probabilities, whereas the link-scale makes predictions of log-odds
(probabilities on the logit scale). Note that when users select
<code>predict="classification"</code> in binomial models, the <code>get_predicted()</code>
function will first calculate predictions as if the user had selected
<code>predict="expectation"</code>. Then, it will round the responses in order to
return the most likely outcome.
</p>


<h3>Heteroscedasticity consistent standard errors</h3>

<p>The arguments <code>vcov</code> and <code>vcov_args</code> can be used to calculate robust
standard errors for confidence intervals of predictions. These arguments,
when provided in <code>get_predicted()</code>, are passed down to <code>get_predicted_ci()</code>,
thus, see the related documentation there for more
details.
</p>


<h3>Bayesian and Bootstrapped models and iterations</h3>

<p>For predictions based on multiple iterations, for instance in the case of Bayesian
models and bootstrapped predictions, the function used to compute the centrality
(point-estimate predictions) can be modified via the <code>centrality_function</code>
argument. For instance, <code>get_predicted(model, centrality_function = stats::median)</code>.
The default is <code>mean</code>. Individual draws can be accessed by running
<code>iter &lt;- as.data.frame(get_predicted(model))</code>, and their iterations can be
reshaped into a long format by <code>bayestestR::reshape_iterations(iter)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_datagrid">get_datagrid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
x &lt;- lm(mpg ~ cyl + hp, data = mtcars)

predictions &lt;- get_predicted(x, ci = 0.95)
predictions

# Options and methods ---------------------
get_predicted(x, predict = "prediction")

# Get CI
as.data.frame(predictions)

# Bootstrapped
as.data.frame(get_predicted(x, iterations = 4))
# Same as as.data.frame(..., keep_iterations = FALSE)
summary(get_predicted(x, iterations = 4))

# Different prediction types ------------------------
data(iris)
data &lt;- droplevels(iris[1:100, ])

# Fit a logistic model
x &lt;- glm(Species ~ Sepal.Length, data = data, family = "binomial")

# Expectation (default): response scale + CI
pred &lt;- get_predicted(x, predict = "expectation", ci = 0.95)
head(as.data.frame(pred))

# Prediction: response scale + PI
pred &lt;- get_predicted(x, predict = "prediction", ci = 0.95)
head(as.data.frame(pred))

# Link: link scale + CI
pred &lt;- get_predicted(x, predict = "link", ci = 0.95)
head(as.data.frame(pred))

# Classification: classification "type" + PI
pred &lt;- get_predicted(x, predict = "classification", ci = 0.95)
head(as.data.frame(pred))

</code></pre>

<hr>
<h2 id='get_predicted_ci'>Confidence intervals around predicted values</h2><span id='topic+get_predicted_ci'></span><span id='topic+get_predicted_ci.default'></span>

<h3>Description</h3>

<p>Confidence intervals around predicted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_predicted_ci(x, ...)

## Default S3 method:
get_predicted_ci(
  x,
  predictions = NULL,
  data = NULL,
  se = NULL,
  ci = 0.95,
  ci_type = "confidence",
  ci_method = NULL,
  dispersion_method = "sd",
  vcov = NULL,
  vcov_args = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_predicted_ci_+3A_x">x</code></td>
<td>
<p>A statistical model (can also be a data.frame, in which case the
second argument has to be a model).</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_...">...</code></td>
<td>
<p>Other argument to be passed, for instance to <code>get_predicted_ci()</code>.</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_predictions">predictions</code></td>
<td>
<p>A vector of predicted values (as obtained by
<code>stats::fitted()</code>, <code>stats::predict()</code> or <code><a href="#topic+get_predicted">get_predicted()</a></code>).</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_data">data</code></td>
<td>
<p>An optional data frame in which to look for variables with which
to predict. If omitted, the data used to fit the model is used. Visualization
matrices can be generated using <code><a href="#topic+get_datagrid">get_datagrid()</a></code>.</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_se">se</code></td>
<td>
<p>Numeric vector of standard error of predicted values. If <code>NULL</code>,
standard errors are calculated based on the variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_ci">ci</code></td>
<td>
<p>The interval level. Default is <code>NULL</code>, to be fast even for larger
models. Set the interval level to an explicit value, e.g. <code>0.95</code>, for <code style="white-space: pre;">&#8288;95%&#8288;</code>
CI).</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_ci_type">ci_type</code></td>
<td>
<p>Can be <code>"prediction"</code> or <code>"confidence"</code>. Prediction
intervals show the range that likely contains the value of a new
observation (in what range it would fall), whereas confidence intervals
reflect the uncertainty around the estimated parameters (and gives the
range of the link; for instance of the regression line in a linear
regressions). Prediction intervals account for both the uncertainty in the
model's parameters, plus the random variation of the individual values.
Thus, prediction intervals are always wider than confidence intervals.
Moreover, prediction intervals will not necessarily become narrower as the
sample size increases (as they do not reflect only the quality of the fit).
This applies mostly for &quot;simple&quot; linear models (like <code>lm</code>), as for
other models (e.g., <code>glm</code>), prediction intervals are somewhat useless
(for instance, for a binomial model for which the dependent variable is a
vector of 1s and 0s, the prediction interval is... <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>).</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_ci_method">ci_method</code></td>
<td>
<p>The method for computing p values and confidence intervals.
Possible values depend on model type.
</p>

<ul>
<li> <p><code>NULL</code> uses the default method, which varies based on the model type.
</p>
</li>
<li><p> Most frequentist models: <code>"wald"</code> (default), <code>"residual"</code> or <code>"normal"</code>.
</p>
</li>
<li><p> Bayesian models:  <code>"quantile"</code>  (default), <code>"hdi"</code>, <code>"eti"</code>, and <code>"spi"</code>.
</p>
</li>
<li><p> Mixed effects <strong>lme4</strong> models: <code>"wald"</code> (default), <code>"residual"</code>, <code>"normal"</code>,
<code>"satterthwaite"</code>, and <code>"kenward-roger"</code>.
</p>
</li></ul>

<p>See <code><a href="#topic+get_df">get_df()</a></code> for details.</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_dispersion_method">dispersion_method</code></td>
<td>
<p>Bootstrap dispersion and Bayesian posterior summary:
<code>"sd"</code> or <code>"mad"</code>.</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_vcov">vcov</code></td>
<td>
<p>Variance-covariance matrix used to compute uncertainty estimates
(e.g., for robust standard errors). This argument accepts a covariance
matrix, a function which returns a covariance matrix, or a string which
identifies the function to be used to compute the covariance matrix.
</p>

<ul>
<li><p> A covariance matrix
</p>
</li>
<li><p> A function which returns a covariance matrix (e.g., <code>stats::vcov()</code>)
</p>
</li>
<li><p> A string which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"vcovHC"</code>, <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>,
<code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Cluster-robust: <code>"vcovCR"</code>, <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>, <code>"CR1S"</code>,
<code>"CR2"</code>, <code>"CR3"</code>. See <code>?clubSandwich::vcovCR()</code>
</p>
</li>
<li><p> Bootstrap: <code>"vcovBS"</code>, <code>"xy"</code>, <code>"residual"</code>, <code>"wild"</code>, <code>"mammen"</code>,
<code>"webb"</code>. See <code>?sandwich::vcovBS</code>
</p>
</li>
<li><p> Other <code>sandwich</code> package functions: <code>"vcovHAC"</code>, <code>"vcovPC"</code>, <code>"vcovCL"</code>,
<code>"vcovPL"</code>.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_vcov_args">vcov_args</code></td>
<td>
<p>List of arguments to be passed to the function identified by
the <code>vcov</code> argument. This function is typically supplied by the <strong>sandwich</strong>
or <strong>clubSandwich</strong> packages. Please refer to their documentation (e.g.,
<code>?sandwich::vcovHAC</code>) to see the list of available arguments. If no estimation
type (argument <code>type</code>) is given, the default type for <code>"HC"</code> (or <code>"vcovHC"</code>)
equals the default from the <strong>sandwich</strong> package; for type <code>"CR"</code> (or
<code>"vcoCR"</code>), the default is set to <code>"CR3"</code>.</p>
</td></tr>
<tr><td><code id="get_predicted_ci_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically, <code>get_predicted()</code> returns confidence intervals based on the standard
errors as returned by the <code>predict()</code>-function, assuming normal distribution
(<code style="white-space: pre;">&#8288;+/- 1.96 * SE&#8288;</code>) resp. a Student's t-distribution (if degrees of freedom are
available). If <code>predict()</code> for a certain class does <em>not</em> return standard
errors (for example, <em>merMod</em>-objects), these are calculated manually, based
on following steps: matrix-multiply <code>X</code> by the parameter vector <code>B</code> to get the
predictions, then extract the variance-covariance matrix <code>V</code> of the parameters
and compute <code style="white-space: pre;">&#8288;XVX'&#8288;</code> to get the variance-covariance matrix of the predictions.
The square-root of the diagonal of this matrix represent the standard errors
of the predictions, which are then multiplied by the critical test-statistic
value (e.g., ~1.96 for normal distribution) for the confidence intervals.
</p>
<p>If <code>ci_type = "prediction"</code>, prediction intervals are calculated. These are
wider than confidence intervals, because they also take into account the
uncertainty of the model itself. Before taking the square-root of the
diagonal of the variance-covariance matrix, <code>get_predicted_ci()</code> adds the
residual variance to these values. For mixed models, <code>get_variance_residual()</code>
is used, while <code>get_sigma()^2</code> is used for non-mixed models.
</p>
<p>It is preferred to rely on standard errors returned by <code>get_predicted()</code> (i.e.
returned by the <code>predict()</code>-function), because these are more accurate than
manually calculated standard errors. Use <code>get_predicted_ci()</code> only if standard
errors are not available otherwise. An exception are Bayesian models or
bootstrapped predictions, where <code>get_predicted_ci()</code> returns quantiles of the
posterior distribution or bootstrapped samples of the predictions. These are
actually accurate standard errors resp. confidence (or uncertainty) intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Confidence Intervals for Model Predictions
# ------------------------------------------

data(mtcars)

# Linear model
# ------------
x &lt;- lm(mpg ~ cyl + hp, data = mtcars)
predictions &lt;- predict(x)
ci_vals &lt;- get_predicted_ci(x, predictions, ci_type = "prediction")
head(ci_vals)
ci_vals &lt;- get_predicted_ci(x, predictions, ci_type = "confidence")
head(ci_vals)
ci_vals &lt;- get_predicted_ci(x, predictions, ci = c(0.8, 0.9, 0.95))
head(ci_vals)

# Bootstrapped
# ------------
predictions &lt;- get_predicted(x, iterations = 500)
get_predicted_ci(x, predictions)

ci_vals &lt;- get_predicted_ci(x, predictions, ci = c(0.80, 0.95))
head(ci_vals)
datawizard::reshape_ci(ci_vals)

ci_vals &lt;- get_predicted_ci(x,
  predictions,
  dispersion_method = "MAD",
  ci_method = "HDI"
)
head(ci_vals)


# Logistic model
# --------------
x &lt;- glm(vs ~ wt, data = mtcars, family = "binomial")
predictions &lt;- predict(x, type = "link")
ci_vals &lt;- get_predicted_ci(x, predictions, ci_type = "prediction")
head(ci_vals)
ci_vals &lt;- get_predicted_ci(x, predictions, ci_type = "confidence")
head(ci_vals)

</code></pre>

<hr>
<h2 id='get_predictors'>Get the data from model predictors</h2><span id='topic+get_predictors'></span>

<h3>Description</h3>

<p>Returns the data from all predictor variables (fixed effects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_predictors(x, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_predictors_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_predictors_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data from all predictor variables, as data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
head(get_predictors(m))
</code></pre>

<hr>
<h2 id='get_priors'>Get summary of priors used for a model</h2><span id='topic+get_priors'></span><span id='topic+get_priors.brmsfit'></span>

<h3>Description</h3>

<p>Provides a summary of the prior distributions used
for the parameters in a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_priors(x, ...)

## S3 method for class 'brmsfit'
get_priors(x, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_priors_+3A_x">x</code></td>
<td>
<p>A Bayesian model.</p>
</td></tr>
<tr><td><code id="get_priors_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_priors_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a summary of the prior distributions used
for the parameters in a given model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(rstanarm)
model &lt;- stan_glm(Sepal.Width ~ Species * Petal.Length, data = iris)
get_priors(model)


</code></pre>

<hr>
<h2 id='get_random'>Get the data from random effects</h2><span id='topic+get_random'></span>

<h3>Description</h3>

<p>Returns the data from all random effects terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_random(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_random_+3A_x">x</code></td>
<td>
<p>A fitted mixed model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data from all random effects terms, as data frame. Or <code>NULL</code>
if model has no random effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sleepstudy)
# prepare some data...
sleepstudy$mygrp &lt;- sample(1:5, size = 180, replace = TRUE)
sleepstudy$mysubgrp &lt;- NA
for (i in 1:5) {
  filter_group &lt;- sleepstudy$mygrp == i
  sleepstudy$mysubgrp[filter_group] &lt;-
    sample(1:30, size = sum(filter_group), replace = TRUE)
}

m &lt;- lmer(
  Reaction ~ Days + (1 | mygrp / mysubgrp) + (1 | Subject),
  data = sleepstudy
)

head(get_random(m))

</code></pre>

<hr>
<h2 id='get_residuals'>Extract model residuals</h2><span id='topic+get_residuals'></span><span id='topic+get_residuals.default'></span>

<h3>Description</h3>

<p>Returns the residuals from regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_residuals(x, ...)

## Default S3 method:
get_residuals(x, weighted = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_residuals_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_...">...</code></td>
<td>
<p>Passed down to <code>residuals()</code>, if possible.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_weighted">weighted</code></td>
<td>
<p>Logical, if <code>TRUE</code>, returns weighted residuals.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The residuals, or <code>NULL</code> if this information could not be
accessed.
</p>


<h3>Note</h3>

<p>This function returns the default type of residuals, i.e. for the
response from linear models, the deviance residuals for models of class
<code>glm</code> etc. To access different types, pass down the <code>type</code> argument (see
'Examples').
</p>
<p>This function is a robust alternative to <code>residuals()</code>, as it works for
some special model objects that otherwise do not respond properly to calling
<code>residuals()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_residuals(m)

m &lt;- glm(vs ~ wt + cyl + mpg, data = mtcars, family = binomial())
get_residuals(m) # type = "deviance" by default
get_residuals(m, type = "response")
</code></pre>

<hr>
<h2 id='get_response'>Get the values from the response variable</h2><span id='topic+get_response'></span><span id='topic+get_response.default'></span><span id='topic+get_response.nestedLogit'></span>

<h3>Description</h3>

<p>Returns the values the response variable(s) from a model object.
If the model is a multivariate response model, a data frame with values
from all response variables is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_response(x, ...)

## Default S3 method:
get_response(
  x,
  select = NULL,
  as_proportion = TRUE,
  source = "environment",
  verbose = TRUE,
  ...
)

## S3 method for class 'nestedLogit'
get_response(x, dichotomies = FALSE, source = "environment", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_response_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_response_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_response_+3A_select">select</code></td>
<td>
<p>Optional name(s) of response variables for which to extract values.
Can be used in case of regression models with multiple response variables.</p>
</td></tr>
<tr><td><code id="get_response_+3A_as_proportion">as_proportion</code></td>
<td>
<p>Logical, if <code>TRUE</code> and the response value is a proportion
(e.g. <code>y1 / y2</code>), then the returned response value will be a vector with
the result of this proportion. Else, always a data frame is returned.</p>
</td></tr>
<tr><td><code id="get_response_+3A_source">source</code></td>
<td>
<p>String, indicating from where data should be recovered. If
<code>source = "environment"</code> (default), data is recovered from the environment
(e.g. if the data is in the workspace). This option is usually the fastest
way of getting data and ensures that the original variables used for model
fitting are returned. Note that always the <em>current</em> data is recovered from
the environment. Hence, if the data was modified <em>after</em> model fitting
(e.g., variables were recoded or rows filtered), the returned data may no
longer equal the model data. If <code>source = "frame"</code> (or <code>"mf"</code>), the data
is taken from the model frame. Any transformed variables are back-transformed,
if possible. This option returns the data even if it is not available in
the environment, however, in certain edge cases back-transforming to the
original data may fail. If <code>source = "environment"</code> fails to recover the
data, it tries to extract the data from the model frame; if
<code>source = "frame"</code> and data cannot be extracted from the model frame, data
will be recovered from the environment. Both ways only returns observations
that have no missing data in the variables used for model fitting.</p>
</td></tr>
<tr><td><code id="get_response_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="get_response_+3A_dichotomies">dichotomies</code></td>
<td>
<p>Logical, if model is a <code>nestedLogit</code> objects, returns
the response values for the dichotomies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The values of the response variable, as vector, or a data frame if
<code>x</code> has more than one defined response variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cbpp)
cbpp$trials &lt;- cbpp$size - cbpp$incidence
dat &lt;&lt;- cbpp

m &lt;- glm(cbind(incidence, trials) ~ period, data = dat, family = binomial)
head(get_response(m))
get_response(m, select = "incidence")

data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_response(m)

</code></pre>

<hr>
<h2 id='get_sigma'>Get residual standard deviation from models</h2><span id='topic+get_sigma'></span>

<h3>Description</h3>

<p>Returns <code>sigma</code>, which corresponds the estimated standard
deviation of the residuals. This function extends the <code>sigma()</code> base R
generic for models that don't have implemented it. It also computes the
confidence interval (CI), which is stored as an attribute.
</p>
<p>Sigma is a key-component of regression models, and part of the so-called
auxiliary parameters that are estimated. Indeed, linear models for instance
assume that the residuals comes from a normal distribution with mean 0 and
standard deviation <code>sigma</code>. See the details section below for more
information about its interpretation and calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sigma(x, ci = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sigma_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="get_sigma_+3A_ci">ci</code></td>
<td>
<p>Scalar, the CI level. The default (<code>NULL</code>) returns no CI.</p>
</td></tr>
<tr><td><code id="get_sigma_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The residual standard deviation (sigma), or <code>NULL</code> if this
information could not be accessed.
</p>


<h3>Interpretation of Sigma</h3>

<p>The residual standard deviation, &sigma;,
indicates that the predicted outcome will be within +/-
&sigma; units of the linear predictor for
approximately <code style="white-space: pre;">&#8288;68%&#8288;</code> of the data points (<em>Gelman, Hill &amp; Vehtari 2020, p.84</em>).
In other words, the residual standard deviation indicates the accuracy for a
model to predict scores, thus it can be thought of as &quot;a measure of the
average distance each observation falls from its prediction from the model&quot;
(<em>Gelman, Hill &amp; Vehtari 2020, p.168</em>).
&sigma; can be considered as a measure of
the unexplained variation in the data, or of the precision of inferences
about regression coefficients.
</p>


<h3>Calculation of Sigma</h3>

<p>By default, <code>get_sigma()</code> tries to extract sigma by calling <code>stats::sigma()</code>.
If the model-object has no <code>sigma()</code> method, the next step is calculating
sigma as square-root of the model-deviance divided by the residual degrees of
freedom. Finally, if even this approach fails, and <code>x</code> is a mixed model, the
residual standard deviation is accessed using the square-root from
<code>get_variance_residual()</code>.
</p>


<h3>References</h3>

<p>Gelman, A., Hill, J., &amp; Vehtari, A. (2020). Regression and Other
Stories. Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_sigma(m)
</code></pre>

<hr>
<h2 id='get_statistic'>Get statistic associated with estimates</h2><span id='topic+get_statistic'></span><span id='topic+get_statistic.default'></span><span id='topic+get_statistic.glmmTMB'></span><span id='topic+get_statistic.emmGrid'></span><span id='topic+get_statistic.gee'></span>

<h3>Description</h3>

<p>Returns the statistic (<em>t</em>, <code>z</code>, ...) for model
estimates. In most cases, this is the related column from
<code>coef(summary())</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_statistic(x, ...)

## Default S3 method:
get_statistic(x, column_index = 3, verbose = TRUE, ...)

## S3 method for class 'glmmTMB'
get_statistic(x, component = "all", ...)

## S3 method for class 'emmGrid'
get_statistic(x, ci = 0.95, adjust = "none", merge_parameters = FALSE, ...)

## S3 method for class 'gee'
get_statistic(x, robust = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_statistic_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="get_statistic_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_statistic_+3A_column_index">column_index</code></td>
<td>
<p>For model objects that have no defined
<code>get_statistic()</code> method yet, the default method is called. This
method tries to extract the statistic column from <code>coef(summary())</code>,
where the index of the column that is being pulled is <code>column_index</code>.
Defaults to 3, which is the default statistic column for most models'
summary-output.</p>
</td></tr>
<tr><td><code id="get_statistic_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="get_statistic_+3A_component">component</code></td>
<td>
<p>String, indicating the model component for which parameters
should be returned. The default for all models is <code>"all"</code>, which returns
the requested information for all available model components. Furthermore,
there are specific options depending on the model class. <code>component</code> then
may be one of:
</p>

<ul>
<li><p> For zero-inflated models (<code>gmmTMB</code>, <code>hurdle</code>, <code>zeroinfl</code>, ...) can also
be <code>"conditional"</code> or <code>"zero-inflated"</code>. Note that the <em>conditional</em>
component is also called <em>count</em> or <em>mean</em> component, depending on the
model. <code>glmmTMB</code> also has a <code>"dispersion"</code> component.
</p>
</li>
<li><p> For models with smooth terms, <code>component = "smooth_terms"</code> returns the
test statistic for the smooth terms.
</p>
</li>
<li><p> For models of class <code>mhurdle</code>, may also be one of  <code>"conditional"</code>,
<code>"zero_inflated"</code>, <code>"infrequent_purchase"</code> or <code>"auxiliary"</code>.
</p>
</li>
<li><p> For models of class <code>clm2</code> or <code>clmm2</code>, may also be <code>"scale"</code>.
</p>
</li>
<li><p> For models of class <code>betareg</code>, <code>betaor</code> or <code>betamfx</code>, may also be
<code>"precision"</code>. For other <code style="white-space: pre;">&#8288;*mfx&#8288;</code> models (<code>logitmfx</code>, <code>betamfx</code>, ...),
may also be <code>"marginal"</code>.
</p>
</li>
<li><p> For models of class <code>mvord</code>, may also be <code>"thresholds"</code> or
<code>"correlation"</code>.
</p>
</li>
<li><p> For models of class <code>selection</code>, may also be <code>"selection"</code>, <code>"outcome"</code>
or <code>"auxiliary"</code>.
</p>
</li>
<li><p> For models of class <code>glmx</code>, may also be <code>"extra"</code>.
</p>
</li>
<li><p> For models of class <code>averaging</code>, may also be <code>"full"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_statistic_+3A_ci">ci</code></td>
<td>
<p>Confidence Interval (CI) level. Default to <code>0.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).
Currently only applies to objects of class <code>emmGrid</code>.</p>
</td></tr>
<tr><td><code id="get_statistic_+3A_adjust">adjust</code></td>
<td>
<p>Character value naming the method used to adjust p-values or
confidence intervals. See <code>?emmeans::summary.emmGrid</code> for details.</p>
</td></tr>
<tr><td><code id="get_statistic_+3A_merge_parameters">merge_parameters</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> has multiple columns for
parameter names (like <code>emmGrid</code> objects may have), these are merged into a
single parameter column, with parameters names and values as values.</p>
</td></tr>
<tr><td><code id="get_statistic_+3A_robust">robust</code></td>
<td>
<p>Logical, if <code>TRUE</code>, test statistic based on robust
standard errors is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the model's parameter names and the related test
statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_statistic(m)
</code></pre>

<hr>
<h2 id='get_transformation'>Return function of transformed response variables</h2><span id='topic+get_transformation'></span>

<h3>Description</h3>

<p>This functions checks whether any transformation, such as log- or
exp-transforming, was applied to the response variable (dependent variable)
in a regression formula, and returns the related function that was used for
transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_transformation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_transformation_+3A_x">x</code></td>
<td>
<p>A regression model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two functions: <code style="white-space: pre;">&#8288;$transformation&#8288;</code>, the function that was used to
transform the response variable; <code style="white-space: pre;">&#8288;$inverse&#8288;</code>, the inverse-function of
<code style="white-space: pre;">&#8288;$transformation&#8288;</code> (can be used for &quot;back-transformation&quot;). If no
transformation was applied, both list-elements <code style="white-space: pre;">&#8288;$transformation&#8288;</code> and
<code style="white-space: pre;">&#8288;$inverse&#8288;</code> just return <code>function(x) x</code>. If transformation is unknown,
<code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># identity, no transformation
model &lt;- lm(Sepal.Length ~ Species, data = iris)
get_transformation(model)

# log-transformation
model &lt;- lm(log(Sepal.Length) ~ Species, data = iris)
get_transformation(model)

# log-function
get_transformation(model)$transformation(0.3)
log(0.3)

# inverse function is exp()
get_transformation(model)$inverse(0.3)
exp(0.3)
</code></pre>

<hr>
<h2 id='get_varcov'>Get variance-covariance matrix from models</h2><span id='topic+get_varcov'></span><span id='topic+get_varcov.default'></span><span id='topic+get_varcov.nestedLogit'></span><span id='topic+get_varcov.betareg'></span><span id='topic+get_varcov.clm2'></span><span id='topic+get_varcov.truncreg'></span><span id='topic+get_varcov.hurdle'></span><span id='topic+get_varcov.glmmTMB'></span><span id='topic+get_varcov.MixMod'></span><span id='topic+get_varcov.brmsfit'></span><span id='topic+get_varcov.betamfx'></span><span id='topic+get_varcov.aov'></span><span id='topic+get_varcov.mixor'></span>

<h3>Description</h3>

<p>Returns the variance-covariance, as retrieved by <code>stats::vcov()</code>, but works
for more model objects that probably don't provide a <code>vcov()</code>-method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_varcov(x, ...)

## Default S3 method:
get_varcov(x, verbose = TRUE, vcov = NULL, vcov_args = NULL, ...)

## S3 method for class 'nestedLogit'
get_varcov(
  x,
  component = "all",
  verbose = TRUE,
  vcov = NULL,
  vcov_args = NULL,
  ...
)

## S3 method for class 'betareg'
get_varcov(
  x,
  component = c("conditional", "precision", "all"),
  verbose = TRUE,
  ...
)

## S3 method for class 'clm2'
get_varcov(x, component = c("all", "conditional", "scale"), ...)

## S3 method for class 'truncreg'
get_varcov(x, component = c("conditional", "all"), verbose = TRUE, ...)

## S3 method for class 'hurdle'
get_varcov(
  x,
  component = c("conditional", "zero_inflated", "zi", "all"),
  vcov = NULL,
  vcov_args = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'glmmTMB'
get_varcov(
  x,
  component = c("conditional", "zero_inflated", "zi", "dispersion", "all"),
  verbose = TRUE,
  ...
)

## S3 method for class 'MixMod'
get_varcov(
  x,
  effects = c("fixed", "random"),
  component = c("conditional", "zero_inflated", "zi", "dispersion", "auxiliary", "all"),
  verbose = TRUE,
  ...
)

## S3 method for class 'brmsfit'
get_varcov(x, component = "conditional", verbose = TRUE, ...)

## S3 method for class 'betamfx'
get_varcov(
  x,
  component = c("conditional", "precision", "all"),
  verbose = TRUE,
  ...
)

## S3 method for class 'aov'
get_varcov(x, complete = FALSE, verbose = TRUE, ...)

## S3 method for class 'mixor'
get_varcov(x, effects = c("all", "fixed", "random"), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_varcov_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="get_varcov_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_varcov_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="get_varcov_+3A_vcov">vcov</code></td>
<td>
<p>Variance-covariance matrix used to compute uncertainty estimates
(e.g., for robust standard errors). This argument accepts a covariance
matrix, a function which returns a covariance matrix, or a string which
identifies the function to be used to compute the covariance matrix.
</p>

<ul>
<li><p> A covariance matrix
</p>
</li>
<li><p> A function which returns a covariance matrix (e.g., <code>stats::vcov()</code>)
</p>
</li>
<li><p> A string which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"vcovHC"</code>, <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>,
<code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Cluster-robust: <code>"vcovCR"</code>, <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>, <code>"CR1S"</code>,
<code>"CR2"</code>, <code>"CR3"</code>. See <code>?clubSandwich::vcovCR()</code>
</p>
</li>
<li><p> Bootstrap: <code>"vcovBS"</code>, <code>"xy"</code>, <code>"residual"</code>, <code>"wild"</code>, <code>"mammen"</code>,
<code>"webb"</code>. See <code>?sandwich::vcovBS</code>
</p>
</li>
<li><p> Other <code>sandwich</code> package functions: <code>"vcovHAC"</code>, <code>"vcovPC"</code>, <code>"vcovCL"</code>,
<code>"vcovPL"</code>.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="get_varcov_+3A_vcov_args">vcov_args</code></td>
<td>
<p>List of arguments to be passed to the function identified by
the <code>vcov</code> argument. This function is typically supplied by the <strong>sandwich</strong>
or <strong>clubSandwich</strong> packages. Please refer to their documentation (e.g.,
<code>?sandwich::vcovHAC</code>) to see the list of available arguments. If no estimation
type (argument <code>type</code>) is given, the default type for <code>"HC"</code> (or <code>"vcovHC"</code>)
equals the default from the <strong>sandwich</strong> package; for type <code>"CR"</code> (or
<code>"vcoCR"</code>), the default is set to <code>"CR3"</code>.</p>
</td></tr>
<tr><td><code id="get_varcov_+3A_component">component</code></td>
<td>
<p>Should the complete variance-covariance matrix of the model
be returned, or only for specific model components only (like count or
zero-inflated model parts)? Applies to models with zero-inflated component,
or models with precision (e.g. <code>betareg</code>) component. <code>component</code> may be one
of <code>"conditional"</code>, <code>"zi"</code>, <code>"zero-inflated"</code>, <code>"dispersion"</code>,
<code>"precision"</code>, or <code>"all"</code>. May be abbreviated. Note that the <em>conditional</em>
component is also called <em>count</em> or <em>mean</em> component, depending on the
model.</p>
</td></tr>
<tr><td><code id="get_varcov_+3A_effects">effects</code></td>
<td>
<p>Should the complete variance-covariance matrix of the model
be returned, or only for specific model parameters only? Currently only
applies to models of class <code>mixor</code>.</p>
</td></tr>
<tr><td><code id="get_varcov_+3A_complete">complete</code></td>
<td>
<p>Logical, if <code>TRUE</code>, for <code>aov</code>, returns the full
variance-covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance-covariance matrix, as <code>matrix</code>-object.
</p>


<h3>Note</h3>

<p><code>get_varcov()</code> tries to return the nearest positive definite matrix
in case of negative eigenvalues of the variance-covariance matrix. This
ensures that it is still possible, for instance, to calculate standard
errors of model parameters. A message is shown when the matrix is negative
definite and a corrected matrix is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
get_varcov(m)

# vcov of zero-inflation component from hurdle-model
data("bioChemists", package = "pscl")
mod &lt;- hurdle(art ~ phd + fem | ment, data = bioChemists, dist = "negbin")
get_varcov(mod, component = "zero_inflated")

# robust vcov of, count component from hurdle-model
data("bioChemists", package = "pscl")
mod &lt;- hurdle(art ~ phd + fem | ment, data = bioChemists, dist = "negbin")
get_varcov(
  mod,
  component = "conditional",
  vcov = "BS",
  vcov_args = list(R = 50)
)

</code></pre>

<hr>
<h2 id='get_variance'>Get variance components from random effects models</h2><span id='topic+get_variance'></span><span id='topic+get_variance_residual'></span><span id='topic+get_variance_fixed'></span><span id='topic+get_variance_random'></span><span id='topic+get_variance_distribution'></span><span id='topic+get_variance_dispersion'></span><span id='topic+get_variance_intercept'></span><span id='topic+get_variance_slope'></span><span id='topic+get_correlation_slope_intercept'></span><span id='topic+get_correlation_slopes'></span>

<h3>Description</h3>

<p>This function extracts the different variance components of a mixed model and
returns the result as list. Functions like <code>get_variance_residual(x)</code> or
<code>get_variance_fixed(x)</code> are shortcuts for <code>get_variance(x, component = "residual")</code> etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_variance(
  x,
  component = c("all", "fixed", "random", "residual", "distribution", "dispersion",
    "intercept", "slope", "rho01", "rho00"),
  verbose = TRUE,
  ...
)

get_variance_residual(x, verbose = TRUE, ...)

get_variance_fixed(x, verbose = TRUE, ...)

get_variance_random(x, verbose = TRUE, tolerance = 1e-05, ...)

get_variance_distribution(x, verbose = TRUE, ...)

get_variance_dispersion(x, verbose = TRUE, ...)

get_variance_intercept(x, verbose = TRUE, ...)

get_variance_slope(x, verbose = TRUE, ...)

get_correlation_slope_intercept(x, verbose = TRUE, ...)

get_correlation_slopes(x, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_variance_+3A_x">x</code></td>
<td>
<p>A mixed effects model.</p>
</td></tr>
<tr><td><code id="get_variance_+3A_component">component</code></td>
<td>
<p>Character value, indicating the variance component that should
be returned. By default, all variance components are returned. The
distribution-specific (<code>"distribution"</code>) and residual (<code>"residual"</code>)
variance are the most computational intensive components, and hence may
take a few seconds to calculate.</p>
</td></tr>
<tr><td><code id="get_variance_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="get_variance_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_variance_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance for singularity check of random effects, to decide
whether to compute random effect variances or not. Indicates up to which
value the convergence result is accepted. The larger tolerance is, the
stricter the test will be. See <code><a href="performance.html#topic+check_singularity">performance::check_singularity()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns different variance components from mixed models,
which are needed, for instance, to calculate r-squared measures or the
intraclass-correlation coefficient (ICC).
</p>


<h3>Value</h3>

<p>A list with following elements:
</p>

<ul>
<li> <p><code>var.fixed</code>, variance attributable to the fixed effects
</p>
</li>
<li> <p><code>var.random</code>, (mean) variance of random effects
</p>
</li>
<li> <p><code>var.residual</code>, residual variance (sum of dispersion and distribution)
</p>
</li>
<li> <p><code>var.distribution</code>, distribution-specific variance
</p>
</li>
<li> <p><code>var.dispersion</code>, variance due to additive dispersion
</p>
</li>
<li> <p><code>var.intercept</code>, the random-intercept-variance, or between-subject-variance (&tau;<sub>00</sub>)
</p>
</li>
<li> <p><code>var.slope</code>, the random-slope-variance (&tau;<sub>11</sub>)
</p>
</li>
<li> <p><code>cor.slope_intercept</code>, the random-slope-intercept-correlation (&rho;<sub>01</sub>)
</p>
</li>
<li> <p><code>cor.slopes</code>, the correlation between random slopes (&rho;<sub>00</sub>)
</p>
</li></ul>



<h3>Fixed effects variance</h3>

<p>The fixed effects variance, &sigma;<sup>2</sup><sub>f</sub>,
is the variance of the matrix-multiplication &beta;&lowast;X
(parameter vector by model matrix).
</p>


<h3>Random effects variance</h3>

<p>The random effect variance, &sigma;<sup>2</sup><sub>i</sub>,
represents the <em>mean</em> random effect variance of the model. Since this
variance reflects the &quot;average&quot; random effects variance for mixed models, it
is also appropriate for models with more complex random effects structures,
like random slopes or nested random effects. Details can be found in
<em>Johnson 2014</em>, in particular equation 10. For simple random-intercept models,
the random effects variance equals the random-intercept variance.
</p>


<h3>Distribution-specific variance</h3>

<p>The distribution-specific variance,
&sigma;<sup>2</sup><sub>d</sub>,
depends on the model family. For Gaussian models, it is
&sigma;<sup>2</sup> (i.e. <code>sigma(model)^2</code>).
For models with binary outcome, it is
<code class="reqn">\pi^2 / 3</code> for logit-link, <code>1</code> for probit-link, and <code class="reqn">\pi^2 / 6</code>
for cloglog-links. Models from Gamma-families use <code class="reqn">\mu^2</code> (as obtained
from <code>family$variance()</code>). For all other models, the distribution-specific
variance is based on lognormal approximation, <code class="reqn">log(1 + var(x) / \mu^2)</code>
(see <cite>Nakagawa et al. 2017</cite>). The expected variance of a zero-inflated
model is computed according to <em>Zuur et al. 2012, p277</em>.
</p>


<h3>Variance for the additive overdispersion term</h3>

<p>The variance for the additive overdispersion term,
&sigma;<sup>2</sup><sub><em>e</em></sub>,
represents &quot;the excess variation relative to what is expected from a certain
distribution&quot; (<em>Nakagawa et al. 2017</em>). In (most? many?) cases, this will be
<code>0</code>.
</p>


<h3>Residual variance</h3>

<p>The residual variance, &sigma;<sup>2</sup><sub>&epsilon;</sub>,
is simply &sigma;<sup>2</sup><sub>d</sub> + &sigma;<sup>2</sup><sub><em>e</em></sub>.
</p>


<h3>Random intercept variance</h3>

<p>The random intercept variance, or <em>between-subject</em> variance
(&tau;<sub>00</sub>), is obtained from
<code>VarCorr()</code>. It indicates how much groups or subjects differ from each other,
while the residual variance &sigma;<sup>2</sup><sub>&epsilon;</sub>
indicates the <em>within-subject variance</em>.
</p>


<h3>Random slope variance</h3>

<p>The random slope variance (&tau;<sub>11</sub>)
is obtained from <code>VarCorr()</code>. This measure is only available for mixed models
with random slopes.
</p>


<h3>Random slope-intercept correlation</h3>

<p>The random slope-intercept correlation
(&rho;<sub>01</sub>) is obtained from
<code>VarCorr()</code>. This measure is only available for mixed models with random
intercepts and slopes.
</p>


<h3>Note</h3>

<p>This function supports models of class <code>merMod</code> (including models
from <strong>blme</strong>), <code>clmm</code>, <code>cpglmm</code>, <code>glmmadmb</code>, <code>glmmTMB</code>, <code>MixMod</code>, <code>lme</code>,
<code>mixed</code>, <code>rlmerMod</code>, <code>stanreg</code>, <code>brmsfit</code> or <code>wbm</code>. Support for objects of
class <code>MixMod</code> (<strong>GLMMadaptive</strong>), <code>lme</code> (<strong>nlme</strong>) or <code>brmsfit</code> (<strong>brms</strong>) is
experimental and may not work for all models.
</p>


<h3>References</h3>


<ul>
<li><p> Johnson, P. C. D. (2014). Extension of Nakagawa &amp; Schielzeth’s R2 GLMM to
random slopes models. Methods in Ecology and Evolution, 5(9), 944–946.
<a href="https://doi.org/10.1111/2041-210X.12225">doi:10.1111/2041-210X.12225</a>
</p>
</li>
<li><p> Nakagawa, S., Johnson, P. C. D., &amp; Schielzeth, H. (2017). The coefficient
of determination R2 and intra-class correlation coefficient from generalized
linear mixed-effects models revisited and expanded. Journal of The Royal
Society Interface, 14(134), 20170213. <a href="https://doi.org/10.1098/rsif.2017.0213">doi:10.1098/rsif.2017.0213</a>
</p>
</li>
<li><p> Zuur, A. F., Savel'ev, A. A., &amp; Ieno, E. N. (2012). Zero inflated models
and generalized linear mixed models with R. Newburgh, United Kingdom:
Highland Statistics.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

library(lme4)
data(sleepstudy)
m &lt;- lmer(Reaction ~ Days + (1 + Days | Subject), data = sleepstudy)

get_variance(m)
get_variance_fixed(m)
get_variance_residual(m)


</code></pre>

<hr>
<h2 id='get_weights'>Get the values from model weights</h2><span id='topic+get_weights'></span><span id='topic+get_weights.default'></span>

<h3>Description</h3>

<p>Returns weighting variable of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_weights(x, ...)

## Default S3 method:
get_weights(x, na_rm = FALSE, null_as_ones = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_weights_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="get_weights_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="get_weights_+3A_na_rm">na_rm</code></td>
<td>
<p>Logical, if <code>TRUE</code>, removes possible missing values.</p>
</td></tr>
<tr><td><code id="get_weights_+3A_null_as_ones">null_as_ones</code></td>
<td>
<p>Logical, if <code>TRUE</code>, will return a vector of <code>1</code>
if no weights were specified in the model (as if the weights were all set
to 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The weighting variable, or <code>NULL</code> if no weights were specified.
If the weighting variable should also be returned (instead of <code>NULL</code>)
when all weights are set to 1 (i.e. no weighting),
set <code>null_as_ones = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
set.seed(123)
mtcars$weight &lt;- rnorm(nrow(mtcars), 1, .3)

# LMs
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars, weights = weight)
get_weights(m)

get_weights(lm(mpg ~ wt, data = mtcars), null_as_ones = TRUE)

# GLMs
m &lt;- glm(vs ~ disp + mpg, data = mtcars, weights = weight, family = quasibinomial)
get_weights(m)
m &lt;- glm(cbind(cyl, gear) ~ mpg, data = mtcars, weights = weight, family = binomial)
get_weights(m)
</code></pre>

<hr>
<h2 id='has_intercept'>Checks if model has an intercept</h2><span id='topic+has_intercept'></span>

<h3>Description</h3>

<p>Checks if model has an intercept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_intercept(x, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_intercept_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="has_intercept_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> has an intercept, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- lm(mpg ~ 0 + gear, data = mtcars)
has_intercept(model)

model &lt;- lm(mpg ~ gear, data = mtcars)
has_intercept(model)


model &lt;- lmer(Reaction ~ 0 + Days + (Days | Subject), data = sleepstudy)
has_intercept(model)

model &lt;- lmer(Reaction ~ Days + (Days | Subject), data = sleepstudy)
has_intercept(model)

</code></pre>

<hr>
<h2 id='is_converged'>Convergence test for mixed effects models</h2><span id='topic+is_converged'></span>

<h3>Description</h3>

<p><code>is_converged()</code> provides an alternative convergence
test for <code>merMod</code>-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_converged(x, tolerance = 0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_converged_+3A_x">x</code></td>
<td>
<p>A <code>merMod</code> or <code>glmmTMB</code>-object.</p>
</td></tr>
<tr><td><code id="is_converged_+3A_tolerance">tolerance</code></td>
<td>
<p>Indicates up to which value the convergence result is
accepted. The smaller <code>tolerance</code> is, the stricter the test will be.</p>
</td></tr>
<tr><td><code id="is_converged_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if convergence is fine and <code>FALSE</code> if convergence
is suspicious. Additionally, the convergence value is returned as attribute.
</p>


<h3>Convergence and log-likelihood</h3>

<p>Convergence problems typically arise when the model hasn't converged to a
solution where the log-likelihood has a true maximum. This may result in
unreliable and overly complex (or non-estimable) estimates and standard
errors.
</p>


<h3>Inspect model convergence</h3>

<p><strong>lme4</strong> performs a convergence-check (see <code>?lme4::convergence</code>), however, as
discussed <a href="https://github.com/lme4/lme4/issues/120">here</a> and suggested by
one of the lme4-authors in <a href="https://github.com/lme4/lme4/issues/120#issuecomment-39920269">this comment</a>,
this check can be too strict. <code>is_converged()</code> thus provides an alternative
convergence test for <code>merMod</code>-objects.
</p>


<h3>Resolving convergence issues</h3>

<p>Convergence issues are not easy to diagnose. The help page on <code>?lme4::convergence</code>
provides most of the current advice about how to resolve convergence issues.
Another clue might be large parameter values, e.g. estimates (on the scale of
the linear predictor) larger than 10 in (non-identity link) generalized linear
model <em>might</em> indicate complete separation, which can be addressed by
regularization, e.g. penalized regression or Bayesian regression with
appropriate priors on the fixed effects.
</p>


<h3>Convergence versus Singularity</h3>

<p>Note the different meaning between singularity and convergence: singularity
indicates an issue with the &quot;true&quot; best estimate, i.e. whether the maximum
likelihood estimation for the variance-covariance matrix of the random effects
is positive definite or only semi-definite. Convergence is a question of
whether we can assume that the numerical optimization has worked correctly
or not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cbpp)
set.seed(1)
cbpp$x &lt;- rnorm(nrow(cbpp))
cbpp$x2 &lt;- runif(nrow(cbpp))

model &lt;- glmer(
  cbind(incidence, size - incidence) ~ period + x + x2 + (1 + x | herd),
  data = cbpp,
  family = binomial()
)

is_converged(model)



model &lt;- glmmTMB(
  Sepal.Length ~ poly(Petal.Width, 4) * poly(Petal.Length, 4) +
    (1 + poly(Petal.Width, 4) | Species),
  data = iris
)

is_converged(model)


</code></pre>

<hr>
<h2 id='is_empty_object'>Check if object is empty</h2><span id='topic+is_empty_object'></span>

<h3>Description</h3>

<p>Check if object is empty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_empty_object(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_empty_object_+3A_x">x</code></td>
<td>
<p>A list, a vector, or a dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether the entered object is empty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_empty_object(c(1, 2, 3, NA))
is_empty_object(list(NULL, c(NA, NA)))
is_empty_object(list(NULL, NA))
</code></pre>

<hr>
<h2 id='is_gam_model'>Checks if a model is a generalized additive model</h2><span id='topic+is_gam_model'></span>

<h3>Description</h3>

<p>Small helper that checks if a model is a generalized additive
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_gam_model(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_gam_model_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical, <code>TRUE</code> if <code>x</code> is a generalized additive model
<em>and</em> has smooth-terms
</p>


<h3>Note</h3>

<p>This function only returns <code>TRUE</code> when the model inherits from a
typical GAM model class <em>and</em> when smooth terms are present in the model
formula. If model has no smooth terms or is not from a typical gam class,
<code>FALSE</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
model1 &lt;- lm(Petal.Length ~ Petal.Width + Sepal.Length, data = iris)
model2 &lt;- mgcv::gam(Petal.Length ~ Petal.Width + s(Sepal.Length), data = iris)
is_gam_model(model1)
is_gam_model(model2)

</code></pre>

<hr>
<h2 id='is_mixed_model'>Checks if a model is a mixed effects model</h2><span id='topic+is_mixed_model'></span>

<h3>Description</h3>

<p>Small helper that checks if a model is a mixed effects model,
i.e. if it the model has random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mixed_model(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_mixed_model_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical, <code>TRUE</code> if <code>x</code> is a mixed model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
model &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
is_mixed_model(model)

data(sleepstudy, package = "lme4")
model &lt;- lme4::lmer(Reaction ~ Days + (1 | Subject), data = sleepstudy)
is_mixed_model(model)

</code></pre>

<hr>
<h2 id='is_model'>Checks if an object is a regression model or statistical test object</h2><span id='topic+is_model'></span><span id='topic+is_regression_model'></span>

<h3>Description</h3>

<p>Small helper that checks if a model is a regression model or
a statistical object. <code>is_regression_model()</code> is stricter and only
returns <code>TRUE</code> for regression models, but not for, e.g., <code>htest</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_model(x)

is_regression_model(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_model_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns <code>TRUE</code> if <code>x</code> is a model object.
</p>


<h3>Value</h3>

<p>A logical, <code>TRUE</code> if <code>x</code> is a (supported) model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)

is_model(m)
is_model(mtcars)

test &lt;- t.test(1:10, y = c(7:20))
is_model(test)
is_regression_model(test)
</code></pre>

<hr>
<h2 id='is_model_supported'>Checks if a regression model object is supported by the insight package</h2><span id='topic+is_model_supported'></span><span id='topic+supported_models'></span>

<h3>Description</h3>

<p>Small helper that checks if a model is a <em>supported</em>
(regression) model object. <code>supported_models()</code> prints a list
of currently supported model classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_model_supported(x)

supported_models()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_model_supported_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns <code>TRUE</code> if <code>x</code> is a model object that works with the
package's functions. A list of supported models can also be found here:
<a href="https://github.com/easystats/insight">https://github.com/easystats/insight</a>.
</p>


<h3>Value</h3>

<p>A logical, <code>TRUE</code> if <code>x</code> is a (supported) model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)

is_model_supported(m)
is_model_supported(mtcars)

# to see all supported models
supported_models()

</code></pre>

<hr>
<h2 id='is_multivariate'>Checks if an object stems from a multivariate response model</h2><span id='topic+is_multivariate'></span>

<h3>Description</h3>

<p>Small helper that checks if a model is a multivariate response
model, i.e. a model with multiple outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_multivariate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_multivariate_+3A_x">x</code></td>
<td>
<p>A model object, or an object returned by a function from this
package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical, <code>TRUE</code> if either <code>x</code> is a model object and is a multivariate
response model, or <code>TRUE</code> if a return value from a function of <strong>insight</strong>
is from a multivariate response model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(rstanarm)
data("pbcLong")
model &lt;- suppressWarnings(stan_mvmer(
  formula = list(
    logBili ~ year + (1 | id),
    albumin ~ sex + year + (year | id)
  ),
  data = pbcLong,
  chains = 1, cores = 1, seed = 12345, iter = 1000,
  show_messages = FALSE, refresh = 0
))

f &lt;- find_formula(model)
is_multivariate(model)
is_multivariate(f)


</code></pre>

<hr>
<h2 id='is_nested_models'>Checks whether a list of models are nested models</h2><span id='topic+is_nested_models'></span>

<h3>Description</h3>

<p>Checks whether a list of models are nested models, strictly
following the order they were passed to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_nested_models(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_nested_models_+3A_...">...</code></td>
<td>
<p>Multiple regression model objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The term &quot;nested&quot; here means that all the fixed predictors of a
model are contained within the fixed predictors of a larger model (sometimes
referred to as the encompassing model). Currently, <code>is_nested_models()</code> ignores
random effects parameters.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if models are nested, <code>FALSE</code> otherwise. If models
are nested, also returns two attributes that indicate whether nesting of
models is in decreasing or increasing order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lm(Sepal.Length ~ Petal.Width + Species, data = iris)
m2 &lt;- lm(Sepal.Length ~ Species, data = iris)
m3 &lt;- lm(Sepal.Length ~ Petal.Width, data = iris)
m4 &lt;- lm(Sepal.Length ~ 1, data = iris)

is_nested_models(m1, m2, m4)
is_nested_models(m4, m2, m1)
is_nested_models(m1, m2, m3)
</code></pre>

<hr>
<h2 id='is_nullmodel'>Checks if model is a null-model (intercept-only)</h2><span id='topic+is_nullmodel'></span>

<h3>Description</h3>

<p>Checks if model is a null-model (intercept-only), i.e. if
the conditional part of the model has no predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_nullmodel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_nullmodel_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a null-model, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- lm(mpg ~ 1, data = mtcars)
is_nullmodel(model)

model &lt;- lm(mpg ~ gear, data = mtcars)
is_nullmodel(model)

data(sleepstudy, package = "lme4")
model &lt;- lme4::lmer(Reaction ~ 1 + (Days | Subject), data = sleepstudy)
is_nullmodel(model)

model &lt;- lme4::lmer(Reaction ~ Days + (Days | Subject), data = sleepstudy)
is_nullmodel(model)

</code></pre>

<hr>
<h2 id='link_function'>Get link-function from model object</h2><span id='topic+link_function'></span><span id='topic+link_function.betamfx'></span><span id='topic+link_function.gamlss'></span><span id='topic+link_function.betareg'></span><span id='topic+link_function.DirichletRegModel'></span>

<h3>Description</h3>

<p>Returns the link-function from a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_function(x, ...)

## S3 method for class 'betamfx'
link_function(x, what = c("mean", "precision"), ...)

## S3 method for class 'gamlss'
link_function(x, what = c("mu", "sigma", "nu", "tau"), ...)

## S3 method for class 'betareg'
link_function(x, what = c("mean", "precision"), ...)

## S3 method for class 'DirichletRegModel'
link_function(x, what = c("mean", "precision"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_function_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="link_function_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="link_function_+3A_what">what</code></td>
<td>
<p>For <code>gamlss</code> models, indicates for which distribution
parameter the link (inverse) function should be returned; for
<code>betareg</code> or <code>DirichletRegModel</code>, can be <code>"mean"</code> or
<code>"precision"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function, describing the link-function from a model-object.
For multivariate-response models, a list of functions is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example from ?stats::glm
counts &lt;- c(18, 17, 15, 20, 10, 20, 25, 13, 12)
outcome &lt;- gl(3, 1, 9)
treatment &lt;- gl(3, 3)
m &lt;- glm(counts ~ outcome + treatment, family = poisson())

link_function(m)(0.3)
# same as
log(0.3)
</code></pre>

<hr>
<h2 id='link_inverse'>Get link-inverse function from model object</h2><span id='topic+link_inverse'></span><span id='topic+link_inverse.betareg'></span><span id='topic+link_inverse.DirichletRegModel'></span><span id='topic+link_inverse.betamfx'></span><span id='topic+link_inverse.gamlss'></span>

<h3>Description</h3>

<p>Returns the link-inverse function from a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_inverse(x, ...)

## S3 method for class 'betareg'
link_inverse(x, what = c("mean", "precision"), ...)

## S3 method for class 'DirichletRegModel'
link_inverse(x, what = c("mean", "precision"), ...)

## S3 method for class 'betamfx'
link_inverse(x, what = c("mean", "precision"), ...)

## S3 method for class 'gamlss'
link_inverse(x, what = c("mu", "sigma", "nu", "tau"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_inverse_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="link_inverse_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="link_inverse_+3A_what">what</code></td>
<td>
<p>For <code>gamlss</code> models, indicates for which distribution
parameter the link (inverse) function should be returned; for
<code>betareg</code> or <code>DirichletRegModel</code>, can be <code>"mean"</code> or
<code>"precision"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function, describing the inverse-link function from a model-object.
For multivariate-response models, a list of functions is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example from ?stats::glm
counts &lt;- c(18, 17, 15, 20, 10, 20, 25, 13, 12)
outcome &lt;- gl(3, 1, 9)
treatment &lt;- gl(3, 3)
m &lt;- glm(counts ~ outcome + treatment, family = poisson())

link_inverse(m)(0.3)
# same as
exp(0.3)
</code></pre>

<hr>
<h2 id='model_info'>Access information from model objects</h2><span id='topic+model_info'></span><span id='topic+model_info.default'></span>

<h3>Description</h3>

<p>Retrieve information from model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_info(x, ...)

## Default S3 method:
model_info(x, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_info_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="model_info_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="model_info_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model_info()</code> returns a list with information about the
model for many different model objects. Following information
is returned, where all values starting with <code>is_</code> are logicals.
</p>

<ul>
<li> <p><code>is_binomial</code>: family is binomial (but not negative binomial)
</p>
</li>
<li> <p><code>is_bernoulli</code>: special case of binomial models: family is Bernoulli
</p>
</li>
<li> <p><code>is_poisson</code>: family is poisson
</p>
</li>
<li> <p><code>is_negbin</code>: family is negative binomial
</p>
</li>
<li> <p><code>is_count</code>: model is a count model (i.e. family is either poisson or negative binomial)
</p>
</li>
<li> <p><code>is_beta</code>: family is beta
</p>
</li>
<li> <p><code>is_betabinomial</code>: family is beta-binomial
</p>
</li>
<li> <p><code>is_orderedbeta</code>: family is ordered beta
</p>
</li>
<li> <p><code>is_dirichlet</code>: family is dirichlet
</p>
</li>
<li> <p><code>is_exponential</code>: family is exponential (e.g. Gamma or Weibull)
</p>
</li>
<li> <p><code>is_logit</code>: model has logit link
</p>
</li>
<li> <p><code>is_probit</code>: model has probit link
</p>
</li>
<li> <p><code>is_linear</code>: family is gaussian
</p>
</li>
<li> <p><code>is_tweedie</code>: family is tweedie
</p>
</li>
<li> <p><code>is_ordinal</code>: family is ordinal or cumulative link
</p>
</li>
<li> <p><code>is_cumulative</code>: family is ordinal or cumulative link
</p>
</li>
<li> <p><code>is_multinomial</code>: family is multinomial or categorical link
</p>
</li>
<li> <p><code>is_categorical</code>: family is categorical link
</p>
</li>
<li> <p><code>is_censored</code>: model is a censored model (has a censored response, including survival models)
</p>
</li>
<li> <p><code>is_truncated</code>: model is a truncated model (has a truncated response)
</p>
</li>
<li> <p><code>is_survival</code>: model is a survival model
</p>
</li>
<li> <p><code>is_zero_inflated</code>: model has zero-inflation component
</p>
</li>
<li> <p><code>is_hurdle</code>: model has zero-inflation component and is a hurdle-model (truncated family distribution)
</p>
</li>
<li> <p><code>is_dispersion</code>: model has dispersion component (not only dispersion <em>parameter</em>)
</p>
</li>
<li> <p><code>is_mixed</code>: model is a mixed effects model (with random effects)
</p>
</li>
<li> <p><code>is_multivariate</code>: model is a multivariate response model (currently only works for <em>brmsfit</em> and <em>vglm/vgam</em> objects)
</p>
</li>
<li> <p><code>is_trial</code>: model response contains additional information about the trials
</p>
</li>
<li> <p><code>is_bayesian</code>: model is a Bayesian model
</p>
</li>
<li> <p><code>is_gam</code>: model is a generalized additive model
</p>
</li>
<li> <p><code>is_anova</code>: model is an Anova object
</p>
</li>
<li> <p><code>is_ttest</code>: model is an an object of class <code>htest</code>, returned by <code>t.test()</code>
</p>
</li>
<li> <p><code>is_correlation</code>: model is an an object of class <code>htest</code>, returned by <code>cor.test()</code>
</p>
</li>
<li> <p><code>is_ranktest</code>: model is an an object of class <code>htest</code>, returned by <code>cor.test()</code>
(if Spearman's rank correlation), <code>wilcox.text()</code> or <code>kruskal.test()</code>.
</p>
</li>
<li> <p><code>is_variancetest</code>: model is an an object of class <code>htest</code>, returned by
<code>bartlett.test()</code>, <code>shapiro.test()</code> or <code>car::leveneTest()</code>.
</p>
</li>
<li> <p><code>is_levenetest</code>: model is an an object of class <code>anova</code>, returned by <code>car::leveneTest()</code>.
</p>
</li>
<li> <p><code>is_onewaytest</code>: model is an an object of class <code>htest</code>, returned by <code>oneway.test()</code>
</p>
</li>
<li> <p><code>is_proptest</code>: model is an an object of class <code>htest</code>, returned by <code>prop.test()</code>
</p>
</li>
<li> <p><code>is_binomtest</code>: model is an an object of class <code>htest</code>, returned by <code>binom.test()</code>
</p>
</li>
<li> <p><code>is_chi2test</code>: model is an an object of class <code>htest</code>, returned by <code>chisq.test()</code>
</p>
</li>
<li> <p><code>is_xtab</code>: model is an an object of class <code>htest</code> or <code>BFBayesFactor</code>, and
test-statistic stems from a contingency table (i.e. <code>chisq.test()</code> or
<code>BayesFactor::contingencyTableBF()</code>).
</p>
</li>
<li> <p><code>link_function</code>: the link-function
</p>
</li>
<li> <p><code>family</code>: name of the distributional family of the model. For some
exceptions (like some <code>htest</code> objects), can also be the name of the test.
</p>
</li>
<li> <p><code>n_obs</code>: number of observations
</p>
</li>
<li> <p><code>n_grouplevels</code>: for mixed models, returns names and numbers of random effect groups
</p>
</li></ul>



<h3>Value</h3>

<p>A list with information about the model, like family, link-function
etc. (see 'Details').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ldose &lt;- rep(0:5, 2)
numdead &lt;- c(1, 4, 9, 13, 18, 20, 0, 2, 6, 10, 12, 16)
sex &lt;- factor(rep(c("M", "F"), c(6, 6)))
SF &lt;- cbind(numdead, numalive = 20 - numdead)
dat &lt;- data.frame(ldose, sex, SF, stringsAsFactors = FALSE)
m &lt;- glm(SF ~ sex * ldose, family = binomial)

# logistic regression
model_info(m)

# t-test
m &lt;- t.test(1:10, y = c(7:20))
model_info(m)
</code></pre>

<hr>
<h2 id='model_name'>Name the model</h2><span id='topic+model_name'></span><span id='topic+model_name.default'></span>

<h3>Description</h3>

<p>Returns the &quot;name&quot; (class attribute) of a model, possibly including further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_name(x, ...)

## Default S3 method:
model_name(x, include_formula = FALSE, include_call = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_name_+3A_x">x</code></td>
<td>
<p>A model.</p>
</td></tr>
<tr><td><code id="model_name_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="model_name_+3A_include_formula">include_formula</code></td>
<td>
<p>Should the name include the model's formula.</p>
</td></tr>
<tr><td><code id="model_name_+3A_include_call">include_call</code></td>
<td>
<p>If <code>TRUE</code>, will return the function call as a name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of a name (which usually equals the model's class attribute).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lm(Sepal.Length ~ Petal.Width, data = iris)
model_name(m)
model_name(m, include_formula = TRUE)
model_name(m, include_call = TRUE)

model_name(lme4::lmer(Sepal.Length ~ Sepal.Width + (1 | Species), data = iris))

</code></pre>

<hr>
<h2 id='n_grouplevels'>Count number of random effect levels in a mixed model</h2><span id='topic+n_grouplevels'></span>

<h3>Description</h3>

<p>Returns the number of group levels of random effects from mixed models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_grouplevels(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_grouplevels_+3A_x">x</code></td>
<td>
<p>A mixed model.</p>
</td></tr>
<tr><td><code id="n_grouplevels_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed to the function. Currently,
you can use <code>data</code> to provide the model data, if available, to avoid
retrieving model data multiple times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of group levels in the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sleepstudy, package = "lme4")
set.seed(12345)
sleepstudy$grp &lt;- sample(1:5, size = 180, replace = TRUE)
sleepstudy$subgrp &lt;- NA
for (i in 1:5) {
  filter_group &lt;- sleepstudy$grp == i
  sleepstudy$subgrp[filter_group] &lt;-
    sample(1:30, size = sum(filter_group), replace = TRUE)
}
model &lt;- lme4::lmer(
  Reaction ~ Days + (1 | grp / subgrp) + (1 | Subject),
  data = sleepstudy
)
n_grouplevels(model)

</code></pre>

<hr>
<h2 id='n_obs'>Get number of observations from a model</h2><span id='topic+n_obs'></span><span id='topic+n_obs.glm'></span><span id='topic+n_obs.svyolr'></span><span id='topic+n_obs.afex_aov'></span><span id='topic+n_obs.stanmvreg'></span>

<h3>Description</h3>

<p>This method returns the number of observation that were used
to fit the model, as numeric value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_obs(x, ...)

## S3 method for class 'glm'
n_obs(x, disaggregate = FALSE, ...)

## S3 method for class 'svyolr'
n_obs(x, weighted = FALSE, ...)

## S3 method for class 'afex_aov'
n_obs(x, shape = c("long", "wide"), ...)

## S3 method for class 'stanmvreg'
n_obs(x, select = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_obs_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="n_obs_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="n_obs_+3A_disaggregate">disaggregate</code></td>
<td>
<p>For binomial models with aggregated data, <code>n_obs()</code>
returns the number of data rows by default. If <code>disaggregate = TRUE</code>,
the total number of trials is returned instead (determined by summing the
results of <code>weights()</code> for aggregated data, which will be either the
weights input for proportion success response or the row sums of the
response matrix if matrix response, see 'Examples').</p>
</td></tr>
<tr><td><code id="n_obs_+3A_weighted">weighted</code></td>
<td>
<p>For survey designs, returns the weighted sample size.</p>
</td></tr>
<tr><td><code id="n_obs_+3A_shape">shape</code></td>
<td>
<p>Return long or wide data? Only applicable in repeated measures
designs.</p>
</td></tr>
<tr><td><code id="n_obs_+3A_select">select</code></td>
<td>
<p>Optional name(s) of response variables for which to extract values.
Can be used in case of regression models with multiple response variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of observations used to fit the model, or <code>NULL</code> if
this information is not available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
m &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
n_obs(m)


data(cbpp, package = "lme4")
m &lt;- glm(
  cbind(incidence, size - incidence) ~ period,
  data = cbpp,
  family = binomial(link = "logit")
)
n_obs(m)
n_obs(m, disaggregate = TRUE)

</code></pre>

<hr>
<h2 id='n_parameters'>Count number of parameters in a model</h2><span id='topic+n_parameters'></span><span id='topic+n_parameters.default'></span><span id='topic+n_parameters.merMod'></span><span id='topic+n_parameters.glmmTMB'></span><span id='topic+n_parameters.zeroinfl'></span><span id='topic+n_parameters.gam'></span><span id='topic+n_parameters.brmsfit'></span>

<h3>Description</h3>

<p>Returns the number of parameters (coefficients) of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_parameters(x, ...)

## Default S3 method:
n_parameters(x, remove_nonestimable = FALSE, ...)

## S3 method for class 'merMod'
n_parameters(
  x,
  effects = c("fixed", "random"),
  remove_nonestimable = FALSE,
  ...
)

## S3 method for class 'glmmTMB'
n_parameters(
  x,
  effects = c("fixed", "random"),
  component = c("all", "conditional", "zi", "zero_inflated"),
  remove_nonestimable = FALSE,
  ...
)

## S3 method for class 'zeroinfl'
n_parameters(
  x,
  component = c("all", "conditional", "zi", "zero_inflated"),
  remove_nonestimable = FALSE,
  ...
)

## S3 method for class 'gam'
n_parameters(
  x,
  component = c("all", "conditional", "smooth_terms"),
  remove_nonestimable = FALSE,
  ...
)

## S3 method for class 'brmsfit'
n_parameters(x, effects = "all", component = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_parameters_+3A_x">x</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="n_parameters_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="n_parameters_+3A_remove_nonestimable">remove_nonestimable</code></td>
<td>
<p>Logical, if <code>TRUE</code>, removes (i.e. does not
count) non-estimable parameters (which may occur for models with
rank-deficient model matrix).</p>
</td></tr>
<tr><td><code id="n_parameters_+3A_effects">effects</code></td>
<td>
<p>Should number of parameters for fixed effects, random effects
or both be returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="n_parameters_+3A_component">component</code></td>
<td>
<p>Should total number of parameters, number parameters for the
conditional model, the zero-inflated part of the model, the dispersion term
or the instrumental variables be returned? Applies to models with
zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of parameters in the model.
</p>


<h3>Note</h3>

<p>This function returns the number of parameters for the fixed effects by
default, as returned by <code>find_parameters(x, effects = "fixed")</code>. It does not
include <em>all</em> estimated model parameters, i.e. auxiliary parameters like
sigma or dispersion are not counted. To get the number of <em>all estimated</em>
parameters, use <code>get_df(x, type = "model")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
model &lt;- lm(Sepal.Length ~ Sepal.Width * Species, data = iris)
n_parameters(model)
</code></pre>

<hr>
<h2 id='null_model'>Compute intercept-only model for regression models</h2><span id='topic+null_model'></span>

<h3>Description</h3>

<p>This function computes the null-model (i.e. <code>(y ~ 1)</code>) of
a model. For mixed models, the null-model takes random effects into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_model(model, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_model_+3A_model">model</code></td>
<td>
<p>A (mixed effects) model.</p>
</td></tr>
<tr><td><code id="null_model_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="null_model_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The null-model of <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sleepstudy)
m &lt;- lmer(Reaction ~ Days + (1 + Days | Subject), data = sleepstudy)
summary(m)
summary(null_model(m))

</code></pre>

<hr>
<h2 id='object_has_names'>Check names and rownames</h2><span id='topic+object_has_names'></span><span id='topic+object_has_rownames'></span>

<h3>Description</h3>

<p><code>object_has_names()</code> checks if specified names are present in the given object.
<code>object_has_rownames()</code> checks if rownames are present in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_has_names(x, names)

object_has_rownames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_has_names_+3A_x">x</code></td>
<td>
<p>A named object (an atomic vector, a list, a dataframe, etc.).</p>
</td></tr>
<tr><td><code id="object_has_names_+3A_names">names</code></td>
<td>
<p>A single character or a vector of characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical or a vector of logicals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# check if specified names are present in the given object
object_has_names(mtcars, "am")
object_has_names(anscombe, c("x1", "z1", "y1"))
object_has_names(list("x" = 1, "y" = 2), c("x", "a"))

# check if a dataframe has rownames
object_has_rownames(mtcars)

</code></pre>

<hr>
<h2 id='print_color'>Coloured console output</h2><span id='topic+print_color'></span><span id='topic+print_colour'></span><span id='topic+color_text'></span><span id='topic+colour_text'></span><span id='topic+color_theme'></span>

<h3>Description</h3>

<p>Convenient function that allows coloured output in the console.
Mainly implemented to reduce package dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_color(text, color)

print_colour(text, colour)

color_text(text, color)

colour_text(text, colour)

color_theme()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_color_+3A_text">text</code></td>
<td>
<p>The text to print.</p>
</td></tr>
<tr><td><code id="print_color_+3A_color">color</code>, <code id="print_color_+3A_colour">colour</code></td>
<td>
<p>Character vector, indicating the colour for printing.
May be one of <code>"white"</code>, <code>"black"</code>, <code>"red"</code>, <code>"yellow"</code>, <code>"green"</code>, <code>"blue"</code>,
<code>"violet"</code>, <code>"cyan"</code> or <code>"grey"</code>. Bright variants of colors are available
by adding the prefix <code>"b"</code> (or <code>"br_"</code> or <code>"bright_"</code>), e.g. <code>"bred"</code> (or
<code>"br_red"</code> resp. <code>"bright_red"</code>). Background colors can be set by adding
the prefix <code>"bg_"</code> (e.g. <code>"bg_red"</code>). Formatting is also possible with <code>"bold"</code>
or <code>"italic"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints <code>text</code> directly to the console using
<code>cat()</code>, so no string is returned. <code>color_text()</code>, however,
returns only the formatted string, without using <code>cat()</code>.
<code>color_theme()</code> either returns <code>"dark"</code> when RStudio is used
with dark color scheme, <code>"light"</code> when it's used with light theme,
and <code>NULL</code> if the theme could not be detected.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print_color("I'm blue dabedi dabedei", "blue")
</code></pre>

<hr>
<h2 id='print_parameters'>Prepare summary statistics of model parameters for printing</h2><span id='topic+print_parameters'></span>

<h3>Description</h3>

<p>This function takes a data frame, typically a data frame with information on
summaries of model parameters like <code><a href="bayestestR.html#topic+describe_posterior">bayestestR::describe_posterior()</a></code>,
<code><a href="bayestestR.html#topic+hdi">bayestestR::hdi()</a></code> or <code><a href="parameters.html#topic+model_parameters">parameters::model_parameters()</a></code>, as input and splits
this information into several parts, depending on the model. See details
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_parameters(
  x,
  ...,
  split_by = c("Effects", "Component", "Group", "Response"),
  format = "text",
  parameter_column = "Parameter",
  keep_parameter_column = TRUE,
  remove_empty_column = FALSE,
  titles = NULL,
  subtitles = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_parameters_+3A_x">x</code></td>
<td>
<p>A fitted model, or a data frame returned by <code><a href="#topic+clean_parameters">clean_parameters()</a></code>.</p>
</td></tr>
<tr><td><code id="print_parameters_+3A_...">...</code></td>
<td>
<p>One or more objects (data frames), which contain information about
the model parameters and related statistics (like confidence intervals, HDI,
ROPE, ...).</p>
</td></tr>
<tr><td><code id="print_parameters_+3A_split_by">split_by</code></td>
<td>
<p><code>split_by</code> should be a character vector with one or
more of the following elements: <code>"Effects"</code>, <code>"Component"</code>,
<code>"Response"</code> and <code>"Group"</code>. These are the column names returned
by <code><a href="#topic+clean_parameters">clean_parameters()</a></code>, which is used to extract the information
from which the group or component model parameters belong. If <code>NULL</code>, the
merged data frame is returned. Else, the data frame is split into a list,
split by the values from those columns defined in <code>split_by</code>.</p>
</td></tr>
<tr><td><code id="print_parameters_+3A_format">format</code></td>
<td>
<p>Name of output-format, as string. If <code>NULL</code> (or <code>"text"</code>),
assumed use for output is basic printing. If <code>"markdown"</code>, markdown-format
is assumed. This only affects the style of title- and table-caption
attributes, which are used in <code><a href="#topic+export_table">export_table()</a></code>.</p>
</td></tr>
<tr><td><code id="print_parameters_+3A_parameter_column">parameter_column</code></td>
<td>
<p>String, name of the column that contains the
parameter names. Usually, for data frames returned by functions the
easystats-packages, this will be <code>"Parameter"</code>.</p>
</td></tr>
<tr><td><code id="print_parameters_+3A_keep_parameter_column">keep_parameter_column</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the data frames in the
returned list have both a <code>"Cleaned_Parameter"</code> and <code>"Parameter"</code>
column. If <code>FALSE</code>, the (unformatted) <code>"Parameter"</code> is removed,
and the column with cleaned parameter names (<code>"Cleaned_Parameter"</code>) is
renamed into <code>"Parameter"</code>.</p>
</td></tr>
<tr><td><code id="print_parameters_+3A_remove_empty_column">remove_empty_column</code></td>
<td>
<p>Logical, if <code>TRUE</code>, columns with completely
empty character values will be removed.</p>
</td></tr>
<tr><td><code id="print_parameters_+3A_titles">titles</code>, <code id="print_parameters_+3A_subtitles">subtitles</code></td>
<td>
<p>By default, the names of the model components (like
fixed or random effects, count or zero-inflated model part) are added as
attributes <code>"table_title"</code> and <code>"table_subtitle"</code> to each list
element returned by <code>print_parameters()</code>. These attributes are then
extracted and used as table (sub) titles in <code><a href="#topic+export_table">export_table()</a></code>.
Use <code>titles</code> and <code>subtitles</code> to override the default attribute
values for <code>"table_title"</code> and <code>"table_subtitle"</code>. <code>titles</code>
and <code>subtitles</code> may be any length from 1 to same length as returned
list elements. If <code>titles</code> and <code>subtitles</code> are shorter than
existing elements, only the first default attributes are overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prepares data frames that contain information
about model parameters for clear printing.
</p>
<p>First, <code>x</code> is required, which should either be a model object or a
prepared data frame as returned by <code><a href="#topic+clean_parameters">clean_parameters()</a></code>. If
<code>x</code> is a model, <code>clean_parameters()</code> is called on that model
object to get information with which model components the parameters
are associated.
</p>
<p>Then, <code>...</code> take one or more data frames that also contain information
about parameters from the same model, but also have additional information
provided by other methods. For instance, a data frame in <code>...</code> might
be the result of, for instance, <code><a href="bayestestR.html#topic+describe_posterior">bayestestR::describe_posterior()</a></code>,
or <code><a href="parameters.html#topic+model_parameters">parameters::model_parameters()</a></code>, where we have a) a
<code>Parameter</code> column and b) columns with other parameter values (like
CI, HDI, test statistic, etc.).
</p>
<p>Now we have a data frame with model parameters and information about the
association to the different model components, a data frame with model
parameters, and some summary statistics. <code>print_parameters()</code> then merges
these data frames, so the parameters or statistics of interest are also
associated with the different model components. The data frame is split into
a list, so for a clear printing. Users can loop over this list and print each
component for a better overview. Further, parameter names are &quot;cleaned&quot;, if
necessary, also for a cleaner print. See also 'Examples'.
</p>


<h3>Value</h3>

<p>A data frame or a list of data frames (if <code>split_by</code> is not <code>NULL</code>). If a
list is returned, the element names reflect the model components where the
extracted information in the data frames belong to, e.g.
<code>random.zero_inflated.Intercept: persons</code>. This is the data frame that
contains the parameters for the random effects from group-level &quot;persons&quot;
from the zero-inflated model component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(bayestestR)
model &lt;- download_model("brms_zi_2")
x &lt;- hdi(model, effects = "all", component = "all")

# hdi() returns a data frame; here we use only the
# information on parameter names and HDI values
tmp &lt;- as.data.frame(x)[, 1:4]
tmp

# Based on the "split_by" argument, we get a list of data frames that
# is split into several parts that reflect the model components.
print_parameters(model, tmp)

# This is the standard print()-method for "bayestestR::hdi"-objects.
# For printing methods, it is easy to print complex summary statistics
# in a clean way to the console by splitting the information into
# different model components.
x


</code></pre>

<hr>
<h2 id='standardize_column_order'>Standardize column order</h2><span id='topic+standardize_column_order'></span><span id='topic+standardize_column_order.parameters_model'></span>

<h3>Description</h3>

<p>Standardizes order of columns for dataframes and other objects from
<em>easystats</em> and <em>broom</em> ecosystem packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_column_order(data, ...)

## S3 method for class 'parameters_model'
standardize_column_order(data, style = c("easystats", "broom"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_column_order_+3A_data">data</code></td>
<td>
<p>A data frame. In particular, objects from <em>easystats</em>
package functions like <code><a href="parameters.html#topic+model_parameters">parameters::model_parameters()</a></code> or
<code><a href="effectsize.html#topic+effectsize">effectsize::effectsize()</a></code> are accepted, but also data frames returned by
<code>broom::tidy()</code> are valid objects.</p>
</td></tr>
<tr><td><code id="standardize_column_order_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="standardize_column_order_+3A_style">style</code></td>
<td>
<p>Standardization can either be based on the naming conventions
from the <a href="https://easystats.github.io/easystats/">easystats-project</a>, or on
<strong>broom</strong>'s naming scheme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, with standardized column order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># easystats conventions
df1 &lt;- cbind.data.frame(
  CI_low      = -2.873,
  t           = 5.494,
  CI_high     = -1.088,
  p           = 0.00001,
  Parameter   = -1.980,
  CI          = 0.95,
  df          = 29.234,
  Method      = "Student's t-test"
)

standardize_column_order(df1, style = "easystats")

# broom conventions
df2 &lt;- cbind.data.frame(
  conf.low   = -2.873,
  statistic  = 5.494,
  conf.high  = -1.088,
  p.value    = 0.00001,
  estimate   = -1.980,
  conf.level = 0.95,
  df         = 29.234,
  method     = "Student's t-test"
)

standardize_column_order(df2, style = "broom")
</code></pre>

<hr>
<h2 id='standardize_names'>Standardize column names</h2><span id='topic+standardize_names'></span><span id='topic+standardize_names.parameters_model'></span>

<h3>Description</h3>

<p>Standardize column names from data frames, in particular objects returned
from <code><a href="parameters.html#topic+model_parameters">parameters::model_parameters()</a></code>, so column names are consistent and
the same for any model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_names(data, ...)

## S3 method for class 'parameters_model'
standardize_names(
  data,
  style = c("easystats", "broom"),
  ignore_estimate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_names_+3A_data">data</code></td>
<td>
<p>A data frame. In particular, objects from <em>easystats</em>
package functions like <code><a href="parameters.html#topic+model_parameters">parameters::model_parameters()</a></code> or
<code><a href="effectsize.html#topic+effectsize">effectsize::effectsize()</a></code> are accepted, but also data frames returned by
<code>broom::tidy()</code> are valid objects.</p>
</td></tr>
<tr><td><code id="standardize_names_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="standardize_names_+3A_style">style</code></td>
<td>
<p>Standardization can either be based on the naming conventions
from the <a href="https://easystats.github.io/easystats/">easystats-project</a>, or on
<strong>broom</strong>'s naming scheme.</p>
</td></tr>
<tr><td><code id="standardize_names_+3A_ignore_estimate">ignore_estimate</code></td>
<td>
<p>Logical, if <code>TRUE</code>, column names like <code>"mean"</code> or
<code>"median"</code> will <em>not</em> be converted to <code>"Coefficient"</code> resp. <code>"estimate"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is in particular useful for package developers or users
who use, e.g., <code><a href="parameters.html#topic+model_parameters">parameters::model_parameters()</a></code> in their own code or
functions to retrieve model parameters for further processing. As
<code>model_parameters()</code> returns a data frame with varying column names
(depending on the input), accessing the required information is probably
not quite straightforward. In such cases, <code>standardize_names()</code> can be
used to get consistent, i.e. always the same column names, no matter what
kind of model was used in <code>model_parameters()</code>.
</p>
<p>For <code>style = "broom"</code>, column names are renamed to match <strong>broom</strong>'s
naming scheme, i.e. <code>Parameter</code> is renamed to <code>term</code>, <code>Coefficient</code> becomes
<code>estimate</code> and so on.
</p>
<p>For <code>style = "easystats"</code>, when <code>data</code> is an object from <code>broom::tidy()</code>,
column names are converted from &quot;broom&quot;-style into &quot;easystats&quot;-style.
</p>


<h3>Value</h3>

<p>A data frame, with standardized column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- lm(mpg ~ wt + cyl, data = mtcars)
mp &lt;- model_parameters(model)

as.data.frame(mp)
standardize_names(mp)
standardize_names(mp, style = "broom")

</code></pre>

<hr>
<h2 id='text_remove_backticks'>Remove backticks from a string</h2><span id='topic+text_remove_backticks'></span><span id='topic+text_remove_backticks.data.frame'></span>

<h3>Description</h3>

<p>This function removes backticks from a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_remove_backticks(x, ...)

## S3 method for class 'data.frame'
text_remove_backticks(x, column = "Parameter", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_remove_backticks_+3A_x">x</code></td>
<td>
<p>A character vector, a data frame or a matrix. If a matrix,
backticks are removed from the column and row names, not from values
of a character vector.</p>
</td></tr>
<tr><td><code id="text_remove_backticks_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="text_remove_backticks_+3A_column">column</code></td>
<td>
<p>If <code>x</code> is a data frame, specify the column of character
vectors, where backticks should be removed. If <code>NULL</code>, all character
vectors are processed.</p>
</td></tr>
<tr><td><code id="text_remove_backticks_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, where all backticks are removed.
</p>


<h3>Note</h3>

<p>If <code>x</code> is a character vector or data frame, backticks are removed from
the elements of that character vector (or character vectors from the data
frame.) If <code>x</code> is a matrix, the behaviour slightly differs: in this case,
backticks are removed from the column and row names. The reason for this
behaviour is that this function mainly serves formatting coefficient names.
For <code>vcov()</code> (a matrix), row and column names equal the coefficient names
and therefore are manipulated then.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example model
data(iris)
iris$`a m` &lt;- iris$Species
iris$`Sepal Width` &lt;- iris$Sepal.Width
model &lt;- lm(`Sepal Width` ~ Petal.Length + `a m`, data = iris)

# remove backticks from string
names(coef(model))
text_remove_backticks(names(coef(model)))

# remove backticks from character variable in a data frame
# column defaults to "Parameter".
d &lt;- data.frame(
  Parameter = names(coef(model)),
  Estimate = unname(coef(model))
)
d
text_remove_backticks(d)
</code></pre>

<hr>
<h2 id='trim_ws'>Small helper functions</h2><span id='topic+trim_ws'></span><span id='topic+trim_ws.data.frame'></span><span id='topic+n_unique'></span><span id='topic+n_unique.default'></span><span id='topic+safe_deparse'></span><span id='topic+safe_deparse_symbol'></span><span id='topic+has_single_value'></span>

<h3>Description</h3>

<p>Collection of small helper functions. <code>trim_ws()</code> is an
efficient function to trim leading and trailing whitespaces from character
vectors or strings. <code>n_unique()</code> returns the number of unique values in a
vector. <code>has_single_value()</code> is equivalent to <code>n_unique() == 1</code> but is faster.
<code>safe_deparse()</code> is comparable to <code>deparse1()</code>, i.e. it can safely
deparse very long expressions into a single string. <code>safe_deparse_symbol()</code>
only deparses a substituted expressions when possible, which can be much faster
than <code>deparse(substitute())</code> for those cases where <code>substitute()</code> returns no
valid object name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_ws(x, ...)

## S3 method for class 'data.frame'
trim_ws(x, character_only = TRUE, ...)

n_unique(x, ...)

## Default S3 method:
n_unique(x, na.rm = TRUE, ...)

safe_deparse(x, ...)

safe_deparse_symbol(x)

has_single_value(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_ws_+3A_x">x</code></td>
<td>
<p>A (character) vector, or for some functions may also be a data frame.</p>
</td></tr>
<tr><td><code id="trim_ws_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="trim_ws_+3A_character_only">character_only</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a data frame or list,
only processes character vectors.</p>
</td></tr>
<tr><td><code id="trim_ws_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, if missing values should be removed from the input.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>n_unique()</code>: For a vector, <code>n_unique</code> always returns an integer value,
even if the input is <code>NULL</code> (the return value will be <code>0</code> then). For data
frames or lists, <code>n_unique()</code> returns a named numeric vector, with the
number of unique values for each element.
</p>
</li>
<li> <p><code>has_single_value()</code>: <code>TRUE</code> if <code>x</code> has only one unique value,
<code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>trim_ws()</code>: A character vector, where trailing and leading white spaces
are removed.
</p>
</li>
<li> <p><code>safe_deparse()</code>: A character string of the unevaluated expression or symbol.
</p>
</li>
<li> <p><code>safe_deparse_symbol()</code>: A character string of the unevaluated expression
or symbol, if <code>x</code> was a symbol. If <code>x</code> is no symbol (i.e. if <code>is.name(x)</code>
would return <code>FALSE</code>), <code>NULL</code> is returned.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>trim_ws("  no space!  ")
n_unique(iris$Species)
has_single_value(c(1, 1, 2))

# safe_deparse_symbol() compared to deparse(substitute())
safe_deparse_symbol(as.name("test"))
deparse(substitute(as.name("test")))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
