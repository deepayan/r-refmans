<!DOCTYPE html><html lang="en"><head><title>Help for package geiger</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geiger}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geiger-package'>
<p>GEIGER</p></a></li>
<li><a href='#aicm'>
<p>Akaike's Information Criterion for MCMC samples (AICM)</p></a></li>
<li><a href='#aicw'>
<p>determining Akaike weights</p></a></li>
<li><a href='#aov.phylo'><p>phylogenetic ANOVA and MANOVA</p></a></li>
<li><a href='#bd.ms'><p> estimate net diversification rate</p></a></li>
<li><a href='#calibrate.mecca'>
<p>calibrating MECCA</p></a></li>
<li><a href='#calibrate.rjmcmc'>
<p>initialize proposal width</p></a></li>
<li><a href='#congruify.phylo'>
<p>ultrametricization of trees from a supplied timetree</p></a></li>
<li><a href='#dcount'>
<p>prior densities for truncated discrete random variable</p></a></li>
<li><a href='#drop.extinct'><p>prune specified taxa from a phylogenetic tree</p></a></li>
<li><a href='#dtt'><p>disparity-through-time</p></a></li>
<li><a href='#fitContinuous'><p> Model fitting for continuous comparative data</p></a></li>
<li><a href='#fitContinuousMCMC'>
<p>Fit models of continuous trait evolution to comparative data using MCMC</p></a></li>
<li><a href='#fitDiscrete'><p> Model fitting for discrete comparative data</p></a></li>
<li><a href='#gbresolve'><p> NCBI taxonomy</p></a></li>
<li><a href='#geiger-data'><p>example datasets</p></a></li>
<li><a href='#geiger-defunct'><p>deprecated functions in GEIGER</p></a></li>
<li><a href='#geiger-example'><p>internal geiger functions</p></a></li>
<li><a href='#geiger-internal'><p>internal geiger functions</p></a></li>
<li><a href='#load.rjmcmc'><p>posterior samples from single or multiple MCMC runs</p></a></li>
<li><a href='#make.gbm'>
<p>tailor reversible-jump Markov chain Monte Carlo sampling</p></a></li>
<li><a href='#mecca'>
<p>running a MECCA analysis</p></a></li>
<li><a href='#medusa'>
<p>MEDUSA: modeling evolutionary diversification using stepwise AIC</p></a></li>
<li><a href='#name.check'><p> Compares taxa in data and tree</p></a></li>
<li><a href='#nh.test'>
<p>using the Freckleton and Harvey node-height test</p></a></li>
<li><a href='#nodelabel.phylo'>
<p>Blending information from taxonomies and trees</p></a></li>
<li><a href='#plot.medusa'>
<p>MEDUSA: modeling evolutionary diversification using stepwise AIC</p></a></li>
<li><a href='#pp.mcmc'>
<p>using posterior predictive MCMC for modeling quantitative trait evolution</p></a></li>
<li><a href='#r8s.phylo'>
<p>call r8s from geiger</p></a></li>
<li><a href='#ratematrix'><p>evolutionary VCV matrix</p></a></li>
<li><a href='#rc'><p> relative cladogenesis test</p></a></li>
<li><a href='#rescale.phylo'><p>Rescale object of class <code>"phylo"</code></p></a></li>
<li><a href='#rjmcmc.bm'><p>Bayesian sampling of shifts in trait evolution: relaxed Brownian motion</p></a></li>
<li><a href='#sim.bd'><p>birth-death population simulator</p></a></li>
<li><a href='#sim.bdtree'><p>birth-death tree simulator</p></a></li>
<li><a href='#sim.char'><p> simulate character evolution</p></a></li>
<li><a href='#startingpt.mecca'>
<p>starting values for MECCA</p></a></li>
<li><a href='#subset.phylo'>
<p>blending information from taxonomies and trees</p></a></li>
<li><a href='#tips'><p>descendents of a given node in a phylogenetic tree</p></a></li>
<li><a href='#to.auteur'>
<p>conversion of MCMC samples between auteur and coda</p></a></li>
<li><a href='#treedata'><p> compare taxa in data and tree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Evolutionary Diversification</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Harmon, Matthew Pennell, Chad Brock, Joseph Brown, Wendell Challenger,
	Jon Eastman, Rich FitzJohn, Rich Glor, Gene Hunt, Liam Revell, Graham Slater,
	Josef Uyeda, Jason Weir and CRAN team (corrections in 2022)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Harmon &lt;lukeh@uidaho.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>ape (&ge; 3.0-6), R (&ge; 2.15.0), phytools (&ge; 1.5-1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, mvtnorm, subplex, deSolve (&ge; 1.7), digest, Rcpp (&ge;
0.11.0), coda, ncbit, colorspace, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>TreeSim</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for fitting macroevolutionary models to phylogenetic trees
	Pennell (2014) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtu181">doi:10.1093/bioinformatics/btu181</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-01 18:14:35 UTC; liamj</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-03 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='geiger-package'>
GEIGER
</h2><span id='topic+geiger-package'></span><span id='topic+geiger'></span>

<h3>Description</h3>

<p>A package for macroevolutionary simulation and estimating parameters 
related to diversification from comparative phylogenetic data.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> geiger</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL version 2 or greater?</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>LJ Harmon, J Weir, C Brock, RE Glor, W Challenger, G Hunt, R FitzJohn, MW Pennell, GJ Slater, JW Brown, J Uyeda, and JM Eastman
</p>
<p>Maintainer: Matt Pennell &lt;mwpennell@gmail.com&gt;
</p>

<hr>
<h2 id='aicm'>
Akaike's Information Criterion for MCMC samples (AICM)
</h2><span id='topic+aicm'></span>

<h3>Description</h3>

<p>Computes Akaike's Information Criterion for MCMC samples (AICM: see Raftery et al. 2007). Can be used to perform model selection using output from fitContinuousMCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aicm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicm_+3A_x">x</code></td>
<td>

<p>a vector containing sampled likelihoods from the MCMC chain. Assumes that burn-in has been removed prior to computation of AICM score.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AICM is one way of comparing model fit using posterior likelihood samples. It has advantages over approaches such as thermodynamic integration in that it uses the chain output directly and thus has little added time cost. Furthermore, it has been shown to perform better than the harmonic mean estimator of the marginal likelihood. However, it is also less robust than stepping-stone or thermodynamic integration approaches and should be used with care.
</p>


<h3>Value</h3>

<p>AICM - Akaike's Information Criterion for the posterior sample 
</p>


<h3>Author(s)</h3>

<p>Graham Slater
</p>


<h3>References</h3>

<p>Raftery et al. 2007. Estimating the integrated likelihood via posterior simulation using the harmonic mean identity. In. Bernardo et al. (eds) Bayesian Statistics. Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a random set of values from a normal distribution, 
## similar to a set of likelihood samples obtained via MCMC.

x &lt;- rnorm(1000, -275, 2);
aicm(x);

</code></pre>

<hr>
<h2 id='aicw'>
determining Akaike weights
</h2><span id='topic+aicw'></span>

<h3>Description</h3>

<p>This function computes Akaike Weights and ranks model based on their support from a vector of AIC scores. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aicw(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicw_+3A_x">x</code></td>
<td>

<p>a named vector of AIC scores
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An nx3 matrix, where n is the number of models being compared. The first column contains the AIC scores, the second contains the deltaAIC score and the third the Akaike Weight. Models are ranked in descending order according to weight. Rownames are the model names taken from the input vector.
</p>


<h3>Author(s)</h3>

<p>Graham Slater
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AIC.scores &lt;- c(3,7,-5, 6)
names(AIC.scores) &lt;- c("model1", "model2", "model3", "model4")
aicw(AIC.scores)
</code></pre>

<hr>
<h2 id='aov.phylo'>phylogenetic ANOVA and MANOVA</h2><span id='topic+aov.phylo'></span>

<h3>Description</h3>

<p>computing phylogenetic ANOVA or MANOVA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aov.phylo(formula, phy, nsim = 1000, 
    test = c("Wilks", "Pillai", "Hotelling-Lawley", "Roy"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aov.phylo_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the model (see <b>Examples</b>)</p>
</td></tr>
<tr><td><code id="aov.phylo_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="aov.phylo_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to run</p>
</td></tr>
<tr><td><code id="aov.phylo_+3A_test">test</code></td>
<td>
<p>test statistic to apply if MANOVA</p>
</td></tr>
<tr><td><code id="aov.phylo_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>print.anova</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs an ANOVA or MANOVA in a phylogenetic context.  First, the test statistic for ANOVA 
(one dependent variable) or MANOVA (more than one dependent variable) is calculated.  The null distribution 
of this test statistic is then obtained by simulating new sets of dependent variables on the phylogenetic
tree.  Simulations are run under a Brownian-motion model.  For ANOVA, the rate parameter is estimated from 
the average squared independent contrast; for MANOVA the simulations use an estimated variance-covariance
matrix from <code><a href="#topic+ratematrix">ratematrix</a></code>.
</p>
<p>For MANOVA, you can specify the test statistic for the summary table.  Wilks' statistic is most popular in the 
literature and for further details, see <code><a href="stats.html#topic+summary.manova">summary.manova</a></code>.
</p>


<h3>Value</h3>

<p>The function prints (and returns) a standard ANOVA or MANOVA table and p-value based on simulations (from the <code>Pr(phy)</code> column). For convenience, the summary table is included as an attribute of the returned object (see <b>Examples</b>).
</p>


<h3>Author(s)</h3>

<p> JM Eastman and LJ Harmon </p>


<h3>References</h3>

<p>Garland T Jr, AW Dickerman, CM Janis, and JA Jones. 1993. Phylogenetic analysis of covariance by computer simulation. <em>Systematic Biology</em> 42(3):265-292.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+aov">aov</a></code>; <code><a href="stats.html#topic+anova">anova</a></code>; <code><a href="stats.html#topic+summary.manova">summary.manova</a></code>; <code><a href="#topic+ratematrix">ratematrix</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
geo=get(data(geospiza))
dat=geo$dat
d1=dat[,1]
grp&lt;-as.factor(c(rep(0, 7), rep(1, 6)))
names(grp)=rownames(dat)

## MANOVA
x=aov.phylo(dat~grp, geo$phy, nsim=50, test="Wilks")
print(attributes(x)$summary) # summary table

## ANOVA
x1=aov.phylo(d1~grp, geo$phy, nsim=50)

## End(Not run)
</code></pre>

<hr>
<h2 id='bd.ms'> estimate net diversification rate </h2><span id='topic+bd.ms'></span><span id='topic+bd.km'></span><span id='topic+stem.p'></span><span id='topic+crown.p'></span><span id='topic+crown.limits'></span><span id='topic+stem.limits'></span>

<h3>Description</h3>

<p>estimating net diversification rate with confidence limits and testing diversities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bd.ms(phy=NULL, time, n, missing = 0, crown=TRUE, epsilon = 0)
bd.km(phy=NULL, time, n, missing = 0, crown=TRUE)
crown.p(phy=NULL, time, n, r, epsilon)
stem.p(phy=NULL, time, n, r, epsilon)
crown.limits(time, r, epsilon, CI=0.95)
stem.limits(time, r, epsilon, CI=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bd.ms_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo' (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="bd.ms_+3A_time">time</code></td>
<td>
<p> time interval (can be a vector) </p>
</td></tr>
<tr><td><code id="bd.ms_+3A_n">n</code></td>
<td>
<p>number of extant species</p>
</td></tr>
<tr><td><code id="bd.ms_+3A_r">r</code></td>
<td>
<p>net diversification rate, birth - death </p>
</td></tr>
<tr><td><code id="bd.ms_+3A_epsilon">epsilon</code></td>
<td>
<p> extinction rate as a fraction of speciation rate </p>
</td></tr>
<tr><td><code id="bd.ms_+3A_missing">missing</code></td>
<td>
<p> number of taxa missing from tree </p>
</td></tr>
<tr><td><code id="bd.ms_+3A_crown">crown</code></td>
<td>
<p>whether time is treated as crown age (or otherwise as stem age)</p>
</td></tr>
<tr><td><code id="bd.ms_+3A_ci">CI</code></td>
<td>
<p>confidence level for estimated parameters</p>
</td></tr>
</table>


<h3>Details</h3>

	
<p><code>bd.ms</code> uses the Magallon and Sanderson (2000) method to calculate net diversification rate for a clade given extant diversity and age. <code>bd.km</code> 
computes the Kendall-Moran estimate of speciation rate, which assumes a complete phylogenetic tree.
</p>
<p>Associated functions <code>crown.p</code> and <code>stem.p</code> also calculate the probability of obtaining a clade with at least <code>n</code> species given 
a net diversification rate (<code>r</code>), extinction fraction (<code>epsilon</code>), and <code>time</code> interval. Associated functions <code>stem.limits</code> and 
<code>crown.limits</code> generate confidence limits on extant diversity given a net diversification rate (<code>r</code>), extinction fraction (<code>epsilon</code>), 
and <code>time</code> interval.
</p>
<p>Where a function calls for a <code>time</code> and an <code>n</code> element, a tree may be given instead (as argument <code>phy</code>). The argument <code>n</code> is taken from the number of tips in the tree. The method 
will attempt to discern whether the model should be fitted assuming <code>crown</code> or <code>stem</code>.  If the tree has a non-NULL <code>phy$root.edge</code> element, the length will be assumed for the stem and <code>crown</code> is assumed to be <code>FALSE</code> (see also <code><a href="ape.html#topic+read.tree">read.tree</a></code>). 
</p>


<h3>Value</h3>


<ul>
<li><p><b>bd.ms</b> returns net diversification rate (<code>r</code> = <code>lambda</code> - <code>mu</code>)
</p>
</li>
<li><p><b>bd.km</b> returns speciation rate assuming a completely sampled tree
</p>
</li>
<li><p><b>crown.p</b> and <b>stem.p</b> return the probability of obtaining a clade as big as (or bigger than) size <code>n</code>, given 
<code>time</code>, <code>r</code>, and <code>epsilon</code>
</p>
</li>
<li><p><b>crown.limits</b> and <b>stem.limits</b> return lower (<code>lb</code>) and upper (<code>ub</code>) confidence intervals for clade size given <code>time</code>, 
<code>r</code>, and <code>epsilon</code>	
</p>
</li></ul>



<h3>Author(s)</h3>

<p> LJ Harmon and C Brock </p>


<h3>References</h3>

 
<p>Magallon S and MJ Sanderson. 2000. Absolute diversification rates in angiosperm clades. <em>Evolution</em> 55:1762-1780.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

geo=get(data(geospiza))

# Assuming no extinction
bd.ms(phy=geo$phy, missing=1, epsilon=0)

# Assuming high extinction
bd.ms(phy=geo$phy, missing=1, epsilon=0.9)


</code></pre>

<hr>
<h2 id='calibrate.mecca'>
calibrating MECCA
</h2><span id='topic+calibrate.mecca'></span>

<h3>Description</h3>

<p>Runs a user defined number of calibration simulations (Wegmann et al. 2009) to generate tuning parameters MECCA's ABC-MCMC. The function takes a large number of arguments but in most cases these can remain at default settings. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate.mecca(phy, richness, model = c("BM", "Trend", "twoRate"), 
	prior.list = list(priorSigma = c(-4.961845, 4.247066), priorMean = c(-10, 10)), 
	Ncalibrations = 10000, sigmaPriorType = "uniform", rootPriorType = "uniform", 
	divSampleFreq = 0, initPars = "ML", propWidth = 0.1,
        SigmaBounds = c(-4.961845, 4.247066), 
	hotclade = NULL, BOXCOX = TRUE, optimRange = c(-1000, 10))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrate.mecca_+3A_phy">phy</code></td>
<td>

<p>A time calibrated phylogenetic tree of class &quot;phylo&quot;
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_richness">richness</code></td>
<td>

<p>A named vector of species richnesses corresponding to tips in the tree; if a tip does not represent a higher level taxon, its richness should be 1. 
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_model">model</code></td>
<td>

<p>The model of trait evolution to be used. Options currently implemented are: &quot;BM&quot; = Brownian Motion, &quot;Trend&quot; = Brownian moton with a trend, &quot;twoRate&quot; = two Brownian rate model (see hotclade below).
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_prior.list">prior.list</code></td>
<td>

<p>A namedlist containing prior distribution parameters. If no values are specified, default values will be used. Default values for the BM rate are taken from the range reported in Harmon et al. 2010.
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_ncalibrations">Ncalibrations</code></td>
<td>

<p>The number of calibration simulations to use. No fewer than 10,000 are recommended.
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_sigmapriortype">sigmaPriorType</code></td>
<td>

<p>The type of prior distribution on the Brownian rate parameter. Currently, uniform and normal are implemented.
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_rootpriortype">rootPriorType</code></td>
<td>

<p>The type of prior distribution on the root state rate parameter. Currently, uniform is implemented.
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_divsamplefreq">divSampleFreq</code></td>
<td>

<p>Should new trees be simulated at every step? The default (0) is yes. If a non-zero value is given, this will determine the frequency (every n steps) with which new tip trees are simulated. This option is designed for use with large datasets where simulating new trees will slow MECCA down considerably.
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_initpars">initPars</code></td>
<td>

<p>Should Maximum Likelihood (&quot;ML&quot;) values be used to start the diversification rate sampler? if not, two numeric values should be specified for speciation and extinction rates.
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_propwidth">propWidth</code></td>
<td>

<p>Proposal width for the diversification MCMC. The default value of 0.1 seems to work well.
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_sigmabounds">SigmaBounds</code></td>
<td>

<p>If a normal prior is used for the trait evolution rate, it can be bounded with reasonable values to ensure that the chain does not get stuck in areas of low likelihood. Default values correspond to the range of rates reported in Harmon et al. (2010).
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_hotclade">hotclade</code></td>
<td>

<p>If a two-rate model is to be fit, which clade takes the second rate? There are two ways to do this - either a clade is designated or a single edge. For a clade, two tip names that span the clade of interest should be specified in a vector. If a single edge is to be used pass a two-item vector, where the first item is a single terminal name (for a tip branch) or the number of a node (for an internal edge) and the second item is NULL
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_boxcox">BOXCOX</code></td>
<td>

<p>Will summaries be BOX-COX standardized? Default is yes and is recommended. Raw summaries will be returned, along with parameters for Box-Cox transformation.
</p>
</td></tr>
<tr><td><code id="calibrate.mecca_+3A_optimrange">optimRange</code></td>
<td>

<p>Optimization range for the lambda parameter for Box-Cox. Default params should work in most cases.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>$diversification</code></td>
<td>
<p>A 3-column matrix containing 1) birth-rates and 2) death-rates sampled by the MCMC, plus 3) their associated likelihoods</p>
</td></tr>
<tr><td><code>$trait</code></td>
<td>
<p>A matrix of trait evolution parameters sampled from their priors and summary statistics from the simulations. If BM is used, columns 1 and 2 are the rate and root state parameter samples. If Trend or twoRate are the models, the first two columns are the same but the third contains the additional rate or trend parameter</p>
</td></tr>
<tr><td><code>$stdz</code>, <code>$lambda</code>, <code>$GM</code>, <code>$BoxCox</code></td>
<td>
<p>If BOXCOX = T, these items will also be output to BoxCox transform simulations in the MCMC</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Tree simulation is done using modified code from Tanja Stadler's TreeSim package. Trait evolution is done using modified code from Liam Revell's phytools package.
</p>


<h3>Author(s)</h3>

<p>Graham J Slater, Luke Harmon, Dan Wegmann
</p>


<h3>References</h3>

<p>Slater, GJ, Harmon, LJ, Wegmann D, Joyce, P., Revell, LJ, Alfaro ME. in press. Evolution, also Wegmann D, Leuenberger C, Excoffier L. 2009. Genetics 182:1207-1218.
Harmon LJ et al. 2010. Early Bursts of body size and shape evolution are rare in comparative data. Evolution 64: 2385 - 2396</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example(mecca)

</code></pre>

<hr>
<h2 id='calibrate.rjmcmc'>
initialize proposal width
</h2><span id='topic+calibrate.rjmcmc'></span>

<h3>Description</h3>

<p>estimating a reasonable proposal width to initiate sampling for Markov sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate.rjmcmc(phy, dat, nstep = 10000, widths = 2^(-3:3), type=c("bm", 
    "rbm", "jump-bm", "jump-rbm"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrate.rjmcmc_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="calibrate.rjmcmc_+3A_dat">dat</code></td>
<td>
<p>a named vector of continuous trait values, associated with each species in <code>phy</code></p>
</td></tr>
<tr><td><code id="calibrate.rjmcmc_+3A_nstep">nstep</code></td>
<td>
<p>number of proposal steps over which to assess proposal widths</p>
</td></tr>
<tr><td><code id="calibrate.rjmcmc_+3A_widths">widths</code></td>
<td>
<p>if unspecified, a series of proposal widths from 1/8 to 8 will be considered</p>
</td></tr>
<tr><td><code id="calibrate.rjmcmc_+3A_type">type</code></td>
<td>
<p>a model type available in <code><a href="#topic+rjmcmc.bm">rjmcmc.bm</a></code></p>
</td></tr>
<tr><td><code id="calibrate.rjmcmc_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+make.gbm">make.gbm</a></code> and <code><a href="#topic+rjmcmc.bm">rjmcmc.bm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be useful for constraining subsequent runs after an adequate proposal width has been approximated. MCMC samples from this calibration are not stored and do not become available to the user. This function is solely used to give the user a sense of acceptance rates that can be expected for different proposal widths. The narrower the width, the more easily the chain can become stuck. With a wider width, the chain will more quickly explore a broader parameter space, yet acceptance rates may become unacceptably low.</p>


<h3>Author(s)</h3>

<p>JM Eastman</p>


<h3>See Also</h3>

<p><code><a href="#topic+rjmcmc.bm">rjmcmc.bm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n=40
phy=rcoal(n=n)
dat=rTraitCont(phy=phy, model="BM", sigma=sqrt(0.1))
r=paste(sample(letters,9,replace=TRUE),collapse="")

## calibrate proposal width
calibrate.rjmcmc(phy=phy, dat=dat, nstep=500, widths=2^(-3:0), type="rbm")	

</code></pre>

<hr>
<h2 id='congruify.phylo'>
ultrametricization of trees from a supplied timetree</h2><span id='topic+congruify.phylo'></span>

<h3>Description</h3>

<p>automagically generating secondary calibrations</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruify.phylo(reference, target, taxonomy = NULL, tol = 0,
  scale=c(NA, "PATHd8", "treePL"), ncores=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="congruify.phylo_+3A_reference">reference</code></td>
<td>
<p>an ultrametric tree used to time-scale the <code>target</code></p>
</td></tr>
<tr><td><code id="congruify.phylo_+3A_target">target</code></td>
<td>
<p>a phylogram that is sought to be ultrametricized based on the <code>reference</code> phylogeny</p>
</td></tr>
<tr><td><code id="congruify.phylo_+3A_taxonomy">taxonomy</code></td>
<td>
<p>a linkage table between tips of the phylogeny and clades represented in the tree; rownames of 'taxonomy' should be tips found in the phylogeny</p>
</td></tr>
<tr><td><code id="congruify.phylo_+3A_tol">tol</code></td>
<td>
<p>branching time in <code>reference</code> above which secondary constraints will be applied to <code>target</code></p>
</td></tr>
<tr><td><code id="congruify.phylo_+3A_scale">scale</code></td>
<td>
<p><code>NA</code>, <code>"PATHd8"</code> or <code>"treePL"</code> (if <code>PATHd8</code> or <code>"treePL"</code> are available in the R <code>PATH</code>)</p>
</td></tr>
<tr><td><code id="congruify.phylo_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code>reference</code> to inform secondary calibrations in the <code>target</code>. The primary output is a table of 'congruent' nodes between the <code>reference</code>
and <code>target</code> with associated dates extracted from corresponding nodes in the <code>reference</code>.
</p>
<p>If multiple trees are supplied as the <code>reference</code>, a 'congruification' table is generated for each.
</p>
<p>If <code>scale="PATHd8"</code>, the <code>target</code> will be smoothed by <code>PATHd8</code> using the &quot;d8 calculation&quot; (see <a href="http://www2.math.su.se/PATHd8/PATHd8manual.pdf">http://www2.math.su.se/PATHd8/PATHd8manual.pdf</a>).
This scaling method requires that <code>PATHd8</code> is available on the user's <code>PATH</code> variable that can be accessed by <code><a href="base.html#topic+Sys.getenv">Sys.getenv</a>("PATH")</code>.
</p>
<p>If <code>scale="treePL"</code>, the <code>target</code> will be smoothed by <code>treePL</code>.
This scaling method requires that <code>treePL</code> is available on the user's <code>PATH</code> variable that can be accessed by <code><a href="base.html#topic+Sys.getenv">Sys.getenv</a>("PATH")</code>.
</p>


<h3>Author(s)</h3>

<p>JM Eastman</p>


<h3>References</h3>

<p>Eastman JM, LJ Harmon, and DC Tank. 2013. Congruification: support for time scaling large phylogenetic trees. <em>Methods in Ecology and Evolution</em>, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sal=get(data(caudata))
res=congruify.phylo(sal$fam, sal$phy, sal$tax, tol=0, scale=NA, ncores=2)
print(res$calibrations)
plot(ladderize(sal$phy,right=FALSE), cex=0.35, type="fan", label.offset=2.5)
plot(ladderize(sal$fam,right=FALSE), cex=0.5, type="fan", label.offset=2.5, no.margin=FALSE)

# if you have PATHd8 installed you can also run
# res=congruify.phylo(sal$fam, sal$phy, sal$tax, tol=0, scale=\"PATHd8\")
# print(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='dcount'>
prior densities for truncated discrete random variable
</h2><span id='topic+dcount'></span>

<h3>Description</h3>

<p>creating a prior density function for a truncated discrete random variable</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcount(x, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dcount_+3A_x">x</code></td>
<td>
<p>an integer vector spanning from the minimal to maximal values</p>
</td></tr>
<tr><td><code id="dcount_+3A_fun">FUN</code></td>
<td>
<p>a probability density function (see <b>Examples</b>)</p>
</td></tr>
<tr><td><code id="dcount_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>JM Eastman</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.gbm">make.gbm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>range=0:100
u=dcount(range, FUN=dunif, min=min(range), max=max(range))
g=dcount(range, FUN=dgeom, prob=0.05)
p=dcount(range, FUN=dtpois, min=min(range), max=max(range), lambda=0.5)
priors=list(pois=p, geom=g, unif=u)
plot(range(range), c(0,1), xlab="index", ylab="cumsum(prob)", type="n", bty="n")
for(i in 1:length(priors)){
	points(attributes(attributes(priors[[i]])$density)$cumsum, col=i, pch=22, cex=0.35)
}
legend("bottomright", bty="n", legend=names(priors), col=1:length(priors), pch=22)


## LN prior probabilities
print(u(0))	## dunif
print(g(0))	## dgeom
print(p(0)) ## dtpois
</code></pre>

<hr>
<h2 id='drop.extinct'>prune specified taxa from a phylogenetic tree</h2><span id='topic+drop.extinct'></span><span id='topic+is.extinct'></span><span id='topic+drop.random'></span>

<h3>Description</h3>

<p>pruning a set of taxa from a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop.extinct(phy, tol = NULL)
drop.random(phy, n)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop.extinct_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="drop.extinct_+3A_tol">tol</code></td>
<td>
<p>rounding-error tolerance for taxa that do not reach the present day exactly</p>
</td></tr>
<tr><td><code id="drop.extinct_+3A_n">n</code></td>
<td>
<p>number of random taxa to prune from the tree</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions prune taxa from a tree either at random or based either on a temporal criterion (whether the leaves reach the present within a given <code>tol</code>). By default, <code>tol = min(phy$edge.length)/100</code>. The result is a tree that has been pruned based on the given criterion. The function <code>is.extinct</code> will return a vector of the tip labels of inferred extinct taxa (or NULL is no extinct taxa exist).</p>


<h3>Author(s)</h3>

<p>LJ Harmon, and JW Brown
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+drop.tip">drop.tip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Birth-death tree with extinct taxa
p1 &lt;- sim.bdtree(b=0.2, d=0.1, stop="time", seed=1, t=30)
plot(p1, cex=0.25)

# List extinct taxa
p1.extinct &lt;- is.extinct(p1)

# Previous tree with extinct taxa removed
p2 &lt;- drop.extinct(p1)
plot(p2, cex=0.5)


</code></pre>

<hr>
<h2 id='dtt'>disparity-through-time</h2><span id='topic+dtt'></span><span id='topic+disparity'></span>

<h3>Description</h3>

<p>calculating and plotting disparity-through-time for a phylogenetic tree and 
phenotypic data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disparity(phy=NULL, data, index = c("avg.sq", "avg.manhattan", "num.states"))
dtt(phy, data, index=c("avg.sq", "avg.manhattan", "num.states"),
    mdi.range=c(0,1), nsim=0, CI=0.95, plot=TRUE, calculateMDIp=F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtt_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="dtt_+3A_data">data</code></td>
<td>
<p>a named vector or matrix of continuous trait values, associated with species in <code>phy</code></p>
</td></tr>
<tr><td><code id="dtt_+3A_index">index</code></td>
<td>
<p>disparity index to use (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="dtt_+3A_mdi.range">mdi.range</code></td>
<td>
<p>time range over which to calculate MDI statistic</p>
</td></tr>
<tr><td><code id="dtt_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations used to calculate null disparity-through-time plot (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="dtt_+3A_ci">CI</code></td>
<td>
<p>confidence level from which to plot simulated disparities</p>
</td></tr>
<tr><td><code id="dtt_+3A_plot">plot</code></td>
<td>
<p>whether to plot disparities through time</p>
</td></tr>
<tr><td><code id="dtt_+3A_calculatemdip">calculateMDIp</code></td>
<td>
<p>calculate p-value for MDI compared to null; only valid if nsim is not zero</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most complete implementation of <code>dtt</code> (where <code>nsim</code> is greater than 0) carries out the entire disparity-through-time (DTT) procedure described in Harmon et al. 2003, where simulated data are used to construct a null DTT distribution. The function <code>disparity</code> simply computes the morphological disparity for a set of species. Note that for <code>mdi.range</code>, time is relative to a total tree length of 1. The default <code>mdi.range</code> is the entire temporal span of the tree, from 0 (root) to 1 (tips). 
</p>
<p>For either function, the disparity index can be one of the following:
</p>

<ul>
<li><p><b>avg.sq </b>is average squared Euclidean distance among all pairs of points; this is the most common distance metric for disparity in macroevolution
</p>
</li>
<li><p><b>avg.manhattan </b>is average Manhattan distance among all pairs of points
</p>
</li>
<li><p><b>num.states </b>is number of unique character states; this is currently the only option for discrete 
character data
</p>
</li></ul>



<h3>Value</h3>

<p>The function <code>disparity</code> returns the disparity of the supplied <code>data</code>. If given a tree, <code>disparity</code> will return 
disparities computed for each subtree.  The vector of disparities is indexed based on the numeric node-identifier of the subtending subtree (e.g., the 
root is indexed by N+1, where N is the number of species in the tree; see <code><a href="ape.html#topic+read.tree">read.tree</a></code>). 
</p>
<p>The function <code>dtt</code> returns elements from the list below:
</p>

<ul>
<li><p><b>dtt </b>is average disparity for clades whose stem crosses each time interval in the tree
</p>
</li>
<li><p><b>times </b>are times for each value in disparity-through-time calculation; these are just the branching times of the phylogeny
</p>
</li>
<li><p><b>sim </b>are disparities at time intervals for each simulated dataset
</p>
</li>
<li><p><b>MDI </b>is the value of the MDI statistic, which is the area between the DTT for the data and the median of the simulations
</p>
</li></ul>
	
<p>If results are plotted, the mean DTT from the simulated datasets appears in dashed line and the empirical DTT in solid line.  
</p>


<h3>Author(s)</h3>

<p> LJ Harmon and GJ Slater</p>


<h3>References</h3>

<p>Foote M. 1997. The evolution of morphological diversity. <em>ARES</em> 28:129-152.
</p>
<p>Harmon LJ, JA Schulte, JB Losos, and A Larson. 2003. Tempo and mode of evolutionary radiation in iguanian lizards. <em>Science</em> 301:961-964.
</p>
<p>Slater GJ, SA Price, F Santini, and MA Alfaro. 2010. Diversity vs disparity and the evolution of modern cetaceans. <em>PRSB</em> 277:3097 -3104.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
geo=get(data(geospiza))

## disparity -- not tree-based
disparity(data=geo$dat) # not tree-based

## cladewise disparities
disparity(phy=geo$phy, data=geo$dat)

## disparity through time of culmen length
dttcul&lt;-dtt(phy=geo$phy, data=geo$dat[,"culmenL"], nsim=100, plot=TRUE)

## disparity through time of entire dataset -- without simulated data
dttgeo&lt;-dtt(phy=geo$phy, data=geo$dat, nsim=0, plot=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitContinuous'> Model fitting for continuous comparative data </h2><span id='topic+fitContinuous'></span>

<h3>Description</h3>

<p>fitting macroevolutionary models to phylogenetic trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitContinuous(phy, dat, SE = 0,
    model = c("BM","OU","EB","rate_trend","lambda","kappa","delta","mean_trend","white"),
    bounds= list(), control = list(method = c("subplex","L-BFGS-B"),
    niter = 100, FAIL = 1e+200, hessian = FALSE, CI = 0.95), ncores=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitContinuous_+3A_phy">phy</code></td>
<td>
<p> a phylogenetic tree of class phylo</p>
</td></tr>
<tr><td><code id="fitContinuous_+3A_dat">dat</code></td>
<td>
<p> data vector for a single trait, with names matching tips in <code>phy</code></p>
</td></tr>
<tr><td><code id="fitContinuous_+3A_se">SE</code></td>
<td>
<p> a single value or named vector of standard errors associated with values in <code>dat</code>; if any elements in the vector <code>SE</code> are NA, SE will be estimated </p>
</td></tr>
<tr><td><code id="fitContinuous_+3A_model">model</code></td>
<td>
<p> model to fit to comparative data (see <b>Details</b>) </p>
</td></tr>
<tr><td><code id="fitContinuous_+3A_bounds">bounds</code></td>
<td>
<p> range to constrain parameter estimates (see <b>Details</b>)  </p>
</td></tr>
<tr><td><code id="fitContinuous_+3A_control">control</code></td>
<td>
<p> settings used for optimization of the model likelihood</p>
</td></tr>
<tr><td><code id="fitContinuous_+3A_ncores">ncores</code></td>
<td>
<p> Number of cores. If <code>NULL</code> then number of cores is detected</p>
</td></tr>
<tr><td><code id="fitContinuous_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the internal likelihood function <code>bm.lik</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits various likelihood models for continuous character evolution. The function
returns parameter estimates and the likelihood for univariate datasets.
</p>
<p>The model likelihood is maximized using methods available in <code><a href="stats.html#topic+optim">optim</a></code> as well as <code><a href="subplex.html#topic+subplex">subplex</a></code>.
Optimization methods to be used within <code>optim</code> can be specified through the <code>control</code> object (i.e., <code>control$method</code>).
</p>
<p>A number of random starting points are used in optimization and are given through the <code>niter</code> element within the <code>control</code> object
(e.g., <code>control$niter</code>). The <code>FAIL</code> value within the <code>control</code> object should be a large value
that will be considerably far from -lnL of the maximum model likelihood. In most cases, the default setting
for <code>control$FAIL</code> will be appropriate. The Hessian may be used to compute confidence intervals
(<code>CI</code>) for the parameter estimates if the <code>hessian</code> element in <code>control</code> is TRUE.
</p>
<p><em>Beware</em>: difficulty in finding the optimal solution is determined by an interaction between the nature and complexity of the
likelihood space (which is data- and model-dependent) and the numerical optimizer used to explore the space.  There is never a
guarantee that the optimal solution is found, but using many random starting points (<code>control$niter</code>) and many optimization methods
(<code>control$method</code>) will increase these odds.
</p>
<p>Bounds for the relevant parameters of the fitted model may be given through the <code>bounds</code> argument. Bounds
may be necessary (particularly under the <code>OU</code> model) if the likelihood surface is characterized by a long,
flat ridge which can be exceedingly difficult for optimization methods. Several bounds can be given at a time
(e.g., <code>bounds=list(SE=c(0,0.1),alpha=c(0,1))</code> would constrain measurement error as well as the 'constraint'
parameter of the Ornstein-Uhlenbeck model).  Default bounds under the different models are given below.
</p>
<p>Possible models are as follows:
</p>

<ul>
<li><p><b>BM</b> is the Brownian motion model (Felsenstein 1973), which assumes the correlation structure among trait values is proportional to the extent of shared ancestry
for pairs of species. Default bounds on the rate parameter are <code>sigsq=c(min=exp(-500),max=exp(100))</code>. The same bounds are applied to all other
models, which also estimate <code>sigsq</code>
</p>
</li>
<li><p><b>OU</b> is the Ornstein-Uhlenbeck model (Butler and King 2004), which fits a random walk with a central tendency with an attraction strength proportional to the parameter <code>alpha</code>.
The <code>OU</code> model is called the <code>hansen</code> model in <span class="pkg">ouch</span>, although the way the parameters are fit is slightly different here. Default
bounds are <code>alpha = c(min = exp(-500), max = exp(1))</code>
</p>
</li>
<li><p><b>EB</b> is the Early-burst model (Harmon et al. 2010) and also called the <code>ACDC</code> model (accelerating-decelerating; Blomberg et al. 2003). Set by the <code>a</code> rate parameter, <code>EB</code>
fits a model where the rate of evolution increases or decreases exponentially through time, under the model r[t] = r[0] * exp(a * t), where <code>r[0]</code> is the
initial rate, <code>a</code> is the rate change parameter, and <code>t</code> is time. The maximum bound is set to <code>-0.000001</code>, representing a decelerating rate of evolution. The minimum bound is set to log(10^-5)/depth of the tree.
</p>
</li>
<li><p><b>rate_trend</b> is a diffusion model with linear trend in rates through time (toward larger or smaller rates). Used to be denominated the <code>"trend"</code> model, which is still accepted by <code>fitContinuous</code> for backward compatibility. Default bounds are <code>slope = c(min = -100, max = 100)</code>
</p>
</li>
<li><p><b>lambda</b> is one of the Pagel (1999) models that fits the extent to which the phylogeny predicts covariance among trait values for species. The model effectively transforms the tree:
values of <code>lambda</code> near 0 cause the phylogeny to become more star-like, and a <code>lambda</code> value of 1 recovers the <code>BM</code> model. Default
bounds are <code>lambda = c(min = exp(-500), max = 1</code>
</p>
</li>
<li><p><b>kappa</b> is a punctuational (speciational) model of trait evolution (Pagel 1999), where character divergence is related to the number of speciation events between two species. Note that if
there are speciation events that are missing from the given phylogeny (due to extinction or incomplete sampling), interpretation under the <code>kappa</code> model may be difficult. Considered as a tree
transformation, the model raises all branch lengths to an estimated power (<code>kappa</code>). Default bounds are <code>kappa = c(min = exp(-500), max = 1)</code>  
</p>
</li>
<li><p><b>delta</b> is a time-dependent model of trait evolution (Pagel 1999).  The <code>delta</code> model is similar to <code>ACDC</code> insofar as the <code>delta</code> model fits the relative contributions of
early versus late evolution in the tree to the covariance of species trait values.  Where <code>delta</code> is greater than 1, recent evolution has been relatively fast; if <code>delta</code> is less
than 1, recent evolution has been comparatively slow. Intrepreted as a tree transformation, the model raises all node depths to an estimated power (<code>delta</code>). Default bounds are <code>delta = c(min = exp(-500), max = 3)</code>
</p>
</li>
<li><p><b>mean_trend</b> is a model of trait evolution with a directional drift or <em>trend</em> component (i.e., toward smaller or larger values through time).  This model is sensible only for non-ultrametric trees, as the likelihood surface is entirely flat with respect to the slope of the trend if the tree is ultrametric. The model used to be denominated the <code>"drift"</code> model, which is still accepted by <code>fitContinuous</code> for backward compatibility. Default bounds are <code>drift = c(min = -100, max = 100)</code>
</p>
</li>
<li><p><b>white</b> is a <code>white</code>-noise (non-phylogenetic) model, which assumes data come from a single normal distribution with no covariance structure among species. The variance parameter <code>sigsq</code>
takes the same bounds defined under the <code>BM</code> model
</p>
</li></ul>



<h3>Value</h3>

<p><code>fitContinuous</code> returns a list with the following four elements:
</p>
<table role = "presentation">
<tr><td><code>\bold{lik}</code></td>
<td>
<p>is the function used to compute the model likelihood. The returned function (<code>lik</code>) takes arguments that are necessary for the given model.
For instance, if estimating a Brownian-motion model with unknown standard error, the arguments (<code>pars</code>) to the <code>lik</code> function would be <code>sigsq</code> and <code>SE</code>. By default, the function evaluates the likelihood of the model by assuming the maximum likelihood root state. This behavior can be changed in the call to <code>lik</code> with <code>lik(pars, root=ROOT.GIVEN)</code> where <code>pars</code> includes a value for the root state (z0). See <b>Examples</b> for a demonstration. The tree and data are stored internally within the <code>lik</code> function, which permits those elements to be efficiently reused when computing the likelihood under different parameter values
</p>
</td></tr>
<tr><td><code>\bold{bnd}</code></td>
<td>
<p>is a matrix of the used bounds for the relevant parameters estimated in the model. Warnings will be issued if any parameter estimates occur at the supplied (or default) parameter bounds
</p>
</td></tr>
<tr><td><code>\bold{res}</code></td>
<td>
<p>is a matrix of results from optimization. Rownames of the <code>res</code> matrix are the optimization methods
(see <code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="subplex.html#topic+subplex">subplex</a></code>). The columns in the <code>res</code> matrix are the estimated
parameter values, the estimated model likelihood, and an indication of optimization convergence. Values of convergence not
equal to zero are not to be trusted
</p>
</td></tr>
<tr><td><code>\bold{opt}</code></td>
<td>
<p>is a list of the primary results: estimates of the parameters, the maximum-likelihood estimate (<code>lnL</code>) of the model, the
optimization method used to compute the MLE, the number of model parameters (<code>k</code>, including one parameter for the root state), the AIC (<code>aic</code>),
sample-size corrected AIC (<code>aicc</code>). The number of observations for AIC computation is taken to be the number of trait values observed.
If the Hessian is used, confidence intervals on the parameter estimates (<code>CI</code>) and the Hessian matrix (<code>hessian</code>) are also returned
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To speed the likelihood search, one may set an environment variable to make use of parallel processing, used by <code><a href="parallel.html#topic+mclapply">mclapply</a></code>. To set the environment variable, use <code>options(mc.cores=INTEGER)</code>, where <code>INTEGER</code> is the number of available cores. Alternatively, the <code>mc.cores</code> variable may be preset upon the initiation of an R session (see <code><a href="base.html#topic+Startup">Startup</a></code> for details).
</p>


<h3>Author(s)</h3>

<p>LJ Harmon, W Challenger, and JM Eastman</p>


<h3>References</h3>

<p>Blomberg SP, T Garland, and AR Ives. 2003. Testing for phylogenetic signal in comparative data: behavioral traits are more labile. <em>Evolution</em> 57:717-745.
</p>
<p>Butler MA and AA King, 2004. Phylogenetic comparative analysis: a modeling approach for adaptive evolution. <em>American Naturalist</em> 164:683-695.
</p>
<p>Felsenstein J. 1973. Maximum likelihood estimation of evolutionary trees from continuous characters. <em>American Journal of Human Genetics</em> 25:471-492.
</p>
<p>Harmon LJ et al. 2010. Early bursts of body size and shape evolution are rare in comparative data. <em>Evolution</em> 64:2385-2396.
</p>
<p>Pagel M. 1999. Inferring the historical patterns of biological evolution. <em>Nature</em> 401:877-884
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
geo=get(data(geospiza))

tmp=treedata(geo$phy, geo$dat)
phy=tmp$phy
dat=tmp$data

#---- STORE RESULTS
brownFit &lt;-  fitContinuous(phy, dat[,"wingL"], SE=NA, control=list(niter=50), ncores=2)

#---- PRINT RESULTS
print(names(brownFit))
print(brownFit)

\donttest{
#---- COMPUTE LIKELIHOOD
flik=brownFit$lik
print(argn(flik))

#---- CREATE a FUNCTION to COMPARE MODELS
fitGeospiza=function(trait=c("wingL","tarsusL","culmenL","beakD","gonysW")){

	trait=match.arg(trait, c("wingL","tarsusL","culmenL","beakD","gonysW"))

	# define set of models to compare
	models=c("BM", "OU", "EB", "white")
	summaries=c("diffusion", "Ornstein-Uhlenbeck", "early burst", "white noise")

	## ESTIMATING measurement error ##
	aic.se=numeric(length(models))
	lnl.se=numeric(length(models))

	for(m in 1:length(models)){
		cat("\n\n\n\n\t*** ", paste(toupper(summaries[m]),": fitting ", sep=""), models[m],
			" with SE *** \n", sep="")
		tmp=fitContinuous(phy,dat[,trait],SE=NA, model=models[m],
                                    bounds=list(SE=c(0,0.5)), ncores=2)
		print(tmp)
		aic.se[m]=tmp$opt$aicc
		lnl.se[m]=tmp$opt$lnL
	}


	## ASSUMING no measurement error ##
	aic=numeric(length(models))
	lnl=numeric(length(models))

	for(m in 1:length(models)){
		cat("\n\n\n\n\t*** ", paste(toupper(summaries[m]),": fitting ", sep=""), models[m],
			 " *** \n", sep="")
		tmp=fitContinuous(phy,dat[,trait],SE=0,model=models[m], ncores=2)
		print(tmp)
		aic[m]=tmp$opt$aicc
		lnl[m]=tmp$opt$lnL
	}

	## COMPARE AIC ##
	names(aic.se)&lt;-names(lnl.se)&lt;-names(aic)&lt;-names(lnl)&lt;-models
	delta_aic&lt;-function(x) x-x[which(x==min(x))]

	# no measurement error
	daic=delta_aic(aic)
	cat("\n\n\n\t\t\t\t*** MODEL COMPARISON: ",trait," *** \n",sep="")
	cat("\tdelta-AIC values for models assuming no measurement error
    \t\t\t\t zero indicates the best model\n\n")
	print(daic, digits=2)

		# measurement error
	daic.se=delta_aic(aic.se)
	cat("\n\n\n\n\t\t\t\t*** MODEL COMPARISON: ",trait," ***\n",sep="")
	cat("\t\t   delta-AIC values for models estimating SE
    \t\t\t\t zero indicates the best model\n\n")
	print(daic.se, digits=2)
	cat("\n\n\n")

	res_aicc=rbind(aic, aic.se, daic, daic.se)
	rownames(res_aicc)=c("AICc","AICc_SE","dAICc", "dAICc_SE")

	return(res_aicc)
}

#---- COMPARE MODELS for WING LENGTH
res=fitGeospiza("wingL")
print(res)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fitContinuousMCMC'>
Fit models of continuous trait evolution to comparative data using MCMC
</h2><span id='topic+fitContinuousMCMC'></span>

<h3>Description</h3>

<p>This function is essentially an MCMC version of the fitContinuous function that fits models using Maximum Likelihood. The main advantage of using MCMC is that informative prior distributions may be placed on node values when such information is available, for example from the fossil record. In such cases, model selection may be improved upon and differ from results using extant taxa only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitContinuousMCMC(phy, d, model = c("BM", "Trend", "SSP", "ACDC.exp","ACDC.lin"),
	Ngens = 1e+06, sampleFreq = 1000, printFreq = 1000,
	propwidth = rep(0.1, 5), node.priors = NULL, root.prior = NULL,
	acdc.prior = NULL, sample.node.states = T, outputName = "mcmc.output")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitContinuousMCMC_+3A_phy">phy</code></td>
<td>

<p>A phylogenetic tree in phylo format
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_d">d</code></td>
<td>

<p>A named numeric vector of tip values
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_model">model</code></td>
<td>

<p>The type of model to be fitted. Options are: &quot;BM&quot; - Brownian motion, &quot;Trend&quot; = BM with a directional trend (this option can only be used with non ultrametric trees or when node priors are available for an ultrametric tree), &quot;SSP&quot; - the single stationary peak, or single-optimum OU model, &quot;ACDC.exp&quot; - Accelerating-Decelerating evolution where the change in rate is exponential with respect to time. The DC portion of this model corresponds to the EB model in Harmon et al. (2010), &quot;ACDC.lin&quot; - Accelerating-Decelerating evolution where the change in rate is linear with respect to time (see the supplementary information for Harmon et al. 2010 for details).
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_ngens">Ngens</code></td>
<td>

<p>The number of generations that the MCMC should be run for.
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_samplefreq">sampleFreq</code></td>
<td>

<p>The frequency with which likelihoods and parameters should be sampled from the chain. For large trees and/or if ancestral states are being sampled, this value should be large (at least equal to the number of internal nodes in the tree).
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_printfreq">printFreq</code></td>
<td>

<p>The frequency with which progress should be printed to the screen.
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_propwidth">propwidth</code></td>
<td>

<p>A numeric vector containing five values corresponding to proposal widths. The order is: 1 - root state proposal width, 2 - rate proposal width, 3 - scaler (alpha, rate change, trend parameter) proposal width, 4 - Theta (OU optimum) proposal width (not yet implemented), and 5- node state proposal width. 5 Values should be provided regardless of the model being fitted. Dummy or random values can be used for non-applicable parameters in such cases.
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_node.priors">node.priors</code></td>
<td>

<p>A data frame of informative node priors. The default is node.priors=NULL, in which case uniformative priors will be assumed for all nodes. Alternatively, the user may provide a dataframe with five columns. The first two columns should specify the tips spanning the clade descended from the node on which an informative prior is to be placed. Columns 3 and 4 give parameters related to the prior while column 5 specifies the type of prior distribution. Current options, along with the associated parameters required in columns 3 and 4, are &quot;normal&quot; (mean and sd), &quot;uniform&quot; (min and max), and &quot;exp&quot; (offset and rate).
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_root.prior">root.prior</code></td>
<td>

<p>A prior for the root value. The default is root.prior = NULL, in which case an uniformative root prior is assumed. Alternatively, the user may provide a vector containing 3 values: 1 &amp; 2 are the parameters for the root prior parameter values, while the 3rd is the type of prior. Current prior types are the same as for node priors.
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_acdc.prior">acdc.prior</code></td>
<td>

<p>For the ACDC models, it is  wise to bound the values of the rate change parameter as unreasonable proposed values can result in rounding issues and negatively infinite log-likelihoods. The default for this option is NULL. If an ACDC model is selected and no prior is given, a bounded, informative uniform prior will be assigned based on the root height of the tree. Alternatively, the user may provide bounds of their own. This may be particularly useful if the user is only interested in a subset of the parameter space area (eg., EB).
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_sample.node.states">sample.node.states</code></td>
<td>

<p>Logical. If sample.node.states = TRUE, node states (ancestral state values) will be logged to a separate output file. If sample.node.states = FALSE, ancestral states will be treated as nuisance parameters and discarded after computation of likelihoods.
</p>
</td></tr>
<tr><td><code id="fitContinuousMCMC_+3A_outputname">outputName</code></td>
<td>

<p>stem name for output file(s)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike fitContinuous, which returns output as a list, fitContinuousMCMC outputs directly to text file(s). The model parameter file is designed to be compatatible with the popular Tracer software used in conjunction with BEAST. The output can easily be read back into R for further analysis. A particular advantage of writing directly to text file is that crashes etc do not result in the complete loss of long runs, and memory is saved.
</p>


<h3>Value</h3>

<p>If sample.node.states = FALSE, one text file is written to the current working directory. 
</p>
<table role = "presentation">
<tr><td><code>outputName_model_params.txt</code></td>
<td>
<p>a text file containing sampled prior, posterior, likelihood, and model parameter values from the MCMC run</p>
</td></tr>
</table>
<p>If sample.node.states = TRUE, a second text file is written
</p>
<table role = "presentation">
<tr><td><code>outputName_nodestates.txt</code></td>
<td>
<p>contains the posterior sample of ancestral states for internal nodes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Graham Slater
</p>


<h3>References</h3>

<p>Slater GJ, LJ Harmon, and ME Alfaro. 2012. Integrating fossils with molecular phylogenies improves inference of trait evolution. <em>Evolution</em> 66:3931-3944.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(caniformia)
phy &lt;- caniformia$phy
d &lt;- caniformia$dat
node.priors &lt;- caniformia$node.priors
root.prior &lt;- caniformia$root.prior

## as an example, we will run a very short (too short!) analysis,
##fitting BM and Trend to the caniform data

fitContinuousMCMC(phy, d, model = "BM", Ngens = 1000, sampleFreq =100,
printFreq = 100, node.priors = node.priors, root.prior = root.prior,
outputName ="BM_caniforms")

fitContinuousMCMC(phy, d, model = "Trend", Ngens = 1000, sampleFreq=100,
printFreq = 100, node.priors = node.priors, root.prior = root.prior,
outputName ="Trend_caniforms")

bm.res &lt;- read.table("BM_caniforms_model_params.txt", header= TRUE)
head(bm.res)

trend.res &lt;- read.table("Trend_caniforms_model_params.txt", header= TRUE)
head(trend.res)

### produce trace plots of logLk scores 

plot(bm.res$generation, bm.res$logLk, type = "l",
ylim = c(min(bm.res$logLk), max = max(trend.res$logLk)))

lines(trend.res$generation, trend.res$logLk, col = "red")
legend("bottomleft", c("bm", "trend"), lwd = 3, col = c("black", "red"))

## End(Not run)
</code></pre>

<hr>
<h2 id='fitDiscrete'> Model fitting for discrete comparative data </h2><span id='topic+fitDiscrete'></span><span id='topic+as.Qmatrix.gfit'></span>

<h3>Description</h3>

<p>fitting macroevolutionary models to phylogenetic trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDiscrete(phy, dat,
    model = c("ER","SYM","ARD","meristic"),
    transform = c("none", "EB", "lambda", "kappa", "delta", "white"),
    bounds = list(), control = list(method = c("subplex", "L-BFGS-B"),
    niter = 100, FAIL = 1e+200, hessian = FALSE, CI = 0.95), ncores=NULL,
    ...)
## S3 method for class 'gfit'
as.Qmatrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitDiscrete_+3A_phy">phy</code></td>
<td>
<p> a phylogenetic tree of class phylo</p>
</td></tr>
<tr><td><code id="fitDiscrete_+3A_dat">dat</code></td>
<td>
<p> data vector for a single trait, with names matching tips in <code>phy</code></p>
</td></tr>
<tr><td><code id="fitDiscrete_+3A_model">model</code></td>
<td>
<p> an Mkn model to fit to comparative data (see <b>Details</b>) </p>
</td></tr>
<tr><td><code id="fitDiscrete_+3A_transform">transform</code></td>
<td>
<p> an evolutionary model used to transform the tree (see <b>Details</b>) </p>
</td></tr>
<tr><td><code id="fitDiscrete_+3A_bounds">bounds</code></td>
<td>
<p> range to constrain parameter estimates (see <b>Details</b>)  </p>
</td></tr>
<tr><td><code id="fitDiscrete_+3A_control">control</code></td>
<td>
<p> settings used for optimization of the model likelihood</p>
</td></tr>
<tr><td><code id="fitDiscrete_+3A_ncores">ncores</code></td>
<td>
<p> Number of cores. If <code>NULL</code> then number of cores is detected</p>
</td></tr>
<tr><td><code id="fitDiscrete_+3A_x">x</code></td>
<td>
<p> Object of class <code>"gfit"</code> for S3 method <code>as.Qmatrix</code> </p>
</td></tr>
<tr><td><code id="fitDiscrete_+3A_...">...</code></td>
<td>
<p>if <code>model="meristic"</code>, <code>...</code> can dictate whether the matrix is asymmetric (<code>symmetric=FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits various likelihood models for discrete character evolution. The function returns parameter estimates and the likelihood for univariate datasets. All of the models are continuous-time Markov models of trait evolution (see Yang 2006 for a good general discussion of this type of model).
</p>
<p>The model likelihood is maximized using methods available in <code><a href="stats.html#topic+optim">optim</a></code> as well as <code><a href="subplex.html#topic+subplex">subplex</a></code>. Optimization methods to be used within <code>optim</code> can be specified through the <code>control</code> object.
</p>
<p>A number of random starting points are used in optimization and are given through the <code>niter</code> element within the <code>control</code> object (e.g., <code>control$niter</code>). Finding the maximum likelihood fit is sometimes tricky, especially as the number of parameters in the model increases. Even in the example below, a slightly suboptimal fit is occasionally returned with the default settings fitting the general (<code>ARD</code>) model. There is no rule of thumb for the number of iterations that will be appropriate for a given dataset and model, but one use the variance in fitted likelihoods across iterations as an indication of the difficulty of the likelihood space (see details of the <code>res</code> object in <b>Value</b>). Twenty optimization iterations per parameter seems to be a decent <em>starting</em> point for fitting these models.
</p>
<p>The <code>FAIL</code> value within the <code>control</code> object should be a large value that will be considerably far from -lnL of the maximum model likelihood. In most cases, the default setting for <code>control$FAIL</code> will be appropriate. The Hessian may be used to compute confidence intervals (<code>CI</code>) for the parameter estimates if the <code>hessian</code> element in <code>control</code> is TRUE.
</p>
<p>The function can handle traits with any number of character states, under a range of models. The character model is specified by the <code>model</code> argument:
</p>

<ul>
<li><p><b>ER</b> is an <code>equal-rates</code> model of where a single parameter governs all transition rates
</p>
</li>
<li><p><b>SYM</b> is a <code>symmetric</code> model where forward and reverse transitions share the same parameter
</p>
</li>
<li><p><b>ARD</b> is an <code>all-rates-different</code> model where each rate is a unique parameter
</p>
</li>
<li><p><b>meristic</b> is a model wherein transitions occur in a stepwise fashion (e.g., 1 to 2 to 3 to 2) without skipping intermediate steps; this requires a sensible coding of the character
states as consecutive integers are assumed to be neighboring states
</p>
</li>
<li><p><b>matrix</b> is a user supplied model (given as a dummy matrix representing transition classes between states); elements that are zero signify rates that are also zero (see <b>Examples</b>)
</p>
</li></ul>

<p>The <code>transform</code> argument allows one to test models where rates vary across the tree.  Bounds for the relevant parameters of the tree <code>transform</code>
may be given through the <code>bounds</code> argument. Several bounds can be given at a time. Default bounds under the different models are given below.
Options for <code>transform</code> are as follows:
</p>

<ul>
<li><p><b>none</b> is a model of rate constancy through time
</p>
</li>
<li><p><b>EB</b> is the Early-burst model (Harmon et al. 2010) and also called the <code>ACDC</code> model (accelerating-decelerating; Blomberg et al. 2003). Set by the <code>a</code> rate parameter, <code>EB</code>
fits a model where the rate of evolution increases or decreases exponentially through time, under the model r[t] = r[0] * exp(a * t), where <code>r[0]</code> is the
initial rate, <code>a</code> is the rate change parameter, and <code>t</code> is time. Default bounds are <code>a = c(min = -10, max = 10)</code>
</p>
</li>
<li><p><b>lambda</b> is one of the Pagel (1999) models that fits the extent to which the phylogeny predicts covariance among trait values for species. The model effectively transforms the tree:
values of <code>lambda</code> near 0 cause the phylogeny to become more star-like, and a <code>lambda</code> value of 1 recovers the <code>none</code> model. Default
bounds are <code>lambda = c(min = 0, max = 1)</code>
</p>
</li>
<li><p><b>kappa</b> is a punctuational (speciational) model of trait evolution (Pagel 1999), where character divergence is related to the number of speciation events between two species. Note that if
there are speciation events in the given phylogeny (due to extinction or incomplete sampling), interpretation under the <code>kappa</code> model may be difficult. Considered as a tree
transformation, the model raises all branch lengths to an estimated power (<code>kappa</code>). Default bounds are <code>kappa = c(min = 0, max = 1)</code>
</p>
</li>
<li><p><b>delta</b> is a time-dependent model of trait evolution (Pagel 1999).  The <code>delta</code> model is similar to <code>ACDC</code> insofar as the <code>delta</code> model fits the relative contributions of
early versus late evolution in the tree to the covariance of species trait values.  Where <code>delta</code> is greater than 1, recent evolution has been relatively fast; if <code>delta</code> is less
than 1, recent evolution has been comparatively slow. Intrepreted as a tree transformation, the model raises all node depths to an estimated power (<code>delta</code>). Default bounds are <code>delta = c(min = 0, max = 3)</code>
</p>
</li>
<li><p><b>white</b> is a <code>white</code>-noise (non-phylogenetic) model, which converts the tree into a star phylogeny
</p>
</li></ul>



<h3>Value</h3>

<p><code>fitDiscrete</code> returns a list with the following four elements:
</p>
<table role = "presentation">
<tr><td><code>\bold{lik}</code></td>
<td>
<p>is the function used to compute the model likelihood. The returned function (<code>lik</code>) takes arguments that are necessary for the given model.
For instance, if estimating an untransformed <code>ER</code> model, there would be a single argument (the transition rate) necessary for the <code>lik</code> function. The tree and data are stored internally within the <code>lik</code> function, which permits those elements to be efficiently reused when computing the likelihood under different parameter values. By default, the function evaluates the likelihood of the model by weighting root states in accordance with their conditional probability given the data (this is the <code>"obs"</code> option; see FitzJohn et al. 2009). This default behavior can be changed in the call to <code>lik</code> with <code>lik(pars, root="flat")</code>, for instance, which would weight each state equally at the root. The other useful option is <code>"given"</code>, where the user must also supply a vector (<code>root.p</code>) of probabilities for each possible state. To make likelihoods roughly comparable between <span class="pkg">geiger</span> and <span class="pkg">ape</span>, one should use the option <code>lik(pars, root="given", root.p=rep(1,k))</code>, where <code>k</code> is the number of character states. See <b>Examples</b> for a demonstration
</p>
</td></tr>
<tr><td><code>\bold{bnd}</code></td>
<td>
<p>is a matrix of the used bounds for the relevant parameters estimated in the model. Warnings will be issued if any parameter estimates occur at the supplied (or default) parameter bounds
</p>
</td></tr>
<tr><td><code>\bold{res}</code></td>
<td>
<p>is a matrix of results from optimization. Rownames of the <code>res</code> matrix are the optimization methods
(see <code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="subplex.html#topic+subplex">subplex</a></code>). The columns in the <code>res</code> matrix are the estimated
parameter values, the estimated model likelihood, and an indication of optimization convergence. Values of convergence not
equal to zero are not to be trusted
</p>
</td></tr>
<tr><td><code>\bold{opt}</code></td>
<td>
<p>is a list of the primary results: estimates of the parameters, the maximum-likelihood estimate (<code>lnL</code>) of the model, the
optimization method used to compute the MLE, the number of model parameters (<code>k</code>, including one parameter for the root state), the AIC (<code>aic</code>),
sample-size corrected AIC (<code>aicc</code>). The number of observations for AIC computation is taken to be the number of trait values observed.
If the Hessian is used, confidence intervals on the parameter estimates (<code>CI</code>) and the Hessian matrix (<code>hessian</code>) are also returned
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To speed the likelihood search, one may set an environment variable to make use of parallel processing, used by <code><a href="parallel.html#topic+mclapply">mclapply</a></code>. To set the environment variable, use <code>options(mc.cores=INTEGER)</code>, where <code>INTEGER</code> is the number of available cores. Alternatively, the <code>mc.cores</code> variable may be preset upon the initiation of an R session (see <code><a href="base.html#topic+Startup">Startup</a></code> for details).
</p>


<h3>Author(s)</h3>

<p> LJ Harmon, RE Glor, RG FitzJohn, and JM Eastman </p>


<h3>References</h3>

<p>Yang Z. 2006. <em>Computational Molecular Evolution</em>. Oxford University Press: Oxford.
FitzJohn RG, WP Maddison, and SP Otto. 2009. Estimating trait-dependent speciation and extinction rates from incompletely resolved molecular phylogenies. <em>Systematic Biology</em> 58:595-611.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## match data and tree
tmp=get(data(geospiza))
td=treedata(tmp$phy, tmp$dat)
geo=list(phy=td$phy, dat=td$data)
gb=round(geo$dat[,5]) ## create discrete data
names(gb)=rownames(geo$dat)

tmp=fitDiscrete(geo$phy, gb, model="ER", control=list(niter=5), ncores=2) #-7.119792
## using the returned likelihood function
lik=tmp$lik
lik(0.3336772, root="obs") #-7.119792
lik(0.3336772, root="flat") #-8.125354
lik(0.3336772, root="given", root.p=rep(1/3,3)) #-8.125354
lik(0.3336772, root="given", root.p=c(0, 1, 0)) #-7.074039
lik(c(0.3640363), root="given", root.p=rep(1,3)) #-7.020569 &amp; comparable to ape:::ace solution

## End(Not run)

# general model (ARD)
## match data and tree
tmp=get(data(geospiza))
td=treedata(tmp$phy, tmp$dat)
geo=list(phy=td$phy, dat=td$data)
gb=round(geo$dat[,5]) ## create discrete data
names(gb)=rownames(geo$dat)
fitDiscrete(geo$phy, gb, model="ARD", ncores=1) #-6.064573

# user-specified rate classes
mm=rbind(c(NA, 0, 0), c(1, NA, 2), c(0, 2, NA))
fitDiscrete(geo$phy, gb, model=mm, ncores=1) #-7.037944

# symmetric-rates model
fitDiscrete(geo$phy, gb, model="SYM", ncores=1)#-6.822943
</code></pre>

<hr>
<h2 id='gbresolve'> NCBI taxonomy </h2><span id='topic+gbresolve.phylo'></span><span id='topic+gbresolve'></span><span id='topic+gbcontain'></span>

<h3>Description</h3>

<p>working with NCBI taxonomy</p>


<h3>Usage</h3>

<pre><code class='language-R'>	gbresolve(x, rank="phylum", within="", ncores=1, ...)
	gbcontain(x, rank="species", within="", ncores=1,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbresolve_+3A_x">x</code></td>
<td>
<p>a phylogenetic tree of class 'phylo' (<code>gbresolve.phylo</code>), or a string vector (<code>gbresolve</code>), or a single string (<code>gbcontain</code>)</p>
</td></tr>
<tr><td><code id="gbresolve_+3A_rank">rank</code></td>
<td>
<p>a Linnaean rank to restrict taxonomic resolution</p>
</td></tr>
<tr><td><code id="gbresolve_+3A_within">within</code></td>
<td>
<p>a character string representing a group within which to resolve query</p>
</td></tr>
<tr><td><code id="gbresolve_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use.</p>
</td></tr>
<tr><td><code id="gbresolve_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the taxdump constructor (<code><a href="ncbit.html#topic+ncbit">ncbit</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions access the NCBI taxonomy resource (<a href="https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/">https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/</a>; see also <code><a href="ncbit.html#topic+ncbit">ncbit</a></code>).
<code>gbresolve</code> resolves the taxonomic hierarchy for queried taxa up to the given <code>rank</code> (or between the given <code>rank</code>s if two are given),
and <code>gbcontain</code> resolves all taxa found within a given queried group and occurring at a specified <code>rank</code>.  The <code>rank</code> must be found
within the object <code>Linnaean</code> (see <b>Examples</b>). The argument <code>within</code> can restrict the group within which to conduct the search
(see <b>Examples</b>).
</p>
<p>The local copy of the taxonomy resource (accessible in with <code>data(ncbi)</code> from <span class="pkg">ncbit</span>) can be updated with a call to <code>ncbit(update=TRUE)</code>.
</p>
<p>Setting the <code>ncores</code> argument to <code>NULL</code> will use all available cores.
</p>


<h3>Author(s)</h3>

<p>JM Eastman</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## call up NCBI taxonomy
ncbi=ncbit::ncbit(update=FALSE)

## possible ranks
print(Linnaean)

## resolve taxa
gbresolve(c("Ambystoma_laterale", "Dicamptodon_copei"))
gbresolve("Andrias japonicus")


## resolve taxa found in tree
sal=get(data(caudata))
x=gbresolve(sal$phy, rank=c("genus", "order"))
plot(x$phy, show.node=TRUE, type="f", show.tip=FALSE, cex=0.3)

## find all genera within salamanders
gbcontain("caudata", rank="genus")

</code></pre>

<hr>
<h2 id='geiger-data'>example datasets</h2><span id='topic+amphibia'></span><span id='topic+chelonia'></span><span id='topic+geospiza'></span><span id='topic+primates'></span><span id='topic+caudata'></span><span id='topic+whales'></span><span id='topic+carnivores'></span><span id='topic+caniformia'></span>

<h3>Description</h3>

<p>providing access to comparative datasets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amphibia)
data(caniformia)
data(carnivores)
data(caudata)
data(chelonia)
data(geospiza)
data(primates)
data(whales)
</code></pre>


<h3>Details</h3>

<p>The objects <code>caudata</code>, <code>chelonia</code>, <code>carnivores</code>, <code>geospiza</code>, and <code>primates</code> each have at least two items, a <code>phy</code> object 
and a <code>dat</code> object. The <code>phy</code> object is a phylogenetic tree of class 'phylo' (see <code><a href="ape.html#topic+read.tree">read.tree</a></code>).  The <code>dat</code> object (e.g., <code>caudata$dat</code>)
is a named vector of (natural log-transformed) body sizes for each group. The salamander data (object <code>caudata</code>) also includes 
the systematics for all recognized taxa (object <code>caudata$tax</code>) as well as a time-calibrated family-level phylogeny (<code>caudata$fam</code>) from Zhang and Wake (2009). The object <code>caudata$phy</code> is an unpublished glomogram of mostly family level phylogenies from the literature.  The backbone for that tree is from Zhang and Wake (2009). 
</p>
<p>The <code>amphibia</code> object is a set of three trees, the last of which is a time-scaled estimate of the Pyron and Wiens (2011) tree (see <code><a href="#topic+congruify.phylo">congruify.phylo</a></code>).
</p>
<p>The <code>whales</code> object is a dataset including a tree and a taxon richness matrix (see <code><a href="#topic+medusa">medusa</a></code>).
</p>


<h3>References</h3>

<p>Data are from the following sources:
</p>
<p><code>AMPHIBIANS (amphibia)</code>
</p>

<ul>
<li><p>Roelants K, DJ Gower, M Wilkinson, SP Loader, SD Biju, K Guillaume, L Moriau, and F Bossuyt. 2007. Global patterns of diversification in the history of modern amphibians. <em>PNAS</em> 104:887-892.
</p>
</li>
<li><p>Pyron RA and JJ Wiens. 2011. A large-scale phylogeny of Amphibia including over 2800 species, and a revised classification of extant frogs, salamanders, and caecilians. <em>MPE</em> 61:543-583.
</p>
</li></ul>

<p><code>SALAMANDERS (caudata)</code>
</p>

<ul>
<li><p>Adams DC, CM Berns, KH Kozak, and JJ Wiens. 2009. Are rates of species diversification correlated with rates of morphological evolution? <em>PRSB</em> 276:2729-2738. 
</p>
</li>
<li><p>Bonett RM, PT Chippindale, PE Moler, RW van Devender, and DB Wake. 2009. Evolution of gigantism in amphiumid salamanders. <em>PLoSONE</em> 4(5):e5615.
</p>
</li>
<li><p>Kozak KH, RW Mendyk, and JJ Wiens. 2009. Can Parallel Diversification Occur in Sympatry? Repeated Patterns of Body-Size Evolution in Coexisting Clades of North American Salamanders. <em>Evolution</em> 63:1769-1784.
</p>
</li>
<li><p>Weisrock DW, TJ Papenfuss, JR Macey, SN Litvinchuk, R Polymeni, IH Ugurtas, E Zhao, H Jowkar, and A Larson. 2006. A molecular assessment of phylogenetic relationships and lineage accumulation rates within the family Salamandridae (Amphibia, Caudata). <em>MPE</em> 41:368-383.
</p>
</li>
<li><p>Wiens JJ and JT Hoverman. 2008. Digit reduction, body size, and paedomorphosis in salamanders. <em>Evolution and Development</em> 10:449-463.
</p>
</li>
<li><p>Zhang P, Y-Q Chen, H Zhou, X-L Wang, TJ Papenfuss, DB Wake and L-H Qu. 2006. Phylogeny, evolution, and biogeography of Asiatic salamanders (Hynobiidae). <em>PNAS</em> 103:7360-7365.
</p>
</li>
<li><p>Zhang P and DB Wake. 2009. Higher-level salamander relationships and divergence dates inferred from complete mitochondrial genomes. <em>MPE</em> 53:492-508. 
</p>
</li></ul>

<p><code>PRIMATES (primates)</code>
</p>

<ul>
<li><p>Redding DW, C DeWolff, and AO Mooers. 2010. Evolutionary distinctiveness, threat status and ecological oddity in primates. <em>Conservation Biology</em> 24:1052-1058.
</p>
</li>
<li><p>Vos RA and AO Mooers. 2006. A new dated supertree of the Primates. Chapter 5. In: VOS RA (Ed.) <em>Inferring large phylogenies: the big tree problem</em>. [Ph.D. thesis]. Burnaby BC, Canada: Simon Fraser University.
</p>
</li></ul>

<p><code>CARNIVORES (carnivores)</code>
</p>

<ul>
<li><p>Eizirik E, WJ Murphy, K-P Koepfli, WE Johnson, JW Dragoo, RK Wayne, and SJ O'Brien. 2010. Pattern and timing of diversification of the mammalian order Carnivora inferred from multiple nuclear gene sequences. <em>Molecular Phylogenetic and Evolution</em> 56:49-63.
</p>
</li>
<li><p>Wozencraft WC. 2005. Order Carnivora in Wilson DE and DM Reeder (Eds.) <em>Mammal Species of the World</em>. Johns Hopkins University Press.
</p>
</li>
<li><p>Jones KE, J Bielby, M Cardillo, et al. 2009. <em>Ecological Archives</em> E090-184.
</p>
</li></ul>
	
<p><code>CANIFORMS (caniformia)</code>
</p>

<ul>
<li><p>Slater GJ, LJ Harmon, and ME Alfaro. 2012. Integrating fossils with molecular phylogenies improves inference of trait evolution. <em>Evolution</em> 66:3931-3944. 
</p>
</li></ul>

<p><code>TURTLES (chelonia)</code>
</p>

<ul>
<li><p>Jaffe AL, GJ Slater, and ME Alfaro. 2011. Ecological habitat and body size evolution in turtles. <em>Biology Letters</em> 7:558-561.
</p>
</li></ul>
	
<p><code>DARWINS FINCHES (geospiza)</code>
</p>

<ul>
<li><p>Schluter D
</p>
</li></ul>

<p><code>WHALES (whales)</code>
</p>

<ul>
<li><p>data compiled by GJ Slater
</p>
</li>
<li><p>Paleobiology Database. 2011. <a href="https://paleobiodb.org/">https://paleobiodb.org/</a>.
</p>
</li></ul>


<hr>
<h2 id='geiger-defunct'>deprecated functions in GEIGER</h2><span id='topic+area.between.curves'></span><span id='topic+BDsim'></span><span id='topic+birthdeath.tree'></span><span id='topic+calibrate.proposalwidth'></span><span id='topic+compare.rates'></span><span id='topic+deltaTree'></span><span id='topic+disp.calc'></span><span id='topic+dtt.full'></span><span id='topic+exponentialchangeTree'></span><span id='topic+get.simulation.matrix'></span><span id='topic+getAncStates'></span><span id='topic+ic.sigma'></span><span id='topic+intercalate.samples'></span><span id='topic+kappaTree'></span><span id='topic+lambdaTree'></span><span id='topic+linearchangeTree'></span><span id='topic+node.leaves'></span><span id='topic+node.sons'></span><span id='topic+ouTree'></span><span id='topic+phy.anova'></span><span id='topic+phy.manova'></span><span id='topic+pool.rjmcmcsamples'></span><span id='topic+prune.extinct.taxa'></span><span id='topic+prune.random.taxa'></span><span id='topic+rate.estimate'></span><span id='topic+rescaleTree'></span><span id='topic+runMedusa'></span><span id='topic+shifts.plot'></span><span id='topic+speciationalTree'></span><span id='topic+tip.disparity'></span><span id='topic+tracer'></span><span id='topic+transform.phylo'></span><span id='topic+tworateTree'></span><span id='topic+vmat'></span>

<h3>Description</h3>

<p>This function has been deprecated in <span class="pkg">geiger</span> and <span class="pkg">auteur</span> or may be available from another package. Below shows the original function and the suggested function to use in its place.
</p>


<h3>Details</h3>


<ul>
<li><p><code>area.between.curves</code>: use <code>geiger:::.area.between.curves</code>
</p>
</li>
<li><p><code>BDsim</code>: use <code><a href="#topic+sim.bd">sim.bd</a></code>
</p>
</li>
<li><p><code>birthdeath.tree</code>: use <code><a href="#topic+sim.bdtree">sim.bdtree</a></code>
</p>
</li>
<li><p><code>calibrate.proposalwidth</code>: use <code><a href="#topic+calibrate.rjmcmc">calibrate.rjmcmc</a></code>
</p>
</li>
<li><p><code>deltaTree</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>disp.calc</code>: use <code><a href="#topic+disparity">disparity</a></code>
</p>
</li>
<li><p><code>dtt.full</code>: use <code><a href="#topic+dtt">dtt</a></code>
</p>
</li>
<li><p><code>exponentialchangeTree</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>get.simulation.matrix</code>: use <code>geiger:::.get.simulation.matrix</code>
</p>
</li>
<li><p><code>getAncStates</code>: use <code><a href="phytools.html#topic+fastAnc">fastAnc</a></code>
</p>
</li>
<li><p><code>ic.sigma</code>: use <code><a href="#topic+ratematrix">ratematrix</a></code>
</p>
</li>
<li><p><code>intercalate.samples</code>: use <code>geiger:::.intercalate.rjmcmc</code>
</p>
</li>
<li><p><code>kappaTree</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>lambdaTree</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>linearchangeTree</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>name.check</code>: use <code>geiger:::.treedata</code>
</p>
</li>
<li><p><code>node.leaves</code>: use <code><a href="#topic+tips">tips</a></code>
</p>
</li>
<li><p><code>node.sons</code>: use <code>geiger:::.get.desc.of.node</code>
</p>
</li>
<li><p><code>ouTree</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>phy.anova</code>: use <code><a href="#topic+aov.phylo">aov.phylo</a></code>
</p>
</li>
<li><p><code>phy.manova</code>: use <code><a href="#topic+aov.phylo">aov.phylo</a></code>
</p>
</li>
<li><p><code>pool.rjmcmcsamples</code>: use <code><a href="#topic+load">load</a></code>
</p>
</li>
<li><p><code>prune.extinct.taxa</code>: use <code><a href="#topic+drop.extinct">drop.extinct</a></code>
</p>
</li>
<li><p><code>prune.random.taxa</code>: use <code><a href="#topic+drop.random">drop.random</a></code>
</p>
</li>
<li><p><code>rate.estimate</code>: use <code><a href="#topic+bd.ms">bd.ms</a></code> or <code><a href="#topic+bd.km">bd.km</a></code>
</p>
</li>
<li><p><code>rescaleTree</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>runMedusa</code>: use <code><a href="#topic+medusa">medusa</a></code>
</p>
</li>
<li><p><code>shifts.plot</code>: use <code>plot</code>
</p>
</li>
<li><p><code>speciationalTree</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>tip.disparity</code>: use <code><a href="#topic+disparity">disparity</a></code>
</p>
</li>
<li><p><code>tracer</code>: use of <code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code> and other functions in <span class="pkg">coda</span> recommended
</p>
</li>
<li><p><code>transform.phylo</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>tworateTree</code>: use <code><a href="#topic+rescale.phylo">rescale.phylo</a></code>
</p>
</li>
<li><p><code>vmat</code>: use <code>geiger:::.vmat</code>
</p>
</li></ul>


<hr>
<h2 id='geiger-example'>internal geiger functions</h2><span id='topic+ex.traitgram'></span><span id='topic+ex.jumpsimulator'></span><span id='topic+ex.ratesimulator'></span>

<h3>Description</h3>

<p><code>geiger-example</code> functions are used solely for demonstrative purposes</p>

<hr>
<h2 id='geiger-internal'>internal geiger functions</h2><span id='topic+print.bm'></span><span id='topic+print.mkn'></span><span id='topic+argn'></span><span id='topic+argn.default'></span><span id='topic+argn.bm'></span><span id='topic+argn.mkn'></span><span id='topic+argn+3C-'></span><span id='topic+argn+3C-.bm'></span><span id='topic+as.phylo.hphylo'></span><span id='topic+bf'></span><span id='topic+bm.lik'></span><span id='topic+cherries'></span><span id='topic+coef.gfit'></span><span id='topic+coef.gfits'></span><span id='topic+constrain'></span><span id='topic+constrain.k'></span><span id='topic+constrain.m'></span><span id='topic+dlunif'></span><span id='topic+drop.tip'></span><span id='topic+dtpois'></span><span id='topic+edges.phylo'></span><span id='topic+edgelabels.auteur'></span><span id='topic+ess'></span><span id='topic+exemplar.phylo'></span><span id='topic+fitDiversification'></span><span id='topic+fitSplitModel'></span><span id='topic+gbresolve.default'></span><span id='topic+gbtaxdump'></span><span id='topic+gen'></span><span id='topic+getBD'></span><span id='topic+getDiversificationModel'></span><span id='topic+getFullSplitModel'></span><span id='topic+hash.node'></span><span id='topic+hashes.phylo'></span><span id='topic+hashes.rjmcmc'></span><span id='topic+hdr'></span><span id='topic+heights'></span><span id='topic+heights.multiPhylo'></span><span id='topic+heights.phylo'></span><span id='topic+hme'></span><span id='topic+is.constrained'></span><span id='topic+is.phylo'></span><span id='topic+is.root'></span><span id='topic+kendallmoran.rate'></span><span id='topic+likfx.bm'></span><span id='topic+Linnaean'></span><span id='topic+load'></span><span id='topic+logLik.gfit'></span><span id='topic+logLik.gfits'></span><span id='topic+make.bm.relaxed'></span><span id='topic+mkn.lik'></span><span id='topic+PATHd8.phylo'></span><span id='topic+plotDiversificationSurface'></span><span id='topic+plot.auteurMCMCMC'></span><span id='topic+plot.auteurMCMC'></span><span id='topic+plot.rjmcmc'></span><span id='topic+plot.rjmcmc.list'></span><span id='topic+print.auteurRAW'></span><span id='topic+print.bayesfactor'></span><span id='topic+print.constraint.m'></span><span id='topic+print.glnL'></span><span id='topic+print.gprior'></span><span id='topic+print.mcmc.list'></span><span id='topic+print.rbm'></span><span id='topic+print.rjmcmc'></span><span id='topic+print.rjmcmcmc'></span><span id='topic+print.taxdump'></span><span id='topic+print.transformer'></span><span id='topic+resplitEdgeMatrixGeiger'></span><span id='topic+root.phylo'></span><span id='topic+sim.mecca'></span><span id='topic+sem'></span><span id='topic+span.phylo'></span><span id='topic+splitEdgeMatrixGeiger'></span><span id='topic+ultrametricize.phylo'></span><span id='topic+unique.phylo'></span><span id='topic+uniqueMultiPhylo'></span><span id='topic+white.mkn'></span><span id='topic+write.pathd8'></span><span id='topic+write.r8s'></span><span id='topic+write.treePL'></span>

<h3>Description</h3>

<p><code>geiger-internal</code> functions are either not typically called by the user or are currently undocumented</p>


<h3>Details</h3>

<p>This is an internal <span class="pkg">geiger</span> function, either not intended to be called directly by the user or is currently undocumented.
</p>

<hr>
<h2 id='load.rjmcmc'>posterior samples from single or multiple MCMC runs</h2><span id='topic+load.rjmcmc'></span>

<h3>Description</h3>

<p>generating a pooled and thinned sample of posterior estimates from rjmcmc</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.rjmcmc(x, phy = NULL, burnin = NULL, thin = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load.rjmcmc_+3A_x">x</code></td>
<td>
<p>a vector of directory names (character strings) in which samples generated by <span class="pkg">geiger</span> are found</p>
</td></tr>
<tr><td><code id="load.rjmcmc_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo' for which to compile results; if NULL, the tree stored within each generated <code>rda</code> file is used</p>
</td></tr>
<tr><td><code id="load.rjmcmc_+3A_burnin">burnin</code></td>
<td>
<p>the proportion of each chain to be removed as burnin</p>
</td></tr>
<tr><td><code id="load.rjmcmc_+3A_thin">thin</code></td>
<td>
<p>an integer specifying the thinning interval for chains</p>
</td></tr>
<tr><td><code id="load.rjmcmc_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other functions (has no effect in the present context)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a means to compile results from at least a single MCMC run, and is especially useful in pooling of multiple independent runs. In cases where MCMC chains were sampled
using a set of (different) trees, the argument <code>phy</code> can be used to summarize compiled results against a single summary tree. Branchwise samples are stored with unique edge identifiers 
(character strings) that are more reliable than the use of numeric node-identifiers (see <code><a href="digest.html#topic+digest">digest</a></code> for the function used to generate these unique edge labels). 
</p>
<p>If it is desired to run analyses for the same trait data across a set of trees (see <b>Examples</b>), it is strongly recommended that the set of trees be sent to <code>rjmcmc.bm</code> as a <code>multiPhylo</code> 
object (see <code><a href="ape.html#topic+read.tree">read.tree</a></code>).
</p>


<h3>Value</h3>

<p>an object of class <code>rjmcmc</code> or <code>rjmcmcmc</code></p>


<h3>Author(s)</h3>

<p>JM Eastman</p>


<h3>See Also</h3>

<p><code><a href="#topic+rjmcmc.bm">rjmcmc.bm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
sal=get(data(caudata))
a&lt;-sim&lt;-sal$phy
bl=c(386,387,388,183,184,185,186)
mod=match(bl, sim$edge[,2])
sim$edge.length[mod]=sim$edge.length[mod]*64
dat=rTraitCont(sim)
while(1){
	b=a
	b$tip.label[183:186]=sample(b$tip.label[183:186])
	if(!all(a$tip.label==b$tip.label)) break()
}

trees=list(a=a,b=b, c=ladderize(a, right=TRUE), d=ladderize(a, right=FALSE))
class(trees)="multiPhylo"
rjmcmc.bm(trees, dat, ngen=1e3, type="rbm")

res=load.rjmcmc(paste("relaxedBM", names(trees), sep="."), phy=trees$d, burnin=0.25)
plot(res, par="shifts", show.tip=FALSE, edge.width=2.5)

</code></pre>

<hr>
<h2 id='make.gbm'>
tailor reversible-jump Markov chain Monte Carlo sampling</h2><span id='topic+make.gbm'></span>

<h3>Description</h3>

<p>controlling reversible-jump Markov chain Monte Carlo sampling</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.gbm(phy, dat, SE=NA, type = c("bm", "rbm", "jump-bm", "jump-rbm"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.gbm_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="make.gbm_+3A_dat">dat</code></td>
<td>
<p>a named vector of continuous trait values, associated with each species in <code>phy</code></p>
</td></tr>
<tr><td><code id="make.gbm_+3A_se">SE</code></td>
<td>
<p>a named vector of standard errors for each trait value; applied to all trait values if given a single value</p>
</td></tr>
<tr><td><code id="make.gbm_+3A_type">type</code></td>
<td>
<p>the class of model to use (see <code><a href="#topic+rjmcmc.bm">rjmcmc.bm</a></code>)</p>
</td></tr>
<tr><td><code id="make.gbm_+3A_...">...</code></td>
<td>
<p>arguments passed internally to control other settings (see <b>Details</b>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>...</code> controls the substitution of default settings for Markov-chain Monte Carlo sampling. Below are the settings that are controllable by the user. 
These parameters and their default settings can also be found with an <em>empty</em> call to the function (e.g., <code>make.gbm()</code>).
</p>
<p><b>measurement error (SE)</b>: one of the arguments necessary for running <code><a href="#topic+rjmcmc.bm">rjmcmc.bm</a></code> is <code>SE</code>, which is a statement about the error associated with the values 
given in <code>dat</code>.  Measurement error (whose argument is <code>SE</code>) can be a named vector of numeric values (including <code>NA</code>) or a single value (including <code>NA</code>).  If given as 
a vector, <code>SE</code> must have names that correspond to the those found for <code>dat</code>. If given a single value for 
<code>SE</code>, the sampler will apply that value of measurement error to all tips in the tree. If <code>NA</code> appears for the measurement error for <em>any</em> species, 
<code>SE</code> becomes an additional parameter of the model: this density is consequently sampled by <code>rjmcmc.bm</code>. The default for <code>rjmcmc.bm</code> is to estimate a single <code>SE</code> 
(which is applied to all species).  
</p>
<p><b>control settings</b>: default settings for each control parameter are given below.  Note that for the discrete random variables (for which <code>dlnSHIFT</code> and <code>dlnJUMP</code>) apply, 
certain criteria must be met if the user prefers to supply a different prior density. The function <code><a href="#topic+dcount">dcount</a></code> is useful for building a custom prior density function 
for discrete variables.
</p>


<h3>Value</h3>

<p>The items that can be tailored in the resulting control object are as follows:
</p>
<table role = "presentation">
<tr><td><code>\bold{method}</code></td>
<td>
<p>default <code>direct</code>; this defines the implementation for computing model likelihood (currently with only the default available)</p>
</td></tr>				
<tr><td><code>\bold{constrainSHIFT}</code></td>
<td>
<p>default <code>FALSE</code>; if integer given, this constrains the number of local clocks in the diffusive process</p>
</td></tr>
<tr><td><code>\bold{constrainJUMP}</code></td>
<td>
<p>default <code>FALSE</code>; if integer given, this constrains the number of pulses in the jump process</p>
</td></tr>
<tr><td><code>\bold{dlnSHIFT}</code></td>
<td>
<p>default <code>dcount(0:(nn - 1), FUN = dpois, lambda = log(2))</code>, where <code>nn</code> is the number of branches in the tree; this controls the prior density on the number of shifts between local clocks in the tree (and applies only if the <code>type</code> argument to <code><a href="#topic+rjmcmc.bm">rjmcmc.bm</a></code> is <code>"rbm"</code> or <code>"jump-rbm"</code>) and if <code>constrainSHIFT</code> is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code>\bold{dlnJUMP}</code></td>
<td>
<p>default <code>dcount(0:nn, FUN = dlunif, min = 0, max = nn, dzero = 0.5)</code>, where <code>nn</code> is the number of branches in the tree; this controls the prior density on the number of evolutionary pulses across the tree (and applies only if the <code>type</code> argument to <code><a href="#topic+rjmcmc.bm">rjmcmc.bm</a></code> is <code>"jump-bm"</code> or <code>"jump-rbm"</code> and if <code>constrainJUMP</code> is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code>\bold{dlnRATE}</code></td>
<td>
<p>default <code>function (x) dexp(x, rate = 1/(10^3), log = TRUE)</code>; this defines the prior density on rate scalars</p>
</td></tr>
<tr><td><code>\bold{dlnSE}</code></td>
<td>
<p>default <code>function (x) dexp(x, rate = 1/(10^3), log = TRUE)</code>; this defines the prior density on measurement error</p>
</td></tr>
<tr><td><code>\bold{dlnPULS}</code></td>
<td>
<p>default <code>function (x) dexp(x, rate = 1/(10^3), log = TRUE)</code>; this defines the prior density on jump variance</p>
</td></tr>
<tr><td><code>\bold{dlnROOT}</code></td>
<td>
<p>default <code>function (x) dunif(x, min=-10^3, max=10^3, log=TRUE)</code>; this defines the prior density on root state</p>
</td></tr>
<tr><td><code>\bold{rate.lim}</code></td>
<td>
<p>default <code>list(min=0, max=Inf)</code>; this defines the numerical limits on the rate scalars</p>
</td></tr>
<tr><td><code>\bold{se.lim}</code></td>
<td>
<p>default <code>list(min=0, max=Inf)</code>; this defines the numerical limits on the measurement error</p>
</td></tr>
<tr><td><code>\bold{root.lim}</code></td>
<td>
<p>default <code>list(min=-Inf, max=Inf)</code>; this defines the numerical limits on the root state</p>
</td></tr>
<tr><td><code>\bold{jump.lim}</code></td>
<td>
<p>default <code>1</code>; determines the number of jumps permissible along each branch (1 is currently supported)</p>
</td></tr>
<tr><td><code>\bold{excludeSHIFT}</code></td>
<td>
<p>default <code>c()</code>; if this argument is not empty, these are branches (specified by numeric node-identifiers) which cannot be chosen for a novel local clock</p>
</td></tr>
<tr><td><code>\bold{excludeJUMP}</code></td>
<td>
<p>default <code>c()</code>; if this argument if not empty, these are branches (specified by numeric node-identifiers) which cannot be chosen for an evolutionary pulse</p>
</td></tr>
<tr><td><code>\bold{bm.jump}</code></td>
<td>
<p>default <code>0.5</code>; this defines the ratio between proposals for the diffusion and jump processes (0.5 is perfectly balanced)</p>
</td></tr>
<tr><td><code>\bold{mergesplit.shift}</code></td>
<td>
<p>default <code>0.5</code>; this defines the ratio between proposals that scale model complexity and those that do not</p>
</td></tr>
<tr><td><code>\bold{tune.scale}</code></td>
<td>
<p>default <code>0.65</code>; this defines the ratio between proposals that modify the model branchwise versus treewide</p>
</td></tr>
<tr><td><code>\bold{slide.mult}</code></td>
<td>
<p>default <code>0.25</code>; this defines the ratio between sliding window and multiplier proposals</p>
</td></tr>
<tr><td><code>\bold{prob.dimension}</code></td>
<td>
<p>default <code>0.65</code>; this defines the proportion of proposals used to modify model dimensionality</p>
</td></tr>
<tr><td><code>\bold{prob.effect}</code></td>
<td>
<p>default <code>0.3</code>; this defines the proportion of proposals that do not alter dimensionality</p>
</td></tr>
<tr><td><code>\bold{prob.SE}</code></td>
<td>
<p>default <code>0.03</code>; this defines the proportion of proposals that alter the (unknown) measurement error</p>
</td></tr>
<tr><td><code>\bold{prob.root}</code></td>
<td>
<p>default <code>0.02</code>; this defines the proportion of proposals that alter the root state</p>
</td></tr>
<tr><td><code>\bold{prop.width}</code></td>
<td>
<p>default <code>1</code>; this defines the proposal width used for multiplier and sliding-window proposals</p>
</td></tr>
<tr><td><code>\bold{simple.start}</code></td>
<td>
<p>default <code>TRUE</code>; this determines whether to start the MCMC sampler with minimal dimensionality</p>
</td></tr>
<tr><td><code>\bold{filebase}</code></td>
<td>
<p>default <code>"result"</code>; this defines a 'base' filename for the output</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>JM Eastman</p>


<h3>See Also</h3>

<p><code><a href="#topic+rjmcmc.bm">rjmcmc.bm</a></code>
</p>

<hr>
<h2 id='mecca'>
running a MECCA analysis
</h2><span id='topic+mecca'></span>

<h3>Description</h3>

<p>Runs MECCA's hybrid ABC-MCMC algorithm to jointly estimate diversification rates and trait evolution from incompletely sampled comparative data. Many of the arguments taken by this function are the same as those in calibrateMecca().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mecca(phy, richness, cladeMean, cladeVariance, model = c("BM", "Trend", "twoRate"),
   prior.list = list(priorSigma = c(-4.961845, 4.247066), priorMean = c(-10, 10)),
   start = start, Ngens = 10000, printFreq = 100, sigmaPriorType = "uniform",
   rootPriorType = "uniform", SigmaBounds = c(-4.961845, 4.247066), hotclade = NULL,
   divPropWidth = 0.1, scale = 1, divSampleFreq = 0, BoxCox = TRUE, outputName = "mecca")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mecca_+3A_phy">phy</code></td>
<td>

<p>time-calibrated phylogenetic tree of class 'phylo'
</p>
</td></tr>
<tr><td><code id="mecca_+3A_richness">richness</code></td>
<td>

<p>named vector of species richnesses corresponding to tips in the tree (if a tip does not represent a higher level taxon, its richness should be 1)
</p>
</td></tr>
<tr><td><code id="mecca_+3A_clademean">cladeMean</code></td>
<td>

<p>named vector of trait means (all tips in the tree must be represented)
</p>
</td></tr>
<tr><td><code id="mecca_+3A_cladevariance">cladeVariance</code></td>
<td>

<p>named vector of trait variances (all tips in the tree must be represented; if only one taxon is present, use 0 for the variance)
</p>
</td></tr>
<tr><td><code id="mecca_+3A_model">model</code></td>
<td>

<p>model of trait evolution to be used &ndash; options currently implemented are &quot;BM&quot; = Brownian Motion, &quot;Trend&quot; = Brownian moton with a trend, and &quot;twoRate&quot; = two Brownian rate model (see <code>hotclade</code> below).
</p>
</td></tr>
<tr><td><code id="mecca_+3A_prior.list">prior.list</code></td>
<td>

<p>a list containing prior distribution parameters (default values used if this argument is empty)
</p>
</td></tr>
<tr><td><code id="mecca_+3A_start">start</code></td>
<td>

<p>ouput of <code><a href="#topic+startingpt.mecca">startingpt.mecca</a></code>
</p>
</td></tr>
<tr><td><code id="mecca_+3A_ngens">Ngens</code></td>
<td>

<p>number of generations to run MECCA
</p>
</td></tr>
<tr><td><code id="mecca_+3A_printfreq">printFreq</code></td>
<td>

<p>frequency of printing the acceptance rate
</p>
</td></tr>
<tr><td><code id="mecca_+3A_sigmapriortype">sigmaPriorType</code></td>
<td>

<p>type of prior distribution on the Brownian rate parameter (currently either &quot;uniform&quot; or &quot;normal&quot;)
</p>
</td></tr>
<tr><td><code id="mecca_+3A_rootpriortype">rootPriorType</code></td>
<td>

<p>type of prior distribution on the root state rate parameter (currently &quot;uniform&quot; is available)
</p>
</td></tr>
<tr><td><code id="mecca_+3A_sigmabounds">SigmaBounds</code></td>
<td>

<p>bounds for sigma (default values correspond to a wide range taken from Harmon et al. 2010)
</p>
</td></tr>
<tr><td><code id="mecca_+3A_hotclade">hotclade</code></td>
<td>

<p>if a two-rate model is to be fit, this specifies which clade takes the second rate &ndash; two names should be specified in a vector; either the two tip names that span the clade of interest, or the name of a terminal/internal edge and NULL if only one branch takes the second rate
</p>
</td></tr>
<tr><td><code id="mecca_+3A_divpropwidth">divPropWidth</code></td>
<td>

<p>proposal width for the diversification MCMC (default value of 0.1 seems to work well)
</p>
</td></tr>
<tr><td><code id="mecca_+3A_scale">scale</code></td>
<td>

<p>a numeric value by which the proposal width for trait evolution parameters will be multiplied (a value of 2 seems to work well, but this should be adjusted for each individual dataset)
</p>
</td></tr>
<tr><td><code id="mecca_+3A_divsamplefreq">divSampleFreq</code></td>
<td>

<p>whether new trees are simulated at every step &ndash; the default (0) is yes; if a non-zero value is given, this will determine the frequency (every n steps) with which new tip trees are simulated
</p>
</td></tr>
<tr><td><code id="mecca_+3A_boxcox">BoxCox</code></td>
<td>

<p>whether summaries are BOX-COX standardized &ndash; default (1) is yes and is recommended; this should always be consistent with the calibration step
</p>
</td></tr>
<tr><td><code id="mecca_+3A_outputname">outputName</code></td>
<td>

<p>name stem for output file names
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output files produced are formatted to be used with the C++ Program ABCtoolbox (Wegmann et al. 2010), which produces adjusted posterior distributions and can perform model selection without likelihoods.
</p>


<h3>Value</h3>

<p>MECCA does not store any output in memory. Instead, five output files are generated to the current working directory. This files are fully compatible with ABCtoolbox (Wegmann et al. 2011). The first file (outputname_bdSimFile.tx) will output the posterior sample for diversification parameters. The second file (outputname_bmSimFile.txt) ouputs the sampled trait evolution parameters and their associated raw summary statistics while outputname_ObsFile.txt gives the observed summaries.For ABC toolbox though, it will often be more efficient to use pls-transformed versions of the observed and simulated summary statistics. These are available in outputname_distObs.txt, and outputname_distSimFile.txt.
</p>


<h3>Note</h3>

<p>The numbers printed to the screen during the run give the current generation, acceptance rate for diversification parameters, acceptance rate for trait evolutionary rate parameters and acceptance rate for root state parameters, respectively
</p>


<h3>Author(s)</h3>

<p>Graham Slater, Luke Harmon, Daniel Wegmann
</p>


<h3>References</h3>

<p>Slater GJ, LJ Harmon, D Wegmann, P Joyce, LJ Revell, and ME Alfaro. 2012. Fitting models of continuous trait evolution to incompletely sampled comparative data using approximate Bayesian computation. <em>Evolution</em> 66:752-762.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(carnivores)
phy &lt;- carnivores$phy
data &lt;- carnivores$dat
richness &lt;- data[,1]
names(richness) &lt;- rownames(data)

priors &lt;- list(priorSigma = c(-4.5, 4.5), priorMean = c(-5, 2))

## CALIBRATION (far too short for a real analysis)
Cal &lt;- calibrate.mecca(phy, richness, model = "BM", prior.list = priors, Ncalibrations = 1000)

params &lt;- Cal$trait[, c(1,2)] ## extract the calibration BM parameters
stats &lt;- Cal$trait[, -c(1,2)] ## extract the calibration summary stats

## now we run pls, determining combinations of summaries that explain variation in our parameters
## For BM, 2 components is sufficient. For more complex models, more componenets will be required.
require(pls)
myPlsr&lt;-pls::plsr(as.matrix(params) ~ as.matrix(stats), scale=F, ncomp = 2)

plot(RMSEP(myPlsr)) ## Look at Root Mean Square error plots

summary(myPlsr) ## take a look at 

plsdat &lt;- myPlsr$loadings

## extract means and variances from the carnivore data ##

cladeMean&lt;-data[,2]
names(cladeMean)&lt;-rownames(data)
cladeVariance&lt;-data[,3]
names(cladeVariance)&lt;-rownames(data)

## STARTING POINT
## And now we can compute starting values for the ABC-MCMC
start &lt;- startingpt.mecca(Cal, phy, cladeMean, cladeVariance,
tolerance = 0.05, plsdat, BoxCox = TRUE)


## MECCA (far too short for a real analysis)
mecca(phy, richness, cladeMean, cladeVariance, model = "BM", prior.list = priors, start = start,
   Ngens = 1000, printFreq = 100, sigmaPriorType = "uniform", rootPriorType = "uniform",
   SigmaBounds = c(-4.5, 4.5), divPropWidth = 0.1, scale = 2, divSampleFreq = 0, BoxCox = TRUE,
   outputName ="MeccaBM.txt")

## PASTE UNCOMMENTED FOLLOWING LINE TO DROP FILES CREATED BY MECCA
 # unlink(dir(pattern=paste(r)),recursive=TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='medusa'>
MEDUSA: modeling evolutionary diversification using stepwise AIC
</h2><span id='topic+medusa'></span><span id='topic+print.medusa'></span>

<h3>Description</h3>

<p>Fits piecewise birth-death models to ultrametric phylogenetic tree(s) according to phylogenetic (edge-length) and taxonomic (richness) likelihoods. Optimal model size is determined via a stepwise AIC approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medusa(phy, richness = NULL, criterion = c("aicc", "aic"),
    partitions=NA, threshold=NA, model = c("mixed", "bd", "yule"), 
    cut = c("both","stem","node"), stepBack = TRUE, 
    init = c(r=0.05, epsilon=0.5), ncores = NULL, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medusa_+3A_phy">phy</code></td>
<td>
<p>an ultrametric phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="medusa_+3A_richness">richness</code></td>
<td>
<p>an optional matrix of taxonomic richnesses (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="medusa_+3A_criterion">criterion</code></td>
<td>
<p>an information criterion to use as stopping criterion</p>
</td></tr>
<tr><td><code id="medusa_+3A_partitions">partitions</code></td>
<td>
<p>the maximum number of models to be considered</p>
</td></tr>
<tr><td><code id="medusa_+3A_threshold">threshold</code></td>
<td>
<p>the improvement in AIC score that should be considered significant (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="medusa_+3A_model">model</code></td>
<td>
<p>the flavor of piecewise models to consider (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="medusa_+3A_cut">cut</code></td>
<td>
<p>determines where shifts are placed on the tree (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="medusa_+3A_stepback">stepBack</code></td>
<td>
<p>determines whether parameter/model removal is considered. default = TRUE. (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="medusa_+3A_init">init</code></td>
<td>
<p>initial conditions for net diversification and relative extinction</p>
</td></tr>
<tr><td><code id="medusa_+3A_ncores">ncores</code></td>
<td>
<p>the number of processor cores to using in parallel processing. default = all</p>
</td></tr>
<tr><td><code id="medusa_+3A_verbose">verbose</code></td>
<td>
<p>print out extra information. default = FALSE</p>
</td></tr>
<tr><td><code id="medusa_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+treedata">treedata</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MEDUSA model fits increasingly complex diversification models to a dataset including <code>richness</code> information for sampled tips in <code>phy</code>. The tree must have branch lengths proportional to time. The <code>richness</code> object is optional, but must be given if the tree is not completely sampled. MEDUSA assumes that the entire extant diversity in the group is sampled either in <code>phy</code> or given by information contained within the <code>richness</code> object. The <code>richness</code> object associates species richness with lineages sampled in the tree. For instance, if a genus containing a total of 10 species is exemplied in the tree by a single tip, the total diversity of the clade must be recorded in the <code>richness</code> object (see <b>Examples</b>). All taxa missing from the tree have to be assigned to one of the tips in the <code>richness</code> matrix. If the <code>richness</code> object is <code>NULL</code>, the tree is assumed to be completely sampled.  
</p>
<p>The algorithm first fits a single diversification model to the entire dataset. A series of single breakpoints in the diversification process is then added, so that different parts of the tree evolve with different parameter values (per-lineage net diversification&ndash;<code>r</code> and relative extinction rates&ndash;<code>epsilon</code>). Initial values for these diversification parameters are given through the <code>init</code> argument and may need to be tailored for particular datasets. The algorithm compares all single-breakpoint models to the initial model, and retains the best breakpoint. Then all possible two-breakpoint models are compared with the best single-breakpoint model, and so on. Breakpoints may be considered at a <code>"node"</code>, a <code>"stem"</code> branch, or both (as dictated by the <code>cut</code> argument). Birth-death or pure-birth (Yule) processes (or a combination of these processes) may be considered by the MEDUSA algorithm. The model flavor is determined through the <code>model</code> argument. 
</p>
<p>Two stopping criteria are available for the MEDUSA algorithm. The user can either limit the number of piecewise models explored by MEDUSA or this number may be determined based on model fits. A maximum number of model partitions to be explored may be given a priori (if given a non-zero number through the <code>partitions</code> argument) or an information <code>criterion</code> is used to choose sufficient model complexity. If the latter stopping criterion is used, one needs to specify whether to use Akaike information criterion (<code>"aic"</code>) or sample-size corrected AIC (<code>"aicc"</code>); the latter is recommended, and is the default setting. An appropriate threshold in AICc differences between different MEDUSA models has been shown to be dependent on tree size. The threshold used for model selection is computed internally (and is based on extensive simulation study); this value is reported to the user. The user may choose to specify an alternative AIC-threshold with the (<code>"threshold"</code>) argument, making the algorithm more (or less) strict in scrutinizing model improvement.
</p>
<p>The user will almost certainly want to summarize the object returned from MEDUSA with the function TBA. 
</p>


<h3>Value</h3>

<p>A list object is returned including fits for all model complexities as well as summary information:
</p>
<table role = "presentation">
<tr><td><code>control</code></td>
<td>
<p>is a list object specifying the stopping criterion, the information criterion and threshold used (if appropriate), or the number of partitions explored</p>
</td></tr>
<tr><td><code>cache</code></td>
<td>
<p>is a list object primarily used internally (including the tree and richness information)</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>is a list object containing each optimized piecewise model, primarily for internal use</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>is a dataframe containing breakpoints and fit values for optimal models at each model complexity. If <code>partitions</code> is used as a stopping criterion. Other data include: the number of parameters for each model (<code>k</code>, determined by the number of breakpoints, independent net-diversification rates, and independent relative-extinction values), the branch or node chosen for each successive piecewise model (<code>split</code>), whether the split occurs at a node or stem (<code>cut</code>), and the model likelihood (<code>lnL</code>)</p>
</td></tr>
<tr><td><code>FUN</code></td>
<td>
<p>is a function used to summarize a particular model (indexed by number) and is primarily for internal use</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>JW Brown &lt;phylo.jwb@gmail.com&gt;, RG FitzJohn, ME Alfaro, LJ Harmon, and JM Eastman
</p>


<h3>References</h3>

<p>Alfaro, ME, F Santini, C Brock, H Alamillo, A Dornburg, DL Rabosky, G Carnevale, and LJ Harmon. 2009. Nine exceptional radiations plus high turnover explain species diversity in jawed vertebrates. <em>Proceedings of the National Academy of Sciences</em> <b>106</b>: 13410-13414.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.medusa">plot.medusa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    dat=get(data(whales))
    phy=dat$phy
    richness=dat$richness
    
    ## USING AICc as STOPPING CRITERION
    res1=medusa(phy, richness, warnings=FALSE)
    print(names(res1)) # output list elements
    print(res1$summary) # show 'summary' object
    summary(res1, criterion="aicc") # select best model based on AICc
    
    ## PLOTTING RESULTS
    # plot breakpoints for the best model chosen by AICc
    # invoking plot.medusa()
    plot(res1, cex=0.5,label.offset=1, edge.width=2) 
    
</code></pre>

<hr>
<h2 id='name.check'> Compares taxa in data and tree </h2><span id='topic+name.check'></span>

<h3>Description</h3>

<p>This function is a general tool for checking for concordance between a data file and a phylogenetic
tree.  For the data, names can be specified as the names of objects in the vector, rownames of the data 
array or as 'data.names'. The name.check function finds and lists all taxa present in data set but not 
in the tree, and vice-versa.  The treedata function returns a list containing both the tree and the data 
after pruning out any species that are not found in both. </p>


<h3>Usage</h3>

<pre><code class='language-R'>name.check(phy, data, data.names=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name.check_+3A_phy">phy</code></td>
<td>
<p> an object of class &quot;phylo&quot; </p>
</td></tr>
<tr><td><code id="name.check_+3A_data">data</code></td>
<td>
<p> data for tips of the tree </p>
</td></tr>
<tr><td><code id="name.check_+3A_data.names">data.names</code></td>
<td>
<p> names of the tips in the order of the data; if this is not given, names 
will be taken from the names or rownames of the object data</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Tree.not.data</code></td>
<td>
<p>Taxa in tree but not data</p>
</td></tr>
<tr><td><code>Data.not.tree</code></td>
<td>
<p>Taxa in data but not tree</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p> Luke J. Harmon </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(geospiza)

tmp &lt;- name.check(geospiza$phy, geospiza$dat)
tmp

## then match data to tree
newphy &lt;- drop.tip(geospiza$phy, tip=tmp$tree_not_data)

## name check should now say "OK"
name.check(newphy, geospiza$dat)

## this can all be done in one step using treedata
td &lt;- treedata(geospiza$phy, geospiza$dat)
td

all(td$phy$tip.label == newphy$tip.label)

</code></pre>

<hr>
<h2 id='nh.test'>
using the Freckleton and Harvey node-height test
</h2><span id='topic+nh.test'></span>

<h3>Description</h3>

<p>Fits a linear model between the absolute magnitude of the standardized independent contrasts and the height above the root of the node at which they were being compared to identify early bursts of trait evolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nh.test(phy, d, regression.type, log = TRUE, rlm.maxit = 20 , show.plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nh.test_+3A_phy">phy</code></td>
<td>

<p>A time calibrated phylogeny in &quot;phylo&quot; format
</p>
</td></tr>
<tr><td><code id="nh.test_+3A_d">d</code></td>
<td>

<p>A named vector of trait values. 
</p>
</td></tr>
<tr><td><code id="nh.test_+3A_regression.type">regression.type</code></td>
<td>

<p>The type of regression to be used. Specify <code>regression.type="lm"</code> to fit a standard linear model or <code>regression.type="rlm"</code> to fit a robust regression model 
</p>
</td></tr>
<tr><td><code id="nh.test_+3A_log">log</code></td>
<td>

<p>Whether the data should be logged or not.
</p>
</td></tr>
<tr><td><code id="nh.test_+3A_rlm.maxit">rlm.maxit</code></td>
<td>

<p>The maximum number of iterations to fit the robust regression model. This is ignored if <code>regression.type="lm"</code>. 
</p>
</td></tr>
<tr><td><code id="nh.test_+3A_show.plot">show.plot</code></td>
<td>

<p>Binary argument indicating whether plot should be made.
</p>
</td></tr>
<tr><td><code id="nh.test_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to plot
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="MASS.html#topic+rlm">rlm</a></code> object and outputs a plot if <code>show.plot=TRUE</code>
</p>


<h3>Author(s)</h3>

<p>Graham Slater
</p>


<h3>References</h3>

<p>Slater GJ and MW Pennell (in press) Robust regression and posterior predictive simulation increase power to detect early bursts of trait evolution. <em>Systematic Biology</em>.
</p>
<p>Freckleton RP and PH Harvey (2006) Detecting non-brownian evolution in adaptive radiations. <em>PLoS Biology</em> 4:e373.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp.mcmc">pp.mcmc</a></code>, <code><a href="ape.html#topic+pic">pic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(whales)

tmp &lt;- treedata(whales$phy, whales$dat[,1])

phy &lt;- tmp$phy
dat &lt;- tmp$data[,1]

nh.test(phy, dat, regression.type="lm", show.plot=TRUE)

</code></pre>

<hr>
<h2 id='nodelabel.phylo'>
Blending information from taxonomies and trees</h2><span id='topic+nodelabel.phylo'></span><span id='topic+lookup.phylo'></span><span id='topic+phylo.lookup'></span><span id='topic+phylo.clades'></span><span id='topic+glomogram.phylo'></span>

<h3>Description</h3>

<p>working with systematic reference tables and phylogenies</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodelabel.phylo(phy, taxonomy, strict=TRUE, ncores=NULL)
phylo.lookup(taxonomy, ncores=NULL)
lookup.phylo(phy, taxonomy = NULL, clades = NULL, ncores=NULL)
phylo.clades(clades, phy=NULL, unplaced=TRUE, ncores=NULL)
glomogram.phylo(phy, subtrees)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodelabel.phylo_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo' ('multiPhylo' in <code>phylo.clades</code>)</p>
</td></tr>
<tr><td><code id="nodelabel.phylo_+3A_taxonomy">taxonomy</code></td>
<td>
<p>a linkage table (of class <code>matrix</code>) between tips of the phylogeny and clades represented in the tree; rownames of 'taxonomy' should be tips found in the phylogeny</p>
</td></tr>
<tr><td><code id="nodelabel.phylo_+3A_clades">clades</code></td>
<td>
<p>a named list of clade definitions (i.e., spanning taxa; see <b>Examples</b>); spanning taxa may invoke other definitions found within the <code>clades</code> list</p>
</td></tr>
<tr><td><code id="nodelabel.phylo_+3A_unplaced">unplaced</code></td>
<td>
<p>whether to use 'unplaced' taxa if given as an element in <code>clades</code></p>
</td></tr> 
<tr><td><code id="nodelabel.phylo_+3A_subtrees">subtrees</code></td>
<td>
<p>a list of trees to be grafted into <code>phy</code>; each <code>subtrees</code> element must either be a 'phylo' or 'multiPhylo' object with branch lengths in the same units as <code>phy</code> (see <b>Examples</b>)</p>
</td></tr>
<tr><td><code id="nodelabel.phylo_+3A_strict">strict</code></td>
<td>
<p>whether to enforce strict labeling of nodes or allow
liberal estimates of the best location of a given nodelabel</p>
</td></tr>
<tr><td><code id="nodelabel.phylo_+3A_ncores">ncores</code></td>
<td>
<p>the maximum number of cores to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nodelabel.phylo</code> provides a function (as part of the <code>phylo</code> object returned) to resolve the hash key and node identifier for a label found in <code>taxonomy</code>. 
This function is the <code>FUN</code> element of the returned object. If the taxonomic label cannot be properly placed in the tree (i.e., no subtree is found that is absolutely 
consistent with the supplied <code>taxonomy</code>, the nearest matching node(s) will be returned when invoking <code>FUN</code>).   
</p>
<p><code>phylo.lookup</code> converts a <code>taxonomy</code> into a phylogenetic tree. 
</p>
<p><code>lookup.phylo</code> converts a phylogenetic tree (<code>phy</code>) into a linkage table based on nodelabels associated with <code>phy</code>, which can be supplemented with a <code>taxonomy</code> and (or) 
<code>clades</code> object.   
</p>
<p><code>phylo.clades</code> returns a series of phylogenetic subtrees based on clade definitions found in the <code>clades</code> object.  Definitions can be handles that are recursive (see <b>Examples</b>).
</p>


<h3>Author(s)</h3>

<p>JM Eastman</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sal=get(data(caudata))
print(head(sal$tax))

## TREE from TABLE: phylo.lookup()
tax=cbind(sal$tax[,c("subfamily", "family", "suborder")], order="Caudata")
tphy=phylo.lookup(tax, ncores=2)
print(tphy)
head(tphy$node.label)

## TABLE from TREE: lookup.phylo()
tax=sal$tax[,c("genus", "family")]
cld=list(
	Sirenoidea=c("Siren", "Pseudobranchus"), 
	Salamandroidea=c("Ambystomatidae", "Plethodontidae"), 
	Cryptobranchoidea=c("Hynobius_naevius", "Cryptobranchus_alleganiensis"),
	CAUDATA=c("Sirenoidea","Salamandroidea","Cryptobranchoidea")
)
lkp=lookup.phylo(sal$phy, taxonomy=tax, clades=cld, ncores=2)
print(lkp)
nphy=nodelabel.phylo(sal$phy, lkp, ncores=2)
dev.new()
plot.phylo(ladderize(nphy,right=FALSE), cex=0.35, 
type="fan", label.offset=2.5, no.margin=TRUE, edge.color="gray", edge.width=0.5)

nodelabels(nphy$node.label, cex=0.45, col="red", frame="n")

## CLADES to TREE: phylo.clades()
fmrca=geiger:::.mrca
salamandroidea=extract.clade(nphy, fmrca(c("Ambystomatidae", "Plethodontidae"), nphy))
cryptobranchoidea=extract.clade(nphy, fmrca(c("Cryptobranchidae", "Hynobiidae"), nphy))
siren=extract.clade(nphy, fmrca(c("Siren_lacertina", "Siren_intermedia"), nphy))

clades=list(
			 Sirenoidea=c("Siren", "Pseudobranchus"), 
			 Caudata=c("Sirenoidea","Salamandroidea","Cryptobranchoidea"),
			 AMPHIBIA=c("Caudata","Anura","Gymnophiona")
)

phy=list(Cryptobranchoidea=cryptobranchoidea, Salamandroidea=salamandroidea, Siren=siren)
class(phy)="multiPhylo"

res=phylo.clades(clades, phy, ncores=2)
amph=nodelabel.phylo(res$AMPHIBIA, lkp, ncores=2)
print(amph$FUN("Salamandroidea"))
dev.new()
plot(ladderize(amph, right=FALSE), cex=0.2, label.offset=0.05)
nodelabels(amph$node.label, cex=0.35, col="red", frame="n")


## GLOMOGRAM
sirenidae=extract.clade(nphy, fmrca(c("Siren_lacertina", "Pseudobranchus_axanthus"), nphy))
ambystomatidae=extract.clade(nphy, fmrca(c("Ambystoma_gracile", "Ambystoma_texanum"), nphy))
trees=list(
	Cryptobranchoidea=cryptobranchoidea,
	Sirenidae=sirenidae,
	Ambystomatidae=ambystomatidae
)
class(trees)="multiPhylo"

fam=sal$fam
ftax=unique(sal$tax[,c("family", "suborder")])
rownames(ftax)=unname(ftax[,"family"])
fam=nodelabel.phylo(fam, ftax, ncores=2)
fam$FUN("Salamandroidea")

res=glomogram.phylo(fam, trees)
dev.new()
zz=match(res$tip.label, fam$tip.label)
cc=integer(length(zz))
cc[!is.na(zz)]=1

plot(ladderize(res, right=FALSE), cex=1, label.offset=5, tip.color=ifelse(cc==1, "red", "black"))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.medusa'>
MEDUSA: modeling evolutionary diversification using stepwise AIC
</h2><span id='topic+plot.medusa'></span>

<h3>Description</h3>

<p>summarizing piecewise diversification models estimated by MEDUSA 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'medusa'
plot(x, cex = 0.5, time = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.medusa_+3A_x">x</code></td>
<td>
<p>an object of class <code>medusa</code> for plotting</p>
</td></tr>
<tr><td><code id="plot.medusa_+3A_cex">cex</code></td>
<td>
<p>text size</p>
</td></tr>
<tr><td><code id="plot.medusa_+3A_time">time</code></td>
<td>
<p>logical. should a time axis be plotted. default = TRUE.</p>
</td></tr>
<tr><td><code id="plot.medusa_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to internal functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+medusa">medusa</a></code> model returns a raw list object. This function is used to generate a modified <code>edge</code> matrix (see <code><a href="ape.html#topic+read.tree">read.tree</a></code> for details on the <code>edge</code> matrix), giving all relevant information about the estimated diversification process. The returned <b>z</b>-matrix includes: the ancestor (<code>anc</code>) and descendant (<code>dec</code>) relationships between nodes of the tree (using <span class="pkg">ape</span> indices); the beginning (<code>t.0</code>) and ending (<code>t.1</code>) times and length (<code>t.len</code>) of each branch; the diversities at the start (<code>n.0</code>) and end (<code>n.t</code>) of each branch; the piecewise model assigned <code>partition</code> to the branch; whether the branch is associated with a <code>shift</code>; the timing of the shift (<code>t.shift</code>); the net-diversification rate (<code>r</code>) and relative-extinction rate (<code>epsilon</code>) associated with the branch as well as for the direct ancestor of the branch (<code>ancestral.r</code> and <code>ancestral.epsilon</code>). The  <b>z</b>-matrix also includes a <code>summary</code> attribute that shows which model is chosen and associated information on model fit (see <b>Examples</b>). 
</p>
<p>The raw output of <code><a href="#topic+medusa">medusa</a></code> contains an optimized model. The summary output may then be sent to a plotting function which will display the location on the tree where breakpoints have been placed. Note that the first piecewise model corresponds to the root and all descendants (until another breakpoint is encountered).
</p>


<h3>Author(s)</h3>

<p>JW Brown &lt;phylo.jwb@gmail.com&gt;, RG FitzJohn, ME Alfaro, LJ Harmon, and JM Eastman
</p>


<h3>References</h3>

<p>Alfaro, ME, F Santini, C Brock, H Alamillo, A Dornburg, DL Rabosky, G Carnevale, and LJ Harmon. 2009. Nine exceptional radiations plus high turnover explain species diversity in jawed vertebrates. <em>Proceedings of the National Academy of Sciences</em> <b>106</b>: 13410-13414.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+medusa">medusa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    dat=get(data(whales))
    phy=dat$phy
    richness=dat$richness
        
    res &lt;- medusa(phy, richness)
    
    # select best model based on AICc (showing the third model as best)
    plot(res, cex=0.5, label.offset=1) # using plot.medusa()
    title("AICc-chosen model")
    
</code></pre>

<hr>
<h2 id='pp.mcmc'>
using posterior predictive MCMC for modeling quantitative trait evolution
</h2><span id='topic+pp.mcmc'></span>

<h3>Description</h3>

<p>performs posterior predictive checks for models of quantitative trait evolution. At present, only BM, EB, and clade.shift models are implemented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.mcmc(phy, d, Ngens = 1000000, sampleFreq = 1000, printFreq = 1000,
        prop.width = 1, model = "BM", eb.type = "exponential",
        clade = NULL, rlm.maxit = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pp.mcmc_+3A_phy">phy</code></td>
<td>

<p>A time calibrated phylogeny in &quot;phylo&quot; format
</p>
</td></tr>
<tr><td><code id="pp.mcmc_+3A_d">d</code></td>
<td>

<p>A named vector or dataframe of trait values.
</p>
</td></tr>
<tr><td><code id="pp.mcmc_+3A_ngens">Ngens</code></td>
<td>

<p>Number of generations that the posterior predictive MCMC will run for. Default is 1 million generations
</p>
</td></tr>
<tr><td><code id="pp.mcmc_+3A_samplefreq">sampleFreq</code></td>
<td>

<p>The frequency with which model parameters will be sampled from the chain and simulations run. Default is every 1000 generations
</p>
</td></tr>
<tr><td><code id="pp.mcmc_+3A_printfreq">printFreq</code></td>
<td>

<p>The frequency with which the current number of generations and acceptance rates will be printed to screen. Default is every 1000 generations
</p>
</td></tr>
<tr><td><code id="pp.mcmc_+3A_prop.width">prop.width</code></td>
<td>

<p>The width of the sliding window proposal distribution for ln(Sigmasq) and, if applicable, the exponential change parameter for EB. The width for the EB parameter is obtained by dividing by 10. Default proposal width is 1.
</p>
</td></tr>
<tr><td><code id="pp.mcmc_+3A_model">model</code></td>
<td>

<p>The model to fit and simulate under. Default is Brownian motion (BM). Other options are early burst (EB) or an edge shift model (edge.shift) where the rate is allowed to change along an internal edge leading to a specified clade (see argument &quot;clade&quot; and Slater and Pennell in press for an example)
</p>
</td></tr>
<tr><td><code id="pp.mcmc_+3A_eb.type">eb.type</code></td>
<td>

<p>The type of exponential change model assumed. If eb.type = &quot;exponential&quot; (the default), then an exponentially declining rate will be assumed and contrasts will be log transformed when computing the node height test. If eb.type = &quot;linear&quot;, a linear decline in rate will be assumed and untransformed contrasts will be used.
</p>
</td></tr>
<tr><td><code id="pp.mcmc_+3A_clade">clade</code></td>
<td>

<p>Default = NULL and is used if model = &quot;BM&quot; or model = &quot;EB&quot;. If using model = &quot;edge.shift&quot;, then a clade must be specified for which the stem lineage experiences a different rate of evolution. The clade is specified by giving the names of two taxa spanning the clade of interest, e.g. clade = c(&quot;A&quot;, &quot;B&quot;)
</p>
</td></tr>
<tr><td><code id="pp.mcmc_+3A_rlm.maxit">rlm.maxit</code></td>
<td>

<p>Maximum number of interations to use for the iteratively reweighted least squares optimization of the robust regression algorithm (see ?rlm). Default is 20 and should be sufficient for most problems
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs a posterior predictive MCMC under the specified model, sampling model parameters from their posterior distributions and simulating under that model. Simulated data are summarized using the Node height test (Freckleton and Harvey 2006) slope  (OLS and robust regression) and Morphological Disparity Index (Harmon et al. 2003). Model adequacy can then be assessed by comparing observed values for these summary statistics to the posterior predictive distributions
</p>


<h3>Value</h3>

<p>A dataframe containing the following columns:
</p>
<table role = "presentation">
<tr><td><code>$generation</code></td>
<td>
<p>the generation at which parameters where sampled and simulations conducted</p>
</td></tr>
<tr><td><code>$logLk</code></td>
<td>
<p>The sampled logLikelihood values for the model</p>
</td></tr>
<tr><td><code>$Sigma</code></td>
<td>
<p>Brownian rate parameter values</p>
</td></tr>
<tr><td><code>$node.height.slope.lm</code></td>
<td>
<p>posterior predictive distribution of slopes for the node height test using an ordinary least squares regression</p>
</td></tr>
<tr><td><code>$node.height.slope.rlm</code></td>
<td>
<p>posterior predictive distribution of slopes for the node height test using a robust regression</p>
</td></tr>
<tr><td><code>$MDI</code></td>
<td>
<p>posterior predictive distribution of MDI values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Graham Slater and Matthew Pennell
</p>


<h3>References</h3>

<p>Slater GJ and MW Pennell (2014) Robust regression and posterior predictive simulation increase power to detect early bursts of trait evolution. <em>Systematic Biology</em>.
</p>
<p>Freckleton RP and PH Harvey (2006) Detecting non-brownian evolution in adaptive radiations. <em>PLoS Biology</em> 4:e373.
</p>
<p>Harmon LJ, JA Schulte, A Larson, and JB Losos (2003). Tempo and mode of evolutionary readiations in iguanian lizards. <em>Science</em> 301:961-964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nh.test">nh.test</a></code>, <code><a href="#topic+dtt">dtt</a></code>, <code><a href="#topic+fitContinuous">fitContinuous</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(whales)

tmp &lt;- treedata(whales$phy, whales$dat[,1])

phy &lt;- tmp$phy
dat &lt;- tmp$data[,1]

## compute observed statistics

nht.ols &lt;- nh.test(phy, dat, regression.type = "lm",
log = TRUE, show.plot = FALSE)$coefficients[2,1]

nht.rlm &lt;- nh.test(phy, dat, regression.type = "rlm",
 log = TRUE, show.plot = FALSE)$coefficients[2,1]

mdi.exp &lt;- 0

#---- run short pp.mcmc

pp.eb &lt;- pp.mcmc(phy, dat, Ngens = 1000, sampleFreq = 10, printFreq = 100, model ="EB")

# ---- plot results

# quartz(width = 5, height = 7)
par(mar = c(4,5,1,1))
par(mfcol = c(3,1))


hist(pp.eb$MDI, col = "gray", border = "gray", main = NULL, xlab = "pp.MDI",
ylab = "Frequency", cex.axis = 1.2)

abline(v = mdi.exp, col = "black", lwd = 3, lty = 2)

mdi.p &lt;- length(which(pp.eb$MDI&lt;=0))/length(pp.eb$MDI)

hist(pp.eb$node.height.slope.lm, col = "gray", border = "gray", main = NULL, xlab = "pp.nht_ols",
ylab = "Frequency", cex.axis = 1.2)

abline(v = nht.ols, col = "black", lwd = 3, lty = 2)

node.height.ols.p &lt;- length(which(pp.eb$node.height.slope.lm &lt;= nht.ols)) /
(length(pp.eb$node.height.slope.lm) +1)


hist(pp.eb$node.height.slope.rlm, col = "gray", border = "gray", main = NULL, xlab = "pp.nht_ols",
ylab = "Frequency", cex.axis = 1.2)

abline(v = nht.rlm, col = "black", lwd = 3, lty = 2)

node.height.rr.p &lt;- length(which(pp.eb$node.height.slope.rlm &lt;= nht.rlm)) /
(length(pp.eb$node.height.slope.rlm) +1)


</code></pre>

<hr>
<h2 id='r8s.phylo'>
call r8s from geiger</h2><span id='topic+r8s.phylo'></span>

<h3>Description</h3>

<p>call r8s, including a calibration file</p>


<h3>Usage</h3>

<pre><code class='language-R'>r8s.phylo(phy, calibrations=NULL, base="r8srun", ez.run="none", rm=TRUE,
  blformat=c(lengths="persite", nsites=10000, ultrametric="no", round="yes"),
  divtime=c(method="NPRS", algorithm="POWELL"),
  cv=c(cvStart=0, cvInc=0.5, cvNum=8), do.cv=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r8s.phylo_+3A_phy">phy</code></td>
<td>
<p>a phylogram to turn into a chronogram</p>
</td></tr>
<tr><td><code id="r8s.phylo_+3A_calibrations">calibrations</code></td>
<td>
<p>a set of calibrations</p>
</td></tr>
<tr><td><code id="r8s.phylo_+3A_base">base</code></td>
<td>
<p>file name</p>
</td></tr>
<tr><td><code id="r8s.phylo_+3A_ez.run">ez.run</code></td>
<td>
<p>if set to &quot;PL&quot; or &quot;NPRS&quot;, does the analysis with settings appropriate for each</p>
</td></tr>
<tr><td><code id="r8s.phylo_+3A_rm">rm</code></td>
<td>
<p>remove the output files</p>
</td></tr>
<tr><td><code id="r8s.phylo_+3A_blformat">blformat</code></td>
<td>
<p>blformat options for r8s. Pay special attention to nsites.</p>
</td></tr>
<tr><td><code id="r8s.phylo_+3A_divtime">divtime</code></td>
<td>
<p>divtime options for r8s</p>
</td></tr>
<tr><td><code id="r8s.phylo_+3A_cv">cv</code></td>
<td>
<p>cv options for r8s</p>
</td></tr>
<tr><td><code id="r8s.phylo_+3A_do.cv">do.cv</code></td>
<td>
<p>Boolean for whether to do cross validation or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses r8s and a calibration to make your tree ultrametric</p>


<h3>Author(s)</h3>

<p>JM Eastman &amp; B O'Meara</p>


<h3>References</h3>

<p>SANDERSON r8s ____NEED TO ADD_____
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
phy &lt;- read.tree(text=paste0("(Marchantia:0.033817,",
  "(Lycopodium:0.040281,((Equisetum:0.048533",
  "Osmunda:0.033640,Asplenium:0.036526):0.000425):",
  "0.011806,((((Cycas:0.009460,Zamia:0.018847):",
  "0.005021,Ginkgo:0.014702):1.687e-86,((Pinus:",
  "0.021500,(Podocarpac:0.015649,Taxus:0.021081):",
  "0.006473):0.002448,(Ephedra:0.029965,(Welwitsch",
  ":0.011298,Gnetum:0.014165):0.006883):0.016663)",
  ":0.006309):0.010855,((Nymphaea:0.016835,(((((Saururus:",
  "0.019902,Chloranth:0.020151):1.687e-86,",
  "((Araceae:0.020003,(Palmae:0.006005,Oryza:0.031555):",
  "0.002933):0.007654,Acorus:0.038488):0.007844)",
  ":1.777e-83,(Calycanth:0.013524,Lauraceae:0.035902):",
  "0.004656):1.687e-86,((Magnolia:0.015119,Drimys:",
  "0.010172):0.005117,(Ranunculus:0.029027,((Nelumbo:",
  "0.006180,Platanus:0.002347):0.003958,(Buxaceae:",
  "0.013294,((Pisum:0.035675,(Fagus:0.009848,Carya:",
  "0.008236):0.001459):0.001994,(Ericaceae:0.019136,",
  "Solanaceae:0.041396):0.002619):1.687e-86):0.004803)",
  ":1.687e-86):0.006457):0.002918):0.007348,",
  "Austrobail:0.019265):1.687e-86):1.687e-86,Amborella:",
  "0.019263):0.003527):0.021625):0.012469):",
  "0.019372);"))

	calibrations &lt;- data.frame(MRCA="LP", MaxAge=450, MinAge=450,
		taxonA="marchantia", taxonB="pisum", stringsAsFactors=FALSE)

	phy.nprs &lt;- r8s.phylo(phy=phy, calibrations=calibrations, base="nprs_file", ez.run="NPRS")
	phy.pl &lt;- r8s.phylo(phy=phy, calibrations=calibrations, base="pl_file", ez.run="PL")
	
## End(Not run)
</code></pre>

<hr>
<h2 id='ratematrix'>evolutionary VCV matrix</h2><span id='topic+ratematrix'></span>

<h3>Description</h3>

<p>estimating the evolutionary or phylogenetic variance-covariance matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratematrix(phy, dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ratematrix_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="ratematrix_+3A_dat">dat</code></td>
<td>
<p>a named vector or matrix of continuous trait values, associated with species in <code>phy</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If given <code>dat</code> for <code>n</code> quantitative variables, this function returns the estimated evolutionary variance-covariance matrix of the variables under a multivariate Brownian motion model.  Note that other evolutionary models may be possible if the tree is first transformed (see <code><a href="#topic+rescale.phylo">rescale.phylo</a></code> and <b>Examples</b>).  If you have <code>n</code> characters in your analysis, this will be an <code>n</code>x<code>n</code> matrix. Diagonal elements represent rate estimates for individual characters, while off-diagonal elements represent the estimated covariance between two characters.
</p>


<h3>Author(s)</h3>

<p> LJ Harmon </p>


<h3>References</h3>

<p> Revell, L. J., L. J. Harmon, R. B. Langerhans, and J. J. Kolbe. 2007. A phylogenetic 
approach to determining the importance of constraint on phenotypic evolution in the 
neotropical lizard, <em>Anolis cristatellus</em>. <em>Evolutionary Ecology Research</em> 9: 261-282. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
geo &lt;- get(data(geospiza))

## EVOLUTIONARY VCV
ratematrix(geo$phy, geo$dat)

## EVOLUTIONARY VCV -- assuming speciational model
kphy &lt;- rescale(geo$phy, "kappa", 0)
ratematrix(kphy, geo$dat)
geo &lt;- get(data(geospiza))

## EVOLUTIONARY VCV
ratematrix(geo$phy, geo$dat)

## EVOLUTIONARY VCV -- assuming speciational model
kphy &lt;- rescale(geo$phy, "kappa", 0)
ratematrix(kphy, geo$dat)

</code></pre>

<hr>
<h2 id='rc'> relative cladogenesis test </h2><span id='topic+rc'></span>

<h3>Description</h3>

<p>conducting the relative cladogenesis test for all slices through a tree	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc(phy, plot=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rc_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="rc_+3A_plot">plot</code></td>
<td>
<p> whether to plot tree with significant branches highlighted</p>
</td></tr>
<tr><td><code id="rc_+3A_...">...</code></td>
<td>
<p>arguments passed for plotting (see <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A list of nodes is returned, along with the number of lineages alive just before that node, the 
maximum number of descendents that any of those lineages has at the present day, a p-value for this
observation under the null hypothesis of a birth-death process (that is, given the null, what is the 
probability that one of these lineages had at least that many descendents), and the p-value after 
Bonferroni correction (given that a total of n-1 comparisons are made).
</p>
<p>If a plot is made, asterisks will mark significantly diverse clades.  These asterisks appear just 
to the right of the MRCA of the diverse clade.
</p>
<p>The Bonferroni correction used here is exceedingly conservative for a tree of any reasonable size (and not 
necessarily recommended, especially given the exploratory nature of this test and the non-independence of the comparisons). Plotting defaults to indicating which nodes are significant without a Bonferroni correction and a P-value of 0.05 as a cutoff (see <b>Examples</b> for modifying this behavior).
</p>
<p>One will often see significant results &quot;trickle down&quot; nodes in the tree - that is, if one clade is 
expecially diverse, then one or more of its parent clades will also be diverse.  The most 
parsimonious place to attribute this effect is to the most shallow significant branch - that is, 
the branch closest to the tips (see Moore et al. 2004).
</p>


<h3>Value</h3>

<p>Table of results with four columns: 
Number of ancestors, Maximum descendents, p-value, Bonferroni-corrected p-value
</p>


<h3>Author(s)</h3>

<p> LJ Harmon </p>


<h3>References</h3>

 
<p>Purvis A, S Nee, and PH Harvey. 1995. <em>Proc. R. Soc. London Ser. B</em> 260:329-333.
</p>
<p>Moore BR, KMA Chan, and MJ Donoghue. 2004. Detecting diversification rate variation in supertrees. In O.R.P. Bininda-Emonds (ed.), <em>Phylogenetic 
Supertrees: Combining Information to Reveal the Tree of Life</em>, pp. 487-533. Kluwer Academic, Netherlands:Dordrecht.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
geo &lt;- get(data(geospiza))

## WITHOUT BONFERRONI CORRECTION
rc(geo$phy)

## WITH BONFERRONI CORRECTION and ALPHA=0.15
rc(geo$phy, bonf=TRUE, p.cutoff=0.15)

</code></pre>

<hr>
<h2 id='rescale.phylo'>Rescale object of class <code>"phylo"</code></h2><span id='topic+rescale.phylo'></span>

<h3>Description</h3>

<p>Applying various transformation to the branches of a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
rescale(x, model = c("BM", "OU", "EB", "nrate", "lrate",
    "trend", "lambda", "kappa", "delta", "white", "depth"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale.phylo_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo"</code>/</p>
</td></tr>
<tr><td><code id="rescale.phylo_+3A_model">model</code></td>
<td>
<p>a model used to transform the tree (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="rescale.phylo_+3A_...">...</code></td>
<td>
<p>argument(s) to be passed to the transformation function (see <b>Examples</b>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a tree and returns either a transformed tree if <code>...</code> is not empty and gives the parameter value(s) for the tree transformation. If <code>...</code> is left empty, a function is returned to the user that can be efficiently iterated over many parameter values for transformation. The available models are meant to correspond with changing the model of phenotypic evolution for discrete or continuous characters. 
</p>


<h3>Value</h3>

<p>A transformation function (or rescaled phylogenetic tree of class 'phylo' (<span class="pkg">ape</span> format) is returned. Possible transforms include the following: 
</p>
<table role = "presentation">
<tr><td><code>\bold{BM}</code></td>
<td>
<p>is the Brownian motion model, which fits a random walk with variance <code>sigsq</code></p>
</td></tr>
<tr><td><code>\bold{OU}</code></td>
<td>
<p>is the Ornstein-Uhlenbeck model (Butler and King 2004), which fits a random walk with a central tendency with an attraction strength proportional to the parameter <code>alpha</code>. The <code>OU</code> model is called the <code>hansen</code> model in <span class="pkg">ouch</span>, although the way the parameters are fit is slightly different here. The parameter used for transformation is <code>alpha</code></p>
</td></tr>
<tr><td><code>\bold{EB}</code></td>
<td>
<p>is the Early-burst model (Harmon et al. 2010) and also called the <code>ACDC</code> model (accelerating-decelerating; Blomberg et al. 2003). Set by the <code>a</code> rate parameter, <code>EB</code> fits a model where the rate of evolution increases or decreases exponentially through time, under the model r[t] = r[0] * exp(a * t), where <code>r[0]</code> is the initial rate, <code>a</code> is the rate change parameter, and <code>t</code> is time. The parameter used for transformation is <code>a</code>.</p>
</td></tr>
<tr><td><code>\bold{nrate}</code></td>
<td>
<p>is the multiple-rates model where time slices have independent rates of evolution. The parameters used for transformation are <code>time</code> and <code>rate</code>, both of which may be vectors. If rates for several time slices are given, the vectors <code>time</code> and <code>rate</code> must match in length. The <code>time</code> argument is expected in relative branching heights (where the root is 0 and the tips of an ultrametric tree terminate at a relative time of 1). Note that the default behavior is for the multirate transformation to rescale the tree to its original height, while preserving the relative rates across the tree. Note also that the default initial relative rate (<code>sigsq</code>, for the rootmost time slice) is 1.</p>
</td></tr>
<tr><td><code>\bold{lrate}</code></td>
<td>
<p>is the multiple-rates model where local clades have independent rates of evolution. The parameters used for transformation are <code>node</code> and <code>rate</code>, both of which may be vectors. If rates for several lineages are given, the vectors <code>node</code> and <code>rate</code> must match in length. The <code>node</code> argument is expected to have node identifiers consistent with <span class="pkg">ape</span> labeling (see <code><a href="ape.html#topic+read.tree">read.tree</a></code>). This <code>node</code> argument defines where breakpoints occur in the tree (at which a transition to the associated relative rate occurs). Note that the stem branch associated with the node is included as part of the defined rate partition. Rates given are relative to a default rootmost partition with a rate scalar (<code>sigsq</code>) of 1.</p>
</td></tr>
<tr><td><code>\bold{trend}</code></td>
<td>
<p>is a diffusion model with linear trend in rates through time. The parameter used for transformation is <code>slope</code>.</p>
</td></tr>
<tr><td><code>\bold{lambda}</code></td>
<td>
<p>is one of the Pagel (1999) models that fits the extent to which the phylogeny predicts covariance among trait values for species. The model effectively transforms the tree as follows: values of <code>lambda</code> near 0 cause the phylogeny to become more star-like, and a <code>lambda</code> value of 1 recovers the <code>BM</code> model. The parameter used for transformation is <code>lambda</code>.</p>
</td></tr>
<tr><td><code>\bold{kappa}</code></td>
<td>
<p>is a punctuational (speciational) model of trait evolution (Pagel 1999), where character divergence is related to the number of speciation events between two species. Note that if there are missing speciation events in the given phylogeny (due to extinction or incomplete sampling), interpretation under the <code>kappa</code> model may be difficult. Considered as a tree transformation, the model raises all branch lengths to an estimated power (<code>kappa</code>). The parameter used for transformation is <code>kappa</code>.</p>
</td></tr>
<tr><td><code>\bold{delta}</code></td>
<td>
<p>is a time-dependent model of trait evolution (Pagel 1999).  The <code>delta</code> model is similar to <code>ACDC</code> insofar as the <code>delta</code> model fits the relative contributions of early versus late evolution in the tree to the covariance of species trait values.  Where <code>delta</code> is greater than 1, recent evolution has been relatively fast; if <code>delta</code> is less than 1, recent evolution has been comparatively slow. Intrepreted as a tree transformation, the model raises all node depths to an estimated power (<code>delta</code>). The parameter used for transformation is <code>delta</code>. Note that the default behavior is for the delta transformation to rescale the tree to its original height.</p>
</td></tr>
<tr><td><code>\bold{white}</code></td>
<td>
<p>is a <code>white</code>-noise (non-phylogenetic) model, which assumes data come from a single normal distribution with no covariance structure among species</p>
</td></tr>
<tr><td><code>\bold{depth}</code></td>
<td>
<p>is simply a transformation of the total depth of the tree; stretching the tree has an effect of increasing rates of evolution under Brownian motion (relative to characters evolved on the unstretched tree), and compressing the tree has the opposite effect. The parameter used for transformation is <code>depth</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>LJ Harmon and JM Eastman</p>


<h3>References</h3>

<p>Pagel, M. 1999. Inferring the historical patterns of biological evolution. <em>Nature</em> 401:877-884.
</p>
<p>Butler, M.A. and A.A. King, 2004. Phylogenetic comparative analysis: a modeling approach for adaptive evolution. <em>American Naturalist</em> 164:683-695.
</p>
<p>Various papers in prep., L. J. Harmon and J. T. Weir.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

geo &lt;- get(data(geospiza))

## returning a function
ltrns &lt;- rescale(geo$phy, "lambda")
plot(ltrns(0))
title("lambda: 0.0")

plot(ltrns(0.5))
title("lambda: 0.5")

plot(ltrns(1))
title("lambda: 1")


## transforming the tree
lphy &lt;- rescale(geo$phy, "lambda", 0.5) # transform tree in one fell swoop
plot(lphy)
title("lambda: 0.5")

## multirate tree -- time
rtrns &lt;- rescale(geo$phy, "nrate")
rphy &lt;- rtrns(time=c(0.2, 0.4, 0.6, 0.8), rate=c(2, 4, 8, 16))
plot(rphy)
title("5-rate tree: by time")

## multirate tree -- lineages
mtrns &lt;- rescale(geo$phy, "lrate")
mphy &lt;- mtrns(node=c(25, 20), rate=c(4, 8))
plot(mphy)
title("3-rate tree: by lineages")

</code></pre>

<hr>
<h2 id='rjmcmc.bm'>Bayesian sampling of shifts in trait evolution: relaxed Brownian motion</h2><span id='topic+rjmcmc.bm'></span>

<h3>Description</h3>

<p>Implements reversible-jump Markov chain Monte Carlo sampling for trait evolutionary models</p>


<h3>Usage</h3>

<pre><code class='language-R'>rjmcmc.bm(phy, dat, SE=NA, ngen = 50000, samp = 100, 
    type = c("jump-rbm", "rbm", "jump-bm", "bm"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rjmcmc.bm_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="rjmcmc.bm_+3A_dat">dat</code></td>
<td>
<p>a named vector of continuous trait values, associated with each species in <code>phy</code></p>
</td></tr>
<tr><td><code id="rjmcmc.bm_+3A_se">SE</code></td>
<td>
<p>a named vector of standard errors for each trait value; applied to all trait values if given a single value</p>
</td></tr>
<tr><td><code id="rjmcmc.bm_+3A_ngen">ngen</code></td>
<td>
<p>number of sampling generations</p>
</td></tr>
<tr><td><code id="rjmcmc.bm_+3A_samp">samp</code></td>
<td>
<p>frequency with which Markov samples are retained (e.g., <code>samp=10</code> retains every tenth sample in the chain)</p>
</td></tr>
<tr><td><code id="rjmcmc.bm_+3A_type">type</code></td>
<td>
<p>the class of model to use (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="rjmcmc.bm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+make.gbm">make.gbm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented is an MCMC sampler for a general model of Brownian motion, which in the full model (<code>type="jump-rbm"</code>) allows relaxed local clocks and also a point process of pulses 
in evolutionary rate along individual branches. Restricted models include global-rate Brownian motion (<code>type="bm"</code>), relaxed-rates Brownian motion (<code>type="rbm"</code>), and models including
jumps but a single rate of diffusion across the tree (<code>type="jump-bm"</code>). 
</p>
<p>Where applicable, posterior estimates of <code>shifts</code> between local rates, estimates of the <code>rates</code> themselves, and inferred <code>jumps</code> (or pulses) are provided as output. 
Estimates are stored as an MCMC-generations-by-branches matrix (see <b>Examples</b>), and branches are uniquely labeled by a cryptographic function to ensure comparability amongst trees 
differing in topology (see <code><a href="digest.html#topic+digest">digest</a></code>). 
</p>
<p>Note that default settings (as the user assumes if nothing is specified in <code>...</code>) provide absolutely no guarantee of the chain achieving convergence.  The user is 
emphatically encouraged to supply informed arguments for what are the most critical aspects of this MCMC sampler (see <code><a href="#topic+make.gbm">make.gbm</a></code> for more information on 
permissible modifications to the MCMC sampler). Finding reasonable run parameters will likely require much trial and error.  Run diagnosis and inspection of chain mixing is 
facilitated by the R-package <span class="pkg">coda</span> or by the Java application, Tracer (<a href="http://tree.bio.ed.ac.uk/software/tracer/">http://tree.bio.ed.ac.uk/software/tracer/</a>).
</p>
<p>In the <b>Examples</b> below, do <em>not</em> expect such short chains to reach stationarity!
</p>


<h3>Value</h3>

<p>After a run has completed, acceptance rates for the primary proposal mechanisms are printed to the console, along with 
settings of control parameters for the run (see <code><a href="#topic+make.gbm">make.gbm</a></code>).  
</p>
<p>Posterior results are written to several files within a base directory, the contents of which are as follows:
</p>
<table role = "presentation">
<tr><td><code>\bold{log}</code></td>
<td>
<p>is a logfile including the following for each Markov chain: the generations at which samples were retained (<code>state</code>), the <code>min</code>, <code>max</code>, and <code>median</code> rate of the 
diffusion process across the tree, the number of evolutionary pulses (<code>jumps</code>) along single branches, the variance associated with the jump process (<code>jumpvar</code>), the <code>root</code> state, 
and the likelihood (<code>lnL</code>) and prior (<code>lnLp</code>) of the model at sampled generations.</p>
</td></tr>
<tr><td><code>\bold{rda}</code></td>
<td>
<p>is a compressed R object, which stores branchwise estimates of the jump and diffusion processes. In order to be interpretable, the <code>rda</code> file should be processed by the function 
<code><a href="#topic+load.rjmcmc">load.rjmcmc</a></code>.  The package <span class="pkg">coda</span> can be used within R for run diagnostics on the processed output (see, e.g., <code><a href="coda.html#topic+heidel.diag">heidel.diag</a></code> and <code><a href="coda.html#topic+autocorr">autocorr</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>JM Eastman, LJ Harmon, AL Hipp, and JC Uyeda</p>


<h3>References</h3>

<p> Eastman JM, ME Alfaro, P Joyce, AL Hipp, and LJ Harmon. 2011. A novel comparative method for identifying shifts in the rate of character evolution on trees. <em>Evolution</em> 65:3578-3589.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.rjmcmc">load.rjmcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## GENERATE DATA: jump-diffusion
phy &lt;- ladderize(sim.bdtree(n=200), right=FALSE)
r &lt;- paste(sample(letters,9,replace=TRUE),collapse="")
defpar &lt;- par(no.readonly=TRUE)


tmp &lt;- ex.jumpsimulator(phy, jumps=10)
dat &lt;- tmp$dat
hist &lt;- tmp$hist

ex.traitgram(phy, hist, alpha=0) # plot history of trait change

## RUN ANALYSIS


## coda package is not a dependency of geiger
## but is very useful for evaluating mcmc runs
## library(coda)


rjmcmc.bm(phy,dat, prop.width=1.5, ngen=20000, samp=500, filebase=r,
          simple.start=TRUE, type="jump-bm")
outdir &lt;- paste("jump-BM", r, sep=".")
ps &lt;- load.rjmcmc(outdir)

dev.new()
plot(x=ps, par="jumps", burnin=0.25, legend=FALSE, show.tip=FALSE, type="fan", edge.width=2)
mm=match(phy$edge[,2],hist$descendant)
hist=hist[mm,]
edgelabels.auteur(text=NULL, pch=21, cex=hist$cex, bg=NA, col=ifelse(hist$cex&gt;0, 1, NA), lty=2)
title("red (estimated); black (true jump size)", line=-5)
par(defpar)

dev.new()
## from the coda package
coda::autocorr.plot(ps$log, ask=dev.interactive())
plot(ps$log, ask=dev.interactive())

## GENERATE DATA: multi-rate diffusion
scl &lt;- ex.ratesimulator(phy, min=12, show.tip=FALSE)
dat &lt;- rTraitCont(scl)

## RUN ANALYSIS
rjmcmc.bm(phy, dat, prop.width=1.5, ngen=20000, samp=500, filebase=r, simple.start=TRUE, type="rbm")
outdir &lt;- paste("relaxedBM", r, sep=".")
ps &lt;- load.rjmcmc(outdir)
dev.new()
plot(x=ps, par="shifts", burnin=0.25, legend=TRUE, show.tip=FALSE, edge.width=2)

if(!interactive()) { ## clean up
    dirs &lt;- dir(pattern="^(jump-BM|relaxedBM)")
    unlink(dirs, recursive=TRUE)
}

</code></pre>

<hr>
<h2 id='sim.bd'>birth-death population simulator</h2><span id='topic+sim.bd'></span>

<h3>Description</h3>

<p>simulating species richness (or population growth) under a uniform, time-homogeneous 
birth-death process	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.bd(b=1, d=0, n0=1, times=0:4, seed=0) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.bd_+3A_b">b</code></td>
<td>
<p>per-lineage birth (speciation) rate</p>
</td></tr>
<tr><td><code id="sim.bd_+3A_d">d</code></td>
<td>
<p>per-lineage death (extinction) rate</p>
</td></tr>
<tr><td><code id="sim.bd_+3A_n0">n0</code></td>
<td>
<p>number of taxa at starting time zero</p>
</td></tr>
<tr><td><code id="sim.bd_+3A_times">times</code></td>
<td>
<p>vector of times where extant species are counted</p>
</td></tr>
<tr><td><code id="sim.bd_+3A_seed">seed</code></td>
<td>
<p>random number seed (default is to seed based on the clock)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates species diversification under a uniform birth-death process. This differs 
from <code><a href="#topic+sim.bdtree">sim.bdtree</a></code> in that only the number of species, and not their phylogenetic affinities, are
stored. This function relates to <code><a href="#topic+bd.ms">bd.ms</a></code> and <code><a href="#topic+bd.km">bd.km</a></code>, which are also non-phylogenetic.
</p>


<h3>Value</h3>

<p>a matrix of population size at each time point
</p>


<h3>Author(s)</h3>

<p> RE Glor and LJ Harmon </p>


<h3>References</h3>

<p>Yule, GU. 1924. A mathematical theory of evolution based on the conclusions of 
Dr. J. C. Willis, FRS. <em>Philos. Trans. R. Soc. London Ser. B</em> 213:21-87 </p>


<h3>See Also</h3>

<p><code><a href="#topic+bd.ms">bd.ms</a></code>; <code><a href="#topic+bd.km">bd.km</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop1 &lt;- sim.bd(b=0.1, d=0, n0=10, times=1:10)
pop2 &lt;- sim.bd(b=0, d=0.1, n0=10, times=1:10)
pop3 &lt;- sim.bd(b=0.1, d=0.1, n0=10, times=1:10)

plot(pop1, type="l", ylim=c(0,max(c(pop1[,"n"], pop2[,"n"], pop3[,"n"]))))
lines(pop2, col="red")
lines(pop3, col="blue")

</code></pre>

<hr>
<h2 id='sim.bdtree'>birth-death tree simulator</h2><span id='topic+sim.bdtree'></span>

<h3>Description</h3>

<p>simulating phylogenetic trees under a uniform birth-death process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.bdtree(b=1, d=0, stop=c("taxa", "time"), n=100, t=4, seed=0, extinct=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.bdtree_+3A_b">b</code></td>
<td>
<p>per-lineage birth (speciation) rate</p>
</td></tr>
<tr><td><code id="sim.bdtree_+3A_d">d</code></td>
<td>
<p>per-lineage death (extinction) rate</p>
</td></tr>
<tr><td><code id="sim.bdtree_+3A_stop">stop</code></td>
<td>
<p>stopping criterion</p>
</td></tr>
<tr><td><code id="sim.bdtree_+3A_n">n</code></td>
<td>
<p>maximum number of taxa in simulation</p>
</td></tr>
<tr><td><code id="sim.bdtree_+3A_t">t</code></td>
<td>
<p>maximum time steps of simulation</p>
</td></tr>
<tr><td><code id="sim.bdtree_+3A_seed">seed</code></td>
<td>
<p>random number seed (default is to seed based on the clock)</p>
</td></tr>
<tr><td><code id="sim.bdtree_+3A_extinct">extinct</code></td>
<td>
<p> whether to return trees where all lineages have gone extinct (see <b>Details</b>)</p>
</td></tr>  </table>


<h3>Details</h3>

<p>Starting from a root node - i.e., two living lineages - this function simulates the growth of a
phylogenetic tree under a uniform, time-homogeneous birth-death process.  This means that every
lineage has a constant probability of speciating, and a constant probability of going extinct, per
unit time.  If birth is greater than death, then the number of lineages is expected to grow exponentially.
If <code>extinct=FALSE</code>, the function will build trees until one is simulated with at least one surviving lineage. 
</p>


<h3>Value</h3>

<p>A phylogenetic tree in 'phylo' format is returned.  If death rate is non-zero, then the returned tree will likely 
include some extinct lineages (terminating before the present day).  See <code><a href="#topic+drop.extinct">drop.extinct</a></code> for 
a function to remove these lineages.
</p>


<h3>Note</h3>

 
<p>One note of caution: it is easy to set parameter values that result in tremendously <em>huge</em> trees.  If the
function seems to hang up, this could be the problem.
</p>
<p>Other tree simulators are available from the packages <span class="pkg">ape</span> (<code><a href="ape.html#topic+rbdtree">rbdtree</a></code>), <span class="pkg">TreeSim</span> (<code><a href="TreeSim.html#topic+sim.bd.taxa">sim.bd.taxa</a></code>, <code><a href="TreeSim.html#topic+sim.bd.age">sim.bd.age</a></code>, and <code><a href="TreeSim.html#topic+sim.bd.taxa.age">sim.bd.taxa.age</a></code>), and <span class="pkg">phytools</span> (<code><a href="phytools.html#topic+pbtree">pbtree</a></code>).
</p>


<h3>Author(s)</h3>

<p> LJ Harmon and J Weir</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.bd">sim.bd</a></code> for non-phylogenetic simulations; <code><a href="#topic+drop.extinct">drop.extinct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Pure-birth tree
p1 &lt;- sim.bdtree(b=0.1, d=0, stop="time", t=20)
plot(p1)

# Birth-death tree with extinct taxa
# The extinct flag prevents trees with no survivors

p2 &lt;- sim.bdtree(b=0.2, d=0.05, stop="time", t=20, extinct=FALSE)
plot(p2)

# Previous tree with extinct taxa removed
p3 &lt;- drop.extinct(p2)

</code></pre>

<hr>
<h2 id='sim.char'> simulate character evolution </h2><span id='topic+sim.char'></span>

<h3>Description</h3>

<p>simulating evolution of discrete or continuous characters on a phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.char(phy, par, nsim = 1, model = c("BM", "speciational", "discrete"), root = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.char_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="sim.char_+3A_par">par</code></td>
<td>
<p>matrix describing model (either vcv matrix or Q matrix) </p>
</td></tr>
<tr><td><code id="sim.char_+3A_nsim">nsim</code></td>
<td>
<p> number of simulations to run </p>
</td></tr>
<tr><td><code id="sim.char_+3A_model">model</code></td>
<td>
<p>a model from which to simulate data</p>
</td></tr>
<tr><td><code id="sim.char_+3A_root">root</code></td>
<td>
<p>starting state (value) at root</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates either discrete or continuous data on a phylogenetic tree. The model variable 
determines the type of simulation to be run. There are three options: <code>discrete</code>, which evolves
characters under a continuous time Markov model, and two continuous models, <code>BM</code> and <code>speciational</code>.
The <code>BM</code> model is a constant rate Brownian-motion model, while <code>speciational</code> is a Brownian model on a tree
where all branches have the same length.  The <code>model.matrix</code> parameter gives the structure of the model, 
and should be either a transition matrix, Q, for the <code>discrete</code> model, or a trait variance-covariance 
matrix for <code>BM</code> or <code>speciational</code> models.  For discrete models, multiple characters may be simulated 
if <code>model.matrix</code> is given as a list of Q matrices (see <b>Examples</b>). For continuous models, multivariate characters can be simulated, 
with their evolution goverened by a covariance matrix specified in the <code>model.matrix</code>. 
</p>


<h3>Value</h3>

<p>An array of simulated data, either two or three-dimensional, is returned. 
The first dimension is the number of taxa, the second the number of characters, and the third the 
number of simulated data sets.
</p>


<h3>Author(s)</h3>

<p> LJ Harmon </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
geo &lt;- get(data(geospiza))

## Continuous character -- univariate
usims &lt;- sim.char(geo$phy, 0.02, 100)

## Use a simulated dataset in fitContinuous()
fitC &lt;- fitContinuous(geo$phy, usims[,,1], model="BM", control=list(niter=10), ncores=2)

## Continuous character -- multivariate
s &lt;- ratematrix(geo$phy, geo$dat)
csims &lt;- sim.char(geo$phy, s, 100)

## Discrete character -- univariate
q &lt;- list(rbind(c(-.5, .5), c(.5, -.5)))
dsims &lt;- sim.char(geo$phy, q, model="discrete", n=10)

## Use a simulated dataset in fitDiscrete()
fitD &lt;- fitDiscrete(geo$phy, dsims[,,1], model="ER", niter=10, ncores=2)

## Discrete character -- multivariate
qq &lt;- list(rbind(c(-.5, .5), c(.5, -.5)), rbind(c(-.05, .05), c(.05, -.05)))
msims &lt;- sim.char(geo$phy, qq, model="discrete", n=10)

## End(Not run)
  
</code></pre>

<hr>
<h2 id='startingpt.mecca'>
starting values for MECCA
</h2><span id='topic+startingpt.mecca'></span>

<h3>Description</h3>

<p>This function takes the output of calibrateMecca along with observed data and partial least squares loadings and outputs starting values and tuning parameters for the ABC-MCMC (Wegmann et al. 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startingpt.mecca(calibrationOutput, phy, cladeMean, cladeVariance,
                 tolerance = 0.01, plsComponents, BoxCox = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="startingpt.mecca_+3A_calibrationoutput">calibrationOutput</code></td>
<td>

<p>The output from calibrateMecca
</p>
</td></tr>
<tr><td><code id="startingpt.mecca_+3A_phy">phy</code></td>
<td>

<p>A time calibrated phylogeny in &quot;phylo&quot; format
</p>
</td></tr>
<tr><td><code id="startingpt.mecca_+3A_clademean">cladeMean</code></td>
<td>

<p>A named vector of trait means. All tips in the tree must be represented
</p>
</td></tr>
<tr><td><code id="startingpt.mecca_+3A_cladevariance">cladeVariance</code></td>
<td>

<p>A names vector of trait variances. All tips in the tree must be represented. If only one taxon is present, use 0 for the variance
</p>
</td></tr>
<tr><td><code id="startingpt.mecca_+3A_tolerance">tolerance</code></td>
<td>

<p>The proportion of calibrations simulations that fall closest to the oberved data that will be retained to compute MECCA tuning parameters
</p>
</td></tr>
<tr><td><code id="startingpt.mecca_+3A_plscomponents">plsComponents</code></td>
<td>

<p>a matrix of Partial Least Squares component loadings
</p>
</td></tr>
<tr><td><code id="startingpt.mecca_+3A_boxcox">BoxCox</code></td>
<td>

<p>Logical - Should Summary Statistics be Box-Cox transformed? Default is yes and is recommended
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You will need to compute PLS loadings using the package &quot;pls&quot; prior to running this function. MECCA performs extremely poorly if summaries are not PLS transformed. If Bayes Factors are to be computed to perform model selection (Leuenberger and Wegmann 2010), raw summaries will need to be used in the post-sampling adjustment step. However, PLS transformed summaries can still be used in the acceptance/rejection step of the MCMC and can also be used to determine which simulations to retain
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>$tuning</code></td>
<td>
<p>a matrix containing starting values and proposal widths for trait evolution parameters</p>
</td></tr>
<tr><td><code>$startingBirth</code></td>
<td>
<p>Starting value for speciation</p>
</td></tr>
<tr><td><code>$startingDeath</code></td>
<td>
<p>Starting value for extinction</p>
</td></tr>
<tr><td><code>$dcrit</code></td>
<td>
<p>the criticial distance - simulated data must fall within this distance of the observed data in order to be accepted</p>
</td></tr>
<tr><td><code>$obsTraits</code></td>
<td>
<p>the observed data</p>
</td></tr>
<tr><td><code>$plsObserved</code></td>
<td>
<p>Partial Least Squared transformed observed data</p>
</td></tr>
<tr><td><code>$plsLoadings</code></td>
<td>
<p>Partial Least Squared componenent loadings - these are used to transform data during the MCMC</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Graham Slater, Luke Harmon, Daniel Wegman
</p>


<h3>References</h3>

<p>Slater GJ, Harmon LJ, Wegmann D, Joyce P, Revell LJ, Alfaro ME. in press Evolution, Leuenberger C, and Wegmann D. 2010. Genetics 184: 243-252., Wegmann D, Leuenberger C, Excoffier L. 2009. Genetics 182: 1207-1218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example(mecca)

</code></pre>

<hr>
<h2 id='subset.phylo'>
blending information from taxonomies and trees </h2><span id='topic+subset.phylo'></span>

<h3>Description</h3>

<p>working with systematic reference tables and phylogenies</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    ## S3 method for class 'phylo'
subset(x, taxonomy, rank="", ncores=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.phylo_+3A_x">x</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="subset.phylo_+3A_taxonomy">taxonomy</code></td>
<td>
<p>a ('matrix') linkage table between tips of the phylogeny and clades represented in the tree; rownames of 'taxonomy' should be tips found in the phylogeny</p>
</td></tr>
<tr><td><code id="subset.phylo_+3A_rank">rank</code></td>
<td>
<p>a column name in 'taxonomy' at which to resample the tree (see <b>Examples</b>)</p>
</td></tr>
<tr><td><code id="subset.phylo_+3A_ncores">ncores</code></td>
<td>
<p>max number of cores to use</p>
</td></tr>
<tr><td><code id="subset.phylo_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other functions (has no effect in the present context)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>JM Eastman</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sal &lt;- get(data(caudata))
print(head(sal$tax))

nphy &lt;- subset(sal$phy, sal$tax, "genus", ncores=1)
plot(nphy, type="fan", cex=0.15)

## End(Not run)
</code></pre>

<hr>
<h2 id='tips'>descendents of a given node in a phylogenetic tree</h2><span id='topic+tips'></span>

<h3>Description</h3>

<p>finding descendants of a node in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tips(phy, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tips_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="tips_+3A_node">node</code></td>
<td>
<p>numeric node-identifier (an integer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the set of tips subtended by the given <code>node</code>.
</p>


<h3>Author(s)</h3>

<p> LJ Harmon </p>


<h3>Examples</h3>

<pre><code class='language-R'>geo &lt;- get(data(geospiza))

tips(geo$phy, 18)
</code></pre>

<hr>
<h2 id='to.auteur'>
conversion of MCMC samples between auteur and coda</h2><span id='topic+to.auteur'></span><span id='topic+to.coda'></span>

<h3>Description</h3>

<p>converting MCMC samples between auteur and coda</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.auteur(obj, phy = NULL, ...)
to.coda(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to.auteur_+3A_obj">obj</code></td>
<td>
<p>for <code>to.auteur</code> &ndash; an object of class <code>codaMCMCMC</code>, <code>mcmc.list</code>, or an object exported to an <code>rda</code> file by <span class="pkg">auteur</span>;
for <code>to.coda</code> &ndash; an object of class <code>auteurMCMCMC</code> or a list of objects individually of class <code>auteurMCMC</code></p>
</td></tr>
<tr><td><code id="to.auteur_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo' against which to compile results; if NULL, the tree stored within the <code>rda</code> file is used</p>
</td></tr>
<tr><td><code id="to.auteur_+3A_...">...</code></td>
<td>
<p>arguments (<code>burnin</code> and <code>thin</code>) to be passed to <code><a href="#topic+load.rjmcmc">load.rjmcmc</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>coda</code> format of run(s) is recommended for diagnostic purposes; for summarization, <code>auteur</code> formats are advised. For single chains, the format adopted by both <span class="pkg">auteur</span> and <span class="pkg">coda</span> is identical (an object of class <code>mcmc</code>).  
For a series of combined runs, formats differ between the <span class="pkg">auteur</span> and <span class="pkg">coda</span> packages: <span class="pkg">auteur</span> requires an intercalated (single) matrix of values, whereas functions within <span class="pkg">coda</span> 
expect the values to be concatenated into a list (of class <code>mcmc.list</code>).  The function <code>to.coda</code> is used solely for pooling multiple runs into a format compatible with the <span class="pkg">coda</span> package.    
</p>


<h3>Value</h3>

<p>For <code>to.auteur</code>, an object of class <code>auteurMCMCMC</code> (given multiple runs) or <code>auteurMCMC</code> (given a single run) is returned; 
for <code>to.coda</code>, an object of class <code>codaMCMCMC</code> is returned.
</p>


<h3>Author(s)</h3>

<p>JM Eastman</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.rjmcmc">load.rjmcmc</a></code></p>

<hr>
<h2 id='treedata'> compare taxa in data and tree </h2><span id='topic+treedata'></span>

<h3>Description</h3>

<p>matching species found in a comparative dataset</p>


<h3>Usage</h3>

<pre><code class='language-R'>treedata(phy, data, sort=FALSE, warnings=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treedata_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class 'phylo'</p>
</td></tr>
<tr><td><code id="treedata_+3A_data">data</code></td>
<td>
<p>a named vector or matrix of continuous trait values, for species in <code>phy</code></p>
</td></tr>
<tr><td><code id="treedata_+3A_sort">sort</code></td>
<td>
<p>whether to sort the <code>data</code> based on names found in <code>phy</code></p>
</td></tr>
<tr><td><code id="treedata_+3A_warnings">warnings</code></td>
<td>
<p>whether to report warnings of mismatched taxa between <code>phy</code> and <code>data</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a general tool for checking for concordance between a data object and a phylogenetic
tree.  For the <code>data</code>, names can be specified as the names of objects in the vector or rownames of the data 
array. 
</p>


<h3>Value</h3>

<p>The function returns a list of two elements (<code>phy</code> and <code>data</code>) that are manipulated to include only those species 
found in both the tree and data supplied by the user.  
</p>


<h3>Author(s)</h3>

<p> LJ Harmon </p>


<h3>Examples</h3>

<pre><code class='language-R'>
geo &lt;- get(data(geospiza))

treedata(geo$phy, geo$dat, sort=TRUE, warnings=TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
