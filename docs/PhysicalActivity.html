<!DOCTYPE html><html><head><title>Help for package PhysicalActivity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PhysicalActivity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PhysicalActivity-package'><p>Process Accelerometer Data for Physical Activity Measurement</p></a></li>
<li><a href='#agdMetaKeys'><p>Define Metadata Vector</p></a></li>
<li><a href='#agdSettings'><p>Retrieve ActiGraph Settings</p></a></li>
<li><a href='#dataCollapser'><p>Collapse Accelerometer Data to a Dataset with a Longer Epoch</p></a></li>
<li><a href='#dataSec'><p>Accelerometer Data Example</p></a></li>
<li><a href='#deliveryData'><p>Data Example for Mail Delivery Day Classification</p></a></li>
<li><a href='#deliveryFeatures'><p>Delivery Features</p></a></li>
<li><a href='#deliveryPred'><p>Wrapper Function for Accelerometry data Preprocessing, Feature Extraction, and Delivery Prediction</p></a></li>
<li><a href='#deliveryPrediction'><p>Predict Delivery Days in Accelerometry Data</p></a></li>
<li><a href='#deliveryPreprocess'><p>Preprocess Accelerometry Data</p></a></li>
<li><a href='#deliveryThreshold'><p>Delivery Count Threshold</p></a></li>
<li><a href='#markDelivery'><p>Classify Mail Delivery and Non-Delivery Days for Accelerometer Data</p></a></li>
<li><a href='#marking'><p>Marking Data with Wearing Tags</p></a></li>
<li><a href='#markingTime'><p>Mark Days</p></a></li>
<li><a href='#markPAI'><p>Mark Physical Activity Intensity (PAI) Level</p></a></li>
<li><a href='#modeNames'><p>Retrieve ActiGraph Column Names</p></a></li>
<li><a href='#nthOccurance'><p>Internal Function</p></a></li>
<li><a href='#pa-internal'><p>Internal functions</p></a></li>
<li><a href='#plotData'><p>Plot Accelerometer Data over Time</p></a></li>
<li><a href='#queryActigraph'><p>Query ActiGraph File</p></a></li>
<li><a href='#readActigraph'><p>Read ActiGraph Accelerometer Data</p></a></li>
<li><a href='#readCountsData'><p>Convert Accelerometer Output Data to a Correct Data Format</p></a></li>
<li><a href='#summaryData'><p>Summarize Classified Wear Time by Daily Basis</p></a></li>
<li><a href='#sumVct'><p>Summarize Wear and Nonwear Time Interval</p></a></li>
<li><a href='#timeFromYear1'><p>Create Time From Seconds Since 0001-01-01</p></a></li>
<li><a href='#validWindow'><p>Define Days Within Window</p></a></li>
<li><a href='#wearingMarking'><p>Classify Wear and Nonwear Time for Accelerometer Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-12-29</td>
</tr>
<tr>
<td>Title:</td>
<td>Process Accelerometer Data for Physical Activity Measurement</td>
</tr>
<tr>
<td>Description:</td>
<td>It provides a function "wearingMarking" for classification of monitor
    wear and nonwear time intervals in accelerometer data collected to assess
    physical activity. The package also contains functions for making plot for 
    accelerometer data and obtaining the summary of various information including 
    daily monitor wear time and the mean monitor wear time during valid days.      
    "deliveryPred" and "markDelivery" can classify days for ActiGraph delivery by mail;
    "deliveryPreprocess" can process accelerometry data for analysis by zeropadding incomplete 
    days and removing low activity days; "markPAI" can categorize physical activity
    intensity level based on user-defined cut-points of accelerometer counts. It also
    supports importing ActiGraph AGD files with "readActigraph" and "queryActigraph" functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RSQLite, DBI, data.table, e1071, keras, randomForest,
reticulate, rms</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-22 17:38:24 UTC; leenachoi</td>
</tr>
<tr>
<td>Author:</td>
<td>Leena Choi <a href="https://orcid.org/0000-0002-2544-7090"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Cole Beck <a href="https://orcid.org/0000-0002-6849-6255"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Zhouwen Liu [aut],
  Ryan Moore [aut],
  Charles E. Matthews [aut],
  Maciej S. Buchowski [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leena Choi &lt;leena.choi@Vanderbilt.Edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-22 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PhysicalActivity-package'>Process Accelerometer Data for Physical Activity Measurement</h2><span id='topic+PhysicalActivity'></span><span id='topic+PhysicalActivity-package'></span>

<h3>Description</h3>

<p>It provides a function <code><a href="#topic+wearingMarking">wearingMarking</a></code> for classification of monitor
wear and nonwear time intervals in accelerometer data collected to assess
physical activity. The package also contains functions for making plot for
accelerometer data and obtaining the summary of various information including
daily monitor wear time and the mean monitor wear time during valid days.
</p>


<h3>Details</h3>

<p>The revised package version 0.2-2 improved the functions in the previous version
regarding speed and robustness. In addition, several functions were added: 
<code><a href="#topic+markDelivery">markDelivery</a></code> can classify days for ActiGraph delivery by mail; 
<code><a href="#topic+markPAI">markPAI</a></code> can categorize physical activity intensity level based on
user-defined cut-points of accelerometer counts. It also supports importing ActiGraph
AGD files with <code><a href="#topic+readActigraph">readActigraph</a></code> and <code><a href="#topic+queryActigraph">queryActigraph</a></code> functions.
The package also better supports time zones and daylight saving.
</p>
<p>Classify wear and nonwear time status for accelerometer data by
epoch-by-epoch basis by <code><a href="#topic+wearingMarking">wearingMarking</a></code>.
</p>
<p>Classify mail delivery and non-delivery day status for accelerometer data 
by <code><a href="#topic+markDelivery">markDelivery</a></code>.
</p>
<p>Three options are available for the package: <code>pa.validCut=600</code>,
<code>pa.timeStamp='TimeStamp'</code>, and <code>pa.cts='axis1'</code>. When these 
options are specified (as in <code><a href="#topic+markDelivery">markDelivery</a></code>), the other 
functions will automatically respect these values as defaults. For 
instance, the count variable in <code>data(dataSec)</code> is &quot;counts&quot;.
Running <code>options(pa.cts='counts')</code> allows the user to avoid specifying the 
&quot;cts&quot; argument in <code><a href="#topic+wearingMarking">wearingMarking</a></code>. The options for <code>validCut</code> and
<code>timeStamp</code> are rarely changed.
</p>
<p>Shiny app called <span class="pkg">Actigraph</span> can be used to visualize accelerometer data
and summarize the data.  Please see <a href="https://github.com/couthcommander/PhysicalActivityShiny">https://github.com/couthcommander/PhysicalActivityShiny</a>.
</p>


<h3>Author(s)</h3>

<p>Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>,
Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>,
Zhouwen Liu <a href="mailto:zhouwen.liu@vumc.org">zhouwen.liu@vumc.org</a>,
Charles E. Matthews <a href="mailto:Charles.Matthews2@nih.gov">Charles.Matthews2@nih.gov</a>, and
Maciej S. Buchowski <a href="mailto:maciej.buchowski@Vanderbilt.Edu">maciej.buchowski@Vanderbilt.Edu</a>
</p>
<p>Maintainer: Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>References</h3>

<p>Choi L, Liu Z, Matthews CE, Buchowski MS. 
Validation of accelerometer wear and nonwear time classification algorithm.
Med Sci Sports Exerc. 2011 Feb;43(2):357-64.
</p>
<p>Choi L, Ward SC, Schnelle JF, Buchowski MS. 
Assessment of wear/nonwear time classification algorithms for triaxial accelerometer.
Med Sci Sports Exerc. 2012 Oct;44(10):2009-16.
</p>
<p>Choi L, Chen KY, Acra SA, Buchowski MS. 
Distributed lag and spline modeling for predicting energy expenditure from 
accelerometry in youth. J Appl Physiol. 2010 Feb;108(2):314-27.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataSec)

mydata1m = dataCollapser(dataSec, TS = "TimeStamp", col = "counts", by = 60)
options(pa.cts = 'counts') # change cnt variable from "axis1" to "counts"
data1m = wearingMarking(dataset = mydata1m, frame = 90)

sumVct(data1m, id="sdata1m")

plotData(data=data1m)

summaryData(data=data1m, validCut=600, perMinuteCts=1, markingString = "w")
</code></pre>

<hr>
<h2 id='agdMetaKeys'>Define Metadata Vector</h2><span id='topic+agdMetaKeys'></span>

<h3>Description</h3>

<p>Define Metadata Vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agdMetaKeys()
</code></pre>

<hr>
<h2 id='agdSettings'>Retrieve ActiGraph Settings</h2><span id='topic+agdSettings'></span>

<h3>Description</h3>

<p>Query ActiGraph (agd) SQLite file for settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agdSettings(datfile)
</code></pre>

<hr>
<h2 id='dataCollapser'>Collapse Accelerometer Data to a Dataset with a Longer Epoch</h2><span id='topic+dataCollapser'></span>

<h3>Description</h3>

<p>The function collapses counts in data collected with a short epoch to make a 
data set with a longer epoch. For example, this function collapses data with
1-sec epoch to 10-sec epoch or 1-min epoch data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataCollapser(dataset, TS, by, col, func = sum, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataCollapser_+3A_dataset">dataset</code></td>
<td>
<p>The source dataset, in dataframe format, that needs to be
collapsed.</p>
</td></tr>
<tr><td><code id="dataCollapser_+3A_ts">TS</code></td>
<td>
<p>The column name for timestamp.</p>
</td></tr>
<tr><td><code id="dataCollapser_+3A_by">by</code></td>
<td>
<p>Epoch in seconds for a collapsed dataset. For example, to collapse
second data to minute data, set by = 60; to collapse 10-second data to minute
data, set by = 60.</p>
</td></tr>
<tr><td><code id="dataCollapser_+3A_col">col</code></td>
<td>
<p>The column name(s) to collapse.  If not provided, will default to
all numeric columns.</p>
</td></tr>
<tr><td><code id="dataCollapser_+3A_func">func</code></td>
<td>
<p>A method for collapsing counts. The default is the summation of
counts.</p>
</td></tr>
<tr><td><code id="dataCollapser_+3A_...">...</code></td>
<td>
<p>Argument settings that to be used by user-defined &quot;func&quot;
setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A collapsed data with user specified epoch.
</p>


<h3>Author(s)</h3>

<p>Zhouwen Liu <a href="mailto:zhouwen.liu@vumc.org">zhouwen.liu@vumc.org</a>
</p>


<h3>References</h3>

<p>Choi L, Liu Z, Matthews CE, Buchowski MS. 
Validation of accelerometer wear and nonwear time classification algorithm.
Med Sci Sports Exerc. 2011 Feb;43(2):357-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataSec)

## collapse 1-sec epoch data to 10-sec epoch data
mydata10s = dataCollapser(dataSec, TS = "TimeStamp", col = "counts", by = 10)

## collapse 1-sec epoch data to 1-min epoch data
mydata1m = dataCollapser(dataSec, TS = "TimeStamp", col = "counts", by = 60)
</code></pre>

<hr>
<h2 id='dataSec'>Accelerometer Data Example</h2><span id='topic+dataSec'></span>

<h3>Description</h3>

<p>Approximately 3 days of accelerometer data collected with 1-sec epoch in the
correct data format that can be used by <code>wearingMarking</code> to classify
wear and nonwear time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataSec)
</code></pre>


<h3>Format</h3>

<p>A data frame with 238140 observations on the following 2 required
variables.
</p>

<dl>
<dt>TimeStamp</dt><dd><p>A character vector, timestamp of accelerometer measurements</p>
</dd>
<dt>counts</dt><dd><p>A numeric vector, counts as accelerometer measurements</p>
</dd>
</dl>



<h3>References</h3>

<p>Choi L, Liu Z, Matthews CE, Buchowski MS. 
Validation of accelerometer wear and nonwear time classification algorithm.
Med Sci Sports Exerc. 2011 Feb;43(2):357-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataSec)
</code></pre>

<hr>
<h2 id='deliveryData'>Data Example for Mail Delivery Day Classification</h2><span id='topic+deliveryData'></span>

<h3>Description</h3>

<p>Approximately 15 days of 3-axis accelerometer data collected with 1-minute epoch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(deliveryData)
</code></pre>


<h3>Format</h3>

<p>A data frame with 20987 observations on the following variables.
</p>

<dl>
<dt>TimeStamp</dt><dd><p>A character vector, timestamp of accelerometer measurements</p>
</dd>
<dt>axis1</dt><dd><p>A numeric vector, counts from axis1 of 3-axis accelerometer</p>
</dd>
<dt>axis2</dt><dd><p>A numeric vector, counts from axis2 of 3-axis accelerometer</p>
</dd>
<dt>axis3</dt><dd><p>A numeric vector, counts from axis3 of 3-axis accelerometer</p>
</dd>
<dt>steps</dt><dd><p>A numeric vector, the number of steps</p>
</dd>
<dt>vm</dt><dd><p>A numeric vector, the vector magnitude calculated from counts of axis1, axis2 and axis3</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>,
Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deliveryData)
</code></pre>

<hr>
<h2 id='deliveryFeatures'>Delivery Features</h2><span id='topic+deliveryFeatures'></span>

<h3>Description</h3>

<p>The function extracts multiple statistical features relevant for classification of days as delivery or human wear. 
The extracted features are: mean, variance, maximum, absolute change, absolute energy, 
proportion of trial completed, 95th quantile, skewness, and kurtosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deliveryFeatures(df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deliveryFeatures_+3A_df">df</code></td>
<td>
<p>A dataframe. The source accelerometry dataset, in dataframe format.</p>
</td></tr>
<tr><td><code id="deliveryFeatures_+3A_...">...</code></td>
<td>
<p>not used at this time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function works for data consisting of one or multiple unique trials.
</p>


<h3>Value</h3>

<p>A dataframe is returned with a row for each unique day and a column for each feature.
</p>


<h3>Note</h3>

<p>The input dataframe should have the following columns: 
&lsquo;TimeStamp&rsquo;, &lsquo;axis1&rsquo;, &lsquo;axis2&rsquo;, &lsquo;axis3&rsquo;, &lsquo;vm&rsquo;,
where &lsquo;vm&rsquo; is the vector magnitude of axes 1, 2, and 3. 
Dataframe should also be formatted to 60 second epoch.
</p>


<h3>Author(s)</h3>

<p>Ryan Moore <a href="mailto:ryan.moore@vumc.org">ryan.moore@vumc.org</a>,
Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>, and
Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deliveryPred">deliveryPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deliveryData)

deliveryDataProcessed &lt;- deliveryPreprocess(df = deliveryData)
deliveryDataFeats &lt;- deliveryFeatures(df = deliveryDataProcessed)

</code></pre>

<hr>
<h2 id='deliveryPred'>Wrapper Function for Accelerometry data Preprocessing, Feature Extraction, and Delivery Prediction</h2><span id='topic+deliveryPred'></span>

<h3>Description</h3>

<p>The function is a wrapper function that performs preprocessing, feature extraction, and delivery day prediction 
of an accelerometry dataset. The prediction model can be selected from one of three models, 
a Random Forest, a logistic regression, and a convolutional neural network (default: Random Forest).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deliveryPred(df, model = c("RF", "NN", "GLM"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deliveryPred_+3A_df">df</code></td>
<td>
<p>A dataframe. The source accelerometry dataset, in dataframe format.</p>
</td></tr>
<tr><td><code id="deliveryPred_+3A_model">model</code></td>
<td>
<p>A character. Indicates which prediction model to use.
&lsquo;RF&rsquo; is a Random Forest. &lsquo;GLM&rsquo; is a logistic regression, and
&lsquo;NN&rsquo; is a convolutional neural network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function works for data consisting of one or multiple unique trials.
</p>


<h3>Value</h3>

<p>A dataframe is returned with a predicted probability of each day being a delivery activity day.
</p>


<h3>Note</h3>

<p>The input dataframe should have the following columns: 
&lsquo;TimeStamp&rsquo;, &lsquo;axis1&rsquo;, &lsquo;axis2&rsquo;, &lsquo;axis3&rsquo;, &lsquo;vm&rsquo;,
where &lsquo;vm&rsquo; is the vector magnitude of axes 1, 2, and 3. 
Dataframe should also be formatted to 60 second epoch. 
</p>
<p>The function uses the default preprocessing criteria used in the development of the predictive models.
</p>


<h3>Author(s)</h3>

<p>Ryan Moore <a href="mailto:ryan.moore@vumc.org">ryan.moore@vumc.org</a>,
Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>, and
Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deliveryPreprocess">deliveryPreprocess</a></code>, <code><a href="#topic+deliveryFeatures">deliveryFeatures</a></code>, <code><a href="#topic+deliveryPrediction">deliveryPrediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deliveryData)

predictions &lt;- deliveryPred(df = deliveryData, model = "GLM")

</code></pre>

<hr>
<h2 id='deliveryPrediction'>Predict Delivery Days in Accelerometry Data</h2><span id='topic+deliveryPrediction'></span>

<h3>Description</h3>

<p>The function predicts the probability of each day in an accelerometry dataset being 
caused from delivery activity instead of human activity. 
The prediction model can be selected from one of three models, 
a Random Forest, a logistic regression, and a convolutional neural network (default: Random Forest).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deliveryPrediction(df, feats, model = c("RF", "GLM", "NN"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deliveryPrediction_+3A_df">df</code></td>
<td>
<p>A dataframe. The source accelerometry dataset, in dataframe format.</p>
</td></tr>
<tr><td><code id="deliveryPrediction_+3A_feats">feats</code></td>
<td>
<p>A dataframe. Features output from the <code><a href="#topic+deliveryFeatures">deliveryFeatures</a></code> function.</p>
</td></tr>
<tr><td><code id="deliveryPrediction_+3A_model">model</code></td>
<td>
<p>A character. Indicates which prediction model to use.
&lsquo;RF&rsquo; is a Random Forest. &lsquo;GLM&rsquo; is a logistic regression, and
&lsquo;NN&rsquo; is a convolutional neural network.</p>
</td></tr>
<tr><td><code id="deliveryPrediction_+3A_...">...</code></td>
<td>
<p>not used at this time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function works for data consisting of one or multiple unique trials.
</p>


<h3>Value</h3>

<p>A dataframe is returned with a predicted probability of each day being a delivery activity day.
</p>


<h3>Note</h3>

<p>The input dataframe should have the following columns: 
&lsquo;TimeStamp&rsquo;, &lsquo;axis1&rsquo;, &lsquo;axis2&rsquo;, &lsquo;axis3&rsquo;, &lsquo;vm&rsquo;,
where &lsquo;vm&rsquo; is the vector magnitude of axes 1, 2, and 3. 
Dataframe should also be formatted to 60 second epoch.
</p>


<h3>Author(s)</h3>

<p>Ryan Moore <a href="mailto:ryan.moore@vumc.org">ryan.moore@vumc.org</a>,
Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>, and
Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deliveryFeatures">deliveryFeatures</a></code>, <code><a href="#topic+deliveryPred">deliveryPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deliveryData)

deliveryDataProcessed &lt;- deliveryPreprocess(df = deliveryData)
deliveryDataFeats &lt;- deliveryFeatures(df = deliveryDataProcessed)
deliveryPrediction(deliveryDataProcessed, deliveryDataFeats)

</code></pre>

<hr>
<h2 id='deliveryPreprocess'>Preprocess Accelerometry Data</h2><span id='topic+deliveryPreprocess'></span>

<h3>Description</h3>

<p>This function preprocesses accelerometry data by removing days based on a total
activity count (default: less than 5000) or total time with activity (default: less than 10 minutes). 
Additionally, the function has an option to zeropad truncated days such that that days that do not 
have a whole day of 1440 minutes of data spanning from 00:00 to 23:59 (default: TRUE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deliveryPreprocess(df, minLow = 5000, minTime = 10, zeropad = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deliveryPreprocess_+3A_df">df</code></td>
<td>
<p>A dataframe. The source accelerometry dataset, in dataframe format.</p>
</td></tr>
<tr><td><code id="deliveryPreprocess_+3A_minlow">minLow</code></td>
<td>
<p>Numeric. The minimum total counts of movement for a day to not be removed.</p>
</td></tr>
<tr><td><code id="deliveryPreprocess_+3A_mintime">minTime</code></td>
<td>
<p>Numeric. The minimum number of minutes of activity for a day to not be removed.</p>
</td></tr>
<tr><td><code id="deliveryPreprocess_+3A_zeropad">zeropad</code></td>
<td>
<p>Boolean value for truncated days to be zeropadded.</p>
</td></tr>
<tr><td><code id="deliveryPreprocess_+3A_...">...</code></td>
<td>
<p>not used at this time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function works for dataframes from one or multiple unique trials.
</p>


<h3>Value</h3>

<p>The dataframe is returned with days fulfilling the dropping criteria removed and truncated days zeropadded. 
A new column indicating which day is added to the dataframe.
</p>


<h3>Note</h3>

<p>The input dataframe should have the following columns: 
&lsquo;TimeStamp&rsquo;, &lsquo;axis1&rsquo;, &lsquo;axis2&rsquo;, &lsquo;axis3&rsquo;, &lsquo;vm&rsquo;,
where &lsquo;vm&rsquo; is the vector magnitude of axes 1, 2, and 3. 
Dataframe should also be formatted to 60 second epoch.
</p>


<h3>Author(s)</h3>

<p>Ryan Moore <a href="mailto:ryan.moore@vumc.org">ryan.moore@vumc.org</a>,
Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>, and
Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deliveryPred">deliveryPred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deliveryData)

deliveryDataProcessed &lt;- deliveryPreprocess(df = deliveryData)

</code></pre>

<hr>
<h2 id='deliveryThreshold'>Delivery Count Threshold</h2><span id='topic+deliveryThreshold'></span>

<h3>Description</h3>

<p>Delivery Count Threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deliveryThreshold(
  data,
  daylist,
  cts = getOption("pa.cts"),
  dist = c("t", "normal"),
  stat = c("mean", "sd", "95")
)
</code></pre>

<hr>
<h2 id='markDelivery'>Classify Mail Delivery and Non-Delivery Days for Accelerometer Data</h2><span id='topic+markDelivery'></span>

<h3>Description</h3>

<p>This function adds an indicator variable for accelerometer delivery days based
on a delivery classification algorithm. The algorithm classifies each day as 
delivery or non-delivery day within each participant data using summary 
statistics of accelerometer counts for each day. As the summary statistics,
the 95th percentile, mean and standard deviation (sd) of accelerometer counts
can be used. Using the summary statistics for each day, the algorithm defines
a set of days that are used to estimate the 95% confidence interval (CI)
based on t-distribution (default) or normal distribution. The lower bound of
the 95%  CI is used to classify delivery days; if the summary statistics 
for a day is below the lower bound of the 95% CI, this day is classified 
as delivery day. Three methods for defining a set of days are available: 
<code>trim</code> (default), <code>consecutive</code>, and <code>valid</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markDelivery(
  data,
  cts = getOption("pa.cts"),
  markingString = "w",
  window = c("trim", "consecutive", "valid"),
  method = c("95", "mean", "sd"),
  validCut = getOption("pa.validCut"),
  wearThreshold = 300,
  dist = c("t", "normal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markDelivery_+3A_data">data</code></td>
<td>
<p>Data with classified wear (nonwear) status by
<code><a href="#topic+wearingMarking">wearingMarking</a></code>.</p>
</td></tr>
<tr><td><code id="markDelivery_+3A_cts">cts</code></td>
<td>
<p>The name of the counts column. The default is &ldquo;axis1&rdquo;.</p>
</td></tr>
<tr><td><code id="markDelivery_+3A_markingstring">markingString</code></td>
<td>
<p>Option for summarizing wear (markingString = &ldquo;w&rdquo;) or
nonwear time (markingString = &ldquo;nw&rdquo;).</p>
</td></tr>
<tr><td><code id="markDelivery_+3A_window">window</code></td>
<td>
<p>A character. It should be one of &lsquo;trim&rsquo;, &lsquo;consecutive&rsquo;, 
or &lsquo;valid&rsquo;.</p>
</td></tr>
<tr><td><code id="markDelivery_+3A_method">method</code></td>
<td>
<p>A character. It should be one of &lsquo;95&rsquo;, &lsquo;mean&rsquo; or &lsquo;sd&rsquo;.</p>
</td></tr>
<tr><td><code id="markDelivery_+3A_validcut">validCut</code></td>
<td>
<p>A cutoff for the total minutes of classified monitor wear
time per day to be considered as a valid monitor day.</p>
</td></tr>
<tr><td><code id="markDelivery_+3A_wearthreshold">wearThreshold</code></td>
<td>
<p>A numeric value specifying a pseudo-valid day cutoff
similar to &ldquo;validCut&rdquo;, which is used to define a set of days to estimate
the 95% CI.</p>
</td></tr>
<tr><td><code id="markDelivery_+3A_dist">dist</code></td>
<td>
<p>Option for distribution used to calculate the 95% CI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with summary information about daily counts.
</p>


<h3>Author(s)</h3>

<p>Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>,
Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deliveryData)

options(pa.cts = "vm")
wm &lt;- wearingMarking(dataset = deliveryData)

markDelivery(wm)
plotData(data=wm) # days 1, 2, 10 - 15 are delivery or invalid days based on the result above
markDelivery(wm, window='valid', method='mean')
markDelivery(wm, method='mean')
markDelivery(wm, method='sd')
</code></pre>

<hr>
<h2 id='marking'>Marking Data with Wearing Tags</h2><span id='topic+marking'></span>

<h3>Description</h3>

<p>This function marks the dataset with wearing/non-wearing tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marking(
  dataset,
  frame,
  cts = getOption("pa.cts"),
  streamFrame = NULL,
  allowanceFrame = 2,
  newcolname = "wearing"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marking_+3A_dataset">dataset</code></td>
<td>
<p>The source dataset, in dataframe format, which needs to be
marked.</p>
</td></tr>
<tr><td><code id="marking_+3A_frame">frame</code></td>
<td>
<p>The size of time interval to be considered.</p>
</td></tr>
<tr><td><code id="marking_+3A_cts">cts</code></td>
<td>
<p>The name of the counts column. The default is &quot;axis1&quot;.</p>
</td></tr>
<tr><td><code id="marking_+3A_streamframe">streamFrame</code></td>
<td>
<p>The size of time interval that the program will look back
or forward if activity is detected. The default is the half of frame.</p>
</td></tr>
<tr><td><code id="marking_+3A_allowanceframe">allowanceFrame</code></td>
<td>
<p>The size of time interval that zero counts allowed.
The default is 2.</p>
</td></tr>
<tr><td><code id="marking_+3A_newcolname">newcolname</code></td>
<td>
<p>The wearing marking column name.  The default is &quot;wearing&quot;.
After the data is processed, a new field will be added to the original
dataframe.  This new field is the wearing /nowwearing indicator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with an extra wearing/non-wearing marking column.
</p>


<h3>Author(s)</h3>

<p>Zhouwen Liu <a href="mailto:zhouwen.liu@vumc.org">zhouwen.liu@vumc.org</a>
</p>


<h3>References</h3>

<p>Choi L, Liu Z, Matthews CE, Buchowski MS. 
Validation of accelerometer wear and nonwear time classification algorithm.
Med Sci Sports Exerc. 2011 Feb;43(2):357-64.
</p>

<hr>
<h2 id='markingTime'>Mark Days</h2><span id='topic+markingTime'></span>

<h3>Description</h3>

<p>This function adds a &quot;day&quot; variable to the source dataset. The day is marked
in numeric order, according to the timestamp variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markingTime(dataset, timestamp, startTime = "00:00:00", tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markingTime_+3A_dataset">dataset</code></td>
<td>
<p>The source dataset, in dataframe format, which needs to be
marked.</p>
</td></tr>
<tr><td><code id="markingTime_+3A_timestamp">timestamp</code></td>
<td>
<p>The column name in the dataset that will be used as
timestamp.</p>
</td></tr>
<tr><td><code id="markingTime_+3A_starttime">startTime</code></td>
<td>
<p>Define the starting time of a day.  It must be in the format
of &quot;hh:mm:ss&quot;.</p>
</td></tr>
<tr><td><code id="markingTime_+3A_tz">tz</code></td>
<td>
<p>Local time zone, defaults to UTC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with an extra day marking column.
</p>


<h3>Author(s)</h3>

<p>Zhouwen Liu <a href="mailto:zhouwen.liu@vumc.org">zhouwen.liu@vumc.org</a>
</p>


<h3>References</h3>

<p>Choi L, Liu Z, Matthews CE, Buchowski MS. 
Validation of accelerometer wear and nonwear time classification algorithm.
Med Sci Sports Exerc. 2011 Feb;43(2):357-64.
</p>

<hr>
<h2 id='markPAI'>Mark Physical Activity Intensity (PAI) Level</h2><span id='topic+markPAI'></span>

<h3>Description</h3>

<p>This function adds a physical activity intensity level variable &ldquo;pai&rdquo; to the
source dataset. The &ldquo;pai&rdquo; is an ordered factor variable. It will be NA for
nonwear times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markPAI(
  data,
  cts = getOption("pa.cts"),
  markingString = "w",
  breaks = c(-Inf, 100, 760, 2020, Inf),
  labels = c("sedentary", "light", "moderate", "vigorous")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markPAI_+3A_data">data</code></td>
<td>
<p>Data with classified wear (nonwear) status by
<code><a href="#topic+wearingMarking">wearingMarking</a></code>.</p>
</td></tr>
<tr><td><code id="markPAI_+3A_cts">cts</code></td>
<td>
<p>The name of the counts column. The default is &ldquo;axis1&rdquo;.</p>
</td></tr>
<tr><td><code id="markPAI_+3A_markingstring">markingString</code></td>
<td>
<p>Option for summarizing wear (markingString = &ldquo;w&rdquo;) or
nonwear time (markingString = &ldquo;nw&rdquo;).</p>
</td></tr>
<tr><td><code id="markPAI_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector of cut-points. The default cut-points are based on
Matthews <em>et al.</em> (2016).</p>
</td></tr>
<tr><td><code id="markPAI_+3A_labels">labels</code></td>
<td>
<p>A character vector labelling intensity levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with an additional PAI-level column.
</p>


<h3>Author(s)</h3>

<p>Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>,
Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>References</h3>

<p>Matthews CE, Keadle SK, Troiano RP, Kahle L, Koster A, Brychta R, 
Van Domelen D, Caserotti P, Chen KY, Harris TB, Berrigan D. 
Accelerometer-measured dose-response for physical activity, sedentary time, and mortality in US adults.
Am J Clin Nutr. 2016 Nov;104(5):1424-1432.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataSec)

mydata1m = dataCollapser(dataSec, TS = "TimeStamp", col = "counts", by = 60)

data1m = wearingMarking(dataset = mydata1m,
                       perMinuteCts = 1,
                       cts = "counts")

markPAI(data = data1m, cts = 'counts')[1:10,]
</code></pre>

<hr>
<h2 id='modeNames'>Retrieve ActiGraph Column Names</h2><span id='topic+modeNames'></span>

<h3>Description</h3>

<p>Column names should match the mode number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeNames(mode)
</code></pre>


<h3>Details</h3>

<p>https://actigraph.desk.com/customer/en/portal/articles/
2515800-what-do-the-different-mode-numbers-mean-in-a-csv-or-dat-file-
</p>

<hr>
<h2 id='nthOccurance'>Internal Function</h2><span id='topic+nthOccurance'></span>

<h3>Description</h3>

<p>This is an internal function, not for users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nthOccurance(dataVct, value, nth = NA, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nthOccurance_+3A_datavct">dataVct</code></td>
<td>
<p>DataVct</p>
</td></tr>
<tr><td><code id="nthOccurance_+3A_value">value</code></td>
<td>
<p>Value</p>
</td></tr>
<tr><td><code id="nthOccurance_+3A_nth">nth</code></td>
<td>
<p>Nth</p>
</td></tr>
<tr><td><code id="nthOccurance_+3A_reverse">reverse</code></td>
<td>
<p>Reverse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>loc
</p>


<h3>Author(s)</h3>

<p>Zhouwen Liu <a href="mailto:zhouwen.liu@vumc.org">zhouwen.liu@vumc.org</a>
</p>

<hr>
<h2 id='pa-internal'>Internal functions</h2><span id='topic+pa-internal'></span><span id='topic+l2df'></span><span id='topic+convertTZ'></span><span id='topic+createTime'></span><span id='topic+addDayIndex'></span>

<h3>Description</h3>

<p>codel2df: convert list to data.frame
</p>


<h3>Details</h3>

<p>codeconvertTZ: force a new timezone on datetime
</p>
<p>codecreateTime: create datetime variable
</p>
<p>codeaddDayIndex: create ID_day variable from timestamp
</p>

<hr>
<h2 id='plotData'>Plot Accelerometer Data over Time</h2><span id='topic+plotData'></span>

<h3>Description</h3>

<p>This function makes plot for accelerometer collected data (counts) over time
for the whole monitor period, or a user specified time period or day with a
midnight marking to separate monitored days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotData(
  data,
  day = NULL,
  start = NULL,
  end = NULL,
  cts = getOption("pa.cts"),
  TS = getOption("pa.timeStamp"),
  summary = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotData_+3A_data">data</code></td>
<td>
<p>Data with classified wear and nonwear status from
<code><a href="#topic+wearingMarking">wearingMarking</a></code>.</p>
</td></tr>
<tr><td><code id="plotData_+3A_day">day</code></td>
<td>
<p>A part of data during a user specified day for plot.</p>
</td></tr>
<tr><td><code id="plotData_+3A_start">start</code></td>
<td>
<p>Define a starting time for plot.</p>
</td></tr>
<tr><td><code id="plotData_+3A_end">end</code></td>
<td>
<p>Define a ending time for plot.</p>
</td></tr>
<tr><td><code id="plotData_+3A_cts">cts</code></td>
<td>
<p>The name of the counts column. The default is &quot;axis1&quot;.</p>
</td></tr>
<tr><td><code id="plotData_+3A_ts">TS</code></td>
<td>
<p>The column name for timestamp. The default is &quot;TimeStamp&quot;.</p>
</td></tr>
<tr><td><code id="plotData_+3A_summary">summary</code></td>
<td>
<p>List output of <code><a href="#topic+summaryData">summaryData</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a local time-zone is specified for <code>wearkingMarking</code>, it is possible
that daylight savings starts or ends during the period shown.  In this case
a dotted line will indicate its position and the appropriate time-zone
abbreviations will be included.
</p>


<h3>Value</h3>

<p>Plot with midnight marking.
</p>


<h3>Author(s)</h3>

<p>Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wearingMarking">wearingMarking</a></code>, <code><a href="#topic+sumVct">sumVct</a></code>, <code><a href="#topic+summaryData">summaryData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataSec)

mydata1m = dataCollapser(dataSec, TS = "TimeStamp", col = "counts", by = 60)

data1m = wearingMarking(dataset = mydata1m,
                       frame = 90, 
                       perMinuteCts = 1,
                       TS = "TimeStamp",
                       cts = "counts", 
                       streamFrame = NULL, 
                       allowanceFrame= 2, 
                       newcolname = "wearing")

## change "cts" default from "axis1" to "counts"
options(pa.cts = "counts")
## plot the whole data
plotData(data=data1m)

## plot the data from 60 min to 900 min
plotData(data=data1m, start=60, end=900)

## plot the data for day 2
plotData(data=data1m, day=2)

## include summaryData
sumdat &lt;- summaryData(data=data1m)
plotData(data=data1m, summary=sumdat)

## present daylight saving time change
data(deliveryData)
options(pa.cts = "vm")
wm &lt;- wearingMarking(dataset = deliveryData, TS="TimeStamp", tz="America/Chicago")
sumdat &lt;- summaryData(wm)
plotData(data=wm, summary = sumdat)
## valid data after delivery marking
del &lt;- markDelivery(wm)
sumdat &lt;- summaryData(wm, delivery = del)
plotData(data=wm, summary = sumdat)
</code></pre>

<hr>
<h2 id='queryActigraph'>Query ActiGraph File</h2><span id='topic+queryActigraph'></span>

<h3>Description</h3>

<p>This function executes a SELECT query on an ActiGraph AGD file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queryActigraph(datfile, qry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queryActigraph_+3A_datfile">datfile</code></td>
<td>
<p>An AGD file.</p>
</td></tr>
<tr><td><code id="queryActigraph_+3A_qry">qry</code></td>
<td>
<p>An SQL SELECT statement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AGD files are actually SQLite databases.  This function requires the
<span class="pkg">RSQLite</span> package.  The user is encouraged to directly interface with
the database by creating a connection with the <span class="pkg">DBI</span> package.  This has
been tested with AGD files produced with ActiLife v6.11.
</p>


<h3>Value</h3>

<p>A data frame with query results.
</p>


<h3>Author(s)</h3>

<p>Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readActigraph">readActigraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- queryActigraph("actfile.agd", "SELECT * FROM data LIMIT 5")

queryActigraph("actfile.agd", "SELECT * FROM settings")

## directly interface using DBI package
con &lt;- DBI::dbConnect(RSQLite::SQLite(), "actfile.agd")
DBI::dbListTables(con)
DBI::dbDisconnect(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='readActigraph'>Read ActiGraph Accelerometer Data</h2><span id='topic+readActigraph'></span>

<h3>Description</h3>

<p>This function reads an ActiGraph AGD file into R as a data frame.
If accelerometer data are collected with three axes, it creates vector magnitude
(vm). The counts at any axis or &quot;vm&quot; can be used to classify with wear and 
nonwear time using <code><a href="#topic+wearingMarking">wearingMarking</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readActigraph(datfile, convertTime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readActigraph_+3A_datfile">datfile</code></td>
<td>
<p>An AGD file.</p>
</td></tr>
<tr><td><code id="readActigraph_+3A_converttime">convertTime</code></td>
<td>
<p>Convert the timestamp from a character string into
POSIXct.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AGD files are SQLite databases. This function requires the <span class="pkg">RSQLite</span>
package.
</p>


<h3>Value</h3>

<p>A data frame with accelerometer data.
</p>


<h3>Author(s)</h3>

<p>Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wearingMarking">wearingMarking</a></code>, <code><a href="#topic+queryActigraph">queryActigraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- readActigraph("actfile.agd")
dat1s &lt;- wearingMarking(dataset = dat,
                       frame = 90,
                       perMinuteCts = 1,
                       TS = "TimeStamp",
                       cts = "axis1",
                       streamFrame = NULL,
                       allowanceFrame= 2,
                       newcolname = "wearing",
                       getMinuteMarking = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='readCountsData'>Convert Accelerometer Output Data to a Correct Data Format</h2><span id='topic+readCountsData'></span>

<h3>Description</h3>

<p>This function converts accelerometer output data to a correct data format to
classify wear and nonwear time using <code><a href="#topic+wearingMarking">wearingMarking</a></code>. This
function can accept accelerometer output data with various epochs (for
example, 1-sec, 10-sec or 1-min). If accelerometer data are collected with 
three axes, it creates vector magnitude (vm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCountsData(filename, ctPerSec, mode = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readCountsData_+3A_filename">filename</code></td>
<td>
<p>A filename of accelerometer output to be read.</p>
</td></tr>
<tr><td><code id="readCountsData_+3A_ctpersec">ctPerSec</code></td>
<td>
<p>Data collection epoch. This argument tells the program the
number of counting will be performed in every second. For examples: for 1-sec
epoch data, set ctPerSec = 1; for 10-sec epoch data, set ctPerSec = 1/10; for
1-min epoch data, set ctPerSec = 1/60.</p>
</td></tr>
<tr><td><code id="readCountsData_+3A_mode">mode</code></td>
<td>
<p>The mode of the ActiLife dat file.  Defaults to 0, and should be
listed in the file header.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the correct format (TimeStamp, counts) to be used for
<code><a href="#topic+wearingMarking">wearingMarking</a></code>.
</p>


<h3>Note</h3>

<p>Warning: It can be very slow if accelerometer data were collected with
1-sec epoch for many days.
</p>


<h3>Author(s)</h3>

<p>Zhouwen Liu <a href="mailto:zhouwen.liu@vumc.org">zhouwen.liu@vumc.org</a>
</p>


<h3>References</h3>

<p>Choi L, Liu Z, Matthews CE, Buchowski MS. 
Validation of accelerometer wear and nonwear time classification algorithm.
Med Sci Sports Exerc. 2011 Feb;43(2):357-64.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wearingMarking">wearingMarking</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############################################################################
## Read accelerometer output and convert to a correct format (TimeStamp, counts)
## Suppose "rawActigraphOutput.dat" is an Actigraph output with header as follows:
###############################################################################
## --- Data File Created By ActiGraph GT1M ActiLife v4.4.1 Firmware v7.2.0 ---
## Serial Number: LYN2B21080027
## Start Time 16:15:00
## Start Date 6/16/2010
## Epoch Period (hh:mm:ss) 00:00:01
## Download Time 09:50:23
## Download Date 6/22/2010
## Current Memory Address: 983038
## Current Battery Voltage: 4.01     Mode = 0
## --------------------------------------------------
###############################################################################
## This raw data with 1-sec epoch can be converted to a correct data format to
## classify wear and nonwear time using "wearingMarking" by the following code:

## Not run: mydata1s = readCountsData("rawActigraphOutput.dat", ctPerSec=1)
</code></pre>

<hr>
<h2 id='summaryData'>Summarize Classified Wear Time by Daily Basis</h2><span id='topic+summaryData'></span>

<h3>Description</h3>

<p>This function summarizes accelerometer data and the classified wear or nonwear
time by daily basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryData(
  data,
  validCut = getOption("pa.validCut"),
  perMinuteCts = 1,
  markingString = "w",
  TS = getOption("pa.timeStamp"),
  cts = getOption("pa.cts"),
  delivery = NULL,
  deliveryCut = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryData_+3A_data">data</code></td>
<td>
<p>Data with classified wear (nonwear) status by
<code><a href="#topic+wearingMarking">wearingMarking</a></code>.</p>
</td></tr>
<tr><td><code id="summaryData_+3A_validcut">validCut</code></td>
<td>
<p>A cutoff for the total minutes of classified monitor wear
time per day to be considered as a valid monitor day.</p>
</td></tr>
<tr><td><code id="summaryData_+3A_perminutects">perMinuteCts</code></td>
<td>
<p>The number of data rows per minute. The default is 1-min
epoch (perMinuteCts = 1) and we recommend to use 1-min epoch data for this
summary. For examples: for data with 10-sec epoch, set perMinuteCts = 6; for
data with 1-sec epoch, set perMinuteCts = 60.</p>
</td></tr>
<tr><td><code id="summaryData_+3A_markingstring">markingString</code></td>
<td>
<p>Option for summarizing wear (markingString = &ldquo;w&rdquo;) or
nonwear time (markingString = &ldquo;nw&rdquo;).</p>
</td></tr>
<tr><td><code id="summaryData_+3A_ts">TS</code></td>
<td>
<p>The column name for timestamp. The default is &ldquo;TimeStamp&rdquo;.</p>
</td></tr>
<tr><td><code id="summaryData_+3A_cts">cts</code></td>
<td>
<p>The name of the counts column. The default is &ldquo;axis1&rdquo;.</p>
</td></tr>
<tr><td><code id="summaryData_+3A_delivery">delivery</code></td>
<td>
<p>data.frame. Delivery information created by
<code><a href="#topic+markDelivery">markDelivery</a></code> or <code><a href="#topic+deliveryPrediction">deliveryPrediction</a></code>.</p>
</td></tr>
<tr><td><code id="summaryData_+3A_deliverycut">deliveryCut</code></td>
<td>
<p>A cutoff (probability) to consider a valid delivery date.
See the <code><a href="#topic+deliveryPrediction">deliveryPrediction</a></code> function. The default value is 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function summarizes the total number of days, weekdays and weekend days 
in accelerometer data. It provides the total number of valid days,
valid weekdays and valid weekend days based on a user defined cutoff
for the total minutes of classified monitor wear time per day. This function
also summarizes the classified wear (nonwear) time by day and by valid day,
and the mean wear (nonwear) time for valid days during weekday and weekends,
and for overall valid days. If mail delivery days are classified by 
<code><a href="#topic+markDelivery">markDelivery</a></code>, it also summarizes the classified delivery
(non-delivery) days with argument &ldquo;delivery&rdquo;.
If &ldquo;pai&rdquo; column is present in the data, 
which can be created by <code><a href="#topic+markPAI">markPAI</a></code>, then physical activity intensity
(PAI) level will be summarized in the output.
</p>


<h3>Value</h3>

<table>
<tr><td><code>unit</code></td>
<td>
<p>epoch for data.</p>
</td></tr>
<tr><td><code>totalNumDays</code></td>
<td>
<p>the total number of days in accelerometer data.</p>
</td></tr>
<tr><td><code>totalNumWeekWeekend</code></td>
<td>
<p>the total number of weekdays and weekend days in
accelerometer data.</p>
</td></tr>
<tr><td><code>validCut</code></td>
<td>
<p>a user defined cutoff for the total minutes of classified
monitor wear time per day to be considered as a valid monitor day.</p>
</td></tr>
<tr><td><code>totalValidNumDays</code></td>
<td>
<p>the total number of valid days based on the user defined 
cutoff (&ldquo;validCut&rdquo;) for the total minutes of wear time and the classified wear time.</p>
</td></tr>
<tr><td><code>totalValidNumWeekWeekend</code></td>
<td>
<p>the total number of valid weekdays and valid
weekend days based on the user defined cutoff (&ldquo;validCut&rdquo;) for the total minutes of
classified monitor wear time per day.</p>
</td></tr>
<tr><td><code>wearTimeByDay</code></td>
<td>
<p>the classified total wear (nonwear) time by day.</p>
</td></tr>
<tr><td><code>deliveryDays</code></td>
<td>
<p>marked delivery days.</p>
</td></tr>
<tr><td><code>validWearTimeByDay</code></td>
<td>
<p>the classified total wear (nonwear) time by valid
day.</p>
</td></tr>
<tr><td><code>meanWeartimeValidDays</code></td>
<td>
<p>the mean wear (nonwear) time for valid days
during weekdays and weekends.</p>
</td></tr>
<tr><td><code>meanWeartimeOverallValidDays</code></td>
<td>
<p>the mean wear (nonwear) time for overall
valid days.</p>
</td></tr>
<tr><td><code>dayInfo</code></td>
<td>
<p>information about wear time and mean counts for each day.</p>
</td></tr>
<tr><td><code>intensity</code></td>
<td>
<p>optional output depending on &ldquo;pai&rdquo; column in the data; 
the total time in hours of physical activity intensity by day.</p>
</td></tr>
<tr><td><code>meanValidIntensity</code></td>
<td>
<p>optional output depending on &ldquo;pai&rdquo; column in the data; 
the mean physical activity intensity (PAI) level for valid days.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>,
Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>
</p>


<h3>References</h3>

<p>Choi L, Liu Z, Matthews CE, Buchowski MS. 
Validation of accelerometer wear and nonwear time classification algorithm.
Med Sci Sports Exerc. 2011 Feb;43(2):357-64.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wearingMarking">wearingMarking</a></code>, <code><a href="#topic+sumVct">sumVct</a></code>,
<code><a href="#topic+markPAI">markPAI</a></code>, <code><a href="#topic+markDelivery">markDelivery</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataSec)

mydata1m = dataCollapser(dataSec, TS = "TimeStamp", col = "counts", by = 60)

data1m = wearingMarking(dataset = mydata1m,
                       frame = 90, 
                       perMinuteCts = 1,
                       TS = "TimeStamp",
                       cts = "counts", 
                       streamFrame = NULL, 
                       allowanceFrame= 2, 
                       newcolname = "wearing")

summaryData(data=data1m, validCut=600, perMinuteCts=1, markingString = "w", cts = "counts")

data(deliveryData)
options(pa.cts = "vm")
wm &lt;- wearingMarking(dataset = deliveryData)
dd &lt;- markDelivery(wm)
pdd &lt;- deliveryPred(wm)
summaryData(wm, delivery = dd)
summaryData(wm, delivery = pdd)

pai.data &lt;- markPAI(data = wm)
dd &lt;- markDelivery(pai.data)
summaryData(pai.data, delivery = dd)

</code></pre>

<hr>
<h2 id='sumVct'>Summarize Wear and Nonwear Time Interval</h2><span id='topic+sumVct'></span>

<h3>Description</h3>

<p>This function summarizes the classified wear (nonwear) time by interval basis
from the epoch-by-epoch classified wear (nonwear) status classified by
<code><a href="#topic+wearingMarking">wearingMarking</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumVct(
  datavct,
  wearing = "wearing",
  TS = getOption("pa.timeStamp"),
  markingString = "w",
  by = "days",
  id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumVct_+3A_datavct">datavct</code></td>
<td>
<p>Data with classified wear (nonwear) status classified by
<code><a href="#topic+wearingMarking">wearingMarking</a></code>.</p>
</td></tr>
<tr><td><code id="sumVct_+3A_wearing">wearing</code></td>
<td>
<p>The column name for classified wear and nonwear status. The
default is &quot;wearing&quot;.</p>
</td></tr>
<tr><td><code id="sumVct_+3A_ts">TS</code></td>
<td>
<p>The column name for timestamp. The default is &quot;TimeStamp&quot;.</p>
</td></tr>
<tr><td><code id="sumVct_+3A_markingstring">markingString</code></td>
<td>
<p>Option for summarizing wear (markingString=&quot;w&quot;) or
nonwear time interval (markingString=&quot;nw&quot;).</p>
</td></tr>
<tr><td><code id="sumVct_+3A_by">by</code></td>
<td>
<p>A sequence of days for classified wear (nonwear) time intervals.</p>
</td></tr>
<tr><td><code id="sumVct_+3A_id">id</code></td>
<td>
<p>Optional output for subject identification or file name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary data for wear and nonwear time intervals.
</p>


<h3>Author(s)</h3>

<p>Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>,
Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>,
Zhouwen Liu <a href="mailto:zhouwen.liu@vumc.org">zhouwen.liu@vumc.org</a>,
Charles E. Matthews <a href="mailto:Charles.Matthews2@nih.gov">Charles.Matthews2@nih.gov</a>, and
Maciej S. Buchowski <a href="mailto:maciej.buchowski@Vanderbilt.Edu">maciej.buchowski@Vanderbilt.Edu</a>
</p>


<h3>References</h3>

<p>Choi L, Liu Z, Matthews CE, Buchowski MS. 
Validation of accelerometer wear and nonwear time classification algorithm.
Med Sci Sports Exerc. 2011 Feb;43(2):357-64.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wearingMarking">wearingMarking</a></code>, <code><a href="#topic+summaryData">summaryData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dataSec)

mydata1m = dataCollapser(dataSec, TS = "TimeStamp", col = "counts", by = 60)

data1m = wearingMarking(dataset = mydata1m,
                       frame = 90, 
                       perMinuteCts = 1,
                       TS = "TimeStamp",
                       cts = "counts", 
                       streamFrame = NULL, 
                       allowanceFrame= 2, 
                       newcolname = "wearing")

sumVct(data1m, id="sdata1m")
sumVct(data1m, id="sdata1m", markingString = "nw")
</code></pre>

<hr>
<h2 id='timeFromYear1'>Create Time From Seconds Since 0001-01-01</h2><span id='topic+timeFromYear1'></span>

<h3>Description</h3>

<p>There are 62,135,596,800 seconds from 0001-01-01 until 1970-01-01.
The last 1e7 digits of x are unnecessary microseconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeFromYear1(x, base = 62135596800, tz = "UTC")
</code></pre>

<hr>
<h2 id='validWindow'>Define Days Within Window</h2><span id='topic+validWindow'></span>

<h3>Description</h3>

<p>Define Days Within Window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validWindow(wearTime, cnt, trim = TRUE)
</code></pre>

<hr>
<h2 id='wearingMarking'>Classify Wear and Nonwear Time for Accelerometer Data</h2><span id='topic+wearingMarking'></span>

<h3>Description</h3>

<p>This function classifies wear and nonwear time status for accelerometer
data by epoch-by-epoch basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wearingMarking(
  dataset,
  frame = 90,
  perMinuteCts = 60,
  TS = getOption("pa.timeStamp"),
  cts = getOption("pa.cts"),
  streamFrame = NULL,
  allowanceFrame = 2,
  newcolname = "wearing",
  getMinuteMarking = FALSE,
  dayStart = "00:00:00",
  tz = "UTC",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wearingMarking_+3A_dataset">dataset</code></td>
<td>
<p>The source dataset, in dataframe format, which needs to be
marked.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_frame">frame</code></td>
<td>
<p>The size of time interval to be considered; Window 1 described
in Choi <em>et al.</em> (2011). The default is 90.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_perminutects">perMinuteCts</code></td>
<td>
<p>The number of data rows per minute. The default is 1-sec
epoch (perMinuteCts = 60). For examples: for data with 10-sec epoch, set
perMinuteCts = 6; for data with 1-min epoch, set perMinuteCts = 1.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_ts">TS</code></td>
<td>
<p>The column name for timestamp. The default is &ldquo;TimeStamp&rdquo;.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_cts">cts</code></td>
<td>
<p>The column name for counts. The default is &ldquo;axis1&rdquo;.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_streamframe">streamFrame</code></td>
<td>
<p>The size of time interval that the program will look back
or forward if activity is detected; Window 2 described in Choi <em>et al.</em>
(2011). The default is the half of the frame.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_allowanceframe">allowanceFrame</code></td>
<td>
<p>The size of time interval that zero counts are allowed;
the artifactual movement interval described in Choi <em>et al.</em> (2011).
The default is 2.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_newcolname">newcolname</code></td>
<td>
<p>The column name for classified wear and nonwear status. The
default is &ldquo;wearing&rdquo;.  After the data is processed, a new field will 
be added to the original dataframe. This new field is an indicator for the
wearing (&ldquo;w&rdquo;) or nowwearing (&ldquo;nw&rdquo;).</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_getminutemarking">getMinuteMarking</code></td>
<td>
<p>Return minute data with wear and nonwear
classification. If the source is not a minute dataset, the function will
collapse it into minute data. The default is FALSE.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_daystart">dayStart</code></td>
<td>
<p>Define the starting time of day. The default is the midnight,
&quot;00:00:00&quot;. It must be in the format of &quot;hh:mm:ss&quot;.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_tz">tz</code></td>
<td>
<p>Local time zone, defaults to UTC.</p>
</td></tr>
<tr><td><code id="wearingMarking_+3A_...">...</code></td>
<td>
<p>Parameter settings that will be used in
<code><a href="#topic+dataCollapser">dataCollapser</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A detailed description of the algorithm implemented in this function is
described in Choi <em>et al.</em> (2011).
</p>


<h3>Value</h3>

<p>A data frame with the column for wear and nonwear classification
indicator by epoch-by-epoch basis.
</p>


<h3>Note</h3>

<p>Warning: It will be very slow if accelerometer data with 1-sec epoch
for many days are directly classified. We recommend to collapse a dataset
with 1-sec epoch to 1-min epoch data using <code><a href="#topic+dataCollapser">dataCollapser</a></code> and
then classify wear and nonwear status using a dataset with a larger epoch.
</p>


<h3>Author(s)</h3>

<p>Leena Choi <a href="mailto:leena.choi@Vanderbilt.Edu">leena.choi@Vanderbilt.Edu</a>,
Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>,
Zhouwen Liu <a href="mailto:zhouwen.liu@vumc.org">zhouwen.liu@vumc.org</a>,
Charles E. Matthews <a href="mailto:Charles.Matthews2@nih.gov">Charles.Matthews2@nih.gov</a>, and
Maciej S. Buchowski <a href="mailto:maciej.buchowski@Vanderbilt.Edu">maciej.buchowski@Vanderbilt.Edu</a>
</p>


<h3>References</h3>

<p>Choi L, Liu Z, Matthews CE, Buchowski MS. 
Validation of accelerometer wear and nonwear time classification algorithm.
Med Sci Sports Exerc. 2011 Feb;43(2):357-64.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readCountsData">readCountsData</a></code>, <code><a href="#topic+sumVct">sumVct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataSec)

## mark data with 1-min epoch
mydata1m = dataCollapser(dataSec, TS = "TimeStamp", col = "counts", by = 60)

data1m = wearingMarking(dataset = mydata1m,
                       frame = 90, 
                       perMinuteCts = 1,
                       TS = "TimeStamp",
                       cts = "counts", 
                       streamFrame = NULL, 
                       allowanceFrame= 2, 
                       newcolname = "wearing")

sumVct(data1m, id="dataid")

## mark data with 1-sec epoch
## Not run: 
data1s = wearingMarking(dataset = dataSec,
                       frame = 90, 
                       perMinuteCts = 60,
                       TS = "TimeStamp",
                       cts = "counts", 
                       streamFrame = NULL, 
                       allowanceFrame= 2, 
                       newcolname = "wearing",
                       getMinuteMarking = FALSE)

sumVct(data1s, id="dataid")
sumVct(data1s, id="dataid", markingString = "nw")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
