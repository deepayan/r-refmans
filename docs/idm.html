<!DOCTYPE html><html lang="en"><head><title>Help for package idm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {idm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#idm-package'>
<p>Incremental Decomposition Methods</p></a></li>
<li><a href='#add_es'>
<p>Adds two eigenspaces using block-wise incremental SVD (with or without mean update)</p></a></li>
<li><a href='#do_es'>
<p>Computes the eigenspace of a data matrix</p></a></li>
<li><a href='#enron'>
<p>enron data set</p></a></li>
<li><a href='#i_mca'>
<p>Incremental Multiple Correspondence Analysis (MCA)</p></a></li>
<li><a href='#i_pca'>
<p>Incremental Principal Component Analysis (PCA)</p></a></li>
<li><a href='#plot.i_mca'>
<p>Plotting 2D maps in Multiple Correspondence Analysis</p></a></li>
<li><a href='#plot.i_pca'>
<p>Plotting 2D maps in Principal Component Analysis</p></a></li>
<li><a href='#tweet'>
<p>twitter data set</p></a></li>
<li><a href='#update.i_mca'>
<p>Updates a Multiple Correspondence Analysis solution</p></a></li>
<li><a href='#update.i_pca'>
<p>Updates a Principal Component Analysis solution</p></a></li>
<li><a href='#women'>
<p>women data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Incremental Decomposition Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-07-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Alfonso Iodice D' Enza [aut], Angelos Markos [aut, cre], Davide
    Buttarazzi [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Angelos Markos &lt;amarkos@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), ggplot2, animation</td>
</tr>
<tr>
<td>Imports:</td>
<td>corpcor, ca, ggrepel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>ImageMagick (http://imagemagick.org) or
GraphicsMagick (http://www.graphicsmagick.org)</td>
</tr>
<tr>
<td>Description:</td>
<td>Incremental Multiple Correspondence Analysis and Principal
    Component Analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-11 17:09:39 UTC; amarkos</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-11 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='idm-package'>
Incremental Decomposition Methods
</h2><span id='topic+idm-package'></span><span id='topic+idm'></span>

<h3>Description</h3>

<p>Incremental Multiple Correspondence Analysis and Principal Component Analysis 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> idm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.8.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-08-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alfonso Iodice D' Enza [aut],
Angelos Markos [aut, cre],
Davide Buttarazzi [ctb]
</p>


<h3>References</h3>

<p>Hall, P., Marshall, D., &amp; Martin, R. (2002). Adding and subtracting eigenspaces with eigenvalue decomposition and singular value decomposition. <em>Image and Vision Computing</em>, <em>20</em>(13), 1009-1016.<br /> <br />
Iodice D' Enza, A., &amp; Markos, A. (2015). Low-dimensional tracking of association structures in categorical data, <em>Statistics and Computing</em>, <em>25</em>(5), 1009&ndash;1022. <br /> <br />
Iodice D'Enza, A., Markos, A., &amp; Buttarazzi, D. (2018). The idm Package: Incremental Decomposition Methods in R. <em>Journal of Statistical Software, Code Snippets</em>, <em>86</em>(4), 1&ndash;24. DOI: 10.18637/jss.v086.c04. <br /> <br />
Ross, D. A., Lim, J., Lin, R. S., &amp; Yang, M. H. (2008). Incremental learning for robust visual tracking. <em>International Journal of Computer Vision</em>, <em>77</em>(1-3), 125&ndash;141.
</p>

<hr>
<h2 id='add_es'>
Adds two eigenspaces using block-wise incremental SVD (with or without mean update)
</h2><span id='topic+add_es'></span>

<h3>Description</h3>

<p>This function implements two procedures for updating existing decomposition. When <code>method="esm"</code> it adds two eigenspaces using the incremental method of Hall, Marshall &amp; Martin (2002). The results correspond to the eigenspace of the mean-centered and concatenated data.
When <code>method = "isvd"</code> it adds the eigenspace of an incoming data block to an existing eigenspace using the block-wise incremental singular value decomposition (SVD) method described by Zha &amp; Simon (1999), Levy and Lindenbaum (2000), Brand (2002) and Baker (2012). New data blocks are added row-wise. The procedure can optionally keep track of the data mean using the orgn argument, as described in Ross et al. (2008) and Iodice D'Enza &amp; Markos (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_es(eg, eg2, current_rank, ff = 0, method = c("esm", "isvd"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_es_+3A_eg">eg</code></td>
<td>
<p>A list describing the eigenspace of a data matrix, with components <br />
<code>u</code> Left eigenvectors <br />
<code>v</code> Right eigenvectors <br />
<code>m</code> Number of cases <br />
<code>d</code> Eigenvalues <br />
<code>orgn</code> Data mean <br />
</p>
</td></tr>
<tr><td><code id="add_es_+3A_method">method</code></td>
<td>
<p>refers to the procedure being implemented: <code>"esm"</code> refers to the eigenspace merge (Hall et al., 2002); <code>"isvd"</code> refers to the incremental SVD method, with or without keeping track of the data mean.</p>
</td></tr>
<tr><td><code id="add_es_+3A_eg2">eg2</code></td>
<td>
<p>(*)A list describing the eigenspace of a data matrix, with components <br />
<code>u</code> Left eigenvectors <br />
<code>v</code> Right eigenvectors <br />
<code>m</code> Number of cases <br />
<code>d</code> Eigenvalues <br />
<code>orgn</code> Data mean <br />
</p>
</td></tr>
<tr><td><code id="add_es_+3A_current_rank">current_rank</code></td>
<td>
<p>Rank of approximation; if empty, the full rank is used</p>
</td></tr>
<tr><td><code id="add_es_+3A_ff">ff</code></td>
<td>
<p>(**)Number between 0 and 1 indicating the forgetting factor used to down-weight the contribution of earlier data blocks to the current solution. When ff = 0 (default) no forgetting occurs</p>
</td></tr>
</table>
<p>(*) for <code>method = "esm"</code> only; (**) for <code>method = "isvd"</code> only.
</p>


<h3>Value</h3>

<p>A list describing the SVD of a data matrix, with components <br />
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>Left singular vectors</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Singular values</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Right singular vectors</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code>orgn</code></td>
<td>
<p>Data mean; returned only if <code>orgn</code> is given as input</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zha, H., &amp; Simon, H. D. (1999). On updating problems in latent semantic indexing. <em>SIAM Journal on Scientific Computing</em>, <em>21</em>(2), 782-791.<br /> <br />
Levy, A., &amp; Lindenbaum, M. (2000). Sequential Karhunen-Loeve basis extraction and its application to images. <em>IEEE Transactions on Image Processing</em>, <em>9</em>(8), 1371-1374.<br /> <br />
Brand, M. (2002). Incremental singular value decomposition of uncertain data with missing values. In <em>Computer Vision-ECCV 2002</em> (pp. 707-720). Springer Berlin Heidelberg.<br /> <br />
Ross, D. A., Lim, J., Lin, R. S., &amp; Yang, M. H. (2008). Incremental learning for robust visual tracking. <em>International Journal of Computer Vision</em>, <em>77</em>(1-3), 125-141.<br /> <br />
Baker, C. G., Gallivan, K. A., &amp; Van Dooren, P. (2012). Low-rank incremental methods for computing dominant singular subspaces. <em>Linear Algebra and its Applications</em>, <em>436</em>(8), 2866-2888.<br /> <br />
Iodice D' Enza, A., &amp; Markos, A. (2015). Low-dimensional tracking of association structures in categorical data, <em>Statistics and Computing</em>, <em>25</em>(5), 1009-1022. 
Iodice D'Enza, A., Markos, A., &amp; Buttarazzi, D. (2018). The idm Package: Incremental Decomposition Methods in R. <em>Journal of Statistical Software, Code Snippets</em>, <em>86</em>(4), 1&ndash;24. DOI: 10.18637/jss.v086.c04.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+do_es">do_es</a></code>, <code><a href="#topic+i_pca">i_pca</a></code>, <code><a href="#topic+i_mca">i_mca</a></code>, <code><a href="#topic+update.i_pca">update.i_pca</a></code>, <code><a href="#topic+update.i_mca">update.i_mca</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1 - eigenspace merge (Hall et al., 2002)
#Iris species
data("iris", package = "datasets")
X = iris[,-5]
#obtain two eigenspaces
eg = do_es(X[1:50, ])
eg2 = do_es(X[c(51:150), ])
#add the two eigenspaces keeping track of the data mean
eg12 = add_es(method = "esm", eg, eg2)
#equivalent to the SVD of the mean-centered data (svd(scale(X, center = TRUE,scale = FALSE)))

## Example 2 - block-wise incremental SVD with mean update, full rank (Ross et al., 2008)
data("iris", package = "datasets")
# obtain the eigenspace of the first 50 Iris species
X = iris[,-5]
eg = do_es(X[1:50, ])
#update the eigenspace of the remaining species to
eg_new = add_es(method = "isvd", eg, data.matrix(X[c(51:150), ]))
#equivalent to the SVD of the mean-centered data (svd(scale(X, center = TRUE, scale = FALSE)))

##Example 3 - incremental SVD with mean update, 2d approximation (Ross et al., 2008)
data("iris", package = "datasets")
# obtain the eigenspace of the first 50 Iris species
X = iris[,-5]
eg = do_es(X[1:50, ])
#update the eigenspace of the remaining species to
eg = add_es(method = "isvd", eg, data.matrix(X[c(51:150), ]),current_rank = 2)
#similar to PCA on the covariance matrix of X (SVD of the mean-centered data)

</code></pre>

<hr>
<h2 id='do_es'>
Computes the eigenspace of a data matrix
</h2><span id='topic+do_es'></span>

<h3>Description</h3>

<p>This function computes the eigenspace of a mean-centered data matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_es(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do_es_+3A_data">data</code></td>
<td>
<p>a matrix or data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list describing the eigenspace of a data matrix, with components 
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>Left eigenvectors</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Right eigenvectors</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Eigenvalues</p>
</td></tr>
<tr><td><code>orgn</code></td>
<td>
<p>Data mean</p>
</td></tr>
<tr><td><code>smfq</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+add_es">add_es</a></code>, <code><a href="#topic+update.i_pca">update.i_pca</a></code>, <code><a href="#topic+i_pca">i_pca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Iris species
data("iris", package = "datasets")
eg = do_es(iris[,-5]) 
#corresponds to the SVD of the centered data matrix
</code></pre>

<hr>
<h2 id='enron'>
enron data set
</h2><span id='topic+enron'></span>

<h3>Description</h3>

<p>The data set is a subset of the Enron e-mail corpus from the UCI Machine Learning Repository (Lichman, 2013). The original data is a collection of 39,861 email messages with roughly 6 million tokens and a 28,102 term vocabulary. The subset is a binary (presence/absence) data set containing the 80 most frequent words which appear in the original corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("enron")</code></pre>


<h3>Format</h3>

<p>A binary data frame with 39,861 observations (e-mail messages) on 80 variables (words).
</p>


<h3>References</h3>

<p>Lichman, M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(enron)
</code></pre>

<hr>
<h2 id='i_mca'>
Incremental Multiple Correspondence Analysis (MCA)
</h2><span id='topic+i_mca'></span>

<h3>Description</h3>

<p>This function computes the Multiple Correspondence Analysis (MCA) solution on the indicator matrix using two incremental methods described in Iodice D'Enza &amp; Markos (2015)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_mca(data1, data2, method=c("exact","live"), current_rank, nchunk = 2, 
 ff = 0, disk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_mca_+3A_data1">data1</code></td>
<td>
<p>Matrix or data frame of starting data or full data if data2 = NULL</p>
</td></tr>
<tr><td><code id="i_mca_+3A_data2">data2</code></td>
<td>
<p>Matrix or data frame of incoming data</p>
</td></tr>
<tr><td><code id="i_mca_+3A_method">method</code></td>
<td>
<p>String specifying the type of implementation: <code>"exact"</code> or <code>"live"</code>. <code>"exact"</code> refers to the case when all the data is available from the start and dimension reduction is based on the method of Hall et al. (2002). <code>"live"</code> refers to the case when new data comes in as data flows and dimension reduction is based on the method of Ross et al. (2008). The main difference between the two approaches lies in the calculation of the column margins of the input matrix. For the <code>"exact"</code> approach, the analysis is based on the &quot;global&quot; margins, that is, the margins of the whole indicator matrix, which is available in advance. For the <code>"live"</code> approach, the whole matrix is unknown and the global margins are approximated by  the &quot;local&quot; margins, that is, the average margins of the data analysed insofar. A detailed description of the two implementations is provided in Iodice D' Enza &amp; Markos (2015).</p>
</td></tr>
<tr><td><code id="i_mca_+3A_current_rank">current_rank</code></td>
<td>
<p>Rank of approximation or number of components to compute; if empty, the full rank is used</p>
</td></tr>
<tr><td><code id="i_mca_+3A_nchunk">nchunk</code></td>
<td>
<p>Number of incoming data chunks (equal splits of 'data2', <code>default = 2</code>) or a Vector with the row size of each incoming data chunk</p>
</td></tr>
<tr><td><code id="i_mca_+3A_ff">ff</code></td>
<td>
<p>Number between 0 and 1 indicating the &quot;forgetting factor&quot; used to down-weight the contribution of earlier data blocks to the current solution. When <code>ff = 0</code> (default) no forgetting occurs; applicable only when <code>method ="live"</code></p>
</td></tr>
<tr><td><code id="i_mca_+3A_disk">disk</code></td>
<td>
<p>Logical indicating whether then output is saved to hard disk</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>rowpcoord</code></td>
<td>
<p>Row principal coordinates</p>
</td></tr>     
<tr><td><code>colpcoord</code></td>
<td>
<p>Column principal coordinates</p>
</td></tr>
<tr><td><code>rowcoord</code></td>
<td>
<p>Row standard coordinates</p>
</td></tr>     
<tr><td><code>colcoord</code></td>
<td>
<p>Column standard coordinates</p>
</td></tr>
<tr><td><code>sv</code></td>
<td>
<p>Singular values</p>
</td></tr>
<tr><td><code>inertia.e</code></td>
<td>
<p>Percentages of explained inertia</p>
</td></tr>
<tr><td><code>levelnames</code></td>
<td>
<p>Column labels</p>
</td></tr>
<tr><td><code>rowctr</code></td>
<td>
<p>Row contributions</p>
</td></tr>
<tr><td><code>colctr</code></td>
<td>
<p>Column contributions</p>
</td></tr> 
<tr><td><code>rowcor</code></td>
<td>
<p>Row squared correlations</p>
</td></tr>
<tr><td><code>colcor</code></td>
<td>
<p>Column squared correlations</p>
</td></tr>
<tr><td><code>rowmass</code></td>
<td>
<p>Row masses</p>
</td></tr>
<tr><td><code>colmass</code></td>
<td>
<p>Column masses</p>
</td></tr>  
<tr><td><code>nchunk</code></td>
<td>
<p>A copy of <code>nchunk</code> in the return object</p>
</td></tr>
<tr><td><code>disk</code></td>
<td>
<p>A copy of <code>disk</code> in the return object</p>
</td></tr>
<tr><td><code>ff</code></td>
<td>
<p>A copy of <code>ff</code> in the return object</p>
</td></tr>
<tr><td><code>allrowcoord</code></td>
<td>
<p>A list containing the row principal coordinates  produced after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allcolcoord</code></td>
<td>
<p>A list containing the column principal coordinates  on the principal components produced after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allrowctr</code></td>
<td>
<p>A list containing the row contributions after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allcolctr</code></td>
<td>
<p>A list containing the column contributions after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allrowcor</code></td>
<td>
<p>A list containing the row squared correlations produced after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allcolcor</code></td>
<td>
<p>A list containing the column squared correlations produced after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Hall, P., Marshall, D., &amp; Martin, R. (2002). Adding and subtracting eigenspaces with eigenvalue decomposition and singular value decomposition. <em>Image and Vision Computing</em>, <em>20</em>(13), 1009-1016.<br /> <br />
Iodice D' Enza, A., &amp; Markos, A. (2015). Low-dimensional tracking of association structures in categorical data, <em>Statistics and Computing</em>, <em>25</em>(5), 1009&ndash;1022. <br /> <br />
Iodice D'Enza, A., Markos, A., &amp; Buttarazzi, D. (2018). The idm Package: Incremental Decomposition Methods in R. <em>Journal of Statistical Software, Code Snippets</em>, <em>86</em>(4), 1&ndash;24. DOI: 10.18637/jss.v086.c04. <br /> <br />
Ross, D. A., Lim, J., Lin, R. S., &amp; Yang, M. H. (2008). Incremental learning for robust visual tracking. <em>International Journal of Computer Vision</em>, <em>77</em>(1-3), 125&ndash;141.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update.i_mca">update.i_mca</a></code>, <code><a href="#topic+i_pca">i_pca</a></code>, <code><a href="#topic+update.i_pca">update.i_pca</a></code>, <code><a href="#topic+add_es">add_es</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Example 1 - Exact case
data("women", package = "idm")
nc = 5 # number of chunks
res_iMCAh = i_mca(data1 = women[1:300,1:7], data2 = women[301:2107,1:7]
,method = "exact", nchunk = nc)
#static MCA plot of attributes on axes 2 and 3
plot(x = res_iMCAh, dim = c(2,3), what = c(FALSE,TRUE), animation = FALSE)

#\donttest is used here because the code calls the saveLatex function of the animation package 
#which requires ImageMagick or GraphicsMagick and 
#Adobe Acrobat Reader to be installed in your system 
#Creates animated plot in PDF for objects and variables
plot(res_iMCAh, animation = TRUE, frames = 10, movie_format = 'pdf')


##Example 2 - Live case
data("tweet", package = "idm")
nc = 5
#provide attributes with custom labels
labels = c("HLTN", "ICN", "MRT","BWN","SWD","HYT","CH", "-", "-/+", "+", "++", "Low", "Med","High")
#mimics the 'live' MCA implementation 
res_iMCAl = i_mca(data1 = tweet[1:100,], data2 = tweet[101:1000,],
method="live", nchunk = nc, current_rank = 2)


#\donttest is used here because the code calls the saveLatex function of the animation package 
#which requires ImageMagick or GraphicsMagick and 
#Adobe Acrobat Reader to be installed in your system 
#See help(im.convert) for details on the configuration of ImageMagick or GraphicsMagick.
#Creates animated plot in PDF for observations and variables
plot(res_iMCAl, labels = labels, animation = TRUE, frames = 10, movie_format = 'pdf')

</code></pre>

<hr>
<h2 id='i_pca'>
Incremental Principal Component Analysis (PCA)
</h2><span id='topic+i_pca'></span>

<h3>Description</h3>

<p>This function computes the Principal Component Analysis (PCA) solution on the covariance matrix using the incremental method of Hall, Marshall &amp; Martin (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_pca(data1, data2, current_rank, nchunk = 2, disk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_pca_+3A_data1">data1</code></td>
<td>
<p>Matrix or data frame of starting data, or full data if data2 = NULL</p>
</td></tr>
<tr><td><code id="i_pca_+3A_data2">data2</code></td>
<td>
<p>Matrix or data frame of incoming data; omitted when full data is given in data1</p>
</td></tr>
<tr><td><code id="i_pca_+3A_current_rank">current_rank</code></td>
<td>
<p>Rank of approximation or number of components to compute; if empty, the full rank is used</p>
</td></tr>
<tr><td><code id="i_pca_+3A_nchunk">nchunk</code></td>
<td>
<p>Number of incoming data chunks (equal splits of 'data2', <code>default = 2</code>) or a Vector with the row size of each incoming data chunk</p>
</td></tr>
<tr><td><code id="i_pca_+3A_disk">disk</code></td>
<td>
<p>Logical indicating whether then output is saved to hard disk</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>rowpcoord</code></td>
<td>
<p>Row scores on the principal components</p>
</td></tr>     
<tr><td><code>colpcoord</code></td>
<td>
<p>Variable loadings</p>
</td></tr>     
<tr><td><code>eg</code></td>
<td>
<p>A list describing the eigenspace of a data matrix, with components <br />
<code>u</code> Left eigenvectors <br />
<code>v</code> Right eigenvectors <br />
<code>m</code> Number of cases <br />
<code>d</code> Eigenvalues <br />
<code>orgn</code> Data mean <br /></p>
</td></tr>
<tr><td><code>sv</code></td>
<td>
<p>Singular values</p>
</td></tr>
<tr><td><code>inertia_e</code></td>
<td>
<p>Percentage of explained variance</p>
</td></tr>
<tr><td><code>levelnames</code></td>
<td>
<p>Attribute labels</p>
</td></tr>
<tr><td><code>rowctr</code></td>
<td>
<p>Row contributions</p>
</td></tr>
<tr><td><code>colctr</code></td>
<td>
<p>Column contributions</p>
</td></tr>
<tr><td><code>rowcor</code></td>
<td>
<p>Row squared correlations</p>
</td></tr>
<tr><td><code>colcor</code></td>
<td>
<p>Column squared correlations</p>
</td></tr>
<tr><td><code>nchunk</code></td>
<td>
<p>A copy of <code>nchunk</code> in the return object</p>
</td></tr>
<tr><td><code>disk</code></td>
<td>
<p>A copy of <code>disk</code> in the return object</p>
</td></tr>
<tr><td><code>allrowcoord</code></td>
<td>
<p>A list containing the row scores on the principal components produced after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allcolcoord</code></td>
<td>
<p>A list containing the variable loadings on the principal components produced after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allrowctr</code></td>
<td>
<p>A list containing the row contributions after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allcolctr</code></td>
<td>
<p>A list containing the column contributions after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allrowcor</code></td>
<td>
<p>A list containing the row squared correlations produced after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
<tr><td><code>allcolcor</code></td>
<td>
<p>A list containing the column squared correlations produced after each data chunk is analyzed; returned only when <code>disk = FALSE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Hall, P., Marshall, D., &amp; Martin, R. (2002). Adding and subtracting eigenspaces with eigenvalue decomposition and singular value decomposition. <em>Image and Vision Computing</em>, <em>20</em>(13), 1009-1016.<br /> <br />
Iodice D' Enza, A., &amp; Markos, A. (2015). Low-dimensional tracking of association structures in categorical data, <em>Statistics and Computing</em>, <em>25</em>(5), 1009&ndash;1022. <br /> <br />
Iodice D'Enza, A., Markos, A., &amp; Buttarazzi, D. (2018). The idm Package: Incremental Decomposition Methods in R. <em>Journal of Statistical Software, Code Snippets</em>, <em>86</em>(4), 1&ndash;24. DOI: 10.18637/jss.v086.c04.</p>


<h3>See Also</h3>

<p><code><a href="#topic+update.i_pca">update.i_pca</a></code>, <code><a href="#topic+i_mca">i_mca</a></code>, <code><a href="#topic+update.i_mca">update.i_mca</a></code>, <code><a href="#topic+add_es">add_es</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("segmentationData", package = "caret")
#center and standardize variables, keep 58 continuous attributes
HCS = data.frame(scale(segmentationData[,-c(1:3)]))
#abbreviate variable names for plotting
names(HCS) = abbreviate(names(HCS), minlength = 5)
#split the data into starting data and incoming data
data1 = HCS[1:150, ]
data2 = HCS[151:2019, ]
#Incremental PCA on the HCS data set: the incoming data is 
#splitted into twenty chunks; the first 5 components/dimensions 
#are computed in each update
res_iPCA = i_pca(data1, data2, current_rank = 5, nchunk = 20)
#Static plots 
plot(res_iPCA, animation = FALSE)

#\donttest is used here because the code calls the saveLatex function of the animation package 
#which requires ImageMagick or GraphicsMagick and 
#Adobe Acrobat Reader to be installed in your system 
#See help(im.convert) for details on the configuration of ImageMagick or GraphicsMagick.
#Creates animated plot in PDF for objects and variables
plot(res_iPCA, animation = TRUE, frames = 10, movie_format = 'pdf')


#Daily Closing Prices of Major European Stock Indices, 1991-1998 
data("EuStockMarkets", package = "datasets") 
res_iPCA = i_pca(data1 = EuStockMarkets[1:50,], data2 = EuStockMarkets[51:1860,], nchunk = 5) 

#\donttest is used here because the code calls the saveLatex function of the animation package 
#which requires ImageMagick or GraphicsMagick and 
#Adobe Acrobat Reader to be installed in your system 
#See help(im.convert) for details on the configuration of ImageMagick or GraphicsMagick.
#Creates animated plot in PDF movies for objects and variables
plot(res_iPCA, animation = TRUE, frames = 10, movie_format = 'pdf')

</code></pre>

<hr>
<h2 id='plot.i_mca'>
Plotting 2D maps in Multiple Correspondence Analysis
</h2><span id='topic+plot.i_mca'></span>

<h3>Description</h3>

<p>Graphical display of Multiple Correspondence Analysis results in two dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'i_mca'
plot(x, dims = c(1,2), what = c(TRUE,TRUE), 
contrib = "none", dataname = NULL, labels = NULL, animation = TRUE, 
frames = 10, zoom = TRUE, movie_format = "gif", binary = FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.i_mca_+3A_x">x</code></td>
<td>
<p>Multiple correspondence analysis object returned by <code><a href="#topic+i_mca">i_mca</a></code></p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_dims">dims</code></td>
<td>
<p>Numerical vector of length 2 indicating the dimensions to plot on horizontal and vertical axes respectively; default is first dimension horizontal and second dimension vertical</p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_what">what</code></td>
<td>
<p>Vector of two logicals specifying the contents of the plot(s). First entry indicates if the rows (observations) are displayed in principal coordinates and the second entry if the variable categories are displayed in principal coordinates (<code>default = c(TRUE,TRUE)</code> and shows two separate plots and a joint plot if <code>animation = FALSE</code> and two separate plots if <code>animation = TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_contrib">contrib</code></td>
<td>
<p>Vector of two character strings specifying if attribute contributions should be represented by different label size. Available options are<br />
<kbd>"none"</kbd> (contributions are not indicated in the plot)<br />
<kbd>"cor"</kbd> (relative contributions are indicated by label size)<br />
<kbd>"ctr"</kbd> (absolute contributions are indicated by label size)<br />
The higher the contribution of a point, the larger its label size. Default is <kbd>"none"</kbd></p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_dataname">dataname</code></td>
<td>
<p>String prefix used for custom naming of output files; default is the name of the output object</p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_labels">labels</code></td>
<td>
<p>String vector of variable labels</p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_animation">animation</code></td>
<td>
<p>Logical indicating whether animated GIF or PDF files are created and saved to the hard drive or a static plot is created (<code>default = TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_frames">frames</code></td>
<td>
<p>Number of animation frames shown per iteration (<code>default = 10</code>); applicable only when <code>animation = TRUE</code></p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_zoom">zoom</code></td>
<td>
<p>Logical indicating whether axis limits change during the animation creating a zooming effect; applicable only when <code>animation = TRUE</code></p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_binary">binary</code></td>
<td>
<p>Logical indicating whether the categories associated with attribute presence are displayed on the plot; applicable only when the data are 0/1</p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_movie_format">movie_format</code></td>
<td>
<p>Specifies if the animated plot is saved in the working directory either in <code>default = "gif"</code> or <code>"pdf"</code> format</p>
</td></tr>
<tr><td><code id="plot.i_mca_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+points">points</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>plot.i_mca</code> makes a two-dimensional map of the object created by <code>i_mca</code> with respect to two selected dimensions. In this map both the row and column points are scaled to have inertias (weighted variances) equal to the principal inertia (eigenvalue or squared singular value) along the principal axes, that is both rows and columns are in pricipal coordinates. 
</p>


<h3>References</h3>

<p>Greenacre, M.J. (1993) <em>Correspondence Analysis in Practice</em>. London: Academic Press. <br />
Greenacre, M.J. (1993) Biplots in Correspondence Analysis, <em>Journal of Applied Statistics</em>, 20, 251-269.<br />
ImageMagick: <a href="http://www.imagemagick.org">http://www.imagemagick.org</a>; GraphicsMagick: <a href="http://www.graphicsmagick.org">http://www.graphicsmagick.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.i_pca">plot.i_pca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("women", package = "idm")
res_iMCAl = i_mca(data1 = women[1:50, 1:4], data2 = women[51:300, 1:4], 
method = "live", nchunk = 4)
#static plot, final solution
plot(res_iMCAl, contrib = "ctr", animation = FALSE)

#\donttest is used here because the code calls the saveLatex function of the animation package 
#which requires ImageMagick or GraphicsMagick and 
#Adobe Acrobat Reader to be installed in your system 
#See help(im.convert) for details on the configuration of ImageMagick or GraphicsMagick.
#Creates animated plots in PDF for objects and variables
plot(res_iMCAl, contrib = "ctr", animation = TRUE, frames = 10, movie_format = 'pdf')

</code></pre>

<hr>
<h2 id='plot.i_pca'>
Plotting 2D maps in Principal Component Analysis
</h2><span id='topic+plot.i_pca'></span>

<h3>Description</h3>

<p>Graphical display of Principal Component Analysis results in two dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'i_pca'
plot(x, dims = c(1,2), what = c(TRUE,TRUE), 
dataname = NULL, labels = NULL, animation = TRUE, frames = 10, 
zoom = TRUE, movie_format = "gif", ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.i_pca_+3A_x">x</code></td>
<td>
<p>Principal component analysis object returned by <code><a href="#topic+i_pca">i_pca</a></code></p>
</td></tr>
<tr><td><code id="plot.i_pca_+3A_dims">dims</code></td>
<td>
<p>Numerical vector of length 2 indicating the dimensions to plot on horizontal and vertical axes respectively; default is first dimension horizontal and second dimension vertical</p>
</td></tr>
<tr><td><code id="plot.i_pca_+3A_what">what</code></td>
<td>
<p>Vector of two logicals specifying the contents of the plot(s). First entry indicates if the scatterplot of observations is displayed and the second entry if the correlation circle of the variable loadings is displayed (<code>default = c(TRUE,TRUE)</code> and shows both plots)</p>
</td></tr>
<tr><td><code id="plot.i_pca_+3A_dataname">dataname</code></td>
<td>
<p>String prefix used for custom naming of output files; default is the name of the output object</p>
</td></tr>
<tr><td><code id="plot.i_pca_+3A_labels">labels</code></td>
<td>
<p>String vector of variable labels</p>
</td></tr>
<tr><td><code id="plot.i_pca_+3A_animation">animation</code></td>
<td>
<p>Logical indicating whether animated GIF or PDF files are created and saved to the hard drive or a static plot is created (<code>default = TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.i_pca_+3A_frames">frames</code></td>
<td>
<p>Number of animation frames shown per iteration (<code>default = 10</code>); applicable only when <code>animation = TRUE</code></p>
</td></tr>
<tr><td><code id="plot.i_pca_+3A_zoom">zoom</code></td>
<td>
<p>Logical indicating whether axes limits change during the animation creating a zooming effect; applicable only when <code>animation = TRUE</code></p>
</td></tr>
<tr><td><code id="plot.i_pca_+3A_movie_format">movie_format</code></td>
<td>
<p>Specifies if the animated plot is saved in the working directory either in <code>default = "gif"</code> or <code>"pdf"</code> format</p>
</td></tr>
<tr><td><code id="plot.i_pca_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+points">points</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>plot.i_pca</code> makes a two-dimensional map of the object created by <code>i_pca</code> with respect to two selected dimensions.  
</p>


<h3>References</h3>

<p>ImageMagick: <a href="http://www.imagemagick.org">http://www.imagemagick.org</a>; GraphicsMagick: <a href="http://www.graphicsmagick.org">http://www.graphicsmagick.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.i_mca">plot.i_mca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris", package = "datasets")
#standardize variables
X = scale(iris[,-5])
res_iPCA = i_pca(data1 = X[1:50,-5], data2 = X[51:150,-5], nchunk = c(50,50))
#static plot, final solution
plot(res_iPCA, animation = FALSE)

##\donttest is used here because the code calls the saveLatex function of the animation package 
#which requires ImageMagick or GraphicsMagick and 
#Adobe Acrobat Reader to be installed in your system 
#See help(im.convert) for details on the configuration of ImageMagick or GraphicsMagick.
#Creates animated plots in PDF for objects and variables
plot(res_iPCA, animation = TRUE, frames = 10, movie_format = 'pdf')

</code></pre>

<hr>
<h2 id='tweet'>
twitter data set
</h2><span id='topic+tweet'></span>

<h3>Description</h3>

<p>The data set refers to a small corpus of messages or tweets mentioning seven
major hotel brands. It was gathered by continuously querying and archiving
the Twitter Streaming API service, using the <code>twitteR</code> package in <code>R</code>. A total of 7,296 tweets were extracted within a time period of 6 days, from June 23th to June 28th 2013. Only tweets in the English language were considered. A sentiment polarity variable was calculated, indicating the sentiment value of each message and a third variable, user visibility or popularity, as measured by
the number of followers each user had, was also included in the dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("tweet")</code></pre>


<h3>Format</h3>

<p>A data frame with the following variables:
</p>

<dl>
<dt><code>Brand</code></dt><dd><p>The hotel brand mentioned in the tweet: 1=<kbd>Hilton</kbd>, 2=<kbd>Intercontinental</kbd>, 3=<kbd>Marriott</kbd>, 4=<kbd>Bestwestern</kbd>, 5=<kbd>Starwood</kbd>, 6=<kbd>Hyatt</kbd>, 7=<kbd>Choice</kbd></p>
</dd>
<dt><code>Sentiment</code></dt><dd><p>Sentiment  for each tweet: 1=<kbd>negative (-)</kbd>, 2=<kbd>mixed (+/-)</kbd>, 3=<kbd>positive (+)</kbd>, 4=<kbd>very positive (++)</kbd></p>
</dd>
<dt><code>UserVis</code></dt><dd><p>User popularity/visibility in Twitter: 1=<kbd>low</kbd>, 2=<kbd>medium</kbd>, 3=<kbd>high</kbd></p>
</dd>
</dl>



<h3>References</h3>

<p>Iodice D' Enza, A., &amp; Markos, A. (2015). Low-dimensional tracking of association structures in categorical data, <em>Statistics and Computing</em>, <em>25</em>(5), 1009-1022. <br /> <br />
Iodice D'Enza, A., Markos, A., &amp; Buttarazzi, D. (2018). The idm Package: Incremental Decomposition Methods in R. <em>Journal of Statistical Software, Code Snippets</em>, <em>86</em>(4), 1&ndash;24. DOI: 10.18637/jss.v086.c04.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tweet)
</code></pre>

<hr>
<h2 id='update.i_mca'>
Updates a Multiple Correspondence Analysis solution
</h2><span id='topic+update.i_mca'></span>

<h3>Description</h3>

<p>This function updates the Multiple Correspondence Analysis (MCA) solution on the indicator matrix using the incremental method of Ross, Lim, Lin, &amp; Yang (2008)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'i_mca'
update(object, incdata, current_rank, ff = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.i_mca_+3A_object">object</code></td>
<td>
<p>object of class 'i_mca'</p>
</td></tr>
<tr><td><code id="update.i_mca_+3A_incdata">incdata</code></td>
<td>
<p>Matrix of incoming data</p>
</td></tr>
<tr><td><code id="update.i_mca_+3A_current_rank">current_rank</code></td>
<td>
<p>Rank of approximation or number of components to compute; if empty, the full rank is used</p>
</td></tr>
<tr><td><code id="update.i_mca_+3A_ff">ff</code></td>
<td>
<p>Number between 0 and 1 indicating the &quot;forgetting factor&quot; used to down-weight the contribution of earlier data blocks to the current solution. When <code>ff = 0</code> (default) no forgetting occurs</p>
</td></tr>
<tr><td><code id="update.i_mca_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+update">update</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>rowpcoord</code></td>
<td>
<p>Row principal coordinates</p>
</td></tr>     
<tr><td><code>colpcoord</code></td>
<td>
<p>Column principal coordinates</p>
</td></tr> 
<tr><td><code>rowcoord</code></td>
<td>
<p>Row standard coordinates</p>
</td></tr>     
<tr><td><code>colcoord</code></td>
<td>
<p>Column standard coordinates</p>
</td></tr> 
<tr><td><code>sv</code></td>
<td>
<p>Singular values</p>
</td></tr> 
<tr><td><code>inertia.e</code></td>
<td>
<p>Percentages of explained inertia</p>
</td></tr>
<tr><td><code>levelnames</code></td>
<td>
<p>Attribute names</p>
</td></tr> 
<tr><td><code>rowctr</code></td>
<td>
<p>Row contributions</p>
</td></tr>
<tr><td><code>colctr</code></td>
<td>
<p>Column contributions</p>
</td></tr> 
<tr><td><code>rowcor</code></td>
<td>
<p>Row squared correlations</p>
</td></tr> 
<tr><td><code>colcor</code></td>
<td>
<p>Column squared correlations</p>
</td></tr> 
<tr><td><code>rowmass</code></td>
<td>
<p>Row masses</p>
</td></tr> 
<tr><td><code>colmass</code></td>
<td>
<p>Column masses</p>
</td></tr> 
<tr><td><code>indmat</code></td>
<td>
<p>Indicator matrix</p>
</td></tr> 
<tr><td><code>m</code></td>
<td>
<p>Number of cases processed up to this point</p>
</td></tr> 
<tr><td><code>ff</code></td>
<td>
<p>A copy of <code>ff</code> in the return object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Iodice D'Enza, A., Markos, A., &amp; Buttarazzi, D. (2018). The idm Package: Incremental Decomposition Methods in R. <em>Journal of Statistical Software, Code Snippets</em>, <em>86</em>(4), 1&ndash;24. DOI: 10.18637/jss.v086.c04. <br /> <br />
Ross, D. A., Lim, J., Lin, R. S., &amp; Yang, M. H. (2008). Incremental learning for robust visual tracking. <em>International Journal of Computer Vision</em>, <em>77</em>(1-3), 125&ndash;141.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_es">add_es</a></code>, <code><a href="#topic+i_mca">i_mca</a></code>, <code><a href="#topic+plot.i_mca">plot.i_mca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(women, package = "idm")
dat = women[,c(1:4)]
res_MCA = i_mca(dat[1:300,])
aa = seq(from = 301, to = nrow(women), by = 200)
aa[length(aa)] = nrow(dat)+1
for (k in c(1:(length(aa)-1)))
{
  res_MCA = update(res_MCA,dat[c((aa[k]):(aa[k+1]-1)),])
}
plot(res_MCA, what = c(FALSE, TRUE), animation = FALSE)
</code></pre>

<hr>
<h2 id='update.i_pca'>
Updates a Principal Component Analysis solution
</h2><span id='topic+update.i_pca'></span>

<h3>Description</h3>

<p>This function updates the Principal Component Analysis (PCA) solution on the covariance matrix using the incremental method of Hall, Marshall &amp; Martin (2002)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'i_pca'
update(object, incdata, current_rank, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.i_pca_+3A_object">object</code></td>
<td>
<p>object of class 'i_pca'</p>
</td></tr>
<tr><td><code id="update.i_pca_+3A_incdata">incdata</code></td>
<td>
<p>matrix of incoming data</p>
</td></tr>
<tr><td><code id="update.i_pca_+3A_current_rank">current_rank</code></td>
<td>
<p>Rank of approximation or number of components to compute; if empty, the full rank is used</p>
</td></tr>
<tr><td><code id="update.i_pca_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+update">update</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>rowpcoord</code></td>
<td>
<p>Row scores on the principal components</p>
</td></tr>     
<tr><td><code>colpcoord</code></td>
<td>
<p>Variable loadings</p>
</td></tr>     
<tr><td><code>eg</code></td>
<td>
<p>A list describing the eigenspace of a data matrix, with components <br />
<code>u</code> Left eigenvectors <br />
<code>v</code> Right eigenvectors <br />
<code>m</code> Number of cases <br />
<code>d</code> Eigenvalues <br />
<code>orgn</code> Data mean <br /></p>
</td></tr>
<tr><td><code>inertia.e</code></td>
<td>
<p>Percentages of explained variance</p>
</td></tr>
<tr><td><code>sv</code></td>
<td>
<p>Singular values</p>
</td></tr>
<tr><td><code>levelnames</code></td>
<td>
<p>Variable names</p>
</td></tr>
<tr><td><code>rowcor</code></td>
<td>
<p>Row squared correlations</p>
</td></tr>
<tr><td><code>rowctr</code></td>
<td>
<p>Row contributions</p>
</td></tr>
<tr><td><code>colcor</code></td>
<td>
<p>Column squared correlations</p>
</td></tr>
<tr><td><code>colctr</code></td>
<td>
<p>Column contributions</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hall, P., Marshall, D., &amp; Martin, R. (2002). Adding and subtracting eigenspaces with eigenvalue decomposition and singular value decomposition. <em>Image and Vision Computing</em>, <em>20</em>(13), 1009-1016.<br /> <br />
Iodice D' Enza, A., &amp; Markos, A. (2015). Low-dimensional tracking of association structures in categorical data, <em>Statistics and Computing</em>, <em>25</em>(5), 1009&ndash;1022. <br /> <br />
Iodice D'Enza, A., Markos, A., &amp; Buttarazzi, D. (2018). The idm Package: Incremental Decomposition Methods in R. <em>Journal of Statistical Software, Code Snippets</em>, <em>86</em>(4), 1&ndash;24. DOI: 10.18637/jss.v086.c04.</p>


<h3>See Also</h3>

<p><code><a href="#topic+update.i_mca">update.i_mca</a></code>, <code><a href="#topic+i_pca">i_pca</a></code>, <code><a href="#topic+i_mca">i_mca</a></code>, <code><a href="#topic+add_es">add_es</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(segmentationData, package = "caret")
HCS = data.frame(scale(segmentationData[,-c(1:3)]))
names(HCS) = abbreviate(names(HCS), minlength = 5)
res_PCA = i_pca(HCS[1:200, ])
aa = seq(from = 201, to = nrow(HCS), by = 200)
aa[length(aa)] = nrow(HCS)+1
for (k in c(1:(length(aa)-1))){
     res_PCA = update(res_PCA, HCS[c((aa[k]):(aa[k+1]-1)),])
    }
#Static plot
plot(res_PCA, animation = FALSE)
</code></pre>

<hr>
<h2 id='women'>
women data set
</h2><span id='topic+women'></span>

<h3>Description</h3>

<p>The data are from the third Family and Changing Gender Roles survey conducted in 2002. The questions retained are those related to working women in Spain and the effect on the family. A total of 2,107 respondents answered eight questions on a 5-point Likert scale, as well as four demographic variables (gender, martial status, education and age). There are no cases with missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("women")</code></pre>


<h3>Format</h3>

<p>A data frame with the following variables:
</p>

<dl>
<dt><code>A</code></dt><dd><p>&quot;a working mother can establish a warm relationship with her child&quot; <br /> 1=<kbd>strongly agree</kbd>, 2=<kbd>agree</kbd>, 3=<kbd>neither agree or disagree</kbd>, 4=<kbd>disagree</kbd>, 5=<kbd>strongly disagree</kbd></p>
</dd>
<dt><code>B</code></dt><dd><p>&quot;a pre-school child suffers if his or her mother works&quot; <br /> 1=<kbd>strongly agree</kbd>, 2=<kbd>agree</kbd>, 3=<kbd>neither agree or disagree</kbd>, 4=<kbd>disagree</kbd>, 5=<kbd>strongly disagree</kbd></p>
</dd>
<dt><code>C</code></dt><dd><p>&quot;when a woman works the family life suffers&quot; <br /> 1=<kbd>strongly agree</kbd>, 2=<kbd>agree</kbd>, 3=<kbd>neither agree or disagree</kbd>, 4=<kbd>disagree</kbd>, 5=<kbd>strongly disagree</kbd></p>
</dd>
<dt><code>D</code></dt><dd><p>&quot;what women really want is a home and kids&quot; <br /> 1=<kbd>strongly agree</kbd>, 2=<kbd>agree</kbd>, 3=<kbd>neither agree or disagree</kbd>, 4=<kbd>disagree</kbd>, 5=<kbd>strongly agree</kbd></p>
</dd>
<dt><code>E</code></dt><dd><p>&quot;running a household is just as satisfying as a paid job&quot; <br /> 1=<kbd>strongly agree</kbd>, 2=<kbd>agree</kbd>, 3=<kbd>neither agree or disagree</kbd>, 4=<kbd>disagree</kbd>, 5=<kbd>strongly disagree</kbd></p>
</dd>
<dt><code>F</code></dt><dd><p>&quot;work is best for a woman's independence&quot; <br /> 1=<kbd>strongly agree</kbd>, 2=<kbd>agree</kbd>, 3=<kbd>neither agree or disagree</kbd>, 4=<kbd>disagree</kbd>, 5=<kbd>strongly disagree</kbd></p>
</dd>
<dt><code>G</code></dt><dd><p>&quot;a man's job is to work; a woman's job is the household&quot; <br /> 1=<kbd>strongly agree</kbd>, 2=<kbd>agree</kbd>, 3=<kbd>neither agree or disagree</kbd>, 4=<kbd>disagree</kbd>, 5=<kbd>strongly disagree</kbd></p>
</dd>
<dt><code>H</code></dt><dd><p>&quot;working women should get paid maternity leave&quot; <br /> 1=<kbd>strongly agree</kbd>, 2=<kbd>agree</kbd>, 3=<kbd>neither agree or disagree</kbd>, 4=<kbd>disagree</kbd>, 5=<kbd>strongly disagree</kbd></p>
</dd>
<dt><code>g</code></dt><dd><p>gender: 1=<kbd>male</kbd>, 2=<kbd>female</kbd></p>
</dd>
<dt><code>m</code></dt><dd><p>marital status: 1=<kbd>married/living as married</kbd>, 2=<kbd>widowed</kbd>, 3=<kbd>divorced</kbd>, 4=<kbd>separated, but married</kbd>, 5=<kbd>single, never married</kbd></p>
</dd>
<dt><code>e</code></dt><dd><p>education: 1=<kbd>no formal education</kbd>, 2=<kbd>lowest education</kbd>, 3=<kbd>above lowest education</kbd>, 4=<kbd>highest secondary completed</kbd>, 5=<kbd>above higher secondary level, below full university</kbd>, 6=<kbd>university degree completed</kbd></p>
</dd>
<dt><code>a</code></dt><dd><p>age: 1=<kbd>16-25 years</kbd>, 2=<kbd>26-35</kbd>, 3=<kbd>36-45</kbd>, 4=<kbd>46-55</kbd>, 5=<kbd>56-65</kbd>, 6=<kbd>66 and older</kbd></p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.econ.upf.edu/~michael/women_Spain2002_original.xls">http://www.econ.upf.edu/~michael/women_Spain2002_original.xls</a>
</p>


<h3>References</h3>

<p>Greenacre, M. J. (2010). <em>Biplots in practice</em>. Fundacion BBVA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(women)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
