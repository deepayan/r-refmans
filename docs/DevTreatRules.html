<!DOCTYPE html><html><head><title>Help for package DevTreatRules</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DevTreatRules}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BuildRule'><p>Build a Treatment Rule</p></a></li>
<li><a href='#CompareRulesOnValidation'><p>Build treatment rules on a development dataset and evaluate performance on an independent validation dataset</p></a></li>
<li><a href='#EvaluateRule'><p>Evaluate a Treatment Rule</p></a></li>
<li><a href='#obsStudyGeneExpressions'><p>Simulated dataset for package <code>DevTreatRule</code></p></a></li>
<li><a href='#PredictRule'><p>Get the treatment rule implied by <code>BuildRule()</code></p></a></li>
<li><a href='#SplitData'><p>Partition a dataset into independent subsets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Develop Treatment Rules with Observational Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Develop and evaluate treatment rules based on: (1) the standard indirect approach of split-regression, which fits regressions separately in both treatment groups and assigns an individual to the treatment option under which predicted outcome is more desirable; (2) the direct approach of outcome-weighted-learning proposed by Yingqi Zhao, Donglin Zeng, A. John Rush, and Michael Kosorok (2012) &lt;<a href="https://doi.org/10.1080%2F01621459.2012.695674">doi:10.1080/01621459.2012.695674</a>&gt;; (3) the direct approach, which we refer to as direct-interactions, proposed by Shuai Chen, Lu Tian, Tianxi Cai, and Menggang Yu (2017) &lt;<a href="https://doi.org/10.1111%2Fbiom.12676">doi:10.1111/biom.12676</a>&gt;. Please see the vignette for a walk-through of how to start with an observational dataset whose design is understood scientifically and end up with a treatment rule that is trustworthy statistically, along with an estimation of rule benefit in an independent sample.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, DynTxRegime, modelObj</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-20 15:22:59 UTC; jeremy</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeremy Roth [cre, aut],
  Noah Simon [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeremy Roth &lt;jhroth@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-20 17:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='BuildRule'>Build a Treatment Rule</h2><span id='topic+BuildRule'></span>

<h3>Description</h3>

<p>Perform principled development of a treatment rule (using the IPW approach to account for potential confounding) on a development dataset (i.e. training set) that is independent of datasets used for model selection (i.e. validation set) and rule evaluation (i.e. test set).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildRule(
  development.data,
  study.design,
  prediction.approach,
  name.outcome,
  type.outcome,
  name.treatment,
  names.influencing.treatment = NULL,
  names.influencing.rule,
  desirable.outcome,
  rule.method = NULL,
  propensity.method,
  additional.weights = rep(1, nrow(development.data)),
  truncate.propensity.score = TRUE,
  truncate.propensity.score.threshold = 0.05,
  type.observation.weights = NULL,
  propensity.k.cv.folds = 10,
  rule.k.cv.folds = 10,
  lambda.choice = c("min", "1se"),
  OWL.lambda.seq = NULL,
  OWL.kernel = "linear",
  OWL.kparam.seq = NULL,
  OWL.cvFolds = 10,
  OWL.verbose = TRUE,
  OWL.framework.shift.by.min = TRUE,
  direct.interactions.center.continuous.Y = TRUE,
  direct.interactions.exclude.A.from.penalty = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildRule_+3A_development.data">development.data</code></td>
<td>
<p>A data frame representing the *development* dataset (i.e. training set) used for building a treatment rule.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_study.design">study.design</code></td>
<td>
<p>Either &lsquo;observational&rsquo;, &lsquo;RCT&rsquo;, or &lsquo;naive&rsquo;. For the <code>observational</code> design, the function uses inverse-probability-of-treatment observation weights (IPW) based on estimated propensity scores with predictors <code>names.influencing.treatment</code>; for the <code>RCT</code> design, the function uses IPW based on propensity scores equal to the observed sample proportions; for the <code>naive</code> design, all observation weights will be uniformly equal to 1.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_prediction.approach">prediction.approach</code></td>
<td>
<p>One of &lsquo;split.regression&rsquo;, &lsquo;direct.interactions&rsquo;, &lsquo;OWL&rsquo;, or &lsquo;OWL.framework&rsquo;.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_name.outcome">name.outcome</code></td>
<td>
<p>A character indicating the name of the outcome variable in <code>development.data</code>.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_type.outcome">type.outcome</code></td>
<td>
<p>Either &lsquo;binary&rsquo; or &lsquo;continuous&rsquo;, the form of <code>name.outcome</code>.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_name.treatment">name.treatment</code></td>
<td>
<p>A character indicating the name of the treatment variable in <code>development.data</code>.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_names.influencing.treatment">names.influencing.treatment</code></td>
<td>
<p>A character vector (or single element) indicating the names of the variables in <code>development.data</code> that are expected to influence treatment assignment in the current dataset. Required for <code>study.design=</code>&lsquo;observational&rsquo;.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_names.influencing.rule">names.influencing.rule</code></td>
<td>
<p>A character vector (or single element) indicating the names of the variables in <code>development.data</code> that may influence response to treatment and are expected to be observed in future clinical settings.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_desirable.outcome">desirable.outcome</code></td>
<td>
<p>A logical equal to <code>TRUE</code> if higher values of the outcome are considered desirable (e.g. for a binary outcome, a 1 is more desirable than a 0). The <code>OWL.framework</code> and <code>OWL</code> prediction approaches require a desirable outcome.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_rule.method">rule.method</code></td>
<td>
<p>One of &lsquo;glm.regression&rsquo;, &lsquo;lasso&rsquo;, or &lsquo;ridge&rsquo;. For <code>type.outcome=</code>&lsquo;binary&rsquo;, &lsquo;glm.regression&rsquo; leads to logistic regression; for a <code>type.outcome=</code>&lsquo;continuous&rsquo;, &lsquo;glm.regression&rsquo; specifies linear regression. This is the underlying regression model used to develop the treatment rule.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_propensity.method">propensity.method</code></td>
<td>
<p>One of &lsquo;logistic.regression&rsquo;, &lsquo;lasso&rsquo;, or &lsquo;ridge&rsquo;. This is the underlying regression model used to estimate propensity scores for <code>study.design=</code>&lsquo;observational&rsquo;.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_additional.weights">additional.weights</code></td>
<td>
<p>A numeric vector of observation weights that will be multiplied by IPW weights in the rule development stage, with length equal to the number of rows in <code>development.data</code>. This can be used, for example, to account for a non-representative sampling design or to apply an IPW adjustment for missingness. The default is a vector of 1s.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_truncate.propensity.score">truncate.propensity.score</code></td>
<td>
<p>A logical variable dictating whether estimated propensity scores less than <code>truncate.propensity.score.threshold</code> away from 0 or 1 should be truncated to be no more than <code>truncate.propensity.score.threshold</code> away from 0 or 1.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_truncate.propensity.score.threshold">truncate.propensity.score.threshold</code></td>
<td>
<p>A numeric value between 0 and 0.25.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_type.observation.weights">type.observation.weights</code></td>
<td>
<p>Default is NULL, but other choices are &lsquo;IPW.L&rsquo;, &lsquo;IPW.L.and.X&rsquo;, and &lsquo;IPW.ratio&rsquo;, where L indicates <code>names.influencing.treatment</code>, X indicates <code>names.influencing.rule</code>. The default behavior is to use the &lsquo;IPW.ratio&rsquo; observation weights (propensity score based on X divided by propensity score based on L and X) for <code>prediction.approach=</code>&lsquo;split.regression&rsquo; and to use &lsquo;IPW.L&rsquo; observation weights (inverse of propensity score based on L) for the &lsquo;direct.interactions&rsquo;, &lsquo;OWL&rsquo;, and &lsquo;OWL.framework&rsquo; prediction approaches.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_propensity.k.cv.folds">propensity.k.cv.folds</code></td>
<td>
<p>An integer specifying how many folds to use for K-fold cross-validation that chooses the tuning parameters when <code>propensity.method</code> is &lsquo;lasso&rsquo; or &lsquo;ridge&rsquo;. Default is 10.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_rule.k.cv.folds">rule.k.cv.folds</code></td>
<td>
<p>An integer specifying how many folds to use for K-fold cross-validation that chooses the tuning parameter when <code>rule.method</code> is <code>lasso</code> or &lsquo;ridge&rsquo;. Default is 10.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_lambda.choice">lambda.choice</code></td>
<td>
<p>Either &lsquo;min&rsquo; or &lsquo;1se&rsquo;, corresponding to the <code>s</code> argument in <code>predict.cv.glmnet()</code> from the <code>glmnet</code> package. Only used when <code>propensity.method</code> or <code>rule.method</code> is &lsquo;lasso&rsquo; or &lsquo;ridge&rsquo;. Default is &lsquo;min&rsquo;.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_owl.lambda.seq">OWL.lambda.seq</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo;, a numeric vector that corresponds to the <code>lambdas</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Defaults to <code>2^seq(-5, 5, 1)</code>.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_owl.kernel">OWL.kernel</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo;, a character equal to either &lsquo;linear&rsquo; or &lsquo;radial&rsquo;. Corresponds to the <code>kernel</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Default is &lsquo;linear&rsquo;.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_owl.kparam.seq">OWL.kparam.seq</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo; and <code>OWL.kernel=</code>&lsquo;radial&rsquo;.  Corresponds to the <code>kparam</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Defaults to <code>2^seq(-10, 10, 1)</code>.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_owl.cvfolds">OWL.cvFolds</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo;, an integer corresponding to the <code>cvFolds</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Defaults to 10.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_owl.verbose">OWL.verbose</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo;, a logical corresponding to the <code>verbose</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_owl.framework.shift.by.min">OWL.framework.shift.by.min</code></td>
<td>
<p>Logical, set to <code>TRUE</code> by default in recognition of our empirical observation that, with a continuous outcome, OWL framework performs far better in simulation studies when the outcome was shifted to have a minimum of just above 0.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_direct.interactions.center.continuous.y">direct.interactions.center.continuous.Y</code></td>
<td>
<p>Logical, set to <code>TRUE</code> by default in recognition of our empirical observation that, with a continuous outcome, direct-interactions performed far better in simulation studies when the outcome was mean-centered.</p>
</td></tr>
<tr><td><code id="BuildRule_+3A_direct.interactions.exclude.a.from.penalty">direct.interactions.exclude.A.from.penalty</code></td>
<td>
<p>Logical, set to <code>TRUE</code> by default in recognition of our empirical observation that, with a continuous outcome and lasso/ridge used specified as the <code>rule.method</code>, direct-interactions performed far better in simulation studies when the coefficient corresponding to the treatment variable was excluded from the penalty function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some combination of the following components (depending on specified <code>prediction.approach</code>)
</p>

<ul>
<li> <p><code>type.outcome</code>: The <code>type.outcome</code> specified above (used by other functions that are based on <code>BuildRule()</code>)
</p>
</li>
<li> <p><code>prediction.approach</code>: The <code>prediction.approach</code> specified above (used by other functions that are based on <code>BuildRule()</code>)
</p>
</li>
<li> <p><code>rule.method</code>: The <code>rule.method</code> specified above (used by other functions that are based on <code>BuildRule()</code>)
</p>
</li>
<li> <p><code>lambda.choice</code>: The <code>lambda.choice</code> specified above (used by other functions that are based on <code>BuildRule()</code>)
</p>
</li>
<li> <p><code>propensity.score.object</code>: A list containing the relevant regression object from propensity score estimation. The list has two elements for <code>type.observation.weights=</code>&lsquo;IPW.ratio&rsquo; (the default for <code>prediction.approach=</code>&lsquo;split.regression&rsquo;), has one element for <code>type.observation.weights=</code>&lsquo;IPW.L&rsquo; (the default for &lsquo;OWL&rsquo;, &lsquo;OWL.framework&rsquo; and &lsquo;direct.interactions&rsquo;), has one element when <code>type.observation.weights=</code>&lsquo;IPW.L.and.X&rsquo;, and is simply equal to NA if <code>study.design=</code>&lsquo;RCT&rsquo; (in which case propensity score would just be the inverse of sample proportion receiving treatment).
</p>
</li>
<li> <p><code>owl.object</code>: For <code>prediction.approach=</code>&lsquo;OWL&rsquo; only, the object returned by the <code>owl()</code> function in the <code>DynTxRegime</code> package.
</p>
</li>
<li> <p><code>observation.weights</code>: The observation weights used for estimating the treatment rule
</p>
</li>
<li> <p><code>rule.object</code>: For <code>prediction.approach=</code>&lsquo;OWL.framework&rsquo; or <code>prediction.approach=</code>&lsquo;direct.interactions&rsquo;, the regression object returned from treatment rule estimation (to which the <code>coef()</code> function could be applied, for example)
</p>
</li>
<li> <p><code>rule.object.control</code>: For <code>prediction.approach=</code>&lsquo;split.regression&rsquo; the regression object returned from treatment rule estimation (to which the <code>coef()</code> function could be applied, for example) that estimates the outcome variable for individuals who do not receive treatment.
</p>
</li>
<li> <p><code>rule.object.treatment</code>: For <code>prediction.approach=</code>&lsquo;split.regression&rsquo; the regression object returned from treatment rule estimation (to which the <code>coef()</code> function could be applied, for example) that estimates the outcome variable for individuals who do receive treatment.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Yingqi Zhao, Donglin Zeng, A. John Rush &amp; Michael R. Kosorok  (2012)
Estimating individualized treatment rules using outcome weighted learning.
Journal of the American Statistical Association,
107:499 1106&ndash;1118.
</p>
</li>
<li><p> Shuai Chen, Lu Tian, Tianxi Cai, Menggang Yu (2017)
A general statistical framework for subgroup identification and comparative treatment scoring.
Biometrics,
73:4: 1199&ndash;1209.
</p>
</li>
<li><p> Lu Tian, Ash A. Alizadeh, Andrew J. Gentles, Robert Tibshirani (2014)
A simple method for estimating interactions between a treatment and a large number of covariates.
Journal of the American Statistical Association,
109:508: 1517&ndash;1532.
</p>
</li>
<li><p> Jeremy Roth and Noah Simon (2019).
Using propensity scores to develop and evaluate treatment rules with observational data
(Manuscript in progress)
</p>
</li>
<li><p> Jeremy Roth and Noah Simon (2019).
Elucidating outcome-weighted learning and its comparison to split-regression: direct vs. indirect methods in practice.
(Manuscript in progress)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
example.split &lt;- SplitData(data=obsStudyGeneExpressions,
                                     n.sets=3, split.proportions=c(0.5, 0.25, 0.25))
development.data &lt;- example.split[example.split$partition == "development",]
one.rule &lt;- BuildRule(development.data=development.data,
                     study.design="observational",
                     prediction.approach="split.regression",
                     name.outcome="no_relapse",
                     type.outcome="binary",
                     desirable.outcome=TRUE,
                     name.treatment="intervention",
                     names.influencing.treatment=c("prognosis", "clinic", "age"),
                     names.influencing.rule=c("age", paste0("gene_", 1:10)),
                     propensity.method="logistic.regression",
                     rule.method="glm.regression")
coef(one.rule$rule.object.control)
coef(one.rule$rule.object.treatment)
</code></pre>

<hr>
<h2 id='CompareRulesOnValidation'>Build treatment rules on a development dataset and evaluate performance on an independent validation dataset</h2><span id='topic+CompareRulesOnValidation'></span>

<h3>Description</h3>

<p>In many practical settings, <code>BuildRule()</code> has limited utility because it requires the specification of a single value in its  <code>prediction.approach</code> argument (even if there is no prior knowledge about which of the split-regression, OWL framework, and direct-interactions approaches will perform best) and a single value for the 'propensity.score' and 'rule.method' arguments (even if there is no prior knowledge about whether standard or penalized GLM will perform best). <code>CompareRulesOnValidation()</code> supports model selection in these settings by  essentially looping over calls to <code>BuildRule()</code> for different combinations of split-regression/OWL framework/direct-interactions and standard/lasso/ridge regression to simultaneously build the rules on a development dataset and evaluate them on an independent validation dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareRulesOnValidation(
  development.data,
  validation.data,
  vec.approaches = c("split.regression", "OWL.framework", "direct.interactions"),
  vec.rule.methods = c("glm.regression", "lasso", "ridge"),
  vec.propensity.methods = "logistic.regression",
  study.design.development,
  name.outcome.development,
  type.outcome.development,
  name.treatment.development,
  names.influencing.treatment.development,
  names.influencing.rule.development,
  desirable.outcome.development,
  additional.weights.development = rep(1, nrow(development.data)),
  study.design.validation = study.design.development,
  name.outcome.validation = name.outcome.development,
  type.outcome.validation = type.outcome.development,
  name.treatment.validation = name.treatment.development,
  names.influencing.treatment.validation = names.influencing.treatment.development,
  names.influencing.rule.validation = names.influencing.rule.development,
  desirable.outcome.validation = desirable.outcome.development,
  clinical.threshold.validation = 0,
  propensity.method.validation = "logistic.regression",
  additional.weights.validation = rep(1, nrow(validation.data)),
  truncate.propensity.score = TRUE,
  truncate.propensity.score.threshold = 0.05,
  type.observation.weights = NULL,
  propensity.k.cv.folds = 10,
  rule.k.cv.folds = 10,
  lambda.choice = c("min", "1se"),
  OWL.lambda.seq = NULL,
  OWL.kernel = "linear",
  OWL.kparam.seq = NULL,
  OWL.cvFolds = 10,
  OWL.verbose = TRUE,
  OWL.framework.shift.by.min = TRUE,
  direct.interactions.center.continuous.Y = TRUE,
  direct.interactions.exclude.A.from.penalty = TRUE,
  bootstrap.CI = FALSE,
  bootstrap.CI.replications = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareRulesOnValidation_+3A_development.data">development.data</code></td>
<td>
<p>A data frame representing the *development* dataset used to build treatment rules.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_validation.data">validation.data</code></td>
<td>
<p>A data frame representing the independent *validation* dataset used to estimate the performance of treatment rules built on the development dataset.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_vec.approaches">vec.approaches</code></td>
<td>
<p>A character vector (or element) indicating the values of the <code>prediction.approach</code> to be used for building the rule with <code>BuildRule()</code>. Default is <code>c(`split.regression', `OWL.framework', `direct.interactions')</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_vec.rule.methods">vec.rule.methods</code></td>
<td>
<p>A character vector (or element) indicating the values of the <code>rule.method</code> to be used for building the rule with <code>BuildRule()</code>. Default is <code>c(`glm.regression', `lasso', `ridge')</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_vec.propensity.methods">vec.propensity.methods</code></td>
<td>
<p>A character vector (or element) indicating the values of <code>propensity.method</code> to be used for building the rule with <code>Build.Rule()</code>. Default is &lsquo;logistic.regression&rsquo; to allow for estimation of bootstrap-based CIs.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_study.design.development">study.design.development</code></td>
<td>
<p>Either &lsquo;observational&rsquo;, &lsquo;RCT&rsquo;, or &lsquo;naive&rsquo;, representing the study design on the development dataset. For the <code>observational</code> design, the function will use inverse-probability-of-treatment observation weights (IPW) based on estimated propensity scores with predictors <code>names.influencing.treatment</code>; for the <code>RCT</code> design, the function will use IPW based on propensity scores equal to the observed sample proportions; for the <code>naive</code> design, all observation weights will be uniformly equal to 1.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_name.outcome.development">name.outcome.development</code></td>
<td>
<p>A character indicating the name of the outcome variable in <code>development.data</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_type.outcome.development">type.outcome.development</code></td>
<td>
<p>Either &lsquo;binary&rsquo; or &lsquo;continuous&rsquo;, the form of <code>name.outcome.development</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_name.treatment.development">name.treatment.development</code></td>
<td>
<p>A character indicating the name of the treatment variable in <code>development.data</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_names.influencing.treatment.development">names.influencing.treatment.development</code></td>
<td>
<p>A character vector (or element) indicating the names of the variables in <code>development.data</code> that are expected to influence treatment assignment in the current dataset. Required for <code>study.design.development=</code>&lsquo;observational&rsquo;.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_names.influencing.rule.development">names.influencing.rule.development</code></td>
<td>
<p>A character vector (or element) indicating the names of the variables in <code>development.data</code> that may influence response to treatment and are expected to be observed in future clinical settings.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_desirable.outcome.development">desirable.outcome.development</code></td>
<td>
<p>A logical equal to <code>TRUE</code> if higher values of the outcome on <code>development,data</code> are considered desirable (e.g. for a binary outcome, a 1 is more desirable than a 0). The <code>OWL.framework</code> and <code>OWL</code> prediction approaches require a desirable outcome.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_additional.weights.development">additional.weights.development</code></td>
<td>
<p>A numeric vector of observation weights that will be multiplied by IPW weights in the rule development stage, with length equal to the number of rows in <code>development.data</code>. This can be used, for example, to account for a non-representative sampling design or an IPW adjustment for missingness. The default is a vector of 1s.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_study.design.validation">study.design.validation</code></td>
<td>
<p>Either &lsquo;observational&rsquo;, &lsquo;RCT&rsquo;, or &lsquo;naive&rsquo;,representing the study design on the development dataset. Default is the value of <code>study.design.development</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_name.outcome.validation">name.outcome.validation</code></td>
<td>
<p>A character indicating the name of the outcome variable in <code>validation.data</code>. Default is the value of <code>name.outcome.development</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_type.outcome.validation">type.outcome.validation</code></td>
<td>
<p>Either &lsquo;binary&rsquo; or &lsquo;continuous&rsquo;, the form of <code>name.outcome.validation</code>. Default is the value of <code>type.outcome.development</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_name.treatment.validation">name.treatment.validation</code></td>
<td>
<p>A character indicating the name of the treatment variable in <code>validation.data</code>. Default is the value of <code>name.treatment.development</code></p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_names.influencing.treatment.validation">names.influencing.treatment.validation</code></td>
<td>
<p>A character vector (or element) indicating the names of the variables in <code>validation.data</code> that are expected to influence treatment assignment in <code>validation.data</code>. Required for Required for <code>study.design.validation=</code>&lsquo;observational&rsquo;. Default is the value of <code>names.influencing.treatment.development</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_names.influencing.rule.validation">names.influencing.rule.validation</code></td>
<td>
<p>A character vector (or element) indicating the names of the variables in <code>validation.data</code> that may influence response to treatment and are expected to be observed in future clinical settings. Default is the value of <code>names.influencing.rule.development</code></p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_desirable.outcome.validation">desirable.outcome.validation</code></td>
<td>
<p>A logical equal to <code>TRUE</code> if higher values of the outcome on <code>validation,data</code>  are considered desirable (e.g. for a binary outcome, a 1 is more desirable than a 0). The <code>OWL.framework</code> and <code>OWL</code> prediction approaches require a desirable outcome. Default is the value of <code>desirable.outcome.development</code></p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_clinical.threshold.validation">clinical.threshold.validation</code></td>
<td>
<p>A numeric equal to a positive number above which the predicted outcome under treatment must be superior to the predicted outcome under control for treatment to be recommended. Only used when <code>BuildRuleObject</code> was specified and derived from the split-regression or direct-interactions approach. Default is 0.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_propensity.method.validation">propensity.method.validation</code></td>
<td>
<p>One of &lsquo;logistic.regression&rsquo;, &lsquo;lasso&rsquo;, or &lsquo;ridge&rsquo;. This is the underlying regression model used to estimate propensity scores (for <code>study.design=</code>&lsquo;observational&rsquo; on <code>validation.data</code>. If <code>bootstrap.CI=TRUE</code>, then <code>propensity.method</code> must be &lsquo;logistic.regression&rsquo;. Default is &lsquo;logistic.regression&rsquo; to allow for estimation of bootstrap-based CIs.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_additional.weights.validation">additional.weights.validation</code></td>
<td>
<p>A numeric vector of observation weights that will be multiplied by IPW weights in the rule evaluation stage, with length equal to the number of rows in <code>validation.data</code>. This can be used, for example, to account for a non-representative sampling design or an IPW adjustment for missingness. The default is a vector of 1s.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_truncate.propensity.score">truncate.propensity.score</code></td>
<td>
<p>A logical variable dictating whether estimated propensity scores less than <code>truncate.propensity.score.threshold</code> away from 0 or 1 should be truncated to be <code>truncate.propensity.score.threshold</code> away from 0 or 1.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_truncate.propensity.score.threshold">truncate.propensity.score.threshold</code></td>
<td>
<p>A numeric value between 0 and 0.25.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_type.observation.weights">type.observation.weights</code></td>
<td>
<p>Default is NULL, but other choices are &lsquo;IPW.L&rsquo;, &lsquo;IPW.L.and.X&rsquo;, and &lsquo;IPW.ratio&rsquo;, where L indicates the <code>names.influencing.treatment</code> variables, X indicates the <code>names.influencing.rule</code> variables. The default behavior is to use the &lsquo;IPW.ratio&rsquo; observation weights (propensity score based on X divided by propensity score based on L and X) for <code>prediction.approach=</code>&lsquo;split.regression&rsquo; and to use &lsquo;IPW.L&rsquo; observation weights (inverse of propensity score based on L) for the &lsquo;direct.interactions&rsquo;, &lsquo;OWL&rsquo;, and &lsquo;OWL.framework&rsquo; prediction approaches.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_propensity.k.cv.folds">propensity.k.cv.folds</code></td>
<td>
<p>An integer specifying how many folds to use for K-fold cross-validation that chooses the tuning parameter when <code>propensity.method</code> is &lsquo;lasso&rsquo; or &lsquo;ridge&rsquo;. Default is 10.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_rule.k.cv.folds">rule.k.cv.folds</code></td>
<td>
<p>An integer specifying how many folds to use for K-fold cross-validation that chooses the tuning parameter when <code>rule.method</code> is <code>lasso</code> or &lsquo;ridge&rsquo;. Default is 10.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_lambda.choice">lambda.choice</code></td>
<td>
<p>Either &lsquo;min&rsquo; or &lsquo;1se&rsquo;, corresponding to the <code>s</code> argument in <code>predict.cv.glmnet()</code> from the <code>glmnet</code> package. Only used when <code>propensity.method</code> or <code>rule.method</code> is &lsquo;lasso&rsquo; or &lsquo;ridge&rsquo;. Default is &lsquo;min&rsquo;.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_owl.lambda.seq">OWL.lambda.seq</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo;, a numeric vector that corresponds to the <code>lambdas</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Defaults to <code>2^seq(-5, 5, 1)</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_owl.kernel">OWL.kernel</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo;, a character equal to either &lsquo;linear&rsquo; or &lsquo;radial&rsquo;. Corresponds to the <code>kernel</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Default is &lsquo;linear&rsquo;.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_owl.kparam.seq">OWL.kparam.seq</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo; and <code>OWL.kernel=</code>&lsquo;radial&rsquo;.  Corresponds to the <code>kparam</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Defaults to <code>2^seq(-10, 10, 1)</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_owl.cvfolds">OWL.cvFolds</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo;, an integer corresponding to the <code>cvFolds</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Defaults to 10.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_owl.verbose">OWL.verbose</code></td>
<td>
<p>Used when <code>prediction.approach=</code>&lsquo;OWL&rsquo;, a logical corresponding to the <code>verbose</code> argument in the <code>owl()</code> function from the <code>DynTxRegime</code> package. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_owl.framework.shift.by.min">OWL.framework.shift.by.min</code></td>
<td>
<p>Logical, set to <code>TRUE</code> by default in recognition of our empirical observation that, with a continuous outcome, OWL framework performs far better in simulation studies when the outcome was shifted to have a minimum of just above 0.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_direct.interactions.center.continuous.y">direct.interactions.center.continuous.Y</code></td>
<td>
<p>Logical, set to <code>TRUE</code> by default in recognition of our empirical observation that, with a continuous outcome, direct-interactions performed far better in simulation studies when the outcome was mean-centered.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_direct.interactions.exclude.a.from.penalty">direct.interactions.exclude.A.from.penalty</code></td>
<td>
<p>Logical, set to <code>TRUE</code> by default in recognition of our empirical observation that, with a continuous outcome and lasso/ridge used specified as the <code>rule.method</code>, direct-interactions performed far better in simulation studies when the coefficient corresponding to the treatment variable was excluded from the penalty function.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_bootstrap.ci">bootstrap.CI</code></td>
<td>
<p>Logical indicating whether the ATE/ABR estimates on the validation set should be accompanied by 95% confidence intervals based on the bootstrap. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CompareRulesOnValidation_+3A_bootstrap.ci.replications">bootstrap.CI.replications</code></td>
<td>
<p>An integer specifying how many bootstrap replications should underlie the computed CIs. Default is 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li> <p><code>list.summaries</code>: A list with number of elements equal to the length of <code>vec.approaches</code>. Each element is a matrix that, for a given prediction approach, shows estimated rule performance with 5 columns if <code>bootstrap.CI=FALSE</code>  (number of test-positives, number of test-negatives, ATE in test-positives, ATE in test-negatives, ABR) for the different combinations of <code>vec.rule.methods</code> or 9 columns if <code>bootstrap.CI=TRUE</code> (those same 5 summaries plus the bounds for 95% CIs for ATE in test-positives and ATE in test-negatives) and, in the rows, the <code>vec.propensity.methods</code> in addition to the two naive rules (treating all observations and treating no observations).
</p>
</li>
<li> <p><code>list.rules</code>: A list with number of elements equal to the length of <code>vec.approaches</code>. Each element is another list that, for a given prediction approach, stores the object returned by <code>BuildRule()</code> for the different combinations of <code>vec.rule.methods</code> and <code>vec.propensity.methods</code> in the rows.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
example.split &lt;- SplitData(data=obsStudyGeneExpressions,
                                    n.sets=3, split.proportions=c(0.5, 0.25, 0.25))
development.data &lt;- example.split[example.split$partition == "development", ]
validation.data &lt;- example.split[example.split$partition == "validation", ]
model.selection &lt;- CompareRulesOnValidation(development.data=development.data,
               validation.data=validation.data,
               study.design.development="observational",
               vec.approaches=c("split.regression", "OWL.framework", "direct.interactions"),
               vec.rule.methods=c("glm.regression", "lasso"),
               vec.propensity.methods="logistic.regression",
               name.outcome.development="no_relapse",
               type.outcome.development="binary",
               name.treatment.development="intervention",
               names.influencing.treatment.development=c("prognosis", "clinic", "age"),
               names.influencing.rule.development=c("age", paste0("gene_", 1:10)),
               desirable.outcome.development=TRUE)
model.selection$list.summaries$split.regression
</code></pre>

<hr>
<h2 id='EvaluateRule'>Evaluate a Treatment Rule</h2><span id='topic+EvaluateRule'></span>

<h3>Description</h3>

<p>Perform principled evaluation of a treatment rule (using the IPW approach to account for potential confounding) on a dataset that is independent of the development dataset on which the rule was developed, either to perform model selection (with a validation dataset) or to obtain trustworthy estimates of performance for a pre-specified treatment rule (with an evaluation dataset).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvaluateRule(
  evaluation.data,
  BuildRule.object = NULL,
  B = NULL,
  study.design,
  name.outcome,
  type.outcome,
  desirable.outcome,
  separate.propensity.estimation = TRUE,
  clinical.threshold = 0,
  name.treatment,
  names.influencing.treatment,
  names.influencing.rule,
  propensity.method = NULL,
  show.treat.all = TRUE,
  show.treat.none = TRUE,
  truncate.propensity.score = TRUE,
  truncate.propensity.score.threshold = 0.05,
  observation.weights = NULL,
  additional.weights = rep(1, nrow(evaluation.data)),
  lambda.choice = c("min", "1se"),
  propensity.k.cv.folds = 10,
  bootstrap.CI = FALSE,
  bootstrap.CI.replications = 1000,
  bootstrap.type = "basic"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvaluateRule_+3A_evaluation.data">evaluation.data</code></td>
<td>
<p>A data frame representing the *validation* or *evaluation* dataset used to estimate the performance of a rule that was developed on an independent development dataset.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_buildrule.object">BuildRule.object</code></td>
<td>
<p>The object returned by the <code>BuildRule()</code> function. Defaults to NULL but is required if a treatment rule is not provided in the <code>B</code> argument. Only one of <code>BuildRule.object</code> and <code>B</code> should be specified.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_b">B</code></td>
<td>
<p>A numeric vector representing a pre-specified treatment rule, which must have length equal to the number of rows in <code>evaluation.data</code> and elements equal to <code>0/FALSE</code> indicating no treatment and <code>1/TRUE</code> indicating treatment. Defaults to <code>NULL</code> but is required if <code>BuildRule.object</code> is not specified.  Only one of <code>BuildRule.object</code> and <code>B</code> should be specified.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_study.design">study.design</code></td>
<td>
<p>Either &lsquo;observational&rsquo;, &lsquo;RCT&rsquo;, or &lsquo;naive&rsquo;. For the <code>observational</code> design, the function will use inverse-probability-of-treatment observation weights (IPW) based on estimated propensity scores with predictors <code>names.influencing.treatment</code>; for the <code>RCT</code> design, the function will use IPW based on propensity scores equal to the observed sample proportions; for the <code>naive</code> design, all observation weights will be uniformly equal to 1.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_name.outcome">name.outcome</code></td>
<td>
<p>A character indicating the name of the outcome variable in <code>evaluation.data</code>.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_type.outcome">type.outcome</code></td>
<td>
<p>Either &lsquo;binary&rsquo; or &lsquo;continuous&rsquo;, the form of <code>name.outcome</code>.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_desirable.outcome">desirable.outcome</code></td>
<td>
<p>A logical equal to <code>TRUE</code> if higher values of the outcome are considered desirable (e.g. for a binary outcome, 1 is more desirable than 0). The <code>OWL.framework</code> and <code>OWL</code> approaches to treatment rule estimation require a desirable outcome.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_separate.propensity.estimation">separate.propensity.estimation</code></td>
<td>
<p>A logical equal to <code>TRUE</code> if propensity scores should be estimated separately in the test-positives and test-negatives subpopulations and equal to <code>FALSE</code> if propensity scores should be estimated in the combined sample. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_clinical.threshold">clinical.threshold</code></td>
<td>
<p>A numeric equal to a positive number above which the predicted outcome under treatment must be superior to the predicted outcome under control for treatment to be recommended. Only used when <code>BuildRuleObject</code> was specified and derived from the split-regression or direct-interactions approach. Default is 0.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_name.treatment">name.treatment</code></td>
<td>
<p>A character indicating the name of the treatment variable in <code>evaluation.data</code>.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_names.influencing.treatment">names.influencing.treatment</code></td>
<td>
<p>A character vector (or element) indicating the names of the variables in <code>evaluation.data</code> that are expected to influence treatment assignment in the current dataset. Required for <code>study.design=</code>&lsquo;observational&rsquo;.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_names.influencing.rule">names.influencing.rule</code></td>
<td>
<p>A character vector (or element) indicating the names of the variables in <code>evaluation.data</code> that may influence response to treatment and are expected to be observed in future clinical settings.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_propensity.method">propensity.method</code></td>
<td>
<p>One of&lsquo;logistic.regression&rsquo;, &lsquo;lasso&rsquo;, or &lsquo;ridge&rsquo;. This is the underlying regression model used to estimate propensity scores (for <code>study.design=</code>&lsquo;observational&rsquo;. If <code>bootstrap.CI=TRUE</code>, then <code>propensity.method</code> must be &lsquo;logistic.regression&rsquo;. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_show.treat.all">show.treat.all</code></td>
<td>
<p>A logical variable dictating whether summaries for the naive rule that assigns treatment to all observations are reported, which help put the performance of the estimated treatment rule in context. Default is TRUE</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_show.treat.none">show.treat.none</code></td>
<td>
<p>A logical variable dictating whether summaries for the naive rule that assigns treatment to no observations are reported, which help put the performance of the estimated treatment rule in context. Default is TRUE</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_truncate.propensity.score">truncate.propensity.score</code></td>
<td>
<p>A logical variable dictating whether estimated propensity scores less than <code>truncate.propensity.score.threshold</code> away from 0 or 1 should be truncated to be <code>truncate.propensity.score.threshold</code> away from 0 or 1.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_truncate.propensity.score.threshold">truncate.propensity.score.threshold</code></td>
<td>
<p>A numeric value between 0 and 0.25.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_observation.weights">observation.weights</code></td>
<td>
<p>A numeric vector equal to the number of rows in <code>evaluation.data</code> that provides observation weights to be used in place of the IPW weights estimated with <code>propensity.method</code>. Defaults to NULL. Only one of the <code>propensity.method</code> and <code>observation.weights</code> should be specified.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_additional.weights">additional.weights</code></td>
<td>
<p>A numeric vector of observation weights that will be multiplied by IPW weights in the rule evaluation stage, with length equal to the number of rows in <code>evaluation.data</code>.. This can be used, for example, to account for a non-representative sampling design or to apply an IPW adjustment for missingness. The default is a vector of 1s.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_lambda.choice">lambda.choice</code></td>
<td>
<p>Either &lsquo;min&rsquo; or &lsquo;1se&rsquo;, corresponding to the <code>s</code> argument in <code>predict.cv.glmnet()</code> from the <code>glmnet</code> package; only used when <code>propensity.method</code> or <code>rule.method</code> is &lsquo;lasso&rsquo; or &lsquo;ridge&rsquo;. Default is &lsquo;min&rsquo;.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_propensity.k.cv.folds">propensity.k.cv.folds</code></td>
<td>
<p>An integer dictating how many folds to use for K-fold cross-validation that chooses the tuning parameter when <code>propensity.method</code> is &lsquo;lasso&rsquo; or &lsquo;ridge&rsquo;. Default is 10.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_bootstrap.ci">bootstrap.CI</code></td>
<td>
<p>Logical indicating whether the ATE/ABR estimates returned by <code>EvaluateRule()</code> should be accompanied by 95% confidence intervals based on the bootstrap. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_bootstrap.ci.replications">bootstrap.CI.replications</code></td>
<td>
<p>An integer specifying how many bootstrap replications should underlie the computed CIs. Default is 1000.</p>
</td></tr>
<tr><td><code id="EvaluateRule_+3A_bootstrap.type">bootstrap.type</code></td>
<td>
<p>One character element specifying the type of bootstrap CI that should be computed. Currently the only supported option is <code>bootstrap.type=</code>&lsquo;basic&rsquo;, but this may be expanded in the future.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>

<ul>
<li> <p><code>recommended.treatment</code>: A numeric vector of 0s and 1s, with length equal to the number of rows in <code>evaluation.data</code>, where a 0 indicates treatment is not recommended and a 1 indicates treatment is recommended for the corresponding observation in <code>evaluation.data</code>.
</p>
</li>
<li> <p><code>fit.object</code>: A list consisting of one of the following: the propensity scores estimated in the test-positives and in the test-negatives (if <code>separate.propensity.estimation=TRUE</code>, <code>study.design=</code>&lsquo;observational&rsquo;, and <code>observation.weights=NULL</code>); the propensity scores estimated in the combined sample (if <code>separate.propensity.estimation=FALSE</code>, <code>study.design=</code>&lsquo;observational&rsquo;, and <code>observation.weights=NULL</code>); and simply is simply null if <code>study.design=</code>&lsquo;RCT&rsquo; (in which case propensity score would just be the inverse of the sample proportion receiving treatment)
</p>
</li>
<li> <p><code>summaries</code>: a matrix with columns reporting the following summaries of treatment rule performance: the number of observations in <code>evaluation.data</code> recommended to receive treatment. (<code>n.positives</code>); the estimated average treatment effect among those recommended to receive treatment (<code>ATE.positives</code>); the number of observations in <code>evaluation.data</code> recommended to not receive treatment (<code>n.negatives</code>); the estimated average treatment effect among those recommended to not receive treatment (<code>ATE.negatives</code>); the estimated average benefit of using the rule, with the weighted average of ATE.positives and -1 * ATE.negatives where weights are the proportions of test-positives and test-negatives (<code>ABR</code>). If <code>bootstrap.CI=TRUE</code>, then 4 additional columns are included, showing the lower bound (LB) and upper bound (UB) of the 95% CIs for <code>ATE.positives</code> and <code>ATE.negatives</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
example.split &lt;- SplitData(data=obsStudyGeneExpressions,
                                     n.sets=3, split.proportions=c(0.5, 0.25, 0.25))
development.data &lt;- example.split[example.split$partition == "development",]
validation.data &lt;- example.split[example.split$partition == "validation",]
one.rule &lt;- BuildRule(development.data=development.data,
                     study.design="observational",
                     prediction.approach="split.regression",
                     name.outcome="no_relapse",
                     type.outcome="binary",
                     desirable.outcome=TRUE,
                     name.treatment="intervention",
                     names.influencing.treatment=c("prognosis", "clinic", "age"),
                     names.influencing.rule=c("age", paste0("gene_", 1:10)),
                     propensity.method="logistic.regression",
                     rule.method="glm.regression")
split.validation &lt;- EvaluateRule(evaluation.data=validation.data,
                          BuildRule.object=one.rule,
                          study.design="observational",
                          name.outcome="no_relapse",
                          type.outcome="binary",
                          desirable.outcome=TRUE,
                          name.treatment="intervention",
                          names.influencing.treatment=c("prognosis", "clinic", "age"),
                          names.influencing.rule=c("age", paste0("gene_", 1:10)),
                          propensity.method="logistic.regression",
                          bootstrap.CI=FALSE)
split.validation[c("n.positives", "n.negatives",
                       "ATE.positives", "ATE.negatives", "ABR")]
</code></pre>

<hr>
<h2 id='obsStudyGeneExpressions'>Simulated dataset for package <code>DevTreatRule</code></h2><span id='topic+obsStudyGeneExpressions'></span>

<h3>Description</h3>

<p>Simulated observational dataset reporting an indicator of remaining relapse-free at the end of the study period (clinical outcome) along with 14 additional baseline characteristics that may influence either treatment assignment, response to treatment, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsStudyGeneExpressions
</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 rows and 15 variables:
</p>

<ul>
<li><p> no_relapse: Binary indicator of remaining relapse-free at the end of study period
</p>
</li>
<li><p> intervention: Binary indicator of receiving treatment
</p>
</li>
<li><p> prognosis: Two-level factor variable indicating whether clinic-specific measure of prognosis is &ldquo;poor&rdquo; or 'good&rdquo;
</p>
</li>
<li><p> clinic: Ten-level factor variable indicating which of 10 clinics each observation attended
</p>
</li>
<li><p> age: Numeric variable indicating an individual's age (ranges from 40 to 65)
</p>
</li>
<li><p> gene_1: Numeric variable representing the expression level of specific gene_1
</p>
</li>
<li><p> gene_2: Numeric variable representing the expression level of specific gene_2
</p>
</li>
<li><p> gene_3: Numeric variable representing the expression level of specific gene_3
</p>
</li>
<li><p> gene_4: Numeric variable representing the expression level of specific gene_4
</p>
</li>
<li><p> gene_5: Numeric variable representing the expression level of specific gene_5
</p>
</li>
<li><p> gene_6: Numeric variable representing the expression level of specific gene_6
</p>
</li>
<li><p> gene_7: Numeric variable representing the expression level of specific gene_7
</p>
</li>
<li><p> gene_8: Numeric variable representing the expression level of specific gene_8
</p>
</li>
<li><p> gene_9: Numeric variable representing the expression level of specific gene_9
</p>
</li>
<li><p> gene_10: Numeric variable representing the expression level of specific gene_10
</p>
</li></ul>

<hr>
<h2 id='PredictRule'>Get the treatment rule implied by <code>BuildRule()</code></h2><span id='topic+PredictRule'></span>

<h3>Description</h3>

<p>Map the object returned by <code>BuildRule()</code> to the treatment rule corresponding to a particular dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictRule(
  BuildRule.object,
  new.X,
  desirable.outcome = NULL,
  clinical.threshold = 0,
  return.predicted.response = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PredictRule_+3A_buildrule.object">BuildRule.object</code></td>
<td>
<p>The object returned by the <code>BuildRule()</code> function.</p>
</td></tr>
<tr><td><code id="PredictRule_+3A_new.x">new.X</code></td>
<td>
<p>A data frame representing the dataset for which the treatment rule is desired.</p>
</td></tr>
<tr><td><code id="PredictRule_+3A_desirable.outcome">desirable.outcome</code></td>
<td>
<p>A logical equal to <code>TRUE</code> if higher values of the outcome are considered desirable (e.g. for a binary outcome, 1 is more desirable than 0). The <code>OWL.framework</code> and <code>OWL</code> approaches to treatment rule estimation require a desirable outcome.</p>
</td></tr>
<tr><td><code id="PredictRule_+3A_clinical.threshold">clinical.threshold</code></td>
<td>
<p>A numeric equal a positive number above which the predicted outcome under treatment must be superior to the predicted outcome under control for treatment to be recommended. Only used when <code>BuildRuleObject</code> was specified and derived from the split-regression or direct-interactions approach. Defaults to 0.</p>
</td></tr>
<tr><td><code id="PredictRule_+3A_return.predicted.response">return.predicted.response</code></td>
<td>
<p>logical indicating whether the predicted response variable (for <code>split.regression</code>, <code>OWL.framework</code>, and <code>OWL</code> approaches) or score function (for <code>direct.interactions</code>) should be returned in addition to its mapping to a binary treatment recommendation. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> If <code>return.predicted.response=FALSE</code> (the default), then the single object returned is a numeric vector of 0s and 1s, with length equal to the number of rows in <code>new.X</code>, where a 0 indicates treatment is not recommended and a 1 indicates treatment is recommended for the corresponding observation in <code>new.X</code>.
</p>
</li>
<li><p> If <code>return.predicted.response=TRUE</code>, then the object returned is a list with some combination of the following components (depending on which prediction approach underlies the <code>BuildRule.object</code>).
</p>

<ul>
<li> <p><code>recommended.treatment</code>: A numeric vector of 0s and 1s, with length equal to the number of rows in <code>new.X</code>, where a 0 indicates treatment is not recommended and a 1 indicates treatment is recommended for the corresponding observation in <code>new.X</code>.
</p>
</li>
<li> <p><code>predicted.outcome</code>: A numeric vector showing the predicted values of the score function mapped to <code>recommended.treatment</code>. Only returned if <code>return.predicted.response=TRUE</code> and the approach underlying <code>BuildRule.object</code>. was &lsquo;direct.interactions&rsquo;.
</p>
</li>
<li> <p><code>predicted.outcome.under.control</code>: A numeric vector showing the predicted values of the outcome under no treatment which, along with <code>predicted.outcome.under.treatment</code>, corresponds to <code>recommended.treatment</code>. Only returned if <code>return.predicted.response=TRUE</code> and the approach underlying <code>BuildRule.object</code>. was &lsquo;split.regression&rsquo;.
</p>
</li>
<li> <p><code>predicted.outcome.under.treatment</code>: A numeric vector showing the predicted values of the outcome under treatment which, along with <code>predicted.outcome.under.control</code>, corresponds to <code>recommended.treatment</code>. Only returned if <code>return.predicted.response=TRUE</code> and the approach underlying <code>BuildRule.object</code>. was &lsquo;split.regression&rsquo;.
</p>
</li>
<li> <p><code>predicted.treatment.prob</code>: A numeric vector showing the predicted treatment probability that corresponds to <code>recommended.treatment</code>. Only returned if <code>return.predicted.response=TRUE</code> and the approach underlying <code>BuildRule.object</code>. was &lsquo;OWL.framework&rsquo;.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
example.split &lt;- SplitData(data=obsStudyGeneExpressions,
                                     n.sets=3, split.proportions=c(0.5, 0.25, 0.25))
development.data &lt;- example.split[example.split$partition == "development",]
validation.data &lt;- example.split[example.split$partition == "validation",]
one.rule &lt;- BuildRule(development.data=development.data,
                     study.design="observational",
                     prediction.approach="split.regression",
                     name.outcome="no_relapse",
                     type.outcome="binary",
                     desirable.outcome=TRUE,
                     name.treatment="intervention",
                     names.influencing.treatment=c("prognosis", "clinic", "age"),
                     names.influencing.rule=c("age", paste0("gene_", 1:10)),
                     propensity.method="logistic.regression",
                     rule.method="glm.regression")
one.prediction &lt;- PredictRule(BuildRule.object=one.rule,
                                        new.X=validation.data[, c("age", paste0("gene_", 1:10))],
                                        desirable.outcome=TRUE,
                                        clinical.threshold=0)
table(one.prediction)
</code></pre>

<hr>
<h2 id='SplitData'>Partition a dataset into independent subsets</h2><span id='topic+SplitData'></span>

<h3>Description</h3>

<p>To get a trustworthy estimate of how a developed treatment rule will perform in independent samples drawn from the same population, it is critical that rule development be performed independently of rule evaluation. Further, it is common to perform model selection to settle on the form of the developed treatment rule and, in this case, it is essential that the ultimately chosen treatment rule is also evaluated on data that did not inform any stage of the model-building. The <code>SplitData()</code> function partitions a dataset so rule development/validation/evaluation (or development/evaluation if there is no model selection) can quickly be performed on independent datasets. This function is only appropriate for the simple setting where the rows in a given dataset are independent of one another (e.g. the same individuals are not represented with multiple rows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitData(data, n.sets = c(3, 2), split.proportions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitData_+3A_data">data</code></td>
<td>
<p>A data frame representing the *development*  dataset used for building a treatment rule</p>
</td></tr>
<tr><td><code id="SplitData_+3A_n.sets">n.sets</code></td>
<td>
<p>A numeric/integer equal to either 3 (if a development/validation/evaluation partition is desired) or 2 (if there is no model-selection and only a development/evaluation partition is desired).</p>
</td></tr>
<tr><td><code id="SplitData_+3A_split.proportions">split.proportions</code></td>
<td>
<p>A numeric vector with length equal to <code>n.sets</code>, providing the proportion of observations in <code>data</code> that should be assigned to the development/evaluation partitions (if <code>n.sets=2</code>) or to the development/validation/evaluation partitions (if <code>n.sets=3</code>). The entries must sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame equal to <code>data</code> with an additional column named &lsquo;partition&rsquo;, which is a factor variable with levels equal to &lsquo;development&rsquo; and &lsquo;evaluation&rsquo; (if <code>n.sets=2</code>)  or to  &lsquo;development&rsquo;, &lsquo;validation&rsquo;, and &lsquo;evaluation&rsquo; (if <code>n.sets=3</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
example.split &lt;- SplitData(data=obsStudyGeneExpressions,
                                     n.sets=3, split.proportions=c(0.5, 0.25, 0.25))
table(example.split$partition)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
