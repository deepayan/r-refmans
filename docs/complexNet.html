<!DOCTYPE html><html><head><title>Help for package complexNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {complexNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#avg_degree_bnr'><p>Expected average degree of BNR networks</p></a></li>
<li><a href='#init_graph'><p>Initialising a random graph</p></a></li>
<li><a href='#iterate_bnr'><p>Iterating a bnr network</p></a></li>
<li><a href='#iterate_kp'><p>Iterating a kp network</p></a></li>
<li><a href='#make_bnr'><p>Generating a Pb, Pn, Pr network</p></a></li>
<li><a href='#make_kp'><p>Generating a kp network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Complex Network Generation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Providing a set of functions to easily generate and iterate complex networks.
 The functions can be used to generate realistic networks with a wide range of different clustering, density, and average path length.
 For more information consult research articles by Amiyaal Ilany and Erol Akcay (2016) &lt;<a href="https://doi.org/10.1093%2Ficb%2Ficw068">doi:10.1093/icb/icw068</a>&gt; and Ilany and Erol Akcay (2016) &lt;<a href="https://doi.org/10.1101%2F026120">doi:10.1101/026120</a>&gt;, which have inspired many methods in this package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://marcosmolla.github.io/complexNet/">https://marcosmolla.github.io/complexNet/</a>,
<a href="https://github.com/marcosmolla/complexNet">https://github.com/marcosmolla/complexNet</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/marcosmolla/complexNet/issues">https://github.com/marcosmolla/complexNet/issues</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-09 09:00:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-10 10:30:41 UTC; marcosmolla</td>
</tr>
<tr>
<td>Author:</td>
<td>Marco Smolla <a href="https://orcid.org/0000-0001-6367-8765"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marco Smolla &lt;drsmolla@icloud.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-10 13:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='avg_degree_bnr'>Expected average degree of BNR networks</h2><span id='topic+avg_degree_bnr'></span><span id='topic+avg_degree_bnr+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Calculates the expected average degree of a BNR network (single parent only) based on the approximation by Ilany and Akcay, 2016 (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_degree_bnr(n, pb, pn, pr)

## S4 method for signature 'numeric,numeric,numeric,numeric'
avg_degree_bnr(n, pb, pn, pr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_degree_bnr_+3A_n">n</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
<tr><td><code id="avg_degree_bnr_+3A_pb">pb</code></td>
<td>
<p>Probability to connect to parent (default is 1)</p>
</td></tr>
<tr><td><code id="avg_degree_bnr_+3A_pn">pn</code></td>
<td>
<p>Probability to connect to neighbour of parent(s)</p>
</td></tr>
<tr><td><code id="avg_degree_bnr_+3A_pr">pr</code></td>
<td>
<p>Probability to connect to individuals that are not connected to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected average degree <code class="reqn">\bar{d}</code> is calculated as </p>
<p style="text-align: center;"><code class="reqn"> \bar{d} = \frac{(N-1)(p_b + (N-2)p_r)}{N-1-(N-2)(p_n - p_r)} </code>
</p>



<h3>Value</h3>

<p>Returns the expected average degree of a BNR network as a numeric value. This value is an analytic result and not a numeric approximation (compare examples below).
</p>


<h3>References</h3>

<p>Ilany, A., and Akçay, E. (2016). Personality and Social Networks: A Generative Model Approach. Integrative and Comparative Biology, 56(6), 1197–1205. <a href="https://doi.org/10.1093/icb/icw068">doi:10.1093/icb/icw068</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Expected degree
avg_degree_bnr(n = 100, pb = 1, pn = .2, pr = .02)
# Compare to simulated network with identical parameters
adjm &lt;- make_bnr(n = 100, np = c(0,0), pb = 1, pn = .2, pr = .02)
mean(adjm) * 100
</code></pre>

<hr>
<h2 id='init_graph'>Initialising a random graph</h2><span id='topic+init_graph'></span><span id='topic+init_graph+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>init_graph takes number of nodes (n) and average degree (deg) to generate a random graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_graph(n, deg)

## S4 method for signature 'numeric,numeric'
init_graph(n, deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_graph_+3A_n">n</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
<tr><td><code id="init_graph_+3A_deg">deg</code></td>
<td>
<p>Average degree in the network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an unweighted (binary) adjacency matrix, where each cell represents the presence (1) or absence (0) of an interaction between the row and the column individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init_graph(n = 10, deg = 4)
</code></pre>

<hr>
<h2 id='iterate_bnr'>Iterating a bnr network</h2><span id='topic+iterate_bnr'></span><span id='topic+iterate_bnr+2Cmatrix+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Iterating a bnr network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate_bnr(adjm, np, pb, pn, pr)

## S4 method for signature 'matrix,numeric,numeric,numeric,numeric'
iterate_bnr(adjm, np, pb, pn, pr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterate_bnr_+3A_adjm">adjm</code></td>
<td>
<p>Adjacency matrix</p>
</td></tr>
<tr><td><code id="iterate_bnr_+3A_np">np</code></td>
<td>
<p>numeric vector setting ids for the newborn (i.e. which individual will be replaced with a new one) and a parent(s). Length 2 or 3. If you want to randomly select an id for the newborn (first value) and parents (second and third value), simply use c(0,0) or c(0,0,0). For one parent, the focal individual connects to this parent with probability pb. For two parent values, the individual connects to two parents each with probability pb.</p>
</td></tr>
<tr><td><code id="iterate_bnr_+3A_pb">pb</code></td>
<td>
<p>Probability to connect to parent. Default is 1.</p>
</td></tr>
<tr><td><code id="iterate_bnr_+3A_pn">pn</code></td>
<td>
<p>Probability to connect to neighbour of parent(s)</p>
</td></tr>
<tr><td><code id="iterate_bnr_+3A_pr">pr</code></td>
<td>
<p>Probability to connect to individuals that are not connected to the parent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you just want to iterate the graph you can use <code>np=c(0,0)</code> or <code>np=c(0,0,0)</code>. However, the function does not return the ids of the newborn and the parent(s). If you want to keep track of the ids that are changed, you should provide these as an input to the function.
</p>


<h3>Value</h3>

<p>Returns an iterated version of the supplied adjacency matrix as a numeric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up linking parameters:
pb &lt;- 1
pn &lt;- 0.2
pr &lt;- 0.01
# Generate a network based on these parameters
adjm_t0 &lt;- make_bnr(n = 100, np=c(0,0), pb = pb, pn = pn, pr = pr)
# Iterate the network
adjm_t1 &lt;- iterate_bnr(adjm = adjm_t0, np=c(0,0), pb = pb, pn = pn, pr = pr)
</code></pre>

<hr>
<h2 id='iterate_kp'>Iterating a kp network</h2><span id='topic+iterate_kp'></span><span id='topic+iterate_kp+2Cmatrix+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Iterating a kp network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate_kp(adjm, np, pb, k, p)

## S4 method for signature 'matrix,numeric,numeric,numeric,numeric'
iterate_kp(adjm, np, pb, k, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterate_kp_+3A_adjm">adjm</code></td>
<td>
<p>Adjacency matrix</p>
</td></tr>
<tr><td><code id="iterate_kp_+3A_np">np</code></td>
<td>
<p>numeric vector setting ids for the newborn (i.e. which individual will be replaced with a new one) and a parent(s). Length 2 or 3. If you want to randomly select an id for the newborn (first value) and parents (second and third value), simply use c(0,0) or c(0,0,0). For one parent, the focal individual connects to this parent with probability pb. For two parent values, the individual connects to two parents each with probability pb.</p>
</td></tr>
<tr><td><code id="iterate_kp_+3A_pb">pb</code></td>
<td>
<p>Probability to connect to parent. Default is 1.</p>
</td></tr>
<tr><td><code id="iterate_kp_+3A_k">k</code></td>
<td>
<p>Degree (number of connections a new individual will form)</p>
</td></tr>
<tr><td><code id="iterate_kp_+3A_p">p</code></td>
<td>
<p>Maximum proportion of k that will be connections to neighbours of the parent. The complimentary k*(1-p) connections will be formed with random other individuals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you just want to iterate the graph you can use <code>np=c(0,0)</code> or <code>np=c(0,0,0)</code>. However, the function does not return the ids of the newborn and the parent(s). If you want to keep track of the ids that are changed, you should provide these as an input to the function.
</p>


<h3>Value</h3>

<p>Returns an iterated version of the supplied adjacency matrix as a numeric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up linking parameters:
pb &lt;- 1
k &lt;- 4
p &lt;- 0.2
# Generate a network based on these parameters
adjm_t0 &lt;- make_kp(n = 100, np=c(0,0), pb = pb, k = k, p = p)
# Iterate the network
adjm_t1 &lt;- iterate_kp(adjm = adjm_t0, np=c(0,0), pb = pb, k = k, p = p)
</code></pre>

<hr>
<h2 id='make_bnr'>Generating a Pb, Pn, Pr network</h2><span id='topic+make_bnr'></span><span id='topic+make_bnr+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+make_bnr+2Cnumeric+2Cnumeric+2Cmissing+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>This function takes adj.matrix (ADJM), probabilities to connect to parent(s), neighbours, and randoms (PB, PN, PR), the index of the parent (if NULL, default, NPARENT number of individuals are randomly chosen as parent), number of parents (NPARENT, default is 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_bnr(n, np, pb, pn, pr)

## S4 method for signature 'numeric,numeric,numeric,numeric,numeric'
make_bnr(n, np, pb, pn, pr)

## S4 method for signature 'numeric,numeric,missing,numeric,numeric'
make_bnr(n, np, pb, pn, pr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_bnr_+3A_n">n</code></td>
<td>
<p>Number of vertices (population size)</p>
</td></tr>
<tr><td><code id="make_bnr_+3A_np">np</code></td>
<td>
<p>numeric vector setting ids for the newborn (i.e. which individual will be replaced with a new one) and a parent(s). Length 2 or 3. If you want to randomly select an id for the newborn (first value) and parents (second and third value), simply use c(0,0) or c(0,0,0).</p>
</td></tr>
<tr><td><code id="make_bnr_+3A_pb">pb</code></td>
<td>
<p>Probability to connect to parent (default is 1)</p>
</td></tr>
<tr><td><code id="make_bnr_+3A_pn">pn</code></td>
<td>
<p>Probability to connect to neighbour of parent(s)</p>
</td></tr>
<tr><td><code id="make_bnr_+3A_pr">pr</code></td>
<td>
<p>Probability to connect to individuals that are not connected to the parent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is important to note that, although all three parameters (PB, PN, PR) are probabilities, i.e. values between 0 and 1, the same value (say 0.2) means something different for each of them. This is because, PB is the probability to connect to the parent(s), i.e. 1 or two individuals. In contrast, PN and PR are the probabilities to connect to neighbours of the parent(s) or to random other individuals. In the case of a small social neighbourhood of the parent(s) a PR of 0.2 would mean to connect to a large amount of individuals in the remaining network. Therefore, it is important to keep in mind that the value of both (or all three) values is important and not the individual one in isolation.
</p>


<h3>Value</h3>

<p>Returns an unweighted (binary) adjacency matrix, where each cell represents the presence (1) or absence (0) of an interaction between the row and the column individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_bnr(n = 10, np = c(0,0), pb = 1, pn = .2, pr = .01)
</code></pre>

<hr>
<h2 id='make_kp'>Generating a kp network</h2><span id='topic+make_kp'></span><span id='topic+make_kp+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+make_kp+2Cnumeric+2Cnumeric+2Cmissing+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>This function ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_kp(n, np, pb, k, p)

## S4 method for signature 'numeric,numeric,numeric,numeric,numeric'
make_kp(n, np, pb, k, p)

## S4 method for signature 'numeric,numeric,missing,numeric,numeric'
make_kp(n, np, pb, k, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_kp_+3A_n">n</code></td>
<td>
<p>Number of vertices (population size)</p>
</td></tr>
<tr><td><code id="make_kp_+3A_np">np</code></td>
<td>
<p>numeric vector setting ids for the newborn (i.e. which individual will be replaced with a new one) and a parent(s). Length 2 or 3. If you want to randomly select an id for the newborn (first value) and parents (second and third value), simply use c(0,0) or c(0,0,0).</p>
</td></tr>
<tr><td><code id="make_kp_+3A_pb">pb</code></td>
<td>
<p>Probability to connect to parent (default is 1)</p>
</td></tr>
<tr><td><code id="make_kp_+3A_k">k</code></td>
<td>
<p>Degree (number of connections a new individual will form)</p>
</td></tr>
<tr><td><code id="make_kp_+3A_p">p</code></td>
<td>
<p>Maximum proportion of k that will be connections to neighbours of the parent. The complimentary k*(1-p) connections will be formed with random other individuals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is important to note that ... P is a maximum value, say an individual wants to have 10 connections and P=0.5, i.e. it wants 5 connections to the neighbours of its parent but the parent only has 4 then it will only inherit those 4.
</p>


<h3>Value</h3>

<p>Returns an unweighed (binary) adjacency matrix, where each cell represents the presence (1) or absence (0) of an interaction between the row and the column individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_kp(n = 10, np = c(0,0), pb = 1, k = 4, p = .5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
