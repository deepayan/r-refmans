<!DOCTYPE html><html lang="en"><head><title>Help for package REndo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {REndo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#REndo'><p>Fitting Linear Models with Endogenous Regressors using Latent Instrumental Variables</p></a></li>
<li><a href='#confint.rendo.boots'><p>Confidence Intervals for Bootstrapped Model Parameters</p></a></li>
<li><a href='#copulaCorrection'><p>Fitting Linear Models Endogenous Regressors using Gaussian Copula</p></a></li>
<li><a href='#dataCopCont'><p>Simulated Dataset with One Endogenous Continuous Regressor</p></a></li>
<li><a href='#dataCopCont2'><p>Simulated Dataset with Two Endogenous Continuous Regressor</p></a></li>
<li><a href='#dataCopDis'><p>Simulated Dataset with One Endogenous Discrete Regressor</p></a></li>
<li><a href='#dataCopDis2'><p>Simulated Dataset with Two Endogenous Discrete Regressors</p></a></li>
<li><a href='#dataCopDisCont'><p>Simulated Dataset with Two Endogenous Regressors</p></a></li>
<li><a href='#dataHetIV'><p>Simulated Dataset with One Endogenous Continuous Regressor</p></a></li>
<li><a href='#dataHigherMoments'><p>Simulated Dataset with One Endogenous Regressor</p></a></li>
<li><a href='#dataLatentIV'><p>Simulated Dataset with One Endogenous Continuous Regressor</p></a></li>
<li><a href='#dataMultilevelIV'><p>Multilevel Simulated Dataset - Three Levels</p></a></li>
<li><a href='#hetErrorsIV'><p>Fitting Linear Models with Endogenous Regressors using Heteroskedastic Covariance Restrictions</p></a></li>
<li><a href='#higherMomentsIV'><p>Fitting Linear Models with Endogenous Regressors using Lewbel's Higher Moments Approach</p></a></li>
<li><a href='#latentIV'><p>Fitting Linear Models with one Endogenous Regressor using Latent Instrumental Variables</p></a></li>
<li><a href='#multilevelIV'><p>Fitting Multilevel GMM Estimation with Endogenous Regressors</p></a></li>
<li><a href='#predict.rendo.copula.correction'><p>Predict method for Models using the Gaussian Copula Approach</p></a></li>
<li><a href='#predict.rendo.ivreg'><p>Predict method for fitted Regression Models with Internal Instrumental Variables</p></a></li>
<li><a href='#predict.rendo.latent.IV'><p>Predict method for Models using the Latent Instrumental Variables approach</p></a></li>
<li><a href='#predict.rendo.multilevel'><p>Predict method for Multilevel GMM Estimations</p></a></li>
<li><a href='#summary.rendo.copula.correction'><p>Summarizing Bootstrapped copulaCorrection Model Fits</p></a></li>
<li><a href='#summary.rendo.latent.IV'><p>Summarizing latentIV Model Fits</p></a></li>
<li><a href='#summary.rendo.multilevel'><p>Summarizing Multilevel GMM Estimation with Endogenous Regressors Model Fits</p></a></li>
<li><a href='#vcov.rendo.boots'><p>Calculate Variance-Covariance Matrix for Models Fitted with Bootstrapped Parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fitting Linear Models with Endogenous Regressors using Latent
Instrumental Variables</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits linear models with endogenous regressor using latent instrumental variable approaches. 
    The methods included in the package are Lewbel's (1997) &lt;<a href="https://doi.org/10.2307%2F2171884">doi:10.2307/2171884</a>&gt; higher moments approach as well as 
    Lewbel's (2012) &lt;<a href="https://doi.org/10.1080%2F07350015.2012.643126">doi:10.1080/07350015.2012.643126</a>&gt; heteroscedasticity approach, Park and Gupta's (2012) &lt;<a href="https://doi.org/10.1287%2Fmksc.1120.0718">doi:10.1287/mksc.1120.0718</a>&gt; joint estimation method 
    that uses Gaussian copula and Kim and Frees's (2007) &lt;<a href="https://doi.org/10.1007%2Fs11336-007-9008-1">doi:10.1007/s11336-007-9008-1</a>&gt; multilevel generalized
    method of moment approach that deals with endogeneity in a multilevel setting.
    These are statistical techniques to address the endogeneity problem where no external instrumental variables are needed.
    See the publication related to this package in the Journal of Statistical Software for more details: &lt;<a href="https://doi.org/10.18637%2Fjss.v107.i03">doi:10.18637/jss.v107.i03</a>&gt;.
    Note that with version 2.0.0 sweeping changes were introduced which greatly improve functionality and usability but break backwards compatibility.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mmeierer/REndo">https://github.com/mmeierer/REndo</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mmeierer/REndo/issues">https://github.com/mmeierer/REndo/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods (&ge; 3.4), stats (&ge; 3.4), utils (&ge; 3.4), Formula (&ge;
1.2), optimx (&ge; 2013.8.7), mvtnorm (&ge; 1.0-8), AER (&ge; 1.2-5),
Matrix (&ge; 1.2-14), lme4 (&ge; 1.1-18-1), data.table (&ge; 1.11.8),
corpcor (&ge; 1.6.9), Rcpp (&ge; 1.0.3), lmtest (&ge; 0.9-35)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, R.rsp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-02 19:11:46 UTC; rstudio</td>
</tr>
<tr>
<td>Author:</td>
<td>Raluca Gui [cre, aut],
  Markus Meierer [aut],
  Rene Algesheimer [aut],
  Patrik Schilter [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raluca Gui &lt;raluca.gui@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-02 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='REndo'>Fitting Linear Models with Endogenous Regressors using Latent Instrumental Variables</h2><span id='topic+REndo'></span><span id='topic+REndo-package'></span>

<h3>Description</h3>

<p>Fits linear models with endogenous regressor using latent instrumental variable approaches.
</p>
<p>The methods included in the package are Lewbel's (1997) &lt;doi:10.2307/2171884&gt; higher moments approach as well as
Lewbel's (2012) &lt;doi:10.1080/07350015.2012.643126&gt; heteroskedasticity approach, Park and Gupta's (2012) &lt;doi:10.1287/mksc.1120.0718&gt; joint estimation method
that uses Gaussian copula and Kim and Frees's (2007) &lt;doi:10.1007/s11336-007-9008-1&gt; multilevel generalized
method of moment approach that deals with endogeneity in a multilevel setting.
These are statistical techniques to address the endogeneity problem where no external instrumental variables are needed.
</p>
<p>The main functions to estimate models are:
</p>

<dl>
<dt><code>latentIV()</code></dt><dd><p>the latent instrumental variables method of Ebbes et al. (2005)</p>
</dd>
<dt><code>copulaCorrection()</code></dt><dd><p>copula correction method proposed by Paek and Gupta (2012)</p>
</dd>
<dt><code>hetErrorsIV()</code></dt><dd><p>heteroskedastic errors approach proposed by Lewbel(2012)</p>
</dd>
<dt><code>higherMomentsIV()</code></dt><dd><p>higher moments method proposed by Lewbel (1997)</p>
</dd>
<dt><code>multilevelIV()</code></dt><dd><p>multilevel GMM method proposed by Kim and Frees (2007)</p>
</dd>
</dl>

<p><strong>Differences between current (2.0.0) and previous version of REndo</strong>
</p>
<p>Note that with version 2.0.0 sweeping changes were which greatly improve functionality but break backwards compatibility.
Various bugs were fixed, performance improved, handling of S3 objects and methods across the package was harmonized,
and a set of argument checks has been added. Starting with REndo 2.0, all functions support the use
of transformations such as I(x^2) or log(x) in the formulas.
Moreover, the call of most of the functions (except latentIV() and multilevelIV()) changed from the previous versions, making use
of the Formula package.
</p>
<p>Check the NEWS file or our <a href="https://github.com/mmeierer/REndo">github page</a> for the latest updates and for reporting issues.
</p>
<p>See our publication in the Journal of Statistical Software for more details: <a href="https://doi.org/10.18637/jss.v107.i03">doi:10.18637/jss.v107.i03</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Raluca Gui <a href="mailto:raluca.gui@gmail.com">raluca.gui@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Markus Meierer <a href="mailto:markus.meierer@business.uzh.ch">markus.meierer@business.uzh.ch</a>
</p>
</li>
<li><p> Rene Algesheimer <a href="mailto:market-research@business.uzh.ch">market-research@business.uzh.ch</a>
</p>
</li>
<li><p> Patrik Schilter <a href="mailto:patrik.schilter@gmail.com">patrik.schilter@gmail.com</a>
</p>
</li></ul>



<h3>References</h3>

<p>Gui R, Meierer M, Schilter P, Algesheimer R (2023). “REndo: Internal Instrumental Variables to Address Endogeneity.” Journal of Statistical Software, 107 (3), 1-43. <a href="https://doi.org/10.18637/jss.v107.i03">doi:10.18637/jss.v107.i03</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mmeierer/REndo">https://github.com/mmeierer/REndo</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mmeierer/REndo/issues">https://github.com/mmeierer/REndo/issues</a>
</p>
</li></ul>


<hr>
<h2 id='confint.rendo.boots'>Confidence Intervals for Bootstrapped Model Parameters</h2><span id='topic+confint.rendo.boots'></span>

<h3>Description</h3>

<p>Confidence Intervals for Bootstrapped Model Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rendo.boots'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.rendo.boots_+3A_object">object</code></td>
<td>
<p>a fitted model object with bootstrapped parameters. Typically from <code>copulaCorrection</code></p>
</td></tr>
<tr><td><code id="confint.rendo.boots_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given
confidence intervals, either a vector of numbers or a vector of
names.  If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.rendo.boots_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.rendo.boots_+3A_...">...</code></td>
<td>
<p>ignored, for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the two-sided percentile confidence intervals from the bootstrapped parameter estimates. The intervals are
obtained by selecting the quantile of the bootstrapped parameter estimates corresponding to the given alpha level.
</p>
<p>A minimum of 1/min(level, 1-level)
parameters estimates are needed to derive the confidence interval. The reason for this is that there is
otherwise no natural way to derive the percentiles (ie one cannot reasonably estimate the 95% quantile of only 7 values).
</p>

<hr>
<h2 id='copulaCorrection'>Fitting Linear Models Endogenous Regressors using Gaussian Copula</h2><span id='topic+copulaCorrection'></span>

<h3>Description</h3>

<p>Fits linear models with continuous or discrete endogenous regressors (or a mixture of both) using Gaussian copulas, as presented in Park and Gupta (2012).
This is a statistical technique to address the endogeneity problem where no external instrumental variables are needed.
The important assumption of the model is that the endogenous variables should NOT be normally distributed, if continuous, preferably with a skewed distribution.
The corrections proposed by Qian, Koschmann, and Xie (2024, p.19-22) are implemented. These mitigate the bias of the original paper for small and moderate sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copulaCorrection(formula, data, num.boots = 1000, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copulaCorrection_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fitted. See the &quot;Details&quot; section for the exact notation.</p>
</td></tr>
<tr><td><code id="copulaCorrection_+3A_data">data</code></td>
<td>
<p>A data.frame containing the data of all parts specified in the formula parameter.</p>
</td></tr>
<tr><td><code id="copulaCorrection_+3A_num.boots">num.boots</code></td>
<td>
<p>Number of bootstrapping iterations. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="copulaCorrection_+3A_verbose">verbose</code></td>
<td>
<p>Show details about the running of the function.</p>
</td></tr>
<tr><td><code id="copulaCorrection_+3A_...">...</code></td>
<td>
<p>Arguments for the log-likelihood optimization function in the case of a single continuous endogenous
regressor. Ignored with a warning otherwise.
</p>

<dl>
<dt>start.params</dt><dd><p>A named vector containing a set of parameters to use in the first optimization iteration.
The names have to correspond exactly to the names of the components specified in the <code>formula</code> parameter.
If not provided, a linear model is fitted to derive them.</p>
</dd>
<dt>optimx.args</dt><dd><p>A named list of arguments which are passed to <code><a href="optimx.html#topic+optimx">optimx</a></code>. This allows users to tweak optimization settings to their liking.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>

<p>The underlying idea of the joint estimation method is that using information contained in the observed data,
one selects marginal distributions for the endogenous regressor and the structural error term, respectively.
Then, the copula model enables the construction of a flexible multivariate joint distribution allowing a wide range
of correlations between the two marginals.
</p>
<p>Consider the model:
</p>
<br><div style="text-align:center">Y<sub>t</sub>=&beta;<sub>0</sub>+&beta;<sub>1</sub>P<sub>t</sub>+&beta;<sub>2</sub>X<sub>t</sub>+&epsilon;<sub>t</sub></div>
<p>where <code class="reqn">t=1,..,T</code> indexes either time or cross-sectional units, Y<sub>t</sub> is a <code class="reqn">1x1</code> response variable,
X<sub>t</sub> is a <code class="reqn">kxn</code> exogenous regressor,
P<sub>t</sub> is a <code class="reqn">kx1</code> continuous endogenous regressor,
&epsilon;<sub>t</sub> is a normally distributed structural error term with mean zero and
E(&epsilon;<sup>2</sup>)=&sigma;<sub>&epsilon;</sub><sup>2</sup>,
<code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are model parameters.
</p>
<p>The marginal distribution of the endogenous regressor P<sub>t</sub> is obtained using the Epanechnikov
kernel density estimator (Epanechnikov, 1969), as below:
</p>
<br><div style="text-align:center">h&#770;(p)=1/(T&#183;b) &sum;(K&#183;((p-P<sub>t</sub>)/b))</div>
<p>where P<sub>t</sub> is the endogenous regressor,
K(x)=0.75&#183;(1-x<sup>2</sup>)&#183;I(|x|<=1)
and the bandwidth <code class="reqn">b</code> is the one proposed by Silverman (1986),
and is equal to b=0.9&#183;T<sup>-1.5</sup>&#183;min(s, IQR/1.34).
<code class="reqn">IQR</code> is the interquartile range while <code class="reqn">s</code> is the data sample standard deviation
and <code class="reqn">T</code> is the number of time periods observed in the data.
After obtaining the joint distribution of the error term and the continuous endogenous regressor, the model parameters are estimated using
maximum likelihood estimation.
</p>
<p>The additional parameters used during model fitting and printed in <code>summary</code> hence are:
</p>

<dl>
<dt><code>rho</code></dt><dd><p>The correlation between the endogenous regressor and the error.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>The variance of the model's error.</p>
</dd>
</dl>

<p>With more than one continuous endogenous regressor or an endogenous discrete regressor, an alternative approach to the
estimation using Gaussian copula should be applied. This approach is similar to the control function approach (Petrin and Train, 2010).
The core idea is to apply OLS estimation on the original set of explanatory variables in the model equation above, plus an additional regressor
P<sub>t</sub>&#42;=&Phi;<sup>-1</sup>(H(P<sub>t</sub>)).
Here, H(P<sub>t</sub>) is the marginal distribution of the endogenous regressor <code class="reqn">P</code>.
Including this regressor solves the correlation between the endogenous regressor and the structural error, <code class="reqn">\epsilon</code>,
OLS providing consistent parameter estimates. Due to identification problems, the discrete endogenous regressor cannot have a binomial
distribution.
</p>
<p>Hence, only in the case of a single continuous endogenous regressor maximum likelihood estimation is used.
In all other cases, augmented OLS based on Gaussian copula is applied. This includes cases of multiple endogenous regressors
of both discrete and continuous distributions.
</p>
<p>In the case of discrete endogenous regressors, a random seed needs to be assigned because the marginal distribution function of
the endogenous regressor is a step function in this case. This means that the value of P&#42;
lies between 2 values, &Phi;<sup>-1</sup>(H(P<sub>t</sub>-1)) and
&Phi;<sup>-1</sup>(H(P<sub>t</sub>)).
However, the reported upper and lower bounds of the 95% bootstrapped confidence interval gives indication of the variance of the estimates.
</p>

<p>Since the inference procedure in both cases, augmented OLS and maximum likelihood, occurs in two stages (first the empirical distribution of the endogenous
regressor is computed and then used in constructing the likelihood function), the standard errors are not correct. Therefore, in both cases, the standard errors
and the confidence intervals are obtained based on the sampling distributions resulted from bootstrapping. Since the distribution of the bootstrapped parameters
is highly skewed, we report the percentile confidence intervals. Moreover, the variance-covariance matrix is also computed based on the bootstrapped
parameters, and not based on the Hessian.
</p>


<h4>Formula parameter</h4>

<p>The <code>formula</code> argument follows a two part notation:
</p>
<p>A two-sided formula describing the model (e.g. <code>y ~ X1 + X2 + P</code>) to be estimated and a
second right-hand side part in which the endogenous regressors and their distributional
assumptions are indicated (e.g. <code>continuous(P)</code>). These two parts are separated by a single vertical bar (<code>|</code>).
In the second part, the special functions <code>continuous</code>, <code>discrete</code>, or a combination
of both, are used to indicate the endogenous regressors and their respective distribution.
Both functions use the <code>...</code> parameter in which the respective endogenous regressors is specified.
</p>
<p>Note that no argument to <code>continuous</code> or <code>discrete</code> is to be supplied as character
but as symbols without quotation marks.
</p>
<p>See the example section for illustrations on how to specify the <code>formula</code> parameter.
</p>



<h3>Value</h3>

<p>For all cases, an object of classes <code>rendo.copula.correction</code>, <code>rendo.boots</code>, and <code>rendo.base</code> is returned
which is a list and contains the following components:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>The formula given to specify the fitted model.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The terms object used for model fitting.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model.frame used for model fitting.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A named vector of all coefficients resulting from model fitting.</p>
</td></tr>
<tr><td><code>names.main.coefs</code></td>
<td>
<p>a vector specifying which coefficients are from the model. For internal usage.</p>
</td></tr>
<tr><td><code>names.vars.continuous</code></td>
<td>
<p>The names of the continuous endogenous regressors.</p>
</td></tr>
<tr><td><code>names.vars.discrete</code></td>
<td>
<p>The names of the discrete endogenous regressors.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values at the found solution.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The residuals at the found solution.</p>
</td></tr>
<tr><td><code>boots.params</code></td>
<td>
<p>The bootstrapped coefficients.</p>
</td></tr>
</table>
<p>For the case of a single continuous endogenous regressor, the returned object further
contains the following components:
</p>
<table role = "presentation">
<tr><td><code>start.params</code></td>
<td>
<p>A named vector with the initial set of parameters used to optimize the log-likelihood function.</p>
</td></tr>
<tr><td><code>res.optimx</code></td>
<td>
<p>The result object returned by the function <code>optimx</code> after optimizing the log-likelihood function.</p>
</td></tr>
</table>
<p>For all other cases, the returned object further contains the following component:
</p>
<table role = "presentation">
<tr><td><code>res.lm.real.data</code></td>
<td>
<p>The linear model fitted on the original data together with generated p.star data.</p>
</td></tr>
</table>
<p>The function <code>summary</code> can be used to obtain and print a summary of the results.
Depending on the returned object, the generic accessor functions <code>coefficients</code>, <code>fitted.values</code>,
<code>residuals</code>, <code>vcov</code>, <code>logLik</code>, <code>AIC</code>, <code>BIC</code>, and <code>nobs</code> are available.
</p>


<h3>References</h3>

<p>Park, S. and Gupta, S., (2012), &quot;Handling Endogenous Regressors by Joint Estimation Using Copulas&quot;, Marketing Science, 31(4), 567-86.
</p>
<p>Qian, Y., Koschmann, A., and Xie, H. (2024). &quot;A Practical Guide to Endogeneity Correction Using Copulas&quot;. National Bureau of Economic Research, w32231.
</p>
<p>Epanechnikov V (1969). &quot;Nonparametric Estimation of a Multidimensional Probability Density.&quot; Teoriya veroyatnostei i ee primeneniya, 14(1), 156–161.
</p>
<p>Silverman B (1986). &quot;Density Estimation for Statistics and Data Analysis&quot;. CRC Monographs on Statistics and Applied Probability. London: Chapman &amp; Hall.
</p>
<p>Petrin A, Train K (2010). &quot;A Control Function Approach to Endogeneity in Consumer Choice Models.&quot; Journal of Marketing Research, 47(1), 3–13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.rendo.copula.correction">summary</a></code> for how fitted models are summarized
</p>
<p><code><a href="#topic+vcov.rendo.boots">vcov</a></code> for how the variance-covariance matrix is derived
</p>
<p><code><a href="#topic+confint.rendo.boots">confint</a></code> for how confidence intervals are derived
</p>
<p><code><a href="optimx.html#topic+optimx">optimx</a></code> for possible elements of parameter <code>optimx.arg</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dataCopCont")
data("dataCopCont2")
data("dataCopDis")
data("dataCopDis2")
data("dataCopDisCont")


## Not run: 
# Single continuous: log-likelihood optimization
c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P), num.boots=10, data=dataCopCont)
# same as above, with start.parameters and number of bootstrappings
c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P), num.boots=10, data=dataCopCont,
                       start.params = c("(Intercept)"=1, X1=1, X2=-2, P=-1))

# All following examples fit linear model with Gaussian copulas

# 2 continuous endogenous regressors
c2 &lt;- copulaCorrection(y~X1+X2+P1+P2|continuous(P1, P2),
                        num.boots=10, data=dataCopCont2)
# same as above
c2 &lt;- copulaCorrection(y~X1+X2+P1+P2|continuous(P1)+continuous(P2),
                        num.boots=10, data=dataCopCont2)

# single discrete endogenous regressor
d1 &lt;- copulaCorrection(y~X1+X2+P|discrete(P), num.boots=10, data=dataCopDis)

# two discrete endogenous regressor
d2 &lt;- copulaCorrection(y~X1+X2+P1+P2|discrete(P1)+discrete(P2),
                        num.boots=10, data=dataCopDis2)
# same as above but less bootstrap runs
d2 &lt;- copulaCorrection(y~X1+X2+P1+P2|discrete(P1, P2), num.boots = 10,
                       data=dataCopDis2)

# single discrete, single continuous
cd &lt;- copulaCorrection(y~X1+X2+P1+P2|discrete(P1)+continuous(P2),
                        num.boots=10, data=dataCopDisCont)

# For single continuous only: use own optimization settings (see optimx())
# set maximum number of iterations to 50'000
res.c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P),
                           optimx.args = list(itnmax = 50000),
                            num.boots=10, data=dataCopCont)

# print detailed tracing information on progress
 res.c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P),
                            optimx.args = list(control = list(trace = 6)),
                             num.boots=10, data=dataCopCont)

# use method L-BFGS-B instead of Nelder-Mead and print report every 50 iterations
 res.c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P),
                            optimx.args = list(method = "L-BFGS-B",
                                               control=list(trace = 2, REPORT=50)),
                             num.boots=10, data=dataCopCont)

# For coef(), the parameter "complete" determines if only the
# main model parameters or also the auxiliary coefficients are returned

c1.all.coefs &lt;- coef(res.c1) # also returns rho and sigma
# same as above
c1.all.coefs &lt;- coef(res.c1, complete = TRUE)

# only main model coefs
c1.main.coefs &lt;- coef(res.c1, complete = FALSE)


## End(Not run)

</code></pre>

<hr>
<h2 id='dataCopCont'>Simulated Dataset with One Endogenous Continuous Regressor</h2><span id='topic+dataCopCont'></span>

<h3>Description</h3>

<p>A dataset with two exogenous regressors,
<code>X1</code>,<code>X2</code>, and one endogenous, continuous regressor,
<code>P</code>, having a T-distribution with 3 degrees of freedom.
An intercept and a dependent variable, <code>y</code>, are also included.
The true parameter values for the coefficients are: <code>b0 = 2</code>, <code>b1 = 1.5</code>,
<code>b2 = -3</code> and the coefficient of the endogenous regressor, P, is equal to <code>a1 = -1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataCopCont")
</code></pre>


<h3>Format</h3>

<p>A data frame with 2500 observations on 4 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector representing the dependent variable.</p>
</dd>
<dt><code>X1</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>X2</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector, continuous and endogenous having T-distribution with 3 degrees of freedom.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Raluca Gui <a href="mailto:raluca.gui@business.uzh.ch">raluca.gui@business.uzh.ch</a>
</p>

<hr>
<h2 id='dataCopCont2'>Simulated Dataset with Two Endogenous Continuous Regressor</h2><span id='topic+dataCopCont2'></span>

<h3>Description</h3>

<p>A dataset with two exogenous regressors,
<code>X1</code>,<code>X2</code>, and two endogenous, continuous regressors,
<code>P1</code> and <code>P2</code>, having a T-distribution with 3 degrees of freedom.
An intercept and a dependent variable, <code>y</code>, are also included.
The true parameter values for the intercept and the exogenous regressors' coefficients are: <code>b0 = 2</code>, <code>b1 = 1.5</code>,
<code>b2 = -3</code>. The coefficient of the endogenous regressor <code>P1</code> is equal to <code>a1 = -1</code> and
of <code>P2</code> is equal to <code>a2 = 0.8</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataCopCont2")
</code></pre>


<h3>Format</h3>

<p>A data frame with 2500 observations on 5 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector representing the dependent variable.</p>
</dd>
<dt><code>X1</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>X2</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>P1</code></dt><dd><p>a numeric vector, continuous and endogenous having T-distribution with 3 degrees of freedom.</p>
</dd>
<dt><code>P2</code></dt><dd><p>a numeric vector, continuous and endogenous having T-distribution with 3 degrees of freedom.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Raluca Gui <a href="mailto:raluca.gui@business.uzh.ch">raluca.gui@business.uzh.ch</a>
</p>

<hr>
<h2 id='dataCopDis'>Simulated Dataset with One Endogenous Discrete Regressor</h2><span id='topic+dataCopDis'></span>

<h3>Description</h3>

<p>A dataset with two exogenous regressors,
<code>X1</code>,<code>X2</code>, and one endogenous, discrete (Poisson distributed) regressor,
<code>P</code>.
An intercept and a dependent variable, <code>y</code>, are also included.
The true parameter values for the coefficients are: <code>b0 = 2</code>, <code>b1 = 1.5</code>,
<code>b2 = -3</code> and the coefficient of the endogenous regressor, P, is equal to <code>a1 = -1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataCopDis")
</code></pre>


<h3>Format</h3>

<p>A data frame with 2500 observations on 4 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector representing the dependent variable.</p>
</dd>
<dt><code>X1</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>X2</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector, continuous and endogenous having T-distribution with 3 degrees of freedom.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Raluca Gui <a href="mailto:raluca.gui@business.uzh.ch">raluca.gui@business.uzh.ch</a>
</p>

<hr>
<h2 id='dataCopDis2'>Simulated Dataset with Two Endogenous Discrete Regressors</h2><span id='topic+dataCopDis2'></span>

<h3>Description</h3>

<p>A dataset with two exogenous regressors,
<code>X1</code>,<code>X2</code>, and two endogenous, discrete (Poisson distributed) regressors,
<code>P1</code> and <code>P2</code>.
An intercept and a dependent variable, <code>y</code>, are also included.
The true parameter values for the coefficients of the intercept and the exogenous variables are: <code>b0 = 2</code>, <code>b1 = 1.5</code>,
<code>b2 = -3</code>. The true parameter values for the coefficients of the endogenous regressors are <code>a1 = -1</code> for <code>P1</code> and
<code>a2 = 0.8</code> for <code>P2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataCopDis2")
</code></pre>


<h3>Format</h3>

<p>A data frame with 2500 observations on 5 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector representing the dependent variable.</p>
</dd>
<dt><code>X1</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>X2</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>P1</code></dt><dd><p>a numeric vector, having a Poisson distribution with parameter lambda equal to 3, and endogenous.</p>
</dd>
<dt><code>P2</code></dt><dd><p>a numeric vector, having a Poisson distribution with parameter lambda equal to 3, and endogenous.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Raluca Gui <a href="mailto:raluca.gui@business.uzh.ch">raluca.gui@business.uzh.ch</a>
</p>

<hr>
<h2 id='dataCopDisCont'>Simulated Dataset with Two Endogenous Regressors</h2><span id='topic+dataCopDisCont'></span>

<h3>Description</h3>

<p>A dataset with two exogenous regressors,
<code>X1</code>,<code>X2</code>, and two endogenous regressors,
<code>P1</code>, having a Poisson distribution with lambda parameter equal to 3, and <code>P2</code>, having a T-distribution with 3 degrees of freedom.
An intercept and a dependent variable, <code>y</code>, are also included.
The true parameter values for the coefficients are: <code>b0 = 2</code>, <code>b1 = 1.5</code>,
<code>b2 = -3</code> and the coefficient of the endogenous regressor <code>P1</code> is set to <code>a1 = -1</code> and of <code>P2</code> is set to <code>a2=0.8</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataCopDisCont")
</code></pre>


<h3>Format</h3>

<p>A data frame with 2500 observations on 5 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector representing the dependent variable.</p>
</dd>
<dt><code>X1</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>X2</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>P1</code></dt><dd><p>a numeric vector, continuous and endogenous having Poisson distribution with parameter lambda equal to 3.</p>
</dd>
<dt><code>P2</code></dt><dd><p>a numeric vector, continuous and endogenous having T-distribution with 3 degrees of freedom.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Raluca Gui <a href="mailto:raluca.gui@business.uzh.ch">raluca.gui@business.uzh.ch</a>
</p>

<hr>
<h2 id='dataHetIV'>Simulated Dataset with One Endogenous Continuous Regressor</h2><span id='topic+dataHetIV'></span>

<h3>Description</h3>

<p>A dataset with two exogenous regressors,
<code>X1</code>,<code>X2</code>, one endogenous, continuous regressor <code>P</code>, and the dependent variable <code>y</code>.
The true parameter values for the coefficients are: <code>b0 = 2</code>, <code>b1 = 1.5</code>,
<code>b2 = 3</code> and the coefficient of the endogenous regressor, <code>P</code>, is equal to <code>a1 = -1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataHetIV")
</code></pre>


<h3>Format</h3>

<p>A data frame with 2500 observations on 4 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector representing the dependent variable.</p>
</dd>
<dt><code>X1</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>X2</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector, continuous and endogenous regressor, normally distributed.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Raluca Gui <a href="mailto:raluca.gui@business.uzh.ch">raluca.gui@business.uzh.ch</a>
</p>

<hr>
<h2 id='dataHigherMoments'>Simulated Dataset with One Endogenous Regressor</h2><span id='topic+dataHigherMoments'></span>

<h3>Description</h3>

<p>A dataset with two exogenous regressors,
<code>X1</code>,<code>X2</code>, and one endogenous, continuous regressor <code>P</code>.
An intercept and a dependent variable, <code>y</code>, are also included.
The true parameter values for the coefficients are: <code>b0 = 2</code>, <code>b1 = 1.5</code>,
<code>b2 = 3</code> and the coefficient of the endogenous regressor, P, is equal to <code>a1 = -1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataHigherMoments")
</code></pre>


<h3>Format</h3>

<p>A data frame with 2500 observations on 4 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector representing the dependent variable.</p>
</dd>
<dt><code>X1</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>X2</code></dt><dd><p>a numeric vector, normally distributed and exogenous.</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector, continuous and endogenous regressor, normally distributed.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Raluca Gui <a href="mailto:raluca.gui@business.uzh.ch">raluca.gui@business.uzh.ch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dataHigherMoments")
# to recover the parameters,
#   on average over many simulations
higherMomentsIV(formula = y ~ X1 + X2 + P|P|IIV(iiv=yp),
               data=dataHigherMoments)

</code></pre>

<hr>
<h2 id='dataLatentIV'>Simulated Dataset with One Endogenous Continuous Regressor</h2><span id='topic+dataLatentIV'></span>

<h3>Description</h3>

<p>A dataset with one endogenous regressor <code>P</code>, an instrument <code>Z</code>
used to build <code>P</code>, an intercept and a dependent variable, <code>y</code>.
The true parameter values for the coefficients are: <code>b0 = 3</code> for the intercept
and <code>a1 = -1</code> for <code>P</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataLatentIV")
</code></pre>


<h3>Format</h3>

<p>A data frame with 2500 observations on 3 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector representing the dependent variable.</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector representing the endogenous variable.</p>
</dd>
<dt><code>Z</code></dt><dd><p>a numeric vector used in the construction of the endogenous variable, P.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Raluca Gui <a href="mailto:raluca.gui@business.uzh.ch">raluca.gui@business.uzh.ch</a>
</p>

<hr>
<h2 id='dataMultilevelIV'>Multilevel Simulated Dataset - Three Levels</h2><span id='topic+dataMultilevelIV'></span>

<h3>Description</h3>

<p>A dataset simulated to exemplify the use of the <code>multilevelIV()</code> function.
It has 2767 observations, clustered into 40 level-three variables and 1347 observations at level two. The endogenous regressor is <code>X15</code> with a true
coefficient value of -1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataMultilevelIV")
</code></pre>


<h3>Format</h3>

<p>A data frame with 2767 observations clustered into 40 level-three variables and 1347 level-two variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector representing the dependent variable.</p>
</dd>
<dt><code>X11</code></dt><dd><p>a level-one numeric vector representing a categorical exogenous variable with true parameter value equal to 3.</p>
</dd>
<dt><code>X12</code></dt><dd><p>a level-one numeric vector representing a binomial distributed exogenous variable with true parameter value equal to 9.</p>
</dd>
<dt><code>X13</code></dt><dd><p>a level-one numeric vector representing a binomial distributed exogenous variable with true parameter value equal to -2.</p>
</dd>
<dt><code>X14</code></dt><dd><p>a level-two numeric vector representing a normally distributed exogenous variable with true parameter value equal to 2.</p>
</dd>
<dt><code>X15</code></dt><dd><p>a level-two numeric vector representing a normally distributed endogenous variable, correlated with the level-two errors.
It true parameter value equals to <code class="reqn">-1</code> and it has a correlation with the level two errors equal to 0.7.</p>
</dd>
<dt><code>X21</code></dt><dd><p>a level-two numeric vector representing a binomial distributed exogenous variable with true parameter value equal to -1.5.</p>
</dd>
<dt><code>X22</code></dt><dd><p>a level-two numeric vector representing a binomial distributed exogenous variable with true parameter value equal to -4.</p>
</dd>
<dt><code>X23</code></dt><dd><p>a level-two numeric vector representing a binomial distributed exogenous variable with true parameter value equal to -3.</p>
</dd>
<dt><code>X24</code></dt><dd><p>a level-teo numeric vector representing a normally distributed exogenous variable with true parameter value equal to 6.</p>
</dd>
<dt><code>X31</code></dt><dd><p>a level-three numeric vector representing a normally distributed exogenous variable with true parameter value equal to 0.5.</p>
</dd>
<dt><code>X32</code></dt><dd><p>a level-three numeric vector representing a truncated normally distributed exogenous variable with true parameter value equal to 0.1.</p>
</dd>
<dt><code>X33</code></dt><dd><p>a level-three numeric vector representing a truncated normally distributed exogenous variable with true parameter value equal to -0.5.</p>
</dd>
<dt><code>SID</code></dt><dd><p>a numeric vector identifying each level-three observations.</p>
</dd>
<dt><code>CID</code></dt><dd><p>a numeric vector identifying each level-two observations.</p>
</dd></dl>



<h3>Author(s)</h3>

<p>Raluca Gui <a href="mailto:raluca.gui@business.uzh.ch">raluca.gui@business.uzh.ch</a>
</p>

<hr>
<h2 id='hetErrorsIV'>Fitting Linear Models with Endogenous Regressors using Heteroskedastic Covariance Restrictions</h2><span id='topic+hetErrorsIV'></span>

<h3>Description</h3>

<p>This function estimates the model parameters and associated standard errors for a
linear regression model with one endogenous regressor. Identification is achieved
through heteroscedastic covariance restrictions within the triangular system as proposed in Lewbel(2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hetErrorsIV(formula, data, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hetErrorsIV_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fitted. See the &quot;Details&quot; section for the exact notation.</p>
</td></tr>
<tr><td><code id="hetErrorsIV_+3A_data">data</code></td>
<td>
<p>A data.frame containing the data of all parts specified in the formula parameter.</p>
</td></tr>
<tr><td><code id="hetErrorsIV_+3A_verbose">verbose</code></td>
<td>
<p>Show details about the running of the function.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>

<p>The method proposed in Lewbel(2012) identifies structural parameters in regression models with endogenous
regressors by means of variables that are uncorrelated with the product of heteroskedastic errors.
The instruments are constructed as simple functions of the model's data. The method can be applied when
no external instruments are available or to supplement external instruments to improve the efficiency of the
IV estimator.
Consider the model in the equation:
</p>
<br><div style="text-align:center">y<sub>t</sub>=&beta;<sub>0</sub>+&beta;<sub>1</sub>P<sub>t</sub>+&beta;<sub>2</sub>X<sub>t</sub>+&epsilon;<sub>t</sub></div>
<p>where <code class="reqn">t=1,..,T</code> indexes either time or cross-sectional units.The endogeneity problem arises from the correlation of
P<sub>t</sub> and &epsilon;<sub>t</sub>.
As such: P<sub>t</sub> = Z<sub>t</sub>+&nu;<sub>t</sub>,
where Z<sub>t</sub> is a subset of variables in X<sub>t</sub>.
</p>
<p>The errors, &epsilon; and &nu;, may be correlated with each other.
Structural parameters are identified by an ordinary two-stage least squares regression of <code class="reqn">Y</code> on <code class="reqn">X</code> and <code class="reqn">P</code>, using <code class="reqn">X</code> and <code class="reqn">[Z-E(Z)]\nu</code> as instruments.
A vital assumption for identification is that cov(Z,&nu;<sup>2</sup>)&ne;0.
The strength of the instrument is proportional to the covariance of (Z-Z&#773;)&nu; with <code class="reqn">\nu</code>, which corresponds to
the degree of heteroskedasticity of <code class="reqn">\nu</code> with respect to <code class="reqn">Z</code> (Lewbel 2012).
</p>
<p>The assumption that the covariance between <code class="reqn">Z</code> and the squared error is different from zero can be empirically tested (this is checked in the background when calling the
function). If it is zero or close to zero, the instrument is weak, producing imprecise estimates, with large standard errors.
</p>



<h4>Formula parameter</h4>

<p>The <code>formula</code> argument follows a four part notation:
</p>
<p>A two-sided formula describing the model (e.g. <code>y ~ X1 + X2 + P</code>), a single endogenous regressor
(e.g. <code>P</code>), and the exogenous variables from which the internal instrumental variables should
be build (e.g. <code>IIV(X1) + IIV(X2)</code>), each part separated by a single vertical bar (<code>|</code>).
</p>
<p>The instrumental variables that should be built are specified as (multiple) functions, one for each
instrument. This function is <code>IIV</code> and uses the following arguments:
</p>

<dl>
<dt><code>...</code></dt><dd><p>The exogenous regressors to build the internal instruments from.
If more than one is given, separate instruments are built for each.</p>
</dd>
</dl>

<p>Note that no argument to <code>IIV</code> is to be supplied as character but as symbols without quotation marks.
</p>
<p>Optionally, additional external instrumental variables to also include in the instrumental variable
regression can be specified. These external instruments have to be already present in the data
and are provided as the fourth right-hand side part of the formula, again separated by a vertical bar.
</p>
<p>See the example section for illustrations on how to specify the <code>formula</code> parameter.
</p>



<h3>Value</h3>

<p>Returns an object of classes <code>rendo.ivreg</code> and <code>ivreg</code>, It extends the object returned from
function <code>ivreg</code> of package <code>AER</code> and slightly modifies it by adapting the <code>call</code>
and <code>formula</code> components. The <code>summary</code> function prints additional diagnostic information as
described in documentation for <code><a href="AER.html#topic+summary.ivreg">summary.ivreg</a></code>.
</p>
<p>All generic accessor functions for <code>ivreg</code> such as <code>anova</code>, <code>hatvalues</code>, or <code>vcov</code> are available.
</p>


<h3>References</h3>

<p>Lewbel, A. (2012). Using Heteroskedasticity to Identify and Estimate Mismeasured and Endogenous Regressor Models, Journal of Business &amp; Economic Statistics, 30(1), 67-80.
</p>
<p>Angrist, J. and Pischke, J.S. (2009). Mostly Harmless Econometrics: An Empiricists Companion, Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="AER.html#topic+ivreg">ivreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dataHetIV")
# P is the endogenous regressor in all examples
# X1 generates a weak instrument but for the examples
# this is ignored

# 2 IVs, one from X1, one from X2
het &lt;- hetErrorsIV(y~X1+X2+P|P|IIV(X1)+IIV(X2), data=dataHetIV)
# same as above
het &lt;- hetErrorsIV(y~X1+X2+P|P|IIV(X1,X2), data=dataHetIV)

# use X2 as an external IV
het &lt;- hetErrorsIV(y~X1+P|P|IIV(X1)|X2, data=dataHetIV)

summary(het)

</code></pre>

<hr>
<h2 id='higherMomentsIV'>Fitting Linear Models with Endogenous Regressors using Lewbel's Higher Moments Approach</h2><span id='topic+higherMomentsIV'></span>

<h3>Description</h3>

<p>Fits linear models with one endogenous regressor using internal instruments built using the approach described in
Lewbel A. (1997). This is a statistical technique to address the endogeneity problem where no external instrumental
variables are needed. The implementation allows the incorporation of external instruments if available.
An important assumption for identification is that the endogenous variable has a skewed distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>higherMomentsIV(formula, data, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="higherMomentsIV_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fitted. See the &quot;Details&quot; section for the exact notation.</p>
</td></tr>
<tr><td><code id="higherMomentsIV_+3A_data">data</code></td>
<td>
<p>A data.frame containing the data of all parts specified in the formula parameter.</p>
</td></tr>
<tr><td><code id="higherMomentsIV_+3A_verbose">verbose</code></td>
<td>
<p>Show details about the running of the function.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>

<p>Consider the model:
</p>
<br><div style="text-align:center">Y<sub>t</sub>=&beta;<sub>0</sub> + &beta;<sub>1</sub>X<sub>t</sub>+&alpha;P<sub>t</sub>+&epsilon;<sub>t</sub></div>
<div style="text-align:center">P<sub>t</sub>=Z<sub>t</sub>+&nu;<sub>t</sub></div>
<p>The observed data consist of Y<sub>t</sub>, X<sub>t</sub> and P<sub>t</sub>,
while Z<sub>t</sub>, &epsilon;<sub>t</sub>,
and &nu;<sub>t</sub> are unobserved. The endogeneity problem arises from
the correlation of P<sub>t</sub> with the structural error
&epsilon;<sub>t</sub>,
since E(&epsilon;&nu;)&ne;0.
The requirement for the structural and measurement error is to have mean zero, but no restriction is imposed on their distribution.
</p>
<p>Let S&#773; be the sample mean of a variable S<sub>t</sub>
and G<sub>t</sub>=G(X<sub>t</sub>) for any given function <code class="reqn">G</code> that
has finite third own and cross moments. Lewbel(1997) proves that the following instruments can be constructed and used with two-stage least squares to obtain consistent estimates:
</p>
<div style="text-align:center">q<sub>1t</sub>=(G<sub>t</sub>-G&#773;)<span style="float:right;">(3a)</span></div>
<div style="text-align:center">q<sub>2t</sub>=(G<sub>t</sub>-G&#773;)(P<sub>t</sub>-P&#773;)<span style="float:right;">(3b)</span></div>
<div style="text-align:center">q<sub>3t</sub>=(G<sub>t</sub>-G&#773;)(Y<sub>t</sub>-Y&#773;)<span style="float:right;">(3c)</span></div>
<div style="text-align:center">q<sub>4t</sub>=(Y<sub>t</sub>-Y&#773;)(P<sub>t</sub>-P&#773;)<span style="float:right;">(3d)</span></div>
<div style="text-align:center">q<sub>5t</sub>=(P<sub>t</sub>-P&#773;)<sup>2</sup><span style="float:right;">(3e)</span></div>
<div style="text-align:center">q<sub>6t</sub>=(Y<sub>t</sub>-Y&#773;)<sup>2</sup><span style="float:right;">(3f)</span></div>
<p>Instruments in equations <code class="reqn">3e</code> and <code class="reqn">3f</code> can be used only when the measurement and the structural errors are symmetrically distributed.
Otherwise, the use of the instruments does not require any distributional assumptions for the errors. Given that the regressors <code class="reqn">G(X) = X</code>
are included as instruments, <code class="reqn">G(X)</code> should not be linear in <code class="reqn">X</code> in equation <code class="reqn">3a</code>.
</p>
<p>Let small letter denote deviation from the sample mean: s<sub>i</sub> = S<sub>i</sub>-S&#773;.
Then, using as instruments the variables presented in equations <code class="reqn">3</code> together with <code class="reqn">1</code> and
X<sub>t</sub>, the two-stage-least-squares estimation will provide consistent estimates for the parameters
in equation <code class="reqn">1</code> under the assumptions exposed in Lewbel(1997).
</p>



<h4>Formula parameter</h4>

<p>The <code>formula</code> argument follows a four part notation:
</p>
<p>A two-sided formula describing the model (e.g. <code>y ~ X1 + X2 + P</code>), a single endogenous regressor
(e.g. <code>P</code>), and the exogenous variables from which the internal instrumental variables should
be build (e.g. <code>IIV(iiv=y2)</code>), each part separated by a single vertical bar (<code>|</code>).
</p>
<p>The instrumental variables that should be built are specified as (multiple) functions, one for each
instrument. This function is <code>IIV</code> and uses the following arguments:
</p>

<dl>
<dt><code>iiv</code></dt><dd><p>Which internal instrument to build. One of <code>g, gp, gy, yp, p2, y2</code> can be chosen.</p>
</dd>
<dt><code>g</code></dt><dd><p>Which function <code>g</code> represents in <code>iiv</code>.
One of <code>x2, x3, lnx, 1/x</code> can be chosen.
Only required if the type of internal instrument demands it.</p>
</dd>
<dt><code>...</code></dt><dd>
<p>The exogenous regressors to build the internal instrument. If more than one is given,
separate instruments are built for each. Only required if the type of internal instrument demands it.</p>
</dd>
</dl>

<p>Note that no argument to <code>IIV</code> is to be supplied as character but as symbols without quotation marks.
</p>
<p>Optionally, additional external instrumental variables to also include in the instrumental variable
regression can be specified. These external instruments have to be already present in the data
and are provided as the fourth right-hand side part of the formula, again separated by a vertical bar.
</p>
<p>See the example section for illustrations on how to specify the <code>formula</code> parameter.
</p>



<h3>Value</h3>

<p>Returns an object of classes <code>rendo.ivreg</code> and <code>ivreg</code>, It extends the object returned from
function <code>ivreg</code> of package <code>AER</code> and slightly modifies it by adapting the <code>call</code>
and <code>formula</code> components. The <code>summary</code> function prints additional diagnostic information as
described in documentation for <code><a href="AER.html#topic+summary.ivreg">summary.ivreg</a></code>.
</p>
<p>All generic accessor functions for <code>ivreg</code> such as <code>anova</code>, <code>hatvalues</code>, or <code>vcov</code> are available.
</p>


<h3>References</h3>

<p>Lewbel A (1997). “Constructing Instruments for Regressions with Measurement Error When No Additional Data are Available, With an Application to Patents and R&amp;D.” Econometrica, 65(5), 1201–1213.
</p>


<h3>See Also</h3>

<p><code><a href="AER.html#topic+ivreg">ivreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dataHigherMoments")
# P is the endogenous regressor in all examples

# 2 IVs with g*p, g=x^2, separately for each regressor X1 and X2.
hm &lt;- higherMomentsIV(y~X1+X2+P|P|IIV(iiv=gp, g=x2, X1, X2),
                      data = dataHigherMoments)
# same as above
hm &lt;- higherMomentsIV(y~X1+X2+P|P|IIV(iiv=gp, g=x2, X1) +
                                  IIV(iiv=gp, g=x2, X2),
                      data = dataHigherMoments)

# 3 different IVs
hm &lt;- higherMomentsIV(y~X1+X2+P|P|IIV(iiv=y2) + IIV(iiv=yp) +
                                  IIV(iiv=g,g=x3,X1),
                      data = dataHigherMoments)

# use X2 as external IV
hm &lt;- higherMomentsIV(y~X1+P|P|IIV(iiv=y2)+IIV(iiv=g,g=lnx,X1)| X2,
                      data = dataHigherMoments)
summary(hm)

</code></pre>

<hr>
<h2 id='latentIV'>Fitting Linear Models with one Endogenous Regressor using Latent Instrumental Variables</h2><span id='topic+latentIV'></span>

<h3>Description</h3>

<p>Fits linear models with one endogenous regressor and no additional explanatory variables using the latent instrumental variable approach
presented in Ebbes, P., Wedel, M.,  Böckenholt, U., and Steerneman, A. G. M. (2005). This is a statistical technique to address the endogeneity problem where no external instrumental
variables are needed. The important assumption of the model is that the latent variables are discrete with at least two groups with different means and
the structural error is normally distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latentIV(
  formula,
  data,
  start.params = c(),
  optimx.args = list(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latentIV_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fitted. Of class &quot;formula&quot;.</p>
</td></tr>
<tr><td><code id="latentIV_+3A_data">data</code></td>
<td>
<p>A data.frame containing the data of all parts specified in the formula parameter.</p>
</td></tr>
<tr><td><code id="latentIV_+3A_start.params">start.params</code></td>
<td>
<p>A named vector containing a set of parameters to use in the first optimization iteration.
The names have to correspond exactly to the names of the components specified in the formula parameter.
If not provided, a linear model is fitted to derive them.</p>
</td></tr>
<tr><td><code id="latentIV_+3A_optimx.args">optimx.args</code></td>
<td>
<p>A named list of arguments which are passed to <code><a href="optimx.html#topic+optimx">optimx</a></code>. This allows users to tweak optimization settings to their liking.</p>
</td></tr>
<tr><td><code id="latentIV_+3A_verbose">verbose</code></td>
<td>
<p>Show details about the running of the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let's consider the model:
</p>
<br><div style="text-align:center">Y<sub>t</sub>=&beta;<sub>0</sub>+&alpha;P<sub>t</sub>+&epsilon;<sub>t</sub></div>
<div style="text-align:center">P<sub>t</sub>=&pi;'Z<sub>t</sub>+&nu;<sub>t</sub></div>
<p>where <code class="reqn">t = 1,..,T</code> indexes either time or cross-sectional units, Y<sub>t</sub> is the dependent variable,
P<sub>t</sub> is a <code>k x 1</code> continuous, endogenous regressor,
&epsilon;<sub>t</sub> is a structural error term with mean zero
and E(&epsilon;<sup>2</sup>)=&sigma;<sub>&epsilon;</sub><sup>2</sup>,
<code class="reqn">\alpha</code> and &beta;<sub>0</sub> are model parameters.
Z;<sub>t</sub> is a <code>l x 1</code> vector of instruments,
and &nu;<sub>t</sub> is a random error with mean zero and
E(&nu;<sup>2</sup>)=&sigma;<sub>&nu;</sub><sup>2</sup>.
The endogeneity problem arises from the correlation of <code class="reqn">P</code> and &epsilon;<sub>t</sub>
through E(&epsilon;&nu;)=&sigma;<sub>&epsilon;&nu;</sub>
</p>
<p><code>latentIV</code> considers Z<sub>t</sub>' to be a latent, discrete, exogenous variable with an unknown number of groups <code class="reqn">m</code> and <code class="reqn">\pi</code> is a vector of group means.
It is assumed that <code class="reqn">Z</code> is independent of the error terms <code class="reqn">\epsilon</code> and <code class="reqn">\nu</code> and that it has at least two groups with different means.
The structural and random errors are considered normally distributed with mean zero and variance-covariance matrix <code class="reqn">\Sigma</code>:
</p>
<div style="text-align:center">&Sigma;=(&sigma;<sub>&epsilon;</sub><sup>2</sup>, &sigma;<sub>0</sub><sup>2</sup>,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&sigma;<sub>0</sub><sup>2</sup>, &sigma;<sub>&nu;</sub><sup>2</sup>)</div>
<p>The identification of the model lies in the assumption of the non-normality of
P<sub>t</sub>, the discreteness of the unobserved instruments and the existence of
at least two groups with different means.
</p>
<p>The method has been implemented such that the latent variable has two groups. Ebbes et al.(2005) show in a Monte Carlo experiment that
even if the true number of the categories of the instrument is larger than two, estimates are approximately consistent. Besides, overfitting in terms
of the number of groups/categories reduces the degrees of freedom and leads to efficiency loss. For a model with additional explanatory variables a Bayesian approach is needed, since
in a frequentist approach identification issues appear.
</p>
<p>Identification of the parameters relies on the distributional assumptions of the latent instruments as well as that of
the endogenous regressor P<sub>t</sub>.
Specifically, the endogenous regressor should have a non-normal distribution while the unobserved instruments, <code class="reqn">Z</code>, should be discrete and have at least two groups with different means Ebbes, Wedel, and Böckenholt (2009).
A continuous distribution for the instruments leads to an unidentified model, while a normal distribution of the endogenous regressor gives rise to inefficient estimates.
</p>
<p>Additional parameters used during model fitting and printed in <code>summary</code> are:
</p>

<dl>
<dt>pi1</dt><dd><p>The instrumental variables <code class="reqn">Z</code> are assumed to be divided into two groups. <code>pi1</code> represents the estimated group mean of the first group.</p>
</dd>
<dt>pi2</dt><dd><p>The estimated group mean of the second group of the instrumental variables <code class="reqn">Z</code>.</p>
</dd>
<dt>theta5</dt><dd><p>The probability of being in the first group of the instruments.</p>
</dd>
<dt>theta6</dt><dd><p>The variance, &sigma;<sub>&epsilon;</sub><sup>2</sup></p>
</dd>
<dt>theta7</dt><dd><p>The covariance, &sigma;<sub>&epsilon;&nu;</sub></p>
</dd>
<dt>theta8</dt><dd><p>The variance, &sigma;<sub>&nu;</sub><sup>2</sup></p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of classes <code>rendo.latent.IV</code> and <code>rendo.base</code> is returned which is a list and contains the following components:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>The formula given to specify the fitted model.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The terms object used for model fitting.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model.frame used for model fitting.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A named vector of all coefficients resulting from model fitting.</p>
</td></tr>
<tr><td><code>names.main.coefs</code></td>
<td>
<p>a vector specifying which coefficients are from the model. For internal usage.</p>
</td></tr>
<tr><td><code>start.params</code></td>
<td>
<p>A named vector with the initial set of parameters used to optimize the log-likelihood function.</p>
</td></tr>
<tr><td><code>res.optimx</code></td>
<td>
<p>The result object returned by the function <code>optimx</code> after optimizing the log-likelihood function.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>A named, symmetric matrix giving an estimate of the Hessian at the found solution.</p>
</td></tr>
<tr><td><code>m.delta.diag</code></td>
<td>
<p>A diagonal matrix needed when deriving the vcov to apply the delta method on theta5 which was transformed during the LL optimization.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values at the found optimal solution.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The residuals at the found optimal solution.</p>
</td></tr>
</table>
<p>The function <code>summary</code> can be used to obtain and print a summary of the results.
The generic accessor functions <code>coefficients</code>, <code>fitted.values</code>, <code>residuals</code>, <code>vcov</code>, <code>confint</code>, <code>logLik</code>, <code>AIC</code>, <code>BIC</code>, <code>case.names</code>, and <code>nobs</code> are available.
</p>


<h3>References</h3>

<p>Ebbes, P., Wedel,M., Böckenholt, U., and Steerneman, A. G. M. (2005). 'Solving and Testing for Regressor-Error
(in)Dependence When no Instrumental Variables are Available: With New Evidence for the Effect of Education on Income'.
Quantitative Marketing and Economics, 3:365&ndash;392.
</p>
<p>Ebbes P., Wedel M., Böckenholt U. (2009). “Frugal IV Alternatives to Identify the Parameter for an Endogenous Regressor.” Journal of Applied Econometrics, 24(3), 446–468.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.rendo.latent.IV">summary</a></code> for how fitted models are summarized
</p>
<p><code><a href="optimx.html#topic+optimx">optimx</a></code> for possible elements of parameter <code>optimx.arg</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("dataLatentIV")

# function call without any initial parameter values
l  &lt;- latentIV(y ~ P, data = dataLatentIV)
summary(l)

# function call with initial parameter values given by the user
l1 &lt;- latentIV(y ~ P, start.params = c("(Intercept)"=2.5, P=-0.5),
               data = dataLatentIV)
summary(l1)

# use own optimization settings (see optimx())
# set maximum number of iterations to 50'000
l2 &lt;- latentIV(y ~ P, optimx.args = list(itnmax = 50000),
               data = dataLatentIV)

# print detailed tracing information on progress
l3 &lt;- latentIV(y ~ P, optimx.args = list(control = list(trace = 6)),
               data = dataLatentIV)

# use method L-BFGS-B instead of Nelder-Mead and print report every 50 iterations
l4 &lt;- latentIV(y ~ P, optimx.args = list(method = "L-BFGS-B", control=list(trace = 2, REPORT=50)),
               data = dataLatentIV)

# read out all coefficients, incl auxiliary coefs
lat.all.coefs &lt;- coef(l4)
# same as above
lat.all.coefs &lt;- coef(l4, complete = TRUE)
# only main model coefs
lat.main.coefs &lt;- coef(l4, complete = FALSE)


</code></pre>

<hr>
<h2 id='multilevelIV'>Fitting Multilevel GMM Estimation with Endogenous Regressors</h2><span id='topic+multilevelIV'></span>

<h3>Description</h3>

<p>Estimates multilevel models (max. 3 levels) employing the GMM approach presented in Kim and Frees (2007).
One of the important features is that, using the hierarchical structure of the data, no external instrumental
variables are needed, unlike traditional instrumental variable techniques. Specifically, the approach controls for
endogeneity at higher levels in the data hierarchy. For example, for a three-level model, endogeneity can be handled
either if present at level two, at level three or at both levels. Level one endogeneity, where the regressors are correlated
with the structural errors (errors at level one), is not addressed. Moreover, if considered, random slopes cannot be endogenous.
Also, the dependent variable has to have a continuous distribution.
The function returns the coefficient estimates obtained with fixed effects, random effects and the GMM estimator proposed
by Kim and Frees (2007), such that a comparison across models can be done.
Asymptotically, the multilevel GMM estimators share the same properties of corresponding fixed effects estimators, but they
allow the estimation of all the variables in the model, unlike the fixed effects counterpart.
</p>
<p>To facilitate the choice of the estimator to be used for the given data, the function also conducts
omitted variable test based on the Hausman-test for panel data (Hausman, 1978). It allows to compare
a robust estimator and an estimator that is efficient under the null hypothesis of no omitted variables,
and to compare two robust estimators at different levels. The results of these tests are returned when
calling <code><a href="#topic+summary.rendo.multilevel">summary()</a></code> on a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multilevelIV(
  formula,
  data,
  lmer.control = lmerControl(optimizer = "Nelder_Mead", optCtrl = list(maxfun = 1e+05)),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multilevelIV_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fitted. See the &quot;Details&quot; section for the exact notation.</p>
</td></tr>
<tr><td><code id="multilevelIV_+3A_data">data</code></td>
<td>
<p>A data.frame containing the data of all parts specified in the formula parameter.</p>
</td></tr>
<tr><td><code id="multilevelIV_+3A_lmer.control">lmer.control</code></td>
<td>
<p>An output from <code>lmerControl</code> that will be used to fit the <code>lmer</code> model from which the variance and
correlation are obtained.</p>
</td></tr>
<tr><td><code id="multilevelIV_+3A_verbose">verbose</code></td>
<td>
<p>Show details about the running of the function.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>

<p>Multilevel modeling is a generalization of regression methods that recognize the existence of such data hierarchies
by allowing for residual components at each level in the hierarchy. For example, a three-level multilevel model which
allows for grouping of students within classrooms, over time, would include time, student and classroom residuals
(see equation below). Thus, the residual variance is partitioned into four components:
between-classroom (the variance of the classroom-level residuals), within-classroom (the variance of the student-level residuals),
between student (the variance of the student-level residuals) and within-student (the variance of the time-level residuals).
The classroom residuals represent the unobserved classroom characteristics that affect student's outcomes.
These unobserved variables lead to correlation between outcomes for students from the same classroom.
Similarly, the unobserved time residuals lead to correlation between a student's outcomes over time.
A three-level model can be described as follows:
</p>

 <div style="text-align:center">y<sub>cst</sub> = Z<sup>1</sup><sub>cst</sub> &beta;<sup>1</sup><sub>cs</sub> + X<sup>1</sup><sub>cst</sub> &beta;<sub>1</sub> &epsilon;<sup>1</sup><sub>cst</sub> </div>
<br><div style="text-align:center"> &beta;<sup>1</sup><sub>cs</sub> =  Z<sup>2</sup><sub>cs</sub> &beta;<sup>2</sup><sub>c</sub> + X <sup>2</sup><sub>cs</sub> &beta;<sub>2</sub> &epsilon;<sup>2</sup><sub>cs</sub> </div>
<br><div style="text-align:center"> &beta;<sup>2</sup><sub>c</sub> = X<sup>3</sup><sub>c</sub>&beta;<sub>3</sub> &epsilon;<sup>3</sup><sub>c</sub> </div>
<p>Like in single-level regression, in multilevel models endogeneity is also a concern. The additional problem is that in multilevel models
there are multiple independent assumptions involving various random components at different levels. Any moderate correlation between some
predictors and a random component or error term, can result in a significant bias of the coefficients and of the variance components.
The multilevel GMM approach for addressing endogeneity uses both the between and within variations of the exogenous variables, but only the within
variation of the variables assumed endogenous. The assumptions in the multilevel generalized moment of moments model is that the errors at each level
are normally distributed and independent of each other. Moreover, the slope variables are assumed exogenous. Since the model does not handle
&quot;level 1 dependencies&quot;, an additional assumption is that the level 1 structural error is uncorrelated with any of the regressors.
If this assumption is not met, additional, external instruments are necessary.
The coefficients of the explanatory variables appear in the vectors &beta;<sub>1</sub>,
&beta;<sub>2</sub> and &beta;<sub>3</sub>.
The term &beta;<sup>1</sup><sub>cs</sub> captures latent, unobserved characteristics that are classroom and student specific
while &beta;<sup>2</sup><sub>c</sub> captures latent,
unobserved characteristics that are classroom specific. For identification, the disturbance term
&epsilon;<sub>cst</sub> is assumed independent of
the other variables, Z<sup>1</sup><sub>cst</sub> and X<sup>1</sup><sub>cst</sub>.
When all model variables are assumed exogenous, the GMM estimator is the usual GLS estimator, denoted as REF. When all variables (except the variables used as slope)
are assumed endogenous, the fixed-effects estimator is used, FE. While REF assumes all explanatory variables are uncorrelated with the
random intercepts and slopes in the model, FE allows for endogeneity of all effects but sweeps out the random components as well as the
explanatory variables at the same levels. The more general estimator GMM proposed by Kim and Frees (2007) allows for some of the explanatory
variables to be endogenous and uses this information to build instrumental variables. The multilevel GMM estimator uses both the between and
within variations of the exogenous variables, but only the within variation of the variables assumed endogenous. When all variables are assumed
exogenous, GMM estimator equals REF. When all covariates are assume endogenous, GMM equals FE.
</p>



<h4>Formula parameter</h4>

<p>The <code>formula</code> argument follows a two part notation:
</p>
<p>In the first part, the model is specified while in the second part, the endogenous regressors are indicated.
These two parts are separated by a single vertical bar (<code>|</code>).
</p>
<p>The first RHS follows the exact same model specification as required by the <code><a href="lme4.html#topic+lmer">lmer</a></code>
function of package <code>lme4</code> and internally will be used to fit a <code>lmer</code> model. In the second part,
one or multiple endogenous regressors are indicated by passing them to the special function <code>endo</code>
(e.g. <code>endo(X1, X2)</code>). Note that no argument to <code>endo()</code> is to be supplied as character
but as symbols without quotation marks.
</p>
<p>See the example section for illustrations on how to specify the <code>formula</code> parameter.
</p>



<h3>Value</h3>

<p><code>multilevelIV</code> returns an object of class &quot;<code>rendo.multilevel</code>&quot;.
</p>
<p>The generic accessor functions <code>coef</code>, <code>fitted</code>, <code>residuals</code>, <code>vcov</code>, <code>confint</code>, and <code>nobs</code>, are available.
Note that an additional argument <code>model</code> with possible values <code>"REF", "FE_L2", "FE_L3", "GMM_L2"</code>, or <code>"GMM_L3"</code> is
available for <code><a href="#topic+summary.rendo.multilevel">summary</a></code>, <code>fitted</code>, <code>residuals</code>, <code>confint</code>, and <code>vcov</code>
to extract the features for the specified model.
</p>
<p>Note that the obtained coefficients are rounded with <code>round(x, digits=getOption("digits"))</code>.
</p>
<p>An object of class <code>rendo.multilevel</code> is returned that is a list and contains the following components:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>the formula given to specify the model to be fitted.</p>
</td></tr>
<tr><td><code>num.levels</code></td>
<td>
<p>the number of levels detected from the model.</p>
</td></tr>
<tr><td><code>dt.model.data</code></td>
<td>
<p>a data.table of model data including data for slopes and level group ids</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix of rounded coefficients, one column per model.</p>
</td></tr>
<tr><td><code>coefficients.se</code></td>
<td>
<p>a matrix of coefficients' SE, one column per model.</p>
</td></tr>
<tr><td><code>l.fitted</code></td>
<td>
<p>a named list which contains the fitted values per model sorted as the input data</p>
</td></tr>
<tr><td><code>l.residuals</code></td>
<td>
<p>a named list which contains the residuals per model sorted as the input data</p>
</td></tr>
<tr><td><code>l.vcov</code></td>
<td>
<p>a list of variance-covariance matrix, named per model.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>the variance–covariance matrix V of the disturbance term.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>the weight matrix W, such that W=V^(-1/2) per highest level group.</p>
</td></tr>
<tr><td><code>l.ovt</code></td>
<td>
<p>a list of results of the Hausman OVT, named per model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hausman J (1978). “Specification Tests in Econometrics.” Econometrica, 46(6), 1251–1271.
</p>
<p>Kim, Jee-Seon and Frees, Edward W. (2007). &quot;Multilevel Modeling with Correlated Effects&quot;. Psychometrika, 72(4), 505-533.
</p>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+lmer">lmer</a></code> for more details on how to specify the <code>formula</code> parameter
</p>
<p><code><a href="lme4.html#topic+lmerControl">lmerControl</a></code> for more details on how to provide the <code>lmer.control</code> parameter
</p>
<p><code><a href="#topic+summary.rendo.multilevel">summary</a></code> for how fitted models are summarized
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("dataMultilevelIV")

# Two levels
res.ml.L2 &lt;- multilevelIV(y ~ X11 + X12 + X13 + X14 + X15 + X21 + X22 + X23 + X24 + X31 +
                              X32 + X33 + (1|SID) | endo(X15),
                          data = dataMultilevelIV, verbose = FALSE)

# Three levels
res.ml.L3 &lt;- multilevelIV(y ~ X11 + X12 + X13 + X14 + X15 + X21 + X22 + X23 + X24 + X31 +
                              X32 + X33 + (1| CID) + (1|SID) | endo(X15),
                          data = dataMultilevelIV, verbose = FALSE)


# L2 with multiple endogenous regressors
res.ml.L2 &lt;- multilevelIV(y ~ X11 + X12 + X13 + X14 + X15 + X21 + X22 + X23 + X24 + X31 +
                              X32 + X33 + (1|SID) | endo(X15, X21, X22),
                          data = dataMultilevelIV, verbose = FALSE)

# same as above
res.ml.L2 &lt;- multilevelIV(y ~ X11 + X12 + X13 + X14 + X15 + X21 + X22 + X23 + X24 + X31 +
                              X32 + X33 + (1|SID) | endo(X15, X21) + endo(X22),
                          data = dataMultilevelIV, verbose = FALSE)

# Fit above model with different settings for lmer()
lmer.control &lt;- lme4::lmerControl(optimizer="nloptwrap",
                                  optCtrl=list(algorithm="NLOPT_LN_COBYLA",
                                               xtol_rel=1e-6))
res.ml.L2.cob &lt;- multilevelIV(y ~ X11 + X12 + X13 + X14 + X15 + X21 + X22 + X23 + X24 +
                                  X31 + X32 + X33 + (1|SID) | endo(X15, X21) + endo(X22),
                              data = dataMultilevelIV, verbose = FALSE,
                              lmer.control = lmer.control) # use different controls for lmer


# specify argument "model" in the S3 methods to obtain results for the respective model
# default is "REF" for all methods

summary(res.ml.L3)
# same as above
summary(res.ml.L3, model = "REF")

# complete pval table for L3 fixed effects
L3.FE.p &lt;- coef(summary(res.ml.L3, model = "FE_L3"))

# variance covariance matrix
L2.FE.var  &lt;- vcov(res.ml.L2, model = "FE_L2")
L2.GMM.var &lt;- vcov(res.ml.L2, model = "GMM_L2")
# residuals
L3.REF.resid &lt;- resid(res.ml.L3, model = "REF")


</code></pre>

<hr>
<h2 id='predict.rendo.copula.correction'>Predict method for Models using the Gaussian Copula Approach</h2><span id='topic+predict.rendo.copula.correction'></span>

<h3>Description</h3>

<p>Predicted values based on linear models with endogenous regressors estimated using
the gaussian copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rendo.copula.correction'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.rendo.copula.correction_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;rendo.copula.correction&quot;</p>
</td></tr>
<tr><td><code id="predict.rendo.copula.correction_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with which to predict.
If omitted, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.rendo.copula.correction_+3A_...">...</code></td>
<td>
<p>ignored, for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>predict.copula.correction</code> produces a vector of predictions
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+copulaCorrection">copulaCorrection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data("dataCopCont")

c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P), num.boots=10,
                       data=dataCopCont)

# returns the fitted values
predict(c1)

# using the data used for fitting also for predicting,
# correctly results in fitted values
all.equal(predict(c1, dataCopCont), fitted(c1)) # TRUE

## End(Not run)

</code></pre>

<hr>
<h2 id='predict.rendo.ivreg'>Predict method for fitted Regression Models with Internal Instrumental Variables</h2><span id='topic+predict.rendo.ivreg'></span>

<h3>Description</h3>

<p>Predicted values based on model objects fitted using the instrumental variables regression fitted
with IVs generated from the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rendo.ivreg'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.rendo.ivreg_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;rendo.ivreg&quot;</p>
</td></tr>
<tr><td><code id="predict.rendo.ivreg_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame without any instrumental variables in which to look for variables with which to predict.
If omitted, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.rendo.ivreg_+3A_...">...</code></td>
<td>
<p>ignored, for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>predict.rendo.ivreg</code> produces a vector of predictions
</p>


<h3>See Also</h3>

<p>The model fitting functions <code><a href="#topic+hetErrorsIV">hetErrorsIV</a></code>,
<code><a href="#topic+higherMomentsIV">higherMomentsIV</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dataHetIV")

het &lt;- hetErrorsIV(y~X1+X2+P|P|IIV(X1, X2),
                   data = dataHetIV)

# returns the fitted values
predict(het)

# using the data used for fitting also for predicting,
# correctly results in fitted values
all.equal(predict(het, dataHetIV), fitted(het)) # TRUE

</code></pre>

<hr>
<h2 id='predict.rendo.latent.IV'>Predict method for Models using the Latent Instrumental Variables approach</h2><span id='topic+predict.rendo.latent.IV'></span>

<h3>Description</h3>

<p>Predicted values based on linear models estimated using the latent instrumental
variables approach for a single endogenous regressor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rendo.latent.IV'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.rendo.latent.IV_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;rendo.latent.IV&quot;</p>
</td></tr>
<tr><td><code id="predict.rendo.latent.IV_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with which to predict.
If omitted, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.rendo.latent.IV_+3A_...">...</code></td>
<td>
<p>ignored, for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>predict.rendo.latent.IV</code> produces a vector of predictions
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+latentIV">latentIV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dataLatentIV")

lat  &lt;- latentIV(y ~ P, data = dataLatentIV)

# returns the fitted values
predict(lat)

# using the data used for fitting also for predicting,
# correctly results in fitted values
all.equal(predict(lat, dataLatentIV), fitted(lat)) # TRUE

</code></pre>

<hr>
<h2 id='predict.rendo.multilevel'>Predict method for Multilevel GMM Estimations</h2><span id='topic+predict.rendo.multilevel'></span>

<h3>Description</h3>

<p>Predicted values based on multilevel models employing the GMM approach for hierarchical data with
endogenous regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rendo.multilevel'
predict(
  object,
  newdata,
  model = c("REF", "FE_L2", "FE_L3", "GMM_L2", "GMM_L3"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.rendo.multilevel_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;rendo.multilevel&quot;</p>
</td></tr>
<tr><td><code id="predict.rendo.multilevel_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with which to predict.
If omitted, the fitted values for the specified model are returned.</p>
</td></tr>
<tr><td><code id="predict.rendo.multilevel_+3A_model">model</code></td>
<td>
<p>character string to indicate for which fitted model predictions are made.
Possible values are: <code>"REF", "FE_L2", "FE_L3", "GMM_L2"</code>, or <code>"GMM_L3"</code>.</p>
</td></tr>
<tr><td><code id="predict.rendo.multilevel_+3A_...">...</code></td>
<td>
<p>ignored, for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>predict.rendo.multilevel</code> produces a vector of predictions
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+multilevelIV">multilevelIV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dataMultilevelIV")

# Two levels
res.ml.L2 &lt;- multilevelIV(y ~ X11 + X12 + X13 + X14 + X15 + X21 + X22 + X23 + X24 + X31 +
                          X32 + X33 + (1|SID) | endo(X15),
                          data = dataMultilevelIV, verbose = FALSE)
predict(res.ml.L2, model = "FE_L2")

# using the data used for fitting also for predicting,
#    correctly results in fitted values
all.equal(predict(res.ml.L2, dataMultilevelIV, model = "GMM_L2"),
          fitted(res.ml.L2, model = "GMM_L2")) # TRUE

</code></pre>

<hr>
<h2 id='summary.rendo.copula.correction'>Summarizing Bootstrapped copulaCorrection Model Fits</h2><span id='topic+summary.rendo.copula.correction'></span>

<h3>Description</h3>

<p><code>summary</code> method for a model of class <code>rendo.copula.correction</code> resulting from fitting <code>copulaCorrection</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rendo.copula.correction'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rendo.copula.correction_+3A_object">object</code></td>
<td>
<p>an object of class <code>rendo.copula.correction</code>, a result of a call to <code>copulaCorrection</code>.</p>
</td></tr>
<tr><td><code id="summary.rendo.copula.correction_+3A_...">...</code></td>
<td>
<p>ignored, for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a single continuous endogenous regressor, the estimation is realized in two steps by first obtaining the
empirical distribution of the endogenous regressor and then the likelihood function is built. Also for all
other cases the estimation is realized in two steps and hence the standard errors reported by the
fitted OLS model are not correct.
</p>
<p>The standard errors and the confidence intervals are therefore obtained using bootstrapping with replacement as
described in Effron (1979). The reported lower and upper boundaries are from the 95% bootstrapped percentile
confidence interval. If there are too few bootstrapped estimates, no boundaries are reported.
</p>
<p>For a single continuous endogenous regressor the model was fitted using maximum likelihood optimization. The
related goodness of fit measures and convergence indicators are also reported here.
</p>


<h3>Value</h3>

<p>The function computes and returns a list of summary statistics which contains the following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a <code>px4</code> matrix with columns for the estimated coefficients for the the original data, the standard error derived from the bootstrapped parameters,
and the lower and upper boundaries of the 95% bootstrap confidence interval.</p>
</td></tr>
<tr><td><code>num.boots</code></td>
<td>
<p>the number of bootstraps performed.</p>
</td></tr>
<tr><td><code>names.main.coefs</code></td>
<td>
<p>a vector specifying which coefficients are from the model. For internal usage.</p>
</td></tr>
<tr><td><code>start.params</code></td>
<td>
<p>a named vector with the initial set of parameters used to optimize the log-likelihood function.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>variance covariance matrix derived from the bootstrapped parameters.</p>
</td></tr>
<tr><td><code>names.vars.continuous</code></td>
<td>
<p>the names of the continuous endogenous regressors.</p>
</td></tr>
<tr><td><code>names.vars.discrete</code></td>
<td>
<p>the names of the discrete endogenous regressors.</p>
</td></tr>
</table>
<p>For the case of a single continuous endogenous regressor, also the following components
resulting from the log-likelihood optimization are returned:
</p>
<table role = "presentation">
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's An Information Criterion for the model fitted on the provided data.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Schwarz's Bayesian Criterion for the model fitted on the provided data.</p>
</td></tr>
<tr><td><code>KKT1</code></td>
<td>
<p>first Kuhn, Karush, Tucker optimality condition as returned by optimx.</p>
</td></tr>
<tr><td><code>KKT2</code></td>
<td>
<p>second Kuhn, Karush, Tucker optimality condition as returned by optimx.</p>
</td></tr>
<tr><td><code>conv.code</code></td>
<td>
<p>the convergence code as returned by optimx.</p>
</td></tr>
<tr><td><code>log.likelihood</code></td>
<td>
<p>the value of the log-likelihood function at the found solution for the provided data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Effron, B.(1979). &quot;Bootstrap Methods: Another Look at the Jackknife&quot;, The Annals of Statistics, 7(1), 1-26.
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+copulaCorrection">copulaCorrection</a></code>
</p>
<p><code><a href="#topic+confint.rendo.boots">confint</a></code> for how the confidence intervals are derived
</p>
<p><code><a href="#topic+vcov.rendo.boots">vcov</a></code> for how the variance-covariance matrix is derived
</p>
<p><code><a href="optimx.html#topic+optimx">optimx</a></code> for explanations about the returned <code>conv.code</code> and <code>KKT</code>.
</p>
<p>Function <code>coef</code> will extract the <code>coefficients</code> matrix and
function <code>vcov</code> will extract the component <code>vcov</code> from the returned summary object.
</p>

<hr>
<h2 id='summary.rendo.latent.IV'>Summarizing latentIV Model Fits</h2><span id='topic+summary.rendo.latent.IV'></span>

<h3>Description</h3>

<p><code>summary</code> method for a model of class <code>rendo.latent.IV</code> resulting from fitting <code>latentIV</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rendo.latent.IV'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rendo.latent.IV_+3A_object">object</code></td>
<td>
<p>an object of class <code>rendo.latent.IV</code>, a result of a call to <code>latentIV</code>.</p>
</td></tr>
<tr><td><code id="summary.rendo.latent.IV_+3A_...">...</code></td>
<td>
<p>ignored, for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.rendo.latent.IV</code> computes and returns a list of summary statistics
which contains the following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a <code>px4</code> matrix with columns for the estimated coefficients, its standard error,
the t-statistic and corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>start.params</code></td>
<td>
<p>a named vector with the initial set of parameters used to optimize the log-likelihood function.</p>
</td></tr>
<tr><td><code>names.main.coefs</code></td>
<td>
<p>a vector specifying which coefficients are from the model. For internal usage.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>variance covariance matrix derived from the hessian.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's An Information Criterion for the model fitted on the provided data.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Schwarz's Bayesian Criterion for the model fitted on the provided data.</p>
</td></tr>
<tr><td><code>KKT1</code></td>
<td>
<p>first Kuhn, Karush, Tucker optimality condition as returned by optimx.</p>
</td></tr>
<tr><td><code>KKT2</code></td>
<td>
<p>second Kuhn, Karush, Tucker optimality condition as returned by optimx.</p>
</td></tr>
<tr><td><code>conv.code</code></td>
<td>
<p>the convergence code as returned by optimx.</p>
</td></tr>
<tr><td><code>log.likelihood</code></td>
<td>
<p>the value of the log-likelihood function at the found solution for the provided data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+latentIV">latentIV</a></code>
</p>
<p>Function <code>coef</code> will extract the <code>coefficients</code> matrix and
function <code>vcov</code> will extract the component <code>vcov</code> from the returned summary object.
</p>

<hr>
<h2 id='summary.rendo.multilevel'>Summarizing Multilevel GMM Estimation with Endogenous Regressors Model Fits</h2><span id='topic+summary.rendo.multilevel'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;<code>rendo.multilevel</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rendo.multilevel'
summary(object, model = c("REF", "FE_L2", "FE_L3", "GMM_L2", "GMM_L3"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rendo.multilevel_+3A_object">object</code></td>
<td>
<p>an object of class &quot;rendo.multilevel&quot;, usually, a result of a call to <code>multilevelIV</code>.</p>
</td></tr>
<tr><td><code id="summary.rendo.multilevel_+3A_model">model</code></td>
<td>
<p>character string to indicate which fitted model should be summarized.
Possible values are: <code>"REF", "FE_L2", "FE_L3", "GMM_L2"</code>, or <code>"GMM_L3"</code>.</p>
</td></tr>
<tr><td><code id="summary.rendo.multilevel_+3A_...">...</code></td>
<td>
<p>ignored, for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multilevelIV() function estimates three models, namely: the usual random
effects model (REF), the fixed effects model (FE) and the hierarchical GMM model (GMM) proposed by Kim and Frees (2007).
The fixed effects and the GMM estimators are calculated at each level - so in the case of a three-level model, the function estimates,
besides the random effects, fixed effects models at level two (FE_L2) and at level three (FE_L3).
The same is true for the GMM estimators, the multilevelIV() function will return a GMM estimator
at level-three (GMM_L3) and a GMM estimator at level two (GMM_L2).
</p>
<p>In order to facilitate the choice of estimator to be used, the <code>summary()</code> function also returns an omitted variable test (OVT).
This test is based on the Hausman test for panel data. The OVT allows the comparison of a robust eastimator and an estimator which is efficient
under the null hypothesis of no omitted variables. Moreover, it allows the comparison of two robust
estimators at different levels.
</p>
<p>For the model specified in  argument <code>model</code>, the <code>summary()</code> function returns the
summary statistics of the estimated coefficients, together with the results of the omitted variable test
between the specified model and each other model.
</p>


<h3>Value</h3>

<p>For the model specified in argument <code>model</code>, the function <code>summary.rendo.multilevel</code> computes and returns
a list of summary statistics and the results of the omitted variable tests for the fitted multilevel object given in <code>object</code>.
</p>
<p>An object of class <code>summary.rendo.multilevel</code> is returned that is a list using the component <code>call</code> of argument <code>object</code>, plus,
</p>
<table role = "presentation">
<tr><td><code>summary.model</code></td>
<td>
<p>the model parameter with which the summary function was called.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code>px4</code> matrix with columns for the estimated coefficients, its standard error,
the t-statistic and corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>OVT.table</code></td>
<td>
<p>results of the Hausman omitted variable test for the specified model compared to all other models.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>variance covariance matrix derived from the GMM fit of this model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+multilevelIV">multilevelIV</a></code>
</p>
<p>Function <code>coef</code> will extract the <code>coefficients</code> matrix and
function <code>vcov</code> will extract the component <code>vcov</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("dataMultilevelIV")
# Fit two levels model
res.ml.L2 &lt;- multilevelIV(y ~ X11 + X12 + X13 + X14 + X15 + X21 + X22 + X23 + X24 + X31 +
                              X32 + X33 + (1|SID) | endo(X15),
                          data = dataMultilevelIV, verbose = FALSE)

# Get summary for FE_L2 (does not print)
res.sum &lt;- summary(res.ml.L2, model = "FE_L2")
# extract table with coefficients summary statistics
sum.stat.FE_L2 &lt;- coef(res.sum)
# extract vcov of model FE_L2
FE_L2.vcov &lt;- vcov(res.sum)
# same as above
FE_L2.vcov &lt;- vcov(res.ml.L2, model = "FE_L2")

</code></pre>

<hr>
<h2 id='vcov.rendo.boots'>Calculate Variance-Covariance Matrix for Models Fitted with Bootstrapped Parameters</h2><span id='topic+vcov.rendo.boots'></span>

<h3>Description</h3>

<p>The variance-covariance matrix is derived from the bootstrapped parameter estimates stored in the object.
It is based on Efron (1979) and calculates the result as follows:
</p>
<div style="text-align:center"> 1/(B-1) * &Sigma;(&theta;<sub>b</sub> - &theta;&#773;)(&theta;<sub>b</sub> - &theta;&#773;)' </div>
<p>where B is the number of bootstraps and &theta;&#773; is the mean of the bootstrapped coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rendo.boots'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.rendo.boots_+3A_object">object</code></td>
<td>
<p>a fitted model object with bootstrapped parameters. Typically from <code>copulaCorrection</code></p>
</td></tr>
<tr><td><code id="vcov.rendo.boots_+3A_...">...</code></td>
<td>
<p>ignored, for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the estimated covariances between the parameter estimates of the model.
The row and column names correspond to the parameter names given by the <code>coef</code> method.
</p>


<h3>References</h3>

<p>Effron, B.(1979). &quot;Bootstrap Methods: Another Look at the Jackknife&quot;, The Annals of Statistics, 7(1), 1-26.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
