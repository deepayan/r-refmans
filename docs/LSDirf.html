<!DOCTYPE html><html><head><title>Help for package LSDirf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LSDirf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LSDirf-package'>
<p>Impulse-Response Function Analysis for Agent-Based Models</p></a></li>
<li><a href='#irf.lsd'>
<p>Impulse-response function analysis</p></a></li>
<li><a href='#state.ident.lsd'>
<p>IRF state Identification</p></a></li>
<li><a href='#state.irf.lsd'>
<p>State-dependent impulse-response function analysis</p></a></li>
<li><a href='#state.sa.lsd'>
<p>Sensitivity analysis of IRF to state variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Impulse-Response Function Analysis for Agent-Based Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-4-4</td>
</tr>
<tr>
<td>Description:</td>
<td>Performing impulse-response function (IRF) analysis of relevant variables of agent-based simulation models, in particular for models described in 'LSD' format. Based on the data produced by the simulation model, it performs both linear and state-dependent IRF analysis, providing the tools required by the Counterfactual Monte Carlo (CMC) methodology (Amendola and Pereira (2024) &lt;<a href="https://doi.org/10.2139%2Fssrn.4740360">doi:10.2139/ssrn.4740360</a>&gt;), including state identification and sensitivity. CMC proposes retrieving the causal effect of shocks by exploiting the opportunity to directly observe the counterfactual in a fully controlled experimental setup. 'LSD' (Laboratory for Simulation Development) is free software available at <a href="https://www.labsimdev.org/">https://www.labsimdev.org/</a>).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, grDevices, graphics, boot, digest, gplots,
abind, partykit, randomForest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>LSDinterface, LSDsensitivity</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 13:43:12 UTC; Marcelo</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcelo C. Pereira
    <a href="https://orcid.org/0000-0002-8069-2734"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Marco Amendola <a href="https://orcid.org/0000-0003-3056-5558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcelo C. Pereira &lt;mcper@unicamp.br&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-04 17:53:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='LSDirf-package'>
Impulse-Response Function Analysis for Agent-Based Models
</h2><span id='topic+LSDirf-package'></span><span id='topic+LSDirf'></span>

<h3>Description</h3>

<p>Performing impulse-response function (IRF) analysis of relevant variables of agent-based simulation models, in particular for models described in 'LSD' format. Based on the data produced by the simulation model, it performs both linear and state-dependent IRF analysis, providing the tools required by the Counterfactual Monte Carlo (CMC) methodology (Amendola and Pereira (2024) &lt;doi:10.2139/ssrn.4740360&gt;), including state identification and sensitivity. CMC proposes retrieving the causal effect of shocks by exploiting the opportunity to directly observe the counterfactual in a fully controlled experimental setup. 'LSD' (Laboratory for Simulation Development) is free software available at &lt;https://www.labsimdev.org/&gt;).
</p>


<h3>Details</h3>

<p>The Counterfactual Monte Carlo (<strong>CMC</strong>) methodology (see note below) is based on the analysis of samples of seed-specific impulse-response functions (IRF's) and cumulative impulse-response functions (CIRF's) of size N. These samples are highly informative about the effects of a shock affecting a simulation running in LSD, with several statistics of interest that can be computed from them.
</p>
<p>In particular, assuming that the mean or the median is chosen as the metric to synthesize information included in these samples, robust IRF and CIRF may be obtained by properly combining the N seed-specific IRF's and CIRF's across the different time horizons. These measures represent the mean/median dynamic effect of a designated shock. Confidence intervals can be obtained by bootstrap, thus allowing the analysis of the uncertainty around these effects.
</p>
<p>The CMC methodology allows going beyond the linear effects. Eventual state-dependent effects of the shock can be investigated starting from the IRF and CIRF samples, exploiting the heterogeneity in the simulated system conditions of different runs of the CMC experiment.
</p>
<p>In particular, in line with the threshold local projections models adopted in several empirical analyses (e.g., Ramey and Zubairy, 2018), the runs of the CMC experiment can be split into alternative states by comparing the value of one or more <em>state variable</em> with a (some) specific threshold(s), computed from the realizations of selected variables' time series in the periods before the shock. As in the case of linear estimates, the confidence intervals around these impulse responses can be constructed via bootstrap, which in this case are also very useful to visually assess the significance of any differences in the impulse responses between alternative states. Several standard statistical tests, such as the t-test or the Mann-Whitney U test, can then be applied to better investigate the significance of state-dependent results.
</p>
<p>Such state-dependent analysis can be potentially conducted in two ways. The first is by testing the results against a set of relevant and distinctive system states <em>known</em> to the researcher (e.g., Auerbach and Gorodnichenko, 2013). The second takes the alternative approach: instead of testing whether specific states significantly impact the effect of the shock, try to find such states from simulated data. A similar target, for example, is at the heart of the recent literature on <em>optimal policy</em>, which goal is to find the optimal allocation of the treatment across heterogeneous units (e.g., Kitagawa and Tetenov, 2018; Athey and Wager, 2021). We offer a data-driven heuristic to this aim that helps discover such states. It is named Random Forest State Identification Algorithm (RFSIA) as it adapts the random forest machine learning technique to our goal.
</p>
<p>The main intuition behind the RFSIA is to use a random forest classifier to obtain a set of <em>meaningful</em> data stratifications to test for state dependency. More precisely, the idea is to test the state dependency in the final nodes of the regression trees produced by the algorithm and then recombine and rearrange this extremely detailed information to obtain a more general sense of which states have a significant impact on the effect of the shock. In particular, to make the output more understandable and bring out the more evident state patterns, the last step of RFSIA is the quantile discretization of the system states. To this aim, we divide each state variable into deciles and replace the threshold values entering each state, and grouping of similar states.
</p>
<p>More details on the methodology, and a comprehensive application to a full LSD simulation model, can be found in Amendola and Pereira (2024).
</p>


<h3>Note</h3>

<p>The <strong>CMC</strong> methodology proposes retrieving the causal effect of shocks by directly exploiting the opportunity to observe the counterfactual in a fully controlled experimental setup. Indeed, counterfactuals emerge naturally in agent-based models if two simulation runs characterized by the same values of the parameters, the same initial conditions, and the same seed of the pseudo-random number generator (PRNG) are considered, and a single shock is introduced in one of them. In these specific circumstances, the non-shocked realization acts as a direct counterfactual for the shocked one, and any difference between the shocked and non-shocked output time series can be directly traced back to the shock.
</p>
<p>Building on this insight, the effects of shocks in an agent-based model can be rigorously studied based on the following procedure, which allows collecting a sample of size N of the (dynamic) unit treatment effect:
</p>

<ol>
<li><p> Defining a shock generating rule (<code class="reqn">sgr \in \{0, 1\}</code>), which precisely defines the shock to be tested, that is, which and how model variable(s) is(are) shocked. 
</p>
</li>
<li><p> Running two simulation runs with the same values of parameters, initial conditions, and the PRNG seed but enabling the shock (<code class="reqn">sgr=1</code>) in just one of them.
</p>
</li>
<li><p> Computing the difference in the time series of interest between the two scenarios (counterfactual: <code class="reqn">sgr = 0</code>; shocked scenario: <code class="reqn">sgr = 1</code>). In particular, two main metrics can be used to quantify the effects of the shock, namely the impulse-response function (IRF) and the cumulative impulse-response function (CIRF). Depending on the specific variable of interest, impulse response functions can be computed in percentage or absolute terms.
</p>
</li>
<li><p> Repeating steps 2 and 3 N times by varying the seed of the PRNG, i.e. running an extensive Monte Carlo experiment.
</p>
</li></ol>

<p>The last step is crucial to robustly evaluate the effect of the shock in an agent-based model. Indeed, in these models, impulse responses are expected to vary by varying the seed. Two explanations for the cross-run variability are possible if the shock size is homogeneous across runs under different seeds. The first one lies in the seed-specific after-shock realizations of the stochastic parts of the model, which is expected to impact the propagation of shocks in the model unpredictably. This implies that the transmission of shocks is inevitably affected by some randomness in most agent-based models. The second reason is instead related to the possibility that, in agent-based models, the effects of shocks may depend on the state of the system, i.e., the propagation of the shocks may be <em>structurally</em> amplified or weakened depending on the prevailing conditions. As the state of the system is generally different in each run of the CMC experiment (due to the seed-specific pre-shock realizations of the stochastic parts of the model), this <em>structural effect</em> is expected to vary between seeds.
</p>
<p>As a consequence of the two cross-run variability channels, the results of a single MC experiment based on a specific seed are not informative enough. Instead, an extensive Monte Carlo experiment in needed, which allows for uncovering the distributional properties of such variability and the study of the effects of shocks in a robust way.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira [aut, cre] (&lt;https://orcid.org/0000-0002-8069-2734&gt;),
  Marco Amendola [aut] (&lt;https://orcid.org/0000-0003-3056-5558&gt;)
</p>
<p>Maintainer: Marcelo C. Pereira &lt;mcper@unicamp.br&gt;
</p>


<h3>References</h3>

<p>LSD documentation is available at &lt;<a href="https://www.labsimdev.org/">https://www.labsimdev.org/</a>&gt;
</p>
<p>The latest LSD binaries and source code can be downloaded at &lt;<a href="https://github.com/SantannaKS/Lsd/">https://github.com/SantannaKS/Lsd/</a>&gt;.
</p>
<p>Amendola, M., Pereira, M. C. (2024) <em>Linear and state-dependent impulse responses in agent-based models: a new methodology and an economic application</em>. SSRN pre-print &lt;doi:10.2139/ssrn.4740360&gt;. Available at &lt;<a href="https://www.ssrn.com/abstract=4740360">https://www.ssrn.com/abstract=4740360</a>&gt;.
</p>
<p>Athey S., Wager, S. (2021) <em>Policy learning with observational data</em>. Econometrica
89(1):133-161
</p>
<p>Auerbach A., Gorodnichenko, Y. (2013) <em>Fiscal multipliers in recession and
expansion</em>. Fiscal Policy After the Financial Crisis, edited by Alberto Alesina and Francesco Giavazzi. University of Chicago Press
</p>
<p>Kitagawa, T., Tetenov, A. (2018) <em>Who should be treated? empirical welfare maximization methods for treatment choice</em>. Econometrica
86(2):591-616
</p>
<p>Ramey, V., Zubairy, S. (2018) <em> Government spending multipliers in good times and in bad: evidence from us historical data</em>. Journal of political economy 126(2):850-901
</p>


<h3>See Also</h3>

<p><a href="LSDinterface.html#topic+LSDinterface-package">LSDinterface-package</a>, <a href="LSDsensitivity.html#topic+LSDsensitivity-package">LSDsensitivity-package</a>
</p>

<hr>
<h2 id='irf.lsd'>
Impulse-response function analysis
</h2><span id='topic+irf.lsd'></span>

<h3>Description</h3>

<p>This function performs a (linear) impulse-response function (IRF) analysis on the data produced by a Monte Carlo experiment, typically from (but not restricted to) a LSD simulation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irf.lsd( data, data.shock, t.horiz, var.irf, var.shock, var.ref = NULL,
         irf.type = c( "incr.irf", "cum.irf", "peak.mult", "cum.mult", "none" ),
         stat = c( "mean", "median" ), ci.R = 999,
         ci.type = c( "basic", "perc", "bca" ),
         lim.outl = 0, alpha = 0.05, seed = 1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irf.lsd_+3A_data">data</code></td>
<td>
<p>numeric: a 3-dimensional array containing data from Monte Carlo (MC) simulation samples where the impulse (shock/treatment) was not applied/occurred. The array must have dimensions ordered as time steps x variables x MC samples. This format is automatically produced by <a href="LSDinterface.html#topic+read.3d.lsd">read.3d.lsd</a> but using it is not required. The second array dimension (variables) must be named with the names of the variables used in the analysis. The absolute minimum array dimensions are 2x1x2.
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_data.shock">data.shock</code></td>
<td>
<p>numeric: a 3-dimensional array similar to <code>data</code> but containing data from MC samples where the impulse (shock/treatment) was applied/occurred. The array must have as dimensions: time steps x variables x MC samples. This can produced by <a href="LSDinterface.html#topic+read.3d.lsd">read.3d.lsd</a>, but this is not required. The first two dimensions must be similar between <code>data</code> and <code>data.shock</code>, containing the same time steps and variable names
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_t.horiz">t.horiz</code></td>
<td>
<p>integer: a positive value indicating the post-impulse time span to consider for analysis.
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_var.irf">var.irf</code></td>
<td>
<p>string: the variable name on which perform the analysis. It must be one of the column names in <code>data</code>.
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_var.shock">var.shock</code></td>
<td>
<p>string: the name of the variable containing the impulse/shock. It must be one of the column names in <code>data.shock</code>.
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_var.ref">var.ref</code></td>
<td>
<p>string: the name of a reference variable to scale down (divide) the shock variable. The default is to do no scaling. If provided, it must be one of the column names in <code>data</code>. The special value <code>"%"</code> represents the same variable as the shock one, but using the corresponding non-shock values, so effectively standardizing the shock values.
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_irf.type">irf.type</code></td>
<td>
<p>string: one of five options (<code>"incr.irf"</code>, <code>"cum.irf"</code>, <code>"peak.mult"</code>, <code>"cum.mult"</code>, or <code>"none"</code>) defining the type of function plot to be produced: incremental impulse-response, cumulative impulse-response, peak multiplier, cumulative multiplier, or no plot. It also selects the type of function to be used when printing reports (response or multiplier functions). The default is <code>"incr.irf"</code>. This option only affect the plot, not the produced data, as all function values are always computed and saved in the output object.
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_stat">stat</code></td>
<td>
<p>string: one of <code>"mean"</code> or <code>"median"</code>, representing the Monte Carlo statistic used to compare samples. It also selects the corresponding deviation measure, between the standard deviation (SD) or the median absolute deviation (MAD). The default is to use the mean and SD.
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_ci.r">ci.R</code></td>
<td>
<p>integer: number of bootstrap replicates when computing the bootstrap confidence interval.
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_ci.type">ci.type</code></td>
<td>
<p>string: the type of bootstrap confidence interval to compute, must be one of <code>"basic"</code> (the default), <code>"perc"</code> (percentile interval), or <code>"bca"</code> (BCa - adjusted percentile interval).
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_lim.outl">lim.outl</code></td>
<td>
<p>numeric: a positive outlier threshold limit multiple, applied over the distance between the first and the fourth quartiles of the Monte Carlo data. Outlier samples below or above the computed thresholds are removed from the analysis. The default (<code>0</code>), is to keep all samples (no outlier removal).
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_alpha">alpha</code></td>
<td>
<p>numeric: a value between 0 and 0.5, defining the desired statistical significance level to be adopted in the analysis. The default is 0.05 (5%).
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_seed">seed</code></td>
<td>
<p>integer: a value defining the initial state of the pseudo-random number generator.
</p>
</td></tr>
<tr><td><code id="irf.lsd_+3A_...">...</code></td>
<td>
<p>additional parameters to configure printing and plotting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a dynamic system, a simulation model may have its outputs analyzed when a brief input signal (an impulse or &quot;shock&quot;) is applied to one of its inputs.
</p>
<p>The function operates over <code>data</code> from multiple realizations of a Monte Carlo experiment.
</p>


<h3>Value</h3>

<p>It returns an object of class <code>irf.lsd</code>, which has <code>print</code>- and <code>plot</code>-specific methods for presenting the analysis results. This object contains several items:
</p>
<table>
<tr><td><code>irf</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the average or median (according to <code>stat</code>) incremental impulse response function data.
</p>
</td></tr>
<tr><td><code>cirf</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the average or median (according to <code>stat</code>) cumulative impulse response function data.
</p>
</td></tr>
<tr><td><code>pmf</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the average or median (according to <code>stat</code>) peak-multiplier function data. The peak impulse-multiplier function evaluates the analysis variable (<code>var.irf</code>) as a multiple of the impulse variable (<code>var.shock</code>) at the shock start time.
</p>
</td></tr>
<tr><td><code>cmf</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the average or median (according to <code>stat</code>) cumulative impulse-multiplier function data. The cumulative-multiplier function evaluates the accumulated analysis variable (<code>var.irf</code>), from impulse time, as a multiple of the accumulated impulse variable (<code>var.shock</code>) over the time horizon (<code>t.horiz</code>).
</p>
</td></tr>
<tr><td><code>irf.ci.lo</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the confidence interval lower limit of incremental impulse response function data.
</p>
</td></tr>
<tr><td><code>irf.ci.hi</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the confidence interval upper limit of incremental impulse response function data.
</p>
</td></tr>
<tr><td><code>cirf.ci.lo</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the confidence interval lower limit of cumulative impulse response function data.
</p>
</td></tr>
<tr><td><code>cirf.ci.hi</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the confidence interval upper limit of cumulative impulse response function data.
</p>
</td></tr>
<tr><td><code>pmf.ci.lo</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the confidence interval lower limit of peak multiplier function data.
</p>
</td></tr>
<tr><td><code>pmf.ci.hi</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the confidence interval upper limit of peak multiplier function data.
</p>
</td></tr>
<tr><td><code>cmf.ci.lo</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the confidence interval lower limit of cumulative multiplier function data.
</p>
</td></tr>
<tr><td><code>cmf.ci.hi</code></td>
<td>
<p>numeric: vector of length <code>t.horiz + 1</code> containing the confidence interval upper limit of cumulative multiplier function data.
</p>
</td></tr>
<tr><td><code>irf.ylim</code></td>
<td>
<p>numeric: vector of length two containing the absolute minimum and maximum values for the incremental impulse response function data.
</p>
</td></tr>
<tr><td><code>cirf.ylim</code></td>
<td>
<p>numeric: vector of length two containing the absolute minimum and maximum values for the cumulative impulse response function data.
</p>
</td></tr>
<tr><td><code>pmf.ylim</code></td>
<td>
<p>numeric: vector of length two containing the absolute minimum and maximum values for the peak multiplier function data.
</p>
</td></tr>
<tr><td><code>cmf.ylim</code></td>
<td>
<p>numeric: vector of length two containing the absolute minimum and maximum values for the cumulative multiplier function data.
</p>
</td></tr>
<tr><td><code>ir</code></td>
<td>
<p>numeric: data frame with <code>nsample</code> (see below) rows and <code>t.horiz + 1</code> columns. The data frame is the set of individual incremental impulse responses from each Monte Carlo (MC) sample.
</p>
</td></tr>
<tr><td><code>cir</code></td>
<td>
<p>numeric: data frame with <code>nsample</code> (see below) rows and <code>t.horiz + 1</code> columns. The data frame is the set of individual cumulative impulse responses from each MC sample.
</p>
</td></tr>
<tr><td><code>pm</code></td>
<td>
<p>numeric: data frame with <code>nsample</code> (see below) rows and <code>t.horiz + 1</code> columns. The data frame is the set of individual peak multipliers from each MC sample.
</p>
</td></tr>
<tr><td><code>cm</code></td>
<td>
<p>numeric: data frame with <code>nsample</code> (see below) rows and <code>t.horiz + 1</code> columns. The data frame is the set of individual cumulative multipliers from each MC sample.
</p>
</td></tr>
<tr><td><code>t.shock</code></td>
<td>
<p>numeric: vector of length equal to <code>nsample</code> (see below), containing the time the shock was detected in each MC sample.
</p>
</td></tr>
<tr><td><code>t.horiz</code></td>
<td>
<p>integer: the time horizon used in the analysis (same as the <code>t.horiz</code> argument).
</p>
</td></tr>
<tr><td><code>var.irf</code></td>
<td>
<p>character: the name of the variable used in the impulse-response analysis (same as the <code>var.irf</code> argument).
</p>
</td></tr>
<tr><td><code>var.shock</code></td>
<td>
<p>character: the name of the shock variable used in the analysis (same as the <code>var.shock</code> argument).
</p>
</td></tr>
<tr><td><code>var.ref</code></td>
<td>
<p>character: the name of the scale-reference variable used in the analysis (same as the <code>var.ref</code> argument).
</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>character: the Monte Carlo statistic used in the analysis (same as the <code>stat</code> argument).
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>numeric: the statistical significance level used in the analysis (same as the <code>alpha</code> argument).
</p>
</td></tr>
<tr><td><code>nsample</code></td>
<td>
<p>integer: the effective number of of Monte Carlo (MC) samples effectively used for deriving the response function, after the removal of outliers if <code>lim.outl &gt; 0</code>.
</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>integer: vector containing the number of each MC sample considered an outlier, and so removed from the analysis, or an empty vector if no outlier was excluded. The MC numbers are the indexes to the third dimension of <code>data</code>.
</p>
</td></tr>
<tr><td><code>data.crc</code></td>
<td>
<p>character: an hexadecimal sting containing the 32-bit Cyclic Redundancy Check (CRC32) for the <code>data</code> used in the analysis.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>character: the command line used to call the function.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See the note in <a href="#topic+LSDirf-package">LSDirf-package</a> for an methodological overview and for instructions on how to perform the (linear) impulse-response function analysis.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira [aut, cre] (&lt;https://orcid.org/0000-0002-8069-2734&gt;),
  Marco Amendola [aut] (&lt;https://orcid.org/0000-0003-3056-5558&gt;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+state.irf.lsd">state.irf.lsd</a></code>,
<code><a href="LSDinterface.html#topic+read.3d.lsd">read.3d.lsd</a></code>,
<code><a href="LSDinterface.html#topic+read.4d.lsd">read.4d.lsd</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data generation: Y is an AR(1) process that may receive a shock at
# t=50, S is the shock (0/1), a combination of 3 AR(1) processes (X1-X3)
# X4 is another AR(1) process, uncorrelated with S, X4sq is just X4^2
# All AR(1) processes have the same phi=0.98 coefficient, and are Monte
# Carlo sampled 500 times
set.seed( 1 )   # make results reproducible
# LSD-like arrays to store simulated time series (t x var x MC)
dataNoShock &lt;- dataShock &lt;-array ( 0, dim = c( 60, 7, 500 ) )
colnames( dataNoShock ) &lt;- colnames( dataShock ) &lt;-
  c( "Y", "S", "X1", "X2", "X3", "X4", "X4sq" )
# Monte Carlo sampling
for( n in 1 : 500 ) {
  # simulation time
  for( t in 2 : 60 ) {
    # AR process on X vars
    for( v in c( "X1", "X2", "X3", "X4" ) ) {
      dataNoShock[ t, v, n ] = dataShock[ t, v, n ] =
        0.98 * dataShock[ t - 1, v, n ] + rnorm( 1, 0, 0.1 )
    }
    # apply shock once
    if( t == 50 ) {
      dataShock[ t, "S", n ] &lt;- 1
      shockEff &lt;- 0.4 + 0.7 * isTRUE( dataShock[ t, "X1", n ] &gt; 0.1 ) -
        0.4 * isTRUE( dataShock[ t, "X2", n ] &gt; 0.1 ) +
        0.2 * isTRUE( dataShock[ t, "X3", n ] &gt; 0.05 ) + rnorm( 1, 0, 0.2 )
    } else
      shockEff &lt;- 0
    # AR process on Y var
    rs &lt;- rnorm( 1, 0, 0.1 )
    dataNoShock[ t, "Y", n ] = 0.98 * dataNoShock[ t - 1, "Y", n ] + rs
    dataShock[ t, "Y", n ] = 0.98 * dataShock[ t - 1, "Y", n ] + shockEff + rs
  }
}
# another uncorrelated var
dataNoShock[ , "X4sq", ] &lt;- dataShock[ , "X4sq", ] &lt;- dataShock[ , "X4", ] ^ 2

# linear IRF analysis
linearIRF &lt;- irf.lsd( data = dataNoShock,     # non-shocked MC data
                      data.shock = dataShock, # shocked data
                      t.horiz = 10,           # post-shock analysis time horizon
                      var.irf = "Y",          # variable to compute IRF
                      var.shock = "S" )       # shock variable (impulse)

plot( linearIRF, irf.type = "cum.irf" )       # cumulative IRF plot

print( linearIRF )                            # show IRF data

</code></pre>

<hr>
<h2 id='state.ident.lsd'>
IRF state Identification
</h2><span id='topic+state.ident.lsd'></span>

<h3>Description</h3>

<p>This function implements the Random Forest Identification Algorithm (RFSIA) on the data produced by a Monte Carlo experiment, typically from (but not restricted to) a LSD simulation model. It exploits the random forest regression technique to obtain a series of &quot;meaningful&quot; stratifications of the data on which state-dependence is then tested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state.ident.lsd( data, irf, state.vars = NULL, metr.irf = NULL,
                 add.vars = NULL, state.cont = FALSE,
                 ntree = 500, maxdepth = 1, nodesize  = 5,
                 mtry = max( floor( ifelse( ! is.null( state.vars ),
                                            length( state.vars ),
                                            dim( data )[ 2 ] ) / 3 ),
                             1 ),
                 quantile = 10, alpha = 0.05, seed = 1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state.ident.lsd_+3A_data">data</code></td>
<td>
<p>numeric: a 3-dimensional array containing data from Monte Carlo (MC) simulation samples where the impulse (shock/treatment) was not applied/occurred. The array must have dimensions ordered as time steps x variables x MC samples. This format is automatically produced by <a href="LSDinterface.html#topic+read.3d.lsd">read.3d.lsd</a> but using it is not required. The second array dimension (variables) must be named with the names of the variables used in the analysis. The absolute minimum array dimensions are 2x1x2.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_irf">irf</code></td>
<td>
<p>object: an object produced by a previous run of <code><a href="#topic+irf.lsd">irf.lsd</a></code> over the same dataset (as defined by <code>data</code>).
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_state.vars">state.vars</code></td>
<td>
<p>character: a vector of variable names to consider as state variables.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_metr.irf">metr.irf</code></td>
<td>
<p>function: a function that assigns a metric to compare each run of a Monte Carlo experiment, to be used on regressions. The function must take a cumulative impulse-response matrix, organized as runs on rows and response times (0, 1, ...,<code>t.horiz</code>) on columns. It must return a numeric vector of length equal to the number of runs, defining the metric associated with each run. Higher metric values correspond to increased impulse effect. If no function is supplied (<code>NULL</code>), the default, the mean of state variable value(s) from impulse time (<code>t=0</code>) until the time horizon (<code>t=t.horiz</code>) is used as metric.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_add.vars">add.vars</code></td>
<td>
<p>function: an optional function to add new variables to the MC dataset, before the analysis is performed. The function must take a single Monte Carlo run data frame, organized as time on rows and (original) variables on columns. It must return this data frame with new column(s) added, one per each new variable.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_state.cont">state.cont</code></td>
<td>
<p>logical: if <code>TRUE</code>, the resulting object will contain the full list of continuous states produced during the analysis. If <code>FALSE</code>, the default, the list of continuous states is not saved.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_ntree">ntree</code></td>
<td>
<p>integer: number of trees to grow. This number should not be set to too small values, to ensure that every possible state gets predicted at least a few times.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_maxdepth">maxdepth</code></td>
<td>
<p>integer: maximum depth of the trees to consider. The default (1) represents the shortest possible trees.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_nodesize">nodesize</code></td>
<td>
<p>integer: minimum number of associated data observations to a node be considered in the analysis.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_mtry">mtry</code></td>
<td>
<p>integer: number of state variables randomly sampled as candidates at each node for the random forest algorithm. The default is to use one third of the number of considered state variables.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_quantile">quantile</code></td>
<td>
<p>integer: number of quantiles to consider when discretizing states.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_alpha">alpha</code></td>
<td>
<p>numeric: a value between 0 and 0.5, defining the desired statistical significance level to be adopted in the analysis. The default is 0.05 (5%).
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_seed">seed</code></td>
<td>
<p>integer: a value defining the initial state of the pseudo-random number generator.
</p>
</td></tr>
<tr><td><code id="state.ident.lsd_+3A_...">...</code></td>
<td>
<p>additional parameters to configure printing and plotting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a dynamic system, a simulation model may have its outputs analyzed when a brief input signal (an impulse or &quot;shock&quot;) is applied to one of its inputs. In particular, the effect of the shock may be correlated to some system-specific state, in which it may be amplified or attenuated. This function allows for the identification of possible relevant states, that is, states which are both probable and distinguishable among them.
</p>
<p>The function operates over <code>data</code> from multiple realizations of a Monte Carlo experiment, and a previous (linear) impulse-response function analysis (<code>irf</code>) performed by <code><a href="#topic+irf.lsd">irf.lsd</a></code>.
</p>


<h3>Value</h3>

<p>It returns an object of class <code>state.ident.lsd</code>, which has a <code>print</code>-specific method for presenting the analysis results. This object contains several items:
</p>
<table>
<tr><td><code>state.freq</code></td>
<td>
<p>data frame: each row represents one of the identified discrete states, ordered in decreasing frequency. First column (<code>State</code>) identifies the state textually, in terms of state variable values in terms of the quantiles (as defined by <code>quantile</code> argument). Second column (<code>Prob</code>) lists the frequency of the state among the random forest sample used. Third column (<code>MetrD</code>) brings the mean/median (according to <code>stat</code> in <code><a href="#topic+irf.lsd">irf.lsd</a></code>) relative metric of the state. Fourth column (<code>MetrAD</code>) presents the mean/median of the absolute deviations relative to the state metric. The next columns, in groups of four, bring the mean/median threshold quantile, its standard deviation or variance absolute deviation (MAD), and absolute minimum and maximum. These groups repeat for each state variable considered in the respective identified state.
</p>
</td></tr>
<tr><td><code>state.vars</code></td>
<td>
<p>character: a vector of variable names effectively available as state variables.
</p>
</td></tr>
<tr><td><code>t.horiz</code></td>
<td>
<p>integer: the time horizon used in the analysis (same as the <code>t.horiz</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).
</p>
</td></tr>
<tr><td><code>var.irf</code></td>
<td>
<p>character: the name of the variable used in the impulse-response analysis (same as the <code>var.irf</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).
</p>
</td></tr>
<tr><td><code>var.ref</code></td>
<td>
<p>character: the name of the scale-reference variable used in the analysis (same as the <code>var.ref</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).
</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>character: the Monte Carlo statistic used in the analysis (same as the <code>stat</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>numeric: the statistical significance level used in the analysis (same as the <code>alpha</code> argument).
</p>
</td></tr>
<tr><td><code>nsample</code></td>
<td>
<p>integer: the effective number of of Monte Carlo (MC) samples effectively used for deriving the response function, after the removal of outliers if <code>lim.outl &gt; 0</code> in <code><a href="#topic+irf.lsd">irf.lsd</a></code>.
</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>integer: vector containing the number of each MC sample considered an outlier, and so removed from the analysis in <code><a href="#topic+irf.lsd">irf.lsd</a></code>, or an empty vector if no outlier was excluded. The MC numbers are the indexes to the third dimension of <code>data</code>.
</p>
</td></tr>
<tr><td><code>ntree</code></td>
<td>
<p>integer: number of trees grown (same as <code>ntree</code> argument).
</p>
</td></tr>
<tr><td><code>maxdepth</code></td>
<td>
<p>integer: maximum depth of the trees considered (same as <code>maxdepth</code> argument).
</p>
</td></tr>
<tr><td><code>nodesize</code></td>
<td>
<p>integer: minimum number of data observations in a node considered  (same as <code>nodesize</code> argument).
</p>
</td></tr>
<tr><td><code>mtry</code></td>
<td>
<p>integer: number of state variables sampled per node (same as <code>mtry</code> argument).
</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>integer: number of quantiles used for discretizing states (same as <code>quantile</code> argument).
</p>
</td></tr>
<tr><td><code>state.cont</code></td>
<td>
<p>data frame: each row represents one of the identified continuous states, ordered by the absolute effect on the metric. Columns are organized in groups of three: state variable name (<code>VarN</code>), relation code (<code>RelN</code>), and split threshold (<code>VarN</code>). There is one column group per variable included in the corresponding state. After all column groups, there is a final column presenting the metric deviation (from non-shocked response) of each identified state.
</p>
</td></tr>
<tr><td><code>state.cont.num</code></td>
<td>
<p>integer: the total number of continuous states identified.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>character: the command line used to call the function.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See the note in <a href="#topic+LSDirf-package">LSDirf-package</a> for an methodological overview and for instructions on how to perform the state-dependent impulse-response function analysis.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira [aut, cre] (&lt;https://orcid.org/0000-0002-8069-2734&gt;),
  Marco Amendola [aut] (&lt;https://orcid.org/0000-0003-3056-5558&gt;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irf.lsd">irf.lsd</a></code>,
<code><a href="LSDinterface.html#topic+read.3d.lsd">read.3d.lsd</a></code>,
<code><a href="LSDinterface.html#topic+read.4d.lsd">read.4d.lsd</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data generation: Y is an AR(1) process that may receive a shock at
# t=50, S is the shock (0/1), a combination of 3 AR(1) processes (X1-X3)
# X4 is another AR(1) process, uncorrelated with S, X4sq is just X4^2
# All AR(1) processes have the same phi=0.98 coefficient, and are Monte
# Carlo sampled 500 times
set.seed( 1 )   # make results reproducible
# LSD-like arrays to store simulated time series (t x var x MC)
dataNoShock &lt;- dataShock &lt;-array ( 0, dim = c( 60, 7, 500 ) )
colnames( dataNoShock ) &lt;- colnames( dataShock ) &lt;-
  c( "Y", "S", "X1", "X2", "X3", "X4", "X4sq" )
# Monte Carlo sampling
for( n in 1 : 500 ) {
  # simulation time
  for( t in 2 : 60 ) {
    # AR process on X vars
    for( v in c( "X1", "X2", "X3", "X4" ) ) {
      dataNoShock[ t, v, n ] = dataShock[ t, v, n ] =
        0.98 * dataShock[ t - 1, v, n ] + rnorm( 1, 0, 0.1 )
    }
    # apply shock once
    if( t == 50 ) {
      dataShock[ t, "S", n ] &lt;- 1
      shockEff &lt;- 0.4 + 0.7 * isTRUE( dataShock[ t, "X1", n ] &gt; 0.1 ) -
        0.4 * isTRUE( dataShock[ t, "X2", n ] &gt; 0.1 ) +
        0.2 * isTRUE( dataShock[ t, "X3", n ] &gt; 0.05 ) + rnorm( 1, 0, 0.2 )
    } else
      shockEff &lt;- 0
    # AR process on Y var
    rs &lt;- rnorm( 1, 0, 0.1 )
    dataNoShock[ t, "Y", n ] = 0.98 * dataNoShock[ t - 1, "Y", n ] + rs
    dataShock[ t, "Y", n ] = 0.98 * dataShock[ t - 1, "Y", n ] + shockEff + rs
  }
}
# another uncorrelated var
dataNoShock[ , "X4sq", ] &lt;- dataShock[ , "X4sq", ] &lt;- dataShock[ , "X4", ] ^ 2

# linear IRF analysis
linearIRF &lt;- irf.lsd( data = dataNoShock,       # non-shocked MC data
                      data.shock = dataShock,   # shocked data
                      t.horiz = 10,             # post-shock analysis t horizon
                      var.irf = "Y",            # variable to compute IRF
                      var.shock = "S",          # shock variable (impulse)
                      irf.type = "none" )       # no plot of linear IRF

# Random-forest state identification
stateId &lt;- state.ident.lsd( data = dataNoShock, # non-shocked MC data
                            irf = linearIRF,    # linear IRF produced by irf.lsd
                            state.vars = c( "X1", "X2", "X3", "X4", "X4sq" ),
                                                # state variables to consider
                            mtry = 3 )          # number of samples per node

print( stateId )                                # show identification data

# state-dependent IRF analysis for most frequent state identified
stateIRF &lt;- state.irf.lsd( data = dataNoShock,  # non-shocked MC data
                           irf = linearIRF,     # linear IRF produced by irf.lsd
                           states = stateId )   # object with identified states

plot( stateIRF, irf.type = "cum.irf" )          # cumulative IRF plot

print( stateIRF )                               # show IRF data

</code></pre>

<hr>
<h2 id='state.irf.lsd'>
State-dependent impulse-response function analysis
</h2><span id='topic+state.irf.lsd'></span>

<h3>Description</h3>

<p>This function performs a state-dependent impulse-response function (IRF) analysis on the data produced by a Monte Carlo experiment, typically from (but not restricted to) a LSD simulation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state.irf.lsd( data, irf, states = NULL, state.num = 1,
               state.vars = NULL, eval.state = NULL,
               metr.irf = NULL, add.vars = NULL,
               irf.type = c( "incr.irf", "cum.irf", "peak.mult",
                             "cum.mult", "none" ),
               state.plot = 0, ci.R = 999,
               ci.type = c( "basic", "perc", "bca" ),
               alpha = 0.05, seed = 1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state.irf.lsd_+3A_data">data</code></td>
<td>
<p>numeric: a 3-dimensional array containing data from Monte Carlo (MC) simulation samples where the impulse (shock/treatment) was not applied/occurred. The array must have dimensions ordered as time steps x variables x MC samples. This format is automatically produced by <a href="LSDinterface.html#topic+read.3d.lsd">read.3d.lsd</a> but using it is not required. The second array dimension (variables) must be named with the names of the variables used in the analysis. The absolute minimum array dimensions are 2x1x2.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_irf">irf</code></td>
<td>
<p>object: an object produced by a previous run of <code><a href="#topic+irf.lsd">irf.lsd</a></code> over the same dataset (as defined by <code>data</code>).
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_states">states</code></td>
<td>
<p>object: an optional object produced by a previous run of <code><a href="#topic+state.ident.lsd">state.ident.lsd</a></code> containing a set of identified state candidates. Only one state candidate, as defined by <code>state.num</code> is used in each run.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_state.num">state.num</code></td>
<td>
<p>integer: the index (1,2,...) of the state candidate in <code>states</code> to use. The default is to use the first state, which is usually the most likely one.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_state.vars">state.vars</code></td>
<td>
<p>character: a vector of variable names to use as state variables. If more than one name is provided, a proper <code>eval.state</code> state evaluation function supporting multi-variable states must be also provided.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_eval.state">eval.state</code></td>
<td>
<p>function: a function able to define the corresponding state of each run of a Monte Carlo experiment. The function must take a matrix as argument, organized as runs on rows and the state variable(s) on columns. It must return an integer vector of length equal to the number of runs, defining the state of each run. States are defined by a sequence of integer values, e.g., 0, 1 or 1, 2 ,3, The minimum number of states is two and there is no maximum. If no function is supplied (<code>NULL</code>), the default, an internal 2-state evaluation function is used, using the mean or the median, according to <code>stat</code>, to split the MC set into two states.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_metr.irf">metr.irf</code></td>
<td>
<p>function: a function that assigns a metric to compare each run of a Monte Carlo experiment, to be used on regressions. The function must take a cumulative impulse-response matrix, organized as runs on rows and response times (0, 1, ...,<code>t.horiz</code>) on columns. It must return a numeric vector of length equal to the number of runs, defining the metric associated with each run. Higher metric values correspond to increased impulse effect. If no function is supplied (<code>NULL</code>), the default, the mean of state variable value(s) from impulse time (<code>t=0</code>) until the time horizon (<code>t=t.horiz</code>) is used as metric.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_add.vars">add.vars</code></td>
<td>
<p>function: an optional function to add new variables to the MC dataset, before the analysis is performed. The function must take a single Monte Carlo run data frame, organized as time on rows and (original) variables on columns. It must return this data frame with new column(s) added, one per each new variable.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_irf.type">irf.type</code></td>
<td>
<p>string: one of five options (<code>"incr.irf"</code>, <code>"cum.irf"</code>, <code>"peak.mult"</code>, <code>"cum.mult"</code>, or <code>"none"</code>) defining the type of function plot to be produced: incremental impulse-response, cumulative impulse-response, peak multiplier, cumulative multiplier, or no plot. It also selects the type of function to be used when printing reports (response or multiplier functions). The default is <code>"incr.irf"</code>. This option only affect the plot, not the produced data, as all function values are always computed and saved in the output object.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_state.plot">state.plot</code></td>
<td>
<p>integer: the relative position (1,2,...) of the state (as defined by <code>eval.state</code>) which data is to be used on plots. The default (<code>0</code>) is to plot data from all states, which allows comparing the state responses.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_ci.r">ci.R</code></td>
<td>
<p>integer: number of bootstrap replicates when computing the bootstrap confidence interval.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_ci.type">ci.type</code></td>
<td>
<p>string: the type of bootstrap confidence interval to compute, must be one of <code>"basic"</code> (the default), <code>"perc"</code> (percentile interval), or <code>"bca"</code> (BCa - adjusted percentile interval).
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_alpha">alpha</code></td>
<td>
<p>numeric: a value between 0 and 0.5, defining the desired statistical significance level to be adopted in the analysis. The default is 0.05 (5%).
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_seed">seed</code></td>
<td>
<p>integer: a value defining the initial state of the pseudo-random number generator.
</p>
</td></tr>
<tr><td><code id="state.irf.lsd_+3A_...">...</code></td>
<td>
<p>additional parameters to configure printing and plotting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a dynamic system, a simulation model may have its outputs analyzed when a brief input signal (an impulse or &quot;shock&quot;) is applied to one of its inputs. In particular, the effect of the shock may be correlated to some system-specific state, in which it may be amplified or attenuated. This function allows for the investigation of such differentiated effects, given an objective criterion to split the system status (i.e., the model outputs) in two or more states.
</p>
<p>The function operates over <code>data</code> from multiple realizations of a Monte Carlo experiment, and a previous (linear) impulse-response function analysis (<code>irf</code>) performed by <code><a href="#topic+irf.lsd">irf.lsd</a></code>.
</p>


<h3>Value</h3>

<p>It returns an object of class <code>state.irf.lsd</code>, which has <code>print</code>- and <code>plot</code>-specific methods for presenting the analysis results. This object contains several items:
</p>
<table>
<tr><td><code>irf.state</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the average or median (according to <code>stat</code>) incremental impulse response function data for each identified state.
</p>
</td></tr>
<tr><td><code>cirf.state</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the average or median (according to <code>stat</code>) cumulative impulse response function data for each identified state.
</p>
</td></tr>
<tr><td><code>pmf.state</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the average or median (according to <code>stat</code>) peak impulse-multiplier function data for each identified state. The peak impulse-multiplier function evaluates the analysis variable (<code>var.irf</code>) as a multiple of the impulse variable (<code>var.shock</code>) at the shock start time.
</p>
</td></tr>
<tr><td><code>cmf.state</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the average or median (according to <code>stat</code>) cumulative impulse-multiplier function data for each identified state. The cumulative-multiplier function evaluates the accumulated analysis variable (<code>var.irf</code>), from impulse time, as a multiple of the accumulated impulse variable (<code>var.shock</code>) over the time horizon (<code>t.horiz</code>)
</p>
</td></tr>
<tr><td><code>irf.state.ci.lo</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the confidence interval lower limit of incremental impulse response function data for each identified state.
</p>
</td></tr>
<tr><td><code>irf.state.ci.hi</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the confidence interval upper limit of incremental impulse response function data for each identified state.
</p>
</td></tr>
<tr><td><code>cirf.state.ci.lo</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the confidence interval lower limit of cumulative impulse response function data for each identified state.
</p>
</td></tr>
<tr><td><code>cirf.state.ci.hi</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the confidence interval upper limit of cumulative impulse response function data for each identified state.
</p>
</td></tr>
<tr><td><code>pmf.state.ci.lo</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the confidence interval lower limit of peak multiplier function data for each identified state.
</p>
</td></tr>
<tr><td><code>pmf.state.ci.hi</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the confidence interval upper limit of peak multiplier function data for each identified state.
</p>
</td></tr>
<tr><td><code>cmf.state.ci.lo</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the confidence interval lower limit of cumulative multiplier function data for each identified state.
</p>
</td></tr>
<tr><td><code>cmf.state.ci.hi</code></td>
<td>
<p>list: each list element is a vector of length <code>t.horiz + 1</code> containing the confidence interval upper limit of cumulative multiplier function data for each identified state.
</p>
</td></tr>
<tr><td><code>irf.state.ylim</code></td>
<td>
<p>list: each list element is a vector of length two containing the absolute minimum and maximum values for the incremental impulse response function data for each identified state.
</p>
</td></tr>
<tr><td><code>cirf.state.ylim</code></td>
<td>
<p>list: each list element is a vector of length two containing the absolute minimum and maximum values for the cumulative impulse response function data for each identified state.
</p>
</td></tr>
<tr><td><code>pmf.state.ylim</code></td>
<td>
<p>list: each list element is a vector of length two containing the absolute minimum and maximum values for the peak multiplier function data for each identified state.
</p>
</td></tr>
<tr><td><code>cmf.state.ylim</code></td>
<td>
<p>list: each list element is a vector of length two containing the absolute minimum and maximum values for the cumulative multiplier function data for each identified state.
</p>
</td></tr>
<tr><td><code>irf.test</code></td>
<td>
<p>object: the result of the test comparing the statistical significance of the incremental impulse-response function difference among different states. Two-state setups are evaluated with t or U tests, according to <code>stat</code> in <code><a href="#topic+irf.lsd">irf.lsd</a></code>, or H or F tests otherwise.
</p>
</td></tr>
<tr><td><code>cirf.test</code></td>
<td>
<p>object: the result of the test comparing the statistical significance of the cumulative impulse-response function difference among different states, considering the entire period of analysis (1, ..., <code>t.horiz</code>). Two-state setups are evaluated with t or U tests, according to <code>stat</code> in <code><a href="#topic+irf.lsd">irf.lsd</a></code>, or H or F tests otherwise.
</p>
</td></tr>
<tr><td><code>cirf.test.t.horiz</code></td>
<td>
<p>object: the result of the test comparing the statistical significance of the cumulative impulse-response function difference among different states just at the end of the analysis time horizon (<code>t.horiz</code>). Two-state setups are evaluated with t or U tests, according to <code>stat</code> in <code><a href="#topic+irf.lsd">irf.lsd</a></code>, or H or F tests otherwise.
</p>
</td></tr>
<tr><td><code>pmf.test</code></td>
<td>
<p>object: the result of the test comparing the statistical significance of the peak multiplier function difference among different states. Two-state setups are evaluated with t or U tests, according to <code>stat</code> in <code><a href="#topic+irf.lsd">irf.lsd</a></code>, or H or F tests otherwise.
</p>
</td></tr>
<tr><td><code>cmf.test</code></td>
<td>
<p>object: the result of the test comparing the statistical significance of the cumulative multiplier function difference among different states. Two-state setups are evaluated with t or U tests, according to <code>stat</code> in <code><a href="#topic+irf.lsd">irf.lsd</a></code>, or H or F tests otherwise.
</p>
</td></tr>
<tr><td><code>state</code></td>
<td>
<p>character: a textual description of the tested state.
</p>
</td></tr>
<tr><td><code>state.vars</code></td>
<td>
<p>character: a vector of variable names effectively available as state variables.
</p>
</td></tr>
<tr><td><code>t.horiz</code></td>
<td>
<p>integer: the time horizon used in the analysis (same as the <code>t.horiz</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).
</p>
</td></tr>
<tr><td><code>var.irf</code></td>
<td>
<p>character: the name of the variable used in the impulse-response analysis (same as the <code>var.irf</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).
</p>
</td></tr>
<tr><td><code>var.ref</code></td>
<td>
<p>character: the name of the scale-reference variable used in the analysis (same as the <code>var.ref</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).
</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>character: the Monte Carlo statistic used in the analysis (same as the <code>stat</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>numeric: the statistical significance level used in the analysis (same as the <code>alpha</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).
</p>
</td></tr>
<tr><td><code>nsample</code></td>
<td>
<p>integer: the effective number of of Monte Carlo (MC) samples effectively used for deriving the response function, after the removal of outliers if <code>lim.outl &gt; 0</code> in <code><a href="#topic+irf.lsd">irf.lsd</a></code>.
</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>integer: vector containing the number of each MC sample considered an outlier, and so removed from the analysis in <code><a href="#topic+irf.lsd">irf.lsd</a></code>, or an empty vector if no outlier was excluded. The MC numbers are the indexes to the third dimension of <code>data</code>.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>character: the command line used to call the function.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See the note in <a href="#topic+LSDirf-package">LSDirf-package</a> for an methodological overview and for instructions on how to perform the state-dependent impulse-response function analysis.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira [aut, cre] (&lt;https://orcid.org/0000-0002-8069-2734&gt;),
  Marco Amendola [aut] (&lt;https://orcid.org/0000-0003-3056-5558&gt;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irf.lsd">irf.lsd</a></code>,
<code><a href="LSDinterface.html#topic+read.3d.lsd">read.3d.lsd</a></code>,
<code><a href="LSDinterface.html#topic+read.4d.lsd">read.4d.lsd</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data generation: Y is an AR(1) process that may receive a shock at
# t=50, S is the shock (0/1), a combination of 3 AR(1) processes (X1-X3)
# X4 is another AR(1) process, uncorrelated with S, X4sq is just X4^2
# All AR(1) processes have the same phi=0.98 coefficient, and are Monte
# Carlo sampled 500 times
set.seed( 1 )   # make results reproducible
# LSD-like arrays to store simulated time series (t x var x MC)
dataNoShock &lt;- dataShock &lt;-array ( 0, dim = c( 60, 7, 500 ) )
colnames( dataNoShock ) &lt;- colnames( dataShock ) &lt;-
  c( "Y", "S", "X1", "X2", "X3", "X4", "X4sq" )
# Monte Carlo sampling
for( n in 1 : 500 ) {
  # simulation time
  for( t in 2 : 60 ) {
    # AR process on X vars
    for( v in c( "X1", "X2", "X3", "X4" ) ) {
      dataNoShock[ t, v, n ] = dataShock[ t, v, n ] =
        0.98 * dataShock[ t - 1, v, n ] + rnorm( 1, 0, 0.1 )
    }
    # apply shock once
    if( t == 50 ) {
      dataShock[ t, "S", n ] &lt;- 1
      shockEff &lt;- 0.4 + 0.7 * isTRUE( dataShock[ t, "X1", n ] &gt; 0.1 ) -
        0.4 * isTRUE( dataShock[ t, "X2", n ] &gt; 0.1 ) +
        0.2 * isTRUE( dataShock[ t, "X3", n ] &gt; 0.05 ) + rnorm( 1, 0, 0.2 )
    } else
      shockEff &lt;- 0
    # AR process on Y var
    rs &lt;- rnorm( 1, 0, 0.1 )
    dataNoShock[ t, "Y", n ] = 0.98 * dataNoShock[ t - 1, "Y", n ] + rs
    dataShock[ t, "Y", n ] = 0.98 * dataShock[ t - 1, "Y", n ] + shockEff + rs
  }
}
# another uncorrelated var
dataNoShock[ , "X4sq", ] &lt;- dataShock[ , "X4sq", ] &lt;- dataShock[ , "X4", ] ^ 2

# linear IRF analysis
linearIRF &lt;- irf.lsd( data = dataNoShock,      # non-shocked MC data
                      data.shock = dataShock,  # shocked data
                      t.horiz = 10,            # post-shock analysis t horizon
                      var.irf = "Y",           # variable to compute IRF
                      var.shock = "S",         # shock variable (impulse)
                      irf.type = "none" )      # no plot of linear IRF

# state-dependent IRF analysis
stateIRF &lt;- state.irf.lsd( data = dataNoShock, # non-shocked MC data
                           irf = linearIRF,    # linear IRF produced by irf.lsd
                           state.vars = "X1" ) # variable defining states

plot( stateIRF, irf.type = "cum.irf" )         # cumulative IRF plot

print( stateIRF )                              # show IRF data

</code></pre>

<hr>
<h2 id='state.sa.lsd'>
Sensitivity analysis of IRF to state variables
</h2><span id='topic+state.sa.lsd'></span>

<h3>Description</h3>

<p>This function performs a sensitivity analysis of the impulse-response function (IRF) to selected state variables of data from a Monte Carlo experiment, typically from (but not restricted to) a LSD simulation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state.sa.lsd( data, irf, state.vars = NULL, metr.irf = NULL,
              add.vars = NULL, ntree = 500, nodesize = 5,
              mtry = max( floor( ifelse( ! is.null( state.vars ),
                                         length( state.vars ),
                                         dim( data )[ 2 ] ) / 3 ),
                          1 ),
              no.plot = FALSE, alpha = 0.05, seed = 1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state.sa.lsd_+3A_data">data</code></td>
<td>
<p>numeric: a 3-dimensional array containing data from Monte Carlo (MC) simulation samples where the impulse (shock/treatment) was not applied/occurred. The array must have dimensions ordered as time steps x variables x MC samples. This format is automatically produced by <a href="LSDinterface.html#topic+read.3d.lsd">read.3d.lsd</a> but using it is not required. The second array dimension (variables) must be named with the names of the variables used in the analysis. The absolute minimum array dimensions are 2x1x2.
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_irf">irf</code></td>
<td>
<p>object: an object produced by a previous run of <code><a href="#topic+irf.lsd">irf.lsd</a></code> over the same dataset (as defined by <code>data</code>).
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_state.vars">state.vars</code></td>
<td>
<p>character: a vector of variable names to consider as state variables.
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_metr.irf">metr.irf</code></td>
<td>
<p>function: a function that assigns a metric to compare each run of a Monte Carlo experiment, to be used on regressions. The function must take a cumulative impulse-response matrix, organized as runs on rows and response times (0, 1, ...,<code>t.horiz</code>) on columns. It must return a numeric vector of length equal to the number of runs, defining the metric associated with each run. Higher metric values correspond to increased impulse effect. If no function is supplied (<code>NULL</code>), the default, the sum of state variable value(s) at impulse time is used as metric.
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_add.vars">add.vars</code></td>
<td>
<p>function: an optional function to add new variables to the MC dataset, before the analysis is performed. The function must take a single Monte Carlo run data frame, organized as time on rows and (original) variables on columns. It must return this data frame with new column(s) added, one per each new variable.
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_ntree">ntree</code></td>
<td>
<p>integer: number of trees to grow. This number should not be set to too small values, to ensure that every possible state gets predicted at least a few times.
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_nodesize">nodesize</code></td>
<td>
<p>integer: minimum number of associated data observations to a node be considered in the analysis.
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_mtry">mtry</code></td>
<td>
<p>integer: number of state variables randomly sampled as candidates at each node for the random forest algorithm. The default is to use one third of the number of considered state variables.
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_no.plot">no.plot</code></td>
<td>
<p>logical: if <code>TRUE</code>, the default, a bar plot is presented with the results. If set to <code>FALSE</code>, the bar plot is not shown.
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_alpha">alpha</code></td>
<td>
<p>numeric: a value between 0 and 0.5, defining the desired statistical significance level to be adopted in the analysis. The default is 0.05 (5%).
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_seed">seed</code></td>
<td>
<p>integer: a value defining the initial state of the pseudo-random number generator.
</p>
</td></tr>
<tr><td><code id="state.sa.lsd_+3A_...">...</code></td>
<td>
<p>additional parameters to configure printing and plotting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a dynamic system, a simulation model may have its outputs analyzed when a brief input signal (an impulse or &quot;shock&quot;) is applied to one of its inputs. In particular, the effect of the shock may be correlated to some system-specific state, in which it may be amplified or attenuated, associated to specific model variables. This function evaluates how sensitive such states are to each of the specified variables.
</p>
<p>The function operates over <code>data</code> from multiple realizations of a Monte Carlo experiment, and a previous (linear) impulse-response function analysis (<code>irf</code>) performed by <code><a href="#topic+irf.lsd">irf.lsd</a></code>.
</p>


<h3>Value</h3>

<p>It returns an object of class <code>state.sa.lsd</code>, which has <code>print</code>- and <code>plot</code>-specific methods for presenting the analysis results. This object contains several items:
</p>
<table>
<tr><td><code>importance</code></td>
<td>
<p>data frame: contains the state variable importance measure (mean decrease in accuracy) produced by the random forest regression, one row for each state variable. First column presents the importance measure, second column brings the measure standard error, and third, the p-value of t test comparing the measure to zero.</p>
</td></tr>
<tr><td><code>state.vars</code></td>
<td>
<p>character: a vector of variable names effectively available as state variables.</p>
</td></tr>
<tr><td><code>t.horiz</code></td>
<td>
<p>integer: the time horizon used in the analysis (same as the <code>t.horiz</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).</p>
</td></tr>
<tr><td><code>var.irf</code></td>
<td>
<p>character: the name of the variable used in the impulse-response analysis (same as the <code>var.irf</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).</p>
</td></tr>
<tr><td><code>var.ref</code></td>
<td>
<p>character: the name of the scale-reference variable used in the analysis (same as the <code>var.ref</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>character: the Monte Carlo statistic used in the analysis (same as the <code>stat</code> argument in <code><a href="#topic+irf.lsd">irf.lsd</a></code>).</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>numeric: the statistical significance level used in the analysis (same as the <code>alpha</code> argument).</p>
</td></tr>
<tr><td><code>nsample</code></td>
<td>
<p>integer: the effective number of of Monte Carlo (MC) samples effectively used for deriving the response function, after the removal of outliers if <code>lim.outl &gt; 0</code> in <code><a href="#topic+irf.lsd">irf.lsd</a></code>.</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>integer: vector containing the number of each MC sample considered an outlier, and so removed from the analysis in <code><a href="#topic+irf.lsd">irf.lsd</a></code>, or an empty vector if no outlier was excluded. The MC numbers are the indexes to the third dimension of <code>data</code>.</p>
</td></tr>
<tr><td><code>ntree</code></td>
<td>
<p>integer: number of trees grown (same as <code>ntree</code> argument).</p>
</td></tr>
<tr><td><code>nodesize</code></td>
<td>
<p>integer: minimum number of data observations in a node considered  (same as <code>nodesize</code> argument).</p>
</td></tr>
<tr><td><code>mtry</code></td>
<td>
<p>integer: number of state variables sampled per node (same as <code>mtry</code> argument).</p>
</td></tr>
<tr><td><code>rsq</code></td>
<td>
<p>numeric: the pseudo R-squared (1 - MSE / Var(y)) of the random forest regression.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>character: the command line used to call the function.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See the note in <a href="#topic+LSDirf-package">LSDirf-package</a> for an methodological overview and for instructions on how to perform the state-dependent impulse-response function analysis.
</p>


<h3>Author(s)</h3>

<p>Marcelo C. Pereira [aut, cre] (&lt;https://orcid.org/0000-0002-8069-2734&gt;),
  Marco Amendola [aut] (&lt;https://orcid.org/0000-0003-3056-5558&gt;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irf.lsd">irf.lsd</a></code>,
<code><a href="LSDinterface.html#topic+read.3d.lsd">read.3d.lsd</a></code>,
<code><a href="LSDinterface.html#topic+read.4d.lsd">read.4d.lsd</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data generation: Y is an AR(1) process that may receive a shock at
# t=50, S is the shock (0/1), a combination of 3 AR(1) processes (X1-X3)
# X4 is another AR(1) process, uncorrelated with S, X4sq is just X4^2
# All AR(1) processes have the same phi=0.98 coefficient, and are Monte
# Carlo sampled 500 times
set.seed( 1 )   # make results reproducible
# LSD-like arrays to store simulated time series (t x var x MC)
dataNoShock &lt;- dataShock &lt;-array ( 0, dim = c( 60, 7, 500 ) )
colnames( dataNoShock ) &lt;- colnames( dataShock ) &lt;-
  c( "Y", "S", "X1", "X2", "X3", "X4", "X4sq" )
# Monte Carlo sampling
for( n in 1 : 500 ) {
  # simulation time
  for( t in 2 : 60 ) {
    # AR process on X vars
    for( v in c( "X1", "X2", "X3", "X4" ) ) {
      dataNoShock[ t, v, n ] = dataShock[ t, v, n ] =
        0.98 * dataShock[ t - 1, v, n ] + rnorm( 1, 0, 0.1 )
    }
    # apply shock once
    if( t == 50 ) {
      dataShock[ t, "S", n ] &lt;- 1
      shockEff &lt;- 0.4 + 0.7 * isTRUE( dataShock[ t, "X1", n ] &gt; 0.1 ) -
        0.4 * isTRUE( dataShock[ t, "X2", n ] &gt; 0.1 ) +
        0.2 * isTRUE( dataShock[ t, "X3", n ] &gt; 0.05 ) + rnorm( 1, 0, 0.2 )
    } else
      shockEff &lt;- 0
    # AR process on Y var
    rs &lt;- rnorm( 1, 0, 0.1 )
    dataNoShock[ t, "Y", n ] = 0.98 * dataNoShock[ t - 1, "Y", n ] + rs
    dataShock[ t, "Y", n ] = 0.98 * dataShock[ t - 1, "Y", n ] + shockEff + rs
  }
}
# another uncorrelated var
dataNoShock[ , "X4sq", ] &lt;- dataShock[ , "X4sq", ] &lt;- dataShock[ , "X4", ] ^ 2

# linear IRF analysis
linearIRF &lt;- irf.lsd( data = dataNoShock,       # non-shocked MC data
                      data.shock = dataShock,   # shocked data
                      t.horiz = 10,             # post-shock analysis t horizon
                      var.irf = "Y",            # variable to compute IRF
                      var.shock = "S",          # shock variable (impulse)
                      irf.type = "none" )       # no plot of linear IRF

# state-variable sensitivity
stateSens &lt;- state.sa.lsd( data = dataNoShock,  # non-shocked MC data
                           irf = linearIRF,     # linear IRF produced by irf.lsd
                           state.vars = c( "X1", "X2", "X3", "X4", "X4sq" ),
                                                # state variables to consider
                           mtry = 3 )           # number of samples per node

print( stateSens )                              # show sensitivity data

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
