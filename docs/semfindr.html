<!DOCTYPE html><html><head><title>Help for package semfindr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {semfindr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#semfindr-package'><p>semfindr: Influential Cases in Structural Equation Modeling</p></a></li>
<li><a href='#approx_check'><p>Compatibility Check for the '_approx' Functions</p></a></li>
<li><a href='#cfa_dat'><p>Sample Data: A CFA Model</p></a></li>
<li><a href='#cfa_dat_heywood'><p>Sample Data: A CFA Model with a Heywood Case</p></a></li>
<li><a href='#cfa_dat_mg'><p>Sample Data: A Multiple-Group CFA Model with an Influential Case</p></a></li>
<li><a href='#cfa_dat2'><p>Sample Data: A CFA Model with an Influential Case</p></a></li>
<li><a href='#est_change'><p>Standardized Case Influence on Parameter Estimates</p></a></li>
<li><a href='#est_change_approx'><p>Standardized Case Influence on Parameter Estimates (Approximate)</p></a></li>
<li><a href='#est_change_plot'><p>Plots of Case Influence on</p>
Parameter Estimates</a></li>
<li><a href='#est_change_raw'><p>Case Influence on Parameter Estimates</p></a></li>
<li><a href='#est_change_raw_approx'><p>Case Influence on Parameter Estimates (Approximate)</p></a></li>
<li><a href='#fit_measures_change'><p>Case Influence on Fit Measures</p></a></li>
<li><a href='#fit_measures_change_approx'><p>Case Influence on Fit Measures (Approximate)</p></a></li>
<li><a href='#implied_scores'><p>Implied Scores of Observed Outcome Variables</p></a></li>
<li><a href='#index_plot'><p>Index Plot of an Arbitrary Statistic</p></a></li>
<li><a href='#influence_plot'><p>Plots of Influence Measures</p></a></li>
<li><a href='#influence_stat'><p>Case Influence Measures</p></a></li>
<li><a href='#lavaan_rerun'><p>Rerun a 'lavaan' Analysis Using the Leaving-One-Out Approach</p></a></li>
<li><a href='#lavaan_rerun_check'><p>Compatibility Check for 'lavaan_rerun'</p></a></li>
<li><a href='#mahalanobis_predictors'><p>Mahalanobis Distance On Observed Predictors</p></a></li>
<li><a href='#mahalanobis_rerun'><p>Mahalanobis Distance on All Observed Variables</p></a></li>
<li><a href='#pa_dat'><p>Sample Data: A Path Model</p></a></li>
<li><a href='#pa_dat2'><p>Sample Data: A Path Model with an Influential Case</p></a></li>
<li><a href='#pars_id'><p>Convert Parameter Syntax to Position</p>
or Row Numbers in the Parameter
Vector or Table</a></li>
<li><a href='#pars_id_to_lorg'><p>Ids to &quot;lhs-op-rhs-(group)&quot;</p></a></li>
<li><a href='#print.est_change'><p>Print an 'est_change' Class Object</p></a></li>
<li><a href='#print.fit_measures_change'><p>Print a 'fit_measures_change' Class Object</p></a></li>
<li><a href='#print.influence_stat'><p>Print an 'influence_stat' Class Object</p></a></li>
<li><a href='#print.lavaan_rerun'><p>Print Method for 'lavaan_rerun'</p></a></li>
<li><a href='#print.md_semfindr'><p>Print a 'md_semfindr' Class Object</p></a></li>
<li><a href='#sem_dat'><p>Sample Data: A Latent Variable Structural Model</p></a></li>
<li><a href='#sem_dat2'><p>Sample Data: A Latent Variable Structural Model</p>
With an Influential Case</a></li>
<li><a href='#user_change_raw'><p>Case Influence on User-Defined Statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Influential Cases in Structural Equation Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Sensitivity analysis in structural equation modeling using
    influence measures and diagnostic plots. Support leave-one-out casewise
    sensitivity analysis presented by Pek and MacCallum (2011)
    &lt;<a href="https://doi.org/10.1080%2F00273171.2011.561068">doi:10.1080/00273171.2011.561068</a>&gt; and approximate casewise influence
    using scores and casewise likelihood.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sfcheung.github.io/semfindr/">https://sfcheung.github.io/semfindr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sfcheung/semfindr/issues">https://github.com/sfcheung/semfindr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), parallel, knitr, rmarkdown, modi, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>lavaan, ggplot2, ggrepel, rlang, stats, methods, utils, Matrix</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-08 11:36:22 UTC; shufa</td>
</tr>
<tr>
<td>Author:</td>
<td>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mark Hok Chio Lai <a href="https://orcid.org/0000-0002-9196-7406"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shu Fai Cheung &lt;shufai.cheung@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 13:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='semfindr-package'>semfindr: Influential Cases in Structural Equation Modeling</h2><span id='topic+semfindr'></span><span id='topic+semfindr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Sensitivity analysis in structural equation modeling using influence measures and diagnostic plots. Support leave-one-out casewise sensitivity analysis presented by Pek and MacCallum (2011) <a href="https://doi.org/10.1080/00273171.2011.561068">doi:10.1080/00273171.2011.561068</a> and approximate casewise influence using scores and casewise likelihood.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Shu Fai Cheung <a href="mailto:shufai.cheung@gmail.com">shufai.cheung@gmail.com</a> (<a href="https://orcid.org/0000-0002-9871-9448">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Mark Hok Chio Lai <a href="mailto:marklhc@gmail.com">marklhc@gmail.com</a> (<a href="https://orcid.org/0000-0002-9196-7406">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://sfcheung.github.io/semfindr/">https://sfcheung.github.io/semfindr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/sfcheung/semfindr/issues">https://github.com/sfcheung/semfindr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='approx_check'>Compatibility Check for the '_approx' Functions</h2><span id='topic+approx_check'></span>

<h3>Description</h3>

<p>Gets a 'lavaan' output and checks whether it is
supported by the functions using the approximate approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_check(
  fit,
  print_messages = TRUE,
  multiple_group = FALSE,
  equality_constraint = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_check_+3A_fit">fit</code></td>
<td>
<p>The output from <code>lavaan</code>, such as <code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code> and
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.</p>
</td></tr>
<tr><td><code id="approx_check_+3A_print_messages">print_messages</code></td>
<td>
<p>Logical. If <code>TRUE</code>, will print messages about the
check. If <code>FALSE</code>, the messages will be attached to the return value
as an attribute. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="approx_check_+3A_multiple_group">multiple_group</code></td>
<td>
<p>Logical. Whether multiple-group models are
supported. If yes, the check for multiple-groups models will be
skipped. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="approx_check_+3A_equality_constraint">equality_constraint</code></td>
<td>
<p>Logical. Whether models with
equality constraints are
supported. If yes, the check for equality constraints will be
skipped. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not supposed to be used by users. It is
called by functions such as <code><a href="#topic+est_change_approx">est_change_approx()</a></code> to see if the
analysis passed to
it is supported. If not, messages will be printed to indicate why.
</p>


<h3>Value</h3>

<p>A single-element vector. If confirmed to be supported, will
return 0. If not confirmed to be support but may still work, return 1.
If confirmed to be not yet supported, will return a negative
number, the value of this number without the negative sign is the
number of tests failed.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- cfa_dat

mod &lt;-
"
f1 =~ x4 + x5 + x6
"
dat_gp &lt;- dat
dat$gp &lt;- rep(c("gp1", "gp2"), length.out = nrow(dat_gp))

fit01 &lt;- lavaan::sem(mod, dat)
# If supported, returns a zero
approx_check(fit01)

fit05 &lt;- lavaan::cfa(mod, dat, group = "gp")
# If not supported, returns a negative number
approx_check(fit05)

</code></pre>

<hr>
<h2 id='cfa_dat'>Sample Data: A CFA Model</h2><span id='topic+cfa_dat'></span>

<h3>Description</h3>

<p>A six-variable dataset with 100 cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfa_dat
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 6 variables:
</p>

<dl>
<dt>x1</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x3</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x4</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x5</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x6</dt><dd><p>Indicator. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(cfa_dat)
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
"
fit &lt;- cfa(mod, cfa_dat)
summary(fit)
</code></pre>

<hr>
<h2 id='cfa_dat_heywood'>Sample Data: A CFA Model with a Heywood Case</h2><span id='topic+cfa_dat_heywood'></span>

<h3>Description</h3>

<p>A six-variable dataset with 60 cases, with
one case resulting in negative variance if not removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfa_dat_heywood
</code></pre>


<h3>Format</h3>

<p>A data frame with 60 rows
and 6 variables:
</p>

<dl>
<dt>x1</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x3</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x4</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x5</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x6</dt><dd><p>Indicator. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(cfa_dat_heywood)
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
"
# The following will result in a warning
fit &lt;- cfa(mod, cfa_dat_heywood)
# One variance is negative
parameterEstimates(fit, output = "text")
# Fit the model with the first case removed
fit_no_case_1 &lt;- cfa(mod, cfa_dat_heywood[-1, ])
# Results admissible
parameterEstimates(fit_no_case_1, output = "text")
</code></pre>

<hr>
<h2 id='cfa_dat_mg'>Sample Data: A Multiple-Group CFA Model with an Influential Case</h2><span id='topic+cfa_dat_mg'></span>

<h3>Description</h3>

<p>A six-variable dataset with 100 cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfa_dat_mg
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 6 variables:
</p>

<dl>
<dt>x1</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x3</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x4</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x5</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x6</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>gp</dt><dd><p>Group variable. Character. Either &quot;GroupA&quot; or &quot;GroupB&quot;.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(cfa_dat_mg)
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
"
fit1 &lt;- cfa(mod, cfa_dat_mg, group = "gp")
fit2 &lt;- cfa(mod, cfa_dat_mg, group = "gp",
            group.equal = "loadings")
fit3 &lt;- cfa(mod, cfa_dat_mg, group = "gp",
            group.equal = c("loadings", "intercepts"))
lavTestLRT(fit1, fit2, fit3)
lavTestLRT(fit1, fit3)

# Drop the first case
cfa_dat_mgb &lt;- cfa_dat_mg[-1, ]
fit1b &lt;- cfa(mod, cfa_dat_mgb, group = "gp")
fit2b &lt;- cfa(mod, cfa_dat_mgb, group = "gp",
             group.equal = "loadings")
fit3b &lt;- cfa(mod, cfa_dat_mgb, group = "gp",
             group.equal = c("loadings", "intercepts"))
lavTestLRT(fit1b, fit2b, fit3b)
lavTestLRT(fit1b, fit3b)

</code></pre>

<hr>
<h2 id='cfa_dat2'>Sample Data: A CFA Model with an Influential Case</h2><span id='topic+cfa_dat2'></span>

<h3>Description</h3>

<p>A six-variable dataset with 100 cases, with
one influential case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfa_dat2
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 7 variables:
</p>

<dl>
<dt>case_id</dt><dd><p>Case ID. Character.</p>
</dd>
<dt>x1</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x3</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x4</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x5</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x6</dt><dd><p>Indicator. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(cfa_dat2)
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
"
fit &lt;- cfa(mod, cfa_dat2)
summary(fit)
inf_out &lt;- influence_stat(fit)
gcd_plot(inf_out)
</code></pre>

<hr>
<h2 id='est_change'>Standardized Case Influence on Parameter Estimates</h2><span id='topic+est_change'></span>

<h3>Description</h3>

<p>Gets a <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> output and computes the
standardized changes in selected parameters for each case
if included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_change(rerun_out, parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_change_+3A_rerun_out">rerun_out</code></td>
<td>
<p>The output from <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.</p>
</td></tr>
<tr><td><code id="est_change_+3A_parameters">parameters</code></td>
<td>
<p>A character vector to specify the selected
parameters. Each parameter is named as in <code>lavaan</code> syntax, e.g.,
<code>x ~ y</code> or <code>x ~~ y</code>, as appeared in the columns <code>lhs</code>, <code>op</code>, and <code>rhs</code>
in the output of <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>.
Supports specifying an operator to select all parameters with this
operators: <code>~</code>, <code style="white-space: pre;">&#8288;~~&#8288;</code>, <code style="white-space: pre;">&#8288;=~&#8288;</code>, and <code>~1</code>. This vector can contain
both parameter names and operators. More details can be found
in the help of <code><a href="#topic+pars_id">pars_id()</a></code>.
If omitted or <code>NULL</code>, the
default, changes on all free parameters will be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each case, <code><a href="#topic+est_change">est_change()</a></code> computes the differences in
the estimates of selected parameters with and without this case:
</p>
<p>(Estimate with all case) - (Estimate without this case).
</p>
<p>The
differences are standardized by dividing the raw differences by
their standard errors (Pek &amp; MacCallum, 2011).
This is a measure of the standardized influence of a case on
the parameter
estimates if it is included.
</p>
<p>If the value of a case is positive, including the case increases an estimate.
</p>
<p>If the value of a case is negative, including the case decreases an estimate.
</p>
<p>If the analysis is not admissible or does not converge when a case
is deleted, <code>NA</code>s will be turned for this case on the differences.
</p>
<p>Unlike <code><a href="#topic+est_change_raw">est_change_raw()</a></code>, <code><a href="#topic+est_change">est_change()</a></code> does not support
computing the standardized changes of standardized estimates.
</p>
<p>It will also compute generalized Cook's distance (<em>gCD</em>), proposed by
Pek and MacCallum (2011) for structural equation modeling.
Only the parameters selected (all free parameters, by default)
will be used in computing <em>gCD</em>.
</p>
<p>Since version 0.1.4.8, if (a) a model has one or more equality
constraints, and
(b) some selected parameters are linearly dependent or constrained
to be equal due to the constraint(s), <em>gCD</em> will be computed
by removing parameters such that the remaining parameters are
not linearly dependent nor constrained to be equal.
(Support for equality constraints and
linearly dependent parameters available in 0.1.4.8 and later version).
</p>
<p>Supports both single-group and multiple-group models.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>An <code>est_change</code>-class object, which is
matrix with the number of columns equals to the number of
requested parameters plus one, the last column being the
generalized Cook's
distance. The number of rows equal to the number
of cases. The row names are the case identification values used in
<code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>. The elements are the standardized difference.
Please see Pek and MacCallum (2011), Equation 7.
A print method is available for user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>References</h3>

<p>Pek, J., &amp; MacCallum, R. (2011). Sensitivity analysis
in structural equation models: Cases and their influence.
<em>Multivariate Behavioral Research, 46</em>(2), 202-228.
doi:10.1080/00273171.2011.561068
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)

# A path model

dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)
# Fit the model several times. Each time with one case removed.
# For illustration, do this only for four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = c(2, 4, 7, 9))
# Compute the standardized changes in parameter estimates
# if a case is included vs. if this case is excluded.
# That is, case influence on parameter estimates, standardized.
out &lt;- est_change(fit_rerun)
# Case influence:
out
# Note that these are the differences divided by the standard errors
# The rightmost column, `gcd`, contains the
# generalized Cook's distances (Pek &amp; MacCallum, 2011).
out[, "gcd", drop = FALSE]

# Compute the changes for the paths from iv1 and iv2 to m1
out2 &lt;- est_change(fit_rerun, c("m1 ~ iv1", "m1 ~ iv2"))
# Case influence:
out2
# Note that only the changes in the selected parameters are included.
# The generalized Cook's distance is computed only from the selected
# parameter estimates.

# A CFA model

dat &lt;- cfa_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f1 ~~ f2
"
# Fit the model
fit &lt;- lavaan::cfa(mod, dat)

# Examine four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = c(2, 3, 5, 7))
# Compute the standardized changes in parameter estimates
# if a case is included vs. if a case is excluded.
# That is, case influence on parameter estimates, standardized.
# For free loadings only
out &lt;- est_change(fit_rerun, parameters = "=~")
out

# A latent variable model

dat &lt;- sem_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   a * f1
f3 ~   b * f2
ab := a * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)

# Examine four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = c(2, 3, 5, 7))
# Compute the changes in parameter estimates if a case is included
# vs. if a case is excluded.
# That is, standardized case influence on parameter estimates.
# For structural paths only
out &lt;- est_change(fit_rerun, parameters = "~")
out

</code></pre>

<hr>
<h2 id='est_change_approx'>Standardized Case Influence on Parameter Estimates (Approximate)</h2><span id='topic+est_change_approx'></span>

<h3>Description</h3>

<p>Gets a <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> output and computes the
approximate standardized changes in selected parameters for each case
if included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_change_approx(
  fit,
  parameters = NULL,
  case_id = NULL,
  allow_inadmissible = FALSE,
  skip_all_checks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_change_approx_+3A_fit">fit</code></td>
<td>
<p>The output from <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> or its wrappers (e.g.,
<code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code> and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>).</p>
</td></tr>
<tr><td><code id="est_change_approx_+3A_parameters">parameters</code></td>
<td>
<p>A character vector to specify the selected
parameters. Each parameter is named as in <code>lavaan</code> syntax, e.g.,
<code>x ~ y</code> or <code>x ~~ y</code>, as appeared in the columns <code>lhs</code>, <code>op</code>, and <code>rhs</code>
in the output of <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>.
Supports specifying an operator to select all parameters with these
operators: <code>~</code>, <code style="white-space: pre;">&#8288;~~&#8288;</code>, <code style="white-space: pre;">&#8288;=~&#8288;</code>, and <code>~1</code>. This vector can contain
both parameter names and operators. More details can be found
in the help of <code><a href="#topic+pars_id">pars_id()</a></code>.
If omitted or <code>NULL</code>, the
default, changes on all free parameters will be computed.</p>
</td></tr>
<tr><td><code id="est_change_approx_+3A_case_id">case_id</code></td>
<td>
<p>If it is a character vector of length equals to the
number of cases (the number of rows in the data in <code>fit</code>), then it
is the vector of case identification values. If it is <code>NULL</code>, the
default, then <code>case.idx</code> used by <code>lavaan</code> functions will be used
as case identification values.</p>
</td></tr>
<tr><td><code id="est_change_approx_+3A_allow_inadmissible">allow_inadmissible</code></td>
<td>
<p>If <code>TRUE</code>, accepts a fit object with
inadmissible results (i.e., <code>post.check</code> from
<code><a href="lavaan.html#topic+lavInspect">lavaan::lavInspect()</a></code> is <code>FALSE</code>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="est_change_approx_+3A_skip_all_checks">skip_all_checks</code></td>
<td>
<p>If <code>TRUE</code>, skips all checks and allows
users to run this function on any object of the <code>lavaan</code> class.
For users to experiment this and other functions on models
not officially supported. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each case, <code><a href="#topic+est_change_approx">est_change_approx()</a></code> computes the
approximate differences in the estimates of selected parameters
with and without this case:
</p>
<p>(Estimate with all case) - (Estimate without this case)
</p>
<p>The differences are standardized by dividing
the approximate raw differences by their standard errors. This is a
measure of the standardized influence of a case on the parameter estimates
if it is included.
</p>
<p>If the value of a case is positive, including the case increases an estimate.
</p>
<p>If the value of a case is negative, including the case decreases an estimate.
</p>
<p>The model is not refitted. Therefore, the result is only an
approximation of that of <code><a href="#topic+est_change">est_change()</a></code>. However, this
approximation is useful for identifying potentially influential
cases when the sample size is very large or the model takes a long
time to fit. This function can be used to identify potentially
influential cases quickly and then select them to conduct the
leave-one-out sensitivity analysis using <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> and
<code><a href="#topic+est_change">est_change()</a></code>.
</p>
<p>This function also computes the approximate generalized Cook's
distance (gCD). To avoid confusion, it is labelled <code>gcd_approx</code>.
</p>
<p>For the technical details, please refer to the vignette
on this approach: <code>vignette("casewise_scores", package = "semfindr")</code>
</p>
<p>The approximate approach supports a model with
equality constraints (available in 0.1.4.8 and later version).
</p>
<p>Supports both single-group and multiple-group models.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>An <code>est_change</code>-class object, which is
matrix with the number of columns equals to the number of
requested parameters plus one, the last column being the
approximate generalized Cook's
distance. The number of rows equal to the number
of cases. The row names are the case identification values used in
<code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>. The elements are approximate standardized
differences.
A print method is available for user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Idea by Mark Hok Chio Lai <a href="https://orcid.org/0000-0002-9196-7406">https://orcid.org/0000-0002-9196-7406</a>,
implemented by Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)

# A path model

dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# Approximate standardized changes and gCD
out_approx &lt;- est_change_approx(fit)
head(out_approx)

# Fit the model several times. Each time with one case removed.
# For illustration, do this only for the first 10 cases.
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
# Compute the changes in chisq if a case is removed
out &lt;- est_change(fit_rerun)
head(out)

# Compare the results
plot(out_approx[1:10, 1], out[, 1])
abline(a = 0, b = 1)
plot(out_approx[1:10, 2], out[, 2])
abline(a = 0, b = 1)
plot(out_approx[1:10, 3], out[, 3])
abline(a = 0, b = 1)
plot(out_approx[1:10, "gcd_approx"], out[, "gcd"])
abline(a = 0, b = 1)

# A CFA model

dat &lt;- cfa_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f1 ~~ f2
"
# Fit the model
fit &lt;- lavaan::cfa(mod, dat)
summary(fit)

# Approximate standardized changes and gCD
# Compute gCD only for free loadings
out_approx &lt;- est_change_approx(fit,
                                parameters = "=~")
head(out_approx)

# A latent variable model

dat &lt;- sem_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   a * f1
f3 ~   b * f2
ab := a * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# Approximate standardized changes and gCD
# Compute gCD only for structural paths
out_approx &lt;- est_change_approx(fit,
                                parameters = "~")
head(out_approx)



</code></pre>

<hr>
<h2 id='est_change_plot'>Plots of Case Influence on
Parameter Estimates</h2><span id='topic+est_change_plot'></span><span id='topic+est_change_gcd_plot'></span>

<h3>Description</h3>

<p>Gets the output of
functions such as <code><a href="#topic+est_change">est_change()</a></code> and
<code><a href="#topic+est_change_approx">est_change_approx()</a></code> and plots case
influence on selected parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_change_plot(
  change,
  parameters,
  cutoff_change = NULL,
  largest_change = 1,
  title = TRUE,
  point_aes = list(),
  vline_aes = list(),
  hline_aes = list(),
  cutoff_line_aes = list(),
  case_label_aes = list(),
  wrap_aes = list()
)

est_change_gcd_plot(
  change,
  parameters,
  cutoff_gcd = NULL,
  largest_gcd = 1,
  cutoff_change = NULL,
  largest_change = 1,
  title = TRUE,
  point_aes = list(),
  hline_aes = list(),
  cutoff_line_aes = list(),
  case_label_aes = list(),
  wrap_aes = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_change_plot_+3A_change">change</code></td>
<td>
<p>The output from
<code><a href="#topic+est_change">est_change()</a></code>, <code><a href="#topic+est_change_raw">est_change_raw()</a></code>,
<code><a href="#topic+est_change_approx">est_change_approx()</a></code>, or
<code><a href="#topic+est_change_raw_approx">est_change_raw_approx()</a></code>.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_parameters">parameters</code></td>
<td>
<p>If it is
a character vector, it
specifies the selected parameters.
Each parameter is named as in
<code>lavaan</code> syntax, e.g., <code>x ~ y</code> or <code>x ~~ y</code>, as appeared in the columns
<code>lhs</code>, <code>op</code>, and <code>rhs</code> in the output
of <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>.
Supports specifying an operator to
select all parameters with this
operators: <code>~</code>, <code style="white-space: pre;">&#8288;~~&#8288;</code>, <code style="white-space: pre;">&#8288;=~&#8288;</code>, and <code>~1</code>.
This vector can contain both
parameter names and operators.
If it is a numeric vector, it
specifies the columns to be used.
If omitted or <code>NULL</code>,
the default, changes on all
parameters in <code>change</code>. will be used.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_cutoff_change">cutoff_change</code></td>
<td>
<p>Cases with
absolute changes larger than this
value will be labeled. Default is
<code>NULL</code>. If <code>NULL</code>, no cutoff line
will be drawn.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_largest_change">largest_change</code></td>
<td>
<p>The number of
cases with the largest absolute
changes to be labelled. Default is
</p>

<ol>
<li><p> If not an integer, it will be
rounded to the nearest integer.
</p>
</li></ol>
</td></tr>
<tr><td><code id="est_change_plot_+3A_title">title</code></td>
<td>
<p>If <code>TRUE</code>, the default,
a default title will be added to
the plot. If it is a string, it will
be used as the title. If <code>FALSE</code>,
no title will be added to the plot.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_point_aes">point_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to modify how
to draw the points. Default is
<code>list()</code> and internal default
settings will be used.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_vline_aes">vline_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code> to modify how
to draw the line for each case
in the index plot by
<code><a href="#topic+est_change_plot">est_change_plot()</a></code>. Default is
<code>list()</code> and internal default
settings will be used.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_hline_aes">hline_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_hline()</a></code> to modify how
to draw the horizontal line for zero
case influence. Default is <code>list()</code>
and internal default settings will be
used.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_cutoff_line_aes">cutoff_line_aes</code></td>
<td>
<p>A named list
of arguments to be passed to
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_hline()</a></code> in
<code><a href="#topic+est_change_plot">est_change_plot()</a></code> or
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_vline()</a></code> in
<code><a href="#topic+est_change_gcd_plot">est_change_gcd_plot()</a></code> to modify how
to draw the line for user cutoff
value (<code>cutoff_change</code> or
<code>cutoff_gcd</code>). Default is <code>list()</code>
and internal default settings will be
used.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_case_label_aes">case_label_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_label_repel()</a></code> to
modify how to draw the labels for
cases marked (based on
<code>cutoff_change</code>, <code>cutoff_gcd</code>,
<code>largest_change</code>, or <code>largest_gcd</code>).
Default is <code>list()</code> and internal
default settings will be used.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_wrap_aes">wrap_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> to modify how
the plots are organized. Default is
<code>list()</code> and internal default
settings will be used.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_cutoff_gcd">cutoff_gcd</code></td>
<td>
<p>Cases with
generalized Cook's distance or
approximate generalized Cook's
distance larger than this value will
be labeled. Default is <code>NULL</code>. If
<code>NULL</code>, no cutoff line will be drawn.</p>
</td></tr>
<tr><td><code id="est_change_plot_+3A_largest_gcd">largest_gcd</code></td>
<td>
<p>The number of
cases with the largest generalized
Cook's distance or approximate
generalized Cook's distance to be
labelled. Default is 1. If not an
integer, it will be rounded to the
nearest integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of
<code><a href="#topic+est_change">est_change()</a></code>, <code><a href="#topic+est_change_raw">est_change_raw()</a></code>,
<code><a href="#topic+est_change_approx">est_change_approx()</a></code>, and
<code><a href="#topic+est_change_raw_approx">est_change_raw_approx()</a></code> is simply a
matrix. Therefore, these functions
will work for any matrix provided.
Row number will be used on the x-axis
if applicable. However, case
identification values will be used
for labeling individual cases if they
are stored as row names.
</p>
<p>The default settings for the plots
should be good enough for diagnostic
purpose. If so desired, users can
use the <code style="white-space: pre;">&#8288;*_aes&#8288;</code> arguments to nearly
fully customize all the major
elements of the plots, as they would
do for building a <a href="ggplot2.html#topic+ggplot2">ggplot2</a> plot.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2">ggplot2</a> plot. Plotted by
default. If assigned to a variable or
called inside a function, it will not
be plotted. Use <code><a href="base.html#topic+plot">plot()</a></code> to plot it.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>est_change_plot()</code>: Index
plot of case influence on parameters.
</p>
</li>
<li> <p><code>est_change_gcd_plot()</code>: Plot case
influence on parameter estimates
against generalized Cook's distance.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Shu Fai Cheung
<a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>References</h3>

<p>Pek, J., &amp; MacCallum, R.
(2011). Sensitivity analysis in
structural equation models: Cases
and their influence. <em>Multivariate
Behavioral Research, 46</em>(2),
202-228.
doi:10.1080/00273171.2011.561068
</p>


<h3>See Also</h3>

<p><code><a href="#topic+est_change">est_change()</a></code>,
<code><a href="#topic+est_change_raw">est_change_raw()</a></code>,
<code><a href="#topic+est_change_approx">est_change_approx()</a></code>, and
<code><a href="#topic+est_change_raw_approx">est_change_raw_approx()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)

# A path model

dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# Compute approximate case influence on parameters estimates
out &lt;- est_change_approx(fit)

# Plot case influence for all regression coefficients
est_change_plot(out,
                parameters = "~",
                largest_change = 2)

# Plot case influence against approximated gCD for all
# regression coefficients
# Label top 5 cases with largest approximated gCD
est_change_gcd_plot(out,
                    parameters = "~",
                    largest_gcd = 5)

# Customize elements in a plot.
# For example, change the color and shape of the points.

est_change_plot(out,
                parameters = "~",
                largest_change = 2,
                point_aes = list(shape = 5,
                                 color = "red"))

</code></pre>

<hr>
<h2 id='est_change_raw'>Case Influence on Parameter Estimates</h2><span id='topic+est_change_raw'></span>

<h3>Description</h3>

<p>Gets a <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> output and computes the
changes in selected parameters for each case if included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_change_raw(
  rerun_out,
  parameters = NULL,
  standardized = FALSE,
  user_defined_label_full = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_change_raw_+3A_rerun_out">rerun_out</code></td>
<td>
<p>The output from <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.</p>
</td></tr>
<tr><td><code id="est_change_raw_+3A_parameters">parameters</code></td>
<td>
<p>A character vector to specify the selected
parameters. Each parameter is named as in <code>lavaan</code> syntax, e.g.,
<code>x ~ y</code> or <code>x ~~ y</code>, as appeared in the columns <code>lhs</code>, <code>op</code>, and <code>rhs</code>
in the output of <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>.
Supports specifying an operator to select all parameters with these
operators: <code>~</code>, <code style="white-space: pre;">&#8288;~~&#8288;</code>, <code style="white-space: pre;">&#8288;=~&#8288;</code>, and <code>~1</code>. This vector can contain
both parameter names and operators. More details can be found
in the help of <code><a href="#topic+pars_id">pars_id()</a></code>.
If omitted or <code>NULL</code>, the
default, changes on all free parameters will be computed.</p>
</td></tr>
<tr><td><code id="est_change_raw_+3A_standardized">standardized</code></td>
<td>
<p>If <code>TRUE</code>, the changes in the full standardized
solution is returned (<code>type</code> = <code>std.all</code> in
<code><a href="lavaan.html#topic+standardizedSolution">lavaan::standardizedSolution()</a></code>). Otherwise, the changes in the
unstandardized solution are returned. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="est_change_raw_+3A_user_defined_label_full">user_defined_label_full</code></td>
<td>
<p>Logical. If <code>TRUE</code>, use the full
labels for user-defined parameters (parameters created by
<code style="white-space: pre;">&#8288;:=&#8288;</code>), which include the definition. If <code>FALSE</code>, then only
the label on the right-hand side of <code style="white-space: pre;">&#8288;:=&#8288;</code> will be used.
Default is <code>FALSE</code>. In previous version, the full labels
were used. Set to <code>TRUE</code> if backward compatibility
is needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each case, <code><a href="#topic+est_change_raw">est_change_raw()</a></code> computes the differences
in the estimates of selected parameters with and without this
case:
</p>
<p>(Estimate with all case) - (Estimate without this case).
</p>
<p>The
change is the raw change, either for the standardized or
unstandardized solution. The change is <em>not</em> divided by standard
error.
This is a measure of the influence of a case on the parameter
estimates if it is included.
</p>
<p>If the value of a case is positive, including the case increases an estimate.
</p>
<p>If the value of a case is negative, including the case decreases an estimate.
</p>
<p>If the analysis is not admissible or did not converge when a case
is deleted, <code>NA</code>s will be returned for this case on the
differences.
</p>
<p>Supports both single-group and multiple-group models.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>An <code>est_change</code>-class object, which is
matrix with the number of columns equals to the number of
requested parameters, and the number of rows equals to the number
of cases. The row names are the case identification values used in
<code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>. The elements are the raw differences.
A print method is available for user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>References</h3>

<p>Pek, J., &amp; MacCallum, R. (2011). Sensitivity analysis
in structural equation models: Cases and their influence.
<em>Multivariate Behavioral Research, 46</em>(2), 202-228.
doi:10.1080/00273171.2011.561068
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)

# A path model

dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)

# Fit the model n times. Each time with one case is removed.
# For illustration, do this only for four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = c(3, 5, 7, 8))
# Compute the changes in parameter estimates if a case is included
# vs. if this case is excluded.
# That is, case influence on parameter estimates.
out &lt;- est_change_raw(fit_rerun)
# Results excluding a case
out
# Note that these are the differences in parameter estimates.

# The parameter estimates from all cases
(coef_all &lt;- coef(fit))
# The parameter estimates from manually deleting the third case
fit_no_3 &lt;- lavaan::sem(mod, dat[-3, ])
(coef_no_3 &lt;- coef(fit_no_3))
# The differences
coef_all - coef_no_3
# The first row of `est_change_raw(fit_rerun)`
round(out[1, ], 3)

# Compute only the changes of the paths from iv1 and iv2 to m1
out2 &lt;- est_change_raw(fit_rerun, c("m1 ~ iv1", "m1 ~ iv2"))
# Results excluding a case
out2
# Note that only the changes in the selected paths are included.

# Use standardized = TRUE to compare the differences in standardized solution
out2_std &lt;- est_change_raw(fit_rerun,
                           c("m1 ~ iv1", "m1 ~ iv2"),
                           standardized = TRUE)
out2_std
(est_std_all &lt;- parameterEstimates(fit,
                 standardized = TRUE)[1:2, c("lhs", "op", "rhs", "std.all")])
(est_std_no_1 &lt;- parameterEstimates(fit_no_3,
                 standardized = TRUE)[1:2, c("lhs", "op", "rhs", "std.all")])
# The differences
est_std_all$std.all - est_std_no_1$std.all
# The first row of `out2_std`
out2_std[1, ]

# A CFA model

dat &lt;- cfa_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f1 ~~ f2
"
# Fit the model
fit &lt;- lavaan::cfa(mod, dat)

# Examine four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = c(2, 3, 5, 7))
# Compute the changes in parameter estimates if a case is included
# vs. if this case is excluded.
# That is, case influence on parameter estimates.
# For free loadings only
out &lt;- est_change_raw(fit_rerun, parameters = "=~")
out
# For standardized loadings only
out_std &lt;- est_change_raw(fit_rerun, parameters = "=~",
                          standardized = TRUE)
out_std

# A latent variable model

dat &lt;- sem_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   a * f1
f3 ~   b * f2
ab := a * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)

# Examine four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = c(2, 3, 5, 7))
# Compute the changes in parameter estimates if a case is included
# vs. if this case is excluded.
# That is, case influence on parameter estimates.
# For structural paths only
out &lt;- est_change_raw(fit_rerun, parameters = "~")
out
# For standardized paths only
out_std &lt;- est_change_raw(fit_rerun, parameters = "~",
                          standardized = TRUE)
out_std


</code></pre>

<hr>
<h2 id='est_change_raw_approx'>Case Influence on Parameter Estimates (Approximate)</h2><span id='topic+est_change_raw_approx'></span>

<h3>Description</h3>

<p>Gets a <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> output and computes the
approximate changes in selected parameters for each case
if included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_change_raw_approx(
  fit,
  parameters = NULL,
  case_id = NULL,
  allow_inadmissible = FALSE,
  skip_all_checks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_change_raw_approx_+3A_fit">fit</code></td>
<td>
<p>The output from <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> or its wrappers (e.g.,
<code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code> and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>).</p>
</td></tr>
<tr><td><code id="est_change_raw_approx_+3A_parameters">parameters</code></td>
<td>
<p>A character vector to specify the selected
parameters. Each parameter is named as in <code>lavaan</code> syntax, e.g.,
<code>x ~ y</code> or <code>x ~~ y</code>, as appeared in the columns <code>lhs</code>, <code>op</code>, and <code>rhs</code>
in the output of <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>.
Supports specifying an operator to select all parameters with these
operators: <code>~</code>, <code style="white-space: pre;">&#8288;~~&#8288;</code>, <code style="white-space: pre;">&#8288;=~&#8288;</code>, and <code>~1</code>. This vector can contain
both parameter names and operators. More details can be found
in the help of <code><a href="#topic+pars_id">pars_id()</a></code>.
If omitted or <code>NULL</code>, the
default, changes on all free parameters will be computed.</p>
</td></tr>
<tr><td><code id="est_change_raw_approx_+3A_case_id">case_id</code></td>
<td>
<p>If it is a character vector of length equals to the
number of cases (the number of rows in the data in <code>fit</code>), then it
is the vector of case identification values. If it is <code>NULL</code>, the
default, then <code>case.idx</code> used by <code>lavaan</code> functions will be used
as case identification values.</p>
</td></tr>
<tr><td><code id="est_change_raw_approx_+3A_allow_inadmissible">allow_inadmissible</code></td>
<td>
<p>If <code>TRUE</code>, accepts a fit object with
inadmissible results (i.e., <code>post.check</code> from
<code><a href="lavaan.html#topic+lavInspect">lavaan::lavInspect()</a></code> is <code>FALSE</code>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="est_change_raw_approx_+3A_skip_all_checks">skip_all_checks</code></td>
<td>
<p>If <code>TRUE</code>, skips all checks and allows
users to run this function on any object of <code>lavaan</code> class.
For users to experiment this and other functions on models
not officially supported. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each case, <code><a href="#topic+est_change_raw_approx">est_change_raw_approx()</a></code> computes the
approximate differences
in the estimates of selected parameters with and without this
case:
</p>
<p>(Estimate with all case) - (Estimate without this case).
</p>
<p>The change is the approximate raw change. The change is <em>not</em> divided by
the standard error of an estimate (hence &quot;raw&quot; in the function name).
This is a measure of the influence of a case on the parameter
estimates if it is included.
</p>
<p>If the value of a case is positive, including the case increases an estimate.
</p>
<p>If the value of a case is negative, including the case decreases an estimate.
</p>
<p>The model is not refitted. Therefore, the result is only an
approximation of that of <code><a href="#topic+est_change_raw">est_change_raw()</a></code>. However, this
approximation is useful for identifying potentially influential
cases when the sample size is very large or the model takes a long
time to fit. This function can be used to identify potentially
influential cases quickly and then select them to conduct the
leave-one-out sensitivity analysis using <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> and
<code><a href="#topic+est_change_raw">est_change_raw()</a></code>.
</p>
<p>Unlike <code><a href="#topic+est_change_raw">est_change_raw()</a></code>, it does not yet support computing the
changes for the standardized solution.
</p>
<p>For the technical details, please refer to the vignette
on this approach: <code>vignette("casewise_scores", package = "semfindr")</code>
</p>
<p>The approximate approach supports a model with
equality constraints (available in 0.1.4.8 and later version).
</p>
<p>Supports both single-group and multiple-group models.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>An <code>est_change</code>-class object, which is
matrix with the number of columns equals to the number of
requested parameters, and the number of rows equals to the number
of cases. The row names are case identification values. The
elements are the raw differences.
A print method is available for user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Idea by Mark Hok Chio Lai <a href="https://orcid.org/0000-0002-9196-7406">https://orcid.org/0000-0002-9196-7406</a>,
implemented by Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)

# A path model

dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)
# Compute the approximate changes in parameter estimates if a case is included
# vs. if this case is excluded.
# That is, the approximate case influence on parameter estimates.
out_approx &lt;- est_change_raw_approx(fit)
head(out_approx)
# Fit the model several times. Each time with one case removed.
# For illustration, do this only for 10 selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
# Compute the changes in parameter estimates if a case is included
# vs. if this case is excluded.
# That is, the case influence on the parameter estimates.
out &lt;- est_change_raw(fit_rerun)
out
# Compare the results
plot(out_approx[1:10, 1], out[, 1])
abline(a = 0, b = 1)
plot(out_approx[1:10, 5], out[, 5])
abline(a = 0, b = 1)

# A CFA model
dat &lt;- cfa_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f1 ~~ f2
"
# Fit the model
fit &lt;- lavaan::cfa(mod, dat)
summary(fit)
# Compute the approximate changes in parameter estimates if a case is included
# vs. if this case is excluded.
# That is, approximate case influence on parameter estimates.
# Compute changes for free loadings only.
out_approx &lt;- est_change_raw_approx(fit,
                                    parameters = "=~")
head(out_approx)

# A latent variable model
dat &lt;- sem_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   a * f1
f3 ~   b * f2
ab := a * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)
# Compute the approximate changes in parameter estimates if a case is included
# vs. if this case is excluded.
# That is, the approximate case influence on parameter estimates.
# Compute changes for structural paths only
out_approx &lt;- est_change_raw_approx(fit,
                                    parameters = c("~"))
head(out_approx)


</code></pre>

<hr>
<h2 id='fit_measures_change'>Case Influence on Fit Measures</h2><span id='topic+fit_measures_change'></span>

<h3>Description</h3>

<p>Gets a <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> output and computes the changes
in selected fit measures if a case is included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_measures_change(
  rerun_out,
  fit_measures = c("chisq", "cfi", "rmsea", "tli"),
  baseline_model = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_measures_change_+3A_rerun_out">rerun_out</code></td>
<td>
<p>The output from <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_measures_change_+3A_fit_measures">fit_measures</code></td>
<td>
<p>The argument <code>fit.measures</code> used in
<a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures</a>. Default is
<code>c("chisq", "cfi", "rmsea", "tli")</code>.</p>
</td></tr>
<tr><td><code id="fit_measures_change_+3A_baseline_model">baseline_model</code></td>
<td>
<p>The argument <code>baseline.model</code> used in
<a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures</a>. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each case, <code><a href="#topic+fit_measures_change">fit_measures_change()</a></code> computes the
differences in selected fit measures with and without this case:
</p>
<p>(Fit measure with all case) - (Fit measure without this case).
</p>
<p>If the value of a case is positive, including the case increases an estimate.
</p>
<p>If the value of a case is negative, including the case decreases an estimate.
</p>
<p>Note that an increase is an improvement in fit for
goodness of fit measures such as CFI and TLI, but a decrease
is an improvement in fit for badness of fit measures such as
RMSEA and model chi-square.
This is a measure of the influence of a case on a fit measure
if it is included.
</p>
<p>If the analysis is not admissible or does not converge when a case
is deleted, <code>NA</code>s will be turned for the differences of this
case.
</p>
<p>Supports both single-group and multiple-group models.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>An <code>fit_measures_change</code>-class object, which is
matrix with the number of columns equals to the number of
requested fit measures, and the number of rows equals to the number
of cases. The row names are the case identification values used in
<code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.
A print method is available for user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>References</h3>

<p>Pek, J., &amp; MacCallum, R. (2011). Sensitivity analysis
in structural equation models: Cases and their influence.
<em>Multivariate Behavioral Research, 46</em>(2), 202-228.
doi:10.1080/00273171.2011.561068
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)

# A path model

dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)
# Fit the model n times. Each time with one case removed.
# For illustration, do this only for four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
# Compute the changes in chisq if a case is included
# vs. if this case is removed.
# That is, case influence on model chi-squared.
out &lt;- fit_measures_change(fit_rerun, fit_measures = "chisq")
# Results excluding a case, for the first few cases
head(out)
# Chi-square will all cases included.
(chisq_all &lt;- fitMeasures(fit, c("chisq")))
# Chi-square with the first case removed
fit_01 &lt;- lavaan::sem(mod, dat[-1, ])
(chisq_no_1 &lt;- fitMeasures(fit_01, c("chisq")))
# Difference
chisq_all - chisq_no_1
# Compare to the result from the fit_measures_change
out[1, ]

# A CFA model

dat &lt;- cfa_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f1 ~~ f2
"
# Fit the model
fit &lt;- lavaan::cfa(mod, dat)

fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
out &lt;- fit_measures_change(fit_rerun, fit_measures = "chisq")
head(out)
(chisq_all &lt;- fitMeasures(fit, c("chisq")))
fit_01 &lt;- lavaan::sem(mod, dat[-1, ])
(chisq_no_1 &lt;- fitMeasures(fit_01, c("chisq")))
chisq_all - chisq_no_1
out[1, ]

# A latent variable model

dat &lt;- sem_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   a * f1
f3 ~   b * f2
ab := a * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)

fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
out &lt;- fit_measures_change(fit_rerun, fit_measures = "chisq")
head(out)
(chisq_all &lt;- fitMeasures(fit, c("chisq")))
fit_01 &lt;- lavaan::sem(mod, dat[-1, ])
(chisq_no_1 &lt;- fitMeasures(fit_01, c("chisq")))
chisq_all - chisq_no_1
out[1, ]

</code></pre>

<hr>
<h2 id='fit_measures_change_approx'>Case Influence on Fit Measures (Approximate)</h2><span id='topic+fit_measures_change_approx'></span>

<h3>Description</h3>

<p>Gets a <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> output and computes the
approximate change
in selected fit measures if a case is included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_measures_change_approx(
  fit,
  fit_measures = c("chisq", "cfi", "rmsea", "tli"),
  baseline_model = NULL,
  case_id = NULL,
  allow_inadmissible = FALSE,
  skip_all_checks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_measures_change_approx_+3A_fit">fit</code></td>
<td>
<p>The output from <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> or its wrappers (e.g.,
<code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code> and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>).</p>
</td></tr>
<tr><td><code id="fit_measures_change_approx_+3A_fit_measures">fit_measures</code></td>
<td>
<p>The argument <code>fit.measures</code> used in
<a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures</a>. Default is
<code>c("chisq", "cfi", "rmsea", "tli")</code>.
Currently, the approximate method supports only
these four measures.</p>
</td></tr>
<tr><td><code id="fit_measures_change_approx_+3A_baseline_model">baseline_model</code></td>
<td>
<p>The argument <code>baseline.model</code> used in
<a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures</a>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fit_measures_change_approx_+3A_case_id">case_id</code></td>
<td>
<p>If it is a character vector of length equals to the
number of cases (the number of rows in the data in <code>fit</code>), then it
is the vector of case identification values. If it is <code>NULL</code>, the
default, then <code>case.idx</code> used by <code>lavaan</code> functions will be used
as case identification values.</p>
</td></tr>
<tr><td><code id="fit_measures_change_approx_+3A_allow_inadmissible">allow_inadmissible</code></td>
<td>
<p>If <code>TRUE</code>, accepts a fit object with
inadmissible results (i.e., <code>post.check</code> from
<code><a href="lavaan.html#topic+lavInspect">lavaan::lavInspect()</a></code> is <code>FALSE</code>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_measures_change_approx_+3A_skip_all_checks">skip_all_checks</code></td>
<td>
<p>If <code>TRUE</code>, skips all checks and allows
users to run this function on any object of <code>lavaan</code> class.
For users to experiment this and other functions on models
not officially supported. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each case, <code><a href="#topic+fit_measures_change_approx">fit_measures_change_approx()</a></code> computes the
approximate differences in selected fit measures with and
without this case:
</p>
<p>(Fit measure with all case) - (Fit measure without this case).
</p>
<p>If the value of a case is positive, including the case increases an estimate.
</p>
<p>If the value of a case is negative, including the case decreases an estimate.
</p>
<p>Note that an increase is an improvement in fit for
goodness of fit measures such as CFI and TLI, but a decrease
is an improvement in fit for badness of fit measures such as
RMSEA and model chi-square.
This is a measure of the influence of a case on a fit measure
if it is included.
</p>
<p>The model is not refitted. Therefore, the result is only an
approximation of that of <code><a href="#topic+fit_measures_change">fit_measures_change()</a></code>. However, this
approximation is useful for identifying potentially influential
cases when the sample size is very large or the model takes a long
time to fit. This function can be used to identify potentially
influential cases quickly and then select them to conduct the
leave-one-out sensitivity analysis using <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> and
<code><a href="#topic+fit_measures_change">fit_measures_change()</a></code>.
</p>
<p>For the technical details, please refer to the vignette
on this approach: <code>vignette("casewise_scores", package = "semfindr")</code>
</p>
<p>Supports both single-group and multiple-group models.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>An <code>fit_measures_change</code>-class object, which is
matrix with the number of columns equals to the number of
requested fit measures, and the number of rows equals to the number
of cases. The row names are case identification values.
A print method is available for user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Idea by Mark Hok Chio Lai <a href="https://orcid.org/0000-0002-9196-7406">https://orcid.org/0000-0002-9196-7406</a>,
implemented by Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)

# A path model

dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# Approximate changes
out_approx &lt;- fit_measures_change_approx(fit, fit_measures = "chisq")
head(out_approx)
# Fit the model several times. Each time with one case removed.
# For illustration, do this only for four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:5)
# Compute the changes in chisq if a case is included
# vs. if this case is excluded.
# That is, case influence on model chi-squared.
out &lt;- fit_measures_change(fit_rerun, fit_measures = "chisq")
# Case influence, for the first few cases
head(out)
# Compare the results
plot(out_approx[1:5, "chisq"], out)
abline(a = 0, b = 1)

# A CFA model

dat &lt;- cfa_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f1 ~~ f2
"
# Fit the model
fit &lt;- lavaan::cfa(mod, dat)

out_approx &lt;- fit_measures_change_approx(fit, fit_measures = "chisq")
head(out_approx)

fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:5)
# Compute the changes in chisq if a case is included
# vs. if this case is excluded.
# That is, case influence on fit measures.
out &lt;- fit_measures_change(fit_rerun, fit_measures = "chisq")
# Results excluding a case, for the first few cases
head(out)
# Compare the results
plot(out_approx[1:5, "chisq"], out)
abline(a = 0, b = 1)

# A latent variable model

dat &lt;- sem_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   a * f1
f3 ~   b * f2
ab := a * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)

out_approx &lt;- fit_measures_change_approx(fit, fit_measures = "chisq")
head(out_approx)

fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:5)
# Compute the changes in chisq if a case is excluded
# vs. if this case is included.
# That is, case influence on model chi-squared.
out &lt;- fit_measures_change(fit_rerun, fit_measures = "chisq")
# Case influence, for the first few cases
head(out)
# Compare the results
plot(out_approx[1:5, "chisq"], out)
abline(a = 0, b = 1)

</code></pre>

<hr>
<h2 id='implied_scores'>Implied Scores of Observed Outcome Variables</h2><span id='topic+implied_scores'></span>

<h3>Description</h3>

<p>Gets a <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> output and computes the
implied scores of observed outcome variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>implied_scores(fit, output = "matrix", skip_all_checks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="implied_scores_+3A_fit">fit</code></td>
<td>
<p>The output from <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code>, such as <code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code>
and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.</p>
</td></tr>
<tr><td><code id="implied_scores_+3A_output">output</code></td>
<td>
<p>Output type. If <code>"matrix"</code>, the default,
the output will be combined to one matrix, with cases ordered as
in the original dataset (after listwise deletion, if used). If
<code>"list"</code>, the a list of matrices is returned, even if the model
has only one group.</p>
</td></tr>
<tr><td><code id="implied_scores_+3A_skip_all_checks">skip_all_checks</code></td>
<td>
<p>If <code>TRUE</code>, skips all checks and allows
users to run this function on any object of <code>lavaan</code> class.
For users to experiment this and other functions on models
not officially supported. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implied scores for each observed outcome variable
(the <code>y</code>-variables or the endogenous variables) are
simply computed in the same way the predicted scores in a linear
regression model are computed.
</p>
<p>Currently it supports only single-group and multiple-group
path analysis models with only
observed variables.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>A matrix of the implied scores if <code>output</code> is <code>"matrix"</code>.
If <code>output</code> is <code>"list"</code>, a list of matrices of the implied scores.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- pa_dat
# For illustration, select only the first 50 cases
dat &lt;- dat[1:50, ]
# The model
mod &lt;-
"
m1 ~ iv1 + iv2
dv ~ m1
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# Compute the implied scores for `m1` and `dv`
fit_implied_scores &lt;- implied_scores(fit)
head(fit_implied_scores)


</code></pre>

<hr>
<h2 id='index_plot'>Index Plot of an Arbitrary Statistic</h2><span id='topic+index_plot'></span>

<h3>Description</h3>

<p>A generic index plot
function for plotting values of
a column # in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_plot(
  object,
  column = NULL,
  plot_title = "Index Plot",
  x_label = NULL,
  cutoff_x_low = NULL,
  cutoff_x_high = NULL,
  largest_x = 1,
  absolute = FALSE,
  point_aes = list(),
  vline_aes = list(),
  hline_aes = list(),
  cutoff_line_aes = list(),
  case_label_aes = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_plot_+3A_object">object</code></td>
<td>
<p>A matrix-like object,
such as the output from
<code><a href="#topic+influence_stat">influence_stat()</a></code>, <code><a href="#topic+est_change">est_change()</a></code>,
<code><a href="#topic+est_change_raw">est_change_raw()</a></code>, and their
counterparts for the approximate
approach.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_column">column</code></td>
<td>
<p>String. The column
name of the values to be plotted.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_plot_title">plot_title</code></td>
<td>
<p>The title of the
plot. Default is <code>"Index Plot"</code>.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_x_label">x_label</code></td>
<td>
<p>The Label for the
vertical axis, for the value of
<code>column</code>. Default is <code>NULL</code>.
If <code>NULL</code>, then the label is
changed to
<code>"Statistic"</code> if <code>absolute</code> is
<code>FALSE</code>, and <code>"Absolute(Statistics)"</code>
if <code>absolute</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_cutoff_x_low">cutoff_x_low</code></td>
<td>
<p>Cases with values
smaller than this value will be labeled.
A cutoff line will be drawn at this
value.
Default is <code>NULL</code>. If <code>NULL</code>, no
cutoff line will be drawn for this
value.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_cutoff_x_high">cutoff_x_high</code></td>
<td>
<p>Cases with values
larger than this value will be labeled.
A cutoff line will be drawn at this
value.
Default is <code>NULL</code>. If <code>NULL</code>, no
cutoff line will be drawn for this
value.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_largest_x">largest_x</code></td>
<td>
<p>The number of cases
with the largest absolute value on
'column&ldquo;
to be labelled. Default is 1. If not
an integer, it will be rounded to the
nearest integer.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_absolute">absolute</code></td>
<td>
<p>Whether absolute values
will be plotted. Useful when cases
are to be compared on magnitude,
ignoring sign. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_point_aes">point_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to modify how
to draw the points. Default is
<code>list()</code> and internal default
settings will be used.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_vline_aes">vline_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code> to modify how
to draw the line for each case
in the index plot. Default is
<code>list()</code> and internal default
settings will be used.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_hline_aes">hline_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_hline()</a></code> to modify how
to draw the horizontal line for zero
case influence. Default is <code>list()</code>
and internal default settings will be
used.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_cutoff_line_aes">cutoff_line_aes</code></td>
<td>
<p>A named list
of arguments to be passed to
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_hline()</a></code> to modify how
to draw the line for user cutoff
values. Default is <code>list()</code>
and internal default settings will be
used.</p>
</td></tr>
<tr><td><code id="index_plot_+3A_case_label_aes">case_label_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_label_repel()</a></code> to
modify how to draw the labels for
cases marked (based on arguments
such as <code>cutoff_x_low</code> or <code>largest_x</code>).
Default is <code>list()</code> and internal
default settings will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This index plot function
is for plotting any measure of
influence or extremeness in a matrix.
It can be used for measures not supported
with other functions.
</p>
<p>Like functions such as <code><a href="#topic+gcd_plot">gcd_plot()</a></code>
and <code><a href="#topic+est_change_plot">est_change_plot()</a></code>, it supports
labelling cases based on the values
on the selected measure
(originaL values or absolute values).
</p>
<p>Users can also plot cases based on
the absolute values. This is useful
when cases are to be compared on
magnitude, ignoring the sign.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2">ggplot2</a> plot. Plotted by
default. If assigned to a variable
or called inside a function, it will
not be plotted. Use <code><a href="base.html#topic+plot">plot()</a></code> to
plot it.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+influence_stat">influence_stat()</a></code>, <code><a href="#topic+est_change">est_change()</a></code>,
<code><a href="#topic+est_change_raw">est_change_raw()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- pa_dat
# The model
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# --- Leave-One-Out Approach

# Fit the model n times. Each time with one case removed.
# For illustration, do this only for selected cases.
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
# Get all default influence stats
out &lt;- influence_stat(fit_rerun)

# Plot case influence on chi-square. Label the 3 cases with the influence.
index_plot(out, "chisq", largest_x = 3)

# Plot absolute case influence on chi-square.
index_plot(out, "chisq", absolute = TRUE)

</code></pre>

<hr>
<h2 id='influence_plot'>Plots of Influence Measures</h2><span id='topic+influence_plot'></span><span id='topic+gcd_plot'></span><span id='topic+md_plot'></span><span id='topic+gcd_gof_plot'></span><span id='topic+gcd_gof_md_plot'></span>

<h3>Description</h3>

<p>Gets an <code><a href="#topic+influence_stat">influence_stat()</a></code> output and plots selected
statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcd_plot(
  influence_out,
  cutoff_gcd = NULL,
  largest_gcd = 1,
  point_aes = list(),
  vline_aes = list(),
  cutoff_line_aes = list(),
  case_label_aes = list()
)

md_plot(
  influence_out,
  cutoff_md = FALSE,
  cutoff_md_qchisq = 0.975,
  largest_md = 1,
  point_aes = list(),
  vline_aes = list(),
  cutoff_line_aes = list(),
  case_label_aes = list()
)

gcd_gof_plot(
  influence_out,
  fit_measure,
  cutoff_gcd = NULL,
  cutoff_fit_measure = NULL,
  largest_gcd = 1,
  largest_fit_measure = 1,
  point_aes = list(),
  hline_aes = list(),
  cutoff_line_gcd_aes = list(),
  cutoff_line_fit_measures_aes = list(),
  case_label_aes = list()
)

gcd_gof_md_plot(
  influence_out,
  fit_measure,
  cutoff_md = FALSE,
  cutoff_fit_measure = NULL,
  circle_size = 2,
  cutoff_md_qchisq = 0.975,
  cutoff_gcd = NULL,
  largest_gcd = 1,
  largest_md = 1,
  largest_fit_measure = 1,
  point_aes = list(),
  hline_aes = list(),
  cutoff_line_md_aes = list(),
  cutoff_line_gcd_aes = list(),
  cutoff_line_fit_measures_aes = list(),
  case_label_aes = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influence_plot_+3A_influence_out">influence_out</code></td>
<td>
<p>The output from <code><a href="#topic+influence_stat">influence_stat()</a></code>.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_cutoff_gcd">cutoff_gcd</code></td>
<td>
<p>Cases with generalized Cook's distance or
approximate generalized Cook's distance larger
than this value will be labeled. Default is <code>NULL</code>. If <code>NULL</code>, no
cutoff line will be drawn.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_largest_gcd">largest_gcd</code></td>
<td>
<p>The number of cases with the largest generalized
Cook's distance or approximate generalized Cook's distance
to be labelled. Default is 1. If not an integer, it
will be rounded to the nearest integer.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_point_aes">point_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> to modify how
to draw the points. Default is
<code>list()</code> and internal default
settings will be used.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_vline_aes">vline_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code> to modify how
to draw the line for each case
in the index plot. Default is
<code>list()</code> and internal default
settings will be used.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_cutoff_line_aes">cutoff_line_aes</code></td>
<td>
<p>A named list
of arguments to be passed to
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_vline()</a></code> or
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_hline()</a></code> to modify how
to draw the line for user cutoff
value. Default is <code>list()</code>
and internal default settings will be
used.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_case_label_aes">case_label_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_label_repel()</a></code> to
modify how to draw the labels for
cases marked (based on arguments
such as <code>cutoff_gcd</code> or <code>largest_gcd</code>).
Default is <code>list()</code> and internal
default settings will be used.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_cutoff_md">cutoff_md</code></td>
<td>
<p>Cases with Mahalanobis distance larger than this
value will be labeled. If it is <code>TRUE</code>, the (<code>cutoff_md_qchisq</code> x
100)th percentile of the chi-square distribution with the degrees
of freedom equal to the number of variables will be used.  Default
is <code>FALSE</code>, no cutoff value.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_cutoff_md_qchisq">cutoff_md_qchisq</code></td>
<td>
<p>This value multiplied by 100 is the
percentile to be used for labeling case based on Mahalanobis
distance. Default is .975.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_largest_md">largest_md</code></td>
<td>
<p>The number of cases with the largest Mahalanobis
distance to be labelled. Default is 1. If not an integer, it will
be rounded to the nearest integer.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_fit_measure">fit_measure</code></td>
<td>
<p>The fit measure to be used in a
plot. Use the name in the <code><a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures()</a></code> function. No
default value.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_cutoff_fit_measure">cutoff_fit_measure</code></td>
<td>
<p>Cases with <code>fit_measure</code> larger than
this cutoff in magnitude will be labeled. No default value and
must be specified.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_largest_fit_measure">largest_fit_measure</code></td>
<td>
<p>The number of cases with the largest
selected fit measure change in magnitude to be labelled. Default is
</p>

<ol>
<li><p> If not an integer, it will be rounded to the nearest integer.
</p>
</li></ol>
</td></tr>
<tr><td><code id="influence_plot_+3A_hline_aes">hline_aes</code></td>
<td>
<p>A named list of
arguments to be passed to
<code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_hline()</a></code> to modify how
to draw the horizontal line for zero
case influence. Default is <code>list()</code>
and internal default settings will be
used.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_cutoff_line_gcd_aes">cutoff_line_gcd_aes</code></td>
<td>
<p>Similar
to <code>cutoff_line_aes</code> but control
the line for the cutoff value of
<em>gCD</em>.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_cutoff_line_fit_measures_aes">cutoff_line_fit_measures_aes</code></td>
<td>
<p>Similar
to <code>cutoff_line_aes</code> but control
the line for the cutoff value of
the selected fit measure.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_circle_size">circle_size</code></td>
<td>
<p>The size of the largest circle when the size
of a circle is controlled by a statistic.</p>
</td></tr>
<tr><td><code id="influence_plot_+3A_cutoff_line_md_aes">cutoff_line_md_aes</code></td>
<td>
<p>Similar
to <code>cutoff_line_aes</code> but control
the line for the cutoff value of
the Mahalanobis distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of <code><a href="#topic+influence_stat">influence_stat()</a></code> is simply a matrix.
Therefore, these functions will work for any matrix provided. Row
number will be used on the x-axis if applicable. However, case
identification values in the output from <code><a href="#topic+influence_stat">influence_stat()</a></code> will
be used for labeling individual cases.
</p>
<p>The default settings for the plots
should be good enough for diagnostic
purpose. If so desired, users can
use the <code style="white-space: pre;">&#8288;*_aes&#8288;</code> arguments to nearly
fully customize all the major
elements of the plots, as they would
do for building a <a href="ggplot2.html#topic+ggplot2">ggplot2</a> plot.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2">ggplot2</a> plot. Plotted by default. If assigned to a variable
or called inside a function, it will not be plotted. Use <code><a href="base.html#topic+plot">plot()</a></code> to
plot it.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>gcd_plot()</code>: Index plot of generalized Cook's distance.
</p>
</li>
<li> <p><code>md_plot()</code>: Index plot of Mahalanobis distance.
</p>
</li>
<li> <p><code>gcd_gof_plot()</code>: Plot the case influence of the selected fit
measure against generalized Cook's distance.
</p>
</li>
<li> <p><code>gcd_gof_md_plot()</code>: Bubble plot of the case influence of the selected
fit measure against Mahalanobis distance, with the size of a bubble
determined by generalized Cook's distance.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>References</h3>

<p>Pek, J., &amp; MacCallum, R. (2011). Sensitivity analysis
in structural equation models: Cases and their influence.
<em>Multivariate Behavioral Research, 46</em>(2), 202-228.
doi:10.1080/00273171.2011.561068
</p>


<h3>See Also</h3>

<p><code><a href="#topic+influence_stat">influence_stat()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- pa_dat
# The model
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)
# Fit the model n times. Each time with one case removed.
# For illustration, do this only for selected cases.
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
# Get all default influence stats
out &lt;- influence_stat(fit_rerun)
head(out)

# Plot generalized Cook's distance. Label the 3 cases with the largest distances.
gcd_plot(out, largest_gcd = 3)

# Plot Mahalanobis distance. Label the 3 cases with the largest distances.
md_plot(out, largest_md = 3)

# Plot case influence on model chi-square against generalized Cook's distance.
# Label the 3 cases with the largest absolute influence.
# Label the 3 cases with the largest generalized Cook's distance.
gcd_gof_plot(out, fit_measure = "chisq", largest_gcd = 3,
             largest_fit_measure = 3)

# Plot case influence on model chi-square against Mahalanobis distance.
# Size of bubble determined by generalized Cook's distance.
# Label the 3 cases with the largest absolute influence.
# Label the 3 cases with the largest Mahalanobis distance.
# Label the 3 cases with the largest generalized Cook's distance.

gcd_gof_md_plot(out, fit_measure = "chisq",
                     largest_gcd = 3,
                     largest_fit_measure = 3,
                     largest_md = 3,
                     circle_size = 10)

# Use the approximate method that does not require refitting the model.

# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)
out &lt;- influence_stat(fit)
head(out)

# Plot approximate generalized Cook's distance.
# Label the 3 cases with the largest values.
gcd_plot(out, largest_gcd = 3)

# Plot Mahalanobis distance.
# Label the 3 cases with the largest values.
md_plot(out, largest_md = 3)

# Plot approximate case influence on model chi-square against
# approximate generalized Cook's distance.
# Label the 3 cases with the largest absolute approximate case influence.
# Label the 3 cases with the largest approximate generalized Cook's distance.
gcd_gof_plot(out, fit_measure = "chisq", largest_gcd = 3,
             largest_fit_measure = 3)

# Plot approximate case influence on model chi-square against Mahalanobis distance.
# The size of a bubble determined by approximate generalized Cook's distance.
# Label the 3 cases with the largest absolute approximate case influence.
# Label the 3 cases with the largest Mahalanobis distance.
# Label the 3 cases with the largest approximate generalized Cook's distance.

gcd_gof_md_plot(out, fit_measure = "chisq",
                     largest_gcd = 3,
                     largest_fit_measure = 3,
                     largest_md = 3,
                     circle_size = 10)

# Customize elements in the plot.
# For example, change the color and shape of the points.

gcd_gof_plot(out, fit_measure = "chisq", largest_gcd = 3,
             largest_fit_measure = 3,
             point_aes = list(shape = 3, color = "red"))

</code></pre>

<hr>
<h2 id='influence_stat'>Case Influence Measures</h2><span id='topic+influence_stat'></span>

<h3>Description</h3>

<p>Gets a <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> output and computes the changes
in selected parameters and fit measures for each case if included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>influence_stat(
  rerun_out,
  fit_measures = c("chisq", "cfi", "rmsea", "tli"),
  baseline_model = NULL,
  parameters = NULL,
  mahalanobis = TRUE,
  keep_fit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influence_stat_+3A_rerun_out">rerun_out</code></td>
<td>
<p>The output from <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>, or the output
of <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> or its wrappers (e.g., <code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code>
and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>).</p>
</td></tr>
<tr><td><code id="influence_stat_+3A_fit_measures">fit_measures</code></td>
<td>
<p>The argument <code>fit.measures</code> used in
<a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures</a>. Default is
<code>c("chisq", "cfi", "rmsea", "tli")</code>.</p>
</td></tr>
<tr><td><code id="influence_stat_+3A_baseline_model">baseline_model</code></td>
<td>
<p>The argument <code>baseline.model</code> used in
<a href="lavaan.html#topic+fitMeasures">lavaan::fitMeasures</a>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="influence_stat_+3A_parameters">parameters</code></td>
<td>
<p>A character vector to specify the selected
parameters. Each parameter is named as in <code>lavaan</code> syntax, e.g.,
<code>x ~ y</code> or <code>x ~~ y</code>, as appeared in the columns <code>lhs</code>, <code>op</code>, and <code>rhs</code>
in the output of <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>.
Supports specifying an operator to select all parameters with this
operators: <code>~</code>, <code style="white-space: pre;">&#8288;~~&#8288;</code>, <code style="white-space: pre;">&#8288;=~&#8288;</code>, and <code>~1</code>. This vector can contain
both parameter names and operators. More details can be found
in the help of <code><a href="#topic+pars_id">pars_id()</a></code>.
If omitted or <code>NULL</code>, the
default, changes on all free parameters will be computed.</p>
</td></tr>
<tr><td><code id="influence_stat_+3A_mahalanobis">mahalanobis</code></td>
<td>
<p>If <code>TRUE</code>, it will call <code><a href="#topic+mahalanobis_rerun">mahalanobis_rerun()</a></code> to
compute the Mahalanobis distance. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="influence_stat_+3A_keep_fit">keep_fit</code></td>
<td>
<p>If <code>TRUE</code>, it will keep the original <code>lavaan</code> output
using the full sample as an attribute to the output. It can be used
by other functions to extract necessary information. Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each case, <code><a href="#topic+influence_stat">influence_stat()</a></code> computes the differences
in the estimates of selected parameters and fit measures with and
without this case. Users can also request a measure of extremeness (only
Mahalanobis distance is available for now).
</p>
<p>If <code>rerun_out</code> is the output of <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>, it will use the
leave-one-out approach.
Measures are computed by <code><a href="#topic+est_change">est_change()</a></code> and <code><a href="#topic+fit_measures_change">fit_measures_change()</a></code>.
</p>
<p>If <code>rerun_out</code> is the output of <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> or its wrappers
(e.g., <code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code> or <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>), it will use the
approximate approach.
Measures are computed by <code><a href="#topic+est_change_approx">est_change_approx()</a></code> and
<code><a href="#topic+fit_measures_change_approx">fit_measures_change_approx()</a></code>.
</p>
<p>If Mahalanobis distance is requested, it is computed by
<code><a href="#topic+mahalanobis_rerun">mahalanobis_rerun()</a></code>.
</p>
<p>Please refer to the help pages of the above functions on
the technical details.
</p>
<p>Supports both single-group and multiple-group models.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>An <code>influence_stat</code>-class object, which is
a matrix with the number of columns equals to the number of
requested statistics, and the number of rows equals to the number of
cases. The row names are the case identification values used in
<code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>. Please refer to the help pages of <code><a href="#topic+est_change">est_change()</a></code> and
<code><a href="#topic+fit_measures_change">fit_measures_change()</a></code> (or <code><a href="#topic+est_change_approx">est_change_approx()</a></code> and
<code><a href="#topic+fit_measures_change_approx">fit_measures_change_approx()</a></code> for details. This object
has a print method for printing user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>References</h3>

<p>Pek, J., &amp; MacCallum, R. (2011). Sensitivity analysis in structural equation
models: Cases and their influence. <em>Multivariate Behavioral Research,
46</em>(2), 202-228. doi:10.1080/00273171.2011.561068
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_measures_change">fit_measures_change()</a></code>, <code><a href="#topic+est_change">est_change()</a></code>, and <code><a href="#topic+mahalanobis_rerun">mahalanobis_rerun()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- pa_dat
# The model
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# --- Leave-One-Out Approach

# Fit the model n times. Each time with one case removed.
# For illustration, do this only for selected cases.
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
# Get all default influence stats
out &lt;- influence_stat(fit_rerun)
head(out)

# --- Approximate Approach

out_approx &lt;- influence_stat(fit)
head(out_approx)

</code></pre>

<hr>
<h2 id='lavaan_rerun'>Rerun a 'lavaan' Analysis Using the Leaving-One-Out Approach</h2><span id='topic+lavaan_rerun'></span>

<h3>Description</h3>

<p>Reruns a <code>lavaan</code> analysis several
times, each time with one case removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavaan_rerun(
  fit,
  case_id = NULL,
  to_rerun,
  md_top,
  resid_md_top,
  allow_inadmissible = FALSE,
  skip_all_checks = FALSE,
  parallel = FALSE,
  makeCluster_args = list(spec = getOption("cl.cores", 2)),
  rerun_method = c("lavaan", "update")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lavaan_rerun_+3A_fit">fit</code></td>
<td>
<p>The output from <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> or its wrappers (e.g.,
<code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code> and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>).</p>
</td></tr>
<tr><td><code id="lavaan_rerun_+3A_case_id">case_id</code></td>
<td>
<p>If it is a character vector of length equals to the
number of cases (the number of rows in the data in <code>fit</code>), then it
is the vector of case identification values. If it is <code>NULL</code>, the
default, then <code>case.idx</code> used by <code>lavaan</code> functions will be used
as case identification values. The case identification values will
be used to name the list of <em>n</em> output.</p>
</td></tr>
<tr><td><code id="lavaan_rerun_+3A_to_rerun">to_rerun</code></td>
<td>
<p>The cases to be processed. If <code>case_id</code> is
specified, this should be a subset of <code>case_id</code>. If <code>case_id</code> is
not specified, then this should be a vector of integers indicating
the rows to te processed, as appeared in the data in <code>fit</code>.
<code>to_rerun</code> cannot be used together with <code>md_top</code> or
<code>resid_md_top.</code></p>
</td></tr>
<tr><td><code id="lavaan_rerun_+3A_md_top">md_top</code></td>
<td>
<p>The number of cases to be processed based on the
Mahalanobis distance computed on all observed variables used in
the model. The cases will be ranked from the largest to the
smallest distance, and the top <code>md_top</code> case(s) will be processed.
<code>md_top</code> cannot be used together with <code>to_rerun</code> or
<code>resid_md_top.</code></p>
</td></tr>
<tr><td><code id="lavaan_rerun_+3A_resid_md_top">resid_md_top</code></td>
<td>
<p>The number of cases to be processed based on
the Mahalanobis distance computed from the residuals of outcome
variables. The cases will be ranked from the largest to the
smallest distance, and the top <code>resid_md_top</code> case(s) will be
processed. <code>resid_md_top</code> cannot be used together with <code>to_rerun</code>
or <code>md_top.</code></p>
</td></tr>
<tr><td><code id="lavaan_rerun_+3A_allow_inadmissible">allow_inadmissible</code></td>
<td>
<p>If <code>TRUE</code>, accepts a fit object with
inadmissible results (i.e., <code>post.check</code> from
<code><a href="lavaan.html#topic+lavInspect">lavaan::lavInspect()</a></code> is <code>FALSE</code>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lavaan_rerun_+3A_skip_all_checks">skip_all_checks</code></td>
<td>
<p>If <code>TRUE</code>, skips all checks and allow
users to run this function on any object of <code>lavaan</code> class.
For users to experiment this and other functions on models
not officially supported. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lavaan_rerun_+3A_parallel">parallel</code></td>
<td>
<p>Whether parallel will be used. If <code>TRUE</code>, will use
functions in the <code>parallel</code> package to rerun the analysis.
Currently, only support <code>"snow"</code> type clusters using local CPU
cores. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lavaan_rerun_+3A_makecluster_args">makeCluster_args</code></td>
<td>
<p>A named list of arguments to be passed to
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>. Default is <code style="white-space: pre;">&#8288;list(spec = getOption("cl.cores", 2)))&#8288;</code>. If only the number of cores need to
be specified, use <code>list(spec = x)</code>, where <code>x</code> is the number
of cores to use.</p>
</td></tr>
<tr><td><code id="lavaan_rerun_+3A_rerun_method">rerun_method</code></td>
<td>
<p>How fit will be rerun. Default is
<code>"lavaan"</code>. An alternative method is <code>"update"</code>. For
internal use. If <code>"lavaan"</code> returns an error, try setting
this argument to <code>"update"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> gets an <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> output and
reruns the analysis <em>n0</em> times, using the same arguments and
options in the output, <em>n0</em> equals to the number of cases selected,
by default all cases in the analysis. In each
run, one case will be removed.
</p>
<p>Optionally, users can rerun the analysis with only selected cases
removed. These cases can be specified by case IDs, by Mahalanobis
distance computed from all variables used in the model, or by
Mahalanobis distance computed from the residuals (observed score -
implied scores) of observed outcome variables. See the help on the
arguments <code>to_rerun</code>, <code>md_top</code>, and <code>resid_md_top</code>.
</p>
<p>It is not recommended to use Mahalanobis distance computed from all
variables, especially for models with observed variables as
predictors (Pek &amp; MacCallum, 2011). Cases that are extreme on
predictors may not be influential on the parameter estimates.
Nevertheless,
this distance is reported in some SEM programs and so this option
is provided.
</p>
<p>Mahalanobis distance based on residuals are supported for models
with no latent factors. The implied scores are computed by
<code><a href="#topic+implied_scores">implied_scores()</a></code>.
</p>
<p>If the sample size is large, it is recommended to use parallel
processing. However, it is possible that parallel
processing will fail. If this is the case, try to use serial
processing, by simply removing the argument <code>parallel</code> or set it to
<code>FALSE</code>.
</p>
<p>Many other functions in <a href="#topic+semfindr">semfindr</a> use the output from
<code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>. Instead of running the <em>n</em> analyses every time, do
this step once and then users can compute whatever influence
statistics they want quickly.
</p>
<p>If the analysis took a few minutes to run due to the large number
of cases or the long processing time in fitting the model, it is
recommended to save the output to an external file (e.g., by
<code><a href="base.html#topic+readRDS">base::saveRDS()</a></code>).
</p>
<p>Supports both single-group and multiple-group models.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>A <code>lavaan_rerun</code>-class object, which is a list with the following elements:
</p>

<ul>
<li> <p><code>rerun</code>: The <em>n</em> <code>lavaan</code> output objects.
</p>
</li>
<li> <p><code>fit</code>: The original output from <code>lavaan</code>.
</p>
</li>
<li> <p><code>post_check</code>: A list of length equals to <em>n</em>. Each analysis was
checked by <a href="lavaan.html#topic+lavInspect">lavaan::lavTech</a><code style="white-space: pre;">&#8288;(x, "post.check")&#8288;</code>, <code>x</code> being the
<code>lavaan</code> results. The results of this test are stored in this
list. If the value is <code>TRUE</code>, the estimation converged and the
solution is admissible. If not <code>TRUE</code>, it is a warning message
issued by <code><a href="lavaan.html#topic+lavInspect">lavaan::lavTech()</a></code>.
</p>
</li>
<li> <p><code>converged</code>: A vector of length equals to <em>n</em>. Each analysis was
checked by <a href="lavaan.html#topic+lavInspect">lavaan::lavTech</a><code style="white-space: pre;">&#8288;(x, "converged")&#8288;</code>, <code>x</code> being the
<code>lavaan</code> results. The results of this test are stored in this
vector. If the value is <code>TRUE</code>, the estimation converged. If
not <code>TRUE</code>, then the estimation failed to converge if the corresponding
case is excluded.
</p>
</li>
<li> <p><code>call</code>: The call to <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.
</p>
</li>
<li> <p><code>selected</code>: A numeric vector of the row numbers of cases selected
in the analysis. Its length should be equal to the length of
<code>rerun</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- pa_dat
# For illustration, select only the first 50 cases
dat &lt;- dat[1:50, ]
# The model
mod &lt;-
"
m1 ~ iv1 + iv2
dv ~ m1
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# Fit the model n times. Each time with one case removed.
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE)

# Print the output for a brief description of the runs
fit_rerun

# Results excluding the first case
fitMeasures(fit_rerun$rerun[[1]], c("chisq", "cfi", "tli", "rmsea"))
# Results by manually excluding the first case
fit_01 &lt;- lavaan::sem(mod, dat[-1, ])
fitMeasures(fit_01, c("chisq", "cfi", "tli", "rmsea"))

</code></pre>

<hr>
<h2 id='lavaan_rerun_check'>Compatibility Check for 'lavaan_rerun'</h2><span id='topic+lavaan_rerun_check'></span>

<h3>Description</h3>

<p>Gets a 'lavaan' output and checks whether it is
supported by <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavaan_rerun_check(fit, print_messages = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lavaan_rerun_check_+3A_fit">fit</code></td>
<td>
<p>The output from <code>lavaan</code>, such as <code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code> and
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.</p>
</td></tr>
<tr><td><code id="lavaan_rerun_check_+3A_print_messages">print_messages</code></td>
<td>
<p>Logical. If <code>TRUE</code>, will print messages about the
check. If <code>FALSE</code>, the messages will be attached to the return value
as an attribute. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not supposed to be used by users. It is
called by <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> to see if the analysis being passed to
it is supported. If not, messages will be printed to indicate why.
</p>


<h3>Value</h3>

<p>A single-element vector. If confirmed to be supported, will
return 0. If not confirmed be support but may still work, return 1.
If confirmed to be not yet supported, will return a negative
number, the value of this number without the negative sign is the
number of tests failed.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- cfa_dat

mod &lt;-
"
f1 =~ x4 + x5 + x6
"
dat_gp &lt;- dat
dat$gp &lt;- rep(c("gp1", "gp2"), length.out = nrow(dat_gp))

fit01 &lt;- lavaan::sem(mod, dat)
# If supported, returns a zero.
lavaan_rerun_check(fit01)

fit05 &lt;- lavaan::cfa(mod, dat, group = "gp")
# If not supported, returns a negative number.
lavaan_rerun_check(fit05)

</code></pre>

<hr>
<h2 id='mahalanobis_predictors'>Mahalanobis Distance On Observed Predictors</h2><span id='topic+mahalanobis_predictors'></span>

<h3>Description</h3>

<p>Gets a <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> or <code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> output
and computes the Mahalanobis distance for each case using only the
observed predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobis_predictors(
  fit,
  emNorm_arg = list(estimate.worst = FALSE, criterion = 1e-06)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahalanobis_predictors_+3A_fit">fit</code></td>
<td>
<p>It can be the output from <code>lavaan</code>, such as
<code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code> and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>, or the output from
<code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.</p>
</td></tr>
<tr><td><code id="mahalanobis_predictors_+3A_emnorm_arg">emNorm_arg</code></td>
<td>
<p>No longer used. Kept for backward
compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each case, <code><a href="#topic+mahalanobis_predictors">mahalanobis_predictors()</a></code> computes the
Mahalanobis distance of each case on the observed predictors.
</p>
<p>If there are no missing values, <code><a href="stats.html#topic+mahalanobis">stats::mahalanobis()</a></code> will be used
to compute the Mahalanobis distance.
</p>
<p>If there are missing values on the observed predictors, the means
and variance-covariance matrices will be estimated by maximum
likelihood using <code><a href="lavaan.html#topic+lavCor">lavaan::lavCor()</a></code>. The estimates will be passed
to <code><a href="modi.html#topic+MDmiss">modi::MDmiss()</a></code> to compute the Mahalanobis distance.
</p>
<p>Supports both single-group and multiple-group models.
For multiple-group models, the Mahalanobis distance for
each case is computed using the means and covariance matrix
of the group this case belongs to.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>A <code>md_semfindr</code>-class object, which is
a one-column matrix (a column vector) of the Mahalanobis
distance for each case. The number of rows equals to the number of
cases in the data stored in the fit object.
A print method is available for user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>References</h3>

<p>Béguin, C., &amp; Hulliger, B. (2004). Multivariate outlier detection in
incomplete survey data: The epidemic algorithm and transformed rank
correlations. <em>Journal of the Royal Statistical Society: Series A
(Statistics in Society)</em>, 167(2), 275-294.
</p>
<p>Mahalanobis, P. C. (1936). On the generalized distance in statistics.
<em>Proceedings of the National Institute of Science of India, 2</em>, 49-55.
</p>
<p>Schafer, J.L. (1997) <em>Analysis of incomplete multivariate data</em>.
Chapman &amp; Hall/CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- pa_dat
# For illustration, select only the first 50 cases.
dat &lt;- dat[1:50, ]
# The model
mod &lt;-
"
m1 ~ a1 * iv1 +  a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

md_predictors &lt;- mahalanobis_predictors(fit)
md_predictors

</code></pre>

<hr>
<h2 id='mahalanobis_rerun'>Mahalanobis Distance on All Observed Variables</h2><span id='topic+mahalanobis_rerun'></span>

<h3>Description</h3>

<p>Computes the Mahalanobis distance for each case on all
observed variables in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobis_rerun(
  fit,
  emNorm_arg = list(estimate.worst = FALSE, criterion = 1e-06)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahalanobis_rerun_+3A_fit">fit</code></td>
<td>
<p>It can be the output from <code>lavaan</code>, such as
<code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code> and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>, or the output from
<code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.</p>
</td></tr>
<tr><td><code id="mahalanobis_rerun_+3A_emnorm_arg">emNorm_arg</code></td>
<td>
<p>No longer used. Kept for backward
compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+mahalanobis_rerun">mahalanobis_rerun()</a></code> gets a <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> or
<code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> output and computes the Mahalanobis distance for
each case on all observed variables.
</p>
<p>If there are no missing values, <code><a href="stats.html#topic+mahalanobis">stats::mahalanobis()</a></code> will be used
to compute the Mahalanobis distance.
</p>
<p>If there are missing values on the observed predictors, the means
and variance-covariance matrices will be estimated by maximum
likelihood using <code><a href="lavaan.html#topic+lavCor">lavaan::lavCor()</a></code>. The estimates will be passed
to <code><a href="modi.html#topic+MDmiss">modi::MDmiss()</a></code> to compute the Mahalanobis distance.
</p>
<p>Supports both single-group and multiple-group models.
For multiple-group models, the Mahalanobis distance for
each case is computed using the means and covariance matrix
of the group this case belongs to.
(Support for multiple-group models available in 0.1.4.8 and later version).
</p>


<h3>Value</h3>

<p>A <code>md_semfindr</code>-class object, which is
a one-column matrix (a column vector) of the Mahalanobis
distance for each case. The row names are the case identification
values used in <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.
A print method is available for user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>References</h3>

<p>Mahalanobis, P. C. (1936). On the generalized distance
in statistics. <em>Proceedings of the National Institute of Science
of India, 2</em>, 49-55.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- pa_dat
# The model
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)
# Fit the model n times. Each time with one case removed.
# For illustration, do this only for selected cases.
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
# Compute the Mahalanobis distance for each case
out &lt;- mahalanobis_rerun(fit_rerun)
# Results excluding a case, for the first few cases
head(out)
# Compute the Mahalanobis distance using stats::mahalanobis()
md1 &lt;- stats::mahalanobis(dat, colMeans(dat), stats::cov(dat))
# Compare the results
head(md1)

# A CFA model

dat &lt;- cfa_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f1 ~~ f2
"
# Fit the model
fit &lt;- lavaan::cfa(mod, dat)

fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
mahalanobis_rerun(fit_rerun)

# A latent variable model

dat &lt;- sem_dat
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   a * f1
f3 ~   b * f2
ab := a * b
"
# Fit the model
fit &lt;- lavaan::cfa(mod, dat)

fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
mahalanobis_rerun(fit_rerun)


</code></pre>

<hr>
<h2 id='pa_dat'>Sample Data: A Path Model</h2><span id='topic+pa_dat'></span>

<h3>Description</h3>

<p>A four-variable dataset with 100 cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pa_dat
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 5 variables:
</p>

<dl>
<dt>m1</dt><dd><p>Mediator. Numeric.</p>
</dd>
<dt>dv</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>iv1</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>iv2</dt><dd><p>Predictor. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(pa_dat)
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
fit &lt;- sem(mod, pa_dat)
summary(fit)
</code></pre>

<hr>
<h2 id='pa_dat2'>Sample Data: A Path Model with an Influential Case</h2><span id='topic+pa_dat2'></span>

<h3>Description</h3>

<p>A four-variable dataset with 100 cases, with
one influential case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pa_dat2
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 5 variables:
</p>

<dl>
<dt>case_id</dt><dd><p>Case ID. Character.</p>
</dd>
<dt>iv1</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>iv2</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>m1</dt><dd><p>Mediator. Numeric.</p>
</dd>
<dt>dv</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(pa_dat2)
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
fit &lt;- sem(mod, pa_dat2)
summary(fit)
inf_out &lt;- influence_stat(fit)
gcd_plot(inf_out)
</code></pre>

<hr>
<h2 id='pars_id'>Convert Parameter Syntax to Position
or Row Numbers in the Parameter
Vector or Table</h2><span id='topic+pars_id'></span>

<h3>Description</h3>

<p>Converts a vector of
lavaan syntax to the ids of parameters
in the vector of free parameters or the row numbers
in the parameter table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pars_id(pars, fit, where = c("coef", "partable"), free_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pars_id_+3A_pars">pars</code></td>
<td>
<p>A character vector of parameters specified
in lavaan syntax, e.g., <code>"y ~ x"</code> and <code>f1 =~ x3</code>. For
multisample models, if only the parameters in some groups
are needed, use the modifier for labeling parameters and
use <code>NA</code> to denote parameters to be requested. E.g.,
<code>f1 =~ c(NA, 0, NA, NA) * x2</code> denotes the loadings of
<code>x2</code> on <code>f1</code> in the first, third, and fourth groups.</p>
</td></tr>
<tr><td><code id="pars_id_+3A_fit">fit</code></td>
<td>
<p>A <code>lavaan</code>-class object. This object is used
to determine the number of groups and the parameters
in the model. Only parameters in <code>pars</code> that appear in
this model will be considered.</p>
</td></tr>
<tr><td><code id="pars_id_+3A_where">where</code></td>
<td>
<p>Where the values are to be found. Can be
&quot;partable&quot; (parameter table) or &quot;coef&quot;
(coefficient vector).
Default is &quot;coef&quot;.</p>
</td></tr>
<tr><td><code id="pars_id_+3A_free_only">free_only</code></td>
<td>
<p>Whether only free parameters will be
kept. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It supports the following ways to specify
the parameters to be included.
</p>

<ul>
<li> <p><code>lavaan</code> syntax
</p>

<ul>
<li><p> For example, <code>"y ~ x"</code> denotes the regression coefficient
regression <code>y</code> on <code>x</code>. It uses <code><a href="lavaan.html#topic+model.syntax">lavaan::lavaanify()</a></code> to
parse the syntax strings.
</p>
</li></ul>

</li>
<li><p> Operator
</p>

<ul>
<li><p> For example, <code>"~"</code> denotes all regression coefficients.
</p>
</li>
<li><p> It also supports <code style="white-space: pre;">&#8288;:=&#8288;</code>, which can be used to select
user-defined parameters.
</p>
</li></ul>

</li>
<li><p> Label
</p>

<ul>
<li><p> For example, <code>"ab"</code> denotes all parameters with this
labels defined in model syntax. It can be used to
select user-defined parameters, such as <code>"ab := a*b"</code>.
</p>
</li></ul>

</li></ul>

<p>It is used by functions such as <code><a href="#topic+est_change">est_change()</a></code>.
</p>


<h4>Multisample model</h4>

<p>If a model has more than one group, a specification
specified as in a single sample model denotes the same
parameters in all group.
</p>

<ul>
<li><p> For example, <code>"f1 =~ x2"</code> denotes the factor loading of
<code>x2</code> on <code>f1</code> in all groups. <code>"~~"</code> denotes covariances
and error covariances in all groups.
</p>
</li></ul>

<p>There are two ways to select parameters only in selected
groups. First, the syntax to fix parameter values
can be used, with <code>NA</code> denoting parameters to be selected.
</p>

<ul>
<li><p> For example, <code>"f2 =~ c(NA, 1, NA) * x5"</code> selects the
factor loadings of <code>x5</code> on <code>f2</code> in the first and third
groups.
</p>
</li></ul>

<p>Users can also add &quot;.grouplabel&quot; to a specification,
<code>grouplabel</code> being the group label of a group (the one
appears in <code><a href="base.html#topic+summary">summary()</a></code>, not the one of the form <code>".g2"</code>,
<code>"g3"</code>, etc.).
</p>

<ul>
<li><p> For example, <code>"f2 =~ x5.Alpha"</code> denotes the factor loading
of <code>x5</code> on <code>f2</code> in the group <code>"Alpha"</code>.
</p>
</li>
<li><p> This method can be used for operators. For example,
<code>"=~.Alpha"</code> denotes all factors loadings in the
group <code>"Alpha"</code>.
</p>
</li></ul>

<p>Though not recommended, users can use labels such as
<code>".g2"</code> and <code>".g3"</code> to denote the parameter in a specific
group. These are the labels appear in the output of
some functions of <code>lavaan</code>. Although <code>lavaan</code> does not label
the parameters in the first group by <code>".g1"</code>, this can
still be used in <code>pars_id()</code>.
</p>

<ul>
<li><p> For example, <code>"f2 =~ x5.g2"</code> denotes the factor loading
of <code>x5</code> on <code>f2</code> in the second group. <code>"y ~ x.g1"</code>
denotes the regression coefficient from <code>x</code> to <code>y</code>
in the first group.
</p>
</li>
<li><p> This method can also be used for operators. For example,
<code>"=~.g2"</code> denotes all factors loadings in the
second group.
</p>
</li></ul>

<p>However, this method is not
as reliable as using <code>grouplabel</code> because the numbering
of groups depends on the order they appear in the data
set.
</p>



<h3>Value</h3>

<p>A numeric vector of the ids. If <code>where</code> is <code>"partable"</code>,
the ids are row numbers. If <code>where</code> is <code>"coef"</code>,
the ids are the positions in the vector.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- sem_dat

library(lavaan)
sem_model &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   f1
f3 ~   f2
"

fit_ng &lt;- sem(sem_model, dat)

pars &lt;- c("f1 =~ x2", "f2 =~ x5", "f2 ~ f1")
tmp &lt;- pars_id(pars, fit = fit_ng)
coef(fit_ng)[tmp]
tmp &lt;- pars_id(pars, fit = fit_ng, where = "partable")
parameterTable(fit_ng)[tmp, ]

# Multiple-group models

dat &lt;- sem_dat
set.seed(64264)
dat$gp &lt;- sample(c("Alpha", "Beta", "Gamma"),
                 nrow(dat),
                 replace = TRUE)

library(lavaan)
sem_model &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   f1
f3 ~   f2
"

fit_ng &lt;- sem(sem_model, dat)
fit_gp &lt;- sem(sem_model, dat, group = "gp")

pars &lt;- c("f1 =~ x2", "f2 =~ x5", "f2 ~ f1")
tmp &lt;- pars_id(pars, fit = fit_ng)
coef(fit_ng)[tmp]
tmp &lt;- pars_id(pars, fit = fit_ng, where = "partable")
parameterTable(fit_ng)[tmp, ]

pars &lt;- c("f1 =~ x2", "f2 =~ c(NA, 1, NA) * x5")
tmp &lt;- pars_id(pars, fit = fit_gp)
coef(fit_gp)[tmp]
tmp &lt;- pars_id(pars, fit = fit_gp, where = "partable")
parameterTable(fit_gp)[tmp, ]

pars2 &lt;- c("f1 =~ x2", "~~.Beta", "f2 =~ x5.Gamma")
tmp &lt;- pars_id(pars2, fit = fit_gp)
coef(fit_gp)[tmp]
tmp &lt;- pars_id(pars2, fit = fit_gp, where = "partable")
parameterTable(fit_gp)[tmp, ]
# Note that group 1 is "Beta", not "Alpha"
lavInspect(fit_gp, "group.label")


</code></pre>

<hr>
<h2 id='pars_id_to_lorg'>Ids to &quot;lhs-op-rhs-(group)&quot;</h2><span id='topic+pars_id_to_lorg'></span>

<h3>Description</h3>

<p>Converts id numbers generated by <code><a href="#topic+pars_id">pars_id()</a></code>
to values that can be used to extract the parameters
from a source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pars_id_to_lorg(pars_id, pars_source, type = c("free", "all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pars_id_to_lorg_+3A_pars_id">pars_id</code></td>
<td>
<p>A vector of integers. Usually the output
of <a href="#topic+pars_id">pars_id</a>.</p>
</td></tr>
<tr><td><code id="pars_id_to_lorg_+3A_pars_source">pars_source</code></td>
<td>
<p>Can be the output of
<code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code> or <code><a href="lavaan.html#topic+lavParTable">lavaan::parameterTable()</a></code>,
or a named vector of free parameters (e.g., the output
of <code><a href="stats.html#topic+coef">coef()</a></code> applied to a <code>lavaan</code>-class object).</p>
</td></tr>
<tr><td><code id="pars_id_to_lorg_+3A_type">type</code></td>
<td>
<p>The meaning of the values in <code>pars_id</code>.
If <code>"free"</code>, they
are the position in the vector of free parameters (i.e.,
the output of of <code>coef()</code>). If &quot;all&quot;, they are the
row numbers in the parameter table (the output of
<code><a href="lavaan.html#topic+lavParTable">lavaan::parameterTable()</a></code>). If <code>pars_source</code>
is the output of <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>, which
does not indicate whether a parameter is free or fixed,
this argument will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the source is a parameter estimates table (i.e.,
the output of <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>, it returns
a data frame with columns &quot;lhs&quot;, &quot;op&quot;, and &quot;rhs&quot;. If
&quot;group&quot; is present in the source, it also add a column
&quot;group&quot;. These columns can be used to uniquely identify
the parameters specified by the ids.
</p>
<p>If the source is a named vector of parameters (e.g., the
output of <code><a href="stats.html#topic+coef">coef()</a></code>), it returns the names of parameters
based on the ids.
</p>


<h3>Value</h3>

<p>If <code>pars_source</code> is the output of
<code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code> or
<code><a href="lavaan.html#topic+lavParTable">lavaan::parameterTable()</a></code>, it returns a subset of
<code>pars_source</code>, keeping the rows of selected parameters
and the columns <code>lhs</code>, <code>op</code>, <code>rhs</code>, and <code>group</code>. If
<code>pars_source</code> is a named vector of free parameters, it
returns a character vector containing the names of the
selected parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- sem_dat
set.seed(64264)
library(lavaan)
sem_model &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~   f1
f3 ~   f2
"
fit_ng &lt;- sem(sem_model, dat)

pars &lt;- c("f1 =~ x2", "f2 =~ x5", "f2 ~ f1")
tmp &lt;- pars_id(pars, fit = fit_ng)
pars_id_to_lorg(tmp, pars_source = coef(fit_ng))
tmp &lt;- pars_id(pars, fit = fit_ng, where = "partable")
pars_id_to_lorg(tmp, pars_source = parameterEstimates(fit_ng))

# Multiple-group models

dat$gp &lt;- sample(c("Alpha", "Beta", "Gamma"),
                 nrow(dat),
                 replace = TRUE)

fit_gp &lt;- sem(sem_model, dat, group = "gp")

pars &lt;- c("f1 =~ x2", "f2 =~ c(NA, 1, NA) * x5")
tmp &lt;- pars_id(pars, fit = fit_gp)
pars_id_to_lorg(tmp, pars_source = coef(fit_gp))
tmp &lt;- pars_id(pars, fit = fit_gp, where = "partable")
pars_id_to_lorg(tmp, pars_source = parameterEstimates(fit_gp))

parameterTable(fit_gp)[tmp, ]
pars2 &lt;- c("f1 =~ x2", "~~.Beta", "f2 =~ x5.Gamma")
tmp &lt;- pars_id(pars2, fit = fit_gp)
pars_id_to_lorg(tmp, pars_source = coef(fit_gp))
tmp &lt;- pars_id(pars2, fit = fit_gp, where = "partable")
pars_id_to_lorg(tmp, pars_source = parameterEstimates(fit_gp))
# Note that group 1 is "Beta", not "Alpha"
lavInspect(fit_gp, "group.label")

</code></pre>

<hr>
<h2 id='print.est_change'>Print an 'est_change' Class Object</h2><span id='topic+print.est_change'></span>

<h3>Description</h3>

<p>Print the content of an 'est_change'-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'est_change'
print(x, digits = 3, first = 10, sort_by = c("gcd", "est"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.est_change_+3A_x">x</code></td>
<td>
<p>An 'est_change'-class object.</p>
</td></tr>
<tr><td><code id="print.est_change_+3A_digits">digits</code></td>
<td>
<p>The number of digits after the decimal.
Default is 3.</p>
</td></tr>
<tr><td><code id="print.est_change_+3A_first">first</code></td>
<td>
<p>Numeric. If not <code>NULL</code>, it prints
only the first <em>k</em> cases, <em>k</em> equal to <code>first</code>.
Default is 10.</p>
</td></tr>
<tr><td><code id="print.est_change_+3A_sort_by">sort_by</code></td>
<td>
<p>String. Should be <code>"est"</code>, <code>"gcd"</code>,
or <code>NULL</code>.
If the output was generated
by <code><a href="#topic+est_change_raw">est_change_raw()</a></code>
or <code><a href="#topic+est_change_raw_approx">est_change_raw_approx()</a></code> and <code>sort_by</code> is
not <code>NULL</code>, then
each column is sorted individually, with case IDs inserted
before each column. If the output was generated by
<code><a href="#topic+est_change">est_change()</a></code> or <code><a href="#topic+est_change_approx">est_change_approx()</a></code> and <code>sort_by</code>
is not <code>NULL</code>, then <code>sort_by</code> determines how the cases are sorted.
If <code>by</code> is <code>"est"</code>, the cases are sorted as for
the output of <code><a href="#topic+est_change_raw">est_change_raw()</a></code>. If <code>by</code> is <code>"gcd"</code>,
the default for the output of <code><a href="#topic+est_change">est_change()</a></code> or
<code><a href="#topic+est_change_approx">est_change_approx()</a></code>,
then cases are sorted by generalized Cook's distance
or approximate generalized Cook's distance, depending on
which column is available.</p>
</td></tr>
<tr><td><code id="print.est_change_+3A_...">...</code></td>
<td>
<p>Other arguments. They will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the functions on case influence
on parameter estimates, <code><a href="#topic+est_change">est_change()</a></code>,
<code><a href="#topic+est_change_approx">est_change_approx()</a></code>, <code><a href="#topic+est_change_raw">est_change_raw()</a></code>,
and <code><a href="#topic+est_change_raw_approx">est_change_raw_approx()</a></code>, return
an <code>est_change</code>-class object. This method will print
the output based on the type of changes and method
used.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly. Called for its side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+est_change_raw">est_change_raw()</a></code>, <code><a href="#topic+est_change_raw_approx">est_change_raw_approx()</a></code>,
<code><a href="#topic+est_change">est_change()</a></code>, <code><a href="#topic+est_change_approx">est_change_approx()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)

# A path model

dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# Approximate case influence
out &lt;- est_change_approx(fit)
out
print(out, sort_by = "est")
out &lt;- est_change_raw_approx(fit)
print(out, first = 3)

# Examine four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = c(2, 3, 5, 7))
est_change(fit_rerun)
est_change_raw(fit_rerun)

</code></pre>

<hr>
<h2 id='print.fit_measures_change'>Print a 'fit_measures_change' Class Object</h2><span id='topic+print.fit_measures_change'></span>

<h3>Description</h3>

<p>Print the content of a 'fit_measures_change'-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit_measures_change'
print(
  x,
  digits = 3,
  first = 10,
  sort_by = NULL,
  decreasing = TRUE,
  absolute = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fit_measures_change_+3A_x">x</code></td>
<td>
<p>An 'fit_measures_change'-class object.</p>
</td></tr>
<tr><td><code id="print.fit_measures_change_+3A_digits">digits</code></td>
<td>
<p>The number of digits after the decimal.
Default is 3.</p>
</td></tr>
<tr><td><code id="print.fit_measures_change_+3A_first">first</code></td>
<td>
<p>Numeric. If not <code>NULL</code>, it prints
only the first <em>k</em> cases, <em>k</em> equal to <code>first</code>.
Default is 10.</p>
</td></tr>
<tr><td><code id="print.fit_measures_change_+3A_sort_by">sort_by</code></td>
<td>
<p>String. Default is <code>NULL</code> and
the output is not sorted. If set to a column
names of <code>x</code>, cases will sorted by this columns.
The sorting is done on the absolute values
if <code>absolute</code> is <code>TRUE</code>, and in decreasing
order if <code>decreasing</code> is <code>TRUE</code>. If <code>decrease</code>
is <code>FALSE</code>, the order is increasing. If <code>absolute</code>
is <code>FALSE</code>, the sorting is done on the raw values.</p>
</td></tr>
<tr><td><code id="print.fit_measures_change_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical. Whether cases, if sorted,
is on decreasing order. Default is <code>TRUE</code>. See <code>sort_by</code>.</p>
</td></tr>
<tr><td><code id="print.fit_measures_change_+3A_absolute">absolute</code></td>
<td>
<p>Logical. Whether cases, if sorted,
are sorted on absolute values. Default is <code>TRUE</code>.
See <code>sort_by</code>.</p>
</td></tr>
<tr><td><code id="print.fit_measures_change_+3A_...">...</code></td>
<td>
<p>Other arguments. They will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the functions on case influence
on fit measures, <code><a href="#topic+fit_measures_change">fit_measures_change()</a></code>
and <code><a href="#topic+fit_measures_change_approx">fit_measures_change_approx()</a></code>, return
an <code>fit_measures_change</code>-class object. This method will print
the output, with the option to sort the cases.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly. Called for its side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_measures_change">fit_measures_change()</a></code>, <code><a href="#topic+fit_measures_change_approx">fit_measures_change_approx()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)

# A path model

dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# Case influence
out &lt;- fit_measures_change_approx(fit)
out
print(out, sort_by = "chisq", first = 5)

fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = c(2, 3, 5, 7))#'
out &lt;- fit_measures_change(fit_rerun)
out
print(out, sort_by = "chisq", first = 5)

</code></pre>

<hr>
<h2 id='print.influence_stat'>Print an 'influence_stat' Class Object</h2><span id='topic+print.influence_stat'></span>

<h3>Description</h3>

<p>Print the content of an 'influence_stat'-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'influence_stat'
print(
  x,
  digits = 3,
  what = c("parameters", "fit_measures", "mahalanobis"),
  first = 10,
  sort_parameters_by = c("gcd", "est"),
  sort_fit_measures_by = NULL,
  sort_mahalanobis = TRUE,
  sort_fit_measures_decreasing = TRUE,
  sort_fit_measures_on_absolute = TRUE,
  sort_mahalanobis_decreasing = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.influence_stat_+3A_x">x</code></td>
<td>
<p>An 'influence_stat'-class object.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_digits">digits</code></td>
<td>
<p>The number of digits after the decimal.
Default is 3.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_what">what</code></td>
<td>
<p>A character vector of the
results #' to be printed, can be
one or more of the following:
<code>"parameters"</code>, <code>"fit_measures"</code>,
and <code>"mahalanobis"</code>. Default
is <code>c("parameters", "fit_measures", "mahalanobis")</code>.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_first">first</code></td>
<td>
<p>Numeric. If not <code>NULL</code>, it prints
only the first <em>k</em> cases, <em>k</em> equal to <code>first</code>.
Default is 10.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_sort_parameters_by">sort_parameters_by</code></td>
<td>
<p>String.
If it is <code>"est"</code>, the cases are sorted individually
on each columns. If it is <code>"gcd"</code>,
the default,
then cases are sorted by generalized Cook's distance
or approximate generalized Cook's distance, depending on
which column is available.
If <code>NULL</code>, cases are not sorted.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_sort_fit_measures_by">sort_fit_measures_by</code></td>
<td>
<p>String. Default is <code>NULL</code> and
the output of case influence on fit measures is not
sorted. If set to a column
names of case influence on fit measures , cases will
sorted by these columns.
The sorting is done on the absolute values
if <code>sort_fit_measures_on_absolute</code> is <code>TRUE</code>, and in decreasing
order if <code>decreasing</code> is <code>TRUE</code>. If <code>decrease</code>
is <code>FALSE</code>, the order is increasing. If <code>sort_fit_measures_on_absolute</code>
is <code>FALSE</code>, the sorting is done on the raw values.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_sort_mahalanobis">sort_mahalanobis</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, the cases
in the output of Mahalanobis distance
will be sorted based on Mahalanobis distance.
The order is determined by <code>sort_mahalanobis_decreasing</code>.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_sort_fit_measures_decreasing">sort_fit_measures_decreasing</code></td>
<td>
<p>Logical. Whether cases, if sorted
on fit measures,
are on decreasing order in the output of
case influence on fit measures. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_sort_fit_measures_on_absolute">sort_fit_measures_on_absolute</code></td>
<td>
<p>Logical. Whether
cases, if sorted on fit measures,
are sorted on absolute values of fit measures. Default is <code>TRUE</code>.
See <code>sort_fit_measures_by</code>.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_sort_mahalanobis_decreasing">sort_mahalanobis_decreasing</code></td>
<td>
<p>Logical. Whether cases, if sorted
on Mahalanobis distance,
is on decreasing order. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.influence_stat_+3A_...">...</code></td>
<td>
<p>Optional arguments. Passed to
other print methods, such as <code><a href="#topic+print.est_change">print.est_change()</a></code>,
<code><a href="#topic+print.fit_measures_change">print.fit_measures_change()</a></code>, and <code><a href="#topic+print.md_semfindr">print.md_semfindr()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method will print
the output of <code><a href="#topic+influence_stat">influence_stat()</a></code> in a user-friendly
way. Users can select the set(s) of output,
case influence on parameter estimates,
case influence on fit measures, and
Mahalanobis distance, to be printed.
The corresponding print methods of
<code>est_change</code>-class objects,
<code>fit_measures_change</code>-class objects,
and <code>md_semfindr</code>-class objects will be called.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly. Called for its side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+influence_stat">influence_stat()</a></code>, <code><a href="#topic+print.est_change">print.est_change()</a></code>,
<code><a href="#topic+print.fit_measures_change">print.fit_measures_change()</a></code>, <code><a href="#topic+print.md_semfindr">print.md_semfindr()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- pa_dat
# The model
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)

# --- Leave-One-Out Approach

# Fit the model n times. Each time with one case removed.
# For illustration, do this only for selected cases.
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
# Get all default influence stats
out &lt;- influence_stat(fit_rerun)
out
print(out, first = 4)
print(out, what = c("parameters", "fit_measures"))

# --- Approximate Approach

out_approx &lt;- influence_stat(fit)
out_approx
print(out, first = 8)
print(out, what = c("parameters", "fit_measures"),
      sort_parameters_by = "est")

</code></pre>

<hr>
<h2 id='print.lavaan_rerun'>Print Method for 'lavaan_rerun'</h2><span id='topic+print.lavaan_rerun'></span>

<h3>Description</h3>

<p>Prints the results of <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lavaan_rerun'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lavaan_rerun_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.</p>
</td></tr>
<tr><td><code id="print.lavaan_rerun_+3A_...">...</code></td>
<td>
<p>Other arguments. They will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned invisibly. Called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- pa_dat
# For illustration only, select only the first 50 cases
dat &lt;- dat[1:50, ]
# The model
mod &lt;-
"
m1 ~ iv1 + iv2
dv ~ m1
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)
# Fit the model n times. Each time with one case removed.
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE)
fit_rerun

</code></pre>

<hr>
<h2 id='print.md_semfindr'>Print a 'md_semfindr' Class Object</h2><span id='topic+print.md_semfindr'></span>

<h3>Description</h3>

<p>Print the content of a 'md_semfindr'-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'md_semfindr'
print(x, digits = 3, first = 10, sort = TRUE, decreasing = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.md_semfindr_+3A_x">x</code></td>
<td>
<p>An 'md_semfindr'-class object.</p>
</td></tr>
<tr><td><code id="print.md_semfindr_+3A_digits">digits</code></td>
<td>
<p>The number of digits after the decimal.
Default is 3.</p>
</td></tr>
<tr><td><code id="print.md_semfindr_+3A_first">first</code></td>
<td>
<p>Numeric. If not <code>NULL</code>, it prints
only the first <em>k</em> cases, <em>k</em> equal to <code>first</code>.
Default is 10.</p>
</td></tr>
<tr><td><code id="print.md_semfindr_+3A_sort">sort</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, the cases
will be sorted based on Mahalanobis distance.
The order is determined by <code>decreasing</code>.</p>
</td></tr>
<tr><td><code id="print.md_semfindr_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical. Whether cases, if sorted,
is on decreasing order. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.md_semfindr_+3A_...">...</code></td>
<td>
<p>Other arguments. They will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method for the
'md_semfindr'-class object, returned by
<code><a href="#topic+mahalanobis_rerun">mahalanobis_rerun()</a></code> or <code><a href="#topic+mahalanobis_predictors">mahalanobis_predictors()</a></code>.
This method will print
the output with the option to sort the cases.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly. Called for its side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mahalanobis_rerun">mahalanobis_rerun()</a></code>, <code><a href="#topic+mahalanobis_predictors">mahalanobis_predictors()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- pa_dat
# The model
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
"
# Fit the model
fit &lt;- lavaan::sem(mod, dat)
summary(fit)
# Fit the model n times. Each time with one case removed.
# For illustration, do this only for selected cases.
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = 1:10)
# Compute the Mahalanobis distance for each case
out &lt;- mahalanobis_rerun(fit_rerun)
out
print(out, first = 3)

</code></pre>

<hr>
<h2 id='sem_dat'>Sample Data: A Latent Variable Structural Model</h2><span id='topic+sem_dat'></span>

<h3>Description</h3>

<p>A nine-variable dataset with 200 cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sem_dat
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows
and 9 variables:
</p>

<dl>
<dt>x1</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x3</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x4</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x5</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x6</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x7</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x8</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x9</dt><dd><p>Indicator. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(sem_dat)
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~ a * f1
f3 ~ b * f2
ab := a * b
"
fit &lt;- sem(mod, sem_dat)
summary(fit)
</code></pre>

<hr>
<h2 id='sem_dat2'>Sample Data: A Latent Variable Structural Model
With an Influential Case</h2><span id='topic+sem_dat2'></span>

<h3>Description</h3>

<p>A ten-variable dataset with 200 cases, with
one influential case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sem_dat2
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows
and 10 variables:
</p>

<dl>
<dt>case_id</dt><dd><p>Case ID. Character.</p>
</dd>
<dt>x1</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x3</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x4</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x5</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x6</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x7</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x8</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x9</dt><dd><p>Indicator. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(sem_dat2)
mod &lt;-
"
f1 =~  x1 + x2 + x3
f2 =~  x4 + x5 + x6
f3 =~  x7 + x8 + x9
f2 ~ a * f1
f3 ~ b * f2
ab := a * b
"
fit &lt;- sem(mod, sem_dat2)
summary(fit)
inf_out &lt;- influence_stat(fit)
gcd_plot(inf_out)
</code></pre>

<hr>
<h2 id='user_change_raw'>Case Influence on User-Defined Statistics</h2><span id='topic+user_change_raw'></span>

<h3>Description</h3>

<p>Gets a <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code> output and computes the
changes in user-defined statistics for each case if included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>user_change_raw(rerun_out, user_function = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="user_change_raw_+3A_rerun_out">rerun_out</code></td>
<td>
<p>The output from <code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>.</p>
</td></tr>
<tr><td><code id="user_change_raw_+3A_user_function">user_function</code></td>
<td>
<p>A function that accepts a
<code>lavaan</code>-class object. This function is for computing
user-defined statistics.</p>
</td></tr>
<tr><td><code id="user_change_raw_+3A_...">...</code></td>
<td>
<p>Optional arguments to be
passed to <code>user_function</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each case, <code><a href="#topic+user_change_raw">user_change_raw()</a></code> computes the differences
in user-defined statistics with and without this
case:
</p>
<p>(User statistics with all case) - (User statistics without this case).
</p>
<p>The
change is the raw change. The change is <em>not</em> divided by standard
error.
This is a measure of the influence of a case on the use-defined
statistics if it is included.
</p>
<p>If the value of a case is positive, including
the case increases a statistic.
</p>
<p>If the value of a case is negative, including
the case decreases a statistic.
</p>
<p>The user-defined statistics are computed by a user-supplied
function, <code>user_function</code>. It must return a named
vector-like object (which can have only one value).
The output needs to be named, even if it has only one
value.
</p>


<h3>Value</h3>

<p>An <code>est_change</code>-class object, which is
matrix with the number of columns equals to the number of
values returned by <code>user_function</code> when computed in one
<code>lavaan</code>-class object, and the number of rows equals to
the number of cases. The row names are the case
identification values used in
<code><a href="#topic+lavaan_rerun">lavaan_rerun()</a></code>. The elements are the raw differences.
A print method is available for user-friendly output.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>.
</p>


<h3>References</h3>

<p>Pek, J., &amp; MacCallum, R. (2011). Sensitivity analysis
in structural equation models: Cases and their influence.
<em>Multivariate Behavioral Research, 46</em>(2), 202-228.
doi:10.1080/00273171.2011.561068
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A path model

library(lavaan)
dat &lt;- pa_dat
mod &lt;-
"
m1 ~ a1 * iv1 + a2 * iv2
dv ~ b * m1
a1b := a1 * b
a2b := a2 * b
"
# Fit the model
fit &lt;- sem(mod, dat)
summary(fit)
# Fit the model several times. Each time with one case removed.
# For illustration, do this only for four selected cases
fit_rerun &lt;- lavaan_rerun(fit, parallel = FALSE,
                          to_rerun = c(2, 4, 7, 9))
# Get the R-squares
lavInspect(fit, what = "rsquare")
out &lt;- user_change_raw(fit_rerun,
                       user_function = lavInspect,
                       what = "rsquare")
out

# Index plot
p &lt;- index_plot(out,
                column = "dv",
                plot_title = "R-square: dv")
p


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
