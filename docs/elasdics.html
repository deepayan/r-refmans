<!DOCTYPE html><html><head><title>Help for package elasdics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {elasdics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align_curves'><p>Align two curves measured at discrete points</p></a></li>
<li><a href='#center_curve'><p>Centers curves for plotting</p></a></li>
<li><a href='#compute_elastic_mean'><p>Compute a elastic mean for a collection of curves</p></a></li>
<li><a href='#elasdics'><p>elasdics: <strong>el</strong>astic <strong>a</strong>nalysis of <strong>s</strong>parse, <strong>d</strong>ense and <strong>i</strong>rregular <strong>c</strong>urve<strong>s</strong>.</p></a></li>
<li><a href='#find_optimal_t'><p>Optimal alignment to a smooth curve</p></a></li>
<li><a href='#find_optimal_t_discrete'><p>Finds optimal alignment for discrete open curves</p></a></li>
<li><a href='#find_optimal_t_discrete_closed'><p>Finds optimal alignment for discrete closed curves</p></a></li>
<li><a href='#fit_elastic_regression'><p>Compute a elastic mean for a collection of curves</p></a></li>
<li><a href='#fit_mean'><p>Fitting function for open curves</p></a></li>
<li><a href='#fit_mean_closed'><p>Fitting function for open curves</p></a></li>
<li><a href='#get_evals'><p>Evaluate a curve on a grid</p></a></li>
<li><a href='#get_srv_from_points'><p>Helper functions for curve data measured at discrete points</p></a></li>
<li><a href='#optimise_one_coord_analytic'><p>Does optimization in one parameter direction</p></a></li>
<li><a href='#optimise_one_coord_analytic_closed'><p>Does optimization in one parameter direction</p></a></li>
<li><a href='#plot.aligned_curves'><p>Plot method for aligned curves</p></a></li>
<li><a href='#plot.elastic_mean'><p>Plot method for planar elastic mean curves</p></a></li>
<li><a href='#plot.elastic_reg_model'><p>Plot method for planar elastic regression models</p></a></li>
<li><a href='#predict.elastic_reg_model'><p>Predict method for elastic regression models</p></a></li>
<li><a href='#project_curve_on_closed'><p>Close open curve via projection on derivative level.</p></a></li>
<li><a href='#srvf_to_curve'><p>Re-transform srv curve back to curve</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Elastic Analysis of Sparse, Dense and Irregular Curves</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Lisa Steyer &lt;lisa.steyer@hu-berlin.de&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lisa Steyer &lt;lisa.steyer@hu-berlin.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to align curves and to compute mean curves based on the 
    elastic distance defined in the square-root-velocity framework. For more details on 
    this framework see Srivastava and Klassen (2016, &lt;<a href="https://doi.org/10.1007%2F978-1-4939-4020-2">doi:10.1007/978-1-4939-4020-2</a>&gt;). 
    For more theoretical details on our methods and algorithms see 
    Steyer et al. (2023, &lt;<a href="https://doi.org/10.1111%2Fbiom.13706">doi:10.1111/biom.13706</a>&gt;) and Steyer et al. (2023, &lt;<a href="https://doi.org/10.48550/arXiv.2305.02075">doi:10.48550/arXiv.2305.02075</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>splines, stats, numDeriv</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-25 13:11:20 UTC; Lisa</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-25 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='align_curves'>Align two curves measured at discrete points</h2><span id='topic+align_curves'></span>

<h3>Description</h3>

<p>Finds the optimal reparametrization of the second curve (stored in
<code>data_curve2</code>) to the first one (stored in <code>data_curve1</code>) with respect
to the elastic distance. Constructor function for class <code>aligned_curves</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_curves(data_curve1, data_curve2, closed = FALSE, eps = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_curves_+3A_data_curve1">data_curve1</code></td>
<td>
<p><code>data.frame</code> with observed points in each row. Each
variable is one coordinate direction. If there is a variable <code>t</code>,
it is treated as the time parametrization, not as an additional coordinate.</p>
</td></tr>
<tr><td><code id="align_curves_+3A_data_curve2">data_curve2</code></td>
<td>
<p>same as <code>data_curve1</code></p>
</td></tr>
<tr><td><code id="align_curves_+3A_closed">closed</code></td>
<td>
<p><code>TRUE</code> if the curves should be treated as closed.</p>
</td></tr>
<tr><td><code id="align_curves_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>aligned_curves</code>, which is a <code>list</code>
with entries
</p>
<table>
<tr><td><code>data_curve1</code></td>
<td>
<p><code>data_curve1</code> with parametrization variable <code>t</code></p>
</td></tr>
<tr><td><code>data_curve2_aligned</code></td>
<td>
<p><code>data_curve2</code> with initial parametrization
variable <code>t</code> and optimal parametrization <code>t_optim</code></p>
</td></tr>
<tr><td><code>elastic_dist</code></td>
<td>
<p>elastic distance between curve1 and curve2</p>
</td></tr>
<tr><td><code>closed</code></td>
<td>
<p><code>TRUE</code> if the curves should have been treated as closed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#open curves
data_curve1 &lt;- data.frame(x1 = c(1, 0.5, -1, -1), x2 = c(1, -0.5, -1, 1))
data_curve2 &lt;- data.frame(x1 = c(0.1,0.7)*sin(1:6), x2 = cos(1:6))
aligned_curves &lt;- align_curves(data_curve1, data_curve2)
plot(aligned_curves)

#different parametrization of the first curve
data_curve1$t &lt;- 0:3/3
align_curves(data_curve1, data_curve2)

#closed curves
data_curve1 &lt;- data.frame(x1 = sin(0:12/5), x2 = cos(0:12/5))
data_curve2 &lt;- data.frame(x1 = c(1, 0.5, -1, -1), x2 = c(1, -0.5, -1, 1))
aligned_curves_closed &lt;- align_curves(data_curve1, data_curve2, closed = TRUE)
plot(aligned_curves_closed, asp = 1)
</code></pre>

<hr>
<h2 id='center_curve'>Centers curves for plotting</h2><span id='topic+center_curve'></span>

<h3>Description</h3>

<p>Centers curves for plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_curve(data_curve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_curve_+3A_data_curve">data_curve</code></td>
<td>
<p>curve data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with evaluations of the curve
centered at the origin
</p>

<hr>
<h2 id='compute_elastic_mean'>Compute a elastic mean for a collection of curves</h2><span id='topic+compute_elastic_mean'></span>

<h3>Description</h3>

<p>Computes a Fréchet mean for the curves stored in <code>data_curves</code>) with respect
to the elastic distance. Constructor function for class <code>elastic_mean</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_elastic_mean(
  data_curves,
  knots = seq(0, 1, len = 5),
  type = c("smooth", "polygon"),
  closed = FALSE,
  eps = 0.01,
  pen_factor = 100,
  max_iter = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_elastic_mean_+3A_data_curves">data_curves</code></td>
<td>
<p>list of <code>data.frame</code>s with observed points in each row. Each
variable is one coordinate direction. If there is a variable <code>t</code>,
it is treated as the time parametrization, not as an additional coordinate.</p>
</td></tr>
<tr><td><code id="compute_elastic_mean_+3A_knots">knots</code></td>
<td>
<p>set of knots for the mean spline curve</p>
</td></tr>
<tr><td><code id="compute_elastic_mean_+3A_type">type</code></td>
<td>
<p>if &quot;smooth&quot; linear srv-splines are used which results in a differentiable mean curve
if &quot;polygon&quot; the mean will be piecewise linear.</p>
</td></tr>
<tr><td><code id="compute_elastic_mean_+3A_closed">closed</code></td>
<td>
<p><code>TRUE</code> if the curves should be treated as closed.</p>
</td></tr>
<tr><td><code id="compute_elastic_mean_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if L2 norm of coefficients changes less</p>
</td></tr>
<tr><td><code id="compute_elastic_mean_+3A_pen_factor">pen_factor</code></td>
<td>
<p>penalty factor forcing the mean to be closed</p>
</td></tr>
<tr><td><code id="compute_elastic_mean_+3A_max_iter">max_iter</code></td>
<td>
<p>maximal number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>elastic_mean</code>, which is a <code>list</code>
with entries
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>&quot;smooth&quot; if mean was modeled using linear srv-splines or
&quot;polygon&quot; if constant srv-splines are used</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>spline coeffiecients</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>spline knots</p>
</td></tr>
<tr><td><code>data_curves</code></td>
<td>
<p>list of <code>data.frame</code>s with observed points in each row.
First variable <code>t</code> gives the initial parametrization, second variable <code>t_optim</code>
the optimal parametrization when the curve is aligned to the mean.</p>
</td></tr>
<tr><td><code>closed</code></td>
<td>
<p><code>TRUE</code> if the mean is supposed to be a closed curve.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>curve &lt;- function(t){
  rbind(t*cos(13*t), t*sin(13*t))
}
set.seed(18)
data_curves &lt;- lapply(1:4, function(i){
  m &lt;- sample(10:15, 1)
  delta &lt;- abs(rnorm(m, mean = 1, sd = 0.05))
  t &lt;- cumsum(delta)/sum(delta)
  data.frame(t(curve(t)) + 0.07*t*matrix(cumsum(rnorm(2*length(delta))),
             ncol = 2))
})

#compute elastic means
knots &lt;- seq(0,1, length = 11)
smooth_elastic_mean &lt;- compute_elastic_mean(data_curves, knots = knots)
plot(smooth_elastic_mean)

knots &lt;- seq(0,1, length = 15)
polygon_elastic_mean &lt;- compute_elastic_mean(data_curves, knots = knots, type = "poly")
lines(get_evals(polygon_elastic_mean), col = "blue", lwd = 2)

#compute closed smooth mean, takes a little longer

knots &lt;- seq(0,1, length = 11)
closed_elastic_mean &lt;- compute_elastic_mean(data_curves, knots = knots, closed = TRUE)
plot(closed_elastic_mean)
</code></pre>

<hr>
<h2 id='elasdics'>elasdics: <strong>el</strong>astic <strong>a</strong>nalysis of <strong>s</strong>parse, <strong>d</strong>ense and <strong>i</strong>rregular <strong>c</strong>urve<strong>s</strong>.</h2><span id='topic+elasdics'></span>

<h3>Description</h3>

<p>The elasdics package provides functions to align observed curves
and to compute elastic means for collections of curves.
</p>


<h3>Main functions</h3>

<p>Align two observed curves: <code><a href="#topic+align_curves">align_curves</a></code> <br />
Compute a mean for a set of observed curves: <code><a href="#topic+compute_elastic_mean">compute_elastic_mean</a></code>
</p>

<hr>
<h2 id='find_optimal_t'>Optimal alignment to a smooth curve</h2><span id='topic+find_optimal_t'></span>

<h3>Description</h3>

<p>Finds optimal alignment for a discrete open srv curve to a smooth curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_optimal_t(srv_curve, s, q, initial_t = s, eps = 10 * .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_optimal_t_+3A_srv_curve">srv_curve</code></td>
<td>
<p>srv transformation of the smooth curve, needs to be vectorized</p>
</td></tr>
<tr><td><code id="find_optimal_t_+3A_s">s</code></td>
<td>
<p>time points for q, first has to be 0, last has to be 1</p>
</td></tr>
<tr><td><code id="find_optimal_t_+3A_q">q</code></td>
<td>
<p>square root velocity vectors, one less than time points in s</p>
</td></tr>
<tr><td><code id="find_optimal_t_+3A_initial_t">initial_t</code></td>
<td>
<p>starting value for the optimization algorithm</p>
</td></tr>
<tr><td><code id="find_optimal_t_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimal time points for q, without first value 0 and last value 1,
optimal time points have the distance of the observation to the srv_curve as an attribute
</p>

<hr>
<h2 id='find_optimal_t_discrete'>Finds optimal alignment for discrete open curves</h2><span id='topic+find_optimal_t_discrete'></span>

<h3>Description</h3>

<p>Finds optimal aligned time points for srv curve q to  srv curve p using
coordinate wise optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_optimal_t_discrete(r, p, s, q, initial_t = s, eps = 10^-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_optimal_t_discrete_+3A_r">r</code></td>
<td>
<p>time points for p, first has to be 0, last has to be 1</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_+3A_p">p</code></td>
<td>
<p>square root velocity vectors, one less than time points in r</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_+3A_s">s</code></td>
<td>
<p>time points for q, first has to be 0, last has to be 1</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_+3A_q">q</code></td>
<td>
<p>square root velocity vectors, one less than time points in s</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_+3A_initial_t">initial_t</code></td>
<td>
<p>starting value for the optimization algorithm</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimal time points for q, without first value 0 and last value 1
optimal time points have the distance of the observation to the srv_curve as an attribute
</p>

<hr>
<h2 id='find_optimal_t_discrete_closed'>Finds optimal alignment for discrete closed curves</h2><span id='topic+find_optimal_t_discrete_closed'></span>

<h3>Description</h3>

<p>Finds optimal aligned time points for srv curve q to  srv curve p using
coordinate wise optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_optimal_t_discrete_closed(r, p, s, q, initial_t, eps = 10^-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_optimal_t_discrete_closed_+3A_r">r</code></td>
<td>
<p>time points for p, first is last - 1</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_closed_+3A_p">p</code></td>
<td>
<p>square root velocity vectors, one less than time points in r</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_closed_+3A_s">s</code></td>
<td>
<p>time points for q, first is last - 1</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_closed_+3A_q">q</code></td>
<td>
<p>square root velocity vectors, one less than time points in s</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_closed_+3A_initial_t">initial_t</code></td>
<td>
<p>starting value for the optimization algorithm</p>
</td></tr>
<tr><td><code id="find_optimal_t_discrete_closed_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimal time points for q, first is last -1
</p>

<hr>
<h2 id='fit_elastic_regression'>Compute a elastic mean for a collection of curves</h2><span id='topic+fit_elastic_regression'></span>

<h3>Description</h3>

<p>Computes a Fréchet mean for the curves stored in <code>data_curves</code> with respect
to the elastic distance. Constructor function for class <code>elastic_reg_model</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_elastic_regression(
  formula,
  data_curves,
  x_data,
  knots = seq(0, 1, 0.2),
  type = "smooth",
  closed = FALSE,
  max_iter = 10,
  eps = 0.001,
  pre_align = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_elastic_regression_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; of the form data_curves ~ ...&quot;.</p>
</td></tr>
<tr><td><code id="fit_elastic_regression_+3A_data_curves">data_curves</code></td>
<td>
<p>list of <code>data.frame</code>s with observed points in each row. Each
variable is one coordinate direction. If there is a variable <code>t</code>,
it is treated as the time parametrization, not as an additional coordinate.</p>
</td></tr>
<tr><td><code id="fit_elastic_regression_+3A_x_data">x_data</code></td>
<td>
<p>a <code>data.frame</code> with covariates.</p>
</td></tr>
<tr><td><code id="fit_elastic_regression_+3A_knots">knots</code></td>
<td>
<p>set of knots for the parameter curves of the regression model</p>
</td></tr>
<tr><td><code id="fit_elastic_regression_+3A_type">type</code></td>
<td>
<p>if &quot;smooth&quot; linear srv-splines are used which results in a differentiable mean curve
if &quot;polygon&quot; the mean will be piecewise linear.</p>
</td></tr>
<tr><td><code id="fit_elastic_regression_+3A_closed">closed</code></td>
<td>
<p><code>TRUE</code> if the curves should be treated as closed.</p>
</td></tr>
<tr><td><code id="fit_elastic_regression_+3A_max_iter">max_iter</code></td>
<td>
<p>maximal number of iterations</p>
</td></tr>
<tr><td><code id="fit_elastic_regression_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if L2 norm of coefficients changes less</p>
</td></tr>
<tr><td><code id="fit_elastic_regression_+3A_pre_align">pre_align</code></td>
<td>
<p>TRUE if curves should be pre aligned to the mean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>elastic_reg_model</code>, which is a <code>list</code>
with entries
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>&quot;smooth&quot; if linear srv-splines or
&quot;polygon&quot; if constant srv-splines were used</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>spline coeffiecients</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>spline knots</p>
</td></tr>
<tr><td><code>data_curves</code></td>
<td>
<p>list of <code>data.frame</code>s with observed points in each row.
First variable <code>t</code> gives the initial parametrization, second variable <code>t_optim</code>
the optimal parametrization when the curve is aligned to the model prediction.</p>
</td></tr>
<tr><td><code>closed</code></td>
<td>
<p><code>TRUE</code> if the regression model fitted closed curves.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>curve &lt;- function(x_1, x_2, t){
  rbind(2*t*cos(6*t) - x_1*t , x_2*t*sin(6*t))
}
set.seed(18)
x_data &lt;- data.frame(x_1 = runif(10,-1,1), x_2 = runif(10,-1,1))
data_curves &lt;- apply(x_data, 1, function(x){
  m &lt;- sample(10:15, 1)
  delta &lt;- abs(rnorm(m, mean = 1, sd = 0.05))
  t &lt;- cumsum(delta)/sum(delta)
  data.frame(t(curve((x[1] + 1), (x[2] + 2), t))
   + 0.07*t*matrix(cumsum(rnorm(2*length(delta))), ncol = 2))
})
reg_model &lt;- fit_elastic_regression(data_curves ~ x_1 + x_2,
                                    data_curves = data_curves, x_data = x_data)
plot(reg_model)
</code></pre>

<hr>
<h2 id='fit_mean'>Fitting function for open curves</h2><span id='topic+fit_mean'></span>

<h3>Description</h3>

<p>Fits an elastic mean for open curves. Is usually called from
<code><a href="#topic+compute_elastic_mean">compute_elastic_mean</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mean(srv_data_curves, knots, max_iter, type, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mean_+3A_srv_data_curves">srv_data_curves</code></td>
<td>
<p>list of <code>data.frame</code>s with srv vectors in each row.
Usually a result of a call to <code><a href="#topic+get_srv_from_points">get_srv_from_points</a></code></p>
</td></tr>
<tr><td><code id="fit_mean_+3A_knots">knots</code></td>
<td>
<p>set of knots for the mean spline curve</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_max_iter">max_iter</code></td>
<td>
<p>maximal number of iterations</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_type">type</code></td>
<td>
<p>if &quot;smooth&quot; linear srv-splines are used which results in a differentiable mean curve
if &quot;polygon&quot; the mean will be piecewise linear.</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if L2 norm of coefficients changes less</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code>
with entries
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>&quot;smooth&quot; or &quot;polygon&quot;</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p><code>coefs</code> srv spline coefficients of the estimated mean</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>spline knots</p>
</td></tr>
<tr><td><code>t_optims</code></td>
<td>
<p>optimal parametrization</p>
</td></tr>
</table>

<hr>
<h2 id='fit_mean_closed'>Fitting function for open curves</h2><span id='topic+fit_mean_closed'></span>

<h3>Description</h3>

<p>Fits an elastic mean for open curves. Is usually called from
<code><a href="#topic+compute_elastic_mean">compute_elastic_mean</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mean_closed(srv_data_curves, knots, max_iter, type, eps, pen_factor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mean_closed_+3A_srv_data_curves">srv_data_curves</code></td>
<td>
<p>list of <code>data.frame</code>s with srv vectors in each row.
Usually a result of a call to <code><a href="#topic+get_srv_from_points">get_srv_from_points</a></code></p>
</td></tr>
<tr><td><code id="fit_mean_closed_+3A_knots">knots</code></td>
<td>
<p>set of knots for the mean spline curve</p>
</td></tr>
<tr><td><code id="fit_mean_closed_+3A_max_iter">max_iter</code></td>
<td>
<p>maximal number of iterations</p>
</td></tr>
<tr><td><code id="fit_mean_closed_+3A_type">type</code></td>
<td>
<p>if &quot;smooth&quot; linear srv-splines are used which results in a differentiable mean curve</p>
</td></tr>
<tr><td><code id="fit_mean_closed_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if L2 norm of coefficients changes less</p>
</td></tr>
<tr><td><code id="fit_mean_closed_+3A_pen_factor">pen_factor</code></td>
<td>
<p>penalty factor forcing the mean to be closed
if &quot;polygon&quot; the mean will be piecewise linear.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code>
with entries
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>&quot;smooth&quot; or &quot;polygon&quot;</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p><code>coefs</code> srv spline coefficients of the estimated mean</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>spline knots</p>
</td></tr>
<tr><td><code>t_optims</code></td>
<td>
<p>optimal parametrization</p>
</td></tr>
<tr><td><code>shift_idxs</code></td>
<td>
<p>index of the starting point of the closed curve after alignment</p>
</td></tr>
</table>

<hr>
<h2 id='get_evals'>Evaluate a curve on a grid</h2><span id='topic+get_evals'></span><span id='topic+get_evals.data.frame'></span><span id='topic+get_evals.elastic_mean'></span>

<h3>Description</h3>

<p>Evaluate a curve on a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_evals(curve, t_grid = NULL, ...)

## S3 method for class 'data.frame'
get_evals(curve, t_grid = NULL, ...)

## S3 method for class 'elastic_mean'
get_evals(curve, t_grid = NULL, centering = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_evals_+3A_curve">curve</code></td>
<td>
<p>a one parameter function which is to be evaluated on a grid</p>
</td></tr>
<tr><td><code id="get_evals_+3A_t_grid">t_grid</code></td>
<td>
<p>the curve is evaluated at the values in t_grid, first value needs
to be 0, last value needs to be 1.
If t_grid = NULL, a default regular grid with grid length 0.01 is chosen</p>
</td></tr>
<tr><td><code id="get_evals_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="get_evals_+3A_centering">centering</code></td>
<td>
<p>TRUE if curves shall be centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with evaluations of the curve
at the values in <code>t_grid</code> in its rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve &lt;- function(t){c(t*sin(10*t), t*cos(10*t))}
plot(get_evals(curve), type = "b")
</code></pre>

<hr>
<h2 id='get_srv_from_points'>Helper functions for curve data measured at discrete points</h2><span id='topic+get_srv_from_points'></span><span id='topic+get_arc_length_param'></span><span id='topic+get_points_from_srv'></span>

<h3>Description</h3>

<p>Compute the square-root-velocity transformation or the
parametrization with respect to arc length for a curve
observed at discrete points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_srv_from_points(data_curve)

get_points_from_srv(srv_data)

get_arc_length_param(data_curve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_srv_from_points_+3A_data_curve">data_curve</code></td>
<td>
<p>A <code>data.frame</code> with observed points on a curve.
Each row is one point, each variable one coordinate direction. If there is a variable <code>t</code>,
it is treated as the time parametrization, not as an additional coordinate.</p>
</td></tr>
<tr><td><code id="get_srv_from_points_+3A_srv_data">srv_data</code></td>
<td>
<p>A <code>data.frame</code> with
first column <code>t</code> corresponding to the parametrization and square-root-velocity
vectors in the remaining columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_srv_from_points</code> returns a <code>data.frame</code> with
first column <code>t</code> corresponding to the parametrization and square-root-velocity
vectors in the remaining columns. If no parametrization is given, the curve will
be parametrized with respect to arc length. This parametrization will be
computed by a call to <code>get_arc_length_param</code> as well.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_srv_from_points()</code>: Compute square-root-velocity transformation
for curve data measured at discrete points. The inverse transformation can
be computed with <code>get_points_from_s</code>
</p>
</li>
<li> <p><code>get_points_from_srv()</code>: The inverse transformation to
<code>get_srv_from_points</code>. Transforms square-root-velocity data to
points representing a curve (with no parametrization).
</p>
</li>
<li> <p><code>get_arc_length_param()</code>: Compute arc length parametrization.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data_curve1 &lt;- data.frame(x1 = 1:6*sin(1:6), x2 = cos(1:6))
get_arc_length_param(data_curve1) #same parametrization as in
get_srv_from_points(data_curve1)

data_curve2 &lt;- data.frame(t = seq(0,1, length = 6), data_curve1)
plot(data_curve2[,2:3], type = "l", xlim = c(-6, 2), ylim = c(-2, 1))
srv_data &lt;- get_srv_from_points(data_curve2)
#back transformed curve starts at (0,0)
lines(get_points_from_srv(srv_data), col = "red")
</code></pre>

<hr>
<h2 id='optimise_one_coord_analytic'>Does optimization in one parameter direction</h2><span id='topic+optimise_one_coord_analytic'></span>

<h3>Description</h3>

<p>Does optimization in one parameter direction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimise_one_coord_analytic(t, i, r, p, s, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimise_one_coord_analytic_+3A_t">t</code></td>
<td>
<p>current time points, first has to be 0, last has to be 1</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_+3A_i">i</code></td>
<td>
<p>index of t that should be updated</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_+3A_r">r</code></td>
<td>
<p>time points for p, first has to be 0, last has to be 1</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_+3A_p">p</code></td>
<td>
<p>square root velocity vectors, one less than time points in r</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_+3A_s">s</code></td>
<td>
<p>time points for q, first has to be 0, last has to be 1</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_+3A_q">q</code></td>
<td>
<p>square root velocity vectors, one less than time points in s</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimal time points for q with respect to optimization only in the i-th
coordinate direction
</p>

<hr>
<h2 id='optimise_one_coord_analytic_closed'>Does optimization in one parameter direction</h2><span id='topic+optimise_one_coord_analytic_closed'></span>

<h3>Description</h3>

<p>Does optimization in one parameter direction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimise_one_coord_analytic_closed(t, i, r, p, s, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimise_one_coord_analytic_closed_+3A_t">t</code></td>
<td>
<p>current time points, first has to be 0, last has to be 1</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_closed_+3A_i">i</code></td>
<td>
<p>index of t that should be updated</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_closed_+3A_r">r</code></td>
<td>
<p>time points for p, first is last - 1</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_closed_+3A_p">p</code></td>
<td>
<p>square root velocity vectors, one less than time points in r</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_closed_+3A_s">s</code></td>
<td>
<p>time points for q, first is last - 1</p>
</td></tr>
<tr><td><code id="optimise_one_coord_analytic_closed_+3A_q">q</code></td>
<td>
<p>square root velocity vectors, one less than time points in s</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimal time points for q with respect to optimization only in the i-th
coordinate direction
</p>

<hr>
<h2 id='plot.aligned_curves'>Plot method for aligned curves</h2><span id='topic+plot.aligned_curves'></span>

<h3>Description</h3>

<p>Plots objects of class <code>aligned_curves</code>.
Points of same color correspond after the second curve is optimally aligned to the first curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aligned_curves'
plot(x, points_col = rainbow, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.aligned_curves_+3A_x">x</code></td>
<td>
<p>object of class <code>aligned_curves</code>, usually a result of a call to <code><a href="#topic+align_curves">align_curves</a></code></p>
</td></tr>
<tr><td><code id="plot.aligned_curves_+3A_points_col">points_col</code></td>
<td>
<p>which color palette is used for points on the curves,
default is rainbow, see <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> for further options.</p>
</td></tr>
<tr><td><code id="plot.aligned_curves_+3A_...">...</code></td>
<td>
<p>further plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value
</p>


<h3>See Also</h3>

<p>For examples see documentation of <code><a href="#topic+align_curves">align_curves</a></code>.
</p>

<hr>
<h2 id='plot.elastic_mean'>Plot method for planar elastic mean curves</h2><span id='topic+plot.elastic_mean'></span>

<h3>Description</h3>

<p>Plots objects of class <code>elastic_mean</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elastic_mean'
plot(x, asp = 1, col = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.elastic_mean_+3A_x">x</code></td>
<td>
<p>object of class <code>elastic_mean</code>,
usually a result of a call to <code><a href="#topic+compute_elastic_mean">compute_elastic_mean</a></code></p>
</td></tr>
<tr><td><code id="plot.elastic_mean_+3A_asp">asp</code></td>
<td>
<p>numeric, giving the aspect ratio of the two coordinates,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.elastic_mean_+3A_col">col</code></td>
<td>
<p>color of the mean curve.</p>
</td></tr>
<tr><td><code id="plot.elastic_mean_+3A_...">...</code></td>
<td>
<p>further plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value
</p>


<h3>See Also</h3>

<p>For examples see documentation of <code><a href="#topic+compute_elastic_mean">compute_elastic_mean</a></code>.
</p>

<hr>
<h2 id='plot.elastic_reg_model'>Plot method for planar elastic regression models</h2><span id='topic+plot.elastic_reg_model'></span>

<h3>Description</h3>

<p>Plots objects of class <code>elastic_reg_model</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elastic_reg_model'
plot(x, asp = 1, col = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.elastic_reg_model_+3A_x">x</code></td>
<td>
<p>object of class <code>elastic_reg_model</code>,
usually a result of a call to <code><a href="#topic+fit_elastic_regression">fit_elastic_regression</a></code></p>
</td></tr>
<tr><td><code id="plot.elastic_reg_model_+3A_asp">asp</code></td>
<td>
<p>numeric, giving the aspect ratio of the two coordinates,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.elastic_reg_model_+3A_col">col</code></td>
<td>
<p>color of the predicted curves.</p>
</td></tr>
<tr><td><code id="plot.elastic_reg_model_+3A_...">...</code></td>
<td>
<p>further plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value
</p>


<h3>See Also</h3>

<p>For examples see documentation of <code><a href="#topic+fit_elastic_regression">fit_elastic_regression</a></code>.
</p>

<hr>
<h2 id='predict.elastic_reg_model'>Predict method for elastic regression models</h2><span id='topic+predict.elastic_reg_model'></span>

<h3>Description</h3>

<p>predicted curves for elastic regression model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elastic_reg_model'
predict(object, newdata = NULL, t_grid = seq(0, 1, 0.01), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.elastic_reg_model_+3A_object">object</code></td>
<td>
<p>object of class <code>elastic_reg_model</code>,
usually a result of a call to <code><a href="#topic+fit_elastic_regression">fit_elastic_regression</a></code></p>
</td></tr>
<tr><td><code id="predict.elastic_reg_model_+3A_newdata">newdata</code></td>
<td>
<p>an optional <code>data.frame</code> in which to look for variables with which to predict.
If not given, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.elastic_reg_model_+3A_t_grid">t_grid</code></td>
<td>
<p>grid on which the predicted curves are evaluated.</p>
</td></tr>
<tr><td><code id="predict.elastic_reg_model_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of <code>data.frame</code>s with predicted curves
</p>


<h3>See Also</h3>

<p>For examples see documentation of <code><a href="#topic+fit_elastic_regression">fit_elastic_regression</a></code>.
</p>

<hr>
<h2 id='project_curve_on_closed'>Close open curve via projection on derivative level.</h2><span id='topic+project_curve_on_closed'></span>

<h3>Description</h3>

<p>Close open curve via projection on derivative level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_curve_on_closed(data_curve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_curve_on_closed_+3A_data_curve">data_curve</code></td>
<td>
<p><code>data.frame</code> with values of the curve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with closed curve.
</p>

<hr>
<h2 id='srvf_to_curve'>Re-transform srv curve back to curve</h2><span id='topic+srvf_to_curve'></span>

<h3>Description</h3>

<p>Re-transform srv curve back to curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srvf_to_curve(t, srv_curve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srvf_to_curve_+3A_t">t</code></td>
<td>
<p>time points at which the resulting curve shall be evaluated.</p>
</td></tr>
<tr><td><code id="srvf_to_curve_+3A_srv_curve">srv_curve</code></td>
<td>
<p>srv curve as a function of one parameter,
needs to be vectorized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code> with curve evaluations at time points t in its columns,
rows correspond to coordinate directions
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
