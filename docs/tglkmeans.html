<!DOCTYPE html><html><head><title>Help for package tglkmeans</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tglkmeans}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#downsample_matrix'><p>Downsample the columns of a matrix to a target number</p></a></li>
<li><a href='#simulate_data'><p>Simulate normal data for kmeans tests</p></a></li>
<li><a href='#TGL_kmeans'><p>kmeans++ with return value similar to R kmeans</p></a></li>
<li><a href='#TGL_kmeans_tidy'><p>TGL kmeans with 'tidy' output</p></a></li>
<li><a href='#tglkmeans-package'><p>tglkmeans: Efficient Implementation of K-Means++ Algorithm</p></a></li>
<li><a href='#tglkmeans.set_parallel'><p>Set parallel threads</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Efficient Implementation of K-Means++ Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Aviezer Lifshitz [aut, cre],
  Amos Tanay [aut],
  Weizmann Institute of Science [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aviezer Lifshitz &lt;aviezer.lifshitz@weizmann.ac.il&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient implementation of K-Means++ algorithm. For more
    information see (1) "kmeans++ the advantages of the k-means++
    algorithm" by David Arthur and Sergei Vassilvitskii (2007),
    Proceedings of the eighteenth annual ACM-SIAM symposium on Discrete
    algorithms, Society for Industrial and Applied Mathematics,
    Philadelphia, PA, USA, pp. 1027-1035, and (2) "The Effectiveness of
    Lloyd-Type Methods for the k-Means Problem" by Rafail Ostrovsky, Yuval
    Rabani, Leonard J. Schulman and Chaitanya Swamy
    &lt;<a href="https://doi.org/10.1145%2F2395116.2395117">doi:10.1145/2395116.2395117</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tanaylab/tglkmeans/issues">https://github.com/tanaylab/tglkmeans/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tanaylab.github.io/tglkmeans/">https://tanaylab.github.io/tglkmeans/</a>,
<a href="https://github.com/tanaylab/tglkmeans">https://github.com/tanaylab/tglkmeans</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, doFuture, dplyr (&ge; 0.5.0), future, ggplot2 (&ge; 2.2.0),
magrittr, Matrix, methods, parallel (&ge; 3.3.2), plyr (&ge;
1.8.4), purrr (&ge; 0.2.0), Rcpp (&ge; 0.12.11), RcppParallel,
tgstat (&ge; 1.0.0), tibble (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rlang, rmarkdown, testthat, withr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>OS_type:</td>
<td>unix</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 13:00:04 UTC; aviezerl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='downsample_matrix'>Downsample the columns of a matrix to a target number</h2><span id='topic+downsample_matrix'></span>

<h3>Description</h3>

<p>This function takes a matrix and downsamples it to a target number of samples.
It uses a random seed for reproducibility and allows for removing columns with
small sums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsample_matrix(
  mat,
  target_n = NULL,
  target_q = NULL,
  seed = NULL,
  remove_columns = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_matrix_+3A_mat">mat</code></td>
<td>
<p>An integer matrix to be downsampled. Can be a matrix or sparse matrix (dgCMatrix).
If the matrix contains NAs, the function will run significantly slower. Values that are
not integers will be coerced to integers using <code>floor()</code>.</p>
</td></tr>
<tr><td><code id="downsample_matrix_+3A_target_n">target_n</code></td>
<td>
<p>The target number of samples to downsample to.</p>
</td></tr>
<tr><td><code id="downsample_matrix_+3A_target_q">target_q</code></td>
<td>
<p>A target quantile of sums to downsample to. Only one of 'target_n' or 'target_q' can be provided.</p>
</td></tr>
<tr><td><code id="downsample_matrix_+3A_seed">seed</code></td>
<td>
<p>The random seed for reproducibility (default is NULL)</p>
</td></tr>
<tr><td><code id="downsample_matrix_+3A_remove_columns">remove_columns</code></td>
<td>
<p>Logical indicating whether to remove columns with small sums (default is FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The downsampled matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

mat &lt;- matrix(1:12, nrow = 4)
downsample_matrix(mat, 2)

# Remove columns with small sums
downsample_matrix(mat, 12, remove_columns = TRUE)

# sparse matrix
mat_sparse &lt;- Matrix::Matrix(mat, sparse = TRUE)
downsample_matrix(mat_sparse, 2)

# with a quantile
downsample_matrix(mat, target_q = 0.5)

</code></pre>

<hr>
<h2 id='simulate_data'>Simulate normal data for kmeans tests</h2><span id='topic+simulate_data'></span>

<h3>Description</h3>

<p>Creates <code>nclust</code> clusters normally distributed around <code>1:nclust</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_data(
  n = 100,
  sd = 0.3,
  nclust = 30,
  dims = 2,
  frac_na = NULL,
  add_true_clust = TRUE,
  id_column = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_data_+3A_n">n</code></td>
<td>
<p>number of observations per cluster</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_sd">sd</code></td>
<td>
<p>sd</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_nclust">nclust</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_dims">dims</code></td>
<td>
<p>number of dimensions</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_frac_na">frac_na</code></td>
<td>
<p>fraction of NA in the first dimension</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_add_true_clust">add_true_clust</code></td>
<td>
<p>add a column with the true cluster ids</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_id_column">id_column</code></td>
<td>
<p>add a column with the id</p>
</td></tr>
</table>


<h3>Value</h3>

<p>simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulate_data(n = 100, sd = 0.3, nclust = 5, dims = 2)

# add 20% missing data
simulate_data(n = 100, sd = 0.3, nclust = 5, dims = 2, frac_na = 0.2)

</code></pre>

<hr>
<h2 id='TGL_kmeans'>kmeans++ with return value similar to R kmeans</h2><span id='topic+TGL_kmeans'></span>

<h3>Description</h3>

<p>kmeans++ with return value similar to R kmeans
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TGL_kmeans(
  df,
  k,
  metric = "euclid",
  max_iter = 40,
  min_delta = 0.0001,
  verbose = FALSE,
  keep_log = FALSE,
  id_column = FALSE,
  reorder_func = "hclust",
  hclust_intra_clusters = FALSE,
  seed = NULL,
  parallel = getOption("tglkmeans.parallel"),
  use_cpp_random = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TGL_kmeans_+3A_df">df</code></td>
<td>
<p>a data frame or a matrix. Each row is a single observation and each column is a dimension.
the first column can contain id for each observation (if id_column is TRUE),
otherwise the rownames are used.</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_k">k</code></td>
<td>
<p>number of clusters. Note that in some cases the algorithm might return less clusters than k.</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_metric">metric</code></td>
<td>
<p>distance metric for kmeans++ seeding. can be 'euclid', 'pearson' or 'spearman'</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_max_iter">max_iter</code></td>
<td>
<p>maximal number of iterations</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_min_delta">min_delta</code></td>
<td>
<p>minimal change in assignments (fraction out of all observations) to continue iterating</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_verbose">verbose</code></td>
<td>
<p>display algorithm messages</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_keep_log">keep_log</code></td>
<td>
<p>keep algorithm messages in 'log' field</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_id_column">id_column</code></td>
<td>
<p><code>df</code>'s first column contains the observation id</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_reorder_func">reorder_func</code></td>
<td>
<p>function to reorder the clusters. operates on each center and orders by the result. e.g. <code>reorder_func = mean</code> would calculate the mean of each center and then would reorder the clusters accordingly. If <code>reorder_func = hclust</code> the centers would be ordered by hclust of the euclidean distance of the correlation matrix, i.e. <code>hclust(dist(cor(t(centers))))</code>
if NULL, no reordering would be done.</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_hclust_intra_clusters">hclust_intra_clusters</code></td>
<td>
<p>run hierarchical clustering within each cluster and return an ordering of the observations.</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_seed">seed</code></td>
<td>
<p>seed for the c++ random number generator</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_parallel">parallel</code></td>
<td>
<p>cluster every cluster parallelly (if hclust_intra_clusters is true)</p>
</td></tr>
<tr><td><code id="TGL_kmeans_+3A_use_cpp_random">use_cpp_random</code></td>
<td>
<p>use c++ random number generator instead of R's. This should be used for only for
backwards compatibility, as from version 0.4.0 onwards the default random number generator was changed o R.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following components:
</p>

<dl>
<dt>cluster:</dt><dd><p>A vector of integers (from ‘1:k’) indicating the cluster to which each point is allocated.</p>
</dd>
<dt>centers:</dt><dd><p>A matrix of cluster centers.</p>
</dd>
<dt>size:</dt><dd><p>The number of points in each cluster.</p>
</dd>
<dt>log:</dt><dd><p>messages from the algorithm run (only if <code>id_column == TRUE</code>).</p>
</dd>
<dt>order:</dt><dd><p>A vector of integers with the new ordering if the observations. (only if hclust_intra_clusters = TRUE)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+TGL_kmeans_tidy">TGL_kmeans_tidy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# create 5 clusters normally distributed around 1:5
d &lt;- simulate_data(
    n = 100,
    sd = 0.3,
    nclust = 5,
    dims = 2,
    add_true_clust = FALSE,
    id_column = FALSE
)

head(d)

# cluster
km &lt;- TGL_kmeans(d, k = 5, "euclid", verbose = TRUE)
names(km)
km$centers
head(km$cluster)
km$size
</code></pre>

<hr>
<h2 id='TGL_kmeans_tidy'>TGL kmeans with 'tidy' output</h2><span id='topic+TGL_kmeans_tidy'></span>

<h3>Description</h3>

<p>TGL kmeans with 'tidy' output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TGL_kmeans_tidy(
  df,
  k,
  metric = "euclid",
  max_iter = 40,
  min_delta = 0.0001,
  verbose = FALSE,
  keep_log = FALSE,
  id_column = FALSE,
  reorder_func = "hclust",
  add_to_data = FALSE,
  hclust_intra_clusters = FALSE,
  seed = NULL,
  parallel = getOption("tglkmeans.parallel"),
  use_cpp_random = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TGL_kmeans_tidy_+3A_df">df</code></td>
<td>
<p>a data frame or a matrix. Each row is a single observation and each column is a dimension.
the first column can contain id for each observation (if id_column is TRUE),
otherwise the rownames are used.</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_k">k</code></td>
<td>
<p>number of clusters. Note that in some cases the algorithm might return less clusters than k.</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_metric">metric</code></td>
<td>
<p>distance metric for kmeans++ seeding. can be 'euclid', 'pearson' or 'spearman'</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_max_iter">max_iter</code></td>
<td>
<p>maximal number of iterations</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_min_delta">min_delta</code></td>
<td>
<p>minimal change in assignments (fraction out of all observations) to continue iterating</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_verbose">verbose</code></td>
<td>
<p>display algorithm messages</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_keep_log">keep_log</code></td>
<td>
<p>keep algorithm messages in 'log' field</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_id_column">id_column</code></td>
<td>
<p><code>df</code>'s first column contains the observation id</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_reorder_func">reorder_func</code></td>
<td>
<p>function to reorder the clusters. operates on each center and orders by the result. e.g. <code>reorder_func = mean</code> would calculate the mean of each center and then would reorder the clusters accordingly. If <code>reorder_func = hclust</code> the centers would be ordered by hclust of the euclidean distance of the correlation matrix, i.e. <code>hclust(dist(cor(t(centers))))</code>
if NULL, no reordering would be done.</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_add_to_data">add_to_data</code></td>
<td>
<p>return also the original data frame with an extra 'clust' column with the cluster ids ('id' is the first column)</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_hclust_intra_clusters">hclust_intra_clusters</code></td>
<td>
<p>run hierarchical clustering within each cluster and return an ordering of the observations.</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_seed">seed</code></td>
<td>
<p>seed for the c++ random number generator</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_parallel">parallel</code></td>
<td>
<p>cluster every cluster parallelly (if hclust_intra_clusters is true)</p>
</td></tr>
<tr><td><code id="TGL_kmeans_tidy_+3A_use_cpp_random">use_cpp_random</code></td>
<td>
<p>use c++ random number generator instead of R's. This should be used for only for
backwards compatibility, as from version 0.4.0 onwards the default random number generator was changed o R.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following components:
</p>

<dl>
<dt>cluster:</dt><dd><p>tibble with 'id' column with the observation id ('1:n' if no id column was supplied), and 'clust' column with the observation assigned cluster.</p>
</dd>
<dt>centers:</dt><dd><p>tibble with 'clust' column and the cluster centers.</p>
</dd>
<dt>size:</dt><dd><p>tibble with 'clust' column and 'n' column with the number of points in each cluster.</p>
</dd>
<dt>data:</dt><dd><p>tibble with 'clust' column the original data frame.</p>
</dd>
<dt>log:</dt><dd><p>messages from the algorithm run (only if <code>id_column = FALSE</code>).</p>
</dd>
<dt>order:</dt><dd><p>tibble with 'id' column, 'clust' column, 'order' column with a new ordering if the observations and 'intra_clust_order' column with the order within each cluster. (only if hclust_intra_clusters = TRUE)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+TGL_kmeans">TGL_kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# create 5 clusters normally distributed around 1:5
d &lt;- simulate_data(
    n = 100,
    sd = 0.3,
    nclust = 5,
    dims = 2,
    add_true_clust = FALSE,
    id_column = FALSE
)

head(d)

# cluster
km &lt;- TGL_kmeans_tidy(d, k = 5, "euclid", verbose = TRUE)
km
</code></pre>

<hr>
<h2 id='tglkmeans-package'>tglkmeans: Efficient Implementation of K-Means++ Algorithm</h2><span id='topic+tglkmeans'></span><span id='topic+tglkmeans-package'></span>

<h3>Description</h3>

<p>Efficient implementation of K-Means++ algorithm. For more information see (1) &quot;kmeans++ the advantages of the k-means++ algorithm&quot; by David Arthur and Sergei Vassilvitskii (2007), Proceedings of the eighteenth annual ACM-SIAM symposium on Discrete algorithms, Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, pp. 1027-1035, and (2) &quot;The Effectiveness of Lloyd-Type Methods for the k-Means Problem&quot; by Rafail Ostrovsky, Yuval Rabani, Leonard J. Schulman and Chaitanya Swamy <a href="https://doi.org/10.1145/2395116.2395117">doi:10.1145/2395116.2395117</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aviezer Lifshitz <a href="mailto:aviezer.lifshitz@weizmann.ac.il">aviezer.lifshitz@weizmann.ac.il</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Amos Tanay
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Weizmann Institute of Science [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tanaylab.github.io/tglkmeans/">https://tanaylab.github.io/tglkmeans/</a>
</p>
</li>
<li> <p><a href="https://github.com/tanaylab/tglkmeans">https://github.com/tanaylab/tglkmeans</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tanaylab/tglkmeans/issues">https://github.com/tanaylab/tglkmeans/issues</a>
</p>
</li></ul>


<hr>
<h2 id='tglkmeans.set_parallel'>Set parallel threads</h2><span id='topic+tglkmeans.set_parallel'></span>

<h3>Description</h3>

<p>Set parallel threads
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tglkmeans.set_parallel(thread_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tglkmeans.set_parallel_+3A_thread_num">thread_num</code></td>
<td>
<p>number of threads. use '1' for non parallel behavior</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tglkmeans.set_parallel(8)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
