<!DOCTYPE html><html><head><title>Help for package pedigree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pedigree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.Inds'><p>Function to add missing individuals to a pedigree</p></a></li>
<li><a href='#blup'><p>Function to calculate breeding values using an animal model</p></a></li>
<li><a href='#calcG'><p>Function to calculate a relationship matrix from marker data</p>
(usually allele count data), G matrix.</a></li>
<li><a href='#calcInbreeding'><p>Calculates inbreeding coefficients for individuals in a pedigree.</p></a></li>
<li><a href='#countGen'><p>Count generation number for each individual in a pedigree.</p></a></li>
<li><a href='#countOff'><p>Function that counts the number of offspring (and following</p>
generations for each individual in a pedigree.</a></li>
<li><a href='#gblup'><p>Function to calculate breeding values using an animal model and a</p>
relationship matrix calculated from the markers (G matrix)</a></li>
<li><a href='#makeA'><p>Makes the A matrix for a part of a pedigree</p></a></li>
<li><a href='#makeAinv'><p>Makes inverted A matrix for a pedigree</p></a></li>
<li><a href='#orderPed'><p>Orders a pedigree</p></a></li>
<li><a href='#pedigree-package'>
<p>Package to deal with pedigree data</p></a></li>
<li><a href='#trimPed'><p>Function to trim a pedigree based on available data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pedigree Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-13</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods,HaploSim (&ge; 1.8.4),reshape</td>
</tr>
<tr>
<td>Description:</td>
<td>Pedigree related functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Author:</td>
<td>Albart Coster [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Albart Coster &lt;albart@dairyconsult.nl&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-13 20:25:52 UTC; Gebruiker</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-13 20:50:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.3.0; x86_64-pc-linux-gnu; 2022-11-07 11:14:19 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='add.Inds'>Function to add missing individuals to a pedigree</h2><span id='topic+add.Inds'></span>

<h3>Description</h3>

<p>Function add.Inds() adds missing individuals to a pedigree and returns the
complete pedigree as a data.frame with the same headers as the
original pedigree. Remeber to check for errors beforehand with
function <code>errors.ped</code>. Unknown parents should be coded as NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.Inds(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.Inds_+3A_ped">ped</code></td>
<td>
<p><code>data.frame</code> with three columns: id,id parent1,id parent2 </p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of three columns with identical header as input.
</p>


<h3>Author(s)</h3>

<p>Albart Coster, Albart.Coster@wur.nl</p>


<h3>See Also</h3>

 <p><code><a href="pedigree.html#topic+orderPed">orderPed</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ID &lt;- 3:5
DAM &lt;- c(1,1,3)
SIRE &lt;- c(2,2,4)
pedigree &lt;- data.frame(ID,DAM,SIRE)
pedigree &lt;- add.Inds(pedigree)
</code></pre>

<hr>
<h2 id='blup'>Function to calculate breeding values using an animal model</h2><span id='topic+blup'></span>

<h3>Description</h3>

<p>Fit an animal model to data, use a given variance ratio
(<code class="reqn">\alpha = \frac{\sigma^2_e}{\sigma^ 2_a}</code>). Calculate inverse of the
additive genetic relationship matrix using function <code>makeInv()</code>
of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blup(formula, ped, alpha,trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blup_+3A_formula">formula</code></td>
<td>
<p>formula of the model, do not include the random effect
due to animal (generally ID).</p>
</td></tr>
<tr><td><code id="blup_+3A_ped">ped</code></td>
<td>
<p><code>data.frame</code> with columns corresponding to ID, SIRE,
DAM and the columns in the formula.</p>
</td></tr>
<tr><td><code id="blup_+3A_alpha">alpha</code></td>
<td>
<p>Variance ratio (<code class="reqn">\frac{\sigma^2_e}{\sigma^ 2_a}</code>).</p>
</td></tr>
<tr><td><code id="blup_+3A_trim">trim</code></td>
<td>
<p>If <code>TRUE</code>, trims the pedigree using the available
phenotype data using function <code><a href="#topic+trimPed">trimPed</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of solutions to the model, including random animal effects.</p>


<h3>See Also</h3>

<p><code><a href="HaploSim.html#topic+SamplePedigree">SamplePedigree</a></code>, <code><a href="#topic+gblup">gblup</a></code>,
<code><a href="#topic+makeAinv">makeAinv</a></code>,<code><a href="#topic+blup">blup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(gblup)
sol &lt;- blup(P~1,ped = ped,alpha = 1/h2 - 1)
</code></pre>

<hr>
<h2 id='calcG'>Function to calculate a relationship matrix from marker data
(usually allele count data), G matrix.</h2><span id='topic+calcG'></span>

<h3>Description</h3>

<p>Function to calculate a relationship matrix from marker data. Option
to return the inverse of matrix. Inverse calculated using
<code>Matrix</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcG(M, data = NULL,solve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcG_+3A_m">M</code></td>
<td>
<p>Matrix of marker genotypes, usually the count of one of the
two SNP alleles at each markers (0, 1, or 2).</p>
</td></tr>
<tr><td><code id="calcG_+3A_data">data</code></td>
<td>
<p>Optional logical vector which can tell of which
individuals we have phenotypes.</p>
</td></tr>
<tr><td><code id="calcG_+3A_solve">solve</code></td>
<td>
<p>Logic, if TRUE then function returns the inverse of the
relationship matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of class <code>dgeMatrix</code>.</p>


<h3>See Also</h3>

<p><code><a href="HaploSim.html#topic+SamplePedigree">SamplePedigree</a></code>, <code><a href="#topic+gblup">gblup</a></code>,
<code><a href="#topic+makeAinv">makeAinv</a></code>,<code><a href="#topic+blup">blup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(gblup)
G &lt;- calcG(M)
Ginv &lt;- calcG(M,solve = TRUE)
</code></pre>

<hr>
<h2 id='calcInbreeding'>Calculates inbreeding coefficients for individuals in a pedigree.</h2><span id='topic+calcInbreeding'></span>

<h3>Description</h3>

<p>Calculates inbreeding coefficients of individuals in a pedigree.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcInbreeding(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcInbreeding_+3A_ped">ped</code></td>
<td>
<p><code>data.frame</code> with three columns: id,id parent1,id parent2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- 1:6
dam &lt;- c(0,0,1,1,4,4)
sire &lt;- c(0,0,2,2,3,5)
ped &lt;- data.frame(id,dam,sire)
(F &lt;- calcInbreeding(ped))
</code></pre>

<hr>
<h2 id='countGen'>Count generation number for each individual in a pedigree.</h2><span id='topic+countGen'></span>

<h3>Description</h3>

<p>Counts generation number for individuals in a pedigreee.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countGen(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countGen_+3A_ped">ped</code></td>
<td>
<p><code>data.frame</code> with three columns: id,id parent1,id parent2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- 1:5
dam &lt;- c(0,0,1,1,4)
sire &lt;- c(0,0,2,2,3)
ped &lt;- data.frame(id,dam,sire)
(gens &lt;- countGen(ped))
</code></pre>

<hr>
<h2 id='countOff'>Function that counts the number of offspring (and following
generations for each individual in a pedigree.</h2><span id='topic+countOff'></span>

<h3>Description</h3>

<p>Function to count the number of offspring for each individual in a
pedigree. With loops, offspring of later generations will be counted
several times.</p>


<h3>Usage</h3>

<pre><code class='language-R'>countOff(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countOff_+3A_ped">ped</code></td>
<td>
<p><code>data.frame</code> with three columns: id,id parent1,id parent2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with number of offspring for each individual in
the pedigree.</p>


<h3>Author(s)</h3>

<p>Albart Coster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(countGen)
countOff(ped)
</code></pre>

<hr>
<h2 id='gblup'>Function to calculate breeding values using an animal model and a
relationship matrix calculated from the markers (G matrix)</h2><span id='topic+gblup'></span>

<h3>Description</h3>

<p>Fit an animal model to data, use a given variance ratio
(<code class="reqn">\alpha = \frac{\sigma^2_e}{\sigma^ 2_a}</code>). Calculate genetic
relationship matrix using the function <code>calcG</code> of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gblup(formula, data, M, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gblup_+3A_formula">formula</code></td>
<td>
<p>formula of the model, do not include the random effect
due to animal (generally ID).</p>
</td></tr>
<tr><td><code id="gblup_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> with columns corresponding to ID and the
columns mentioned in the formula.</p>
</td></tr>
<tr><td><code id="gblup_+3A_m">M</code></td>
<td>
<p>Matrix of marker genotypes, usually the count of one of the
two SNP alleles at each markers (0, 1, or 2).</p>
</td></tr>
<tr><td><code id="gblup_+3A_lambda">lambda</code></td>
<td>
<p>Variance ratio (<code class="reqn">\frac{\sigma^2_e}{\sigma^ 2_a}</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of solutions to the model, including random animal effects.</p>


<h3>See Also</h3>

<p><code><a href="HaploSim.html#topic+SamplePedigree">SamplePedigree</a></code>, <code><a href="#topic+gblup">gblup</a></code>,
<code><a href="#topic+makeAinv">makeAinv</a></code>,<code><a href="#topic+blup">blup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example Code from SampleHaplotypes
hList &lt;- HaploSim::SampleHaplotypes(nHaplotypes = 20,genDist =
1,nDec = 3,nLoc = 20) ## create objects
h &lt;- HaploSim::SampleHaplotype(H0 = hList[[1]],H1 = hList[[2]],genDist =
1,nDec = 3)

## code from the Example SamplePedigree
ID &lt;- 1:10
pID0 &lt;- c(rep(0,5),1,1,3,3,5)
pID1 &lt;- c(rep(0,4),2,2,2,4,4,6)
ped &lt;- data.frame(ID,pID0,pID1)
phList &lt;- HaploSim::SamplePedigree(orig = hList,ped = ped)

## own code
h2 &lt;- 0.5
ped &lt;- phList$ped
hList &lt;- phList$hList
qtlList &lt;- HaploSim::ListQTL(hList = hList,frqtl = 0.1,sigma2qtl = 1)
qtl &lt;- tapply(unlist(qtlList),list(rep(names(qtlList),times = unlist(lapply(qtlList,length))),
                   unlist(lapply(qtlList,function(x)seq(1,length(x))))),mean,na.rm = TRUE)
qtl &lt;- reshape::melt(qtl)
names(qtl) &lt;- c("POS","TRAIT","a")
HH &lt;- HaploSim::getAll(hList,translatePos = FALSE)
rownames(HH) &lt;- sapply(hList,function(x)x@hID)
QQ &lt;- HH[,match(qtl$POS,colnames(HH))]
g &lt;- QQ
ped$G &lt;- with(ped,g[match(hID0,rownames(g))]+g[match(hID1,rownames(g))])
sigmae &lt;- sqrt(var(ped$G)/h2 - var(ped$G))
ped$P &lt;- ped$G + rnorm(nrow(ped),0,sigmae)
M &lt;- with(ped,HH[match(hID0,rownames(HH)),] + HH[match(hID1,rownames(HH)),]) 
rownames(M) &lt;- ped$ID
sol &lt;- gblup(P~1,data = ped[,c('ID','P')],M = M,lambda = 1/h2 - 1)
</code></pre>

<hr>
<h2 id='makeA'>Makes the A matrix for a part of a pedigree</h2><span id='topic+makeA'></span>

<h3>Description</h3>

<p>Makes the A matrix for a part of a pedigree and stores it in a file called
<code>A.txt</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeA(ped,which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeA_+3A_ped">ped</code></td>
<td>
<p><code>data.frame</code> with three columns: id,id parent1,id parent2 </p>
</td></tr>
<tr><td><code id="makeA_+3A_which">which</code></td>
<td>
<p>Logical vector specifying between which indiduals
additive genetic relationship is required. Goes back through the
whole pedigree but only for subset of individuals.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- 1:6
dam &lt;- c(0,0,1,1,4,4)
sire &lt;- c(0,0,2,2,3,5)
ped &lt;- data.frame(id,dam,sire)
makeA(ped,which = c(rep(FALSE,4),rep(TRUE,2)))
A &lt;- read.table("A.txt")

if(file.exists("A.txt"))
file.remove("A.txt")
</code></pre>

<hr>
<h2 id='makeAinv'>Makes inverted A matrix for a pedigree</h2><span id='topic+makeAinv'></span>

<h3>Description</h3>

<p>Makes inverted A matrix for a pedigree and stores it in a file called
<code>Ainv.txt</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAinv(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeAinv_+3A_ped">ped</code></td>
<td>
<p><code>data.frame</code> with three columns: id,id parent1,id parent2 </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- 1:6
dam &lt;- c(0,0,1,1,4,4)
sire &lt;- c(0,0,2,2,3,5)
ped &lt;- data.frame(id,dam,sire)
makeAinv(ped)
Ai &lt;- read.table('Ainv.txt')
nInd &lt;- nrow(ped)
Ainv &lt;- matrix(0,nrow = nInd,ncol = nInd)
Ainv[as.matrix(Ai[,1:2])] &lt;- Ai[,3]
dd &lt;- diag(Ainv)
Ainv &lt;- Ainv + t(Ainv)
diag(Ainv) &lt;- dd

if(file.exists("Ainv.txt"))
file.remove("Ainv.txt")
</code></pre>

<hr>
<h2 id='orderPed'>Orders a pedigree</h2><span id='topic+orderPed'></span>

<h3>Description</h3>

<p>Orders a pedigree so that offspring follow parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderPed(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderPed_+3A_ped">ped</code></td>
<td>
<p><code>data.frame</code> with three columns: id,id parent1,id parent2 </p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- 1:6
dam &lt;- c(0,0,1,1,4,4)
sire &lt;- c(0,0,2,2,3,5)
pedigree &lt;- data.frame(id,dam,sire)
(ord &lt;- orderPed(pedigree))
pedigree &lt;- pedigree[6:1,]
(ord &lt;- orderPed(pedigree))
pedigree &lt;- pedigree[order(ord),]
pwrong &lt;- pedigree
pwrong[1,2] &lt;- pwrong[6,1]
</code></pre>

<hr>
<h2 id='pedigree-package'>
Package to deal with pedigree data</h2><span id='topic+pedigree-package'></span><span id='topic+pedigree'></span>

<h3>Description</h3>

<p>Package with functions to analyse and transform pedigree data. A
pedigree is a <code>data.frame </code> where the first column contains an
ID, and the second and third columns contain ID of first and second parent.
</p>


<h3>Author(s)</h3>

<p>Albart Coster: &lt;albart.coster@wur.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimPed">trimPed</a></code>
<code><a href="#topic+orderPed">orderPed</a></code>
<code><a href="#topic+countGen">countGen</a></code>
<code><a href="#topic+makeA">makeA</a></code>
<code><a href="#topic+makeAinv">makeAinv</a></code>
<code><a href="#topic+calcInbreeding">calcInbreeding</a></code>
<code><a href="#topic+add.Inds">add.Inds</a></code>
</p>

<hr>
<h2 id='trimPed'>Function to trim a pedigree based on available data</h2><span id='topic+trimPed'></span>

<h3>Description</h3>

<p>Trims a pedigree given a vector of data. Branches without data are
trimmed off the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimPed(ped, data,ngenback = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimPed_+3A_ped">ped</code></td>
<td>
<p><code>data.frame</code> with three columns: id,id parent1,id parent2</p>
</td></tr>
<tr><td><code id="trimPed_+3A_data">data</code></td>
<td>
<p>TRUE-FALSE vector. Specifies if data for an individual is
available.</p>
</td></tr>
<tr><td><code id="trimPed_+3A_ngenback">ngenback</code></td>
<td>
<p>Number of generations back. Specifies the number of
generations to keep before the individuals with data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector specifying if an individual should stay in the
pedigree.</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- 1:5
dam &lt;- c(0,0,1,1,4)
sire &lt;- c(0,0,2,2,3)
data &lt;- c(FALSE,FALSE,TRUE,FALSE,FALSE)
ped &lt;- data.frame(id,dam,sire)
yn &lt;- trimPed(ped,data)
ped &lt;- ped[yn,]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
