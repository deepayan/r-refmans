<!DOCTYPE html><html lang="en-US"><head><title>Help for package txtq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {txtq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#txtq-package'><p>txtq-package</p></a></li>
<li><a href='#R6_txtq'><p>R6 class for <code>txtq</code> objects</p></a></li>
<li><a href='#txtq'><p>Create a message queue.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Small Message Queue for Parallel Processes</td>
</tr>
<tr>
<td>Description:</td>
<td>This queue is a data structure that lets
  parallel processes send and receive messages,
  and it can help coordinate the work
  of complicated parallel tasks.
  Processes can push new messages to the queue,
  pop old messages, and obtain a
  log of all the messages ever pushed. File locking
  preserves the integrity of the data even when
  multiple processes access the queue simultaneously.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wlandau/txtq">https://github.com/wlandau/txtq</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wlandau/txtq/issues">https://github.com/wlandau/txtq/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>base64url, filelock (&ge; 1.0.2), R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, purrr, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-27 18:34:28 UTC; c240390</td>
</tr>
<tr>
<td>Author:</td>
<td>William Michael Landau
    <a href="https://orcid.org/0000-0003-1878-3253"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Ian E. Fellows [ctb],
  Eli Lilly and Company [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Michael Landau &lt;will.landau@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-27 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='txtq-package'>txtq-package</h2><span id='topic+txtq-package'></span>

<h3>Description</h3>

<p>The txtq package is a small message queue for R.
</p>


<h3>Author(s)</h3>

<p>William Michael Landau <a href="mailto:will.landau@gmail.com">will.landau@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://github.com/wlandau/txtq">https://github.com/wlandau/txtq</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?txtq for examples.
</code></pre>

<hr>
<h2 id='R6_txtq'>R6 class for <code>txtq</code> objects</h2><span id='topic+R6_txtq'></span>

<h3>Description</h3>

<p>See the <code><a href="#topic+txtq">txtq()</a></code> function for full documentation and usage.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>R6_txtq$new()</code></a>
</p>
</li>
<li> <p><a href="#method-path"><code>R6_txtq$path()</code></a>
</p>
</li>
<li> <p><a href="#method-count"><code>R6_txtq$count()</code></a>
</p>
</li>
<li> <p><a href="#method-total"><code>R6_txtq$total()</code></a>
</p>
</li>
<li> <p><a href="#method-empty"><code>R6_txtq$empty()</code></a>
</p>
</li>
<li> <p><a href="#method-log"><code>R6_txtq$log()</code></a>
</p>
</li>
<li> <p><a href="#method-list"><code>R6_txtq$list()</code></a>
</p>
</li>
<li> <p><a href="#method-pop"><code>R6_txtq$pop()</code></a>
</p>
</li>
<li> <p><a href="#method-push"><code>R6_txtq$push()</code></a>
</p>
</li>
<li> <p><a href="#method-reset"><code>R6_txtq$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-clean"><code>R6_txtq$clean()</code></a>
</p>
</li>
<li> <p><a href="#method-destroy"><code>R6_txtq$destroy()</code></a>
</p>
</li>
<li> <p><a href="#method-validate"><code>R6_txtq$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-import"><code>R6_txtq$import()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>R6_txtq$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a txtq.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$new(path, use_lock_file = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Character string giving the file path of the queue.
The <code>txtq()</code> function creates a folder at this path to store
the messages.</p>
</dd>
<dt><code>use_lock_file</code></dt><dd><p>Logical, whether to use a lock file
for blocking operations. Should only be <code>FALSE</code> in specialized
use cases with no parallel computing (for example, when a
<code>txtq</code> is used as a database and accessed by only one process.)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-path"></a>



<h4>Method <code>path()</code></h4>

<p>Get the txtq path.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$path()</pre></div>


<hr>
<a id="method-count"></a>



<h4>Method <code>count()</code></h4>

<p>Get the number of messages in the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$count()</pre></div>


<hr>
<a id="method-total"></a>



<h4>Method <code>total()</code></h4>

<p>Get the number of messages in the database.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$total()</pre></div>


<hr>
<a id="method-empty"></a>



<h4>Method <code>empty()</code></h4>

<p>Detect whether the txtq is empty.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$empty()</pre></div>


<hr>
<a id="method-log"></a>



<h4>Method <code>log()</code></h4>

<p>List the whole database.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$log()</pre></div>


<hr>
<a id="method-list"></a>



<h4>Method <code>list()</code></h4>

<p>List messages.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$list(n = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of messages.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-pop"></a>



<h4>Method <code>pop()</code></h4>

<p>Pop messages.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$pop(n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of messages.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-push"></a>



<h4>Method <code>push()</code></h4>

<p>Push messages.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$push(title, message)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>title</code></dt><dd><p>Titles of the messages.</p>
</dd>
<dt><code>message</code></dt><dd><p>Contents of the messages.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the txtq.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$reset()</pre></div>


<hr>
<a id="method-clean"></a>



<h4>Method <code>clean()</code></h4>

<p>Clean the txtq.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$clean()</pre></div>


<hr>
<a id="method-destroy"></a>



<h4>Method <code>destroy()</code></h4>

<p>Destroy the txtq.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$destroy()</pre></div>


<hr>
<a id="method-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the txtq.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$validate()</pre></div>


<hr>
<a id="method-import"></a>



<h4>Method <code>import()</code></h4>

<p>Import another txtq.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$import(queue)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>queue</code></dt><dd><p>External txtq to import.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_txtq$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>txtq
</p>

<hr>
<h2 id='txtq'>Create a message queue.</h2><span id='topic+txtq'></span>

<h3>Description</h3>

<p>See the README at
<a href="https://github.com/wlandau/txtq">https://github.com/wlandau/txtq</a>
and the examples in this help file for instructions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>txtq(path, use_lock_file = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="txtq_+3A_path">path</code></td>
<td>
<p>Character string giving the file path of the queue.
The <code>txtq()</code> function creates a folder at this path to store
the messages.</p>
</td></tr>
<tr><td><code id="txtq_+3A_use_lock_file">use_lock_file</code></td>
<td>
<p>Logical, whether to use a lock file
for blocking operations. Should only be <code>FALSE</code> in specialized
use cases with no parallel computing (for example, when a
<code>txtq</code> is used as a database and accessed by only one process.)</p>
</td></tr>
</table>


<h3>NFS</h3>

<p>As an interprocess communication tool,
<code>txtq</code> relies on the <a href="https://github.com/r-lib/filelock"><code>filelock</code></a>
package to prevent race conditions.
Unfortunately, <code>filelock</code> cannot prevent race conditions
on network file systems (NFS), which means neither can <code>txtq</code>.
In other words, on certain common kinds of clusters,
<code>txtq</code> cannot reliably manage interprocess communication
for processes on different computers.
However, it can still serve as a low-tech replacement
for a simple non-threadsafe database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  path &lt;- tempfile() # Define a path to your queue.
  q &lt;- txtq(path) # Create a new queue or recover an existing one.
  q$validate() # Check if the queue is corrupted.
  list.files(q$path()) # The queue lives in this folder.
  q$list() # You have not pushed any messages yet.
  # Let's say two parallel processes (A and B) are sharing this queue.
  # Process A sends Process B some messages.
  # You can only send character vectors.
  q$push(title = "Hello", message = "process B.")
  q$push(
    title = c("Calculate", "Calculate"),
    message = c("sqrt(4)", "sqrt(16)")
  )
  q$push(title = "Send back", message = "the sum.")
  # See your queued messages.
  # The `time` is a formatted character string from `Sys.time()`
  # indicating when the message was pushed.
  q$list()
  q$count() # Number of messages in the queue.
  q$total() # Number of messages that were ever queued.
  q$empty()
  # Now, let's assume process B comes online. It can consume
  # some messages, locking the queue so process A does not
  # mess up the data.
  q$pop(2) # Return and remove the first messages that were added.
  # With those messages popped, we are farther along in the queue.
  q$list()
  q$count() # Number of messages in the queue.
  q$list(1) # You can specify the number of messages to list.
  # But you still have a log of all the messages that were ever pushed.
  q$log()
  q$total() # Number of messages that were ever queued.
  # q$pop() with no arguments just pops one message.
  # Call pop(-1) to pop all the messages at once.
  q$pop()
  # There are more instructions.
  q$pop()
  # Let's say Process B follows the instructions and sends
  # the results back to Process A.
  q$push(title = "Results", message = as.character(sqrt(4) + sqrt(16)))
  # Process A now has access to the results.
  q$pop()
  # Clean out the popped messages
  # so the database file does not grow too large.
  q$push(title = "not", message = "popped")
  q$count()
  q$total()
  q$list()
  q$log()
  q$clean()
  q$count()
  q$total()
  q$list()
  q$log()
  # Optionally remove all messages from the queue.
  q$reset()
  q$count()
  q$total()
  q$list()
  q$log()
  # Destroy the queue's files altogether.
  q$destroy()
  # This whole time, the queue was locked when either Process A
  # or Process B accessed it. That way, the data stays correct
  # no matter who is accessing/modifying the queue and when.
  #
  # You can import a `txtq` into another `txtq`.
  # The unpopped messages are grouped together
  # and sorted by timestamp.
  # Same goes for the popped messages.
  q_from &lt;- txtq(tempfile())
  q_to &lt;- txtq(tempfile())
  q_from$push(title = "from", message = "popped")
  q_from$push(title = "from", message = "unpopped")
  q_to$push(title = "to", message = "popped")
  q_to$push(title = "to", message = "unpopped")
  q_from$pop()
  q_to$pop()
  q_to$import(q_from)
  q_to$list()
  q_to$log()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
