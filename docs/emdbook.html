<!DOCTYPE html><html><head><title>Help for package emdbook</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {emdbook}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply2d'><p>Apply a function to a combination of vectors</p></a></li>
<li><a href='#as.mcmc.bugs'><p>Convert WinBUGS output to CODA format</p></a></li>
<li><a href='#calcslice'><p>Negative log-likelihood slice</p></a></li>
<li><a href='#contour3d'>
<p>Superimpose contour lines on a 3D plot</p></a></li>
<li><a href='#credint'><p>Calculate Bayesian credible intervals</p></a></li>
<li><a href='#curve3d'><p>Plot a 3D surface representing a 2D curve</p></a></li>
<li><a href='#Damselfish'><p>Reef fish (damselfish) data</p></a></li>
<li><a href='#dbetabinom'><p>Beta-binomial distribution</p></a></li>
<li><a href='#dchibarsq'><p>Mixed chi-squared distributions</p></a></li>
<li><a href='#deltamethod'><p>Delta method functions</p></a></li>
<li><a href='#deprecated'><p>Deprecated (obsolete) functions</p></a></li>
<li><a href='#dmvnorm'><p>Multivariate normal distribution density function</p></a></li>
<li><a href='#dzinbinom'><p>Zero-inflated negative binomial distribution</p></a></li>
<li><a href='#emdbook-package'>
<p>Support Functions and Data for &quot;Ecological Models and Data&quot;</p></a></li>
<li><a href='#Fir'><p>Data on fir (Abies) life history</p></a></li>
<li><a href='#get.emdbook.packages'><p>install and update auxiliary packages</p></a></li>
<li><a href='#GobySurvival'><p>Goby (reef fish) survivorship data</p></a></li>
<li><a href='#gridsearch2d'><p>Graphical grid search in 2D</p></a></li>
<li><a href='#HPDregionplot'><p>Plot highest posterior density region</p></a></li>
<li><a href='#lambertW'><p>Lambert W function</p></a></li>
<li><a href='#Lily'><p>Glacier lily occurrence and fecundity data</p></a></li>
<li><a href='#lseq'><p>Log-spaced sequence</p></a></li>
<li><a href='#lump.mcmc.list'><p>Utility functions for mcmc objects</p></a></li>
<li><a href='#metropSB'><p>Metropolis-Szymura-Barton algorithm</p></a></li>
<li><a href='#Myxo'><p>Myxomatosis titer data</p></a></li>
<li><a href='#perturb.params'><p>Create a list of perturbed parameters</p></a></li>
<li><a href='#Reedfrog'><p>Data on reed frog predation experiments</p></a></li>
<li><a href='#scinot'><p>Scientific notation as LaTeX/expression()</p></a></li>
<li><a href='#SeedPred'><p>Seed predation data set from Duncan and Duncan 2000</p></a></li>
<li><a href='#trcoef'><p>Transform coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Support Functions and Data for "Ecological Models and Data"</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.13</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Auxiliary functions and data sets for "Ecological Models and Data", a book presenting maximum likelihood estimation and related topics for ecologists (ISBN 978-0-691-12522-0).</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R2jags, ellipse, SuppDists, numDeriv, testthat, rgl</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, lattice, plyr, coda, bbmle</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.math.mcmaster.ca/bolker/emdbook">https://www.math.mcmaster.ca/bolker/emdbook</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-03 18:34:24 UTC; bolker</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Bolker [aut, cre],
  Sang Woo Park [ctb],
  James Vonesh [dtc],
  Jacqueline Wilson [dtc],
  Russ Schmitt [dtc],
  Sally Holbrook [dtc],
  James D. Thomson [dtc],
  R. Scot Duncan [dtc]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Bolker &lt;bolker@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-03 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply2d'>Apply a function to a combination of vectors</h2><span id='topic+apply2d'></span>

<h3>Description</h3>

<p>applies a (non-vectorized) function to a combination of vectors;
substitute for <code>outer</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply2d(fun, x, y, ..., use_plyr = TRUE, .progress="none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply2d_+3A_fun">fun</code></td>
<td>
<p>a function of two arguments (or a character string such as <code>"*"</code>)</p>
</td></tr>
<tr><td><code id="apply2d_+3A_x">x</code></td>
<td>
<p>first vector</p>
</td></tr>
<tr><td><code id="apply2d_+3A_y">y</code></td>
<td>
<p>second vector</p>
</td></tr>
<tr><td><code id="apply2d_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>fun</code></p>
</td></tr>
<tr><td><code id="apply2d_+3A_use_plyr">use_plyr</code></td>
<td>
<p>use methods from the <code>plyr</code> package?</p>
</td></tr>
<tr><td><code id="apply2d_+3A_.progress">.progress</code></td>
<td>
<p>progress bar type (<code>"none"</code>, <code>"text"</code>,
<code>"tk"</code>,<code>"win"</code>: see <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the function applied to the combinations of the vector values
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p>outer</p>


<h3>Examples</h3>

<pre><code class='language-R'>outer(1:3,1:3)
## this example would work with outer() too
apply2d("*",1:3,1:3)
</code></pre>

<hr>
<h2 id='as.mcmc.bugs'>Convert WinBUGS output to CODA format</h2><span id='topic+as.mcmc.bugs'></span>

<h3>Description</h3>

<p>Converts results of a <code>bugs</code> run
(class <code>"bugs"</code>) to a form that can be
used by CODA (class <code>"mcmc"</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mcmc.bugs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.bugs_+3A_x">x</code></td>
<td>
<p>an object of class <code>bugs</code> (output from <code>bugs()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>mcmc</code>
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>

<hr>
<h2 id='calcslice'>Negative log-likelihood slice</h2><span id='topic+calcslice'></span>

<h3>Description</h3>

<p>Calculate the negative log-likelihood along a line
connecting two <code>mle</code> fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcslice(fit1, fit2, fn = fit1@minuslogl, range = c(-0.1, 1.1), n = 400)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcslice_+3A_fit1">fit1</code></td>
<td>
<p>An <code>mle</code> object</p>
</td></tr>
<tr><td><code id="calcslice_+3A_fit2">fit2</code></td>
<td>
<p>Another <code>mle</code> object</p>
</td></tr>
<tr><td><code id="calcslice_+3A_fn">fn</code></td>
<td>
<p>Negative log-likelihood function</p>
</td></tr>
<tr><td><code id="calcslice_+3A_range">range</code></td>
<td>
<p>Numeric vector: range of parameters to try, where
0 corresponds to <code>coef(fit1)</code> and 1 corresponds to <code>coef(fit2)</code></p>
</td></tr>
<tr><td><code id="calcslice_+3A_n">n</code></td>
<td>
<p>Number of points to evaluate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the negative log-likelihood (not a profile, just a
&quot;slice&quot;) along the line connecting the two sets of coefficients.
Intended for diagnosing and visualizing multiple minima in
a likelihood surface, especially in higher-dimensional models.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Parameter values, along the 0-1 scale described above</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Negative log-likelihood values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ben Bolker</p>

<hr>
<h2 id='contour3d'>
Superimpose contour lines on a 3D plot
</h2><span id='topic+contour3d'></span>

<h3>Description</h3>

<p>Plot contour lines computed from data  in 3D,
or add them to an existing 3D (RGL) surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contour3d(x, y, z, contourArgs=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour3d_+3A_x">x</code></td>
<td>
<p>numeric vector of x values (as in <code><a href="graphics.html#topic+contour">contour</a></code>),
or a list with components <code>x</code>, <code>y</code> and <code>z</code></p>
</td></tr>
<tr><td><code id="contour3d_+3A_y">y</code></td>
<td>
<p>numeric vector of y values (as in <code><a href="graphics.html#topic+contour">contour</a></code>)</p>
</td></tr>
<tr><td><code id="contour3d_+3A_z">z</code></td>
<td>
<p>numeric z matrix (as in <code><a href="graphics.html#topic+contour">contour</a></code>)</p>
</td></tr>
<tr><td><code id="contour3d_+3A_contourargs">contourArgs</code></td>
<td>
<p>list of arguments to <code><a href="grDevices.html#topic+contourLines">contourLines</a></code></p>
</td></tr>
<tr><td><code id="contour3d_+3A_...">...</code></td>
<td>
<p>other arguments to <code><a href="rgl.html#topic+lines3d">lines3d</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of contour lines (as in <code><a href="grDevices.html#topic+contourLines">contourLines</a></code>),
invisibly.
</p>


<h3>Note</h3>

<p>You have to install the <code>rgl</code> package before you
can use this function.</p>


<h3>Note</h3>

<p>If you are superimposing the contour lines on a surface,
it helps to draw the surface with some level of transparency
(<code>alpha</code> parameter: see <code><a href="rgl.html#topic+material3d">material3d</a></code>) so
the contour lines are not obscured by the surface.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker
</p>

<hr>
<h2 id='credint'>Calculate Bayesian credible intervals</h2><span id='topic+tcredint'></span><span id='topic+ncredint'></span>

<h3>Description</h3>

<p>Calculate Bayesian credible intervals based on various types
of information about the posterior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcredint(dist, parlist, ranges, level = 0.95, eps = 1e-05,verbose=FALSE)
ncredint(pvec,npost,level=0.95,tol=0.01,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="credint_+3A_dist">dist</code></td>
<td>
<p>character string giving the name of a distribution for
which &quot;d&quot;, &quot;q&quot;, and &quot;p&quot; function exist, e.g. &quot;beta&quot;</p>
</td></tr>
<tr><td><code id="credint_+3A_parlist">parlist</code></td>
<td>
<p>list of parameters to pass to distribution functions</p>
</td></tr>
<tr><td><code id="credint_+3A_ranges">ranges</code></td>
<td>
<p>lower, middle, and upper values to bracket lower
and upper boundaries of the credible interval</p>
</td></tr>
<tr><td><code id="credint_+3A_level">level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="credint_+3A_eps">eps</code></td>
<td>
<p>if <code>ranges</code> is missing, set lower and
upper brackets to the <code>eps</code> and <code>1-eps</code> quantiles
of the distribution</p>
</td></tr>
<tr><td><code id="credint_+3A_tol">tol</code></td>
<td>
<p>tolerance on credible interval</p>
</td></tr>
<tr><td><code id="credint_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE,
return detailed information on the probability cutoff and
realized area of the credible interval; if FALSE, just lower
and upper bounds of the credible region</p>
</td></tr>
<tr><td><code id="credint_+3A_pvec">pvec</code></td>
<td>
<p>numeric vector of parameter values</p>
</td></tr>
<tr><td><code id="credint_+3A_npost">npost</code></td>
<td>
<p>numeric vector of posterior density values corresponding
to <code>pvec</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcredint</code> gives credible intervals for a theoretical
posterior density with defined density, cumulative density, and
quantile functions; <code>ncredint</code> gives credible intervals
for a numerical posterior density.
</p>


<h3>Value</h3>

<p>A numeric vector giving the credible interval.
If <code>verbose=FALSE</code>, gives just lower and upper bounds;
if <code>verbose=TRUE</code>, also gives
information on the probability cutoff and
realized area of the credible interval
</p>


<h3>Note</h3>

<p>For credible intervals from a sample (e.g. from
an MCMC run), see <code>HPDinterval</code> in the <code>coda</code>
package.</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>Examples</h3>

<pre><code class='language-R'>tcredint("beta",list(shape1=5,shape2=10),verbose=TRUE)
pvec = seq(0,1,length=100)
postvec = dbeta(pvec,shape1=5,shape2=10)
ncredint(pvec,postvec,verbose=TRUE)
set.seed(1001)
</code></pre>

<hr>
<h2 id='curve3d'>Plot a 3D surface representing a 2D curve</h2><span id='topic+curve3d'></span>

<h3>Description</h3>

<p>Two-dimensional analogue of <code>curve</code>: generates a surface
and plots it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve3d(expr, from = c(0, 0), to = c(1, 1), n = c(41, 41),
xlim, ylim, add = FALSE,
xlab=varnames[1],
ylab=varnames[2],
zlab = NULL, log = NULL, sys3d = c("persp", "wireframe", "rgl",
"contour", "image", "none"),
varnames=c("x","y"),use_plyr=TRUE,.progress="none",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve3d_+3A_expr">expr</code></td>
<td>
<p>a mathematical expression using <code>x</code> and <code>y</code> as
the independent variables</p>
</td></tr>
<tr><td><code id="curve3d_+3A_from">from</code></td>
<td>
<p>minimum values for <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="curve3d_+3A_to">to</code></td>
<td>
<p>maximum values for <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="curve3d_+3A_xlim">xlim</code></td>
<td>
<p>range of values for <code>x</code></p>
</td></tr>
<tr><td><code id="curve3d_+3A_ylim">ylim</code></td>
<td>
<p>range of values for <code>y</code></p>
</td></tr>
<tr><td><code id="curve3d_+3A_n">n</code></td>
<td>
<p>number of grid points in each direction</p>
</td></tr>
<tr><td><code id="curve3d_+3A_add">add</code></td>
<td>
<p>(logical) add to an existing plot?  (only possible for
contour plots or rgl)</p>
</td></tr>
<tr><td><code id="curve3d_+3A_xlab">xlab</code></td>
<td>
<p>x label</p>
</td></tr>
<tr><td><code id="curve3d_+3A_ylab">ylab</code></td>
<td>
<p>y label</p>
</td></tr>
<tr><td><code id="curve3d_+3A_zlab">zlab</code></td>
<td>
<p>z label</p>
</td></tr>
<tr><td><code id="curve3d_+3A_log">log</code></td>
<td>
<p>(character): <code>"x"</code>, <code>"y"</code>, or <code>"xy"</code> for
logarithmic axes</p>
</td></tr>
<tr><td><code id="curve3d_+3A_sys3d">sys3d</code></td>
<td>
<p>3D plotting system to use: one of
<code>"persp"</code>, <code>"wireframe"</code>,
<code>"rgl"</code>, <code>"contour"</code>, <code>"image"</code>,
or <code>"none"</code></p>
</td></tr>
<tr><td><code id="curve3d_+3A_varnames">varnames</code></td>
<td>
<p>names of variables to substitute</p>
</td></tr>
<tr><td><code id="curve3d_+3A_use_plyr">use_plyr</code></td>
<td>
<p>use methods from the <code>plyr</code> package?</p>
</td></tr>
<tr><td><code id="curve3d_+3A_.progress">.progress</code></td>
<td>
<p>progress bar type (<code>"none"</code>, <code>"text"</code>,
<code>"tk"</code>,<code>"win"</code>: see <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>)</p>
</td></tr>
<tr><td><code id="curve3d_+3A_...">...</code></td>
<td>
<p>additional arguments to the plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly, a list of
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x values</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y values</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z matrix</p>
</td></tr>
</table>


<h3>Note</h3>


<ul>
<li><p> You must explicitly install the <code>rgl</code> package
(via <code>install.packages("rgl")</code>) before using
<code>sys3d="persp"</code>.
</p>
</li>
<li><p> if you encounter the error &lsquo;Results must have one or
more dimensions&rsquo;, try <code>use_plyr=FALSE</code> or use <code>c()</code>
to remove attributes from the result of your expression
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+outer">outer</a></code>, <code><a href="graphics.html#topic+curve">curve</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>curve3d(cos(2*pi*x)+sin(2*pi*y/3),
 from=c(0,0),to=c(1,1))
x &lt;- 1
y &lt;- 3
curve3d(cos(2*pi*x)+sin(2*pi*y/3),
 from=c(0,0),to=c(1,1),sys3d="wireframe")
curve3d(x*cos(2*pi*a/x)+sin(2*pi*b/y),
 from=c(0,0),to=c(1,1),sys3d="wireframe",
varnames=c("a","b"))  ## identical
op &lt;- par(mfrow=c(2,2))
curve3d(cos(2*pi*x)+sin(2*pi*y/3),
 from=c(0,0),to=c(1,1),sys3d="image")
curve3d(x*cos(2*pi*a/x)+sin(2*pi*b/y),
 from=c(0,0),to=c(1,1),sys3d="image",
varnames=c("a","b"))  ## identical
x &lt;- 4
curve3d(cos(2*pi*a/x)+y*sin(2*pi*b/y),
 from=c(0,0),to=c(1,1),sys3d="image",
varnames=c("a","b"))
curve3d(cos(2*pi*x)+sin(2*pi*y/3),
 from=c(0,0),to=c(1,1),sys3d="image")
curve3d(cos(2*pi*x)+sin(2*pi*y/3),
        sys3d="contour",add=TRUE)
par(op)
</code></pre>

<hr>
<h2 id='Damselfish'>Reef fish (damselfish) data</h2><span id='topic+Damselfish'></span><span id='topic+DamselSettlement'></span><span id='topic+DamselRecruitment'></span><span id='topic+DamselRecruitment_sum'></span>

<h3>Description</h3>

<p>Two data sets on <em>Dascyllus trimaculatus</em>
(three-spot damselfish), one on the distribution of settlement densities
to empty anemones across time and space, the other on survival
(recruitment) of arriving settlers as a function of experimentally manipulated densities
from Schmitt et al. (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DamselSettlement)
data(DamselRecruitment)
data(DamselRecruitment_sum)
</code></pre>


<h3>Format</h3>

<p>Three data frames:
</p>

<dl>
<dt><code>site</code></dt><dd><p>settlement site (location)</p>
</dd>
<dt><code>pulse</code></dt><dd><p>monthly settlement pulse</p>
</dd>
<dt><code>obs</code></dt><dd><p>observation within pulse</p>
</dd>
<dt><code>density</code></dt><dd><p>density of settlers per 0.1 m2 anemone</p>
</dd>
<dt><code>area</code></dt><dd><p>anemone area in cm2</p>
</dd>
<dt><code>init</code></dt><dd><p>initial settler density</p>
</dd>
<dt><code>surv</code></dt><dd><p>surviving density after 6 months</p>
</dd>
<dt><code>settler.den</code></dt><dd><p>target experimental density of settlers on
experimental anemones</p>
</dd>
<dt><code>surv.den</code></dt><dd><p>mean surviving density after 6 months, by target density</p>
</dd>
<dt><code>SE</code></dt><dd><p>standard error of survivor density, by target density</p>
</dd>
</dl>



<h3>Source</h3>

<p>Schmitt et al. (1999), &quot;Quantifying the effects of multiple processes
on local abundance&quot;, Ecology Letters 2:294-303. DOI: 10.1046/j.1461-0248.1999.00086.x (Original data kindly provided
by Schmitt and Holbrook.)
The original version of this data set is available
from the <a href="http://mcr.lternet.edu/cgi-bin/showDataset.cgi?docid=knb-lter-mcr.2">Moorea Coral Reef LTER data repository</a>.
</p>

<hr>
<h2 id='dbetabinom'>Beta-binomial distribution</h2><span id='topic+BetaBinomial'></span><span id='topic+dbetabinom'></span><span id='topic+rbetabinom'></span>

<h3>Description</h3>

<p>Density function and random variate generator 
for the beta-binomial function, parameterized in
terms of probability and overdispersion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbetabinom(x, prob, size,  theta, shape1, shape2, log = FALSE)
rbetabinom(n, prob, size, theta, shape1, shape2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbetabinom_+3A_x">x</code></td>
<td>
<p>a numeric vector of integer values</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_prob">prob</code></td>
<td>
<p>numeric vector: mean probability of underlying beta distribution</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_size">size</code></td>
<td>
<p>integer: number of samples</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_theta">theta</code></td>
<td>
<p>overdispersion parameter</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_shape1">shape1</code></td>
<td>
<p>shape parameter of per-trial probability distribution</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter of per-trial probability distribution</p>
</td></tr>
<tr><td><code id="dbetabinom_+3A_log">log</code></td>
<td>
<p>(logical) return log probability density?</p>
</td></tr> 
<tr><td><code id="dbetabinom_+3A_n">n</code></td>
<td>
<p>integer number of random variates to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta-binomial distribution is the result of
compounding a beta distribution of probabilities with
a binomial sampling process.  The density function is
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \frac{C(N,x) \mbox{Beta}(x+\theta p,N-x+\theta(1-p))}%
{\mbox{Beta}(\theta p,\theta(1-p))}%
</code>
</p>

<p>The parameters <code>shape1</code> and <code>shape2</code> are
the more traditional parameterization in terms of
the parameters of the per-trial probability distribution.
</p>


<h3>Value</h3>

<p>A vector of probability densities or random deviates.
If <code>x</code> is non-integer, the result is zero (and
a warning is given).
</p>


<h3>Note</h3>

<p>Although the quantile (qbetabinom)
and cumulative distribution (pbetabinom)
functions are not available, in a pinch they
could be computed from the <code>pghyper</code> and
<code>qghyper</code> functions in the <code>SuppDists</code>
package &ndash; provided that <code>shape2&gt;1</code>.  As
described in <code>?pghyper</code>, <code>pghyper(q,a=-shape1,
    N=-shape1-shape2,k=size)</code> should give the
cumulative distribution for the beta-binomial
distribution with parameters (shape1,shape2,size),
and similarly for <code>qghyper</code>.
(Translation to the (theta,size,prob) parameterization
is left as an exercise.)</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>References</h3>

<p>Morris (1997), American Naturalist 150:299-327;
<a href="https://en.wikipedia.org/wiki/Beta-binomial_distribution">https://en.wikipedia.org/wiki/Beta-binomial_distribution</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbeta">dbeta</a></code>, <code><a href="stats.html#topic+dbinom">dbinom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(100)
  n &lt;- 9
  z &lt;- rbetabinom(1000, 0.5, size=n, theta=4)
  par(las=1,bty="l")
  plot(table(z)/length(z),ylim=c(0,0.34),col="gray",lwd=4,
       ylab="probability")
  points(0:n,dbinom(0:n,size=n,prob=0.5),col=2,pch=16,type="b")
  points(0:n,dbetabinom(0:n,size=n,theta=4,
           prob=0.5),col=4,pch=17,type="b")
  ## correspondence with SuppDists 
  if (require(SuppDists)) {
    d1a &lt;- dghyper(0:5,a=-5,N=-10,k=5)
    d1b &lt;- dbetabinom(0:5,shape1=5,shape2=5,size=5)
    max(abs(d1a-d1b))
    p1a &lt;- pghyper(0:5,a=-5,N=-10,k=5,lower.tail=TRUE)
    p1b &lt;- cumsum(d1b)
    max(abs(p1a-p1b))
  } 
</code></pre>

<hr>
<h2 id='dchibarsq'>Mixed chi-squared distributions</h2><span id='topic+dchibarsq'></span><span id='topic+pchibarsq'></span><span id='topic+qchibarsq'></span><span id='topic+rchibarsq'></span>

<h3>Description</h3>

<p>Calculates &quot;mixed&quot; chi-squared distributions
(mixtures of chi-square(n) and chi-square(n-1));
useful for Likelihood Ratio Tests when
parameters are on the boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dchibarsq(x, df = 1, mix = 0.5, log = FALSE)
pchibarsq(p, df = 1, mix = 0.5, lower.tail=TRUE, log.p = FALSE)
qchibarsq(q, df = 1, mix = 0.5)
rchibarsq(n, df = 1, mix = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dchibarsq_+3A_x">x</code></td>
<td>
<p>numeric vector of positive values</p>
</td></tr>
<tr><td><code id="dchibarsq_+3A_p">p</code></td>
<td>
<p>numeric vector of positive values</p>
</td></tr>
<tr><td><code id="dchibarsq_+3A_q">q</code></td>
<td>
<p>numeric vector of quantiles (0-1)</p>
</td></tr>
<tr><td><code id="dchibarsq_+3A_n">n</code></td>
<td>
<p>integer: number of random deviates to pick</p>
</td></tr>
<tr><td><code id="dchibarsq_+3A_df">df</code></td>
<td>
<p>degrees of freedom (positive integer)</p>
</td></tr>
<tr><td><code id="dchibarsq_+3A_mix">mix</code></td>
<td>
<p>mixture parameter: fraction of distribution
that is chi-square(n-1) distributed</p>
</td></tr>
<tr><td><code id="dchibarsq_+3A_log">log</code></td>
<td>
<p>return log densities?</p>
</td></tr>
<tr><td><code id="dchibarsq_+3A_log.p">log.p</code></td>
<td>
<p>return log probabilities?</p>
</td></tr>
<tr><td><code id="dchibarsq_+3A_lower.tail">lower.tail</code></td>
<td>
<p>return lower tail values?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vectors of probability densities (<code>dchibarsq</code>),
cumulative probabilities (<code>pchibarsq</code>),
quantiles (<code>qchibarsq</code>), or
random deviates (<code>rchibarsq</code>) from
Goldman and Whelan's &quot;chi-bar-squared&quot; distribution.
<code>qchibarsq</code> uses simple algebra for df=1
and <code><a href="stats.html#topic+uniroot">uniroot</a></code> for df&gt;1.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>References</h3>

<p>N. Goldman and S. Whelan (2000) &quot;Statistical Tests of
Gamma-Distributed Rate Heterogeneity in Models of Sequence Evolution
in Phylogenetics&quot;, Mol. Biol. Evol. 17:975-978.
D. O. Stram and J. W. Lee (1994) &quot;Variance Components Testing in the
Longitudinal Fixed Effects Model&quot;, Biometrics 50:1171-1177.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rchibarsq(100)
plot(density(x,from=0))
curve(dchibarsq(x),add=TRUE,col=2,from=0)
## Not run: 
library(lattice)
print(qqmath(~ simdist,
       distribution=qchibarsq,
       panel = function(x, ...) {
         panel.qqmathline(x, ...)
         panel.qqmath(x, ...)
            }))


## End(Not run)
## create first line of table in Goldman and Whelan 2000
round(qchibarsq(c(0.01,0.05,0.9,0.95,0.975,0.99,0.995),df=1),2)
## check second line of table
round(pchibarsq(c(3.81,5.14,6.48,8.27,9.63),df=2),3)
## create middle column
round(qchibarsq(0.95,df=1:10))
</code></pre>

<hr>
<h2 id='deltamethod'>Delta method functions</h2><span id='topic+deltamethod'></span><span id='topic+deltavar'></span>

<h3>Description</h3>

<p>Delta-method implementations for Jensen's inequality and prediction uncertainty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltamethod(fun, z, var = "x", params = NULL, max.order = 2)
deltavar(fun,meanval=NULL,vars,Sigma,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deltamethod_+3A_fun">fun</code></td>
<td>
<p>Function of one (deltamethod) or more arguments, expressed
in raw form (e.g. a*x/(b+x))</p>
</td></tr>
<tr><td><code id="deltamethod_+3A_z">z</code></td>
<td>
<p>numeric vector of values</p>
</td></tr>
<tr><td><code id="deltamethod_+3A_var">var</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code id="deltamethod_+3A_vars">vars</code></td>
<td>
<p>list of variable names: needed if <code>params</code> does not
have names, or if some of the values specified in <code>params</code>
should be treated as constant</p>
</td></tr>
<tr><td><code id="deltamethod_+3A_params">params</code></td>
<td>
<p>list or numeric vector of parameter values to substitute</p>
</td></tr>
<tr><td><code id="deltamethod_+3A_meanval">meanval</code></td>
<td>
<p>possibly named vector of mean values of parameters</p>
</td></tr>
<tr><td><code id="deltamethod_+3A_sigma">Sigma</code></td>
<td>
<p>numeric vector of variances or variance-covariance matrix</p>
</td></tr>
<tr><td><code id="deltamethod_+3A_max.order">max.order</code></td>
<td>
<p>maximum order of delta method to compute</p>
</td></tr>
<tr><td><code id="deltamethod_+3A_verbose">verbose</code></td>
<td>
<p>print details?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>deltamethod()</code> is for computing delta-method approximations of
the mean of a function of data; <code>deltavar()</code> is for estimating
variances of a function based on the mean values and
variance-covariance matrix of the parameters.  If <code>Sigma</code> is a
vector rather than a matrix, the parameters are assumed to be
independently estimated.
</p>


<h3>Value</h3>

<p>For <code>deltavar()</code>, a vector of predicted variances; for
<code>deltamethod()</code> a vector containing the observed value of the
function average, the function applied to the average, and a series of
delta-method approximations
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>References</h3>

<p>Lyons (1991), &quot;A practical guide to data analysis for
physical science students&quot;, Cambridge University Press</p>


<h3>Examples</h3>

<pre><code class='language-R'>deltamethod(a*x/(b+x),runif(50),params=list(a=1,b=1),max.order=9)
deltavar(scale*gamma(1+1/shape),meanval=c(scale=0.8,shape=12),
   Sigma=matrix(c(0.015,0.125,0.125,8.97),nrow=2))
## more complex deltavar example
xvec = seq(-4,4,length=101)
x1 = xvec
x2 = xvec
v = matrix(0.2,nrow=3,ncol=3)
diag(v) = 1
m = c(b0=1,b1=1.5,b2=1)
v3  = deltavar(1/(1+exp(-(b0+b1*x1+b2*x2))),meanval=m,Sigma=v)
plot(xvec,v3)
</code></pre>

<hr>
<h2 id='deprecated'>Deprecated (obsolete) functions</h2><span id='topic+traceplot.mcmc'></span>

<h3>Description</h3>

<p>Functions that are obsolete for one reason or another
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>

<hr>
<h2 id='dmvnorm'>Multivariate normal distribution density function</h2><span id='topic+dmvnorm'></span>

<h3>Description</h3>

<p>Calculates the probability density function of the multivariate normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvnorm(x, mu, Sigma, log = FALSE, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmvnorm_+3A_x">x</code></td>
<td>
<p>a vector or matrix of multivariate observations</p>
</td></tr>
<tr><td><code id="dmvnorm_+3A_mu">mu</code></td>
<td>
<p>a vector or matrix of mean values</p>
</td></tr>
<tr><td><code id="dmvnorm_+3A_sigma">Sigma</code></td>
<td>
<p>a square variance-covariance matrix</p>
</td></tr>
<tr><td><code id="dmvnorm_+3A_log">log</code></td>
<td>
<p>(logical) return log-likelihood?</p>
</td></tr>
<tr><td><code id="dmvnorm_+3A_tol">tol</code></td>
<td>
<p>tolerance for positive definiteness</p>
</td></tr>
</table>


<h3>Details</h3>

<p>uses naive linear algebra &ndash; could probably use QR decomposition
and/or crossprod.
</p>


<h3>Value</h3>

<p>vector of log-likelihoods
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code> (in <code>MASS</code> package),
<code>dmvnorm</code> (in <code>mvtnorm</code> package)</p>


<h3>Examples</h3>

<pre><code class='language-R'>M = matrix(c(1,0.5,0.5,0.5,1,0.5,0.5,0.5,1),nrow=3)
dmvnorm(1:3,mu=1:3,Sigma=M,log=TRUE)
dmvnorm(matrix(1:6,nrow=2),mu=1:3,Sigma=M,log=TRUE)
dmvnorm(matrix(1:6,nrow=2),mu=matrix(1:6,nrow=2),Sigma=M,log=TRUE)
</code></pre>

<hr>
<h2 id='dzinbinom'>Zero-inflated negative binomial distribution</h2><span id='topic+dzinbinom'></span><span id='topic+rzinbinom'></span>

<h3>Description</h3>

<p>Probability distribution function and random variate generation for the
zero-inflated negative binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzinbinom(x, mu, size, zprob, log=FALSE)
rzinbinom(n, mu, size, zprob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dzinbinom_+3A_x">x</code></td>
<td>
<p>vector of integer values</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_n">n</code></td>
<td>
<p>number of values to draw</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_mu">mu</code></td>
<td>
<p>mean parameter (or vector of parameters) of negative binomial</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_size">size</code></td>
<td>
<p>number of trials/overdispersion parameter (or vector of
parameters) of negative binomial</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_zprob">zprob</code></td>
<td>
<p>probability of structural zeros</p>
</td></tr>
<tr><td><code id="dzinbinom_+3A_log">log</code></td>
<td>
<p>return log probability?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-inflated negative binomial distribution is
widely used to model extra zero counts in count data
that otherwise follows a negative binomial distribution.
The probability distribution is
</p>
<p style="text-align: center;"><code class="reqn">
    p(0) =p_z + (1-p_z) NB(0,mu,k)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) =(1-p_z) NB(x,mu,k)</code>
</p>

<p>for <code class="reqn">x&gt;0</code>.
</p>


<h3>Value</h3>

<p>Probabilities of x or random deviates.
</p>


<h3>Note</h3>

<p>Only the &quot;ecological&quot; parameterization is included here
(must specify <code>mu</code>, not <code>prob</code>)</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>References</h3>

<p>Tyre et al., &quot;Improving precision and reducing bias in biological
surveys: estimating false-negative error rates&quot;, Ecological Applications
13:1790-1801 (2003)</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnbinom">dnbinom</a></code>, Simon Jackman's pscl package</p>


<h3>Examples</h3>

<pre><code class='language-R'>dzinbinom(0:9,mu=2,zprob=0.3,size=0.9)
dnbinom(0:9,mu=2,size=0.9)
rzinbinom(10,mu=2,zprob=0.3,size=0.9)
</code></pre>

<hr>
<h2 id='emdbook-package'>
Support Functions and Data for &quot;Ecological Models and Data&quot;
</h2><span id='topic+emdbook-package'></span><span id='topic+emdbook'></span>

<h3>Description</h3>

<p>Auxiliary functions and data sets for &quot;Ecological Models and Data&quot;, a book presenting maximum likelihood estimation and related topics for ecologists (ISBN 978-0-691-12522-0).
</p>


<h3>References</h3>

<p><cite>Bolker, Benjamin M. Ecological Models and Data in R. Princeton University Press, 2008</cite>
</p>

<hr>
<h2 id='Fir'>Data on fir (Abies) life history</h2><span id='topic+Fir'></span><span id='topic+FirDBHFec'></span><span id='topic+FirDBHFec_sum'></span>

<h3>Description</h3>

<p>Data on various aspects of life history (diameter at
breast height, onset of reproduction, crowding, fecundity)
from subalpine <em>Abies balsamea</em>,
from Dodd and Silvertown
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FirDBHFec)
data(FirDBHFec_sum)
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>DBH</code></dt><dd><p>diameter in m at breast height (1.4 m)</p>
</dd>
<dt><code>fecundity</code></dt><dd><p>number of cone rachises [per year?]</p>
</dd>
<dt><code>pop</code></dt><dd><p>which population (wave, nonwave) an
individual was sampled from</p>
</dd>
<dt><code>VAR1</code></dt><dd><p>location</p>
</dd>
<dt><code>WAVE_NON</code></dt><dd><p>non-wave (n) or wave (w)</p>
</dd>
<dt><code>TREE_NO</code></dt><dd><p>tree number</p>
</dd>
<dt><code>C1991</code></dt><dd><p>1991 cones</p>
</dd>
<dt><code>C1992</code></dt><dd><p>1992 cones</p>
</dd>
<dt><code>C1993</code></dt><dd><p>1993 cones</p>
</dd>
<dt><code>C1994</code></dt><dd><p>1994 cones</p>
</dd>
<dt><code>C1995</code></dt><dd><p>1995 cones</p>
</dd>
<dt><code>C1996</code></dt><dd><p>1996 cones</p>
</dd>
<dt><code>C1997</code></dt><dd><p>1997 cones</p>
</dd>
<dt><code>C1998</code></dt><dd><p>1998 cones</p>
</dd>
<dt><code>C1999</code></dt><dd><p>1999 cones</p>
</dd>  
<dt><code>NOTES_IN</code></dt><dd><p>notes</p>
</dd>
<dt><code>G1990</code></dt><dd><p>1990 growth</p>
</dd>
<dt><code>G1991</code></dt><dd><p>1991 growth</p>
</dd>
<dt><code>G1992</code></dt><dd><p>1992 growth</p>
</dd>
<dt><code>G1993</code></dt><dd><p>1993 growth</p>
</dd>
<dt><code>G1994</code></dt><dd><p>1994 growth</p>
</dd>
<dt><code>G1995</code></dt><dd><p>1995 growth</p>
</dd>
<dt><code>G1996</code></dt><dd><p>1996 growth</p>
</dd>
<dt><code>G1997</code></dt><dd><p>1997 growth</p>
</dd>
<dt><code>G1998</code></dt><dd><p>1998 growth</p>
</dd>
<dt><code>DBH</code></dt><dd><p>diameter at breast height</p>
</dd>
<dt><code>DBH_MM</code></dt><dd><p>dbh in mm</p>
</dd>
<dt><code>DBH_2</code></dt><dd><p>?</p>
</dd>
<dt><code>DBH_2MM</code></dt><dd><p>?</p>
</dd>
<dt><code>AGE</code></dt><dd><p>?</p>
</dd>
<dt><code>GOOD_OR</code></dt><dd><p>?</p>
</dd>
<dt><code>PC1998</code></dt><dd><p>?</p>
</dd>
<dt><code>AC1998</code></dt><dd><p>?</p>
</dd>
<dt><code>PC1994</code></dt><dd><p>?</p>
</dd>
<dt><code>AC1994</code></dt><dd><p>?</p>
</dd>
<dt><code>R3PC1998</code></dt><dd><p>?</p>
</dd>
<dt><code>RPC1994</code></dt><dd><p>?</p>
</dd>
<dt><code>RAC1994</code></dt><dd><p>?</p>
</dd>
<dt><code>RLOOKOUT</code></dt><dd><p>?</p>
</dd>
<dt><code>RSHREWYS</code></dt><dd><p>?</p>
</dd>
<dt><code>RWILLS</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code> <code>Fajita</code></p>
</dd>
<dt><code>C8TOT</code></dt><dd><p>?</p>
</dd>
<dt><code>G8TOT</code></dt><dd><p>?</p>
</dd>
<dt><code>RAC1994I</code></dt><dd><p>?</p>
</dd>
<dt><code>RPC1994I</code></dt><dd><p>?</p>
</dd>
<dt><code>R3PC1998.1</code></dt><dd><p>?</p>
</dd>
<dt><code>AC1998I</code></dt><dd><p>?</p>
</dd>
<dt><code>TOTCONES</code></dt><dd><p>total cones</p>
</dd>
</dl>
    


<h3>Source</h3>

<p>J. Silvertown and M. Dodd, Evolution of life history
in balsam fir (<em>Abies balsamea</em>) in subalpine
forests, Proc. Roy. Soc. Lond. B (1999) 266, 729-733.
</p>


<h3>References</h3>

<p>M. Dodd and J. Silvertown, Size-specific fecundity
and the influence of lifetime size variation upon
effective population size in <em>Abies balsamea</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FirDBHFec_sum)
attach(FirDBHFec_sum)
plot(DBH,fecundity,col=as.numeric(pop),pch=as.numeric(pop))
lms = lapply(split(FirDBHFec_sum,pop),lm,formula=fecundity~DBH)
for (i in 1:2) abline(lms[[i]],col=i)
detach(FirDBHFec_sum)
</code></pre>

<hr>
<h2 id='get.emdbook.packages'>install and update auxiliary packages</h2><span id='topic+get.emdbook.packages'></span><span id='topic+update.bmb.packages'></span>

<h3>Description</h3>

<p>convenience function for downloading and installing
all the packages needed for the book (just a list
and a wrapper around <code><a href="utils.html#topic+install.packages">install.packages</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.emdbook.packages()
</code></pre>


<h3>Value</h3>

<p>none: installs packages as a side effect
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+install.packages">install.packages</a></code></p>

<hr>
<h2 id='GobySurvival'>Goby (reef fish) survivorship data</h2><span id='topic+GobySurvival'></span>

<h3>Description</h3>

<p>Survivorship data from experimental
manipulations on gobies <em>Elacatinus evelynae</em> and
<em>E. prochilos</em> in the US Virgin Islands, 2000-2002
</p>


<h3>Format</h3>


<dl>
<dt><code>exper</code></dt><dd><p>experiment</p>
</dd>
<dt><code>year</code></dt><dd><p>year</p>
</dd>
<dt><code>site</code></dt><dd><p>site (factor: backreef, patchreef)</p>
</dd>
<dt><code>head</code></dt><dd><p>coral head (factor)</p>
</dd>
<dt><code>density</code></dt><dd><p>treatment &quot;density&quot; (number of &quot;target&quot; fish)</p>
</dd>
<dt><code>qual</code></dt><dd><p>treatment &quot;quality&quot;; background settlement rate</p>
</dd>
<dt><code>d1</code></dt><dd><p>last day observed (starting at 1)</p>
</dd>
<dt><code>d2</code></dt><dd><p>first day not observed</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data have been made available by the author for pedagogical use;
out of courtesy,
please don't redistribute (outside of the context of this
package) or use in an academic publication without requesting
permission (via the package maintainer).
</p>


<h3>Source</h3>

<p>J. Wilson, pers. comm.; &quot;Habitat quality, competition and recruitment
processes in two marine gobies&quot;, Ph.D. thesis, University of Florida
(2004);
<a href="https://ufdc.ufl.edu/UFE0004180/00001/pdf">https://ufdc.ufl.edu/UFE0004180/00001/pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## midpoint of survival times
gg &lt;- transform(GobySurvival,mid=(d1+d2)/2)
plot(table(gg$mid))
</code></pre>

<hr>
<h2 id='gridsearch2d'>Graphical grid search in 2D</h2><span id='topic+gridsearch2d'></span>

<h3>Description</h3>

<p>Given an objective function and starting ranges, computes the
values over the ranges and displays them in the graphics window.
User can then interactively zoom in to view interesting
parts of the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridsearch2d(fun, v1min, v2min, v1max, v2max,
n1 = 20, n2 = 20, logz = FALSE,
sys3d = c("both", "contour", "image"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridsearch2d_+3A_fun">fun</code></td>
<td>
<p>Objective function to be minimized: function of two arguments</p>
</td></tr>
<tr><td><code id="gridsearch2d_+3A_v1min">v1min</code></td>
<td>
<p>Minimum starting value of variable 1</p>
</td></tr>
<tr><td><code id="gridsearch2d_+3A_v2min">v2min</code></td>
<td>
<p>Minimum starting  value of variable 2</p>
</td></tr>
<tr><td><code id="gridsearch2d_+3A_v1max">v1max</code></td>
<td>
<p>Maximum starting  value of variable 1</p>
</td></tr>
<tr><td><code id="gridsearch2d_+3A_v2max">v2max</code></td>
<td>
<p>Maximum starting  value of variable 2</p>
</td></tr>
<tr><td><code id="gridsearch2d_+3A_n1">n1</code></td>
<td>
<p>Number of grid points for variable 1</p>
</td></tr>
<tr><td><code id="gridsearch2d_+3A_n2">n2</code></td>
<td>
<p>Number of grid points for variable 2</p>
</td></tr>
<tr><td><code id="gridsearch2d_+3A_logz">logz</code></td>
<td>
<p>Display image or contour on log scale?</p>
</td></tr>
<tr><td><code id="gridsearch2d_+3A_sys3d">sys3d</code></td>
<td>
<p>Display surface as an image, contour, or both?</p>
</td></tr>
<tr><td><code id="gridsearch2d_+3A_...">...</code></td>
<td>
<p>Other arguments to <code>fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>log=TRUE</code>, the value of the surface is rescaled to
<code>log10(m-min(m)+mindm)</code>, where <code>mindm</code> is the
difference between the minimum and the next-largest value
(or 1e-10 if this difference is zero).
</p>
<p>At each iteration, the user is prompted to select two
corners of the new range with the mouse; if this choice
is confirmed then the view zooms in.  When the user chooses
to quit, they are asked whether they want to choose a final
point (e.g. an estimate of the minimum) with the mouse.
</p>


<h3>Value</h3>

<p>If a final point is chosen, a list with elements <code>x</code> and
<code>y</code>,
otherwise NULL.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p><code><a href="#topic+curve3d">curve3d</a></code></p>

<hr>
<h2 id='HPDregionplot'>Plot highest posterior density region</h2><span id='topic+HPDregionplot'></span>

<h3>Description</h3>

<p>Given a sample from a posterior distribution (an <code>mcmc</code> object
from the <code>coda</code> package),
plot the bivariate region of highest marginal posterior density
for two variables, using <code>kde2d</code> from <code>MASS</code> to calculate
a bivariate density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPDregionplot(x, vars = 1:2, h, n = 50, lump = TRUE, prob = 0.95, xlab =
NULL, ylab = NULL, lims=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HPDregionplot_+3A_x">x</code></td>
<td>
<p>an <code>mcmc</code> or <code>mcmc.list</code> object</p>
</td></tr>
<tr><td><code id="HPDregionplot_+3A_vars">vars</code></td>
<td>
<p>which variables to plot: numeric or character vector</p>
</td></tr>
<tr><td><code id="HPDregionplot_+3A_h">h</code></td>
<td>
<p>bandwidth of 2D kernel smoother (previous default value was <code>c(1,1)</code>,
which worked poorly with some plots with very small scales;
if not specified, defaults to values in <code><a href="MASS.html#topic+kde2d">kde2d</a></code>)</p>
</td></tr>
<tr><td><code id="HPDregionplot_+3A_n">n</code></td>
<td>
<p>number of points at which to evaluate the density grid</p>
</td></tr>
<tr><td><code id="HPDregionplot_+3A_lump">lump</code></td>
<td>
<p>if <code>x</code> is an <code>mcmc.list</code> object, lump the
chains together for plotting?</p>
</td></tr>
<tr><td><code id="HPDregionplot_+3A_prob">prob</code></td>
<td>
<p>probability level</p>
</td></tr>
<tr><td><code id="HPDregionplot_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="HPDregionplot_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="HPDregionplot_+3A_lims">lims</code></td>
<td>
<p>limits, specified as (x.lower,x.upper,y.lower,y.upper)
(passed to <code>kde2d</code>)</p>
</td></tr>
<tr><td><code id="HPDregionplot_+3A_...">...</code></td>
<td>
<p>other arguments to <code><a href="graphics.html#topic+contour">contour</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>kde2d</code> to calculate a bivariate density, then
normalizes the plot and calculates the contour corresponding
to a contained volume of <code>prob</code> of the total volume under
the surface (a two-dimensional Bayesian credible region).
</p>


<h3>Value</h3>

<p>Draws a plot on the current device, and
invisibly returns a list of contour lines (<code><a href="grDevices.html#topic+contourLines">contourLines</a></code>).
</p>


<h3>Note</h3>

<p>Accuracy may be limited by density estimation; you may
need to tinker with <code>h</code> and <code>n</code> (see <code>kde2d</code>
in the <code>MASS</code> package).
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p><code>HPDinterval</code> in the <code>coda</code> package,
<code>ellipse</code> package</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
library(coda)
z &lt;- mvrnorm(1000,mu=c(0,0),Sigma=matrix(c(2,1,1,2),nrow=2))
z2 &lt;- mvrnorm(1000,mu=c(0,0),Sigma=matrix(c(2,1,1,2),nrow=2))
HPDregionplot(mcmc(z))
HPDregionplot(mcmc.list(mcmc(z),mcmc(z2)))
</code></pre>

<hr>
<h2 id='lambertW'>Lambert W function</h2><span id='topic+lambertW'></span><span id='topic+lWasymp'></span><span id='topic+lambertW_base'></span>

<h3>Description</h3>

<p>Computes the Lambert W function, giving efficient solutions to the equation x*exp(x)==z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambertW_base(z, b = 0, maxiter = 10, eps = .Machine$double.eps, min.imag =
1e-09)
lWasymp(z,logz)
lambertW(z,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambertW_+3A_z">z</code></td>
<td>
<p>(complex) vector of values for which to compute the function</p>
</td></tr>
<tr><td><code id="lambertW_+3A_logz">logz</code></td>
<td>
<p>(complex (?)) vector of <code class="reqn">log(z)</code> values (to be
specified by name instead of <code>z</code>)</p>
</td></tr>
<tr><td><code id="lambertW_+3A_b">b</code></td>
<td>
<p>(integer) b=0 specifies the principal
branch, 0 and -1 are the ones that can take non-complex values</p>
</td></tr>
<tr><td><code id="lambertW_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum numbers of iterations for convergence</p>
</td></tr>
<tr><td><code id="lambertW_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
<tr><td><code id="lambertW_+3A_min.imag">min.imag</code></td>
<td>
<p>maximum magnitude of imaginary part to chop when
returning solutions</p>
</td></tr>
<tr><td><code id="lambertW_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>lambertW_base</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the Lambert W function of z.  This function satisfies
<code class="reqn">W(z)\exp(W(z))=z</code>, and can thus be used to express solutions
of transcendental equations involving exponentials or logarithms.
For <code class="reqn">z&gt;10^307</code>, an asymptotic formula (from
Corless et al by way of
<a href="http://mathworld.wolfram.com/LambertW-Function.html">http://mathworld.wolfram.com/LambertW-Function.html</a>)
is used: <code>lambertW</code> is a wrapper that automatically selects
the asymptotic formula where appropriate.
</p>

<ul>
<li><p>In ecology, the Lambert W can be used to solve the so-called
&quot;Rogers equation&quot; for predator functional response with depletion.
</p>
</li>
<li><p>In epidemiology, the Lambert W function solves the final-size
equation of a simple SIR epidemic model.
</p>
</li></ul>



<h3>Value</h3>

<p>Complex or real vector of solutions.
</p>


<h3>Note</h3>

<p>This implementation should return values within 2.5*eps of its
counterpart in Maple V, release 3 or later.  Please report any
discrepancies to the author or translator.
</p>
<p>The derivative of the <code>lambertW</code> function is <code>plogis(-lambertW)</code>.
</p>


<h3>Author(s)</h3>

<p>Nici Schraudolph &lt;schraudo@inf.ethz.ch&gt; (original
version (c) 1998), Ben Bolker (R translation)
</p>


<h3>References</h3>

<p>Corless, Gonnet, Hare, Jeffrey, and Knuth (1996), &quot;On the Lambert
W Function&quot;, Advances in Computational Mathematics 5(4):329-359</p>


<h3>See Also</h3>

<p><code>?Lambert</code> in the <code>gsl</code> package by Robin Hankin,
which uses Gnu Scientific Library code; also <code>?lambertW</code>
in the <code>VGAM</code> and <code>pracma</code> packages, and the <code>lambertW</code> package</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(lambertW(x),from=0,to=10)
pvec &lt;- seq(-1,1,length=40)
m &lt;- outer(pvec,pvec,function(x,y)Re(lambertW(x+y*1i)))
persp(pvec,pvec,m,
      theta=290,shade=0.5,zlab="lambertW")
num1 &lt;- uniroot(function(x) {x*exp(x)-1},lower=0,upper=1,tol=1e-9)
abs(lambertW(1)-num1$root)&lt;1e-9
###
## Rogers random predator equation:
rogers.pred &lt;- function(N0,a,h,T) {
   N0 - lambertW(a*h*N0*exp(-a*(T-h*N0)))/(a*h)
}
holling2.pred &lt;- function(N0,a,h) {
  a*N0/(1+a*h*N0)
}
curve(rogers.pred(x,a=1,h=0.2,T=1),from=0,to=60,
  ylab="Number eaten/unit time",xlab="Initial number",ylim=c(0,5),
  main="Predation: a=1, h=0.2")
curve(rogers.pred(x,a=1,h=0.2,T=5)/5,add=TRUE,lty=2,from=0)
curve(rogers.pred(x,a=1,h=0.2,T=0.2)*5,add=TRUE,lty=3,from=0)
curve(rogers.pred(x,a=1,h=0.2,T=10)/10,add=TRUE,lty=4,from=0)
curve(holling2.pred(x,a=1,h=0.2),add=TRUE,lty=1,lwd=2,from=0)
abline(h=5)
legend(30,2,
   c(paste("Rogers, T=",c(0.2,1,5,10),sep=""),
    "Holling type II"),lwd=c(rep(1,4),2),lty=c(3,1,2,4,1))
## final size of an epidemic
finalsize &lt;- function(R0) {
   1+1/R0*lambertW(-R0*exp(-R0))
}
curve(finalsize,from=1,to=10,xlab=expression(R[0]),ylab="Final size")
## comparison of asymptotic results
tmpf &lt;- function(x) {
  L0 &lt;- lambertW_base(10^x)
  L1 &lt;- lWasymp(logz=x*log(10))
  (L1-L0)/L0
}
curve(tmpf,from=1,to=307,log="y")

## derivative
## don't run (avoid numDeriv dependency)
## require(numDeriv)
##   grad(lambertW(1))
##   plogis(-lambertW(1))
</code></pre>

<hr>
<h2 id='Lily'>Glacier lily occurrence and fecundity data</h2><span id='topic+Lily'></span><span id='topic+Lily_sum'></span>

<h3>Description</h3>

<p>Data on sample quadrats of the glacier lily,
<em>Erythronium grandiflorum</em>, from Thomson et al 1996
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Lily_sum)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>x</code></dt><dd><p>location of quadrat</p>
</dd>
<dt><code>y</code></dt><dd><p>location of quadrat</p>
</dd>
<dt><code>flowers</code></dt><dd><p>number of flowers</p>
</dd>
<dt><code>seedlings</code></dt><dd><p>number of seedlings</p>
</dd>
<dt><code>vegetative</code></dt><dd><p>number of vegetative plants</p>
</dd>
<dt><code>gopher</code></dt><dd><p>index of gopher activity</p>
</dd>
<dt><code>rockiness</code></dt><dd><p>rockiness index</p>
</dd>
<dt><code>moisture</code></dt><dd><p>moisture index</p>
</dd>
<dt><code>flowcol</code></dt><dd><p>inverse quintile of flowering plants</p>
</dd>
<dt><code>seedcol</code></dt><dd><p>inverse quintile of seedlings</p>
</dd>
<dt><code>vegcol</code></dt><dd><p>inverse quintile of number of vegetative plants for image plots</p>
</dd>
<dt><code>gophcol</code></dt><dd><p>inverse quintile of gopher activity</p>
</dd>
<dt><code>rockcol</code></dt><dd><p>inverse quintile of rockiness</p>
</dd>
<dt><code>moiscol</code></dt><dd><p>inverse quintile of moisture</p>
</dd>
</dl>



<h3>Details</h3>

<p>16x16 grid of 2x2m quadrats in Washington Gulch, sampled 1992
</p>


<h3>Source</h3>

<p>Thomson et al 1996, &quot;Untangling multiple factors in spatial distributions&quot;,
Ecology 77:1698-1715.  Data from James D. Thomson, with file format
conversion help from Jennifer Schmidt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Lily_sum)
par(mfrow=c(3,2))
for (i in 9:14) {
  image(matrix(Lily_sum[,i],nrow=16),main=names(Lily_sum)[i])
}
</code></pre>

<hr>
<h2 id='lseq'>Log-spaced sequence</h2><span id='topic+lseq'></span>

<h3>Description</h3>

<p>Generates a logarithmically spaced sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lseq(from, to, length.out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lseq_+3A_from">from</code></td>
<td>
<p>starting value</p>
</td></tr>
<tr><td><code id="lseq_+3A_to">to</code></td>
<td>
<p>ending value</p>
</td></tr>
<tr><td><code id="lseq_+3A_length.out">length.out</code></td>
<td>
<p>number of intervening values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lseq()</code> is just a wrapper for
<code>exp(seq(log(from), log(to), length.out = length.out))</code>
</p>


<h3>Value</h3>

<p>logarithmically spaced sequence
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+seq">seq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lseq(10,1000,9)
</code></pre>

<hr>
<h2 id='lump.mcmc.list'>Utility functions for mcmc objects</h2><span id='topic+lump.mcmc.list'></span>

<h3>Description</h3>

<p>Creates traceplots or combine mcmc list into
mcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lump.mcmc.list(x)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lump.mcmc.list_+3A_x">x</code></td>
<td>
<p>an <code>mcmc.list</code> object</p>
</td></tr>




</table>


<h3>Value</h3>



<p>a single <code>mcmc</code> object with the chains lumped together
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p><code>coda</code> package</p>

<hr>
<h2 id='metropSB'>Metropolis-Szymura-Barton algorithm</h2><span id='topic+metropSB'></span>

<h3>Description</h3>

<p>Stochastic global optimization using the Metropolis-Szymura-Barton
algorithm. New parameters are chosen from a uniform candidate
distribution with an adaptively tuned scale, and accepted or rejected
according to a Metropolis rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metropSB(fn, start, deltap = NULL, scale = 1, rptfreq = -1, acceptscale
= 1.01, rejectscale = 0.99, nmax = 10000,
retvals = FALSE, retfreq = 100, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metropSB_+3A_fn">fn</code></td>
<td>
<p>Objective function, taking a vector of parameters as its
first argument.  The function is minimized, so it should be a
negative log-likelihood or a negative log-posterior density.</p>
</td></tr>
<tr><td><code id="metropSB_+3A_start">start</code></td>
<td>
<p>Vector of starting values</p>
</td></tr>
<tr><td><code id="metropSB_+3A_deltap">deltap</code></td>
<td>
<p>Starting jump size; half-width of uniform distribution</p>
</td></tr>
<tr><td><code id="metropSB_+3A_scale">scale</code></td>
<td>
<p>Scaling factor for acceptance</p>
</td></tr>
<tr><td><code id="metropSB_+3A_rptfreq">rptfreq</code></td>
<td>
<p>Frequency for reporting interim results (&lt;0 means no reporting)</p>
</td></tr>
<tr><td><code id="metropSB_+3A_acceptscale">acceptscale</code></td>
<td>
<p>Amount to inflate candidate distribution if last
jump was accepted</p>
</td></tr>
<tr><td><code id="metropSB_+3A_rejectscale">rejectscale</code></td>
<td>
<p>Amount to shrink candidate distribution if last
jump was rejected</p>
</td></tr>
<tr><td><code id="metropSB_+3A_nmax">nmax</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code id="metropSB_+3A_retvals">retvals</code></td>
<td>
<p>Return detailed statistics?</p>
</td></tr>
<tr><td><code id="metropSB_+3A_retfreq">retfreq</code></td>
<td>
<p>Sampling frequency for detailed statistics</p>
</td></tr>
<tr><td><code id="metropSB_+3A_verbose">verbose</code></td>
<td>
<p>Print status?</p>
</td></tr>
<tr><td><code id="metropSB_+3A_...">...</code></td>
<td>
<p>Other arguments to <code>fn</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Metropolis-Szymura-Barton algorithm: given function and starting value, try to find
parameters that minimize the function
Algorithm: at a given step,
1. pick a new set of parameters, each of which is uniformly distributed
in (p[i]-deltap[i],p[i]+deltap[i])
2. calculate function value at new parameter values
3. if f(new)&lt;f(old), accept
4. if f(new)&gt;f(old), accept with probability (exp(-scale*(f(new)-f(old)))
5. if accept, increase all deltap values by acceptscale; if reject, decrease by rejectscale
6. if better than min so far, save function and parameter values
7. if reject, restore old values
</p>


<h3>Value</h3>

<table>
<tr><td><code>minimum</code></td>
<td>
<p>minimum value achieved</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>parameters corresponding to minimum</p>
</td></tr>
<tr><td><code>funcalls</code></td>
<td>
<p>number of function evaluations</p>
</td></tr>
</table>
<p>If <code>retvals=TRUE</code>:
</p>
<table>
<tr><td><code>retvals</code></td>
<td>
<p>matrix of periodic samples including parameters,
jump scale, current value, and minimum achieved value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>  If <code>scale=1</code> the algorithm satisfies MCMC rules, provided
that the other properties of the MC (irreducibility and aperiodicity)
are satisfied.</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>References</h3>

<p>Szymura and Barton (1986) Genetic analysis of a hybrid zone
between the fire-bellied toads,Bombina bombina and B. variegata, near
Cracow in southern Poland. Evolution 40(6):1141-1159.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code>MCMCmetrop1R</code> (<code>MCMCpack</code> package)</p>

<hr>
<h2 id='Myxo'>Myxomatosis titer data</h2><span id='topic+Myxo'></span><span id='topic+MyxoTiter_sum'></span>

<h3>Description</h3>

<p>Myxomatosis viral titer in blood samples from European rabbits,
as a function of day-of-infection and virus grade,
from Dwyer et al. 1990, ultimately from Fenner et al. 1956
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MyxoTiter_sum)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>grade</code></dt><dd><p>virus grade (1, least virulent; 5, most virulent)</p>
</dd>
<dt><code>day</code></dt><dd><p>day of infection</p>
</dd>
<dt><code>titer</code></dt><dd><p>blood virus titer (in log10 rabbit infectious doses)</p>
</dd>
</dl>



<h3>Note</h3>

<p>Pulled graphically from figure in Dwyer et al.;
to be replaced (eventually) with original tabular data in Fenner et al.
</p>


<h3>Source</h3>

<p>Dwyer, Levin and Buttel, &quot;A Simulation Model of the Population
Dynamics and Evolution of Myxomatosis&quot;, Ecological Monographs
60(4):423-447 (1990).
Original source: Fenner et al. 1956
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MyxoTiter_sum)
library(lattice)
xyplot(titer~day|factor(grade),data=MyxoTiter_sum,xlim=c(0,30))
</code></pre>

<hr>
<h2 id='perturb.params'>Create a list of perturbed parameters</h2><span id='topic+perturb.params'></span>

<h3>Description</h3>

<p>Takes a baseline set of parameters and perturbs it to
create a variety of starting points for maximum likelihood
estimation or MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb.params(base, alt, which, mult = FALSE, use.base = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturb.params_+3A_base">base</code></td>
<td>
<p>a named list (or vector) of parameters</p>
</td></tr>
<tr><td><code id="perturb.params_+3A_alt">alt</code></td>
<td>
<p>a list of lists (or vectors) of alternative parameter values
or multipliers</p>
</td></tr>
<tr><td><code id="perturb.params_+3A_which">which</code></td>
<td>
<p>which parameters to perturb (currently unused)</p>
</td></tr>
<tr><td><code id="perturb.params_+3A_mult">mult</code></td>
<td>
<p>(logical) multiply baseline values rather than
replacing them?</p>
</td></tr>
<tr><td><code id="perturb.params_+3A_use.base">use.base</code></td>
<td>
<p>(logical) include baseline parameters in the list?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes the baseline parameter list and substitutes alternative values.
</p>


<h3>Value</h3>

<p>A list of named lists of parameters.
</p>


<h3>Note</h3>

<p>To be extended.</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>Examples</h3>

<pre><code class='language-R'>perturb.params(list(x=1,y=2,z=3),alt=list(x=c(2,4),z=5))
</code></pre>

<hr>
<h2 id='Reedfrog'>Data on reed frog predation experiments</h2><span id='topic+Reedfrog'></span><span id='topic+ReedfrogPred'></span><span id='topic+ReedfrogFuncresp'></span><span id='topic+ReedfrogSizepred'></span>

<h3>Description</h3>

<p>Data on lab experiments on the density- and size-dependent
predation rate of an African reed frog, <em>Hyperolius
spinigularis</em>,
from Vonesh and Bolker 2005 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ReedfrogPred)
data(ReedfrogSizepred)
data(ReedfrogFuncresp)</code></pre>


<h3>Format</h3>

<p>Various data with variables:
</p>

<dl>
<dt><code>density</code></dt><dd><p>initial tadpole density (number of tadpoles
in a 1.2 x 0.8 x 0.4 m tank) [experiment 1]</p>
</dd>
<dt><code>pred</code></dt><dd><p>factor: predators present or absent [experiment 1]</p>
</dd>
<dt><code>size</code></dt><dd><p>factor: big or small tadpoles [experiment 1]</p>
</dd>
<dt><code>surv</code></dt><dd><p>number surviving</p>
</dd>
<dt><code>propsurv</code></dt><dd><p>proportion surviving (=surv/density) [experiment 1]</p>
</dd>
<dt><code>TBL</code></dt><dd><p>tadpole body length in mm [size-predation
experiment]</p>
</dd>
<dt><code>Kill</code></dt><dd><p>number killed out of 10, in 3 days
[size-predation]</p>
</dd>
<dt><code>Initial</code></dt><dd><p>initial number/density (300 L tank)
[functional response]</p>
</dd>
<dt><code>Killed</code></dt><dd><p>number killed by 3 dragonfly larvae in 14
days [functional response]</p>
</dd>
</dl>



<h3>Source</h3>

<p>Vonesh and Bolker (2005) Compensatory larval responses shift
trade-offs associated with predator-induced hatching plasticity.
Ecology 86:1580-1591
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ReedfrogPred)
boxplot(propsurv~size*density*pred,data=ReedfrogPred)
data(ReedfrogSizepred)
data(ReedfrogFuncresp)
</code></pre>

<hr>
<h2 id='scinot'>Scientific notation as LaTeX/expression()</h2><span id='topic+scinot'></span><span id='topic+axis.scinot'></span>

<h3>Description</h3>

<p>Takes a number and returns a version formatted in LaTeX
(suitable for use with <code>Sexpr()</code> in an Sweave document)
or in <code>expression()</code> (suitable for plotting),
or plots an axis with labels in scientific notation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scinot(x, format = c("latex", "expression"), delim="$",
pref="", ...)
axis.scinot(side,at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scinot_+3A_x">x</code></td>
<td>
<p>a numeric vector (of length 1)</p>
</td></tr>
<tr><td><code id="scinot_+3A_format">format</code></td>
<td>
<p>produce LaTeX or expression() format?</p>
</td></tr>
<tr><td><code id="scinot_+3A_delim">delim</code></td>
<td>
<p>delimiter to add at beginning and end (latex only)</p>
</td></tr>
<tr><td><code id="scinot_+3A_pref">pref</code></td>
<td>
<p>text to put before expression (expression only)</p>
</td></tr>
<tr><td><code id="scinot_+3A_side">side</code></td>
<td>
<p>side on which to plot axis</p>
</td></tr>
<tr><td><code id="scinot_+3A_at">at</code></td>
<td>
<p>list of locations/labels</p>
</td></tr>
<tr><td><code id="scinot_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="base.html#topic+formatC">formatC</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector (if <code>latex</code>) or expression (if
<code>expression</code>); <code>axis.scinot</code> draws an axis on the
current plot
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+formatC">formatC</a></code>, <code><a href="base.html#topic+expression">expression</a></code>,
<code><a href="grDevices.html#topic+plotmath">plotmath</a></code>, <code><a href="graphics.html#topic+axis">axis</a></code>, <code><a href="graphics.html#topic+axTicks">axTicks</a></code>,
<code>latexSN</code> in the <code>Hmisc</code> package, <code>eaxis</code> in the <code>sfsmisc</code> package</p>


<h3>Examples</h3>

<pre><code class='language-R'>scinot(1e-5)
scinot(1e-5,digits=0)
scinot(1e-5,"expression")
scinot(1e-5,"expression",pref="p=")
set.seed(1001)
plot(1:100,rlnorm(100,0,2),log="y",axes=FALSE)
axis(side=1)
axis.scinot(side=2)  ## fix bug!
</code></pre>

<hr>
<h2 id='SeedPred'>Seed predation data set from Duncan and Duncan 2000</h2><span id='topic+SeedPred'></span><span id='topic+SeedPred_wide'></span><span id='topic+SeedPred_mass'></span>

<h3>Description</h3>

<p>Data on seed predation over time from Duncan and Duncan (2000)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SeedPred)
data(SeedPred_wide)
data(SeedPred_mass)
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>station</code></dt><dd><p>a factor specifying the station number</p>
</dd>
<dt><code>species</code></dt><dd><p>a factor with levels <code>abz</code> <code>cd</code> <code>cor</code> <code>dio</code> <code>mmu</code> <code>pol</code> <code>psd</code> <code>uva</code></p>
</dd>
<dt><code>date</code></dt><dd><p>sample date</p>
</dd>
<dt><code>seeds</code></dt><dd><p>number of seeds present</p>
</dd>
<dt><code>tcum</code></dt><dd><p>cumulative time elapsed</p>
</dd>
<dt><code>tint</code></dt><dd><p>time since last sample</p>
</dd>
<dt><code>taken</code></dt><dd><p>seeds removed since last sample</p>
</dd>
<dt><code>dist</code></dt><dd><p>distance from forest edge (m)</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>SeedPred</code> is in long format, <code>SeedPred_wide</code> is in wide
format; <code>SeedPred_wide</code> has lots of <code>NA</code> values because
stations at 10 and 25 m from the forest were sampled on different
days. <code>SeedPred_mass</code> is a numeric vector containing the
approximate seed masses for each species.
</p>


<h3>Source</h3>

<p>R. Scot Duncan and Virginia E. Duncan (2000) Forest Succession and Distance from Forest Edge in an Afro-Tropical Grassland, Biotropica 32(1):33-41. (Data from Scot Duncan.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SeedPred)
</code></pre>

<hr>
<h2 id='trcoef'>Transform coefficients</h2><span id='topic+trcoef'></span>

<h3>Description</h3>

<p>Perform standard transformations of coefficients
based on information encoded in the names or
the <code>transf</code> attribute of the vector or list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trcoef(x, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trcoef_+3A_x">x</code></td>
<td>
<p>A numeric vector of coefficients with names and/or
a <code>transf</code> attribute</p>
</td></tr>
<tr><td><code id="trcoef_+3A_inverse">inverse</code></td>
<td>
<p>(logical) Perform inverse transform?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>inverse=FALSE</code>
and coefficient names begin with &quot;logit&quot;, &quot;log&quot;, or &quot;sqrt&quot;
the function will back-transform them (using <code><a href="stats.html#topic+plogis">plogis</a></code>,
<code><a href="base.html#topic+exp">exp</a></code>, or squaring), strip the descriptor
from the names, and set the <code>transf</code> attribute.
Naturally, <code>inverse=TRUE</code> will do the opposite.
If the <code>transf</code> attribute is all empty strings
after an inverse transformation, it will be deleted.
</p>


<h3>Value</h3>

<p>A vector of transformed variables with modified names
and <code>transf</code> attributes.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(loga=1,logitb=2,sqrtc=2)
trx = trcoef(x); trx
trcoef(trx,inverse=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
