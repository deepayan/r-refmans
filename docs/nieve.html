<!DOCTYPE html><html lang="en"><head><title>Help for package nieve</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nieve}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nieve-package'><p>Miscellaneous Utilities for Extreme Value Analysis</p></a></li>
<li><a href='#Exp1'><p>Density, Distribution Function, Quantile Function and</p>
Random Generation for the One-Parameter Exponential
Distribution</a></li>
<li><a href='#GEV'><p>Density, Distribution Function, Quantile Function and</p>
Random Generation for the Generalized Extreme Value (GEV)
Distribution</a></li>
<li><a href='#GPD2'><p>Density, Distribution Function, Quantile Function and</p>
Random Generation for the Two-Parameter Generalized Pareto
Distribution (GPD)</a></li>
<li><a href='#poisGP2PP'><p>Transform Poisson-GP Parameters into Point-Process Parameters</p></a></li>
<li><a href='#PP2poisGP'><p>Transform Point-Process Parameters into Poisson-GP</p>
Parameters</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Utilities for Extreme Value Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yves Deville &lt;deville.yves@alpestat.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utility functions and objects for Extreme Value
    Analysis. These include probability functions with their exact
    derivatives w.r.t. the parameters that can be used for estimation
    and inference, even with censored observations. The
    transformations exchanging the two parameterizations of Peaks Over
    Threshold (POT) models: Poisson-GP and Point-Process are also
    provided with their derivatives.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, numDeriv, Renext, knitr, covr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yvesdeville/nieve/">https://github.com/yvesdeville/nieve/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yvesdeville/nieve/issues/">https://github.com/yvesdeville/nieve/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-05 17:32:12 UTC; yves</td>
</tr>
<tr>
<td>Author:</td>
<td>Yves Deville <a href="https://orcid.org/0000-0002-1233-488X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-05 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nieve-package'>Miscellaneous Utilities for Extreme Value Analysis</h2><span id='topic+nieve-package'></span>

<h3>Description</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> nieve</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Miscellaneous Utilities for Extreme Value Analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> 
    c(person(given = "Yves",
             family = "Deville",
             role = c("cre", "aut"),
             email = "deville.yves@alpestat.com",
	     comment = c(ORCID = "0000-0002-1233-488X")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Yves Deville &lt;deville.yves@alpestat.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Provides utility functions and objects for Extreme Value
    Analysis. These include probability functions with their exact
    derivatives w.r.t. the parameters that can be used for estimation
    and inference, even with censored observations. The
    transformations exchanging the two parameterizations of Peaks Over
    Threshold (POT) models: Poisson-GP and Point-Process are also
    provided with their derivatives.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> testthat,
numDeriv,
Renext,
knitr,
covr</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/yvesdeville/nieve/</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/yvesdeville/nieve/issues/</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Yves Deville [cre, aut] (&lt;https://orcid.org/0000-0002-1233-488X&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Exp1                    Density, Distribution Function, Quantile
                        Function and Random Generation for the
                        One-Parameter Exponential Distribution
GEV                     Density, Distribution Function, Quantile
                        Function and Random Generation for the
                        Generalized Extreme Value (GEV) Distribution
GPD2                    Density, Distribution Function, Quantile
                        Function and Random Generation for the
                        Two-Parameter Generalized Pareto Distribution
                        (GPD)
PP2poisGP               Transform Point-Process Parameters into
                        Poisson-GP Parameters
nieve-package           Miscellaneous Utilities for Extreme Value
                        Analysis
poisGP2PP               Transform Poisson-GP Parameters into
                        Point-Process Parameters
</pre>
<p>The <span class="pkg">nieve</span> package provides utility functions for Extreme
Value Analysis. It includes the probability functions for the
two-parameter Generalized Pareto Distribution (GPD) and for the
three-parameter Generalized Extreme Value (GEV)
distribution. These functions are vectorized w.r.t. the parameters
and optionally provide the exact derivatives w.r.t. the
parameters: gradient and Hessian which can be used in optimization
e.g., to maximize the log-likelihood. Since the gradient is
available for the distribution function, the exact gradient of the
log-likelihood function is available even when censored
observations are used.
</p>
<p>These functions should behave like the probability functions of
the <span class="pkg">stats</span> package: when a probability <code>p = 0.0</code> or
<code>p = 1.0</code> is given, the quantile functions should return the
lower and the upper end-point, be they finite or not. Also when
evaluated at <code>-Inf</code> and <code>Inf</code> the probability functions
should return <code>0.0</code> and <code>1.0</code>.
</p>
<p>The <span class="pkg">nieve</span> package was partly funded by the French
<em>Institut de Radioprotection et Sûreté
Nucléaire (IRSN)</em> and some of the code formerly was part of R
packages owned by the IRSN <em>Bureau d'Expertise en
Hydrogéologie et sur les Risques d'Inondation, météorologiques et
Géotechniques</em> (Behrig).
</p>

<hr>
<h2 id='Exp1'>Density, Distribution Function, Quantile Function and
Random Generation for the One-Parameter Exponential
Distribution</h2><span id='topic+Exp1'></span><span id='topic+dexp1'></span><span id='topic+pexp1'></span><span id='topic+qexp1'></span><span id='topic+rexp1'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the one-parameter Exponential Distribution
distribution with scale parameter <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexp1(x, scale = 1, log = FALSE, deriv = FALSE, hessian = FALSE)

pexp1(q, scale = 1, lower.tail = TRUE, deriv = FALSE, hessian = FALSE)

qexp1(p, scale = 1, lower.tail = TRUE, deriv = FALSE, hessian = FALSE)

rexp1(n, scale = 1, array)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Exp1_+3A_x">x</code>, <code id="Exp1_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Exp1_+3A_scale">scale</code></td>
<td>
<p>Scale parameter. Numeric vector with suitable length,
see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="Exp1_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, densities <code>p</code> are
returned as <code>log(p)</code>.</p>
</td></tr>
<tr><td><code id="Exp1_+3A_deriv">deriv</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the gradient of each
computed value w.r.t. the parameter vector is computed, and
returned as a <code>"gradient"</code> attribute of the result. This
is a numeric array with dimension <code>c(n, 1)</code> where
<code>n</code> is the length of the first argument, i.e. <code>x</code>,
<code>p</code> or <code>q</code>, depending on the function.</p>
</td></tr>
<tr><td><code id="Exp1_+3A_hessian">hessian</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the Hessian of each
computed value w.r.t. the parameter vector is computed, and
returned as a <code>"hessian"</code> attribute of the result. This
is a numeric array with dimension <code>c(n, 1, 1)</code> where
<code>n</code> is the length of the first argument, i.e. <code>x</code>,
<code>p</code> or depending on the function.</p>
</td></tr>
<tr><td><code id="Exp1_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities
are <code class="reqn">\textrm{Pr}[X \leq x]</code>, otherwise,
<code class="reqn">\textrm{Pr}[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Exp1_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="Exp1_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="Exp1_+3A_array">array</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the simulated values form a
numeric matrix with <code>n</code> columns and <code>np</code> rows where
<code>np</code> is the number of exponential parameter values i.e.,
the length of <code>scale</code>. This option is useful to cope with
so-called <em>non-stationary</em> models with exponential
margins. See <b>Examples</b>. The default value is
<code>length(scale) &gt; 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival and density functions are given by
</p>
<p style="text-align: center;"><code class="reqn">S(x) = \exp\{-x / \sigma\} \qquad
      f(x) = \frac{1}{\sigma} \exp\{-x / \sigma\} \qquad (x &gt; 0)</code>
</p>

<p>where <code class="reqn">\sigma</code> is the scale parameter. This distribution is
the Generalized Pareto Distribution for a shape <code class="reqn">\xi = 0</code>.
</p>
<p>The probability functions <code>d</code>, <code>p</code> and <code>q</code>
all allow the parameter <code>scale</code> to be a vector. Then the
recycling rule is used to get two vectors of the same length,
corresponding to the first argument and to the scale
parameter. This behaviour is the standard one for the
probability functions of the <strong>stats</strong> package but is
unusual in R packages devoted to Extreme Value in which the
parameters must generally have length one. Note that the
provided functions can be used e.g. to evaluate the quantile
with a given probability for a large number of values of the
parameter vector <code>shape</code>. This is frequently required in
he Bayesian framework with MCMC inference.
</p>


<h3>Value</h3>

<p>A numeric vector with its length equal to the maximum of
the two lengths: that of the first argument and that of the
parameter <code>scale</code>. When <code>deriv</code> is <code>TRUE</code>, the
returned value has an attribute named <code>"gradient"</code> which
is a matrix with <code class="reqn">n</code> lines and <code class="reqn">1</code> column containing
the derivative. A row contains the partial derivative of the
corresponding element w.r.t. the parameter <code>"scale"</code>.
</p>


<h3>Note</h3>

<p>The attributes <code>"gradient"</code> and <code>"hessian"</code> have
dimension <code>c(n, 1)</code> and <code>c(n, 1, 1)</code>, even when
<code>n</code> equals <code>1</code>. Use the <code>drop</code> method on these
objects to drop the extra dimension if wanted i.e. to get a
gradient vector and a Hessian matrix.
</p>


<h3>See Also</h3>

<p>The exponential distribution
<code><a href="stats.html#topic+Exponential">Exponential</a></code> with <code class="reqn">rate</code> being the
inverse scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Illustrate the effect of recycling rule.
pexp1(1.0, scale = 1:4, lower.tail = FALSE) - exp(-1.0 / (1:4))
pexp1(1:4, scale = 1:4, lower.tail = FALSE) - exp(-1.0)

## With gradient and Hessian.
pexp1(c(1.1, 1.7), scale = 1, deriv = TRUE, hessian = TRUE)

ti &lt;- 1:60; names(ti) &lt;- 2000 + ti
sigma &lt;- 1.0 + 0.7 * ti
## simulate 40 paths
y &lt;- rexp1(n = 40, scale = sigma)
matplot(ti, y, type = "l", col = "gray", main = "varying scale")
lines(ti, apply(y, 1, mean))

</code></pre>

<hr>
<h2 id='GEV'>Density, Distribution Function, Quantile Function and
Random Generation for the Generalized Extreme Value (GEV)
Distribution</h2><span id='topic+GEV'></span><span id='topic+dGEV'></span><span id='topic+pGEV'></span><span id='topic+qGEV'></span><span id='topic+rGEV'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and
random generation for the Generalized Extreme Value (GEV)
distribution with parameters <code>loc</code>, <code>scale</code> and
<code>shape</code>.
The distribution function <code class="reqn">F(x) = \textrm{Pr}[X \leq x]</code>
is given by 
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp\left\{-[1 + \xi z]^{-1/\xi}\right\}</code>
</p>

<p>when <code class="reqn">\xi \neq 0</code> and <code class="reqn">1 + \xi z &gt; 0</code>, and by 
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp\left\{-e^{-z}\right\}</code>
</p>

<p>for <code class="reqn">\xi =0</code> where <code class="reqn">z := (x - \mu) / \sigma</code> in both cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dGEV(
  x,
  loc = 0,
  scale = 1,
  shape = 0,
  log = FALSE,
  deriv = FALSE,
  hessian = FALSE
)

pGEV(q, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, deriv = FALSE)

qGEV(
  p,
  loc = 0,
  scale = 1,
  shape = 0,
  lower.tail = TRUE,
  deriv = FALSE,
  hessian = FALSE
)

rGEV(n, loc = 0, scale = 1, shape = 0, array)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GEV_+3A_x">x</code>, <code id="GEV_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="GEV_+3A_loc">loc</code></td>
<td>
<p>Location parameter. Numeric vector with suitable
length, see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_scale">scale</code></td>
<td>
<p>Scale parameter. Numeric vector with suitable length,
see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_shape">shape</code></td>
<td>
<p>Shape parameter. Numeric vector with suitable length,
see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, densities <code>p</code> are
returned as <code>log(p)</code>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_deriv">deriv</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the gradient of each
computed value w.r.t. the parameter vector is computed, and
returned as a <code>"gradient"</code> attribute of the result. This
is a numeric array with dimension <code>c(n, 3)</code> where
<code>n</code> is the length of the first argument, i.e. <code>x</code>,
<code>p</code> or <code>q</code> depending on the function.</p>
</td></tr>
<tr><td><code id="GEV_+3A_hessian">hessian</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the Hessian of each
computed value w.r.t. the parameter vector is computed, and
returned as a <code>"hessian"</code> attribute of the result. This
is a numeric array with dimension <code>c(n, 3, 3)</code> where
<code>n</code> is the length of the first argument, i.e. <code>x</code>,
<code>p</code> or depending on the function.</p>
</td></tr>
<tr><td><code id="GEV_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities
are <code class="reqn">\textrm{Pr}[X \leq x]</code>, otherwise,
<code class="reqn">\textrm{Pr}[X&gt;x]</code>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="GEV_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="GEV_+3A_array">array</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the simulated values form a
numeric matrix with <code>n</code> columns and <code>np</code> rows where
<code>np</code> is the number of GEV parameter values. This number
is obtained by recycling the three GEV parameters vectors to a
common length, so <code>np</code> is the maximum of the lengths of
the parameter vectors <code>loc</code>, <code>scale</code>,
<code>shape</code>. This option is useful to cope with so-called
<em>non-stationary</em> models with GEV margins. See
<b>Examples</b>. The default value is <code>TRUE</code> if any of
the vectors <code>loc</code>, <code>scale</code> and <code>shape</code> has
length <code>&gt; 1</code> and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the probability function normally requires two
formulas: one for the non-zero shape case <code class="reqn">\xi \neq 0</code> and one for the zero-shape case <code class="reqn">\xi = 0</code>. However
the non-zero shape formulas lead to numerical instabilities
near <code class="reqn">\xi = 0</code>, especially for the derivatives
w.r.t. <code class="reqn">\xi</code>. This can create problem in optimization
tasks. To avoid this, a Taylor expansion w.r.t. <code class="reqn">\xi</code> is
used for <code class="reqn">|\xi| &lt; \epsilon</code> for a small positive
<code class="reqn">\epsilon</code>.  The expansion has order <code class="reqn">2</code> for the
functions (log-density, distribution and quantile), order
<code class="reqn">1</code> for their first-order derivatives and order <code class="reqn">0</code>
for the second-order derivatives.
</p>
<p>For the <code>d</code>, <code>p</code> and <code>q</code> functions, the GEV
parameter arguments <code>loc</code>, <code>scale</code> and <code>shape</code>
are recycled in the same fashion as the classical R
distribution functions in the <span class="pkg">stats</span> package, see e.g.,
<code><a href="stats.html#topic+Normal">Normal</a></code>, <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>, ...
Let <code>n</code> be the maximum length of the four arguments:
<code>x</code> <code>q</code> or <code>p</code> and the GEV parameter arguments,
then the four provided vectors are recycled in order to have
length <code>n</code>. The returned vector has length <code>n</code> and
the attributes <code>"gradient"</code> and <code>"hessian"</code>, when
computed, are arrays wich dimension: <code>c(1, 3)</code> and
<code>c(1, 3, 3)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector with length <code>n</code> as described in the
<b>Details</b> section. When <code>deriv</code> is <code>TRUE</code>, the
returned value has an attribute named <code>"gradient"</code> which
is a matrix with <code class="reqn">n</code> lines and <code class="reqn">3</code> columns containing
the derivatives. A row contains the partial derivatives of the
corresponding element w.r.t. the three parameters <code>loc</code>
<code>scale</code> and <code>shape</code> in that order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ti &lt;- 1:10; names(ti) &lt;- 2000 + ti
mu &lt;- 1.0 + 0.1 * ti
## simulate 40 paths
y &lt;- rGEV(n = 40, loc = mu, scale = 1, shape = 0.05)
matplot(ti, y, type = "l", col = "gray")
lines(ti, apply(y, 1, mean))
</code></pre>

<hr>
<h2 id='GPD2'>Density, Distribution Function, Quantile Function and
Random Generation for the Two-Parameter Generalized Pareto
Distribution (GPD)</h2><span id='topic+GPD2'></span><span id='topic+dGPD2'></span><span id='topic+pGPD2'></span><span id='topic+qGPD2'></span><span id='topic+rGPD2'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and
random generation for the two-parameter Generalized Pareto
Distribution (GPD) distribution with <code>scale</code> and
<code>shape</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dGPD2(x, scale = 1, shape = 0, log = FALSE, deriv = FALSE, hessian = FALSE)

pGPD2(
  q,
  scale = 1,
  shape = 0,
  lower.tail = TRUE,
  deriv = FALSE,
  hessian = FALSE
)

qGPD2(
  p,
  scale = 1,
  shape = 0,
  lower.tail = TRUE,
  deriv = FALSE,
  hessian = FALSE
)

rGPD2(n, scale = 1, shape = 0, array)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GPD2_+3A_x">x</code>, <code id="GPD2_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="GPD2_+3A_scale">scale</code></td>
<td>
<p>Scale parameter. Numeric vector with suitable length,
see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GPD2_+3A_shape">shape</code></td>
<td>
<p>Shape parameter. Numeric vector with suitable length,
see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GPD2_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, densities <code>p</code> are
returned as <code>log(p)</code>.</p>
</td></tr>
<tr><td><code id="GPD2_+3A_deriv">deriv</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the gradient of each
computed value w.r.t. the parameter vector is computed, and
returned as a <code>"gradient"</code> attribute of the result. This
is a numeric array with dimension <code>c(n, 2)</code> where
<code>n</code> is the length of the first argument, i.e. <code>x</code>,
<code>p</code> or <code>q</code>, depending on the function.</p>
</td></tr>
<tr><td><code id="GPD2_+3A_hessian">hessian</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the Hessian of each
computed value w.r.t. the parameter vector is computed, and
returned as a <code>"hessian"</code> attribute of the result. This
is a numeric array with dimension <code>c(n, 2, 2)</code> where
<code>n</code> is the length of the first argument, i.e. <code>x</code>,
<code>p</code> or depending on the function.</p>
</td></tr>
<tr><td><code id="GPD2_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities
are <code class="reqn">\textrm{Pr}[X \leq x]</code>, otherwise,
<code class="reqn">\textrm{Pr}[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="GPD2_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="GPD2_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="GPD2_+3A_array">array</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the simulated values form a
numeric matrix with <code>n</code> columns and <code>np</code> rows where
<code>np</code> is the number of GPD parameter values. This number
is obtained by recycling the two GPD parameters vectors to a
common length, so <code>np</code> is the maximum of the lengths of
the parameter vectors <code>scale</code> and <code>shape</code>. This
option is useful to cope with so-called <em>non-stationary</em>
models with GPD margins. See <b>Examples</b>. The default
value is <code>TRUE</code> if any of the vectors <code>scale</code> and
<code>shape</code> has length <code>&gt; 1</code> and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\sigma &gt;0</code> and <code class="reqn">\xi</code> denote the scale and the shape; the
survival function <code class="reqn">S(x) := \textrm{Pr}[X &gt; x]</code> is given
for <code class="reqn">x \geq 0</code> by
</p>
<p style="text-align: center;"><code class="reqn">S(x) = \left[1 + \xi x/ \sigma \right]_+^{-1/\xi}</code>
</p>
<p> for <code class="reqn">\xi \neq 0</code> where <code class="reqn">v_+ := \max\{v, \, 0\}</code> 
and by </p>
<p style="text-align: center;"><code class="reqn">S(x) = \exp\{-x/\sigma\}</code>
</p>

<p>for <code class="reqn">\xi = 0</code>. For <code class="reqn">x &lt; 0</code> we have <code class="reqn">S(x) = 1</code>:
the support of the distribution is <code class="reqn">(0,\,\infty(</code>.
</p>
<p>The probability functions <code>d</code>, <code>p</code> and <code>q</code> all
allow each of the two GP parameters to be a vector. Then the
recycling rule is used to get three vectors of the same length,
corresponding to the first argument and to the two GP
parameters. This behaviour is the standard one for the probability
functions of the <strong>stats</strong>. Note that the provided functions
can be used e.g.  to evaluate the quantile with a given
probability for a large number of values of the parameter vector
<code>c(shape, scale)</code>. This is frequently required in he Bayesian
framework with MCMC inference.
</p>


<h3>Value</h3>

<p>A numeric vector with length equal to the maximum of the
four lengths: that of the first argument and that of the two
parameters <code>scale</code> and <code>shape</code>. When <code>deriv</code> is
<code>TRUE</code>, the returned value has an attribute named
<code>"gradient"</code> which is a matrix with <code class="reqn">n</code> lines and <code class="reqn">2</code>
columns containing the derivatives. A row contains the partial
derivatives of the corresponding element w.r.t. the two parameters
<code>"scale"</code> and <code>"shape"</code> in that order.
</p>


<h3>Note</h3>

<p>The attributes <code>"gradient"</code> and <code>"hessian"</code> have
dimension <code>c(n, 2)</code> and <code>c(n, 2, 2)</code>, even when <code>n</code>
equals <code>1</code>. Use the <code>drop</code> method on these objects to
drop the extra dimension if wanted i.e. to get a gradient vector
and a Hessian matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Illustrate the effect of recycling rule.
pGPD2(1.0, scale = 1:4, shape = 0.0, lower.tail = FALSE) - exp(-1.0 / (1:4))
pGPD2(1:4, scale = 1:4, shape = 0.0, lower.tail = FALSE) - exp(-1.0)

## With gradient and Hessian.
pGPD2(c(1.1, 1.7), scale = 1, shape = 0, deriv = TRUE, hessian = TRUE)

## simulate 40 paths
ti &lt;- 1:20
names(ti) &lt;- 2000 + ti
y &lt;- rGPD2(n = 40, scale = ti, shape = 0.05)
matplot(ti, y, type = "l", col = "gray", main = "varying scale")
lines(ti, apply(y, 1, mean))

</code></pre>

<hr>
<h2 id='poisGP2PP'>Transform Poisson-GP Parameters into Point-Process Parameters</h2><span id='topic+poisGP2PP'></span>

<h3>Description</h3>

<p>Transform Poisson-GP parameters into Point-Process
(PP) parameters. In the POT Poisson-GP framework the three
parameters are the rate <code>lambda</code> <code class="reqn">\lambda_u</code>
of the Poisson process in time and the two GP parameters:
<code>scale</code> <code class="reqn">\sigma_u</code> and <code>shape</code>
<code class="reqn">\xi</code>. The vector <code>loc</code> contains the fixed
threshold <code class="reqn">u</code>, and <code>w</code> the fixed block
duration. These parameters are converted into the vector of
three parameters of the GEV distribution for the maximum of
the marks <code class="reqn">Y_i</code> on a time interval with duration
<code>w</code>, the number <code class="reqn">N</code> of these marks being a r.v. with
Poisson distribution. More precisely, the GEV distribution
applies when <code class="reqn">N &gt; 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisGP2PP(lambda, loc = 0.0, scale = 1.0, shape = 0.0, w =
    1.0, deriv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poisGP2PP_+3A_lambda">lambda</code></td>
<td>
<p>A numeric vector containing the Poisson rate(s).</p>
</td></tr>
<tr><td><code id="poisGP2PP_+3A_loc">loc</code></td>
<td>
<p>A numeric vector containing the Generalized Pareto
location, i.e. the threshold in the POT framework.</p>
</td></tr>
<tr><td><code id="poisGP2PP_+3A_scale">scale</code>, <code id="poisGP2PP_+3A_shape">shape</code></td>
<td>
<p>Numeric vectors containing the Generalized
Pareto scale and shape parameters.</p>
</td></tr>
<tr><td><code id="poisGP2PP_+3A_w">w</code></td>
<td>
<p>The block duration. Its physical dimension is time and
the product <code class="reqn">\lambda_u \times w</code> is
dimensionless.</p>
</td></tr>
<tr><td><code id="poisGP2PP_+3A_deriv">deriv</code></td>
<td>
<p>Logical. If <code>TRUE</code> the derivative (Jacobian) of
the transformation is computed and returned as an attribute
named <code>"gradient"</code> of the attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three PP parameters <code class="reqn">\mu^\star_w</code>,
<code class="reqn">\sigma^\star_w</code> and <code class="reqn">\xi^\star</code>
relate to the Poisson-GP parameters according to
</p>
<p style="text-align: center;"><code class="reqn">\left\{ \begin{array}{c c l} \mu^\star_w &amp;=&amp; u +
        \frac{(\lambda_u w)^\xi - 1}{\xi} \, \sigma_u, \\
        \sigma^\star_w &amp;=&amp; (\lambda_u w)^\xi \, \sigma_u,\\
        \xi^\star &amp;=&amp; \xi, \end{array} \right.</code>
</p>

<p>the fraction <code class="reqn">[(\lambda_u w)^\xi - 1] / \xi</code> of the first
equation being to be replaced for <code class="reqn">\xi = 0</code> by its limit
<code class="reqn">\log(\lambda_u w)</code>.
</p>


<h3>Value</h3>

<p>A numeric matrix with three columns representing the
Point-Process parameters <code>loc</code>
<code class="reqn">\mu^\star_w</code>, <code>scale</code>
<code class="reqn">\sigma^\star_w</code> and <code>shape</code>
<code class="reqn">\xi^\star</code>.
</p>


<h3>Note</h3>

<p>This function is essentially a re-implementation in C of the
function <code><a href="Renext.html#topic+Ren2gev">Ren2gev</a></code> of <b>Renext</b>. As a
major improvement, this function is &quot;vectorized&quot; w.r.t. the
parameters so it can transform efficiently a large number of
Poisson-GP parameter vectors as can be required e.g. in a MCMC
Bayesian inference. Note also that this function copes with
values near zero for the shape parameter: it suitably computes
then both the function value and its derivatives.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PP2poisGP">PP2poisGP</a></code> for the reciprocal
transformation.
</p>

<hr>
<h2 id='PP2poisGP'>Transform Point-Process Parameters into Poisson-GP
Parameters</h2><span id='topic+PP2poisGP'></span>

<h3>Description</h3>

<p>Transform Point Process (PP) parameters into
Poisson-GP parameters. The provided parameters are GEV
parameters: location <code class="reqn">\mu^\star</code>, scale
<code class="reqn">\sigma^\star_w</code> and shape
<code class="reqn">\xi^\star</code>. They are assumed to describe (the
tail of) the distribution for a maximum on a time-interval
with given duration <code class="reqn">w</code>. For a given threshold <code class="reqn">u</code>
chosen to be in the interior of the support of the GEV
distribution, there exists a unique vector of three Poisson-GP
parameters such that the maximum <code class="reqn">M</code> of the marks on an
interval with duration <code>w</code> has the prescribed GEV
tail. Remind that the three Poisson-GP parameters are the rate
of the Poisson process in time: <code class="reqn">\lambda_u</code>, and the two
GP parameters: <code>scale</code> <code class="reqn">\sigma_u</code> and <code>shape</code>
<code class="reqn">\xi</code>. The shape parameters <code class="reqn">\xi^\star</code> and
<code class="reqn">\xi</code> are identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PP2poisGP(locStar = 0.0, scaleStar = 1.0, shapeStar = 0.0,
          threshold,
          w = 1.0, deriv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PP2poisGP_+3A_locstar">locStar</code>, <code id="PP2poisGP_+3A_scalestar">scaleStar</code>, <code id="PP2poisGP_+3A_shapestar">shapeStar</code></td>
<td>
<p>Numeric vectors containing the
GEV location, scale and shape parameters.</p>
</td></tr>
<tr><td><code id="PP2poisGP_+3A_threshold">threshold</code></td>
<td>
<p>Numeric vector containing the thresholds of the
Poisson-GP model, i.e. the location of the Generalised Pareto
Distribution. <em>The threshold must be an interior point of the
support of the corresponding GEV distribution</em>.</p>
</td></tr>
<tr><td><code id="PP2poisGP_+3A_w">w</code></td>
<td>
<p>The block duration. Its physical dimension is time and
the product <code class="reqn">\lambda \times w</code> is dimensionless.</p>
</td></tr>
<tr><td><code id="PP2poisGP_+3A_deriv">deriv</code></td>
<td>
<p>Logical. If <code>TRUE</code> the derivative (Jacobian) of
the transformation is computed and returned as an attribute named
<code>"gradient"</code> of the attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Poisson-GP parameters are obtained by 
</p>
<p style="text-align: center;"><code class="reqn">\left\{
         \begin{array}{c c l}
             \sigma_u &amp;=&amp; \sigma_w^\star + \xi^\star \left[ u - \mu_w^\star \right],\\
             \lambda_u &amp;=&amp; w^{-1} \, \left[\sigma_u / \sigma_w^\star \right]^{-1/ \xi^\star},\\
             \xi &amp;=&amp; \xi^\star, 
          \end{array}\right.</code>
</p>

<p>the second equation becomes <code class="reqn">\lambda_u = w^{-1}</code> for
<code class="reqn">\xi^\star = 0</code>.
</p>


<h3>Value</h3>

<p>A matrix with three columns representing the Poisson-GP
parameters <code>lambda</code>, <code>scale</code> and <code>shape</code>.
</p>


<h3>Note</h3>

<p>This function is essentially a re-implementation in C of the
function <code><a href="Renext.html#topic+gev2Ren">gev2Ren</a></code> of <b>Renext</b>.  As a
major improvement, this function is &quot;vectorized&quot; w.r.t. the
parameters so it can transform efficiently a large number of PP
parameter vectors as it can be required e.g. in a MCMC Bayesian
inference. Note also that this function copes with values near
zero for the shape parameter: it suitably computes then both the
function value and its derivatives.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poisGP2PP">poisGP2PP</a></code> for the reciprocal
transformation.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
