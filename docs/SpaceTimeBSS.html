<!DOCTYPE html><html><head><title>Help for package SpaceTimeBSS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpaceTimeBSS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.stbss'>
<p>Coef Method for an Object of Class 'stbss'</p></a></li>
<li><a href='#lacov'>
<p>Local Autocovariance Matrices</p></a></li>
<li><a href='#meteo_veneto'>
<p>Climate and Meteorological Deseasonalized Data in Veneto</p></a></li>
<li><a href='#print.stbss'>
<p>Print Method for an Object of Class 'stbss'</p></a></li>
<li><a href='#SpaceTimeBSS-package'>
<p>Blind Source Separation for Multivariate Spatio-Temporal Data</p></a></li>
<li><a href='#stbss'>
<p>Space Time Blind Source Separation</p></a></li>
<li><a href='#stkmat'>
<p>Spatio-Temporal Kernel Matrices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Blind Source Separation for Multivariate Spatio-Temporal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simultaneous/joint diagonalization of local autocovariance matrices to estimate spatio-temporally uncorrelated random fields. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.2), JADE, Matrix, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sftime, sf, spacetime, xts, zoo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-20 13:15:46 UTC; admin</td>
</tr>
<tr>
<td>Author:</td>
<td>Christoph Muehlmann
    <a href="https://orcid.org/0000-0001-7330-8434"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Nikolaus Piccolotto
    <a href="https://orcid.org/0000-0001-6876-6502"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Claudia Cappello <a href="https://orcid.org/0000-0002-7905-5068"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sandra De Iaco <a href="https://orcid.org/0000-0003-1820-2068"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-20 16:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.stbss'>
Coef Method for an Object of Class 'stbss'
</h2><span id='topic+coef.stbss'></span>

<h3>Description</h3>

<p>Extracts the estimated unmixing matrix of an object of class <code>'stbss'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stbss'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.stbss_+3A_object">object</code></td>
<td>

<p>object of class <code>'stbss'</code>. Usually result of <code><a href="#topic+stbss">stbss</a></code>.
</p>
</td></tr>
<tr><td><code id="coef.stbss_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to or from methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the estimated unmixing matrix of an object of class <code>'stbss'</code> as a numeric matrix. For a description of the class <code>'stbss'</code> see <code><a href="#topic+stbss">stbss</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stbss">stbss</a></code>
</p>

<hr>
<h2 id='lacov'>
Local Autocovariance Matrices
</h2><span id='topic+lacov'></span>

<h3>Description</h3>

<p>Computation of local autocovariance matrices for a multivariate space-time dataset based on a given set of spatio-temporal kernel functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lacov(x, coords, time, kernel_type, kernel_parameters, 
      lags, kernel_list = NULL, center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lacov_+3A_x">x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the space-time random field and the <code>n</code> rows are the observations. 
</p>
</td></tr>
<tr><td><code id="lacov_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the spatial coordinates of the corresponding observation over a 2D spatial domain.
</p>
</td></tr>
<tr><td><code id="lacov_+3A_time">time</code></td>
<td>

<p>a numeric vector of length <code>n</code> where each entry represents the temporal coordinate of the corresponding observation.
</p>
</td></tr>
<tr><td><code id="lacov_+3A_kernel_type">kernel_type</code></td>
<td>

<p>either a string or a string vector of length <code>K</code> (or <code>1</code>) indicating which spatio-temporal kernel function to use. Implemented choices are <code>'ring'</code>, <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td></tr>
<tr><td><code id="lacov_+3A_kernel_parameters">kernel_parameters</code></td>
<td>

<p>a numeric vector of length <code>K</code> (or <code>1</code>) for the <code>'ball'</code> and <code>'gauss'</code> kernel function or a list of length <code>K</code> (or <code>1</code>) for the <code>'ring'</code> kernel, see details.
</p>
</td></tr>
<tr><td><code id="lacov_+3A_lags">lags</code></td>
<td>

<p>an integer vector of length <code>K</code> (or <code>1</code>) that provides the temporal lags for the spatio-temporal kernel functions, see details.
</p>
</td></tr>
<tr><td><code id="lacov_+3A_kernel_list">kernel_list</code></td>
<td>

<p>a list of spatio-temporal kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code><a href="#topic+stkmat">stkmat</a></code>.
</p>
</td></tr>
<tr><td><code id="lacov_+3A_center">center</code></td>
<td>

<p>logical. If <code>TRUE</code> the data <code>x</code> is centered prior computing the local covariance matrices. Default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local autocovariance matrices are defined by </p>
<p style="text-align: center;"><code class="reqn"> LACov(f) = 1/(n F_{f,n}) \sum_{i,j} f(s_i-s_j,t_i-t_j) (x(s_i,t_i)-\bar{x}) (x(s_j,t_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F^2_{f,n} = 1 / n \sum_{i,j} f^2(s_i-s_j,t_i-t_j).</code>
</p>
<p> Here, <code class="reqn">x(s_i,t_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i,t_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the space-time kernel function <code class="reqn">f</code> determines the locality. The following kernel functions are implemented and chosen with the argument <code>kernel_type</code>:
</p>

<ul>
<li> <p><code>'ring'</code>: the spatial parameters are inner radius <code class="reqn">r_i</code> and outer radius <code class="reqn">r_o</code>, with <code class="reqn">r_i &lt; r_o</code>, and <code class="reqn">r_i, r_o \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = I(r_i &lt; d_s \le r_o)I(d_t = u)</code>
</p>

</li>
<li> <p><code>'ball'</code>: the spatial parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = I(d_s \le r)I(d_t = u)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the spatial parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = exp(-0.5 (\Phi^{-1}(0.95) d_s/r)^2)I(d_t = u)</code>
</p>

</li></ul>

<p>Above, <code class="reqn">I()</code> represents the indicator function. The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>lags</code> provides the used temporal lags for the kernel functions (<code class="reqn">u</code> in the above formulas) and the argument <code>kernel_parameters</code> gives the spatial parameters for the kernel function. Each of the arguments <code>kernel_type</code>, <code>lags</code> and <code>kernel_parameters</code> can be of length <code>K</code> or <code>1</code>. Specifically, <code>kernel_type</code> can be either one kernel, then each local autocovariance matrix use the same kernel type, or of length <code>K</code> which leads to different kernel functions for the provided kernel parameters. <code>lags</code> can be either one integer, then for each kernel the same temporal lag is used, or an integer vector of length  <code>K</code> which leads to different temporal lags. In the same fashion <code>kernel_parameters</code> is a vector of length <code>K</code> or <code>1</code>. If <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then the corresponding entry of <code>kernel_parameters</code> gives the single spatial radius parameter. In contrast, if (at least one entry of) <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a list of length <code>K</code> (or <code>1</code>) where each entry is a numeric vector of length <code>2</code> defining the inner and outer spatial radius. See examples below.
</p>
<p>Alternatively, a list of kernel matrices can be given directly to the function <code>lacov</code> through the <code>kernel_list</code> argument. A list with kernel matrices can be computed with the function <code><a href="#topic+stkmat">stkmat</a></code>.
</p>


<h3>Value</h3>

<p><code>lacov</code> returns a list of length <code>K</code> where each entry is a numeric matrix of dimension <code>c(p, p)</code> corresponding to a local autocovariance matrix. 
</p>


<h3>References</h3>

<p><cite>Muehlmann, C., De Iaco, S. and Nordhausen, K. (2023), Blind Recovery of Sources for Multivariate Space-Time Environmental Data. <em>Stochastic and Environmental Research and Risk Assessment</em>,  <b>37</b>, 1593&ndash;1613, &lt;doi:10.1007/s00477-022-02348-2&gt;.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stkmat">stkmat</a></code>, <code><a href="#topic+stbss">stbss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># space and time coordinates
n_t &lt;- 50
n_sp &lt;- 10
st_coords &lt;- as.matrix(expand.grid(1:n_sp, 1:n_sp, 1:n_t))

# simulate three latent white noise fields
field_1 &lt;- rnorm(nrow(st_coords))
field_2 &lt;- rnorm(nrow(st_coords))
field_3 &lt;- rnorm(nrow(st_coords))

# compute the observed field
latent_field &lt;- cbind(field_1, field_2, field_3)
mixing_matrix &lt;- matrix(rnorm(9), 3, 3)
observed_field &lt;- latent_field 

# lacov with different ring kernels and same lags
lacov_r &lt;- lacov(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                 kernel_type = 'ring', 
                 kernel_parameters = list(c(0, 1), c(1, 2)), lags = 1)

# lacov with same ball kernels and different lags
lacov_b &lt;- lacov(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                 kernel_type = 'ball', kernel_parameters = 1, lags = c(1, 2, 3))

# lacov with different gauss kernels and different lags
lacov_g &lt;- lacov(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                 kernel_type = 'gauss', kernel_parameters = 1, lags = 1:3)

# lacov mixed kernels
lacov_m &lt;- lacov(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                 kernel_type = c('ball', 'ring', 'gauss'), 
                 kernel_parameters = list(1, c(1:2), 3), lags = 1:3)

# lacov with a kernel list
kernel_list &lt;- stkmat(coords = st_coords[, 1:2], time = st_coords[, 3], 
                      kernel_type = 'ring', 
                      kernel_parameters = list(c(0, 1)), lags = 1)
lacov_k &lt;- lacov(observed_field, kernel_list = kernel_list)
</code></pre>

<hr>
<h2 id='meteo_veneto'>
Climate and Meteorological Deseasonalized Data in Veneto
</h2><span id='topic+meteo_veneto'></span>

<h3>Description</h3>

<p>Weekly aggregated climate and meteorological deseasonalized data in Veneto region (Italy) for a 23-year span (2000-2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("meteo_veneto")</code></pre>


<h3>Format</h3>

<p>Object of class data.frame with 85248 rows and 13 variables, where 85248 consists of 1184 weekly observations times 72 spatial locations. The variables are as follows:
</p>

<dl>
<dt><code>x</code></dt><dd><p>x coordinates in meters (Gauss Boaga - EPSG:3003)</p>
</dd>
<dt><code>y</code></dt><dd><p>y coordinates in meters (Gauss Boaga - EPSG:3003)</p>
</dd>
<dt><code>sp.ID</code></dt><dd><p>code for the spatial location</p>
</dd>
<dt><code>timeIndex</code></dt><dd><p>code for the temporal observation, from 1 to 1184</p>
</dd>
<dt><code>deseas_ET0</code></dt><dd><p>evapotranspiration levels (mm)</p>
</dd>
<dt><code>deseas_rad</code></dt><dd><p>solar radiation (MJ/m^2)</p>
</dd>
<dt><code>deseas_tmax</code></dt><dd><p>maximum temperature (degrees C)</p>
</dd>
<dt><code>deseas_taver</code></dt><dd><p>average temperature (degrees C)</p>
</dd>
<dt><code>deseas_tmin</code></dt><dd><p>minimum temperature (degrees C)</p>
</dd>
<dt><code>deseas_hmax</code></dt><dd><p>maximum humidity (%)</p>
</dd>
<dt><code>deseas_hmin</code></dt><dd><p>minimum humidity (%)</p>
</dd>
<dt><code>deseas_wind</code></dt><dd><p>wind velocity (m/s)</p>
</dd>
<dt><code>deseas_log_prec</code></dt><dd><p>log of precipitation (mm)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The evapotranspiration levels were estimated by ARPA Veneto according to the Hargreaves equation. The data have been obtained by removing the annual periodicity from the raw data and then computing weekly averages.
</p>


<h3>Source</h3>

<p>The raw data can be downloaded from the Environmental Protection Agency of Veneto Region (ARPA Veneto) website.
</p>

<hr>
<h2 id='print.stbss'>
Print Method for an Object of Class 'stbss'
</h2><span id='topic+print.stbss'></span>

<h3>Description</h3>

<p>Prints the estimated unmixing matrix, the (pseudo-)eigenvalues and the diagonalized local autocovariance matrices for an object of class <code>'stbss'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stbss'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stbss_+3A_x">x</code></td>
<td>

<p>object of class <code>'stbss'</code>. Usually result of <code><a href="#topic+stbss">stbss</a></code>.
</p>
</td></tr>
<tr><td><code id="print.stbss_+3A_...">...</code></td>
<td>

<p>additional arguments for the method <code>print.listof</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stbss">stbss</a></code>
</p>

<hr>
<h2 id='SpaceTimeBSS-package'>
Blind Source Separation for Multivariate Spatio-Temporal Data
</h2><span id='topic+SpaceTimeBSS-package'></span>

<h3>Description</h3>

<p>Simultaneous/joint diagonalization of local autocovariance matrices to estimate spatio-temporally uncorrelated random fields. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SpaceTimeBSS</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3-0 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-07-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Solving the second order blind source separation problem for multivariate space-time random fields. The random fields can be irregular in space but must be regular in time. The main function of this package is:
</p>

<ul>
<li><p><code><a href="#topic+stbss">stbss</a></code> This function computes local autocovariance matrices. The considered temporal lags are integer numbers and the spatial lags are defined by spatial kernel functions. Then, these local autocovariance matrices and the sample covariance are simultaneously/jointly diagonalized.
</p>
</li></ul>

<p>The package also contains a 9-variate dataset of deseasonalized weekly climate and meteorological measurements from the Italian Veneto region between 2000 and 2022 <code><a href="#topic+meteo_veneto">meteo_veneto</a></code>.
</p>
<p>Joint diagonalization is computed with the <code><a href="JADE.html#topic+frjd">frjd</a></code> (fast real joint diagonalization) algorithm from the package <code><a href="JADE.html#topic+JADE-package">JADE</a></code>.
</p>
<p>The available finite realizations of the space time random fields can be defined by matrices or an object of classes <code><a href="spacetime.html#topic+STFDF">STFDF</a></code>, <code><a href="spacetime.html#topic+STSDF">STSDF</a></code> or <code><a href="sftime.html#topic+st_sftime">st_sftime</a></code>.
</p>


<h3>Author(s)</h3>

<p>Christoph Muehlmann, Nikolaus Piccolotto, Claudia Cappello, Sandra De Iaco, Klaus Nordhausen
</p>
<p>Maintainer: 
Klaus Nordhausen <a href="mailto:klausnordhausenR@gmail.com">klausnordhausenR@gmail.com</a>
</p>


<h3>References</h3>

<p><cite>Muehlmann, C., De Iaco, S. and Nordhausen, K. (2023), Blind Recovery of Sources for Multivariate Space-Time Environmental Data. <em>Stochastic and Environmental Research and Risk Assessment</em>,  <b>37</b>, 1593&ndash;1613, &lt;doi:10.1007/s00477-022-02348-2&gt;.</cite>
</p>

<hr>
<h2 id='stbss'>
Space Time Blind Source Separation
</h2><span id='topic+stbss'></span><span id='topic+stbss.default'></span><span id='topic+stbss.STFDF'></span><span id='topic+stbss.STSDF'></span><span id='topic+stbss.sftime'></span>

<h3>Description</h3>

<p>For a given multivariate space-time dataset, <code>stbss</code> estimates the realization of spatio-temporally uncorrelated random fields through a linear transformation which is defined by a so-called mixing matrix and a location vector. This is done assuming a spatio-temporal blind source separation model and simultaneously/jointly diagonalizing the sample covariance matrix and one/many local autocovariance matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stbss(x, ...)

## Default S3 method:
stbss(x, coords, time, kernel_type, 
      kernel_parameters, lags, ordered = TRUE, kernel_list = NULL, ...)
## S3 method for class 'STFDF'
stbss(x, ...)
## S3 method for class 'STSDF'
stbss(x, ...)
## S3 method for class 'sftime'
stbss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stbss_+3A_x">x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the space-time random field and the <code>n</code> rows are the observations, an object of class <code><a href="spacetime.html#topic+STFDF">STFDF</a></code>, an object of class <code><a href="spacetime.html#topic+STSDF">STSDF</a></code> or an object of class <code><a href="sftime.html#topic+st_sftime">st_sftime</a></code>. 
</p>
</td></tr>
<tr><td><code id="stbss_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain over a 2D spatial domain. Only needed if <code>x</code> is a matrix and the argument <code>kernel_list</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="stbss_+3A_time">time</code></td>
<td>

<p>a numeric vector of length <code>n</code> where each entry represents the time of a point in the temporal domain. Only needed if <code>x</code> is a matrix and the argument <code>kernel_list</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="stbss_+3A_kernel_type">kernel_type</code></td>
<td>

<p>either a string or a string vector of length <code>K</code> (or <code>1</code>) indicating which spatio-temporal kernel function to use. Implemented choices are <code>'ring'</code>, <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td></tr>
<tr><td><code id="stbss_+3A_kernel_parameters">kernel_parameters</code></td>
<td>

<p>a numeric vector of length <code>K</code> (or <code>1</code>) for the <code>'ball'</code> and <code>'gauss'</code> kernel function or a list of length <code>K</code> (or <code>1</code>) for the <code>'ring'</code> kernel, see details.
</p>
</td></tr>
<tr><td><code id="stbss_+3A_lags">lags</code></td>
<td>

<p>an integer vector of length <code>K</code> (or <code>1</code>) that provides the temporal lags for the spatio-temporal kernel functions, see details.
</p>
</td></tr>
<tr><td><code id="stbss_+3A_ordered">ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered by the sum of squared (pseudo-)eigenvalues of the diagonalized local covariance matrix/matrices. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="stbss_+3A_kernel_list">kernel_list</code></td>
<td>

<p>a list of spatio-temporal kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code><a href="#topic+stkmat">stkmat</a></code>.
</p>
</td></tr>
<tr><td><code id="stbss_+3A_...">...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the local covariance matrices. See details and <code><a href="JADE.html#topic+frjd">frjd</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the p-variate space-time random field <code class="reqn">x(s,t)</code> is formed by </p>
<p style="text-align: center;"><code class="reqn">x(s,t) = A z(s,t) + b,</code>
</p>
<p> where <code class="reqn">z(s,t)</code> is the latent p-variate space-time random field, <code class="reqn">A</code> and <code class="reqn">b</code> are the mixing matrix and a location vector and <code class="reqn">s</code> and <code class="reqn">t</code> are the space and time coordinates. Furthermore, it is assumed that <code class="reqn">z(s,t)</code> is white and consists of space-time uncorrelated components. The goal is to reverse the linear form by estimating an unmixing matrix and the location vector. This is done by simultaneously/jointly diagonalizing local autocovariance matrices which are defined by </p>
<p style="text-align: center;"><code class="reqn"> LACov(f) = 1/(n F_{f,n}) \sum_{i,j} f(s_i-s_j,t_i-t_j) (x(s_i,t_i)-\bar{x}) (x(s_j,t_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F^2_{f,n} = 1 / n \sum_{i,j} f^2(s_i-s_j,t_i-t_j).</code>
</p>
<p> Here, <code class="reqn">x(s_i,t_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i,t_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the space-time kernel function <code class="reqn">f</code> determines the locality. The following kernel functions are implemented and chosen with the argument <code>kernel_type</code>:
</p>

<ul>
<li> <p><code>'ring'</code>: the spatial parameters are inner radius <code class="reqn">r_i</code> and outer radius <code class="reqn">r_o</code>, with <code class="reqn">r_i &lt; r_o</code>, and <code class="reqn">r_i, r_o \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = I(r_i &lt; d_s \le r_o)I(d_t = u)</code>
</p>

</li>
<li> <p><code>'ball'</code>: the spatial parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = I(d_s \le r)I(d_t = u)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the spatial parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = exp(-0.5 (\Phi^{-1}(0.95) d_s/r)^2)I(d_t = u)</code>
</p>

</li></ul>

<p>Above, <code class="reqn">I()</code> represents the indicator function. The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>lags</code> provides the used temporal lags for the kernel functions (<code class="reqn">u</code> in the above formulas) and the argument <code>kernel_parameters</code> gives the spatial parameters for the kernel function. Each of the arguments <code>kernel_type</code>, <code>lags</code> and <code>kernel_parameters</code> can be of length <code>K</code> or <code>1</code>. Specifically, <code>kernel_type</code> can be either one kernel, then each local autocovariance matrix use the same kernel type, or of length <code>K</code> which leads to different kernel functions for the provided kernel parameters. <code>lags</code> can be either one integer, then for each kernel the same temporal lag is used, or an integer vector of length  <code>K</code> which leads to different temporal lags. In the same fashion <code>kernel_parameters</code> is a vector of length <code>K</code> or <code>1</code>. If <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then the corresponding entry of <code>kernel_parameters</code> gives the single spatial radius parameter. In contrast, if (at least one entry of) <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a list of length <code>K</code> (or <code>1</code>) where each entry is a numeric vector of length <code>2</code> defining the inner and outer spatial radius.
</p>
<p>Internally, <code>stbss</code> calls <code><a href="#topic+stkmat">stkmat</a></code> to compute a list of <code>c(n,n)</code> kernel matrices based on the parameters given, where each entry of those matrices corresponds to <code class="reqn">f(s_i-s_j,t_i-t_j)</code>. Alternatively, such a list of kernel matrices can be given directly to the function <code>stbss</code> through the <code>kernel_list</code> argument. This is useful when <code>stbss</code> is called numerous times with the same coordinates/kernel functions as the computation of the kernel matrices is then only done once prior the actual <code>stbss</code> calls. For details see also <code><a href="#topic+lacov">lacov</a></code>.
</p>
<p>If more than one local autocovariance matrix is used <code>stbss</code> jointly diagonalizes these matrices with the function <code><a href="JADE.html#topic+frjd">frjd</a></code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li></ul>



<h3>Value</h3>

<p><code>stbss</code> returns a list of class <code>'stbss'</code> with the following entries: 
</p>
<table>
<tr><td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source space-time values.
</p>
</td></tr>  
<tr><td><code>coords</code></td>
<td>

<p>coordinates of the observations. Is <code>NULL</code> if <code>class(x)</code> is not a matrix or if <code>kernel_list</code> is provided at the <code>stbss</code> call.
</p>
</td></tr>
<tr><td><code>time</code></td>
<td>

<p>time of the observations. Is <code>NULL</code> if <code>kernel_list</code> is provided or if <code>class(x)</code> is not a matrix at the <code>stbss</code> call.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>pevals</code></td>
<td>

<p>(pseudo-)eigenvalues for each latent field entry.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized local autocovariance matrices with dimension <code>c(length(kernel_parameters)*p,p)</code>.
</p>
</td></tr>
<tr><td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td></tr>
<tr><td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Muehlmann, C., De Iaco, S. and Nordhausen, K. (2023), Blind Recovery of Sources for Multivariate Space-Time Environmental Data. <em>Stochastic and Environmental Research and Risk Assessment</em>,  <b>37</b>, 1593&ndash;1613, &lt;doi:10.1007/s00477-022-02348-2&gt;.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stkmat">stkmat</a></code>, <code><a href="JADE.html#topic+frjd">frjd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># space and time coordinates
n_t &lt;- 50
n_sp &lt;- 10
st_coords &lt;- as.matrix(expand.grid(1:n_sp, 1:n_sp, 1:n_t))

# simulate three latent white noise fields
field_1 &lt;- rnorm(nrow(st_coords))
field_2 &lt;- rnorm(nrow(st_coords))
field_3 &lt;- rnorm(nrow(st_coords))
  
# compute the observed field
latent_field &lt;- cbind(field_1, field_2, field_3)
mixing_matrix &lt;- matrix(rnorm(9), 3, 3)
observed_field &lt;- latent_field 

# apply stbss with lag 1 and a ring kernel
stbss_res &lt;- stbss(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                   kernel_type = 'ring', kernel_parameters = list(c(0, 1)), lags = 1)

# print object
print(stbss_res)

# unmixing matrix
w_unmix &lt;- coef(stbss_res)

# apply the same stbss with a kernel list
kernel_list &lt;- stkmat(coords = st_coords[, 1:2], time = st_coords[, 3], 
                      kernel_type = 'ring', kernel_parameters = list(c(0, 1)), lags = 1)
stbss_res_k &lt;- stbss(observed_field, kernel_list = kernel_list)

# apply stbss with three ball kernels 
stbss_res_b &lt;- stbss(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                     kernel_type = 'ball', kernel_parameters = 1:3, lags = 1:3)


</code></pre>

<hr>
<h2 id='stkmat'>
Spatio-Temporal Kernel Matrices
</h2><span id='topic+stkmat'></span>

<h3>Description</h3>

<p>Computation of spatio-temporal kernel matrices for given kernel functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stkmat(coords, time, kernel_type, kernel_parameters, lags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stkmat_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the spatial coordinates of the corresponding observation over a 2D spatial domain.
</p>
</td></tr>
<tr><td><code id="stkmat_+3A_time">time</code></td>
<td>

<p>an integer vector of length <code>n</code> where each entry represents the temporal coordinate of the corresponding observation.
</p>
</td></tr>
<tr><td><code id="stkmat_+3A_kernel_type">kernel_type</code></td>
<td>

<p>either a string or a string vector of length <code>K</code> (or <code>1</code>) indicating which spatio-temporal kernel function to use. Implemented choices are <code>'ring'</code>, <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td></tr>
<tr><td><code id="stkmat_+3A_kernel_parameters">kernel_parameters</code></td>
<td>

<p>a numeric vector of length <code>K</code> (or <code>1</code>) for the <code>'ball'</code> and <code>'gauss'</code> kernel function or a list of length <code>K</code> (or <code>1</code>) for the <code>'ring'</code> kernel, see details.
</p>
</td></tr>
<tr><td><code id="stkmat_+3A_lags">lags</code></td>
<td>

<p>an integer vector of length <code>K</code> (or <code>1</code>) that provides the temporal lags for the spatio-temporal kernel functions, see details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following kernel functions are implemented and chosen with the argument <code>kernel_type</code>:
</p>

<ul>
<li> <p><code>'ring'</code>: the spatial parameters are inner radius <code class="reqn">r_i</code> and outer radius <code class="reqn">r_o</code>, with <code class="reqn">r_i &lt; r_o</code>, and <code class="reqn">r_i, r_o \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = I(r_i &lt; d_s \le r_o)I(d_t = u)</code>
</p>

</li>
<li> <p><code>'ball'</code>: the spatial parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = I(d_s \le r)I(d_t = u)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the spatial parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = exp(-0.5 (\Phi^{-1}(0.95) d_s/r)^2)I(d_t = u)</code>
</p>

</li></ul>

<p>Above, <code class="reqn">I()</code> represents the indicator function. The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>lags</code> provides the used temporal lags for the kernel functions (<code class="reqn">u</code> in the above formulas) and the argument <code>kernel_parameters</code> gives the spatial parameters for the kernel function. Each of the arguments <code>kernel_type</code>, <code>lags</code> and <code>kernel_parameters</code> can be of length <code>K</code> or <code>1</code>. Specifically, <code>kernel_type</code> can be either one kernel, then each local autocovariance matrix use the same kernel type, or of length <code>K</code> which leads to different kernel functions for the provided kernel parameters. <code>lags</code> can be either one integer, then for each kernel the same temporal lag is used, or an integer vector of length  <code>K</code> which leads to different temporal lags. In the same fashion <code>kernel_parameters</code> is a vector of length <code>K</code> or <code>1</code>. If <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then the corresponding entry of <code>kernel_parameters</code> gives the single spatial radius parameter. In contrast, if (at least one entry of) <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a list of length <code>K</code> (or <code>1</code>) where each entry is a numeric vector of length <code>2</code> defining the inner and outer spatial radius. See examples below.
</p>
<p>The output of this function can be used with the function <code><a href="#topic+stbss">stbss</a></code> to avoid unnecessary computation of kernel matrices when <code><a href="#topic+stbss">stbss</a></code> is called multiple times with the same coordinate/kernel function setting. Additionally, the output can be used with the function <code><a href="#topic+lacov">lacov</a></code>.
</p>


<h3>Value</h3>

<p><code>stkmat</code> returns a list of length <code>K</code> containing numeric matrices of dimension <code>c(n,n)</code> corresponding to the spatio-temporal kernel matrices.
</p>


<h3>References</h3>

<p><cite>Muehlmann, C., De Iaco, S. and Nordhausen, K. (2023), Blind Recovery of Sources for Multivariate Space-Time Environmental Data. <em>Stochastic and Environmental Research and Risk Assessment</em>,  <b>37</b>, 1593&ndash;1613, &lt;doi:10.1007/s00477-022-02348-2&gt;.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stbss">stbss</a></code>, <code><a href="#topic+lacov">lacov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# space and time coordinates
n_t &lt;- 50
n_sp &lt;- 10
coords &lt;- runif(n_sp ^ 2 * 2) * n_sp
dim(coords) &lt;- c(n_sp ^ 2, 2)
time &lt;- 1:n_t

st_coords &lt;- as.matrix(expand.grid(1:nrow(coords), 1:length(time)))
st_coords &lt;- cbind(coords[st_coords[, 1], ], time[st_coords[, 2]])

# different ring kernels and same lags
stkmat_r &lt;- stkmat(coords = st_coords[, 1:2], time = st_coords[, 3], 
                   kernel_type = 'ring', 
                   kernel_parameters = list(c(0, 1), c(1, 2)), lags = c(1, 1))

# same ball kernels and different lags
stkmat_b &lt;- stkmat(coords = st_coords[, 1:2], time = st_coords[, 3], 
                   kernel_type = 'ball', kernel_parameters = 1:3, lags = c(1, 2, 3))

# different gauss kernels and different lags
stkmat_g &lt;- stkmat(coords = st_coords[, 1:2], time = st_coords[, 3], 
                   kernel_type = 'gauss', kernel_parameters = 1:3, lags = 1:3)

# mixed kernels
stkmat_m &lt;- stkmat(coords = st_coords[, 1:2], time = st_coords[, 3], 
                   kernel_type = c('ball', 'ring', 'gauss'), 
                   kernel_parameters = list(1, c(1:2), 3), lags = 1:3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
