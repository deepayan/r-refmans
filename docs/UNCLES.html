<!DOCTYPE html><html><head><title>Help for package UNCLES</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {UNCLES}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#UNCLES-package'>
<p>Unification of Clustering Results from Multiple Datasets using External Specifications</p></a></li>
<li><a href='#binarise'><p>Binarise</p></a></li>
<li><a href='#closestToSquareFactors'><p>closestToSquareFactors</p></a></li>
<li><a href='#clustDist'><p>clustDist</p></a></li>
<li><a href='#clusterDataset'><p>Cluster Dataset</p></a></li>
<li><a href='#clustVec2partMat'><p>clustVec2partMat</p></a></li>
<li><a href='#factors'><p>factors</p></a></li>
<li><a href='#fixnans'><p>Fixnans</p></a></li>
<li><a href='#fuzzystretch'><p>fuzzystretch</p></a></li>
<li><a href='#generateCoPaM'><p>Generate CoPaM</p></a></li>
<li><a href='#HC'><p>HC</p></a></li>
<li><a href='#isempty'><p>isempty</p></a></li>
<li><a href='#isnullorempty'><p>isnullorempty</p></a></li>
<li><a href='#isValidBPM'><p>isValidBPM</p></a></li>
<li><a href='#KA'><p>KA</p></a></li>
<li><a href='#kmeansKA'><p>kmeansKA</p></a></li>
<li><a href='#mnplots'><p>M-N Plots</p></a></li>
<li><a href='#mseclusters'><p>MSE Clusters</p></a></li>
<li><a href='#normaliseMatrix'><p>Normalise Matrix</p></a></li>
<li><a href='#partMat2clustVec'><p>partMat2clustVec</p></a></li>
<li><a href='#permutations'><p>permutations</p></a></li>
<li><a href='#relabelClusts'><p>Relabel Clusters</p></a></li>
<li><a href='#SOMs'><p>SOMs</p></a></li>
<li><a href='#uncles'><p>UNCLES</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Unification of Clustering Results from Multiple Datasets using
External Specifications</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-06-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Basel Abu-Jamous</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Basel Abu-Jamous &lt;baselabujamous@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>pdist, kohonen, class</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Consensus clustering by the unification of clustering results from multiple datasets using external specifications.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-06-29 01:59:52 UTC; eepgbwa</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-06-29 10:37:45</td>
</tr>
</table>
<hr>
<h2 id='UNCLES-package'>
Unification of Clustering Results from Multiple Datasets using External Specifications
</h2><span id='topic+UNCLES-package'></span><span id='topic+UNCLES'></span>

<h3>Description</h3>

<p>UNCLES package
</p>


<h3>Author(s)</h3>

<p>Basel Abu-Jamous
</p>

<hr>
<h2 id='binarise'>Binarise</h2><span id='topic+binarise'></span>

<h3>Description</h3>

<p>Binarise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarise(U, K, technique = "DTB", parameter = 0.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binarise_+3A_u">U</code></td>
<td>

</td></tr>
<tr><td><code id="binarise_+3A_k">K</code></td>
<td>

</td></tr>
<tr><td><code id="binarise_+3A_technique">technique</code></td>
<td>

</td></tr>
<tr><td><code id="binarise_+3A_parameter">parameter</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (U, K, technique, parameter) 
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='closestToSquareFactors'>closestToSquareFactors</h2><span id='topic+closestToSquareFactors'></span>

<h3>Description</h3>

<p>Finds the two factors of (n), closest to its square root
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closestToSquareFactors(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closestToSquareFactors_+3A_n">n</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (n)
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='clustDist'>clustDist</h2><span id='topic+clustDist'></span>

<h3>Description</h3>

<p>Find the distances between clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustDist(U1, U2, X, criterion)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustDist_+3A_u1">U1</code></td>
<td>

</td></tr>
<tr><td><code id="clustDist_+3A_u2">U2</code></td>
<td>

</td></tr>
<tr><td><code id="clustDist_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="clustDist_+3A_criterion">criterion</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(U1, U2, X, criterion) {
    return(NULL)
}
</code></pre>

<hr>
<h2 id='clusterDataset'>Cluster Dataset</h2><span id='topic+clusterDataset'></span>

<h3>Description</h3>

<p>Cluster a single dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterDataset(X, K, D = 0, methods = list(kmeansKA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterDataset_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="clusterDataset_+3A_k">K</code></td>
<td>

</td></tr>
<tr><td><code id="clusterDataset_+3A_d">D</code></td>
<td>

</td></tr>
<tr><td><code id="clusterDataset_+3A_methods">methods</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X, K, D = 0, methods = c("HC-Ward", "kmeans", "SOMs")) 
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='clustVec2partMat'>clustVec2partMat</h2><span id='topic+clustVec2partMat'></span>

<h3>Description</h3>

<p>Converts a clustering result vector to a partition matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustVec2partMat(C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustVec2partMat_+3A_c">C</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(C) {
    return(NULL)
}
</code></pre>

<hr>
<h2 id='factors'>factors</h2><span id='topic+factors'></span>

<h3>Description</h3>

<p>Find the factors of a number. If (primesonly) was true, it gives prime factors only. Otherwise, it gives all factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factors(n, primeonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factors_+3A_n">n</code></td>
<td>

</td></tr>
<tr><td><code id="factors_+3A_primeonly">primeonly</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (n, primeonly = FALSE)
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='fixnans'>Fixnans</h2><span id='topic+fixnans'></span>

<h3>Description</h3>

<p>Fixing the not a number (NaN) entries in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixnans(X, type = "spline")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixnans_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="fixnans_+3A_type">type</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X, type = "spline") 
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='fuzzystretch'>fuzzystretch</h2><span id='topic+fuzzystretch'></span>

<h3>Description</h3>

<p>Stretches the fuzzy values in each row of the matrix X such the one
stays one, zeros stays zero, x0 stays x0, values between zero and x0
decreased, and values between x0 and one increased.
</p>
<p>If a vector was given for x0 then it should have elements with the same
number of rows in X. If a single value of x0 was given then it is used
for all of the rows of X.
</p>
<p>The default value of x0 is the mean of the non-zero elements of the
corresponding row, we recommend using this value because it preserve
the criterion of (sum of fuzzy values for a single row is unity) to a
good level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzystretch(X, x0 = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuzzystretch_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="fuzzystretch_+3A_x0">x0</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X, x0 = -1) 
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='generateCoPaM'>Generate CoPaM</h2><span id='topic+generateCoPaM'></span>

<h3>Description</h3>

<p>Generate a Consensus Partition Matrix (CoPaM) from partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCoPaM(U, relabel_technique, w, X, distCriterion, K, GDM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateCoPaM_+3A_u">U</code></td>
<td>

</td></tr>
<tr><td><code id="generateCoPaM_+3A_relabel_technique">relabel_technique</code></td>
<td>

</td></tr>
<tr><td><code id="generateCoPaM_+3A_w">w</code></td>
<td>

</td></tr>
<tr><td><code id="generateCoPaM_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="generateCoPaM_+3A_distcriterion">distCriterion</code></td>
<td>

</td></tr>
<tr><td><code id="generateCoPaM_+3A_k">K</code></td>
<td>

</td></tr>
<tr><td><code id="generateCoPaM_+3A_gdm">GDM</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (U, relabel_technique = "minmin", w = numeric(), X = numeric(), 
    distCriterion = "direct_euc", K = 0, GDM = numeric()) 
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='HC'>HC</h2><span id='topic+HC'></span>

<h3>Description</h3>

<p>Perform hierarchical clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HC(X, K, distancemetric = "euclidean", method = "ward.D2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HC_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="HC_+3A_k">K</code></td>
<td>

</td></tr>
<tr><td><code id="HC_+3A_distancemetric">distancemetric</code></td>
<td>

<p>Any distance method which can be used by the function &quot;dist&quot;
</p>
<p>Default: &quot;euclidean&quot;
</p>
</td></tr>
<tr><td><code id="HC_+3A_method">method</code></td>
<td>

<p>The hierarchical clustering method / algorithm. Acceptable
values are: &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA),
&quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or &quot;centroid&quot; (= UPGMC)
</p>
<p>Default: &quot;ward.D2&quot;
</p>
</td></tr>
</table>

<hr>
<h2 id='isempty'>isempty</h2><span id='topic+isempty'></span>

<h3>Description</h3>

<p>Checks if the input matrix, vector, or list X is empty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isempty(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isempty_+3A_x">X</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X)
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='isnullorempty'>isnullorempty</h2><span id='topic+isnullorempty'></span>

<h3>Description</h3>

<p>Checks if the input matrix, vector, or list X is NULL or empty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isnullorempty(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isnullorempty_+3A_x">X</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X)
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='isValidBPM'>isValidBPM</h2><span id='topic+isValidBPM'></span>

<h3>Description</h3>

<p>Checking if a matrix is a valid binary partition matrix (BPM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isValidBPM(U)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isValidBPM_+3A_u">U</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (U)
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='KA'>KA</h2><span id='topic+KA'></span>

<h3>Description</h3>

<p>Perform Kaufman's initialisation for k-means clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KA(X,K,distancemetric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KA_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="KA_+3A_k">K</code></td>
<td>

</td></tr>
<tr><td><code id="KA_+3A_distancemetric">distancemetric</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X,K,distancemetric)
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='kmeansKA'>kmeansKA</h2><span id='topic+kmeansKA'></span>

<h3>Description</h3>

<p>Perform kmeans clustering using Kaufman's (KA) initialisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeansKA(X, K, distancemetric, iter.max, nstart, algorithm, trace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeansKA_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="kmeansKA_+3A_k">K</code></td>
<td>

</td></tr>
<tr><td><code id="kmeansKA_+3A_distancemetric">distancemetric</code></td>
<td>

</td></tr>
<tr><td><code id="kmeansKA_+3A_iter.max">iter.max</code></td>
<td>

</td></tr>
<tr><td><code id="kmeansKA_+3A_nstart">nstart</code></td>
<td>

</td></tr>
<tr><td><code id="kmeansKA_+3A_algorithm">algorithm</code></td>
<td>

</td></tr>
<tr><td><code id="kmeansKA_+3A_trace">trace</code></td>
<td>

</td></tr>
</table>

<hr>
<h2 id='mnplots'>M-N Plots</h2><span id='topic+mnplots'></span>

<h3>Description</h3>

<p>Generate M-N plots and select clusters based on them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mnplots(unclesResult, MCs = 10, corner = c(0, 1),
    removedtype = 'abs', removedval = 1,
    Vmse = numeric(), mseCache = numeric(), doplot = FALSE, subplotdim = numeric(),
    subplotind = 1:MCs, minimiseDistance = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnplots_+3A_unclesresult">unclesResult</code></td>
<td>

<p>The result of the &quot;uncles&quot; function as it is, or a
similarly structred list as explained here.
</p>
<p>This argument is a list which must include two named
elements at least:
</p>
<p>- unclesResult$X: A list of the datasets as matrices
or data frames. If a single dataset is provided, it
may be provided as it is rather than as a list containing
a single matrix or data frame.
</p>
<p>- unclesResult$B: This can simply be a list of partitions, or
can be a multi-dimensional list array of partitions. Any of the
partitions, for example unclesResult$B[[i]], is a binary
partition of M rows representing M genes, and K columns
representing K clusters. The element unclesResult$B[[i]][j,k]
is the binary membership (either 1 or 0) of the (j)th gene in
the (k)th cluster as per the (i)th partition.
</p>
<p>The partitions can have different numbers of clusters (K values)
represented by their columns, but they all have to have the same
numbers of genes, represented by rows. Moreover, the gene
represented by the (j)th row in one of the partitions has to be
the same gene represented by the (j)th row in all of the other
partitions. In other words, the rows of the partitions must be
aligned.
</p>
<p>If this argument is passed as the output of the &quot;uncles&quot;
function, it will be a 4D list array of binary partitions with
the dimensions of:
</p>
<p>(T)x(NBP1)x(NBP2)x(NKs).
</p>
<p>where (T) is the number of the CoPaM final trials; (NBP1) is
the number of the different values of the parameter of the
binarisation technique if the UNCLES type is &quot;A&quot;, and is the
number of the different values of the parameter of the positive
binarisation technique if the UNCLES type is &quot;B&quot;; (NBP2) is 1
if the UNCLES type is &quot;A&quot;, and is the number of the different
values of the parameter of the negative binarisation technique
if UNCLES type is &quot;B&quot;; (NKs) is the number of the different
numbers of clusters (K values). For example: if 5 trials of the
final CoPaM were considered, UNCLES type &quot;A&quot; was used with a
DTB binarisation technique whose parameter delta ranges from
0.0 to 1.0 with steps of 0.1, and 4 different K values were
considered (e.g. K = 4, 8, 12, and 16), then the dimensions of
unclesResult$B will be (5x11x1x4).
</p>
<p>Other optional named elements of the argument unclesResult
include:
</p>
<p>- unclesResult$GDM: Gene-dataset logical matrix of M rows representing
M genes and L columns representing L datasets. A value of 1 in an
element of this matrix indicates that the corresponding gene is
found in the corresponding dataset, i.e. it is represented by some
probe(s) in that dataset.
</p>
<p>Default: All ones (all considered genes are found in all of the datasets).
</p>
<p>- unclesResult$params$type: The type of UNCLES, 'A' or 'B'. Default: 'A'.
</p>
<p>- unclesResult$params$setsP: For UNCLES type 'B', these are the datasets
considered in the positive set of datasets. See the description of the
argument &quot;setsP&quot; of the function &quot;uncles&quot;.
</p>
<p>- unclesResult$params$setsN: For UNCLES type 'B', these are the datasets
considered in the negative set of datasets. See the description of the
argument &quot;setsN&quot; of the function &quot;uncles&quot;.
</p>
<p>- unclesResult$params$wsets: For L datasets, this is a vector of L
numeric values representing the relative weights of the datasets. The
vector does not have to be normalised as it will be normalised within
the &quot;uncles&quot; function. Valid examples for 5 datasets include:
</p>
<p>wsets = c(0.2, 0.2, 0.2, 0.2, 0.2)
</p>
<p>wsets = rep(1, 5)
</p>
<p>wsets = c(4, 4, 4, 4, 4)
</p>
<p>wsets = c(1, 2, 2, 0, 1)
</p>
<p>wsets = c(0.2, 0.3, 0, 0.4, 0.4)
</p>
<p>Note that the first three examples result in the same weighting, 
which is to treat all datasets equally. If the weight of a dataset
was set to zero, this implies excluding it of the analysis.
</p>
<p>Default: numeric() # which will be read as equal weights for all
datasets.
</p>
</td></tr>
<tr><td><code id="mnplots_+3A_mcs">MCs</code></td>
<td>

<p>The number of clusters to be selected by the M-N scatter plots
technique. This is also the number of iterations, as in each
iteration one cluster is selected.
</p>
<p>Default: 10.
</p>
</td></tr>
<tr><td><code id="mnplots_+3A_corner">corner</code></td>
<td>

<p>The coordinates of point at the unity-normalised M-N plots
which is considered as the reference point from which the 
distance is measured for the points of all of the clusters.
Better clusters are those which are closer to this corner.
Its default is the top-left corner of the plot with the
coordinates of (0.0, 1.0). As the horizontal axis represents
the dispersion within the cluster and the vertical axis
represents the size of the cluster, clusters closer to that
top-left corner minimise dispersion while maximize their size.
</p>
<p>If the reference was moved a bit towards the right on the
horizontal axis (e.g. to become at (0.2, 1.0)), wider clusters
will be selected. While if it was moved towards the left (e.g.
to become at (-0.2, 1.0)), tighter clusters will be selected.
</p>
<p>Default: c(0.0, 1.0).
</p>
</td></tr>
<tr><td><code id="mnplots_+3A_removedtype">removedtype</code></td>
<td>

<p>This is either 'perc' or 'abs'. When a cluster is selected as
the best cluster (closest to the &quot;corner&quot; argument), how do we
identify the other clusters which overlap with it?
</p>
<p>Read the description of the argument &quot;removedval&quot; below for details.
</p>
<p>Default: 'abs'
</p>
</td></tr>
<tr><td><code id="mnplots_+3A_removedval">removedval</code></td>
<td>

<p>A numeric value indicating the minimum amount of overlap between the
cluster selected as the best cluster in the current iteration and
the other clusters for these other clusters to be removed before the
following iteration.
</p>
<p>If &quot;removedtype&quot; is 'perc', &quot;removedval&quot; represents the percentage
of the overlap out of the smaller cluster between the two clusters
being compared. &quot;removedval&quot; in this case should be in the range
0.0 to 1.0. For example, if &quot;removedval&quot; is 0.25, the overlap between
the two clusters has to be at least 25% of the smaller cluster of
the two to consider it a significant overlap.
</p>
<p>If &quot;removedtype&quot; is 'abs', &quot;removedval&quot; represents the minimum number
of genes in the overlap to consider it as a significant overlap.
&quot;removedval&quot; in this case should be an integer greater than zero.
</p>
<p>Default: 1. As the default of &quot;removedtype&quot; is 'abs', this means that
if a single gene was found in the overlap, the overlap is considered
significant.
</p>
</td></tr>
<tr><td><code id="mnplots_+3A_vmse">Vmse</code></td>
<td>

</td></tr>
<tr><td><code id="mnplots_+3A_msecache">mseCache</code></td>
<td>

</td></tr>
<tr><td><code id="mnplots_+3A_doplot">doplot</code></td>
<td>

<p>If TRUE, the function plots the M-N plots in addition to providing
the calculated results in the output. If FALSE, it just calculates
the results and provides them without plotting.
</p>
</td></tr>
<tr><td><code id="mnplots_+3A_subplotdim">subplotdim</code></td>
<td>

</td></tr>
<tr><td><code id="mnplots_+3A_subplotind">subplotind</code></td>
<td>

</td></tr>
<tr><td><code id="mnplots_+3A_minimisedistance">minimiseDistance</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># This is the simplist way to apply UNCLES and MN plots.
# Just pass the datasets to the "uncles" function and then pass
# the UNCLES result to the "mnplots" function.
# Both functions will use default values for all other arguments.
#
# Define three random gene expression datasets for 1000 genes.
# The number of samples in the datasets are 6, 4, and 9, respectively.
#
# X = list()
# X[[1]] = matrix(rnorm(6000), 1000, 6)
# X[[2]] = matrix(rnorm(4000), 1000, 4)
# X[[3]] = matrix(rnorm(9000), 1000, 9)
#
# unclesResult &lt;- uncles(X)
# mnResult &lt;- mnplots(unclesResult)
#
# The clusters will be available in the form of a partition matrix in the variable:
# mnResult$B;
</code></pre>

<hr>
<h2 id='mseclusters'>MSE Clusters</h2><span id='topic+mseclusters'></span>

<h3>Description</h3>

<p>Calculate the MSE values for clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mseclusters(X, B, normalise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mseclusters_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="mseclusters_+3A_b">B</code></td>
<td>

</td></tr>
<tr><td><code id="mseclusters_+3A_normalise">normalise</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
</code></pre>

<hr>
<h2 id='normaliseMatrix'>Normalise Matrix</h2><span id='topic+normaliseMatrix'></span>

<h3>Description</h3>

<p>Normalise a given matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normaliseMatrix(X, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normaliseMatrix_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="normaliseMatrix_+3A_type">type</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X, type) 
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='partMat2clustVec'>partMat2clustVec</h2><span id='topic+partMat2clustVec'></span>

<h3>Description</h3>

<p>Converts a partition matrix to a clustering result vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partMat2clustVec(U, skipValidity=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partMat2clustVec_+3A_u">U</code></td>
<td>

</td></tr>
<tr><td><code id="partMat2clustVec_+3A_skipvalidity">skipValidity</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(U, skipValidity=FALSE) {
    return(NULL)
}
</code></pre>

<hr>
<h2 id='permutations'>permutations</h2><span id='topic+permutations'></span>

<h3>Description</h3>

<p>Finds all permutations of numbers 1 to n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutations_+3A_n">n</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (n)
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='relabelClusts'>Relabel Clusters</h2><span id='topic+relabelClusts'></span>

<h3>Description</h3>

<p>Relabel clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relabelClusts(ref, input, technique = "minmin", X = numeric(),
                 distCriterion = "direct_euc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relabelClusts_+3A_ref">ref</code></td>
<td>

</td></tr>
<tr><td><code id="relabelClusts_+3A_input">input</code></td>
<td>

</td></tr>
<tr><td><code id="relabelClusts_+3A_technique">technique</code></td>
<td>

</td></tr>
<tr><td><code id="relabelClusts_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="relabelClusts_+3A_distcriterion">distCriterion</code></td>
<td>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (Ref, Input, technique = "minmin", X = numeric(), distCriterion = "direct_euc") 
{
    return(NULL)
  }
</code></pre>

<hr>
<h2 id='SOMs'>SOMs</h2><span id='topic+SOMs'></span>

<h3>Description</h3>

<p>Perform self-organising maps (SOMs) clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SOMs(X, K, topo = "hexagonal", rlen = 100, alpha = c(0.05, 0.01),
    n.hood = "circular")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SOMs_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="SOMs_+3A_k">K</code></td>
<td>

</td></tr>
<tr><td><code id="SOMs_+3A_topo">topo</code></td>
<td>

</td></tr>
<tr><td><code id="SOMs_+3A_rlen">rlen</code></td>
<td>

</td></tr>
<tr><td><code id="SOMs_+3A_alpha">alpha</code></td>
<td>

</td></tr>
<tr><td><code id="SOMs_+3A_n.hood">n.hood</code></td>
<td>

</td></tr>
</table>

<hr>
<h2 id='uncles'>UNCLES</h2><span id='topic+uncles'></span>

<h3>Description</h3>

<p>Perform UNCLES clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncles(X, type = 'A', Ks = c(4, 8, 12, 16),
methods = list(kmeansKA, list(HC, method = "ward.D2"), SOMs),
methodsDetailed = list(), inparams = list(), normalise = 0,
samplesIDs = numeric(), flipSamples = list(), U = list(),
UType = 'PM', Xn = list(), relabel_technique = "minmin",
binarisation_technique = "DTB", binarisation_param = seq(0, 1, 0.1),
setsP = numeric(), setsN = numeric(),
dofuzzystretch = FALSE, wsets = numeric(), wmethods = numeric(),
GDM = numeric(), CoPaMforDatasetTrials = 1, CoPaMfinaltrials = 1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncles_+3A_x">X</code></td>
<td>

<p>The datasets to be clustered as a list of matrices or data frames.
If a single dataset is to be provided, it can be as a matrix, a data frame, or a list of a single matrix or frame.
</p>
</td></tr>
<tr><td><code id="uncles_+3A_type">type</code></td>
<td>

<p>The type of UNCLES. Either &quot;A&quot; or &quot;B&quot;. Default: &quot;A&quot;
</p>
</td></tr>
<tr><td><code id="uncles_+3A_ks">Ks</code></td>
<td>

<p>A vector with the K values (numbers of clusters) with each of which UNCLES will be performed to the same datasets.
The result of the function will include the results of applying UNCLES to each one of them.
Default: c(4, 8, 12, 14)
</p>
</td></tr>
<tr><td><code id="uncles_+3A_methods">methods</code></td>
<td>

<p>A list of the individual clustering methods' functions to be employed by UNCLES.
Each method can be given as a single function (e.g. kmeansKA) or as a list with
the methods' function as its first element followed by named elements representing
the arguments to be passed to that clustering function. If the clustering
function returns a list of multiple elements and one of which is the actual
clustering result, add a named element to the list with the case-sensitive name
&quot;outputVariable&quot; to indicate the name of the variable or element in the list which
includes the clustering result (as a vector of cluster indices or a partition matrix).
</p>
<p>For example:
</p>
<p>method1 = kmeansKA
</p>
<p>method2 = list(kmeans, outputVariable = &quot;cluster&quot;, iter.max=100)
</p>
<p>method3 = list(HC, method = &quot;ward.D2&quot;)
</p>
<p>method4 = list(HC, method = &quot;average&quot;)
</p>
<p>method5 = list(SOMs, topo = &quot;rectangular&quot;)
</p>
<p>methods = list(method1, method2, method3, method4, method5)
</p>
<p>Default: list(kmeansKA, list(HC, method = &quot;ward.D2&quot;), SOMs)
</p>
</td></tr>
<tr><td><code id="uncles_+3A_methodsdetailed">methodsDetailed</code></td>
<td>

<p>If you wish to apply different methods to different datasets, use this argument.
For L datasets, this is a list of L lists. Each list represents the methods to
be applied to its corresponding dataset and has the format of the argument
&quot;methods&quot; above. If this argument was not provided, or of it was empty, the
methods in the argument &quot;methods&quot; will be applied to all datasets.
</p>
<p>Default: list()
</p>
</td></tr>
<tr><td><code id="uncles_+3A_inparams">inparams</code></td>
<td>

<p>As this uncles method includes in its output a variable &quot;params&quot; to store the 
parameters used in it, you may provide input parameters here which will be
passed to the output as they are after the addition of the uncles parameters.
This is useful if you wish to add your own parameters.
</p>
<p>Example:
</p>
<p>params = list()
</p>
<p>params$author = &quot;Basel Abu-Jamous&quot;
</p>
<p>params$studytitle = &quot;Analysis of gene expression&quot;
</p>
<p>result = uncles(..., inparams = params)
</p>
<p># the output &quot;result$params&quot; here will have all uncles parameters in addition
to &quot;author&quot; and &quot;studytitle&quot;.
</p>
</td></tr>
<tr><td><code id="uncles_+3A_normalise">normalise</code></td>
<td>

<p>For L datasets, this is a list of L normalisation values.
Each element is a single number or a vector of numbers representing the
normalisation techniques to be applied to the corresponding dataset in order.
For example, if three datasets were included, &quot;normalise&quot; can be:
</p>
<p>list(6, c(3, 2), 6)
</p>
<p>which applies normalisation (6) to the first and the third datasets,
and applies the normalisation techniques (3) and (2), in order, to the
second dataset.
</p>
<p>If a single value or a single vector was provided, it is applied to all datasets.
</p>
<p>Refer to the help of the &quot;normaliseMatrix&quot; function for details on
normalisation techniques' codes.
</p>
<p>Default: 0 (no normalisation)
</p>
</td></tr>
<tr><td><code id="uncles_+3A_samplesids">samplesIDs</code></td>
<td>

<p>If some datasets include replicates that need summarisation, this must be provided.
For L datasets, this is a list of L vectors of integers. Each vector has to be
equal in length to the number of samples in corresponding dataset. Each integer in
one of these vectors represents the index of the group of replicates to which the
corresponding sample belongs. The value (0) is provided to indicate that the
corresponding sample should not be included.
</p>
<p>For example, consider this samplesIDs list for 3 different datasets:
</p>
<p>samplesIDs = list(c(1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 0, 0, 0, 0),
</p>
<p>1:10,
</p>
<p>c(3, 2, 1, 3, 2, 1, 2, 0))
</p>
<p>The first vector in these three vectors within samplesIDs matches the real dataset
GSE22552, which has 16 samples. The first 12 of them represent 3 replicates for each
of the four stages of erythropoiesis (CFU-E, Pro-E, Int-E, and Late-E). The last 4
samples of the 16 are unsorted samples (not to be included).
</p>
<p>The second vector represents a dataset with 10 independant samples with no replicates.
</p>
<p>The third vector represents a dataset with 3 groups of samples (1, 2, and 3) with
replicates that are not ordered in the original dataset as desired in the output.
</p>
<p>In any case, the replicates are summarised by taking their median value, and are
ordered in the processed and normalised datasets starting from the group numbered as
(1), followed by (2), and so on.
</p>
<p>Default: numeric() (i.e. no replicates are combined, and provided datasets are
clustered as they are)
</p>
</td></tr>
<tr><td><code id="uncles_+3A_flipsamples">flipSamples</code></td>
<td>

<p>This is provided if some samples in the datasets are replicates in opposite directions
(e.g. dyes in two-colour arrays were flipped for the condition and the same experimental
condition), and therefore some of them needs to be &quot;flipped&quot; by taking their reciprocals
or opposite sign before they can be summarised by median.
</p>
<p>For L datasets, this is a list of L numeric vectors. This is an example for 4 datasets:
</p>
<p>flipSamples = list(numeric(), numeric(), c(0, 0, 2, 0, 2, 0), numeric())
</p>
<p>In this example, the first, second, and fourth datasets need no flipping of their samples.
On the other hand, two samples of the third dataset, indicated with the flipping code (2),
need to be negated by toggeling their sign before they are considered in summarisation as
per the &quot;samplesIDs&quot; argument described above and indeed before clustering.
</p>
<p>Flipping codes are:
</p>
<p>0: no flipping
1: flipping by taking the reciprocal (1/x)
2: flipping by negating (-x)
</p>
<p>Default: list() (i.e. no flipping for any dataset)
</p>
</td></tr>
<tr><td><code id="uncles_+3A_u">U</code></td>
<td>

<p>If you already have the individual clustering results, provide them here.
For L datasets, this should be a list matrix of L rows and as many columns
as the used K values. Each element of this matrix will be a list of partition
matrices that all use the same K value but may have been generated using
different individual clustering methods or runs.
</p>
<p>For example:
</p>
<p>U[[i,1]] is a list of partitions of the (i)th dataset that have the same
number of clusters (K). U[[i,1]][[1]] might be a partition produced by
k-means clustering, U[[i,1]][[2]] might be a partition produced by self-
organising maps (SOMs) clustering, and so on.
</p>
<p>For the same (i)th dataset, U[[i,2]] is a nother list of partitions which
have a similar K value to each other but different from U[[i,1]].
</p>
<p>The format of each partition U[[i,j]][[l]] depends on the value of the
argument &quot;UType&quot;. See details in the description of that argument below.
The default of UType is &quot;PM&quot;.
</p>
<p>If (U) is provided, the arguments &quot;methods&quot; and &quot;methodsDetailed&quot; will
be ignored.
</p>
<p>Default: list()
</p>
</td></tr>
<tr><td><code id="uncles_+3A_utype">UType</code></td>
<td>

<p>This is the type of the partitions the argument &quot;U&quot; if provided. This can
be &quot;PM&quot; for partition matrices or &quot;IDX&quot; for cluster index vectors.
</p>
<p>If UType is &quot;PM&quot;, a partition U[[i,j]][[l]] should be a partition matrix
of K rows representing clusters and M columns representing the clustered
objects (e.g. genes in gene clustering). Each value U[[i,j]][l]][l,m] is
the membership value of the (m)th gene in the (k)th cluster, and ranges
from 0.0 (does not belong) to 1.0 (fully belongs).
</p>
<p>If UType is &quot;IDX&quot;, a partition U[[i,j]][[l]] should be a vector of M
integer elements (for M genes). Each value U[[i,j]][[l]][m] is an integer
that represents the index of the cluster to which the (m)th gene belongs.
Therefore, if the total number of clusters is (K), this value would range
from 1 to K. However, if the value is zero, it indicates that this gene
does not belong to any cluster.
</p>
<p>Default: &quot;PM&quot;
</p>
</td></tr>
<tr><td><code id="uncles_+3A_xn">Xn</code></td>
<td>

<p>Normalised datasets. This has the same format of the argument &quot;X&quot;, and if
provided, normalisation using the &quot;normalise&quot; argument will be ignored.
</p>
<p>Default: list()
</p>
</td></tr>
<tr><td><code id="uncles_+3A_relabel_technique">relabel_technique</code></td>
<td>

<p>The relabelling technique to be used for the relabelling step. This can
have one of these values:
</p>
<p>- &quot;brute&quot;: Brute force relabelling. This is not practical for K &gt; 8.
</p>
<p>- &quot;minmin_strict&quot;: minmin relabelling
</p>
<p>- &quot;minmax_strict&quot;: minmax relabelling
</p>
<p>- &quot;minmin&quot; (DEFAULT): if (K &gt; 8), minmin relabelling is applied,
otherwise brute force is applied.
</p>
<p>- &quot;minmax&quot;: if (K &gt; 8), minmax relabelling is applied, otherwise brute
force is applied.
</p>
</td></tr>
<tr><td><code id="uncles_+3A_binarisation_technique">binarisation_technique</code></td>
<td>

<p>This is one of the six binarisation techniques described in (Abu-Jamous
et al., PLOS ONE, 2013):
</p>
<p>- &quot;MVB&quot;: maximum value binarisation
</p>
<p>- &quot;IB&quot;: intersection binarisation
</p>
<p>- &quot;UB&quot;: union binarisation
</p>
<p>- &quot;TB&quot;: top binarisation
</p>
<p>- &quot;VTB&quot;: value threshold binarisation
</p>
<p>- &quot;DTB&quot; (DEFAULT): difference threshold binarisation
</p>
<p>TB, VTB, and DTB require the next argument &quot;binarisation_param&quot;.
</p>
</td></tr>
<tr><td><code id="uncles_+3A_binarisation_param">binarisation_param</code></td>
<td>

<p>If the &quot;binarisation_technique&quot; argument is TB, VTB, or DTB, this argument
is considered. It is the tuning parameter that is associated with those
techniques as described in (Abu-Jamous et al., PLOS ONE, 2013).
</p>
<p>Default: seq(0, 1, 0.1)
</p>
</td></tr>
<tr><td><code id="uncles_+3A_setsp">setsP</code></td>
<td>

<p>For UNCLES type &quot;B&quot;, this is a vector of integers representing the
indices of the positive datasets in X. If the number of datasets is
L, every element of setsP should be between 1 and L, inclusively.
</p>
<p>For UNCLES type &quot;A&quot;, a concatenation of both setsP and setsN is formed
to represent the datasets to be considered. In other words, if the
concatenation c(setsP, setsN) does not include all of the integers
from 1 to L, the missing indices represent the indices of the datasets
to be ignored in the UNCLES &quot;A&quot; analysis.
</p>
<p>For example, if 8 datasets were provided in X (L = 8), and:
</p>
<p>type = &quot;A&quot;
</p>
<p>setsP = c(1, 2, 3, 6)
</p>
<p>setsN = c(4, 5, 8)
</p>
<p>This means that UNCLES A will be applied over the datasets 1, 2, 3, 6,
4, 5, and 8, while the dataset 7 will be ignored.
</p>
<p>The X and Xn members of the result of UNCLES will include 7 datasets
only in the order 1, 2, 3, 6, 4, 5, and then 8.
</p>
<p>Default (if Type = &quot;A&quot;): 1:L
</p>
<p>Default (if Type = &quot;B&quot;): 1:(ceiling of L/2)
</p>
</td></tr>
<tr><td><code id="uncles_+3A_setsn">setsN</code></td>
<td>

<p>For UNCLES type &quot;B&quot;, this is a vector of integers representing the
indices of the negative datasets in X. If the number of datasets is
L, every element of setsP should be between 1 and L, inclusively.
</p>
<p>For UNCLES type &quot;A&quot;, see the description of the &quot;setsP&quot; argument.
</p>
<p>Default (if Type = &quot;A&quot;): numeric()
</p>
<p>Default (if Type = &quot;B&quot;): 1:(floor of L/2).
</p>
</td></tr>
<tr><td><code id="uncles_+3A_dofuzzystretch">dofuzzystretch</code></td>
<td>

<p>When multiple clustering methods are applied to multiple datasets,
the partitions resulting from applying mutiple methods to the same
dataset are first combined to obtain an intermediate consensus
partition matrix (CoPaM) per dataset, then these intermediate CoPaMs
are combined to produce the final CoPaM.
</p>
<p>If &quot;dofuzzystretch&quot; is set to TRUE, the intermediate CoPaMs are
&quot;fuzzy stretched&quot; before they are combined to produce the final CoPaM.
Fuzzy stretching is to push their fuzzy values closer to 0.0 and 1.0,
i.e. to make them less fuzzy and closer to binary. This makes the
effect of the differences amongst the datasets on the final result
stronger than the effect of the differences amongst the clustering
methods. See the description of the &quot;fuzzystrech&quot; function for
details on the equations used to perform fuzzy stretching.
</p>
<p>Default: FALSE
</p>
</td></tr>
<tr><td><code id="uncles_+3A_wsets">wsets</code></td>
<td>

<p>For L datasets, this is a vector of L numeric values representing
the relative weights of the datasets. The vector does not have to
be normalised as it will be normalised within the &quot;uncles&quot; function.
Valid examples for 5 datasets include:
</p>
<p>wsets = c(0.2, 0.2, 0.2, 0.2, 0.2)
</p>
<p>wsets = rep(1, 5)
</p>
<p>wsets = c(4, 4, 4, 4, 4)
</p>
<p>wsets = c(1, 2, 2, 0, 1)
</p>
<p>wsets = c(0.2, 0.3, 0, 0.4, 0.4)
</p>
<p>Note that the first three examples result in the same weighting, 
which is to treat all datasets equally. If the weight of a dataset
was set to zero, this implies excluding it of the analysis.
</p>
<p>Default: numeric() # which will be read as equal weights for all
datasets.
</p>
</td></tr>
<tr><td><code id="uncles_+3A_wmethods">wmethods</code></td>
<td>

<p>Similar format to &quot;wsets&quot; but as a vector with the same length as
the number of methods used, as it represents weights of the
different clustering methods.
</p>
</td></tr>
<tr><td><code id="uncles_+3A_gdm">GDM</code></td>
<td>

<p>Gene-Dataset Matrix (GDM) is provided if not all of the datasets
have probesets/entries for the same set of genes. GDM is an MxL
matrix where M is the total number of genes from all datasets and
L is the number of the datasets. GDM[m,l] is 1 if the (m)th gene
is included in the (l)th dataset, and is 0 if it does not.
</p>
<p>For example, if there are 6 genes in total (M = 6) and 3
datasets (L = 3), a possible GDM can be:
</p>
<p>GDM = 
</p>
<p>1 1 1
</p>
<p>1 0 1
</p>
<p>1 1 1
</p>
<p>1 1 1
</p>
<p>0 1 1
</p>
<p>1 1 1
</p>
<p>This means that each one of the first and the second
datasets has 5 genes only, while the third has all of the
six genes. It is important that the rows of the datasets in
the argument X are in the same order as the order in the
GDM matrix.
</p>
<p>Default: numeric() # which will consider that all datasets
X[[1]] to X[[L]] have the same number of rows representing
genes, and in the same order.
</p>
</td></tr>
<tr><td><code id="uncles_+3A_copamfordatasettrials">CoPaMforDatasetTrials</code></td>
<td>

<p>Number of different CoPaMs generated for each dataset by
combining the partitions generated for that dataset.
</p>
<p>This is used because the combining process takes one of the
partitions to be combined as the reference and then applies
relabelling and merging for the rest of them one by one.
Practice shows that different order of partitions in this
merging may produce different results. Therefore, generating
more than one CoPaM for the same dataset using different
random permutations, which are combined to produce the final
CoPaM afterwards, may produce more robust results.
</p>
<p>Default: 1.
</p>
</td></tr>
<tr><td><code id="uncles_+3A_copamfinaltrials">CoPaMfinaltrials</code></td>
<td>

<p>Number of different final CoPaMs generated.
</p>
<p>UNCLES first combines the different partitions generated for
any single dataset into a single CoPaM per dataset per K value,
or as many as the argument &quot;CoPaMforDatasetTrials&quot; states if it
was provided. Then, these per-set CoPaMs are combined to produce
the final CoPaM. For the same reason for which the argument
&quot;CoPaMforDatasetTrials&quot; may be provided, that is, because
different orders of combining of the partitions or per-set
CoPaMs into a CoPaM may produce different results, this argument
also is provided.
</p>
<p>In the final output, the variable &quot;params$CoPaMs&quot; for type A or
the variables &quot;params$CoPaMsP&quot; and &quot;params$CoPaMsN&quot; for type B,
are list matrices with &quot;CoPaMfinaltrials&quot; rows and as many columns
as the number of different K values, i.e. the number of elements
in the argument &quot;Ks&quot;. For example:
</p>
<p>result = uncles(...)
result$params$CoPaMs[[i,j]] is a CoPaM (numeric partition matrix)
produced by the (i)th trial of combining the per-set CoPaMs of all
datasets at the (j)th K value.
</p>
<p>Also, the first dimension of the four dimensions of the output &quot;B&quot;
is this number of trials as well.
</p>
<p>Indeed, larger values of this argument enlarges the output, while
larger values of the previous argument &quot;CoPaMforDatasetTrials&quot; does
not, as all trials of per-set CoPaMs are eventually combined into
the same output fuzzy CoPaM(s) or binary B(s).
</p>
<p>Default: 1
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># This is the simplist way to apply UNCLES and MN plots.
# Just pass the datasets to the "uncles" function and then pass
# the UNCLES result to the "mnplots" function.
# Both functions will use default values for all other arguments.
#
# Define three random gene expression datasets for 1000 genes.
# The number of samples in the datasets are 6, 4, and 9, respectively.
#
# X = list()
# X[[1]] = matrix(rnorm(6000), 1000, 6)
# X[[2]] = matrix(rnorm(4000), 1000, 4)
# X[[3]] = matrix(rnorm(9000), 1000, 9)
#
# unclesResult &lt;- uncles(X)
# mnResult &lt;- mnplots(unclesResult)
#
# The clusters will be available in the form of a partition matrix in the variable:
# mnResult$B;
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
