<!DOCTYPE html><html><head><title>Help for package BayesfMRI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesfMRI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.findTheta'><p>Perform the EM algorithm of the Bayesian GLM fitting</p></a></li>
<li><a href='#.getSqrtInvCpp'><p>Get the prewhitening matrix for a single data location</p></a></li>
<li><a href='#.initialKP'><p>Find the initial values of kappa2 and phi</p></a></li>
<li><a href='#.logDetQt'><p>Find the log of the determinant of Q_tilde</p></a></li>
<li><a href='#act_prevalance'><p>Activations prevalence.</p></a></li>
<li><a href='#aic_Param'><p>aic</p></a></li>
<li><a href='#AICc'><p>Corrected AIC</p></a></li>
<li><a href='#ar_order_Param'><p>ar_order</p></a></li>
<li><a href='#ar_smooth_Param'><p>ar_smooth</p></a></li>
<li><a href='#Bayes_Param'><p>Bayes</p></a></li>
<li><a href='#BayesGLM'><p>BayesGLM</p></a></li>
<li><a href='#BayesGLM_argChecks'><p>Bayes GLM arg checks</p></a></li>
<li><a href='#BayesGLM_cifti'><p>BayesGLM for CIFTI</p></a></li>
<li><a href='#BayesGLM2'><p>Group-level Bayesian GLM</p></a></li>
<li><a href='#beta.posterior.thetasamp'><p>Beta posterior theta sampling</p></a></li>
<li><a href='#cAIC'><p>Corrected AIC To-Do</p></a></li>
<li><a href='#cderiv'><p>Central derivative</p></a></li>
<li><a href='#check_INLA'><p>Check INLA and PARDISO</p></a></li>
<li><a href='#cholQsample'><p>Sample from the multivariate normal distribution with Cholesky(Q)</p></a></li>
<li><a href='#combine_sessions_Param'><p>combine_sessions</p></a></li>
<li><a href='#contrasts_Param'><p>contrasts</p></a></li>
<li><a href='#create_listRcpp'><p>Function to prepare objects for use in Rcpp functions</p></a></li>
<li><a href='#ELL'><p>Expected log-likelihood function</p></a></li>
<li><a href='#EM_Param'><p>EM</p></a></li>
<li><a href='#emTol_Param'><p>emTol</p></a></li>
<li><a href='#extract_estimates'><p>Extract Estimates of Activation</p></a></li>
<li><a href='#F.logwt'><p>F logwt</p></a></li>
<li><a href='#faces_Param'><p>faces</p></a></li>
<li><a href='#galerkin_db'><p>Create FEM matrices</p></a></li>
<li><a href='#get_posterior_densities'><p>Extracts posterior density estimates for hyperparameters</p></a></li>
<li><a href='#GLMEM_fixptseparate'><p>Fixed point function for the joint BayesGLMEM update algorithm</p></a></li>
<li><a href='#GLMEM_objfn'><p>Objective function for the BayesGLM EM algorithm</p></a></li>
<li><a href='#HRF'><p>Canonical (double-gamma) HRF</p></a></li>
<li><a href='#id_activations'><p>Identify task activations</p></a></li>
<li><a href='#id_activations.classical'><p>Identification of areas of activation in a General Linear Model using classical methods</p></a></li>
<li><a href='#id_activations.posterior'><p>Identify activations using joint posterior probabilities</p></a></li>
<li><a href='#init_fixpt'><p>The fix point function for the initialization of kappa2 and phi</p></a></li>
<li><a href='#init_objfn'><p>Objective function for the initialization of kappa2 and phi</p></a></li>
<li><a href='#INLA_deps'><p>Import INLA dependencies</p></a></li>
<li><a href='#INLA_Description'><p>INLA</p></a></li>
<li><a href='#is.a_session'><p>Validate an individual session in a <code>"BfMRI.sess"</code> object.</p></a></li>
<li><a href='#is.BfMRI.sess'><p>Validate a <code>"BfMRI.sess"</code> object.</p></a></li>
<li><a href='#kappa_init_fn'><p>Function to optimize over kappa2</p></a></li>
<li><a href='#make_data_list'><p>Make data list for <code>estimate_model</code></p></a></li>
<li><a href='#make_HRFs'><p>Make HRFs</p></a></li>
<li><a href='#make_mask'><p>Mask out invalid data</p></a></li>
<li><a href='#make_mesh'><p>Make Mesh</p></a></li>
<li><a href='#make_Q'><p>Make the full SPDE precision based on theta, the spde, and the number of sessions</p></a></li>
<li><a href='#mask_Param_vertices'><p>mask: vertices</p></a></li>
<li><a href='#max.threads_Param'><p>max.threads</p></a></li>
<li><a href='#mesh_Param_either'><p>mesh: either</p></a></li>
<li><a href='#mesh_Param_inla'><p>mesh: INLA only</p></a></li>
<li><a href='#neg_kappa_fn'><p>The negative of the objective function for kappa</p></a></li>
<li><a href='#neg_kappa_fn2'><p>The negative of the objective function for kappa without Sig_inv</p></a></li>
<li><a href='#neg_kappa_fn3'><p>Streamlined negative objective function for kappa2 using precompiled values</p></a></li>
<li><a href='#neg_kappa_fn4'><p>Streamlined negative objective function for kappa2 using precompiled values</p></a></li>
<li><a href='#num.threads_Param'><p>num.threads</p></a></li>
<li><a href='#organize_data'><p>Organize data for Bayesian GLM</p></a></li>
<li><a href='#organize_data_pw'><p>Organize prewhitened data for Bayesian GLM</p></a></li>
<li><a href='#organize_replicates'><p>Organize replicates</p></a></li>
<li><a href='#plot.act_BayesGLM_cifti'><p>S3 method: use <code>view_xifti_surface</code> to plot a <code>"act_BayesGLM_cifti"</code> object</p></a></li>
<li><a href='#plot.BayesGLM_cifti'><p>S3 method: use <code>view_xifti_surface</code> to plot a <code>"BayesGLM_cifti"</code> object</p></a></li>
<li><a href='#plot.BayesGLM2_cifti'><p>S3 method: use <code>view_xifti_surface</code> to plot a <code>"BayesGLM2_cifti"</code> object</p></a></li>
<li><a href='#plot.prev_BayesGLM_cifti'><p>S3 method: use <code>view_xifti</code> to plot a <code>"prev_BayesGLM_cifti"</code> object</p></a></li>
<li><a href='#prep_kappa2_optim'><p>Find values for coefficients used in objective function for kappa2</p></a></li>
<li><a href='#pw_estimate'><p>Estimate residual autocorrelation for prewhitening</p></a></li>
<li><a href='#pw_smooth'><p>Smooth AR coefficients and white noise variance</p></a></li>
<li><a href='#Q_prime'><p>Gives the portion of the Q matrix independent of phi</p></a></li>
<li><a href='#qsample'><p>Sample from a multivariate normal with mean and precision</p></a></li>
<li><a href='#retro_mask_BGLM'><p>Retroactively mask locations from BayesGLM result.</p></a></li>
<li><a href='#retro_mask_mesh'><p>Retroactively mask locations from mesh.</p></a></li>
<li><a href='#return_INLA_Param'><p>return_INLA</p></a></li>
<li><a href='#s2m'><p>Sequential 2-means variable selection</p></a></li>
<li><a href='#s2m_B'><p>Sequential 2-means on array B</p></a></li>
<li><a href='#scale_BOLD_Param'><p>scale_BOLD</p></a></li>
<li><a href='#scale_design_mat'><p>Scale the design matrix</p></a></li>
<li><a href='#scale_design_Param'><p>scale_design</p></a></li>
<li><a href='#seed_Param'><p>seed</p></a></li>
<li><a href='#session_names_Param'><p>session_names</p></a></li>
<li><a href='#spde_Q_phi'><p>Calculate the SPDE covariance</p></a></li>
<li><a href='#submesh'><p>Remove part of a mesh without using INLA functions</p></a></li>
<li><a href='#summary.act_BayesGLM'><p>Summarize a <code>"act_BayesGLM"</code> object</p></a></li>
<li><a href='#summary.act_BayesGLM_cifti'><p>Summarize a <code>"act_BayesGLM_cifti"</code> object</p></a></li>
<li><a href='#summary.BayesGLM'><p>Summarize a <code>"BayesGLM"</code> object</p></a></li>
<li><a href='#summary.BayesGLM_cifti'><p>Summarize a <code>"BayesGLM_cifti"</code> object</p></a></li>
<li><a href='#summary.BayesGLM2'><p>Summarize a <code>"BayesGLM2"</code> object</p></a></li>
<li><a href='#summary.BayesGLM2_cifti'><p>Summarize a <code>"BayesGLM2_cifti"</code> object</p></a></li>
<li><a href='#summary.prev_BayesGLM'><p>Summarize a <code>"prev_BayesGLM"</code> object</p></a></li>
<li><a href='#summary.prev_BayesGLM_cifti'><p>Summarize a <code>"prev_BayesGLM_cifti"</code> object</p></a></li>
<li><a href='#task_names_Param'><p>task_names</p></a></li>
<li><a href='#trim_INLA_model_obj'><p>Trim INLA object</p></a></li>
<li><a href='#trim_INLA_Param'><p>trim_INLA</p></a></li>
<li><a href='#TrQbb'><p>Trace of Q beta' beta</p></a></li>
<li><a href='#TrQEww'><p>Trace approximation function</p></a></li>
<li><a href='#TrSigB'><p>Hutchinson estimator of the trace</p></a></li>
<li><a href='#verbose_Param'><p>verbose</p></a></li>
<li><a href='#vertex_areas'><p>Surface area of each vertex</p></a></li>
<li><a href='#vertices_Param'><p>vertices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Bayesian Methods for Task Functional MRI Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.11</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amanda Mejia &lt;mandy.mejia@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs a spatial Bayesian general linear model (GLM) for task 
    functional magnetic resonance imaging (fMRI) data on the cortical surface. 
    Additional models include group analysis and inference to detect thresholded
    areas of activation. Includes direct support for the 'CIFTI' neuroimaging 
    file format. For more information see A. F. Mejia, Y. R. Yue, D. Bolin, F. 
    Lindgren, M. A. Lindquist (2020) &lt;<a href="https://doi.org/10.1080%2F01621459.2019.1611582">doi:10.1080/01621459.2019.1611582</a>&gt; and D. 
    Spencer, Y. R. Yue, D. Bolin, S. Ryan, A. F. Mejia (2022) 
    &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2022.118908">doi:10.1016/j.neuroimage.2022.118908</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>ciftiTools (&ge; 0.8.0), excursions, foreach, fMRItools, MASS,
Matrix, matrixStats, methods, Rcpp, stats, sp, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, abind, dplyr, geometry, ggplot2, grDevices, INLA (&ge;
0.0-1468840039), knitr, MatrixModels, parallel, purrr, rdist,
rmarkdown, SQUAREM, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mandymejia/BayesfMRI">https://github.com/mandymejia/BayesfMRI</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mandymejia/BayesfMRI/issues">https://github.com/mandymejia/BayesfMRI/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-17 06:37:53 UTC; ddpham</td>
</tr>
<tr>
<td>Author:</td>
<td>Amanda Mejia [aut, cre],
  Daniel Spencer <a href="https://orcid.org/0000-0002-9705-3605"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Damon Pham <a href="https://orcid.org/0000-0001-7563-4727"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  David Bolin [ctb],
  Sarah Ryan [ctb],
  Yu (Ryan) Yue [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-18 08:50:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='.findTheta'>Perform the EM algorithm of the Bayesian GLM fitting</h2><span id='topic+.findTheta'></span>

<h3>Description</h3>

<p>Perform the EM algorithm of the Bayesian GLM fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.findTheta(theta, spde, y, X, QK, Psi, A, Ns, tol, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".findTheta_+3A_theta">theta</code></td>
<td>
<p>the vector of initial values for theta</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_spde">spde</code></td>
<td>
<p>a list containing the sparse matrix elements Cmat, Gmat, and GtCinvG</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_y">y</code></td>
<td>
<p>the vector of response values</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_x">X</code></td>
<td>
<p>the sparse matrix of the data values</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_qk">QK</code></td>
<td>
<p>a sparse matrix of the prior precision found using the initial values of the hyperparameters</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_psi">Psi</code></td>
<td>
<p>a sparse matrix representation of the basis function mapping the data locations to the mesh vertices</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_a">A</code></td>
<td>
<p>a precomputed matrix crossprod(X%*%Psi)</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_ns">Ns</code></td>
<td>
<p>the number of columns for the random matrix used in the Hutchinson estimator</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_tol">tol</code></td>
<td>
<p>a value for the tolerance used for a stopping rule (compared to
the squared norm of the differences between <code>theta(s)</code> and <code>theta(s-1)</code>)</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Should intermediate output be displayed?</p>
</td></tr>
</table>

<hr>
<h2 id='.getSqrtInvCpp'>Get the prewhitening matrix for a single data location</h2><span id='topic+.getSqrtInvCpp'></span>

<h3>Description</h3>

<p>Get the prewhitening matrix for a single data location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getSqrtInvCpp(AR_coeffs, nTime, avg_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getSqrtInvCpp_+3A_ar_coeffs">AR_coeffs</code></td>
<td>
<p>a length-p vector where p is the AR order</p>
</td></tr>
<tr><td><code id=".getSqrtInvCpp_+3A_ntime">nTime</code></td>
<td>
<p>(integer) the length of the time series that is being prewhitened</p>
</td></tr>
<tr><td><code id=".getSqrtInvCpp_+3A_avg_var">avg_var</code></td>
<td>
<p>a scalar value of the residual variances of the AR model</p>
</td></tr>
</table>

<hr>
<h2 id='.initialKP'>Find the initial values of kappa2 and phi</h2><span id='topic+.initialKP'></span>

<h3>Description</h3>

<p>Find the initial values of kappa2 and phi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.initialKP(theta, spde, w, n_sess, tol, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".initialKP_+3A_theta">theta</code></td>
<td>
<p>a vector of length two containing the range and scale parameters
kappa2 and phi, in that order</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_spde">spde</code></td>
<td>
<p>a list containing the sparse matrix elements Cmat, Gmat, and GtCinvG</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_w">w</code></td>
<td>
<p>the beta_hat estimates for a single task</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_n_sess">n_sess</code></td>
<td>
<p>the number of sessions</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_tol">tol</code></td>
<td>
<p>the stopping rule tolerance</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Should intermediate output be displayed?</p>
</td></tr>
</table>

<hr>
<h2 id='.logDetQt'>Find the log of the determinant of Q_tilde</h2><span id='topic+.logDetQt'></span>

<h3>Description</h3>

<p>Find the log of the determinant of Q_tilde
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.logDetQt(kappa2, in_list, n_sess)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".logDetQt_+3A_kappa2">kappa2</code></td>
<td>
<p>a scalar</p>
</td></tr>
<tr><td><code id=".logDetQt_+3A_in_list">in_list</code></td>
<td>
<p>a list with elements Cmat, Gmat, and GtCinvG</p>
</td></tr>
<tr><td><code id=".logDetQt_+3A_n_sess">n_sess</code></td>
<td>
<p>the integer number of sessions</p>
</td></tr>
</table>

<hr>
<h2 id='act_prevalance'>Activations prevalence.</h2><span id='topic+act_prevalance'></span>

<h3>Description</h3>

<p>Activations prevalence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>act_prevalance(act_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="act_prevalance_+3A_act_list">act_list</code></td>
<td>
<p>List of activations from <code><a href="#topic+id_activations">id_activations</a></code>. All
should have the same sessions, fields, and brainstructures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the prevalances of activation, as a proportion of
the results from <code>act_list</code>.
</p>

<hr>
<h2 id='aic_Param'>aic</h2><span id='topic+aic_Param'></span>

<h3>Description</h3>

<p>aic
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic_Param_+3A_aic">aic</code></td>
<td>
<p>Use the AIC to select AR model order between <code>0</code> and
<code>ar_order</code>? Default: <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='AICc'>Corrected AIC</h2><span id='topic+AICc'></span>

<h3>Description</h3>

<p>Computes corrected AIC (AICc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICc(y, demean = FALSE, order.max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICc_+3A_y">y</code></td>
<td>
<p>The autocorrelated data</p>
</td></tr>
<tr><td><code id="AICc_+3A_demean">demean</code></td>
<td>
<p>Demean <code>y</code>? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="AICc_+3A_order.max">order.max</code></td>
<td>
<p>The model order limit. Default: <code>10</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cAIC
</p>

<hr>
<h2 id='ar_order_Param'>ar_order</h2><span id='topic+ar_order_Param'></span>

<h3>Description</h3>

<p>ar_order
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar_order_Param_+3A_ar_order">ar_order</code></td>
<td>
<p>(numeric) Controls prewhitening. If greater than zero, this
should be a number indicating the order of the autoregressive model to use
for prewhitening. If zero, do not prewhiten. Default: <code>6</code>. For
multi-session models, note that a single AR model is used; the parameters
are estimated by averaging the estimates from each session.</p>
</td></tr>
</table>

<hr>
<h2 id='ar_smooth_Param'>ar_smooth</h2><span id='topic+ar_smooth_Param'></span>

<h3>Description</h3>

<p>ar_smooth
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar_smooth_Param_+3A_ar_smooth">ar_smooth</code></td>
<td>
<p>(numeric) FWHM parameter for smoothing the AR model
coefficient estimates for prewhitening. Remember that
<code class="reqn">\sigma = \frac{FWHM}{2*sqrt(2*log(2)}</code>. Set to <code>0</code> or <code>NULL</code>
to not do any smoothing. Default: <code>5</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Bayes_Param'>Bayes</h2><span id='topic+Bayes_Param'></span>

<h3>Description</h3>

<p>Bayes
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bayes_Param_+3A_bayes">Bayes</code></td>
<td>
<p>If <code>TRUE</code> (default), will fit a spatial Bayesian GLM in
addition to the classical GLM. (The classical GLM is always returned.)</p>
</td></tr>
</table>

<hr>
<h2 id='BayesGLM'>BayesGLM</h2><span id='topic+BayesGLM'></span>

<h3>Description</h3>

<p>Performs spatial Bayesian GLM for fMRI task activation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM(
  data,
  vertices = NULL,
  faces = NULL,
  mesh = NULL,
  mask = NULL,
  task_names = NULL,
  session_names = NULL,
  combine_sessions = TRUE,
  scale_BOLD = c("auto", "mean", "sd", "none"),
  scale_design = TRUE,
  Bayes = TRUE,
  ar_order = 6,
  ar_smooth = 5,
  aic = FALSE,
  num.threads = 4,
  return_INLA = c("trimmed", "full", "minimal"),
  verbose = 1,
  meanTol = 1e-06,
  varTol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesGLM_+3A_data">data</code></td>
<td>
<p>A list of sessions in the <code>"BfMRI.sess"</code> object format. Each
session is a list with elements <code>"BOLD"</code>, <code>"design"</code>, and
optionally <code>"nuisance"</code>. Each element should be a numeric matrix with
<code class="reqn">T</code> rows. The name of each element in <code>data</code> is the name of that
session. See <code>?is.BfMRI.sess</code> for details.
</p>
<p>Note that the argument <code>session_names</code> can be used instead of providing
the session names as the names of the elements in <code>data</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_vertices">vertices</code>, <code id="BayesGLM_+3A_faces">faces</code></td>
<td>
<p>If <code>Bayes</code>, the geometry data can be provided
with either both the <code>vertices</code> and <code>faces</code> arguments, or with the
<code>mesh</code> argument.
</p>
<p><code>vertices</code> is a <code class="reqn">V \times 3</code> matrix, where each row contains the
Euclidean coordinates at which a given vertex in the mesh is located.
<code class="reqn">V</code> is the number of vertices in the mesh.
</p>
<p><code>faces</code> is a <code class="reqn">F \times 3</code> matrix, where each row contains the
vertex indices for a given triangular face in the mesh. <code class="reqn">F</code> is the
number of faces in the mesh.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_mesh">mesh</code></td>
<td>
<p>If <code>Bayes</code>, the geometry data can be provided
with either both the <code>vertices</code> and <code>faces</code> arguments, or with the
<code>mesh</code> argument.
</p>
<p><code>mesh</code> is an <code>"inla.mesh"</code> object. This can be created for surface
data using <code><a href="#topic+make_mesh">make_mesh</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_mask">mask</code></td>
<td>
<p>(Optional) A length <code class="reqn">V</code> logical vector indicating the
vertices to include.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_task_names">task_names</code></td>
<td>
<p>(Optional) Names of tasks represented in design matrix.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_session_names">session_names</code></td>
<td>
<p>(Optional, and only relevant for multi-session modeling)
Names of each session. Default: <code>NULL</code>. In <code><a href="#topic+BayesGLM">BayesGLM</a></code> this
argument will overwrite the names of the list entries in <code>data</code>, if
both exist.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_combine_sessions">combine_sessions</code></td>
<td>
<p>If multiple sessions are provided, should their data
be combined and analyzed as a single session?
</p>
<p>If <code>TRUE</code> (default), the multiple sessions will be concatenated along
time after scaling and nuisance regression, but before prewhitening. If
<code>FALSE</code>, each session will be analyzed separately, except that a single
estimate of the AR model coefficients for prewhitening is used, estimated
across all sessions.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_scale_bold">scale_BOLD</code></td>
<td>
<p>Option for scaling the BOLD response.
</p>
<p><code>"auto"</code> (default) will use <code>"mean"</code> scaling except if demeaned
data is detected (if any mean is less than one), in which case <code>"sd"</code>
scaling will be used instead.
</p>
<p><code>"mean"</code> scaling will scale the data to percent local signal change.
</p>
<p><code>"sd"</code> scaling will scale the data by local standard deviation.
</p>
<p><code>"none"</code> will only center the data, not scale it.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_scale_design">scale_design</code></td>
<td>
<p>Scale the design matrix by dividing each column by its
maximum and then subtracting the mean? Default: <code>TRUE</code>. If
<code>FALSE</code>, the design matrix is centered but not scaled.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_bayes">Bayes</code></td>
<td>
<p>If <code>TRUE</code> (default), will fit a spatial Bayesian GLM in
addition to the classical GLM. (The classical GLM is always returned.)</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_ar_order">ar_order</code></td>
<td>
<p>(numeric) Controls prewhitening. If greater than zero, this
should be a number indicating the order of the autoregressive model to use
for prewhitening. If zero, do not prewhiten. Default: <code>6</code>. For
multi-session models, note that a single AR model is used; the parameters
are estimated by averaging the estimates from each session.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_ar_smooth">ar_smooth</code></td>
<td>
<p>(numeric) FWHM parameter for smoothing the AR model
coefficient estimates for prewhitening. Remember that
<code class="reqn">\sigma = \frac{FWHM}{2*sqrt(2*log(2)}</code>. Set to <code>0</code> or <code>NULL</code>
to not do any smoothing. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_aic">aic</code></td>
<td>
<p>Use the AIC to select AR model order between <code>0</code> and
<code>ar_order</code>? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_num.threads">num.threads</code></td>
<td>
<p>The maximum number of threads to use for parallel
computations: prewhitening parameter estimation, and the inla-program model
estimation. Default: <code>4</code>. Note that parallel prewhitening requires the
<code>parallel</code> package.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_return_inla">return_INLA</code></td>
<td>
<p>Return the INLA model object? (It can be large.) Use
<code>"trimmed"</code> (default) to return only the more relevant results, which
is enough for both <code><a href="#topic+id_activations">id_activations</a></code> and <code>BayesGLM2</code>,
<code>"minimal"</code> to return just enough for <code><a href="#topic+BayesGLM2">BayesGLM2</a></code> but not
<code>id_activations</code>, or <code>"full"</code> to return the full output of
<code>inla</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_verbose">verbose</code></td>
<td>
<p>Should updates be printed? Use <code>1</code> (default) for
occasional updates, <code>2</code> for occasional updates as well as running INLA
in verbose mode (if applicable), or <code>0</code> for no updates.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_meantol">meanTol</code>, <code id="BayesGLM_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Default: <code>1e-6</code> for both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"BayesGLM"</code> object: a list with elements
</p>

<dl>
<dt>INLA_model_obj</dt><dd><p>The full result of the call to <code>INLA::inla</code>.</p>
</dd>
<dt>task_estimates</dt><dd><p>The task coefficients for the Bayesian model.</p>
</dd>
<dt>result_classical</dt><dd><p>Results from the classical model: task estimates, task standard error estimates, residuals, degrees of freedom, and the mask.</p>
</dd>
<dt>mesh</dt><dd><p>The model mesh including only the locations analyzed, i.e. within <code>mask</code>, without missing values, and meeting <code>meanTol</code> and <code>varTol</code>.</p>
</dd>
<dt>mesh_orig</dt><dd><p>The original mesh provided.</p>
</dd>
<dt>mask</dt><dd><p>A mask of <code>mesh_orig</code> indicating the locations inside <code>mesh</code>.</p>
</dd>
<dt>design</dt><dd><p>The design matrix, after centering and scaling, but before any nuisance regression or prewhitening.</p>
</dd>
<dt>task_names</dt><dd><p>The names of the tasks.</p>
</dd>
<dt>session_names</dt><dd><p>The names of the sessions.</p>
</dd>
<dt>hyperpar_posteriors</dt><dd><p>Hyperparameter posterior densities.</p>
</dd>
<dt>theta_estimates</dt><dd><p>Theta estimates from the Bayesian model.</p>
</dd>
<dt>posterior_Sig_inv</dt><dd><p>For joint group modeling.</p>
</dd>
<dt>mu_theta</dt><dd><p>For joint group modeling.</p>
</dd>
<dt>Q_theta</dt><dd><p>For joint group modeling.</p>
</dd>
<dt>y</dt><dd><p>For joint group modeling: The BOLD data after any centering, scaling, nuisance regression, or prewhitening.</p>
</dd>
<dt>X</dt><dd><p>For joint group modeling: The design matrix after any centering, scaling, nuisance regression, or prewhitening.</p>
</dd>
<dt>prewhiten_info</dt><dd><p>Vectors of values across locations: <code>phi</code> (AR coefficients averaged across sessions), <code>sigma_sq</code> (residual variance averaged across sessions), and AIC (the maximum across sessions).</p>
</dd>
<dt>call</dt><dd><p>match.call() for this function call.</p>
</dd>
</dl>



<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='BayesGLM_argChecks'>Bayes GLM arg checks</h2><span id='topic+BayesGLM_argChecks'></span>

<h3>Description</h3>

<p>Checks arguments for <code>BayesGLM</code> and <code>BayesGLM_cifti</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_argChecks(
  combine_sessions = FALSE,
  scale_BOLD = c("auto", "mean", "sd", "none"),
  scale_design = TRUE,
  Bayes = TRUE,
  EM = FALSE,
  ar_order = 6,
  ar_smooth = 5,
  aic = FALSE,
  num.threads = 4,
  return_INLA = c("trimmed", "full", "minimal"),
  verbose = 1,
  meanTol = 1e-06,
  varTol = 1e-06,
  emTol = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesGLM_argChecks_+3A_combine_sessions">combine_sessions</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_scale_bold">scale_BOLD</code>, <code id="BayesGLM_argChecks_+3A_scale_design">scale_design</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_bayes">Bayes</code>, <code id="BayesGLM_argChecks_+3A_em">EM</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_ar_order">ar_order</code>, <code id="BayesGLM_argChecks_+3A_ar_smooth">ar_smooth</code>, <code id="BayesGLM_argChecks_+3A_aic">aic</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_num.threads">num.threads</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_return_inla">return_INLA</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_meantol">meanTol</code>, <code id="BayesGLM_argChecks_+3A_vartol">varTol</code>, <code id="BayesGLM_argChecks_+3A_emtol">emTol</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Avoids duplicated code between <code>BayesGLM</code> and <code>BayesGLM_cifti</code>
</p>


<h3>Value</h3>

<p>The arguments that may have changed, in a list: <code>scale_BOLD</code>,
<code>do_Bayesian</code>, <code>do_EM</code>, and <code>do_pw</code>.
</p>

<hr>
<h2 id='BayesGLM_cifti'>BayesGLM for CIFTI</h2><span id='topic+BayesGLM_cifti'></span>

<h3>Description</h3>

<p>Performs spatial Bayesian GLM on the cortical surface for fMRI task activation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_cifti(
  cifti_fname,
  surfL_fname = NULL,
  surfR_fname = NULL,
  brainstructures = c("left", "right"),
  design = NULL,
  onsets = NULL,
  TR = NULL,
  nuisance = NULL,
  dHRF = c(0, 1, 2),
  dHRF_as = c("auto", "nuisance", "task"),
  hpf = NULL,
  DCT = if (is.null(hpf)) {
     4
 } else {
     NULL
 },
  resamp_res = 10000,
  task_names = NULL,
  session_names = NULL,
  combine_sessions = TRUE,
  scale_BOLD = c("auto", "mean", "sd", "none"),
  scale_design = TRUE,
  Bayes = TRUE,
  ar_order = 6,
  ar_smooth = 5,
  aic = FALSE,
  num.threads = 4,
  return_INLA = c("trimmed", "full", "minimal"),
  verbose = 1,
  meanTol = 1e-06,
  varTol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesGLM_cifti_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>fMRI timeseries data in CIFTI format (&quot;*.dtseries.nii&quot;).
For single-session analysis this can be a file path to a CIFTI file or a
<code>"xifti"</code> object from the <code>ciftiTools</code> package. For multi-session
analysis this can be a vector of file paths or a list of <code>"xifti"</code>
objects.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_surfl_fname">surfL_fname</code></td>
<td>
<p>Left cortex surface geometry in GIFTI format
(&quot;*.surf.gii&quot;). This can be a file path to a GIFTI file or a <code>"surf"</code>
object from the <code>ciftiTools</code> package. This argument is only used if
<code>brainstructures</code> includes <code>"left"</code> and <code>Bayes==TRUE</code>. If
it's not provided, the HCP group-average inflated surface included in the
<code>ciftiTools</code> package will be used.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_surfr_fname">surfR_fname</code></td>
<td>
<p>Right cortex surface geometry in GIFTI format
(&quot;*.surf.gii&quot;). This can be a file path to a GIFTI file or a <code>"surf"</code>
object from the <code>ciftiTools</code> package. This argument is only used if
<code>brainstructures</code> includes <code>"right"</code> and <code>Bayes==TRUE</code>. If
it's not provided, the HCP group-average inflated surface included in the
<code>ciftiTools</code> package will be used.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
to analyze: <code>"left"</code> (left cortical surface) and/or <code>"right"</code>
(right cortical surface). Default: <code>c("left","right")</code> (both
hemispheres). Note that the subcortical models have not yet been implemented.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_design">design</code>, <code id="BayesGLM_cifti_+3A_onsets">onsets</code>, <code id="BayesGLM_cifti_+3A_tr">TR</code></td>
<td>
<p>Either provide <code>design</code> directly, or provide
both <code>onsets</code> and <code>TR</code> from which the design matrix or matrices
will be constructed.
</p>
<p><code>design</code> is a <code class="reqn">T \times K</code> task design matrix. Each column
represents the expected BOLD response due to each task, a convolution of
the hemodynamic response function (HRF) and the task stimulus. Note that
the scale of the regressors will affect the scale and interpretation of the
beta coefficients, so imposing a proper scale is recommended; see the
<code>scale_design</code> argument, which by default is <code>TRUE</code>. Task names
should be the column names, if not provided by the <code>task_names</code>
argument. For multi-session modeling, this argument should be a list of
such matrices. To model HRF derivatives, calculate the derivatives of the
task columns beforehand (see the helper function <code><a href="#topic+cderiv">cderiv</a></code> which
computes the discrete central derivative) and either add them to
<code>design</code> to model them as tasks, or <code>nuisance</code> to model them as
nuisance signals; it's recommended to then drop the first and last
timepoints because the discrete central derivative doesn't exist at the
time series boundaries. Do note that INLA computation times increase
greatly if the design matrix has more than five columns, so it might be
required to add these derivatives to <code>nuisance</code> rather than
<code>design</code>.
</p>
<p><code>onsets</code> is an <code class="reqn">L</code>-length list in which the name of each element is
the name of the corresponding task, and the value of each element is a
matrix of onsets (first column) and durations (second column) for each
stimuli (each row) of the corresponding task. The units of both columns
is seconds. For multi-session modeling, this argument should be a list of
such lists. To model HRF derivatives, use the arguments <code>dHRF</code> and
<code>dHRF_as</code>. If <code>dHRF==0</code> or <code>dHRF_as=="nuisance"</code>, the total
number of columns in the design matrix, <code class="reqn">K</code>, will equal <code class="reqn">L</code>.
If <code>dHRF_as=="task"</code>, <code class="reqn">K</code> will equal <code class="reqn">L</code> times <code>dHRF+1</code>.
</p>
<p><code>TR</code> is the temporal resolution of the data, in seconds.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_nuisance">nuisance</code></td>
<td>
<p>(Optional) A <code class="reqn">T \times J</code> matrix of nuisance signals.
These are regressed from the fMRI data and the design matrix prior to the
GLM computation. For multi-session modeling, this argument should be a list
of such matrices.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_dhrf">dHRF</code>, <code id="BayesGLM_cifti_+3A_dhrf_as">dHRF_as</code></td>
<td>
<p>Only applicable if <code>onsets</code> and <code>TR</code> are
provided. These arguments enable the modeling of HRF derivatives.
</p>
<p>Set <code>dHRF</code> to <code>1</code> to model the temporal derivatives of each task,
<code>2</code> to add the second derivatives too, or <code>0</code> to not model the
derivatives. Default: <code>1</code>.
</p>
<p>If <code>dHRF &gt; 0</code>, <code>dHRF_as</code> controls whether the derivatives are
modeled as <code>"nuisance"</code> signals to regress out, <code>"tasks"</code>, or
<code>"auto"</code> (default) to treat them as tasks unless the total number of
columns in the design matrix would exceed five.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_hpf">hpf</code>, <code id="BayesGLM_cifti_+3A_dct">DCT</code></td>
<td>
<p>Add DCT bases to <code>nuisance</code> to apply a temporal
high-pass filter to the data? Only one of these arguments should be provided.
<code>hpf</code> should be the filter frequency; if it is provided, <code>TR</code>
must be provided too. The number of DCT bases to include will be computed
to yield a filter with as close a frequency to <code>hpf</code> as possible.
Alternatively, <code>DCT</code> can be provided to directly specify the number
of DCT bases to include.
</p>
<p>Default: <code>DCT=4</code>. For typical <code>TR</code>, four DCT bases amounts to a
lower frequency cutoff than the approximately .01 Hz used in most studies.
We selected this default to err on the side of retaining more low-frequency
information, but we recommend setting these arguments to values most
appropriate for the data analysis at hand.
</p>
<p>Using at least two DCT bases is as sufficient as using linear and quadratic
drift terms in the design matrix. So if DCT detrending is being used, there
is no need to add linear and quadratic drift terms to <code>nuisance</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_resamp_res">resamp_res</code></td>
<td>
<p>The number of vertices to which each cortical surface
should be resampled, or <code>NULL</code> to not resample. For computational
feasibility, a value of <code>10000</code> or lower is recommended.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_task_names">task_names</code></td>
<td>
<p>(Optional) Names of tasks represented in design matrix.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_session_names">session_names</code></td>
<td>
<p>(Optional, and only relevant for multi-session modeling)
Names of each session. Default: <code>NULL</code>. In <code><a href="#topic+BayesGLM">BayesGLM</a></code> this
argument will overwrite the names of the list entries in <code>data</code>, if
both exist.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_combine_sessions">combine_sessions</code></td>
<td>
<p>If multiple sessions are provided, should their data
be combined and analyzed as a single session?
</p>
<p>If <code>TRUE</code> (default), the multiple sessions will be concatenated along
time after scaling and nuisance regression, but before prewhitening. If
<code>FALSE</code>, each session will be analyzed separately, except that a single
estimate of the AR model coefficients for prewhitening is used, estimated
across all sessions.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_scale_bold">scale_BOLD</code></td>
<td>
<p>Option for scaling the BOLD response.
</p>
<p><code>"auto"</code> (default) will use <code>"mean"</code> scaling except if demeaned
data is detected (if any mean is less than one), in which case <code>"sd"</code>
scaling will be used instead.
</p>
<p><code>"mean"</code> scaling will scale the data to percent local signal change.
</p>
<p><code>"sd"</code> scaling will scale the data by local standard deviation.
</p>
<p><code>"none"</code> will only center the data, not scale it.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_scale_design">scale_design</code></td>
<td>
<p>Scale the design matrix by dividing each column by its
maximum and then subtracting the mean? Default: <code>TRUE</code>. If
<code>FALSE</code>, the design matrix is centered but not scaled.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_bayes">Bayes</code></td>
<td>
<p>If <code>TRUE</code> (default), will fit a spatial Bayesian GLM in
addition to the classical GLM. (The classical GLM is always returned.)</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_ar_order">ar_order</code></td>
<td>
<p>(numeric) Controls prewhitening. If greater than zero, this
should be a number indicating the order of the autoregressive model to use
for prewhitening. If zero, do not prewhiten. Default: <code>6</code>. For
multi-session models, note that a single AR model is used; the parameters
are estimated by averaging the estimates from each session.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_ar_smooth">ar_smooth</code></td>
<td>
<p>(numeric) FWHM parameter for smoothing the AR model
coefficient estimates for prewhitening. Remember that
<code class="reqn">\sigma = \frac{FWHM}{2*sqrt(2*log(2)}</code>. Set to <code>0</code> or <code>NULL</code>
to not do any smoothing. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_aic">aic</code></td>
<td>
<p>Use the AIC to select AR model order between <code>0</code> and
<code>ar_order</code>? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_num.threads">num.threads</code></td>
<td>
<p>The maximum number of threads to use for parallel
computations: prewhitening parameter estimation, and the inla-program model
estimation. Default: <code>4</code>. Note that parallel prewhitening requires the
<code>parallel</code> package.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_return_inla">return_INLA</code></td>
<td>
<p>Return the INLA model object? (It can be large.) Use
<code>"trimmed"</code> (default) to return only the more relevant results, which
is enough for both <code><a href="#topic+id_activations">id_activations</a></code> and <code>BayesGLM2</code>,
<code>"minimal"</code> to return just enough for <code><a href="#topic+BayesGLM2">BayesGLM2</a></code> but not
<code>id_activations</code>, or <code>"full"</code> to return the full output of
<code>inla</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_verbose">verbose</code></td>
<td>
<p>Should updates be printed? Use <code>1</code> (default) for
occasional updates, <code>2</code> for occasional updates as well as running INLA
in verbose mode (if applicable), or <code>0</code> for no updates.</p>
</td></tr>
<tr><td><code id="BayesGLM_cifti_+3A_meantol">meanTol</code>, <code id="BayesGLM_cifti_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Default: <code>1e-6</code> for both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"BayesGLM_cifti"</code>: a list with elements
</p>

<dl>
<dt>betas_Bayesian</dt><dd><p>The task coefficients for the Bayesian model.</p>
</dd>
<dt>betas_classical</dt><dd><p>The task coefficients for the classical model.</p>
</dd>
<dt>GLMs_Bayesian</dt><dd><p>The entire list of GLM results, except for parameters estimated for the classical model.</p>
</dd>
<dt>GLMs_classical</dt><dd><p>Parameters estimated for the classical model from the GLM.</p>
</dd>
<dt>session_names</dt><dd><p>The names of the sessions.</p>
</dd>
<dt>n_sess_orig</dt><dd><p>The number of sessions (before averaging, if applicable).</p>
</dd>
<dt>task_names</dt><dd><p>The task part of the design matrix, after centering and scaling, but before any nuisance regression or prewhitening.</p>
</dd>
</dl>



<h3>INLA latent fields limit</h3>

<p>INLA computation times increase greatly when the number of columns in the
design matrix exceeds five. So if there are more than five tasks, or
three or more tasks each with its temporal derivative being modeled as a
task, <code>BayesGLM</code> will raise a warning. In cases like the latter, we
recommend modeling the temporal derivatives as nuisance signals using the
<code>nuisance</code> argument, rather than modeling them as tasks.
</p>


<h3>Connectome Workbench Requirement</h3>

<p>This function uses a system wrapper for the 'wb_command' executable. The
user must first download and install the Connectome Workbench, available
from https://www.humanconnectome.org/software/get-connectome-workbench .
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='BayesGLM2'>Group-level Bayesian GLM</h2><span id='topic+BayesGLM2'></span><span id='topic+BayesGLM_group'></span>

<h3>Description</h3>

<p>Performs group-level Bayesian GLM estimation and inference using the joint
approach described in Mejia et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM2(
  results,
  contrasts = NULL,
  quantiles = NULL,
  excursion_type = NULL,
  contrast_names = NULL,
  gamma = 0,
  alpha = 0.05,
  nsamp_theta = 50,
  nsamp_beta = 100,
  num_cores = NULL,
  verbose = 1
)

BayesGLM_group(
  results,
  contrasts = NULL,
  quantiles = NULL,
  excursion_type = NULL,
  gamma = 0,
  alpha = 0.05,
  nsamp_theta = 50,
  nsamp_beta = 100,
  num_cores = NULL,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesGLM2_+3A_results">results</code></td>
<td>
<p>Either (1) a length <code class="reqn">N</code> list of <code>"BayesGLM"</code> objects,
or (2) a length <code class="reqn">N</code> character vector of files storing <code>"BayesGLM"</code>
objects saved with <code><a href="base.html#topic+saveRDS">saveRDS</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_contrasts">contrasts</code></td>
<td>
<p>(Optional) A list of contrast vectors that specify the
group-level summaries of interest. If <code>NULL</code>, use contrasts that compute
the average of each field (task HRF) across subjects and sessions.
</p>
<p>Each contrast vector is length <code class="reqn">K * S * N</code> vector specifying a
group-level summary of interest, where <code class="reqn">K</code> is the number
of fields (task HRFs), <code class="reqn">S</code> is the number of sessions, and <code class="reqn">N</code> is the
number of subjects. For a single subject-session the contrast
for the first field would be:
</p>
<p><code>contrast1 &lt;- c(1, rep(0, K-1))</code>
</p>
<p>and so the full contrast vector representing the group average across
sessions and subjects for the first task would be:
</p>
<p><code>rep(rep(contrast1, S), N) /S /N</code>.
</p>
<p>To obtain the group average for the first task, for just the first sessions
from each subject:
</p>
<p><code>rep(c(contrast1, rep(0, K*(S-1))), N) /N</code>.
</p>
<p>To obtain the mean difference between the first and second sessions, for the
first task:
</p>
<p><code>rep(c(contrast1, -contrast1, rep(0, K-2)), N) /N</code>.
</p>
<p>To obtain the mean across sessions of the first task, just for the first
subject:
</p>
<p><code>c(rep(contrast1, S-1), rep(0, K*S*(N-1)) /S</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_quantiles">quantiles</code></td>
<td>
<p>(Optional) Vector of posterior quantiles to return in
addition to the posterior mean.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_excursion_type">excursion_type</code></td>
<td>
<p>(For inference only) The type of excursion function for
the contrast (&quot;&gt;&quot;, &quot;&lt;&quot;, &quot;!=&quot;), or a vector thereof (each element
corresponding to one contrast).  If <code>NULL</code>, no inference performed.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_contrast_names">contrast_names</code></td>
<td>
<p>(Optional) Names of contrasts.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_gamma">gamma</code></td>
<td>
<p>(For inference only) Activation threshold for the excursion set,
or a vector thereof (each element corresponding to one contrast). Default:
<code>0</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_alpha">alpha</code></td>
<td>
<p>(For inference only) Significance level for activation for the
excursion set, or a vector thereof (each element corresponding to one
contrast). Default: <code>.05</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_nsamp_theta">nsamp_theta</code></td>
<td>
<p>Number of theta values to sample from posterior. Default:
<code>50</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_nsamp_beta">nsamp_beta</code></td>
<td>
<p>Number of beta vectors to sample conditional on each theta
value sampled. Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use for sampling betas in parallel. If
<code>NULL</code> (default), do not run in parallel.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_verbose">verbose</code></td>
<td>
<p>Should updates be printed? Use <code>1</code> (default) for
occasional updates, <code>2</code> for occasional updates as well as running INLA
in verbose mode (if applicable), or <code>0</code> for no updates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimates, PPMs and areas of activation for each contrast.
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='beta.posterior.thetasamp'>Beta posterior theta sampling</h2><span id='topic+beta.posterior.thetasamp'></span>

<h3>Description</h3>

<p>Internal function used in joint approach to group-analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.posterior.thetasamp(
  theta,
  spde,
  Xcros,
  Xycros,
  contrasts,
  quantiles,
  excursion_type,
  gamma,
  alpha,
  nsamp_beta = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.posterior.thetasamp_+3A_theta">theta</code></td>
<td>
<p>A single sample of theta (hyperparameters) from q(theta|y)</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_spde">spde</code></td>
<td>
<p>A SPDE object from inla.spde2.matern() function.</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_xcros">Xcros</code></td>
<td>
<p>A crossproduct of design matrix.</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_xycros">Xycros</code></td>
<td>
<p>A crossproduct of design matrix and BOLD y.</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_contrasts">contrasts</code></td>
<td>
<p>A list of vectors of length M*K specifying the contrasts of interest.</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of posterior quantiles to return in addition to the posterior mean</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_excursion_type">excursion_type</code></td>
<td>
<p>Vector of excursion function type (&quot;&gt;&quot;, &quot;&lt;&quot;, &quot;!=&quot;) for each contrast</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_gamma">gamma</code></td>
<td>
<p>Vector of activation thresholds for each contrast</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for activation for the excursion sets</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_nsamp_beta">nsamp_beta</code></td>
<td>
<p>The number of samples to draw from full conditional of beta given the current value of theta (p(beta|theta,y))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing <code>mu</code>, <code>quantiles</code>, and <code>F</code>
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='cAIC'>Corrected AIC To-Do</h2><span id='topic+cAIC'></span>

<h3>Description</h3>

<p>Get corrected AIC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cAIC(...)
</code></pre>

<hr>
<h2 id='cderiv'>Central derivative</h2><span id='topic+cderiv'></span>

<h3>Description</h3>

<p>Take the central derivative of numeric vectors by averaging the forward and
backward differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cderiv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cderiv_+3A_x">x</code></td>
<td>
<p>A numeric matrix, or a vector which will be converted to a
single-column matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector the same dimensions as <code>x</code>, with the
derivative taken for each column of <code>x</code>. The first and last rows may
need to be deleted, depending on the application.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cderiv(seq(5))
stopifnot(all(x == c(.5, 1, 1, 1, .5)))

</code></pre>

<hr>
<h2 id='check_INLA'>Check INLA and PARDISO</h2><span id='topic+check_INLA'></span>

<h3>Description</h3>

<p>Check INLA and PARDISO
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_INLA(require_PARDISO = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_INLA_+3A_require_pardiso">require_PARDISO</code></td>
<td>
<p>Is PARDISO required? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='cholQsample'>Sample from the multivariate normal distribution with Cholesky(Q)</h2><span id='topic+cholQsample'></span>

<h3>Description</h3>

<p>Sample from the multivariate normal distribution with Cholesky(Q)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cholQsample(n, mu, cholQ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cholQsample_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="cholQsample_+3A_mu">mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id="cholQsample_+3A_cholq">cholQ</code></td>
<td>
<p>Cholesky decomposition of the precision (found via <code>Matrix::Cholesky(Q)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n \times p</code> matrix of samples from the MVN distribution,
where <code class="reqn">p</code> is the length of <code>mu</code>.
</p>

<hr>
<h2 id='combine_sessions_Param'>combine_sessions</h2><span id='topic+combine_sessions_Param'></span>

<h3>Description</h3>

<p>combine_sessions
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_sessions_Param_+3A_combine_sessions">combine_sessions</code></td>
<td>
<p>If multiple sessions are provided, should their data
be combined and analyzed as a single session?
</p>
<p>If <code>TRUE</code> (default), the multiple sessions will be concatenated along
time after scaling and nuisance regression, but before prewhitening. If
<code>FALSE</code>, each session will be analyzed separately, except that a single
estimate of the AR model coefficients for prewhitening is used, estimated
across all sessions.</p>
</td></tr>
</table>

<hr>
<h2 id='contrasts_Param'>contrasts</h2><span id='topic+contrasts_Param'></span>

<h3>Description</h3>

<p>contrasts
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="contrasts_Param_+3A_contrasts">contrasts</code></td>
<td>
<p>List of contrast vectors to be passed to <code>inla::inla</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='create_listRcpp'>Function to prepare objects for use in Rcpp functions</h2><span id='topic+create_listRcpp'></span>

<h3>Description</h3>

<p>Function to prepare objects for use in Rcpp functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_listRcpp(spde)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_listRcpp_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SPDE matrices with the correct data formats
</p>

<hr>
<h2 id='ELL'>Expected log-likelihood function</h2><span id='topic+ELL'></span>

<h3>Description</h3>

<p>Expected log-likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ELL(Q, sigma2, model_data, Psi, mu, Sigma, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ELL_+3A_q">Q</code></td>
<td>
<p>precision matrix</p>
</td></tr>
<tr><td><code id="ELL_+3A_sigma2">sigma2</code></td>
<td>
<p>noise variance</p>
</td></tr>
<tr><td><code id="ELL_+3A_model_data">model_data</code></td>
<td>
<p>list with X and y</p>
</td></tr>
<tr><td><code id="ELL_+3A_psi">Psi</code></td>
<td>
<p>data locations to mesh locations matrix</p>
</td></tr>
<tr><td><code id="ELL_+3A_mu">mu</code></td>
<td>
<p>posterior mean of w</p>
</td></tr>
<tr><td><code id="ELL_+3A_sigma">Sigma</code></td>
<td>
<p>posterior covariance of w</p>
</td></tr>
<tr><td><code id="ELL_+3A_a">A</code></td>
<td>
<p>crossprod(X%*%Psi)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar expected log-likelihood
</p>

<hr>
<h2 id='EM_Param'>EM</h2><span id='topic+EM_Param'></span>

<h3>Description</h3>

<p>EM
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM_Param_+3A_em">EM</code></td>
<td>
<p>(logical) Should the EM implementation of the Bayesian GLM be used?
Default: <code>FALSE</code>. This method is still in development.</p>
</td></tr>
</table>

<hr>
<h2 id='emTol_Param'>emTol</h2><span id='topic+emTol_Param'></span>

<h3>Description</h3>

<p>emTol
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="emTol_Param_+3A_emtol">emTol</code></td>
<td>
<p>The stopping tolerance for the EM algorithm. Default:
<code>1e-3</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_estimates'>Extract Estimates of Activation</h2><span id='topic+extract_estimates'></span>

<h3>Description</h3>

<p>Obtains the posterior mean or other summary statistic for each latent field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_estimates(INLA_model_obj, session_names, mask = NULL, stat = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_estimates_+3A_inla_model_obj">INLA_model_obj</code></td>
<td>
<p>An object of class <code>"inla"</code>, a result of a call to
<code>inla</code>.</p>
</td></tr>
<tr><td><code id="extract_estimates_+3A_session_names">session_names</code></td>
<td>
<p>Vector of fMRI session names</p>
</td></tr>
<tr><td><code id="extract_estimates_+3A_mask">mask</code></td>
<td>
<p>(Optional) Original mask applied to data before model fitting</p>
</td></tr>
<tr><td><code id="extract_estimates_+3A_stat">stat</code></td>
<td>
<p>A string representing the posterior summary statistic to be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates from inla model
</p>

<hr>
<h2 id='F.logwt'>F logwt</h2><span id='topic+F.logwt'></span>

<h3>Description</h3>

<p>Internal function used in joint approach to group-analysis for combining across models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.logwt(theta, spde, mu_theta, Q_theta, nN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.logwt_+3A_theta">theta</code></td>
<td>
<p>A vector of hyperparameter values at which to compute the posterior log density</p>
</td></tr>
<tr><td><code id="F.logwt_+3A_spde">spde</code></td>
<td>
<p>A SPDE object from inla.spde2.matern() function, determines prior precision matrix</p>
</td></tr>
<tr><td><code id="F.logwt_+3A_mu_theta">mu_theta</code></td>
<td>
<p>Posterior mean from combined subject-level models.</p>
</td></tr>
<tr><td><code id="F.logwt_+3A_q_theta">Q_theta</code></td>
<td>
<p>Posterior precision matrix from combined subject-level models.</p>
</td></tr>
<tr><td><code id="F.logwt_+3A_nn">nN</code></td>
<td>
<p>Number of subjects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The prior density
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='faces_Param'>faces</h2><span id='topic+faces_Param'></span>

<h3>Description</h3>

<p>faces
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="faces_Param_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
</table>

<hr>
<h2 id='galerkin_db'>Create FEM matrices</h2><span id='topic+galerkin_db'></span>

<h3>Description</h3>

<p>Create FEM matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galerkin_db(FV, P, surface = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="galerkin_db_+3A_fv">FV</code></td>
<td>
<p>Matrix of faces in triangularization</p>
</td></tr>
<tr><td><code id="galerkin_db_+3A_p">P</code></td>
<td>
<p>Matrix of vertex locations in triangularization</p>
</td></tr>
<tr><td><code id="galerkin_db_+3A_surface">surface</code></td>
<td>
<p>(logical) Will this create the SPDE matrices for a surface
or not?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices C and G appearing in sparse SPDE precision
</p>

<hr>
<h2 id='get_posterior_densities'>Extracts posterior density estimates for hyperparameters</h2><span id='topic+get_posterior_densities'></span>

<h3>Description</h3>

<p>Extracts posterior density estimates for hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_posterior_densities(INLA_model_obj, spde, task_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_posterior_densities_+3A_inla_model_obj">INLA_model_obj</code></td>
<td>
<p>An object of class <code>"inla"</code>, a result of a call to
<code>inla()</code></p>
</td></tr>
<tr><td><code id="get_posterior_densities_+3A_spde">spde</code></td>
<td>
<p>The model used for the latent fields in the <code>inla()</code> call,
an object of class <code>"inla.spde"</code></p>
</td></tr>
<tr><td><code id="get_posterior_densities_+3A_task_names">task_names</code></td>
<td>
<p>Descriptive names of model regressors (tasks).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Long-form data frame containing posterior densities for the
hyperparameters associated with each latent field
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='GLMEM_fixptseparate'>Fixed point function for the joint BayesGLMEM update algorithm</h2><span id='topic+GLMEM_fixptseparate'></span>

<h3>Description</h3>

<p>Fixed point function for the joint BayesGLMEM update algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMEM_fixptseparate(theta, spde, model_data, Psi, K, A, cl, Ns = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMEM_fixptseparate_+3A_theta">theta</code></td>
<td>
<p>a list containing kappa2, phi, and sigma2, in that order</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_spde">spde</code></td>
<td>
<p>the spde object</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_model_data">model_data</code></td>
<td>
<p>the model_data object containing <code>y</code> and <code>X</code></p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_psi">Psi</code></td>
<td>
<p>a conversion matrix (N by V) (or N by n)</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_k">K</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_a">A</code></td>
<td>
<p>The value for Matrix::crossprod(X%*%Psi) (saves time on computation)</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_cl">cl</code></td>
<td>
<p>parallelization cluster</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_ns">Ns</code></td>
<td>
<p>The number of samples used to approximate traces using the Hutchinson
estimator. If set to 0, the exact trace is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the same length as <code>theta</code>, the EM updates
</p>

<hr>
<h2 id='GLMEM_objfn'>Objective function for the BayesGLM EM algorithm</h2><span id='topic+GLMEM_objfn'></span>

<h3>Description</h3>

<p>This returns the negative of the expected log-likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMEM_objfn(theta, spde, model_data, Psi, K, A, num.threads = NULL, Ns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMEM_objfn_+3A_theta">theta</code></td>
<td>
<p>a vector containing kappa2, phi, and sigma2, in that order</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_spde">spde</code></td>
<td>
<p>the spde object</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_model_data">model_data</code></td>
<td>
<p>the model_data object containing <code>y</code> and <code>X</code></p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_psi">Psi</code></td>
<td>
<p>a conversion matrix (N by V) (or N by n)</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_k">K</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_a">A</code></td>
<td>
<p>The value for Matrix::crossprod(X%*%Psi) (saves time on computation)</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_num.threads">num.threads</code></td>
<td>
<p>Needed for SQUAREM (it is an argument to the fixed-point functions)</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_ns">Ns</code></td>
<td>
<p>The number of samples used to approximate traces using the Hutchinson
estimator. If set to 0, the exact trace is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value for the negative expected log-likelihood
</p>

<hr>
<h2 id='HRF'>Canonical (double-gamma) HRF</h2><span id='topic+HRF'></span>

<h3>Description</h3>

<p>Calculate the HRF from a time vector and parameters. Optionally compute the
first or second derivative of the HRF instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HRF(t, deriv = 0, a1 = 6, b1 = 0.9, a2 = 12, b2 = 0.9, c = 0.35)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HRF_+3A_t">t</code></td>
<td>
<p>time vector</p>
</td></tr>
<tr><td><code id="HRF_+3A_deriv">deriv</code></td>
<td>
<p><code>0</code> (default) for the HRF, <code>1</code> for the first derivative
of the HRF, or <code>2</code> for the second derivative of the HRF.</p>
</td></tr>
<tr><td><code id="HRF_+3A_a1">a1</code></td>
<td>
<p>delay of response. Default: <code>6</code></p>
</td></tr>
<tr><td><code id="HRF_+3A_b1">b1</code></td>
<td>
<p>response dispersion. Default: <code>0.9</code></p>
</td></tr>
<tr><td><code id="HRF_+3A_a2">a2</code></td>
<td>
<p>delay of undershoot. Default: <code>12</code></p>
</td></tr>
<tr><td><code id="HRF_+3A_b2">b2</code></td>
<td>
<p>dispersion of undershoot. Default: <code>0.9</code></p>
</td></tr>
<tr><td><code id="HRF_+3A_c">c</code></td>
<td>
<p>scale of undershoot. Default: <code>0.35</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>HRF vector (or dHRF, or d2HRF) corresponding to time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>downsample &lt;- 100
HRF(seq(0, 30, by=1/downsample))

</code></pre>

<hr>
<h2 id='id_activations'>Identify task activations</h2><span id='topic+id_activations'></span>

<h3>Description</h3>

<p>Identify areas of activation for each task from the result of <code>BayesGLM</code>
or <code>BayesGLM_cifti</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_activations(
  model_obj,
  tasks = NULL,
  sessions = NULL,
  method = c("Bayesian", "classical"),
  alpha = 0.05,
  gamma = NULL,
  correction = c("FWER", "FDR", "none"),
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_activations_+3A_model_obj">model_obj</code></td>
<td>
<p>Result of <code>BayesGLM</code> or <code>BayesGLM_cifti</code> model
call, of class <code>"BayesGLM"</code> or <code>"BayesGLM_cifti"</code>.</p>
</td></tr>
<tr><td><code id="id_activations_+3A_tasks">tasks</code></td>
<td>
<p>The task(s) to identify activations for. Give either the name(s)
as a character vector, or the numerical indices. If <code>NULL</code> (default),
analyze all tasks.</p>
</td></tr>
<tr><td><code id="id_activations_+3A_sessions">sessions</code></td>
<td>
<p>The session(s) to identify activations for. Give either the
name(s) as a character vector, or the numerical indices. If <code>NULL</code>
(default), analyze the first session.
</p>
<p>Currently, if multiple sessions are provided, activations are identified
separately for each session. (Information is not combined between the
different sessions.)</p>
</td></tr>
<tr><td><code id="id_activations_+3A_method">method</code></td>
<td>
<p><code>"Bayesian"</code> (default) or <code>"classical"</code>. If
<code>model_obj</code> does not have Bayesian results because <code>Bayes</code> was set
to <code>FALSE</code>, only the <code>"classical"</code> method can be used.</p>
</td></tr>
<tr><td><code id="id_activations_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default: <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="id_activations_+3A_gamma">gamma</code></td>
<td>
<p>Activation threshold, for example <code>1</code> for 1\
change if <code>scale_BOLD=="mean"</code> during model estimation. Setting a
<code>gamma</code> is required for the Bayesian method; <code>NULL</code> (default)
will use a <code>gamma</code> of zero for the classical method.</p>
</td></tr>
<tr><td><code id="id_activations_+3A_correction">correction</code></td>
<td>
<p>For the classical method only: Type of multiple comparisons
correction: <code>"FWER"</code> (Bonferroni correction, the default), <code>"FDR"</code>
(Benjamini Hochberg), or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="id_activations_+3A_verbose">verbose</code></td>
<td>
<p>Should updates be printed? Use <code>1</code> (default) for
occasional updates, <code>2</code> for occasional updates as well as running INLA
in verbose mode (if applicable), or <code>0</code> for no updates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>"act_BayesGLM"</code> or <code>"act_BayesGLM_cifti"</code> object, a
list which indicates the activated locations along with related information.
</p>

<hr>
<h2 id='id_activations.classical'>Identification of areas of activation in a General Linear Model using classical methods</h2><span id='topic+id_activations.classical'></span>

<h3>Description</h3>

<p>Identification of areas of activation in a General Linear Model using classical methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_activations.classical(
  model_obj,
  tasks,
  session,
  alpha = 0.05,
  gamma = 0,
  correction = c("FWER", "FDR", "none"),
  mesh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_activations.classical_+3A_model_obj">model_obj</code></td>
<td>
<p>A <code>BayesGLM</code> object</p>
</td></tr>
<tr><td><code id="id_activations.classical_+3A_tasks">tasks</code>, <code id="id_activations.classical_+3A_session">session</code>, <code id="id_activations.classical_+3A_alpha">alpha</code>, <code id="id_activations.classical_+3A_gamma">gamma</code></td>
<td>
<p>See <code><a href="#topic+id_activations">id_activations</a></code>.</p>
</td></tr>
<tr><td><code id="id_activations.classical_+3A_correction">correction</code></td>
<td>
<p>(character) Either 'FWER' or 'FDR'. 'FWER' corresponds to the
family-wise error rate with Bonferroni correction, and 'FDR' refers to the
false discovery rate using Benjamini-Hochberg.</p>
</td></tr>
<tr><td><code id="id_activations.classical_+3A_mesh">mesh</code></td>
<td>
<p>(Optional) An <code>"inla.mesh"</code> object (see <code><a href="#topic+make_mesh">make_mesh</a></code> for
surface data). Only necessary for computing surface areas of identified activations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix corresponding to the
0-1 activation status for the model coefficients.
</p>

<hr>
<h2 id='id_activations.posterior'>Identify activations using joint posterior probabilities</h2><span id='topic+id_activations.posterior'></span>

<h3>Description</h3>

<p>Identifies areas of activation given an activation threshold and significance
level using joint posterior probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_activations.posterior(model_obj, tasks, session, alpha = 0.05, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_activations.posterior_+3A_model_obj">model_obj</code></td>
<td>
<p>Result of <code>BayesGLM</code>, of class <code>"BayesGLM"</code>.</p>
</td></tr>
<tr><td><code id="id_activations.posterior_+3A_tasks">tasks</code>, <code id="id_activations.posterior_+3A_session">session</code>, <code id="id_activations.posterior_+3A_alpha">alpha</code>, <code id="id_activations.posterior_+3A_gamma">gamma</code></td>
<td>
<p>See <code><a href="#topic+id_activations">id_activations</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given latent field, identifies locations that exceed a certain activation
threshold (e.g. 1 percent signal change) at a given significance level, based on the joint
posterior distribution of the latent field.
</p>


<h3>Value</h3>

<p>A list with two elements: <code>active</code>, which gives a matrix of zeros
and ones of the same dimension as <code>model_obj$task_estimates${session}</code>,
and <code>excur_result</code>, an object of class <code>"excurobj"</code> (see <code><a href="excursions.html#topic+excursions.inla">excursions.inla</a></code> for
more information).
</p>

<hr>
<h2 id='init_fixpt'>The fix point function for the initialization of kappa2 and phi</h2><span id='topic+init_fixpt'></span>

<h3>Description</h3>

<p>The fix point function for the initialization of kappa2 and phi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_fixpt(theta, spde, beta_hat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_fixpt_+3A_theta">theta</code></td>
<td>
<p>a vector c(kappa2,phi)</p>
</td></tr>
<tr><td><code id="init_fixpt_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="init_fixpt_+3A_beta_hat">beta_hat</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar
</p>

<hr>
<h2 id='init_objfn'>Objective function for the initialization of kappa2 and phi</h2><span id='topic+init_objfn'></span>

<h3>Description</h3>

<p>Objective function for the initialization of kappa2 and phi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_objfn(theta, spde, beta_hat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_objfn_+3A_theta">theta</code></td>
<td>
<p>a vector c(kappa2,phi)</p>
</td></tr>
<tr><td><code id="init_objfn_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="init_objfn_+3A_beta_hat">beta_hat</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar
</p>

<hr>
<h2 id='INLA_deps'>Import INLA dependencies</h2><span id='topic+INLA_deps'></span>

<h3>Description</h3>

<p>Roxygen entry for additional INLA dependencies
</p>

<hr>
<h2 id='INLA_Description'>INLA</h2><span id='topic+INLA_Description'></span>

<h3>Description</h3>

<p>INLA
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='is.a_session'>Validate an individual session in a <code>"BfMRI.sess"</code> object.</h2><span id='topic+is.a_session'></span>

<h3>Description</h3>

<p>Check if object is valid for a list entry in <code>"BfMRI.sess"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.a_session(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.a_session_+3A_x">x</code></td>
<td>
<p>The putative entry in a <code>"BfMRI.sess"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A valid entry in a <code>"BfMRI.sess"</code> object is a list with these named
fields:
</p>

<dl>
<dt>BOLD</dt><dd><p>a <code class="reqn">T \times V</code> BOLD matrix. Rows are time points; columns are data locations (vertices/voxels).</p>
</dd>
<dt>design</dt><dd><p>a <code class="reqn">T \times K</code> matrix containing the <code class="reqn">K</code> task regressors. See <code><a href="#topic+make_HRFs">make_HRFs</a></code>.</p>
</dd>
<dt>nuisance</dt><dd><p>an optional argument. <code class="reqn">T \times J</code> matrix containing the <code class="reqn">L</code> nuisance regressors.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Logical. Is <code>x</code> a valid entry in a <code>"BfMRI.sess"</code> object?
</p>

<hr>
<h2 id='is.BfMRI.sess'>Validate a <code>"BfMRI.sess"</code> object.</h2><span id='topic+is.BfMRI.sess'></span>

<h3>Description</h3>

<p>Check if object is valid for a <code>"BfMRI.sess"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.BfMRI.sess(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.BfMRI.sess_+3A_x">x</code></td>
<td>
<p>The putative <code>"BfMRI.sess"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>"BfMRI.sess"</code> object is a list of length <code class="reqn">S</code>, where <code class="reqn">S</code> is
the number of sessions in the analysis. Each list entry corresponds to a
separate session, and should itself be a list with these named fields:
</p>

<dl>
<dt>BOLD</dt><dd><p>a <code class="reqn">T \times V</code> BOLD matrix. Rows are time points; columns are data locations (vertices/voxels).</p>
</dd>
<dt>design</dt><dd><p>a <code class="reqn">T \times K</code> matrix containing the <code class="reqn">K</code> task regressors. See <code><a href="#topic+make_HRFs">make_HRFs</a></code>.</p>
</dd>
<dt>nuisance</dt><dd><p>an optional argument. <code class="reqn">T \times J</code> matrix containing the <code class="reqn">L</code> nuisance regressors.</p>
</dd>
</dl>

<p>In addition, all sessions must have the same number of data locations, <code class="reqn">V</code>, and tasks, <code class="reqn">K</code>.
</p>


<h3>Value</h3>

<p>Logical. Is <code>x</code> a valid <code>"BfMRI.sess"</code> object?
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nT &lt;- 180
nV &lt;- 700 
BOLD1 &lt;- matrix(rnorm(nT*nV), nrow=nT)
BOLD2 &lt;- matrix(rnorm(nT*nV), nrow=nT)
onsets1 &lt;- list(taskA=cbind(c(2,17,23),4)) # one task, 3 four sec-long stimuli
onsets2 &lt;- list(taskA=cbind(c(1,18,25),4))
TR &lt;- .72 # .72 seconds per volume, or (1/.72) Hz
duration &lt;- nT # session is 180 volumes long (180*.72 seconds long)
design1 &lt;- make_HRFs(onsets1, TR, duration)$design
design2 &lt;- make_HRFs(onsets2, TR, duration)$design
x &lt;- list(
 sessionOne = list(BOLD=BOLD1, design=design1),
 sessionTwo = list(BOLD=BOLD2, design=design2)
)
stopifnot(is.BfMRI.sess(x))

</code></pre>

<hr>
<h2 id='kappa_init_fn'>Function to optimize over kappa2</h2><span id='topic+kappa_init_fn'></span>

<h3>Description</h3>

<p>Function to optimize over kappa2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappa_init_fn(kappa2, phi, spde, beta_hat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kappa_init_fn_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="kappa_init_fn_+3A_phi">phi</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="kappa_init_fn_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="kappa_init_fn_+3A_beta_hat">beta_hat</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='make_data_list'>Make data list for <code>estimate_model</code></h2><span id='topic+make_data_list'></span>

<h3>Description</h3>

<p>Make data list to be passed to <code>estimate_model</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_data_list(y, X, betas, repls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_data_list_+3A_y">y</code></td>
<td>
<p>Vectorized BOLD data (all voxels, sessions, etc.)</p>
</td></tr>
<tr><td><code id="make_data_list_+3A_x">X</code></td>
<td>
<p>List (length = number of sessions) of sparse design matrices size TVxVK from each session, each created using <code>organize_data()</code></p>
</td></tr>
<tr><td><code id="make_data_list_+3A_betas">betas</code></td>
<td>
<p>List (length = number of tasks) of bbeta objects from organize_replicates</p>
</td></tr>
<tr><td><code id="make_data_list_+3A_repls">repls</code></td>
<td>
<p>List (length = number of tasks) of repl objects from organize_replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>

<hr>
<h2 id='make_HRFs'>Make HRFs</h2><span id='topic+make_HRFs'></span>

<h3>Description</h3>

<p>Create HRF design matrix columns from onsets and durations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_HRFs(
  onsets,
  TR,
  duration,
  dHRF = c(0, 1, 2),
  dHRF_as = c("auto", "nuisance", "task"),
  downsample = 100,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_HRFs_+3A_onsets">onsets</code></td>
<td>
<p><code class="reqn">L</code>-length list in which the name of each element is the
name of the corresponding task, and the value of each element is a matrix of
onsets (first column) and durations (second column) for each stimuli (each
row) of the corresponding task.</p>
</td></tr>
<tr><td><code id="make_HRFs_+3A_tr">TR</code></td>
<td>
<p>Temporal resolution of the data, in seconds.</p>
</td></tr>
<tr><td><code id="make_HRFs_+3A_duration">duration</code></td>
<td>
<p>The number of volumes in the fMRI data.</p>
</td></tr>
<tr><td><code id="make_HRFs_+3A_dhrf">dHRF</code></td>
<td>
<p>Set to <code>1</code> to add the temporal derivative of each column
in the design matrix, <code>2</code> to add the second derivatives too, or
<code>0</code> to not add any columns. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="make_HRFs_+3A_dhrf_as">dHRF_as</code></td>
<td>
<p>Only applies if <code>dHRF &gt; 0</code>. Model the temporal
derivatives as <code>"nuisance"</code> signals to regress out, <code>"tasks"</code>, or
<code>"auto"</code> to treat them as tasks unless the total number of columns in
the design matrix (i.e. the total number of tasks, times <code>dHRF+1</code>), would be
<code>&gt;=10</code>, the limit for INLA.</p>
</td></tr>
<tr><td><code id="make_HRFs_+3A_downsample">downsample</code></td>
<td>
<p>Downsample factor for convolving stimulus boxcar or stick
function with canonical HRF. Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="make_HRFs_+3A_verbose">verbose</code></td>
<td>
<p>If applicable, print a message saying how the HRF derivatives
will be modeled? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the design matrix and/or the nuisance matrix containing the
HRF-convolved stimuli as columns, depending on <code>dHRF_as</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>onsets &lt;- list(taskA=cbind(c(2,17,23),4)) # one task, 3 four sec-long stimuli
TR &lt;- .72 # .72 seconds per volume, or (1/.72) Hz
duration &lt;- 300 # session is 300 volumes long (300*.72 seconds long)
make_HRFs(onsets, TR, duration)

</code></pre>

<hr>
<h2 id='make_mask'>Mask out invalid data</h2><span id='topic+make_mask'></span>

<h3>Description</h3>

<p>Mask out data locations that are invalid (missing data, low mean, or low
variance) for any session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mask(data, meanTol = 1e-06, varTol = 1e-06, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mask_+3A_data">data</code></td>
<td>
<p>A list of sessions, where each session is a list with elements
<code>BOLD</code>, <code>design</code>, and optionally <code>nuisance</code>. See
<code>?is.BfMRI.sess</code> for details.</p>
</td></tr>
<tr><td><code id="make_mask_+3A_meantol">meanTol</code>, <code id="make_mask_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Defaults: <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="make_mask_+3A_verbose">verbose</code></td>
<td>
<p>Print messages counting how many locations are removed?
Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating locations that are valid across all sessions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nT &lt;- 30
nV &lt;- 400
BOLD1 &lt;- matrix(rnorm(nT*nV), nrow=nT)
BOLD1[,seq(30,50)] &lt;- NA
BOLD2 &lt;- matrix(rnorm(nT*nV), nrow=nT)
BOLD2[,65] &lt;- BOLD2[,65] / 1e10
data &lt;- list(sess1=list(BOLD=BOLD1, design=NULL), sess2=list(BOLD=BOLD2, design=NULL))
make_mask(data)

</code></pre>

<hr>
<h2 id='make_mesh'>Make Mesh</h2><span id='topic+make_mesh'></span>

<h3>Description</h3>

<p>Make INLA triangular mesh from faces and vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mesh(vertices, faces, use_INLA = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mesh_+3A_vertices">vertices</code></td>
<td>
<p>A <code class="reqn">V \times 3</code> matrix, where each row contains the Euclidean
coordinates at which a given vertex in the mesh is located. <code class="reqn">V</code> is the
number of vertices in the mesh</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_use_inla">use_INLA</code></td>
<td>
<p>(logical) Use the INLA package to make the mesh? Default:
<code>TRUE</code>. Otherwise, mesh construction is based on an internal function,
<code>galerkin_db</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>INLA triangular mesh
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='make_Q'>Make the full SPDE precision based on theta, the spde, and the number of sessions</h2><span id='topic+make_Q'></span>

<h3>Description</h3>

<p>Make the full SPDE precision based on theta, the spde, and the number of sessions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Q(theta, spde, n_sess)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Q_+3A_theta">theta</code></td>
<td>
<p>the hyperparameter theta vector of length K * 2 + 1, where the
first K elements are the kappas, the next K elements are the phis, and the
last element (unused here) corresponds to sigma2</p>
</td></tr>
<tr><td><code id="make_Q_+3A_spde">spde</code></td>
<td>
<p>a list containing three spde elements: Cmat, Gmat, and GtCinvG</p>
</td></tr>
<tr><td><code id="make_Q_+3A_n_sess">n_sess</code></td>
<td>
<p>The integer number of sessions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An SPDE prior matrix
</p>

<hr>
<h2 id='mask_Param_vertices'>mask: vertices</h2><span id='topic+mask_Param_vertices'></span>

<h3>Description</h3>

<p>mask: vertices
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_Param_vertices_+3A_mask">mask</code></td>
<td>
<p>A length <code class="reqn">V</code> logical vector indicating if each vertex is
within the input mask.</p>
</td></tr>
</table>

<hr>
<h2 id='max.threads_Param'>max.threads</h2><span id='topic+max.threads_Param'></span>

<h3>Description</h3>

<p>max.threads
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="max.threads_Param_+3A_max.threads">max.threads</code></td>
<td>
<p>The maximum number of threads to use in the inla-program
for model estimation. <code>0</code> (default) will use the maximum number of
threads allowed by the system.</p>
</td></tr>
</table>

<hr>
<h2 id='mesh_Param_either'>mesh: either</h2><span id='topic+mesh_Param_either'></span>

<h3>Description</h3>

<p>mesh: either
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh_Param_either_+3A_mesh">mesh</code></td>
<td>
<p>An <code>"inla.mesh"</code> object (see <code><a href="#topic+make_mesh">make_mesh</a></code> for
surface data)</p>
</td></tr>
</table>

<hr>
<h2 id='mesh_Param_inla'>mesh: INLA only</h2><span id='topic+mesh_Param_inla'></span>

<h3>Description</h3>

<p>mesh: INLA only
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh_Param_inla_+3A_mesh">mesh</code></td>
<td>
<p>An <code>"inla.mesh"</code> object (see <code><a href="#topic+make_mesh">make_mesh</a></code> for
surface data).</p>
</td></tr>
</table>

<hr>
<h2 id='neg_kappa_fn'>The negative of the objective function for kappa</h2><span id='topic+neg_kappa_fn'></span>

<h3>Description</h3>

<p>The negative of the objective function for kappa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_kappa_fn(kappa2, spde, phi, Sigma, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neg_kappa_fn_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="neg_kappa_fn_+3A_phi">phi</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn_+3A_sigma">Sigma</code></td>
<td>
<p>dgCMatrix</p>
</td></tr>
<tr><td><code id="neg_kappa_fn_+3A_mu">mu</code></td>
<td>
<p>dgeMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='neg_kappa_fn2'>The negative of the objective function for kappa without Sig_inv</h2><span id='topic+neg_kappa_fn2'></span>

<h3>Description</h3>

<p>The negative of the objective function for kappa without Sig_inv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_kappa_fn2(kappa2, spde, phi, P, mu, Vh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neg_kappa_fn2_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_phi">phi</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_p">P</code></td>
<td>
<p>Matrix of dimension nk by N_s found by <code>solve(Sig_inv,Vh)</code></p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_mu">mu</code></td>
<td>
<p>dgeMatrix</p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_vh">Vh</code></td>
<td>
<p>random matrix of -1 and 1 of dim <code>dim(P)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='neg_kappa_fn3'>Streamlined negative objective function for kappa2 using precompiled values</h2><span id='topic+neg_kappa_fn3'></span>

<h3>Description</h3>

<p>Streamlined negative objective function for kappa2 using precompiled values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_kappa_fn3(kappa2, spde, a_star, b_star, n_sess)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neg_kappa_fn3_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn3_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="neg_kappa_fn3_+3A_a_star">a_star</code></td>
<td>
<p>precomputed coefficient (scalar)</p>
</td></tr>
<tr><td><code id="neg_kappa_fn3_+3A_b_star">b_star</code></td>
<td>
<p>precomputed coefficient (scalar)</p>
</td></tr>
<tr><td><code id="neg_kappa_fn3_+3A_n_sess">n_sess</code></td>
<td>
<p>number of sessions (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar output of the negative objective function
</p>

<hr>
<h2 id='neg_kappa_fn4'>Streamlined negative objective function for kappa2 using precompiled values</h2><span id='topic+neg_kappa_fn4'></span>

<h3>Description</h3>

<p>Streamlined negative objective function for kappa2 using precompiled values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_kappa_fn4(kappa2, spde, a_star, b_star, n_sess)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neg_kappa_fn4_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn4_+3A_spde">spde</code></td>
<td>
<p>SPDE prior matrix</p>
</td></tr>
<tr><td><code id="neg_kappa_fn4_+3A_a_star">a_star</code></td>
<td>
<p>precomputed coefficient (scalar)</p>
</td></tr>
<tr><td><code id="neg_kappa_fn4_+3A_b_star">b_star</code></td>
<td>
<p>precomputed coefficient (scalar)</p>
</td></tr>
<tr><td><code id="neg_kappa_fn4_+3A_n_sess">n_sess</code></td>
<td>
<p>number of sessions (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar output of the negative objective function
</p>

<hr>
<h2 id='num.threads_Param'>num.threads</h2><span id='topic+num.threads_Param'></span>

<h3>Description</h3>

<p>num.threads
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.threads_Param_+3A_num.threads">num.threads</code></td>
<td>
<p>The maximum number of threads to use for parallel
computations: prewhitening parameter estimation, and the inla-program model
estimation. Default: <code>4</code>. Note that parallel prewhitening requires the
<code>parallel</code> package.</p>
</td></tr>
</table>

<hr>
<h2 id='organize_data'>Organize data for Bayesian GLM</h2><span id='topic+organize_data'></span>

<h3>Description</h3>

<p>Transforms the usual TxV BOLD data matrix Y into vector form, and
the usual TxK design matrix X into big sparse matrix form for use in
Bayesian GLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>organize_data(y, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="organize_data_+3A_y">y</code></td>
<td>
<p>the TxV data matrix containing the fMRI timeseries</p>
</td></tr>
<tr><td><code id="organize_data_+3A_x">X</code></td>
<td>
<p>the TxK design matrix with K task-related columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayesian GLM requires <code>y</code> (a vector of length TV containing the BOLD data)
and <code>X_k</code> (a sparse TVxV matrix corresponding to the kth task regressor) for each task k.
The design matrices are combined as <code>A=cbind(X_1,...,X_K)</code>.
</p>
<p>The Bayesian GLM requires <code>y</code> (a vector of length TV containing the BOLD data)
and <code>X_k</code> (a sparse TVxV matrix corresponding to the kth task regressor) for each task k.
The design matrices are combined as <code>A=cbind(X_1,...,X_K)</code>.
</p>


<h3>Value</h3>

<p>A list containing fields <code>y</code> and <code>A</code> (see Details)
</p>

<hr>
<h2 id='organize_data_pw'>Organize prewhitened data for Bayesian GLM</h2><span id='topic+organize_data_pw'></span>

<h3>Description</h3>

<p>Transforms the usual TxV BOLD data matrix Y into vector form, and
the usual TxK design matrix X into big sparse matrix form for use in
Bayesian GLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>organize_data_pw(y, X, transpose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="organize_data_pw_+3A_y">y</code></td>
<td>
<p>the TxV data matrix containing the fMRI timeseries</p>
</td></tr>
<tr><td><code id="organize_data_pw_+3A_x">X</code></td>
<td>
<p>the TxK design matrix with K task-related columns</p>
</td></tr>
<tr><td><code id="organize_data_pw_+3A_transpose">transpose</code></td>
<td>
<p>Check orientation of data, which, if <code>TRUE</code>, will transpose
the data when the number of time points is greater than the number of voxels.
Note: this is not always true for subcortical regions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayesian GLM requires <code>y</code> (a vector of length TV containing the BOLD data)
and <code>X_k</code> (a sparse TVxV matrix corresponding to the kth task regressor) for each task k.
The design matrices are combined as <code>A=cbind(X_1,...,X_K)</code>.
</p>
<p>The Bayesian GLM requires <code>y</code> (a vector of length TV containing the BOLD data)
and <code>X_k</code> (a sparse TVxV matrix corresponding to the kth task regressor) for each task k.
The design matrices are combined as <code>A=cbind(X_1,...,X_K)</code>.
</p>


<h3>Value</h3>

<p>A list containing fields <code>y</code> and <code>A</code> (see Details)
</p>

<hr>
<h2 id='organize_replicates'>Organize replicates</h2><span id='topic+organize_replicates'></span>

<h3>Description</h3>

<p>beta and repl vectors are of length <code class="reqn">nvox \times n_sess \times n_task</code>.
The ith repl vector is an indicator vector for the cells corresponding to the ith column of x.
The ith beta vector contains data indices (e.g. 1,...,V) in the cells corresponding to the ith column of x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>organize_replicates(n_sess, task_names, mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="organize_replicates_+3A_n_sess">n_sess</code></td>
<td>
<p>The number of sessions sharing hyperparameters (can be different tasks)</p>
</td></tr>
<tr><td><code id="organize_replicates_+3A_task_names">task_names</code></td>
<td>
<p>Vector of names for each task</p>
</td></tr>
<tr><td><code id="organize_replicates_+3A_mesh">mesh</code></td>
<td>
<p>An <code>"inla.mesh"</code> object (see <code><a href="#topic+make_mesh">make_mesh</a></code> for
surface data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>replicates vector and betas for sessions
</p>

<hr>
<h2 id='plot.act_BayesGLM_cifti'>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code> to plot a <code>"act_BayesGLM_cifti"</code> object</h2><span id='topic+plot.act_BayesGLM_cifti'></span>

<h3>Description</h3>

<p>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code> to plot a <code>"act_BayesGLM_cifti"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'act_BayesGLM_cifti'
plot(x, idx = NULL, session = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.act_BayesGLM_cifti_+3A_x">x</code></td>
<td>
<p>An object of class &quot;act_BayesGLM_cifti&quot;</p>
</td></tr>
<tr><td><code id="plot.act_BayesGLM_cifti_+3A_idx">idx</code></td>
<td>
<p>Which task should be plotted? Give the numeric indices or the
names. <code>NULL</code> (default) will show all tasks. This argument overrides
the <code>idx</code> argument to <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code>.</p>
</td></tr>
<tr><td><code id="plot.act_BayesGLM_cifti_+3A_session">session</code></td>
<td>
<p>Which session should be plotted? <code>NULL</code> (default) will
use the first.</p>
</td></tr>
<tr><td><code id="plot.act_BayesGLM_cifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the call to <code>ciftiTools::view_cifti_surface</code>.
</p>

<hr>
<h2 id='plot.BayesGLM_cifti'>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code> to plot a <code>"BayesGLM_cifti"</code> object</h2><span id='topic+plot.BayesGLM_cifti'></span>

<h3>Description</h3>

<p>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code> to plot a <code>"BayesGLM_cifti"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesGLM_cifti'
plot(x, idx = NULL, session = NULL, method = NULL, zlim = c(-1, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BayesGLM_cifti_+3A_x">x</code></td>
<td>
<p>An object of class &quot;BayesGLM_cifti&quot;</p>
</td></tr>
<tr><td><code id="plot.BayesGLM_cifti_+3A_idx">idx</code></td>
<td>
<p>Which task should be plotted? Give the numeric indices or the
names. <code>NULL</code> (default) will show all tasks. This argument overrides
the <code>idx</code> argument to <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code>.</p>
</td></tr>
<tr><td><code id="plot.BayesGLM_cifti_+3A_session">session</code></td>
<td>
<p>Which session should be plotted? <code>NULL</code> (default) will
use the first.</p>
</td></tr>
<tr><td><code id="plot.BayesGLM_cifti_+3A_method">method</code></td>
<td>
<p>&quot;Bayes&quot; or &quot;classical&quot;. <code>NULL</code> (default) will use
the Bayesian results if available, and the classical results if not.</p>
</td></tr>
<tr><td><code id="plot.BayesGLM_cifti_+3A_zlim">zlim</code></td>
<td>
<p>Overrides the <code>zlim</code> argument for
<code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code>. Default: <code>c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="plot.BayesGLM_cifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the call to <code>ciftiTools::view_cifti_surface</code>.
</p>

<hr>
<h2 id='plot.BayesGLM2_cifti'>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code> to plot a <code>"BayesGLM2_cifti"</code> object</h2><span id='topic+plot.BayesGLM2_cifti'></span>

<h3>Description</h3>

<p>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code> to plot a <code>"BayesGLM2_cifti"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesGLM2_cifti'
plot(x, idx = NULL, what = c("contrasts", "activations"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BayesGLM2_cifti_+3A_x">x</code></td>
<td>
<p>An object of class &quot;BayesGLM2_cifti&quot;</p>
</td></tr>
<tr><td><code id="plot.BayesGLM2_cifti_+3A_idx">idx</code></td>
<td>
<p>Which contrast should be plotted? Give the numeric index.
<code>NULL</code> (default) will show all contrasts. This argument overrides
the <code>idx</code> argument to <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code>.</p>
</td></tr>
<tr><td><code id="plot.BayesGLM2_cifti_+3A_what">what</code></td>
<td>
<p>Estimates of the <code>"contrasts"</code> (default), or their
thresholded <code>"activations"</code>.</p>
</td></tr>
<tr><td><code id="plot.BayesGLM2_cifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ciftiTools.html#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the call to <code>ciftiTools::view_cifti_surface</code>.
</p>

<hr>
<h2 id='plot.prev_BayesGLM_cifti'>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"prev_BayesGLM_cifti"</code> object</h2><span id='topic+plot.prev_BayesGLM_cifti'></span>

<h3>Description</h3>

<p>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"prev_BayesGLM_cifti"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prev_BayesGLM_cifti'
plot(
  x,
  idx = NULL,
  session = NULL,
  drop_zeros = NULL,
  colors = "plasma",
  zlim = c(round(1/x$n_results - 0.005, 2), 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.prev_BayesGLM_cifti_+3A_x">x</code></td>
<td>
<p>An object of class &quot;prev_BayesGLM_cifti&quot;</p>
</td></tr>
<tr><td><code id="plot.prev_BayesGLM_cifti_+3A_idx">idx</code></td>
<td>
<p>Which task should be plotted? Give the numeric indices or the
names. <code>NULL</code> (default) will show all tasks. This argument overrides
the <code>idx</code> argument to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prev_BayesGLM_cifti_+3A_session">session</code></td>
<td>
<p>Which session should be plotted? <code>NULL</code> (default) will
use the first.</p>
</td></tr>
<tr><td><code id="plot.prev_BayesGLM_cifti_+3A_drop_zeros">drop_zeros</code></td>
<td>
<p>Color locations without any activation across all results
(zero prevalence) the same color as the medial wall? Default: <code>NULL</code> to
drop the zeros if only one <code>idx</code> is being plotted.</p>
</td></tr>
<tr><td><code id="plot.prev_BayesGLM_cifti_+3A_colors">colors</code>, <code id="plot.prev_BayesGLM_cifti_+3A_zlim">zlim</code></td>
<td>
<p>See <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code>. Here, the defaults
are overrided to use the Viridis <code>"plasma"</code> color scale between
<code>1/nA</code> and 1, where <code>nA</code> is the number of results in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.prev_BayesGLM_cifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the call to <code>ciftiTools::view_cifti_surface</code>.
</p>

<hr>
<h2 id='prep_kappa2_optim'>Find values for coefficients used in objective function for kappa2</h2><span id='topic+prep_kappa2_optim'></span>

<h3>Description</h3>

<p>Find values for coefficients used in objective function for kappa2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_kappa2_optim(spde, mu, phi, P, vh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_kappa2_optim_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="prep_kappa2_optim_+3A_mu">mu</code></td>
<td>
<p>the mean</p>
</td></tr>
<tr><td><code id="prep_kappa2_optim_+3A_phi">phi</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="prep_kappa2_optim_+3A_p">P</code></td>
<td>
<p>Matrix of dimension nk by N_s found by <code>solve(Sig_inv,Vh)</code></p>
</td></tr>
<tr><td><code id="prep_kappa2_optim_+3A_vh">vh</code></td>
<td>
<p>random matrix of -1 and 1 of dim <code>dim(P)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two elements, which are precomputed coefficients for the
optimization function
</p>

<hr>
<h2 id='pw_estimate'>Estimate residual autocorrelation for prewhitening</h2><span id='topic+pw_estimate'></span>

<h3>Description</h3>

<p>Estimate residual autocorrelation for prewhitening
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pw_estimate(resids, ar_order, aic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pw_estimate_+3A_resids">resids</code></td>
<td>
<p>Estimated residuals</p>
</td></tr>
<tr><td><code id="pw_estimate_+3A_ar_order">ar_order</code>, <code id="pw_estimate_+3A_aic">aic</code></td>
<td>
<p>Order of the AR model used to prewhiten the data at each location.
If <code>!aic</code> (default), the order will be exactly <code>ar_order</code>. If <code>aic</code>,
the order will be between zero and <code>ar_order</code>, as determined by the AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated AR coefficients and residual variance at every vertex
</p>

<hr>
<h2 id='pw_smooth'>Smooth AR coefficients and white noise variance</h2><span id='topic+pw_smooth'></span>

<h3>Description</h3>

<p>Smooth AR coefficients and white noise variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pw_smooth(vertices, faces, mask = NULL, AR, var, FWHM = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pw_smooth_+3A_vertices">vertices</code></td>
<td>
<p>A <code class="reqn">V \times 3</code> matrix, where each row contains the Euclidean
coordinates at which a given vertex in the mesh is located. <code class="reqn">V</code> is the
number of vertices in the mesh</p>
</td></tr>
<tr><td><code id="pw_smooth_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
<tr><td><code id="pw_smooth_+3A_mask">mask</code></td>
<td>
<p>A logical vector indicating, for each vertex, whether to include
it in smoothing. <code>NULL</code> (default) will use a vector of all <code>TRUE</code>,
meaning that no vertex is masked out; all are used for smoothing.</p>
</td></tr>
<tr><td><code id="pw_smooth_+3A_ar">AR</code></td>
<td>
<p>A Vxp matrix of estimated AR coefficients, where V is the number of vertices and p is the AR model order</p>
</td></tr>
<tr><td><code id="pw_smooth_+3A_var">var</code></td>
<td>
<p>A vector length V containing the white noise variance estimates from the AR model</p>
</td></tr>
<tr><td><code id="pw_smooth_+3A_fwhm">FWHM</code></td>
<td>
<p>FWHM parameter for smoothing. Remember that
<code class="reqn">\sigma = \frac{FWHM}{2*sqrt(2*log(2)}</code>. Set to <code>0</code> or <code>NULL</code>
to not do any smoothing. Default: <code>5</code>.#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Smoothed AR coefficients and residual variance at every vertex
</p>

<hr>
<h2 id='Q_prime'>Gives the portion of the Q matrix independent of phi</h2><span id='topic+Q_prime'></span>

<h3>Description</h3>

<p>Gives the portion of the Q matrix independent of phi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q_prime(kappa2, spde)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q_prime_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="Q_prime_+3A_spde">spde</code></td>
<td>
<p>An spde object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dgCMatrix
</p>

<hr>
<h2 id='qsample'>Sample from a multivariate normal with mean and precision</h2><span id='topic+qsample'></span>

<h3>Description</h3>

<p>Sample from a multivariate normal with mean and precision
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsample(n, mu, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsample_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="qsample_+3A_mu">mu</code></td>
<td>
<p>mean vector (length = p)</p>
</td></tr>
<tr><td><code id="qsample_+3A_q">Q</code></td>
<td>
<p>sparse p x p positive definite precision matrix (class = dgCMatrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An n x p matrix of samples
</p>

<hr>
<h2 id='retro_mask_BGLM'>Retroactively mask locations from BayesGLM result.</h2><span id='topic+retro_mask_BGLM'></span>

<h3>Description</h3>

<p>Work in progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retro_mask_BGLM(x, mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retro_mask_BGLM_+3A_x">x</code></td>
<td>
<p>The BayesGLM result</p>
</td></tr>
<tr><td><code id="retro_mask_BGLM_+3A_mask">mask</code></td>
<td>
<p>The mask to be applied to <code>x</code> (on top of any masks already
applied to it.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The masked result
</p>

<hr>
<h2 id='retro_mask_mesh'>Retroactively mask locations from mesh.</h2><span id='topic+retro_mask_mesh'></span>

<h3>Description</h3>

<p>Work in progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retro_mask_mesh(x, mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retro_mask_mesh_+3A_x">x</code></td>
<td>
<p>The mesh</p>
</td></tr>
<tr><td><code id="retro_mask_mesh_+3A_mask">mask</code></td>
<td>
<p>The mask to be applied to <code>x</code> (on top of any masks already
applied to it.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The masked result
</p>

<hr>
<h2 id='return_INLA_Param'>return_INLA</h2><span id='topic+return_INLA_Param'></span>

<h3>Description</h3>

<p>return_INLA
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_INLA_Param_+3A_return_inla">return_INLA</code></td>
<td>
<p>Return the INLA model object? (It can be large.) Use
<code>"trimmed"</code> (default) to return only the more relevant results, which
is enough for both <code><a href="#topic+id_activations">id_activations</a></code> and <code>BayesGLM2</code>,
<code>"minimal"</code> to return just enough for <code><a href="#topic+BayesGLM2">BayesGLM2</a></code> but not
<code>id_activations</code>, or <code>"full"</code> to return the full output of
<code>inla</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='s2m'>Sequential 2-means variable selection</h2><span id='topic+s2m'></span>

<h3>Description</h3>

<p>Sequential 2-means variable selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2m(x, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2m_+3A_x">x</code></td>
<td>
<p>A vector consisting of all variables of interest for a single draw
from a posterior distribution</p>
</td></tr>
<tr><td><code id="s2m_+3A_b">b</code></td>
<td>
<p>A scale parameter used to determine at what distance cluster centers
are considered to be the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of nonzero values detected within x
</p>

<hr>
<h2 id='s2m_B'>Sequential 2-means on array B</h2><span id='topic+s2m_B'></span>

<h3>Description</h3>

<p>Sequential 2-means on array B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2m_B(B, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2m_B_+3A_b">B</code></td>
<td>
<p>An array of posterior samples (typically a matrix), in which the last margin corresponds to a single posterior sample</p>
</td></tr>
<tr><td><code id="s2m_B_+3A_sigma">sigma</code></td>
<td>
<p>A scale parameter used to determine at what distance cluster centers are considered to be the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of dimension <code>head(dim(B),-1)</code> with a point estimate of B based on the sequential 2-means method
</p>

<hr>
<h2 id='scale_BOLD_Param'>scale_BOLD</h2><span id='topic+scale_BOLD_Param'></span>

<h3>Description</h3>

<p>scale_BOLD
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_BOLD_Param_+3A_scale_bold">scale_BOLD</code></td>
<td>
<p>Option for scaling the BOLD response.
</p>
<p><code>"auto"</code> (default) will use <code>"mean"</code> scaling except if demeaned
data is detected (if any mean is less than one), in which case <code>"sd"</code>
scaling will be used instead.
</p>
<p><code>"mean"</code> scaling will scale the data to percent local signal change.
</p>
<p><code>"sd"</code> scaling will scale the data by local standard deviation.
</p>
<p><code>"none"</code> will only center the data, not scale it.</p>
</td></tr>
</table>

<hr>
<h2 id='scale_design_mat'>Scale the design matrix</h2><span id='topic+scale_design_mat'></span>

<h3>Description</h3>

<p>Scale the design matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_design_mat(design_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_design_mat_+3A_design_mat">design_mat</code></td>
<td>
<p>The original (unscaled) design matrix that is T x K, where
T is the number of time points, and k is the number of task covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scaled design matrix
</p>

<hr>
<h2 id='scale_design_Param'>scale_design</h2><span id='topic+scale_design_Param'></span>

<h3>Description</h3>

<p>scale_design
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_design_Param_+3A_scale_design">scale_design</code></td>
<td>
<p>Scale the design matrix by dividing each column by its
maximum and then subtracting the mean? Default: <code>TRUE</code>. If
<code>FALSE</code>, the design matrix is centered but not scaled.</p>
</td></tr>
</table>

<hr>
<h2 id='seed_Param'>seed</h2><span id='topic+seed_Param'></span>

<h3>Description</h3>

<p>seed
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="seed_Param_+3A_seed">seed</code></td>
<td>
<p>Random seed (optional). Default: <code>NULL</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='session_names_Param'>session_names</h2><span id='topic+session_names_Param'></span>

<h3>Description</h3>

<p>session_names
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="session_names_Param_+3A_session_names">session_names</code></td>
<td>
<p>(Optional, and only relevant for multi-session modeling)
Names of each session. Default: <code>NULL</code>. In <code><a href="#topic+BayesGLM">BayesGLM</a></code> this
argument will overwrite the names of the list entries in <code>data</code>, if
both exist.</p>
</td></tr>
</table>

<hr>
<h2 id='spde_Q_phi'>Calculate the SPDE covariance</h2><span id='topic+spde_Q_phi'></span>

<h3>Description</h3>

<p>Calculate the SPDE covariance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde_Q_phi(kappa2, phi, spde)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spde_Q_phi_+3A_kappa2">kappa2</code></td>
<td>
<p>A scalar</p>
</td></tr>
<tr><td><code id="spde_Q_phi_+3A_phi">phi</code></td>
<td>
<p>A scalar</p>
</td></tr>
<tr><td><code id="spde_Q_phi_+3A_spde">spde</code></td>
<td>
<p>An object containing the information about the
mesh structure for the SPDE prior</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SPDE prior matrix
</p>

<hr>
<h2 id='submesh'>Remove part of a mesh without using INLA functions</h2><span id='topic+submesh'></span>

<h3>Description</h3>

<p>Remove part of a mesh without using INLA functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submesh(mask, mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submesh_+3A_mask">mask</code></td>
<td>
<p>a 0-1 vector</p>
</td></tr>
<tr><td><code id="submesh_+3A_mesh">mesh</code></td>
<td>
<p>a mesh resulting from a call to <code>make_mesh</code> with
<code>use_INLA = FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mesh object with fewer vertices than the original input mesh
</p>

<hr>
<h2 id='summary.act_BayesGLM'>Summarize a <code>"act_BayesGLM"</code> object</h2><span id='topic+summary.act_BayesGLM'></span><span id='topic+print.summary.act_BayesGLM'></span><span id='topic+print.act_BayesGLM'></span>

<h3>Description</h3>

<p>Summary method for class <code>"act_BayesGLM"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'act_BayesGLM'
summary(object, ...)

## S3 method for class 'summary.act_BayesGLM'
print(x, ...)

## S3 method for class 'act_BayesGLM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.act_BayesGLM_+3A_object">object</code></td>
<td>
<p>Object of class <code>"act_BayesGLM"</code>.</p>
</td></tr>
<tr><td><code id="summary.act_BayesGLM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.act_BayesGLM_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.act_BayesGLM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.act_BayesGLM"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.act_BayesGLM_cifti'>Summarize a <code>"act_BayesGLM_cifti"</code> object</h2><span id='topic+summary.act_BayesGLM_cifti'></span><span id='topic+print.summary.act_BayesGLM_cifti'></span><span id='topic+print.act_BayesGLM_cifti'></span>

<h3>Description</h3>

<p>Summary method for class <code>"act_BayesGLM_cifti"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'act_BayesGLM_cifti'
summary(object, ...)

## S3 method for class 'summary.act_BayesGLM_cifti'
print(x, ...)

## S3 method for class 'act_BayesGLM_cifti'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.act_BayesGLM_cifti_+3A_object">object</code></td>
<td>
<p>Object of class <code>"act_BayesGLM_cifti"</code>.</p>
</td></tr>
<tr><td><code id="summary.act_BayesGLM_cifti_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.act_BayesGLM_cifti_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.act_BayesGLM_cifti"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.act_BayesGLM_cifti"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.BayesGLM'>Summarize a <code>"BayesGLM"</code> object</h2><span id='topic+summary.BayesGLM'></span><span id='topic+print.summary.BayesGLM'></span><span id='topic+print.BayesGLM'></span>

<h3>Description</h3>

<p>Summary method for class <code>"BayesGLM"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesGLM'
summary(object, ...)

## S3 method for class 'summary.BayesGLM'
print(x, ...)

## S3 method for class 'BayesGLM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BayesGLM_+3A_object">object</code></td>
<td>
<p>Object of class <code>"BayesGLM"</code>.</p>
</td></tr>
<tr><td><code id="summary.BayesGLM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.BayesGLM_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.BayesGLM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.BayesGLM"</code> object, a list summarizing the properties
of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.BayesGLM_cifti'>Summarize a <code>"BayesGLM_cifti"</code> object</h2><span id='topic+summary.BayesGLM_cifti'></span><span id='topic+print.summary.BayesGLM_cifti'></span><span id='topic+print.BayesGLM_cifti'></span>

<h3>Description</h3>

<p>Summary method for class <code>"BayesGLM_cifti"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesGLM_cifti'
summary(object, ...)

## S3 method for class 'summary.BayesGLM_cifti'
print(x, ...)

## S3 method for class 'BayesGLM_cifti'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BayesGLM_cifti_+3A_object">object</code></td>
<td>
<p>Object of class <code>"BayesGLM_cifti"</code>.</p>
</td></tr>
<tr><td><code id="summary.BayesGLM_cifti_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.BayesGLM_cifti_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.BayesGLM_cifti"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.BayesGLM_cifti"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.BayesGLM2'>Summarize a <code>"BayesGLM2"</code> object</h2><span id='topic+summary.BayesGLM2'></span><span id='topic+print.summary.BayesGLM2'></span><span id='topic+print.BayesGLM2'></span>

<h3>Description</h3>

<p>Summary method for class <code>"BayesGLM2"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesGLM2'
summary(object, ...)

## S3 method for class 'summary.BayesGLM2'
print(x, ...)

## S3 method for class 'BayesGLM2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BayesGLM2_+3A_object">object</code></td>
<td>
<p>Object of class <code>"BayesGLM2"</code>.</p>
</td></tr>
<tr><td><code id="summary.BayesGLM2_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.BayesGLM2_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.BayesGLM2"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.BayesGLM2"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.BayesGLM2_cifti'>Summarize a <code>"BayesGLM2_cifti"</code> object</h2><span id='topic+summary.BayesGLM2_cifti'></span><span id='topic+print.summary.BayesGLM2_cifti'></span><span id='topic+print.BayesGLM2_cifti'></span>

<h3>Description</h3>

<p>Summary method for class <code>"BayesGLM2_cifti"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesGLM2_cifti'
summary(object, ...)

## S3 method for class 'summary.BayesGLM2_cifti'
print(x, ...)

## S3 method for class 'BayesGLM2_cifti'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BayesGLM2_cifti_+3A_object">object</code></td>
<td>
<p>Object of class <code>"BayesGLM2_cifti"</code>.</p>
</td></tr>
<tr><td><code id="summary.BayesGLM2_cifti_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.BayesGLM2_cifti_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.BayesGLM2_cifti"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.BayesGLM2_cifti"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.prev_BayesGLM'>Summarize a <code>"prev_BayesGLM"</code> object</h2><span id='topic+summary.prev_BayesGLM'></span><span id='topic+print.summary.prev_BayesGLM'></span><span id='topic+print.prev_BayesGLM'></span>

<h3>Description</h3>

<p>Summary method for class <code>"prev_BayesGLM"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prev_BayesGLM'
summary(object, ...)

## S3 method for class 'summary.prev_BayesGLM'
print(x, ...)

## S3 method for class 'prev_BayesGLM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.prev_BayesGLM_+3A_object">object</code></td>
<td>
<p>Object of class <code>"prev_BayesGLM"</code>.</p>
</td></tr>
<tr><td><code id="summary.prev_BayesGLM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.prev_BayesGLM_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.prev_BayesGLM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.prev_BayesGLM"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.prev_BayesGLM_cifti'>Summarize a <code>"prev_BayesGLM_cifti"</code> object</h2><span id='topic+summary.prev_BayesGLM_cifti'></span><span id='topic+print.summary.prev_BayesGLM_cifti'></span><span id='topic+print.prev_BayesGLM_cifti'></span>

<h3>Description</h3>

<p>Summary method for class <code>"prev_BayesGLM_cifti"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prev_BayesGLM_cifti'
summary(object, ...)

## S3 method for class 'summary.prev_BayesGLM_cifti'
print(x, ...)

## S3 method for class 'prev_BayesGLM_cifti'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.prev_BayesGLM_cifti_+3A_object">object</code></td>
<td>
<p>Object of class <code>"prev_BayesGLM_cifti"</code>.</p>
</td></tr>
<tr><td><code id="summary.prev_BayesGLM_cifti_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.prev_BayesGLM_cifti_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.prev_BayesGLM_cifti"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.prev_BayesGLM_cifti"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='task_names_Param'>task_names</h2><span id='topic+task_names_Param'></span>

<h3>Description</h3>

<p>task_names
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="task_names_Param_+3A_task_names">task_names</code></td>
<td>
<p>(Optional) Names of tasks represented in design matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='trim_INLA_model_obj'>Trim INLA object</h2><span id='topic+trim_INLA_model_obj'></span>

<h3>Description</h3>

<p>Trim an INLA object to only include what is necessary for
<code>id_activations</code> or <code>BayesGLM2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_INLA_model_obj(INLA_model_obj, minimal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_INLA_model_obj_+3A_inla_model_obj">INLA_model_obj</code></td>
<td>
<p>An object of class <code>"inla"</code>.</p>
</td></tr>
<tr><td><code id="trim_INLA_model_obj_+3A_minimal">minimal</code></td>
<td>
<p>Just keep the two parameters needed for <code>BayesGLM2</code>?
Default: <code>FALSE</code>. <code>!minimal</code> is required for
<code>id_activations</code>, but <code>minimal</code> is sufficient for
<code>BayesGLM2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trimmed <code>"inla"</code> object.
</p>

<hr>
<h2 id='trim_INLA_Param'>trim_INLA</h2><span id='topic+trim_INLA_Param'></span>

<h3>Description</h3>

<p>trim_INLA
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_INLA_Param_+3A_trim_inla">trim_INLA</code></td>
<td>
<p>(logical) should the <code>INLA_model_obj</code> within the
result be trimmed to only what is necessary to use <code>id_activations</code>?
Default: <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='TrQbb'>Trace of Q beta' beta</h2><span id='topic+TrQbb'></span>

<h3>Description</h3>

<p>Trace of Q beta' beta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrQbb(kappa2, beta_hat, spde)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrQbb_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="TrQbb_+3A_beta_hat">beta_hat</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="TrQbb_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='TrQEww'>Trace approximation function</h2><span id='topic+TrQEww'></span>

<h3>Description</h3>

<p>Trace approximation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrQEww(kappa2, spde, P, mu, Vh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrQEww_+3A_kappa2">kappa2</code></td>
<td>
<p>a scalar</p>
</td></tr>
<tr><td><code id="TrQEww_+3A_spde">spde</code></td>
<td>
<p>spde object</p>
</td></tr>
<tr><td><code id="TrQEww_+3A_p">P</code></td>
<td>
<p>Matrix of dimension nk by N_s found by <code>solve(Sig_inv,Vh)</code></p>
</td></tr>
<tr><td><code id="TrQEww_+3A_mu">mu</code></td>
<td>
<p>posterior mean</p>
</td></tr>
<tr><td><code id="TrQEww_+3A_vh">Vh</code></td>
<td>
<p>matrix of random variables with <code>nrow(Sig_inv)</code> rows and Ns
columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='TrSigB'>Hutchinson estimator of the trace</h2><span id='topic+TrSigB'></span>

<h3>Description</h3>

<p>Hutchinson estimator of the trace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrSigB(P, B, vh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrSigB_+3A_p">P</code></td>
<td>
<p>Matrix of dimension nk by N_s found by <code>solve(Sig_inv,Vh)</code></p>
</td></tr>
<tr><td><code id="TrSigB_+3A_b">B</code></td>
<td>
<p>Matrix of dimension nk by nk inside the desired trace product</p>
</td></tr>
<tr><td><code id="TrSigB_+3A_vh">vh</code></td>
<td>
<p>Matrix of dimension nk by N_s in which elements are -1 or 1 with
equal probability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar estimate of the trace of <code>Sigma %*% B</code>
</p>

<hr>
<h2 id='verbose_Param'>verbose</h2><span id='topic+verbose_Param'></span>

<h3>Description</h3>

<p>verbose
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="verbose_Param_+3A_verbose">verbose</code></td>
<td>
<p>Should updates be printed? Use <code>1</code> (default) for
occasional updates, <code>2</code> for occasional updates as well as running INLA
in verbose mode (if applicable), or <code>0</code> for no updates.</p>
</td></tr>
</table>

<hr>
<h2 id='vertex_areas'>Surface area of each vertex</h2><span id='topic+vertex_areas'></span>

<h3>Description</h3>

<p>Compute surface areas of each vertex in a triangular mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_areas(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_areas_+3A_mesh">mesh</code></td>
<td>
<p>An <code>"inla.mesh"</code> object (see <code><a href="#topic+make_mesh">make_mesh</a></code> for
surface data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of areas
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='vertices_Param'>vertices</h2><span id='topic+vertices_Param'></span>

<h3>Description</h3>

<p>vertices
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertices_Param_+3A_vertices">vertices</code></td>
<td>
<p>A <code class="reqn">V \times 3</code> matrix, where each row contains the Euclidean
coordinates at which a given vertex in the mesh is located. <code class="reqn">V</code> is the
number of vertices in the mesh</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
