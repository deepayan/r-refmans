<!DOCTYPE html><html lang="en-US"><head><title>Help for package BayesfMRI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesfMRI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BayesfMRI-package'><p>BayesfMRI: Spatial Bayesian Methods for Task Functional MRI Studies</p></a></li>
<li><a href='#.findTheta'><p>Perform the EM algorithm of the Bayesian GLM fitting</p></a></li>
<li><a href='#.getSqrtInvCpp'><p>Get the prewhitening matrix for a single data location</p></a></li>
<li><a href='#.initialKP'><p>Find the initial values of kappa2 and phi</p></a></li>
<li><a href='#.logDetQt'><p>Find the log of the determinant of Q_tilde</p></a></li>
<li><a href='#activations'><p>Identify field activations</p></a></li>
<li><a href='#activations.classical'><p>Identification of areas of activation in a General Linear Model using classical methods</p></a></li>
<li><a href='#activations.posterior'><p>Identify activations using joint posterior probabilities</p></a></li>
<li><a href='#aic_Param'><p>aic</p></a></li>
<li><a href='#AICc'><p>Corrected AIC</p></a></li>
<li><a href='#ar_order_Param'><p>ar_order</p></a></li>
<li><a href='#ar_smooth_Param'><p>ar_smooth</p></a></li>
<li><a href='#Bayes_Param'><p>Bayes</p></a></li>
<li><a href='#BayesGLM'><p>BayesGLM for CIFTI</p></a></li>
<li><a href='#BayesGLM_argChecks'><p>Bayes GLM arg checks</p></a></li>
<li><a href='#BayesGLM_format_cifti'><p>Format fit_bayesglm results into <code>"xifti"</code> objects</p></a></li>
<li><a href='#BayesGLM_format_design'><p>Format design</p></a></li>
<li><a href='#BayesGLM_format_nuisance'><p>Format nuisance</p></a></li>
<li><a href='#BayesGLM_format_scrub'><p>Format scrub</p></a></li>
<li><a href='#BayesGLM_is_valid_one_design'><p>Is a valid design?</p></a></li>
<li><a href='#BayesGLM_is_valid_one_nuisance'><p>Is a valid nuisance?</p></a></li>
<li><a href='#BayesGLM_is_valid_one_scrub'><p>Is a valid scrub?</p></a></li>
<li><a href='#BayesGLM_session_names'><p>Get <code>session_names</code> for GLM</p></a></li>
<li><a href='#BayesGLM2'><p>Group-level Bayesian GLM</p></a></li>
<li><a href='#beta.posterior.thetasamp'><p>Beta posterior theta sampling</p></a></li>
<li><a href='#BOLD_Param_BayesGLM'><p>BOLD</p></a></li>
<li><a href='#brainstructures_Param_BayesGLM'><p>brainstructures</p></a></li>
<li><a href='#buffer_Param'><p>buffer</p></a></li>
<li><a href='#cbind2'><p><code>cbind</code> if first argument might be <code>NULL</code></p></a></li>
<li><a href='#check_INLA'><p>Check INLA and PARDISO</p></a></li>
<li><a href='#cholQsample'><p>Sample from the multivariate normal distribution with Cholesky(Q)</p></a></li>
<li><a href='#Connectome_Workbench_Description'><p>Connectome Workbench</p></a></li>
<li><a href='#contrasts_Param'><p>contrasts</p></a></li>
<li><a href='#create_listRcpp'><p>Function to prepare objects for use in Rcpp functions</p></a></li>
<li><a href='#design_Param_BayesGLM'><p>design</p></a></li>
<li><a href='#dgCMatrix_cols_to_zero'><p>Set column values to zero for sparse matrix</p></a></li>
<li><a href='#do_QC'><p>Mask out invalid data</p></a></li>
<li><a href='#ELL'><p>Expected log-likelihood function</p></a></li>
<li><a href='#EM_Param'><p>EM</p></a></li>
<li><a href='#emTol_Param'><p>emTol</p></a></li>
<li><a href='#extract_estimates'><p>Extract Estimates of Activation</p></a></li>
<li><a href='#F.logwt'><p>F logwt</p></a></li>
<li><a href='#faces_Param'><p>faces</p></a></li>
<li><a href='#field_names_Param'><p>field_names</p></a></li>
<li><a href='#fit_bayesglm'><p>fit_bayesglm</p></a></li>
<li><a href='#galerkin_db'><p>Create FEM matrices</p></a></li>
<li><a href='#get_nV'><p>Get number of locations for various masks</p></a></li>
<li><a href='#get_posterior_densities'><p>Extracts posterior density estimates for hyperparameters</p></a></li>
<li><a href='#get_posterior_densities2'><p>Extracts posterior density estimates for hyperparameters for volumetric SPDE</p></a></li>
<li><a href='#GLM_classical'><p>Classical GLM</p></a></li>
<li><a href='#GLM_compare'><p>Classical GLM for multiple models</p></a></li>
<li><a href='#GLM_est_resid_var_pw'><p>Standardize data variance, and prewhiten if applicable</p></a></li>
<li><a href='#GLMEM_fixptseparate'><p>Fixed point function for the joint BayesGLM EM update algorithm</p></a></li>
<li><a href='#GLMEM_objfn'><p>Objective function for the BayesGLM EM algorithm</p></a></li>
<li><a href='#hpf_Param_BayesGLM'><p>hpf</p></a></li>
<li><a href='#init_fixpt'><p>The fix point function for the initialization of kappa2 and phi</p></a></li>
<li><a href='#init_objfn'><p>Objective function for the initialization of kappa2 and phi</p></a></li>
<li><a href='#INLA_deps'><p>Import INLA dependencies</p></a></li>
<li><a href='#INLA_Description'><p>INLA</p></a></li>
<li><a href='#INLA_Latent_Fields_Limit_Description'><p>INLA Latent Fields</p></a></li>
<li><a href='#intersect_mask'><p>Intersection mask for BayesGLM or activations result</p></a></li>
<li><a href='#is_matrix_or_df'><p>Is a matrix or data.frame?</p></a></li>
<li><a href='#kappa_init_fn'><p>Function to optimize over kappa2</p></a></li>
<li><a href='#log_kappa_tau'><p>Make <code>log_kappa</code> and <code>log_tau</code></p></a></li>
<li><a href='#make_A_mat'><p>Make A matrix</p></a></li>
<li><a href='#make_A_mat_rs'><p>Make A matrix with resampling framework</p></a></li>
<li><a href='#make_data_list'><p>Make data list for <code>estimate_model</code></p></a></li>
<li><a href='#make_mesh'><p>Make Mesh</p></a></li>
<li><a href='#make_Q'><p>Make the full SPDE precision based on theta, the spde, and the number of sessions</p></a></li>
<li><a href='#make_replicates'><p>Make replicates</p></a></li>
<li><a href='#make_sqrtInv_all'><p>Make <code>sqrtInv_all</code></p></a></li>
<li><a href='#mask_Param_vertices'><p>mask: vertices</p></a></li>
<li><a href='#max_threads_Param'><p>max_threads</p></a></li>
<li><a href='#mean_var_Tol_Param'><p>mean and variance tolerance</p></a></li>
<li><a href='#mesh_Param_either'><p>mesh: either</p></a></li>
<li><a href='#mesh_Param_inla'><p>mesh: INLA only</p></a></li>
<li><a href='#n_threads_Param'><p>n_threads</p></a></li>
<li><a href='#nbhd_order_Param'><p>nbhd_order</p></a></li>
<li><a href='#neg_kappa_fn'><p>The negative of the objective function for kappa</p></a></li>
<li><a href='#neg_kappa_fn2'><p>The negative of the objective function for kappa without Sig_inv</p></a></li>
<li><a href='#neg_kappa_fn3'><p>Streamlined negative objective function for kappa2 using precompiled values</p></a></li>
<li><a href='#neg_kappa_fn4'><p>Streamlined negative objective function for kappa2 using precompiled values</p></a></li>
<li><a href='#nuisance_Param_BayesGLM'><p>nuisance</p></a></li>
<li><a href='#plot.act_BGLM'><p>S3 method: use <code>view_xifti</code> to plot a <code>"act_BGLM"</code> object</p></a></li>
<li><a href='#plot.BGLM'><p>S3 method: use <code>view_xifti</code> to plot a <code>"BGLM"</code> object</p></a></li>
<li><a href='#plot.BGLM2'><p>S3 method: use <code>view_xifti</code> to plot a <code>"BGLM2"</code> object</p></a></li>
<li><a href='#plot.prev_BGLM'><p>S3 method: use <code>view_xifti</code> to plot a <code>"prev_BGLM"</code> object</p></a></li>
<li><a href='#prep_kappa2_optim'><p>Find values for coefficients used in objective function for kappa2</p></a></li>
<li><a href='#prevalence'><p>Activations prevalence.</p></a></li>
<li><a href='#pw_estimate'><p>Estimate residual autocorrelation for prewhitening</p></a></li>
<li><a href='#pw_smooth'><p>Smooth AR coefficients and white noise variance</p></a></li>
<li><a href='#Q_prime'><p>Q prime</p></a></li>
<li><a href='#qsample'><p>Sample from a multivariate normal with mean and precision</p></a></li>
<li><a href='#resamp_res_Param_BayesGLM'><p>resamp_res</p></a></li>
<li><a href='#retro_mask_act'><p>Retroactively mask activations</p></a></li>
<li><a href='#retro_mask_fit_bglm'><p>Retroactively mask locations from fit_bglm result.</p></a></li>
<li><a href='#retro_mask_mesh'><p>Retroactively mask locations from mesh.</p></a></li>
<li><a href='#return_INLA_Param'><p>return_INLA</p></a></li>
<li><a href='#s2m'><p>Sequential 2-means variable selection</p></a></li>
<li><a href='#s2m_B'><p>Sequential 2-means on array B</p></a></li>
<li><a href='#scale_BOLD'><p>Scale the BOLD timeseries</p></a></li>
<li><a href='#scale_BOLD_Param'><p>scale_BOLD</p></a></li>
<li><a href='#scale_design_mat'><p>Scale the design matrix</p></a></li>
<li><a href='#scrub_Param_BayesGLM'><p>scrub</p></a></li>
<li><a href='#seed_Param'><p>seed</p></a></li>
<li><a href='#session_names_Param'><p>session_names</p></a></li>
<li><a href='#sparse_and_PW'><p>Organize data for Bayesian GLM</p></a></li>
<li><a href='#SPDE_from_vertex'><p>SPDE from mesh model</p></a></li>
<li><a href='#SPDE_from_voxel'><p>SPDE from voxel model</p></a></li>
<li><a href='#spde_Q_phi'><p>Calculate the SPDE covariance</p></a></li>
<li><a href='#summary.act_BGLM'><p>Summarize a <code>"act_BGLM"</code> object</p></a></li>
<li><a href='#summary.act_fit_bglm'><p>Summarize a <code>"act_fit_bglm"</code> object</p></a></li>
<li><a href='#summary.BGLM'><p>Summarize a <code>"BGLM"</code> object</p></a></li>
<li><a href='#summary.BGLM2'><p>Summarize a <code>"BGLM2"</code> object</p></a></li>
<li><a href='#summary.fit_bglm'><p>Summarize a <code>"fit_bglm"</code> object</p></a></li>
<li><a href='#summary.fit_bglm2'><p>Summarize a <code>"fit_bglm2"</code> object</p></a></li>
<li><a href='#summary.prev_BGLM'><p>Summarize a <code>"prev_BGLM"</code> object</p></a></li>
<li><a href='#summary.prev_fit_bglm'><p>Summarize a <code>"prev_fit_bglm"</code> object</p></a></li>
<li><a href='#surfaces_Param_BayesGLM'><p>surfaces</p></a></li>
<li><a href='#TR_Param_BayesGLM'><p>TR</p></a></li>
<li><a href='#trim_INLA_model_obj'><p>Trim INLA object</p></a></li>
<li><a href='#trim_INLA_Param'><p>trim_INLA</p></a></li>
<li><a href='#TrQbb'><p>Trace of Q beta' beta</p></a></li>
<li><a href='#TrQEww'><p>Trace approximation function</p></a></li>
<li><a href='#TrSigB'><p>Hutchinson estimator of the trace</p></a></li>
<li><a href='#unmask_Mdat2In'><p>Unmask data</p></a></li>
<li><a href='#validate_spatial'><p>Validate <code>spatial</code></p></a></li>
<li><a href='#verbose_Param'><p>verbose</p></a></li>
<li><a href='#vertex_areas'><p>Surface area of each vertex</p></a></li>
<li><a href='#vertices_Param'><p>vertices</p></a></li>
<li><a href='#vol2spde'><p>Construct a triangular mesh from a 3D volumetric mask</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Bayesian Methods for Task Functional MRI Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amanda Mejia &lt;mandy.mejia@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs a spatial Bayesian general linear model (GLM) for task 
    functional magnetic resonance imaging (fMRI) data on the cortical surface. 
    Additional models include group analysis and inference to detect thresholded
    areas of activation. Includes direct support for the 'CIFTI' neuroimaging 
    file format. For more information see A. F. Mejia, Y. R. Yue, D. Bolin, F. 
    Lindgren, M. A. Lindquist (2020) &lt;<a href="https://doi.org/10.1080%2F01621459.2019.1611582">doi:10.1080/01621459.2019.1611582</a>&gt; and D. 
    Spencer, Y. R. Yue, D. Bolin, S. Ryan, A. F. Mejia (2022) 
    &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2022.118908">doi:10.1016/j.neuroimage.2022.118908</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mandymejia/BayesfMRI">https://github.com/mandymejia/BayesfMRI</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mandymejia/BayesfMRI/issues">https://github.com/mandymejia/BayesfMRI/issues</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>car, ciftiTools (&ge; 0.17.2), excursions, foreach, fMRItools
(&ge; 0.5.3), MASS, Matrix, matrixStats, methods, Rcpp, stats,
sp, utils, viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, abind, grDevices, hrf, INLA (&ge; 0.0-1468840039), knitr,
MatrixModels, parallel, purrr, rmarkdown, SQUAREM, testthat (&ge;
3.0.0), spelling</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, Rcpp</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-07 23:13:18 UTC; ddpham</td>
</tr>
<tr>
<td>Author:</td>
<td>Amanda Mejia [aut, cre],
  Damon Pham <a href="https://orcid.org/0000-0001-7563-4727"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  David Bolin [ctb],
  Yu (Ryan) Yue [ctb],
  Daniel Spencer <a href="https://orcid.org/0000-0002-9705-3605"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sarah Ryan [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-07 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BayesfMRI-package'>BayesfMRI: Spatial Bayesian Methods for Task Functional MRI Studies</h2><span id='topic+BayesfMRI'></span><span id='topic+BayesfMRI-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Performs a spatial Bayesian general linear model (GLM) for task functional magnetic resonance imaging (fMRI) data on the cortical surface. Additional models include group analysis and inference to detect thresholded areas of activation. Includes direct support for the 'CIFTI' neuroimaging file format. For more information see A. F. Mejia, Y. R. Yue, D. Bolin, F. Lindgren, M. A. Lindquist (2020) <a href="https://doi.org/10.1080/01621459.2019.1611582">doi:10.1080/01621459.2019.1611582</a> and D. Spencer, Y. R. Yue, D. Bolin, S. Ryan, A. F. Mejia (2022) <a href="https://doi.org/10.1016/j.neuroimage.2022.118908">doi:10.1016/j.neuroimage.2022.118908</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Amanda Mejia <a href="mailto:mandy.mejia@gmail.com">mandy.mejia@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Daniel Spencer <a href="mailto:danieladamspencer@gmail.com">danieladamspencer@gmail.com</a> (<a href="https://orcid.org/0000-0002-9705-3605">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Damon Pham <a href="mailto:damondpham@gmail.com">damondpham@gmail.com</a> (<a href="https://orcid.org/0000-0001-7563-4727">ORCID</a>) [contributor]
</p>
</li>
<li><p> David Bolin <a href="mailto:david.bolin@kaust.edu.sa">david.bolin@kaust.edu.sa</a> [contributor]
</p>
</li>
<li><p> Yu (Ryan) Yue <a href="mailto:yybaruch@gmail.com">yybaruch@gmail.com</a> [contributor]
</p>
</li>
<li><p> Sarah Ryan <a href="mailto:sarahryan320@gmail.com">sarahryan320@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mandymejia/BayesfMRI">https://github.com/mandymejia/BayesfMRI</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mandymejia/BayesfMRI/issues">https://github.com/mandymejia/BayesfMRI/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.findTheta'>Perform the EM algorithm of the Bayesian GLM fitting</h2><span id='topic+.findTheta'></span>

<h3>Description</h3>

<p>Perform the EM algorithm of the Bayesian GLM fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.findTheta(theta, spde, y, X, QK, Psi, A, Ns, tol, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".findTheta_+3A_theta">theta</code></td>
<td>
<p>the vector of initial values for theta</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_spde">spde</code></td>
<td>
<p>a list containing the sparse matrix elements Cmat, Gmat, and GtCinvG</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_y">y</code></td>
<td>
<p>the vector of response values</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_x">X</code></td>
<td>
<p>the sparse matrix of the data values</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_qk">QK</code></td>
<td>
<p>a sparse matrix of the prior precision found using the initial values of the hyperparameters</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_psi">Psi</code></td>
<td>
<p>a sparse matrix representation of the basis function mapping the data locations to the mesh vertices</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_a">A</code></td>
<td>
<p>a precomputed matrix crossprod(X%*%Psi)</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_ns">Ns</code></td>
<td>
<p>the number of columns for the random matrix used in the Hutchinson estimator</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_tol">tol</code></td>
<td>
<p>a value for the tolerance used for a stopping rule (compared to
the squared norm of the differences between <code>theta(s)</code> and <code>theta(s-1)</code>)</p>
</td></tr>
<tr><td><code id=".findTheta_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Should intermediate output be displayed?</p>
</td></tr>
</table>

<hr>
<h2 id='.getSqrtInvCpp'>Get the prewhitening matrix for a single data location</h2><span id='topic+.getSqrtInvCpp'></span>

<h3>Description</h3>

<p>Get the prewhitening matrix for a single data location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getSqrtInvCpp(AR_coefs, nTime, avg_var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".getSqrtInvCpp_+3A_ar_coefs">AR_coefs</code></td>
<td>
<p>a length-p vector where p is the AR order</p>
</td></tr>
<tr><td><code id=".getSqrtInvCpp_+3A_ntime">nTime</code></td>
<td>
<p>(integer) the length of the time series that is being prewhitened</p>
</td></tr>
<tr><td><code id=".getSqrtInvCpp_+3A_avg_var">avg_var</code></td>
<td>
<p>a scalar value of the residual variances of the AR model</p>
</td></tr>
</table>

<hr>
<h2 id='.initialKP'>Find the initial values of kappa2 and phi</h2><span id='topic+.initialKP'></span>

<h3>Description</h3>

<p>Find the initial values of kappa2 and phi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.initialKP(theta, spde, w, n_sess, tol, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".initialKP_+3A_theta">theta</code></td>
<td>
<p>a vector of length two containing the range and scale parameters
kappa2 and phi, in that order</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_spde">spde</code></td>
<td>
<p>a list containing the sparse matrix elements Cmat, Gmat, and GtCinvG</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_w">w</code></td>
<td>
<p>the beta_hat estimates for a single task</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_n_sess">n_sess</code></td>
<td>
<p>the number of sessions</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_tol">tol</code></td>
<td>
<p>the stopping rule tolerance</p>
</td></tr>
<tr><td><code id=".initialKP_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Should intermediate output be displayed?</p>
</td></tr>
</table>

<hr>
<h2 id='.logDetQt'>Find the log of the determinant of Q_tilde</h2><span id='topic+.logDetQt'></span>

<h3>Description</h3>

<p>Find the log of the determinant of Q_tilde
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.logDetQt(kappa2, in_list, n_sess)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".logDetQt_+3A_kappa2">kappa2</code></td>
<td>
<p>a scalar</p>
</td></tr>
<tr><td><code id=".logDetQt_+3A_in_list">in_list</code></td>
<td>
<p>a list with elements Cmat, Gmat, and GtCinvG</p>
</td></tr>
<tr><td><code id=".logDetQt_+3A_n_sess">n_sess</code></td>
<td>
<p>the integer number of sessions</p>
</td></tr>
</table>

<hr>
<h2 id='activations'>Identify field activations</h2><span id='topic+activations'></span><span id='topic+id_activations'></span>

<h3>Description</h3>

<p>Identify areas of activation for each field from the result of <code>BayesGLM</code>
or <code>fit_bayesglm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activations(
  x,
  Bayes = TRUE,
  gamma = NULL,
  alpha = 0.05,
  correction = c("FWER", "FDR", "none"),
  fields = NULL,
  sessions = NULL,
  verbose = 1
)

id_activations(
  x,
  Bayes = TRUE,
  gamma = NULL,
  alpha = 0.05,
  correction = c("FWER", "FDR", "none"),
  fields = NULL,
  sessions = NULL,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activations_+3A_x">x</code></td>
<td>
<p>Result of <code>BayesGLM</code> or <code>fit_bayesglm</code> model
call, of class <code>"BGLM"</code> or <code>"fit_bglm"</code>.</p>
</td></tr>
<tr><td><code id="activations_+3A_bayes">Bayes</code></td>
<td>
<p>Use spatial Bayesian modeling to identify activations based on
the joint posterior distribution? Default: <code>TRUE</code>. If <code>FALSE</code>,
activations will be based on classical (massive univariate) GLM model, with
multiple comparisons correction (see <code>correction</code>). Note that <code>TRUE</code>
is only applicable if <code>x</code> includes Bayesian results (i.e.
<code>x &lt;- BayesGLM(..., Bayes = TRUE)</code> was run.)</p>
</td></tr>
<tr><td><code id="activations_+3A_gamma">gamma</code></td>
<td>
<p>Activation threshold, for example <code>1</code> for 1 percent
signal change if <code>scale_BOLD=="mean"</code> during model estimation. Setting
a <code>gamma</code> is required for the Bayesian method; <code>NULL</code>
(default) will use a <code>gamma</code> of zero for the classical method.</p>
</td></tr>
<tr><td><code id="activations_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for inference. Default: <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="activations_+3A_correction">correction</code></td>
<td>
<p>For the classical method only: Type of multiple comparisons
correction: <code>"FWER"</code> (Bonferroni correction, the default), <code>"FDR"</code>
(Benjamini Hochberg), or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="activations_+3A_fields">fields</code></td>
<td>
<p>The field(s) to identify activations for. Give either the name(s)
as a character vector, or the numerical indices. If <code>NULL</code> (default),
analyze all fields.</p>
</td></tr>
<tr><td><code id="activations_+3A_sessions">sessions</code></td>
<td>
<p>The session(s) to identify activations for. Give either the
name(s) as a character vector, or the numerical indices. If <code>NULL</code>
(default), analyze the first session.</p>
</td></tr>
<tr><td><code id="activations_+3A_verbose">verbose</code></td>
<td>
<p><code>1</code> (default) to print occasional updates during model
computation; <code>2</code> for occasional updates as well as running INLA in
verbose mode (if <code>Bayes</code>), or <code>0</code> for no printed updates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>"act_BGLM"</code> or <code>"act_fit_bglm"</code> object, a
list which indicates the activated locations along with related information.
</p>

<hr>
<h2 id='activations.classical'>Identification of areas of activation in a General Linear Model using classical methods</h2><span id='topic+activations.classical'></span>

<h3>Description</h3>

<p>Identification of areas of activation in a General Linear Model using classical methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activations.classical(
  x,
  gamma = 0,
  alpha = 0.05,
  correction = c("FWER", "FDR", "none"),
  fields,
  session,
  mesh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activations.classical_+3A_x">x</code></td>
<td>
<p>A <code>BayesGLM</code> object</p>
</td></tr>
<tr><td><code id="activations.classical_+3A_gamma">gamma</code>, <code id="activations.classical_+3A_alpha">alpha</code>, <code id="activations.classical_+3A_correction">correction</code>, <code id="activations.classical_+3A_fields">fields</code>, <code id="activations.classical_+3A_session">session</code></td>
<td>
<p>See <code><a href="#topic+activations">activations</a></code>.</p>
</td></tr>
<tr><td><code id="activations.classical_+3A_mesh">mesh</code></td>
<td>
<p>(Optional) An <code>"inla.mesh"</code> object (see <code><a href="#topic+make_mesh">make_mesh</a></code> for
surface data). Only necessary for computing surface areas of identified activations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix corresponding to the
0-1 activation status for the model coefficients.
</p>

<hr>
<h2 id='activations.posterior'>Identify activations using joint posterior probabilities</h2><span id='topic+activations.posterior'></span>

<h3>Description</h3>

<p>Identifies areas of activation given an activation threshold and significance
level using joint posterior probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activations.posterior(x, fields, session, alpha = 0.05, gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activations.posterior_+3A_x">x</code></td>
<td>
<p>Result of <code>BayesGLM</code>, of class <code>"BGLM"</code>.</p>
</td></tr>
<tr><td><code id="activations.posterior_+3A_fields">fields</code>, <code id="activations.posterior_+3A_session">session</code>, <code id="activations.posterior_+3A_alpha">alpha</code>, <code id="activations.posterior_+3A_gamma">gamma</code></td>
<td>
<p>See <code><a href="#topic+activations">activations</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given latent field, identifies locations that exceed a certain activation
threshold (e.g. 1 percent signal change) at a given significance level, based on the joint
posterior distribution of the latent field.
</p>


<h3>Value</h3>

<p>A list with two elements: <code>active</code>, which gives a matrix of zeros
and ones of the same dimension as <code>x$field_estimates${session}</code>,
and <code>excur_result</code>, an object of class <code>"excurobj"</code> (see INLA's <code>excursions.inla</code> for
more information).
</p>

<hr>
<h2 id='aic_Param'>aic</h2><span id='topic+aic_Param'></span>

<h3>Description</h3>

<p>aic
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aic_Param_+3A_aic">aic</code></td>
<td>
<p>(For prewhitening) Use the Akaike information criterion (AIC) to
select AR model orders between <code>0</code> and <code>ar_order</code>? Default:
<code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='AICc'>Corrected AIC</h2><span id='topic+AICc'></span>

<h3>Description</h3>

<p>Computes corrected AIC (AICc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICc(y, demean = FALSE, order.max = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AICc_+3A_y">y</code></td>
<td>
<p>The autocorrelated data</p>
</td></tr>
<tr><td><code id="AICc_+3A_demean">demean</code></td>
<td>
<p>Demean <code>y</code>? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="AICc_+3A_order.max">order.max</code></td>
<td>
<p>The model order limit. Default: <code>10</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cAIC
</p>

<hr>
<h2 id='ar_order_Param'>ar_order</h2><span id='topic+ar_order_Param'></span>

<h3>Description</h3>

<p>ar_order
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ar_order_Param_+3A_ar_order">ar_order</code></td>
<td>
<p>(For prewhitening) The order of the autoregressive (AR) model
to use for prewhitening. If <code>0</code>, do not prewhiten. Default: <code>6</code>.
</p>
<p>For multi-session modeling, note that a single AR model is used; its
coefficients will be the average estimate from each session.</p>
</td></tr>
</table>

<hr>
<h2 id='ar_smooth_Param'>ar_smooth</h2><span id='topic+ar_smooth_Param'></span>

<h3>Description</h3>

<p>ar_smooth
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ar_smooth_Param_+3A_ar_smooth">ar_smooth</code></td>
<td>
<p>(For prewhitening) The FWHM parameter for spatially
smoothing the coefficient estimates for the AR model to use for
prewhitening. Recall that
<code class="reqn">\sigma = \frac{FWHM}{2*sqrt(2*log(2)}</code>. Set to <code>0</code> to not smooth
the estimates. Default: <code>5</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Bayes_Param'>Bayes</h2><span id='topic+Bayes_Param'></span>

<h3>Description</h3>

<p>Bayes
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bayes_Param_+3A_bayes">Bayes</code></td>
<td>
<p>Perform spatial Bayesian modeling? Default: <code>TRUE</code>. If
<code>FALSE</code>, only perform classical (massive univariate) modeling. (The classical GLM
result is always returned, whether <code>Bayes</code> is <code>TRUE</code> or <code>FALSE</code>.)</p>
</td></tr>
</table>

<hr>
<h2 id='BayesGLM'>BayesGLM for CIFTI</h2><span id='topic+BayesGLM'></span>

<h3>Description</h3>

<p>Performs spatial Bayesian GLM for task fMRI activation with CIFTI-format
data. The cortex is modeled as a surface mesh, and subcortical structures
are modeled as distinct volumetric regions. Includes the pre-processing
steps of nuisance regression, prewhitening, scaling, and variance
normalization. Supports both single- and multi-session analysis. Can also
compute just the classical (spatially-independent)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM(
  BOLD,
  brainstructures = c("left", "right"),
  subROI = c("Amygdala-L", "Amygdala-R", "Caudate-L", "Caudate-R", "Hippocampus-L",
    "Hippocampus-R", "Thalamus-L", "Thalamus-R"),
  design,
  nuisance = NULL,
  scrub = NULL,
  hpf = NULL,
  TR = NULL,
  surfL = NULL,
  surfR = NULL,
  resamp_res = 10000,
  nbhd_order = 1,
  buffer = c(1, 1, 3, 4, 4),
  session_names = NULL,
  scale_BOLD = c("mean", "sd", "none"),
  Bayes = TRUE,
  hyperpriors = c("informative", "default"),
  ar_order = 6,
  ar_smooth = 5,
  aic = FALSE,
  n_threads = 4,
  return_INLA = c("trimmed", "full", "minimal"),
  verbose = 1,
  meanTol = 1e-06,
  varTol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_+3A_bold">BOLD</code></td>
<td>
<p>fMRI timeseries data in CIFTI format (&quot;*.dtseries.nii&quot;).
For single-session analysis this can be a file path to a CIFTI file or a
<code>"xifti"</code> object from the <code>ciftiTools</code> package. For multi-session
analysis this can be a vector of file paths or a list of <code>"xifti"</code>
objects.
</p>
<p>If <code>BOLD</code> is a <code>"xifti"</code> object(s), the surfaces, if any, will be
used for the spatial model. However, if <code>surfL</code> and <code>surfR</code> are
provided, they will override any surfaces in <code>BOLD</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
of <code>BOLD</code> to analyze: <code>"left"</code> cortex; <code>"right"</code> cortex;
and/or <code>"subcortical"</code> structures. Or <code>"all"</code> to model all three.
Default: <code>c("left","right")</code> (cortex only).</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_subroi">subROI</code></td>
<td>
<p>Which subcortical ROIs should be analyzed? Can be <code>"all"</code>
to analyze all subcortex ROIs. See the <code>ciftiTools_Name</code> column of
<code>ciftiTools:::substructure_table()</code> for a list of possible
subcortical ROIs.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_design">design</code></td>
<td>
<p>A numeric matrix or <code>data.frame</code>, or a
<code>"BayesfMRI_design"</code> object from <code>make_design</code>. Can also
be an array where the third dimension is the same length as the number of
data locations, to model each location with its own design.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_nuisance">nuisance</code></td>
<td>
<p>(Optional) A <code class="reqn">T \times N_{nuis}</code> matrix of nuisance signals,
where <code class="reqn">T</code> is the number of timepoints and <code class="reqn">N</code> is the number of
nuisance signals, or a list of these for multi-session analysis. Nuisance
signals are regressed from the fMRI data and design matrix prior to GLM
computation. Nuisance signals can include motion regressors, HRF derivatives
not being modeled as tasks, and other sources of noise.
</p>
<p>Detrending/high-pass filtering is accomplished by adding DCT bases to the
nuisance matrix; see the parameters <code>hpf</code> and <code>DCT</code>.
</p>
<p>Do not add spike regressors for scrubbing to the <code>nuisance</code> matrix.
Rather, provide these in <code>scrub</code> so that their corresponding timepoints
are also removed from the BOLD data after nuisance regression.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_scrub">scrub</code></td>
<td>
<p>(Optional) A <code class="reqn">T \times N_{scrub}</code> matrix of spike regressors
(one 1 value at the timepoint to scrub, and 0 for all other values), or a
logical vector indicating the timepoints to scrub (<code>TRUE</code> to scrub, and
<code>FALSE</code> to keep). For multi-session data, a session-length list of
such matrices or logical vectors.
</p>
<p>The spike regressors will be included in the nuisance
regression, and afterwards the timepoints indicated in <code>scrub</code> will be
removed from the BOLD data and design matrix.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_hpf">hpf</code></td>
<td>
<p>Add DCT bases to <code>nuisance</code> to apply a temporal high-pass
filter to the data, for detrending? <code>hpf</code> is the filter frequency.
Use <code>NULL</code> to skip detrending. Detrending is strongly recommended for
fMRI data, to help reduce the autocorrelation in the residuals, so
<code>NULL</code> will induce a warning. Use <code>"already"</code> to disable the
warning while skipping highpass filtering.
</p>
<p>Using at least two DCT bases is as sufficient for detrending as using linear
and quadratic drift terms in the nuisance matrix. So if DCT detrending is
being used here, there is no need to add linear and quadratic drift terms to
<code>nuisance</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_tr">TR</code></td>
<td>
<p>Temporal resolution of the data, in seconds.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_surfl">surfL</code>, <code id="BayesGLM_+3A_surfr">surfR</code></td>
<td>
<p>For cortex spatial model. Left and right cortex surface
geometry in GIFTI format (&quot;*.surf.gii&quot;). These can be a file path to
a GIFTI file or a <code>"surf"</code> object from <code>ciftiTools</code>.
</p>
<p>Surfaces can alternatively be provided through the <code>$surf</code> metadata in
<code>BOLD</code> if it is <code>"xifti"</code> data. If neither are provided, by default the
HCP group-average fs_LR inflated surfaces included in <code>ciftiTools</code> will be
used for the cortex spatial model.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_resamp_res">resamp_res</code></td>
<td>
<p>For cortex spatial model. The number of vertices to which
each cortical surface should be resampled, or <code>NULL</code> to not resample.
</p>
<p>For computational feasibility, a value of <code>10000</code> (default) or lower is
recommended for Bayesian spatial modeling. If <code>Bayes=FALSE</code>,
<code>resamp_res</code> can be set to <code>NULL</code> for full-resolution classical
modeling.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_nbhd_order">nbhd_order</code></td>
<td>
<p>For volumetric model. What order neighborhood around data
locations to keep? <code>0</code> for no neighbors, <code>1</code> for 1st-order
neighbors, <code>2</code> for 1st- and 2nd-order neighbors, etc. Smaller values
will provide greater computational efficiency at the cost of higher variance
around the edge of the data.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_buffer">buffer</code></td>
<td>
<p>For volumetric model. The number of extra voxel layers around
the bounding box. Set to <code>NULL</code> for no buffer. (We recommend not
changing <code>buffer</code> unless you know what you're doing. Instead, to reduce
the number of boundary voxels, adjust <code>nbhd_order</code>).</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_session_names">session_names</code></td>
<td>
<p>The names of the task-fMRI <code>BOLD</code> sessions, for
multi-session analysis. If not provided here, will be inferred from
<code>names(BOLD)</code>, inferred from <code>names(design)</code>, or generated
automatically, in that order.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_scale_bold">scale_BOLD</code></td>
<td>
<p>Controls scaling the BOLD response at each location.
</p>

<dl>
<dt>&quot;mean&quot;:</dt><dd><p>   Scale the data to percent local signal change.</p>
</dd>
<dt>&quot;sd&quot;:</dt><dd><p>   Scale the data by local standard deviation.</p>
</dd>
<dt>&quot;none&quot;:</dt><dd><p>   Center the data but do not scale it.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="BayesGLM_+3A_bayes">Bayes</code></td>
<td>
<p>Perform spatial Bayesian modeling? Default: <code>TRUE</code>. If
<code>FALSE</code>, only perform classical (massive univariate) modeling. (The classical GLM
result is always returned, whether <code>Bayes</code> is <code>TRUE</code> or <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_hyperpriors">hyperpriors</code></td>
<td>
<p>Should informative or default non-informative hyperpriors be assumed on SPDE hyperparameters?</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_ar_order">ar_order</code></td>
<td>
<p>(For prewhitening) The order of the autoregressive (AR) model
to use for prewhitening. If <code>0</code>, do not prewhiten. Default: <code>6</code>.
</p>
<p>For multi-session modeling, note that a single AR model is used; its
coefficients will be the average estimate from each session.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_ar_smooth">ar_smooth</code></td>
<td>
<p>(For prewhitening) The FWHM parameter for spatially
smoothing the coefficient estimates for the AR model to use for
prewhitening. Recall that
<code class="reqn">\sigma = \frac{FWHM}{2*sqrt(2*log(2)}</code>. Set to <code>0</code> to not smooth
the estimates. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_aic">aic</code></td>
<td>
<p>(For prewhitening) Use the Akaike information criterion (AIC) to
select AR model orders between <code>0</code> and <code>ar_order</code>? Default:
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_n_threads">n_threads</code></td>
<td>
<p>The maximum number of threads to use for parallel
computations: prewhitening parameter estimation, and the inla-program model
estimation. Default: <code>4</code>. Note that parallel prewhitening requires the
<code>parallel</code> package.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_return_inla">return_INLA</code></td>
<td>
<p>Return the INLA model object? (It can be large.) Use
<code>"trimmed"</code> (default) returns the results sufficient for
<code><a href="#topic+activations">activations</a></code> and <code><a href="#topic+BayesGLM2">BayesGLM2</a></code>; <code>"minimal"</code>
returns enough for <code><a href="#topic+BayesGLM2">BayesGLM2</a></code> but not
<code><a href="#topic+activations">activations</a></code>; <code>"full"</code> returns the full <code>inla</code>
output.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_verbose">verbose</code></td>
<td>
<p><code>1</code> (default) to print occasional updates during model
computation; <code>2</code> for occasional updates as well as running INLA in
verbose mode (if <code>Bayes</code>), or <code>0</code> for no printed updates.</p>
</td></tr>
<tr><td><code id="BayesGLM_+3A_meantol">meanTol</code>, <code id="BayesGLM_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Default: <code>1e-6</code> for both.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use <code>BayesGLM</code>, the design matrix must first be constructed
with <code>make_design</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"BayesGLM"</code>: a list with elements
</p>

<dl>
<dt>betas_Bayesian</dt><dd><p>The field coefficients for the Bayesian model.</p>
</dd>
<dt>betas_classical</dt><dd><p>The field coefficients for the classical model.</p>
</dd>
<dt>GLMs_Bayesian</dt><dd><p>The entire list of GLM results, except for parameters estimated for the classical model.</p>
</dd>
<dt>GLMs_classical</dt><dd><p>Parameters estimated for the classical model from the GLM.</p>
</dd>
<dt>brainstructures</dt><dd><p><code>data.frame</code> summarizing the spatial features of each brain structure modeled.</p>
</dd>
<dt>sessions</dt><dd><p><code>data.frame</code> with the <code>name</code> and <code>nTime</code> of each BOLD session.</p>
</dd>
<dt>fields</dt><dd><p><code>data.frame</code> with the <code>name</code>, related <code>task</code>, and <code>HRF_order</code> of each field.</p>
</dd>
</dl>



<h3>Connectome Workbench Requirement</h3>

<p>This function uses a system wrapper for the 'wb_command' executable. The
user must first download and install the Connectome Workbench, available
from https://www.humanconnectome.org/software/get-connectome-workbench .
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>


<h3>INLA Latent Fields Limit</h3>

<p>INLA computation times increase greatly when the number of columns in the
design matrix exceeds five: when there are more than five tasks, or more
than three tasks each with a temporal derivative modeled as a field. In
cases like the latter, we recommend modeling the temporal derivatives as
nuisance signals using the option <code>dHRF_as="nuisance"</code>, rather than
modeling the temporal derivatives as fields.
</p>

<hr>
<h2 id='BayesGLM_argChecks'>Bayes GLM arg checks</h2><span id='topic+BayesGLM_argChecks'></span>

<h3>Description</h3>

<p>Checks arguments for <code>BayesGLM</code> and <code>fit_bayesglm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_argChecks(
  scale_BOLD = c("mean", "sd", "none"),
  Bayes = TRUE,
  EM = FALSE,
  ar_order = 6,
  ar_smooth = 5,
  aic = FALSE,
  n_threads = 4,
  return_INLA = c("trimmed", "full", "minimal"),
  verbose = 1,
  meanTol = 1e-06,
  varTol = 1e-06,
  emTol = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_argChecks_+3A_scale_bold">scale_BOLD</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_bayes">Bayes</code>, <code id="BayesGLM_argChecks_+3A_em">EM</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_ar_order">ar_order</code>, <code id="BayesGLM_argChecks_+3A_ar_smooth">ar_smooth</code>, <code id="BayesGLM_argChecks_+3A_aic">aic</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_n_threads">n_threads</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_return_inla">return_INLA</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_meantol">meanTol</code>, <code id="BayesGLM_argChecks_+3A_vartol">varTol</code>, <code id="BayesGLM_argChecks_+3A_emtol">emTol</code></td>
<td>
<p>See <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Avoids duplicated code between <code>BayesGLM</code> and <code>fit_bayesglm</code>
</p>


<h3>Value</h3>

<p>The arguments that may have changed, in a list: <code>scale_BOLD</code>,
<code>do_Bayesian</code>, <code>do_EM</code>, and <code>do_pw</code>.
</p>

<hr>
<h2 id='BayesGLM_format_cifti'>Format fit_bayesglm results into <code>"xifti"</code> objects</h2><span id='topic+BayesGLM_format_cifti'></span>

<h3>Description</h3>

<p>Format beta estimates or RSS of the <code>fit_bayesglm</code> results into list of
<code>"xifti"</code> objects for each session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_format_cifti(
  BGLMs,
  do,
  spatial,
  submeta,
  session_names,
  field_names,
  method = c("classical", "Bayesian")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_format_cifti_+3A_bglms">BGLMs</code></td>
<td>
<p>The list of <code>"BGLM"</code> objects, from <code>fit_bayesglm</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_cifti_+3A_do">do</code>, <code id="BayesGLM_format_cifti_+3A_spatial">spatial</code>, <code id="BayesGLM_format_cifti_+3A_submeta">submeta</code>, <code id="BayesGLM_format_cifti_+3A_session_names">session_names</code>, <code id="BayesGLM_format_cifti_+3A_field_names">field_names</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_cifti_+3A_method">method</code></td>
<td>
<p><code>"classical"</code> or <code>"Bayesian"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of <code>"xifti"</code> objects
</p>

<hr>
<h2 id='BayesGLM_format_design'>Format design</h2><span id='topic+BayesGLM_format_design'></span>

<h3>Description</h3>

<p>Format design for <code>BayesGLM</code>, <code>fit_bayesglm</code>,
<code>multiGLM</code>, and <code>multiGLM_fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_format_design(
  design,
  scale_design = TRUE,
  nS_expect = NULL,
  nT_expect = NULL,
  nD_expect = NULL,
  per_location_design = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_format_design_+3A_design">design</code></td>
<td>
<p>The <code>design</code> argument input. Will be formatted to a
<code>nS</code>-length list.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_design_+3A_scale_design">scale_design</code></td>
<td>
<p>Scale the design matrix by dividing each column by its
maximum and then subtracting the mean? Default: <code>TRUE</code>. If
<code>FALSE</code>, the design matrix is centered but not scaled.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_design_+3A_ns_expect">nS_expect</code></td>
<td>
<p>The expected number of sessions, if known.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_design_+3A_nt_expect">nT_expect</code></td>
<td>
<p>The expected number of timepoints, if known. For
multi-session data this is a session-length vector.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_design_+3A_nd_expect">nD_expect</code></td>
<td>
<p>The expected number of designs, if known. For per-location
modeling this is equal to <code>nVd0</code>, the initial number of data locations.
For multi-session data this is a session-length vector.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_design_+3A_per_location_design">per_location_design</code></td>
<td>
<p><code>FALSE</code> if per-location modeling is not
being performed (i.e. for multiGLM); <code>TRUE</code> if it is; or, <code>NULL</code>
to infer based on the dimensions of <code>design</code> (<code>TRUE</code> if the
design has three dimensions.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>design</code>
</p>

<hr>
<h2 id='BayesGLM_format_nuisance'>Format nuisance</h2><span id='topic+BayesGLM_format_nuisance'></span>

<h3>Description</h3>

<p>Format nuisance for <code>BayesGLM</code>, <code>fit_bayesglm</code>,
<code>multiGLM</code>, and <code>multiGLM_fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_format_nuisance(nuisance, nS_expect = NULL, nT_expect = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_format_nuisance_+3A_nuisance">nuisance</code></td>
<td>
<p>The <code>nuisance</code> argument input. Will be formatted to a
<code>nS</code>-length list.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_nuisance_+3A_ns_expect">nS_expect</code></td>
<td>
<p>The expected number of sessions, if known.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_nuisance_+3A_nt_expect">nT_expect</code></td>
<td>
<p>The expected number of timepoints, if known. For
multi-session data this is a session-length vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nuisance</code>
</p>

<hr>
<h2 id='BayesGLM_format_scrub'>Format scrub</h2><span id='topic+BayesGLM_format_scrub'></span>

<h3>Description</h3>

<p>Format scrub for <code>BayesGLM</code>, <code>fit_bayesglm</code>,
<code>multiGLM</code>, and <code>multiGLM_fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_format_scrub(scrub, nS_expect = NULL, nT_expect = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_format_scrub_+3A_scrub">scrub</code></td>
<td>
<p>The <code>scrub</code> argument input. Will be formatted to a
<code>nS</code>-length list.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_scrub_+3A_ns_expect">nS_expect</code></td>
<td>
<p>The expected number of sessions, if known.</p>
</td></tr>
<tr><td><code id="BayesGLM_format_scrub_+3A_nt_expect">nT_expect</code></td>
<td>
<p>The expected number of timepoints, if known. For
multi-session data this is a session-length vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>scrub</code>
</p>

<hr>
<h2 id='BayesGLM_is_valid_one_design'>Is a valid design?</h2><span id='topic+BayesGLM_is_valid_one_design'></span>

<h3>Description</h3>

<p>Is a valid design?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_is_valid_one_design(design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_is_valid_one_design_+3A_design">design</code></td>
<td>
<p>The design matrix/array</p>
</td></tr>
</table>

<hr>
<h2 id='BayesGLM_is_valid_one_nuisance'>Is a valid nuisance?</h2><span id='topic+BayesGLM_is_valid_one_nuisance'></span>

<h3>Description</h3>

<p>Is a valid nuisance?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_is_valid_one_nuisance(nuisance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_is_valid_one_nuisance_+3A_nuisance">nuisance</code></td>
<td>
<p>The nuisance matrix</p>
</td></tr>
</table>

<hr>
<h2 id='BayesGLM_is_valid_one_scrub'>Is a valid scrub?</h2><span id='topic+BayesGLM_is_valid_one_scrub'></span>

<h3>Description</h3>

<p>Is a valid scrub?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_is_valid_one_scrub(scrub)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_is_valid_one_scrub_+3A_scrub">scrub</code></td>
<td>
<p>The scrub matrix</p>
</td></tr>
</table>

<hr>
<h2 id='BayesGLM_session_names'>Get <code>session_names</code> for GLM</h2><span id='topic+BayesGLM_session_names'></span>

<h3>Description</h3>

<p>Get <code>session_names</code> for GLM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_session_names(nS, session_names, BOLD_names, design_names)
</code></pre>

<hr>
<h2 id='BayesGLM2'>Group-level Bayesian GLM</h2><span id='topic+BayesGLM2'></span>

<h3>Description</h3>

<p>Performs group-level Bayesian GLM estimation and inference using the joint
approach described in Mejia et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM2(
  results,
  contrasts = NULL,
  quantiles = NULL,
  excursion_type = NULL,
  contrast_names = NULL,
  gamma = 0,
  alpha = 0.05,
  nsamp_theta = 50,
  nsamp_beta = 100,
  num_cores = NULL,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM2_+3A_results">results</code></td>
<td>
<p>Either (1) a length <code class="reqn">N</code> list of <code>"BGLM"</code> objects,
or (2) a length <code class="reqn">N</code> character vector of files storing <code>"BGLM"</code>
objects saved with <code><a href="base.html#topic+saveRDS">saveRDS</a></code>. <code>"fit_bglm"</code> objects
also are accepted.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_contrasts">contrasts</code></td>
<td>
<p>(Optional) A list of contrast vectors that specify the
group-level summaries of interest. If <code>NULL</code> (DEFAULT), use contrasts that
compute the average of each field (field HRF) across all subjects/sessions.
</p>
<p>Each contrast vector is length <code class="reqn">KSN</code> specifying a group-level summary of
interest, where <code class="reqn">K</code> is the number of fields in the first-level design
matrices, <code class="reqn">S</code> is the number of sessions, and <code class="reqn">N</code> is the number of
subjects. The vector is grouped by fields, then sessions, then subjects.
</p>
<p>For a single session/subject, the contrast vector for the first field would be:
</p>
<p><code>c0 &lt;- c(1, rep(0, K-1)) #indexes the first field for a single session</code>
</p>
<p>so the full contrast vector for the group <em>average over all sessions/subjects
for the first field</em> would be:
</p>
<p><code>contrasts = rep(c0, S*N) /(S*N)</code>.
</p>
<p>To obtain the group average for the first field, for <em>just the first session</em>,
input zeros for the remaining sessions:
</p>
<p><code>c2 &lt;- c(c0, rep(0, K*(S-1)))</code>
<code>contrasts = rep(c2, N) /N</code>.
</p>
<p>To obtain the group mean <em>difference between two sessions</em> (<code class="reqn">S=2</code>) for the first field:
</p>
<p><code>c3 &lt;- c(c0, -c0)</code>
<code>contrasts = rep(c3, N) / N</code>.
</p>
<p>To obtain the <em>mean over sessions</em> of the first field, just for the first subject:
</p>
<p><code>c4 &lt;- rep(c0, S)</code>
<code>c(c4, rep(0, K*S*(N-1))) / S</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_quantiles">quantiles</code></td>
<td>
<p>(Optional) Vector of posterior quantiles to return in
addition to the posterior mean.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_excursion_type">excursion_type</code></td>
<td>
<p>(For inference only) The type of excursion function for
the contrast (&quot;&gt;&quot;, &quot;&lt;&quot;, &quot;!=&quot;), or a vector thereof (each element
corresponding to one contrast).  If <code>NULL</code>, no inference performed.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_contrast_names">contrast_names</code></td>
<td>
<p>(Optional) Names of contrasts.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_gamma">gamma</code></td>
<td>
<p>(For inference only) Activation threshold for the excursion set,
or a vector thereof (each element corresponding to one contrast). Default:
<code>0</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_alpha">alpha</code></td>
<td>
<p>(For inference only) Significance level for activation for the
excursion set, or a vector thereof (each element corresponding to one
contrast). Default: <code>.05</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_nsamp_theta">nsamp_theta</code></td>
<td>
<p>Number of theta values to sample from posterior. Default:
<code>50</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_nsamp_beta">nsamp_beta</code></td>
<td>
<p>Number of beta vectors to sample conditional on each theta
value sampled. Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use for sampling betas in parallel. If
<code>NULL</code> (default), do not run in parallel.</p>
</td></tr>
<tr><td><code id="BayesGLM2_+3A_verbose">verbose</code></td>
<td>
<p><code>1</code> (default) to print occasional updates during model
computation; <code>2</code> for occasional updates as well as running INLA in
verbose mode (if <code>Bayes</code>), or <code>0</code> for no printed updates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimates, PPMs and areas of activation for each contrast.
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='beta.posterior.thetasamp'>Beta posterior theta sampling</h2><span id='topic+beta.posterior.thetasamp'></span>

<h3>Description</h3>

<p>Internal function used in joint approach to group-analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.posterior.thetasamp(
  theta,
  spde,
  Xcros,
  Xycros,
  contrasts,
  quantiles,
  excursion_type,
  gamma,
  alpha,
  nsamp_beta = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta.posterior.thetasamp_+3A_theta">theta</code></td>
<td>
<p>A single sample of theta (hyperparameters) from q(theta|y)</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_spde">spde</code></td>
<td>
<p>A SPDE object from inla.spde2.matern() function.</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_xcros">Xcros</code></td>
<td>
<p>A crossproduct of design matrix.</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_xycros">Xycros</code></td>
<td>
<p>A crossproduct of design matrix and BOLD y.</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_contrasts">contrasts</code></td>
<td>
<p>A list of vectors of length M*K specifying the contrasts of interest.</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of posterior quantiles to return in addition to the posterior mean</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_excursion_type">excursion_type</code></td>
<td>
<p>Vector of excursion function type (&quot;&gt;&quot;, &quot;&lt;&quot;, &quot;!=&quot;) for each contrast</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_gamma">gamma</code></td>
<td>
<p>Vector of activation thresholds for each contrast</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for activation for the excursion sets</p>
</td></tr>
<tr><td><code id="beta.posterior.thetasamp_+3A_nsamp_beta">nsamp_beta</code></td>
<td>
<p>The number of samples to draw from full conditional of beta given the current value of theta (p(beta|theta,y))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing <code>mu</code>, <code>quantiles</code>, and <code>F</code>
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='BOLD_Param_BayesGLM'>BOLD</h2><span id='topic+BOLD_Param_BayesGLM'></span>

<h3>Description</h3>

<p>BOLD
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BOLD_Param_BayesGLM_+3A_bold">BOLD</code></td>
<td>
<p>fMRI timeseries data in CIFTI format (&quot;*.dtseries.nii&quot;).
For single-session analysis this can be a file path to a CIFTI file or a
<code>"xifti"</code> object from the <code>ciftiTools</code> package. For multi-session
analysis this can be a vector of file paths or a list of <code>"xifti"</code>
objects.
</p>
<p>If <code>BOLD</code> is a <code>"xifti"</code> object(s), the surfaces, if any, will be
used for the spatial model. However, if <code>surfL</code> and <code>surfR</code> are
provided, they will override any surfaces in <code>BOLD</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='brainstructures_Param_BayesGLM'>brainstructures</h2><span id='topic+brainstructures_Param_BayesGLM'></span>

<h3>Description</h3>

<p>brainstructures
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainstructures_Param_BayesGLM_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
of <code>BOLD</code> to analyze: <code>"left"</code> cortex; <code>"right"</code> cortex;
and/or <code>"subcortical"</code> structures. Or <code>"all"</code> to model all three.
Default: <code>c("left","right")</code> (cortex only).</p>
</td></tr>
</table>

<hr>
<h2 id='buffer_Param'>buffer</h2><span id='topic+buffer_Param'></span>

<h3>Description</h3>

<p>buffer
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buffer_Param_+3A_buffer">buffer</code></td>
<td>
<p>For volumetric model. The number of extra voxel layers around
the bounding box. Set to <code>NULL</code> for no buffer. (We recommend not
changing <code>buffer</code> unless you know what you're doing. Instead, to reduce
the number of boundary voxels, adjust <code>nbhd_order</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='cbind2'><code>cbind</code> if first argument might be <code>NULL</code></h2><span id='topic+cbind2'></span>

<h3>Description</h3>

<p><code>cbind</code>, but return the second argument if the first is <code>NULL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind2(mat_or_NULL, to_add)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbind2_+3A_mat_or_null">mat_or_NULL</code></td>
<td>
<p><code>NULL</code> or a numeric matrix</p>
</td></tr>
<tr><td><code id="cbind2_+3A_to_add">to_add</code></td>
<td>
<p>A numeric matrix with the same number of rows as <code>mat_or_NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cbind(mat_or_NULL, to_add)</code>, or just <code>to_add</code> if the first argument is NULL.
</p>

<hr>
<h2 id='check_INLA'>Check INLA and PARDISO</h2><span id='topic+check_INLA'></span>

<h3>Description</h3>

<p>Check INLA and PARDISO
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_INLA(require_PARDISO = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_INLA_+3A_require_pardiso">require_PARDISO</code></td>
<td>
<p>Is PARDISO required? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='cholQsample'>Sample from the multivariate normal distribution with Cholesky(Q)</h2><span id='topic+cholQsample'></span>

<h3>Description</h3>

<p>Sample from the multivariate normal distribution with Cholesky(Q)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cholQsample(n, mu, cholQ)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cholQsample_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="cholQsample_+3A_mu">mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id="cholQsample_+3A_cholq">cholQ</code></td>
<td>
<p>Cholesky decomposition of the precision (found via <code>Matrix::Cholesky(Q)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n \times p</code> matrix of samples from the MVN distribution,
where <code class="reqn">p</code> is the length of <code>mu</code>.
</p>

<hr>
<h2 id='Connectome_Workbench_Description'>Connectome Workbench</h2><span id='topic+Connectome_Workbench_Description'></span>

<h3>Description</h3>

<p>Connectome Workbench
</p>


<h3>Connectome Workbench Requirement</h3>

<p>This function uses a system wrapper for the 'wb_command' executable. The
user must first download and install the Connectome Workbench, available
from https://www.humanconnectome.org/software/get-connectome-workbench .
</p>

<hr>
<h2 id='contrasts_Param'>contrasts</h2><span id='topic+contrasts_Param'></span>

<h3>Description</h3>

<p>contrasts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contrasts_Param_+3A_contrasts">contrasts</code></td>
<td>
<p>List of contrast vectors to be passed to <code>inla::inla</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='create_listRcpp'>Function to prepare objects for use in Rcpp functions</h2><span id='topic+create_listRcpp'></span>

<h3>Description</h3>

<p>Function to prepare objects for use in Rcpp functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_listRcpp(spde)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_listRcpp_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SPDE matrices with the correct data formats
</p>

<hr>
<h2 id='design_Param_BayesGLM'>design</h2><span id='topic+design_Param_BayesGLM'></span>

<h3>Description</h3>

<p>design
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_Param_BayesGLM_+3A_design">design</code></td>
<td>
<p>A numeric matrix or <code>data.frame</code>, or a
<code>"BayesfMRI_design"</code> object from <code>make_design</code>. Can also
be an array where the third dimension is the same length as the number of
data locations, to model each location with its own design.</p>
</td></tr>
</table>

<hr>
<h2 id='dgCMatrix_cols_to_zero'>Set column values to zero for sparse matrix</h2><span id='topic+dgCMatrix_cols_to_zero'></span>

<h3>Description</h3>

<p>Set column values to zero for sparse matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgCMatrix_cols_to_zero(mat, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgCMatrix_cols_to_zero_+3A_mat">mat</code></td>
<td>
<p>dgCMatrix</p>
</td></tr>
<tr><td><code id="dgCMatrix_cols_to_zero_+3A_cols">cols</code></td>
<td>
<p>The column indices to set to zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified sparse matrix
</p>

<hr>
<h2 id='do_QC'>Mask out invalid data</h2><span id='topic+do_QC'></span>

<h3>Description</h3>

<p>Mask out data locations that are invalid (missing data, low mean, or low
variance) for any session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_QC(BOLD, meanTol = 1e-06, varTol = 1e-06, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do_QC_+3A_bold">BOLD</code></td>
<td>
<p>A session-length list of <code class="reqn">T \times V</code> numeric BOLD data.</p>
</td></tr>
<tr><td><code id="do_QC_+3A_meantol">meanTol</code>, <code id="do_QC_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Defaults: <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="do_QC_+3A_verbose">verbose</code></td>
<td>
<p>Print messages counting how many locations are removed?
Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating locations that are valid across all sessions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nT &lt;- 30
nV &lt;- 400
BOLD1 &lt;- matrix(rnorm(nT*nV), nrow=nT)
BOLD1[,seq(30,50)] &lt;- NA
BOLD2 &lt;- matrix(rnorm(nT*nV), nrow=nT)
BOLD2[,65] &lt;- BOLD2[,65] / 1e10
BOLD &lt;- list(sess1=BOLD1, sess2=BOLD2)
do_QC(BOLD)

</code></pre>

<hr>
<h2 id='ELL'>Expected log-likelihood function</h2><span id='topic+ELL'></span>

<h3>Description</h3>

<p>Expected log-likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ELL(Q, sigma2, model_data, Psi, mu, Sigma, A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ELL_+3A_q">Q</code></td>
<td>
<p>precision matrix</p>
</td></tr>
<tr><td><code id="ELL_+3A_sigma2">sigma2</code></td>
<td>
<p>noise variance</p>
</td></tr>
<tr><td><code id="ELL_+3A_model_data">model_data</code></td>
<td>
<p>list with X and y</p>
</td></tr>
<tr><td><code id="ELL_+3A_psi">Psi</code></td>
<td>
<p>data locations to mesh locations matrix</p>
</td></tr>
<tr><td><code id="ELL_+3A_mu">mu</code></td>
<td>
<p>posterior mean of w</p>
</td></tr>
<tr><td><code id="ELL_+3A_sigma">Sigma</code></td>
<td>
<p>posterior covariance of w</p>
</td></tr>
<tr><td><code id="ELL_+3A_a">A</code></td>
<td>
<p>crossprod(X%*%Psi)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar expected log-likelihood
</p>

<hr>
<h2 id='EM_Param'>EM</h2><span id='topic+EM_Param'></span>

<h3>Description</h3>

<p>EM
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_Param_+3A_em">EM</code></td>
<td>
<p>(logical) Should the EM implementation of the Bayesian GLM be used?
Default: <code>FALSE</code>. This method is still in development.</p>
</td></tr>
</table>

<hr>
<h2 id='emTol_Param'>emTol</h2><span id='topic+emTol_Param'></span>

<h3>Description</h3>

<p>emTol
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emTol_Param_+3A_emtol">emTol</code></td>
<td>
<p>The stopping tolerance for the EM algorithm. Default:
<code>1e-3</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_estimates'>Extract Estimates of Activation</h2><span id='topic+extract_estimates'></span>

<h3>Description</h3>

<p>Obtains the posterior mean or other summary statistic for each latent field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_estimates(INLA_model_obj, session_names, spatial, spde, stat = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_estimates_+3A_inla_model_obj">INLA_model_obj</code></td>
<td>
<p>An object of class <code>"inla"</code>, a result of a call to
<code>inla</code>.</p>
</td></tr>
<tr><td><code id="extract_estimates_+3A_session_names">session_names</code></td>
<td>
<p>Vector of fMRI session names</p>
</td></tr>
<tr><td><code id="extract_estimates_+3A_stat">stat</code></td>
<td>
<p>A string representing the posterior summary statistic to be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates from inla model
</p>

<hr>
<h2 id='F.logwt'>F logwt</h2><span id='topic+F.logwt'></span>

<h3>Description</h3>

<p>Internal function used in joint approach to group-analysis for combining across models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.logwt(theta, spde, mu_theta, Q_theta, nN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F.logwt_+3A_theta">theta</code></td>
<td>
<p>A vector of hyperparameter values at which to compute the posterior log density</p>
</td></tr>
<tr><td><code id="F.logwt_+3A_spde">spde</code></td>
<td>
<p>A SPDE object from inla.spde2.matern() function, determines prior precision matrix</p>
</td></tr>
<tr><td><code id="F.logwt_+3A_mu_theta">mu_theta</code></td>
<td>
<p>Posterior mean from combined subject-level models.</p>
</td></tr>
<tr><td><code id="F.logwt_+3A_q_theta">Q_theta</code></td>
<td>
<p>Posterior precision matrix from combined subject-level models.</p>
</td></tr>
<tr><td><code id="F.logwt_+3A_nn">nN</code></td>
<td>
<p>Number of subjects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The prior density
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='faces_Param'>faces</h2><span id='topic+faces_Param'></span>

<h3>Description</h3>

<p>faces
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="faces_Param_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
</table>

<hr>
<h2 id='field_names_Param'>field_names</h2><span id='topic+field_names_Param'></span>

<h3>Description</h3>

<p>field_names
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="field_names_Param_+3A_field_names">field_names</code></td>
<td>
<p>(Optional) Names of fields represented in design matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='fit_bayesglm'>fit_bayesglm</h2><span id='topic+fit_bayesglm'></span>

<h3>Description</h3>

<p>Performs spatial Bayesian GLM for task fMRI activation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_bayesglm(
  BOLD,
  design,
  nuisance = NULL,
  scrub = NULL,
  spatial,
  scale_BOLD = c("mean", "sd", "none"),
  Bayes = TRUE,
  hyperpriors = c("informative", "default"),
  ar_order = 6,
  ar_smooth = 5,
  aic = FALSE,
  n_threads = 4,
  return_INLA = c("trimmed", "full", "minimal"),
  verbose = 1,
  meanTol = 1e-06,
  varTol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_bayesglm_+3A_bold">BOLD</code>, <code id="fit_bayesglm_+3A_design">design</code>, <code id="fit_bayesglm_+3A_nuisance">nuisance</code></td>
<td>
<p>Session-length list of numeric matrices/arrays,
each with volumes along the first dimension.</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_scrub">scrub</code></td>
<td>
<p>Session-length list of spike regressors: numeric matrices, with
volumes along the first dimension, valued at 1 for scrubbed volumes and 0
otherwise.
</p>
<p>Scrubbing is performed by incorporating spike regressors in the nuisance
matrix during nuisance regression (in a simultaneous framework), and then
removing the scrubbed timepoints from the resulting BOLD and design.</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_spatial">spatial</code></td>
<td>
<p>Gives the spatial information:
</p>

<dl>
<dt>surf</dt><dd><p>A list of two: <code>vertices</code> <code class="reqn">V \times 3</code> numeric matrix of vertex locations in XYZ coordinate space, and <code>faces</code>, <code class="reqn">F \times 3</code> matrix of positive integers defining the triangular faces.</p>
</dd>
<dt>mask</dt><dd><p>Mask of locations with valid data.</p>
</dd>
</dl>

<p>For voxel data, a list of six:
</p>

<dl>
<dt>label</dt><dd><p>3D array of labeled locations to include in the model.</p>
</dd>
<dt>trans_mat</dt><dd><p>Projection matrix to convert voxel indices to XYZ position. Can be <code>NULL</code>.</p>
</dd>
<dt>trans_units</dt><dd><p>XYZ units. Can be <code>NULL</code>.</p>
</dd>
<dt>nbhd_order</dt><dd><p>See documentation for <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</dd>
<dt>buffer</dt><dd><p>See documentation for <code><a href="#topic+BayesGLM">BayesGLM</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_scale_bold">scale_BOLD</code></td>
<td>
<p>Controls scaling the BOLD response at each location.
</p>

<dl>
<dt>&quot;mean&quot;:</dt><dd><p>   Scale the data to percent local signal change.</p>
</dd>
<dt>&quot;sd&quot;:</dt><dd><p>   Scale the data by local standard deviation.</p>
</dd>
<dt>&quot;none&quot;:</dt><dd><p>   Center the data but do not scale it.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_bayes">Bayes</code></td>
<td>
<p>Perform spatial Bayesian modeling? Default: <code>TRUE</code>. If
<code>FALSE</code>, only perform classical (massive univariate) modeling. (The classical GLM
result is always returned, whether <code>Bayes</code> is <code>TRUE</code> or <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_hyperpriors">hyperpriors</code></td>
<td>
<p>Should informative or default non-informative hyperpriors be assumed on SPDE hyperparameters?</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_ar_order">ar_order</code></td>
<td>
<p>(For prewhitening) The order of the autoregressive (AR) model
to use for prewhitening. If <code>0</code>, do not prewhiten. Default: <code>6</code>.
</p>
<p>For multi-session modeling, note that a single AR model is used; its
coefficients will be the average estimate from each session.</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_ar_smooth">ar_smooth</code></td>
<td>
<p>(For prewhitening) The FWHM parameter for spatially
smoothing the coefficient estimates for the AR model to use for
prewhitening. Recall that
<code class="reqn">\sigma = \frac{FWHM}{2*sqrt(2*log(2)}</code>. Set to <code>0</code> to not smooth
the estimates. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_aic">aic</code></td>
<td>
<p>(For prewhitening) Use the Akaike information criterion (AIC) to
select AR model orders between <code>0</code> and <code>ar_order</code>? Default:
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_n_threads">n_threads</code></td>
<td>
<p>The maximum number of threads to use for parallel
computations: prewhitening parameter estimation, and the inla-program model
estimation. Default: <code>4</code>. Note that parallel prewhitening requires the
<code>parallel</code> package.</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_return_inla">return_INLA</code></td>
<td>
<p>Return the INLA model object? (It can be large.) Use
<code>"trimmed"</code> (default) returns the results sufficient for
<code><a href="#topic+activations">activations</a></code> and <code><a href="#topic+BayesGLM2">BayesGLM2</a></code>; <code>"minimal"</code>
returns enough for <code><a href="#topic+BayesGLM2">BayesGLM2</a></code> but not
<code><a href="#topic+activations">activations</a></code>; <code>"full"</code> returns the full <code>inla</code>
output.</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_verbose">verbose</code></td>
<td>
<p><code>1</code> (default) to print occasional updates during model
computation; <code>2</code> for occasional updates as well as running INLA in
verbose mode (if <code>Bayes</code>), or <code>0</code> for no printed updates.</p>
</td></tr>
<tr><td><code id="fit_bayesglm_+3A_meantol">meanTol</code>, <code id="fit_bayesglm_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean, variance and SNR of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Default: <code>1e-6</code> for mean and variance, <code>50</code> for SNR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"BayesGLM"</code> object: a list with elements
</p>

<dl>
<dt>INLA_model_obj</dt><dd><p>The full result of the call to <code>INLA::inla</code>.</p>
</dd>
<dt>field_estimates</dt><dd><p>The estimated coefficients for the Bayesian model.</p>
</dd>
<dt>result_classical</dt><dd><p>Results from the classical model: field estimates, field standard error estimates, residuals, degrees of freedom, and the mask.</p>
</dd>
<dt>mesh</dt><dd><p>The model mesh.</p>
</dd>
<dt>mask</dt><dd><p>A mask of <code>mesh</code> indicating the locations inside <code>mesh</code>.</p>
</dd>
<dt>design</dt><dd><p>The design matrix, after centering and scaling, but before any nuisance regression or prewhitening.</p>
</dd>
<dt>field_names</dt><dd><p>The names of the fields.</p>
</dd>
<dt>session_names</dt><dd><p>The names of the sessions.</p>
</dd>
<dt>hyperpar_posteriors</dt><dd><p>Hyperparameter posterior densities.</p>
</dd>
<dt>theta_estimates</dt><dd><p>Theta estimates from the Bayesian model.</p>
</dd>
<dt>posterior_Sig_inv</dt><dd><p>For joint group modeling.</p>
</dd>
<dt>mu_theta</dt><dd><p>For joint group modeling.</p>
</dd>
<dt>Q_theta</dt><dd><p>For joint group modeling.</p>
</dd>
<dt>y</dt><dd><p>For joint group modeling: The BOLD data after any centering, scaling, nuisance regression, or prewhitening.</p>
</dd>
<dt>X</dt><dd><p>For joint group modeling: The design matrix after any centering, scaling, nuisance regression, or prewhitening.</p>
</dd>
<dt>prewhiten_info</dt><dd><p>Vectors of values across locations: <code>phi</code> (AR coefficients averaged across sessions), <code>sigma_sq</code> (residual variance averaged across sessions), and AIC (the maximum across sessions).</p>
</dd>
<dt>call</dt><dd><p>match.call() for this function call.</p>
</dd>
</dl>



<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='galerkin_db'>Create FEM matrices</h2><span id='topic+galerkin_db'></span>

<h3>Description</h3>

<p>Create FEM matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galerkin_db(FV, P, surface = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="galerkin_db_+3A_fv">FV</code></td>
<td>
<p>Matrix of faces in triangularization</p>
</td></tr>
<tr><td><code id="galerkin_db_+3A_p">P</code></td>
<td>
<p>Matrix of vertex locations in triangularization</p>
</td></tr>
<tr><td><code id="galerkin_db_+3A_surface">surface</code></td>
<td>
<p>(logical) Will this create the SPDE matrices for a surface
or not?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices C and G appearing in sparse SPDE precision
</p>

<hr>
<h2 id='get_nV'>Get number of locations for various masks</h2><span id='topic+get_nV'></span>

<h3>Description</h3>

<p>Get number of locations for various masks: total, model, data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nV(spatial)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_nV_+3A_spatial">spatial</code></td>
<td>
<p><code>spatial</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two: <code>T</code> for the total number of locations, and
<code>D</code> for the number of data locations. If <code>spatial</code> is provided for
voxel data, there is also <code>DB</code> for the number of data locations plus
the number of boundary locations.
</p>

<hr>
<h2 id='get_posterior_densities'>Extracts posterior density estimates for hyperparameters</h2><span id='topic+get_posterior_densities'></span>

<h3>Description</h3>

<p>Extracts posterior density estimates for hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_posterior_densities(INLA_model_obj, spde, field_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_posterior_densities_+3A_inla_model_obj">INLA_model_obj</code></td>
<td>
<p>An object of class <code>"inla"</code>, a result of a call to
<code>inla()</code></p>
</td></tr>
<tr><td><code id="get_posterior_densities_+3A_spde">spde</code></td>
<td>
<p>The model used for the latent fields in the <code>inla()</code> call,
an object of class <code>"inla.spde"</code></p>
</td></tr>
<tr><td><code id="get_posterior_densities_+3A_field_names">field_names</code></td>
<td>
<p>Descriptive names of model regressors (fields).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Long-form data frame containing posterior densities for the
hyperparameters associated with each latent field
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='get_posterior_densities2'>Extracts posterior density estimates for hyperparameters for volumetric SPDE</h2><span id='topic+get_posterior_densities2'></span>

<h3>Description</h3>

<p>Extracts posterior density estimates for hyperparameters for volumetric SPDE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_posterior_densities2(INLA_model_obj, field_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_posterior_densities2_+3A_inla_model_obj">INLA_model_obj</code></td>
<td>
<p>An object of class <code>"inla"</code>, a result of a call to
<code>inla()</code></p>
</td></tr>
<tr><td><code id="get_posterior_densities2_+3A_field_names">field_names</code></td>
<td>
<p>Descriptive names of model regressors (fields).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Long-form data frame containing posterior densities for the
hyperparameters associated with each latent field
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='GLM_classical'>Classical GLM</h2><span id='topic+GLM_classical'></span>

<h3>Description</h3>

<p>Classical GLM for fit_bayesglm (internal function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLM_classical(
  BOLD,
  design,
  nK2,
  nV_input,
  field_names,
  design_type,
  valid_cols,
  nT,
  do_pw,
  compute_SE = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM_classical_+3A_bold">BOLD</code></td>
<td>
<p>BOLD timeseries in vector form (TVx1), result of <code>sparse_and_PW</code></p>
</td></tr>
<tr><td><code id="GLM_classical_+3A_design">design</code></td>
<td>
<p>List of large sparse design matrices (each TVxV), one per regressor, result of <code>sparse_and_PW</code></p>
</td></tr>
<tr><td><code id="GLM_classical_+3A_nk2">nK2</code>, <code id="GLM_classical_+3A_nv_input">nV_input</code>, <code id="GLM_classical_+3A_field_names">field_names</code>, <code id="GLM_classical_+3A_design_type">design_type</code></td>
<td>
<p>See <code>fit_bayesglm</code>.</p>
</td></tr>
<tr><td><code id="GLM_classical_+3A_valid_cols">valid_cols</code>, <code id="GLM_classical_+3A_nt">nT</code></td>
<td>
<p>See <code>fit_bayesglm</code>.</p>
</td></tr>
<tr><td><code id="GLM_classical_+3A_do_pw">do_pw</code></td>
<td>
<p>Has prewhitening been performed on the data and design?</p>
</td></tr>
<tr><td><code id="GLM_classical_+3A_compute_se">compute_SE</code></td>
<td>
<p>Compute SE of model coefficients?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results
</p>

<hr>
<h2 id='GLM_compare'>Classical GLM for multiple models</h2><span id='topic+GLM_compare'></span>

<h3>Description</h3>

<p>Classical GLM for multiple models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLM_compare(...)
</code></pre>

<hr>
<h2 id='GLM_est_resid_var_pw'>Standardize data variance, and prewhiten if applicable</h2><span id='topic+GLM_est_resid_var_pw'></span>

<h3>Description</h3>

<p>Standardize data variance and prewhiten if applicable, for the GLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLM_est_resid_var_pw(
  BOLD,
  design,
  spatial,
  session_names,
  field_names,
  design_type,
  valid_cols,
  nT,
  ar_order,
  ar_smooth,
  aic,
  n_threads,
  do_pw
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM_est_resid_var_pw_+3A_bold">BOLD</code>, <code id="GLM_est_resid_var_pw_+3A_design">design</code>, <code id="GLM_est_resid_var_pw_+3A_spatial">spatial</code></td>
<td>
<p>See <code>fit_bayesglm</code>.</p>
</td></tr>
<tr><td><code id="GLM_est_resid_var_pw_+3A_session_names">session_names</code>, <code id="GLM_est_resid_var_pw_+3A_field_names">field_names</code>, <code id="GLM_est_resid_var_pw_+3A_design_type">design_type</code></td>
<td>
<p>See <code>fit_bayesglm</code>.</p>
</td></tr>
<tr><td><code id="GLM_est_resid_var_pw_+3A_valid_cols">valid_cols</code>, <code id="GLM_est_resid_var_pw_+3A_nt">nT</code>, <code id="GLM_est_resid_var_pw_+3A_do_pw">do_pw</code></td>
<td>
<p>See <code>fit_bayesglm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of results
</p>

<hr>
<h2 id='GLMEM_fixptseparate'>Fixed point function for the joint BayesGLM EM update algorithm</h2><span id='topic+GLMEM_fixptseparate'></span>

<h3>Description</h3>

<p>Fixed point function for the joint BayesGLM EM update algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMEM_fixptseparate(theta, spde, model_data, Psi, K, A, cl, Ns = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLMEM_fixptseparate_+3A_theta">theta</code></td>
<td>
<p>a list containing kappa2, phi, and sigma2, in that order</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_spde">spde</code></td>
<td>
<p>the spde object</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_model_data">model_data</code></td>
<td>
<p>the model_data object containing <code>y</code> and <code>X</code></p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_psi">Psi</code></td>
<td>
<p>a conversion matrix (N by V) (or N by n)</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_k">K</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_a">A</code></td>
<td>
<p>The value for Matrix::crossprod(X%*%Psi) (saves time on computation)</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_cl">cl</code></td>
<td>
<p>parallelization cluster</p>
</td></tr>
<tr><td><code id="GLMEM_fixptseparate_+3A_ns">Ns</code></td>
<td>
<p>The number of samples used to approximate traces using the Hutchinson
estimator. If set to 0, the exact trace is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the same length as <code>theta</code>, the EM updates
</p>

<hr>
<h2 id='GLMEM_objfn'>Objective function for the BayesGLM EM algorithm</h2><span id='topic+GLMEM_objfn'></span>

<h3>Description</h3>

<p>This returns the negative of the expected log-likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMEM_objfn(theta, spde, model_data, Psi, K, A, n_threads = NULL, Ns = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLMEM_objfn_+3A_theta">theta</code></td>
<td>
<p>a vector containing kappa2, phi, and sigma2, in that order</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_spde">spde</code></td>
<td>
<p>the spde object</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_model_data">model_data</code></td>
<td>
<p>the model_data object containing <code>y</code> and <code>X</code></p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_psi">Psi</code></td>
<td>
<p>a conversion matrix (N by V) (or N by n)</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_k">K</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_a">A</code></td>
<td>
<p>The value for Matrix::crossprod(X%*%Psi) (saves time on computation)</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_n_threads">n_threads</code></td>
<td>
<p>Needed for SQUAREM (it is an argument to the fixed-point functions)</p>
</td></tr>
<tr><td><code id="GLMEM_objfn_+3A_ns">Ns</code></td>
<td>
<p>The number of samples used to approximate traces using the Hutchinson
estimator. If set to 0, the exact trace is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value for the negative expected log-likelihood
</p>

<hr>
<h2 id='hpf_Param_BayesGLM'>hpf</h2><span id='topic+hpf_Param_BayesGLM'></span>

<h3>Description</h3>

<p>hpf
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hpf_Param_BayesGLM_+3A_hpf">hpf</code></td>
<td>
<p>Add DCT bases to <code>nuisance</code> to apply a temporal high-pass
filter to the data, for detrending? <code>hpf</code> is the filter frequency.
Use <code>NULL</code> to skip detrending. Detrending is strongly recommended for
fMRI data, to help reduce the autocorrelation in the residuals, so
<code>NULL</code> will induce a warning. Use <code>"already"</code> to disable the
warning while skipping highpass filtering.
</p>
<p>Using at least two DCT bases is as sufficient for detrending as using linear
and quadratic drift terms in the nuisance matrix. So if DCT detrending is
being used here, there is no need to add linear and quadratic drift terms to
<code>nuisance</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='init_fixpt'>The fix point function for the initialization of kappa2 and phi</h2><span id='topic+init_fixpt'></span>

<h3>Description</h3>

<p>The fix point function for the initialization of kappa2 and phi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_fixpt(theta, spde, beta_hat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_fixpt_+3A_theta">theta</code></td>
<td>
<p>a vector c(kappa2,phi)</p>
</td></tr>
<tr><td><code id="init_fixpt_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="init_fixpt_+3A_beta_hat">beta_hat</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar
</p>

<hr>
<h2 id='init_objfn'>Objective function for the initialization of kappa2 and phi</h2><span id='topic+init_objfn'></span>

<h3>Description</h3>

<p>Objective function for the initialization of kappa2 and phi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_objfn(theta, spde, beta_hat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_objfn_+3A_theta">theta</code></td>
<td>
<p>a vector c(kappa2,phi)</p>
</td></tr>
<tr><td><code id="init_objfn_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="init_objfn_+3A_beta_hat">beta_hat</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar
</p>

<hr>
<h2 id='INLA_deps'>Import INLA dependencies</h2><span id='topic+INLA_deps'></span>

<h3>Description</h3>

<p>Roxygen entry for additional INLA dependencies
</p>

<hr>
<h2 id='INLA_Description'>INLA</h2><span id='topic+INLA_Description'></span>

<h3>Description</h3>

<p>INLA
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='INLA_Latent_Fields_Limit_Description'>INLA Latent Fields</h2><span id='topic+INLA_Latent_Fields_Limit_Description'></span>

<h3>Description</h3>

<p>INLA Latent Fields
</p>


<h3>INLA Latent Fields Limit</h3>

<p>INLA computation times increase greatly when the number of columns in the
design matrix exceeds five: when there are more than five tasks, or more
than three tasks each with a temporal derivative modeled as a field. In
cases like the latter, we recommend modeling the temporal derivatives as
nuisance signals using the option <code>dHRF_as="nuisance"</code>, rather than
modeling the temporal derivatives as fields.
</p>

<hr>
<h2 id='intersect_mask'>Intersection mask for BayesGLM or activations result</h2><span id='topic+intersect_mask'></span>

<h3>Description</h3>

<p>Intersection mask for BayesGLM or activations result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect_mask(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersect_mask_+3A_x">x</code></td>
<td>
<p>The list of <code>"fit_bglm"</code>, <code>"BGLM"</code>, or <code>"act_BGLM"</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The intersections masks
</p>

<hr>
<h2 id='is_matrix_or_df'>Is a matrix or data.frame?</h2><span id='topic+is_matrix_or_df'></span>

<h3>Description</h3>

<p>Is this a matrix or data.frame?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_matrix_or_df(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_matrix_or_df_+3A_x">x</code></td>
<td>
<p>The object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length-one logical.
</p>

<hr>
<h2 id='kappa_init_fn'>Function to optimize over kappa2</h2><span id='topic+kappa_init_fn'></span>

<h3>Description</h3>

<p>Function to optimize over kappa2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappa_init_fn(kappa2, phi, spde, beta_hat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kappa_init_fn_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="kappa_init_fn_+3A_phi">phi</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="kappa_init_fn_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="kappa_init_fn_+3A_beta_hat">beta_hat</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='log_kappa_tau'>Make <code>log_kappa</code> and <code>log_tau</code></h2><span id='topic+log_kappa_tau'></span>

<h3>Description</h3>

<p>Make <code>log_kappa</code> and <code>log_tau</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_kappa_tau(spatial, hyperpriors, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_kappa_tau_+3A_spatial">spatial</code>, <code id="log_kappa_tau_+3A_hyperpriors">hyperpriors</code>, <code id="log_kappa_tau_+3A_verbose">verbose</code></td>
<td>
<p>See <code>fit_bayesglm</code></p>
</td></tr>
</table>

<hr>
<h2 id='make_A_mat'>Make A matrix</h2><span id='topic+make_A_mat'></span>

<h3>Description</h3>

<p>Make A matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_A_mat(spatial)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_A_mat_+3A_spatial">spatial</code></td>
<td>
<p>See <code>BayesGLM</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The A matrix
</p>

<hr>
<h2 id='make_A_mat_rs'>Make A matrix with resampling framework</h2><span id='topic+make_A_mat_rs'></span>

<h3>Description</h3>

<p>Make the A matrix for downsampling surface mesh data to a lower resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_A_mat_rs(surf, surf_rs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_A_mat_rs_+3A_surf">surf</code></td>
<td>
<p>The full-resolution <code>"surf"</code> object.</p>
</td></tr>
<tr><td><code id="make_A_mat_rs_+3A_surf_rs">surf_rs</code></td>
<td>
<p>The downsampled <code>"surf"</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The A matrix
</p>

<hr>
<h2 id='make_data_list'>Make data list for <code>estimate_model</code></h2><span id='topic+make_data_list'></span>

<h3>Description</h3>

<p>Make data list to be passed to <code>estimate_model</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_data_list(y, X, betas, repls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_data_list_+3A_y">y</code></td>
<td>
<p>Vectorized BOLD data (all voxels, sessions, etc.)</p>
</td></tr>
<tr><td><code id="make_data_list_+3A_x">X</code></td>
<td>
<p>List (length = number of sessions) of sparse design matrices size TVxVK from each session, each created using <code>sparse_and_PW</code></p>
</td></tr>
<tr><td><code id="make_data_list_+3A_betas">betas</code></td>
<td>
<p>List (length = number of fields) of beta objects from make_replicates</p>
</td></tr>
<tr><td><code id="make_data_list_+3A_repls">repls</code></td>
<td>
<p>List (length = number of fields) of repl objects from make_replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>

<hr>
<h2 id='make_mesh'>Make Mesh</h2><span id='topic+make_mesh'></span>

<h3>Description</h3>

<p>Make INLA triangular mesh from faces and vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mesh(vertices, faces)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_mesh_+3A_vertices">vertices</code></td>
<td>
<p>A <code class="reqn">V \times 3</code> matrix, where each row contains the Euclidean
coordinates at which a given vertex in the mesh is located. <code class="reqn">V</code> is the
number of vertices in the mesh</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>INLA triangular mesh
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='make_Q'>Make the full SPDE precision based on theta, the spde, and the number of sessions</h2><span id='topic+make_Q'></span>

<h3>Description</h3>

<p>Make the full SPDE precision based on theta, the spde, and the number of sessions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Q(theta, spde, n_sess)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_Q_+3A_theta">theta</code></td>
<td>
<p>the hyperparameter theta vector of length K * 2 + 1, where the
first K elements are the kappas, the next K elements are the phis, and the
last element (unused here) corresponds to sigma2</p>
</td></tr>
<tr><td><code id="make_Q_+3A_spde">spde</code></td>
<td>
<p>a list containing three spde elements: Cmat, Gmat, and GtCinvG</p>
</td></tr>
<tr><td><code id="make_Q_+3A_n_sess">n_sess</code></td>
<td>
<p>The integer number of sessions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An SPDE prior matrix
</p>

<hr>
<h2 id='make_replicates'>Make replicates</h2><span id='topic+make_replicates'></span>

<h3>Description</h3>

<p>beta and repl vectors are of length <code class="reqn">nMesh \times nSess \times n_field</code>.
The ith repl vector is an indicator vector for the cells corresponding to the ith column of x.
The ith beta vector contains data indices (e.g. 1,...,V) in the cells corresponding to the ith column of x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_replicates(nSess, field_names, spatial)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_replicates_+3A_nsess">nSess</code></td>
<td>
<p>The number of sessions sharing hyperparameters (can be different fields)</p>
</td></tr>
<tr><td><code id="make_replicates_+3A_field_names">field_names</code></td>
<td>
<p>Vector of names for each field</p>
</td></tr>
<tr><td><code id="make_replicates_+3A_spatial">spatial</code></td>
<td>
<p>Spatial info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>replicates vector and betas for sessions
</p>

<hr>
<h2 id='make_sqrtInv_all'>Make <code>sqrtInv_all</code></h2><span id='topic+make_sqrtInv_all'></span>

<h3>Description</h3>

<p>Make <code>sqrtInv_all</code> for prewhitening
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sqrtInv_all(nT, nV, do_pw, n_threads, ar_order, AR_coefs_avg, var_avg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_sqrtInv_all_+3A_nt">nT</code>, <code id="make_sqrtInv_all_+3A_nv">nV</code>, <code id="make_sqrtInv_all_+3A_do_pw">do_pw</code>, <code id="make_sqrtInv_all_+3A_n_threads">n_threads</code>, <code id="make_sqrtInv_all_+3A_ar_order">ar_order</code>, <code id="make_sqrtInv_all_+3A_ar_coefs_avg">AR_coefs_avg</code>, <code id="make_sqrtInv_all_+3A_var_avg">var_avg</code></td>
<td>
<p>See <code><a href="#topic+GLM_est_resid_var_pw">GLM_est_resid_var_pw</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sqrtInv_all</code>
</p>

<hr>
<h2 id='mask_Param_vertices'>mask: vertices</h2><span id='topic+mask_Param_vertices'></span>

<h3>Description</h3>

<p>mask: vertices
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mask_Param_vertices_+3A_mask">mask</code></td>
<td>
<p>A length <code class="reqn">V</code> logical vector indicating if each vertex is
within the input mask.</p>
</td></tr>
</table>

<hr>
<h2 id='max_threads_Param'>max_threads</h2><span id='topic+max_threads_Param'></span>

<h3>Description</h3>

<p>max_threads
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_threads_Param_+3A_max_threads">max_threads</code></td>
<td>
<p>The maximum number of threads to use in the inla-program
for model estimation. <code>0</code> (default) will use the maximum number of
threads allowed by the system.</p>
</td></tr>
</table>

<hr>
<h2 id='mean_var_Tol_Param'>mean and variance tolerance</h2><span id='topic+mean_var_Tol_Param'></span>

<h3>Description</h3>

<p>mean and variance tolerance
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_var_Tol_Param_+3A_meantol">meanTol</code>, <code id="mean_var_Tol_Param_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Default: <code>1e-6</code> for both.</p>
</td></tr>
</table>

<hr>
<h2 id='mesh_Param_either'>mesh: either</h2><span id='topic+mesh_Param_either'></span>

<h3>Description</h3>

<p>mesh: either
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh_Param_either_+3A_mesh">mesh</code></td>
<td>
<p>An <code>"inla.mesh"</code> object (see <code><a href="#topic+make_mesh">make_mesh</a></code> for
surface data)</p>
</td></tr>
</table>

<hr>
<h2 id='mesh_Param_inla'>mesh: INLA only</h2><span id='topic+mesh_Param_inla'></span>

<h3>Description</h3>

<p>mesh: INLA only
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh_Param_inla_+3A_mesh">mesh</code></td>
<td>
<p>An <code>"inla.mesh"</code> object (see <code><a href="#topic+make_mesh">make_mesh</a></code> for
surface data).</p>
</td></tr>
</table>

<hr>
<h2 id='n_threads_Param'>n_threads</h2><span id='topic+n_threads_Param'></span>

<h3>Description</h3>

<p>n_threads
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_threads_Param_+3A_n_threads">n_threads</code></td>
<td>
<p>The maximum number of threads to use for parallel
computations: prewhitening parameter estimation, and the inla-program model
estimation. Default: <code>4</code>. Note that parallel prewhitening requires the
<code>parallel</code> package.</p>
</td></tr>
</table>

<hr>
<h2 id='nbhd_order_Param'>nbhd_order</h2><span id='topic+nbhd_order_Param'></span>

<h3>Description</h3>

<p>nbhd_order
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nbhd_order_Param_+3A_nbhd_order">nbhd_order</code></td>
<td>
<p>For volumetric model. What order neighborhood around data
locations to keep? <code>0</code> for no neighbors, <code>1</code> for 1st-order
neighbors, <code>2</code> for 1st- and 2nd-order neighbors, etc. Smaller values
will provide greater computational efficiency at the cost of higher variance
around the edge of the data.</p>
</td></tr>
</table>

<hr>
<h2 id='neg_kappa_fn'>The negative of the objective function for kappa</h2><span id='topic+neg_kappa_fn'></span>

<h3>Description</h3>

<p>The negative of the objective function for kappa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_kappa_fn(kappa2, spde, phi, Sigma, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neg_kappa_fn_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="neg_kappa_fn_+3A_phi">phi</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn_+3A_sigma">Sigma</code></td>
<td>
<p>dgCMatrix</p>
</td></tr>
<tr><td><code id="neg_kappa_fn_+3A_mu">mu</code></td>
<td>
<p>dgeMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='neg_kappa_fn2'>The negative of the objective function for kappa without Sig_inv</h2><span id='topic+neg_kappa_fn2'></span>

<h3>Description</h3>

<p>The negative of the objective function for kappa without Sig_inv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_kappa_fn2(kappa2, spde, phi, P, mu, Vh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neg_kappa_fn2_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_phi">phi</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_p">P</code></td>
<td>
<p>Matrix of dimension nk by N_s found by <code>solve(Sig_inv,Vh)</code></p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_mu">mu</code></td>
<td>
<p>dgeMatrix</p>
</td></tr>
<tr><td><code id="neg_kappa_fn2_+3A_vh">Vh</code></td>
<td>
<p>random matrix of -1 and 1 of dim <code>dim(P)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='neg_kappa_fn3'>Streamlined negative objective function for kappa2 using precompiled values</h2><span id='topic+neg_kappa_fn3'></span>

<h3>Description</h3>

<p>Streamlined negative objective function for kappa2 using precompiled values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_kappa_fn3(kappa2, spde, a_star, b_star, n_sess)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neg_kappa_fn3_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn3_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="neg_kappa_fn3_+3A_a_star">a_star</code></td>
<td>
<p>precomputed coefficient (scalar)</p>
</td></tr>
<tr><td><code id="neg_kappa_fn3_+3A_b_star">b_star</code></td>
<td>
<p>precomputed coefficient (scalar)</p>
</td></tr>
<tr><td><code id="neg_kappa_fn3_+3A_n_sess">n_sess</code></td>
<td>
<p>number of sessions (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar output of the negative objective function
</p>

<hr>
<h2 id='neg_kappa_fn4'>Streamlined negative objective function for kappa2 using precompiled values</h2><span id='topic+neg_kappa_fn4'></span>

<h3>Description</h3>

<p>Streamlined negative objective function for kappa2 using precompiled values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_kappa_fn4(kappa2, spde, a_star, b_star, n_sess)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neg_kappa_fn4_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="neg_kappa_fn4_+3A_spde">spde</code></td>
<td>
<p>a list of SPDE prior matrices from</p>
</td></tr>
<tr><td><code id="neg_kappa_fn4_+3A_a_star">a_star</code></td>
<td>
<p>precomputed coefficient (scalar)</p>
</td></tr>
<tr><td><code id="neg_kappa_fn4_+3A_b_star">b_star</code></td>
<td>
<p>precomputed coefficient (scalar)</p>
</td></tr>
<tr><td><code id="neg_kappa_fn4_+3A_n_sess">n_sess</code></td>
<td>
<p>number of sessions (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar output of the negative objective function
</p>

<hr>
<h2 id='nuisance_Param_BayesGLM'>nuisance</h2><span id='topic+nuisance_Param_BayesGLM'></span>

<h3>Description</h3>

<p>nuisance
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nuisance_Param_BayesGLM_+3A_nuisance">nuisance</code></td>
<td>
<p>(Optional) A <code class="reqn">T \times N_{nuis}</code> matrix of nuisance signals,
where <code class="reqn">T</code> is the number of timepoints and <code class="reqn">N</code> is the number of
nuisance signals, or a list of these for multi-session analysis. Nuisance
signals are regressed from the fMRI data and design matrix prior to GLM
computation. Nuisance signals can include motion regressors, HRF derivatives
not being modeled as tasks, and other sources of noise.
</p>
<p>Detrending/high-pass filtering is accomplished by adding DCT bases to the
nuisance matrix; see the parameters <code>hpf</code> and <code>DCT</code>.
</p>
<p>Do not add spike regressors for scrubbing to the <code>nuisance</code> matrix.
Rather, provide these in <code>scrub</code> so that their corresponding timepoints
are also removed from the BOLD data after nuisance regression.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.act_BGLM'>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"act_BGLM"</code> object</h2><span id='topic+plot.act_BGLM'></span>

<h3>Description</h3>

<p>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"act_BGLM"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'act_BGLM'
plot(x, idx = NULL, title = NULL, session = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.act_BGLM_+3A_x">x</code></td>
<td>
<p>An object of class &quot;act_BGLM&quot;</p>
</td></tr>
<tr><td><code id="plot.act_BGLM_+3A_idx">idx</code></td>
<td>
<p>Which field should be plotted? Give the numeric indices or the
names. <code>NULL</code> (default) will show all fields. This argument overrides
the <code>idx</code> argument to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code>.</p>
</td></tr>
<tr><td><code id="plot.act_BGLM_+3A_title">title</code></td>
<td>
<p>If NULL, the field names associated with idx will be used.</p>
</td></tr>
<tr><td><code id="plot.act_BGLM_+3A_session">session</code></td>
<td>
<p>Which session should be plotted? <code>NULL</code> (default) will
use the first.</p>
</td></tr>
<tr><td><code id="plot.act_BGLM_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the call to <code>ciftiTools::view_cifti_surface</code>.
</p>

<hr>
<h2 id='plot.BGLM'>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"BGLM"</code> object</h2><span id='topic+plot.BGLM'></span>

<h3>Description</h3>

<p>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"BGLM"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGLM'
plot(
  x,
  Bayes = NULL,
  idx = NULL,
  title = NULL,
  session = NULL,
  zlim = c(-1, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.BGLM_+3A_x">x</code></td>
<td>
<p>An object of class &quot;BGLM&quot;</p>
</td></tr>
<tr><td><code id="plot.BGLM_+3A_bayes">Bayes</code></td>
<td>
<p><code>TRUE</code> for plotting Bayesian results, <code>FALSE</code> for plotting
classical GLM results. Default: <code>NULL</code>, which will use the Bayesian results
if available and the classical results if not.</p>
</td></tr>
<tr><td><code id="plot.BGLM_+3A_idx">idx</code></td>
<td>
<p>Which field should be plotted? Give the numeric indices or the
names. <code>NULL</code> (default) will show all fields. This argument overrides
the <code>idx</code> argument to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code>.</p>
</td></tr>
<tr><td><code id="plot.BGLM_+3A_title">title</code></td>
<td>
<p>If NULL, the field names associated with idx will be used.</p>
</td></tr>
<tr><td><code id="plot.BGLM_+3A_session">session</code></td>
<td>
<p>Which session should be plotted? <code>NULL</code> (default) will
use the first.</p>
</td></tr>
<tr><td><code id="plot.BGLM_+3A_zlim">zlim</code></td>
<td>
<p>Overrides the <code>zlim</code> argument for
<code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code>. Default: <code>c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="plot.BGLM_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the call to <code>ciftiTools::view_cifti</code>.
</p>

<hr>
<h2 id='plot.BGLM2'>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"BGLM2"</code> object</h2><span id='topic+plot.BGLM2'></span>

<h3>Description</h3>

<p>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"BGLM2"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGLM2'
plot(x, idx = NULL, stat = c("contrasts", "activations"), zlim = c(-1, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.BGLM2_+3A_x">x</code></td>
<td>
<p>An object of class &quot;BGLM2&quot;</p>
</td></tr>
<tr><td><code id="plot.BGLM2_+3A_idx">idx</code></td>
<td>
<p>Which contrast should be plotted? Give the numeric indices or the
names. <code>NULL</code> (default) will show all contrasts. This argument
overrides the <code>idx</code> argument to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code>.</p>
</td></tr>
<tr><td><code id="plot.BGLM2_+3A_stat">stat</code></td>
<td>
<p>Estimates of the <code>"contrasts"</code> (default), or their
thresholded <code>"activations"</code>.</p>
</td></tr>
<tr><td><code id="plot.BGLM2_+3A_zlim">zlim</code></td>
<td>
<p>Overrides the <code>zlim</code> argument for
<code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code>. Default: <code>c(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="plot.BGLM2_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the call to <code>ciftiTools::view_cifti</code>.
</p>

<hr>
<h2 id='plot.prev_BGLM'>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"prev_BGLM"</code> object</h2><span id='topic+plot.prev_BGLM'></span>

<h3>Description</h3>

<p>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"prev_BGLM"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prev_BGLM'
plot(
  x,
  idx = NULL,
  session = NULL,
  drop_zeros = NULL,
  colors = "plasma",
  zlim = c(0, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.prev_BGLM_+3A_x">x</code></td>
<td>
<p>An object of class &quot;prev_BGLM&quot;</p>
</td></tr>
<tr><td><code id="plot.prev_BGLM_+3A_idx">idx</code></td>
<td>
<p>Which task should be plotted? Give the numeric indices or the
names. <code>NULL</code> (default) will show all tasks. This argument overrides
the <code>idx</code> argument to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prev_BGLM_+3A_session">session</code></td>
<td>
<p>Which session should be plotted? <code>NULL</code> (default) will
use the first.</p>
</td></tr>
<tr><td><code id="plot.prev_BGLM_+3A_drop_zeros">drop_zeros</code></td>
<td>
<p>Color locations without any activation across all results
(zero prevalence) the same color as the medial wall? Default: <code>NULL</code> to
drop the zeros if only one <code>idx</code> is being plotted.</p>
</td></tr>
<tr><td><code id="plot.prev_BGLM_+3A_colors">colors</code>, <code id="plot.prev_BGLM_+3A_zlim">zlim</code></td>
<td>
<p>See <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prev_BGLM_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the call to <code>ciftiTools::view_cifti_surface</code>.
</p>

<hr>
<h2 id='prep_kappa2_optim'>Find values for coefficients used in objective function for kappa2</h2><span id='topic+prep_kappa2_optim'></span>

<h3>Description</h3>

<p>Find values for coefficients used in objective function for kappa2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_kappa2_optim(spde, mu, phi, P, vh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_kappa2_optim_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
<tr><td><code id="prep_kappa2_optim_+3A_mu">mu</code></td>
<td>
<p>the mean</p>
</td></tr>
<tr><td><code id="prep_kappa2_optim_+3A_phi">phi</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="prep_kappa2_optim_+3A_p">P</code></td>
<td>
<p>Matrix of dimension nk by N_s found by <code>solve(Sig_inv,Vh)</code></p>
</td></tr>
<tr><td><code id="prep_kappa2_optim_+3A_vh">vh</code></td>
<td>
<p>random matrix of -1 and 1 of dim <code>dim(P)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two elements, which are precomputed coefficients for the
optimization function
</p>

<hr>
<h2 id='prevalence'>Activations prevalence.</h2><span id='topic+prevalence'></span>

<h3>Description</h3>

<p>Activations prevalence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prevalence(
  act_list,
  gamma_idx = 1,
  p_test = NULL,
  alpha = 0.05,
  correction = c("FWER", "FDR", "none")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prevalence_+3A_act_list">act_list</code></td>
<td>
<p>List of activations from <code><a href="#topic+activations">activations</a></code>. All
should have the same sessions, fields, and brainstructures.</p>
</td></tr>
<tr><td><code id="prevalence_+3A_gamma_idx">gamma_idx</code></td>
<td>
<p>If activations at multiple thresholds were computed, which
threshold should be used for prevalence? Default: the first (lowest).</p>
</td></tr>
<tr><td><code id="prevalence_+3A_p_test">p_test</code></td>
<td>
<p>For inference: the expected baseline rate of activation for all
data locations, under the null hypothesis. Default: <code>NULL</code> (do not
perform hypothesis testing).</p>
</td></tr>
<tr><td><code id="prevalence_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for inference. Default: <code>.05</code>.</p>
</td></tr>
<tr><td><code id="prevalence_+3A_correction">correction</code></td>
<td>
<p>For the classical method only: Type of multiple comparisons
correction: <code>"FWER"</code> (Bonferroni correction, the default), <code>"FDR"</code>
(Benjamini Hochberg), or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the prevalences of activation, as a proportion of
the results from <code>act_list</code>.
</p>

<hr>
<h2 id='pw_estimate'>Estimate residual autocorrelation for prewhitening</h2><span id='topic+pw_estimate'></span>

<h3>Description</h3>

<p>Estimate residual autocorrelation for prewhitening
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pw_estimate(resids, ar_order, aic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pw_estimate_+3A_resids">resids</code></td>
<td>
<p>Estimated residuals in <code class="reqn">T \times V</code> numeric matrix</p>
</td></tr>
<tr><td><code id="pw_estimate_+3A_ar_order">ar_order</code>, <code id="pw_estimate_+3A_aic">aic</code></td>
<td>
<p>Order of the AR model used to prewhiten the data at each location.
If <code>!aic</code> (default), the order will be exactly <code>ar_order</code>. If <code>aic</code>,
the order will be between zero and <code>ar_order</code>, as determined by the AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated AR coefficients and residual variance at every vertex
</p>

<hr>
<h2 id='pw_smooth'>Smooth AR coefficients and white noise variance</h2><span id='topic+pw_smooth'></span>

<h3>Description</h3>

<p>Smooth AR coefficients and white noise variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pw_smooth(spatial, AR, var, FWHM = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pw_smooth_+3A_spatial">spatial</code></td>
<td>
<p>See <code>fit_bayesglm</code> internal code.</p>
</td></tr>
<tr><td><code id="pw_smooth_+3A_ar">AR</code></td>
<td>
<p>A Vxp matrix of estimated AR coefficients, where V is the number of vertices and p is the AR model order</p>
</td></tr>
<tr><td><code id="pw_smooth_+3A_var">var</code></td>
<td>
<p>A vector length V containing the white noise variance estimates from the AR model</p>
</td></tr>
<tr><td><code id="pw_smooth_+3A_fwhm">FWHM</code></td>
<td>
<p>FWHM parameter for smoothing. Remember that
<code class="reqn">\sigma = \frac{FWHM}{2*sqrt(2*log(2)}</code>. Set to <code>0</code> or <code>NULL</code>
to not do any smoothing. Default: <code>5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Smoothed AR coefficients and residual variance at every vertex
</p>

<hr>
<h2 id='Q_prime'>Q prime</h2><span id='topic+Q_prime'></span>

<h3>Description</h3>

<p>Gives the portion of the Q matrix independent of phi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q_prime(kappa2, spde)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Q_prime_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="Q_prime_+3A_spde">spde</code></td>
<td>
<p>spde object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dgCMatrix
</p>

<hr>
<h2 id='qsample'>Sample from a multivariate normal with mean and precision</h2><span id='topic+qsample'></span>

<h3>Description</h3>

<p>Sample from a multivariate normal with mean and precision
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsample(n, mu, Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qsample_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="qsample_+3A_mu">mu</code></td>
<td>
<p>mean vector (length = p)</p>
</td></tr>
<tr><td><code id="qsample_+3A_q">Q</code></td>
<td>
<p>sparse p x p positive definite precision matrix (class = dgCMatrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An n x p matrix of samples
</p>

<hr>
<h2 id='resamp_res_Param_BayesGLM'>resamp_res</h2><span id='topic+resamp_res_Param_BayesGLM'></span>

<h3>Description</h3>

<p>resamp_res
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resamp_res_Param_BayesGLM_+3A_resamp_res">resamp_res</code></td>
<td>
<p>For cortex spatial model. The number of vertices to which
each cortical surface should be resampled, or <code>NULL</code> to not resample.
</p>
<p>For computational feasibility, a value of <code>10000</code> (default) or lower is
recommended for Bayesian spatial modeling. If <code>Bayes=FALSE</code>,
<code>resamp_res</code> can be set to <code>NULL</code> for full-resolution classical
modeling.</p>
</td></tr>
</table>

<hr>
<h2 id='retro_mask_act'>Retroactively mask activations</h2><span id='topic+retro_mask_act'></span>

<h3>Description</h3>

<p>Retroactively mask activations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retro_mask_act(x, Masks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retro_mask_act_+3A_x">x</code></td>
<td>
<p>The activations object</p>
</td></tr>
<tr><td><code id="retro_mask_act_+3A_masks">Masks</code></td>
<td>
<p>The masks to be applied to each brain structure of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The masked result
</p>

<hr>
<h2 id='retro_mask_fit_bglm'>Retroactively mask locations from fit_bglm result.</h2><span id='topic+retro_mask_fit_bglm'></span>

<h3>Description</h3>

<p>Retroactively mask locations from fit_bglm result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retro_mask_fit_bglm(x, mask)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retro_mask_fit_bglm_+3A_x">x</code></td>
<td>
<p>The <code>"fit_bglm"</code> result</p>
</td></tr>
<tr><td><code id="retro_mask_fit_bglm_+3A_mask">mask</code></td>
<td>
<p>The mask to be applied to <code>x</code>. It's relative to the full
mesh/voxel array, not <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The masked result
</p>

<hr>
<h2 id='retro_mask_mesh'>Retroactively mask locations from mesh.</h2><span id='topic+retro_mask_mesh'></span>

<h3>Description</h3>

<p>Work in progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retro_mask_mesh(x, mask)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retro_mask_mesh_+3A_x">x</code></td>
<td>
<p>The mesh</p>
</td></tr>
<tr><td><code id="retro_mask_mesh_+3A_mask">mask</code></td>
<td>
<p>The mask to be applied to <code>x</code> (on top of any masks already
applied to it.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The masked result
</p>

<hr>
<h2 id='return_INLA_Param'>return_INLA</h2><span id='topic+return_INLA_Param'></span>

<h3>Description</h3>

<p>return_INLA
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="return_INLA_Param_+3A_return_inla">return_INLA</code></td>
<td>
<p>Return the INLA model object? (It can be large.) Use
<code>"trimmed"</code> (default) returns the results sufficient for
<code><a href="#topic+activations">activations</a></code> and <code><a href="#topic+BayesGLM2">BayesGLM2</a></code>; <code>"minimal"</code>
returns enough for <code><a href="#topic+BayesGLM2">BayesGLM2</a></code> but not
<code><a href="#topic+activations">activations</a></code>; <code>"full"</code> returns the full <code>inla</code>
output.</p>
</td></tr>
</table>

<hr>
<h2 id='s2m'>Sequential 2-means variable selection</h2><span id='topic+s2m'></span>

<h3>Description</h3>

<p>Sequential 2-means variable selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2m(x, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s2m_+3A_x">x</code></td>
<td>
<p>A vector consisting of all variables of interest for a single draw
from a posterior distribution</p>
</td></tr>
<tr><td><code id="s2m_+3A_b">b</code></td>
<td>
<p>A scale parameter used to determine at what distance cluster centers
are considered to be the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of nonzero values detected within x
</p>

<hr>
<h2 id='s2m_B'>Sequential 2-means on array B</h2><span id='topic+s2m_B'></span>

<h3>Description</h3>

<p>Sequential 2-means on array B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2m_B(B, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s2m_B_+3A_b">B</code></td>
<td>
<p>An array of posterior samples (typically a matrix), in which the last margin corresponds to a single posterior sample</p>
</td></tr>
<tr><td><code id="s2m_B_+3A_sigma">sigma</code></td>
<td>
<p>A scale parameter used to determine at what distance cluster centers are considered to be the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of dimension <code>head(dim(B),-1)</code> with a point estimate of B based on the sequential 2-means method
</p>

<hr>
<h2 id='scale_BOLD'>Scale the BOLD timeseries</h2><span id='topic+scale_BOLD'></span>

<h3>Description</h3>

<p>Scale the BOLD timeseries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_BOLD(BOLD, scale = c("mean", "sd", "none"), v_means = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_BOLD_+3A_bold">BOLD</code></td>
<td>
<p>fMRI data as a locations by time (<code class="reqn">V \times T</code>) numeric
matrix.</p>
</td></tr>
<tr><td><code id="scale_BOLD_+3A_scale">scale</code></td>
<td>
<p>Option for scaling the BOLD response.</p>
</td></tr>
<tr><td><code id="scale_BOLD_+3A_v_means">v_means</code></td>
<td>
<p>Original means of the BOLD data. ONLY provide if data has
already been centered.
</p>
<div class="sourceCode"><pre>\code{"mean"} scaling will scale the data to percent local signal change.

\code{"sd"} scaling will scale the data by local standard deviation.

\code{"none"} will only center the data, not scale it.
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>Scale to units of percent local signal change and centers
</p>

<hr>
<h2 id='scale_BOLD_Param'>scale_BOLD</h2><span id='topic+scale_BOLD_Param'></span>

<h3>Description</h3>

<p>scale_BOLD
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_BOLD_Param_+3A_scale_bold">scale_BOLD</code></td>
<td>
<p>Controls scaling the BOLD response at each location.
</p>

<dl>
<dt>&quot;mean&quot;:</dt><dd><p>   Scale the data to percent local signal change.</p>
</dd>
<dt>&quot;sd&quot;:</dt><dd><p>   Scale the data by local standard deviation.</p>
</dd>
<dt>&quot;none&quot;:</dt><dd><p>   Center the data but do not scale it.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='scale_design_mat'>Scale the design matrix</h2><span id='topic+scale_design_mat'></span>

<h3>Description</h3>

<p>Scale the design matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_design_mat(design_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_design_mat_+3A_design_mat">design_mat</code></td>
<td>
<p>The original (unscaled) design matrix that is T x K, where
T is the number of time points, and k is the number of field covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scaled design matrix
</p>

<hr>
<h2 id='scrub_Param_BayesGLM'>scrub</h2><span id='topic+scrub_Param_BayesGLM'></span>

<h3>Description</h3>

<p>scrub
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scrub_Param_BayesGLM_+3A_scrub">scrub</code></td>
<td>
<p>(Optional) A <code class="reqn">T \times N_{scrub}</code> matrix of spike regressors
(one 1 value at the timepoint to scrub, and 0 for all other values), or a
logical vector indicating the timepoints to scrub (<code>TRUE</code> to scrub, and
<code>FALSE</code> to keep). For multi-session data, a session-length list of
such matrices or logical vectors.
</p>
<p>The spike regressors will be included in the nuisance
regression, and afterwards the timepoints indicated in <code>scrub</code> will be
removed from the BOLD data and design matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='seed_Param'>seed</h2><span id='topic+seed_Param'></span>

<h3>Description</h3>

<p>seed
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seed_Param_+3A_seed">seed</code></td>
<td>
<p>Random seed (optional). Default: <code>NULL</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='session_names_Param'>session_names</h2><span id='topic+session_names_Param'></span>

<h3>Description</h3>

<p>session_names
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="session_names_Param_+3A_session_names">session_names</code></td>
<td>
<p>The names of the task-fMRI <code>BOLD</code> sessions, for
multi-session analysis. If not provided here, will be inferred from
<code>names(BOLD)</code>, inferred from <code>names(design)</code>, or generated
automatically, in that order.</p>
</td></tr>
</table>

<hr>
<h2 id='sparse_and_PW'>Organize data for Bayesian GLM</h2><span id='topic+sparse_and_PW'></span>

<h3>Description</h3>

<p>Transforms the usual TxV BOLD data matrix Y into vector form, and
the usual TxK design matrix X into big sparse matrix form for use in
Bayesian GLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_and_PW(
  BOLD,
  design,
  spatial,
  spde,
  field_names,
  design_type,
  valid_cols,
  nT,
  sqrtInv_all
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_and_PW_+3A_bold">BOLD</code>, <code id="sparse_and_PW_+3A_design">design</code>, <code id="sparse_and_PW_+3A_spatial">spatial</code>, <code id="sparse_and_PW_+3A_spde">spde</code></td>
<td>
<p>See <code>fit_bayesglm</code>.</p>
</td></tr>
<tr><td><code id="sparse_and_PW_+3A_field_names">field_names</code>, <code id="sparse_and_PW_+3A_design_type">design_type</code></td>
<td>
<p>See <code>fit_bayesglm</code>.</p>
</td></tr>
<tr><td><code id="sparse_and_PW_+3A_valid_cols">valid_cols</code>, <code id="sparse_and_PW_+3A_nt">nT</code>, <code id="sparse_and_PW_+3A_sqrtinv_all">sqrtInv_all</code></td>
<td>
<p>See <code>fit_bayesglm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayesian GLM requires <code>y</code> (a vector of length TV containing the BOLD data)
and <code>X_k</code> (a sparse TVxV matrix corresponding to the kth field regressor) for each field k.
The design matrices are combined as <code>A=cbind(X_1,...,X_K)</code>.
</p>
<p>The Bayesian GLM requires <code>y</code> (a vector of length TV containing the BOLD data)
and <code>X_k</code> (a sparse TVxV matrix corresponding to the kth field regressor) for each field k.
The design matrices are combined as <code>A=cbind(X_1,...,X_K)</code>.
</p>


<h3>Value</h3>

<p>A list containing fields <code>y</code> and <code>A</code> (see Details)
</p>

<hr>
<h2 id='SPDE_from_vertex'>SPDE from mesh model</h2><span id='topic+SPDE_from_vertex'></span>

<h3>Description</h3>

<p>SPDE from mesh model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPDE_from_vertex(spatial, qc_mask, logkappa = NULL, logtau = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SPDE_from_vertex_+3A_spatial">spatial</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="SPDE_from_vertex_+3A_qc_mask">qc_mask</code></td>
<td>
<p>QC mask.</p>
</td></tr>
<tr><td><code id="SPDE_from_vertex_+3A_logkappa">logkappa</code>, <code id="SPDE_from_vertex_+3A_logtau">logtau</code></td>
<td>
<p>vector of min, max and initial value for prior on log kappa and log tau. Min and max are extreme quantiles, not hard constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List: <code>spde</code> and <code>spatial</code>.
</p>

<hr>
<h2 id='SPDE_from_voxel'>SPDE from voxel model</h2><span id='topic+SPDE_from_voxel'></span>

<h3>Description</h3>

<p>SPDE from voxel model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPDE_from_voxel(spatial, qc_mask = NULL, logkappa = NULL, logtau = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SPDE_from_voxel_+3A_spatial">spatial</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="SPDE_from_voxel_+3A_qc_mask">qc_mask</code></td>
<td>
<p>QC mask.</p>
</td></tr>
<tr><td><code id="SPDE_from_voxel_+3A_logkappa">logkappa</code>, <code id="SPDE_from_voxel_+3A_logtau">logtau</code></td>
<td>
<p>vector of min, max and initial value for prior on log kappa and log tau. Min and max are extreme quantiles, not hard constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List: <code>spde</code> and <code>spatial</code>.
</p>

<hr>
<h2 id='spde_Q_phi'>Calculate the SPDE covariance</h2><span id='topic+spde_Q_phi'></span>

<h3>Description</h3>

<p>Calculate the SPDE covariance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde_Q_phi(kappa2, phi, spde)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spde_Q_phi_+3A_kappa2">kappa2</code></td>
<td>
<p>A scalar</p>
</td></tr>
<tr><td><code id="spde_Q_phi_+3A_phi">phi</code></td>
<td>
<p>A scalar</p>
</td></tr>
<tr><td><code id="spde_Q_phi_+3A_spde">spde</code></td>
<td>
<p>An object containing the information about the
mesh structure for the SPDE prior</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SPDE prior matrix
</p>

<hr>
<h2 id='summary.act_BGLM'>Summarize a <code>"act_BGLM"</code> object</h2><span id='topic+summary.act_BGLM'></span><span id='topic+print.summary.act_BGLM'></span><span id='topic+print.act_BGLM'></span>

<h3>Description</h3>

<p>Summary method for class <code>"act_BGLM"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'act_BGLM'
summary(object, ...)

## S3 method for class 'summary.act_BGLM'
print(x, ...)

## S3 method for class 'act_BGLM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.act_BGLM_+3A_object">object</code></td>
<td>
<p>Object of class <code>"act_BGLM"</code>.</p>
</td></tr>
<tr><td><code id="summary.act_BGLM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.act_BGLM_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.act_BGLM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.act_BGLM"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.act_fit_bglm'>Summarize a <code>"act_fit_bglm"</code> object</h2><span id='topic+summary.act_fit_bglm'></span><span id='topic+print.summary.act_fit_bglm'></span><span id='topic+print.act_fit_bglm'></span>

<h3>Description</h3>

<p>Summary method for class <code>"act_fit_bglm"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'act_fit_bglm'
summary(object, ...)

## S3 method for class 'summary.act_fit_bglm'
print(x, ...)

## S3 method for class 'act_fit_bglm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.act_fit_bglm_+3A_object">object</code></td>
<td>
<p>Object of class <code>"act_fit_bglm"</code>.</p>
</td></tr>
<tr><td><code id="summary.act_fit_bglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.act_fit_bglm_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.act_fit_bglm"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.act_fit_bglm"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.BGLM'>Summarize a <code>"BGLM"</code> object</h2><span id='topic+summary.BGLM'></span><span id='topic+print.summary.BGLM'></span><span id='topic+print.BGLM'></span>

<h3>Description</h3>

<p>Summary method for class <code>"BGLM"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGLM'
summary(object, ...)

## S3 method for class 'summary.BGLM'
print(x, ...)

## S3 method for class 'BGLM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.BGLM_+3A_object">object</code></td>
<td>
<p>Object of class <code>"BGLM"</code>.</p>
</td></tr>
<tr><td><code id="summary.BGLM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.BGLM_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.BGLM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.BGLM"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.BGLM2'>Summarize a <code>"BGLM2"</code> object</h2><span id='topic+summary.BGLM2'></span><span id='topic+print.summary.BGLM2'></span><span id='topic+print.BGLM2'></span>

<h3>Description</h3>

<p>Summary method for class <code>"BGLM2"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGLM2'
summary(object, ...)

## S3 method for class 'summary.BGLM2'
print(x, ...)

## S3 method for class 'BGLM2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.BGLM2_+3A_object">object</code></td>
<td>
<p>Object of class <code>"BGLM2"</code>.</p>
</td></tr>
<tr><td><code id="summary.BGLM2_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.BGLM2_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.BGLM2"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.BGLM2"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.fit_bglm'>Summarize a <code>"fit_bglm"</code> object</h2><span id='topic+summary.fit_bglm'></span><span id='topic+print.summary.fit_bglm'></span><span id='topic+print.fit_bglm'></span>

<h3>Description</h3>

<p>Summary method for class <code>"fit_bglm"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit_bglm'
summary(object, ...)

## S3 method for class 'summary.fit_bglm'
print(x, ...)

## S3 method for class 'fit_bglm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fit_bglm_+3A_object">object</code></td>
<td>
<p>Object of class <code>"fit_bglm"</code>.</p>
</td></tr>
<tr><td><code id="summary.fit_bglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.fit_bglm_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.fit_bglm"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.fit_bglm"</code> object, a list summarizing the properties
of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.fit_bglm2'>Summarize a <code>"fit_bglm2"</code> object</h2><span id='topic+summary.fit_bglm2'></span><span id='topic+print.summary.fit_bglm2'></span><span id='topic+print.fit_bglm2'></span>

<h3>Description</h3>

<p>Summary method for class <code>"fit_bglm2"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit_bglm2'
summary(object, ...)

## S3 method for class 'summary.fit_bglm2'
print(x, ...)

## S3 method for class 'fit_bglm2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fit_bglm2_+3A_object">object</code></td>
<td>
<p>Object of class <code>"fit_bglm2"</code>.</p>
</td></tr>
<tr><td><code id="summary.fit_bglm2_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.fit_bglm2_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.fit_bglm2"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.fit_bglm2"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.prev_BGLM'>Summarize a <code>"prev_BGLM"</code> object</h2><span id='topic+summary.prev_BGLM'></span><span id='topic+print.summary.prev_BGLM'></span><span id='topic+print.prev_BGLM'></span>

<h3>Description</h3>

<p>Summary method for class <code>"prev_BGLM"</code>
</p>
<p>Summary method for class <code>"prev_BGLM"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prev_BGLM'
summary(object, ...)

## S3 method for class 'summary.prev_BGLM'
print(x, ...)

## S3 method for class 'prev_BGLM'
print(x, ...)

## S3 method for class 'prev_BGLM'
summary(object, ...)

## S3 method for class 'summary.prev_BGLM'
print(x, ...)

## S3 method for class 'prev_BGLM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.prev_BGLM_+3A_object">object</code></td>
<td>
<p>Object of class <code>"prev_BGLM"</code>.</p>
</td></tr>
<tr><td><code id="summary.prev_BGLM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.prev_BGLM_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.prev_BGLM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.prev_BGLM"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p>A <code>"summary.prev_BGLM"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='summary.prev_fit_bglm'>Summarize a <code>"prev_fit_bglm"</code> object</h2><span id='topic+summary.prev_fit_bglm'></span><span id='topic+print.summary.prev_fit_bglm'></span><span id='topic+print.prev_fit_bglm'></span>

<h3>Description</h3>

<p>Summary method for class <code>"prev_fit_bglm"</code>
</p>
<p>Summary method for class <code>"prev_fit_bglm"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prev_fit_bglm'
summary(object, ...)

## S3 method for class 'summary.prev_fit_bglm'
print(x, ...)

## S3 method for class 'prev_fit_bglm'
print(x, ...)

## S3 method for class 'prev_fit_bglm'
summary(object, ...)

## S3 method for class 'summary.prev_fit_bglm'
print(x, ...)

## S3 method for class 'prev_fit_bglm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.prev_fit_bglm_+3A_object">object</code></td>
<td>
<p>Object of class <code>"prev_fit_bglm"</code>.</p>
</td></tr>
<tr><td><code id="summary.prev_fit_bglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.prev_fit_bglm_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.prev_fit_bglm"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.prev_fit_bglm"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p>A <code>"summary.prev_fit_bglm"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='surfaces_Param_BayesGLM'>surfaces</h2><span id='topic+surfaces_Param_BayesGLM'></span>

<h3>Description</h3>

<p>surfaces
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surfaces_Param_BayesGLM_+3A_surfl">surfL</code>, <code id="surfaces_Param_BayesGLM_+3A_surfr">surfR</code></td>
<td>
<p>For cortex spatial model. Left and right cortex surface
geometry in GIFTI format (&quot;*.surf.gii&quot;). These can be a file path to
a GIFTI file or a <code>"surf"</code> object from <code>ciftiTools</code>.
</p>
<p>Surfaces can alternatively be provided through the <code>$surf</code> metadata in
<code>BOLD</code> if it is <code>"xifti"</code> data. If neither are provided, by default the
HCP group-average fs_LR inflated surfaces included in <code>ciftiTools</code> will be
used for the cortex spatial model.</p>
</td></tr>
</table>

<hr>
<h2 id='TR_Param_BayesGLM'>TR</h2><span id='topic+TR_Param_BayesGLM'></span>

<h3>Description</h3>

<p>TR
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TR_Param_BayesGLM_+3A_tr">TR</code></td>
<td>
<p>Temporal resolution of the data, in seconds.</p>
</td></tr>
</table>

<hr>
<h2 id='trim_INLA_model_obj'>Trim INLA object</h2><span id='topic+trim_INLA_model_obj'></span>

<h3>Description</h3>

<p>Trim an INLA object to only include what is necessary for
<code>activations</code> or <code>BayesGLM2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_INLA_model_obj(INLA_model_obj, minimal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim_INLA_model_obj_+3A_inla_model_obj">INLA_model_obj</code></td>
<td>
<p>An object of class <code>"inla"</code>.</p>
</td></tr>
<tr><td><code id="trim_INLA_model_obj_+3A_minimal">minimal</code></td>
<td>
<p>Just keep the two parameters needed for <code>BayesGLM2</code>?
Default: <code>FALSE</code>. <code>!minimal</code> is required for
<code>activations</code>, but <code>minimal</code> is sufficient for
<code>BayesGLM2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trimmed <code>"inla"</code> object.
</p>

<hr>
<h2 id='trim_INLA_Param'>trim_INLA</h2><span id='topic+trim_INLA_Param'></span>

<h3>Description</h3>

<p>trim_INLA
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim_INLA_Param_+3A_trim_inla">trim_INLA</code></td>
<td>
<p>(logical) should the <code>INLA_model_obj</code> within the
result be trimmed to only what is necessary to use <code>activations</code>?
Default: <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='TrQbb'>Trace of Q beta' beta</h2><span id='topic+TrQbb'></span>

<h3>Description</h3>

<p>Trace of Q beta' beta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrQbb(kappa2, beta_hat, spde)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TrQbb_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="TrQbb_+3A_beta_hat">beta_hat</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="TrQbb_+3A_spde">spde</code></td>
<td>
<p>an spde object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='TrQEww'>Trace approximation function</h2><span id='topic+TrQEww'></span>

<h3>Description</h3>

<p>Trace approximation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrQEww(kappa2, spde, P, mu, Vh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TrQEww_+3A_kappa2">kappa2</code></td>
<td>
<p>a scalar</p>
</td></tr>
<tr><td><code id="TrQEww_+3A_spde">spde</code></td>
<td>
<p>spde object</p>
</td></tr>
<tr><td><code id="TrQEww_+3A_p">P</code></td>
<td>
<p>Matrix of dimension nk by N_s found by <code>solve(Sig_inv,Vh)</code></p>
</td></tr>
<tr><td><code id="TrQEww_+3A_mu">mu</code></td>
<td>
<p>posterior mean</p>
</td></tr>
<tr><td><code id="TrQEww_+3A_vh">Vh</code></td>
<td>
<p>matrix of random variables with <code>nrow(Sig_inv)</code> rows and Ns
columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>

<hr>
<h2 id='TrSigB'>Hutchinson estimator of the trace</h2><span id='topic+TrSigB'></span>

<h3>Description</h3>

<p>Hutchinson estimator of the trace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrSigB(P, B, vh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TrSigB_+3A_p">P</code></td>
<td>
<p>Matrix of dimension nk by N_s found by <code>solve(Sig_inv,Vh)</code></p>
</td></tr>
<tr><td><code id="TrSigB_+3A_b">B</code></td>
<td>
<p>Matrix of dimension nk by nk inside the desired trace product</p>
</td></tr>
<tr><td><code id="TrSigB_+3A_vh">vh</code></td>
<td>
<p>Matrix of dimension nk by N_s in which elements are -1 or 1 with
equal probability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar estimate of the trace of <code>Sigma %*% B</code>
</p>

<hr>
<h2 id='unmask_Mdat2In'>Unmask data</h2><span id='topic+unmask_Mdat2In'></span>

<h3>Description</h3>

<p><code>maskMdat</code> is a subset of <code>maskIn</code>. <code>x</code> is masked by
<code>maskMdat</code>; this function makes it masked by <code>maskIn</code> instead
and uses <code>fill_val</code> for the previously masked-out locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmask_Mdat2In(x, maskIn, maskMdat, fill_val = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unmask_Mdat2In_+3A_x">x</code></td>
<td>
<p>The matrix to unmask</p>
</td></tr>
<tr><td><code id="unmask_Mdat2In_+3A_maskin">maskIn</code>, <code id="unmask_Mdat2In_+3A_maskmdat">maskMdat</code></td>
<td>
<p>The input mask, and the modeled locations mask, as
logical vectors. The latter should be a subset of the former. They should
have the same length.</p>
</td></tr>
<tr><td><code id="unmask_Mdat2In_+3A_fill_val">fill_val</code></td>
<td>
<p>The fill value. Default: <code>NA</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='validate_spatial'>Validate <code>spatial</code></h2><span id='topic+validate_spatial'></span>

<h3>Description</h3>

<p>Validate <code>spatial</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_spatial(spatial)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_spatial_+3A_spatial">spatial</code></td>
<td>
<p><code>spatial</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='verbose_Param'>verbose</h2><span id='topic+verbose_Param'></span>

<h3>Description</h3>

<p>verbose
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verbose_Param_+3A_verbose">verbose</code></td>
<td>
<p><code>1</code> (default) to print occasional updates during model
computation; <code>2</code> for occasional updates as well as running INLA in
verbose mode (if <code>Bayes</code>), or <code>0</code> for no printed updates.</p>
</td></tr>
</table>

<hr>
<h2 id='vertex_areas'>Surface area of each vertex</h2><span id='topic+vertex_areas'></span>

<h3>Description</h3>

<p>Compute surface areas of each vertex in a triangular mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_areas(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vertex_areas_+3A_mesh">mesh</code></td>
<td>
<p>An <code>"inla.mesh"</code> object (see <code><a href="#topic+make_mesh">make_mesh</a></code> for
surface data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of areas
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

<hr>
<h2 id='vertices_Param'>vertices</h2><span id='topic+vertices_Param'></span>

<h3>Description</h3>

<p>vertices
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vertices_Param_+3A_vertices">vertices</code></td>
<td>
<p>A <code class="reqn">V \times 3</code> matrix, where each row contains the Euclidean
coordinates at which a given vertex in the mesh is located. <code class="reqn">V</code> is the
number of vertices in the mesh</p>
</td></tr>
</table>

<hr>
<h2 id='vol2spde'>Construct a triangular mesh from a 3D volumetric mask</h2><span id='topic+vol2spde'></span>

<h3>Description</h3>

<p>Construct a triangular mesh from a 3D volumetric mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol2spde(mask, res, nbhd_order = 1, buffer = c(1, 1, 3, 4, 4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol2spde_+3A_mask">mask</code></td>
<td>
<p>An array of 0s and 1s representing a volumetric mask</p>
</td></tr>
<tr><td><code id="vol2spde_+3A_res">res</code></td>
<td>
<p>The spatial resolution in each direction, in mm. For example, c(2,2,2) indicates 2mm isotropic voxels.</p>
</td></tr>
<tr><td><code id="vol2spde_+3A_nbhd_order">nbhd_order</code></td>
<td>
<p>For volumetric data, what order neighborhood around data
locations to keep? (0 = no neighbors, 1 = 1st-order neighbors, 2 = 1st- and
2nd-order neighbors, etc.). Smaller values will provide greater computational
efficiency at the cost of higher variance around the edge of the data.</p>
</td></tr>
<tr><td><code id="vol2spde_+3A_buffer">buffer</code></td>
<td>
<p>For volumetric data, size of extra voxels layers around the
bounding box, in terms of voxels. Set to NULL for no buffer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An inla.spde2 object.
</p>


<h3>INLA Requirement</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
