<!DOCTYPE html><html><head><title>Help for package Rankcluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rankcluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rankcluster-package'><p>Model-Based Clustering for Multivariate Partial Ranking Data</p></a></li>
<li><a href='#+5B+2CRankclust-method'><p>Getter method for rankclust output</p></a></li>
<li><a href='#APA'><p>Rank data: APA</p></a></li>
<li><a href='#big4'><p>Rank data: big4</p></a></li>
<li><a href='#convertRank'><p>Change the representation of a rank</p></a></li>
<li><a href='#criteria'><p>Criteria estimation</p></a></li>
<li><a href='#distCayley'><p>Cayley distance between two ranks</p></a></li>
<li><a href='#distHamming'><p>Hamming distance between two ranks</p></a></li>
<li><a href='#distKendall'><p>Kendall distance between two ranks</p></a></li>
<li><a href='#distSpearman'><p>Spearman distance between two ranks</p></a></li>
<li><a href='#eurovision'><p>Multidimensional partial rank data: eurovision</p></a></li>
<li><a href='#frequence'><p>Convert data storage</p></a></li>
<li><a href='#khi2'><p>Khi2 test</p></a></li>
<li><a href='#kullback'><p>Kullback-Leibler divergence</p></a></li>
<li><a href='#Output-class'><p>Constructor of Output class</p></a></li>
<li><a href='#probability'><p>Probability computation</p></a></li>
<li><a href='#quiz'><p>Multidimensional rank data: quiz</p></a></li>
<li><a href='#rankclust'><p>Model-based clustering for multivariate partial ranking</p></a></li>
<li><a href='#Rankclust-class'><p>Constructor of Rankclust class</p></a></li>
<li><a href='#show+2COutput-method'><p>Show function.</p></a></li>
<li><a href='#simulISR'><p>Simulate a sample of ISR(pi,mu)</p></a></li>
<li><a href='#sports'><p>Rank data: sports</p></a></li>
<li><a href='#summary+2CRankclust-method'><p>Summary function.</p></a></li>
<li><a href='#unfrequence'><p>Convert data</p></a></li>
<li><a href='#words'><p>Rank data: words</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model-Based Clustering for Multivariate Partial Ranking Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.98.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of a model-based clustering algorithm for
    ranking data (C. Biernacki, J. Jacques (2013) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2012.08.008">doi:10.1016/j.csda.2012.08.008</a>&gt;). 
    Multivariate rankings as well as partial rankings are taken
    into account. This algorithm is based on an extension of the Insertion
    Sorting Rank (ISR) model for ranking data, which is a meaningful and
    effective model parametrized by a position parameter (the modal ranking,
    quoted by mu) and a dispersion parameter (quoted by pi). The heterogeneity
    of the rank population is modelled by a mixture of ISR, whereas conditional
    independence assumption is considered for multivariate rankings.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Inria - Université de Lille</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/modal-inria/Rankcluster/issues/">https://github.com/modal-inria/Rankcluster/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-11 19:24:51 UTC; quentin</td>
</tr>
<tr>
<td>Author:</td>
<td>Quentin Grimonprez [aut, cre],
  Julien Jacques [aut],
  Christophe Biernacki [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Quentin Grimonprez &lt;quentingrim@yahoo.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-12 01:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rankcluster-package'>Model-Based Clustering for Multivariate Partial Ranking Data</h2><span id='topic+Rankcluster-package'></span>

<h3>Description</h3>

<p>This package proposes a model-based clustering algorithm for ranking data.
Multivariate rankings as well as partial rankings are taken into account.
This algorithm is based on an extension of the Insertion Sorting Rank (ISR) model for ranking data, which is a meaningful
and effective model parametrized by a position parameter (the modal ranking, quoted by mu) and a dispersion parameter
(quoted by pi). The heterogeneity of the rank population is modeled by a mixture of ISR, whereas conditional independence
assumption is considered for multivariate rankings.
</p>


<h3>Details</h3>

<p>The main function is <a href="#topic+rankclust">rankclust</a>.
See vignettes for detailed examples: <code>RShowDoc("dataFormat", package = "Rankcluster")</code> and
<code>RShowDoc("Rankcluster", package = "Rankcluster")</code>
</p>


<h3>References</h3>

<p>[1] C.Biernacki and J.Jacques (2013), A generative model for rank data based on sorting algorithm,
Computational Statistics and Data Analysis, 58, 162-176.
</p>
<p>[2] J.Jacques and C.Biernacki (2012), Model-based clustering for multivariate partial ranking data,
Inria Research Report n 8113.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see vignettes
# RShowDoc("dataFormat", package = "Rankcluster")
# RShowDoc("Rankcluster", package = "Rankcluster")

# main function of the package for run the algorithm
data(big4)
result &lt;- rankclust(big4$data, K = 2, m = big4$m, Ql = 200, Bl = 100, maxTry = 2)

if(result@convergence) {
  summary(result)

  partition &lt;- result[2]@partition
  tik &lt;- result[2]@tik
}

</code></pre>

<hr>
<h2 id='+5B+2CRankclust-method'>Getter method for rankclust output</h2><span id='topic++5B+2CRankclust-method'></span>

<h3>Description</h3>

<p>Extract values of various
slots of the output from the function <code><a href="#topic+rankclust">rankclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rankclust'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CRankclust-method_+3A_x">x</code></td>
<td>
<p>object from which to extract element(s) or in which to replace element(s).</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CRankclust-method_+3A_i">i</code></td>
<td>
<p>the number of cluster of the element we want to extract or &quot;bic&quot;, &quot;icl&quot;, &quot;ll&quot;</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CRankclust-method_+3A_j">j</code>, <code id="+2B5B+2B2CRankclust-method_+3A_drop">drop</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='APA'>Rank data: APA</h2><span id='topic+APA'></span>

<h3>Description</h3>

<p>This dataset contains the 5738 full rankings resulting from the American Psychological Association (APA)
presidential election of 1980. For this election, members of APA had to rank five candidates in order of preference.
</p>
<p>For information, a total of 15449 votes have been registered for this election, but only the 5738 full rankings are
reported in the APA dataset. Candidates A and C were research psychologists, candidates D and E were clinical
psychologists and candidate B was a community psychologist.
</p>


<h3>Format</h3>

<p>A list containing:
</p>

<dl>
<dt>data</dt><dd><p>A matrix of size 5738x5 containing the 5738 observed full ranks in ranking representation.
The ranking representation r=(r_1,...,r_m) contains the  ranks assigned to the objects, and means that the ith object is
in r_ith position.
</p>
<p>For example, if the ranking representation of a rank is (4,3,1,2,5), it means that judge ranks
the first object in 4th position, second object in 3rd position, ...</p>
</dd>
<dt>frequency</dt><dd><p>matrix of size 120x6. Each row corresponds to one of the different observed rank.
The first fifth columns contains the observed ranks (ordering representation) and the sixth column
contains the frequency of observation.</p>
</dd>
<dt>m</dt><dd><p>vector with the size of the ranks (5 here).</p>
</dd>
</dl>



<h3>Source</h3>

<p>&quot;Group representations in probability and statistics&quot;, P. Diaconis, 1988.
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+big4">big4</a></code>,
<code><a href="#topic+eurovision">eurovision</a></code>,
<code><a href="#topic+quiz">quiz</a></code>,
<code><a href="#topic+sports">sports</a></code>,
<code><a href="#topic+words">words</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(APA)

</code></pre>

<hr>
<h2 id='big4'>Rank data: big4</h2><span id='topic+big4'></span>

<h3>Description</h3>

<p>This dataset is composed of the rankings (in ranking notation) of the &quot;Big Four&quot; English football teams
(A: Manchester, B: Liverpool, C: Arsenal, D: Chelsea) to the English Championship (Premier League) and according to the UEFA
coefficients (statistics used in Europe for ranking and seeding teams in international competitions), from 1993 to 2013.
</p>
<p>In 2000-2001, Arsenal and Chelsea had the same UEFA coefficient and then are tied. UEFA ranking is (1, 4, 2, 2) for
2000-2001, what means that Manchester United is the first, Liverpool is the last, and the two intermediate positions are
for Arsenal and Chelsea in an unknown order.
</p>
<p>In 2009-2010, Liverpool and Arsenal have also the same UEFA coefficient, the ranking is  (1, 2, 2, 4).
</p>


<h3>Format</h3>

<p>A list containing:
</p>

<dl>
<dt>data</dt><dd><p>A matrix of size 21*8 containing the 21 Premier League seasons. Each row corresponding to one ranking
(ranking representation).
</p>
<p>The ranking representation r=(r_1,...,r_m) contains the  ranks assigned to the objects, and means that the
ith object is in r_ith position.
</p>
<p>For example, if the ranking representation of a rank is (4,3,1,2,5), it means that judge ranks the first
object in 4th position, second object in 3rd position, ...</p>
</dd>
<dt>frequency</dt><dd><p>matrix of size 21*9. Each row corresponds to one of the 21 different observed rankings, and the
last column contains the observation frequency.</p>
</dd>
<dt>m</dt><dd><p>the size of the rankings (m=c(4,4) ).</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://en.wikipedia.org/wiki/Premier_League">https://en.wikipedia.org/wiki/Premier_League</a>
</p>
<p><a href="https://fr.uefa.com/nationalassociations/uefarankings/club/">https://fr.uefa.com/nationalassociations/uefarankings/club/</a>
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+APA">APA</a></code>,
<code><a href="#topic+eurovision">eurovision</a></code>,
<code><a href="#topic+quiz">quiz</a></code>,
<code><a href="#topic+sports">sports</a></code>,
<code><a href="#topic+words">words</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(big4)

</code></pre>

<hr>
<h2 id='convertRank'>Change the representation of a rank</h2><span id='topic+convertRank'></span>

<h3>Description</h3>

<p>convertRank converts a rank from its ranking representation to its ordering representation, and vice-versa.
The function does not work with partial ranking. The transformation to convert a rank from ordering to ranking
representation is the same that from ranking to ordering representation, there is no need to precise the representation
of rank x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertRank(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertRank_+3A_x">x</code></td>
<td>
<p>a rank (vector) datum either in its ranking or ordering representation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ranking representation r=(r_1,...,r_m) contains the ranks assigned to the objects,
and means that the ith object is in r_ith position.
</p>
<p>The ordering representation o=(o_1,...,o_m) means that object o_i is in the ith position.
</p>
<p>Let us consider the following example to illustrate both notations: a judge, which has to rank three holidays destinations
according to its preferences, O1 = Countryside, O2 =Mountain and O3 = Sea, ranks first Sea, second Countryside,
and last Mountain. The ordering result of the judge is o = (3, 1, 2) whereas the ranking result is r = (2, 3, 1).
</p>


<h3>Value</h3>

<p>a rank (vector) in its ordering representation if its ranking representation has been given in input of
convertRank, and vice-versa.
</p>


<h3>Author(s)</h3>

<p>Julien Jacques
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2, 3, 1, 4, 5)
convertRank(x)

</code></pre>

<hr>
<h2 id='criteria'>Criteria estimation</h2><span id='topic+criteria'></span>

<h3>Description</h3>

<p>This function estimates the loglikelihood of a mixture of multidimensional ISR model, as well as the
BIC and ICL model selection criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria(data, proportion, pi, mu, m, Ql = 500, Bl = 100, IC = 1, nb_cpus = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criteria_+3A_data">data</code></td>
<td>
<p>a matrix in which each row is a rank (partial or not; for partial rank,
missing elements of a rank are put to 0).</p>
</td></tr>
<tr><td><code id="criteria_+3A_proportion">proportion</code></td>
<td>
<p>a vector (which sums to 1) containing the K mixture proportions.</p>
</td></tr>
<tr><td><code id="criteria_+3A_pi">pi</code></td>
<td>
<p>a matrix of size K*p, where K is the number of clusters and p the number of dimension, containing the
probabilities of a good comparison of the model (dispersion parameters).</p>
</td></tr>
<tr><td><code id="criteria_+3A_mu">mu</code></td>
<td>
<p>a matrix of size K*sum(m), containing the modal ranks. Each row contains the modal rank for a cluster.
In the case of multivariate ranks, the reference rank for each dimension are set successively on the same row.</p>
</td></tr>
<tr><td><code id="criteria_+3A_m">m</code></td>
<td>
<p>a vector containing the size of ranks for each dimension.</p>
</td></tr>
<tr><td><code id="criteria_+3A_ql">Ql</code></td>
<td>
<p>number of iterations of the Gibbs sampler used for the estimation of the log-likelihood.</p>
</td></tr>
<tr><td><code id="criteria_+3A_bl">Bl</code></td>
<td>
<p>burn-in period of the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="criteria_+3A_ic">IC</code></td>
<td>
<p>number of run of the computation of the loglikelihood.</p>
</td></tr>
<tr><td><code id="criteria_+3A_nb_cpus">nb_cpus</code></td>
<td>
<p>number of cpus for parallel computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>ll</code></td>
<td>
<p>the estimated log-likelihood.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>the estimated BIC criterion.</p>
</td></tr>
<tr><td><code>icl</code></td>
<td>
<p>the estimated ICL criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(big4)
res &lt;- rankclust(big4$data, m = big4$m, K = 2, Ql = 100, Bl = 50, maxTry = 2)
if (res@convergence) {
  crit &lt;- criteria(big4$data, res[2]@proportion, res[2]@pi, res[2]@mu,
                  big4$m, Ql = 200, Bl = 100)
}

</code></pre>

<hr>
<h2 id='distCayley'>Cayley distance between two ranks</h2><span id='topic+distCayley'></span>

<h3>Description</h3>

<p>The Cayley distance between two ranks x and y is the minimum number of transpositions required to
transform the ranking x into y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distCayley(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distCayley_+3A_x">x</code>, <code id="distCayley_+3A_y">y</code></td>
<td>
<p>two ranks of size m.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Cayley distance between x and y.
</p>


<h3>Author(s)</h3>

<p>Julien Jacques
</p>


<h3>See Also</h3>

<p>Other distance: 
<code><a href="#topic+distHamming">distHamming</a>()</code>,
<code><a href="#topic+distKendall">distKendall</a>()</code>,
<code><a href="#topic+distSpearman">distSpearman</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(2, 3, 1, 4, 5)
distCayley(x, y)

</code></pre>

<hr>
<h2 id='distHamming'>Hamming distance between two ranks</h2><span id='topic+distHamming'></span>

<h3>Description</h3>

<p>The Hamming distance between two ranks x and y is the number of difference between the two ranks.
For example, the Hamming's distance between x=(1,4,2,5,3) and y=(1,3,4,5,2) is 3 because, only 1 and 5 have the same
place in both ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distHamming(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distHamming_+3A_x">x</code>, <code id="distHamming_+3A_y">y</code></td>
<td>
<p>two ranks of size m.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer, the Hamming distance between x and y.
</p>


<h3>Author(s)</h3>

<p>Julien Jacques
</p>


<h3>See Also</h3>

<p>Other distance: 
<code><a href="#topic+distCayley">distCayley</a>()</code>,
<code><a href="#topic+distKendall">distKendall</a>()</code>,
<code><a href="#topic+distSpearman">distSpearman</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(2, 3, 1, 4, 5)
distHamming(x, y)

</code></pre>

<hr>
<h2 id='distKendall'>Kendall distance between two ranks</h2><span id='topic+distKendall'></span>

<h3>Description</h3>

<p>The Kendall distance between two ranks is the number of pairs that are in different order in the two ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distKendall(x, y, type = "ordering")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distKendall_+3A_x">x</code>, <code id="distKendall_+3A_y">y</code></td>
<td>
<p>two ranks of size m.</p>
</td></tr>
<tr><td><code id="distKendall_+3A_type">type</code></td>
<td>
<p>type of the rank representation (&quot;ordering&quot; ou &quot;ranking&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer, the Kendall distance between x and y.
</p>


<h3>Author(s)</h3>

<p>Julien Jacques
</p>


<h3>References</h3>

<p>A New Measure of Rank Correlation, M. G. Kendall
</p>


<h3>See Also</h3>

<p>Other distance: 
<code><a href="#topic+distCayley">distCayley</a>()</code>,
<code><a href="#topic+distHamming">distHamming</a>()</code>,
<code><a href="#topic+distSpearman">distSpearman</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(2, 3, 1, 4, 5)
distKendall(x, y, type = "ordering")

</code></pre>

<hr>
<h2 id='distSpearman'>Spearman distance between two ranks</h2><span id='topic+distSpearman'></span>

<h3>Description</h3>

<p>The Spearman distance is the square of Euclidean distance between two rank vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distSpearman(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distSpearman_+3A_x">x</code>, <code id="distSpearman_+3A_y">y</code></td>
<td>
<p>two ranks of size m.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer, the Spearman distance between x and y.
</p>


<h3>Author(s)</h3>

<p>Julien Jacques
</p>


<h3>See Also</h3>

<p>Other distance: 
<code><a href="#topic+distCayley">distCayley</a>()</code>,
<code><a href="#topic+distHamming">distHamming</a>()</code>,
<code><a href="#topic+distKendall">distKendall</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(2, 3, 1, 4, 5)
distSpearman(x, y)

</code></pre>

<hr>
<h2 id='eurovision'>Multidimensional partial rank data: eurovision</h2><span id='topic+eurovision'></span>

<h3>Description</h3>

<p>This dataset contains the ranking of the 8 common finalists of the Eurovision song contest from 2007 to 2012:
</p>
<p>A: France, B:Germany, C:Greece, D:Romania, E:Russia, F:Spain, G:Ukraine, H:United Kingdom.
</p>
<p>The number of rankings is 33, corresponding to the 33 European countries having participated to those
six editions of the contest.
</p>
<p>All the rankings are partial since none country has ranked this 8 countries in its 10 preferences. Missing ranking
elements are zeros.
</p>


<h3>Format</h3>

<p>A list containing:
</p>

<dl>
<dt>data</dt><dd><p> A matrix of size 34*48. Each row corresponds to the ranking representation of a multidimensional ranking.
Columns 1 to 8 correspond to the 2007 contest, columns 9 to 18 to the 2008 contest, etc...
</p>
<p>The ranking representation r=(r_1,...,r_m) contains the  ranks assigned to the objects, and means that
the ith object is in r_ith position.
</p>
<p>For example, if the ranking representation of a rank is (4,3,1,2,5), it means that judge ranks the first
object in 4th position, second object in 3rd position, ...
</p>
</dd>
<dt>frequency</dt><dd><p>A matrix of size 34*49 containing the different multidimensional rankings. The 48 first columns are
the same as in data, and the last column contains the frequency (1 for all ranks).</p>
</dd>
<dt>m</dt><dd><p> a vector with the sizes of ranks for each dimension.</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://eurovision.tv
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+APA">APA</a></code>,
<code><a href="#topic+big4">big4</a></code>,
<code><a href="#topic+quiz">quiz</a></code>,
<code><a href="#topic+sports">sports</a></code>,
<code><a href="#topic+words">words</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eurovision)

</code></pre>

<hr>
<h2 id='frequence'>Convert data storage</h2><span id='topic+frequence'></span>

<h3>Description</h3>

<p>This function takes in input a matrix containing all the observed ranks (a rank can be repeated)
and returns a matrix containing all the different observed ranks with their observation frequencies (in the last column).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frequence(X, m = ncol(X))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frequence_+3A_x">X</code></td>
<td>
<p>a matrix containing ranks.</p>
</td></tr>
<tr><td><code id="frequence_+3A_m">m</code></td>
<td>
<p>a vector with the size of ranks of each dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing each different observed ranks with its observation frequencies in the last column.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+unfrequence">unfrequence</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(1:4, ncol = 4, nrow = 5, byrow = TRUE)
Y &lt;- frequence(X)
Y

</code></pre>

<hr>
<h2 id='khi2'>Khi2 test</h2><span id='topic+khi2'></span>

<h3>Description</h3>

<p>This function computes the p-value of the khi2 goodness-of-fit test (only for univariate data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>khi2(data, proportion, mu, pi, nBoot = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="khi2_+3A_data">data</code></td>
<td>
<p>a matrix in which each row is a rank of size m.</p>
</td></tr>
<tr><td><code id="khi2_+3A_proportion">proportion</code></td>
<td>
<p>a vector (which sums to 1) containing the K mixture proportion.</p>
</td></tr>
<tr><td><code id="khi2_+3A_mu">mu</code></td>
<td>
<p>a matrix of size K*m, where m is the size of a rank, containing the modal rankings of the model
(position parameters).</p>
</td></tr>
<tr><td><code id="khi2_+3A_pi">pi</code></td>
<td>
<p>a vector of size K, where K is the number of clusters, containing the probabilities of a good paired comparison
of the model (dispersion parameters).</p>
</td></tr>
<tr><td><code id="khi2_+3A_nboot">nBoot</code></td>
<td>
<p>number of bootstrap iterations used to estimate the p-value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the p-value of the test.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proportion &lt;- c(0.4, 0.6)
pi &lt;- c(0.8, 0.75)
mu &lt;- matrix(c(1, 2, 3, 4, 4, 2, 1, 3), nrow = 2, byrow = TRUE)
# simulate a data set with declared parameters.
data &lt;- rbind(
  simulISR(proportion[1] * 100, pi[1], mu[1, ]),
  simulISR(proportion[2] * 100, pi[2], mu[2, ])
)
pval &lt;- khi2(data, proportion, mu, pi)

</code></pre>

<hr>
<h2 id='kullback'>Kullback-Leibler divergence</h2><span id='topic+kullback'></span>

<h3>Description</h3>

<p>It computes the Kullback-Leibler divergence between two mixtures of multidimensional ISR distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kullback(proportion1, pi1, mu1, proportion2, pi2, mu2, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kullback_+3A_proportion1">proportion1</code>, <code id="kullback_+3A_proportion2">proportion2</code></td>
<td>
<p>vectors (which sums to 1) containing the K mixture proportions.</p>
</td></tr>
<tr><td><code id="kullback_+3A_pi1">pi1</code>, <code id="kullback_+3A_pi2">pi2</code></td>
<td>
<p>matrices of size K*p, where K is the number of clusters and p the number of dimension,
containing the probabilities of a good comparison of the model (dispersion parameters).</p>
</td></tr>
<tr><td><code id="kullback_+3A_mu1">mu1</code>, <code id="kullback_+3A_mu2">mu2</code></td>
<td>
<p>matrices of size K*sum(m), containing the modal ranks. Each row contains the modal rank for a cluster.
In the case of multivariate ranks, the reference rank for each dimension are set successively on the same row.</p>
</td></tr>
<tr><td><code id="kullback_+3A_m">m</code></td>
<td>
<p>a vector containing the size of ranks for each dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Kullback-Leibler divergence.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Kullback
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proportion1 &lt;- c(0.4, 0.6)
pi1 &lt;- matrix(c(0.8, 0.75), nrow = 2)
mu1 &lt;- matrix(c(1, 2, 3, 4, 4, 2, 1, 3), nrow = 2, byrow = TRUE)

proportion2 &lt;- c(0.43, 0.57)
pi2 &lt;- matrix(c(0.82, 0.7), nrow = 2)
mu2 &lt;- matrix(c(1, 2, 3, 4, 4, 2, 1, 3), nrow = 2, byrow = TRUE)

dK &lt;- kullback(proportion1, pi1, mu1, proportion2, pi2, mu2, 4)

</code></pre>

<hr>
<h2 id='Output-class'>Constructor of Output class</h2><span id='topic+Output-class'></span>

<h3>Description</h3>

<p>This class contains a result of a run. Let K be the total number of cluster,
p the number of dimension m the p-vector containing the size of each dimension.
</p>


<h3>Slots</h3>


<dl>
<dt><code>proportion</code></dt><dd><p>a K-vector of proportions.</p>
</dd>
<dt><code>pi</code></dt><dd><p>a K*p-matrix composed of the scale parameters.</p>
</dd>
<dt><code>mu</code></dt><dd><p>a matrix with K lines and sum(m) columns in which line k is composed of the location
parameters of cluster k.</p>
</dd>
<dt><code>ll</code></dt><dd><p>the estimated log-likelihood.</p>
</dd>
<dt><code>bic</code></dt><dd><p>the estimated BIC criterion.</p>
</dd>
<dt><code>icl</code></dt><dd><p>the estimated ICL criterion.</p>
</dd>
<dt><code>tik</code></dt><dd><p>a n*K-matrix containing the estimation of the conditional probabilities for the observed
ranks to belong to each cluster.</p>
</dd>
<dt><code>partition</code></dt><dd><p>a n-vector containing the partition estimation resulting from the clustering.</p>
</dd>
<dt><code>entropy</code></dt><dd><p>a n*2-matrix containing for each observation its estimated cluster and its entropy. The entropy
output illustrates the confidence in the clustering of each observation (a high entropy means a
low confidence in the clustering)..</p>
</dd>
<dt><code>probability</code></dt><dd><p>a n*2-matrix similar to the entropy output, containing for each observation
its estimated cluster and its probability p(xi; mk, pk) given its
cluster. This probability is estimated using the last simulation of the presentation orders used
for the likelihood approximation. The probability output exhibits the best representative of
each cluster.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>a boolean indicating if none problem of empty class has been encountered.</p>
</dd>
<dt><code>partial</code></dt><dd><p>a boolean indicating the presence of partial rankings or ties.</p>
</dd>
<dt><code>partialRank</code></dt><dd><p>a matrix containing the full rankings, estimated using the within cluster ISR parameters
when the ranking is partial. When ranking is full, partialRank simply contains the
observed ranking. Available only in presence of at least one partial ranking.</p>
</dd>
<dt><code>partialRankScore</code></dt><dd><p>confidence score in estimated partial rank</p>
</dd>
<dt><code>distanceProp</code></dt><dd><p>Distances (MSE) between the final estimation and the current
value at each iteration of the SEM-Gibbs algorithm (except the burn-in phase) for proportions. A list of Qsem-Bsem elements,
each element being a K*p-matrix.</p>
</dd>
<dt><code>distancePi</code></dt><dd><p>Distances (MSE) between the final estimation and the current value at each iteration of the
SEM-Gibbs algorithm (except the burn-in phase) for scale parameters. A list of Qsem-Bsem elements,
each element being a K*p-matrix.</p>
</dd>
<dt><code>distanceMu</code></dt><dd><p>Distances (Kendall distance) between the final estimation and the current value at each iteration of the
SEM-Gibbs algorithm (except the burn-in phase) for proportions. A list of Qsem-Bsem elements,
each element being a K*p-matrix.</p>
</dd>
<dt><code>distanceZ</code></dt><dd><p>a vector of size Qsem-Bsem containing the rand index between the final
estimated partition and the current value at each iteration of the SEM-Gibbs algorithm (except
the burn-in phase). Let precise that the rand index is not affected by label switching.</p>
</dd>
<dt><code>distancePartialRank</code></dt><dd><p>Kendall distance between the final estimation of the partial rankings
(missing positions in such rankings are estimated) and the current value at each iteration of the
SEM-Gibbs algorithm (except the burn-in phase). distancePartialRank is a list of Qsem-Bsem
elements, each element being a matrix of size n*p. Available only in presence of at least one
partial ranking.</p>
</dd>
<dt><code>proportionInitial</code></dt><dd><p>a vector containing the initialization of proportions in the algorithm.</p>
</dd>
<dt><code>piInitial</code></dt><dd><p>a matrix containing the initialization of the probabilities of good paired comparison in the algorithm.</p>
</dd>
<dt><code>muInitial</code></dt><dd><p>a matrix containing the initialization of modal rankings in the algorithm.</p>
</dd>
<dt><code>partialRankInitial</code></dt><dd><p>a matrix containing the initialization of the partial rankings in the algorithm.</p>
</dd>
</dl>

<hr>
<h2 id='probability'>Probability computation</h2><span id='topic+probability'></span>

<h3>Description</h3>

<p>It computes the probability of a (multivariate) rank x according to a ISR(mu, pi).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probability(x, mu, pi, m = length(mu))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probability_+3A_x">x</code></td>
<td>
<p>a vector or a matrix containing the rankings in ranking notation (see Details or <a href="#topic+convertRank">convertRank</a> function).
The rankings of each dimension are placed end to end. <code>x</code> must contain only full ranking (no partial or tied).</p>
</td></tr>
<tr><td><code id="probability_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>sum(m)</code> containing the modal ranks in ranking notation (see Details or
<a href="#topic+convertRank">convertRank</a> function).
The rankings of each dimension are placed end to end. <code>mu</code> must contain only full ranking (no partial or tied).</p>
</td></tr>
<tr><td><code id="probability_+3A_pi">pi</code></td>
<td>
<p>a vector of size <code>p=length(m)</code>, where <code>p</code> is the number of dimension, containing the probabilities of
a good comparison of the model (dispersion parameters).</p>
</td></tr>
<tr><td><code id="probability_+3A_m">m</code></td>
<td>
<p>a vector containing the size of ranks for each dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ranks have to be given to the package in the ranking notation (see <a href="#topic+convertRank">convertRank</a> function),
with the following convention:
</p>
<p>- missing positions are replaced by 0
</p>
<p>- tied are replaced by the lowest position they share&quot;
</p>
<p>The ranking representation r=(r_1,...,r_m) contains the
ranks assigned to the objects, and means that the ith
object is in r_ith position.
</p>
<p>The ordering representation o=(o_1,...,o_m) means that object
o_i is in the ith position.
</p>
<p>Let us consider the following example to illustrate both
notations: a judge, which has to rank three holidays
destinations according to its preferences, O1 =
Countryside, O2 =Mountain and O3 = Sea, ranks first Sea,
second Countryside, and last Mountain. The ordering
result of the judge is o = (3, 1, 2) whereas the ranking
result is r = (2, 3, 1).
</p>


<h3>Value</h3>

<p>the probability of <code>x</code> according to a ISR(mu, pi).
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- c(4, 5)
x &lt;- mu &lt;- matrix(nrow = 1, ncol = 9)
x[1:4] &lt;- c(1, 4, 2, 3)
x[5:9] &lt;- c(3, 5, 2, 4, 1)
mu[1:4] &lt;- 1:4
mu[5:9] &lt;- c(3, 5, 4, 2, 1)
pi &lt;- c(0.75, 0.82)

prob &lt;- probability(x, mu, pi, m)
prob

</code></pre>

<hr>
<h2 id='quiz'>Multidimensional rank data: quiz</h2><span id='topic+quiz'></span>

<h3>Description</h3>

<p>This dataset contains the answers of 70 students (40 of third year and 30 of fourth year)
from Polytech'Lille (statistics engineering school, France) to the four following quizzes:
</p>
<p>#'
</p>
<dl>
<dt>Literature Quiz</dt><dd>
<p>This quiz consists of ranking four French writers according to chronological order:
A=Victor Hugo, B=Molière, C=Albert Camus, D=Jean-Jacques Rousseau.</p>
</dd>
<dt>Football Quiz</dt><dd>
<p>This quiz consists of ranking four national football teams according to increasing number of wins in the football
World Cup: A=France, B=Germany, C=Brazil, D=Italy.</p>
</dd>
<dt>Mathematics Quiz</dt><dd>
<p>This quiz consists of ranking four numbers according to increasing order:
A=pi/3, B=log(1), C=exp(2), D=(1+sqrt(5))/2.</p>
</dd>
<dt>Cinema Quiz</dt><dd>
<p>This quiz consists of ranking four Tarantino's movies according to chronological order:
A=Inglourious Basterds, B=Pulp Fiction, C=Reservoir Dogs, D=Jackie Brown.</p>
</dd>
</dl>



<h3>Format</h3>

<p>A list containing:
</p>

<dl>
<dt>data</dt><dd><p>a matrix of size 70*16. The student's answers are in row and the 16 columns correspond to the 4 rankings
(for the 4 quizzes) of size 4 (ranking representation).
</p>
<p>The ranking representation r=(r_1,...,r_m) contains the  ranks assigned to the objects, and means that the ith object is
in r_ith position.
</p>
<p>For example, if the ranking representation of a rank is (4,3,1,2,5), it means that judge ranks the first object in 4th
position, second object in 3rd position, ...</p>
</dd>
<dt>frequency</dt><dd><p>a matrix of size 63*17. Each row corresponds to one of the 63 different observed rankings
(ranking representation). Each row contains 4 ranks of size 4 and a last column for the frequency.</p>
</dd>
<dt>m</dt><dd><p>a vector with the sizes of the ranks for each dimension.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Julien Jacques
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+APA">APA</a></code>,
<code><a href="#topic+big4">big4</a></code>,
<code><a href="#topic+eurovision">eurovision</a></code>,
<code><a href="#topic+sports">sports</a></code>,
<code><a href="#topic+words">words</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quiz)

</code></pre>

<hr>
<h2 id='rankclust'>Model-based clustering for multivariate partial ranking</h2><span id='topic+rankclust'></span>

<h3>Description</h3>

<p>This functions estimates a clustering of ranking data, potentially multivariate, partial and containing tied,
based on a mixture of multivariate ISR model [2].
By specifying only one cluster, the function performs a modelling of the ranking data using the multivariate ISR model.
The estimation is performed thanks to a SEM-Gibbs algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankclust(
  data,
  m = ncol(data),
  K = 1,
  criterion = "bic",
  Qsem = 100,
  Bsem = 20,
  RjSE = m * (m - 1)/2,
  RjM = m * (m - 1)/2,
  Ql = 500,
  Bl = 100,
  maxTry = 3,
  run = 1,
  detail = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankclust_+3A_data">data</code></td>
<td>
<p>a matrix in which each row is a ranking (partial or not; for partial ranking,
missing elements must be 0 or NA. Tied are replaced by the lowest position they share). For multivariate rankings,
the rankings of each dimension are placed end to end in each row. The data must be in ranking notation (see Details or
<a href="#topic+convertRank">convertRank</a> functions).</p>
</td></tr>
<tr><td><code id="rankclust_+3A_m">m</code></td>
<td>
<p>a vector composed of the sizes of the rankings of each dimension (default value is the number of column of the
matrix data).</p>
</td></tr>
<tr><td><code id="rankclust_+3A_k">K</code></td>
<td>
<p>an integer or a vector of integer with the number of clusters.</p>
</td></tr>
<tr><td><code id="rankclust_+3A_criterion">criterion</code></td>
<td>
<p>criterion &quot;bic&quot; or &quot;icl&quot;, criterion to minimize for selecting the number of clusters.</p>
</td></tr>
<tr><td><code id="rankclust_+3A_qsem">Qsem</code></td>
<td>
<p>the total number of iterations for the SEM algorithm (default value=40).</p>
</td></tr>
<tr><td><code id="rankclust_+3A_bsem">Bsem</code></td>
<td>
<p>burn-in period for SEM algorithm (default value=10).</p>
</td></tr>
<tr><td><code id="rankclust_+3A_rjse">RjSE</code></td>
<td>
<p>a vector containing, for each dimension, the number of iterations of the Gibbs sampler
used both in the SE step for partial rankings and for the presentation orders generation (default value=mj(mj-1)/2).</p>
</td></tr>
<tr><td><code id="rankclust_+3A_rjm">RjM</code></td>
<td>
<p>a vector containing, for each dimension, the number of iterations of the Gibbs sampler used in the  M step
(default value=mj(mj-1)/2)</p>
</td></tr>
<tr><td><code id="rankclust_+3A_ql">Ql</code></td>
<td>
<p>number of iterations of the Gibbs sampler
for estimation of log-likelihood (default value=100).</p>
</td></tr>
<tr><td><code id="rankclust_+3A_bl">Bl</code></td>
<td>
<p>burn-in period for estimation of log-likelihood (default value=50).</p>
</td></tr>
<tr><td><code id="rankclust_+3A_maxtry">maxTry</code></td>
<td>
<p>maximum number of restarts of the SEM-Gibbs algorithm in the case of non convergence (default value=3).</p>
</td></tr>
<tr><td><code id="rankclust_+3A_run">run</code></td>
<td>
<p>number of runs of the algorithm for each value of K.</p>
</td></tr>
<tr><td><code id="rankclust_+3A_detail">detail</code></td>
<td>
<p>boolean, if TRUE, time and others information will be print during the process (default value FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ranks have to be given to the package in the ranking notation (see <a href="#topic+convertRank">convertRank</a> function), with the following
convention:
</p>
<p>- missing positions are replaced by 0
</p>
<p>- tied are replaced by the lowest position they share
</p>
<p>See the vignette dataFormat for mode details (<code>RShowDoc("dataFormat", package = "Rankcluster")</code>).
</p>
<p>The ranking representation r=(r_1,...,r_m) contains the
ranks assigned to the objects, and means that the ith
object is in r_ith position.
</p>
<p>The ordering representation o=(o_1,...,o_m) means that object
o_i is in the ith position.
</p>
<p>Let us consider the following example to illustrate both
notations: a judge, which has to rank three holidays
destinations according to its preferences, O1 =
Countryside, O2 =Mountain and O3 = Sea, ranks first Sea,
second Countryside, and last Mountain. The ordering
result of the judge is o = (3, 1, 2) whereas the ranking
result is r = (2, 3, 1).
</p>


<h3>Value</h3>

<p>An object of class Rankclust (See <code><a href="#topic+Output-class">Output-class</a></code> and <code><a href="#topic+Rankclust-class">Rankclust-class</a></code>).
If the output object is named <code>res</code>. You can access the result by res[number of groups]@slotName where
<code>slotName</code> is an element of the class Output.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>References</h3>

<p>[1] C.Biernacki and J.Jacques (2013), A generative model for rank data based on sorting algorithm,
Computational Statistics and Data Analysis, 58, 162-176.
</p>
<p>[2] J.Jacques and C.Biernacki (2012), Model-based clustering for multivariate partial ranking data,
Inria Research Report n 8113.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+Output-class">Output-class</a></code> and <code><a href="#topic+Rankclust-class">Rankclust-class</a></code> for available output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(big4)
result &lt;- rankclust(big4$data, K = 2, m = big4$m, Ql = 200, Bl = 100, maxTry = 2)

if(result@convergence) {
  summary(result)

  partition &lt;- result[2]@partition
  tik &lt;- result[2]@tik
}

</code></pre>

<hr>
<h2 id='Rankclust-class'>Constructor of Rankclust class</h2><span id='topic+Rankclust-class'></span>

<h3>Description</h3>

<p>This class contains results of <a href="#topic+rankclust">rankclust</a> function.
</p>


<h3>Details</h3>

<p>If <code>res</code> is the result of <a href="#topic+rankclust">rankclust</a> function, each slot of results can be reached by <code>res[k]@slotname</code>,
where <code>k</code> is the number of clusters and <code>slotname</code> is the name of the slot we want to reach
(see <a href="#topic+Output-class">Output-class</a>).
For the slots, <code>ll</code>, <code>bic</code>, <code>icl</code>, <code>res["slotname"]</code> returns a vector of size <code>k</code> containing
the values of the slot for each number of clusters.
</p>


<h3>Slots</h3>


<dl>
<dt><code>K</code></dt><dd><p>a vector of the number of clusters.</p>
</dd>
<dt><code>data</code></dt><dd><p>the data used for clustering.</p>
</dd>
<dt><code>criterion</code></dt><dd><p>the model selection criterion used.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>a boolean indicating if none problem of empty class has been encountered (for
any number of clusters).</p>
</dd>
<dt><code>results</code></dt><dd><p>a list of <a href="#topic+Output-class">Output-class</a>, containing the results for each number of clusters (one
element of the list is associated to one number of clusters).</p>
</dd>
</dl>

<hr>
<h2 id='show+2COutput-method'>Show function.</h2><span id='topic+show+2COutput-method'></span><span id='topic+show+2CRankclust-method'></span>

<h3>Description</h3>

<p>This function shows the elements of a given object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Output'
show(object)

## S4 method for signature 'Rankclust'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2COutput-method_+3A_object">object</code></td>
<td>
<p>an object of class <a href="#topic+Output-class">Output-class</a> or <a href="#topic+Rankclust-class">Rankclust-class</a>.</p>
</td></tr>
</table>

<hr>
<h2 id='simulISR'>Simulate a sample of ISR(pi,mu)</h2><span id='topic+simulISR'></span>

<h3>Description</h3>

<p>This function simulates univariate rankings data (ordering representation) according to the ISR(pi,mu).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulISR(n, pi, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulISR_+3A_n">n</code></td>
<td>
<p>size of the sample.</p>
</td></tr>
<tr><td><code id="simulISR_+3A_pi">pi</code></td>
<td>
<p>dispersion parameter: probability of correct paired comparison according to mu.</p>
</td></tr>
<tr><td><code id="simulISR_+3A_mu">mu</code></td>
<td>
<p>position parameter: modal ranking in ordering representation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ranking representation r=(r_1,...,r_m) contains the
ranks assigned to the objects, and means that the ith
object is in r_ith position.
</p>
<p>The ordering representation o=(o_1,...,o_m) means that
object o_i is in the ith position.
</p>
<p>Let us consider the following example to illustrate both
notations: a judge, which has to rank three holidays
destinations according to its preferences, O1 =
Countryside, O2 =Mountain and O3 = Sea, ranks first Sea,
second Countryside, and last Mountain. The ordering
result of the judge is o = (3, 1, 2) whereas the ranking
result is r = (2, 3, 1).
</p>
<p>You can see the <a href="#topic+convertRank">convertRank</a> function to convert the simulated ranking from ordering to ranking representation.
</p>


<h3>Value</h3>

<p>a matrix with simulated ranks.
</p>


<h3>Author(s)</h3>

<p>Julien Jacques
</p>


<h3>References</h3>

<p>[1] C.Biernacki and J.Jacques (2013), A generative model for rank data based on sorting algorithm,
Computational Statistics and Data Analysis, 58, 162-176.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- simulISR(30, 0.8, 1:4)

</code></pre>

<hr>
<h2 id='sports'>Rank data: sports</h2><span id='topic+sports'></span>

<h3>Description</h3>

<p>This data set is due to Louis Roussos who asked 130 students at the
University of Illinois to rank seven sports according to their preference in participating:
A = Baseball, B = Football, C = Basketball, D = Tennis, E = Cycling, F =
Swimming, G = Jogging.
</p>


<h3>Format</h3>

<p>A list containing:
</p>

<dl>
<dt>data</dt><dd><p>a matrix containing 130 ranks of size 7 in ranking representation.
</p>
<p>The ranking representation r=(r_1,...,r_m) contains the  ranks assigned to the objects, and means that
the ith object is in r_ith position.
</p>
<p>For example, if the ranking representation of a rank is (4,3,1,2,5), it means that judge ranks the first
object in 4th position, second object in 3rd position, ...</p>
</dd>
<dt>frequency</dt><dd><p>a matrix with 123 different ranks of size 7. In each row the first 7 columns correspond to one
observed ranking and the last column contains the observation frequency.</p>
</dd>
<dt>m</dt><dd><p> the size of the rankings (m=7).</p>
</dd>
</dl>



<h3>Source</h3>

<p>J.I. Marden. &quot;Analyzing and modeling rank data, volume 64 of Monographs on Statistics and Applied Probability&quot;. Chapman &amp; Hall, London, 1995.
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+APA">APA</a></code>,
<code><a href="#topic+big4">big4</a></code>,
<code><a href="#topic+eurovision">eurovision</a></code>,
<code><a href="#topic+quiz">quiz</a></code>,
<code><a href="#topic+words">words</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sports)

</code></pre>

<hr>
<h2 id='summary+2CRankclust-method'>Summary function.</h2><span id='topic+summary+2CRankclust-method'></span>

<h3>Description</h3>

<p>This function gives the summary of an output from <code>rankclust</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rankclust'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CRankclust-method_+3A_object">object</code></td>
<td>
<p>output object from <code><a href="#topic+rankclust">rankclust</a></code>.</p>
</td></tr>
<tr><td><code id="summary+2B2CRankclust-method_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='unfrequence'>Convert data</h2><span id='topic+unfrequence'></span>

<h3>Description</h3>

<p>This function takes in input a matrix in which the m first columns are the different observed ranks and
the last column contains the observation frequency, and returns a matrix containing all the ranks (ranks with frequency&gt;1
are repeated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfrequence(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfrequence_+3A_data">data</code></td>
<td>
<p>a matrix containing rankings and observation frequency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing all the rankings.
</p>


<h3>See Also</h3>

<p><a href="#topic+frequence">frequence</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quiz)
Y &lt;- unfrequence(quiz$frequency)
Y

</code></pre>

<hr>
<h2 id='words'>Rank data: words</h2><span id='topic+words'></span>

<h3>Description</h3>

<p>The data was collected under the auspices of the Graduate Record
Examination Board. A sample of 98 college students were asked to rank five words according to strength of association
(least to most associated) with the target word &quot;Idea&quot;:
A = Thought, B = Play, C = Theory, D = Dream and E = Attention.
</p>


<h3>Format</h3>

<p>A list containing:
</p>

<dl>
<dt>data</dt><dd><p>A matrix of size 98*5 containing the 98 answers. Each row corresponding to one ranking
(ranking representation).
</p>
<p>The ranking representation r=(r_1,...,r_m) contains the  ranks assigned to the objects, and means that
the ith object is in r_ith position.
</p>
<p>For example, if the ranking representation of a rank is (4,3,1,2,5), it means that judge ranks the
first object in 4th position, second object in 3rd position, ...</p>
</dd>
<dt>frequency</dt><dd><p>matrix of size 15*6. Each row corresponds to one of the 15 different observed rankings, and the
last column contains the observation frequency.</p>
</dd>
<dt>m</dt><dd><p>the size of the rankings (m=5).</p>
</dd>
</dl>



<h3>Source</h3>

<p>M.A. Fligner and J.S. Verducci. &quot;Distance based ranking models&quot;. J. Roy. Statist. Soc. Ser. B, 48(3):359-369, 1986.
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+APA">APA</a></code>,
<code><a href="#topic+big4">big4</a></code>,
<code><a href="#topic+eurovision">eurovision</a></code>,
<code><a href="#topic+quiz">quiz</a></code>,
<code><a href="#topic+sports">sports</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sports)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
