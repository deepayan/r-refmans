<!DOCTYPE html><html lang="en"><head><title>Help for package pooledpeaks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pooledpeaks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pooledpeaks-package'><p>pooledpeaks: Genetic Analysis of Pooled Samples</p></a></li>
<li><a href='#AlRich'><p>Calculate Allelic Richness</p></a></li>
<li><a href='#associate_dyes'><p>Associate Dye Names in Batch Import Output</p></a></li>
<li><a href='#BootStrap3'><p>Perform Bootstrap Analysis</p></a></li>
<li><a href='#check_fsa_v_batch'><p>Check .fsa Version and Batch Information</p></a></li>
<li><a href='#clean_scores'><p>Clean Scores Data</p></a></li>
<li><a href='#cluster'><p>K-means Clustering</p></a></li>
<li><a href='#ClusterFromSamples'><p>Cluster From Samples</p></a></li>
<li><a href='#data_manipulation'><p>Data Manipulation for Marker Data</p></a></li>
<li><a href='#DistCor'><p>Distance Correlation</p></a></li>
<li><a href='#EmpiricalSE'><p>Calculate Empirical Standard Error</p></a></li>
<li><a href='#fsa_batch_imp'><p>Batch Import of .fsa files</p></a></li>
<li><a href='#fsa_metadata'><p>Retrieve Metadata</p></a></li>
<li><a href='#GeneIdentityMatrix'><p>Gene Identity Matrix</p></a></li>
<li><a href='#GeneticDistanceMatrix'><p>Genetic Distance Matrix</p></a></li>
<li><a href='#GST'><p>Nei's GST</p></a></li>
<li><a href='#JostD'><p>Calculate Jost's D</p></a></li>
<li><a href='#JostD_KK'><p>Pairwise Jost D between replicates</p></a></li>
<li><a href='#lf_to_tdf'><p>Transform LF to TDF</p></a></li>
<li><a href='#LoadData'><p>Load Genetic Data</p></a></li>
<li><a href='#MDSplot'><p>Multi Dimensional Scaling (MDS) Plot</p></a></li>
<li><a href='#PCDM'><p>Post-consolidation Data Manipulation</p></a></li>
<li><a href='#preGST'><p>Pre GST Calculation</p></a></li>
<li><a href='#preJostD'><p>Calculate Pre-Jost's D</p></a></li>
<li><a href='#Rep_check'><p>Replicate Check for Duplicate Samples</p></a></li>
<li><a href='#RWCDistanceMatrix'><p>Random Walk Covariance Distance Matrix</p></a></li>
<li><a href='#SampleOfLoci'><p>Sample Of Loci</p></a></li>
<li><a href='#score_markers_rev3'><p>Score Markers Wrapper</p></a></li>
<li><a href='#TwoLevelGST'><p>Calculate Two-Level GST</p></a></li>
<li><a href='#TypedLoci'><p>Typed Loci</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Genetic Analysis of Pooled Samples</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyzing genetic data obtained from pooled samples. 
    This package can read in Fragment Analysis output files, process the data, 
    and score peaks, as well as facilitate various analyses, including cluster 
    analysis, calculation of genetic distances and diversity indices, 
    as well as bootstrap resampling for statistical inference. Specifically 
    tailored to handle genetic data efficiently, researchers can explore 
    population structure, genetic differentiation, and genetic relatedness 
    among samples. We updated some functions from Covarrubias-Pazaran et al. 
    (2016) &lt;<a href="https://doi.org/10.1186%2Fs12863-016-0365-6">doi:10.1186/s12863-016-0365-6</a>&gt; to allow for the use of new file formats 
    and referenced the following to write our genetic analysis functions: 
    Long et al. (2022) &lt;<a href="https://doi.org/10.1038%2Fs41598-022-04776-0">doi:10.1038/s41598-022-04776-0</a>&gt;, Jost (2008) 
    &lt;<a href="https://doi.org/10.1111%2Fj.1365-294x.2008.03887.x">doi:10.1111/j.1365-294x.2008.03887.x</a>&gt;, Nei (1973) 
    &lt;<a href="https://doi.org/10.1073%2Fpnas.70.12.3321">doi:10.1073/pnas.70.12.3321</a>&gt;, Foulley et al. (2006) 
    &lt;<a href="https://doi.org/10.1016%2Fj.livprodsci.2005.10.021">doi:10.1016/j.livprodsci.2005.10.021</a>&gt;, Chao et al. (2008) 
    &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2008.01010.x">doi:10.1111/j.1541-0420.2008.01010.x</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kmkuesters/pooledpeaks">https://github.com/kmkuesters/pooledpeaks</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, dplyr, Fragman, graphics, magrittr, pdftools, qpdf,
rlang, stats, tibble, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kmkuesters/pooledpeaks/issues">https://github.com/kmkuesters/pooledpeaks/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-14 20:56:28 UTC; kathleenkuesters</td>
</tr>
<tr>
<td>Author:</td>
<td>Kathleen Kuesters <a href="https://orcid.org/0000-0003-0238-7889"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Jeffrey Long [aut],
  Jessica Blanton [aut],
  Walter Blank [ctb],
  Jeffrey Kovach [ctb],
  Ronald Blanton [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kathleen Kuesters &lt;kathleen.kuesters@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pooledpeaks-package'>pooledpeaks: Genetic Analysis of Pooled Samples</h2><span id='topic+pooledpeaks'></span><span id='topic+pooledpeaks-package'></span>

<h3>Description</h3>

<p>Analyzing genetic data obtained from pooled samples. This package can read in Fragment Analysis output files, process the data, and score peaks, as well as facilitate various analyses, including cluster analysis, calculation of genetic distances and diversity indices, as well as bootstrap resampling for statistical inference. Specifically tailored to handle genetic data efficiently, researchers can explore population structure, genetic differentiation, and genetic relatedness among samples. We updated some functions from Covarrubias-Pazaran et al. (2016) <a href="https://doi.org/10.1186/s12863-016-0365-6">doi:10.1186/s12863-016-0365-6</a> to allow for the use of new file formats and referenced the following to write our genetic analysis functions: Long et al. (2022) <a href="https://doi.org/10.1038/s41598-022-04776-0">doi:10.1038/s41598-022-04776-0</a>, Jost (2008) <a href="https://doi.org/10.1111/j.1365-294x.2008.03887.x">doi:10.1111/j.1365-294x.2008.03887.x</a>, Nei (1973) <a href="https://doi.org/10.1073/pnas.70.12.3321">doi:10.1073/pnas.70.12.3321</a>, Foulley et al. (2006) <a href="https://doi.org/10.1016/j.livprodsci.2005.10.021">doi:10.1016/j.livprodsci.2005.10.021</a>, Chao et al. (2008) <a href="https://doi.org/10.1111/j.1541-0420.2008.01010.x">doi:10.1111/j.1541-0420.2008.01010.x</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kathleen Kuesters <a href="mailto:kathleen.kuesters@gmail.com">kathleen.kuesters@gmail.com</a> (<a href="https://orcid.org/0000-0003-0238-7889">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Jeffrey Long
</p>
</li>
<li><p> Jessica Blanton
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Walter Blank [contributor]
</p>
</li>
<li><p> Jeffrey Kovach [contributor]
</p>
</li>
<li><p> Ronald Blanton [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/kmkuesters/pooledpeaks">https://github.com/kmkuesters/pooledpeaks</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/kmkuesters/pooledpeaks/issues">https://github.com/kmkuesters/pooledpeaks/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AlRich'>Calculate Allelic Richness</h2><span id='topic+AlRich'></span>

<h3>Description</h3>

<p>This function calculates allelic richness based on provided genetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlRich(datafile = data.frame, n = matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AlRich_+3A_datafile">datafile</code></td>
<td>
<p>A data frame containing the data as read in by
<a href="#topic+LoadData">LoadData</a></p>
</td></tr>
<tr><td><code id="AlRich_+3A_n">n</code></td>
<td>
<p>A matrix representing the number of markers successfully genotyped
like the output of the <a href="#topic+TypedLoci">TypedLoci</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the allelic richness for each locus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
genetic_data &lt;- data.frame(
Locus = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2),
Locus_allele = c("Marker1", "n", 1, 2, 3, "Marker2", "n", 1, 2, 3),
Sample1 = c(NA, 10, 0.5, 0.5, 0, NA, 10, 0.2, 0.3, 0.5),
Sample2 = c(NA, 20, 0.1, 0.2, 0.7, NA, 20, 0.3, 0.4, 0.3),
Sample3 = c(NA, 30, 0.3, 0.4, 0.3, NA, 30, 0.4, 0.2, 0.4)
)

n_alleles &lt;- matrix(c(
3, 3, 3,
3, 3, 3,
3, 3, 3
), nrow = 3, byrow = TRUE,
dimnames = list(paste0("Sample", 1:3), paste0("Sample", 1:3)))

AlRich(datafile=genetic_data,n=n_alleles)
</code></pre>

<hr>
<h2 id='associate_dyes'>Associate Dye Names in Batch Import Output</h2><span id='topic+associate_dyes'></span>

<h3>Description</h3>

<p>This function associates dye info with fragman channel names. It was
designed to be performed on any fsa formats after final columns are
correctly imported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>associate_dyes(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="associate_dyes_+3A_x">x</code></td>
<td>
<p>The Output list of data frames from fsa_batch_imp.</p>
</td></tr>
<tr><td><code id="associate_dyes_+3A_y">y</code></td>
<td>
<p>The path to the folder from the current directory where the
.fsa files that will be analyzed are stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe with an added column assigning fluorescent
dye colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- system.file("extdata", package = "pooledpeaks")
x &lt;- fsa_batch_imp(y, channels = 5, fourier = FALSE, saturated = FALSE ,
lets.pullup = FALSE, plotting = FALSE, rawPlot = FALSE,
llength = 3000, ulength = 80000 )
associate_dyes(x,y)
</code></pre>

<hr>
<h2 id='BootStrap3'>Perform Bootstrap Analysis</h2><span id='topic+BootStrap3'></span>

<h3>Description</h3>

<p>This function performs bootstrap analysis on genetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootStrap3(A = data.frame, Rep = 20, Stat = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootStrap3_+3A_a">A</code></td>
<td>
<p>Data frame containing data as read in by <a href="#topic+LoadData">LoadData</a></p>
</td></tr>
<tr><td><code id="BootStrap3_+3A_rep">Rep</code></td>
<td>
<p>Number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="BootStrap3_+3A_stat">Stat</code></td>
<td>
<p>Type of statistic to compute (1 for AlRich, 2 for TwoLevelGST)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a matrix of AlRich statistics or a list containing various
statistics computed using TwoLevelGST.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_data &lt;- data.frame(
Locus = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2),
Locus_allele = c("Marker1", "n", 1, 2, 3, "Marker2", "n", 1, 2, 3),
Sample1 = c(NA, 10, 0.5, 0.5, 0, NA, 10, 0.2, 0.3, 0.5),
Sample2 = c(NA, 20, 0.1, 0.2, 0.7, NA, 20, 0.3, 0.4, 0.3),
Sample3 = c(NA, 30, 0.3, 0.4, 0.3, NA, 30, 0.4, 0.2, 0.4)
)

BootStrap3(A=genetic_data, Rep=10, Stat=1)
BootStrap3(A=genetic_data, Rep=10, Stat=2)
</code></pre>

<hr>
<h2 id='check_fsa_v_batch'>Check .fsa Version and Batch Information</h2><span id='topic+check_fsa_v_batch'></span>

<h3>Description</h3>

<p>This function analyzes .fsa files in a specified folder, providing a summary
of their version and batch information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_fsa_v_batch(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_fsa_v_batch_+3A_x">x</code></td>
<td>
<p>The path to the folder from the current directory where the .fsa
files that will be analyzed are stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A written summary of how many .fsa files are in the folder and which
version they are.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file_path &lt;- system.file("extdata", package = "pooledpeaks")
check_fsa_v_batch(x = file_path)

</code></pre>

<hr>
<h2 id='clean_scores'>Clean Scores Data</h2><span id='topic+clean_scores'></span>

<h3>Description</h3>

<p>This function cleans the score_markers_rev3 data by applying specified
patterns and replacements to the ID and filename columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_scores(
  scores_data,
  pattern1 = NULL,
  replacement1 = NULL,
  pattern2 = NULL,
  replacement2 = NULL,
  pattern3 = NULL,
  replacement3 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_scores_+3A_scores_data">scores_data</code></td>
<td>
<p>The list containing the output scores data from the
score_markers_rev3.</p>
</td></tr>
<tr><td><code id="clean_scores_+3A_pattern1">pattern1</code></td>
<td>
<p>The first pattern to replace in the ID.This is intended to
clean up the ID names for when the machine adds substrings to the names. For
example 104.1a_FA060920_2020-06-09_C05.fsa.1 becomes 104.1a using
pattern1=&quot;_FA.*&quot; and replacement1= &quot;&quot;</p>
</td></tr>
<tr><td><code id="clean_scores_+3A_replacement1">replacement1</code></td>
<td>
<p>Replacement for the first pattern.</p>
</td></tr>
<tr><td><code id="clean_scores_+3A_pattern2">pattern2</code></td>
<td>
<p>The second pattern to replace in the ID. See pattern1 for
more details.</p>
</td></tr>
<tr><td><code id="clean_scores_+3A_replacement2">replacement2</code></td>
<td>
<p>Replacement for the second pattern.</p>
</td></tr>
<tr><td><code id="clean_scores_+3A_pattern3">pattern3</code></td>
<td>
<p>The pattern to replace in the file name.This is intended to
clean up the file names for when the machine adds sub strings to the names.
For example 104.1a_FA060920_2020-06-09_C05.fsa.1 becomes
104.1a_FA060920_2020-06-09_C05.fsa using pattern3= &quot;\.1*$&quot; and
replacement3= &quot;&quot;</p>
</td></tr>
<tr><td><code id="clean_scores_+3A_replacement3">replacement3</code></td>
<td>
<p>Replacement for the file name pattern.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cleaned long format data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scores_data &lt;- list(
data.frame(Score = c(90, 85, 70), stringsAsFactors = FALSE),
data.frame(Score = c(80, 75, 60), stringsAsFactors = FALSE)
)
rownames(scores_data[[1]]) &lt;- c("104.1a_FA060920_2020-06-09_C05.fsa_Sa.1",
                                "105.2b_FA060920_2020-06-09_C05.fsa_Sa.1",
                                "106.3c_FA060920_2020-06-09_C05.fsa_Fa.1")
rownames(scores_data[[2]]) &lt;- c("107.4d_FA060920_2020-06-09_C05.fsa_Sa.1",
                                "108.5e_FA060920_2020-06-09_C05.fsa_Sa.1",
                                "109.6f_SA060920_2020-06-09_C05.fsa_Fa.1")
clean_scores(scores_data,pattern1= "_SA.*", replacement1="",
pattern2= "_FA.*",replacement2="")

</code></pre>

<hr>
<h2 id='cluster'>K-means Clustering</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>K-means Clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(RawData = data.frame, K = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_+3A_rawdata">RawData</code></td>
<td>
<p>A data frame containing the raw data as read in by
<a href="#topic+LoadData">LoadData</a></p>
</td></tr>
<tr><td><code id="cluster_+3A_k">K</code></td>
<td>
<p>An integer specifying the number of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of the K-means cluster analysis,
including cluster assignments and original data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_data &lt;- data.frame(
Locus = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2),
Locus_allele = c("Marker1", "n", 1, 2, 3, "Marker2", "n", 1, 2, 3),
Sample1 = c(NA, 10, 0.5, 0.5, 0, NA, 10, 0.2, 0.3, 0.5),
Sample2 = c(NA, 20, 0.1, 0.2, 0.7, NA, 20, 0.3, 0.4, 0.3),
Sample3 = c(NA, 30, 0.3, 0.4, 0.3, NA, 30, 0.4, 0.2, 0.4)
)
cluster(RawData=genetic_data, K=2)
</code></pre>

<hr>
<h2 id='ClusterFromSamples'>Cluster From Samples</h2><span id='topic+ClusterFromSamples'></span>

<h3>Description</h3>

<p>Perform clustering on samples of loci from a data frame and calculate
statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusterFromSamples(datafile = data.frame, numloci = 5, reps = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ClusterFromSamples_+3A_datafile">datafile</code></td>
<td>
<p>A data frame containing the input data must be in LoadData
style <a href="#topic+LoadData">LoadData</a>.</p>
</td></tr>
<tr><td><code id="ClusterFromSamples_+3A_numloci">numloci</code></td>
<td>
<p>An integer specifying the number of loci to sample.</p>
</td></tr>
<tr><td><code id="ClusterFromSamples_+3A_reps">reps</code></td>
<td>
<p>An integer specifying the number of repetitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing statistics calculated from the clustering
results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_data &lt;- data.frame(
Locus = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2),
Locus_allele = c("Marker1", "n", 1, 2, 3, "Marker2", "n", 1, 2, 3),
Sample1 = c(NA, 10, 0.5, 0.5, 0, NA, 10, 0.2, 0.3, 0.5),
Sample2 = c(NA, 20, 0.1, 0.2, 0.7, NA, 20, 0.3, 0.4, 0.3),
Sample3 = c(NA, 30, 0.3, 0.4, 0.3, NA, 30, 0.4, 0.2, 0.4)
)

ClusterFromSamples(datafile=genetic_data, numloci=5, reps=10)
</code></pre>

<hr>
<h2 id='data_manipulation'>Data Manipulation for Marker Data</h2><span id='topic+data_manipulation'></span>

<h3>Description</h3>

<p>This function ensures that at least one peak for each sample is greater than
a specified threshold (default: 500) and then formats the data frame for
the next steps in the analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_manipulation(marker, threshold = 500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_manipulation_+3A_marker">marker</code></td>
<td>
<p>A data frame containing marker data, where each row represents
a marker and each column represents a sample.</p>
</td></tr>
<tr><td><code id="data_manipulation_+3A_threshold">threshold</code></td>
<td>
<p>The threshold value for peak height. Peaks below this
threshold will be replaced with 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted data frame where at least one peak for each sample is
greater than the specified threshold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
marker_data &lt;- data.frame(
Sample1 = c(400, 600, 700,0),
Sample2 = c(450, 550, 480,0),
Sample3 = c(300, 200, 400,200),
Sample4 = c(0,0,0,0),
row.names=c(185,188,191,194)
)
data_manipulation(marker_data,threshold=500)
</code></pre>

<hr>
<h2 id='DistCor'>Distance Correlation</h2><span id='topic+DistCor'></span>

<h3>Description</h3>

<p>Calculate the correlation between expected and realized genetic distances
and plot them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistCor(GD = matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DistCor_+3A_gd">GD</code></td>
<td>
<p>A matrix containing the genetic distance data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot showing the Expected Genetic Distance versus Realized Genetic
Distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_distance_matrix &lt;- matrix(c(0.316455, 0.2836333, 0.2760485,
0.2685221, 0.2797302,0.3202661,0.2836333, 0.3106084, 0.2867215, 0.2687472,
0.2596309, 0.2957862,0.2760485,0.2867215, 0.3338663, 0.297918, 0.3057039,
0.3153261,0.2685221, 0.2687472, 0.297918,0.3107094, 0.2753477, 0.3042383,
0.2797302, 0.2596309, 0.3057039, 0.2753477, 0.3761386, 0.3398558,0.3202661,
0.2957862, 0.3153261, 0.3042383, 0.3398558, 0.4402125),
 nrow = 6, byrow = TRUE,dimnames = list(c("Sample1", "Sample2", "Sample3",
  "Ind1", "Ind2", "Ind3"),
 c("Sample1", "Sample2", "Sample3", "Ind1", "Ind2", "Ind3")))

DC&lt;- DistCor(genetic_distance_matrix)

</code></pre>

<hr>
<h2 id='EmpiricalSE'>Calculate Empirical Standard Error</h2><span id='topic+EmpiricalSE'></span>

<h3>Description</h3>

<p>This function calculates the empirical standard error based on repeated
sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EmpiricalSE(datafile = data.frame, NLoci = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EmpiricalSE_+3A_datafile">datafile</code></td>
<td>
<p>A data frame containing genetic data from the
<a href="#topic+LoadData">LoadData</a></p>
</td></tr>
<tr><td><code id="EmpiricalSE_+3A_nloci">NLoci</code></td>
<td>
<p>Number of loci to sample in each iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the empirical standard error estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
genetic_data &lt;- data.frame(
Locus = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2),
Locus_allele = c("Marker1", "n", 1, 2, 3, "Marker2", "n", 1, 2, 3),
Sample1 = c(NA, 10, 0.5, 0.5, 0, NA, 10, 0.2, 0.3, 0.5),
Sample2 = c(NA, 20, 0.1, 0.2, 0.7, NA, 20, 0.3, 0.4, 0.3),
Sample3 = c(NA, 30, 0.3, 0.4, 0.3, NA, 30, 0.4, 0.2, 0.4)
)


EmpiricalSE(datafile=genetic_data, NLoci=3)
</code></pre>

<hr>
<h2 id='fsa_batch_imp'>Batch Import of .fsa files</h2><span id='topic+fsa_batch_imp'></span>

<h3>Description</h3>

<p>This function imports and extracts all of the information out of the .fsa
files and combines them into one list type object.<code>fsa_batch_imp</code> is a
modification of the original Fragman import script function, <code>storing.inds</code>,
This revised script accommodates ABI's .fsa file format up to version 3.
It retains Fragman functions for Fourier transformation, saturated peaks,
and pull-up correction. Notable adjustments include updating channel
parameters, utilizing Dyechannel count from the file directory, and
streamlining the script by extracting data only from &quot;DATA&quot; tags.
Major changes involve column selection for v3 formats and modifications to
the &quot;channel&quot; parameter. Minor changes include allowing relative paths for
the data directory, importing only .fsa files, and renaming channels with
dye names. This revision ensures successful execution for any format version
up to 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsa_batch_imp(
  folder,
  channels = NULL,
  fourier = TRUE,
  saturated = TRUE,
  lets.pullup = FALSE,
  plotting = FALSE,
  rawPlot = FALSE,
  llength = 3000,
  ulength = 80000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fsa_batch_imp_+3A_folder">folder</code></td>
<td>
<p>The path to the folder from the current directory where the
.fsa files that will be analyzed are stored.</p>
</td></tr>
<tr><td><code id="fsa_batch_imp_+3A_channels">channels</code></td>
<td>
<p>The number of dye channels expected, including the ladder.</p>
</td></tr>
<tr><td><code id="fsa_batch_imp_+3A_fourier">fourier</code></td>
<td>
<p>True/False Should fourier transformation be applied.</p>
</td></tr>
<tr><td><code id="fsa_batch_imp_+3A_saturated">saturated</code></td>
<td>
<p>True/False whether to Check and correct for saturated peaks.</p>
</td></tr>
<tr><td><code id="fsa_batch_imp_+3A_lets.pullup">lets.pullup</code></td>
<td>
<p>True/False Applying pull up correction to the samples to
decrease noise from channel to channel. The default is FALSE, please do not
change this.</p>
</td></tr>
<tr><td><code id="fsa_batch_imp_+3A_plotting">plotting</code></td>
<td>
<p>True/False Should plots be drawn of all channels after data
cleaning.</p>
</td></tr>
<tr><td><code id="fsa_batch_imp_+3A_rawplot">rawPlot</code></td>
<td>
<p>True/False indicating whether a plot should be drawn of all
vectors.</p>
</td></tr>
<tr><td><code id="fsa_batch_imp_+3A_llength">llength</code></td>
<td>
<p>A numeric value for the minimum number of indexes in each
channel.</p>
</td></tr>
<tr><td><code id="fsa_batch_imp_+3A_ulength">ulength</code></td>
<td>
<p>A numeric value for the maximum number fo indexes in each
channel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a LIST where each element of the list is a DATAFRAME with
the channels in columns for each FSA file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file_path &lt;- system.file("extdata", package = "pooledpeaks")
fsa_batch_imp(file_path, channels = 5, fourier = FALSE, saturated = FALSE ,
lets.pullup = FALSE,plotting = FALSE, rawPlot = FALSE)
</code></pre>

<hr>
<h2 id='fsa_metadata'>Retrieve Metadata</h2><span id='topic+fsa_metadata'></span>

<h3>Description</h3>

<p>Retrieves basic info from .fsa files about the sample and run,and aggregates
multiple samples in a single object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsa_metadata(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fsa_metadata_+3A_x">x</code></td>
<td>
<p>The path to the folder from the current directory where the .fsa
files that will be analyzed are stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the metadata of the machine and run
extracted from the .fsa file.
One row for each .fsa file in directory x and the following columns:
retrieved_sample_name, batch_container_name,  fsa_version, user,
run_start_date, run_start_time, machine_type,machineN_serial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file_path &lt;- system.file("extdata", package = "pooledpeaks")
fsa_metadata(x = file_path)

</code></pre>

<hr>
<h2 id='GeneIdentityMatrix'>Gene Identity Matrix</h2><span id='topic+GeneIdentityMatrix'></span>

<h3>Description</h3>

<p>Using the number of typed loci, this function calculates the gene identity
between all possible pairwise combinations between individuals for all
markers creating a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneIdentityMatrix(RawData = data.frame, LociGenotyped = matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeneIdentityMatrix_+3A_rawdata">RawData</code></td>
<td>
<p>A data frame containing the input data must be in LoadData
style <a href="#topic+LoadData">LoadData</a>.</p>
</td></tr>
<tr><td><code id="GeneIdentityMatrix_+3A_locigenotyped">LociGenotyped</code></td>
<td>
<p>The Output from the TypedLoci function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Gene Identity Matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_data &lt;- data.frame(
Locus = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2),
Locus_allele = c("Marker1", "n", 1, 2, 3, "Marker2", "n", 1, 2, 3),
Sample1 = c(NA, 10, 0.5, 0.5, 0, NA, 10, 0.2, 0.3, 0.5),
Sample2 = c(NA, 20, 0.1, 0.2, 0.7, NA, 20, 0.3, 0.4, 0.3),
Sample3 = c(NA, 30, 0.3, 0.4, 0.3, NA, 30, 0.4, 0.2, 0.4)
)

n_alleles &lt;- matrix(c(
3, 3, 3,
3, 3, 3,
3, 3, 3
), nrow = 3, byrow = TRUE,
dimnames = list(paste0("Sample", 1:3), paste0("Sample", 1:3)))

GeneIdentityMatrix(RawData=genetic_data,LociGenotyped=n_alleles)
</code></pre>

<hr>
<h2 id='GeneticDistanceMatrix'>Genetic Distance Matrix</h2><span id='topic+GeneticDistanceMatrix'></span>

<h3>Description</h3>

<p>This function calculates the genetic distance matrix from a given gene
identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneticDistanceMatrix(J = matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeneticDistanceMatrix_+3A_j">J</code></td>
<td>
<p>The Gene Identity Matrix created using
<a href="#topic+GeneIdentityMatrix">GeneIdentityMatrix</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Genetic Distance Matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene_identity_matrix &lt;- matrix(c(
0.3164550, 0.2836333, 0.2760485,
0.2836333, 0.3106084, 0.2867215,
0.2760485, 0.2867215, 0.3338663
), nrow = 3, byrow = TRUE,
dimnames = list(paste0("Sample", 1:3), paste0("Sample", 1:3)))

GeneticDistanceMatrix(gene_identity_matrix)
</code></pre>

<hr>
<h2 id='GST'>Nei's GST</h2><span id='topic+GST'></span>

<h3>Description</h3>

<p>This function calculates GST (Nei's standard genetic distance) measure from
a gene identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GST(J = matrix, pairwise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GST_+3A_j">J</code></td>
<td>
<p>A square matrix representing a gene identity matrix.</p>
</td></tr>
<tr><td><code id="GST_+3A_pairwise">pairwise</code></td>
<td>
<p>Logical indicating whether to calculate pairwise GST. If set
to FALSE, must not contain any missing data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If pairwise = TRUE, returns a matrix of pairwise GST values.
If pairwise = FALSE, returns the overall GST value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene_identity_matrix &lt;- matrix(c(
0.3164550, 0.2836333, 0.2760485,
0.2836333, 0.3106084, 0.2867215,
0.2760485, 0.2867215, 0.3338663
), nrow = 3, byrow = TRUE,
dimnames = list(paste0("Sample", 1:3), paste0("Sample", 1:3)))

GST(J=gene_identity_matrix, pairwise=TRUE)
GST(J=gene_identity_matrix, pairwise=FALSE)
</code></pre>

<hr>
<h2 id='JostD'>Calculate Jost's D</h2><span id='topic+JostD'></span>

<h3>Description</h3>

<p>This function calculates Jost's D measure from a gene identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JostD(J = matrix, pairwise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JostD_+3A_j">J</code></td>
<td>
<p>A gene identity matrix.</p>
</td></tr>
<tr><td><code id="JostD_+3A_pairwise">pairwise</code></td>
<td>
<p>Logical indicating whether to calculate pairwise Jost's D.
If pairwise=FALSE, must not have any missing data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If pairwise = TRUE, returns a matrix of pairwise Jost's D values.
If pairwise = FALSE, returns the overall Jost's D value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene_identity_matrix &lt;- matrix(c(
0.3164550, 0.2836333, 0.2760485,
0.2836333, 0.3106084, 0.2867215,
0.2760485, 0.2867215, 0.3338663
), nrow = 3, byrow = TRUE,
dimnames = list(paste0("Sample", 1:3), paste0("Sample", 1:3)))

JostD(J=gene_identity_matrix, pairwise=TRUE)
JostD(J=gene_identity_matrix, pairwise=FALSE)
</code></pre>

<hr>
<h2 id='JostD_KK'>Pairwise Jost D between replicates</h2><span id='topic+JostD_KK'></span>

<h3>Description</h3>

<p>This function calculates Jost's D between two columns, specifically designed
for comparing duplicate samples based on allele frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JostD_KK(Ni1, Ni2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JostD_KK_+3A_ni1">Ni1</code></td>
<td>
<p>Vector containing the allele frequencies of the first duplicate
sample.</p>
</td></tr>
<tr><td><code id="JostD_KK_+3A_ni2">Ni2</code></td>
<td>
<p>Vector containing the allele frequencies of the second duplicate
sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The calculated Jost's D value.
</p>

<hr>
<h2 id='lf_to_tdf'>Transform LF to TDF</h2><span id='topic+lf_to_tdf'></span>

<h3>Description</h3>

<p>This function transforms a data frame from LF (long format) to TDF (table
format),performing various data manipulation steps such as spreading data
across columns,removing NA and/or 0 columns, merging ID allele heights
within each replicate,transposing the table, converting from character to
numeric class, and replacing empty data with &quot;0&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lf_to_tdf(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lf_to_tdf_+3A_x">x</code></td>
<td>
<p>A data frame in LF format ideally coming out of the clean_scores
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transformed data frame in TDF format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scores&lt;- data.frame(ID=c("104.1a","105.2b","106.3c","107.4d","108.5e",
"109.6f"),
filename=c("104.1a_FA060920_2020-06-09_C05.fsa_Sa.1",
"105.2b_FA060920_2020-06-09_C05.fsa_Sa.1",
"106.3c_FA060920_2020-06-09_C05.fsa_Fa.1",
"107.4d_FA060920_2020-06-09_C05.fsa_Sa.1" ,
"108.5e_FA060920_2020-06-09_C05.fsa_Sa.1" ,
"109.6f_SA060920_2020-06-09_C05.fsa_Fa.1"),
hei=c(2000,3000,4000,5000,2500, 1000),
pos=c(2000,3000,4000,5000,2500, 1000),
wei=c(290,285,280,275,270,260),
row.names= c("104.1a_FA060920_2020-06-09_C05.fsa_Sa.1",
"105.2b_FA060920_2020-06-09_C05.fsa_Sa.1",
"106.3c_FA060920_2020-06-09_C05.fsa_Fa.1",
"107.4d_FA060920_2020-06-09_C05.fsa_Sa.1" ,
"108.5e_FA060920_2020-06-09_C05.fsa_Sa.1" ,
"109.6f_SA060920_2020-06-09_C05.fsa_Fa.1"))

lf_to_tdf(scores)
</code></pre>

<hr>
<h2 id='LoadData'>Load Genetic Data</h2><span id='topic+LoadData'></span>

<h3>Description</h3>

<p>This function imports data for genetic analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadData(datafile = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LoadData_+3A_datafile">datafile</code></td>
<td>
<p>The path to your datafile. The format of your data should be
.txt or .csv.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the imported data formatted in the way
necessary for downstream population genetic functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file&lt;-system.file("extdata", "Multiplex_frequencies.txt",
package = "pooledpeaks")
LoadData(file)
</code></pre>

<hr>
<h2 id='MDSplot'>Multi Dimensional Scaling (MDS) Plot</h2><span id='topic+MDSplot'></span>

<h3>Description</h3>

<p>Generate a multidimensional scaling (MDS) plot from genetic distance data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDSplot(
  distance = matrix,
  pcs = c(1, 2),
  PF = NULL,
  y = c("dodgerblue", "red", "turquoise3", "purple", "olivedrab3")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MDSplot_+3A_distance">distance</code></td>
<td>
<p>A matrix containing the genetic distance data.</p>
</td></tr>
<tr><td><code id="MDSplot_+3A_pcs">pcs</code></td>
<td>
<p>A numeric vector specifying the principal coordinates to plot.</p>
</td></tr>
<tr><td><code id="MDSplot_+3A_pf">PF</code></td>
<td>
<p>A factor vector specifying population labels.</p>
</td></tr>
<tr><td><code id="MDSplot_+3A_y">y</code></td>
<td>
<p>A character vector specifying colors for population labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is the MDS plot for the samples for the specified principal
coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_distance_matrix &lt;- matrix(c(
0, 0.2836333, 0.2760485, 0.2685221, 0.2797302,0.3202661,
0.2836333, 0, 0.2867215, 0.2687472, 0.2596309, 0.2957862,
0.2760485,0.2867215, 0, 0.297918, 0.3057039, 0.3153261,
0.2685221, 0.2687472, 0.297918,0, 0.2753477, 0.3042383,
0.2797302, 0.2596309, 0.3057039, 0.2753477, 0,0.3398558,
0.3202661, 0.2957862, 0.3153261, 0.3042383, 0.3398558, 0),
 nrow = 6, byrow = TRUE,dimnames = list(c("Sample1", "Sample2",
 "Sample3", "Ind1", "Ind2", "Ind3"),
 c("Sample1", "Sample2", "Sample3", "Ind1", "Ind2", "Ind3")))

 MDSplot(distance=genetic_distance_matrix, pcs=c(1,3))

</code></pre>

<hr>
<h2 id='PCDM'>Post-consolidation Data Manipulation</h2><span id='topic+PCDM'></span>

<h3>Description</h3>

<p>This function manipulates consolidated marker data and egg count data to
prepare them for further analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCDM(consolidated_marker = data.frame, eggcount = data.frame, marker_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCDM_+3A_consolidated_marker">consolidated_marker</code></td>
<td>
<p>A data frame containing consolidated marker data.</p>
</td></tr>
<tr><td><code id="PCDM_+3A_eggcount">eggcount</code></td>
<td>
<p>A data frame containing egg count data.</p>
</td></tr>
<tr><td><code id="PCDM_+3A_marker_name">marker_name</code></td>
<td>
<p>A string specifying the marker name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the allele frequencies and eggcounts for each
sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>marker_data &lt;- data.frame(
Sample1 = c(400, 600, 700),
Sample2 = c(450, 550, 480),
Sample3 = c(300, 200, 500),
row.names=c(185,188,191)
)

eggs&lt;-data.frame(
ID=c("Sample1","Sample2","Sample3"),n=c(3000,400,50))

PCDM(consolidated_marker=marker_data, eggcount= eggs,"SMMS2")

</code></pre>

<hr>
<h2 id='preGST'>Pre GST Calculation</h2><span id='topic+preGST'></span>

<h3>Description</h3>

<p>This function calculates the GST from a gene identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preGST(G = matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preGST_+3A_g">G</code></td>
<td>
<p>The gene identity matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The GST value.
</p>

<hr>
<h2 id='preJostD'>Calculate Pre-Jost's D</h2><span id='topic+preJostD'></span>

<h3>Description</h3>

<p>This function calculates the pre-Jost's D measure from a gene identity
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preJostD(G = matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preJostD_+3A_g">G</code></td>
<td>
<p>A square matrix representing a gene identity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Jost's D value.
</p>

<hr>
<h2 id='Rep_check'>Replicate Check for Duplicate Samples</h2><span id='topic+Rep_check'></span>

<h3>Description</h3>

<p>This function checks for duplicate samples in the input data frame and
calculates the average peak heights for each sample. If the Jost's D
between duplicate samples exceeds 0.05, it flags those samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rep_check(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rep_check_+3A_df">df</code></td>
<td>
<p>The input data frame containing peak heights for each sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the average peak heights for each sample,
with flagged samples where duplicates have a Jost's D exceeding 0.05.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>marker_data &lt;- data.frame(
Sample.1a = c(400, 600, 700),
Sample.1b = c(420, 606, 710),
Sample.2a = c(450, 550, 480),
Sample.2b = c(500, 540, 480),
Sample.3a = c(300, 200, 500),
Sample.3b = c(290, 100, 400),
row.names=c(185,188,191)
)

Rep_check(marker_data)

</code></pre>

<hr>
<h2 id='RWCDistanceMatrix'>Random Walk Covariance Distance Matrix</h2><span id='topic+RWCDistanceMatrix'></span>

<h3>Description</h3>

<p>This function calculates the RWC (Random Walk Covariance) distance matrix
from a given matrix of genetic distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RWCDistanceMatrix(J = matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RWCDistanceMatrix_+3A_j">J</code></td>
<td>
<p>The Genetic Distance Matrix calculated using
<a href="#topic+GeneticDistanceMatrix">GeneticDistanceMatrix</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the distance matrix calculated using the
Random Walk Covariance method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_distance_matrix &lt;- matrix(c(0.316455, 0.2836333, 0.2760485,
0.2685221, 0.2797302,0.3202661,0.2836333, 0.3106084, 0.2867215, 0.2687472,
 0.2596309, 0.2957862,0.2760485,0.2867215, 0.3338663, 0.297918, 0.3057039,
  0.3153261,0.2685221, 0.2687472, 0.297918,0.3107094, 0.2753477, 0.3042383,
  0.2797302, 0.2596309, 0.3057039, 0.2753477, 0.3761386,0.3398558,0.3202661,
   0.2957862, 0.3153261, 0.3042383, 0.3398558, 0.4402125),
 nrow = 6, byrow = TRUE, dimnames = list(c("Sample1", "Sample2", "Sample3",
 "Ind1", "Ind2", "Ind3"),
 c("Sample1", "Sample2", "Sample3", "Ind1", "Ind2", "Ind3")))
 RWCDistanceMatrix(genetic_distance_matrix)
</code></pre>

<hr>
<h2 id='SampleOfLoci'>Sample Of Loci</h2><span id='topic+SampleOfLoci'></span>

<h3>Description</h3>

<p>An internal function that supports ClusterFromSamples. Sample loci from a
dataset based on the number of loci specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SampleOfLoci(aaax = data.frame, NLoci = max(aaax[, 1]))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SampleOfLoci_+3A_aaax">aaax</code></td>
<td>
<p>A data frame containing the input data must be in LoadData
style <a href="#topic+LoadData">LoadData</a>.</p>
</td></tr>
<tr><td><code id="SampleOfLoci_+3A_nloci">NLoci</code></td>
<td>
<p>An integer specifying the number of loci to sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the sampled loci.
</p>

<hr>
<h2 id='score_markers_rev3'>Score Markers Wrapper</h2><span id='topic+score_markers_rev3'></span>

<h3>Description</h3>

<p>This is a revision of the Fragman script score.markers, for the original
instructions and parameters, run '?score.markers'. This revision designates
separate parameters for Left and Right search windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_markers_rev3(
  my.inds,
  channel = 1,
  n.inds = NULL,
  panel = NULL,
  shift = 0.8,
  ladder,
  channel.ladder = NULL,
  ploidy = 2,
  left.cond = c(0.6, 3),
  right.cond = 0.35,
  warn = FALSE,
  windowL = 0.5,
  windowR = 0.5,
  init.thresh = 200,
  ladd.init.thresh = 200,
  method = "iter2",
  env = parent.frame(),
  my.palette = NULL,
  plotting = FALSE,
  plotdir = "plots_scoring",
  pref = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_markers_rev3_+3A_my.inds">my.inds</code></td>
<td>
<p>The list output from the fsa_batch_imp or storing.inds
function that contains the channel information from the individuals that you
want to score.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_channel">channel</code></td>
<td>
<p>The number of the channel you wish to analyze. Typically 1 is
blue, 2 is green, 3 yellow, and 4 red.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_n.inds">n.inds</code></td>
<td>
<p>(optional) A vector specifying which fsa files to score.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_panel">panel</code></td>
<td>
<p>A vector containing the expected allele sizes for this marker.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_shift">shift</code></td>
<td>
<p>All peaks at that distance from the tallest peak will be
ignored and be considered noise.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_ladder">ladder</code></td>
<td>
<p>A vector containing the expected peaks for your ladder.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_channel.ladder">channel.ladder</code></td>
<td>
<p>The channel number where your ladder can be found.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_ploidy">ploidy</code></td>
<td>
<p>The name is a relic of the fact that <a href="Fragman.html#topic+score.markers">Fragman::score.markers</a>
was originally written for plants. In the context of pooled egg samples it
is used to specify the number of possible alleles in the marker.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_left.cond">left.cond</code></td>
<td>
<p>The first part is a percentile (0-1) that corresponds to
the height that a peak to the left of the tallest peak must be in order to
be considered real. The second argument is a number of base pairs that a
peak to the left of the tallest peak must be away to be considered as real.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_right.cond">right.cond</code></td>
<td>
<p>A percentile (0-1) that corresponds to the height that a
peak to the right of the tallest peak must be in order to be real.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_warn">warn</code></td>
<td>
<p>TRUE/FAlSE Do you want to receive warnings when detecting the
ladder?</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_windowl">windowL</code></td>
<td>
<p>the window means that all peaks closer by that distance to
the left of the panel peaks will be accounted as peaks.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_windowr">windowR</code></td>
<td>
<p>the window means that all peaks closer by that distance to
the right of the panel peaks will be accounted as peaks.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_init.thresh">init.thresh</code></td>
<td>
<p>A value that sets a minimum intensity in order for a
peak to be called.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_ladd.init.thresh">ladd.init.thresh</code></td>
<td>
<p>We don't recommend messing with this parameter
unless your ladder has special circumstances. See <a href="Fragman.html#topic+score.markers">Fragman::score.markers</a></p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_method">method</code></td>
<td>
<p>In cases where samples weren't sized using the
info.ladder.attach function, this technique steps in to identify ladder
peaks. You have three method options using an argument: &quot;cor&quot; explores all
potential peak combinations and thoroughly searches for correlations to
identify the correct peaks corresponding to expected DNA weights; &quot;ci&quot;
constructs confidence intervals to identify peaks meeting specified
conditions from earlier arguments; &quot;iter2&quot; applies an iterative strategy to
identify the most likely peaks aligning with your ladder expectations. The
default method is &quot;iter2.&quot;</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_env">env</code></td>
<td>
<p>Please do not change this parameter, it is used to detect the
users environment.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_my.palette">my.palette</code></td>
<td>
<p>(optional) A character vector specifying which colors
to use for the output RFU plots.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_plotting">plotting</code></td>
<td>
<p>TRUE/FALSE Do you want to create pdf output plots?</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_plotdir">plotdir</code></td>
<td>
<p>The name of the directory where output pdf plots should
be stored.</p>
</td></tr>
<tr><td><code id="score_markers_rev3_+3A_pref">pref</code></td>
<td>
<p>The number of plots to be drawn in the output plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The score_markers_rev3 function will return a list containing three
variables: $pos, $hei, and $wei. These correspond to the index position for
the intensities, the intensity of each peak, and the weight in base pairs
based on the ladder respectively. If plotting = TRUE, a pdf file will
also have been created in the specified directory. This pdf file allows
you to visually inspect how all of the peaks were scored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file_path &lt;- system.file("extdata", package = "pooledpeaks")
mock_fsa_batch_imp_output&lt;- fsa_batch_imp(file_path, channels = 5,
fourier = FALSE, saturated = FALSE, lets.pullup = FALSE,
plotting = FALSE, rawPlot = FALSE)
panel &lt;- c(176,179,182,185,188,191,194,197,200,203,206)
ladder &lt;- c( 140, 160, 180, 200, 214, 220,240, 250, 260, 280, 300, 314)
mock_fsa_batch_imp_output &lt;- associate_dyes(mock_fsa_batch_imp_output,
                             file_path)
score_markers_rev3(my.inds = mock_fsa_batch_imp_output,
                            channel = 1,
                            channel.ladder = 5,
                            panel = "panel",
                            ladder = ladder,
                            init.thresh = 200,
                            ploidy = length(panel),
                            plotting = FALSE)
                            
</code></pre>

<hr>
<h2 id='TwoLevelGST'>Calculate Two-Level GST</h2><span id='topic+TwoLevelGST'></span>

<h3>Description</h3>

<p>This function calculates two-level GST (Nei's standard gene identity)
measure from a gene identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoLevelGST(G = matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TwoLevelGST_+3A_g">G</code></td>
<td>
<p>A square matrix representing a gene identity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the components of two-level GST including
within-group gene identity, between-group gene identity, and GST values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene_identity_matrix &lt;- matrix(c(
0.3164550, 0.2836333, 0.2760485,
0.2836333, 0.3106084, 0.2867215,
0.2760485, 0.2867215, 0.3338663
), nrow = 3, byrow = TRUE,
dimnames = list(paste0("Sample", 1:3), paste0("Sample", 1:3)))

TwoLevelGST(G=gene_identity_matrix)

</code></pre>

<hr>
<h2 id='TypedLoci'>Typed Loci</h2><span id='topic+TypedLoci'></span>

<h3>Description</h3>

<p>This function calculates the number of loci successfully genotyped by each
individual included in our data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TypedLoci(datafile = data.frame)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TypedLoci_+3A_datafile">datafile</code></td>
<td>
<p>A data frame containing the input data must be in LoadData
style <a href="#topic+LoadData">LoadData</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing processed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genetic_data &lt;- data.frame(
Locus = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2),
Locus_allele = c("Marker1", "n", 1, 2, 3, "Marker2", "n", 1, 2, 3),
Sample1 = c(NA, 10, 0.5, 0.5, 0, NA, 10, 0.2, 0.3, 0.5),
Sample2 = c(NA, 20, 0.1, 0.2, 0.7, NA, 20, 0.3, 0.4, 0.3),
Sample3 = c(NA, 30, 0.3, 0.4, 0.3, NA, 30, 0.4, 0.2, 0.4)
)
TypedLoci(datafile=genetic_data)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
