<!DOCTYPE html><html lang="en"><head><title>Help for package fdWasserstein</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fdWasserstein}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fdWasserstein-package'>
<p>Application of Optimal Transport to Functional Data Analysis</p></a></li>
<li><a href='#dwasserstein'>
<p>2-Wasserstein distance</p></a></li>
<li><a href='#gaussBary'>
<p>Wasserstein barycenter between Gaussian Processes</p></a></li>
<li><a href='#Phoneme'><p>Phoneme data</p></a></li>
<li><a href='#tangentPCA'>
<p>Tangent space principal component analysis</p></a></li>
<li><a href='#wassersteinCluster'>
<p>Soft clustering of covariance operators.</p></a></li>
<li><a href='#wassersteinTest'>
<p>A permutation or bootstrap test based on optimal transport maps.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Application of Optimal Transport to Functional Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Valentina Masarotto [aut, cph, cre],
  Guido Masarotto [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valentina Masarotto &lt;v.masarotto@math.leidenuniv.nl&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>future</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>These functions were developed to support statistical analysis on functional covariance operators.
  The package contains functions to:
  - compute 2-Wasserstein distances between Gaussian Processes as in
    Masarotto, Panaretos &amp; Zemel (2019) &lt;<a href="https://doi.org/10.1007%2Fs13171-018-0130-1">doi:10.1007/s13171-018-0130-1</a>&gt;;
  - compute the Wasserstein barycenter (Frechet mean) as in Masarotto,
    Panaretos &amp; Zemel (2019) &lt;<a href="https://doi.org/10.1007%2Fs13171-018-0130-1">doi:10.1007/s13171-018-0130-1</a>&gt;;
  - perform analysis of variance testing procedures for functional
    covariances and tangent space principal component analysis of
    covariance operators as in Masarotto, Panaretos &amp; Zemel (2022)
    &lt;<a href="https://doi.org/10.48550/arXiv.2212.04797">doi:10.48550/arXiv.2212.04797</a>&gt;.
  - perform a soft-clustering based on the Wasserstein distance where
    functional data are classified based on their covariance structure
    as in Masarotto &amp; Masarotto (2023) &lt;<a href="https://doi.org/10.1111%2Fsjos.12692">doi:10.1111/sjos.12692</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 11:40:17 UTC; valentinamasarotto</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fdWasserstein-package'>
Application of Optimal Transport to Functional Data Analysis
</h2><span id='topic+fdWasserstein-package'></span><span id='topic+fdWasserstein'></span>

<h3>Description</h3>

<p>A package containing functions developed to support statistical analysis on functional covariance operators. 
In particular, 
</p>

<ul>
<li><p> Function <code><a href="#topic+dwasserstein">dwasserstein</a></code> computes the
Wasserstein-Procrustes distance between two covariances.
</p>
</li>
<li><p> Function <code><a href="#topic+gaussBary">gaussBary</a></code> computes the Frechet mean of
K covariances with respect to the Procrustes metrics
(equivalently, the Wasserstein barycenter of centered Gaussian
processes with corresponding covariances) via steepest gradient
descent. See Masarotto, Panaretos &amp; Zemel (2019).
</p>
</li>
<li><p> Function <code><a href="#topic+tangentPCA">tangentPCA</a></code> performs the tangent space
principal component analysis considered in Masarotto, Panaretos &amp;
Zemel (2022). 
</p>
</li>
<li><p> Function <code><a href="#topic+wassersteinTest">wassersteinTest</a></code> lets to test the null
hypothesis that K covariances are equal using the methodology suggested by
Masarotto, Panaretos &amp; Zemel (2022).
</p>
</li>
<li><p> Function <code><a href="#topic+wassersteinCluster">wassersteinCluster</a></code> implements the soft
partion procedure proposed by Masarotto &amp; Masarotto (2023).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Valentina Masarotto [aut, cph, cre], Guido Masarotto [aut, cph]
</p>
<p>Maintainer: Valentina Masarotto &lt;v.masarotto@math.leidenuniv.nl&gt;
</p>


<h3>References</h3>

<p>Masarotto, V., Panaretos, V.M. &amp; Zemel, Y. (2019) &quot;Procrustes Metrics on
Covariance Operators and Optimal Transportation of Gaussian Processes&quot;,
<em>Sankhya A</em> <strong>81</strong>, 172-213 <a href="https://doi.org/10.1007/s13171-018-0130-1">doi:10.1007/s13171-018-0130-1</a>
</p>
<p>Masarotto, V., Panaretos, V.M. &amp; Zemel, Y. (2022) &quot;Transportation-Based Functional ANOVA and PCA for Covariance Operators&quot;, <em>arXiv</em>,  <a href="https://arxiv.org/abs/2212.04797">https://arxiv.org/abs/2212.04797</a>
</p>
<p>Masarotto, V. &amp; Masarotto, G. (2023) &quot;Covariance-based soft clustering
of functional data based on the Wasserstein-Procrustes metric&quot;, 
<em>Scandinavian Journal of Statistics</em>, <a href="https://doi.org/10.1111/sjos.12692">doi:10.1111/sjos.12692</a>.
</p>

<hr>
<h2 id='dwasserstein'>
2-Wasserstein distance
</h2><span id='topic+dwasserstein'></span>

<h3>Description</h3>

<p>Computes the 2-Wasserstein distance between the (covariance) matrices A and B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dwasserstein(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dwasserstein_+3A_a">A</code>, <code id="dwasserstein_+3A_b">B</code></td>
<td>

<p>Two symmetric positive semi-definite matrices.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric object with the 2-Wasserstein distance of A and B. 
</p>


<h3>Author(s)</h3>

<p>Valentina Masarotto, Guido Masarotto</p>


<h3>References</h3>

<p>Masarotto, V., Panaretos, V.M. &amp; Zemel, Y. (2019) &quot;Procrustes Metrics on
Covariance Operators and Optimal Transportation of Gaussian Processes&quot;,
<em>Sankhya A</em> <strong>81</strong>, 172-213 <a href="https://doi.org/10.1007/s13171-018-0130-1">doi:10.1007/s13171-018-0130-1</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussBary">gaussBary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
matrices &lt;- rWishart(2,n,diag(n))
A &lt;- matrices[,,2]
B &lt;- matrices[,,1]
dwasserstein(A,B)
dwasserstein(A, 10*crossprod(B))
</code></pre>

<hr>
<h2 id='gaussBary'>
Wasserstein barycenter between Gaussian Processes
</h2><span id='topic+gaussBary'></span>

<h3>Description</h3>

<p>Computes the Frechet mean between covariance operators with respect to the Procrustes metrics (equivalently, a Wasserstein barycenter of centered Gaussian processes with corresponding covariances) via steepest gradient descent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussBary(sigma, w = rep(1, dim(sigma)[3]), gamma, sigma0.5, 
  max.iter = 30, eps = 1e-08, silent = max.iter == 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussBary_+3A_sigma">sigma</code></td>
<td>

<p>An MxMxK array containing the K covariances. 
</p>
</td></tr>
<tr><td><code id="gaussBary_+3A_w">w</code></td>
<td>

<p>Optional. A vector of weights of length K. If missing, each matrix is given equal weight 1. 
</p>
</td></tr>
<tr><td><code id="gaussBary_+3A_gamma">gamma</code></td>
<td>

<p>Optional. Initialisation point for the gradient descent algorithm. 
</p>
</td></tr>
<tr><td><code id="gaussBary_+3A_sigma0.5">sigma0.5</code></td>
<td>

<p>Optional. An array containing the square roots of the matrices in
sigma if available. The square roots are computed by
<code>gaussBary</code> if <code>sigma0.5</code> is missing.
</p>
</td></tr>
<tr><td><code id="gaussBary_+3A_max.iter">max.iter</code></td>
<td>

<p>Maximum number of gradient descent iterations.
</p>
</td></tr>
<tr><td><code id="gaussBary_+3A_eps">eps</code></td>
<td>

<p>Iterations stop when the relative decrease of the objective function in two consecutive iterations is less than 'eps'. 
</p>
</td></tr>
<tr><td><code id="gaussBary_+3A_silent">silent</code></td>
<td>

<p>If <code>FALSE</code> returns a warning if maximal number of iteration is reached. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 containing:
</p>
<table role = "presentation">
<tr><td><code>gamma</code></td>
<td>
<p>The MxM Frechet mean.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations needed to reach convergence, numeric.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>We thank Yoav Zemel for the first version of the code. 
</p>


<h3>Author(s)</h3>

<p>Valentina Masarotto, Guido Masarotto
</p>


<h3>References</h3>

<p>Masarotto, V., Panaretos, V.M. &amp; Zemel, Y. (2019) &quot;Procrustes Metrics on
Covariance Operators and Optimal Transportation of Gaussian Processes&quot;,
<em>Sankhya A</em> <strong>81</strong>, 172-213 <a href="https://doi.org/10.1007/s13171-018-0130-1">doi:10.1007/s13171-018-0130-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- 5
K &lt;- 4

sigma &lt;- rWishart(M, df = K, Sigma = diag(K))

gaussBary(sigma) 
</code></pre>

<hr>
<h2 id='Phoneme'>Phoneme data</h2><span id='topic+Phoneme'></span><span id='topic+logPeriodogram'></span>

<h3>Description</h3>

<p>The dataset comprises 4509 log-periodograms computed from digitalized
speech frames. Each log-periodograms is of length 256, and is based on the
pronunciation of one of the following five phonemes:
&quot;sh&quot;, &quot;dcl&quot;, &quot;iy&quot;, &quot;aa&quot; and &quot;ao&quot;.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(phoneme)
</code></pre>


<h3>Format</h3>


<ul>
<li> <p><code>logPeriodogram</code>: a 4509x256 matrix containing the log-periodograms.
</p>
</li>
<li> <p><code>Phoneme</code>: a vector of length 4509 containing the phonemes.
</p>
</li></ul>



<h3>Source</h3>

<p>The data set was downloaded from the &quot;<em>Elements of statistical
learning</em>&quot; website at <a href="https://hastie.su.domains/ElemStatLearn/">https://hastie.su.domains/ElemStatLearn/</a>
</p>


<h3>References</h3>

<p>T. Hastie and R. Tibshirani and J. Friedman (2009) <em>The elements of statistical learning: Data mining, inference and prediction</em>, 2nd edn, New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(phoneme)
old &lt;- par(mfrow=c(3,2))
for (i in unique(Phoneme)) 
    matplot(t(logPeriodogram[Phoneme==i,]), type="l", 
            xlab="", ylab="", ylim=c(0,30), main=i)
par(old)
</code></pre>

<hr>
<h2 id='tangentPCA'>
Tangent space principal component analysis 
</h2><span id='topic+tangentPCA'></span>

<h3>Description</h3>

<p>The function performs a standard PCA of K covariances after projecting them
on the tangent space at their Wasserstein barycenter. Rationale and
details are given in Masarotto, Panaretos &amp; Zemel (2019, 2022)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tangentPCA(sigma, max.iter=30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tangentPCA_+3A_sigma">sigma</code></td>
<td>

<p>An MxMxK array containing the K covariances. 
</p>
</td></tr>
<tr><td><code id="tangentPCA_+3A_max.iter">max.iter</code></td>
<td>

<p>Maximum number of gradient descent iterations used to compute the
Wasserstein barycenter of the covariances in sigma.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A standard <code><a href="stats.html#topic+prcomp">prcomp</a></code> object with added a MxMxK array
containing the eigenvectors projected back to the covariances space.
</p>


<h3>Author(s)</h3>

<p>Valentina Masarotto
</p>


<h3>References</h3>

<p>Masarotto, V., Panaretos, V.M. &amp; Zemel, Y. (2022) &quot;Transportation-Based Functional ANOVA and PCA for Covariance Operators&quot;, <em>arXiv</em>,  <a href="https://arxiv.org/abs/2212.04797">https://arxiv.org/abs/2212.04797</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussBary">gaussBary</a></code>, <code><a href="stats.html#topic+prcomp">prcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example taken from https://arxiv.org/abs/2212.04797  . 
data(phoneme)
# resampling the log-periodograms
# 12 sample covariances for each phoneme
# each estimated on 50 curves 
set.seed(12345)
nsubsamples &lt;- 12
n &lt;- 50
gg &lt;- unique(Phoneme)
nphonemes &lt;- length(gg)
K &lt;- n*nsubsamples*nphonemes
M &lt;- NCOL(logPeriodogram)
Sigma &lt;- array(dim=c(M, M, nphonemes*nsubsamples))
r &lt;- 0
for (l in gg) {
  for (i in 1:nsubsamples) {
      r &lt;- r+1
      Sigma[,,r] &lt;- cov(logPeriodogram[sample(which(Phoneme==l),n), ])
  }
}
pca &lt;- tangentPCA(Sigma, max.iter=3)
summary(pca)
plot(pca)
# See https://arxiv.org/abs/2212.04797 for the interpretation
# of the figure
pairs(pca$x[,1:5], col=rep(1:nphonemes, rep(nsubsamples, nphonemes)))

</code></pre>

<hr>
<h2 id='wassersteinCluster'>
Soft clustering of covariance operators.
</h2><span id='topic+wassersteinCluster'></span><span id='topic+trimmedAverageSilhouette'></span>

<h3>Description</h3>

<p>Computes the soft cluster solutions for different values of the number of clusters K. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wassersteinCluster(data, grp, 
                   kmin = 2, kmax = 10, 
                   E = -0.75 * (0.95 * log(0.95) + 
                        0.05 * log(0.05)) + 0.25 * log(2), 
                   nstart = 5, nrefine = 5, ntry = 0, 
                   max.iter = 20, tol = 0.001, 
                   nreduced = length(unique(grp)), 
                   nperm = 0, 
                   add.sigma = FALSE, 
                   use.future = FALSE, verbose = TRUE)

trimmedAverageSilhouette(a, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wassersteinCluster_+3A_data">data</code></td>
<td>

<p>A N times M matrix containing the N sample curves; M denotes the number of points of the grid on which the curves are available.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_grp">grp</code></td>
<td>

<p>A vector or factor of length N; a covariance operator is estimated for
each level of grp.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_kmin">kmin</code>, <code id="wassersteinCluster_+3A_kmax">kmax</code></td>
<td>

<p>A pair of integer defining the desired number of clusters. A solution is computed for K=kmin,...,kmax.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_e">E</code></td>
<td>

<p>The desired average entropy.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_nstart">nstart</code>, <code id="wassersteinCluster_+3A_nrefine">nrefine</code>, <code id="wassersteinCluster_+3A_ntry">ntry</code></td>
<td>

<p>The integers used during the initialization search. If ntry=0, then 'ntry' is set to 'round(1+N/K)'.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_max.iter">max.iter</code></td>
<td>

<p>Maximum number of block descend iterations.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_tol">tol</code></td>
<td>

<p>Iterations stop when the relative decrease of the objective function in two consecutive iterations is less than 'tol'.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_nreduced">nreduced</code></td>
<td>

<p>The number of covariances used to estimate the cluster barycenters.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_nperm">nperm</code></td>
<td>

<p>The number of permutation used to approximate the reference distribution of max TASW.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_add.sigma">add.sigma</code></td>
<td>

<p>Should the sample covariances be returned?
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_use.future">use.future</code></td>
<td>

<p>Use or not use package 'future' to parallelize the computation? See note.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_verbose">verbose</code></td>
<td>

<p>If 'verbose==TRUE', information on the progress of the optimization are shown.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_a">a</code></td>
<td>

<p>A list returned by 'wassersteinCluster'.
</p>
</td></tr>
<tr><td><code id="wassersteinCluster_+3A_plot">plot</code></td>
<td>

<p>If 'plot==TRUE', the TASW profile is plotted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Masarotto &amp; Masarotto (2023) for the algorithm details.
</p>


<h3>Value</h3>

<p>'wassersteinCluster' returns a list of length kmax-kmin+1. 
The ith element is a list describing the cluster solution obtained for k=kmin+i-1, and containing: 
</p>
<table role = "presentation">
<tr><td><code>K</code>, <code>E</code>, <code>eta</code></td>
<td>
<p>the number of cluster, the average entropy and the corresponding value of 'eta';</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the N times K soft partition matrix;</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>a M times M times K array with the cluster barycenters;</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>a N times K matrices containing the distances between the N sample covariances and the K cluster barycenters;</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>'obj': the minimum value of the objective function.</p>
</td></tr>
</table>
<p>The list may have the following attributes:
</p>
<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>the degree of freedom of the sample operators (a vector). Always present.</p>
</td></tr>
<tr><td><code>sample.covariances</code></td>
<td>
<p>a list contaning the sample operators (as a
3-dimensional array); only present if add.sigma=TRUE;</p>
</td></tr>
<tr><td><code>tasw.test</code></td>
<td>
<p>a list containing the value of maxTASW computed from the data (a scalar), the nperm values of of maxTASW obtained by permutation (a vector), and the corresponding p-value (a scalar); only present if nperm&gt;0.</p>
</td></tr>
</table>
<p>'trimmedAverageSilhouette' returns a numeric vector with the TASW values.
</p>


<h3>Note</h3>

<p>To distribute the computation on more than a cpu 
</p>

<ol>
<li><p> install the package 'future'
</p>
</li>
<li><p>  execute in the R session
</p>

<ul>
<li><p> library(future)
</p>
</li>
<li><p> plan(multissession)
</p>
</li></ul>

</li></ol>

<p>For more options, see the future's documentation
</p>


<h3>Author(s)</h3>

<p>Valentina Masarotto, Guido Masarotto
</p>


<h3>References</h3>

<p>Masarotto, V. &amp; Masarotto, G. (2023) &quot;Covariance-based soft clustering
of functional data based on the Wasserstein-Procrustes metric&quot;, 
<em>Scandinavian Journal of Statistics</em>, <a href="https://doi.org/10.1111/sjos.12692">doi:10.1111/sjos.12692</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example phoneme.R (simplified) from https://doi.org/10.1111/sjos.12692. 
data(phoneme)
# resampling the log-periodograms
# 15 sample covariances for each phoneme
set.seed(12345)
nsubsamples &lt;- 15
n &lt;- 40
gg &lt;- unique(Phoneme)
nphonemes &lt;- length(gg)
N &lt;- n*nsubsamples*nphonemes
M &lt;- NCOL(logPeriodogram)
X &lt;- matrix(NA, N, M)
gr &lt;- integer(N)
r &lt;- 1
first &lt;- 1
last &lt;- n
for (l in gg) {
  for (i in 1:nsubsamples) {
    X[first:last, ] &lt;- logPeriodogram[sample(which(Phoneme==l),n), ]
    gr[first:last] &lt;- r
    r &lt;- r+1
    first &lt;- first+n
    last &lt;- last+n
  }
}
# soft clustering
a &lt;- wassersteinCluster(X, gr)
# how many cluster?
trimmedAverageSilhouette(a)
# the membership weigths show that the
# algorithm reconstructed the five phoneme
w &lt;- ts(a[[4]]$w)
colnames(w) &lt;- paste("Cluster", 1:5)
plot(w, xlab="Sample covariances", main="")

</code></pre>

<hr>
<h2 id='wassersteinTest'>
A permutation or bootstrap test based on optimal transport maps. 
</h2><span id='topic+wassersteinTest'></span>

<h3>Description</h3>

<p>The main function performs a k-sample permutation- or bootstrap-based test to check the equality of covariance operators. More specifically, given a sample of N functional curves belonging to K different populations, each characterized by its own covariance operators, the test aims to check the null hypothesis <code class="reqn">\Sigma_1 = \dots = \Sigma_K</code> versus the alternative that at least one operator is different. The test leverages on the equivalence between covariance operators and centered Gaussian processes. In the default version, in order to test the null, the test builds optimal transport maps from the sample to the Wasserstein barycenter of the processes. Successively, it contrasts these maps to the identity operator, as explained in Masarotto, Panaretos &amp; Zemel (2022). However, argument &quot;statistics&quot; allows to base the test directly on the Wasserstein distance between covariance operators, rather than on optimal maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wassersteinTest(data, grp, B = 1000, 
                statistic = c("transport", "distance"), 
                type = c("permutation", "bootstrap"), 
                r = c("HS", "trace", "operator"),
                align = TRUE, 
                use.future = FALSE,
                iter.bary = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wassersteinTest_+3A_data">data</code></td>
<td>

<p>A N times M matrix containing the N sample curves; M denotes the number of points of the grid on which the curves are available.
</p>
</td></tr>
<tr><td><code id="wassersteinTest_+3A_grp">grp</code></td>
<td>

<p>Labels that identify which population each curve belongs to.
</p>
</td></tr>
<tr><td><code id="wassersteinTest_+3A_b">B</code></td>
<td>

<p>Number of permutations or bootstrap replications. If missing, B=1000. 
</p>
</td></tr>
<tr><td><code id="wassersteinTest_+3A_statistic">statistic</code></td>
<td>

<p>Whether the test is based on the transport maps or directly on the Wasserstein distance. Default is transport.  
</p>
</td></tr>
<tr><td><code id="wassersteinTest_+3A_type">type</code></td>
<td>

<p>Whether the test is permutation or bootstrap based. 
</p>
</td></tr>
<tr><td><code id="wassersteinTest_+3A_r">r</code></td>
<td>

<p>Which norm is used to contrast the test statistics to 0 (used only if statistics=&quot;transport&quot;). If r=&quot;HS&quot; the Hilbert-Schmidt norm is used, if r=&quot;trace&quot; the trace (nuclear) norm is used, if r=&quot;operator&quot;, the operator norm is used. Default is r=&quot;HS&quot;.
</p>
</td></tr>
<tr><td><code id="wassersteinTest_+3A_align">align</code></td>
<td>

<p>If 'align=TRUE', the curves are centered around their mean. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="wassersteinTest_+3A_use.future">use.future</code></td>
<td>

<p>Use or not use package 'future' to parallelize the computation? See note.
</p>
</td></tr>
<tr><td><code id="wassersteinTest_+3A_iter.bary">iter.bary</code></td>
<td>

<p>After how many iterations the gradient descent algorithm to compute the barycenter stops. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three returning:
</p>
<table role = "presentation">
<tr><td><code>stat</code></td>
<td>
<p>Observed value of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value indicating the significance level of the test</p>
</td></tr>
<tr><td><code>trep</code></td>
<td>
<p>Value of the test statistics for each of the B permutation</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To distribute the computation on more than a cpu 
</p>

<ol>
<li><p> install the package 'future'
</p>
</li>
<li><p>  execute in the R session
</p>

<ul>
<li><p> library(future)
</p>
</li>
<li><p> plan(multissession)
</p>
</li></ul>

</li></ol>

<p>For more options, see the future's documentation.
</p>


<h3>Author(s)</h3>

<p>Valentina Masarotto, Guido Masarotto
</p>


<h3>References</h3>

<p>Masarotto, V., Panaretos, V.M. &amp; Zemel, Y. (2022) &quot;Transportation-Based Functional ANOVA and PCA for Covariance Operators&quot;, <em>arXiv</em>,  <a href="https://arxiv.org/abs/2212.04797">https://arxiv.org/abs/2212.04797</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 20 
size &lt;- 10
covariances &lt;- rWishart(2,size,diag(size))
A &lt;- covariances[,,1]
B &lt;- covariances[,,2]

# Two groups, each with one covariance. Creates n Gaussian data for each covariance.
# more generally, we could have two groups each with "g_i" covariances in them
g1 &lt;- g2 &lt;- 1
grp &lt;- rep(1:(g1+g2),rep(n,g1+g2))

data &lt;- rbind(matrix(rnorm(n*NCOL(A)),n*g1)%*%A,
             matrix(rnorm(n*NCOL(B)),n*g2)%*%B)
wassersteinTest(data,grp, B=100,r="HS")$p.value

data(phoneme)
wassersteinTest(logPeriodogram, Phoneme, B=100,r="HS")$p.value

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
