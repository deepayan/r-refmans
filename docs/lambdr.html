<!DOCTYPE html><html><head><title>Help for package lambdr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lambdr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_json'><p>Convert an object to JSON</p></a></li>
<li><a href='#as_stringified_json'><p>Convert an R object to stringified JSON matching AWS Lambda conventions</p></a></li>
<li><a href='#assert_status_code_is_good'><p>Check that the status code shows a success, and error otherwise</p></a></li>
<li><a href='#classify_event'><p>Classify an event based on how it is invoked</p></a></li>
<li><a href='#condition'><p>Define a condition (like an error) with support for HTTP status codes</p></a></li>
<li><a href='#config_or_runtime_api'><p>Convert a config to a runtime API if necessary</p></a></li>
<li><a href='#decode_html_body'><p>Decode the body of event content coming via an API Gateway</p></a></li>
<li><a href='#endpoints'><p>AWS Lambda endpoints</p></a></li>
<li><a href='#extract_and_augment_context'><p>Combine class-specific context with general context for an event</p></a></li>
<li><a href='#extract_context'><p>Extract the context of a Lambda invocation from the headers of an event</p></a></li>
<li><a href='#extract_context_from_environment'><p>Extract context from environment variables</p></a></li>
<li><a href='#extract_event_headers'><p>Extract the headers from a Lambda event</p></a></li>
<li><a href='#from_base64'><p>Decode a Base64 encoded value to a string</p></a></li>
<li><a href='#function_accepts_context'><p>Determine if a function accepts a <code>context</code> argument</p></a></li>
<li><a href='#generate_result'><p>Parse the content of an event and pass it through the handler function</p></a></li>
<li><a href='#get_handler_function_from_env_var'><p>Determine the function referred to by the &quot;_HANDLER&quot; environment variable</p></a></li>
<li><a href='#get_lambda_environment_variable'><p>Retrieve a Lambda environment variable if available, and error otherwise</p></a></li>
<li><a href='#handle_event'><p>Process the input of an event, and submit the result to Lambda</p></a></li>
<li><a href='#handle_event_error'><p>Generate a handling function for an invocation error</p></a></li>
<li><a href='#html_response'><p>Prepare a HTML response for a Lambda behind an API Gateway</p></a></li>
<li><a href='#is_eventbridge_event_content'><p>Determine if a Lambda event is coming from a EventBridge event (CloudWatch events)</p></a></li>
<li><a href='#is_from_html_api_gateway'><p>Determine if a Lambda event is coming via an API Gateway</p></a></li>
<li><a href='#is_from_rest_api_gateway'><p>Determine if a Lambda event is coming via a REST API Gateway</p></a></li>
<li><a href='#is_sns_event_content'><p>Determine if a Lambda event is coming from SNS</p></a></li>
<li><a href='#lambda_config'><p>Set up endpoints, variables, and configuration for AWS Lambda</p></a></li>
<li><a href='#lambdr-package'><p>lambdr: Create a Runtime for Serving Containerised R Functions on AWS Lambda</p></a></li>
<li><a href='#mark_as_already_serialised'><p>Give a value the &quot;already_serialised = TRUE&quot; attribute</p></a></li>
<li><a href='#parse_event_content'><p>Parse the body of the Lambda event</p></a></li>
<li><a href='#parse_json_or_empty'><p>Parse a JSON, but force a NULL or empty string to be interpreted as an empty list</p></a></li>
<li><a href='#post_lambda_error'><p>Post an error to an endpoint with the format expected by AWS Lambda</p></a></li>
<li><a href='#post_result'><p>Post an event with a result to the response endpoint</p></a></li>
<li><a href='#prettify_list'><p>Convert a list to a single character, preserving names</p></a></li>
<li><a href='#serialise_result'><p>Serialise a result</p></a></li>
<li><a href='#start_lambda'><p>Start the Lambda runtime</p></a></li>
<li><a href='#start_listening'><p>Start listening for events, and process them as they come</p></a></li>
<li><a href='#stop_decomposition'><p>Raise an error with a request ID if known</p></a></li>
<li><a href='#stop_html'><p>Raise an error with an optional HTML status code for API Gateways</p></a></li>
<li><a href='#validate_lambda_config'><p>Validate a Lambda config object</p></a></li>
<li><a href='#wait_for_and_handle_event'><p>Wait for and handle event</p></a></li>
<li><a href='#wait_for_event'><p>Query the next invocation endpoint to get the next input</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create a Runtime for Serving Containerised R Functions on 'AWS
Lambda'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Runtime for serving containers that can execute R code on the 
    'AWS Lambda' serverless compute service <a href="https://aws.amazon.com/lambda/">https://aws.amazon.com/lambda/</a>.
    Provides the necessary functionality for handling the various endpoints
    required for accepting new input and sending responses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>httr, jsonlite, logger</td>
</tr>
<tr>
<td>Suggests:</td>
<td>withr, testthat (&ge; 3.0.0), webmockr, knitr, rmarkdown,
lifecycle</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lambdr.mdneuzerling.com/">https://lambdr.mdneuzerling.com/</a>,
<a href="https://github.com/mdneuzerling/lambdr">https://github.com/mdneuzerling/lambdr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mdneuzerling/lambdr/issues">https://github.com/mdneuzerling/lambdr/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-25 10:29:51 UTC; mdneuzerling</td>
</tr>
<tr>
<td>Author:</td>
<td>David Neuzerling [aut, cre],
  James Goldie [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Neuzerling &lt;david@neuzerling.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-25 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_json'>Convert an object to JSON</h2><span id='topic+as_json'></span>

<h3>Description</h3>

<p>This function effectively wraps <code><a href="jsonlite.html#topic+toJSON">toJSON</a></code> with two
hardcoded arguments:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_json(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_json_+3A_x">x</code></td>
<td>
<p>R object to be converted to JSON.</p>
</td></tr>
<tr><td><code id="as_json_+3A_...">...</code></td>
<td>
<p>additional arguments (except <code>auto_unbox</code> and <code>null</code>) passed to
<code><a href="jsonlite.html#topic+toJSON">toJSON</a></code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>auto_unbox</code> is set to <code>TRUE</code>, such that singleton values are not
represented as lists.
</p>
</li>
<li> <p><code>NULL</code> values are represented as JSON <code>null</code>s.
</p>
</li></ul>



<h3>Value</h3>

<p>character of class &quot;json&quot;
</p>

<hr>
<h2 id='as_stringified_json'>Convert an R object to stringified JSON matching AWS Lambda conventions</h2><span id='topic+as_stringified_json'></span>

<h3>Description</h3>

<p>Stringified JSON is a string which can be parsed as a JSON. While a standard
JSON interpretation of <code>list(number = 9)</code> would be <code>{"number":9}</code>,
a stringified JSON representation would be <code style="white-space: pre;">&#8288;"{\"number\":9}"&#8288;</code>.
</p>
<p>This function will convert <code>NULL</code> values to JSON &quot;nulls&quot;, to match the
convention used by Lambda event inputs, and values are automatically
unboxed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_stringified_json(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_stringified_json_+3A_x">x</code></td>
<td>
<p>R object to be converted to stringified JSON.</p>
</td></tr>
<tr><td><code id="as_stringified_json_+3A_...">...</code></td>
<td>
<p>additional arguments (except <code>auto_unbox</code> and <code>null</code>) passed to
<code><a href="jsonlite.html#topic+toJSON">toJSON</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_stringified_json(list(number = 9))
"{\"number\":9}"
</code></pre>

<hr>
<h2 id='assert_status_code_is_good'>Check that the status code shows a success, and error otherwise</h2><span id='topic+assert_status_code_is_good'></span>

<h3>Description</h3>

<p>Check that the status code shows a success, and error otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_status_code_is_good(status_code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_status_code_is_good_+3A_status_code">status_code</code></td>
<td>
<p>integer, usually returned by
<code><a href="httr.html#topic+status_code">status_code</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE
</p>

<hr>
<h2 id='classify_event'>Classify an event based on how it is invoked</h2><span id='topic+classify_event'></span>

<h3>Description</h3>

<p>Events need to be handled differently depending on how the Lambda is invoked.
For example, an event via an API Gateway needs to be parsed and handled
differently to that of an event received via direct invocation. This function
attempts to detect the method of invocation and returns a character vector
which can be used to assign an S3 class to the event. The last element of
the vector is always &quot;event&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_event(event_content)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_event_+3A_event_content">event_content</code></td>
<td>
<p>the content of the response received from querying the
text invocation endpoint, as a character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector, the last element of which is always &quot;event&quot;
</p>

<hr>
<h2 id='condition'>Define a condition (like an error) with support for HTTP status codes</h2><span id='topic+condition'></span>

<h3>Description</h3>

<p>For more information on conditions and errors see
<a href="http://adv-r.had.co.nz/Exceptions-Debugging.html">http://adv-r.had.co.nz/Exceptions-Debugging.html</a>. See also
<code><a href="base.html#topic+conditions">conditions</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition(subclass, ..., code = 500L, request_id = NULL, call = sys.call(-1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condition_+3A_subclass">subclass</code></td>
<td>
<p>conditions returned by this function will be of the class
<code>c(subclass, "simpleError", "error", "condition")</code>.</p>
</td></tr>
<tr><td><code id="condition_+3A_...">...</code></td>
<td>
<p>zero or more objects which can be coerced to character (and which
are pasted together with no separator). This forms the error message.</p>
</td></tr>
<tr><td><code id="condition_+3A_code">code</code></td>
<td>
<p>HTTP status code to return (if applicable). Defaults to <code>500</code>,
which is a generic &quot;Internal Server Error&quot;. This is used when errors are to
be returned to an API Gateway.</p>
</td></tr>
<tr><td><code id="condition_+3A_request_id">request_id</code></td>
<td>
<p>character. Used in error handling during event
decomposition, when it's possible that a request ID might be known but the
event hasn't been fully examined yet.</p>
</td></tr>
<tr><td><code id="condition_+3A_call">call</code></td>
<td>
<p>call expression</p>
</td></tr>
</table>

<hr>
<h2 id='config_or_runtime_api'>Convert a config to a runtime API if necessary</h2><span id='topic+config_or_runtime_api'></span>

<h3>Description</h3>

<p>Endpoint functions need to accept either a config (as created by
<code><a href="#topic+lambda_config">lambda_config</a></code>) or a runtime API. This function will accept
either and ensure that the runtime API is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>config_or_runtime_api(config)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="config_or_runtime_api_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>

<hr>
<h2 id='decode_html_body'>Decode the body of event content coming via an API Gateway</h2><span id='topic+decode_html_body'></span>

<h3>Description</h3>

<p>Decode the body of event content coming via an API Gateway
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_html_body(body, config, base64_encoded = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_html_body_+3A_body">body</code></td>
<td>
<p>character body of an event received via an API Gateway
invocation. Usually this isn't the entire content of the event, but the
&quot;body&quot; component of it.</p>
</td></tr>
<tr><td><code id="decode_html_body_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
<tr><td><code id="decode_html_body_+3A_base64_encoded">base64_encoded</code></td>
<td>
<p>logical that indicates if the body is encoded as Base64</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a list or, if the body is Base64 and the configuration demands
that Base64 values are not decoded, a Base64 value as a character
</p>

<hr>
<h2 id='endpoints'>AWS Lambda endpoints</h2><span id='topic+endpoints'></span><span id='topic+get_next_invocation_endpoint'></span><span id='topic+get_initialisation_error_endpoint'></span><span id='topic+get_response_endpoint'></span><span id='topic+get_invocation_error_endpoint'></span>

<h3>Description</h3>

<p>These endpoints are configured based on the &quot;AWS_LAMBDA_RUNTIME_API&quot;
environment variable set by AWS Lambda during initialisation. They generally
won't be available locally. The &quot;AWS_LAMBDA_RUNTIME_API&quot; environment variable
(accessed through <code><a href="#topic+lambda_config">lambda_config</a></code>) is used in the following
functions:
</p>

<ul>
<li> <p><code>get_next_invocation_endpoint</code> returns the endpoint which R must query for
the next input. R must send a <code>GET</code> request to this endpoint and will wait
until either a response is received or the Lambda instance is shut down for
inactivity. When Lambda receives an input from, say, an API Gateway, it will
respond to the pending request with details of the input.
</p>
</li>
<li> <p><code>get_initialisation_error_endpoint</code> returns the endpoint to which an error
should be sent if the error occurs when setting up the runtime. This is
distinct from errors that occur during handling of an event.
</p>
</li>
<li> <p><code>get_response_endpoint</code> returns the endpoint to which an event response
should be sent. It is unique for each event.
</p>
</li>
<li> <p><code>get_invocation_error_endpoint</code> returns the endpoint to which errors that
occur during event handling should be sent. It is unique for each event.
</p>
</li></ul>

<p>The values returned by <code>get_next_invocation_endpoint</code> and
<code>get_initialisation_error_endpoint</code> are unique in each Lambda instance. That
is, the runtime only needs to retrieve their values once. The values returned
by <code>get_response_endpoint</code> and <code>get_invocation_error_endpoint</code> are determined
by the <code>request_id</code> argument that these functions require, and so need to be
recalculated for each event. The request ID is given in the
&quot;lambda-runtime-aws-request-id&quot; header in the event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_next_invocation_endpoint(config, runtime_api)

get_initialisation_error_endpoint(config, runtime_api)

get_response_endpoint(config, request_id)

get_invocation_error_endpoint(config, request_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endpoints_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code><a href="#topic+lambda_config">lambda_config</a></code> function. Alternatively, a runtime API host can
be provided directly. This would be the case if there's not enough
information available to build a full configuration object due to an error.</p>
</td></tr>
<tr><td><code id="endpoints_+3A_request_id">request_id</code></td>
<td>
<p>For <code>get_response_endpoint</code> and
<code>get_invocation_error_endpoint</code>, the ID of the particular event/request.
This is provided in the &quot;lambda-runtime-aws-request-id&quot; header of the
event.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>

<hr>
<h2 id='extract_and_augment_context'>Combine class-specific context with general context for an event</h2><span id='topic+extract_and_augment_context'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+extract_context">extract_context</a></code> function dispatches on the class of an
event to extract context specific to that class. By default, it returns an
empty list. This function takes that class-specific context and combined it
with the context that is applicable for all classes, contained in both
event headers and environment variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_and_augment_context(event, config, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_and_augment_context_+3A_event">event</code></td>
<td>
<p>the response received from querying the next invocation
endpoint.</p>
</td></tr>
<tr><td><code id="extract_and_augment_context_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
<tr><td><code id="extract_and_augment_context_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+extract_context">extract_context</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Event context</h3>

<p>Context is metadata associated with each invocation. If the handler function
accepts a <code>context</code> argument then it will automatically receive at runtime a
named list consisting of these values along with the arguments in the body
(if any). For example, a function such as <code>my_func(x, context)</code> will receive
the context argument automatically. The <code>context</code> argument must be named
(<code>...</code> will not work).
</p>
<p>Refer to <code>vignette("lambda-runtime-in-container", package = "lambdr")</code>
for details.
</p>

<hr>
<h2 id='extract_context'>Extract the context of a Lambda invocation from the headers of an event</h2><span id='topic+extract_context'></span>

<h3>Description</h3>

<p>Extract the context of a Lambda invocation from the headers of an event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_context(event, config, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_context_+3A_event">event</code></td>
<td>
<p>the response received from querying the next invocation
endpoint.</p>
</td></tr>
<tr><td><code id="extract_context_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Event context</h3>

<p>Context is metadata associated with each invocation. If the handler function
accepts a <code>context</code> argument then it will automatically receive at runtime a
named list consisting of these values along with the arguments in the body
(if any). For example, a function such as <code>my_func(x, context)</code> will receive
the context argument automatically. The <code>context</code> argument must be named
(<code>...</code> will not work).
</p>
<p>Refer to <code>vignette("lambda-runtime-in-container", package = "lambdr")</code>
for details.
</p>

<hr>
<h2 id='extract_context_from_environment'>Extract context from environment variables</h2><span id='topic+extract_context_from_environment'></span>

<h3>Description</h3>

<p>This function is intended to provide ambient configuration that makes up part
of the context returned by <code><a href="#topic+extract_context">extract_context</a></code>. These are the
components of the context formed by environment variables. To speed things up
a little we call the environment variables only once on runtime
initialisation and store them in the config.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_context_from_environment()
</code></pre>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='extract_event_headers'>Extract the headers from a Lambda event</h2><span id='topic+extract_event_headers'></span>

<h3>Description</h3>

<p>This function is largely equivalent to <code><a href="httr.html#topic+headers">headers</a></code>, which it
wraps. The only difference is that the names of the headers returned are
converted to lower-case (these are meant to be case-insensitive) and the
headers are logged at the DEBUG level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_event_headers(event)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_event_headers_+3A_event">event</code></td>
<td>
<p>the response received from querying the next invocation
endpoint.</p>
</td></tr>
</table>

<hr>
<h2 id='from_base64'>Decode a Base64 encoded value to a string</h2><span id='topic+from_base64'></span>

<h3>Description</h3>

<p>Events coming via an API Gateway can have content with bodies encoded as
Base64. This is especially true for HTML API Gateways (as opposed to REST
API Gateways).
</p>
<p>This function propagates <code>NULL</code>s. That is, <code>from_base64(NULL)</code> returns
<code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_base64(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_base64_+3A_x">x</code></td>
<td>
<p>a Base64 string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>from_base64("eyJudW1iZXIiOjd9")
</code></pre>

<hr>
<h2 id='function_accepts_context'>Determine if a function accepts a <code>context</code> argument</h2><span id='topic+function_accepts_context'></span>

<h3>Description</h3>

<p>The context of a Lambda is the metadata associated with each request, such as
the ARN. In other languages, a function used in a Lambda must accept the
context as an argument. We allow here for functions that disregard it, since
it's not necessary.
</p>
<p>The purpose of <code>functions_accepts_context</code> then is to determine if the
arguments of the function defined by the handler includes <code>context</code>, in which
case we pass the <code>context</code> as an argument whenever the Lambda is invoked. The
<code>context</code> argument must be named (<code>...</code> won't be recognised). Primitive
functions will always return FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_accepts_context(func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="function_accepts_context_+3A_func">func</code></td>
<td>
<p>Function that may or may not accept a <code>context</code> argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='generate_result'>Parse the content of an event and pass it through the handler function</h2><span id='topic+generate_result'></span>

<h3>Description</h3>

<p>Parse the content of an event and pass it through the handler function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_result(event, config = lambda_config(), deserialiser = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_result_+3A_event">event</code></td>
<td>
<p>the response received from querying the next invocation
endpoint.</p>
</td></tr>
<tr><td><code id="generate_result_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class the same as <code>event</code>. The object contains a
<code>result</code> value, and the <code>result_calculated</code> attribute is set to <code>TRUE</code>.
</p>

<hr>
<h2 id='get_handler_function_from_env_var'>Determine the function referred to by the &quot;_HANDLER&quot; environment variable</h2><span id='topic+get_handler_function_from_env_var'></span>

<h3>Description</h3>

<p>This function will try to identify the function referred to by the &quot;_HANDLER&quot;
environment variable. This environment variable is configured by AWS Lambda,
either through the CMD of the Dockerfile containing the runtime or through
the AWS Lambda console (which takes priority). This function also performs
some checks, making sure that the environment variable is defined and that
it exists in the given environment, and that it's a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_handler_function_from_env_var(environ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_handler_function_from_env_var_+3A_environ">environ</code></td>
<td>
<p>environment in which to search for the function given by the
&quot;_HANDLER&quot; environment variable. Defaults to the parent frame.</p>
</td></tr>
</table>

<hr>
<h2 id='get_lambda_environment_variable'>Retrieve a Lambda environment variable if available, and error otherwise</h2><span id='topic+get_lambda_environment_variable'></span>

<h3>Description</h3>

<p>This function is provided to return a specific error if an environment
variable is not defined. This is used by <code><a href="#topic+lambda_config">lambda_config</a></code> to
ensure that the environment variables that are expected to be defined by AWS
are present.
</p>
<p>If the environment variable is undefined but a <code>default</code> value is provided,
then that default value will be returned. However, the environment variable
will always take precedence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lambda_environment_variable(env_var, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lambda_environment_variable_+3A_env_var">env_var</code></td>
<td>
<p>character environment variable to retrieve</p>
</td></tr>
<tr><td><code id="get_lambda_environment_variable_+3A_default">default</code></td>
<td>
<p>character default value to return if the environment variable
is undefined. The environment variable always takes precedence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>

<hr>
<h2 id='handle_event'>Process the input of an event, and submit the result to Lambda</h2><span id='topic+handle_event'></span>

<h3>Description</h3>

<p>If the handler function accepts a named <code>context</code> argument then the Lambda
invocation context will be included as an argument. See the section below for
more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_event(event, config = lambda_config())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_event_+3A_event">event</code></td>
<td>
<p>the response received from querying the next invocation
endpoint.</p>
</td></tr>
<tr><td><code id="handle_event_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>


<h3>Invocations via an API Gateway</h3>

<p>Events coming from an API Gateway need to be treated a little differently,
both in parsing the event content and in posting the results. Refer to
<code>vignette("api-gateway-invocations", package = "lambdr")</code> for details.
</p>


<h3>Event context</h3>

<p>Context is metadata associated with each invocation. If the handler function
accepts a <code>context</code> argument then it will automatically receive at runtime a
named list consisting of these values along with the arguments in the body
(if any). For example, a function such as <code>my_func(x, context)</code> will receive
the context argument automatically. The <code>context</code> argument must be named
(<code>...</code> will not work).
</p>
<p>Refer to <code>vignette("lambda-runtime-in-container", package = "lambdr")</code>
for details.
</p>

<hr>
<h2 id='handle_event_error'>Generate a handling function for an invocation error</h2><span id='topic+handle_event_error'></span>

<h3>Description</h3>

<p>An error caught during event handling must be handled in a special way. An
error message must be logged and posted to the invocation error endpoint,
and the the runtime must continue &mdash; an invocation error is a problem for
the invocation, not the runtime.
</p>
<p>The <code>handle_event_error</code> function accepts an event and generates a
function. The generated function accepts error caught by
<code><a href="base.html#topic+tryCatch">tryCatch</a></code>, logs it, and then submits it to the invocation
error endpoint. Importantly it does not stop the kernel &mdash; the intention is
that the runtime moves onto the next event.
</p>
<p>This function may need to be implemented differently depending on the source
of an event. As such, <code>handle_event_error</code> is an S3 generic that can dispatch
on the event class as returned by <code><a href="#topic+classify_event">classify_event</a></code>.
</p>
<div class="sourceCode r"><pre>tryCatch(
    handle_event(...),
    error = handle_invocation_error(event) # returns a function(e)
 )
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>handle_event_error(event, config, ...)
</code></pre>


<h3>Value</h3>

<p>A function that accepts an error <code>e</code> as caught by
<code><a href="base.html#topic+tryCatch">tryCatch</a></code>
</p>

<hr>
<h2 id='html_response'>Prepare a HTML response for a Lambda behind an API Gateway</h2><span id='topic+html_response'></span>

<h3>Description</h3>

<p>Lambdas behind API Gateways need to send specially formatted responses that
look like this:
</p>
<div class="sourceCode json"><pre>{
  "statusCode": 200,
  "headers": {
    "Content-Type": "application/json"
  },
  "isBase64Encoded": false,
  "body": "{\"best_animal\": \"corgi\"}"
}
</pre></div>
<p>For basic applications where the handler function is returning a simple
result, <code>lambdr</code> will do its best to automatically return a result compatible
with API Gateways. It will do this whenever an event is detected as having
come via an API Gateway. For most purposes this is sufficient, and allows
users to focus on the handler function rather than the specifics of how
<em>AWS Lambda</em> works.
</p>
<p>For more complicated applications, such as when the Lambda needs to return a
specific content type or specific headers, may require a bespoke response.
This function will take any R object and format it in style of the above
example, allowing for customisation.
</p>
<p>When the handler function returns a <code>html_response</code> the formatted result will
be returned to the API Gateway without further serialisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_response(
  body,
  is_base64 = FALSE,
  status_code = 200L,
  content_type = NULL,
  headers = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_response_+3A_body">body</code></td>
<td>
<p>the actual result to be delivered. This is not serialised in any
way, so if this is a list to be interpreted JSON it should be
stringified, that is, it should be a string of a JSON. Consider using the
<code><a href="#topic+as_stringified_json">as_stringified_json</a></code> function.</p>
</td></tr>
<tr><td><code id="html_response_+3A_is_base64">is_base64</code></td>
<td>
<p>logical which indicates if <code>body</code> is Base64 encoded.
Defaults to False.</p>
</td></tr>
<tr><td><code id="html_response_+3A_status_code">status_code</code></td>
<td>
<p>integer status code of the response. Defaults to <code>200L</code>
(OK).</p>
</td></tr>
<tr><td><code id="html_response_+3A_content_type">content_type</code></td>
<td>
<p>MIME type for the content. This will be appended to the
headers (as &quot;Content-Type&quot;), unless such a value is already provided to
<code>headers</code>, in which case this argument is ignored. If not provided then no
information on headers will be sent in the response, leaving the beahviour
up to the defaults of the API Gateway.</p>
</td></tr>
<tr><td><code id="html_response_+3A_headers">headers</code></td>
<td>
<p>additional headers, as a named list, to be included in the
response. If this contains a &quot;Content-Type&quot; value then <code>content_type</code> is
ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stringified JSON response for an API Gateway, with the
&quot;already_serialised&quot; attribute marked as <code>TRUE</code>. This will stop
<code>serialise_result</code> from attempting to serialise the result again.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>html_response("abc")
html_response("YWJj", is_base64 = TRUE)
html_response("abc", headers = list(x = "a"))
html_response(
  "&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;",
  content_type = "text/html"
)
</code></pre>

<hr>
<h2 id='is_eventbridge_event_content'>Determine if a Lambda event is coming from a EventBridge event (CloudWatch events)</h2><span id='topic+is_eventbridge_event_content'></span>

<h3>Description</h3>

<p>See <a href="https://docs.aws.amazon.com/lambda/latest/dg/services-cloudwatchevents.html">https://docs.aws.amazon.com/lambda/latest/dg/services-cloudwatchevents.html</a>
for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_eventbridge_event_content(event_content)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_eventbridge_event_content_+3A_event_content">event_content</code></td>
<td>
<p>the content of the response received from querying the
text invocation endpoint, as a character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='is_from_html_api_gateway'>Determine if a Lambda event is coming via an API Gateway</h2><span id='topic+is_from_html_api_gateway'></span>

<h3>Description</h3>

<p>Determine if a Lambda event is coming via an API Gateway
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_from_html_api_gateway(event_content)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_from_html_api_gateway_+3A_event_content">event_content</code></td>
<td>
<p>the content of the response received from querying the
text invocation endpoint, as a character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Invocations via an API Gateway</h3>

<p>Events coming from an API Gateway need to be treated a little differently,
both in parsing the event content and in posting the results. Refer to
<code>vignette("api-gateway-invocations", package = "lambdr")</code> for details.
</p>

<hr>
<h2 id='is_from_rest_api_gateway'>Determine if a Lambda event is coming via a REST API Gateway</h2><span id='topic+is_from_rest_api_gateway'></span>

<h3>Description</h3>

<p>Determine if a Lambda event is coming via a REST API Gateway
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_from_rest_api_gateway(event_content)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_from_rest_api_gateway_+3A_event_content">event_content</code></td>
<td>
<p>the content of the response received from querying the
text invocation endpoint, as a character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Invocations via an API Gateway</h3>

<p>Events coming from an API Gateway need to be treated a little differently,
both in parsing the event content and in posting the results. Refer to
<code>vignette("api-gateway-invocations", package = "lambdr")</code> for details.
</p>

<hr>
<h2 id='is_sns_event_content'>Determine if a Lambda event is coming from SNS</h2><span id='topic+is_sns_event_content'></span>

<h3>Description</h3>

<p>See <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-sns.html">https://docs.aws.amazon.com/lambda/latest/dg/with-sns.html</a>
for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_sns_event_content(event_content)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_sns_event_content_+3A_event_content">event_content</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='lambda_config'>Set up endpoints, variables, and configuration for AWS Lambda</h2><span id='topic+lambda_config'></span>

<h3>Description</h3>

<p>This function provides a configuration object that can be passed to
<code><a href="#topic+start_lambda">start_lambda</a></code>. By default it will use the environment variables
configured by AWS Lambda and so will often work without arguments.
</p>
<p>The most important configuration variable is the handler function which
processes invocations of the Lambda. This is configured in any of the three
below ways, in order of decreasing priority:
</p>

<ol>
<li><p> configured directly through the AWS Lambda console
</p>
</li>
<li><p> configured as the <code>CMD</code> argument of the Docker container holding the
runtime
</p>
</li>
<li><p> passed as a value to the <code>handler</code> argument of <code>lambda_config</code>
</p>
</li></ol>

<p>In the first two options, the handler will be made available to the runtime
through the &quot;_HANDLER&quot; environment variable. This function will search for
the function in the given <code>environ</code>ment.
</p>
<p>If the handler accepts a <code>context</code> argument then it will receive a list of
suitable event context for every invocation. This argument must be named
(<code>...</code> will not work), and the configuration may be different for each
invocation type. See the section below for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_config(
  handler = NULL,
  runtime_api = NULL,
  task_root = NULL,
  deserialiser = NULL,
  serialiser = NULL,
  decode_base64 = TRUE,
  environ = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_config_+3A_handler">handler</code></td>
<td>
<p>the function to use for processing inputs from
events. The &quot;_HANDLER&quot; environment variable, as configured in AWS, will
always override this value if present.</p>
</td></tr>
<tr><td><code id="lambda_config_+3A_runtime_api">runtime_api</code></td>
<td>
<p>character. Used as the host in the various endpoints used
by AWS Lambda. This argument is provided for debugging and testing only.
The &quot;AWS_LAMBDA_RUNTIME_API&quot; environment variable, as configured by AWS,
will always override this value if present.</p>
</td></tr>
<tr><td><code id="lambda_config_+3A_task_root">task_root</code></td>
<td>
<p>character. Defines the path to the Lambda function code.
This argument is provided for debugging and testing only. The
&quot;LAMBDA_TASK_ROOT&quot; environment variable, as configured by AWS, will always
override this value if present.</p>
</td></tr>
<tr><td><code id="lambda_config_+3A_deserialiser">deserialiser</code></td>
<td>
<p>function for deserialising the body of the event. By
default, will attempt to deserialise the body as JSON, based on whether the
input is coming from an API Gateway, scheduled Cloudwatch event, or direct.
To use the body as is, pass the <code>identity</code> function. To ignore the event
content, pass <code>function(x) list()</code>. See the vignettes for details on
parsing invocations from particular sources.</p>
</td></tr>
<tr><td><code id="lambda_config_+3A_serialiser">serialiser</code></td>
<td>
<p>function for serialising the result before sending.
By default, will attempt to serialise the body as JSON, based on the
request type. To send the result as is, pass the <code>identity</code> function.</p>
</td></tr>
<tr><td><code id="lambda_config_+3A_decode_base64">decode_base64</code></td>
<td>
<p>logical. Should Base64 input be automatically decoded?
This is only used for events coming via an API Gateway. Complicated input
(such as images) may be better left as is, so that the handler function can
deal with it appropriately. Defaults to <code>TRUE</code>. Ignored if a custom
<code>deserialiser</code> is used.</p>
</td></tr>
<tr><td><code id="lambda_config_+3A_environ">environ</code></td>
<td>
<p>environment in which to search for the function given by the
&quot;_HANDLER&quot; environment variable. Defaults to the parent frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a rule of thumb, it takes longer to retrieve a value from an environment
variable than it does to retrieve a value from R. This is because retrieving
an environment variable requires a system call. Since the environment
variables do not change in a Lambda instance, we fetch them once and store
them in a configuration object which is passed to the various internal
functions.
</p>


<h3>AWS Lambda variables</h3>

<p>The <code><a href="#topic+lambda_config">lambda_config</a></code> function obtains the configuration values
for the Lambda runtime configures the R session for Lambda based on
environment variables made available by Lambda. The following environment
variables are available:
</p>

<ul>
<li><p> Lambda Runtime API, available as the &quot;AWS_LAMBDA_RUNTIME_API&quot; environment
variable, is the host of the various HTTP endpoints through which the
runtime interacts with Lambda.
</p>
</li>
<li><p> Lambda Task Root, available as the &quot;LAMBDA_TASK_ROOT&quot; environment variable,
defines the path to the Lambda function code. It isn't used in container
environments with a custom runtime, as that runtime is responsible for
finding and sourcing the function code. Hence, a missing task root is
ignored by this package.
</p>
</li>
<li><p> The handler, available as the &quot;_HANDLER&quot; environment variable, is
interpreted by R as the function that is executed when the Lambda is
called. This value could be anything, as the interpretation is solely up
to the runtime, so requiring it to be a function is a standard imposed by
this package.
</p>
</li></ul>

<p>These <code>handler</code>, <code>runtime_api</code> and <code>task_root</code> arguments to the
<code><a href="#topic+lambda_config">lambda_config</a></code> function can also provide values to these
configuration options, although the environment variables will always be
used if available. While it may be sensible to provide the <code>handler</code>
function directly, the other two configuration options are only provided for
debugging and testing purposes.
</p>


<h3>Event context</h3>

<p>Context is metadata associated with each invocation. If the handler function
accepts a <code>context</code> argument then it will automatically receive at runtime a
named list consisting of these values along with the arguments in the body
(if any). For example, a function such as <code>my_func(x, context)</code> will receive
the context argument automatically. The <code>context</code> argument must be named
(<code>...</code> will not work).
</p>
<p>Refer to <code>vignette("lambda-runtime-in-container", package = "lambdr")</code>
for details.
</p>

<hr>
<h2 id='lambdr-package'>lambdr: Create a Runtime for Serving Containerised R Functions on AWS Lambda</h2><span id='topic+lambdr'></span><span id='topic+lambdr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/lambdr.png" alt='logo' width='150' />
</p>
<p>This package provides an R runtime for the
<a href="https://aws.amazon.com/lambda/"><em>AWS Lambda</em> serverless compute
service</a>. It is intended to be used to create containers that can run on <em>AWS
Lambda</em>. <code>lambdr</code> provides the necessary functionality for handling the
various endpoints required for accepting new input and sending responses.
</p>
<p>This package is <strong>unofficial</strong>. Its creators are not affiliated with <em>Amazon
Web Services</em>, nor is its content endorsed by <em>Amazon Web Services</em>.
<em>Lambda</em>, <em>API Gateway</em>, <em>EventBridge</em>, <em>CloudWatch</em>, and <em>SNS</em> are services
of <em>Amazon Web Services</em>.
</p>
<p>To see an example of how to use this package to create a runtime, refer to
<code>vignette("lambda-runtime-in-container", package = "lambdr")</code>.
</p>
<p>The default behaviour is to convert the body of the received event from JSON
into arguments for the handler function using the <code>jsonlite</code> package. For
example, a raw event body of <code>{"number": 9}</code> will be converted to
<code>list(number = 9)</code>. The handler function will then receive the arguments
directly after unlisting, eg. <code>number = 9</code>. This works for direct
invocations, as well as situations where the user wishes to implement
behaviour specific to a trigger.
</p>
<p>Some invocation types have their own logic for converting the event body into
an R object. This is useful for say, using an R function in a Lambda behind
an API Gateway, so that the R function does not need to deal with the HTML
elements of the invocation. The below invocation types have custom logic
implemented. Refer to the vignettes or the package website for more
information.
</p>
<p>Alternatively, user-defined functions can be provided for parsing event
content and serialising results. The user can also use the <code>identity</code>
function as a deserialiser to pass the raw event content &mdash; as a string &mdash;
to the handler function. Refer to <code><a href="#topic+lambda_config">lambda_config</a></code> for more
information.
</p>


<h3>Direct invocations</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>REST API Gateway invocations</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
<code>vignette("api-gateway-invocations", package = "lambdr")</code>
</p>


<h3>HTML API Gateway invocations</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
<code>vignette("api-gateway-invocations", package = "lambdr")</code>
</p>


<h3>EventBridge invocations</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
<code>vignette("eventbridge-and-sns-invocations", package = "lambdr")</code>
</p>


<h3>SNS invocations</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
<code>vignette("eventbridge-and-sns-invocations", package = "lambdr")</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Neuzerling <a href="mailto:david@neuzerling.com">david@neuzerling.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> James Goldie <a href="mailto:me@jamesgoldie.dev">me@jamesgoldie.dev</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://lambdr.mdneuzerling.com/">https://lambdr.mdneuzerling.com/</a>
</p>
</li>
<li> <p><a href="https://github.com/mdneuzerling/lambdr">https://github.com/mdneuzerling/lambdr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mdneuzerling/lambdr/issues">https://github.com/mdneuzerling/lambdr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='mark_as_already_serialised'>Give a value the &quot;already_serialised = TRUE&quot; attribute</h2><span id='topic+mark_as_already_serialised'></span>

<h3>Description</h3>

<p>Give a value the &quot;already_serialised = TRUE&quot; attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_as_already_serialised(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_as_already_serialised_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with &quot;already_serialised&quot; attribute TRUE
</p>

<hr>
<h2 id='parse_event_content'>Parse the body of the Lambda event</h2><span id='topic+parse_event_content'></span>

<h3>Description</h3>

<p>Parse the body of the Lambda event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_event_content(event, config)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_event_content_+3A_event">event</code></td>
<td>
<p>the response received from querying the next invocation
endpoint.</p>
</td></tr>
<tr><td><code id="parse_event_content_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the arguments to be passed to the handler function
</p>


<h3>Invocations via an API Gateway</h3>

<p>Events coming from an API Gateway need to be treated a little differently,
both in parsing the event content and in posting the results. Refer to
<code>vignette("api-gateway-invocations", package = "lambdr")</code> for details.
</p>

<hr>
<h2 id='parse_json_or_empty'>Parse a JSON, but force a NULL or empty string to be interpreted as an empty list</h2><span id='topic+parse_json_or_empty'></span>

<h3>Description</h3>

<p>Since <code>jsonlite::fromJSON(NULL)</code> and <code>jsonlite::fromJSON("")</code> return errors,
this function will force a NULL or empty string to be interpreted as
<code>list()</code>. Otherwise, the output of this function is identical to
<code><a href="jsonlite.html#topic+fromJSON">fromJSON</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_json_or_empty(json, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_json_or_empty_+3A_json">json</code></td>
<td>
<p>character to be interpreted as a JSON</p>
</td></tr>
<tr><td><code id="parse_json_or_empty_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="jsonlite.html#topic+fromJSON">fromJSON</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='post_lambda_error'>Post an error to an endpoint with the format expected by AWS Lambda</h2><span id='topic+post_lambda_error'></span>

<h3>Description</h3>

<p>According to the
<a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-dg.pdf">AWS Lambda
Developer Guide</a> an error posted to the initialisation or invocation error
endpoints must be of content type <code>application/vnd.aws.lambda.error+json</code>
and of the format:
</p>
<div class="sourceCode json"><pre>{
  "errorMessage": "...",
  "errorType": "...",
  "stackTrace": [],
}
</pre></div>
<p>Here the <code>errorMessage</code> and <code>errorType</code> are strings, with the <code>stackTrace</code>
a list of strings.
</p>
<p>This function accepts an error as caught by  <code><a href="base.html#topic+tryCatch">tryCatch</a></code> and
posts it to the given endpoint, ensuring that the correct formatting is
adhered to. This function does not stop the runtime as in the case of
invocation errors it's desirable to continue.
</p>
<p>The stacktrace is not currently reported. This functionality is yet to be
implemented. See the
<a href="https://github.com/mdneuzerling/lambdr/issues/5">GitHub issue</a> for more
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_lambda_error(e, endpoint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_lambda_error_+3A_e">e</code></td>
<td>
<p>an error as caught by <code><a href="base.html#topic+tryCatch">tryCatch</a></code></p>
</td></tr>
<tr><td><code id="post_lambda_error_+3A_endpoint">endpoint</code></td>
<td>
<p>where to <code><a href="httr.html#topic+POST">POST</a></code> the error</p>
</td></tr>
</table>

<hr>
<h2 id='post_result'>Post an event with a result to the response endpoint</h2><span id='topic+post_result'></span>

<h3>Description</h3>

<p>This function will first serialise the event result according to its class
by dispatching through <code><a href="#topic+serialise_result">serialise_result</a></code>.The result of that
serialisation is posted <strong>as is</strong> to the response endpoint; this function
will not perform any JSON serialisation, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_result(event, config)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_result_+3A_event">event</code></td>
<td>
<p>the response received from querying the next invocation
endpoint.</p>
</td></tr>
<tr><td><code id="post_result_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>


<h3>Invocations via an API Gateway</h3>

<p>Events coming from an API Gateway need to be treated a little differently,
both in parsing the event content and in posting the results. Refer to
<code>vignette("api-gateway-invocations", package = "lambdr")</code> for details.
</p>

<hr>
<h2 id='prettify_list'>Convert a list to a single character, preserving names</h2><span id='topic+prettify_list'></span>

<h3>Description</h3>

<p>Convert a list to a single character, preserving names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettify_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prettify_list_+3A_x">x</code></td>
<td>
<p>Named list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prettify_list(list(a = 1, b = 2, c = 3))
# "a=1, b=2, c=3"

</code></pre>

<hr>
<h2 id='serialise_result'>Serialise a result</h2><span id='topic+serialise_result'></span>

<h3>Description</h3>

<p>This result is posted <strong>as is</strong>, and so all JSON serialisation, etc. must be
performed here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialise_result(event, config)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serialise_result_+3A_event">event</code></td>
<td>
<p>the response received from querying the next invocation
endpoint.</p>
</td></tr>
<tr><td><code id="serialise_result_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character.
</p>


<h3>Invocations via an API Gateway</h3>

<p>Events coming from an API Gateway need to be treated a little differently,
both in parsing the event content and in posting the results. Refer to
<code>vignette("api-gateway-invocations", package = "lambdr")</code> for details.
</p>

<hr>
<h2 id='start_lambda'>Start the Lambda runtime</h2><span id='topic+start_lambda'></span>

<h3>Description</h3>

<p>This is the main function of the package, responsible for starting the
infinite loop of listening for new invocations. It relies on configuration
provided to the <code>config</code> argument and produced by the
<code><a href="#topic+lambda_config">lambda_config</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_lambda(
  config = lambda_config(environ = parent.frame()),
  timeout_seconds = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_lambda_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
<tr><td><code id="start_lambda_+3A_timeout_seconds">timeout_seconds</code></td>
<td>
<p>If set, the function will stop listening for events
after this timeout. The timeout is checked between events, so this won't
interrupt the function while it is waiting for a new event. This argument
is provided for testing purposes, and shouldn't otherwise need to be set:
AWS should handle the shutdown of idle Lambda instances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("lambda-runtime-in-container", package = "lambdr")</code> for an
example of how to use this function to place an R Lambda Runtime in a
container.
</p>
<p>This package uses the <code><a href="logger.html#topic+logger">logger</a></code> package for logging.
Debug log entries can be enabled with <code>logger::log_threshold(logger::DEBUG)</code>.
This will log additional information such as raw event bodies.
</p>


<h3>Event context</h3>

<p>Context is metadata associated with each invocation. If the handler function
accepts a <code>context</code> argument then it will automatically receive at runtime a
named list consisting of these values along with the arguments in the body
(if any). For example, a function such as <code>my_func(x, context)</code> will receive
the context argument automatically. The <code>context</code> argument must be named
(<code>...</code> will not work).
</p>
<p>Refer to <code>vignette("lambda-runtime-in-container", package = "lambdr")</code>
for details.
</p>


<h3>AWS Lambda variables</h3>

<p>The <code><a href="#topic+lambda_config">lambda_config</a></code> function obtains the configuration values
for the Lambda runtime configures the R session for Lambda based on
environment variables made available by Lambda. The following environment
variables are available:
</p>

<ul>
<li><p> Lambda Runtime API, available as the &quot;AWS_LAMBDA_RUNTIME_API&quot; environment
variable, is the host of the various HTTP endpoints through which the
runtime interacts with Lambda.
</p>
</li>
<li><p> Lambda Task Root, available as the &quot;LAMBDA_TASK_ROOT&quot; environment variable,
defines the path to the Lambda function code. It isn't used in container
environments with a custom runtime, as that runtime is responsible for
finding and sourcing the function code. Hence, a missing task root is
ignored by this package.
</p>
</li>
<li><p> The handler, available as the &quot;_HANDLER&quot; environment variable, is
interpreted by R as the function that is executed when the Lambda is
called. This value could be anything, as the interpretation is solely up
to the runtime, so requiring it to be a function is a standard imposed by
this package.
</p>
</li></ul>

<p>These <code>handler</code>, <code>runtime_api</code> and <code>task_root</code> arguments to the
<code><a href="#topic+lambda_config">lambda_config</a></code> function can also provide values to these
configuration options, although the environment variables will always be
used if available. While it may be sensible to provide the <code>handler</code>
function directly, the other two configuration options are only provided for
debugging and testing purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A general usage pattern involves sourcing necessary functions and running
# this `start_lambda` in a `runtime.R` file which is then executed to start
# the runtime. In the following example, the function handler can be set to
# "lambda" either as the container `CMD`, or configured through AWS Lambda.

parity &lt;- function(number) {
  list(parity = if (as.integer(number) %% 2 == 0) "even" else "odd")
}

start_lambda()

# Alternatively, it can be passed as an argument `handler = parity` to
# the lambda configuration. If the handler is configured through other means
# then this will be ignored:

start_lambda(config = lambda_config(handler = parity))

## End(Not run)
</code></pre>

<hr>
<h2 id='start_listening'>Start listening for events, and process them as they come</h2><span id='topic+start_listening'></span>

<h3>Description</h3>

<p>Start listening for events, and process them as they come
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_listening(config = lambda_config(), timeout_seconds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_listening_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
<tr><td><code id="start_listening_+3A_timeout_seconds">timeout_seconds</code></td>
<td>
<p>If set, the function will stop listening for events
after this timeout. The timeout is checked between events, so this won't
interrupt the function while it is waiting for a new event. This argument
is provided for testing purposes, and shouldn't otherwise need to be set:
AWS should handle the shutdown of idle Lambda instances.</p>
</td></tr>
</table>

<hr>
<h2 id='stop_decomposition'>Raise an error with a request ID if known</h2><span id='topic+stop_decomposition'></span><span id='topic+handle_decomposition_error'></span>

<h3>Description</h3>

<p>During decomposition from an invocation into an event, it is possible for an
error to occur when a request ID is known but the event hasn't been fully
realised yet. In order to handle these, an error must be posted to the
invocation error endpoint.
</p>
<p><code>stop_decomposition</code> raises an error with an optional <code>request_id</code>. The error
can then be processed by <code>handle_decomposition_error</code>. If a <code>request_id</code> is
present then the error can be posted to the invocation error endpoint.
Otherwise, the error is simply logged. In either case the error does not
stop the kernel, and the runtime can move onto the next event.
</p>
<p><code>handle_decomposition_error</code> accepts a <code>config</code> object, created through the
<code><a href="#topic+lambda_config">lambda_config</a></code> function. It returns a function that accepts an
error <code>e</code>, which means that <code>handle_decomposition_error(event)</code> can be passed
as a value to the <code>tryCatch</code> <code>error</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_decomposition(..., request_id = NULL)

handle_decomposition_error(config)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_decomposition_+3A_...">...</code></td>
<td>
<p>zero or more objects which can be coerced to character (and which
are pasted together with no separator). This forms the error message.</p>
</td></tr>
<tr><td><code id="stop_decomposition_+3A_request_id">request_id</code></td>
<td>
<p>character. Used in error handling during event
decomposition, when it's possible that a request ID might be known but the
event hasn't been fully examined yet.</p>
</td></tr>
</table>

<hr>
<h2 id='stop_html'>Raise an error with an optional HTML status code for API Gateways</h2><span id='topic+stop_html'></span>

<h3>Description</h3>

<p>This variation of <code>stop</code> can be used to raise an error with a specific error
code. This is provided to the API Gateway to return an appropriate response.
It had no use outside of invocations via an API Gateway.
</p>
<p>If a status code is not provided, a generic &quot;500&quot; internal server error will
be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_html(..., code = 500L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_html_+3A_...">...</code></td>
<td>
<p>zero or more objects which can be coerced to character (and which
are pasted together with no separator). This forms the error message.</p>
</td></tr>
<tr><td><code id="stop_html_+3A_code">code</code></td>
<td>
<p>HTTP status code to return (if applicable). Defaults to <code>500</code>,
which is a generic &quot;Internal Server Error&quot;. This is used when errors are to
be returned to an API Gateway.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stop_html("Resource doesn't exist", code = 404L)

## End(Not run)
</code></pre>

<hr>
<h2 id='validate_lambda_config'>Validate a Lambda config object</h2><span id='topic+validate_lambda_config'></span>

<h3>Description</h3>

<p>This function only verifies that an object has a &quot;lambda_config&quot; S3 class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_lambda_config(config)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_lambda_config_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE
</p>

<hr>
<h2 id='wait_for_and_handle_event'>Wait for and handle event</h2><span id='topic+wait_for_and_handle_event'></span>

<h3>Description</h3>

<p>Combines <code><a href="#topic+wait_for_event">wait_for_event</a></code> and <code><a href="#topic+handle_event">handle_event</a></code> along
with
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wait_for_and_handle_event(config)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wait_for_and_handle_event_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='wait_for_event'>Query the next invocation endpoint to get the next input</h2><span id='topic+wait_for_event'></span>

<h3>Description</h3>

<p>The query will receive a response when an input is queued up. If there is no
input waiting, the Lambda instance will be shut down after a period of
inactivity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wait_for_event(config = lambda_config())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wait_for_event_+3A_config">config</code></td>
<td>
<p>A list of configuration values as created by the
<code>lambda_config</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Request ID is unique for each input of a Lambda. It is carried by the
&quot;lambda-runtime-aws-request-id&quot; header of the response from the next
invocation endpoint (see <code><a href="#topic+endpoints">endpoints</a></code>).
</p>
<p>If an error occurs when extracting the Request ID it is impossible to post it
to the invocation error endpoint as that is determined by the Request ID. We
log the error and move on.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
